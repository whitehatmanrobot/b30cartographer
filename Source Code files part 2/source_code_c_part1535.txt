_ComponentTypes;

	STDMETHOD(get__NewEnum)(/*[out, retval]*/ IEnumVARIANT** pVal);
	STDMETHOD(EnumComponentTypes)(/*[out, retval]*/ IEnumComponentTypes** pVal);
	STDMETHOD(get_Count)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_Item)(/*[in]*/ VARIANT varIndex, /*[out, retval]*/ IComponentType** ppComponentType);
    STDMETHOD(put_Item)(/*[in]*/ VARIANT varIndex, /*[in]*/ IComponentType* ppComponentType);
    STDMETHOD(Add)(/*[in]*/ IComponentType *pComponentType, /*[out, retval]*/ VARIANT *pNewIndex);
    STDMETHOD(Remove)(VARIANT varIndex);
    STDMETHOD(Clone)(IComponentTypes **ppNewList);

};

typedef CComQIPtr<IComponentTypes> PQComponentTypes;

class CopyComponentTypeToVARIANT {
public:
    static HRESULT copy(VARIANT *pv, IComponentType*const*const p) {
        VariantClear(pv);
        pv->vt = VT_DISPATCH;
        pv->pdispVal = *p;
        pv->pdispVal->AddRef();
        return NOERROR;
    }
    static void init(VARIANT *v) { VariantInit(v); }
    static void destroy(VARIANT *v) { VariantClear(v); }
};

typedef CComObject<CComEnumOnSTL<IEnumVARIANT, &__uuidof(IEnumVARIANT), 
                                 VARIANT, 
                                 CopyComponentTypeToVARIANT, 
                                 ComponentTypeList, 
								 CComMultiThreadModel> > ComponentTypeScriptEnumerator_t;

typedef CComObject<CComEnumOnSTL<IEnumComponentTypes, &__uuidof(IEnumComponentTypes), 
                                 IComponentType *, 
                                 _CopyInterface<IComponentType>, 
                                 ComponentTypeList, 
								 CComMultiThreadModel> > ComponentTypeBaseEnumerator_t;



#endif //__COMPONENTTYPES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\composition.h ===
//==========================================================================;
//
// Composition.h : Declaration of the CComposition class
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#ifndef __COMPOSITION_H_
#define __COMPOSITION_H_

#include <winerror.h>
#include <algorithm>
#include <objectwithsiteimplsec.h>
#include <compimpl.h>
#include <seg.h>
#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CComposition
class ATL_NO_VTABLE __declspec(uuid("2764BCE5-CC39-11D2-B639-00C04F79498E")) CComposition : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CComposition, &__uuidof(CComposition)>,
    public IObjectWithSiteImplSec<CComposition>,
	public IMSVidCompositionSegmentImpl<CComposition>
{
public:
    CComposition() {}
    virtual ~CComposition() {}

REGISTER_NONAUTOMATION_OBJECT_WITH_TM(IDS_PROJNAME, 
						   IDS_REG_COMPOSITION_DESC,
						   LIBID_MSVidCtlLib,
						   __uuidof(CComposition), tvBoth);

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CComposition)
        COM_INTERFACE_ENTRY(IMSVidCompositionSegment)
    	COM_INTERFACE_ENTRY(IMSVidGraphSegment)
        COM_INTERFACE_ENTRY(IPersist)
        COM_INTERFACE_ENTRY(IObjectWithSite)
    END_COM_MAP_WITH_FTM()

// IMSVidComposition
public:
// IMSVidGraphSegment
// IMSVidCompositionSegment
    STDMETHOD(Compose)(IMSVidGraphSegment * upstream, IMSVidGraphSegment * downstream)
	{
        if (m_fComposed) {
	 	    return NOERROR;
        }
        ASSERT(m_pGraph);
        try {
            VWGraphSegment up(upstream);
            ASSERT(up.Graph() == m_pGraph);
            VWGraphSegment down(downstream);
            ASSERT(down.Graph() == m_pGraph);
			if (upstream == downstream) {
		 	    return Error(IDS_CANT_COMPOSE_WITH_SELF, __uuidof(IMSVidCompositionSegment), E_INVALIDARG);
			}
            if (up.begin() == up.end()) {
                TRACELM(TRACE_ERROR, "CComposition::Compose() can't compose empty up segment");
		 	    return NOERROR;
            }
            if (down.begin() == down.end()) {
                TRACELM(TRACE_ERROR, "CComposition::Compose() can't compose empty down segment");
                // this is not an error, for example, CA is an empty segment.
		 	    return NOERROR;
            }
			for (VWGraphSegment::iterator iStart = up.begin(); iStart != up.end(); ++iStart) {
				ASSERT((*iStart).GetGraph() == m_pGraph);
				for (VWGraphSegment::iterator iStop = down.begin(); iStop != down.end(); ++ iStop) {
					ASSERT((*iStop).GetGraph() == m_pGraph);
					DSFilter pStart(*iStart);
					DSFilter pStop(*iStop);
					HRESULT hr = m_pGraph.Connect(pStart, pStop, m_Filters);
					if (SUCCEEDED(hr)) {
						m_Segments.push_back(up);
						m_Segments.push_back(down);
						m_pDown = m_Segments.end();
						--m_pDown;
						m_pUp = m_pDown;
						--m_pUp;
						m_fComposed = true;
						return NOERROR;
					}
				}
			}
            TRACELM(TRACE_ERROR, "CComposition::Compose() compose didn't connect anything");
            //	 	    return Error(IDS_CANT_COMPOSE, __uuidof(IMSVidCompositionSegment), E_FAIL);
            // bda tuner input doesn't compose with anything in CC.  rather, line 21 decoder is 
            // picked up when bda tuner is connected with video renderer.
            // But we do need to know that some cases fail such as dvd to vmr
            // so in those cases we return s_false
            return S_FALSE;
        } catch (ComException &e) {
            return e;
        } catch (...) {
            return E_UNEXPECTED;
        }
	}
};

#endif //__COMPOSITION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\createregbag.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// CreateRegBag.cpp : Implementation of CCreateRegBag
// Copyright (c) Microsoft Corporation 1999.
//
// some code copied from DShow device moniker devmon.cpp
//

#include "stdafx.h"
#include "Regbag.h"
#include "CreateRegBag.h"

DEFINE_EXTERN_OBJECT_ENTRY(CLSID_CreatePropBagOnRegKey, CCreateRegBag)

// REV2: support for more data types 
// REG_MULTI_SZ could be supported via VT_BSTR | VT_ARRAY
// REG_BINARY blobs could be vt_unknown that's an istream
// subkeys could be vt_unknown that's an IPropertyBag2 if default val isn't clsid
// 

/////////////////////////////////////////////////////////////////////////////
// CCreateRegBag

HRESULT CRegBagBase::DeleteSubKey(CRegKey& hk, LPCOLESTR pszPropName) {
    // the registry will allow a peer subkey and value to have the same name
    // this doesn't match property bag semantics. so we force this to never occur.
    // after we write a primitive value then we check for a subkey of the
    // same name and recursively delete it if it exists.  from the property bag
    // perspective this amounts to changing the type of the property by writing
    // a new type to the same name.
    // however, if pszpropname is empty(the default value) the current key will
    // get deleted which we don't want

    ASSERT(hk.m_hKey != NULL && pszPropName);

    if (!wcslen(pszPropName)) {
        return NOERROR;
    }

    USES_CONVERSION;
    DWORD hr = hk.RecurseDeleteKey(OLE2CT(pszPropName));
    switch (hr) {
    case ERROR_BADKEY:
    case ERROR_CANTOPEN:
    case ERROR_KEY_DELETED:
    case ERROR_FILE_NOT_FOUND:
        return S_FALSE;
    default:
        return HRESULT_FROM_WIN32(hr);
    }
}


HRESULT CRegBagBase::DeleteValue(CRegKey& hk, LPCOLESTR pszPropName) {
    ASSERT(hk.m_hKey && pszPropName);
    // this is the inverse of delete duplicate key name

    USES_CONVERSION;
    DWORD hr = hk.DeleteValue(OLE2CT(pszPropName));
    switch (hr) {
    case ERROR_FILE_NOT_FOUND:
#if 0
    ??? what else does reg return for missing value
    case ??? missing value
#endif
        return S_FALSE;
    default:
        return HRESULT_FROM_WIN32(hr);
    }
}


HRESULT CRegBagBase::RegConvertToVARIANT(VARIANT *pVar, DWORD dwType, LPBYTE pbData, DWORD cbSize) {
    ASSERT(pVar && pbData);
    USES_CONVERSION;
    switch (dwType) {
    case REG_DWORD:
        if (pVar->vt != VT_UI4) {
            HRESULT hr = VariantChangeType(pVar, pVar, 0, VT_UI4);
            if (FAILED(hr)) {
                return E_INVALIDARG;
            }
        }
        ASSERT(pVar->vt == VT_UI4);
        ASSERT(pbData);
        pVar->ulVal = *(reinterpret_cast<ULONG *>(pbData));
        break;
    case REG_QWORD:
        if (pVar->vt != VT_UI8) {
            HRESULT hr = VariantChangeType(pVar, pVar, 0, VT_UI8);
            if (FAILED(hr)) {
                return E_INVALIDARG;
            }
        }
        ASSERT(pVar->vt == VT_UI8);
        ASSERT(pbData);
        pVar->ullVal = *(reinterpret_cast<ULONGLONG *>(pbData));
        break;
    case REG_SZ:
        switch(pVar->vt) {
        case VT_EMPTY:
        case VT_NULL:
            pVar->vt = VT_BSTR;
            pVar->bstrVal = NULL;
            break;
        case VT_BSTR:
            break;
        default:
            HRESULT hr = VariantChangeType(pVar, pVar, 0, VT_BSTR);
            if (FAILED(hr)) {
                return E_INVALIDARG;
            }
        }
        ASSERT(pVar->vt == VT_BSTR);
        if (pVar->bstrVal) {
            ::SysFreeString(pVar->bstrVal);
        }
        if (cbSize) {
            ASSERT(pbData);
            pVar->bstrVal = ::SysAllocString(T2OLE(LPTSTR(pbData)));
        } else {
            pVar->bstrVal = NULL;  // empty string
        }
        break;
	case REG_MULTI_SZ:
		switch(pVar->vt) {
		case VT_EMPTY:
		case VT_NULL:
			pVar->vt = VT_BSTR_BLOB;
			break;
		case VT_VECTOR | VT_BSTR:
		case VT_BSTR:
			if (pVar->bstrVal) {
				::SysFreeString(pVar->bstrVal);
			}
			pVar->vt = VT_BSTR_BLOB;
			break;
		default:
            pVar->vt = VT_BSTR_BLOB;
		}
        if (cbSize) {
		    pVar->bstrVal = ::SysAllocStringByteLen(NULL, cbSize);
		    if (!pVar->bstrVal) {
			    return E_OUTOFMEMORY;
		    }
            if (pbData) {
		        memcpy(pVar->bstrVal, pbData, cbSize);
            }
        } 
		break;

    default: // binary
		switch (pVar->vt) {
        case VT_BSTR_BLOB:
		case VT_BSTR:
			if (pVar->bstrVal) {
				::SysFreeString(pVar->bstrVal);
			}
			pVar->bstrVal = ::SysAllocStringByteLen(NULL, cbSize);
			if (!pVar->bstrVal) {
				return E_OUTOFMEMORY;
			}
            if (pbData) {
    			memcpy(pVar->bstrVal, pbData, cbSize);
            }
            break;
		default:
			if (pVar->vt != (VT_UI1 | VT_ARRAY)) {
				HRESULT hr = VariantChangeType(pVar, pVar, 0, VT_UI1 | VT_ARRAY);
				if (FAILED(hr)) {
					return E_INVALIDARG;
				}
			}
			ASSERT(pVar->vt == (VT_UI1 | VT_ARRAY));
			SAFEARRAY * psa = NULL;
            if (cbSize) {
                ASSERT(pbData);
			    SAFEARRAYBOUND rgsabound[1];
			    rgsabound[0].lLbound = 0;
			    rgsabound[0].cElements = cbSize;
			    psa = SafeArrayCreate(VT_UI1, 1, rgsabound);
			    if(!psa) {
				    return E_OUTOFMEMORY;
			    }
			    BYTE *pbArray;
			    HRESULT hr = SafeArrayAccessData(psa, reinterpret_cast<LPVOID *>(&pbArray));
			    if (hr != S_OK) {
				    return E_FAIL;
			    }
			    memcpy(pbArray, pbData, cbSize);
			    hr = SafeArrayUnaccessData(psa);
			    if (hr != S_OK) {
				    return E_FAIL;
			    }
            }
			pVar->parray = psa;
		}
    }
    return NOERROR;
}

HRESULT CRegBagBase::SaveObject(CRegKey& hk, LPCOLESTR pszPropName, VARIANT* pV) {
    ASSERT(hk.m_hKey && pszPropName && pV);
    if (pV->vt != VT_UNKNOWN) {
        return E_UNEXPECTED;
    }
    HRESULT hr = NOERROR;
    USES_CONVERSION;
    if (!pV->punkVal) {
        hk.DeleteValue(OLE2CT(pszPropName));
        hk.RecurseDeleteKey(OLE2CT(pszPropName));
    } else {
        PQPersistPropertyBag2 p2(pV->punkVal);
        if (p2) {
                CRegKey sk;
                DWORD rc = sk.Create(m_hk, OLE2CT(pszPropName), NULL, 0, KEY_READ | KEY_WRITE, NULL, NULL);
                if (rc != ERROR_SUCCESS) {
                    return HRESULT_FROM_WIN32(rc);
                }
                CLSID cl;
                hr = p2->GetClassID(&cl);
                if (FAILED(hr)) {
                    return E_UNEXPECTED;
                }
                OLECHAR szClsid[64];
                rc = StringFromGUID2(cl, szClsid, sizeof(szClsid)/sizeof(OLECHAR));
                if (!rc) {
                    return E_UNEXPECTED;
                }
                rc = RegSetValue(sk, NULL, REG_SZ, OLE2T(szClsid), _tcslen(OLE2T(szClsid)) * sizeof(TCHAR));
                if (rc != ERROR_SUCCESS) {
                    return HRESULT_FROM_WIN32(rc);
                }
                try {
                    PQPropertyBag2 pBag2(new CRegBag(sk, NULL, 0, KEY_READ | KEY_WRITE));
                    if (pBag2) {
                        hr = p2->Save(pBag2, false, true);
                    } else {
                        hr = E_OUTOFMEMORY;
                    }
                } CATCHCOM();
        } else {
            PQPersistPropertyBag p(pV->punkVal);
            if (p) {
                CRegKey sk;
                DWORD rc = sk.Create(m_hk, OLE2CT(pszPropName), NULL, 0, KEY_READ | KEY_WRITE, NULL, NULL);
                if (rc != ERROR_SUCCESS) {
                    return HRESULT_FROM_WIN32(rc);
                }
                CLSID cl;
                hr = p->GetClassID(&cl);
                if (FAILED(hr)) {
                    return E_UNEXPECTED;
                }
                OLECHAR szClsid[64];
                rc = StringFromGUID2(cl, szClsid, sizeof(szClsid)/sizeof(OLECHAR));
                if (!rc) {
                    return E_UNEXPECTED;
                }
                rc = RegSetValue(sk, NULL, REG_SZ, OLE2T(szClsid), _tcslen(OLE2T(szClsid)) * sizeof(TCHAR));
                if (rc != ERROR_SUCCESS) {
                    return HRESULT_FROM_WIN32(rc);
                }
                try {
                    PQPropertyBag pBag(new CRegBag(sk, NULL, 0, KEY_READ | KEY_WRITE));
                    if (pBag) {
                        hr = p->Save(pBag, false, true);
                    } else {
                        hr = E_OUTOFMEMORY;
                    }
                } CATCHCOM();
            }
        }
        // rev2: support other persistence interfaces, esp stream via shopenregstream()
    }

    return hr;
}

// IPropertyBag
STDMETHODIMP CRegBagBase::Read(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog) {
    if (!pszPropName || !pVar) {
        return E_POINTER;
    }
	ATL_LOCK();
    DWORD dwType, cbSize = 64;
    BYTE data[64];
    LPBYTE pbData = data;
    USES_CONVERSION;
    HRESULT hr = RegQueryValueEx(m_hk, OLE2CT(pszPropName), NULL, &dwType, pbData, &cbSize);
    if (hr == ERROR_SUCCESS) {
        return RegConvertToVARIANT(pVar, dwType, pbData, cbSize);
    } else if (hr == ERROR_MORE_DATA) {
        cbSize += sizeof(TCHAR);
        pbData = new BYTE[cbSize];
        hr = RegQueryValueEx(m_hk, OLE2CT(pszPropName), NULL, &dwType, pbData, &cbSize);
        if (hr == ERROR_SUCCESS) {
            hr = RegConvertToVARIANT(pVar, dwType, pbData, cbSize);
            delete[] pbData;
            return hr;
        }
        delete[] pbData;
    }     
    // must be a key, so try the object
    CRegKey sk;
    hr = sk.Open(m_hk, OLE2CT(pszPropName), KEY_READ);
    if (hr != ERROR_SUCCESS) {
        return HRESULT_FROM_WIN32(hr);
    }
    TCHAR pszclsid[80 * sizeof(TCHAR)];
    LONG dwSize = sizeof(pszclsid);
    hr = RegQueryValue(sk, NULL, pszclsid, &dwSize);
    if (hr != ERROR_SUCCESS) {
        return HRESULT_FROM_WIN32(hr);
    }
    GUID clsid;
    hr = CLSIDFromString(T2OLE(pszclsid), &clsid);
    if (FAILED(hr)) {
        return E_FAIL;
    }
    switch (pVar->vt) {
    case VT_EMPTY:
    case VT_NULL:
        //DISPATCH is preferred if object supports it.  if not we'll convert back 
        // to unknown down below.
        pVar->vt = VT_DISPATCH;  
        pVar->pdispVal = NULL;
        break;
    case VT_DISPATCH:
    case VT_UNKNOWN:
        break;
    default:
        hr = VariantChangeType(pVar, pVar, 0, VT_DISPATCH);
        if (FAILED(hr)) {
            hr = VariantChangeType(pVar, pVar, 0, VT_UNKNOWN);
            if (FAILED(hr)) {
                return E_INVALIDARG;
            }
        }
    }
    PQPersistPropertyBag pPersistObj(((pVar->vt == VT_UNKNOWN) ? pVar->punkVal : pVar->pdispVal));
    hr = LoadPersistedObject<PQPropertyBag, PQPersistPropertyBag> (pPersistObj, clsid, pVar, m_hk, pszPropName, pErrorLog);
    if (FAILED(hr)) {
        PQPersistPropertyBag2 pPersistObj2(((pVar->vt == VT_UNKNOWN) ? pVar->punkVal : pVar->pdispVal));
        hr = LoadPersistedObject<PQPropertyBag2, PQPersistPropertyBag2> (pPersistObj2, clsid, pVar, m_hk, pszPropName, pErrorLog);
    }
    return hr;
}

STDMETHODIMP CRegBagBase::Write(LPCOLESTR pszPropName, VARIANT *pVar) {
    if (!pszPropName || !pVar) {
        return E_POINTER;
    }
	ATL_LOCK();

    HRESULT hrc;
    if (pVar->vt & VT_BYREF) {
        hrc = VariantChangeType(pVar, pVar, 0, pVar->vt & ~VT_BYREF);
        if (FAILED(hrc)) {
            return E_INVALIDARG;
        }
    }
    USES_CONVERSION;
    hrc = NOERROR;
    switch(pVar->vt) {
    case VT_I1: //fall thru
    case VT_I2: //fall thru
    case VT_I4: //fall thru
    case VT_UI1: //fall thru
    case VT_UI2: //change type and fall thru
    case VT_INT: //change type and fall thru
    case VT_UINT: //change type and fall thru
	case VT_BOOL: //change type and fall thru
        hrc = VariantChangeType(pVar, pVar, 0, VT_UI4);
        if (FAILED(hrc)) {
            return E_INVALIDARG;
        }
    case VT_UI4:  //REG_DWORD
        hrc = RegSetValueEx(
            m_hk, 
            OLE2CT(pszPropName),
            0,            // dwReserved
            REG_DWORD,
            reinterpret_cast<LPBYTE>(&pVar->ulVal),
            sizeof(pVar->ulVal));
        if (hrc != ERROR_SUCCESS) {
			return HRESULT_FROM_WIN32(hrc);
		}
        // make sure no old object exists
        DeleteSubKey(m_hk, pszPropName);
        break;

    case VT_BSTR: { //REG_SZ
		hrc = ERROR_SUCCESS;
        LPTSTR val = OLE2T(pVar->bstrVal);
		if (val) {
		    UINT len  = ::SysStringByteLen(pVar->bstrVal);
			hrc = RegSetValueEx(
				m_hk, 
				OLE2CT(pszPropName),
				0,            // dwReserved
				REG_SZ,
				reinterpret_cast<LPBYTE>(val), 
				len);
		}
        if (hrc == ERROR_SUCCESS) {
            // make sure no old object exists
            DeleteSubKey(m_hk, pszPropName);
        }
    } break;
#if 0
	// we're not actually going to enable this since REG_MULTI_SZ only exists on NT
	// if we had REG_MULTI_SZ on 9x then we'd have to loop over the hole block skipping embedded nulls and unicode/ansi convert the
	// entire vector of strings
	// instead we're just going to treat vectors of bstrs as binary blobs 
    case VT_VECTOR | VT_BSTR: { //REG_MULTI_SZ
		hrc = ERROR_SUCCESS;
        LPTSTR val = OLE2T(pVar->bstrVal);
		if (val) {
			UINT len = ::SysStringByteLen(pVar->bstrVal);
			hrc = RegSetValueEx(
				m_hk, 
				OLE2CT(pszPropName),
				0,            // dwReserved
				REG_MULTI_SZ,
				reinterpret_cast<LPBYTE>(val), 
				len);
		}
        if (hrc == ERROR_SUCCESS) {
            // make sure no old object exists
            DeleteSubKey(m_hk, pszPropName);
        }
    } break;
#else
	case VT_VECTOR | VT_BSTR: // fall-thru to array(REG_BINARY)
#endif
    case VT_BSTR_BLOB: { //REG_BINARY
		SIZE_T len  = 0;
		LPBYTE pData  = reinterpret_cast<LPBYTE>(pVar->bstrVal);
		if (pData) {
			len  = ::SysStringByteLen(pVar->bstrVal);
			hrc = RegSetValueEx(
				m_hk, 
				OLE2CT(pszPropName),
				0,            // dwReserved
				REG_BINARY,
				pData,
				len);
			if (hrc == ERROR_SUCCESS) {
				// make sure no old object exists
				DeleteSubKey(m_hk, pszPropName);
			}
		}
    } break;
    case VT_ARRAY | VT_UI1: { //REG_BINARY
		LPBYTE pData = NULL;
	    SIZE_T len = 0;
        if (pVar->parray) {
		    HRESULT hr = SafeArrayAccessData(pVar->parray, reinterpret_cast<LPVOID *>(&pData));
		    if (FAILED(hr)) {
			    return hr;
		    }
		    for (int i = pVar->parray->cDims; i--;) {
			    len += pVar->parray->rgsabound[i].cElements;
		    }
		    len *= pVar->parray->cbElements;
			hrc = RegSetValueEx(
				m_hk, 
				OLE2CT(pszPropName),
				0,            // dwReserved
				REG_BINARY,
				pData,
				len);
			if (hrc == ERROR_SUCCESS) {
				// make sure no old object exists
				DeleteSubKey(m_hk, pszPropName);
			}
			SafeArrayUnaccessData(pVar->parray);
        }
	} break;
    case VT_I8://change type and fall thru
        hrc = VariantChangeType(pVar, pVar, 0, VT_UI8);
        if (FAILED(hrc)) {
            return E_INVALIDARG;
        }
    case VT_UI8: //REG_QWORD
        hrc = RegSetValueEx(
            m_hk, 
            OLE2CT(pszPropName),
            0,            // dwReserved
            REG_QWORD,
            reinterpret_cast<LPBYTE>(&pVar->ullVal),
            sizeof(pVar->ullVal));
        if (hrc == ERROR_SUCCESS) {
            // make sure no old object exists
            DeleteSubKey(m_hk, pszPropName);
        }
        break;
    case VT_DISPATCH:
        hrc = VariantChangeType(pVar, pVar, 0, VT_UNKNOWN);
        if (FAILED(hrc)) {
            return E_UNEXPECTED;
        }
    case VT_UNKNOWN:
        DeleteValue(m_hk, pszPropName);
        hrc = SaveObject(m_hk, pszPropName, pVar);
        break;
    case VT_EMPTY:
    case VT_NULL:
        // remove from registry
        DeleteValue(m_hk, pszPropName);
        DeleteSubKey(m_hk, pszPropName);
        hrc = NOERROR;
        break;
    default: 
      hrc = E_INVALIDARG;
    }
    return hrc;
}


STDMETHODIMP CRegBag::CountProperties(ULONG * pcProperties) {
    if (!pcProperties) {
        return E_POINTER;
    }
	ATL_LOCK();
    if (!pcProperties) {
		return E_POINTER;
    }
    DWORD cKeys, cValues;
    DWORD rc = RegQueryInfoKey(m_hk, 
                               NULL, NULL, NULL,
                               &cKeys, NULL, NULL,
                               &cValues, NULL, NULL,
                               NULL, NULL);
    if (rc != ERROR_SUCCESS) {
        return HRESULT_FROM_WIN32(rc);
    }
    *pcProperties = cKeys + cValues;
    return NOERROR;
}

STDMETHODIMP CRegBag::GetPropertyInfo(ULONG iProperty, ULONG cProperties, PROPBAG2* pPropBag, ULONG * pcProperties) {
    if (!pPropBag || !pcProperties) {
		return E_POINTER;
    }
	ATL_LOCK();
    memset(pPropBag, 0, sizeof(*pPropBag) * cProperties);
    // NOTE: since the registry functions don't provide a unified enumeration
    // of subkeys and values, we're just going to establish values as coming
    // before subkeys by definition.
    DWORD cKeys, cValues, cbMaxKeyName, cbMaxValueName, cbMaxValue;
    DWORD rc = RegQueryInfoKey(m_hk, 
                               NULL, NULL, NULL,
                               &cKeys, &cbMaxKeyName, NULL,
                               &cValues, &cbMaxValueName, &cbMaxValue,
                               NULL, NULL);
    if (rc != ERROR_SUCCESS) {
        return HRESULT_FROM_WIN32(rc);
    }
    // nt doesn't return enough room for the terminating character
    // but these are still char counts not byte counts yet.
    ++cbMaxKeyName;
    ++cbMaxValueName;
        
    cbMaxKeyName *= sizeof(TCHAR);
    cbMaxValueName *= sizeof(TCHAR);
    // now they're real byte counts

    DWORD dwValIndex = 0, dwBagIndex = 0;
    USES_CONVERSION;
    if (iProperty < cValues) {
        LPTSTR pszName = new TCHAR[cbMaxValueName + 1];
        // we're starting with values
        for (;dwValIndex < cProperties; ++dwValIndex) {
            DWORD Type;
            DWORD cbName = cbMaxValueName + 1;
            rc = RegEnumValue(m_hk, dwValIndex, pszName, &cbName, NULL, &Type, NULL, NULL);
            if (rc != ERROR_SUCCESS) {
                break;
            }
            if (dwValIndex < iProperty) {
                continue;  // skip until we get to first requested
            }
            switch (Type) {
            case REG_DWORD:
                pPropBag[dwBagIndex].dwType = PROPBAG2_TYPE_DATA;
                pPropBag[dwBagIndex].vt = VT_UI4;
                break;
            case REG_QWORD:
                pPropBag[dwBagIndex].dwType = PROPBAG2_TYPE_DATA;
                pPropBag[dwBagIndex].vt = VT_UI8;
                break;
            case REG_SZ:
                pPropBag[dwBagIndex].dwType = PROPBAG2_TYPE_DATA;
                pPropBag[dwBagIndex].vt = VT_BSTR;
                pPropBag[dwBagIndex].cfType = CF_TEXT;
                break;
            default: // binary
                pPropBag[dwBagIndex].dwType = PROPBAG2_TYPE_DATA;
                pPropBag[dwBagIndex].vt = VT_UI1 | VT_ARRAY;
                break;
            }
            int len = sizeof(OLECHAR) * (_tcsclen(pszName) + 1);
            pPropBag[dwBagIndex].pstrName = reinterpret_cast<LPOLESTR>(CoTaskMemAlloc(len + 1));
            if (!pPropBag[dwBagIndex].pstrName) {
                delete[] pszName;
                return E_OUTOFMEMORY;
            }
            (void)StringCchCopy(pPropBag[dwBagIndex].pstrName, len + 1, T2OLE(pszName));
            ++dwBagIndex;
        }
        delete[] pszName;
    }
    DWORD dwKeyIndex = 0;
    if (iProperty < cKeys + cValues) {
        LPTSTR pszName =  new TCHAR[cbMaxKeyName + 1];
        for (; (dwKeyIndex  + dwValIndex) < cProperties; ++dwKeyIndex) {
            DWORD cbName = cbMaxKeyName + 1;
            rc = RegEnumKeyEx(m_hk, dwKeyIndex, pszName, &cbName, NULL, NULL, NULL, NULL);
            if (rc != ERROR_SUCCESS) {
                break;
            }
            if ((dwValIndex + dwKeyIndex) < iProperty) {
                continue;
            }
            pPropBag[dwBagIndex].dwType = PROPBAG2_TYPE_OBJECT;
            pPropBag[dwBagIndex].vt = VT_UNKNOWN;

            int len = sizeof(OLECHAR) * (_tcsclen(pszName) + 1);
            pPropBag[dwBagIndex].pstrName = reinterpret_cast<LPOLESTR>(CoTaskMemAlloc(len + 1));
            if (!pPropBag[dwBagIndex].pstrName) {
                delete[] pszName;
                return E_OUTOFMEMORY;
            }
            (void)StringCchCopy(pPropBag[dwBagIndex].pstrName, len + 1, T2OLE(pszName));
            ++dwBagIndex;
        }
        delete[] pszName;
    }
    *pcProperties = dwBagIndex;
    return NOERROR;
}

STDMETHODIMP CRegBag::LoadObject(LPCOLESTR pstrName, ULONG dwHint, IUnknown * pUnkObject, IErrorLog * pErrLog) {
    if (!pstrName  || !pUnkObject) {
        return E_POINTER;
    }
    VARIANT v;  // don't clear the variant, we're guaranteed nested lifetimes and
                // we're not addref'ing
    v.vt = VT_UNKNOWN;
    v.punkVal = pUnkObject;
    return Read(pstrName, &v, pErrLog);
}


STDMETHODIMP CCreateRegBag::Create(HKEY hkey, LPCOLESTR subkey, DWORD options, DWORD sam, REFIID iid, LPVOID* ppBag) {
    if (!ppBag) {
        return E_POINTER;
    }
	ATL_LOCK();
	if (ppBag == NULL)
		return E_POINTER;
    try {		
        USES_CONVERSION;
        if (iid == __uuidof(IPropertyBag)) {
            PQPropertyBag temp = new CRegBag(hkey, OLE2CT(subkey), options, sam);
            *ppBag = temp.Detach();
        } else if (iid == __uuidof(IPropertyBag2)) {
            PQPropertyBag2 temp = new CRegBag(hkey, OLE2CT(subkey), options, sam);
            *ppBag = temp.Detach();
        } else {
            return E_NOTIMPL;
        }
        if (!*ppBag) return E_OUTOFMEMORY;
        return NOERROR;
    } CATCHCOM();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\dat2xds.h ===
//==========================================================================;
//
// dat2xds.h : Declaration of the custom composition class for gluing sbe source to vmr
// TODO: Need to update header file and change classids
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#ifndef DAT2XDS_H
#define DAT2XDS_H

#pragma once
#include <uuids.h>
#include "bdamedia.h"
#include "MSVidEncoder.h"
#include "resource.h"       // main symbols
#include <winerror.h>
#include <algorithm>
#include <compimpl.h>
#include <seg.h>
#include <objectwithsiteimplsec.h>



/////////////////////////////////////////////////////////////////////////////
// CDat2XDSComp
class ATL_NO_VTABLE __declspec(uuid("0429EC6E-1144-4bed-B88B-2FB9899A4A3D")) CDat2XDSComp : 
public CComObjectRootEx<CComSingleThreadModel>,
public CComCoClass<CDat2XDSComp, &__uuidof(CDat2XDSComp)>,
public IObjectWithSiteImplSec<CDat2XDSComp>,
public IMSVidCompositionSegmentImpl<CDat2XDSComp>
{
public:
    CDat2XDSComp() {}
    virtual ~CDat2XDSComp() {}
    
    REGISTER_NONAUTOMATION_OBJECT(IDS_PROJNAME, 
        IDS_REG_DAT2XDSCOMP_DESC,
        LIBID_MSVidCtlLib,
        __uuidof(CDat2XDSComp));
    
    DECLARE_PROTECT_FINAL_CONSTRUCT()
        
        BEGIN_COM_MAP(CDat2XDSComp)
        COM_INTERFACE_ENTRY(IMSVidCompositionSegment)
        COM_INTERFACE_ENTRY(IMSVidGraphSegment)
        COM_INTERFACE_ENTRY(IObjectWithSite)
        COM_INTERFACE_ENTRY(IPersist)
        END_COM_MAP()
        
        // IMSVidComposition
public:
    // IMSVidGraphSegment
    // IMSVidCompositionSegment
    STDMETHOD(Compose)(IMSVidGraphSegment * upstream, IMSVidGraphSegment * downstream)
    {
        if (m_fComposed) {
            return NOERROR;
        }
        ASSERT(m_pGraph);
        try {
            VWGraphSegment up(upstream);
            ASSERT(up.Graph() == m_pGraph);
            VWGraphSegment down(downstream);
            ASSERT(down.Graph() == m_pGraph);
            if (upstream == downstream) {
                return Error(IDS_CANT_COMPOSE_WITH_SELF, __uuidof(IMSVidCompositionSegment), E_INVALIDARG);
            }
            if (up.begin() == up.end()) {
                TRACELM(TRACE_ERROR, "CComposition::Compose() can't compose empty up segment");
                return NOERROR;
            }
            if (down.begin() == down.end()) {
                TRACELM(TRACE_ERROR, "CComposition::Compose() can't compose empty down segment");
                // this is not an error, for example, CA is an empty segment.
                return NOERROR;
            }
            bool vidFound = false;
            // VMR has a bug so we need to connect the video before the cc or no cc will be displayed
            DSMediaType mtVideo(MEDIATYPE_Video, MEDIASUBTYPE_MPEG2_VIDEO, FORMAT_MPEG2Video);
            for (VWGraphSegment::iterator iStart = up.begin(); iStart != up.end(); ++iStart) {
                ASSERT((*iStart).GetGraph() == m_pGraph);
                if(!vidFound){
                    for(DSFilter::iterator i = (*iStart).begin(); i != (*iStart).end(); ++i){
                        if((*i).GetDirection() == DOWNSTREAM){
                            for(DSPin::iterator p = (*i).begin(); p != (*i).end(); ++p){ 
                                if((*p) == mtVideo){
                                    for (VWGraphSegment::iterator iStop = down.begin(); iStop != down.end(); ++ iStop) {
                                        ASSERT((*iStop).GetGraph() == m_pGraph);
                                        DSFilter pStop(*iStop);
                                        (*i).IntelligentConnect(pStop, m_Filters);
                                    }
                                    vidFound = true;
                                    iStart = up.begin();
                                }
                            }
                        }
                    }
                }
                else{
                    for (VWGraphSegment::iterator iStop = down.begin(); iStop != down.end(); ++ iStop) {
                        ASSERT((*iStop).GetGraph() == m_pGraph);
                        DSFilter pStart(*iStart);
                        DSFilter pStop(*iStop);
                        HRESULT hr = m_pGraph.Connect(pStart, pStop, m_Filters);
                        if (SUCCEEDED(hr)) {
                            m_Segments.push_back(up);
                            m_Segments.push_back(down);
                            m_pDown = m_Segments.end();
                            --m_pDown;
                            m_pUp = m_pDown;
                            --m_pUp;
                            m_fComposed = true;
                            return NOERROR;
                        }
                    }
                }
            }
            TRACELM(TRACE_ERROR, "CComposition::Compose() compose didn't connect anything");
            return VFW_E_NO_DECOMPRESSOR;
        } catch (ComException &e) {
            return e;
        } catch (...) {
            return E_UNEXPECTED;
        }
        
    }

    
};

#endif // Dat2XDS_H
// end of file - Dat2XDS.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\createregbag.h ===
// CreateRegBag.h : Declaration of the CCreateRegBag

#ifndef __CREATEREGBAG_H_
#define __CREATEREGBAG_H_

#include <comcat.h>
#include <objsafe.h>
#include <propertybag2impl.h>
#include <objectwithsiteimplsec.h>
#include <throw.h>

/////////////////////////////////////////////////////////////////////////////
// CRegBagBase
class ATL_NO_VTABLE CRegBagBase : public CComObjectRootEx<CComMultiThreadModel>,
    public IPropertyBag,
	public IPropertyBag2Impl<CRegBagBase>,
    public IObjectWithSiteImplSec<CRegBagBase>
{

    BEGIN_COM_MAP(CRegBagBase)
	    COM_INTERFACE_ENTRY(IPropertyBag2)
        COM_INTERFACE_ENTRY(IPropertyBag)
        COM_INTERFACE_ENTRY(IObjectWithSite)
    END_COM_MAP_WITH_FTM()

	CRegBagBase() {}

    virtual ~CRegBagBase() {}

// IPropertyBag
    STDMETHOD(Read)(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog);
    STDMETHOD(Write)(LPCOLESTR pszPropName, VARIANT *pVar);
    
protected:
    // internal utility functions
    HRESULT DeleteSubKey(CRegKey& hk, LPCOLESTR pszPropName);
    HRESULT DeleteValue(CRegKey& hk, LPCOLESTR pszPropName);
    HRESULT SaveObject(CRegKey& hk, LPCOLESTR pszPropName, VARIANT* pV);
    HRESULT RegConvertToVARIANT(VARIANT *pVar, DWORD dwType, LPBYTE pbData, DWORD cbSize);

    CRegKey m_hk;
};

/////////////////////////////////////////////////////////////////////////////
// CRegBag
class CRegBag : 
	public CComObject<CRegBagBase>
{
public:
    CRegBag(HKEY hk, LPCTSTR subkey, DWORD ulOptions, REGSAM samDesired) {
        DWORD rc = m_hk.Open(hk, subkey, samDesired, ulOptions);
        if (rc != ERROR_SUCCESS) {
            THROWCOM(HRESULT_FROM_WIN32(rc));
        }
    }
    virtual ~CRegBag() {}
// IPropertyBag2
	STDMETHOD(CountProperties)(ULONG * pcProperties);
	STDMETHOD(GetPropertyInfo)(ULONG iProperty, ULONG cProperties, PROPBAG2 * pPropBag, ULONG * pcProperties);
	STDMETHOD(LoadObject)(LPCOLESTR pstrName, ULONG dwHint, IUnknown * pUnkObject, IErrorLog * pErrLog);
};


template<class BAGTYPE, class PERSISTTYPE> HRESULT LoadPersistedObject(PERSISTTYPE pPersistObj, 
																	   CLSID& clsid, 
																	   VARIANT* pVar, 
																	   HKEY hk, 
																	   LPCOLESTR pszPropName, 
																	   IErrorLog *pErrorLog) {
    ASSERT(pVar && hk && pszPropName);
    HRESULT hr = NOERROR;
    if (!pPersistObj && ((pVar->vt == VT_UNKNOWN) ? pVar->punkVal : pVar->pdispVal)) {
        // got passed an object to initialize and the object doesn't support persist
        return E_NOINTERFACE;
    } else if (!pPersistObj) {
        hr = pPersistObj.CoCreateInstance(clsid);
        if (FAILED(hr)) {
            // we ignore subkeys if they don't look like objects
            // but if they have a default value that successfully converts to a guid
            // and if that object can't be created then its an error
            return hr;
        }
        hr = pPersistObj->InitNew();
        if (FAILED(hr) && hr != E_NOTIMPL) {
            return hr;
        }
        ASSERT(pVar->vt == VT_UNKNOWN || pVar->vt == VT_DISPATCH);
        switch(pVar->vt) {
        case VT_DISPATCH:
            pVar->pdispVal = PQDispatch(pPersistObj);
            if (pVar->pdispVal) {
                pVar->pdispVal->AddRef();
                break;
            } else {
                pVar->vt = VT_UNKNOWN;
            }
            // fall thru
        case VT_UNKNOWN:
            pVar->punkVal = pPersistObj;
            (pVar->punkVal)->AddRef();
        }
    }
    USES_CONVERSION;
    BAGTYPE pBag(new CRegBag(hk, OLE2CT(pszPropName), 0, KEY_READ));
    if (!pBag) {
        return E_OUTOFMEMORY;
    }
    hr = pPersistObj->Load(pBag, pErrorLog);

    return hr;
};

/////////////////////////////////////////////////////////////////////////////
// CCreateRegBag
class ATL_NO_VTABLE CCreateRegBag : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CCreateRegBag, &CLSID_CreatePropBagOnRegKey>,
    public IObjectWithSiteImplSec<CCreateRegBag>,
	public ICreatePropBagOnRegKey
{
public:
	CCreateRegBag()
	{
	}

REGISTER_NONAUTOMATION_OBJECT_WITH_TM(IDS_PROJNAME, 
						   IDS_REG_CREATEREGBAG_DESC,
						   LIBID_MSVidCtlLib,
						   CLSID_CreatePropBagOnRegKey, tvBoth);

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CCreateRegBag)
	COM_INTERFACE_ENTRY(ICreatePropBagOnRegKey)
    COM_INTERFACE_ENTRY(IObjectWithSite)
END_COM_MAP_WITH_FTM()

BEGIN_CATEGORY_MAP(CVidCtl)
    IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
END_CATEGORY_MAP()

// ICreateRegBag
public:
// ICreatePropBagOnRegKey
	STDMETHOD(Create)(HKEY hkey, LPCOLESTR subkey, DWORD options, DWORD sam, REFIID iid, LPVOID* ppBag);
};

#endif //__CREATEREGBAG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\dat2sin.h ===
//==========================================================================;
//
// Composition.h : Declaration of the custom composition class for gluing analog capture to ovmixer
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#ifndef DAT2SIN_H
#define DAT2SIN_H

#pragma once
#include <uuids.h>
#include "bdamedia.h"
#include "MSVidTVTuner.h"
#include "resource.h"       // main symbols
#include <winerror.h>
#include <algorithm>
#include <compimpl.h>
#include <seg.h>
#include <objectwithsiteimplsec.h>
#include <ksmedia.h>
#include "enc2sin.h"

typedef struct

{ 
    KSPROPERTY                               m_ksThingy;
    VBICODECFILTERING_CC_SUBSTREAMS          ccSubStreamMask;
} KSPROPERTY_VBICODECFILTERING_CC_SUBSTREAMS;


/////////////////////////////////////////////////////////////////////////////
// CDat2SinComp
class ATL_NO_VTABLE __declspec(uuid("38F03426-E83B-4e68-B65B-DCAE73304838")) CDat2SinComp : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CDat2SinComp, &__uuidof(CDat2SinComp)>,
    public IObjectWithSiteImplSec<CDat2SinComp>,
    public IMSVidCompositionSegmentImpl<CDat2SinComp>
{
private:
    DSFilterList m_pEncFilters;
public:
    CDat2SinComp() {}
    virtual ~CDat2SinComp() {}

    REGISTER_NONAUTOMATION_OBJECT(IDS_PROJNAME, 
        IDS_REG_DAT2SINCOMP_DESC,
        LIBID_MSVidCtlLib,
        __uuidof(CDat2SinComp));
    
    DECLARE_PROTECT_FINAL_CONSTRUCT()
        
        BEGIN_COM_MAP(CDat2SinComp)
        COM_INTERFACE_ENTRY(IMSVidCompositionSegment)
        COM_INTERFACE_ENTRY(IMSVidGraphSegment)
        COM_INTERFACE_ENTRY(IObjectWithSite)
        COM_INTERFACE_ENTRY(IPersist)
        END_COM_MAP()
        
        // IMSVidComposition
public:
    // IMSVidGraphSegment
    // IMSVidCompositionSegment  
    STDMETHOD(CheckEncFilters)(){
        int j = 0;
        for(DSFilterList::iterator i = m_pEncFilters.begin(); i != m_pEncFilters.end(); ++i){
            TRACELM(TRACE_ERROR, "CAnaSinComp::CheckEncFilters checking filter " << j);
            CComQIPtr<IETFilterConfig> spETConfig;
            CComPtr<IUnknown> spUnkSecChan;
            spETConfig = (*i);
            if(!spETConfig){
                TRACELM(TRACE_ERROR, "CAnaSinComp::CheckEncFilters filter " << j << " could not get et filter config interface");
                return E_NOINTERFACE;
            }            
            HRESULT hr = spETConfig->GetSecureChannelObject(&spUnkSecChan);   
            hr = CheckIfSecureClient(spUnkSecChan);
            if(FAILED(hr)){
                TRACELM(TRACE_ERROR, "CAnaSinComp::CheckEncFilters filter " << j << " Failed");
                return E_FAIL;
            }
            ++j;
        }
        TRACELM(TRACE_ERROR, "CAnaSinComp::CheckEncFilters no failures");
        return NOERROR;
    }

    STDMETHOD(PreRun)(){
        return CheckEncFilters();
    }
    STDMETHOD(put_Container)(IMSVidGraphSegmentContainer *pCtl) {
        try {
            if (!pCtl) {
                m_pEncFilters.clear();
                return Unload();
            }
            if (m_pContainer) {
				if (!m_pContainer.IsEqualObject(VWSegmentContainer(pCtl))) {
					//undone: support moving to different graph
					return Error(IDS_OBJ_ALREADY_INIT, __uuidof(IMSVidGraphSegment), CO_E_ALREADYINITIALIZED);
				} else {
					return NO_ERROR;
				}
            }
            // DON'T addref the container.  we're guaranteed nested lifetimes
            // and an addref creates circular refcounts so we never unload.
            m_pContainer.p = pCtl;
            m_pGraph = m_pContainer.GetGraph();
        } catch(...) {
            return E_UNEXPECTED;
        }
		return NOERROR;
	}
    STDMETHOD(SetSubstreamChannel)(IPin * pPinCCDecoder, DWORD dwSubStreamChannels){
        HRESULT hr;
        if(!(dwSubStreamChannels & 
            (KS_CC_SUBSTREAM_ODD | KS_CC_SUBSTREAM_EVEN |
            KS_CC_SUBSTREAM_SERVICE_CC1 | KS_CC_SUBSTREAM_SERVICE_CC2 |
            KS_CC_SUBSTREAM_SERVICE_CC3   | KS_CC_SUBSTREAM_SERVICE_CC4 |
            KS_CC_SUBSTREAM_SERVICE_T1    | KS_CC_SUBSTREAM_SERVICE_T2 |
            KS_CC_SUBSTREAM_SERVICE_T3    | KS_CC_SUBSTREAM_SERVICE_T4 |
            KS_CC_SUBSTREAM_SERVICE_XDS))){
            return E_INVALIDARG;
        }
        
        
        try {
            IKsPropertySet *pksPSet = NULL;
            
            hr = pPinCCDecoder->QueryInterface(IID_IKsPropertySet, (void **) &pksPSet);
            
            if(SUCCEEDED(hr)){
                DWORD rgdwData[20];
                DWORD cbMax = sizeof(rgdwData);
                DWORD cbData;
                
                hr = pksPSet->Get(KSPROPSETID_VBICodecFiltering,
                    KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_DISCOVERED_BIT_ARRAY,
                    NULL, 0, 
                    (BYTE *) rgdwData, cbMax, &cbData); 
                
                if(SUCCEEDED(hr)){
                    KSPROPERTY_VBICODECFILTERING_CC_SUBSTREAMS ksThing = {0};
                    
                    ksThing.ccSubStreamMask.SubstreamMask = dwSubStreamChannels;
                    
                    // ring3 to ring0 propset call
                    hr = pksPSet->Set(KSPROPSETID_VBICodecFiltering,
                        KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_REQUESTED_BIT_ARRAY,                           
                        &ksThing.ccSubStreamMask, 
                        sizeof(ksThing) - sizeof(KSPROPERTY), 
                        &ksThing, 
                        sizeof(ksThing));
                }
                
                pksPSet->Release();            
                
            }
            
        } catch (HRESULT hrCatch) {
            // bad things happend  
            hr = hrCatch;
        } catch (...) {
            // Threw Badly - Giving Up"
            hr = E_FAIL;
        }
        return hr;
        
    }


    STDMETHOD(Compose)(IMSVidGraphSegment * upstream, IMSVidGraphSegment * downstream)
    {
        if (m_fComposed) {
            return NOERROR;
        }
        ASSERT(m_pGraph);
        try {
            VWGraphSegment up(upstream);
            ASSERT(up.Graph() == m_pGraph);
            VWGraphSegment down(downstream);
            ASSERT(down.Graph() == m_pGraph);
            if (upstream == downstream) {
                return Error(IDS_CANT_COMPOSE_WITH_SELF, __uuidof(IMSVidCompositionSegment), E_INVALIDARG);
            }
            if (up.begin() == up.end()) {
                TRACELM(TRACE_ERROR, "CComposition::Compose() can't compose empty up segment");
                return NOERROR;
            }
            if (down.begin() == down.end()) {
                TRACELM(TRACE_ERROR, "CComposition::Compose() can't compose empty down segment");
                // this is not an error, for example, CA is an empty segment.
                return NOERROR;
            }
            // Making sure that only the cc pin is rendered to the sink and that the encrypter is added
            CMSVidStreamBufferSink* ds = (CMSVidStreamBufferSink*)downstream;
            DSFilter pSink(ds->m_Filters[0]);
            DSGraph::iterator gFilter; 
            DSFilter::iterator fPin;
            DSPin::iterator pMedia;
            DSPin ccPin;
            DSMediaType mtL21(MEDIATYPE_AUXLine21Data, MEDIASUBTYPE_Line21_BytePair);
            for(gFilter = m_pGraph.begin(); gFilter != m_pGraph.end() && !ccPin; ++gFilter){
                for(fPin = (*gFilter).begin(); fPin != (*gFilter).end() && !ccPin; ++fPin){
                    for(pMedia = (*fPin).begin(); pMedia != (*fPin).end() && !ccPin; ++pMedia){
                        if((*pMedia) == mtL21){
                            if(!(*fPin).IsConnected() && (*fPin).GetDirection() == PINDIR_OUTPUT){
                                ccPin = *fPin;
                            }
                        }
                    }
                }
            }
            if(!ccPin){
                return E_FAIL;
            }
            HRESULT hr = E_FAIL;
            DSFilterList intermediates;
#if ENCRYPT_NEEDED
            CComBSTR encString(L"{C4C4C4F1-0049-4E2B-98FB-9537F6CE516D}");
            GUID2 encdecGuid (encString);
            CComPtr<IUnknown> spEncTagFilter(encdecGuid, NULL, CLSCTX_INPROC_SERVER);
            if (!spEncTagFilter) {
                TRACELM(TRACE_ERROR, "CMSVidStreamBufferSink::Build() can't load Tagger filter");
                return ImplReportError(__uuidof(IMSVidStreamBufferSink), IDS_CANT_CREATE_FILTER, __uuidof(IStreamBufferSink), E_UNEXPECTED);
            }
            
            DSFilter ETFilter(spEncTagFilter);
            if (!ETFilter) {
                ASSERT(false);
                return ImplReportError(__uuidof(IMSVidStreamBufferSink), IDS_CANT_CREATE_FILTER, __uuidof(IBaseFilter), E_UNEXPECTED);
            }
            
            m_Filters.push_back(ETFilter);
            m_pEncFilters.push_back(ETFilter);
            CString csName = _T("CC Encoder Tagger Filter");
            m_pGraph.AddFilter(ETFilter, csName);
            
            // Connect cc pin to the Tagger
            hr = ccPin.IntelligentConnect(ETFilter, intermediates);
            if(FAILED(hr)){
                TRACELM(TRACE_DETAIL, "CAnaSinComp::Compose() can't connect audio pin to CC Tagger");
                return E_UNEXPECTED;  
            }

            ASSERT(intermediates.begin() == intermediates.end());
            m_Filters.insert(m_Filters.end(), intermediates.begin(), intermediates.end());

            hr = E_FAIL;
            DSFilter::iterator ETPin;
            for(ETPin = ETFilter.begin(); ETPin != ETFilter.end(); ++ETPin){
                if((*ETPin).GetDirection() == PINDIR_OUTPUT && !(*ETPin).IsConnected()){
                    break;
                }
            }   
            if(ETPin == ETFilter.end()){
                return E_UNEXPECTED;
            }
            for(fPin = pSink.begin(); fPin != pSink.end() && FAILED(hr); ++fPin){
                if((*fPin).GetDirection() == PINDIR_INPUT && !(*fPin).IsConnected()){
                    hr = (*ETPin).Connect((*fPin));
                }
            }

            if(FAILED(hr)){
                return hr;
            }
            else{
                ASSERT(intermediates.begin() == intermediates.end());
                m_Filters.insert(m_Filters.end(), intermediates.begin(), intermediates.end());
            }
            
#else
            for(fPin = pSink.begin(); fPin != pSink.end() && FAILED(hr); ++fPin){
                if((*fPin).GetDirection() == PINDIR_INPUT && !(*fPin).IsConnected()){
                    hr = ccPin.Connect((*fPin));
                }
            }

            if(FAILED(hr)){
                return hr;
            }
            

#endif
            // BUG in the cc codec makes it so we have to set the feilds as such
//            hr = SetSubstreamChannel(ccPin, KS_CC_SUBSTREAM_EVEN|KS_CC_SUBSTREAM_ODD);
            ASSERT(SUCCEEDED(hr));
            return NOERROR;
        } catch (ComException &e) {
            return e;
        } catch (...) {
            return E_UNEXPECTED;
        }
        
    }
    

};

#endif // Dat2Sin_H
// end of file - Dat2Sin.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\devices.h ===
//==========================================================================;
//
// Devices.h : Declaration of the CDevices
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////

#pragma once

#ifndef DEVICES_H_
#define DEVICES_H_

#include <vector>
#include <objectwithsiteimplsec.h>
#include "devseq.h"

#if 0
#define DEBUGREGISTRY
#endif

#ifdef DEBUGREGISTRY
#include <statreg.h>
#endif

void CtorStaticVWDevicesFwdSeqPMFs(void);
void DtorStaticVWDevicesFwdSeqPMFs(void);

template<class DEVICETYPECOLLECTIONINTERFACE, 
		 class DEVICETYPEINTERFACE, 
		 const CLSID* DEVICETYPE_CLSID, 
		 int IDSPROGID,
		 int IDSDESC> class CTypedDevices;

template<class DEVICETYPECOLLECTIONINTERFACE, class DEVICETYPEINTERFACE, const CLSID* DEVICETYPE_CLSID, int IDSPROGID, int IDSDESC> class ATL_NO_VTABLE CTypedDevicesBase : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CTypedDevices<DEVICETYPECOLLECTIONINTERFACE, DEVICETYPEINTERFACE, DEVICETYPE_CLSID, IDSPROGID, IDSDESC>, DEVICETYPE_CLSID>,
	public ISupportErrorInfo,
    public IObjectWithSiteImplSec<CTypedDevicesBase>,
	public IDispatchImpl<DEVICETYPECOLLECTIONINTERFACE, &__uuidof(DEVICETYPECOLLECTIONINTERFACE), &LIBID_MSVidCtlLib>
{
public:

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CTypedDevicesBase)
	COM_INTERFACE_ENTRY(DEVICETYPECOLLECTIONINTERFACE)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectWithSite)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CTypedDevicesBase)
	IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
	IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
	IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
END_CATEGORY_MAP()

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid)
	{
		static const IID* arr[] = 
		{
			&__uuidof(DEVICETYPECOLLECTIONINTERFACE)
		};
		for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
		{
			if (InlineIsEqualGUID(*arr[i],riid))
				return S_OK;
		}
		return S_FALSE;
	}


virtual ~CTypedDevicesBase() {}

};

class CDevEnum;
/////////////////////////////////////////////////////////////////////////////
// CTypedDevices
template<class DEVICETYPECOLLECTIONINTERFACE, 
		 class DEVICETYPEINTERFACE, 
		 const CLSID* DEVICETYPE_CLSID, 
		 int IDSPROGID,
		 int IDSDESC> class CTypedDevices : 
	public CComObject<CTypedDevicesBase<DEVICETYPECOLLECTIONINTERFACE, DEVICETYPEINTERFACE, DEVICETYPE_CLSID, IDSPROGID, IDSDESC> >
{
	typedef CComQIPtr<DEVICETYPECOLLECTIONINTERFACE> PQDEVICETYPECOLLECTIONINTERFACE;
	typedef CComQIPtr<DEVICETYPEINTERFACE> PQDEVICETYPEINTERFACE;
	PQDEVICETYPECOLLECTIONINTERFACE m_Collection;
	bool m_fRO;
    bool m_fValid;
public:
	CTypedDevices(const DeviceCollection &Devices = DeviceCollection(), bool fRO = false, bool fValid = false) : 
		  m_fRO(fRO), m_fValid(fValid) {
		      m_Devices.clear();
			  m_Devices.insert(m_Devices.end(), Devices.begin(), Devices.end());
    }
	CTypedDevices(bool fRO, bool fValid = false) : 
		  m_Devices(DeviceCollection()), m_fRO(fRO), m_fValid(fValid) {}
	CTypedDevices(const CTypedDevices &src) : 
		  m_fRO(src.m_fRO), m_fValid(src.m_fValid) {
		      m_Devices.clear();
			  m_Devices.insert(m_Devices.end(), src.m_Devices.begin(), src.m_Devices.end());
    }
	CTypedDevices(const PQDEVICETYPECOLLECTIONINTERFACE& src) : 
		  m_fRO(static_cast<CTypedDevices<DEVICETYPECOLLECTIONINTERFACE, 
                                          DEVICETYPEINTERFACE, 
                                          DEVICETYPE_CLSID,  
                                          IDSPROGID, 
                                          IDSDESC> *>(src.p)->m_fRO),
		  m_fValid(static_cast<CTypedDevices<DEVICETYPECOLLECTIONINTERFACE, 
                                             DEVICETYPEINTERFACE, 
                                             DEVICETYPE_CLSID,  
                                             IDSPROGID, 
                                             IDSDESC> *>(src.p)->m_fValid) {
		      m_Devices.clear();
			  m_Devices.insert(m_Devices.end(),
                        static_cast<CTypedDevices<DEVICETYPECOLLECTIONINTERFACE, 
                                             DEVICETYPEINTERFACE, 
                                             DEVICETYPE_CLSID,  
                                             IDSPROGID, 
                                             IDSDESC> *>(src.p)->m_Devices.begin(), 
                        static_cast<CTypedDevices<DEVICETYPECOLLECTIONINTERFACE, 
                                             DEVICETYPEINTERFACE, 
                                             DEVICETYPE_CLSID,  
                                             IDSPROGID, 
                                             IDSDESC> *>(src.p)->m_Devices.end()
                        );
    }
	CTypedDevices<DEVICETYPECOLLECTIONINTERFACE, DEVICETYPEINTERFACE, DEVICETYPE_CLSID,  IDSPROGID, IDSDESC> &operator=(const CTypedDevices<DEVICETYPECOLLECTIONINTERFACE, DEVICETYPEINTERFACE, DEVICETYPE_CLSID, IDSPROGID, IDSDESC> &rhs) {
		if (this != &rhs) {
			m_Devices.clear();
			m_Devices.insert(m_Devices.end(), rhs.m_Devices.begin(), rhs.m_Devices.end());
			m_fRO = rhs.m_fRO;
			m_fValid = rhs.m_fValid;
		}

	}

	virtual ~CTypedDevices() {
	}

	static HRESULT WINAPI UpdateRegistry(BOOL bRegister) {
		CRegObject ro;
		return CObjRegHelp::RegisterAutomationClass(bRegister ? true : false, 
												    ro, 
												    IDS_PROJNAME,
												    IDSPROGID, 
												    IDSDESC, 
												    *DEVICETYPE_CLSID,
												    LIBID_MSVidCtlLib);
	}

// IMSVidDevices
public:
	inline bool IsRO() { return m_fRO; }
    inline bool GetValid() { return m_fValid; }
    inline void SetValid(bool fValid) { m_fValid = fValid; }
    __declspec(property(get=GetValid, put=SetValid)) bool Valid;
	DeviceCollection m_Devices;
// IMSVidDevices
	STDMETHOD(get_Count)(LONG * lCount)
	{
		if (lCount == NULL)
			return E_POINTER;
			
		try {
			*lCount = m_Devices.size();
		} catch(...) {
			return E_POINTER;
		}
		return NOERROR;
	}

	STDMETHODIMP get__NewEnum(IEnumVARIANT * * pD)
	{
		if (pD == NULL)
			return E_POINTER;
			
		PQEnumVARIANT temp;
		try {
			temp = new CDevEnum(PQDispatch(this), m_Devices);
		} catch(...) {
			return E_OUTOFMEMORY;
		}
		try {
			*pD = temp.Detach();
		} catch(...) {
			return E_POINTER;
		}
		return NOERROR;
	}

	STDMETHOD(get_Item)(VARIANT v, DEVICETYPEINTERFACE * * pDB)
	{
		if (pDB == NULL)
			return E_POINTER;
		int idx;
		CComVariant vidx;
		try {
			if (SUCCEEDED(vidx.ChangeType(VT_I4, &v))) {
				idx = vidx.lVal;
			} else {
				return DISP_E_TYPEMISMATCH;
			}
			if (idx >= m_Devices.size()) {
				return DISP_E_BADINDEX;
			}
		} catch(...) {
			return E_UNEXPECTED;
		}
		try {
            PQDevice pd(m_Devices[idx]);
            if (!pd) {
                return E_UNEXPECTED;
            }
			*pDB = PQDEVICETYPEINTERFACE(pd);
            if (!*pDB) {
                return E_UNEXPECTED;
            }
            (*pDB)->AddRef();
		} catch(...) {
			return E_POINTER;
		}
			
		return NOERROR;
	}
	STDMETHOD(Add)(DEVICETYPEINTERFACE * pDB)
	{
		if (m_fRO) {
			return Error(IDS_E_ROCOLLECTION, __uuidof(DEVICETYPECOLLECTIONINTERFACE), E_ACCESSDENIED);
		}
		try {
			PQDevice p(pDB);
			try {
				m_Devices.push_back(p);
			} catch(...) {
				return E_OUTOFMEMORY;
			}
		} catch(...) {
			E_POINTER;
		}

		return NOERROR;
	}
	STDMETHOD(Remove)(VARIANT v)
	{
		if (m_fRO) {
			return E_ACCESSDENIED;
		}

		int idx;
		CComVariant vidx;
		try {
			if (SUCCEEDED(vidx.ChangeType(VT_I4, &v))) {
				idx = vidx.lVal;
			} else {
				return DISP_E_TYPEMISMATCH;
			}
			if (idx >= m_Devices.size()) {
				return DISP_E_BADINDEX;
			}

			m_Devices.erase(m_Devices.begin() + idx);
		} catch(...) {
			return E_UNEXPECTED;
		}
			
		return NOERROR;
	}
};

typedef CTypedDevices<IMSVidInputDevices, IMSVidInputDevice, &CLSID_MSVidInputDevices, IDS_INPUTDEVICES_PROGID, IDS_INPUTDEVICES_DESCRIPTION> CInputDevices;
typedef CTypedDevices<IMSVidOutputDevices, IMSVidOutputDevice, &CLSID_MSVidOutputDevices, IDS_OUTPUTDEVICES_PROGID, IDS_OUTPUTDEVICES_DESCRIPTION> COutputDevices;
typedef CTypedDevices<IMSVidVideoRendererDevices, IMSVidVideoRenderer, &CLSID_MSVidVideoRendererDevices, IDS_VIDEORENDERERS_PROGID, IDS_VIDEORENDERERS_DESCRIPTION> CVideoRendererDevices;
typedef CTypedDevices<IMSVidAudioRendererDevices, IMSVidAudioRenderer, &CLSID_MSVidAudioRendererDevices, IDS_AUDIORENDERERS_PROGID, IDS_AUDIORENDERERS_DESCRIPTION> CAudioRendererDevices;
typedef CTypedDevices<IMSVidFeatures, IMSVidFeature, &CLSID_MSVidFeatures, IDS_FEATURES_PROGID, IDS_FEATURES_DESCRIPTION> CFeatures;

/////////////////////////////////////////////////////////////////////////////
// CDevEnum
class ATL_NO_VTABLE CDevEnumBase : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public IObjectWithSiteImplSec<CDevEnumBase>,
	public IEnumVARIANT
{
BEGIN_COM_MAP(CDevEnumBase)
	COM_INTERFACE_ENTRY(IEnumVARIANT)
    COM_INTERFACE_ENTRY(IObjectWithSite)
END_COM_MAP()
DECLARE_PROTECT_FINAL_CONSTRUCT()

virtual ~CDevEnumBase() {}
};

/////////////////////////////////////////////////////////////////////////////
class CDevEnum : public CComObject<CDevEnumBase>
{
public:
	CDevEnum(const PQDispatch& pDevices, DeviceCollection& dci) : 
		m_pDevices(pDevices), m_DC(dci), i(dci.begin()) {}
	CDevEnum(const CDevEnum &orig) : 
		m_pDevices(orig.m_pDevices), m_DC(orig.m_DC), i(orig.i) {}
    virtual ~CDevEnum() {}

// IDevEnum
public:
	PQDispatch m_pDevices;
	DeviceCollection& m_DC;
	DeviceCollection::iterator i;
// IEnumVARIANT
	STDMETHOD(Next)(ULONG celt, VARIANT * rgvar, ULONG * pceltFetched)
	{
		// pceltFetched can legally == 0
		//
		if (pceltFetched != NULL) {
			try {
				*pceltFetched = 0;
			} catch(...) {
				return E_POINTER;
			}
		}

		for (ULONG l=0; l < celt; l++) {
			try {
				VariantInit( &rgvar[l] ) ;
			} catch(...) {
				return E_POINTER;
			}
		}

		// Retrieve the next celt elements.
		HRESULT hr = NOERROR ;
		for (l = 0;i != m_DC.end() && celt != 0 ; ++i, ++l, --celt) {
			rgvar[l].vt = VT_DISPATCH ;
			rgvar[l].pdispVal = PQDevice(*i).Detach();
			if (pceltFetched != NULL) {
				(*pceltFetched)++ ;
			}
		}

		if (celt != 0) {
		   hr = ResultFromScode( S_FALSE ) ;
		}

		return hr ;
	}
	STDMETHOD(Skip)(ULONG celt)
	{
		for (;i != m_DC.end() && celt--; ++i);
		return (celt == 0 ? NOERROR : ResultFromScode( S_FALSE )) ;
	}
	STDMETHOD(Reset)()
	{
		i = m_DC.begin();
		return NOERROR;
	}
	STDMETHOD(Clone)(IEnumVARIANT * * ppenum)
	{
		if (ppenum == NULL)
			return E_POINTER;
		PQEnumVARIANT temp;
		try {
			temp = new CDevEnum(*this);
		} catch(...) {
			return E_OUTOFMEMORY;
		}
		try {
			*ppenum = temp.Detach();
		} catch(...) {
			return E_POINTER;
		}
		return NOERROR;
	}
};

#endif 
//end of file devices.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\dlldatax.h ===
//
//
//
#if !defined(AFX_DLLDATAX_H__CC62DDF2_925F_4B29_BEFD_13EE1E7BEB70__INCLUDED_)
#define AFX_DLLDATAX_H__CC62DDF2_925F_4B29_BEFD_13EE1E7BEB70__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif // !defined(AFX_DLLDATAX_H__CC62DDF2_925F_4B29_BEFD_13EE1E7BEB70__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\dlldatax.c ===
/*********************************************************
   DllData file -- partially generated by MIDL compiler 

  we are building the .idls over in published but we want the actual proxy stub to live in
  msvidctl.dll *not* quartz.dll 
  this is because registering the typelibs wipes out the proxy stub registration and
  we want to avoid any registration order dependencies.  so , we must register the proxy/stubs in 
  the vidctl after the typelib registration and it wouldn't be good to do it in both places and
  make quartz.dll unecessarily larger.

  consequently, we are manually maintaining this file.  if you add a new .idl to the vidctl you
  must update these entries

  for simplicity sake since we know we're always merging the proxy stub we're combining dlldata.c and
  dlldatax.c as well.

*********************************************************/


#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow


//#include "dlldata.c" as follows...

// wrapper for dlldata.c
#define PROXY_DELEGATION

#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

#define USE_STUBLESS_PROXY

EXTERN_PROXY_FILE( regbag )
EXTERN_PROXY_FILE( tuner )
#ifndef TUNING_MODEL_ONLY
    EXTERN_PROXY_FILE( segment )
    EXTERN_PROXY_FILE( msvidctl )
#endif


PROXYFILE_LIST_START
    REFERENCE_PROXY_FILE( regbag ),
    REFERENCE_PROXY_FILE( tuner ),
#ifndef TUNING_MODEL_ONLY
        REFERENCE_PROXY_FILE( segment ),
        REFERENCE_PROXY_FILE( msvidctl ),
#endif
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldatax.c file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\devices.cpp ===
//==========================================================================;
//
// Copyright (c) Microsoft Corporation 1998-2000.
//
//--------------------------------------------------------------------------;
//
// Devices.cpp : Implementation of CDevices
//

#include "stdafx.h"

#ifndef TUNING_MODEL_ONLY

#include "Devices.h"

static DWORD dwFetch;

// note: the compiler is generating but never calling the code to construct these initializers so the pointers
// are staying null.  we work around this by providing a function which dynamically allocating them on the heap 
// and calling it in our dllmain.

typedef enumerator_iterator<PQEnumVARIANT, CComVariant, IEnumVARIANT, VARIANT, std::allocator<VARIANT>::difference_type > EnumVARIANTIterator;
std_arity0pmf<IEnumVARIANT, HRESULT> * EnumVARIANTIterator::Reset = NULL;
std_arity1pmf<IEnumVARIANT, VARIANT *, HRESULT> * EnumVARIANTIterator::Next = NULL;

#define DECLAREPMFS(coll) \
	std_arity1pmf<IMSVid##coll, IEnumVARIANT **, HRESULT> * VW##coll::Fetch = NULL

#define INITPMFS(coll) \
	VW##coll::Fetch = new std_arity1pmf<IMSVid##coll, IEnumVARIANT **, HRESULT>(&IMSVid##coll::get__NewEnum)

#define DELETEPMFS(coll) \
    delete VW##coll::Fetch

DECLAREPMFS(InputDevices);
DECLAREPMFS(OutputDevices);
DECLAREPMFS(VideoRendererDevices);
DECLAREPMFS(AudioRendererDevices);
DECLAREPMFS(Features);

DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidInputDevices, CInputDevices)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidOutputDevices, COutputDevices)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidVideoRendererDevices, CVideoRendererDevices)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidAudioRendererDevices, CAudioRendererDevices)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidFeatures, CFeatures)

// work around compiler bug as per above description
void CtorStaticVWDevicesFwdSeqPMFs(void) {


	INITPMFS(InputDevices);
	INITPMFS(OutputDevices);
	INITPMFS(VideoRendererDevices);
	INITPMFS(AudioRendererDevices);
	INITPMFS(Features);

	EnumVARIANTIterator::Reset = new std_arity0pmf<IEnumVARIANT, HRESULT>(&IEnumVARIANT::Reset);
	EnumVARIANTIterator::Next = new std_bndr_mf_1_3<std_arity3pmf<IEnumVARIANT, ULONG, VARIANT*, ULONG *, HRESULT> >(std_arity3_member(&IEnumVARIANT::Next), 1, &dwFetch);
}

// work around compiler bug as per above description
void DtorStaticVWDevicesFwdSeqPMFs(void) {

	DELETEPMFS(InputDevices);
	DELETEPMFS(OutputDevices);
	DELETEPMFS(VideoRendererDevices);
	DELETEPMFS(AudioRendererDevices);
	DELETEPMFS(Features);

	delete EnumVARIANTIterator::Reset;
	delete EnumVARIANTIterator::Next;
}



/////////////////////////////////////////////////////////////////////////////
// CDevEnum

#endif //TUNING_MODEL_ONLY

// end of file - devices.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\dvbslocator.h ===
/////////////////////////////////////////////////////////////////////////////////////
// DVBSLocator.h : Declaration of the CDVBSLocator
// Copyright (c) Microsoft Corporation 2000.

#ifndef __DVBSLOCATOR_H_
#define __DVBSLOCATOR_H_

#pragma once

#include <objectwithsiteimplsec.h>
#include "DVBSlocatorimpl.h"

/////////////////////////////////////////////////////////////////////////////
// CDVBSLocator
class ATL_NO_VTABLE __declspec(uuid("1DF7D126-4050-47f0-A7CF-4C4CA9241333"))CDVBSLocator : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CDVBSLocator, &CLSID_DVBSLocator>,
    public IObjectWithSiteImplSec<CDVBSLocator>,
	public IDVBSLocatorImpl<CDVBSLocator>,
	public ISupportErrorInfo
{
public:
    CDVBSLocator() : m_bRequiresSave(false)
	{
	}

REGISTER_AUTOMATION_OBJECT_WITH_TM(IDS_REG_TUNEROBJ, 
						   IDS_REG_DVBSLOCATOR_PROGID, 
						   IDS_REG_DVBSLOCATOR_DESC,
						   LIBID_TunerLib,
						   CLSID_DVBSLocator, tvBoth);

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDVBSLocator)
	COM_INTERFACE_ENTRY(IDVBSLocator)
	COM_INTERFACE_ENTRY(ILocator)
	COM_INTERFACE_ENTRY(IPersistPropertyBag)
	COM_INTERFACE_ENTRY(IPersist)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectWithSite)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP_WITH_FTM()

	BEGIN_CATEGORY_MAP(CDVBSLocator)
		IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
		IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
		IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
	END_CATEGORY_MAP()

public:

    bool m_bRequiresSave;
    BEGIN_PROP_MAP(CDVBSLocator)
        CHAIN_PROP_MAP(IDVBSLocatorImpl<CDVBSLocator>)
    END_PROPERTY_MAP()


// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

};

typedef CComQIPtr<IDVBSLocator> PQDVBSLocator;

#endif //__DVBSLOCATOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\dvbsts.h ===
/////////////////////////////////////////////////////////////////////////////////////
// DVBSTS.h : Declaration of the CDVBSTS
// Copyright (c) Microsoft Corporation 1999.

#ifndef __DVBSTS_H_
#define __DVBSTS_H_

#pragma once

#include <objectwithsiteimplsec.h>
#include "dvbstsimpl.h"

/////////////////////////////////////////////////////////////////////////////
// CDVBSTS
class ATL_NO_VTABLE __declspec(uuid("B64016F3-C9A2-4066-96F0-BD9563314726")) CDVBSTS : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CDVBSTS, &__uuidof(CDVBSTS)>,
    public IObjectWithSiteImplSec<CDVBSTS>,
	public IDVBSTuningSpaceImpl<CDVBSTS>
{
public:
    CDVBSTS() : m_bRequiresSave(false)
	{
	}

REGISTER_AUTOMATION_OBJECT_WITH_TM(IDS_REG_TUNEROBJ, 
						   IDS_REG_DVBSTUNINGSPACE_PROGID, 
						   IDS_REG_DVBSTUNINGSPACE_DESC,
						   LIBID_TunerLib,
						   __uuidof(CDVBSTS), tvBoth);

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDVBSTS)
    COM_INTERFACE_ENTRY(IDVBSTuningSpace)
    COM_INTERFACE_ENTRY(IDVBTuningSpace2)
    COM_INTERFACE_ENTRY(IDVBTuningSpace)
    COM_INTERFACE_ENTRY(ITuningSpace)
    COM_INTERFACE_ENTRY(IObjectWithSite)
	COM_INTERFACE_ENTRY(IPersistPropertyBag)
	COM_INTERFACE_ENTRY(IPersist)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IMPEG2TuneRequestSupport)
END_COM_MAP_WITH_FTM()

	BEGIN_CATEGORY_MAP(CDVBSTS)
		IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
		IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
		IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
	END_CATEGORY_MAP()

public:

    typedef IDVBSTuningSpaceImpl<CDVBSTS> basetype;
    bool m_bRequiresSave;
    BEGIN_PROP_MAP(CDVBSTS)
        CHAIN_PROP_MAP(basetype)
    END_PROPERTY_MAP()

};

#endif //__DVBSTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\dvbslocator.cpp ===
/////////////////////////////////////////////////////////////////////////////////////
// DVBSLocator.cpp : Implementation of CDVBSLocator
// Copyright (c) Microsoft Corporation 1999-2000.

#include "stdafx.h"
#include "Tuner.h"
#include "DVBSLocator.h"

DEFINE_EXTERN_OBJECT_ENTRY(CLSID_DVBSLocator, CDVBSLocator)

/////////////////////////////////////////////////////////////////////////////
// CDVBSLocator

STDMETHODIMP CDVBSLocator::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IDVBSLocator
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\dvbtlocator.cpp ===
/////////////////////////////////////////////////////////////////////////////////////
// DVBTLocator.cpp : Implementation of CDVBTLocator
// Copyright (c) Microsoft Corporation 1999-2000.

#include "stdafx.h"
#include "Tuner.h"
#include "DVBTLocator.h"

DEFINE_EXTERN_OBJECT_ENTRY(CLSID_DVBTLocator, CDVBTLocator)

/////////////////////////////////////////////////////////////////////////////
// CDVBTLocator

STDMETHODIMP CDVBTLocator::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IDVBTLocator
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\dvbtlocator.h ===
/////////////////////////////////////////////////////////////////////////////////////
// DVBTLocator.h : Declaration of the CDVBTLocator
// Copyright (c) Microsoft Corporation 2000.

#ifndef __DVBTLOCATOR_H_
#define __DVBTLOCATOR_H_

#pragma once

#include <objectwithsiteimplsec.h>
#include "DVBTlocatorimpl.h"

/////////////////////////////////////////////////////////////////////////////
// CDVBTLocator
class ATL_NO_VTABLE __declspec(uuid("9CD64701-BDF3-4d14-8E03-F12983D86664"))CDVBTLocator : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CDVBTLocator, &CLSID_DVBTLocator>,
    public IObjectWithSiteImplSec<CDVBTLocator>,
	public IDVBTLocatorImpl<CDVBTLocator>,
	public ISupportErrorInfo
{
public:
    CDVBTLocator() : m_bRequiresSave(false)
	{
	}

REGISTER_AUTOMATION_OBJECT_WITH_TM(IDS_REG_TUNEROBJ, 
						   IDS_REG_DVBTLOCATOR_PROGID, 
						   IDS_REG_DVBTLOCATOR_DESC,
						   LIBID_TunerLib,
						   CLSID_DVBTLocator, tvBoth);

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDVBTLocator)
	COM_INTERFACE_ENTRY(IDVBTLocator)
	COM_INTERFACE_ENTRY(ILocator)
	COM_INTERFACE_ENTRY(IPersistPropertyBag)
	COM_INTERFACE_ENTRY(IPersist)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectWithSite)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP_WITH_FTM()

	BEGIN_CATEGORY_MAP(CDVBTLocator)
		IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
		IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
		IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
	END_CATEGORY_MAP()

public:

    bool m_bRequiresSave;
    BEGIN_PROP_MAP(CDVBTLocator)
        CHAIN_PROP_MAP(IDVBTLocatorImpl<CDVBTLocator>)
    END_PROPERTY_MAP()

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

};

typedef CComQIPtr<IDVBTLocator> PQDVBTLocator;

#endif //__DVBTLOCATOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\dvbts.h ===
/////////////////////////////////////////////////////////////////////////////////////
// DVBTS.h : Declaration of the CDVBTS
// Copyright (c) Microsoft Corporation 1999.

#ifndef __DVBTS_H_
#define __DVBTS_H_

#pragma once

#include <objectwithsiteimplsec.h>
#include "dvbtsimpl.h"

/////////////////////////////////////////////////////////////////////////////
// CDVBTS
class ATL_NO_VTABLE __declspec(uuid("C6B14B32-76AA-4a86-A7AC-5C79AAF58DA7")) CDVBTS : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CDVBTS, &__uuidof(CDVBTS)>,
    public IObjectWithSiteImplSec<CDVBTS>,
	public IDVBTuningSpaceImpl<CDVBTS>
{
public:
    CDVBTS() : m_bRequiresSave(false)
	{
	}

REGISTER_AUTOMATION_OBJECT_WITH_TM(IDS_REG_TUNEROBJ, 
						   IDS_REG_DVBTUNINGSPACE_PROGID, 
						   IDS_REG_DVBTUNINGSPACE_DESC,
						   LIBID_TunerLib,
						   __uuidof(CDVBTS), tvBoth);

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDVBTS)
    COM_INTERFACE_ENTRY(IDVBTuningSpace2)
    COM_INTERFACE_ENTRY(IDVBTuningSpace)
    COM_INTERFACE_ENTRY(ITuningSpace)
	COM_INTERFACE_ENTRY(IPersistPropertyBag)
	COM_INTERFACE_ENTRY(IPersist)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectWithSite)
	COM_INTERFACE_ENTRY(IMPEG2TuneRequestSupport)
END_COM_MAP_WITH_FTM()

	BEGIN_CATEGORY_MAP(CDVBTS)
		IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
		IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
		IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
	END_CATEGORY_MAP()

public:

    typedef IDVBTuningSpaceImpl<CDVBTS> basetype;
    bool m_bRequiresSave;
    BEGIN_PROP_MAP(CDVBTS)
        CHAIN_PROP_MAP(basetype)
    END_PROPERTY_MAP()

};

#endif //__DVBTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\dvbtunerequest.h ===
/////////////////////////////////////////////////////////////////////////////////////
// DVBTuneRequest.h : Declaration of the CDVBTuneRequest
// Copyright (c) Microsoft Corporation 1999.

#ifndef __DVBTUNEREQUEST_H_
#define __DVBTUNEREQUEST_H_

#pragma once

#include <objectwithsiteimplsec.h>
#include "dvbtunerequestimpl.h"

typedef CComQIPtr<IDVBTuneRequest> PQDVBTuneRequest;

/////////////////////////////////////////////////////////////////////////////
// CDVBTuneRequest
class ATL_NO_VTABLE CDVBTuneRequest : 
	public CComObjectRootEx<CComMultiThreadModel>,
    public IObjectWithSiteImplSec<CDVBTuneRequest>,
	public IDVBTuneRequestImpl<CDVBTuneRequest>,
	public CComCoClass<CDVBTuneRequest, &CLSID_DVBTuneRequest>,
	public ISupportErrorInfo
{
public:

	CDVBTuneRequest() {}

REGISTER_AUTOMATION_OBJECT_WITH_TM(IDS_REG_TUNEROBJ, 
						   IDS_REG_DVBTUNEREQUEST_PROGID, 
						   IDS_REG_DVBTUNEREQUEST_DESC,
						   LIBID_TunerLib,
						   CLSID_DVBTuneRequest, tvBoth);

BEGIN_COM_MAP(CDVBTuneRequest)
	COM_INTERFACE_ENTRY(IDVBTuneRequest)
	COM_INTERFACE_ENTRY(ITuneRequest)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectWithSite)
	COM_INTERFACE_ENTRY(IPersist)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IPersistPropertyBag)
END_COM_MAP_WITH_FTM()

	BEGIN_CATEGORY_MAP(CDVBTuneRequest)
		IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
		IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
		IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
	END_CATEGORY_MAP()

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    typedef IDVBTuneRequestImpl<CDVBTuneRequest> basetype;
    BEGIN_PROP_MAP(CDVBTuneRequest)
        CHAIN_PROP_MAP(basetype)
    END_PROP_MAP()


};

#endif //__DVBTUNEREQUEST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\dvbtunerequest.cpp ===
/////////////////////////////////////////////////////////////////////////////////////
// DVBTuneRequest.cpp : Implementation of CDVBTuneRequest
// Copyright (c) Microsoft Corporation 1999-2000.

#include "stdafx.h"
#include "Tuner.h"
#include "DVBTuneRequest.h"

DEFINE_EXTERN_OBJECT_ENTRY(CLSID_DVBTuneRequest, CDVBTuneRequest)

/////////////////////////////////////////////////////////////////////////////
// CDVBTuneRequest

STDMETHODIMP CDVBTuneRequest::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IDVBTuneRequest
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\fileplaybackcp.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#ifndef _MSVIDFILEPLAYBACKCP_H_
#define _MSVIDFILEPLAYBACKCP_H_

template <class T, const IID* piid = &IID_IMSVidFilePlaybackEvent, class CDV = CComDynamicUnkArray>
class CProxy_FilePlaybackEvent : public CProxy_PlaybackEvent<T, piid, CDV>
{
public:

// TODO: add fileplayback specific events here	
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\factoryhelp.h ===
//==========================================================================;
//
// Copyright (c) Microsoft Corporation 1999-2000.
//
//--------------------------------------------------------------------------;
//
// factoryhelp.h - helper class for creating vidctl instances from a variety of factories including element
// behavior factories and pluggable protocols

#include "atlbase.h"

typedef CComQIPtr<ICreatePropBagOnRegKey> PQCreatePropBagOnRegKey;
typedef CComQIPtr<IWebBrowserApp> PQWebBrowserApp;
typedef CComQIPtr<IWebBrowser2> PQWebBrowser2;

#define RBFACTORY_DEFAULT_KEY OLESTR("Software\\Microsoft\\MSVidCtl")
#define PROPNAME_DEFAULT_TR OLESTR("DefaultTuneRequest")

LPCOLESTR __declspec(selectany) BIND_TO_OBJ_VAL = OLESTR("TRUE");
LPOLESTR __declspec(selectany) KEY_CLSID_VidCtl = OLESTR("B0EDF163-910A-11D2-B632-00C04F79498E");
LPCOLESTR __declspec(selectany) TVPROT_SCHEME_NAME = OLESTR("tv");
LPCOLESTR __declspec(selectany) DVDPROT_SCHEME_NAME = OLESTR("dvd");

class CFactoryHelper {
public:
    static CComVariant GetDefaultTR() {
	    PQPropertyBag pBag;
	    PQCreatePropBagOnRegKey pCreateBag(CLSID_CreatePropBagOnRegKey, NULL, CLSCTX_INPROC_SERVER);
	    if (!pCreateBag) {
		    TRACELM(TRACE_ERROR, "can't create prop bag");
		    return CComVariant();
	    }
	    HRESULT hr = pCreateBag->Create(HKEY_CURRENT_USER, RBFACTORY_DEFAULT_KEY, 0, KEY_READ, IID_IPropertyBag, reinterpret_cast<LPVOID *>(&pBag));
	    if (FAILED(hr)) {
		    TRACELSM(TRACE_ERROR, (dbgDump << "No Default Tune Request Key Present.  hr = " << hr), "");
		    return CComVariant();
	    }
	    CComVariant pVar;
	    hr = pBag->Read(PROPNAME_DEFAULT_TR, &pVar, NULL);
	    if (FAILED(hr) || (pVar.vt != VT_UNKNOWN && pVar.vt != VT_DISPATCH)) {
		    TRACELSM(TRACE_ERROR, (dbgDump << "No Default Tune Request Property Present.  hr = " << hr), "");
		    return CComVariant();
	    }
	    PQTuningSpace pts;
	    PQTuneRequest ptr(pVar.vt == VT_UNKNOWN ? pVar.punkVal : pVar.pdispVal);
	    if (!ptr) {
		    TRACELSM(TRACE_ERROR, (dbgDump << PROPNAME_DEFAULT_TR << " not a tune request"), "");
		    return CComVariant();
	    }
	    hr = ptr->get_TuningSpace(&pts);
	    if (FAILED(hr) || !pts) {
		    TRACELSM(TRACE_ERROR, (dbgDump << "Can't get ts from tr " << hr), "");
		    return CComVariant();
	    }
	    
	    return pVar;
    }
};

// end of file factoryhelp.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\dvdprot.cpp ===
//==========================================================================;
//
// Copyright (c) Microsoft Corporation 1998-2000.
//
//--------------------------------------------------------------------------;
//
// dvdprot.cpp : Implementation of CDVDProt
//
//
//
// URL ::= DVD | DVD:[//<path>?] [<address>]
// address ::= <title> | <title>/<chapter>[-<end_chapter>] | <title>/<time>[-<end_time>]
// path ::= <unc_path> | <drive_letter>:/<directory_path>
// title ::= [digit] digit
// chapter ::= [ [digit] digit] digit
// time ::= [<hours>:] [<minutes>:] [<seconds>:] <frames>
// hours := [digit | 0]  digit
// minutes:= [digit | 0]  digit
// seconds:= [digit | 0]  digit
// frames:= [digit | 0]  digit
//
// DVD:                  play first DVD found, enumerating from drive D:
// DVD:2                 play title 2 (in first DVD found)
// DVD:5/13              play chapter 13 of title 5 (in first DVD found)
// DVD:7/9:05-13:23      play from 7 seconds 5 frames to 13 seconds 23 frames in title 7
// DVD:7/00:00:12:05-00:00:17:23 (strict version of timecode)
// DVD://myshare/dvd?9   play title 9 from the DVD-Video volume stored in the dvd directory of share
// DVD://f:/video_ts     play the DVD-Video volume in the video_ts directory of drive F:


#include "stdafx.h"

#ifndef TUNING_MODEL_ONLY

#include "devices.h"
#include "msvidwebdvd.h"
#include "vidprot.h"

#define MAX_FIELDS 10

HRESULT CMSVidWebDVD::ParseDVDPath(LPWSTR pPath)
{
    WCHAR wsUncPath[MAX_PATH];
	int nFields, i;
    DVD_HMSF_TIMECODE tc;
    BSTR bstrTime = NULL;
    BSTR bstrEndTime = NULL;
	long Fields[MAX_FIELDS];
	long Delimiters[MAX_FIELDS];
    HRESULT hr = S_OK;

    // recognize "DVD:" at the beginning of string
    // note: we also allow "DVD" for compatibility with old code

    if (!pPath)
    {
        return E_INVALIDARG;
    }

    if (_wcsicmp(pPath, L"DVD") == 0)
    {
        pPath += 3;
    }
    else if (_wcsnicmp(pPath, L"DVD:", 4) == 0)
    {
        pPath += 4;
    }
    else
    {
        return E_INVALIDARG;
    }

    // determine if a unc path follows (starts with "//")

    if (wcsncmp(pPath, L"//", 2) == 0)
    {
        // determine if it is followed by a share name or a drive letter
        if (iswalpha(pPath[2]) && pPath[3] == L':')
        {
            // filter out the two foward slashes in front of drive letter
            pPath += 2;
        }

        // copy over the remaining unc path
        if(wcslen(pPath) >= MAX_PATH){
            // pPath is longer than wsUncPath so it will be truncated
        }
        // Could chop off a char if wsclen(pPath) == MAX_PATH
        lstrcpyn(wsUncPath, pPath, MAX_PATH);

        // search for the ending '?'; replacing forward slash with backslash
        i = 0;
        while (wsUncPath[i] != L'?' && wsUncPath[i] != 0)
        {
            if (wsUncPath[i] == L'/')
            {
                wsUncPath[i] = L'\\';
            }

            i++;
        }

        if (wsUncPath[i] == L'?')
        {
            // replace ? with NULL to truncate the rest of the string
            wsUncPath[i] = 0;
            pPath += i+1; // advance pointer pass the ?
        }
        else
        {
            // the entire string is the unc without the ?
            // advance pointer so that it points to the NULL

            pPath += i;
        }

        // append VIDEO_TS directory if only the drive is given
        // wsUncPath is an array of WCHARs MAX_PATH in length
        if (wcslen(wsUncPath) == 2 && iswalpha(wsUncPath[0]) && wsUncPath[1] == L':')
        {
            (void)StringCchCat(wsUncPath, SIZEOF_CH(wsUncPath), L"\\video_ts");
            //wcscat(wsUncPath, L"\\video_ts");
        }
      
        // save the path to dvd directory

        if (m_urlInfo.bstrPath != NULL)
        {
            SysFreeString(m_urlInfo.bstrPath);
        }
        m_urlInfo.bstrPath = SysAllocString(wsUncPath);
    }

	// if no title or chapter is set, let it play with default settings

	if (*pPath == 0)
	{
		return hr;
	}

    // parse address section
    // address ::= <title> | <title>/<chapter>[-<end_chapter>] | <title>/<time>[-<end_time>]

    // fetch a two-digit title number
    m_urlInfo.lTitle = ParseNumber(pPath);

    // retrieve all the numerical fields and Delimiters

    nFields = 0;
    while (nFields < MAX_FIELDS && *pPath != 0)
    {
        Delimiters[nFields] = *pPath++;
        Fields[nFields] = ParseNumber(pPath);
        nFields++;
    }

    // analyze the fields

    // find if there is a '-' with and ending chapter/time, and ':' indicating time

    int nPosHyphen = nFields;
    bool fEndSpecified = false;
    bool fTimeSpecified = false;

    for (i=0; i<nFields; i++)
    {
        if (L'-' == Delimiters[i])
        {
            nPosHyphen = i;
            fEndSpecified = true;
        }

        if (L':' == Delimiters[i])
        {
            fTimeSpecified = true;
        }
    }

    // title

    if (nFields == 0)
    {
        // title is specified, but no starting chapter or time

        m_urlInfo.enumRef = DVD_Playback_Title;
    }
    else
    {
        if (Delimiters[0] != L'/')
        {
            return E_INVALIDARG;
        }

        if (fTimeSpecified)
        {
            // get start time
            // make sure there are 1 to 4 time fields
            if (nPosHyphen < 1 || nPosHyphen > 4)
            {
                return E_INVALIDARG;
            }
            else
            {
                for (i=1; i < nPosHyphen; i++)
                {
                    if (Delimiters[i] != L':')
                    {
                        return E_INVALIDARG;
                    }
                }

                tc.bHours = 0;
                tc.bMinutes = 0;
                tc.bSeconds = 0;
                tc.bFrames = 0;

                // fill up to 4 fields
                // shifting values from the lower field up
                for (i=0; i < nPosHyphen; i++)
                {
                    tc.bHours = tc.bMinutes;
                    tc.bMinutes = tc.bSeconds;
                    tc.bSeconds = tc.bFrames;
                    tc.bFrames = Fields[i];
                }

                m_urlInfo.ulTime = *(ULONG *)(&tc);
            }

            // end time
            if (fEndSpecified)
            {
                // make sure there are 1 to 4 time fields
                if (nFields-nPosHyphen < 1 || nFields-nPosHyphen > 4)
                {
                    return E_INVALIDARG;
                }
                else
                {
                    for (i=nPosHyphen+1; i < nFields; i++)
                    {
                        if (Delimiters[i] != L':')
                        {
                            return E_INVALIDARG;
                        }
                    }

                    tc.bHours = 0;
                    tc.bMinutes = 0;
                    tc.bSeconds = 0;
                    tc.bFrames = 0;

                    for (i=nPosHyphen; i < nFields; i++)
                    {
                        tc.bHours = tc.bMinutes;
                        tc.bMinutes = tc.bSeconds;
                        tc.bSeconds = tc.bFrames;
                        tc.bFrames = Fields[i];
                    }

                    m_urlInfo.ulEndTime = *(ULONG *)(&tc);
                    m_urlInfo.enumRef = DVD_Playback_Time_Range;
                }
            }
            else
            {
                // only start time specified, no end time

                m_urlInfo.enumRef = DVD_Playback_Time;
            }
        }
        else
        {
            // chapter specified
            if (nPosHyphen != 1)
            {
                return E_INVALIDARG;
            }

            m_urlInfo.lChapter = Fields[0];

            if (fEndSpecified)
            {
                if (nFields-nPosHyphen != 1)
                {
                    return E_INVALIDARG;
                }

                m_urlInfo.lEndChapter = Fields[1];

                if (m_urlInfo.lEndChapter < m_urlInfo.lChapter)
                {
                    return E_INVALIDARG;
                }

                m_urlInfo.enumRef = DVD_Playback_Chapter_Range;
            }
            else
            {
                m_urlInfo.enumRef = DVD_Playback_Chapter;
            }
        }
    }

	return hr;
}


void CMSVidWebDVD::DeleteUrlInfo()
{
    if (m_urlInfo.bstrPath != NULL)
    {
        SysFreeString(m_urlInfo.bstrPath);
    }
    ZeroMemory(&m_urlInfo, sizeof(m_urlInfo));

    m_fUrlInfoSet = false;
}


HRESULT CMSVidWebDVD::SetPlaybackFromUrlInfo()
{
    HRESULT hr = S_OK;
    BSTR bstrTime, bstrEndTime;

    if (!m_fUrlInfoSet)
    {
        return S_OK;
    }

    // clear this flag to prevent this function to be called recursively
    m_fUrlInfoSet = false;
    
    switch (m_urlInfo.enumRef)
    {
    case DVD_Playback_Title:
        hr = PlayTitle(m_urlInfo.lTitle);
        break;

    case DVD_Playback_Chapter:
        hr = PlayChapterInTitle(m_urlInfo.lTitle, m_urlInfo.lChapter);
        break;

    case DVD_Playback_Chapter_Range:
        hr = PlayChaptersAutoStop(m_urlInfo.lTitle, m_urlInfo.lChapter, 
                                  m_urlInfo.lEndChapter-m_urlInfo.lChapter+1);
        break;

    case DVD_Playback_Time:
        DVDTime2bstr((DVD_HMSF_TIMECODE *)&(m_urlInfo.ulTime), &bstrTime);
        hr = PlayAtTimeInTitle(m_urlInfo.lTitle, bstrTime);
        SysFreeString(bstrTime);
        break;

    case DVD_Playback_Time_Range:
        DVDTime2bstr((DVD_HMSF_TIMECODE *)&(m_urlInfo.ulTime), &bstrTime);
        DVDTime2bstr((DVD_HMSF_TIMECODE *)&(m_urlInfo.ulEndTime), &bstrEndTime);
        hr = PlayPeriodInTitleAutoStop(m_urlInfo.lTitle, bstrTime, bstrEndTime);
        SysFreeString(bstrTime);
        SysFreeString(bstrEndTime);
        break;

    default:
        // just let play with the default settings
        break;
    }

    // once the urlInfo has been applied, clear the urlInfo
    DeleteUrlInfo();

    return hr;
}


HRESULT CMSVidWebDVD::SetDirectoryFromUrlInfo()
{
    HRESULT hr = S_OK;
    if (!m_fUrlInfoSet || !(m_urlInfo.bstrPath) )
    {
        return hr;
    }

    hr = put_DVDDirectory(m_urlInfo.bstrPath);

    // clear up the path to prevent this function to be called recursively
    SysFreeString(m_urlInfo.bstrPath);
    m_urlInfo.bstrPath.Empty();

    return hr;
}


// fetch a positive integer from string p, upto nMaxDigits or until a non-digit char is reached
// unlimited nubmer of digits if 0 is passed in nMaxDigits
// advance the the pointer p by the number of chars interpreted.
// it would return 0 if no digit present

int CMSVidWebDVD::ParseNumber(LPWSTR& p, int nMaxDigits)
{
    int nDigits = 0;
    int nNumber = 0;

    while ((nDigits < nMaxDigits || nMaxDigits <= 0) && iswdigit(*p))
    {
        nNumber = nNumber * 10 + (*p - L'0');
        p++;
        nDigits++;
    }
        
    return nNumber;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CDVDProt
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CDVDProt -- IInternetProtocolRoot
STDMETHODIMP CDVDProt::Start(LPCWSTR szUrl,
				IInternetProtocolSink* pOIProtSink,
				IInternetBindInfo* pOIBindInfo,
				DWORD grfPI,
				HANDLE_PTR /* dwReserved */)
{
    TRACELM(TRACE_DEBUG, "CDVDProt::Start()");
    if (!pOIProtSink)
    {
        TRACELM(TRACE_DEBUG, "CDVDProt::Start() IInternetProctocolSink * == NULL");
	    return E_POINTER;
    }
    m_pSink.Release();
    m_pSink = pOIProtSink;
    m_pSink->ReportData(BSCF_FIRSTDATANOTIFICATION, 0, 0);
#if 0
	// this bug is fixed in ie 5.5+ on whistler.  if you want to run on earlier versions of ie such as 2k gold then you need this.
	m_pSink->ReportProgress(BINDSTATUS_CONNECTING, NULL);  // put binding in downloading state so it doesn't ignore our IUnknown*
#endif

	if (!pOIBindInfo) {
		m_pSink->ReportResult(E_NOINTERFACE, 0, 0);
		return E_NOINTERFACE;
	}
    // don't run unless we're being invoked from a safe site
    HRESULT hr = IsSafeSite(m_pSink);
    if (FAILED(hr)) {
	    m_pSink->ReportResult(hr, 0, 0);
		return hr;
    }
	ULONG count;
	LPOLESTR pb;
	hr = pOIBindInfo->GetBindString(BINDSTRING_FLAG_BIND_TO_OBJECT, &pb, 1, &count);
	if (FAILED(hr)) {
	    m_pSink->ReportResult(hr, 0, 0);
		return hr;
	}
	if (wcscmp(pb, BIND_TO_OBJ_VAL)) {
		// we must be getting a bind to storage so skip the expensive stuff and 
		// wait for the bind to object which is coming next
		m_pSink->ReportData(BSCF_LASTDATANOTIFICATION | 
							BSCF_DATAFULLYAVAILABLE, 0, 0);
		m_pSink->ReportResult(S_OK, 0, 0);
		m_pSink.Release();
		return S_OK;
	}

	// and, in one of the most bizarre maneuvers i've ever seen, rather than casting, 
	// urlmon passes back the ascii value of the ibindctx pointer in the string
	hr = pOIBindInfo->GetBindString(BINDSTRING_PTR_BIND_CONTEXT, &pb, 1, &count);
	if (FAILED(hr)) {
	    m_pSink->ReportResult(hr, 0, 0);
		return hr;
	}
	_ASSERT(count == 1);	
	
	PQBindCtx pbindctx;
#define RADIX_BASE_10 (10)
#ifdef _WIN64
#if 0
	// undone: turn this back on for win64 when _wcstoxi64 get into libc.c, they're in the header
	// but not implemented so this doesn't link
	pbindctx.Attach(reinterpret_cast<IBindCtx*>(_wcstoui64(pb, NULL, RADIX_BASE_10)));	// urlmon already did an addref
#else
	swscanf(pb, L"%I64d", &pbindctx.p);
#endif // 0
#else
	pbindctx.Attach(reinterpret_cast<IBindCtx*>(wcstol(pb, NULL, RADIX_BASE_10)));	// urlmon already did an addref
#endif // _WIN64

	if (!pbindctx) {
		m_pSink->ReportResult(E_NOINTERFACE, 0, 0);
		return E_NOINTERFACE;
	}	

    TRACELM(TRACE_DEBUG, "CDVDProt::Start(): creating control object");
	PQVidCtl pCtl;
	PQWebBrowser2 pW2;
	// hunt for cached object
	PQServiceProvider pSP(m_pSink);
	if (pSP) {
		hr = pSP->QueryService(SID_SWebBrowserApp, IID_IWebBrowser2, (LPVOID *)&pW2);
		if (SUCCEEDED(hr)) {
			CComVariant v;
            CComBSTR propname(KEY_CLSID_VidCtl);
            if (!propname) {
                return E_UNEXPECTED;
            }
	        hr = pW2->GetProperty(propname, &v);
			if (SUCCEEDED(hr)) {
				if (v.vt == VT_UNKNOWN) {
					pCtl = v.punkVal;
				} else if (v.vt == VT_DISPATCH) {
					pCtl = v.pdispVal;
				} else {
					TRACELM(TRACE_ERROR, "CDVDProt::Start(): non-object cached w/ our key");
				}
				// undone: look and see if pCtl already has a site.because
				// this means we're seeing the second tv: on this page
				// so just get the current TR/channel from it if necessary (tv: w/ no rhs)
				// and create a new ctl
			}
		}
	}
	if (!pCtl) {
        // undone: long term, we want to move a bunch of this create/setup logic into factoryhelp
        // so we can share more code with the dvd: protocol and the behavior factory
		hr = pCtl.CoCreateInstance(CLSID_MSVidCtl, NULL, CLSCTX_INPROC_SERVER);
		if (FAILED(hr)) {
			m_pSink->ReportResult(hr, 0, 0);
			return hr;
		}
		// cache this ctl for next time
		if (pW2) {
			VARIANT v;
			v.vt = VT_UNKNOWN;
			v.punkVal = pCtl;
            CComBSTR propname(KEY_CLSID_VidCtl);
            if (!propname) {
                return E_UNEXPECTED;
            }
	        hr = pW2->PutProperty(propname, v);
			if (FAILED(hr)) {
				TRACELM(TRACE_ERROR, "CTVProt::Start() Can't cache ctl");
			}
		}

		// pass the url to view, it will be parsed in pCtrl->View()		

        CComVariant vUrl(szUrl);
        hr = pCtl->View(&vUrl);
		if (FAILED(hr)) {
			m_pSink->ReportResult(hr, 0, 0);
			TRACELM(TRACE_ERROR, "CDVDProt::Start() Can't view dvd url");
			return hr;
		}

		// undone: once we know where vidctl will live in the registry then we need to put a flag
		// in the registry just disables including any features in the tv: prot 
		// this must be secured admin only since its a backdoor to disable CA

		// undone: look up default feature segments in registry
		// for now we're just going to take them all since the
		// only one that exists is data

		PQFeatures pF;
		hr = pCtl->get_FeaturesAvailable(&pF);
		if (FAILED(hr)) {
			m_pSink->ReportResult(hr, 0, 0);
			TRACELM(TRACE_ERROR, "CDVDProt::Start() Can't get features collection");
			return hr;
		}

		// undone: look up default feature segments for dvd: in registry
		// for now we're just going to hard code the ones we want

        CFeatures* pC = static_cast<CFeatures *>(pF.p);
        CFeatures* pNewColl = new CFeatures;
        if (!pNewColl) {
            return E_OUTOFMEMORY;
        }
        for (DeviceCollection::iterator i = pC->m_Devices.begin(); i != pC->m_Devices.end(); ++i) {
            PQFeature f(*i);
            GUID2 clsid;
            hr = f->get__ClassID(&clsid);
            if (FAILED(hr)) {
    			TRACELM(TRACE_ERROR, "CTVProt::GetVidCtl() Can't get feature class id");
                continue;
            }
            if (clsid == CLSID_MSVidClosedCaptioning) {
                pNewColl->m_Devices.push_back(*i);
            }
        }
		hr = pCtl->put_FeaturesActive(pNewColl);
		if (FAILED(hr)) {
			m_pSink->ReportResult(hr, 0, 0);
			TRACELM(TRACE_ERROR, "CDVDProt::Start() Can't put features collection");
			return hr;
		}

	}
	ASSERT(pCtl);
	hr = pbindctx->RegisterObjectParam(OLESTR("IUnknown Pointer"), pCtl);
	if (FAILED(hr)) {
	    m_pSink->ReportResult(hr, 0, 0);
		return hr;
	}
	hr = pCtl->Run(); 
	if (FAILED(hr)) {
	    m_pSink->ReportResult(hr, 0, 0);
		return hr;
	}
    TRACELSM(TRACE_DEBUG, (dbgDump << "BINDSTATUS_IUNKNOWNAVAILABLE(29), " << KEY_CLSID_VidCtl), "");
    m_pSink->ReportProgress(BINDSTATUS_IUNKNOWNAVAILABLE, NULL);
    m_pSink->ReportData(BSCF_LASTDATANOTIFICATION | 
			            BSCF_DATAFULLYAVAILABLE, 0, 0);
    m_pSink->ReportResult(S_OK, 0, 0);
    m_pSink.Release();
    return S_OK;
}

#endif // TUNING_MODEL_ONLY
// end of file dvdprot.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\fp2ar.h ===
//==========================================================================;
//
// fp2ar.h : Declaration of the custom composition class for gluing file 
//           playback to the audio renderer
//
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#ifndef FP2ARCOMP_H
#define FP2ARCOMP_H

#pragma once

#include <winerror.h>
#include <algorithm>
#include <compimpl.h>
#include <seg.h>
#include <objectwithsiteimplsec.h>
#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CAnaCapComp
class ATL_NO_VTABLE __declspec(uuid("CC23F537-18D4-4ece-93BD-207A84726979")) CFP2ARComp : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CFP2ARComp, &__uuidof(CFP2ARComp)>,
    public IObjectWithSiteImplSec<CFP2ARComp>,
	public IMSVidCompositionSegmentImpl<CFP2ARComp>
{
public:
    CFP2ARComp() {}
    virtual ~CFP2ARComp() {}

REGISTER_NONAUTOMATION_OBJECT(IDS_PROJNAME, 
						   IDS_REG_FP2ARCOMP_DESC,
						   LIBID_MSVidCtlLib,
						   __uuidof(CFP2ARComp));

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CFP2ARComp)
        COM_INTERFACE_ENTRY(IMSVidCompositionSegment)
    	COM_INTERFACE_ENTRY(IMSVidGraphSegment)
        COM_INTERFACE_ENTRY(IPersist)
        COM_INTERFACE_ENTRY(IObjectWithSite)
    END_COM_MAP()

// IMSVidComposition
public:
// IMSVidGraphSegment
// IMSVidCompositionSegment
    STDMETHOD(Compose)(IMSVidGraphSegment * upstream, IMSVidGraphSegment * downstream)
	{
        TRACELM(TRACE_DEBUG, "CFP2ARComp::Compose()");
        if (m_fComposed) {
            return NOERROR;
        }
        
        ASSERT(m_pGraph);
        try {
            VWGraphSegment up(upstream);
            ASSERT(up.Graph() == m_pGraph);
            VWGraphSegment down(downstream);
            ASSERT(down.Graph() == m_pGraph);
            if (up.begin() == up.end()) {
                TRACELM(TRACE_ERROR, "CFP2ARComp::Compose() can't compose empty up segment");
                return E_INVALIDARG;
            }
            if (down.begin() == down.end()) {
                TRACELM(TRACE_ERROR, "CFP2ARComp::Compose() can't compose empty down segment");
                return E_INVALIDARG;
            }
			DSFilter pFP(*up.begin());
			ASSERT(!!pFP);
            ASSERT(pFP.GetGraph() == m_pGraph);
	
			VWGraphSegment::iterator iAR;
            DSFilter pAR;
			for (iAR = down.begin(); iAR != down.end(); ++iAR) {
                pAR = *iAR;
                if (IsDigitalAudioRenderer(pAR)) {
                    break;
                }
    		}
            if (iAR == down.end()) {
				TRACELM(TRACE_ERROR, "CFP2ARComp::Compose() FAILED to find AR ");
				return E_UNEXPECTED;
            }

			ASSERT(!!pAR);
            ASSERT(pAR.GetGraph() == m_pGraph);
            HRESULT hr = m_pGraph.Connect(pFP, pAR, m_Filters,
                                          DSGraph::ALLOW_WILDCARDS | 
                                          DSGraph::DONT_TERMINATE_ON_RENDERER |
                                          DSGraph::IGNORE_MEDIATYPE_ERRORS, 
                                          DOWNSTREAM);
            if (FAILED(hr)) {
				TRACELSM(TRACE_ERROR, (dbgDump << "CFP2ARComp::Compose() FAILED connect hr = " << hexdump(hr)), "");
				return hr;
            }

            m_fComposed = true;
            return NOERROR;
        } catch (ComException &e) {
            return e;
        } catch (...) {
            return E_UNEXPECTED;
        }
	}
};

#endif // FP2ARCOMP_H
// end of file - FP2ARComp.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\enc2sin.h ===
//==========================================================================;
//
// Composition.h : Declaration of the custom composition class for gluing encoder to sbe sink
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#ifndef ENC2SIN_H
#define ENC2SIN_H

#pragma once
#include <uuids.h>
#include "bdamedia.h"
#include "MSVidTVTuner.h"
#include "resource.h"       // main symbols
#include <winerror.h>
#include <algorithm>
#include <compimpl.h>
#include <seg.h>
#include <objectwithsiteimplsec.h>
#include "msvidsbesource.h"
#include "segment.h"

/////////////////////////////////////////////////////////////////////////////
// Helper functions
HRESULT CheckIfSecureClient(IUnknown *pUnk){
        if(!pUnk){ 
            TRACELM(TRACE_ERROR, "CAnaSinComp::CheckIfSecureClient NULL pointer");
            return E_POINTER;
        }
#ifndef BUILD_WITH_DRM
        TRACELM(TRACE_ERROR, "CAnaSinComp::CheckIfSecureClient BUILD_WITH_DRM = false");
        return S_OK;

#else

#ifdef USE_TEST_DRM_CERT
        {
            DWORD dwDisableDRMCheck = 0;
            CRegKey c;
            CString keyname(_T("SOFTWARE\\Debug\\MSVidCtl"));
            DWORD rc = c.Open(HKEY_LOCAL_MACHINE, keyname, KEY_READ);
            if (rc == ERROR_SUCCESS) {
                rc = c.QueryValue(dwDisableDRMCheck, _T("DisableDRMCheck"));
                if (rc != ERROR_SUCCESS) {
                    dwDisableDRMCheck = 0;
                }
            }

            if(dwDisableDRMCheck == 1){
                return S_OK;
            }
        }
#endif
        // QI for the SecureChannel interface on the Punk 
        // (hopefully the ETFilter)
        HRESULT hr = S_OK;
        CComQIPtr<IDRMSecureChannel> spSecureClient(pUnk);
        if (!spSecureClient) {
            TRACELM(TRACE_ERROR, "CAnaSinComp::CheckIfSecureClient Passed in pUnk doesnt support IDRMSecureChannel");
            // Error: Passed in pUnk doesnt support IDRMSecureChannel
            return E_NOINTERFACE;
        }

        // Create the Server side and Init the keys/certs
        CComPtr<IDRMSecureChannel>  spSecureServer; 
        hr = DRMCreateSecureChannel( &spSecureServer);
        if(spSecureServer == NULL ){
            TRACELM(TRACE_ERROR, "CAnaSinComp::CheckIfSecureClient Cannot create secure server");
            return E_OUTOFMEMORY;
        }

        hr = spSecureServer->DRMSC_AtomicConnectAndDisconnect(
            (BYTE *)pabCert2, cBytesCert2,                             // Cert
            (BYTE *)pabPVK2,  cBytesPVK2,                              // PrivKey
            (BYTE *)abEncDecCertRoot, sizeof(abEncDecCertRoot),        // PubKey
            spSecureClient);
        if(FAILED(hr)){
            TRACELM(TRACE_ERROR, "CAnaSinComp::CheckIfSecureClient DRMSC_AtomicConnectAndDisconnect failed " << hr);
        }
        else{
            TRACELM(TRACE_ERROR, "CAnaSinComp::CheckIfSecureClient DRMSC_AtomicConnectAndDisconnect Succeeded");
        }
        return hr;

#endif  // BUILD_WITH_DRM

    }

/////////////////////////////////////////////////////////////////////////////
// CEnc2SinComp
class ATL_NO_VTABLE __declspec(uuid("A0B9B497-AFBC-45ad-A8A6-9B077C40D4F2")) CEnc2SinComp : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CEnc2SinComp, &__uuidof(CEnc2SinComp)>,
    public IObjectWithSiteImplSec<CEnc2SinComp>,
    public IMSVidCompositionSegmentImpl<CEnc2SinComp>
{
private:
    DSFilterList m_pEncFilters;
public:
    CEnc2SinComp() {}
    virtual ~CEnc2SinComp() {}
    
    REGISTER_NONAUTOMATION_OBJECT(IDS_PROJNAME, 
        IDS_REG_ENC2SINCOMP_DESC,
        LIBID_MSVidCtlLib,
        __uuidof(CEnc2SinComp));
    
    DECLARE_PROTECT_FINAL_CONSTRUCT()
        
    BEGIN_COM_MAP(CEnc2SinComp)
        COM_INTERFACE_ENTRY(IMSVidCompositionSegment)
        COM_INTERFACE_ENTRY(IMSVidGraphSegment)
        COM_INTERFACE_ENTRY(IObjectWithSite)
        COM_INTERFACE_ENTRY(IPersist)
    END_COM_MAP()
        
        // IMSVidComposition
public:
    // IMSVidGraphSegment
    // IMSVidCompositionSegment
    STDMETHOD(CheckEncFilters)(){
        int j = 0;
        for(DSFilterList::iterator i = m_pEncFilters.begin(); i != m_pEncFilters.end(); ++i){
            TRACELM(TRACE_ERROR, "CAnaSinComp::CheckEncFilters checking filter " << j);
            CComQIPtr<IETFilterConfig> spETConfig;
            CComPtr<IUnknown> spUnkSecChan;
            spETConfig = (*i);
            if(!spETConfig){
                TRACELM(TRACE_ERROR, "CAnaSinComp::CheckEncFilters filter " << j << " could not get et filter config interface");
				return E_NOINTERFACE;
			}            
            HRESULT hr = spETConfig->GetSecureChannelObject(&spUnkSecChan);   
            hr = CheckIfSecureClient(spUnkSecChan);
            if(FAILED(hr)){
                TRACELM(TRACE_ERROR, "CAnaSinComp::CheckEncFilters filter " << j << " Failed");
                return E_FAIL;
            }
            ++j;
        }
        TRACELM(TRACE_ERROR, "CAnaSinComp::CheckEncFilters no failures");
        return NOERROR;
    }

    STDMETHOD(PreRun)(){
        return CheckEncFilters();
    }

    STDMETHOD(OnEventNotify)(long lEvent, LONG_PTR lParam1, LONG_PTR lParam2){
        if (lEvent == EC_STATE_CHANGE && lParam1 == State_Running) {
            TRACELM(TRACE_ERROR, "CAnaSinComp::OnEventNotify State_Running Event");
            HRESULT hr = CheckEncFilters();
            if(FAILED(hr)){
                TRACELM(TRACE_ERROR, "CAnaSinComp::OnEventNotify CheckEncFilters Failed");
                // need to throw a cert failure
                CComQIPtr<IMSVidCtl> pq_vidCtl;
                if(!m_pContainer){
                    return S_OK;
                }
                else{
                    hr = m_pContainer->QueryInterface(IID_IMSVidCtl, reinterpret_cast<void**>(&pq_vidCtl));
                    if(SUCCEEDED(hr) && pq_vidCtl){
                        pq_vidCtl->Stop();
                    }
                    CComQIPtr<IMSVidStreamBufferSinkEvent>pq_SBESink;
                    VWOutputDevices pq_dev;
                    hr = pq_vidCtl->get_OutputsActive(&pq_dev);
                    if(FAILED(hr)){
                        return hr;
                    }
                    VWOutputDevices::iterator i;
                    for(i = pq_dev.begin(); i != pq_dev.end(); ++i){
                        pq_SBESink = (*i).punkVal;
                        if(pq_SBESink){
                            break;
                        }
                    }

                    if(i != pq_dev.end() && pq_SBESink){
                        pq_SBESink->CertificateFailure();
                    }
                }
            }
        }
        return E_NOTIMPL;
    }
    STDMETHOD(put_Container)(IMSVidGraphSegmentContainer *pCtl) {
        try {
            if (!pCtl) {
                m_pEncFilters.clear();
                return Unload();
            }
            if (m_pContainer) {
				if (!m_pContainer.IsEqualObject(VWSegmentContainer(pCtl))) {
					//undone: support moving to different graph
					return Error(IDS_OBJ_ALREADY_INIT, __uuidof(IMSVidGraphSegment), CO_E_ALREADYINITIALIZED);
				} else {
					return NO_ERROR;
				}
            }
            // DON'T addref the container.  we're guaranteed nested lifetimes
            // and an addref creates circular refcounts so we never unload.
            m_pContainer.p = pCtl;
            m_pGraph = m_pContainer.GetGraph();
        } catch(...) {
            return E_UNEXPECTED;
        }
		return NOERROR;
	}
    STDMETHOD(Compose)(IMSVidGraphSegment * upstream, IMSVidGraphSegment * downstream)
    {
        if (m_fComposed) {
            return NOERROR;
        }
        ASSERT(m_pGraph);
        try {
            VIDPERF_FUNC;
            TRACELM(TRACE_DETAIL, "CAnaSinComp::Compose()");
            VWGraphSegment up(upstream);
            ASSERT(up.Graph() == m_pGraph);
            VWGraphSegment down(downstream);
            ASSERT(down.Graph() == m_pGraph);
            if (up.begin() == up.end()) {
                TRACELM(TRACE_ERROR, "CAnaSinComp::Compose() can't compose empty up segment");
                return E_INVALIDARG;
            }
            if (down.begin() == down.end()) {
                TRACELM(TRACE_ERROR, "CAnaSinComp::Compose() can't compose empty down segment");
                return E_INVALIDARG;
            }
            
            CMSVidStreamBufferSink* ds = (CMSVidStreamBufferSink*)downstream;
            DSFilter pSink(ds->m_Filters[0]);
            
            CComQIPtr<IMSVidEncoder> qiEnc(upstream);
            CEncoder* iEnc;
            iEnc = static_cast<CEncoder*>(qiEnc.p);
            DSPin pVidPin;
            DSPin pAudPin;
            DSPin genVidPin;
            DSPin genAudPin;
            CString csName;
            // render demux out to vr
            DSFilter pDeMux = iEnc->m_Filters[iEnc->m_iDemux];
            DSFilter::iterator iVidPin;
            DSFilter vr;
            DSMediaType mtVideo(MEDIATYPE_Video, MEDIASUBTYPE_MPEG2_VIDEO, FORMAT_MPEG2Video);
            DSMediaType mtAudio(MEDIATYPE_Audio, MEDIASUBTYPE_MPEG1Payload, FORMAT_WaveFormatEx);
            DSMediaType genericVideo(MEDIATYPE_Video);
            DSMediaType genericAudio(MEDIATYPE_Audio);
            for (iVidPin = pDeMux.begin(); iVidPin != pDeMux.end(); ++iVidPin) {
                DSPin::iterator j;
                for(j = (*iVidPin).begin(); j != (*iVidPin).end(); ++j){
                    DSMediaType pinType(*j);
                    if (pinType == mtVideo){
                        CComPtr<IUnknown> spMpeg2Analyze(CLSID_Mpeg2VideoStreamAnalyzer, NULL, CLSCTX_INPROC_SERVER);
                        if (!spMpeg2Analyze) {
                            //TRACELSM(TRACE_ERROR, (dbgDump << "CMSVidStreamBufferSink::Build() can't load Time Shift Sink");
                            return ImplReportError(__uuidof(IMSVidStreamBufferSink), IDS_CANT_CREATE_FILTER, __uuidof(IStreamBufferSink), E_UNEXPECTED);
                        }
                        spMpeg2Analyze->QueryInterface(IID_IBaseFilter, reinterpret_cast<void**>(&vr));
                        if (!vr) {
                            ASSERT(false);
                            return ImplReportError(__uuidof(IMSVidStreamBufferSink), IDS_CANT_CREATE_FILTER, __uuidof(IBaseFilter), E_UNEXPECTED);
                        }
                        m_Filters.push_back(vr);
                        csName = _T("Mpeg2 Analysis");
                        m_pGraph.AddFilter(vr, csName);
                        DSFilter::iterator a;
                        for(a = vr.begin(); a != vr.end(); ++a){
                            HRESULT hr = (*a).Connect(*iVidPin);
                            if(FAILED(hr)){
                                continue;
                            }
                            else{
                                break;
                            }
                        }
                        if(a == vr.end()){
                            return E_FAIL;
                        }
                        for(a = vr.begin(); a != vr.end(); ++a){
                            if((*a).GetDirection() == PINDIR_OUTPUT){
                                pVidPin = (*a); 
                            }
                        }
                        if(!pVidPin){
                            return E_FAIL;
                        }
                    }
                    else if(pinType == mtAudio){
                        pAudPin = (*iVidPin);
                    }
                    else if(pinType == genericVideo){
                        genVidPin = (*iVidPin);
                    }
                    else if(pinType == genericAudio){
                        genAudPin = (*iVidPin);
                    }
                }
                if(!!pVidPin && !!pAudPin){
                    break;
                }
            }
            if(!pVidPin){
                pVidPin = genVidPin;
            }
            if(!pAudPin){
                pAudPin = genAudPin;
            }
            if(!pVidPin){
                TRACELM(TRACE_ERROR, "CAnaSinComp::Compose() can't find video pin on demux");
                return E_UNEXPECTED;  
            }
            if(!pAudPin){
                TRACELM(TRACE_ERROR, "CAnaSinComp::Compose() can't find audio pin on demux");
                return E_UNEXPECTED;  
            }

            DSFilterList intermediates;
            HRESULT hr = S_OK;
            DSFilter::iterator fil;

#if ENCRYPT_NEEDED
            CComBSTR encString(L"{C4C4C4F1-0049-4E2B-98FB-9537F6CE516D}");
            GUID2 encdecGuid (encString);

            // Create and add to graph the Video Tagger Filter                
            CComPtr<IUnknown> spEncTagV(encdecGuid, NULL, CLSCTX_INPROC_SERVER);
            if (!spEncTagV) {
                TRACELM(TRACE_ERROR, "CMSVidStreamBufferSink::Build() can't load Tagger filter");
                return ImplReportError(__uuidof(IMSVidStreamBufferSink), IDS_CANT_CREATE_FILTER, __uuidof(IStreamBufferSink), VFW_E_CERTIFICATION_FAILURE);
            }
            
            DSFilter vrV(spEncTagV);
            if (!vrV) {
                ASSERT(false);
                TRACELM(TRACE_ERROR, "CAnaSinComp::Compose() on tagger interface");
                return ImplReportError(__uuidof(IMSVidStreamBufferSink), IDS_CANT_CREATE_FILTER, __uuidof(IBaseFilter), E_NOINTERFACE);
            }
            m_pEncFilters.push_back(vrV);
            m_Filters.push_back(vrV);
            csName = _T("Video Encoder Tagger Filter");
            m_pGraph.AddFilter(vrV, csName);
            
            // Connect video pin to Tagger
            hr = pVidPin.IntelligentConnect(vrV, intermediates);
            if(FAILED(hr)){
                TRACELM(TRACE_DETAIL, "CAnaSinComp::Compose() can't connect audio pin to Audio Tagger");
                return E_UNEXPECTED;  
            }

            // Connect Video to Sink
            DSFilter::iterator vP;
            hr = E_FAIL;
            for(vP = vrV.begin(); vP != vrV.end(); ++ vP){
                if((*vP).GetDirection() == PINDIR_OUTPUT){
                    break;   
                }
            }
            if(vP == vrV.end()){
                TRACELM(TRACE_ERROR, "CAnaSinComp::Compose() not video output pin");
                return E_UNEXPECTED;
            }
            for(fil = pSink.begin(); fil != pSink.end() && FAILED(hr); ++fil){
                hr = (*vP).Connect((*fil));
            }
            if(FAILED(hr)){
                
                TRACELM(TRACE_DETAIL, "CAnaSinComp::Compose() can't connect Video Tagger to Sink");
                return E_UNEXPECTED;  
            }

            // Create and add to graph the Audio Tagger Filter 
            CComPtr<IUnknown> spEncTagA(encdecGuid, NULL, CLSCTX_INPROC_SERVER);
            if (!spEncTagA) {
                TRACELM(TRACE_ERROR, "CMSVidStreamBufferSink::Build() can't load Tagger filter");
                return ImplReportError(__uuidof(IMSVidStreamBufferSink), IDS_CANT_CREATE_FILTER, __uuidof(IStreamBufferSink), VFW_E_CERTIFICATION_FAILURE);
            }
            
            DSFilter vrA(spEncTagA);
            if (!vrA) {
                ASSERT(false);
                TRACELM(TRACE_ERROR, "CAnaSinComp::Compose() can't create audio tagger filter");
                return ImplReportError(__uuidof(IMSVidStreamBufferSink), IDS_CANT_CREATE_FILTER, __uuidof(IBaseFilter), E_NOINTERFACE);
            }
            m_pEncFilters.push_back(vrV);
            m_Filters.push_back(vrA);
            csName = _T("Audio Encoder Tagger Filter");
            m_pGraph.AddFilter(vrA, csName);
            
            // Connect audio pin to the Tagger
            hr = pAudPin.IntelligentConnect(vrA, intermediates);
            if(FAILED(hr)){
                TRACELM(TRACE_DETAIL, "CAnaSinComp::Compose() can't connect audio pin to Audio Tagger");
                return E_UNEXPECTED;  
            }
            
            // Connect Tagger to Sink
            hr = E_FAIL;
            for(vP = vrA.begin(); vP != vrA.end(); ++ vP){
                if((*vP).GetDirection() == PINDIR_OUTPUT){
                    break;   
                }
            }
            if(vP == vrA.end()){
                TRACELM(TRACE_ERROR, "CAnaSinComp::Compose() no audio tagger pin");
                return E_UNEXPECTED;
            }
            for(fil = pSink.begin(); fil != pSink.end() && FAILED(hr); ++fil){
                hr = (*vP).Connect((*fil));
            }
            if(FAILED(hr)){
                
                TRACELM(TRACE_DETAIL, "CAnaSinComp::Compose() can't connect Audio Tagger to Sink");
                return E_UNEXPECTED;  
            }


#else
            // Connect the Video Pin to the sink
            DSFilter::iterator vidAnaPin;
            hr = E_FAIL;
            hr = E_FAIL;
            for(fil = pSink.begin(); fil != pSink.end() && FAILED(hr); ++fil){
                if((*fil).GetDirection() == PINDIR_INPUT && !(*fil).IsConnected()){
                    hr = pVidPin.Connect((*fil));
                }
            }

            if(FAILED(hr)){         
                TRACELM(TRACE_DETAIL, "CAnaSinComp::Compose() can't connect Video Tagger to Sink");
                ASSERT((L"Can't Connect vid to sink", FALSE));
                return E_UNEXPECTED;  
            }
            
            // Connect the Audio Pin to the Sink
            hr = E_FAIL;
            for(fil = pSink.begin(); fil != pSink.end() && FAILED(hr); ++fil){
                if((*fil).GetDirection() == PINDIR_INPUT && !(*fil).IsConnected()){
                    hr = pAudPin.Connect((*fil));
                }
            }

            if(FAILED(hr)){                
                TRACELM(TRACE_DETAIL, "CAnaSinComp::Compose() can't connect Audio Tagger to Sink");
                ASSERT((L"Can't Connect aud to sink", FALSE));
                return E_UNEXPECTED;  
            }


#endif

            
            /*                
            hr = m_pGraph.Connect(vrA, pSink, intermediates);
            if(FAILED(hr)){
            TRACELM(TRACE_DETAIL, "CAnaSinComp::Compose() can't connect Audio Tagger to Sink");
            return E_UNEXPECTED;  
            }
            */
            
            ASSERT(intermediates.begin() == intermediates.end());
            m_Filters.insert(m_Filters.end(), intermediates.begin(), intermediates.end());
            
            TRACELM(TRACE_DETAIL, "CAnaSinComp::Compose() SUCCEEDED");
            m_fComposed = true;
            return NOERROR;
        } catch (ComException &e) {
            TRACELM(TRACE_ERROR, "CAnaSinComp::Compose() com exception");
            return e;
        } catch (...) {
            TRACELM(TRACE_ERROR, "CAnaSinComp::Compose() ... exception");
            return E_UNEXPECTED;
        }
        
    }
};

#endif // Enc2Sin_H
// end of file - Enc2Sin.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\fp2vr.h ===
//==========================================================================;
//
// fp2vr.h : Declaration of the custom composition class for gluing file 
//           playback to the video renderer
//
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#ifndef FP2VRCOMP_H
#define FP2VRCOMP_H

#pragma once

#include <winerror.h>
#include <algorithm>
#include <compimpl.h>
#include <seg.h>
#include <objectwithsiteimplsec.h>
#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CAnaCapComp
class ATL_NO_VTABLE __declspec(uuid("B401C5EB-8457-427f-84EA-A4D2363364B0")) CFP2VRComp : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CFP2VRComp, &__uuidof(CFP2VRComp)>,
    public IObjectWithSiteImplSec<CFP2VRComp>,
	public IMSVidCompositionSegmentImpl<CFP2VRComp>
{
public:
    CFP2VRComp() {}
    virtual ~CFP2VRComp() {}

REGISTER_NONAUTOMATION_OBJECT(IDS_PROJNAME, 
						   IDS_REG_FP2VRCOMP_DESC,
						   LIBID_MSVidCtlLib,
						   __uuidof(CFP2VRComp));

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CFP2VRComp)
        COM_INTERFACE_ENTRY(IMSVidCompositionSegment)
    	COM_INTERFACE_ENTRY(IMSVidGraphSegment)
        COM_INTERFACE_ENTRY(IPersist)
        COM_INTERFACE_ENTRY(IObjectWithSite)
    END_COM_MAP()

// IMSVidComposition
public:
// IMSVidGraphSegment
// IMSVidCompositionSegment
    STDMETHOD(Compose)(IMSVidGraphSegment * upstream, IMSVidGraphSegment * downstream)
	{
        TRACELM(TRACE_DEBUG, "CFP2VRComp::Compose()");
        if (m_fComposed) {
            return NOERROR;
        }
        
        ASSERT(m_pGraph);
        try {
            VWGraphSegment up(upstream);
            ASSERT(up.Graph() == m_pGraph);
            VWGraphSegment down(downstream);
            ASSERT(down.Graph() == m_pGraph);
            if (up.begin() == up.end()) {
                TRACELM(TRACE_ERROR, "CFP2VRComp::Compose() can't compose empty up segment");
                return E_INVALIDARG;
            }
            if (down.begin() == down.end()) {
                TRACELM(TRACE_ERROR, "CFP2VRComp::Compose() can't compose empty down segment");
                return E_INVALIDARG;
            }
			DSFilter pFP(*up.begin());
	
			VWGraphSegment::iterator iVR;
			VWGraphSegment::iterator prevVR;
			for (iVR = down.begin(); iVR != down.end(); ++iVR) {
				prevVR = iVR;
			}
			DSFilter pVR = DSFilter(*prevVR);
			ASSERT(!!pFP);
            ASSERT(pFP.GetGraph() == m_pGraph);
			ASSERT(!!pVR);
            ASSERT(pVR.GetGraph() == m_pGraph);
          
            HRESULT hr = m_pGraph.Connect(pFP, pVR, m_Filters, 
                                          DSGraph::ATTEMPT_MERIT_UNLIKELY | 
                                              DSGraph::ALLOW_WILDCARDS | 
                                              DSGraph::IGNORE_MEDIATYPE_ERRORS |
                                              DSGraph::DONT_TERMINATE_ON_RENDERER |
                                              DSGraph::BIDIRECTIONAL_MEDIATYPE_MATCHING,
                                          DOWNSTREAM);
            if (FAILED(hr)) {
				TRACELSM(TRACE_ERROR, (dbgDump << "CFP2VRComp::Compose() FAILED connect hr = " << hexdump(hr)), "");
				return hr;
            }

            m_fComposed = true;
            return NOERROR;
        } catch (ComException &e) {
            return e;
        } catch (...) {
            return E_UNEXPECTED;
        }
	}
};

#endif // FP2VRCOMP_H
// end of file - FP2VRComp.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\mp2cc.h ===
//==========================================================================;
//
// Composition.h : Declaration of the custom composition class for gluing mpeg2 
// decoder to closed caption
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#ifndef MP2CCCOMP_H
#define MP2CCCOMP_H

#pragma once

#include <winerror.h>
#include <algorithm>
#include <compimpl.h>
#include <seg.h>
#include <objectwithsiteimplsec.h>
#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CMP2CCComp
class ATL_NO_VTABLE __declspec(uuid("6AD28EE1-5002-4e71-AAF7-BD077907B1A4")) CMP2CCComp : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMP2CCComp, &__uuidof(CMP2CCComp)>,
    public IObjectWithSiteImplSec<CMP2CCComp>,
	public IMSVidCompositionSegmentImpl<CMP2CCComp>
{
public:
    CMP2CCComp() {}
    virtual ~CMP2CCComp() {}

REGISTER_NONAUTOMATION_OBJECT(IDS_PROJNAME, 
						   IDS_REG_MP2CCCOMP_DESC,
						   LIBID_MSVidCtlLib,
						   __uuidof(CMP2CCComp));

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CMP2CCComp)
        COM_INTERFACE_ENTRY(IMSVidCompositionSegment)
    	COM_INTERFACE_ENTRY(IMSVidGraphSegment)
        COM_INTERFACE_ENTRY(IPersist)
        COM_INTERFACE_ENTRY(IObjectWithSite)
    END_COM_MAP()

// IMSVidComposition
public:
// IMSVidGraphSegment
// IMSVidCompositionSegment
    STDMETHOD(Compose)(IMSVidGraphSegment * upstream, IMSVidGraphSegment * downstream)
	{
        TRACELM(TRACE_DEBUG, "CMP2CCComp::Compose()");
        if (m_fComposed) {
            return NOERROR;
        }
        
        ASSERT(m_pGraph);
        try {
            VWGraphSegment up(upstream);
            ASSERT(up.Graph() == m_pGraph);
            VWGraphSegment down(downstream);
            ASSERT(down.Graph() == m_pGraph);
            if (up.begin() == up.end()) {
                TRACELM(TRACE_ERROR, "CMP2CCComp::Compose() can't compose empty up segment");
                return E_INVALIDARG;
            }
            if (down.begin() == down.end()) {
                TRACELM(TRACE_ERROR, "CMP2CCComp::Compose() can't compose empty down segment");
                return E_INVALIDARG;
            }
#if 0
            VWGraphSegment::iterator iMP2 = std::find_if(up.begin(),
                                                         up.end(),
                                                         arity1_pointer(&IsMP2Demux));
#endif
			VWGraphSegment::iterator iMP2;
			int i;
			for (i = 0 , iMP2 = up.begin(); iMP2 != up.end(); ++iMP2, ++i);
			for (iMP2 = up.begin(); iMP2 != up.end() && --i; ++iMP2);
            if (iMP2 == up.end()) {
                TRACELM(TRACE_ERROR, "CMP2CCComp::Compose() upstream segment has no MPEG2 Decoder");
                return E_FAIL;
            }
            ASSERT((*iMP2).GetGraph() == m_pGraph);
          
            VWGraphSegment::iterator iL21 = std::find_if(down.begin(),
                down.end(),
                arity1_pointer(&IsL21Decoder));
            if (iL21 == down.end()) {
                TRACELM(TRACE_ERROR, "CMP2CCComp::Compose() downstream segment has no l21Decoder");
                return E_FAIL;
            }
            
            ASSERT((*iL21).GetGraph() == m_pGraph);
            
            DSFilter pMP2(*iMP2);
            DSFilter pL21(*iL21);

			HRESULT hr = m_pGraph.Connect(pMP2, pL21, m_Filters, DSGraph::RENDER_ALL_PINS, DOWNSTREAM);
            if (FAILED(hr)) {
				TRACELSM(TRACE_ERROR, (dbgDump << "CMP2CCComp::Compose() FAILED connect hr = " << hexdump(hr)), "");
				return hr;
            }

            m_fComposed = true;
            return NOERROR;
        } catch (ComException &e) {
            return e;
        } catch (...) {
            return E_UNEXPECTED;
        }
	}
};

#endif // MP2CCCOMP_H
// end of file - MP2CCComp.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\mp2sin.h ===
//==========================================================================;
//
// Composition.h : Declaration of the custom composition class for gluing bda MPeg2 tuner to sbe SINk
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#ifndef MP2SIN_H
#define MP2SIN_H

#pragma once
#include <uuids.h>
#include <objectwithsiteimplsec.h>
#include "bdamedia.h"
#include "bdaTuner.h"
#include "MSVidSbeSink.h"
#include "resource.h"       // main symbols
#include <winerror.h>
#include <algorithm>
#include <compimpl.h>
#include <seg.h>



/////////////////////////////////////////////////////////////////////////////
// CMP2SinComp
class ATL_NO_VTABLE __declspec(uuid("ABE40035-27C3-4a2f-8153-6624471608AF")) CMP2SinComp : 
public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CMP2SinComp, &__uuidof(CMP2SinComp)>,
    public IObjectWithSiteImplSec<CMP2SinComp>,
    public IMSVidCompositionSegmentImpl<CMP2SinComp>
{
public:
    CMP2SinComp() {}
    virtual ~CMP2SinComp() {}
    
    REGISTER_NONAUTOMATION_OBJECT(IDS_PROJNAME, 
        IDS_REG_MP2SINCOMP_DESC,
        LIBID_MSVidCtlLib,
        __uuidof(CMP2SinComp));
    
    DECLARE_PROTECT_FINAL_CONSTRUCT()
        
    BEGIN_COM_MAP(CMP2SinComp)
        COM_INTERFACE_ENTRY(IMSVidCompositionSegment)
        COM_INTERFACE_ENTRY(IMSVidGraphSegment)
        COM_INTERFACE_ENTRY(IPersist)
        COM_INTERFACE_ENTRY(IObjectWithSite)
    END_COM_MAP()
        
        // IMSVidComposition
public:
    // IMSVidGraphSegment
    // IMSVidCompositionSegment
    STDMETHOD(Compose)(IMSVidGraphSegment * upstream, IMSVidGraphSegment * downstream)
    {

        if (m_fComposed) {
            return NOERROR;
        }
        ASSERT(m_pGraph);
        try {
            TRACELM(TRACE_DETAIL, "CMP2SinComp::Compose()");
            VWGraphSegment up(upstream);
            ASSERT(up.Graph() == m_pGraph);
            VWGraphSegment down(downstream);
            ASSERT(down.Graph() == m_pGraph);
            if (up.begin() == up.end()) {
                TRACELM(TRACE_ERROR, "CMP2SinComp::Compose() can't compose empty up segment");
                return E_INVALIDARG;
            }
            if (down.begin() == down.end()) {
                TRACELM(TRACE_ERROR, "CMP2SinComp::Compose() can't compose empty down segment");
                return E_INVALIDARG;
            }
#if 0
            VWGraphSegment::iterator iOv = std::find_if(down.begin(),
                down.end(),
                arity1_pointer(&IsVideoRenderer));
#endif            
            CMSVidStreamBufferSink* ds = (CMSVidStreamBufferSink*)downstream;
            DSFilter pSink(ds->m_Filters[0]);
            
            
            CComQIPtr<IMpeg2Demultiplexer> qiDeMux;
            VWGraphSegment::iterator i;
            for (i = up.begin(); i != up.end(); ++i){
                qiDeMux = (*i);
                if (!qiDeMux){
                    continue;
                }
                else{
                    break;
                }
            }
            if(i == up.end()){
                TRACELM(TRACE_ERROR, "CAnaSinComp::Compose() cannot find demux");
                return E_INVALIDARG;
            }
            // render demux out to vr
            DSPin pVidPin;
            DSPin pAudPin;
            DSFilter pDeMux = (*i);
            DSFilter::iterator iVidPin;
            DSMediaType mtVideo(MEDIATYPE_Video, MEDIASUBTYPE_MPEG2_VIDEO, FORMAT_MPEG2Video);
            DSMediaType mtAudio(MEDIATYPE_Audio);
            for (iVidPin = pDeMux.begin(); iVidPin != pDeMux.end(); ++iVidPin) {
                DSPin::iterator j;
                for(j = (*iVidPin).begin(); j != (*iVidPin).end(); ++j){
                    DSMediaType pinType(*j);
                    CString csName;
                    if (pinType == mtVideo){
                        CComPtr<IUnknown> spMpeg2Analyze(CLSID_Mpeg2VideoStreamAnalyzer, NULL, CLSCTX_INPROC_SERVER);
                        if (!spMpeg2Analyze) {
                            //TRACELSM(TRACE_ERROR, (dbgDump << "CMSVidStreamBufferSink::Build() can't load Stream Buffer Sink");
                            return ImplReportError(__uuidof(IMSVidStreamBufferSink), IDS_CANT_CREATE_FILTER, __uuidof(IStreamBufferSink), E_UNEXPECTED);
                        }
                        DSFilter vr(spMpeg2Analyze);
                        if (!vr) {
                            ASSERT(false);
                            return ImplReportError(__uuidof(IMSVidStreamBufferSink), IDS_CANT_CREATE_FILTER, __uuidof(IBaseFilter), E_UNEXPECTED);
                        }
                        m_Filters.push_back(vr);
                        csName = _T("Mpeg2 Analysis");
                        m_pGraph.AddFilter(vr, csName);
                        DSFilter::iterator a;
                        for(a = vr.begin(); a != vr.end(); ++a){
                            HRESULT hr = (*a).Connect(*iVidPin);
                            if(FAILED(hr)){
                                continue;
                            }
                            else{
                                break;
                            }
                        }
                        if(a == vr.end()){
                            return E_FAIL;
                        }
                        for(a = vr.begin(); a != vr.end(); ++a){
                            if((*a).GetDirection() == PINDIR_OUTPUT){
                                pVidPin = (*a); 
                            }
                        }
                        if(!pVidPin){
                            return E_FAIL;
                        }
                    }
                    if(pinType == mtAudio){
                        pAudPin = (*iVidPin);
                    }
                }
                if(!!pVidPin && !!pAudPin){
                    break;
                }
            }
            if(!pVidPin || !pAudPin){
                TRACELM(TRACE_DETAIL, "CMP2SinComp::Compose() can't find video and/or audio pin on demux");
                return E_UNEXPECTED;  
            }
            DSFilterList intermediates;
            
            HRESULT hr = pAudPin.IntelligentConnect(pSink, intermediates);
            if(FAILED(hr)){
                TRACELM(TRACE_DETAIL, "CMP2SinComp::Compose() can't find video and/or audio pin on demux");
                return E_UNEXPECTED;  
            }
            
            hr = pVidPin.IntelligentConnect(pSink, intermediates);
            if(FAILED(hr)){
                TRACELM(TRACE_DETAIL, "CMP2SinComp::Compose() can't find video and/or audio pin on demux");
                return E_UNEXPECTED;  
            }
            TRACELM(TRACE_DETAIL, "CMP2SinComp::Compose() SUCCEEDED");
            m_fComposed = true;
            return NOERROR;
        } catch (ComException &e) {
            HRESULT hr = e;
            TRACELSM(TRACE_ERROR, (dbgDump << "CMP2SinComp::Compose() exception = " << hexdump(hr)), "");
            return e;
        } catch (...) {
            TRACELM(TRACE_ERROR, "CMP2SinComp::Compose() exception ... ");
            return E_UNEXPECTED;
        }
    }
};

#endif // MP2Sin_H
// end of file - MP2Sin.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\languagecomponenttype.h ===
/////////////////////////////////////////////////////////////////////////////////////
// LanguageComponentType.h : Declaration of the CLanguageComponentType
// Copyright (c) Microsoft Corporation 1999.

#ifndef __LANGUAGECOMPONENTTYPE_H_
#define __LANGUAGECOMPONENTTYPE_H_

#pragma once

#include <objectwithsiteimplsec.h>
#include "languagecomponenttypeimpl.h"

/////////////////////////////////////////////////////////////////////////////
// CLanguageComponentType
class ATL_NO_VTABLE __declspec(uuid("1BE49F30-0E1B-11d3-9D8E-00C04F72D980")) CLanguageComponentType : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CLanguageComponentType, &CLSID_LanguageComponentType>,
    public IObjectWithSiteImplSec<CLanguageComponentType>,
	public ILanguageComponentTypeImpl<CLanguageComponentType>
{
public:
	CLanguageComponentType()
	{
	}

REGISTER_AUTOMATION_OBJECT_WITH_TM(IDS_REG_TUNEROBJ, 
						   IDS_REG_LANGUAGECOMPONENTTYPE_PROGID, 
						   IDS_REG_LANGUAGECOMPONENTTYPE_DESC,
						   LIBID_TunerLib,
						   CLSID_LanguageComponentType, tvBoth);
DECLARE_NOT_AGGREGATABLE(CLanguageComponentType)

DECLARE_PROTECT_FINAL_CONSTRUCT()

public:
    bool m_bRequiresSave;
    typedef ILanguageComponentTypeImpl<CLanguageComponentType> basetype;
    BEGIN_PROP_MAP(CLanguageComponentType)
        CHAIN_PROP_MAP(basetype)
    END_PROPERTY_MAP()

    BEGIN_COM_MAP(CLanguageComponentType)
	    COM_INTERFACE_ENTRY(ILanguageComponentType)
	    COM_INTERFACE_ENTRY(IComponentType)
	    COM_INTERFACE_ENTRY(IPersistPropertyBag)
    	COM_INTERFACE_ENTRY(IPersist)
	    COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IObjectWithSite)
    END_COM_MAP_WITH_FTM()

	BEGIN_CATEGORY_MAP(CLanguageComponentType)
		IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
		IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
		IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
	END_CATEGORY_MAP()

};

typedef CComQIPtr<ILanguageComponentType> PQLanguageComponentType;

#endif //__LANGUAGECOMPONENTTYPE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\iso3166.h ===
// Copyright (c) 1998 - 1999  Microsoft Corporation.  All Rights Reserved.
#ifndef __ISO3166_H
#define __ISO3166_H

char DVDToUpper(char x)
{
    if('a' <= x && x <= 'z') {
        return x - ('a' - 'A');
    } else {
        return x;
    }
}

struct ISO3166
{
    const char *Code;
    
    // access the table as ISO3166::GetCountry()
    static const ISO3166& GetCountry( unsigned i );
    static unsigned	GetNumCountries();

    // creates an ISO code from a two letter string
    static WORD	PackCode( const char string[2] )
    {
        return DVDToUpper(string[0])<<8 | DVDToUpper(string[1]);
    }
    
};

// ISO3166 country code table
static const ISO3166 g_Table[] =
{ // current as of Dec 22, 2000
    {/* "Afghanistan", */       "AF"},
    {/* "Albania", */           "AL"},
    {/* "Algeria", */           "DZ"},
    {/* "American Samoa", */    "AS"},
    {/* "Andorra", */           "AD"},
    {/* "Angola", */            "AO"},
    {/* "Anguilla", */          "AI"},
    {/* "Antarctica", */        "AQ"},
    {/* "Antigua and Barbuda", */  "AG"},
    {/* "Argentina", */         "AR"},
    {/* "Armenia", */           "AM"},
    {/* "Aruba", */             "AW"},
    {/* "Australia", */         "AU"},
    {/* "Austria", */           "AT"},
    {/* "Azerbaijan", */        "AZ"},
    {/* "Bahamas", */           "BS"},
    {/* "Bahrain", */           "BH"},
    {/* "Bangladesh", */        "BD"},
    {/* "Barbados", */          "BB"},
    {/* "Belarus", */           "BY"},
    {/* "Belgium", */           "BE"},
    {/* "Belize", */            "BZ"},
    {/* "Benin", */             "BJ"},
    {/* "Bermuda", */           "BM"},
    {/* "Bhutan", */            "BT"},
    {/* "Bolivia", */           "BO"},
    {/* "Bosnia and Herzegovina", */        "BA"},
    {/* "Botswana", */          "BW"},
    {/* "Bouvet Island", */     "BV"},
    {/* "Brazil", */            "BR"},
    {/* "British Indian Ocean Territory", */  "IO"},
    {/* "Brunei Darussalam", */ "BN"},
    {/* "Bulgaria", */          "BG"},
    {/* "Burkina Faso", */      "BF"},
    {/* "Burundi", */           "BI"},
    {/* "Cambodia", */          "KH"},
    {/* "Cameroon", */          "CM"},
    {/* "Canada", */            "CA"},
    {/* "Cape Verde", */        "CV"},
    {/* "Cayman Islands", */    "KY"},
    {/* "Central African Republic", */      "CF"},
    {/* "Chad", */              "TD"},
    {/* "Channel Islands", */	"GB"},
    {/* "Chile", */             "CL"},
    {/* "China", */             "CN"},
    {/* "Christmas Island", */  "CX"},
    {/* "Cocos (Keeling) Islands", */       "CC"},
    {/* "Colombia", */          "CO"},
    {/* "Comoros", */           "KM"},
    {/* "Congo", */             "CG"},
    {/* "Cook Islands", */      "CK"},
    {/* "Costa Rica", */        "CR"},
    {/* "Cte d'Ivoire", */     "CI"},
    {/* "Croatia (local name: Hrvatska)", */  "HR"},
    {/* "Cuba", */              "CU"},
    {/* "Cyprus", */            "CY"},
    {/* "Czech Republic", */    "CZ"},
    {/* "Denmark", */           "DK"},
    {/* "Djibouti", */          "DJ"},
    {/* "Dominica", */          "DM"},
    {/* "Dominican Republic", */  "DO"},
    {/* "East Timor", */        "TP"},
    {/* "Ecuador", */           "EC"},
    {/* "Egypt", */             "EG"},
    {/* "El Salvador", */       "SV"},
    {/* "Equatorial Guinea", */  "GQ"},
    {/* "Eritrea", */           "ER"},
    {/* "Estonia", */           "EE"},
    {/* "Ethiopia", */          "ET"},
    {/* "Falkland Islands (Malvinas)", */   "FK"},
    {/* "Faroe Islands", */     "FO"},
    {/* "Fiji", */              "FJ"},
    {/* "Finland", */           "FI"},
    {/* "France", */            "FR"},
    {/* "France, Metropolitan", */  "FX"},
    {/* "French Guiana", */     "GF"},
    {/* "French Polynesia", */  "PF"},
    {/* "French Southern and Antarctic Lands", */	"TF"},
    {/* "Gabon", */             "GA"},
    {/* "Gambia", */            "GM"},
    {/* "Georgia", */           "GE"},
    {/* "Germany", */           "DE"},
    {/* "Ghana", */             "GH"},
    {/* "Gibraltar", */         "GI"},
    {/* "Greece", */            "GR"},
    {/* "Greenland", */         "GL"},
    {/* "Grenada", */           "GD"},
    {/* "Guadeloupe", */        "GP"},
    {/* "Guam", */              "GU"},
    {/* "Guatemala", */         "GT"},
    {/* "Guinea", */            "GN"},
    {/* "Guinea-Bissau", */     "GW"},
    {/* "Guyana", */            "GY"},
    {/* "Haiti", */             "HT"},
    {/* "Heard and Mc Donald Islands", */   "HM"},
    {/* "Holy See (Vatican City State)", */ "VA"},
    {/* "Honduras", */          "HN"},
    {/* "Hong Kong SAR", */         "HK"},
    {/* "Hungary", */           "HU"},
    {/* "Iceland", */           "IS"},
    {/* "India", */             "IN"},
    {/* "Indonesia", */         "ID"},
    {/* "Iran (Islamic Republic Of)", */    "IR"},
    {/* "Iraq", */              "IQ"},
    {/* "Ireland", */           "IE"},
    {/* "Israel", */            "IL"},
    {/* "Italy", */             "IT"},
    {/* "Jamaica", */           "JM"},
    {/* "Japan", */             "JP"},
    {/* "Jordan", */            "JO"},
    {/* "Kazakhstan", */        "KZ"},
    {/* "Kenya", */             "KE"},
    {/* "Kiribati", */          "KI"},
    {/* "Korea, Democratic People's Republic Of", */  "KP"},
    {/* "Korea, Republic Of", */  "KR"},
    {/* "Kuwait", */            "KW"},
    {/* "Kyrgyzstan", */        "KG"},
    {/* "Lao People's Democratic Republic", */  "LA"},
    {/* "Latvia", */            "LV"},
    {/* "Lebanon", */           "LB"},
    {/* "Lesotho", */           "LS"},
    {/* "Liberia", */           "LR"},
    {/* "Libyan Arab Jamahiriya", */        "LY"},
    {/* "Liechtenstein", */     "LI"},
    {/* "Lithuania", */         "LT"},
    {/* "Luxembourg", */        "LU"},
    {/* "Macau SAR", */             "MO"},
    {/* "Macedonia, The Former Yugoslav Republic Of", */  "MK"},
    {/* "Madagascar", */        "MG"},
    {/* "Malawi", */            "MW"},
    {/* "Malaysia", */          "MY"},
    {/* "Maldives", */          "MV"},
    {/* "Mali", */              "ML"},
    {/* "Malta", */             "MT"},
    {/* "Man, Isle of",*/   	"GB"},
    {/* "Marshall Islands", */  "MH"},
    {/* "Martinique", */        "MQ"},
    {/* "Mauritania", */        "MR"},
    {/* "Mauritius", */         "MU"},
    {/* "Mayotte", */           "YT"},
    {/* "Mexico", */            "MX"},
    {/* "Micronesia, Federated States Of", */  "FM"},
    {/* "Moldova, Republic Of", */          "MD"},
    {/* "Monaco", */            "MC"},
    {/* "Mongolia", */          "MN"},
    {/* "Montserrat", */        "MS"},
    {/* "Morocco", */           "MA"},
    {/* "Mozambique", */        "MZ"},
    {/* "Myanmar", */           "MM"},
    {/* "Namibia", */           "NA"},
    {/* "Nauru", */             "NR"},
    {/* "Nepal", */             "NP"},
    {/* "Netherlands", */       "NL"},
    {/* "Netherlands ANTILLES", */          "AN"},
    {/* "New Caledonia", */     "NC"},
    {/* "New Zealand", */       "NZ"},
    {/* "Nicaragua", */         "NI"},
    {/* "Niger", */             "NE"},
    {/* "Nigeria", */           "NG"},
    {/* "Niue", */              "NU"},
    {/* "Norfolk Island", */    "NF"},
    {/* "Northern Mariana Islands", */      "MP"},
    {/* "Norway", */            "NO"},
    {/* "Oman", */              "OM"},
    {/* "Pakistan", */          "PK"},
    {/* "Palau", */             "PW"},
    {/* "Panama", */            "PA"},
    {/* "Papua New Guinea", */  "PG"},
    {/* "Paraguay", */          "PY"},
    {/* "Peru", */              "PE"},
    {/* "Philippines", */       "PH"},
    {/* "Pitcairn Islands", */  "PN"},
    {/* "Poland", */            "PL"},
    {/* "Portugal", */          "PT"},
    {/* "Puerto Rico", */       "PR"},
    {/* "Qatar", */             "QA"},
    {/* "Reunion", */           "RE"},
    {/* "Romania", */           "RO"},
    {/* "Russian Federation", */            "RU"},
    {/* "Rwanda", */            "RW"},
    {/* "Saint Kitts and Nevis", */         "KN"},
    {/* "Saint Lucia", */       "LC"},
    {/* "Saint Vincent and The Grenadines", */  "VC"},
    {/* "Samoa", */             "WS"},
    {/* "San Marino", */        "SM"},
    {/* "So Tom and Prncipe ", */         "ST"},
    {/* "Saudi Arabia", */      "SA"},
    {/* "Senegal", */           "SN"},
    {/* "Seychelles", */        "SC"},
    {/* "Sierra Leone", */      "SL"},
    {/* "Singapore", */         "SG"},
    {/* "Slovakia (Slovak Republic)", */    "SK"},
    {/* "Slovenia", */          "SI"},
    {/* "Solomon Islands", */   "SB"},
    {/* "Somalia", */           "SO"},
    {/* "South Africa", */      "ZA"},
    {/* "South Georgia and The South Sandwich Islands", */  "GS"},
    {/* "Spain", */             "ES"},
    {/* "Sri Lanka", */         "LK"},
    {/* "St. Helena", */        "SH"},
    {/* "St. Pierre and Miquelon", */        "PM"},
    {/* "Sudan", */             "SD"},
    {/* "Suriname", */          "SR"},
    {/* "Svalbard and Jan Mayen Islands", */ "SJ"},
    {/* "Swaziland", */         "SZ"},
    {/* "Sweden", */            "SE"},
    {/* "Switzerland", */       "CH"},
    {/* "Syrian Arab Republic", */  "SY"},
    {/* "Taiwan", */            "TW"},
    {/* "Tajikistan", */        "TJ"},
    {/* "Tanzania, United Republic Of", */  "TZ"},
    {/* "Thailand", */          "TH"},
    {/* "Togo", */              "TG"},
    {/* "Tokelau", */           "TK"},
    {/* "Tonga", */             "TO"},
    {/* "Trinidad and Tobago", */  "TT"},
    {/* "Tunisia", */           "TN"},
    {/* "Turkey", */            "TR"},
    {/* "Turkmenistan", */      "TM"},
    {/* "Turks and Caicos Islands", */      "TC"},
    {/* "Tuvalu", */            "TV"},
    {/* "Uganda", */            "UG"},
    {/* "Ukraine", */           "UA"},
    {/* "United Arab Emirates", */  "AE"},
    {/* "United Kingdom", */    "GB"},
    {/* "United States", */     "US"},
    {/* "U.S. Minor Outlying Islands", */  "UM"},
    {/* "Uruguay", */           "UY"},
    {/* "Uzbekistan", */        "UZ"},
    {/* "Vanuatu", */           "VU"},
    {/* "Venezuela", */         "VE"},
    {/* "Viet Nam", */          "VN"},
    {/* "Virgin Islands (British)", */      "VG"},
    {/* "Virgin Islands (U.S.)", */         "VI"},
    {/* "Wallis and Futuna Islands", */     "WF"},
    {/* "Yemen", */             "YE"},
    {/* "Yugoslavia", */        "YU"},
    {/* "Congo (DRC)", */             "ZR"},
    {/* "Zambia", */            "ZM"},
    {/* "Zimbabwe", */          "ZW"}
};

static const unsigned g_uTableSize = sizeof( g_Table )/ sizeof( g_Table[0] );

const ISO3166& ISO3166::GetCountry( unsigned i )
{
    return g_Table[i];
}

unsigned ISO3166::GetNumCountries()
{
    return g_uTableSize;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\mpeg2tunerequest.cpp ===
/////////////////////////////////////////////////////////////////////////////////////
// MPEG2TuneRequest.cpp : Implementation of CMPEG2TuneRequest
// Copyright (c) Microsoft Corporation 1999.

#include "stdafx.h"
#include "Tuner.h"
#include "MPEG2TuneRequest.h"

DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MPEG2TuneRequestFactory, CMPEG2TuneRequestFactory)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MPEG2TuneRequest, CMPEG2TuneRequest)
/////////////////////////////////////////////////////////////////////////////
// CMPEG2TuneRequest

STDMETHODIMP CMPEG2TuneRequest::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IMPEG2TuneRequest
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

STDMETHODIMP CMPEG2TuneRequestFactory::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IMPEG2TuneRequestFactory
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\mpeg2componenttype.h ===
/////////////////////////////////////////////////////////////////////////////////////
// MPEG2ComponentType.h : Declaration of the CMPEG2ComponentType
// Copyright (c) Microsoft Corporation 1999.

#ifndef __MPEG2COMPONENTTYPE_H_
#define __MPEG2COMPONENTTYPE_H_

#pragma once

#include <objectwithsiteimplsec.h>
#include "MPEG2componenttypeimpl.h"

/////////////////////////////////////////////////////////////////////////////
// CMPEG2ComponentType
class ATL_NO_VTABLE __declspec(uuid("418008F3-CF67-4668-9628-10DC52BE1D08")) CMPEG2ComponentType : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CMPEG2ComponentType, &CLSID_MPEG2ComponentType>,
    public IObjectWithSiteImplSec<CMPEG2ComponentType>,
	public IMPEG2ComponentTypeImpl<CMPEG2ComponentType>
{
public:
	CMPEG2ComponentType()
	{
	}

REGISTER_AUTOMATION_OBJECT_WITH_TM(IDS_REG_TUNEROBJ, 
						   IDS_REG_MPEG2COMPONENTTYPE_PROGID, 
						   IDS_REG_MPEG2COMPONENTTYPE_DESC,
						   LIBID_TunerLib,
						   CLSID_MPEG2ComponentType, tvBoth);
DECLARE_NOT_AGGREGATABLE(CMPEG2ComponentType)

DECLARE_PROTECT_FINAL_CONSTRUCT()

public:
    bool m_bRequiresSave;
    typedef IMPEG2ComponentTypeImpl<CMPEG2ComponentType> basetype;
    BEGIN_PROP_MAP(CMPEG2ComponentType)
        CHAIN_PROP_MAP(basetype)
    END_PROPERTY_MAP()

    BEGIN_COM_MAP(CMPEG2ComponentType)
	    COM_INTERFACE_ENTRY(IMPEG2ComponentType)
	    COM_INTERFACE_ENTRY(ILanguageComponentType)
	    COM_INTERFACE_ENTRY(IComponentType)
	    COM_INTERFACE_ENTRY(IPersistPropertyBag)
    	COM_INTERFACE_ENTRY(IPersist)
	    COM_INTERFACE_ENTRY(IDispatch)
    	COM_INTERFACE_ENTRY(IObjectWithSite)
    END_COM_MAP_WITH_FTM()

	BEGIN_CATEGORY_MAP(CMPEG2ComponentType)
		IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
		IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
		IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
	END_CATEGORY_MAP()

};

typedef CComQIPtr<IMPEG2ComponentType> PQMPEG2ComponentType;

#endif //__MPEG2COMPONENTTYPE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\mpeg2component.h ===
/////////////////////////////////////////////////////////////////////////////////////
// MPEG2Component.h : Declaration of the CMPEG2Component
// Copyright (c) Microsoft Corporation 1999.

#ifndef __MPEG2COMPONENT_H_
#define __MPEG2COMPONENT_H_

#pragma once

#include <objectwithsiteimplsec.h>
#include "MPEG2componentimpl.h"

/////////////////////////////////////////////////////////////////////////////
// CMPEG2Component
class ATL_NO_VTABLE CMPEG2Component : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CMPEG2Component, &CLSID_MPEG2Component>,
    public IObjectWithSiteImplSec<CMPEG2Component>,
	public IMPEG2ComponentImpl<CMPEG2Component>
{
public:
    CMPEG2Component() : m_bRequiresSave(false)
	{
	}

REGISTER_AUTOMATION_OBJECT_WITH_TM(IDS_REG_TUNEROBJ, 
						   IDS_REG_MPEG2COMPONENT_PROGID, 
						   IDS_REG_MPEG2COMPONENT_DESC,
						   LIBID_TunerLib,
						   CLSID_MPEG2Component, tvBoth);

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMPEG2Component)
	COM_INTERFACE_ENTRY(IMPEG2Component)
	COM_INTERFACE_ENTRY(IComponent)
	COM_INTERFACE_ENTRY(IPersistPropertyBag)
	COM_INTERFACE_ENTRY(IPersist)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectWithSite)
END_COM_MAP_WITH_FTM()

	BEGIN_CATEGORY_MAP(CMPEG2Component)
		IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
		IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
		IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
	END_CATEGORY_MAP()

public:

    bool m_bRequiresSave;
    BEGIN_PROP_MAP(CMPEG2Component)
        CHAIN_PROP_MAP(IMPEG2ComponentImpl<CMPEG2Component>)
    END_PROPERTY_MAP()


};

typedef CComQIPtr<IMPEG2Component> PQMPEG2Component;

#endif //__MPEG2COMPONENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\mslcid.h ===
/*************************************************************/
/* Name: MSLCID.h
/* Description: 
/*************************************************************/
#ifndef MSLCID_H_INCLUDE
#define MSLCID_H_INCLUDE

class MSLangID  
{
public:
	struct LanguageList
	{
		UINT   ResourceID;
		WORD   LangID;
	};

	int m_LLlength;
	LanguageList* m_LL;

    virtual ~MSLangID() {};

    MSLangID() {        
        static LanguageList LL[] = {
            { IDS_DVD_LANG1, LANG_AFRIKAANS },
            { IDS_DVD_LANG2, LANG_ALBANIAN },
            { IDS_DVD_LANG3, LANG_ARABIC },
            { IDS_DVD_LANG4, LANG_BASQUE },
            { IDS_DVD_LANG5, LANG_BELARUSIAN },
            { IDS_DVD_LANG6, LANG_BULGARIAN },
            { IDS_DVD_LANG7, LANG_CATALAN },
            { IDS_DVD_LANG8, LANG_CHINESE },
            { IDS_DVD_LANG9, LANG_CROATIAN },
            { IDS_DVD_LANG10, LANG_CZECH },
            { IDS_DVD_LANG11, LANG_DANISH },
            { IDS_DVD_LANG12, LANG_DUTCH },
            { IDS_DVD_LANG13, LANG_ENGLISH },
            { IDS_DVD_LANG14, LANG_ESTONIAN },
            { IDS_DVD_LANG15, LANG_FAEROESE },
            { IDS_DVD_LANG16, LANG_FARSI },
            { IDS_DVD_LANG17, LANG_FINNISH },
            { IDS_DVD_LANG18, LANG_FRENCH },
            { IDS_DVD_LANG19, LANG_GERMAN },
            { IDS_DVD_LANG20, LANG_GREEK },
            { IDS_DVD_LANG21, LANG_HEBREW },
            { IDS_DVD_LANG22, LANG_HUNGARIAN },
            { IDS_DVD_LANG23, LANG_ICELANDIC },
            { IDS_DVD_LANG24, LANG_INDONESIAN },
            { IDS_DVD_LANG25, LANG_ITALIAN },
            { IDS_DVD_LANG26, LANG_JAPANESE },
            { IDS_DVD_LANG27, LANG_KOREAN },
            { IDS_DVD_LANG28, LANG_LATVIAN },
            { IDS_DVD_LANG29, LANG_LITHUANIAN },
            { IDS_DVD_LANG30, LANG_MALAY },
            { IDS_DVD_LANG31, LANG_NORWEGIAN },
            { IDS_DVD_LANG32, LANG_POLISH },
            { IDS_DVD_LANG33, LANG_PORTUGUESE },
            { IDS_DVD_LANG34, LANG_ROMANIAN },
            { IDS_DVD_LANG35, LANG_RUSSIAN },
            { IDS_DVD_LANG36, LANG_SERBIAN },
            { IDS_DVD_LANG37, LANG_SLOVAK },
            { IDS_DVD_LANG38, LANG_SLOVENIAN },
            { IDS_DVD_LANG39, LANG_SPANISH },
            { IDS_DVD_LANG40, LANG_SWAHILI },
            { IDS_DVD_LANG41, LANG_SWEDISH },
            { IDS_DVD_LANG42, LANG_THAI },
            { IDS_DVD_LANG43, LANG_TURKISH },
            { IDS_DVD_LANG44, LANG_UKRAINIAN },
        };
        m_LL = LL;
        m_LLlength = sizeof(LL)/sizeof(LL[0]);
    }/* of Contructor */
    
    static LPTSTR LoadStringFromRes(DWORD redId){
        
        TCHAR *string = new TCHAR[MAX_PATH];
        ::ZeroMemory(string, sizeof(TCHAR) * MAX_PATH);
        if (::LoadString(_Module.GetModuleInstance(), redId, string, MAX_PATH))
            return string;
        
        delete[] string;
        return NULL;
    }/* end of function LoadStringFromRes */
    
    LPTSTR GetLanguageFromLCID(LCID lcid){
        
        // Try to get it from the system first
        TCHAR  *szLanguage = new TCHAR[MAX_PATH];
        int iRet = ::GetLocaleInfo(lcid, LOCALE_SENGLANGUAGE, szLanguage, MAX_PATH);
        if (iRet) {
            return szLanguage;
        }
        
        delete[] szLanguage;
        // Else try to find it in the private LCID table
        for(int i = 0; i < m_LLlength; i++) {
            if(m_LL[i].LangID == PRIMARYLANGID(LANGIDFROMLCID(lcid)))
                return LoadStringFromRes(m_LL[i].ResourceID);
        }
        return NULL;
    }/* end of function GetLanguageFromLCID */
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\mpeg2tunerequest.h ===
/////////////////////////////////////////////////////////////////////////////////////
// MPEG2TuneRequest.h : Declaration of the CMPEG2TuneRequest
// Copyright (c) Microsoft Corporation 2000.

#ifndef __MPEG2TUNEREQUEST_H_
#define __MPEG2TUNEREQUEST_H_

#pragma once

#include <objectwithsiteimplsec.h>
#include "MPEG2tunerequestimpl.h"

/////////////////////////////////////////////////////////////////////////////
// CMPEG2TuneRequest
class ATL_NO_VTABLE CMPEG2TuneRequest : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public IMPEG2TuneRequestImpl<CMPEG2TuneRequest>,
	public CComCoClass<CMPEG2TuneRequest, &CLSID_MPEG2TuneRequest>,
    public IObjectWithSiteImplSec<CMPEG2TuneRequest>,
	public ISupportErrorInfo
{
public:

REGISTER_AUTOMATION_OBJECT_WITH_TM(IDS_REG_TUNEROBJ, 
						   IDS_REG_MPEG2TUNEREQUEST_PROGID, 
						   IDS_REG_MPEG2TUNEREQUEST_DESC,
						   LIBID_TunerLib,
						   CLSID_MPEG2TuneRequest, tvBoth);

BEGIN_COM_MAP(CMPEG2TuneRequest)
	COM_INTERFACE_ENTRY(IMPEG2TuneRequest)
	COM_INTERFACE_ENTRY(ITuneRequest)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IPersistPropertyBag)
	COM_INTERFACE_ENTRY(IPersist)
    COM_INTERFACE_ENTRY(IObjectWithSite)
END_COM_MAP_WITH_FTM()

	BEGIN_CATEGORY_MAP(CMPEG2TuneRequest)
		IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
		IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
		IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
	END_CATEGORY_MAP()


// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    typedef IMPEG2TuneRequestImpl<CMPEG2TuneRequest> basetype;
    BEGIN_PROP_MAP(CMPEG2TuneRequest)
        CHAIN_PROP_MAP(basetype)
    END_PROP_MAP()


};

typedef CComQIPtr<IMPEG2TuneRequestSupport> PQMPEG2TuneRequestSupport;

/////////////////////////////////////////////////////////////////////////////
// CMPEG2TuneRequest
class ATL_NO_VTABLE CMPEG2TuneRequestFactory : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<IMPEG2TuneRequestFactory, 
                         &__uuidof(IMPEG2TuneRequestFactory), 
                         &LIBID_TunerLib>,
	public CComCoClass<CMPEG2TuneRequestFactory, &CLSID_MPEG2TuneRequestFactory>,
    public IObjectWithSiteImplSec<CMPEG2TuneRequestFactory>,
	public ISupportErrorInfo
{
public:

REGISTER_AUTOMATION_OBJECT(IDS_REG_TUNEROBJ, 
						   IDS_REG_MPEG2TUNEREQUESTFACTORY_PROGID, 
						   IDS_REG_MPEG2TUNEREQUESTFACTORY_DESC,
						   LIBID_TunerLib,
						   CLSID_MPEG2TuneRequestFactory);

BEGIN_COM_MAP(CMPEG2TuneRequestFactory)
	COM_INTERFACE_ENTRY(IMPEG2TuneRequestFactory)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectWithSite)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP_WITH_FTM()

	BEGIN_CATEGORY_MAP(CMPEG2TuneRequestFactory)
		IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
		IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
	END_CATEGORY_MAP()


// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    STDMETHOD(CreateTuneRequest)(ITuningSpace* pTS, IMPEG2TuneRequest** pTR) {
        if (!pTR) {
            return E_POINTER;
        }
        try {
            PQMPEG2TuneRequestSupport pt(pTS);
            if (!pt) {
                return Error(IDS_INVALID_TS, __uuidof(IMPEG2TuneRequestFactory), E_INVALIDARG);
            }
            CMPEG2TuneRequest* pNewTR = new CComObject<CMPEG2TuneRequest>;
			ATL_LOCK();
            ASSERT(!pNewTR->m_TS);
			HRESULT hr = pTS->Clone(&pNewTR->m_TS);
            if (FAILED(hr)) {
                pNewTR->Release();
                return hr;
            }
			pNewTR->AddRef();
            *pTR = pNewTR;
            return NOERROR;
        } catch(...) {
            return E_POINTER;
        }

    }

};

#endif //__MPEG2TUNEREQUESTFACTORY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\msvidaudiorenderer.cpp ===
//==========================================================================;
//
// Copyright (c) Microsoft Corporation 1999-2000.
//
//--------------------------------------------------------------------------;
//
// MSVidAudioRenderer.cpp : Implementation of CMSVidAudioRenderer
//

#include "stdafx.h"

#ifndef TUNING_MODEL_ONLY

#include "MSVidCtl.h"
#include "MSVidAudioRenderer.h"
#include "MSVidVideoRenderer.h"
#include "dvdmedia.h"
#include "sbe.h"



DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidAudioRenderer, CMSVidAudioRenderer)

/////////////////////////////////////////////////////////////////////////////
// CMSVidAudioRenderer

STDMETHODIMP CMSVidAudioRenderer::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IMSVidAudioRenderer
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

STDMETHODIMP CMSVidAudioRenderer::PreRun() {
    if (m_fUseKSRenderer) {
        return NOERROR;
    }
    // until sysaudio works correctly with ksproxy so that we only have 1 audio renderer
    // filter for both digital and analog we have to have two different rendering filters and
    // we don't which we're going to need.  in the analog case, after we're done building 
    // we're left with the dsound renderer hooked up to the analog filter which creates a 1/2 second(or so)
    // delayed echo.  find this scenario if it exists and disconnect the dsound renderer from the wavein filter
    TRACELM(TRACE_DEBUG, "CMSVidAudioRenderer::PreRun()");
    if (m_iAudioRenderer == -1) {
        TRACELM(TRACE_ERROR, "CMSVidAudioRenderer::PreRun() no dsr");
        return VFW_E_NO_AUDIO_HARDWARE;
    }
    DSFilter dsr(m_Filters[m_iAudioRenderer]);
    DSPin dsrin(*dsr.begin());
    if (dsrin.GetDirection() != PINDIR_INPUT) {
        TRACELM(TRACE_ERROR, "CMSVidAudioRenderer::PreRun() first dsound renderer pin not an input");
        return E_UNEXPECTED;
    }
    DSPin upstreampin;
    HRESULT hr = dsrin->ConnectedTo(&upstreampin);
    if (FAILED(hr) || !upstreampin) {
        // dsound renderer not connected to anything
        TRACELM(TRACE_DEBUG, "CMSVidAudioRenderer::PreRun() dsr not connected");
        return NOERROR;
    }
    DSFilter upstreamfilter(upstreampin.GetFilter());
    if (!upstreamfilter) {
        TRACELM(TRACE_ERROR, "CMSVidAudioRenderer::PreRun() upstream pin has no filter");
        return E_UNEXPECTED;
    }
    PQAudioInputMixer p(upstreamfilter);
    if (!p) {
        TRACELM(TRACE_ERROR, "CMSVidAudioRenderer::PreRun() upstream filter not wavein");
#if 0
        PQVidCtl pqCtl;
        hr = m_pContainer->QueryInterface(IID_IMSVidCtl, reinterpret_cast<void**>(&pqCtl));
        if(FAILED(hr)){
            return hr;
        }
        
        CComQIPtr<IMSVidVideoRenderer> pq_VidVid;
        hr = pqCtl->get_VideoRendererActive(&pq_VidVid);
        if(FAILED(hr)){
            return hr;
        }

        CComQIPtr<IMSVidStreamBufferSource> pq_SBESource;
        CComQIPtr<IMSVidInputDevice> pq_Dev;
        hr = pqCtl->get_InputActive(&pq_Dev);
        if(FAILED(hr)){
            return hr;
        }
        pq_SBESource = pq_Dev;

        if(!pq_VidVid || !pq_SBESource){
            return NOERROR;
        }
        
        VWGraphSegment vVid(pq_VidVid);
        if(!vVid){
            return E_NOINTERFACE;
        }
        
        VWGraphSegment::iterator iV;
        for (iV = vVid.begin(); iV != vVid.end(); ++iV) {
            if (IsVideoRenderer(*iV)) {
                break;
            }
        }
        
        if (iV == vVid.end()) {
            TRACELM(TRACE_ERROR, "CAnaCapComp::Compose() segment has no video mixer filter");
            return E_FAIL;
        }
        
        CComQIPtr<IMediaFilter> pq_MFVid(*iV);
        if(!pq_MFVid){
            return E_NOINTERFACE;
        }

        CComQIPtr<IMediaFilter> pq_MFAud(dsr);
        if(!pq_MFAud){
            return E_NOINTERFACE;
        }


        CComQIPtr<IMediaFilter> pq_MFGph(m_pGraph);
        if(!pq_MFGph){
            return E_NOINTERFACE;
        }

        VWGraphSegment vSbe(pq_SBESource);
        if(!vSbe){
            return E_NOINTERFACE;
        }
        
        CComQIPtr<IStreamBufferSource> pq_SBE;
        VWGraphSegment::iterator iS;
        for (iS = vSbe.begin(); iS != vSbe.end(); ++iS) {
            pq_SBE = (*iS);
            if (!!pq_SBE) {
                break;
            }
        }
        
        if (iS == vSbe.end()) {
            TRACELM(TRACE_ERROR, "CAnaCapComp::Compose() segment has no video mixer filter");
            return E_FAIL;
        }    
        
        CComQIPtr<IReferenceClock> pq_IClock;
        hr = dsr->QueryInterface(&pq_IClock);
        if(FAILED(hr)){
            return hr;
        }
        
        if(!pq_IClock || !pq_MFVid || !pq_MFAud || !pq_MFGph){
            return E_NOINTERFACE;    
        }

        hr = pq_MFGph->SetSyncSource(pq_IClock);
        if(FAILED(hr)){
            return hr;
        }
#if 0


        hr = pq_MFilter2->SetSyncSource(pq_IClock);
        if(FAILED(hr)){
            return hr;
        }

#endif
        
        hr = pq_MFVid->SetSyncSource(pq_IClock);
        if(FAILED(hr)){
            return hr;
        }
#endif
        return NOERROR;
    }
    bool rc = m_pGraph.DisconnectFilter(dsr, false, false);
    if (!rc) {
        TRACELM(TRACE_ERROR, "CMSVidAudioRenderer::PreRun() disconnect filter failed");
        return E_UNEXPECTED;
    }

    return NOERROR;
}

STDMETHODIMP CMSVidAudioRenderer::Build() {
    if (!m_fInit || !m_pGraph) {
        return Error(IDS_OBJ_NO_INIT, __uuidof(IMSVidAudioRenderer), CO_E_NOTINITIALIZED);
    }
    try {
        CString csName;
		DSFilter ar;
        PQCreateDevEnum SysEnum(CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER);
        if(m_iAudioRenderer==-1){
            if (m_fUseKSRenderer) {
                csName = _T("KS System Renderer");
                // undone: use ks system renderer
            } else if (m_fAnalogOnly) {
                csName = _T("Analog Audio Renderer");
                DSDevices ARList(SysEnum, CLSID_AudioInputDeviceCategory);
                if (ARList.begin() != ARList.end()) {
                    ar = m_pGraph.LoadFilter(*ARList.begin(), csName);
                    m_pAR = ar;
                }
            } else if (m_fDigitalOnly) {
                csName = _T("Default DSound Renderer");
                ar = DSFilter(CLSID_DSoundRender);
                m_pAR = ar;
            } else {
                // NOTE: its important that digital audio be first so that we short circuit
                // loading 8 billion audio codecs trying to connect a digital source
                // to the analog renderer.  there aren't any analog codecs(a physical impossiblity),
                // so we don't have to worry about the reverse case.
                csName = _T("Default DSound Renderer");
                ar = DSFilter(CLSID_DSoundRender);
                if (ar) {
                    m_pGraph.AddFilter(ar, csName);
                    m_Filters.push_back(ar);
                }
                
                csName = _T("Analog Audio Renderer");
                DSDevices ARList(SysEnum, CLSID_AudioInputDeviceCategory);
                if (ARList.begin() != ARList.end()) {
                    ar = m_pGraph.LoadFilter(*ARList.begin(), csName);
                }
            }
        }
        if (ar) {
            m_pGraph.AddFilter(ar, csName);
            m_Filters.push_back(ar);
            m_iAudioRenderer = 0;
        }
        if(m_iAudioRenderer == -1){
            return VFW_E_NO_AUDIO_HARDWARE;
        }
        else{
            return NOERROR;
        }
    } catch (ComException &e) {
        return e;
    } catch (...) {
        return E_UNEXPECTED;
    }
}

#endif //TUNING_MODEL_ONLY

// end of file - msvidaudiorenderer.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\msvidctlp.c ===
#ifndef TUNING_MODEL_ONLY
#include <msvidctl_p.c>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\msvidaudiorenderer.h ===
//==========================================================================;
// MSVidAudioRenderer.h : Declaration of the CMSVidAudioRenderer
// copyright (c) Microsoft Corp. 1998-1999.
//==========================================================================;

#ifndef __MSVidAUDIORENDERER_H_
#define __MSVidAUDIORENDERER_H_

#pragma once

#include "segimpl.h"
#include "devimpl.h"
#include "seg.h"
#include <objectwithsiteimplsec.h>
#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CMSVidAudioRenderer
class ATL_NO_VTABLE __declspec(uuid("37B03544-A4C8-11d2-B634-00C04F79498E")) CMSVidAudioRenderer : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMSVidAudioRenderer, &CLSID_MSVidAudioRenderer>,
    public IObjectWithSiteImplSec<CMSVidAudioRenderer>,
	public ISupportErrorInfo,
	public IConnectionPointContainerImpl<CMSVidAudioRenderer>,
	public IMSVidGraphSegmentImpl<CMSVidAudioRenderer, MSVidSEG_DEST, &GUID_NULL>,
    public IMSVidDeviceImpl<CMSVidAudioRenderer, &LIBID_MSVidCtlLib, &GUID_NULL, IMSVidAudioRenderer>
{
public:
    CMSVidAudioRenderer() : 
		m_fUseKSRenderer(false), 
		m_fAnalogOnly(false), 
		m_fDigitalOnly(false),
        m_iAudioRenderer(-1)
	{}

REGISTER_AUTOMATION_OBJECT(IDS_PROJNAME, 
						   IDS_REG_AUDIORENDERER_PROGID, 
						   IDS_REG_AUDIORENDERER_DESC,
						   LIBID_MSVidCtlLib,
						   CLSID_MSVidAudioRenderer);

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMSVidAudioRenderer)
	COM_INTERFACE_ENTRY(IMSVidGraphSegment)
	COM_INTERFACE_ENTRY(IMSVidAudioRenderer)
	COM_INTERFACE_ENTRY(IMSVidOutputDevice)
	COM_INTERFACE_ENTRY(IMSVidDevice)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectWithSite)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(IPersist)
END_COM_MAP()

	BEGIN_CATEGORY_MAP(CMSVidAudioRenderer)
		IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
		IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
		IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
	END_CATEGORY_MAP()

BEGIN_CONNECTION_POINT_MAP(CMSVidAudioRenderer)
END_CONNECTION_POINT_MAP()

	DSFilter m_pAR;
    int m_iAudioRenderer;
	bool m_fUseKSRenderer;
	bool m_fAnalogOnly;
	bool m_fDigitalOnly;

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

public:
    CComBSTR __declspec(property(get=GetName)) m_Name;
    CComBSTR GetName(void) {
        return CComBSTR(OLESTR("audio renderer"));
    }

// IMSVidDevice
	STDMETHOD(get_Name)(BSTR * Name)
	{
        if (!m_fInit) {
	 	    return Error(IDS_OBJ_NO_INIT, __uuidof(IMSVidAudioRenderer), CO_E_NOTINITIALIZED);
        }
		if (Name == NULL)
			return E_POINTER;
        try {
		    *Name = m_Name.Copy();	
        } catch(...) {
            return E_POINTER;
        }
		return NOERROR;
	}
	STDMETHOD(get_Status)(LONG * Status)
	{
        if (!m_fInit) {
	 	    return Error(IDS_OBJ_NO_INIT, __uuidof(IMSVidAudioRenderer), CO_E_NOTINITIALIZED);
        }
		if (Status == NULL)
			return E_POINTER;
			
		return E_NOTIMPL;
	}
	STDMETHOD(get_Segment)(IMSVidGraphSegment * * pIMSVidGraphSegment)
	{
        if (!m_fInit) {
	 	    return Error(IDS_OBJ_NO_INIT, __uuidof(IMSVidAudioRenderer), CO_E_NOTINITIALIZED);
        }
		if (pIMSVidGraphSegment == NULL)
			return E_POINTER;
			
		return E_NOTIMPL;
	}
// IMSVidAudioRenderer
	STDMETHOD(get_Volume)(LONG * plPercent)
	{
        if (!m_fInit) {
	 	    return Error(IDS_OBJ_NO_INIT, __uuidof(IMSVidAudioRenderer), CO_E_NOTINITIALIZED);
        }
		if (plPercent == NULL)
			return E_POINTER;			
		try {
			if (!m_pGraph) {
				Error(IDS_INVALID_STATE, __uuidof(IMSVidAudioRenderer), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
			}
			PQBasicAudio pBA(m_pGraph);
			if (!pBA) {
				Error(IDS_E_CANTQI, __uuidof(IBasicAudio), E_NOINTERFACE);
			}
			return pBA->get_Volume(plPercent);
		} catch(...) {
			return E_POINTER;
		}
	}
	STDMETHOD(put_Volume)(LONG plPercent)
	{
        if (!m_fInit) {
	 	    return Error(IDS_OBJ_NO_INIT, __uuidof(IMSVidAudioRenderer), CO_E_NOTINITIALIZED);
        }
		try {
			if (!m_pGraph) {
				Error(IDS_INVALID_STATE, __uuidof(IMSVidAudioRenderer), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
			}
			PQBasicAudio pBA(m_pGraph);
			if (!pBA) {
				Error(IDS_E_CANTQI, __uuidof(IBasicAudio), E_NOINTERFACE);
			}
			return pBA->put_Volume(plPercent);
		} catch(...) {
			return E_UNEXPECTED;
		}
	}
	STDMETHOD(get_Balance)(LONG * plPercent)
	{
        if (!m_fInit) {
	 	    return Error(IDS_OBJ_NO_INIT, __uuidof(IMSVidAudioRenderer), CO_E_NOTINITIALIZED);
        }
		if (plPercent == NULL)
			return E_POINTER;
		try {
			if (!m_pGraph) {
				Error(IDS_INVALID_STATE, __uuidof(IMSVidAudioRenderer), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
			}
			PQBasicAudio pBA(m_pGraph);
			if (!pBA) {
				Error(IDS_E_CANTQI, __uuidof(IBasicAudio), E_NOINTERFACE);
			}
			return pBA->get_Balance(plPercent);
		} catch(...) {
			return E_POINTER;
		}
	}
	STDMETHOD(put_Balance)(LONG plPercent)
	{
        if (!m_fInit) {
	 	    return Error(IDS_OBJ_NO_INIT, __uuidof(IMSVidAudioRenderer), CO_E_NOTINITIALIZED);
        }
		try {
			if (!m_pGraph) {
				Error(IDS_INVALID_STATE, __uuidof(IMSVidAudioRenderer), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
			}
			PQBasicAudio pBA(m_pGraph);
			if (!pBA) {
				Error(IDS_E_CANTQI, __uuidof(IBasicAudio), E_NOINTERFACE);
			}
			return pBA->put_Balance(plPercent);
		} catch(...) {
			return E_UNEXPECTED;
		}
	}

// IMSVidGraphSegment
	STDMETHOD(Build)();
    STDMETHOD(PreRun)();
};

#endif //__MSVidAUDIORENDERER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\msvidcp.h ===
//===========================================================================
//
// msvidcp.h : msvidctl event connection point handler
// Copyright (c) Microsoft Corporation 1999-2000.
//
/////////////////////////////////////////////////////////////////////////////
#ifndef _MSVideoCP_H_
#define _MSVideoCP_H_

//#import "..\..\common\include\MSVidCtl.tlb" raw_interfaces_only, raw_native_types, no_namespace, named_guids	//"Import typelib"
template <class T>
class CProxy_IMSVidCtlEvents : public IConnectionPointImpl<T, &DIID__IMSVidCtlEvents, CComDynamicUnkArray>
{
	//Warning this class may be recreated by the wizard.
public:
	VOID Fire_Click()
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				pDispatch->Invoke(DISPID_CLICK, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	
	}
	VOID Fire_DblClick()
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				pDispatch->Invoke(DISPID_DBLCLICK, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	
	}
	VOID Fire_KeyDown(SHORT * KeyCode, SHORT Shift)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[2];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[1] = KeyCode;
				pvars[0] = Shift;
				DISPPARAMS disp = { pvars, NULL, 2, 0 };
				pDispatch->Invoke(DISPID_KEYDOWN, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_KeyPress(SHORT * KeyAscii)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = *KeyAscii;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(DISPID_KEYPRESS, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_KeyUp(SHORT * KeyCode, SHORT Shift)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[2];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[1] = KeyCode;
				pvars[0] = Shift;
				DISPPARAMS disp = { pvars, NULL, 2, 0 };
				pDispatch->Invoke(DISPID_KEYUP, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_MouseDown(SHORT Button, SHORT Shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[4];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[3] = Button;
				pvars[2] = Shift;
				pvars[1] = x;
				pvars[0] = y;
				DISPPARAMS disp = { pvars, NULL, 4, 0 };
				pDispatch->Invoke(DISPID_MOUSEDOWN, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_MouseMove(SHORT Button, SHORT Shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[4];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[3] = Button;
				pvars[2] = Shift;
				pvars[1] = x;
				pvars[0] = y;
				DISPPARAMS disp = { pvars, NULL, 4, 0 };
				pDispatch->Invoke(DISPID_MOUSEMOVE, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_MouseUp(SHORT Button, SHORT Shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[4];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[3] = Button;
				pvars[2] = Shift;
				pvars[1] = x;
				pvars[0] = y;
				DISPPARAMS disp = { pvars, NULL, 4, 0 };
				pDispatch->Invoke(DISPID_MOUSEUP, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_Error(SHORT Number, BSTR * Description, LONG Scode, BSTR Source, BSTR HelpFile, LONG HelpContext, CHAR * CancelDisplay)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[7];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[6] = Number;
				pvars[5] = Description;
				pvars[4] = Scode;
				pvars[3] = Source;
				pvars[2] = HelpFile;
				pvars[1] = HelpContext;
				pvars[0] = CancelDisplay;
				DISPPARAMS disp = { pvars, NULL, 7, 0 };
				pDispatch->Invoke(DISPID_ERROREVENT, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
    VOID Fire_StateChange(MSVidCtlStateList PrevState, MSVidCtlStateList CurrState)
    {
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[2];
		int nConnections = m_vec.GetSize();
		TRACELSM(TRACE_DETAIL, (dbgDump << "CVidCtl::FireStateChange(" << PrevState << ", " << CurrState << ")"), "");
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{

                pvars[1] = PrevState;
				pvars[0] = CurrState;
				DISPPARAMS disp = { pvars, NULL, 2, 0 };
				pDispatch->Invoke(dispidStateChange, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;

    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\msvidctl.cpp ===
// MSVidCtl.cpp : Implementation of DLL Exports.

#include "stdafx.h"

#if 0
#ifndef TUNING_MODEL_ONLY
#include "Devices.h"
#ifndef _WIN64
#include "bdatuner.h"
#include "MSVidTVTuner.h"
#include "MSVidVideoRenderer.h"
#include "MSVidAudioRenderer.h"
#include "MSVidFilePlayback.h"
#include "MSVidSBESource.h"
#include "MSVidWebDVD.h"
#include "MSVidDVDAdm.h"
#include "seg.h"					/// ??? Does this go here or above the _WIN64 ??? (jb 8/31)
#include "closedcaptioning.h"
#include "Composition.h"
#include "vidprot.h"
#include "anacap.h"
#include "anadata.h"
#include "MSViddataservices.h"
#include "WebDVDComp.h"
#include "WebDVDARComp.h"
#include "mp2cc.h"
#include "fp2vr.h"
#include "fp2ar.h"
#include "enc2sin.h"
#include "dat2sin.h"
#include "dat2xds.h"
#include "ana2xds.h"
#include "ana2enc.h"
#include "sbes2cc.h"
#include "sbes2vrm.h"
#include "VidCtl.h"
#include "msvidencoder.h"

#endif //_WIN64

#include "topwin.h"
#include "msvidStreamBufferrecorder.h"
#include "cmseventbinder.h"
#endif //TUNING_MODEL_ONLY

#include "createregbag.h"
#include "TuningSpaceContainer.h"
#include "ATSCTS.h"
#include "AnalogTVTS.h"
#include "AuxiliaryInTs.h"
#include "AnalogRadioTS.h"
#include "DVBTS.h"
#include "DVBSTS.h"
#include "Component.h"
#include "Components.h"
#include "ComponentTypes.h"
#include "ComponentType.h"
#include "LanguageComponentType.h"
#include "MPEG2ComponentType.h"
#include "ATSCComponentType.h"
#include "MPEG2Component.h"
#include "channeltunerequest.h"
#include "atscchanneltunerequest.h"
#include "atsclocator.h"
#include "dvbtlocator.h"
#include "dvbslocator.h"
#include "dvbtunerequest.h"

#else
#ifndef TUNING_MODEL_ONLY
#include "Devices.h"
#include "seg.h"
#endif //TUNING_MODEL_ONLY
#include "TuningSpaceContainer.h"

#endif
#include "dlldatax.h"
CComModule _Module;

#ifndef TUNING_MODEL_ONLY
    DECLARE_EXTERN_OBJECT_ENTRY(CVidCtl)
    // typesafe device collections
    DECLARE_EXTERN_OBJECT_ENTRY(CInputDevices)
    DECLARE_EXTERN_OBJECT_ENTRY(COutputDevices)
    DECLARE_EXTERN_OBJECT_ENTRY(CVideoRendererDevices)
    DECLARE_EXTERN_OBJECT_ENTRY(CAudioRendererDevices)
    DECLARE_EXTERN_OBJECT_ENTRY(CFeatures)
    // device segments
    DECLARE_EXTERN_OBJECT_ENTRY(CMSVidBDATuner)
    DECLARE_EXTERN_OBJECT_ENTRY(CMSVidTVTuner)
    DECLARE_EXTERN_OBJECT_ENTRY(CMSVidVideoRenderer)
    DECLARE_EXTERN_OBJECT_ENTRY(CMSVidAudioRenderer)
    DECLARE_EXTERN_OBJECT_ENTRY(CMSVidFilePlayback)
    DECLARE_EXTERN_OBJECT_ENTRY(CMSVidWebDVD)
    DECLARE_EXTERN_OBJECT_ENTRY(CClosedCaptioning)
    DECLARE_EXTERN_OBJECT_ENTRY(CMSVidStreamBufferSink)
    DECLARE_EXTERN_OBJECT_ENTRY(CMSVidStreamBufferSource)
    // feature segments
    DECLARE_EXTERN_OBJECT_ENTRY(CDataServices)
    DECLARE_EXTERN_OBJECT_ENTRY(CEncoder)
    DECLARE_EXTERN_OBJECT_ENTRY(CXDS)
    //DECLARE_EXTERN_OBJECT_ENTRY(CMSVidTVEGSeg)
	//DECLARE_EXTERN_OBJECT_ENTRY(CMSVidCAGSeg)
    // composition segments
    DECLARE_EXTERN_OBJECT_ENTRY(CComposition)
    DECLARE_EXTERN_OBJECT_ENTRY(CAnaCapComp)
    DECLARE_EXTERN_OBJECT_ENTRY(CAnaDataComp)
    DECLARE_EXTERN_OBJECT_ENTRY(CWebDVDComp)
    DECLARE_EXTERN_OBJECT_ENTRY(CWebDVDARComp)
    DECLARE_EXTERN_OBJECT_ENTRY(CMP2CCComp)
    DECLARE_EXTERN_OBJECT_ENTRY(CAnaSinComp)
    DECLARE_EXTERN_OBJECT_ENTRY(CMP2SinComp)
    DECLARE_EXTERN_OBJECT_ENTRY(CFP2VRComp)
    DECLARE_EXTERN_OBJECT_ENTRY(CFP2ARComp)
    DECLARE_EXTERN_OBJECT_ENTRY(CEnc2SinComp)    
    DECLARE_EXTERN_OBJECT_ENTRY(CDat2XDSComp)    
    DECLARE_EXTERN_OBJECT_ENTRY(CDat2SinComp)
    DECLARE_EXTERN_OBJECT_ENTRY(CAna2XDSComp)
    DECLARE_EXTERN_OBJECT_ENTRY(CAna2EncComp)
    DECLARE_EXTERN_OBJECT_ENTRY(CSbeS2CCComp)
    DECLARE_EXTERN_OBJECT_ENTRY(CSbeS2VmrComp)
    // pluggable protocols
    DECLARE_EXTERN_OBJECT_ENTRY(CTVProt)
    DECLARE_EXTERN_OBJECT_ENTRY(CDVDProt)
    // utility objects
    DECLARE_EXTERN_OBJECT_ENTRY(CMSVidWebDVDAdm)
    DECLARE_EXTERN_OBJECT_ENTRY(CMSEventBinder)
    DECLARE_EXTERN_OBJECT_ENTRY(CMSVidRect)
    DECLARE_EXTERN_OBJECT_ENTRY(CMSVidStreamBufferRecordingControl)
#endif
// utility objects
DECLARE_EXTERN_OBJECT_ENTRY(CCreateRegBag)
// tuning model objects
DECLARE_EXTERN_OBJECT_ENTRY(CSystemTuningSpaces)
DECLARE_EXTERN_OBJECT_ENTRY(CATSCTS)
DECLARE_EXTERN_OBJECT_ENTRY(CAnalogTVTS)
DECLARE_EXTERN_OBJECT_ENTRY(CAuxInTS)
DECLARE_EXTERN_OBJECT_ENTRY(CAnalogRadioTS)
DECLARE_EXTERN_OBJECT_ENTRY(CDVBTS)
DECLARE_EXTERN_OBJECT_ENTRY(CDVBSTS)
DECLARE_EXTERN_OBJECT_ENTRY(CChannelTuneRequest)
DECLARE_EXTERN_OBJECT_ENTRY(CATSCChannelTuneRequest)
DECLARE_EXTERN_OBJECT_ENTRY(CDVBTuneRequest)
DECLARE_EXTERN_OBJECT_ENTRY(CMPEG2TuneRequest)
DECLARE_EXTERN_OBJECT_ENTRY(CComponent)
DECLARE_EXTERN_OBJECT_ENTRY(CMPEG2Component)
DECLARE_EXTERN_OBJECT_ENTRY(CComponentTypes)
DECLARE_EXTERN_OBJECT_ENTRY(CComponentType)
DECLARE_EXTERN_OBJECT_ENTRY(CLanguageComponentType)
DECLARE_EXTERN_OBJECT_ENTRY(CMPEG2ComponentType)
DECLARE_EXTERN_OBJECT_ENTRY(CATSCComponentType)
DECLARE_EXTERN_OBJECT_ENTRY(CATSCLocator)
DECLARE_EXTERN_OBJECT_ENTRY(CDVBTLocator)
DECLARE_EXTERN_OBJECT_ENTRY(CDVBSLocator)
DECLARE_EXTERN_OBJECT_ENTRY(CMPEG2TuneRequestFactory)
#ifndef TUNING_MODEL_ONLY
DECLARE_EXTERN_OBJECT_ENTRY(CBroadcastEventService)
#endif

BEGIN_EXTERN_OBJECT_MAP(ObjectMap)

#ifndef TUNING_MODEL_ONLY
	// primary control
    EXTERN_OBJECT_ENTRY(CVidCtl)
	// typesafe device collections
    EXTERN_OBJECT_ENTRY(CInputDevices)
    EXTERN_OBJECT_ENTRY(COutputDevices)
    EXTERN_OBJECT_ENTRY(CVideoRendererDevices)
    EXTERN_OBJECT_ENTRY(CAudioRendererDevices)
    EXTERN_OBJECT_ENTRY(CFeatures)
	// device segments
    EXTERN_OBJECT_ENTRY(CMSVidBDATuner)
    EXTERN_OBJECT_ENTRY(CMSVidTVTuner)
    EXTERN_OBJECT_ENTRY(CMSVidVideoRenderer)
    EXTERN_OBJECT_ENTRY(CMSVidAudioRenderer)
    EXTERN_OBJECT_ENTRY(CMSVidFilePlayback)
    EXTERN_OBJECT_ENTRY(CMSVidWebDVD)
	EXTERN_OBJECT_ENTRY(CClosedCaptioning)
    EXTERN_OBJECT_ENTRY(CMSVidStreamBufferSink)
    EXTERN_OBJECT_ENTRY(CMSVidStreamBufferSource)
    // feature segments
    EXTERN_OBJECT_ENTRY(CDataServices)
    EXTERN_OBJECT_ENTRY(CEncoder)
    EXTERN_OBJECT_ENTRY(CXDS)
	//EXTERN_OBJECT_ENTRY(CMSVidCAGSeg)
	//EXTERN_OBJECT_ENTRY(CMSVidTVEGSeg)
	// composition segments
    EXTERN_OBJECT_ENTRY(CComposition)
    EXTERN_OBJECT_ENTRY(CAnaCapComp)
    EXTERN_OBJECT_ENTRY(CAnaDataComp)
    EXTERN_OBJECT_ENTRY(CWebDVDComp)
    EXTERN_OBJECT_ENTRY(CWebDVDARComp)
    EXTERN_OBJECT_ENTRY(CMP2CCComp)
    EXTERN_OBJECT_ENTRY(CAnaSinComp)
    EXTERN_OBJECT_ENTRY(CMP2SinComp)
    EXTERN_OBJECT_ENTRY(CFP2VRComp)
    EXTERN_OBJECT_ENTRY(CFP2ARComp)
    EXTERN_OBJECT_ENTRY(CEnc2SinComp)    
    EXTERN_OBJECT_ENTRY(CDat2XDSComp)    
    EXTERN_OBJECT_ENTRY(CDat2SinComp)
    EXTERN_OBJECT_ENTRY(CAna2XDSComp)
    EXTERN_OBJECT_ENTRY(CAna2EncComp)    
    EXTERN_OBJECT_ENTRY(CSbeS2CCComp)    
    EXTERN_OBJECT_ENTRY(CSbeS2VmrComp)    
	// pluggable protocols
    EXTERN_OBJECT_ENTRY(CTVProt)
    EXTERN_OBJECT_ENTRY(CDVDProt)
    // utility objects
    EXTERN_OBJECT_ENTRY(CMSVidWebDVDAdm)
    EXTERN_OBJECT_ENTRY(CMSEventBinder)
    EXTERN_OBJECT_ENTRY(CMSVidStreamBufferRecordingControl)
#endif
	// utility objects
    EXTERN_OBJECT_ENTRY(CCreateRegBag)
	// tuning model objects
    EXTERN_OBJECT_ENTRY(CSystemTuningSpaces)
    EXTERN_OBJECT_ENTRY(CATSCTS)
    EXTERN_OBJECT_ENTRY(CAnalogTVTS)
    EXTERN_OBJECT_ENTRY(CAuxInTS)
    EXTERN_OBJECT_ENTRY(CAnalogRadioTS)
    EXTERN_OBJECT_ENTRY(CDVBTS)
    EXTERN_OBJECT_ENTRY(CDVBSTS)
    EXTERN_OBJECT_ENTRY(CChannelTuneRequest)
    EXTERN_OBJECT_ENTRY(CATSCChannelTuneRequest)
    EXTERN_OBJECT_ENTRY(CDVBTuneRequest)
    EXTERN_OBJECT_ENTRY(CMPEG2TuneRequest)
    EXTERN_OBJECT_ENTRY(CComponent)
    EXTERN_OBJECT_ENTRY(CMPEG2Component)
    EXTERN_OBJECT_ENTRY(CComponentTypes)
    EXTERN_OBJECT_ENTRY(CComponentType)
    EXTERN_OBJECT_ENTRY(CLanguageComponentType)
    EXTERN_OBJECT_ENTRY(CMPEG2ComponentType)
    EXTERN_OBJECT_ENTRY(CATSCComponentType)
    EXTERN_OBJECT_ENTRY(CATSCLocator)
    EXTERN_OBJECT_ENTRY(CDVBTLocator)
    EXTERN_OBJECT_ENTRY(CDVBSLocator)
    EXTERN_OBJECT_ENTRY(CMPEG2TuneRequestFactory)
#ifndef TUNING_MODEL_ONLY
    EXTERN_OBJECT_ENTRY(CBroadcastEventService)
#endif
END_EXTERN_OBJECT_MAP()

using namespace BDATuningModel;
#ifndef TUNING_MODEL_ONLY
using namespace MSVideoControl;
#endif

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point
extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
    if (dwReason == DLL_PROCESS_ATTACH)
    {
#ifdef _DEBUG
        // Turn on leak-checking bit
        int tmpFlag = _CrtSetDbgFlag( _CRTDBG_REPORT_FLAG );
        tmpFlag |= _CRTDBG_LEAK_CHECK_DF;
        _CrtSetDbgFlag( tmpFlag );
#endif

        INTERNALIZE_OBJMAP(ObjectMap);
        _Module.Init(ObjectMap, hInstance, &LIBID_MSVidCtlLib);
        DisableThreadLibraryCalls(hInstance);
#ifndef TUNING_MODEL_ONLY
        // work around compiler bug where static member intializer's not being ctord
#ifdef DEBUG
        CString csModuleName;
        csModuleName.LoadString(IDS_PROJNAME);
        DebugInit(csModuleName);
#endif
        CtorStaticDSExtendFwdSeqPMFs();
        CtorStaticVWSegmentFwdSeqPMFs();
        CtorStaticVWDevicesFwdSeqPMFs();
#endif
    } else if (dwReason == DLL_PROCESS_DETACH) {
#ifndef TUNING_MODEL_ONLY
        // work around compiler bug where static member intializer's not being ctord
        DtorStaticDSExtendFwdSeqPMFs();
        DtorStaticVWSegmentFwdSeqPMFs();
        DtorStaticVWDevicesFwdSeqPMFs();
#ifdef DEBUG
        DebugTerm();
#endif
#endif
        _Module.Term();
        DESTROY_OBJMAP(ObjectMap);
    }
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifndef TUNING_MODEL_ONLY
    // register secondary .tlb(s)
    HRESULT hr = AtlModuleRegisterTypeLib(&_Module, OLESTR("\\2"));				// tuner.tlb
    if (SUCCEEDED(hr)) {
#else
                HRESULT hr;
#endif
                // registers object, typelib and all interfaces in typelib
                hr = _Module.RegisterServer(TRUE);
                if (SUCCEEDED(hr)) {
                    hr = PrxDllRegisterServer();
                    if (SUCCEEDED(hr)) {
#ifdef REGISTER_CANONICAL_TUNING_SPACES
                        hr = RegisterTuningSpaces(_Module.GetModuleInstance());// uses objects in this .dll must be done after any other registering
#endif
                    }
                }
#ifndef TUNING_MODEL_ONLY
    }
#endif
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef REGISTER_CANONICAL_TUNING_SPACES
    // ignore rc and unreg everything we can
    UnregisterTuningSpaces();  // uses objects in this .dll must be done before any other unregistering
#endif
    PrxDllUnregisterServer();
#ifndef TUNING_MODEL_ONLY
	AtlModuleUnRegisterTypeLib(&_Module, OLESTR("\\2"));  // tuner.tlb
#endif
	_Module.UnregisterServer(TRUE);

	return NOERROR;
}
// end of file - msvidctl.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\msviddataservices.h ===
//==========================================================================;
// MSVidDataServices.h : Declaration of the CMSVidDataServices
// copyright (c) Microsoft Corp. 1998-1999.
/////////////////////////////////////////////////////////////////////////////

#pragma once

#ifndef __MSVidDataServices_H_
#define __MSVidDataServices_H_

#include <algorithm>
#include <tchar.h>
#include <objectwithsiteimplsec.h>
#include "segimpl.h"
#include "dataserviceimpl.h"

#include "seg.h"

typedef CComQIPtr<ITuner> PQMSVidDataServices;

/////////////////////////////////////////////////////////////////////////////
// CMSVidDataServices
class ATL_NO_VTABLE __declspec(uuid("334125C0-77E5-11d3-B653-00C04F79498E")) CDataServices : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CDataServices, &__uuidof(CDataServices)>,
    public IObjectWithSiteImplSec<CDataServices>,
	public ISupportErrorInfo,
	public IConnectionPointContainerImpl<CDataServices>,
	public IMSVidGraphSegmentImpl<CDataServices, MSVidSEG_XFORM, &GUID_NULL>,
    public IMSVidDataServicesImpl<CDataServices, &LIBID_MSVidCtlLib, &GUID_NULL, IMSVidDataServices>
{
public:
    CDataServices() : m_iIPSink(-1) {
	}

REGISTER_AUTOMATION_OBJECT(IDS_PROJNAME, 
						   IDS_REG_DATASERVICES_PROGID, 
						   IDS_REG_DATASERVICES_DESC,
						   LIBID_MSVidCtlLib,
						   __uuidof(CDataServices));

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDataServices)
	COM_INTERFACE_ENTRY(IMSVidGraphSegment)
	COM_INTERFACE_ENTRY(IMSVidDataServices)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectWithSite)
	COM_INTERFACE_ENTRY(IMSVidFeature)
	COM_INTERFACE_ENTRY(IMSVidDevice)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(IPersist)
END_COM_MAP()

	BEGIN_CATEGORY_MAP(CDataServices)
		IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
		IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
		IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
	END_CATEGORY_MAP()

BEGIN_CONNECTION_POINT_MAP(CDataServices)
END_CONNECTION_POINT_MAP()


// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

public:
    PQCreateDevEnum m_pSystemEnum;
    int m_iIPSink;

    HRESULT Unload(void) {
        IMSVidGraphSegmentImpl<CDataServices, MSVidSEG_XFORM, &GUID_NULL>::Unload();
        m_iIPSink = -1;
		return NOERROR;
	}
// IMSVidGraphSegment
    STDMETHOD(Build)() {
        return NOERROR;
    }

    STDMETHOD(PreRun)() {
        return NOERROR;
    }

	STDMETHOD(put_Container)(IMSVidGraphSegmentContainer *pCtl)
	{
        if (!m_fInit) {
            return CO_E_NOTINITIALIZED;
        }
        try {
            if (!pCtl) {
                return Unload();
            }
            if (m_pContainer) {
				if (!m_pContainer.IsEqualObject(VWSegmentContainer(pCtl))) {
					return Error(IDS_OBJ_ALREADY_INIT, __uuidof(IMSVidDataServices), CO_E_ALREADYINITIALIZED);
				} else {
					return NO_ERROR;
				}
            }
            // DON'T addref the container.  we're guaranteed nested lifetimes
            // and an addref creates circular refcounts so we never unload.
            m_pContainer.p = pCtl;
            m_pGraph = m_pContainer.GetGraph();

			// bring in all bda renderers
            m_pSystemEnum = PQCreateDevEnum(CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER);
            DSDevices pe(m_pSystemEnum, KSCATEGORY_IP_SINK);
            DSDevices::iterator pit = pe.begin();
            if (!*pe.begin()) {
		        TRACELM(TRACE_ERROR, "CMSVidDataServices::put_Container() missing ipsink category, drivers not installed");
                return E_FAIL;
            }
            for (; pit != pe.end(); ++pit) {
			    DSFilter ipsink(m_pGraph.AddMoniker(*pe.begin()));
			    if (!ipsink) {
		            TRACELM(TRACE_ERROR, "CMSVidDataServices::put_Container() can't load ip sink");
				    return E_FAIL;
			    }
			    m_Filters.push_back(ipsink);
            }
			m_iIPSink = 0;  // assume ipsink was first in category
			return NOERROR;
        } catch (ComException &e) {
            return e;
        } catch(...) {
            return E_UNEXPECTED;
        }
		return NOERROR;
	}

    // IMSVidDevice
	STDMETHOD(get_Name)(BSTR * Name)
	{
        if (!m_fInit) {
            return CO_E_NOTINITIALIZED;
        }
        try {
            return GetName(((m_iIPSink > -1) ? (m_Filters[m_iIPSink]) : DSFilter()), m_pDev, CComBSTR(_T("BDA IPSink"))).CopyTo(Name);
        } catch(...) {
            return E_POINTER;
        }
	}

};

STDMETHODIMP CDataServices::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IMSVidDataServices
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

#endif //__MSVidDataServices_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\msviddvdbookmark.cpp ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: Bookmark.h                                                      */
/* Description: Implementation of Bookmark API                           */
/* Author: Steve Rowe                                                    */
/* Modified: David Janecek                                               */
/*************************************************************************/
#include "stdafx.h"
#include "msvidctl.h"
#include "msvidwebdvd.h"
#include "msviddvdadm.h"
#include "msviddvdBookmark.h"
#include "perfcntr.h"
/*************************************************************************/
/* Global consts.                                                        */
/*************************************************************************/
static const TCHAR g_szBookmark[] = TEXT("DVD.bookmark");

/*************************************************************************/
/* Outgoing interaface implementation.                                   */
/*************************************************************************/

/*************************************************************************/
/* Function: SaveBookmark                                                */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::SaveBookmark(){

    HRESULT hr = S_OK;

    try {

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        CComPtr<IDvdState> pBookmark;

        hr = pDvdInfo2->GetState(&pBookmark);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        hr = CBookmark::SaveToRegistry(pBookmark);
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function SaveBookmark */

/*************************************************************************/
/* Function: RestoreBookmark                                             */
/* Description: Restores the state by loading the bookmark stream        */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::RestoreBookmark(){
    VIDPERF_FUNC;
    HRESULT hr = S_OK;
    CComQIPtr<IDvdCmd>IDCmd;
    try {
       
        CComPtr<IDvdState> pBookmark;

        HRESULT hrTemp = CBookmark::LoadFromRegistry(&pBookmark);

        DeleteBookmark();

        if(SUCCEEDED(hrTemp)){

            INITIALIZE_GRAPH_IF_NEEDS_TO_BE
                
            if(!m_pDVDControl2){
                
                throw(E_UNEXPECTED);
            }/* end of if statement */
            hr = m_pDVDControl2->SetState(pBookmark, DVD_CMD_FLAG_Flush|DVD_CMD_FLAG_Block, 0);
            if(IDCmd){
                IDCmd->WaitForEnd();
            }

        }

    }/* end of try statement */
    catch(HRESULT hrTmp){
        DeleteBookmark();
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        DeleteBookmark();
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function RestoreBookmark */

/*************************************************************************/
/* Function: DeleteBookmark                                               */
/* Description: Blasts the bookmark file away.                           */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::DeleteBookmark(){

	HRESULT hr = S_OK;

    try {

        hr = CBookmark::DeleteFromRegistry();

    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function DeleteBookmark */


/*************************************************************/
/* Name: SaveToRegistry
/* Description: Save the bookmark to registry
/*************************************************************/
HRESULT CBookmark::SaveToRegistry(IDvdState *pbookmark)
{
	IPersistMemory* pPersistMemory;
    HRESULT hr = pbookmark->QueryInterface(IID_IPersistMemory, (void **) &pPersistMemory );

    if (SUCCEEDED(hr)) {

		ULONG ulMax;
		hr = pPersistMemory->GetSizeMax( &ulMax );
		if( SUCCEEDED( hr )) {

			BYTE *buffer = new BYTE[ulMax];
			hr = pPersistMemory->Save( buffer, TRUE, ulMax );
            
            DWORD dwLen = ulMax;
            if (SUCCEEDED(hr)) {
                BOOL bSuccess = SetRegistryBytesCU(g_szBookmark, buffer, dwLen);
                if (!bSuccess)
                    hr = E_FAIL;
            }

            delete[] buffer; 
        }
		pPersistMemory->Release();
    } 
	return hr;
}

/*************************************************************/
/* Name: LoadFromRegistry
/* Description: load the bookmark from registry
/*************************************************************/
HRESULT CBookmark::LoadFromRegistry(IDvdState **ppBookmark)
{
	HRESULT hr = CoCreateInstance( CLSID_DVDState, NULL, CLSCTX_INPROC_SERVER, IID_IDvdState, (LPVOID*) ppBookmark );

	if( SUCCEEDED( hr )) {

		IPersistMemory* pPersistMemory;
		hr = (*ppBookmark)->QueryInterface(IID_IPersistMemory, (void **) &pPersistMemory );

        if( SUCCEEDED( hr )) {

            ULONG ulMax;
            hr = pPersistMemory->GetSizeMax( &ulMax );
            
            if (SUCCEEDED(hr)) {
                
                BYTE *buffer = new BYTE[ulMax];
                DWORD dwLen = ulMax;
                BOOL bFound = GetRegistryBytesCU(g_szBookmark, buffer, &dwLen);
           
                if (bFound && dwLen != 0){
                    hr = pPersistMemory->Load( buffer, dwLen);
                }
                else{
					dwLen = ulMax;
                    bFound = GetRegistryBytes(g_szBookmark, buffer, &dwLen);
                    if (bFound && dwLen != 0){
                        hr = pPersistMemory->Load( buffer, dwLen);
                        if(SUCCEEDED(hr)){
                            SetRegistryBytes(g_szBookmark, NULL, 0);
                        }
                    }
                    else{
                        hr = E_FAIL;
                    }
                }
                delete[] buffer; 

            }
            pPersistMemory->Release();
        }
	}
	return hr;
}


/*************************************************************/
/* Name: DeleteFromRegistry
/* Description: load the bookmark from registry
/*************************************************************/
HRESULT CBookmark::DeleteFromRegistry()
{
    HRESULT hr = S_OK;
    BOOL bSuccess = SetRegistryBytesCU(g_szBookmark, NULL, 0);
    if (!bSuccess)
        hr = E_FAIL;
    return hr;
}

/*************************************************************************/
/* End of file: Bookmark.cpp                                             */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\msviddvdbookmark.h ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: Bookmark.h                                                      */
/* Description: Implementation of Bookmark API                           */
/* Author: Steve Rowe                                                    */
/* Modified: David Janecek                                               */
/*************************************************************************/
#ifndef __BOOKMARK_H
#define __BOOKMARK_H

class CBookmark {

public:	
    static HRESULT SaveToRegistry(IDvdState *ppBookmark);
    static HRESULT LoadFromRegistry(IDvdState **ppBookmark);
    static HRESULT DeleteFromRegistry();

};/* end of class CBookmark */

#endif // __BOOKMARK_H
/*************************************************************************/
/* Function: Bookmark.h                                                  */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\msviddvdadm.h ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: MSVidWebDVDAdm.h                                                */
/* Description: Declaration of the CMSDVDAdm                             */
/* Author: Fang Wang                                                     */
/*************************************************************************/

#ifndef __MSVidWebDVDAdm_H_
#define __MSVidWebDVDAdm_H_

#include "resource.h"       // main symbols
#include <atlctl.h>
#include <objectwithsiteimplsec.h>

#define MAX_PASSWD      256
#define PRE_PASSWD      20
#define MAX_SECTION     20
#define MAX_RATE        10

#define PARENTAL_LEVEL_DISABLED  -1

/////////////////////////////////////////////////////////////////////////////
// CMSDVDAdm
class ATL_NO_VTABLE __declspec(uuid("FA7C375B-66A7-4280-879D-FD459C84BB02")) CMSVidWebDVDAdm : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public IDispatchImpl<IMSVidWebDVDAdm, &IID_IMSVidWebDVDAdm, &LIBID_MSVidCtlLib>,
    public CComCoClass<CMSVidWebDVDAdm, &__uuidof(CMSVidWebDVDAdm)>,
    public IObjectWithSiteImplSec<CMSVidWebDVDAdm>,
    public IObjectSafetyImpl<CMSVidWebDVDAdm, INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA>,
    public ISupportErrorInfo
{
public:
    CMSVidWebDVDAdm();
    virtual ~CMSVidWebDVDAdm();

REGISTER_AUTOMATION_OBJECT(IDS_PROJNAME, 
                           IDS_REG_MSVIDWEBDVDADM_PROGID, 
                           IDS_REG_MSVIDWEBDVDADM_DESC,
                           LIBID_MSVidCtlLib,
                           __uuidof(CMSVidWebDVDAdm));

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMSVidWebDVDAdm)
    COM_INTERFACE_ENTRY(IMSVidWebDVDAdm)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectWithSite)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

BEGIN_PROP_MAP(CMSVidWebDVDAdm)
END_PROP_MAP()

// ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IMSDVDAdm
public:
    STDMETHOD(get_DefaultMenuLCID)(/*[out, retval]*/ long *pVal);
    STDMETHOD(put_DefaultMenuLCID)(/*[in]*/ long newVal);
    STDMETHOD(get_DefaultSubpictureLCID)(/*[out, retval]*/ long *pVal);
    STDMETHOD(put_DefaultSubpictureLCID)(/*[in]*/ long newVal);
    STDMETHOD(get_DefaultAudioLCID)(/*[out, retval]*/ long *pVal);
    STDMETHOD(put_DefaultAudioLCID)(/*[in]*/ long newVal);
    STDMETHOD(GetParentalCountry)(long *lCountry);
    STDMETHOD(GetParentalLevel)(long *lLevel);
    STDMETHOD(get_DisableScreenSaver)(/*[out, retval]*/ VARIANT_BOOL *pVal);
    STDMETHOD(put_DisableScreenSaver)(/*[in]*/ VARIANT_BOOL newVal);
    STDMETHOD(ChangePassword)(BSTR strUserName, BSTR strOld, BSTR strNew);
    STDMETHOD(ConfirmPassword)(BSTR strUserName, BSTR szPassword, VARIANT_BOOL *fRight);
    STDMETHOD(SaveParentalLevel)(long lParentalLevel,BSTR strUserName,  BSTR strPassword);
    STDMETHOD(SaveParentalCountry)(long lCountry,BSTR strUserName,  BSTR strPassword);
    STDMETHOD(get_BookmarkOnStop)(/*[out, retval]*/ VARIANT_BOOL *pVal);
    STDMETHOD(put_BookmarkOnStop)(/*[in]*/ VARIANT_BOOL newVal);
    STDMETHOD(RestoreScreenSaver)();    

protected:
    long        m_lParentctrlLevel;
    long        m_lParentctrlCountry;
    VARIANT_BOOL m_fDisableScreenSaver;
    BOOL        m_bScrnSvrOld;
    BOOL        m_bPowerlowOld;
    BOOL        m_bPowerOffOld;
    VARIANT_BOOL m_fBookmarkOnStop;

    HRESULT EncryptPassword(LPTSTR lpPassword, BYTE **lpAssaultedHash, DWORD *dwCryptLen, DWORD *dwAssault, BOOL genAssault);
    HRESULT DisableScreenSaver();
    HRESULT SaveScreenSaver();
    HRESULT HandleError(HRESULT hr);
};

BOOL SetRegistryString(const TCHAR *pKey, TCHAR *szString, DWORD dwLen);
BOOL GetRegistryString(const TCHAR *pKey, TCHAR *szRet, DWORD *dwLen, TCHAR *szDefault);
BOOL SetRegistryDword(const TCHAR *pKey, DWORD dwRet);
BOOL GetRegistryDword(const TCHAR *pKey, DWORD *dwRet, DWORD dwDefault);
BOOL SetRegistryBytes(const TCHAR *pKey, BYTE *szString, DWORD dwLen);
BOOL GetRegistryBytes(const TCHAR *pKey, BYTE *szRet, DWORD *dwLen);

    // Not so lame functions that use hkcu
BOOL SetRegistryStringCU(const TCHAR *pKey, TCHAR *szString, DWORD dwLen);
BOOL GetRegistryStringCU(const TCHAR *pKey, TCHAR *szRet, DWORD *dwLen, TCHAR *szDefault);
BOOL SetRegistryDwordCU(const TCHAR *pKey, DWORD dwRet);
BOOL GetRegistryDwordCU(const TCHAR *pKey, DWORD *dwRet, DWORD dwDefault);
BOOL SetRegistryBytesCU(const TCHAR *pKey, BYTE *szString, DWORD dwLen);
BOOL GetRegistryBytesCU(const TCHAR *pKey, BYTE *szRet, DWORD *dwLen);

#endif //__MSVidWebDVDAdm_H_

/*************************************************************************/
/* End of file: MSVidWebDVDAdm.h                                         */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\msvidencoder.cpp ===
//==========================================================================;
// MSVidEncoder.cpp : Declaration of the CMSVidEncoder
// copyright (c) Microsoft Corp. 1998-1999.
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#ifndef TUNING_MODEL_ONLY
#include "msvidencoder.h"

// HARD CODED pids for program stream video and audio
const ULONG g_AudioID = 0xC0;
const ULONG g_VideoID = 0xE0;

DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidEncoder, CEncoder)

// "Copied" From Demux Proppage

static BYTE g_Mpeg2ProgramVideo [] = {
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.rcSource.left              = 0x00000000
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.rcSource.top               = 0x00000000
    0xD0, 0x02, 0x00, 0x00,                         //  .hdr.rcSource.right             = 0x000002d0
    0xE0, 0x01, 0x00, 0x00,                         //  .hdr.rcSource.bottom            = 0x000001e0
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.rcTarget.left              = 0x00000000
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.rcTarget.top               = 0x00000000
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.rcTarget.right             = 0x00000000
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.rcTarget.bottom            = 0x00000000
    0x00, 0x09, 0x3D, 0x00,                         //  .hdr.dwBitRate                  = 0x003d0900
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.dwBitErrorRate             = 0x00000000
    0x63, 0x17, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, //  .hdr.AvgTimePerFrame            = 0x0000000000051763
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.dwInterlaceFlags           = 0x00000000
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.dwCopyProtectFlags         = 0x00000000
    0x04, 0x00, 0x00, 0x00,                         //  .hdr.dwPictAspectRatioX         = 0x00000004
    0x03, 0x00, 0x00, 0x00,                         //  .hdr.dwPictAspectRatioY         = 0x00000003
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.dwReserved1                = 0x00000000
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.dwReserved2                = 0x00000000
    0x28, 0x00, 0x00, 0x00,                         //  .hdr.bmiHeader.biSize           = 0x00000028
    0xD0, 0x02, 0x00, 0x00,                         //  .hdr.bmiHeader.biWidth          = 0x000002d0
    0xE0, 0x01, 0x00, 0x00,                         //  .hdr.bmiHeader.biHeight         = 0x00000000
    0x00, 0x00,                                     //  .hdr.bmiHeader.biPlanes         = 0x0000
    0x00, 0x00,                                     //  .hdr.bmiHeader.biBitCount       = 0x0000
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.bmiHeader.biCompression    = 0x00000000
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.bmiHeader.biSizeImage      = 0x00000000
    0xD0, 0x07, 0x00, 0x00,                         //  .hdr.bmiHeader.biXPelsPerMeter  = 0x000007d0
    0x27, 0xCF, 0x00, 0x00,                         //  .hdr.bmiHeader.biYPelsPerMeter  = 0x0000cf27
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.bmiHeader.biClrUsed        = 0x00000000
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.bmiHeader.biClrImportant   = 0x00000000
    0x98, 0xF4, 0x06, 0x00,                         //  .dwStartTimeCode                = 0x0006f498
    0x56, 0x00, 0x00, 0x00,                         //  .cbSequenceHeader               = 0x00000056
    0x02, 0x00, 0x00, 0x00,                         //  .dwProfile                      = 0x00000002
    0x02, 0x00, 0x00, 0x00,                         //  .dwLevel                        = 0x00000002
    0x00, 0x00, 0x00, 0x00,                         //  .Flags                          = 0x00000000
                                                    //  .dwSequenceHeader [1]
    0x00, 0x00, 0x01, 0xB3, 0x2D, 0x01, 0xE0, 0x24,
    0x09, 0xC4, 0x23, 0x81, 0x10, 0x11, 0x11, 0x12,
    0x12, 0x12, 0x13, 0x13, 0x13, 0x13, 0x14, 0x14,
    0x14, 0x14, 0x14, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16,
    0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17,
    0x18, 0x18, 0x18, 0x19, 0x18, 0x18, 0x18, 0x19,
    0x1A, 0x1A, 0x1A, 0x1A, 0x19, 0x1B, 0x1B, 0x1B,
    0x1B, 0x1B, 0x1C, 0x1C, 0x1C, 0x1C, 0x1E, 0x1E,
    0x1E, 0x1F, 0x1F, 0x21, 0x00, 0x00, 0x01, 0xB5,
    0x14, 0x82, 0x00, 0x01, 0x00, 0x00
} ;

//  WaveFormatEx format block; generated with the following settings:
//
//  fwHeadFlags         = 0x1c;
//  wHeadEmphasis       = 1;
//  fwHeadModeExt       = 1;
//  fwHeadMode          = 1;
//  dwHeadBitrate       = 0x3e800;
//  fwHeadLayer         = 0x2;
//  wfx.cbSize          = 0x16;
//  wfx.wBitsPerSample  = 0;
//  wfx.nBlockAlign     = 0x300;
//  wfx.nAvgBytesPerSec = 0x7d00;
//  wfx.nSamplesPerSec  = 0xbb80;
//  wfx.nChannels       = 2;
//  wfx.wFormatTag      = 0x50;
//  dwPTSLow            = 0;
//  dwPTSHigh           = 0;
static BYTE g_MPEG1AudioFormat [] = {
    0x50, 0x00, 0x02, 0x00, 0x80, 0xBB, 0x00, 0x00,
    0x00, 0x7D, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
    0x16, 0x00, 0x02, 0x00, 0x00, 0xE8, 0x03, 0x00,
    0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x1C, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
} ;
// End "Copied" From Demux Proppage

STDMETHODIMP CEncoder::get_AudioEncoderInterface(/*[out, retval]*/ IUnknown **ppEncInt){
    if(!ppEncInt){
        return E_POINTER;
    }
    DSMediaType mediaAudio(MEDIATYPE_Audio);
    DSFilter p_filter = m_Filters[m_iEncoder];
    HRESULT hr = E_NOINTERFACE;
    // Starting at the ecoder filter find the pin/filter implimenting the endcoder api for audio
    // This should work because of two facts
    // 1. only one audio path or audio path coming into the encoder filter
    // 2. we only need to find one matching media type to identify the pin type 
    do{
        DSFilter::iterator pins;
        // check the current filters pins for a audio media type
        for(pins = p_filter.begin(); pins != p_filter.end(); ++pins){
            for(DSPin::iterator mTypes = (*pins).begin(); mTypes != (*pins).end(); ++mTypes){
                if((*mTypes) == mediaAudio){
                    // see if the current pin impliments the encoder api
                    (*pins).QueryInterface(&m_qiAudEnc) ;
                    if(m_qiAudEnc){
                        hr = m_qiAudEnc.QueryInterface(ppEncInt);
                        if(SUCCEEDED(hr)){
                            return S_OK;
                        }
                        else{
                            return E_UNEXPECTED;
                        }
                    }
                    break;
                }
            }
            // If we did not get to the end of the media types then we found a audio type and the pin did not inpliment the interface
            // time to track backwards
            if(mTypes != (*pins).end() &&  (*pins).GetDirection() == PINDIR_INPUT){
                // Following the audio path get the next filter backwards from current filter
                DSPin back = (*pins).GetConnection();
                if(back){
                    p_filter = back.GetFilter();
                    // Check to see if the new filter impliments the encoder api
                    if(p_filter){
                        p_filter.QueryInterface(&m_qiAudEnc);
                        if(m_qiAudEnc){
                            hr = m_qiAudEnc.QueryInterface(ppEncInt);
                            if(SUCCEEDED(hr)){
                                return S_OK;
                            }
                            else{
                                return E_UNEXPECTED;
                            }
                        }
                    }
                }
                break;
            }
        }
        if(pins == p_filter.end()){
            p_filter.Release();
        }
    } while(p_filter && FAILED(hr));
    
    return hr;
}

STDMETHODIMP CEncoder::get_VideoEncoderInterface(/*[out, retval]*/ IUnknown **ppEncInt){
    if(!ppEncInt){
        return E_POINTER;
    }
    DSMediaType mediaVideo(MEDIATYPE_Video);
    DSFilter p_filter = m_Filters[m_iEncoder];
    HRESULT hr = E_NOINTERFACE;   
    if(!m_qiVidEnc){
        hr = p_filter.QueryInterface(&m_qiVidEnc);
        if(FAILED(hr)){
            m_qiVidEnc = static_cast<IUnknown*>(NULL);
        }
    }

    if(m_qiVidEnc){
        hr = m_qiVidEnc.QueryInterface(ppEncInt);                
        if(SUCCEEDED(hr)){
            return S_OK;
        }
        else{
            return hr;
        }
    }

    // Starting at the ecoder filter find the pin/filter implimenting the endcoder api for video
    // This should work because of two facts
    // 1. only one video path or audio path coming into the encoder filter
    // 2. we only need to find one matching media type to identify the pin type 
    do{
        DSFilter::iterator pins;
        // check the current filters pins for a video media type
        for(pins = p_filter.begin(); pins != p_filter.end(); ++pins){
            DSPin::iterator mTypes;
            for(mTypes = (*pins).begin(); mTypes != (*pins).end(); ++mTypes){
                if((*mTypes) == mediaVideo){
                    // see if the current pin impliments the encoder api
                    (*pins).QueryInterface(&m_qiVidEnc) ;
                    if(m_qiVidEnc){
                        hr = m_qiVidEnc.QueryInterface(ppEncInt);
                        if(SUCCEEDED(hr)){
                            return S_OK;
                        }
                        else{
                            return hr;
                        }
                    }
                    break;
                }
            }
            // If we did not get to the end of the media types then we found a video type and the pin did not inpliment the interface
            // time to track backwards
            if(mTypes != (*pins).end() &&  (*pins).GetDirection() == PINDIR_INPUT){
                // Following the video path get the next filter backwards from current filter
                DSPin back = (*pins).GetConnection();
                if(back){
                    p_filter = back.GetFilter();
                    // Check to see if the new filter impliments the encoder api
                    if(p_filter){
                        p_filter.QueryInterface(&m_qiVidEnc);
                        if(m_qiVidEnc){
                            hr = m_qiVidEnc.QueryInterface(ppEncInt);
                            if(SUCCEEDED(hr)){
                                return S_OK;
                            }
                            else{
                                return E_UNEXPECTED;
                            }
                        }
                    }
                }
                break;
            }
        }
        if(pins == p_filter.end()){
            p_filter.Release();
        }
    } while(p_filter && FAILED(hr));
    
    return hr;
}

HRESULT CEncoder::Unload(void) {
    IMSVidGraphSegmentImpl<CEncoder, MSVidSEG_XFORM, &GUID_NULL>::Unload();
    m_iEncoder = -1;
    m_qiVidEnc.Release();
    m_qiAudEnc.Release();
    return NOERROR;
}
// IMSVidGraphSegment
STDMETHODIMP CEncoder::Build() {
    return NOERROR;
}

STDMETHODIMP CEncoder::PreRun() {
    return NOERROR;
}

STDMETHODIMP CEncoder::put_Container(IMSVidGraphSegmentContainer *pCtl){
    if (!m_fInit) {
        return CO_E_NOTINITIALIZED;
    }
    try {
        if (!pCtl) {
            return Unload();
        }

        if (m_pContainer) {
            if (!m_pContainer.IsEqualObject(VWSegmentContainer(pCtl))) {
                return Error(IDS_OBJ_ALREADY_INIT, __uuidof(IMSVidEncoder), CO_E_ALREADYINITIALIZED);
            } else {
                return NO_ERROR;
            }
        }
        
        // DON'T addref the container.  we're guaranteed nested lifetimes
        // and an addref creates circular refcounts so we never unload.
        m_pContainer.p = pCtl;
        m_pGraph = m_pContainer.GetGraph();
        
        // Add some filters when there is an encoder api

        DSFilter pEncoder(m_pGraph.AddMoniker(m_pDev));
        if (!pEncoder) {
            return E_UNEXPECTED;
        }
        
        m_Filters.push_back(pEncoder);
        m_iEncoder = 0;
        TRACELM(TRACE_DETAIL, "CMSVidEncoder::put_Container() Encoder added");
        
        DSFilter::iterator fPin;
        DSMediaType mpeg2ProgramType(MEDIATYPE_Stream, MEDIASUBTYPE_MPEG2_PROGRAM);
        DSMediaType streamType(MEDIATYPE_Stream);
        for(fPin = pEncoder.begin(); fPin != pEncoder.end(); ++fPin) {
            DSPin curPin(*fPin);
            DSPin::iterator pMedia;
            
            // Find the Mpeg2 Progam Steam Pin if there is one
            for(pMedia = curPin.begin(); pMedia != curPin.end(); ++pMedia){
                if ((*pMedia) == streamType && curPin.GetDirection() == PINDIR_OUTPUT){
                    break;
                }
            }
            
            if(pMedia == curPin.end()){
                continue;
            }
            else{
                if((*pMedia) == mpeg2ProgramType){
                    // Found the program stream pin get a demux and set it up
                    CComQIPtr<IMpeg2Demultiplexer> qiDeMux;
                    qiDeMux.CoCreateInstance(CLSID_MPEG2Demultiplexer);

                    if(!qiDeMux){
                        ASSERT(FALSE);
                        return E_UNEXPECTED;
                    }

                    DSFilter DeMux(qiDeMux);
                    DSFilterList intermediates;
                    CString csName(_T("MPEG-2 Demultiplexer"));

                    HRESULT hr = m_pGraph.AddFilter(DeMux, csName);
                    if (FAILED(hr)) {
                        ASSERT(FALSE);
                        return E_UNEXPECTED;
                    }

                    m_Filters.push_back(DeMux);
                    m_iDemux = m_Filters.size() - 1;

                    for(DSFilter::iterator dPin = DeMux.begin(); dPin != DeMux.end(); ++dPin){
                        DSPin demuxIn(*dPin);
                        if(demuxIn.GetDirection() == PINDIR_INPUT){
                            hr = demuxIn.Connect(curPin);
                            if (FAILED(hr)) {
                                ASSERT(FALSE);
                                return E_UNEXPECTED;
                            }
                        }
                    }

                    // Sprout the audio and video pins on the demxu
                    DSPin dspAudio, dspVideo;
                    DSMediaType mtVideo(MEDIATYPE_Video, MEDIASUBTYPE_MPEG2_VIDEO, FORMAT_MPEG2Video);
                    mtVideo.p->bFixedSizeSamples = TRUE;
                    mtVideo.p->cbFormat = sizeof(g_Mpeg2ProgramVideo);
                    mtVideo.p->pbFormat = g_Mpeg2ProgramVideo;

                    DSMediaType mtAudio(MEDIATYPE_Audio, MEDIASUBTYPE_MPEG1Payload, FORMAT_WaveFormatEx);
                    mtAudio.p->bFixedSizeSamples = TRUE;
                    mtAudio.p->cbFormat = sizeof(g_MPEG1AudioFormat);
                    mtAudio.p->pbFormat = g_MPEG1AudioFormat;

                    CComBSTR szAudio("Audio Pin");
                    CComBSTR szVideo("Video Pin");

                    hr = qiDeMux->CreateOutputPin(mtAudio, szAudio, &dspAudio);
                    if (FAILED(hr)) {
                        ASSERT(FALSE);
                        return E_UNEXPECTED;
                    }

                    hr = qiDeMux->CreateOutputPin(mtVideo, szVideo, &dspVideo); 
                    if (FAILED(hr)) {
                        ASSERT(FALSE);
                        return E_UNEXPECTED;
                    }

                    // Map the pids correctly
                    // TODO: use the encoder api to find the pids for audio and video
                    CComQIPtr<IMPEG2StreamIdMap>qiMapper(dspVideo);
                    hr = qiMapper->MapStreamId(g_VideoID, MPEG2_PROGRAM_ELEMENTARY_STREAM, 0, 0);
                    if (FAILED(hr)) {
                        ASSERT(FALSE);
                        return E_UNEXPECTED;
                    }

                    qiMapper = dspAudio;
                    hr = qiMapper->MapStreamId(g_AudioID, MPEG2_PROGRAM_ELEMENTARY_STREAM, 0, 0);
                    if (FAILED(hr)) {
                        ASSERT(FALSE);
                        return E_UNEXPECTED;
                    }

                    // Clean up
                    mtVideo.p->cbFormat = 0;
                    mtVideo.p->pbFormat = 0;
                    mtAudio.p->cbFormat = 0;
                    mtAudio.p->pbFormat = 0;
                    break;
                }
#if 0 // code to support custom demux (e.g. asf/wmv demux by a third party)
                else{
                    CRegKey c;
                    TCHAR szCLSID[MAX_PATH + 1];
                    szCLSID[0] = 0;
                    CString keyname(_T("SOFTWARE\\Debug\\MSVidCtl"));
                    DWORD rc = c.Open(HKEY_LOCAL_MACHINE, keyname, KEY_READ);
                    if (rc == ERROR_SUCCESS) {
                        DWORD len = sizeof(szCLSID);
                        rc = c.QueryValue(szCLSID, _T("CustomDemuxCLSID"), &len);
                        if (rc != ERROR_SUCCESS) {
                            szCLSID[0] = 0;
                        }
                    }
                    DSFilter DeMux;
                    CComBSTR asfCLSID(szCLSID);
                    GUID2 asfDemux(asfCLSID);
                    DeMux.CoCreateInstance(asfDemux);

                    if(!DeMux){
                        ASSERT(FALSE);
                        return E_UNEXPECTED;
                    }

                    DSFilterList intermediates;
                    CString csName(_T("Custom Demultiplexer"));

                    HRESULT hr = m_pGraph.AddFilter(DeMux, csName);
                    if (FAILED(hr)) {
                        ASSERT(FALSE);
                        return E_UNEXPECTED;
                    }

                    m_Filters.push_back(DeMux);
                    m_iDemux = m_Filters.size() - 1;

                    for(DSFilter::iterator dPin = DeMux.begin(); dPin != DeMux.end(); ++dPin){
                        DSPin demuxIn(*dPin);
                        if(demuxIn.GetDirection() == PINDIR_INPUT){
                            hr = demuxIn.Connect(curPin);
                            if (FAILED(hr)) {
                                ASSERT(FALSE);
                                return E_UNEXPECTED;
                            }
                        }
                    }
                }
#endif
            }                
            
            
        }
        // Don't fail if there is no program stream pin. could be elementry streams or non-mpeg content
        return NOERROR;
    } catch (ComException &e) {
        return e;
    } catch(...) {
        return E_UNEXPECTED;
    }
    return NOERROR;
}

// IMSVidDevice
STDMETHODIMP CEncoder::get_Name(BSTR * Name){
    if (!m_fInit) {
        return CO_E_NOTINITIALIZED;
    }
    try {

        CComBSTR DefaultName("Encoder Segment");
        return GetName(((m_iEncoder > -1) ? (m_Filters[m_iEncoder]) : DSFilter()), m_pDev, DefaultName).CopyTo(Name);
        return NOERROR;
    } catch(...) {
        return E_POINTER;
    }
}



STDMETHODIMP CEncoder::InterfaceSupportsErrorInfo(REFIID riid){
    static const IID* arr[] = 
    {
        &IID_IMSVidEncoder
    };
    for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++){
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}
#endif // TUNING_MODEL_ONLY
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\msvidencoder.h ===
//==========================================================================;
// MSVidEncoder.h : Declaration of the CMSVidEncoder
// copyright (c) Microsoft Corp. 1998-1999.
/////////////////////////////////////////////////////////////////////////////

#pragma once

#ifndef __MSVidEncoder_H_
#define __MSVidEncoder_H_

#include <algorithm>
#include <tchar.h>
#include <objectwithsiteimplsec.h>
#include "segimpl.h"
#include "encoderimpl.h"
#include <strmif.h>
#include "seg.h"

typedef CComQIPtr<ITuner> PQMSVidEncoder;

/////////////////////////////////////////////////////////////////////////////
// CMSVidEncoder
class ATL_NO_VTABLE __declspec(uuid("BB530C63-D9DF-4b49-9439-63453962E598")) CEncoder : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CEncoder, &__uuidof(CEncoder)>,
    public IObjectWithSiteImplSec<CEncoder>,
	public ISupportErrorInfo,
	public IConnectionPointContainerImpl<CEncoder>,
	public IMSVidGraphSegmentImpl<CEncoder, MSVidSEG_XFORM, &GUID_NULL>,
    public IMSVidEncoderImpl<CEncoder, &LIBID_MSVidCtlLib, &GUID_NULL, IMSVidEncoder>
{
public:
    CEncoder() : m_iEncoder(-1), m_iDemux(-1) {
	}

REGISTER_AUTOMATION_OBJECT(IDS_PROJNAME, 
						   IDS_REG_ENCODER_PROGID, 
						   IDS_REG_ENCODER_DESC,
						   LIBID_MSVidCtlLib,
						   __uuidof(CEncoder));

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CEncoder)
	COM_INTERFACE_ENTRY(IMSVidGraphSegment)
	COM_INTERFACE_ENTRY(IMSVidEncoder)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectWithSite)
	COM_INTERFACE_ENTRY(IMSVidFeature)
	COM_INTERFACE_ENTRY(IMSVidDevice)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(IPersist)
END_COM_MAP()

	BEGIN_CATEGORY_MAP(CEncoder)
		IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
		IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
		IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
	END_CATEGORY_MAP()

BEGIN_CONNECTION_POINT_MAP(CEncoder)
END_CONNECTION_POINT_MAP()


// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

public:
    PQCreateDevEnum m_pSystemEnum;
    int m_iEncoder;
    int m_iDemux;

    HRESULT Unload(void);
    STDMETHOD(get_AudioEncoderInterface)(/*[out, retval]*/ IUnknown **ppEncInt);
    STDMETHOD(get_VideoEncoderInterface)(/*[out, retval]*/ IUnknown **ppEncInt);
    // IMSVidGraphSegment
    STDMETHOD(Build)();

    STDMETHOD(PreRun)();

	STDMETHOD(put_Container)(IMSVidGraphSegmentContainer *pCtl);
    // IMSVidDevice
	STDMETHOD(get_Name)(BSTR * Name);
protected:
    CComQIPtr<IVideoEncoder> m_qiVidEnc;
    CComQIPtr<IEncoderAPI> m_qiAudEnc;
};

#endif //__MSVidEncoder_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\msviddvdadm.cpp ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: MSVidWebDVDAdm.cpp                                              */
/* Description: DImplementation of CMSVidWebDVDAdm                       */
/* Author: Fang Wang                                                     */
/*************************************************************************/
#include "stdafx.h"
#include "MSVidCtl.h"
#include "MSVidDVDAdm.h"
#include "iso3166.h"
#include <stdio.h>
#include <errors.h>
#include <wincrypt.h>

DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidWebDVDAdm, CMSVidWebDVDAdm)

const TCHAR g_szRegistryKey[] = TEXT("Software\\Microsoft\\Multimedia\\DVD");
const TCHAR g_szPassword[] = TEXT("DVDAdmin.password");
const TCHAR g_szSalt[] = TEXT("DVDAdmin.ps"); // password salt
const TCHAR g_szUserSalt[] = TEXT("DVDAdmin.us"); // username salt
const TCHAR g_szUsername[] = TEXT("DVDAdmin.username");
const TCHAR g_szPlayerLevel[] = TEXT("DVDAdmin.playerLevel");
const TCHAR g_szPlayerCountry[] = TEXT("DVDAdmin.playerCountry");
const TCHAR g_szDisableScrnSvr[] = TEXT("DVDAdmin.disableScreenSaver");
const TCHAR g_szBookmarkOnStop[] = TEXT("DVDAdmin.bookmarkOnStop");
const TCHAR g_szDefaultAudio[] = TEXT("DVDAdmin.defaultAudioLCID");
const TCHAR g_szDefaultSP[] = TEXT("DVDAdmin.defaultSPLCID");
const TCHAR g_szDefaultMenu[] = TEXT("DVDAdmin.defaultMenuLCID");

/*************************************************************/
/* Helper functions                                          */
/*************************************************************/

/*************************************************************/
/* Name: GetRegistryDword
/* Description: 
/*************************************************************/
BOOL GetRegistryDword(const TCHAR *pKey, DWORD* dwRet, DWORD dwDefault)
{
    HKEY hKey;
    LONG lRet;
    *dwRet = dwDefault;

    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, g_szRegistryKey, 0, KEY_QUERY_VALUE, &hKey);
    if (lRet == ERROR_SUCCESS) {

        DWORD   dwType, dwLen;
        dwLen = sizeof(DWORD);

        if (ERROR_SUCCESS != RegQueryValueEx(hKey, pKey, NULL, &dwType, (LPBYTE)dwRet, &dwLen)){ 
            *dwRet = dwDefault;
            RegCloseKey(hKey);
            return FALSE;
        }

        RegCloseKey(hKey);
    }
    return (lRet == ERROR_SUCCESS);
}

/*************************************************************/
/* Name: SetRegistryDword
/* Description: 
/*************************************************************/
BOOL SetRegistryDword(const TCHAR *pKey, DWORD dwRet)
{
    HKEY hKey;
    LONG lRet;

    lRet = RegCreateKey(HKEY_LOCAL_MACHINE, g_szRegistryKey, &hKey);
    if (lRet == ERROR_SUCCESS) {

        lRet = RegSetValueEx(hKey, pKey, NULL, REG_DWORD, (LPBYTE)&dwRet, sizeof(dwRet));
        RegCloseKey(hKey);
    }
    return (lRet == ERROR_SUCCESS);
}

/*************************************************************/
/* Name: GetRegistryString
/* Description: 
/*************************************************************/
BOOL GetRegistryString(const TCHAR *pKey, TCHAR* szRet, DWORD* dwLen, TCHAR* szDefault)
{
    HKEY hKey;
    LONG lRet;
    DWORD dwTempLen = 0;
    lstrcpyn(szRet, szDefault, *dwLen);

    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, g_szRegistryKey, 0, KEY_QUERY_VALUE, &hKey);
    if (lRet == ERROR_SUCCESS) {
        DWORD dwType;
        dwTempLen = (*dwLen) * sizeof(TCHAR);
        if (ERROR_SUCCESS != RegQueryValueEx(hKey, pKey, NULL, &dwType, (LPBYTE)szRet, &dwTempLen)) {
            lstrcpyn(szRet, szDefault, *dwLen);
            *dwLen = 0;
        }

        *dwLen = dwTempLen/sizeof(TCHAR);
        RegCloseKey(hKey);
    }

    return (lRet == ERROR_SUCCESS);
}

/*************************************************************/
/* Name: SetRegistryString
/* Description: 
/*************************************************************/
BOOL SetRegistryString(const TCHAR *pKey, TCHAR *szString, DWORD dwLen)
{
    HKEY hKey;
    LONG lRet;

    lRet = RegCreateKey(HKEY_LOCAL_MACHINE, g_szRegistryKey, &hKey);
    if (lRet == ERROR_SUCCESS) {

        lRet = RegSetValueEx(hKey, pKey, NULL, REG_SZ, (LPBYTE)szString, dwLen*sizeof(TCHAR));
        RegCloseKey(hKey);
    }
    return (lRet == ERROR_SUCCESS);
}

/*************************************************************/
/* Name: GetRegistryByte
/* Description: 
/*************************************************************/
BOOL GetRegistryBytes(const TCHAR *pKey, BYTE* szRet, DWORD* dwLen)
{
    HKEY hKey;
    LONG lRet;

    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, g_szRegistryKey, 0, KEY_QUERY_VALUE, &hKey);
    if (lRet == ERROR_SUCCESS) {

        DWORD dwType;
        if (ERROR_SUCCESS != RegQueryValueEx(hKey, pKey, NULL, &dwType, (LPBYTE)szRet, dwLen)) {
            *dwLen = 0;
        }
        RegCloseKey(hKey);
    }
    return (lRet == ERROR_SUCCESS);
}

/*************************************************************/
/* Name: SetRegistryBytes
/* Description: 
/*************************************************************/
BOOL SetRegistryBytes(const TCHAR *pKey, BYTE *szString, DWORD dwLen)
{
    HKEY hKey;
    LONG lRet;

    lRet = RegCreateKey(HKEY_LOCAL_MACHINE, g_szRegistryKey, &hKey);

    BOOL bRet = TRUE;
    if (lRet == ERROR_SUCCESS) {

        if (szString == NULL) {
            lRet = RegDeleteValue(hKey, pKey);
            bRet = (lRet == ERROR_SUCCESS) || (lRet == ERROR_FILE_NOT_FOUND);
        }
        else  {
            lRet = RegSetValueEx(hKey, pKey, NULL, REG_BINARY, (LPBYTE)szString, dwLen);
            bRet = (lRet == ERROR_SUCCESS);
        }

        RegCloseKey(hKey);
    }
    return (bRet);
}

// Start not so lame functions

/*************************************************************/
/* Name: GetRegistryDwordCU
/* Description: 
/*************************************************************/
BOOL GetRegistryDwordCU(const TCHAR *pKey, DWORD* dwRet, DWORD dwDefault)
{
    HKEY hKey;
    LONG lRet;
    *dwRet = dwDefault;

    lRet = RegOpenKeyEx(HKEY_CURRENT_USER, g_szRegistryKey, 0, KEY_QUERY_VALUE, &hKey);
    if (lRet == ERROR_SUCCESS) {

        DWORD   dwType, dwLen;
        dwLen = sizeof(DWORD);

        if (ERROR_SUCCESS != RegQueryValueEx(hKey, pKey, NULL, &dwType, (LPBYTE)dwRet, &dwLen)){ 
            *dwRet = dwDefault;
            RegCloseKey(hKey);
            return FALSE;
        }

        RegCloseKey(hKey);
    }
    return (lRet == ERROR_SUCCESS);
}

/*************************************************************/
/* Name: SetRegistryDwordCU
/* Description: 
/*************************************************************/
BOOL SetRegistryDwordCU(const TCHAR *pKey, DWORD dwRet)
{
    HKEY hKey;
    LONG lRet;

    lRet = RegCreateKey(HKEY_CURRENT_USER, g_szRegistryKey, &hKey);
    if (lRet == ERROR_SUCCESS) {

        lRet = RegSetValueEx(hKey, pKey, NULL, REG_DWORD, (LPBYTE)&dwRet, sizeof(dwRet));
        RegCloseKey(hKey);
    }
    return (lRet == ERROR_SUCCESS);
}

/*************************************************************/
/* Name: GetRegistryStringCU
/* Description: 
/*************************************************************/
BOOL GetRegistryStringCU(const TCHAR *pKey, TCHAR* szRet, DWORD* dwLen, TCHAR* szDefault)
{
    HKEY hKey;
    LONG lRet;
    DWORD dwTempLen = 0;
    lstrcpyn(szRet, szDefault, *dwLen);

    lRet = RegOpenKeyEx(HKEY_CURRENT_USER, g_szRegistryKey, 0, KEY_QUERY_VALUE, &hKey);
    if (lRet == ERROR_SUCCESS) {

        DWORD dwType;
        dwTempLen = (*dwLen) * sizeof(TCHAR);
        if (ERROR_SUCCESS != RegQueryValueEx(hKey, pKey, NULL, &dwType, (LPBYTE)szRet, &dwTempLen)) {
            lstrcpyn(szRet, szDefault, sizeof(szRet) / sizeof(szRet[0]));
            *dwLen = 0;
        }
        *dwLen = dwTempLen/sizeof(TCHAR);
        RegCloseKey(hKey);
    }
    return (lRet == ERROR_SUCCESS);
}

/*************************************************************/
/* Name: SetRegistryStringCU
/* Description: 
/*************************************************************/
BOOL SetRegistryStringCU(const TCHAR *pKey, TCHAR *szString, DWORD dwLen)
{
    HKEY hKey;
    LONG lRet;

    lRet = RegCreateKey(HKEY_CURRENT_USER, g_szRegistryKey, &hKey);
    if (lRet == ERROR_SUCCESS) {

        lRet = RegSetValueEx(hKey, pKey, NULL, REG_SZ, (LPBYTE)szString, dwLen*sizeof(TCHAR));
        RegCloseKey(hKey);
    }
    return (lRet == ERROR_SUCCESS);
}

/*************************************************************/
/* Name: GetRegistryByteCU
/* Description: 
/*************************************************************/
BOOL GetRegistryBytesCU(const TCHAR *pKey, BYTE* szRet, DWORD* dwLen)
{
    HKEY hKey;
    LONG lRet;

    lRet = RegOpenKeyEx(HKEY_CURRENT_USER, g_szRegistryKey, 0, KEY_QUERY_VALUE, &hKey);
    if (lRet == ERROR_SUCCESS) {

        DWORD dwType;
        if (ERROR_SUCCESS != RegQueryValueEx(hKey, pKey, NULL, &dwType, (LPBYTE)szRet, dwLen)) {
            *dwLen = 0;
        }
        RegCloseKey(hKey);
    }
    return (lRet == ERROR_SUCCESS);
}

/*************************************************************/
/* Name: SetRegistryBytesCU
/* Description: 
/*************************************************************/
BOOL SetRegistryBytesCU(const TCHAR *pKey, BYTE *szString, DWORD dwLen)
{
    HKEY hKey;
    LONG lRet;

    lRet = RegCreateKey(HKEY_CURRENT_USER, g_szRegistryKey, &hKey);

    BOOL bRet = TRUE;
    if (lRet == ERROR_SUCCESS) {

        if (szString == NULL) {
            lRet = RegDeleteValue(hKey, pKey);
            bRet = (lRet == ERROR_SUCCESS) || (lRet == ERROR_FILE_NOT_FOUND);
        }
        else  {
            lRet = RegSetValueEx(hKey, pKey, NULL, REG_BINARY, (LPBYTE)szString, dwLen);
            bRet = (lRet == ERROR_SUCCESS);
        }

        RegCloseKey(hKey);
    }
    return (bRet);
}

// end not so lame functions


/*************************************************************/
/* Function: CMSVidWebDVDAdm                                 */
/*************************************************************/
CMSVidWebDVDAdm::CMSVidWebDVDAdm(){

    DWORD temp;
    GetRegistryDword(g_szPlayerLevel, &temp, (DWORD)8);		
    m_lParentctrlLevel = temp;

    GetRegistryDword(g_szPlayerCountry, &temp, (DWORD)0);		
    m_lParentctrlCountry = temp;

    GetRegistryDword(g_szDisableScrnSvr, &temp, (DWORD)VARIANT_TRUE);		
    m_fDisableScreenSaver = (VARIANT_BOOL)temp;
    SaveScreenSaver();
    if (m_fDisableScreenSaver != VARIANT_FALSE)
        DisableScreenSaver();

    GetRegistryDword(g_szBookmarkOnStop, &temp, (DWORD)VARIANT_FALSE);		
    m_fBookmarkOnStop = (VARIANT_BOOL)temp;
}/* end of function CMSVidWebDVDAdm */

/*************************************************************/
/* Function: ~CMSVidWebDVDAdm                                */
/*************************************************************/
CMSVidWebDVDAdm::~CMSVidWebDVDAdm(){

    RestoreScreenSaver();
}/* end of function ~CMSVidWebDVDAdm */

/*************************************************************/
/* Name: EncryptPassword                                     */
/* Description: Hash the password                            */
/* Params:                                                   */
/*  lpPassword: password to hash                             */
/*  lpAssaultedHash: hashed password,                        */
/*      allocated by this fucntion, released by caller       */
/*  p_dwAssault: salt, save with hash; or salt passed in     */
/*  genAssault: TRUE = generate salt; FALSE = salt passed in */
/*************************************************************/
HRESULT CMSVidWebDVDAdm::EncryptPassword(LPTSTR lpPassword, BYTE **lpAssaultedHash, DWORD *p_dwCryptLen, DWORD *p_dwAssault, BOOL genAssault){
    if(!lpPassword || !lpAssaultedHash || !p_dwAssault || !p_dwCryptLen){
        return E_POINTER;
    }
    if( lstrlen(lpPassword) > MAX_PASSWD){
        return E_INVALIDARG;
    }
    
    HCRYPTPROV hProv = NULL;   // Handle to Crypto Context
    HCRYPTHASH hHash = NULL;   // Handle to Hash Function    
    DWORD dwAssault = 0;       // As(Sa)u(lt) for hash
    DWORD dwAssaultedHash = 0; // Length of Assaulted hash
    
    // Init Crypto Context
    if(!CryptAcquireContext(&hProv, 0, 0, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)){
        return E_UNEXPECTED;
    }
    
    // Store the Salt in dwAssault, either generate it or copy the user passed value
    if(genAssault){        
        if(!CryptGenRandom(hProv, sizeof(DWORD), reinterpret_cast<BYTE *>(&dwAssault))){
            if(hProv) CryptReleaseContext(hProv, 0);                                                                       
            return E_UNEXPECTED;   
        }
        *p_dwAssault = dwAssault;
    }
    else{
        dwAssault = *p_dwAssault;
    }
    
    // Create the handle to the Hash function
    if(!CryptCreateHash(hProv, CALG_SHA1, 0, 0, &hHash)){
        if(hProv) CryptReleaseContext(hProv, 0);                                  
        if(hHash) CryptDestroyHash(hHash);                                      
        return E_UNEXPECTED;
    }
    
    // Hash the password
    if(!CryptHashData(hHash, reinterpret_cast<BYTE *>(lpPassword), lstrlen(lpPassword)*sizeof(lpPassword[0]), 0)){
        if(hProv) CryptReleaseContext(hProv, 0);                                  
        if(hHash) CryptDestroyHash(hHash);                                      
        return E_UNEXPECTED;
    }
    
    // Add the salt
    if(!CryptHashData(hHash, reinterpret_cast<BYTE *>(&dwAssault), sizeof(DWORD), 0)){
        if(hProv) CryptReleaseContext(hProv, 0);                                  
        if(hHash) CryptDestroyHash(hHash);                                      
        return E_UNEXPECTED;
    }
    
    // Get the size of the hashed data
    if(!CryptGetHashParam(hHash, HP_HASHVAL, 0, &dwAssaultedHash, 0)){
        if(hProv) CryptReleaseContext(hProv, 0);                                  
        if(hHash) CryptDestroyHash(hHash);                                      
        return E_UNEXPECTED;
    }
    
    // Allocate a string large enough to hold the hash data and a null
    *lpAssaultedHash = new BYTE[dwAssaultedHash];
    if(!lpAssaultedHash){
        if(hProv) CryptReleaseContext(hProv, 0);                                  
        if(hHash) CryptDestroyHash(hHash);                                      
        return E_UNEXPECTED;
    }
    
    // Zero the string
    ZeroMemory(*lpAssaultedHash, dwAssaultedHash);
    
    // Copy length of Encrypted bytes to return value
    *p_dwCryptLen = dwAssaultedHash;
    
    // Get the hash data and store it in a string
    if(!CryptGetHashParam(hHash, HP_HASHVAL, *lpAssaultedHash, &dwAssaultedHash, 0)){
        if(hProv) CryptReleaseContext(hProv, 0);                                  
        if(hHash) CryptDestroyHash(hHash);                                      
        if(lpAssaultedHash){
            delete[] *lpAssaultedHash;
            *lpAssaultedHash = NULL;
        }
        return E_UNEXPECTED;
    }
    
    // Clean up
    if(hProv) CryptReleaseContext(hProv, 0);                                  
    if(hHash) CryptDestroyHash(hHash);                                      

    return S_OK;

}/* end of function EncryptPassword */


/*************************************************************/
/* Function: ConfirmPassword                                 */
/* Description: comfired a password with the one saved       */
/*************************************************************/
STDMETHODIMP CMSVidWebDVDAdm::ConfirmPassword(BSTR /* strUserName */,
											  BSTR strPassword, VARIANT_BOOL *fRight){
	
    HRESULT hr = S_OK;
	
    try {
        USES_CONVERSION;
		*fRight = VARIANT_FALSE;
		if(!strPassword || !fRight){
			return E_POINTER;
		}

        UINT bStrLen = lstrlen(strPassword);
        if(bStrLen >= MAX_PASSWD){
            return E_INVALIDARG;
        }
		
        LPTSTR szPassword = OLE2T(strPassword);
        BYTE szSavedPasswd[MAX_PASSWD];
        DWORD dwLen = MAX_PASSWD+PRE_PASSWD;
        BOOL bFound = GetRegistryBytes(g_szPassword, szSavedPasswd, &dwLen);
		
        // if no password has been set yet
        if (!bFound || dwLen == 0) {
			
            // so in this case accept only an empty string 
            if(lstrlen(szPassword) <= 0){
				
                *fRight = VARIANT_TRUE;
            }
            else {
				
                *fRight = VARIANT_FALSE;
            }
            throw (hr);
        }
        
        DWORD dwAssault = 0;
        bFound = GetRegistryDword(g_szSalt, &dwAssault, 0);
        if(!bFound ){
            // Old style password since there is no salt
            // ignore current password until it is reset
            *fRight = VARIANT_TRUE;
            throw(hr);
        }

        // Encrypt the password with the salt from the registry
	    BYTE *pszEncrypted = NULL;
        DWORD dwCryptLen = 0;
        hr = EncryptPassword(szPassword, &pszEncrypted, &dwCryptLen, &dwAssault, FALSE);
        if(FAILED(hr)){
            throw (hr);
        }

        // Compare the Encrypted input password with the saved password
        if(memcmp(pszEncrypted, szSavedPasswd, (dwAssault <= dwLen?dwAssault:dwLen) ) == 0)
            *fRight = VARIANT_TRUE;
        else
            *fRight = VARIANT_FALSE;
        delete[] pszEncrypted;
    }
    catch(HRESULT hrTmp){
		
        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }
	
    if(FAILED(hr)){
        Sleep(1000);
    }

    return (HandleError(hr));        
}/* end of function ConfirmPassword */

/*************************************************************/
/* Function: ChangePassword                                  */
/* Description: password change requested                    */
/*************************************************************/
STDMETHODIMP CMSVidWebDVDAdm::ChangePassword(BSTR strUserName, 
                                       BSTR strOldPassword, BSTR strNewPassword){

    HRESULT hr = S_OK;

    try {

        USES_CONVERSION;
		if(!strNewPassword){
			throw E_POINTER;
		}
        if(lstrlen(strNewPassword) >= MAX_PASSWD){
            //Error(IDS_PASSWORD_LENGTH);
            throw E_INVALIDARG;
        }

        LPTSTR szNewPassword = OLE2T(strNewPassword);

        // Confirm old password first
        VARIANT_BOOL temp;
        ConfirmPassword(strUserName, strOldPassword, &temp);
        if (temp == VARIANT_FALSE){

            throw E_ACCESSDENIED;
        }

        DWORD dwAssault = 0;
        DWORD dwCryptLen = 0;
        BYTE *pszEncrypted = NULL;
        
	    hr = EncryptPassword(szNewPassword, &pszEncrypted, &dwCryptLen, &dwAssault, TRUE);
        if(FAILED(hr)){
            throw E_FAIL;
        }

        BOOL bSuccess = SetRegistryBytes(g_szPassword, pszEncrypted, dwCryptLen);
        if (!bSuccess){
            hr = E_FAIL;
        }

        delete[] pszEncrypted;

        // If storing the password hash failed, don't store the salt
        if(SUCCEEDED(hr)){
            bSuccess = SetRegistryDword(g_szSalt, dwAssault);
            if (!bSuccess){
                hr = E_FAIL;
            }
        }

    }
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

    return HandleError(hr);        
}/* end of function ChangePassword */

/*************************************************************/
/* Function: SaveParentalLevel                               */
/*************************************************************/
STDMETHODIMP CMSVidWebDVDAdm::SaveParentalLevel(long lParentalLevel, 
                         BSTR strUserName, BSTR strPassword){
    HRESULT hr = S_OK;

    try {

        if (lParentalLevel != PARENTAL_LEVEL_DISABLED && 
           (lParentalLevel < 1 || lParentalLevel > 8)) {

            throw (E_INVALIDARG);
        } 

        if (m_lParentctrlLevel != lParentalLevel) {

            // Confirm password first
            VARIANT_BOOL temp;
            ConfirmPassword(strUserName, strPassword, &temp);
            if (temp == VARIANT_FALSE)
                throw (E_ACCESSDENIED);

        }
    
        BOOL bSuccess = SetRegistryDword(g_szPlayerLevel, (DWORD) lParentalLevel);
        if (!bSuccess){
            throw E_FAIL;
        }

        m_lParentctrlLevel = lParentalLevel;

    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

    return HandleError(hr);
}/* end of function SaveParentalLevel */

/*************************************************************/
/* Name: SaveParentalCountry                                 */
/*************************************************************/
STDMETHODIMP CMSVidWebDVDAdm::SaveParentalCountry(long lCountry,                                               
                        BSTR strUserName,BSTR strPassword){

    HRESULT hr = S_OK;

    try {

        if(lCountry < 0 && lCountry > 0xffff){

            throw(E_INVALIDARG);
        }/* end of if statement */

        BYTE bCountryCode[2];

        bCountryCode[0] = BYTE(lCountry>>8);
        bCountryCode[1] = BYTE(lCountry);

        // convert the input country code to upper case by applying ToUpper to each letter
        WORD wCountry = ISO3166::PackCode( (char *)bCountryCode );
        BOOL bFound = FALSE;

        for( unsigned i=0; i<ISO3166::GetNumCountries(); i++ )
        {
            if( ISO3166::PackCode(ISO3166::GetCountry(i).Code) == wCountry )
            {
                bFound = TRUE;
            }
        }

        // Not a valid country code
        if (!bFound) {

            throw(E_INVALIDARG);
        }/* end of if statement */

        if (m_lParentctrlCountry != lCountry) {

            // Confirm password first
            VARIANT_BOOL temp;
            ConfirmPassword(strUserName, strPassword, &temp);
            if (temp == VARIANT_FALSE)
                throw(E_ACCESSDENIED);
        
        }
    
        BOOL bSuccess = SetRegistryDword(g_szPlayerCountry, (DWORD) lCountry);
        if (!bSuccess){
            throw E_FAIL;
        }    

        m_lParentctrlCountry = lCountry;
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

    return (HandleError(hr));        
}/* end of function SaveParentalCountry */

/*************************************************************/
/* Function: put_DisableScreenSaver                          */
/*************************************************************/
STDMETHODIMP CMSVidWebDVDAdm::put_DisableScreenSaver(VARIANT_BOOL fDisable){

    HRESULT hr = S_OK;

    try {

        if (fDisable == VARIANT_FALSE)
            RestoreScreenSaver();
        else 
            DisableScreenSaver();

        SetRegistryDword(g_szDisableScrnSvr, (DWORD) fDisable);
        m_fDisableScreenSaver = fDisable;
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

    return HandleError(hr);        
}/* end of function put_DisableScreenSaver */

/*************************************************************/
/* Function: get_DisableScreenSaver                          */
/*************************************************************/
STDMETHODIMP CMSVidWebDVDAdm::get_DisableScreenSaver(VARIANT_BOOL *fDisable){

    HRESULT hr = S_OK;

    try {
        if(NULL == fDisable){

            hr = E_POINTER;
            throw(hr);
        }/* end of if statement */
   
        *fDisable = m_fDisableScreenSaver;
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

    return HandleError(hr);
}/* end of function get_DisableScreenSaver */

/*************************************************************/
/* Function: SaveScreenSaver                                 */
/*************************************************************/
HRESULT CMSVidWebDVDAdm::SaveScreenSaver(){
    /*
    SystemParametersInfo(SPI_GETSCREENSAVEACTIVE, 0, &m_bScrnSvrOld, 0);
    SystemParametersInfo(SPI_GETLOWPOWERACTIVE, 0, &m_bPowerlowOld, 0);
    SystemParametersInfo(SPI_GETPOWEROFFACTIVE, 0, &m_bPowerOffOld, 0);
    */
    return S_OK;
}
/*************************************************************/
/* Function: DisableScreenSaver                              */
/*************************************************************/
HRESULT CMSVidWebDVDAdm::DisableScreenSaver(){
    /*
    SystemParametersInfo(SPI_SETSCREENSAVEACTIVE, FALSE, NULL, 0);
    SystemParametersInfo(SPI_SETLOWPOWERACTIVE, FALSE, NULL, 0);
    SystemParametersInfo(SPI_SETPOWEROFFACTIVE, FALSE, NULL, 0);
    */
    return S_OK;
}/* end of function DisableScreenSaver */

/*************************************************************/
/* Function: RestoreScreenSaver                              */
/*************************************************************/
STDMETHODIMP CMSVidWebDVDAdm::RestoreScreenSaver(){

    HRESULT hr = S_OK;

    try {
        /*
        SystemParametersInfo(SPI_SETSCREENSAVEACTIVE, m_bScrnSvrOld, NULL, 0);
        SystemParametersInfo(SPI_SETLOWPOWERACTIVE, m_bPowerlowOld, NULL, 0);
        SystemParametersInfo(SPI_SETPOWEROFFACTIVE, m_bPowerOffOld, NULL, 0);
        */
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

    return HandleError(hr);
}/* end of function RestoreScreenSaver */

/*************************************************************/
/* Function: GetParentalLevel                                */
/*************************************************************/
STDMETHODIMP CMSVidWebDVDAdm::GetParentalLevel(long *lLevel){

    HRESULT hr = S_OK;

    try {
        if(NULL == lLevel){

            hr = E_POINTER;
            throw(hr);
        }/* end of if statement */

        *lLevel = m_lParentctrlLevel;

    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

    return HandleError(hr);        
}/* end of function GetParentalLevel */

/*************************************************************/
/* Function: GetParentalCountry                              */
/*************************************************************/
STDMETHODIMP CMSVidWebDVDAdm::GetParentalCountry(long *lCountry){

    HRESULT hr = S_OK;

    try {
        if(NULL == lCountry){

            hr = E_POINTER;
            throw(hr);
        }/* end of if statement */

        *lCountry = m_lParentctrlCountry;
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

    return HandleError(hr);        
}/* end of function GetParentalCountry */

/*************************************************************/
/* Name: get_DefaultAudioLCID
/* Description: -1 means title default
/*************************************************************/
STDMETHODIMP CMSVidWebDVDAdm::get_DefaultAudioLCID(long *pVal){

    HRESULT hr = S_OK;

    try {

        if(NULL == pVal){

            hr = E_POINTER;
            throw(hr);
        }/* end of if statement */
    
        GetRegistryDwordCU(g_szDefaultAudio, (DWORD*) pVal, (DWORD)-1);
    }    
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

    return HandleError(hr);        
} /* end of function get_DefaultAudioLCID */

/*************************************************************/
/* Name: put_DefaultAudioLCID
/* Description: -1 means title default
/*************************************************************/
STDMETHODIMP CMSVidWebDVDAdm::put_DefaultAudioLCID(long newVal)
{
    HRESULT hr = S_OK;

    try {

        if (!::IsValidLocale(newVal, LCID_SUPPORTED) && newVal != -1) {

            throw (E_INVALIDARG);
        } /* end of if statement */
    
        SetRegistryDwordCU(g_szDefaultAudio, (DWORD) newVal);
    }    
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

    return HandleError(hr);
} /* end of put_DefaultAudioLCID */

/*************************************************************/
/* Name: get_DefaultSubpictureLCID
/* Description: -1 means title default
/*************************************************************/
STDMETHODIMP CMSVidWebDVDAdm::get_DefaultSubpictureLCID(long *pVal)
{
    HRESULT hr = S_OK;

    try {
        if(NULL == pVal){

            hr = E_POINTER;
            throw(hr);
        }/* end of if statement */

        GetRegistryDwordCU(g_szDefaultSP, (DWORD*) pVal, (DWORD)-1);
    }    
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

    return HandleError(hr);	
} /* end of get_DefaultSubpictureLCID */

/*************************************************************/
/* Name: put_DefaultSubpictureLCID
/* Description: -1 means title default
/*************************************************************/
STDMETHODIMP CMSVidWebDVDAdm::put_DefaultSubpictureLCID(long newVal)
{
    HRESULT hr = S_OK;

    try {

        if (!::IsValidLocale(newVal, LCID_SUPPORTED) && newVal != -1) {

            throw (E_INVALIDARG);
        } /* end of if statement */
    
        SetRegistryDwordCU(g_szDefaultSP, (DWORD) newVal);
    }    
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

	return HandleError(hr);
} /* end of put_DefaultSubpictureLCID */

/*************************************************************/
/* Name: get_DefaultMenuLCID
/* Description: -1 means title default
/*************************************************************/
STDMETHODIMP CMSVidWebDVDAdm::get_DefaultMenuLCID(long *pVal)
{
    HRESULT hr = S_OK;

    try {

       if(NULL == pVal){

            hr = E_POINTER;
            throw(hr);
        }/* end of if statement */

        GetRegistryDwordCU(g_szDefaultMenu, (DWORD*) pVal, (DWORD)-1);
    }    
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

	return HandleError(hr);
} /* end of get_DefaultMenuLCID */

/*************************************************************/
/* Name: put_DefaultMenuLCID
/* Description: -1 means title default
/*************************************************************/
STDMETHODIMP CMSVidWebDVDAdm::put_DefaultMenuLCID(long newVal)
{
    HRESULT hr = S_OK;

    try {

        if (!::IsValidLocale(newVal, LCID_SUPPORTED) && newVal != -1) {

            throw (E_INVALIDARG);
        } /* end of if statement */
    
        SetRegistryDwordCU(g_szDefaultMenu, (DWORD) newVal);
    }    
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

	return HandleError(hr); 
} /* end of put_DefaultMenuLCID */

/*************************************************************/
/* Name: put_BookmarkOnStop
/* Description: 
/*************************************************************/
STDMETHODIMP CMSVidWebDVDAdm::put_BookmarkOnStop(VARIANT_BOOL fEnable){

    HRESULT hr = S_OK;

    try {
        m_fBookmarkOnStop = fEnable;
        SetRegistryDword(g_szBookmarkOnStop, (DWORD) fEnable);
    }    
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

	return HandleError(hr);
}

/*************************************************************/
/* Name: get_BookmarkOnStop
/* Description: 
/*************************************************************/
STDMETHODIMP CMSVidWebDVDAdm::get_BookmarkOnStop(VARIANT_BOOL *fEnable){
    
    HRESULT hr = S_OK;

    try {

       if(NULL == fEnable){

           hr = E_POINTER;
           throw(hr);
       }/* end of if statement */

       *fEnable = m_fBookmarkOnStop;
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

	return HandleError(hr);
}

/*************************************************************************/
/* Function: InterfaceSupportsErrorInfo                                  */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVDAdm::InterfaceSupportsErrorInfo(REFIID riid){	
	static const IID* arr[] = {
        &IID_IMSVidWebDVDAdm,		
	};

	for (int i=0; i<sizeof(arr)/sizeof(arr[0]); i++){
		if (InlineIsEqualGUID(*arr[i], riid))
			return S_OK;
	}/* end of for loop */

	return S_FALSE;
}/* end of function InterfaceSupportsErrorInfo */

/*************************************************************************/
/* Function: HandleError                                                 */
/* Description: Gets Error Descriptio, so we can suppor IError Info.     */
/*************************************************************************/
HRESULT CMSVidWebDVDAdm::HandleError(HRESULT hr){

    try {

        if(FAILED(hr)){
#if 0        
            TCHAR strError[MAX_ERROR_TEXT_LEN] = TEXT("");

            if(AMGetErrorText(hr , strError , MAX_ERROR_TEXT_LEN)){
                USES_CONVERSION;
                Error(T2W(strError));
            } 
            else {
                    ATLTRACE(TEXT("Unhandled Error Code \n")); // please add it
                    ATLASSERT(FALSE);
            }/* end of if statement */
#endif
        }/* end of if statement */
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        // keep the hr same    
    }/* end of catch statement */
    
	return (hr);
}/* end of function HandleError */

/*************************************************************************/
/* End of file: MSVidWebDVDAdm.cpp                                       */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\msvidfileplayback.h ===
//==========================================================================;
// MSVidFilePlayback.h : Declaration of the CMSVidFilePlayback class
// copyright (c) Microsoft Corp. 1998-1999.
//==========================================================================;

#ifndef __MSVidFILEPLAYBACK_H_
#define __MSVidFILEPLAYBACK_H_

#pragma once

#include <algorithm>
#include <objectwithsiteimplsec.h>
#include "pbsegimpl.h"
#include "fileplaybackimpl.h"
#include "fileplaybackcp.h"
#include "seg.h"
#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CMSVidFilePlayback
class ATL_NO_VTABLE __declspec(uuid("37B0353C-A4C8-11d2-B634-00C04F79498E")) CMSVidFilePlayback : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMSVidFilePlayback, &__uuidof(CMSVidFilePlayback)>,
    public IObjectWithSiteImplSec<CMSVidFilePlayback>,
	public ISupportErrorInfo,
	public IConnectionPointContainerImpl<CMSVidFilePlayback>,
    public CProxy_FilePlaybackEvent<CMSVidFilePlayback>,
	public IMSVidPBGraphSegmentImpl<CMSVidFilePlayback, MSVidSEG_SOURCE, &GUID_NULL>,
    public IMSVidFilePlaybackImpl<CMSVidFilePlayback, &LIBID_MSVidCtlLib, &GUID_NULL, IMSVidFilePlayback>,
    public IProvideClassInfo2Impl<&CLSID_MSVidFilePlaybackDevice, &IID_IMSVidFilePlaybackEvent, &LIBID_MSVidCtlLib>
{
public:
    CMSVidFilePlayback()
    {
        m_fEnableResetOnStop = true;
    }

REGISTER_AUTOMATION_OBJECT(IDS_PROJNAME, 
						   IDS_REG_FILEPLAYBACK_PROGID, 
						   IDS_REG_FILEPLAYBACK_DESC,
						   LIBID_MSVidCtlLib,
						   __uuidof(CMSVidFilePlayback));

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMSVidFilePlayback)
	COM_INTERFACE_ENTRY(IMSVidFilePlayback)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectWithSite)
	COM_INTERFACE_ENTRY(IMSVidGraphSegment)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(IMSVidPlayback)
	COM_INTERFACE_ENTRY(IMSVidInputDevice)
	COM_INTERFACE_ENTRY(IMSVidDevice)
	COM_INTERFACE_ENTRY(IPersist)
	COM_INTERFACE_ENTRY(IProvideClassInfo2)
	COM_INTERFACE_ENTRY(IProvideClassInfo)
END_COM_MAP()

	BEGIN_CATEGORY_MAP(CMSVidFilePlayback)
		IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
		IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
		IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
	END_CATEGORY_MAP()

BEGIN_CONNECTION_POINT_MAP(CMSVidFilePlayback)
	CONNECTION_POINT_ENTRY(IID_IMSVidFilePlaybackEvent)    
END_CONNECTION_POINT_MAP()


// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

public:
    STDMETHOD(put_Rate)(double lRate);
    STDMETHOD(get_Rate)(double *lRate);
    STDMETHOD(PostStop)();
    STDMETHOD(PostRun)();
    STDMETHOD(PreStop)();
    // DON'T addref the container.  we're guaranteed nested lifetimes
    // and an addref creates circular refcounts so we never unload.
    CComBSTR __declspec(property(get=GetName)) m_Name;
    CComBSTR GetName(void) {
        CString csName;
        if(m_iReader != -1){
            csName = (m_Filters[m_iReader]).GetName();
        }        
        if (csName.IsEmpty()) {
            csName = _T("File Playback");
        }
        return CComBSTR(csName);
    }
    HRESULT Unload(void) {
        HRESULT hr = IMSVidGraphSegmentImpl<CMSVidFilePlayback, MSVidSEG_SOURCE, &GUID_NULL>::Unload();
        m_iReader = -1;
        return hr;
	}

    virtual ~CMSVidFilePlayback() {}

// IMSVidGraphSegment
	STDMETHOD(put_Init)(IUnknown *pInit)
	{
        HRESULT hr = IMSVidGraphSegmentImpl<CMSVidFilePlayback, MSVidSEG_SOURCE, &GUID_NULL>::put_Init(pInit);
        if (FAILED(hr)) {
            return hr;
        }
        if (pInit) {
            m_fInit = false;
            return E_NOTIMPL;
        }
        return NOERROR;
	}

    STDMETHOD(Build)();
	STDMETHOD(put_Container)(IMSVidGraphSegmentContainer *pVal);
    STDMETHOD(OnEventNotify)(long lEvent, LONG_PTR lParam1, LONG_PTR lParam2);

// IMSVidDevice
	STDMETHOD(get_Name)(BSTR * Name)
	{
        if (!m_fInit) {
	 	    return Error(IDS_OBJ_NO_INIT, __uuidof(IMSVidFilePlayback), CO_E_NOTINITIALIZED);
        }
		if (Name == NULL)
			return E_POINTER;
        try {
		    *Name = m_Name.Copy();	
        } catch(...) {
            return E_POINTER;
        }
		return NOERROR;
	}
    // IMSVidInputDevice
	STDMETHOD(IsViewable)(VARIANT* pv, VARIANT_BOOL *pfViewable)
	{
        if (!m_fInit) {
	 	    return Error(IDS_OBJ_NO_INIT, __uuidof(IMSVidFilePlayback), CO_E_NOTINITIALIZED);
        }
        if (!pv) {
			return E_POINTER;
        }
		return E_NOTIMPL;
	}
	STDMETHOD(View)(VARIANT* pv) {
        if (!m_fInit) {
	 	    return Error(IDS_OBJ_NO_INIT, __uuidof(IMSVidFilePlayback), CO_E_NOTINITIALIZED);
        }
		if (!pv) {
			return E_POINTER;
		}
        if (pv->vt != VT_BSTR) {
			return E_INVALIDARG;
        }
        // if its a string then its either a dvd url or a filename
        // we don't do dvd urls
        if (!_wcsnicmp(pv->bstrVal, L"DVD:", 4)) {
            return E_FAIL;
        }
        if (m_pGraph && !m_pGraph.IsStopped()) {
	        return Error(IDS_INVALID_STATE, __uuidof(IMSVidFilePlayback), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
        }
		return put_FileName(pv->bstrVal);
	}
// IMSVidPlayback
// IMSVidFilePlayback
};

#endif //__MSVidFILEPLAYBACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\msvidfileplayback.cpp ===
//==========================================================================;
//
// Copyright (c) Microsoft Corporation 1999-2000.
//
//--------------------------------------------------------------------------;
//
// MSVidFilePlayback.cpp : Implementation of CMSVidFilePlayback
//

#include "stdafx.h"

#ifndef TUNING_MODEL_ONLY

#include "atltmp.h"
#include "MSVidCtl.h"
#include "MSVidFilePlayback.h"
#include <nserror.h>
#include <wmsdkidl.h>

#define FILE_BEGINNING 0
#define LOCAL_OATRUE -1
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidFilePlaybackDevice, CMSVidFilePlayback)

/////////////////////////////////////////////////////////////////////////////
// CMSVidFilePlayback

STDMETHODIMP CMSVidFilePlayback::PostRun(){
    if(m_fGraphInit){
        InitGraph();
        m_fGraphInit = false;
    }
    return IMSVidPBGraphSegmentImpl<CMSVidFilePlayback, MSVidSEG_SOURCE, &GUID_NULL>::PostRun();
}

STDMETHODIMP CMSVidFilePlayback::put_Rate(double lRate){
    HRESULT hr = S_OK;
    try{
        /*** Checking args and init'ing interfaces ***/

        if (!m_pGraph) {
            // graph not valid
            return Error(IDS_INVALID_STATE, __uuidof(IMSVidFilePlayback), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
        }

        // Attempt to set the rate using IMediaSeeking
        DSFilter Reader = m_Filters[m_iReader];
        PQMediaSeeking PQIMSeeking;
        if(Reader){
            for(DSFilter::iterator iPin = Reader.begin(); iPin != Reader.end(); ++iPin){
                PQIMSeeking = (*iPin);
                if(PQIMSeeking){
                    TRACELSM(TRACE_DETAIL,  (dbgDump << "MSVidFilePlayback::put_Rate found Pin"), ""); 
                    break;
                }
            }
        }
        if(!PQIMSeeking){
            TRACELSM(TRACE_DETAIL,  (dbgDump << "MSVidFilePlayback::put_Rate using graph"), ""); 
            PQIMSeeking = m_pGraph;
        }

        if(PQIMSeeking){
            TRACELSM(TRACE_DETAIL,  (dbgDump << "MSVidFilePlayback::put_Rate using Imediaseeking"), "");
            return PQIMSeeking->SetRate(lRate);
        }
        // If IMediaSeeking FAILS try IMediaPostion
        PQMediaPosition PQIMPos(m_pGraph);
        if(PQIMPos){
            // Change rate
            TRACELSM(TRACE_DETAIL,  (dbgDump << "MSVidFilePlayback::put_Rate using Imediaposition"), "");
            return PQIMPos->put_Rate((double)lRate);
        }

        // Could Not QI Either one set the error
        return Error(IDS_E_CANTQI , __uuidof(IMSVidFilePlayback), E_NOINTERFACE);

    }

    catch(HRESULT hrTmp){
        // Something went bad, threw a HRESULT				
        return Error(IDS_INVALID_STATE , __uuidof(IMSVidFilePlayback), hrTmp);
    }
    catch(...){
        // Something went bad, dont know what it threw
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CMSVidFilePlayback::get_Rate(double *lRate){
    HRESULT hr = S_OK;
    try{
        /*** Checking args and init'ing interfaces ***/

        if (!m_pGraph) {
            // graph not valid
            return Error(IDS_INVALID_STATE, __uuidof(IMSVidFilePlayback), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
        }

        // Attempt to set the rate using IMediaSeeking
        DSFilter Reader = m_Filters[m_iReader];
        PQMediaSeeking PQIMSeeking;
        if(Reader){
            for(DSFilter::iterator iPin = Reader.begin(); iPin != Reader.end(); ++iPin){
                PQIMSeeking = (*iPin);
                if(PQIMSeeking){
                    break;
                }
            }
        }
        if(!PQIMSeeking){
            PQIMSeeking = m_pGraph;
        }

        if(PQIMSeeking){
            return PQIMSeeking->GetRate(lRate);
        }
        // If IMediaSeeking FAILS try IMediaPostion
        PQMediaPosition PQIMPos(m_pGraph);
        if(PQIMPos){
            // Change rate
            return PQIMPos->get_Rate(lRate);
        }

        // Could Not QI Either one set the error
        return Error(IDS_E_CANTQI , __uuidof(IMSVidFilePlayback), E_NOINTERFACE);

    }

    catch(HRESULT hrTmp){
        // Something went bad, threw a HRESULT				
        return Error(IDS_INVALID_STATE , __uuidof(IMSVidFilePlayback), hrTmp);
    }
    catch(...){
        // Something went bad, dont know what it threw
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CMSVidFilePlayback::PreStop(){
    TRACELSM(TRACE_DETAIL,  (dbgDump << "MSVidFilePlayback::PreStop()"), ""); 
    double curRate = 0;
    HRESULT hr = get_Rate(&curRate);
    if(SUCCEEDED(hr) && curRate != 1){
        hr = IMSVidFilePlaybackImpl<CMSVidFilePlayback, &LIBID_MSVidCtlLib, &GUID_NULL, IMSVidFilePlayback>::put_Rate(1);
        if(FAILED(hr)){
            TRACELSM(TRACE_ERROR,  (dbgDump << "MSVidFilePlayback::PreStop() base put_Rate 1 failed"), ""); 
        }

        hr = put_Rate(1);
        if(FAILED(hr)){
            TRACELSM(TRACE_ERROR,  (dbgDump << "MSVidFilePlayback::PreStop() put_Rate 1 failed"), ""); 
        }
    }
    else{
        TRACELSM(TRACE_ERROR,  (dbgDump << "MSVidFilePlayback::PreStop() get_Rate failed"), ""); 
    }

    return NOERROR;
}

STDMETHODIMP CMSVidFilePlayback::PostStop(){
    HRESULT hr = S_OK;
    TRACELSM(TRACE_DETAIL,  (dbgDump << "MSVidFilePlayback::PostStop()"), ""); 
    try {
#if 0
        // If the graph is not is stopped state
        // we make sure it is
        if (!m_pGraph.IsStopped()) {
            HRESULT hr = PQVidCtl(m_pContainer)->Stop();
        }
#endif 
        // If m_fEnableResetOnStop is true then we need to reset 
        // the postion back to the beggining
        // else do nothing
        // If it fails file cannot be reset to beginning
        if(m_fEnableResetOnStop){
            put_CurrentPosition(0);
        }
    }
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }
	return hr;
}

STDMETHODIMP CMSVidFilePlayback::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IMSVidFilePlayback
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

STDMETHODIMP CMSVidFilePlayback::put_Container(IMSVidGraphSegmentContainer *pCtl)
{
    try {
        if (!m_fInit) {
	        return Error(IDS_OBJ_NO_INIT, __uuidof(IMSVidFilePlayback), CO_E_NOTINITIALIZED);
        }
        if (!pCtl) {
            return Unload();
        }
        if (m_pContainer) {
            if (!m_pContainer.IsEqualObject(VWSegmentContainer(pCtl))) {
                return Error(IDS_OBJ_ALREADY_INIT, __uuidof(IMSVidFilePlayback), CO_E_ALREADYINITIALIZED);
            } else {
                return NO_ERROR;
            }
        }
        
        // DON'T addref the container.  we're guaranteed nested lifetimes
        // and an addref creates circular refcounts so we never unload.
        m_pContainer.p = pCtl;
        m_pGraph = m_pContainer.GetGraph();
        return NOERROR;
    } catch (ComException &e) {
        return e;
    } catch (...) {
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CMSVidFilePlayback::Build() {
    if (!m_FileName) {
        return Error(IDS_INVALID_STATE, __uuidof(IMSVidFilePlayback), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
    }
    if(m_Filters.size() > 0){
        return NOERROR;
    }
    USES_CONVERSION;
    CString csName(_T("File Playback"));
    DSFilter pfr;
    HRESULT hr = pfr.CoCreateInstance(CLSID_WMAsfReader,0, CLSCTX_INPROC_SERVER);
    if(SUCCEEDED(hr)){
        CComQIPtr<IFileSourceFilter> pqFS(pfr);
        if(!!pqFS){
            // set the target ASF filename
            hr = pqFS->Load(m_FileName, NULL);
            if(FAILED(hr)){
                if(hr == (HRESULT)NS_E_LICENSE_REQUIRED){
                    CComQIPtr<IWMDRMReader> pq_DRMReader(pqFS);
                    if(pq_DRMReader){
                        hr = pq_DRMReader->AcquireLicense(1); // 1 == attempt silently
                        if(SUCCEEDED(hr)){
                            hr = pqFS->Load(m_FileName, NULL);
                        }
                        else{
                            TRACELSM(TRACE_ERROR,  (dbgDump << "MSVidFilePlayback::Build() Could not acquire license"), ""); 
                        }
                    }
                    else{
                       TRACELSM(TRACE_ERROR,  (dbgDump << "MSVidFilePlayback::Build() Could not qi for IWMDRMReader "), ""); 
                    }
                }
            }
            if(SUCCEEDED(hr)){
                // add the ASF writer filter to the graph
                hr = m_pGraph->AddFilter(pfr, csName);
                if(SUCCEEDED(hr)){
                    TRACELSM(TRACE_ERROR,  (dbgDump << "MSVidFilePlayback::Build() added WMV filter to graph hr = " << std::hex << hr), "");
                }
                else{
                    TRACELSM(TRACE_ERROR,  (dbgDump << "MSVidFilePlayback::Build() could not add filter to graph hr = " << std::hex << hr), "");
                }
            }
            else{
                TRACELSM(TRACE_ERROR,  (dbgDump << "MSVidFilePlayback::Build() Could not set file name, hr = " << std::hex << hr), "");
            }
        }
        else{
            TRACELSM(TRACE_ERROR,  (dbgDump << "MSVidFilePlayback::Build() Could not get IFileSourceFilter interface, hr = " << std::hex << hr), "");
        }
    }
    else{
        TRACELSM(TRACE_ERROR,  (dbgDump << "MSVidFilePlayback::Build() CreateFilter AsfReader failed, hr = " << std::hex << hr), "");
    }

    if (FAILED(hr)) {
        hr = m_pGraph->AddSourceFilter(m_FileName, csName, &pfr);
        if(FAILED(hr)){
            TRACELSM(TRACE_ERROR,  (dbgDump << "MSVidFilePlayback::Build() Add Source Filter Failed, hr = " << std::hex << hr), "");
            return Error(IDS_CANT_PLAY_FILE, __uuidof(IMSVidFilePlayback), hr);
        }
    }
    m_Filters.clear();
    m_Filters.push_back(pfr);
    m_iReader = m_Filters.size() - 1;
    return NOERROR;
}

STDMETHODIMP CMSVidFilePlayback::OnEventNotify(long lEvent, LONG_PTR lParam1, LONG_PTR lParam2) {
    return IMSVidPBGraphSegmentImpl<CMSVidFilePlayback, MSVidSEG_SOURCE, &GUID_NULL>::OnEventNotify(lEvent, lParam1, lParam2);
}

#endif //TUNING_MODEL_ONLY

// end of file - MSVidFilePlayback.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\msvidsberecorder.cpp ===
//==========================================================================;
//
// Copyright (c) Microsoft Corporation 1999-2000.
//
//--------------------------------------------------------------------------;
//
// MSVidSBERecorder.cpp : Implementation of CMSVidStreamBufferRecordingControl
//

#include "stdafx.h"

#ifndef TUNING_MODEL_ONLY

#include "MSVidCtl.h"
#include "MSVidSBERecorder.h"
const long nano_to_hundredths = 100000;

DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidStreamBufferRecordingControl, CMSVidStreamBufferRecordingControl)

STDMETHODIMP CMSVidStreamBufferRecordingControlBase::InterfaceSupportsErrorInfo(REFIID riid){
	static const IID* arr[] = 
	{
		&IID_IMSVidStreamBufferRecordingControl
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

HRESULT CMSVidStreamBufferRecordingControlBase::get_StartTime(/*[out, retval]*/ long *Start) {
    if(!Start){
        return E_POINTER;
    }
    *Start = static_cast<long>(m_Start/nano_to_hundredths);
    return S_OK;
}

HRESULT CMSVidStreamBufferRecordingControlBase::put_StartTime(/*[in]*/ long Start) {
    if(Start < 0){
        return E_INVALIDARG;
    }
    if(!Recorder){
        return E_UNEXPECTED;
    }
    m_Start = Start * nano_to_hundredths;
    HRESULT hr = Recorder->Start(&m_Start);
    if(FAILED(hr)){
        return hr;
    }
    return S_OK;

}

HRESULT CMSVidStreamBufferRecordingControlBase::get_StopTime(/*[out, retval]*/ long *Stop) {
    if(!Stop){
        return E_POINTER;
    }
    *Stop = static_cast<long>(m_Stop/nano_to_hundredths);
    return S_OK;
}

HRESULT CMSVidStreamBufferRecordingControlBase::put_StopTime(/*[in]*/ long  Stop) {
    if(Stop < 0){
        return E_INVALIDARG;
    }
    if(!Recorder){
        return E_UNEXPECTED;
    }
    m_Stop = Stop * nano_to_hundredths;
    HRESULT hr = Recorder->Stop(m_Stop);
    if(FAILED(hr)){
        return hr;
    }
    return S_OK;
}

HRESULT CMSVidStreamBufferRecordingControlBase::get_RecordingStarted(/*[out, retval]*/ VARIANT_BOOL* Result) {
    if(!Result){
        return E_POINTER;
    }
    if(!Recorder){
        ASSERT(FALSE);
        return E_UNEXPECTED;
    }
    HRESULT hres = S_OK;
    BOOL bStarted;
    HRESULT hr = Recorder->GetRecordingStatus(&hres, &bStarted , 0);
    if(FAILED(hr)){
        ASSERT(FALSE);
        return E_UNEXPECTED;  
    }
    if(bStarted){
        *Result = VARIANT_TRUE;
    }
    else{
        *Result = VARIANT_FALSE;
    }
    return S_OK;
}

HRESULT CMSVidStreamBufferRecordingControlBase::get_RecordingStopped(/*[out, retval]*/ VARIANT_BOOL* Result) {
    if(!Result){
        return E_POINTER;
    }
    if(!Recorder){
        ASSERT(FALSE);
        return E_UNEXPECTED;
    }
    HRESULT hres = S_OK;
    BOOL bStopped;
    HRESULT hr = Recorder->GetRecordingStatus(&hres, 0 , &bStopped);
    if(FAILED(hr)){
        ASSERT(FALSE);
        return E_UNEXPECTED;  
    }
    if(bStopped){
        *Result = VARIANT_TRUE;
    }
    else{
        *Result = VARIANT_FALSE;
    }
    return S_OK;
}

HRESULT CMSVidStreamBufferRecordingControlBase::get_FileName(/*[out, retval]*/ BSTR* pName){
    if(!pName){
        return E_POINTER;
    }
    HRESULT hr = m_pName.CopyTo(pName);
    if(FAILED(hr)){
        ASSERT(FALSE);
        return hr;
    }
    return S_OK;
}
HRESULT CMSVidStreamBufferRecordingControlBase::get_RecordingType(/*[out, retval]*/RecordingType *dwType){
    if(!dwType){
        return E_POINTER;
    }
    *dwType = m_Type;
    return S_OK;
}
HRESULT CMSVidStreamBufferRecordingControlBase::get_RecordingAttribute(/*[out, retval]*/ IUnknown **pRecordingAttribute){
    if(!pRecordingAttribute){
        return E_POINTER;
    }
    CComPtr<IUnknown> pRecUnk(Recorder);
    if(!pRecUnk){
        return Error(IDS_INVALID_STATE, __uuidof(IMSVidStreamBufferRecordingControl), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
    }
    *pRecordingAttribute = pRecUnk.Detach();
    return S_OK;
}
#endif //TUNING_MODEL_ONLY

// end of file - MSVidSBERecorder.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\msvidsberecorder.h ===
// CMSVidStreamBufferRecorder.h : Declaration of the CMSVidStreamBufferRecorder

#ifndef __MSVIDSTREAMBUFFERRECORDER_H_
#define __MSVIDSTREAMBUFFERRECORDER_H_

#include "stdafx.h"
#include <map>
#include <Mshtml.h>
#include <activscp.h>
#include <Atlctl.h>
#include <Exdisp.h>
#include <dvdmedia.h>
#include <objectwithsiteimplsec.h>
#include "segimpl.h"
#include "seg.h"
#include "resource.h"       // main symbols
#include "mslcid.h"
#include "sbe.h"
#include "dvdmedia.h"

typedef CComQIPtr<IStreamBufferRecordControl> pqSBERecControl;
/////////////////////////////////////////////////////
    
        
class ATL_NO_VTABLE __declspec(uuid("CAAFDD83-CEFC-4e3d-BA03-175F17A24F91")) CMSVidStreamBufferRecordingControlBase : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMSVidStreamBufferRecordingControlBase, &__uuidof(CMSVidStreamBufferRecordingControlBase)>,
    public IObjectWithSiteImplSec<CMSVidStreamBufferRecordingControlBase>,
    public ISupportErrorInfo,
    public IObjectSafetyImpl<CMSVidStreamBufferRecordingControlBase, INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA>,
	public IDispatchImpl<IMSVidStreamBufferRecordingControl, &IID_IMSVidStreamBufferRecordingControl, &LIBID_MSVidCtlLib>
{  

    public:
    CMSVidStreamBufferRecordingControlBase()
        {
            m_Start = -1;
            m_Stop = -1;
        }	

    virtual ~CMSVidStreamBufferRecordingControlBase(){
        if(!(!Recorder)){// not not'ing smart pointer, they assert if p == 0
            Recorder.Release();
        }
    }
REGISTER_AUTOMATION_OBJECT(IDS_PROJNAME, 
                           IDS_REG_MSVIDSTREAMBUFFERRECORDINGCONTROL_PROGID,
						   IDS_REG_MSVIDSTREAMBUFFERRECORDINGCONTROL_DESC,
						   LIBID_MSVidCtlLib,
						   __uuidof(CMSVidStreamBufferRecordingControlBase));

DECLARE_PROTECT_FINAL_CONSTRUCT()



BEGIN_COM_MAP(CMSVidStreamBufferRecordingControlBase)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IMSVidStreamBufferRecordingControl)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY(IObjectWithSite)
END_COM_MAP()
protected:
    pqSBERecControl Recorder;
    CComBSTR m_pName;
    REFERENCE_TIME m_Start;
    REFERENCE_TIME m_Stop;
    RecordingType m_Type;


// IMSVidStreamBufferRecordingControl
public:
    // ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
    STDMETHOD(get_StartTime)(/*[out, retval]*/ long *Start) ;
    STDMETHOD(put_StartTime)(/*[in]*/ long Start) ;
    STDMETHOD(get_StopTime)(/*[out, retval]*/ long *Stop) ;
    STDMETHOD(put_StopTime)(/*[in]*/ long  Stop) ;    
    STDMETHOD(get_RecordingStopped)(/*[out, retval]*/ VARIANT_BOOL* Result) ;
    STDMETHOD(get_RecordingStarted)(/*[out, retval]*/ VARIANT_BOOL* Result) ;
    STDMETHOD(get_FileName)(/*[out, retval]*/ BSTR* pName);
    STDMETHOD(get_RecordingType)(/*[out, retval]*/ RecordingType *dwType);
    STDMETHOD(get_RecordingAttribute)(/*[out, retval]*/ IUnknown **pRecordingAttribute);

};
class ATL_NO_VTABLE __declspec(uuid("7D0B2FDE-9CA8-4b71-AE65-12193F5F52D8")) CMSVidStreamBufferRecordingControl:
    public CComObject<CMSVidStreamBufferRecordingControlBase>
{
public:
    CMSVidStreamBufferRecordingControl(IStreamBufferRecordControl* newVal, BSTR name, DWORD type){
        Recorder.Attach(newVal);
        m_pName.Attach(name);
        if(type == RECORDING_TYPE_CONTENT){
            m_Type = CONTENT;
        }
        else{
            m_Type = REFERENCE;
        }
    }
    virtual ~CMSVidStreamBufferRecordingControl(){}
};
    
#endif //__MSVIDSTREAMBUFFERRECORDINGCONTROL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\msvidsbesource.h ===
//==========================================================================;
// MSVidSBESource.h : Declaration of the CMSVidStreamBufferSource class
// copyright (c) Microsoft Corp. 1998-1999.
//==========================================================================;

#ifndef __MSVIDSTREAMBUFFERSOURCE_H_
#define __MSVIDSTREAMBUFFERSOURCE_H_

#pragma once

#include <algorithm>
#include <dvdmedia.h>
#include <objectwithsiteimplsec.h>
#include <bcasteventimpl.h>
#include "pbsegimpl.h"
#include "fileplaybackimpl.h"
#include "seg.h"
#include <dvdmedia.h>
#include "sbesourcecp.h"
#include "resource.h"       // main symbols
#include "sbe.h"

typedef CComQIPtr<IStreamBufferMediaSeeking> PQISBEMSeeking;
typedef CComQIPtr<IFileSourceFilter> QIFileSource;

class ATL_NO_VTABLE __declspec(uuid("AD8E510D-217F-409b-8076-29C5E73B98E8")) CMSVidStreamBufferSource:
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMSVidStreamBufferSource, &__uuidof(CMSVidStreamBufferSource)>,
    public IObjectWithSiteImplSec<CMSVidStreamBufferSource>,
	public ISupportErrorInfo,
    public IBroadcastEventImpl<CMSVidStreamBufferSource>,
	public IConnectionPointContainerImpl<CMSVidStreamBufferSource>,
    public CProxy_StreamBufferSourceEvent<CMSVidStreamBufferSource>,
	public IMSVidPBGraphSegmentImpl<CMSVidStreamBufferSource, MSVidSEG_SOURCE, &GUID_NULL>,
    public IMSVidFilePlaybackImpl<CMSVidStreamBufferSource, &LIBID_MSVidCtlLib, &GUID_NULL, IMSVidStreamBufferSource>,
    public IProvideClassInfo2Impl<&CLSID_MSVidStreamBufferSource, &IID_IMSVidStreamBufferSourceEvent, &LIBID_MSVidCtlLib>
{
public:
    CMSVidStreamBufferSource() : m_dwEventCookie(0) {
        m_fEnableResetOnStop = true;
    }
	virtual ~CMSVidStreamBufferSource() {}

REGISTER_AUTOMATION_OBJECT(IDS_PROJNAME, 
						   IDS_REG_MSVIDSTREAMBUFFERSOURCE_PROGID, 
						   IDS_REG_MSVIDSTREAMBUFFERSOURCE_DESC,
						   LIBID_MSVidCtlLib,
						   __uuidof(CMSVidStreamBufferSource));

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMSVidStreamBufferSource)
	COM_INTERFACE_ENTRY(IMSVidStreamBufferSource)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectWithSite)
    COM_INTERFACE_ENTRY(IBroadcastEvent)
	COM_INTERFACE_ENTRY(IMSVidGraphSegment)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(IMSVidPlayback)
	COM_INTERFACE_ENTRY(IMSVidInputDevice)
	COM_INTERFACE_ENTRY(IMSVidDevice)
	COM_INTERFACE_ENTRY(IPersist)
	COM_INTERFACE_ENTRY(IProvideClassInfo2)
	COM_INTERFACE_ENTRY(IProvideClassInfo)
END_COM_MAP()

	BEGIN_CATEGORY_MAP(CMSVidStreamBufferSource)
		IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
		IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
		IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
	END_CATEGORY_MAP()

BEGIN_CONNECTION_POINT_MAP(CMSVidStreamBufferSource)
	CONNECTION_POINT_ENTRY(IID_IMSVidStreamBufferSourceEvent)    
END_CONNECTION_POINT_MAP()


// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
protected:
        QIFileSource m_spFileSource;
        DSFilterList m_decFilters;
        PQBroadcastEvent m_pBcast;
        DWORD m_dwEventCookie;
public:
    STDMETHOD(PostStop)();

    // DON'T addref the container.  we're guaranteed nested lifetimes
    // and an addref creates circular refcounts so we never unload.
    CComBSTR __declspec(property(get=GetName)) m_Name;
    CComBSTR GetName(void) {
        CString csName;
        if(m_iReader != -1){
            csName = (m_Filters[m_iReader]).GetName();
        }        
        if (csName.IsEmpty()) {
            csName = _T("Stream Buffer Source");
        }
        return CComBSTR(csName);
    }
    STDMETHOD(Unload)(void);
	// IMSVidGraphSegment
	STDMETHOD(put_Init)(IUnknown *pInit);
    STDMETHOD(Build)();
	STDMETHOD(put_Container)(IMSVidGraphSegmentContainer *pVal);
    STDMETHOD(OnEventNotify)(long lEvent, LONG_PTR lParam1, LONG_PTR lParam2);
    STDMETHOD(Decompose)();
// IMSVidDevice
	STDMETHOD(get_Name)(BSTR * Name);
    // IMSVidInputDevice
    STDMETHOD(IsViewable)(VARIANT* pv, VARIANT_BOOL *pfViewable);
    STDMETHOD(View)(VARIANT* pv);
    // IMSVidPlayback
    // IMSVidPlayback
    STDMETHOD(get_RecordingAttribute)(/*[out, retval]*/ IUnknown **pRecordingAttribute);
	STDMETHOD(CurrentRatings)(/*[out, retval]*/ EnTvRat_System *pEnSystem, /*[out, retval]*/ EnTvRat_GenericLevel *pEnRating, /*[out, retval]*/ LONG *plbfEnAttr);	//attrs are bitfields of BfEnTvRat_GenericAttributes   
	STDMETHOD(MaxRatingsLevel)(/*[in]*/ EnTvRat_System enSystem, /*[in]*/ EnTvRat_GenericLevel enRating, /*[in]*/ LONG lbfEnAttr);


	STDMETHOD(put_BlockUnrated)(/*[in]*/ VARIANT_BOOL bBlock);
	STDMETHOD(put_UnratedDelay)(/*[in]*/ long dwDelay);
 
    STDMETHOD(get_Start)(/*[out, retval]*/long *lStart); 
    ///////////////////////////////////////////////////////////////////////////////////////////
    // IMSVidPlaybackimpl
    ///////////////////////////////////////////////////////////////////////////////////////////
	STDMETHOD(get_Length)(/*[out, retval]*/long *lLength);
    STDMETHOD(get_CurrentPosition)(/*[out,retval]*/long *lPosition);
    STDMETHOD(put_CurrentPosition)(/*[in]*/long lPosition);
    STDMETHOD(put_PositionMode)(/*[in]*/PositionModeList lPositionMode);
    STDMETHOD(get_PositionMode)(/*[out,retval]*/PositionModeList* lPositionMode);
    STDMETHOD(put_Rate)(double lRate);
  	STDMETHOD(get_Rate)(double *plRate);
    STDMETHOD(get_CanStep)(VARIANT_BOOL fBackwards, VARIANT_BOOL *pfCan);
    STDMETHOD(Step)(long lStep);
    STDMETHOD(PreRun)();
    // IBroadcastEvent
    STDMETHOD(Fire)(GUID gEventID);
    STDMETHOD(get_SBESource)(/*[out, retval]*/ IUnknown **sbeFilter);	
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\msvidsbesource.cpp ===
//==========================================================================;
//
// Copyright (c) Microsoft Corporation 1999-2000.
//
//--------------------------------------------------------------------------;
//
// MSVidStreamBufferSource.cpp : Implementation of CMSVidStreamBufferSource
//

#include "stdafx.h"

#ifndef TUNING_MODEL_ONLY

#include "atltmp.h"
#include <encdec.h>
#include "MSVidCtl.h"
#include "MSVidsbeSource.h"
#include "encdec.h"

#if 0 // code for testing wm content
#include <wmsdkidl.h>
#endif

#include "msvidsbesink.h"   // to get pabCert2


#define FILE_BEGINNING 0
#define LOCAL_OATRUE -1
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidStreamBufferSource, CMSVidStreamBufferSource)

enum{
    CLOSE_TO_LIVE = 50,
};

/////////////////////////////////////////////////////////////////////////////
// CMSVidStreamBufferSource
STDMETHODIMP CMSVidStreamBufferSource::get_SBESource(/*[out, retval]*/ IUnknown **sbeFilter){
    if(!sbeFilter){
         return E_POINTER;
    }

    if(!m_spFileSource){
        USES_CONVERSION;
        CString csName(_T("SBE Playback"));
        QIFileSource qiFSource;
        HRESULT hr = qiFSource.CoCreateInstance(CLSID_StreamBufferSource, NULL, CLSCTX_INPROC_SERVER);
        if (FAILED(hr)){
            _ASSERT(false);
            return E_UNEXPECTED;
        }
        if(!qiFSource){
            _ASSERT(false);
            return E_UNEXPECTED;
        }
        m_spFileSource = qiFSource;
    }

    CComPtr<IUnknown> pUnk(m_spFileSource);
    if(!pUnk){
        return E_UNEXPECTED;
    }

    *sbeFilter = pUnk.Detach();
    return NOERROR;
}

STDMETHODIMP CMSVidStreamBufferSource::CurrentRatings(/*[out, retval]*/ EnTvRat_System *pEnSystem, /*[out, retval]*/ EnTvRat_GenericLevel *pEnRating, 
                                               /*[out, retval]*/ LONG *plbfEnAttr){
    if(!pEnSystem || !pEnRating || !plbfEnAttr){
        return E_POINTER;
    }
    DSFilterList::iterator i;
    EnTvRat_System system = static_cast<EnTvRat_System>(-1);
    EnTvRat_GenericLevel level = static_cast<EnTvRat_GenericLevel>(-1);
    LONG attr = static_cast<LONG>(-1);
    
    if(m_decFilters.empty()){
        return Error(IDS_INVALID_STATE, __uuidof(IMSVidStreamBufferSource), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
    }

    for(i = m_decFilters.begin(); i != m_decFilters.end(); ++i){
        EnTvRat_System temp_system = static_cast<EnTvRat_System>(-1);
        EnTvRat_GenericLevel temp_level = static_cast<EnTvRat_GenericLevel>(-1);
        LONG temp_attri = static_cast<LONG>(-1);
        CComQIPtr<IDTFilter> qiDT(*i);
        if(!qiDT){
            continue;
        }
        HRESULT hr = qiDT->GetCurrRating(&temp_system, &temp_level, &temp_attri);
        if(FAILED(hr)){
            continue;
        }
        if(temp_system != system || 
            temp_level != level || 
            temp_attri != attr){
            system = temp_system;
            level = temp_level;
            attr = temp_attri;
        }
    }
    
    if(static_cast<long>(system) < 0 || static_cast<long>(level) < 0 || static_cast<long>(attr) < 0){
        return E_FAIL;
    }

    *pEnSystem = system;
    *pEnRating = level;
    *plbfEnAttr = attr;
    return S_OK;
}
												   // ------------------

STDMETHODIMP CMSVidStreamBufferSource::MaxRatingsLevel(/*[in]*/ EnTvRat_System enSystem, /*[in]*/ EnTvRat_GenericLevel enRating, 
                                                /*[in]*/ LONG						 plbfEnAttr){
    DSFilterList::iterator i;
    
    if(m_decFilters.empty()){
        return Error(IDS_INVALID_STATE, __uuidof(IMSVidStreamBufferSource), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
    }

    for(i = m_decFilters.begin(); i != m_decFilters.end(); ++i){
        CComQIPtr<IDTFilter> qiDT(*i);
        if(!qiDT){
            continue;
        }

		HRESULT hr = qiDT->put_BlockedRatingAttributes(enSystem, enRating, plbfEnAttr);

        if(FAILED(hr)){
            return hr;
        }
    }
    
    return S_OK;
}

STDMETHODIMP CMSVidStreamBufferSource::put_BlockUnrated(/*[in]*/ VARIANT_BOOL bBlock){
    DSFilterList::iterator i;
    bool block = (bBlock == VARIANT_TRUE) ? true : false;
    
    if(m_decFilters.empty()){
        return Error(IDS_INVALID_STATE, __uuidof(IMSVidStreamBufferSource), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
    }
    
    for(i = m_decFilters.begin(); i != m_decFilters.end(); ++i){
        CComQIPtr<IDTFilter> qiDT(*i);
        if(!qiDT){
            continue;
        }
        HRESULT hr = qiDT->put_BlockUnRated(block);
        if(FAILED(hr)){
            return hr;
        }
    }
    return S_OK;
}

STDMETHODIMP CMSVidStreamBufferSource::put_UnratedDelay(/*[in]*/ long dwDelay){
    DSFilterList::iterator i;
    
    if(m_decFilters.empty()){
        return Error(IDS_INVALID_STATE, __uuidof(IMSVidStreamBufferSource), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
    }

    for(i = m_decFilters.begin(); i != m_decFilters.end(); ++i){
        CComQIPtr<IDTFilter> qiDT(*i);
        if(!qiDT){
            continue;
        }
        HRESULT hr = qiDT->put_BlockUnRatedDelay(dwDelay);
        if(FAILED(hr)){
            return hr;
        }
    }
    
    return S_OK;
}

STDMETHODIMP CMSVidStreamBufferSource::Unload(void) {
    BroadcastUnadvise();
    m_decFilters.clear();
    HRESULT hr = IMSVidGraphSegmentImpl<CMSVidStreamBufferSource, MSVidSEG_SOURCE, &GUID_NULL>::Unload();
    m_iReader = -1;
    m_spFileSource = reinterpret_cast<IFileSourceFilter*>(NULL);
    return hr;
}
STDMETHODIMP CMSVidStreamBufferSource::put_Init(IUnknown *pInit){
    HRESULT hr = IMSVidGraphSegmentImpl<CMSVidStreamBufferSource, MSVidSEG_SOURCE, &GUID_NULL>::put_Init(pInit);
    if (FAILED(hr)) {
        return hr;
    }
    if (pInit) {
        m_fInit = false;
        return E_NOTIMPL;
    }
    return NOERROR;
}
STDMETHODIMP CMSVidStreamBufferSource::get_Name(BSTR * Name){
    if (!m_fInit) {
 	    return Error(IDS_OBJ_NO_INIT, __uuidof(IMSVidStreamBufferSource), CO_E_NOTINITIALIZED);
    }
	if (Name == NULL)
		return E_POINTER;
    try {
	    *Name = m_Name.Copy();	
    } catch(...) {
        return E_POINTER;
    }
	return NOERROR;
}
// IMSVidInputDevice
STDMETHODIMP CMSVidStreamBufferSource::IsViewable(VARIANT* pv, VARIANT_BOOL *pfViewable)
{
    if (!m_fInit) {
        return Error(IDS_OBJ_NO_INIT, __uuidof(IMSVidStreamBufferSource), CO_E_NOTINITIALIZED);
    }
    if (!pv) {
        return E_POINTER;
    }
    return E_NOTIMPL;
}
STDMETHODIMP CMSVidStreamBufferSource::View(VARIANT* pv) {
    if (!m_fInit) {
        return Error(IDS_OBJ_NO_INIT, __uuidof(IMSVidStreamBufferSource), CO_E_NOTINITIALIZED);
    }
    if (!pv) {
        return E_POINTER;
    }
    if (!_wcsnicmp(pv->bstrVal, L"DVD:", 4)) {
        return E_FAIL;
    }
	return put_FileName(pv->bstrVal);
}
STDMETHODIMP CMSVidStreamBufferSource::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IMSVidStreamBufferSource
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
STDMETHODIMP CMSVidStreamBufferSource::put_Container(IMSVidGraphSegmentContainer *pCtl){
    try {
        HRESULT hr = S_OK;
        if (!m_fInit) {
            return Error(IDS_OBJ_NO_INIT, __uuidof(IMSVidStreamBufferSource), CO_E_NOTINITIALIZED);
        }
        if (!pCtl) {
#ifdef BUILD_WITH_DRM
            CComQIPtr<IServiceProvider> spServiceProvider(m_pGraph);
            if (spServiceProvider != NULL) {
                CComPtr<IDRMSecureChannel>  spSecureService;  
                hr = spServiceProvider->QueryService(SID_DRMSecureServiceChannel, 
                    IID_IDRMSecureChannel,
                    reinterpret_cast<LPVOID*>(&spSecureService));
                if(S_OK == hr){
                    // Found existing Secure Server
                    CComQIPtr<IRegisterServiceProvider> spRegServiceProvider(m_pGraph);
                    if(spRegServiceProvider == NULL){
                        // no service provider interface on the graph - fatal!
                        hr = E_NOINTERFACE;                 
                    } 

                    if(SUCCEEDED(hr)){ 
                        hr = spRegServiceProvider->RegisterService(SID_DRMSecureServiceChannel, NULL);
                    }
                } 
                _ASSERT(SUCCEEDED(hr));
            }
#endif
            return Unload();
        }
        if (m_pContainer) {
            if (!m_pContainer.IsEqualObject(VWSegmentContainer(pCtl))) {
                return Error(IDS_OBJ_ALREADY_INIT, __uuidof(IMSVidStreamBufferSource), CO_E_ALREADYINITIALIZED);
            } else {
                return NO_ERROR;
            }
        }

        // DON'T addref the container.  we're guaranteed nested lifetimes
        // and an addref creates circular refcounts so we never unload.
        m_pContainer.p = pCtl;
        m_pGraph = m_pContainer.GetGraph();
        hr = BroadcastAdvise();
        if (FAILED(hr)) {
            TRACELM(TRACE_ERROR, "CMSVidStreamBufferSource::put_Container() can't advise for broadcast events");
            return E_UNEXPECTED;
        }
#if 0 // code for testing wm content
        CComPtr<IUnknown> pUnkCert;
        hr = WMCreateCertificate(&pUnkCert);
        if (FAILED(hr)){
            _ASSERT(false);
        }

        CComQIPtr<IMSVidCtl>tempCtl(pCtl);
        if(tempCtl){
            hr = tempCtl->put_ServiceProvider(pUnkCert);
            if (FAILED(hr)){
                _ASSERT(false);
            }
        }
#endif

#ifdef BUILD_WITH_DRM
#ifdef USE_TEST_DRM_CERT
        {
            DWORD dwDisableDRMCheck = 0;
            CRegKey c;
            CString keyname(_T("SOFTWARE\\Debug\\MSVidCtl"));
            DWORD rc = c.Open(HKEY_LOCAL_MACHINE, keyname, KEY_READ);
            if (rc == ERROR_SUCCESS) {
                rc = c.QueryValue(dwDisableDRMCheck, _T("DisableDRMCheck"));
                if (rc != ERROR_SUCCESS) {
                    dwDisableDRMCheck = 0;
                }
            }

            if(dwDisableDRMCheck == 1){
                return S_OK;
            }
        }
#endif
        CComQIPtr<IServiceProvider> spServiceProvider(m_pGraph);
        if (spServiceProvider == NULL) {
            return E_NOINTERFACE;
        }
        CComPtr<IDRMSecureChannel>  spSecureService;  
        hr = spServiceProvider->QueryService(SID_DRMSecureServiceChannel, 
            IID_IDRMSecureChannel,
            reinterpret_cast<LPVOID*>(&spSecureService));
        if(S_OK == hr){
            // Found existing Secure Server
            return S_OK;
        } 
        else{
            // if it's not there or failed for ANY reason 
            //   lets create it and register it
            CComQIPtr<IRegisterServiceProvider> spRegServiceProvider(m_pGraph);
            if(spRegServiceProvider == NULL){
                // no service provider interface on the graph - fatal!
                hr = E_NOINTERFACE;                 
            } 
            else{
                // Create the Client 
                CComPtr<IDRMSecureChannel>  spSecureServiceServer; 
                hr = DRMCreateSecureChannel( &spSecureServiceServer);
                if(spSecureServiceServer == NULL){
                    hr = E_OUTOFMEMORY;
                }
                if(FAILED(hr)){ 
                    return hr;
                }

                // Init keys
                hr = spSecureServiceServer->DRMSC_SetCertificate((BYTE *)pabCert2, cBytesCert2);
                if(FAILED(hr)){                
                    return hr;
                }

                hr = spSecureServiceServer->DRMSC_SetPrivateKeyBlob((BYTE *)pabPVK2, cBytesPVK2);
                if(FAILED(hr)){ 
                    return hr;
                }

                hr = spSecureServiceServer->DRMSC_AddVerificationPubKey((BYTE *)abEncDecCertRoot, sizeof(abEncDecCertRoot) );
                if(FAILED(hr)){ 
                    return hr;
                }

                // Register It
                //   note RegisterService does not addref pUnkSeekProvider             
                hr = spRegServiceProvider->RegisterService(SID_DRMSecureServiceChannel, spSecureServiceServer);
            }
        }
#endif      // BUILD_WITH_DRM

        return NOERROR;
    } catch (ComException &e) {
        return e;
    } catch (...) {
        return E_UNEXPECTED;
    }
}

//-----------------------------------------------------------------------------------------
// Name: get_CanStep(VARIANT_BOOL, VARIANT_BOOL*)
//-----------------------------------------------------------------------------------------
STDMETHODIMP CMSVidStreamBufferSource::get_CanStep(VARIANT_BOOL fBackwards, VARIANT_BOOL *pfCan){
        // NOTE: NO ONE supports backwords stepping (why not? who knows)
        // so just like everyone else we dont either
        try{
            // Checking args and interfaces 
       
            if(!pfCan){
                // Passed a NULL Pointer
                return E_POINTER;
            }

            if (!m_pGraph) {
                // graph not valid
                return Error(IDS_INVALID_STATE, __uuidof(IMSVidPlayback), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
			}

            //Get a VideoFrameStep Interface
			PQVideoFrameStep pVFS(m_pGraph);
            if(!pVFS){
                // Could Not QI
				return Error(IDS_E_CANTQI , __uuidof(IMSVidPlayback), E_NOINTERFACE);          
			}
            
            if(fBackwards == VARIANT_TRUE){
                *pfCan = VARIANT_TRUE;
                return S_OK;
            }
            else{
                if(pVFS->CanStep(FALSE, NULL)==S_OK){
                    // It is all Good, Can Step Forward
                    *pfCan = VARIANT_TRUE;
                    return S_OK;
                }
                
                else{
                    // Can't Step
                    *pfCan = VARIANT_FALSE;
                    return S_OK;
                }
            }
        }
        catch(HRESULT hrTmp){
            // Something went bad, threw a HRESULT
            return Error(IDS_INVALID_STATE , __uuidof(IMSVidPlayback), hrTmp);
        }
        catch(...){
            // Something went bad, dont know what it threw
            return E_UNEXPECTED;   
        }
    }

//-----------------------------------------------------------------------------------------
// Name: Step(long)
//-----------------------------------------------------------------------------------------
STDMETHODIMP CMSVidStreamBufferSource::Step(long lStep){
        try{
            // Checking args and interfaces
            long tempStep = lStep;
            if (!m_pGraph || !m_pContainer) {
                // graph not valid
                return Error(IDS_INVALID_STATE, __uuidof(IMSVidPlayback), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
            }
            
            PQVideoFrameStep pVFS(m_pGraph);
            
            if(!pVFS){
                // Could Not QI
                return Error(IDS_E_CANTQI , __uuidof(IMSVidPlayback), E_NOINTERFACE);
                
            }
            
            if(lStep < 0){
                PQMediaControl pmc(m_pGraph);
                if (!pmc) {
                    return Error(IDS_NO_MEDIA_CONTROL, __uuidof(IMSVidPlayback), E_UNEXPECTED);
                }
                HRESULT hr = pmc->Pause();
                if (FAILED(hr)) {
                    TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::Pause() hr = " << std::hex << hr), "");
                    return Error(IDS_CANT_PAUSE_GRAPH, __uuidof(IMSVidPlayback), hr);
                }
                
                long cur = 0;
                long stepVal = (/*half a second in 100ths of a second*/ 50 * lStep);
                PositionModeList curMode;
                hr = get_PositionMode(&curMode);
                if(FAILED(hr)){
                    return hr;
                }
                
                if(curMode == FrameMode){
                    stepVal = (stepVal/100) * 30; // hard coded to 30 fps for now
                }
                
                hr = get_CurrentPosition(&cur);
                if(FAILED(hr)){
                    return hr;
                }

                if(cur == 0){
                    return Error(IDS_INVALID_STATE, __uuidof(IMSVidPlayback), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
                }
                
                cur = cur + stepVal; // stepVal is negative, duh
                hr = put_CurrentPosition(cur);
                if(FAILED(hr)){
                    return hr;
                }
                // Set tempStep and then step to refresh the current frame
                tempStep = 1;
            }
            // Make it step
            return pVFS->Step(tempStep, NULL);
        }
        
        catch(HRESULT hrTmp){
            // Something went bad, threw a HRESULT				
            return Error(IDS_INVALID_STATE , __uuidof(IMSVidPlayback), hrTmp);
        }
        catch(...){
            // Something went bad, dont know what it threw
            return E_UNEXPECTED;
        }
    }
    

//-----------------------------------------------------------------------------------------
// Name: get_Start(long)
//-----------------------------------------------------------------------------------------
STDMETHODIMP CMSVidStreamBufferSource::get_Start(/*[out, retval]*/long *lStart){
    HRESULT hr = S_OK;
    LONGLONG tempfirst, templatest;
    PositionModeList curMode;
    try{
        // Checking args and init'ing interfaces
        if (!lStart){
            return E_POINTER;
        }
        if (!m_pGraph) {
            // graph not valid
            return Error(IDS_INVALID_STATE, __uuidof(IMSVidStreamBufferSource), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
        }

        // See if object supports ISBEMediaSeeking
        PQISBEMSeeking PQIMSeeking(m_spFileSource);
        if(!( !PQIMSeeking)){ // not not'ing smart pointer, they assert if p == 0
            // Find out what postion mode is being used
            hr = get_PositionMode(&curMode);
            if(FAILED(hr)){
                return hr;
            }
            hr = PQIMSeeking->GetAvailable(&tempfirst, &templatest);
            if(FAILED(hr)){
                return hr;
            }
            // If it is FrameMode no conversion needed
            if(tempfirst == 0){
                *lStart = 0;
                hr = S_OK;
                return hr;
            }
            if(curMode == FrameMode){
                *lStart = static_cast<long>(tempfirst);
                TRACELSM(TRACE_ERROR, (dbgDump << "StreamBufferSource::get_Start() return=" << (unsigned long)(*lStart) << " longlong=" << (double)(tempfirst)), "");

                hr = S_OK;
                return hr;
            }
            // If it is TenthsSecondsMode need to be converted from 100 nanosecond units
            if(curMode == TenthsSecondsMode){
                *lStart = static_cast<long>(tempfirst / nano_to_hundredths);    
                TRACELSM(TRACE_ERROR, (dbgDump << "StreamBufferSource::get_Start() return=" << (unsigned long)(*lStart) << " longlong=" << (double)(tempfirst)), "");
                hr = S_OK;
                return hr;
            }
            // If it is some other mode not supported by the vidctl
            else{
                return E_UNEXPECTED;
            }
        }
        // Could Not QI IMedia Seeking or Position
        return Error(IDS_E_CANTQI , __uuidof(IMSVidPlayback), E_NOINTERFACE);
        
    }
    
    catch(HRESULT hrTmp){
        // Something went bad, threw a HRESULT				
        return Error(IDS_INVALID_STATE , __uuidof(IMSVidPlayback), hrTmp);
    }
    catch(...){
        // Something went bad, dont know what it threw
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CMSVidStreamBufferSource::get_RecordingAttribute(/*[out, retval]*/ IUnknown **pRecordingAttribute){
    if(!pRecordingAttribute){
        return E_POINTER;
    }
    CComPtr<IUnknown> pRecUnk(m_spFileSource);
    if(!pRecUnk){
        return Error(IDS_INVALID_STATE, __uuidof(IMSVidStreamBufferSource), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
    }
    *pRecordingAttribute = pRecUnk.Detach();
    return S_OK;
}

//-----------------------------------------------------------------------------------------
// Name: get_Length(long)
//-----------------------------------------------------------------------------------------
STDMETHODIMP CMSVidStreamBufferSource::get_Length(/*[out, retval]*/long *lLength){
    HRESULT hr = S_OK;
    LONGLONG tempfirst, templatest;
    PositionModeList curMode;
    try{
        // Checking args and init'ing interfaces
        if (!lLength){
            return E_POINTER;
        }
        if (!m_pGraph) {
            // graph not valid
            return Error(IDS_INVALID_STATE, __uuidof(IMSVidStreamBufferSource), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
        }

        // See if object supports ISBEMediaSeeking
        PQISBEMSeeking PQIMSeeking(m_spFileSource);
        if(!( !PQIMSeeking)){ // not not'ing smart pointer, they assert if p == 0
            // Find out what postion mode is being used
            hr = get_PositionMode(&curMode);
            if(FAILED(hr)){
                return hr;
            }
            hr = PQIMSeeking->GetAvailable(&tempfirst, &templatest);
            if(FAILED(hr)){
                return hr;
            }
            // If it is FrameMode no conversion needed
            if(curMode == FrameMode){
                *lLength = static_cast<long>(templatest);
                TRACELSM(TRACE_ERROR, (dbgDump << "StreamBufferSource::get_Length() return=" << (unsigned long)(*lLength) << " longlong=" << (double)(templatest)), "");
                hr = S_OK;
                return hr;
            }
            // If it is TenthsSecondsMode need to be converted from 100 nanosecond units
            else if(curMode == TenthsSecondsMode){
                *lLength = static_cast<long>(templatest / nano_to_hundredths);
                TRACELSM(TRACE_ERROR, (dbgDump << "StreamBufferSource::get_Length() return=" << (unsigned long)(*lLength) << " longlong=" << (double)(templatest)), "");
                hr = S_OK;
                return hr;
            }
            // If it is some other mode not supported by the vidctl
            else{
                return E_UNEXPECTED;
            }
        }

         // Could Not QI IMedia Seeking
        return Error(IDS_E_CANTQI , __uuidof(IMSVidPlayback), E_NOINTERFACE);
        
    }
    
    catch(HRESULT hrTmp){
        // Something went bad, threw a HRESULT				
        return Error(IDS_INVALID_STATE , __uuidof(IMSVidPlayback), hrTmp);
    }
    catch(...){
        // Something went bad, dont know what it threw
        return E_UNEXPECTED;
    }
}

//-----------------------------------------------------------------------------------------
// Name: get_CurrentPosition(LONGLONG*)
//-----------------------------------------------------------------------------------------
STDMETHODIMP CMSVidStreamBufferSource::get_CurrentPosition(/*[out,retval]*/long *lPosition) {
    HRESULT hr = S_OK;
    LONGLONG tempval;
    PositionModeList curMode;
    try{
        // Checking args and init'ing interfaces
        if (!lPosition){
            return E_POINTER;
        }
        if (!m_spFileSource) {
            // graph not valid
            return Error(IDS_INVALID_STATE, __uuidof(IMSVidPlayback), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
        }

        // See if object supports ISBEMediaSeeking
        PQISBEMSeeking PQIMSeeking(m_spFileSource);
        if(!( !PQIMSeeking)){// not not'ing smart pointer, they assert if p == 0
            // Find out what postion mode is being used
            hr = get_PositionMode(&curMode);
            if(FAILED(hr)){
                return hr;
            }
            hr = PQIMSeeking->GetCurrentPosition(&tempval);
            if(FAILED(hr)){
                return hr;
            }
            // If it is FrameMode no conversion needed
            if(curMode == FrameMode){
                *lPosition = static_cast<long>(tempval);
                TRACELSM(TRACE_ERROR, (dbgDump << "StreamBufferSource::get_CurrentPosition() return=" << (unsigned long)(*lPosition) << " longlong=" << (double)(tempval)), "");
                hr = S_OK;
                return hr;
            }
            // If it is TenthsSecondsMode need to be converted from 100 nanosecond units
            else if(curMode == TenthsSecondsMode){
                *lPosition = static_cast<long>(tempval / nano_to_hundredths);
                TRACELSM(TRACE_ERROR, (dbgDump << "StreamBufferSource::get_CurrentPosition() return=" << (unsigned long)(*lPosition) << " longlong=" << (double)(tempval)), "");
                hr = S_OK;
                return hr;
            }
            // If it is some other mode not supported by the vidctl
            else{
                return E_UNEXPECTED;
            }
        }
        // Could Not QI IMedia Seeking
        return Error(IDS_E_CANTQI , __uuidof(IMSVidPlayback), E_NOINTERFACE);

    }

    catch(HRESULT hrTmp){
        // Something went bad, threw a HRESULT				
        return Error(IDS_INVALID_STATE , __uuidof(IMSVidPlayback), hrTmp);
    }
    catch(...){
        // Something went bad, dont know what it threw
        return E_UNEXPECTED;
    }
}
//-----------------------------------------------------------------------------------------
// Name: put_CurrentPosition(LONGLONG)
//-----------------------------------------------------------------------------------------
STDMETHODIMP CMSVidStreamBufferSource::put_CurrentPosition(/*[in]*/long lPosition) {
    HRESULT hr = S_OK;
    LONGLONG tempval;
    PositionModeList curMode;
    try{
        // Checking args and interfaces
        if (!m_spFileSource) {
            return Error(IDS_INVALID_STATE, __uuidof(IMSVidPlayback), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
        }

        // Check for a ISBEMediaSeeking Interface
        PQISBEMSeeking PQIMSeeking(m_spFileSource);
        if(!( !PQIMSeeking)){ // not not'ing smart pointer, they assert if p == 0
            // Get the position Mode
            hr = get_PositionMode(&curMode);
            if(FAILED(hr)){
                return hr;
            }
            tempval = lPosition;
            // If it is in TenthsSecondsMode convert input into 100 nanosecond units
            if(curMode == TenthsSecondsMode){
                tempval = (tempval) * nano_to_hundredths;
            }
            // If it is in some other mode
            else if(curMode != FrameMode){
                return E_UNEXPECTED;
            }
            // Set the new Position
            TRACELSM(TRACE_ERROR, (dbgDump << "StreamBufferSource::put_CurrentPosition() set to: input=" << (unsigned long)(lPosition) << " longlong=" << (double)(tempval)), "");
            hr = PQIMSeeking->SetPositions(&tempval, AM_SEEKING_AbsolutePositioning, NULL, 0);
            TRACELSM(TRACE_ERROR, (dbgDump << "StreamBufferSource::put_CurrentPosition() actually set to:" << (double)(tempval)), "");

            return hr; 
        }
        // Could Not QI Media Position
        return Error(IDS_E_CANTQI , __uuidof(IMSVidPlayback), E_NOINTERFACE);

    }

    catch(HRESULT hrTmp){
        // Something went bad, threw a HRESULT				
        return Error(IDS_INVALID_STATE , __uuidof(IMSVidPlayback), hrTmp);
    }
    catch(...){
        // Something went bad, dont know what it threw
        return E_UNEXPECTED;
    }
}
//-----------------------------------------------------------------------------------------
// Name: put_PositionMode(LONGLONG)
//-----------------------------------------------------------------------------------------

STDMETHODIMP CMSVidStreamBufferSource::put_PositionMode(/*[in]*/PositionModeList lPositionMode) {
    HRESULT hr = S_OK;
    double testval;
    get_Rate(&testval);
    try{
        // Checking args and interfaces
        if (!m_spFileSource) {
            // graph not valid
            return Error(IDS_INVALID_STATE, __uuidof(IMSVidPlayback), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
        }
        // only valid values
        if(lPositionMode != FrameMode && lPositionMode != TenthsSecondsMode){
            return E_INVALIDARG;
        }
        // Try for a ISBEMediaSeeking
        PQISBEMSeeking PQIMSeeking(m_spFileSource);
        if(!( !PQIMSeeking)){// not not'ing smart pointer, they assert if p == 0
            // Set the new mode
            if(lPositionMode == FrameMode){
                hr = PQIMSeeking->SetTimeFormat( &( static_cast<GUID>(TIME_FORMAT_FRAME) ) );
                return hr; 
            }
            if(lPositionMode == TenthsSecondsMode){
                hr = PQIMSeeking->SetTimeFormat(&(static_cast<GUID>(TIME_FORMAT_MEDIA_TIME)));
                return hr; 
            }
        }
        // Could Not QI
        return Error(IDS_E_CANTQI , __uuidof(IMSVidPlayback), E_NOINTERFACE);

    }

    catch(HRESULT hrTmp){
        // Something went bad, threw a HRESULT				
        return Error(IDS_INVALID_STATE , __uuidof(IMSVidPlayback), hrTmp);
    }
    catch(...){
        // Something went bad, dont know what it threw
        return E_UNEXPECTED;
    }
}


//-----------------------------------------------------------------------------------------
// Name: get_PositionMode(LONGLONG*)
//-----------------------------------------------------------------------------------------
STDMETHODIMP CMSVidStreamBufferSource::get_PositionMode(/*[out,retval]*/PositionModeList* lPositionMode) {
    HRESULT hr = S_OK;
    double testval;
    get_Rate(&testval);
    try{
        // Checking args and interfaces
        if(!lPositionMode){
            return E_POINTER;
        }
        if (!m_spFileSource) {
            // graph not valid
            return Error(IDS_INVALID_STATE, __uuidof(IMSVidPlayback), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
        }
        // Get an ISBEMediaSeeking Interface
        PQISBEMSeeking PQIMSeeking(m_spFileSource);
        if(!( !PQIMSeeking)){// not not'ing smart pointer, they assert if p == 0
            // Get the mode
            GUID cur_mode;
            hr = PQIMSeeking->GetTimeFormat(&cur_mode);
            if(FAILED(hr)){
                return hr;
            }
            // Check to see which mode it is in
            if(cur_mode == static_cast<GUID>(TIME_FORMAT_FRAME)){
                *lPositionMode = FrameMode;
                return S_OK;
            }
            if(cur_mode == static_cast<GUID>(TIME_FORMAT_MEDIA_TIME)){
                *lPositionMode = TenthsSecondsMode;
                return S_OK;
            }
            // Not in a vidctl supported mode
            else{
                return E_FAIL;
            }
        }
        // Could Not QI
        return Error(IDS_E_CANTQI , __uuidof(IMSVidPlayback), E_NOINTERFACE);

    }

    catch(HRESULT hrTmp){
        // Something went bad, threw a HRESULT				
        return Error(IDS_INVALID_STATE , __uuidof(IMSVidPlayback), hrTmp);
    }
    catch(...){
        // Something went bad, dont know what it threw
        return E_UNEXPECTED;
    }
}

//-----------------------------------------------------------------------------------------
// Name: put_Rate(double)
//-----------------------------------------------------------------------------------------
STDMETHODIMP CMSVidStreamBufferSource::put_Rate(double lRate){
    HRESULT hr = S_OK;
    try{
        /*** Checking args and init'ing interfaces ***/

        if (!m_spFileSource) {
            // graph not valid
            return Error(IDS_INVALID_STATE, __uuidof(IMSVidPlayback), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
        }

        // Attempt to set the rate using ISBEMediaSeeking
        PQISBEMSeeking PQIMSeeking(m_spFileSource);
        if(!( !PQIMSeeking)){// not not'ing smart pointer, they assert if p == 0
            return PQIMSeeking->SetRate(lRate);
        }
        // Could Not QI set the error
        return Error(IDS_E_CANTQI , __uuidof(IMSVidPlayback), E_NOINTERFACE);

    }

    catch(HRESULT hrTmp){
        // Something went bad, threw a HRESULT				
        return Error(IDS_INVALID_STATE , __uuidof(IMSVidPlayback), hrTmp);
    }
    catch(...){
        // Something went bad, dont know what it threw
        return E_UNEXPECTED;
    }
}
//-----------------------------------------------------------------------------------------
// Name: get_Rate(double*)
//-----------------------------------------------------------------------------------------
STDMETHODIMP CMSVidStreamBufferSource::get_Rate(double *plRate){
    HRESULT hr = S_OK;
    try{
        /*** Checking args and init'ing interfaces ***/
        if (!plRate){
            return E_POINTER;
        }
        if (!m_spFileSource) {
            // graph not valid
            return Error(IDS_INVALID_STATE, __uuidof(IMSVidPlayback), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
        }
        PQISBEMSeeking PQIMSeeking(m_spFileSource);
        if(!( !PQIMSeeking)){// not not'ing smart pointer, they assert if p == 0
            return PQIMSeeking->GetRate(plRate);
        }
        // Could Not QI
        return Error(IDS_E_CANTQI , __uuidof(IMSVidPlayback), E_NOINTERFACE);

    }

    catch(HRESULT hrTmp){
        // Something went bad, threw a HRESULT				
        return Error(IDS_INVALID_STATE , __uuidof(IMSVidPlayback), hrTmp);
    }
    catch(...){
        // Something went bad, dont know what it threw
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CMSVidStreamBufferSource::PostStop(){
    HRESULT hr = S_OK;

    try {
#if 0
        // If the graph is not is stopped state
        // we make sure it is
        if (!m_pGraph.IsStopped()) {
            HRESULT hr = PQVidCtl(m_pContainer)->Stop();
        }
#endif
        // If m_fEnableResetOnStop is true then we need to reset 
        // the postion back to the beggining
        // else do nothing
        if(m_fEnableResetOnStop){
            return put_CurrentPosition(0);
        }

    }
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }
    return hr;      
}
STDMETHODIMP CMSVidStreamBufferSource::Decompose() {
    return put_Container(NULL);
}
STDMETHODIMP CMSVidStreamBufferSource::Build() {
    if (!m_FileName) {
        return Error(IDS_INVALID_STATE, __uuidof(IMSVidStreamBufferSource), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
    }

    QIFileSource qiFSource;
    HRESULT hr = S_OK;
    DSFilter pfr;
    if(!m_spFileSource){
        USES_CONVERSION;
        hr = qiFSource.CoCreateInstance(CLSID_StreamBufferSource, NULL, CLSCTX_INPROC_SERVER);
        if (FAILED(hr)){
            _ASSERT(false);
            return E_UNEXPECTED;
        }
        if(!qiFSource){
            _ASSERT(false);
            return E_UNEXPECTED;
        }
        m_spFileSource = qiFSource;
        hr = m_spFileSource->QueryInterface(&pfr);
        if (FAILED(hr) || !pfr) {
            _ASSERT(false);
            TRACELSM(TRACE_ERROR,  (dbgDump << "MSVidStreamBufferSource::Build() Could not create StreamBufferSource hr = " << std::hex << hr), "");
            return Error(IDS_CANT_PLAY_FILE, __uuidof(IMSVidStreamBufferSource), hr);
        }
    }
    else{
        qiFSource = m_spFileSource;
        if(!qiFSource){
            _ASSERT(false);
            return E_UNEXPECTED; 
        }
        hr = m_spFileSource->QueryInterface(&pfr);
        if (FAILED(hr) || !pfr) {
            _ASSERT(false);
            TRACELSM(TRACE_ERROR,  (dbgDump << "MSVidStreamBufferSource::Build() Could not create StreamBufferSource hr = " << std::hex << hr), "");
            return Error(IDS_CANT_PLAY_FILE, __uuidof(IMSVidStreamBufferSource), hr);
        }
    }

    CString csName(_T("SBE Playback"));
    m_Filters.clear();
    hr = m_pGraph.AddFilter(pfr, csName);
    if(FAILED(hr)){
        _ASSERT(false);
        return E_UNEXPECTED;
    }

    hr = qiFSource->Load(m_FileName, NULL);
    if (FAILED(hr)) {
        bool rc = m_pGraph.RemoveFilter(pfr);
        if (!rc) {
            return E_UNEXPECTED;
        }
        TRACELSM(TRACE_ERROR,  (dbgDump << "MSVidStreamBufferSource::Build() Could not create StreamBufferSource hr = " << std::hex << hr), "");
        return Error(IDS_CANT_PLAY_FILE, __uuidof(IMSVidStreamBufferSource), hr);
    }

    m_Filters.push_back(pfr);
    m_iReader = m_Filters.size() - 1;
#if ENCRYPT_NEEDED
    DSFilterList intermediates;
    for(DSFilter::iterator i = pfr.begin(); i != pfr.end(); ++i){
        if((*i).GetDirection() == DOWNSTREAM && !(*i).IsConnected()){
            // Create and add a decoder Tagger Filter 
            CComPtr<IUnknown> spEncTagD(CLSID_DTFilter, NULL, CLSCTX_INPROC_SERVER);
            if (!spEncTagD) {
                TRACELM(TRACE_ERROR, "CMSVidStreamBufferSink::Build() can't load Tagger filter");
                return ImplReportError(__uuidof(IMSVidStreamBufferSink), IDS_CANT_CREATE_FILTER, __uuidof(IStreamBufferSink), E_UNEXPECTED);
            }

            DSFilter vrD(spEncTagD);
            if (!vrD) {
                ASSERT(false);
                return ImplReportError(__uuidof(IMSVidStreamBufferSink), IDS_CANT_CREATE_FILTER, __uuidof(IStreamBufferSink), E_UNEXPECTED);
            }

            m_Filters.push_back(vrD);
            m_decFilters.push_back(vrD);
            csName = _T("Decoder/Tagger Filter");
            m_pGraph.AddFilter(vrD, csName);

            // Connect pin to the Tagger
            hr = (*i).IntelligentConnect(vrD, intermediates);
            if(FAILED(hr)){
                TRACELM(TRACE_DETAIL, "CAnaSinComp::Compose() if you see this line more than once something must have gone wrong");  
            }

        }
    }
    ASSERT(intermediates.begin() == intermediates.end());
    m_Filters.insert(m_Filters.end(), intermediates.begin(), intermediates.end());
#endif
    return NOERROR;
}

STDMETHODIMP CMSVidStreamBufferSource::PreRun(){
#if 0 
    if(m_iReader == -1 || m_Filters.empty()){
        return Error(IDS_INVALID_STATE, __uuidof(IMSVidStreamBufferSource), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
    }
    
    CComQIPtr<IReferenceClock> pq_IRClock(m_Filters[m_iReader]);
    if(!pq_IRClock){
        return S_FALSE;
    }

    CComQIPtr<IMediaFilter> pq_MFGph(m_pGraph);
    if(!pq_MFGph){
        return E_NOINTERFACE;
    }


    HRESULT hr = pq_MFGph->SetSyncSource(pq_IRClock);
    if(FAILED(hr)){
        ASSERT(false);
    }

    return hr;
#endif
    return E_NOTIMPL;
}

STDMETHODIMP CMSVidStreamBufferSource::OnEventNotify(long lEvent, LONG_PTR lParam1, LONG_PTR lParam2) {
    if (lEvent == EC_COMPLETE) {
        double curRate = 0;
        HRESULT hr = S_OK;
        hr = get_Rate(&curRate);
        if(SUCCEEDED(hr)){
            if(curRate < 0){
                hr = put_Rate(1);
                if(FAILED(hr)){
                    _ASSERT(false);
                }

                // We need to transition to pause then back to play to flush all of the buffers
                // It appears to be a decoder issue, mostly
                PQVidCtl sp_VidCtl(m_pContainer);
                if(sp_VidCtl){
                    hr = sp_VidCtl->Pause();
                    if(FAILED(hr)){
                        _ASSERT(false); // Failed to pause this is really bad
                    }

                    hr = sp_VidCtl->Run();
                    if(FAILED(hr)){
                        _ASSERT(false); // Failed to run this is really bad
                    }
                }
                else{
                    _ASSERT(false); // We got events with no vidctl hosting us, really weird
                }



                CComQIPtr<IMSVidPlayback> ppb(this);
                Fire_EndOfMedia(ppb);
                TRACELM(TRACE_ERROR, "CMSVidStreamBufferSource::OnEventNotify Tossed EndOfMedia at start of sbe stream");  
                return NOERROR;

            }
        }
    }

    if(lEvent == STREAMBUFFER_EC_RATE_CHANGED){
        TRACELM(TRACE_ERROR, "CMSVidStreamBufferSource::OnEventNotify STREAMBUFFER_EC_RATE_CHANGED");
        HRESULT hr = S_OK;
#if 0 // code to try to make up for the lack of a rate change event on the vidctl
        MSVidCtlStateList curState = STATE_UNBUILT;
        hr = PQVidCtl(m_pContainer)->get_State(&curState);
        if(SUCCEEDED(hr) && curState == STATE_PLAY){
            CComQIPtr<IMSVidDevice> pd(this);
            if (!pd) {
                TRACELM(TRACE_ERROR, "CMSVidStreamBufferSource::OnEventNotify Could not qi SBE Source Segment for IMSVidDevice");  
            }
            else{
                Fire_StateChange(pd, STATE_PLAY, STATE_PLAY);
                TRACELM(TRACE_ERROR, "CMSVidStreamBufferSource::OnEventNotify Tossed StateChange STATE_PLAY STATE_PLAY for rate change");  
            }
        }
#endif
        long len;
        long curPos;
        curPos = len = 0;
        hr = get_Length(&len);
        if(SUCCEEDED(hr)){
            hr = get_CurrentPosition(&curPos);
            if(SUCCEEDED(hr)){
                if(len <= (curPos + CLOSE_TO_LIVE)){ // if current position is with in CLOSE_TO_LIVE of the len the we just bounced off of the end of the stream
                    CComQIPtr<IMSVidPlayback> ppb(this);
                    if (!ppb) {
                        TRACELM(TRACE_ERROR, "CMSVidStreamBufferSource::OnEventNotify Could not qi SBE Source Segment for IMSVidPlayback");  
                    }
                    else{
                        Fire_EndOfMedia(ppb);
                        TRACELM(TRACE_ERROR, "CMSVidStreamBufferSource::OnEventNotify Tossed EndOfMedia at end of sbe stream");  
                        return NOERROR;
                    }
                }
            }
        }
    }

    if(lEvent == STREAMBUFFER_EC_TIMEHOLE){
        Fire_TimeHole(lParam1, lParam2);
        return NOERROR;
    }

    if(lEvent == STREAMBUFFER_EC_STALE_DATA_READ){
        Fire_StaleDataRead();
        return NOERROR;
    }

    if(lEvent == STREAMBUFFER_EC_STALE_FILE_DELETED){
        Fire_StaleFilesDeleted();
        return NOERROR;
    }

    if(lEvent == STREAMBUFFER_EC_CONTENT_BECOMING_STALE){
        Fire_ContentBecomingStale();
        return NOERROR;
    }

    return IMSVidPBGraphSegmentImpl<CMSVidStreamBufferSource, MSVidSEG_SOURCE, &GUID_NULL>::OnEventNotify(lEvent, lParam1, lParam2);
}

HRESULT CMSVidStreamBufferSource::Fire(GUID gEventID) {
    TRACELSM(TRACE_DETAIL, (dbgDump << "CMSVidStreamBufferSource::Fire() guid = " << GUID2(gEventID)), "");
    if (gEventID == EVENTID_ETDTFilterLicenseFailure) {
		Fire_CertificateFailure();
    } else if (gEventID == EVENTID_ETDTFilterLicenseOK) {
		Fire_CertificateSuccess();
    } else if (gEventID == EVENTID_DTFilterRatingsBlock) {
        Fire_RatingsBlocked();
    } else if (gEventID == EVENTID_DTFilterRatingsUnblock) {
        Fire_RatingsUnblocked();
    } else if (gEventID == EVENTID_DTFilterRatingChange) {
        Fire_RatingsChanged();
    }

    return NOERROR;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\msvidsbesink.cpp ===
//==========================================================================;
//
// Copyright (c) Microsoft Corporation 1999-2000.
//
//--------------------------------------------------------------------------;
//
// MSVidStreamBufferSink.cpp : Implementation of CMSVidStreamBufferSink
//

#include "stdafx.h"

#ifndef TUNING_MODEL_ONLY

#include <encdec.h>
#include "MSVidCtl.h"
#include "MSVidSbeSink.h"

DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidStreamBufferSink, CMSVidStreamBufferSink)

/////////////////////////////////////////////////////////////////////////////
// CMSVidStreamBufferSink


STDMETHODIMP CMSVidStreamBufferSink::InterfaceSupportsErrorInfo(REFIID riid){
	static const IID* arr[] = 
	{
		&IID_IMSVidStreamBufferSink
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}



STDMETHODIMP CMSVidStreamBufferSink::get_SinkName(BSTR *pName){
	try{
		if(!pName){
			return E_POINTER;
		}
		*pName = m_SinkName.Copy();
		return S_OK;
	}
	catch(...){
		return E_UNEXPECTED;
	}
}
// This function has to be called before the graph is running
// so before or after build but before run is called
STDMETHODIMP CMSVidStreamBufferSink::put_SinkName(BSTR Name){
	try{
        if(!wcslen(Name)){
            return E_INVALIDARG;
        }
		m_SinkName = Name; 
        m_bNameSet = FALSE;
		CComQIPtr<IMSVidCtl> pq_vidCtl;
        if(!m_pContainer){
			return S_OK;
		}
		else{
            HRESULT hr = m_pContainer->QueryInterface(IID_IMSVidCtl, reinterpret_cast<void**>(&pq_vidCtl));
            if(FAILED(hr)){
                return hr;
            }
            MSVidCtlStateList state;
            hr = pq_vidCtl->get_State(&state);
            if(FAILED(hr)){
                return hr;
            }
            
            if(state == STATE_UNBUILT || state == STATE_STOP){
                hr = m_ptsSink->IsProfileLocked();
                if(FAILED(hr)){
                    return hr;
                }
                else if(hr != S_FALSE){
                    return E_FAIL; // should be called after run called on sink
                }
            }
            else{
                return E_FAIL; // should be called after run called on sink
            }		
        }
		return S_OK;
	}
	catch(...){
		return E_UNEXPECTED;
	}
}
void CMSVidStreamBufferSink::Expunge(){
    if(!( !m_RecordObj)){// not not'ing smart pointer, they assert if p == 0
        m_RecordObj.Release();
    }
    return;   
}
HRESULT CMSVidStreamBufferSink::get_ContentRecorder(BSTR pszFilename, IMSVidStreamBufferRecordingControl ** ppRecording){
    try{
        if(!pszFilename || !ppRecording){
            return E_POINTER;
        }

        if(!( !m_RecordObj)){// not not'ing smart pointer, they assert if p == 0
            m_RecordObj.Release();
        }
            // Create the new recorder if needed and insert it
        PUnknown tempUnknown;
        if(!m_ptsSink){
            //return not_init
            return E_FAIL; // should be invalid state
        }
        CComBSTR val = pszFilename;
        HRESULT hr = m_ptsSink->CreateRecorder(val, RECORDING_TYPE_CONTENT,&tempUnknown);
        if(FAILED(hr)){
            return hr;
        }
        pqSBERecControl newRec(tempUnknown);
        if(!newRec){
            return E_UNEXPECTED;
        }
        tempUnknown.Release();
        m_RecordObj = new CMSVidStreamBufferRecordingControl(newRec.Detach(), val.Detach(), RECORDING_TYPE_CONTENT);
        if(!m_RecordObj){
            ASSERT(false);
            return E_UNEXPECTED;
        }
        /*        
        CComQIPtr<IMSVidStreamBufferRecorder>retObj(m_RecordObj);
        if(!retObj){
            ASSERT(false);
            return E_UNEXPECTED;
        }
        *ppRecording = retObj.Detach();
        */
        //m_RecordObj->AddRef();
        hr = m_RecordObj.CopyTo(ppRecording);
        if(!ppRecording || FAILED(hr)){
            ASSERT(false);
            return E_UNEXPECTED;
        }
    }
    catch(...){
        return E_UNEXPECTED;
    }
    
    return S_OK;
}
HRESULT CMSVidStreamBufferSink::get_ReferenceRecorder(BSTR pszFilename, IMSVidStreamBufferRecordingControl ** ppRecording){
    try{
        if(!pszFilename || !ppRecording){
            return E_POINTER;
        }

        if(!( !m_RecordObj)){// not not'ing smart pointer, they assert if p == 0
            m_RecordObj.Release();
        }
            // Create the new recorder if needed and insert it
        PUnknown tempUnknown;
        if(!m_ptsSink){
            //return not_init
            return E_FAIL; // should be invalid state
        }
        CComBSTR val = pszFilename;
        HRESULT hr = m_ptsSink->CreateRecorder(val, RECORDING_TYPE_REFERENCE, &tempUnknown);
        if(FAILED(hr)){
            return hr;
        }
        pqSBERecControl newRec(tempUnknown);
        if(!newRec){
            return E_UNEXPECTED;
        }
        tempUnknown.Release();
        m_RecordObj = new CMSVidStreamBufferRecordingControl(newRec.Detach(), val.Detach(), RECORDING_TYPE_REFERENCE);
        if(!m_RecordObj){
            ASSERT(false);
            return E_UNEXPECTED;
        }
        /*        
        CComQIPtr<IMSVidStreamBufferRecordingControl>retObj(m_RecordObj);
        if(!retObj){
            ASSERT(false);
            return E_UNEXPECTED;
        }
        *ppRecording = retObj.Detach();
        */
        //m_RecordObj->AddRef();
        hr = m_RecordObj.CopyTo(ppRecording);
        if(!ppRecording || FAILED(hr)){
            ASSERT(false);
            return E_UNEXPECTED;
        }
    }
    catch(...){
        return E_UNEXPECTED;
    }
    
    return S_OK;
}

HRESULT CMSVidStreamBufferSink::get_SBESink(IUnknown ** sbeConfig){
    if(!sbeConfig){
        return E_POINTER;
    }
    if(m_StreamBuffersink == -1){
        return E_UNEXPECTED;
    }
    CComQIPtr<IBaseFilter> spSinkFilter(m_Filters[m_StreamBuffersink]);
    CComPtr<IUnknown>spUnk;
    spUnk = spSinkFilter;
    if(!spUnk){
        return E_UNEXPECTED;
    }
    *sbeConfig = spUnk.Detach();
    return NOERROR;

}

HRESULT CMSVidStreamBufferSink::Fire(GUID gEventID) {
	TRACELSM(TRACE_DETAIL, (dbgDump << "CMSVidStreamBufferSink::Fire() guid = " << GUID2(gEventID)), "");
    if (gEventID == EVENTID_ETDTFilterLicenseFailure) {
		Fire_CertificateFailure();
    } else if (gEventID == EVENTID_ETDTFilterLicenseOK) {
        TRACELSM(TRACE_ERROR, (dbgDump << "CMSVidStreamBufferSink::Fire() Certificate Success"), "");
		Fire_CertificateSuccess();
    } 
    return NOERROR;
}

#endif //TUNING_MODEL_ONLY

// end of file - MSVidStreamBufferSink.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\msvidsbesink.h ===
//==========================================================================;
// MSVidStreamBufferSink.h : Declaration of the CMSVidStreamBufferSink
// copyright (c) Microsoft Corp. 1998-1999.
//==========================================================================;

//==========================================================================;
/* MSVidStreamBufferSink is the sink (destination, output) segement for the MSVidCtl 
   implementation of the SBE/StreamBuffer (StreamBuffer/digital video recording).
        Other than the normal methods of a output segment (see msvidclt.idl and 
        segment.idl) the sink also has:
        get/put_SinkName to name this instance of the SBE/StreamBuffer filter, so it can
            be easily refered to in another 
   In the MSVidCtl solution for SBE/StreamBuffer there are three segments that had to be added
   to MSVidCtl. The sink, source and StreamBufferSource segements. 
   The sink is the segement that gets connected to the input that is being StreamBuffered.
   The source is the segment that acts as the input for playback of the StreamBuffered content.
   The StreamBufferSource segment exists to play back the recorded files that are stored seperatly 
   from the SBE/StreamBuffer buffers. This is a seperate segment since there is no support, currently,
   for wm* (v or a) or asf content in MSVidCtl and even if there was the SBE/StreamBuffer content is in a 
   form of asf that is not supported by the windows media codec anyway.

*/
//==========================================================================;

#ifndef __MSVidSTREAMBUFFERSINK_H_
#define __MSVidSTREAMBUFFERSINK_H_

#pragma once

#include <algorithm>
#include <map>
#include <functional>
#include <iostream>
#include <string>
#include <evcode.h>
#include <uuids.h>
#include <amvideo.h>
#include <strmif.h>
#include <dvdmedia.h>
#include <objectwithsiteimplsec.h>
#include <bcasteventimpl.h>
#include "sbesinkcp.h"
#include "msvidctl.h"
#include "vidrect.h"
#include "vrsegimpl.h"
#include "devimpl.h"
#include "devsegimpl.h"
#include "seg.h"
#include "msvidsberecorder.h"
#include "resource.h"       // main symbols
#ifdef BUILD_WITH_DRM
#include "DRMSecure.h"
#include "DRMRootCert.h"      

#ifdef USE_TEST_DRM_CERT                        // dont use true (7002) CERT 
#include "Keys_7001.h"                                 //   until final release
static const BYTE* pabCert2      = abCert7001;
static const int   cBytesCert2   = sizeof(abCert7001);
static const BYTE* pabPVK2       = abPVK7001;
static const int   cBytesPVK2    = sizeof(abPVK7001);
#else
#include "Keys_7002.h"                                 // used in release code
static const BYTE* pabCert2      = abCert7002;
static const int   cBytesCert2   = sizeof(abCert7002);
static const BYTE* pabPVK2       = abPVK7002;
static const int   cBytesPVK2    = sizeof(abPVK7002);
#endif
#endif
typedef CComQIPtr<IStreamBufferSink> PQTSSink;
typedef CComQIPtr<IMSVidStreamBufferRecordingControl> pqRecorder;

/////////////////////////////////////////////////////////////////////////////
// CMSVidStreamBufferSink
class ATL_NO_VTABLE __declspec(uuid("9E77AAC4-35E5-42a1-BDC2-8F3FF399847C")) CMSVidStreamBufferSink :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMSVidStreamBufferSink, &CLSID_MSVidStreamBufferSink>,
    public IObjectWithSiteImplSec<CMSVidStreamBufferSink>,
	public ISupportErrorInfo,
    public IBroadcastEventImpl<CMSVidStreamBufferSink>,
    public CProxy_StreamBufferSinkEvent<CMSVidStreamBufferSink>,
	public IMSVidGraphSegmentImpl<CMSVidStreamBufferSink, MSVidSEG_DEST, &GUID_NULL>,
	public IConnectionPointContainerImpl<CMSVidStreamBufferSink>,
	public IMSVidDeviceImpl<CMSVidStreamBufferSink, &LIBID_MSVidCtlLib, &GUID_NULL, IMSVidStreamBufferSink>
{
public:
	CMSVidStreamBufferSink() :
        m_StreamBuffersink(-1),
        m_bNameSet(FALSE)
	{

	}
   virtual ~CMSVidStreamBufferSink() {
       Expunge();
    }

REGISTER_AUTOMATION_OBJECT(IDS_PROJNAME,
						   IDS_REG_MSVIDSTREAMBUFFERSINK_PROGID,
						   IDS_REG_MSVIDSTREAMBUFFERSINK_DESC,
						   LIBID_MSVidCtlLib,
						   __uuidof(CMSVidStreamBufferSink));

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMSVidStreamBufferSink)
	COM_INTERFACE_ENTRY(IMSVidGraphSegment)
	COM_INTERFACE_ENTRY(IMSVidStreamBufferSink)
    COM_INTERFACE_ENTRY(IMSVidOutputDevice)
	COM_INTERFACE_ENTRY(IMSVidDevice)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IBroadcastEvent)
    COM_INTERFACE_ENTRY(IObjectWithSite)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IPersist)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CMSVidStreamBufferSink)
	IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
	IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
	IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
END_CATEGORY_MAP()

BEGIN_CONNECTION_POINT_MAP(CMSVidStreamBufferSink)
	CONNECTION_POINT_ENTRY(IID_IMSVidStreamBufferSinkEvent)    
END_CONNECTION_POINT_MAP()
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
protected:
    PQTSSink m_ptsSink;
	int m_StreamBuffersink;
	CComBSTR m_SinkName;
public:
    CComBSTR __declspec(property(get=GetName)) m_Name;
    CComBSTR GetName(void) {
        CString csName;
        if(m_StreamBuffersink != -1){
            csName = (m_Filters[m_StreamBuffersink]).GetName();
        }
        if (csName.IsEmpty()) {
            csName = _T("Time Shift Sink");
        }
		csName += _T(" Segment");
        return CComBSTR(csName);
    }
	STDMETHOD(get_SinkName)(BSTR *pName);
	STDMETHOD(put_SinkName)(BSTR Name);
    STDMETHOD(get_ContentRecorder)(BSTR pszFilename, IMSVidStreamBufferRecordingControl ** ppRecording);  
    STDMETHOD(get_ReferenceRecorder)(BSTR pszFilename, IMSVidStreamBufferRecordingControl ** ppRecording);  
    STDMETHOD(get_SBESink)(IUnknown ** sbeConfig);
STDMETHOD(Unload)(void) {
    // TODO fix this
    TRACELM(TRACE_DETAIL, "CMSVidStreamBufferSink::Unload()");
    BroadcastUnadvise();

	IMSVidGraphSegmentImpl<CMSVidStreamBufferSink, MSVidSEG_DEST, &GUID_NULL>::Unload();
	m_StreamBuffersink = -1;
	m_ptsSink = reinterpret_cast<IUnknown*>(NULL);
    m_RecordObj.Release();
    _ASSERT(!m_RecordObj);
    m_bNameSet = FALSE;
	return NO_ERROR;
}
STDMETHOD(Decompose)(void) {
    // TODO fix this
    TRACELM(TRACE_DETAIL, "CMSVidStreamBufferSink::Decompose()");
	IMSVidGraphSegmentImpl<CMSVidStreamBufferSink, MSVidSEG_DEST, &GUID_NULL>::Decompose();
	Unload();
	return NO_ERROR;
}
 
STDMETHOD(Build)() {
    try{
        TRACELM(TRACE_DETAIL, "CMSVidStreamBufferSink::Build()");
        if (!m_fInit || !m_pGraph) {
            return ImplReportError(__uuidof(IMSVidStreamBufferSink), IDS_OBJ_NO_INIT, __uuidof(IMSVidStreamBufferSink), CO_E_NOTINITIALIZED);
        }
        CString csName;
        PQTSSink pTSSink(CLSID_StreamBufferSink, NULL, CLSCTX_INPROC_SERVER);
        if (!pTSSink) {
            //TRACELSM(TRACE_ERROR, (dbgDump << "CMSVidStreamBufferSink::Build() can't load Time Shift Sink");
            return ImplReportError(__uuidof(IMSVidStreamBufferSink), IDS_CANT_CREATE_FILTER, __uuidof(IStreamBufferSink), E_UNEXPECTED);
        }
        DSFilter vr(pTSSink);
        if (!vr) {
            ASSERT(false);
            return ImplReportError(__uuidof(IMSVidStreamBufferSink), IDS_CANT_CREATE_FILTER, __uuidof(IBaseFilter), E_UNEXPECTED);
        }
        if (m_StreamBuffersink == -1) {
            m_Filters.push_back(vr);
            csName = _T("Time Shift Sink");
            m_pGraph.AddFilter(vr, csName);
        }         
        m_ptsSink = pTSSink;
        if(!m_ptsSink){
            return ImplReportError(__uuidof(IMSVidStreamBufferSink), IDS_CANT_CREATE_FILTER, __uuidof(IBaseFilter), E_UNEXPECTED);
        }
        m_StreamBuffersink = 0;
        ASSERT(m_StreamBuffersink == 0);
        m_bNameSet = FALSE;
        return NOERROR;
    } catch (ComException &e) {
        return e;
    } catch (...) {
        return E_UNEXPECTED;
    }
}
STDMETHOD(get_Segment)(IMSVidGraphSegment * * pIMSVidGraphSegment){
        if (!m_fInit) {
	 	    return Error(IDS_OBJ_NO_INIT, __uuidof(IMSVidStreamBufferSink), CO_E_NOTINITIALIZED);
        }
        try {
            if (pIMSVidGraphSegment == NULL) {
			    return E_POINTER;
            }
            *pIMSVidGraphSegment = this;
            AddRef();
            return NOERROR;
        } catch(...) {
            return E_POINTER;
        }
    }
// IGraphSegment
STDMETHOD(put_Container)(IMSVidGraphSegmentContainer *pCtl) {
    try {
        TRACELM(TRACE_DETAIL, "CMSVidStreamBufferSink::put_Container()");
        HRESULT hr = IMSVidGraphSegmentImpl<CMSVidStreamBufferSink, MSVidSEG_DEST, &GUID_NULL>::put_Container(pCtl);
        if (FAILED(hr)) {
            return hr;
        }

        if (!pCtl) {
#ifdef BUILD_WITH_DRM
            CComQIPtr<IServiceProvider> spServiceProvider(m_pGraph);
            if (spServiceProvider != NULL) {
                CComPtr<IDRMSecureChannel>  spSecureService;  
                hr = spServiceProvider->QueryService(SID_DRMSecureServiceChannel, 
                    IID_IDRMSecureChannel,
                    reinterpret_cast<LPVOID*>(&spSecureService));
                if(S_OK == hr){
                    // Found existing Secure Server
                    CComQIPtr<IRegisterServiceProvider> spRegServiceProvider(m_pGraph);
                    if(spRegServiceProvider == NULL){
                        // no service provider interface on the graph - fatal!
                        hr = E_NOINTERFACE;                 
                    } 

                    if(SUCCEEDED(hr)){ 
                        hr = spRegServiceProvider->RegisterService(SID_DRMSecureServiceChannel, NULL);
                    }
                } 
                _ASSERT(SUCCEEDED(hr));
            }
#endif
        }

        hr = BroadcastAdvise();
        if (FAILED(hr)) {
            TRACELM(TRACE_ERROR, "CMSVidStreamBufferSource::put_Container() can't advise for broadcast events");
            return E_UNEXPECTED;
        }
#ifdef BUILD_WITH_DRM
#ifdef USE_TEST_DRM_CERT
        {
            DWORD dwDisableDRMCheck = 0;
            CRegKey c;
            CString keyname(_T("SOFTWARE\\Debug\\MSVidCtl"));
            DWORD rc = c.Open(HKEY_LOCAL_MACHINE, keyname, KEY_READ);
            if (rc == ERROR_SUCCESS) {
                rc = c.QueryValue(dwDisableDRMCheck, _T("DisableDRMCheck"));
                if (rc != ERROR_SUCCESS) {
                    dwDisableDRMCheck = 0;
                }
            }

            if(dwDisableDRMCheck == 1){
                return S_OK;
            }
        }
#endif
        CComQIPtr<IServiceProvider> spServiceProvider(m_pGraph);
        if (spServiceProvider == NULL) {
            return E_NOINTERFACE;
        }
        CComPtr<IDRMSecureChannel>  spSecureService;  
        hr = spServiceProvider->QueryService(SID_DRMSecureServiceChannel, 
            IID_IDRMSecureChannel,
            reinterpret_cast<LPVOID*>(&spSecureService));
        if(S_OK == hr){
            // Found existing Secure Server
            return S_OK;
        } 
        else{
            // if it's not there or failed for ANY reason 
            //   lets create it and register it
            CComQIPtr<IRegisterServiceProvider> spRegServiceProvider(m_pGraph);
            if(spRegServiceProvider == NULL){
                // no service provider interface on the graph - fatal!
                hr = E_NOINTERFACE;                 
            } 
            else{
                // Create the Client 
                CComPtr<IDRMSecureChannel>  spSecureServiceServer; 
                hr = DRMCreateSecureChannel( &spSecureServiceServer);
                if(spSecureServiceServer == NULL){
                    hr = E_OUTOFMEMORY;
                }
                if(FAILED(hr)){ 
                    return hr;
                }

                // Init keys
                hr = spSecureServiceServer->DRMSC_SetCertificate((BYTE *)pabCert2, cBytesCert2);
                if(FAILED(hr)){                
                    return hr;
                }

                hr = spSecureServiceServer->DRMSC_SetPrivateKeyBlob((BYTE *)pabPVK2, cBytesPVK2);
                if(FAILED(hr)){ 
                    return hr;
                }

                hr = spSecureServiceServer->DRMSC_AddVerificationPubKey((BYTE *)abEncDecCertRoot, sizeof(abEncDecCertRoot) );
                if(FAILED(hr)){ 
                    return hr;
                }

                // Register It
                //   note RegisterService does not addref pUnkSeekProvider             
                hr = spRegServiceProvider->RegisterService(SID_DRMSecureServiceChannel, spSecureServiceServer);
            }
        }
#endif      // BUILD_WITH_DRM
        return NOERROR;
    } catch(...) {
        return E_UNEXPECTED;
    }
}

 
STDMETHODIMP CMSVidStreamBufferSink::PreRun(){
    TRACELM(TRACE_DETAIL, "CMSVidStreamBufferSink::PreRun()");
    return NameSetLock();
}

STDMETHODIMP CMSVidStreamBufferSink::NameSetLock(){
    try {
        TRACELM(TRACE_DETAIL, "CMSVidStreamBufferSink::NameSetLock()");
        HRESULT hr;
        if(!m_bNameSet){
            if(!m_SinkName){
                return S_FALSE;
            }
            else{
                hr = m_ptsSink->IsProfileLocked();
                if(FAILED(hr)){
                    TRACELM(TRACE_DETAIL, "CMSVidStreamBufferSink::NameSetLock() IsProfileLocked failed");
                    return hr;
                }
                else if(hr == S_OK){
                    TRACELM(TRACE_DETAIL, "CMSVidStreamBufferSink::NameSetLock() Profile is locked");
                    return E_FAIL;
                }
                hr = m_ptsSink->LockProfile(m_SinkName);
                if(FAILED(hr)){
                    TRACELM(TRACE_DETAIL, "CMSVidStreamBufferSink::NameSetLock() LockedProfile failed");
                    return hr;
                }
                
            }
            m_bNameSet = TRUE;
        }
        TRACELM(TRACE_DETAIL, "CMSVidStreamBufferSink::NameSetLock() Succeeded");
		return S_OK;

	} catch (ComException &e) {
        TRACELM(TRACE_DETAIL, "CMSVidStreamBufferSink::NameSetLock() Exception");
		return e;
	} catch (...) {
        TRACELM(TRACE_DETAIL, "CMSVidStreamBufferSink::NameSetLock() Possible AV");
		return E_UNEXPECTED;
	}
}

STDMETHODIMP CMSVidStreamBufferSink::PostStop() {
	try {
        m_bNameSet = FALSE;
		TRACELM(TRACE_DETAIL, "CMSVidStreamBufferSink::PostStop()");
        return S_OK;
	} catch (...) {
		ASSERT(FALSE);
		return E_UNEXPECTED;
	}
}

// IMSVidDevice
STDMETHOD(get_Name)(BSTR * Name) {
        if (!m_fInit) {
	 	    return Error(IDS_OBJ_NO_INIT, __uuidof(IMSVidStreamBufferSink), CO_E_NOTINITIALIZED);
        }
		if (Name == NULL)
			return E_POINTER;
        try {
		    *Name = m_Name.Copy();	
        } catch(...) {
            return E_POINTER;
        }
		return NOERROR;
	}
STDMETHOD(get_Status)(LONG * Status) {
        if (!m_fInit) {
	 	    return Error(IDS_OBJ_NO_INIT, __uuidof(IMSVidStreamBufferSink), CO_E_NOTINITIALIZED);
        }
		if (Status == NULL)
			return E_POINTER;
			
		return E_NOTIMPL;
	}

STDMETHOD(OnEventNotify)(LONG lEventCode, LONG_PTR lEventParm1, LONG_PTR lEventParm2){
        if(lEventCode == STREAMBUFFER_EC_WRITE_FAILURE){
            TRACELM(TRACE_DETAIL, "CMSVidStreamBufferSink::OnEventNotify STREAMBUFFER_EC_WRITE_FAILURE");
            Fire_WriteFailure();
            return NO_ERROR;
        }
        return E_NOTIMPL;
    }
    // IBroadcastEvent
    STDMETHOD(Fire)(GUID gEventID);
private:
    void Expunge();
    pqRecorder m_RecordObj;
    BOOL m_bNameSet;
};
#endif //__MSVIDSTREAMBUFFERSINK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\msvidtvtuner.h ===
//==========================================================================;
// MSVidTVTuner.h : Declaration of the CMSVidTVTuner
// copyright (c) Microsoft Corp. 1998-1999.
/////////////////////////////////////////////////////////////////////////////

#pragma once

#ifndef __MSVidTVTUNER_H_
#define __MSVidTVTUNER_H_

#include <algorithm>
#include <tchar.h>
#include <bdamedia.h>
#include <objectwithsiteimplsec.h>
#include <bcasteventimpl.h>
#include "segimpl.h"
#include "analogtunerimpl.h"
#include "analogtvcp.h"
#include "seg.h"

const int DEFAULT_OVERSCAN_PCT = 100; // 1%

/////////////////////////////////////////////////////////////////////////////
// CMSVidTVTuner
class ATL_NO_VTABLE __declspec(uuid("1C15D484-911D-11d2-B632-00C04F79498E")) CMSVidTVTuner : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CMSVidTVTuner, &__uuidof(CMSVidTVTuner)>,
    public IObjectWithSiteImplSec<CMSVidTVTuner>,
    public ISupportErrorInfo,
    public IConnectionPointContainerImpl<CMSVidTVTuner>,
    public CProxy_IMSVidAnalogTuner<CMSVidTVTuner>,
    public IBroadcastEventImpl<CMSVidTVTuner>,
    public IMSVidGraphSegmentImpl<CMSVidTVTuner, MSVidSEG_SOURCE, &KSCATEGORY_TVTUNER>,
    public IMSVidAnalogTunerImpl<CMSVidTVTuner, &LIBID_MSVidCtlLib, &KSCATEGORY_TVTUNER, IMSVidAnalogTuner>,
    public IProvideClassInfo2Impl<&CLSID_MSVidAnalogTunerDevice, &IID_IMSVidAnalogTunerEvent, &LIBID_MSVidCtlLib>
{
public:
    CMSVidTVTuner() : m_iTuner(-1), 
        m_iCapture(-1),
        m_bRouted(false)
    {

    }

    virtual ~CMSVidTVTuner() {}

    REGISTER_AUTOMATION_OBJECT(IDS_PROJNAME, 
        IDS_REG_TVTUNER_PROGID, 
        IDS_REG_TVTUNER_DESC,
        LIBID_MSVidCtlLib,
        __uuidof(CMSVidTVTuner));

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CMSVidTVTuner)
        COM_INTERFACE_ENTRY(IMSVidGraphSegment)
        COM_INTERFACE_ENTRY(IMSVidAnalogTuner)
        COM_INTERFACE_ENTRY(IMSVidTuner)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IObjectWithSite)
        COM_INTERFACE_ENTRY(IMSVidDevice)
        COM_INTERFACE_ENTRY(IMSVidInputDevice)
        COM_INTERFACE_ENTRY(IMSVidVideoInputDevice)
        COM_INTERFACE_ENTRY(IBroadcastEvent)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IConnectionPointContainer)
        COM_INTERFACE_ENTRY(IPersist)
        COM_INTERFACE_ENTRY(IProvideClassInfo2)
        COM_INTERFACE_ENTRY(IProvideClassInfo)
    END_COM_MAP()

    BEGIN_CATEGORY_MAP(CMSVidTVTuner)
        IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
        IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
        IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
    END_CATEGORY_MAP()

    BEGIN_CONNECTION_POINT_MAP(CMSVidTVTuner)
        CONNECTION_POINT_ENTRY(IID_IMSVidAnalogTunerEvent)    
    END_CONNECTION_POINT_MAP()


    // ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

public:
    PQCreateDevEnum m_pSystemEnum;
    int m_iTuner;
    int m_iCapture;
    bool m_bRouted;

    virtual PQTVTuner GetTuner() {
        if (m_iTuner < 0) {
            return PQTVTuner();
        }
        return PQTVTuner(m_Filters[m_iTuner]);
    }
    virtual PQAnalogVideoDecoder GetDecoder() {
        if (m_iCapture < 0) {
            return PQAnalogVideoDecoder();
        }
        return PQAnalogVideoDecoder(m_Filters[m_iCapture]);
    }
    STDMETHOD(put_Tune)(ITuneRequest *pTR);
    STDMETHOD(ChannelAvailable)(LONG nChannel, LONG * SignalStrength, VARIANT_BOOL * fSignalPresent);
    STDMETHOD(Decompose)();
    virtual HRESULT DoTune(TNTuneRequest &ctr);
    virtual HRESULT UpdateTR(TNTuneRequest& pTR);
    HRESULT TwiddleXBar(ULONG dwInput);
    HRESULT Unload(void) {
        BroadcastUnadvise();
        IMSVidGraphSegmentImpl<CMSVidTVTuner, MSVidSEG_SOURCE, &KSCATEGORY_TVTUNER>::Unload();
        m_iTuner = -1;
        m_iCapture = -1;
        return NOERROR;
    }
    // IMSVidGraphSegment
    STDMETHOD(put_Init)(IUnknown *pDeviceMoniker)
    {
        if (!pDeviceMoniker) {
            return E_POINTER;
        }
        HRESULT hr = IMSVidGraphSegmentImpl<CMSVidTVTuner, MSVidSEG_SOURCE, &KSCATEGORY_TVTUNER>::put_Init(pDeviceMoniker);
        if (FAILED(hr)) {
            return hr;
        }
        if (!m_pDev) {
            m_fInit = false;
            return Error(IDS_INVALID_SEG_INIT, __uuidof(IMSVidAnalogTuner), E_NOINTERFACE);
        }
        return NOERROR;
    }
    STDMETHOD(Build)();

    STDMETHOD(PreRun)() {
        ASSERT(m_iTuner != -1);
        PQTVTuner pTV(m_Filters[m_iTuner]);
        if (!pTV) {
            return E_UNEXPECTED;
        }
        if (m_pCurrentTR) {
            return DoTune(m_pCurrentTR);
        }
        TunerInputType it = DEFAULT_ANALOG_TUNER_INPUT_TYPE;
        long cc = DEFAULT_ANALOG_TUNER_COUNTRY_CODE;
        if (m_TS) {
            TNAnalogTVTuningSpace ts(m_TS);
            it = ts.InputType();
            cc = ts.CountryCode();
        }
        HRESULT hr = pTV->put_InputType(0, it);
        _ASSERT(SUCCEEDED(hr));
        hr = pTV->put_CountryCode(cc);
        _ASSERT(SUCCEEDED(hr));

        return NOERROR;
    }

    STDMETHOD(put_Container)(IMSVidGraphSegmentContainer *pCtl);
    // IMSVidDevice
    STDMETHOD(get_Name)(BSTR * Name)
    {
        if (!m_fInit) {
            return CO_E_NOTINITIALIZED;
        }
        try {
            CComBSTR DefaultName(OLESTR("Analog Tuner"));
            return GetName(((m_iTuner > -1) ? (m_Filters[m_iTuner]) : DSFilter()), m_pDev, DefaultName).CopyTo(Name);
            return NOERROR;
        } catch(...) {
            return E_POINTER;
        }
    }
    // IBroadcastEvent
    STDMETHOD(Fire)(GUID gEventID) {
        if (gEventID == EVENTID_TuningChanged) {
            Fire_OnTuneChanged(this);
        }
        return NOERROR;
    }

};

typedef CComQIPtr<IMSVidAnalogTuner, &__uuidof(IMSVidAnalogTuner)> PQMSVidAnalogTuner;
typedef CComPtr<IMSVidAnalogTuner> PMSVidAnalogTuner;
#endif //__MSVidTVTUNER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\msvidtvtuner.cpp ===
//==========================================================================;
//
// Copyright (c) Microsoft Corporation 1999-2000.
//
//--------------------------------------------------------------------------;
//
// MSVidTVTuner.cpp : Implementation of CMSVidTVTuner
//

#include "stdafx.h"

#ifndef TUNING_MODEL_ONLY



#include "perfcntr.h"
#include "MSVidCtl.h"
#include "MSVidTVTuner.h"
#include <bdamedia.h>
#include "segimpl.h"
#include "segimpl.h"
#include "devices.h"


const ULONG t_SVIDEO = 0;
const ULONG t_COMPOSITE = 1;
const ULONG t_TUNER = 2;
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidAnalogTunerDevice, CMSVidTVTuner)

const int DEFAULT_ANALOG_CHANNEL = 4;

typedef CComQIPtr<IMSVidCtl> PQMSVidCtl;
typedef CComQIPtr<IMSVidVideoRenderer> PQMSVidVideoRenderer;

/////////////////////////////////////////////////////////////////////////////
// CMSVidTVTuner

STDMETHODIMP CMSVidTVTuner::Decompose(){
    m_bRouted = false;
    return S_OK;
}

STDMETHODIMP CMSVidTVTuner::ChannelAvailable(LONG nChannel, LONG * SignalStrength, VARIANT_BOOL * fSignalPresent){
    VIDPERF_FUNC; 
    if(!SignalStrength || !fSignalPresent){
        return E_POINTER;
    }
    CComQIPtr<IAMAnalogVideoDecoder> qi_VidDec(m_Filters[m_iCapture]);
    if(qi_VidDec){
        long signal = FALSE;
        HRESULT hr = qi_VidDec->get_HorizontalLocked(&signal);
        if(FAILED(hr)){
            return hr;
        }
        *fSignalPresent = signal ? VARIANT_TRUE:VARIANT_FALSE;
        return NOERROR;
    }
    return E_NOINTERFACE;
}


STDMETHODIMP CMSVidTVTuner::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] = 
    {
        &IID_IMSVidAnalogTuner
    };
    for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}
STDMETHODIMP CMSVidTVTuner::put_Tune(ITuneRequest *pTR) {
    VIDPERF_FUNC;
    TRACELM(TRACE_DETAIL, "CMSVidTVTuner<>::put_Tune()");
    if (!m_fInit) {
        return Error(IDS_OBJ_NO_INIT, __uuidof(IMSVidTuner), CO_E_NOTINITIALIZED);
    }
    if (!pTR) {
        return E_POINTER;
    }
    try {
        TNTuneRequest req(pTR);
        ASSERT(req);
        // This whole next section would be nice to check, but due to aux in 
        //   the Tuning Space may change
        /*if (m_TS) {
        // if this tuner has been initialized propertly it will have a tuning space
        // that it handles already specified.  in that case, we should only
        // handle tune requests for our ts
        TNTuningSpace ts(req.TuningSpace());
        if (ts != m_TS) {
        return ImplReportError(__uuidof(T), IDS_INVALID_TS, __uuidof(IMSVidTuner), E_INVALIDARG);
        }
        } else {
        // undone: if dev init is correct this case should never occur
        // return E_UNEXPECTED;
        }
        */
        HRESULT hr = S_OK;
        PQVidCtl pqCtl;
        if(!!m_pContainer){
            hr = m_pContainer->QueryInterface(IID_IMSVidCtl, reinterpret_cast<void**>(&pqCtl));
            if(FAILED(hr)){
                return hr;
            }
            MSVidCtlStateList curState = STATE_UNBUILT;
            hr = pqCtl->get_State(&curState);
            if(SUCCEEDED(hr) && curState > STATE_STOP){
                hr = DoTune(req);
            }
            else{
                m_bRouted = false;
                hr = NOERROR;
            }
        }
        if (SUCCEEDED(hr)) {
            m_pCurrentTR = req;
            m_pCurrentTR.Clone();
            if (!m_TS) {
                // undone: this is bad.  temporary hack until dev init is correct.
                m_TS = req.TuningSpace();
                m_TS.Clone();
            }
        }
        return hr;
    } catch(...) {
        return E_INVALIDARG;
    }
}
HRESULT CMSVidTVTuner::UpdateTR(TNTuneRequest &tr) {
    TNChannelTuneRequest ctr(tr);

    // If we have not been routed yet, check the current tr first to make sure it is not set
    // if we don't get_Tune wacks the tr currently set
    if(!m_bRouted){
        if(m_pCurrentTR){
            TNChannelTuneRequest curTR(m_pCurrentTR);
            HRESULT hr = ctr->put_Channel(curTR.Channel());
            if (FAILED(hr)) {
                return E_UNEXPECTED;
            }
            return NOERROR;
        }
    }

    long channel;
    PQTVTuner ptv(m_Filters[m_iTuner]);
    long vs, as;
    HRESULT hr = ptv->get_Channel(&channel, &vs, &as);
    if (FAILED(hr)) {
        return E_UNEXPECTED;
    }
    hr = ctr->put_Channel(channel);
    if (FAILED(hr)) {
        return E_UNEXPECTED;
    }
    // undone: update the components 

    return NOERROR;
}
HRESULT CMSVidTVTuner::TwiddleXBar(ULONG dwInput){    // For Support for Aux Inputs
    VIDPERF_FUNC;
    if(dwInput < 0 || dwInput > 2){
        return E_INVALIDARG;
    }
    // Set up lists of audio and video types for use in routing data
    int m_iDeMux = -1;
    MediaMajorTypeList VideoTypes;
    MediaMajorTypeList AudioTypes;
    if (!VideoTypes.size()) {
        VideoTypes.push_back(MEDIATYPE_Video);
        VideoTypes.push_back(MEDIATYPE_AnalogVideo);

    }

    if (!AudioTypes.size()) {
        AudioTypes.push_back(MEDIATYPE_Audio);
        AudioTypes.push_back(MEDIATYPE_AnalogAudio);
    }

    // See how far we have to route the audio/video
    PQVidCtl pqCtl;
    if(!!m_pContainer){
        HRESULT hr = m_pContainer->QueryInterface(IID_IMSVidCtl, reinterpret_cast<void**>(&pqCtl));
        if(FAILED(hr)){
            return hr;
        }

        PQFeatures fa;
        hr = pqCtl->get_FeaturesActive(&fa);
        if(FAILED(hr)){
            return hr;
        }

        CFeatures* pC = static_cast<CFeatures *>(fa.p);
        DeviceCollection::iterator i;
        for(i = pC->m_Devices.begin(); i != pC->m_Devices.end(); ++i){
            if(VWGraphSegment(*i).ClassID() == CLSID_MSVidEncoder){
                break;
            }
        }

        if(i != pC->m_Devices.end()){
            m_iDeMux = 1;
        }
    }

    // Find the Capture Filter
    DSFilter capFilter (m_Filters[m_iCapture]);
    if(!capFilter){
        return E_FAIL;
    }

    // Get the Crossbar
    DSFilterList::iterator i;
    for(i = m_Filters.begin(); i != m_Filters.end(); ++i){
        if((*i).IsXBar()){
            break;
        }
    }
    if(i == m_Filters.end()){
        return E_FAIL;
    }

    // DSextend helper class
    PQCrossbarSwitch qiXBar((*i));
    if(!qiXBar){
        return E_FAIL;
    }

    // DSExtend does not have all the functions so get the filter as well
    DSFilter bar(qiXBar);
    if(!bar){
        return E_FAIL;
    }

    // Variables for routing audio and video
    DSFilter startFilter;
    DSPin audioStartPin, videoStartPin;
    VWStream vpath;
    VWStream apath;

    // Setup startFilter and startPins if needed
    if(dwInput == t_TUNER){
        PQVidCtl pqCtl;
        HRESULT hr = m_pContainer->QueryInterface(IID_IMSVidCtl, reinterpret_cast<void**>(&pqCtl));
        if(FAILED(hr)){
            return hr;
        }

        if(!pqCtl){
            return E_FAIL;
        }

        DSFilter tunerFilter(m_Filters[m_iTuner]);
        if(!tunerFilter){
            return E_FAIL;
        }

        startFilter = tunerFilter;
        if(!tunerFilter){
            _ASSERT(false);
            return E_UNEXPECTED;
        }

    }
    if(dwInput == t_SVIDEO || dwInput == t_COMPOSITE){
        // Route Audio from Audio Line In
        DSPin inAudio;
        DSPin inVideo;
        long inputs, outputs;

        HRESULT hr = qiXBar->get_PinCounts(&outputs, &inputs);
        if(FAILED(hr)){
            return E_FAIL;
        }

        long physConn, audioConn;
        // set up the physical connnecter we are looking for
        if(dwInput == t_SVIDEO){     
            physConn = PhysConn_Video_SVideo;
        }
        else if(dwInput == t_COMPOSITE){
            physConn = PhysConn_Video_Composite;
        }

        // always want line in
        audioConn = PhysConn_Audio_Line;
        long audioIdx = -1;
        long videoIdx = -1;

        // Look through all of the input pins looking for the audio and video input we need 
        for(long n = 0; n <= inputs; ++n){
            long inRelate, inType;
            hr = qiXBar->get_CrossbarPinInfo(TRUE, n, &inRelate, &inType);
            if(FAILED(hr)){
                continue;
            }

            if(inType == physConn){
                videoIdx = n;
            }

            if(inType == audioConn){
                audioIdx = n;
            }
        }
        if(videoIdx == audioIdx || videoIdx == -1 || audioIdx == -1){
            return E_FAIL;
        }

        long idx = -1;

        // Crossbars are wank and dont return pins instead they return indexes so we need to find the pin
        for(DSFilter::iterator foo = bar.begin(); foo != bar.end(); ++foo){
            if((*foo).GetDirection() == PINDIR_INPUT){
                ++idx;
                if(idx == videoIdx){
                    inVideo = (*foo);
                }

                if(idx == audioIdx){
                    inAudio = (*foo);
                }
            }
        }
        if(!inAudio || !inVideo){
            return E_FAIL;
        }
        startFilter = bar;
        audioStartPin = inAudio;
        videoStartPin = inVideo;
        if(!startFilter || !audioStartPin || !videoStartPin){
            _ASSERT(false);
            return E_UNEXPECTED;
        }
    }

    m_pGraph.BuildGraphPath(startFilter, capFilter, vpath, VideoTypes, DOWNSTREAM, videoStartPin);
    // undone: in win64 size() is really __int64.  fix output operator for
    // that type and remove cast
    TRACELSM(TRACE_DETAIL, (dbgDump << "CVidCtl::RouteStreams routing video path of size " << (long)vpath.size()), "");
    vpath.Route();

    TRACELM(TRACE_DETAIL, "CVidCtl::RouteStreams finding audio path");

    if(m_iDeMux > 0){
        m_pGraph.BuildGraphPath(startFilter, capFilter, apath, AudioTypes, DOWNSTREAM, audioStartPin);   
        apath.Route();
    }
    else {
        VWGraphSegment::iterator i;
        // there's an analog filter and a digital filter in every audio renderer segment, try both until
        // we find one that's connected.

        CComQIPtr<IMSVidAudioRenderer> audioR;
        pqCtl->get_AudioRendererActive(&audioR);
        VWGraphSegment ar(audioR);
        if(!!ar){
            for (i = ar.begin(); i != ar.end(); ++i) {
                m_pGraph.BuildGraphPath(startFilter, (*i), apath, AudioTypes, DOWNSTREAM, audioStartPin);
                if (apath.size()) {
                    TRACELSM(TRACE_DETAIL, (dbgDump << "Analog tuner Twiddling for audio path of size " << (long)apath.size()), "");
                    apath.Route();
                    break;
                }
            }
        }

    }

    m_bRouted = true;
    return NOERROR;  
}

HRESULT CMSVidTVTuner::DoTune(TNTuneRequest &tr) {
    VIDPERF_FUNC;
    TRACELM(TRACE_DETAIL, "CMSVidTVTuner()::DoTune()");
    // validate that this tuning request is one we can handle
    TNChannelTuneRequest newTR(tr);
    if (!newTR) {
        return Error(IDS_INVALID_TR, __uuidof(IMSVidAnalogTuner), DISP_E_TYPEMISMATCH);
    }

    TNChannelTuneRequest curTR(m_pCurrentTR);
    TNAnalogTVTuningSpace ats;
    ats = newTR.TuningSpace();
    if (!ats) {
        //return Error(IDS_INVALID_TR, __uuidof(IMSVidAnalogTuner), E_INVALIDARG);

        //********************************************************************//
        // MOGUL "FIX":                                                       //
        // Support for Analog Tuners that output mpeg                         //
        //********************************************************************//
        TNAuxInTuningSpace auxts;
        auxts = newTR.TuningSpace();
        if(!auxts){
            return Error(IDS_INVALID_TR, __uuidof(IMSVidAnalogTuner), E_INVALIDARG);
        }

        // if the graph isn't built don't do any more.
        if (m_iTuner == -1) {
            return S_FALSE;
            //Error(IDS_NP_NOT_INIT, __uuidof(IMSVidAnalogTuner), S_FALSE);
        }

        long channel = newTR.Channel();
        // Default is SVideo
        if (channel == -1) {
            channel = t_SVIDEO;
        }        

        // Check to see if the m_pCurrentTR is the same type as the one we are tuning to
        TNAuxInTuningSpace curTS(m_pCurrentTR.TuningSpace());

        if(!m_bRouted || !curTS || !curTR || curTR.Channel() != channel){
            if(channel == t_SVIDEO){
                HRESULT hr = TwiddleXBar(t_SVIDEO); 
            }
            else if(channel == t_COMPOSITE){
                HRESULT hr = TwiddleXBar(t_COMPOSITE); 
            }
            else{
                return Error(IDS_INVALID_TR, __uuidof(IMSVidAnalogTuner), E_INVALIDARG);
            }
        }
        //********************************************************************//
        // END "FIX"                                                          //
        //********************************************************************//        

    }
    else{
        // if the graph isn't built don't do any more.
        if (m_iTuner == -1) {
            return S_FALSE;
            //Error(IDS_NP_NOT_INIT, __uuidof(IMSVidAnalogTuner), S_FALSE);
        }

        PQTVTuner ptv(m_Filters[m_iTuner]);
        if(!ptv){
            return E_NOINTERFACE;
        }

        long channel = newTR.Channel();
        if (channel == -1) {
            channel = DEFAULT_ANALOG_CHANNEL;
        }

        long curChannel = -1;
        if(curTR){
            curChannel = curTR.Channel();
        }

        long curInputType = ats.InputType();
        long curCountryCode = ats.CountryCode();
		TNAnalogTVTuningSpace curTS;
		if(curTR){
			curTS = curTR.TuningSpace();
			if(curTS){
				curInputType = curTS.InputType();
				curCountryCode = curTS.CountryCode();
			}
        }
        bool bXbarTwiddled = false;
        if(!m_bRouted || !curTR || curInputType != ats.InputType() || curCountryCode != ats.CountryCode() || !curTS || curTS != ats){
            HRESULT hr = TwiddleXBar(t_TUNER); 
            if(FAILED(hr)){
                return hr;
            }
            TunerInputType ti = ats.InputType();
            hr = ptv->put_InputType(0, ti);
            if (FAILED(hr)) {
                return Error(IDS_CANT_SET_INPUTTYPE, __uuidof(IMSVidAnalogTuner), E_UNEXPECTED);
            }

            long countrycode = ats.CountryCode();
            hr = ptv->put_CountryCode(countrycode);
            if (FAILED(hr)) {
                return Error(IDS_CANT_SET_COUNTRYCODE, __uuidof(IMSVidAnalogTuner), E_UNEXPECTED);
            }
            bXbarTwiddled = true;
        }

        if(channel != curChannel || bXbarTwiddled){
            // undone: use components to determine subchannel stuff
            HRESULT hr = ptv->put_Channel(channel, AMTUNER_SUBCHAN_DEFAULT, AMTUNER_SUBCHAN_DEFAULT);
            if (FAILED(hr)) {
                return Error(IDS_CANT_SET_CHANNEL, __uuidof(IMSVidAnalogTuner), hr);
            }
        }

    }
    if (!m_pBcast) {
        PQServiceProvider sp(m_pGraph);
        if (!sp) {
            TRACELM(TRACE_ERROR, "CMSVidTVTuner::DoTune() can't get service provider i/f");
            return Error(IDS_CANT_NOTIFY_CHANNEL_CHANGE, __uuidof(IMSVidAnalogTuner), E_UNEXPECTED);
        }

        HRESULT hr = sp->QueryService(SID_SBroadcastEventService, IID_IBroadcastEvent, reinterpret_cast<LPVOID*>(&m_pBcast));
        if (FAILED(hr) || !m_pBcast) {
            hr = m_pBcast.CoCreateInstance(CLSID_BroadcastEventService, 0, CLSCTX_INPROC_SERVER);
            if (FAILED(hr)) {
                TRACELM(TRACE_ERROR, "CMSVidTVTuner::DoTune() can't create bcast service");
                return Error(IDS_CANT_NOTIFY_CHANNEL_CHANGE, __uuidof(IMSVidAnalogTuner), E_UNEXPECTED);
            }

            PQRegisterServiceProvider rsp(m_pGraph);
            if (!rsp) {
                TRACELM(TRACE_ERROR, "CMSVidTVTuner::DoTune() can't get get register service provider i/f");
                return Error(IDS_CANT_NOTIFY_CHANNEL_CHANGE, __uuidof(IMSVidAnalogTuner), E_UNEXPECTED);
            }

            hr = rsp->RegisterService(SID_SBroadcastEventService, m_pBcast);
            if (FAILED(hr)) {
                TRACELSM(TRACE_ERROR, (dbgDump << "CMSVidTVTuner::DoTune() can't get register service provider. hr = " << hexdump(hr)), "");
                return Error(IDS_CANT_NOTIFY_CHANNEL_CHANGE, __uuidof(IMSVidAnalogTuner), E_UNEXPECTED);
            }
        }
    }

    ASSERT(m_pBcast);
    m_pBcast->Fire(EVENTID_TuningChanged);
    return NOERROR;
}

HRESULT CMSVidTVTuner::put_Container(IMSVidGraphSegmentContainer *pCtl)
{
    if (!m_fInit) {
        return Error(IDS_OBJ_NO_INIT, __uuidof(IMSVidAnalogTuner), CO_E_NOTINITIALIZED);
    }
    try {
        CPerfCounter pCounterTuner;
        pCounterTuner.Reset();
        if (!pCtl) {
            return Unload();
        }
        if (m_pContainer) {
            if (!m_pContainer.IsEqualObject(VWSegmentContainer(pCtl))) {
                return Error(IDS_OBJ_ALREADY_INIT, __uuidof(IMSVidAnalogTuner), CO_E_ALREADYINITIALIZED);
            } else {
                return NO_ERROR;
            }
        }
        // DON'T addref the container.  we're guaranteed nested lifetimes
        // and an addref creates circular refcounts so we never unload.
        m_pContainer.p = pCtl;
        m_pGraph = m_pContainer.GetGraph();
        DSFilter pTuner(m_pGraph.AddMoniker(m_pDev));
        if (!pTuner) {
            return E_UNEXPECTED;
        }
        m_Filters.push_back(pTuner);
        m_iTuner = 0;
        TRACELM(TRACE_DETAIL, "CMSVidTVTuner::put_Container() tuner added");
        pCounterTuner.Stop();
        TRACELSM(TRACE_ERROR, (dbgDump << "        CVidCtl:: PutContainer TVTuner Filter: " << (unsigned long)(pCounterTuner.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterTuner.GetLastTime() % _100NS_IN_MS) << " ms"), "");
        pCounterTuner.Reset();
        if (!m_pSystemEnum) {
            m_pSystemEnum = PQCreateDevEnum(CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER);
            if (!m_pSystemEnum) {
                return E_UNEXPECTED;
            }
        }
        pCounterTuner.Stop();
        TRACELSM(TRACE_ERROR, (dbgDump << "        CVidCtl:: PutContainer TVTuner SysEnum: " << (unsigned long)(pCounterTuner.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterTuner.GetLastTime() % _100NS_IN_MS) << " ms"), "");
        pCounterTuner.Reset();
        DSDevices CaptureList(m_pSystemEnum, KSCATEGORY_CAPTURE);
        DSDevices::iterator i;
        DSFilter Capture;
        DSFilterList intermediates;
        try {
            ASSERT(m_iTuner > -1);
            for (i = CaptureList.begin(); i != CaptureList.end(); ++i) {
                CString csName;
                Capture = m_pGraph.LoadFilter(*i, csName);
                if (!Capture) {
                    continue;
                }
                TRACELSM(TRACE_DETAIL, (dbgDump << "CMSVidTVTuner::put_Container() found not video capture filter = " << csName), "");
                if (!IsVideoFilter(Capture)) {
                    continue;
                }
                TRACELSM(TRACE_DETAIL, (dbgDump << "CMSVidTVTuner::put_Container() found video capture filter = " << csName), "");
                HRESULT hr = m_pGraph.AddFilter(Capture, csName);
                if (FAILED(hr)) {
                    continue;
                }
                hr = m_pGraph.Connect(m_Filters[m_iTuner], Capture, intermediates);
                pCounterTuner.Stop();
                TRACELSM(TRACE_ERROR, (dbgDump << "        CVidCtl:: PutContainer Capture Filter: " << (unsigned long)(pCounterTuner.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterTuner.GetLastTime() % _100NS_IN_MS) << " ms"), "");
                pCounterTuner.Reset();
                if (SUCCEEDED(hr)) {
                    break;
                }
                TRACELM(TRACE_DETAIL, "CMSVidTVTuner::put_Container() removing unconnectable capture filter");
                m_pGraph.RemoveFilter(Capture);
            }
            if (i == CaptureList.end()) {
                TRACELM(TRACE_ERROR, "CMSVidTVTuner::put_Container() can't find valid capture");
                return Error(IDS_NO_CAPTURE, __uuidof(IMSVidAnalogTuner), E_NOINTERFACE);
            }
            m_Filters.insert(m_Filters.end(), intermediates.begin(), intermediates.end());
            m_iTuner = 0;
            ASSERT(m_iTuner > -1);
        } catch(ComException &e) {
            return e;
        }
        m_Filters.push_back(Capture);
        m_iCapture = m_Filters.size() - 1;
        m_iTuner = 0;
        ASSERT(m_iTuner > -1 && m_iCapture > 0 && m_iCapture != m_iTuner);
        TRACELM(TRACE_DETAIL, "CMSVidTVTuner::put_Container() tuner connected");
        pCounterTuner.Stop();
        TRACELSM(TRACE_ERROR, (dbgDump << "        CVidCtl:: PutContainer TVTuner added to list: " << (unsigned long)(pCounterTuner.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterTuner.GetLastTime() % _100NS_IN_MS) << " ms"), "");


        pCounterTuner.Reset();
        HRESULT hr = BroadcastAdvise();
        if (FAILED(hr)) {
            TRACELM(TRACE_ERROR, "CMSVidTVTuner::put_Container() can't advise for broadcast events");
            return E_UNEXPECTED;
        }
        TRACELM(TRACE_DETAIL, "CMSVidTVTuner::put_Container() registered for tuning changed events");
        pCounterTuner.Stop();
        TRACELSM(TRACE_ERROR, (dbgDump << "        CVidCtl:: PutContainer Rest : " << (unsigned long)(pCounterTuner.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterTuner.GetLastTime() % _100NS_IN_MS) << " ms"), "");

    } catch (ComException &e) {
        return e;
    } catch(...) {
        return E_UNEXPECTED;
    }
    return NOERROR;
}


HRESULT CMSVidTVTuner::Build() {
    HRESULT hr = put_SAP(VARIANT_FALSE);
    if(FAILED(hr)){
        TRACELM(TRACE_ERROR, "CVidCtl put_sap failed");
        //ASSERT(false);
    }

    PQMSVidCtl pv(m_pContainer);
    if (!pv) {
        return E_UNEXPECTED;
    }

    PQMSVidVideoRenderer pvr;
    hr = pv->get_VideoRendererActive(&pvr);
    if (FAILED(hr) || !pvr) {
        return NOERROR; // video disabled, no vr present
    }

    hr = pvr->put_SourceSize(sslClipByOverScan);
    if (FAILED(hr)) {
        return hr;
    }

    return pvr->put_OverScan(DEFAULT_OVERSCAN_PCT);
}

#endif //TUNING_MODEL_ONLY

// end of file - msvidtvtuner.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\msvidvideorenderer.cpp ===
//==========================================================================;
//
// Copyright (c) Microsoft Corporation 1999-2000.
//
//--------------------------------------------------------------------------;
//
// MSVidVideoRenderer.cpp : Implementation of CMSVidVideoRenderer
//

#include "stdafx.h"

#ifndef TUNING_MODEL_ONLY

#include "MSVidCtl.h"
#include "MSVidVideoRenderer.h"
#include "Vidctl.h"

DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidVideoRenderer, CMSVidVideoRenderer)

/////////////////////////////////////////////////////////////////////////////
// CMSVidVideoRenderer

STDMETHODIMP CMSVidVideoRenderer::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IMSVidVideoRenderer
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
STDMETHODIMP CMSVidVideoRenderer::put_SuppressEffects(/*in*/ VARIANT_BOOL bSuppressEffects){
    m_vidSuppressEffects = bSuppressEffects==VARIANT_TRUE?true:false; 
    return NOERROR;
}
STDMETHODIMP CMSVidVideoRenderer::get_SuppressEffects(/*out, retval*/ VARIANT_BOOL *bSuppressEffects){
    if(!bSuppressEffects){
        return E_POINTER;
    }
    *bSuppressEffects = m_vidSuppressEffects?VARIANT_TRUE:VARIANT_FALSE;
    return NOERROR;
}
#endif //TUNING_MODEL_ONLY

// end of file - MSVidvideorenderer.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\msvidvideorenderer.h ===
//==========================================================================;
// MSVidVideoRenderer.h : Declaration of the CMSVidVideoRenderer
// copyright (c) Microsoft Corp. 1998-1999.
//==========================================================================;

#ifndef __MSVidVIDEORENDERER_H_
#define __MSVidVIDEORENDERER_H_

#pragma once

#include <algorithm>
#include <evcode.h>
#include <uuids.h>
#include <amvideo.h>
#include <strmif.h>
#include <objectwithsiteimplsec.h>
#include "vidrect.h"
#include "vidvidimpl.h"
#include "vrsegimpl.h"
#include "devimpl.h"
#include "seg.h"
#include "videorenderercp.h"
#include "strmif.h"
#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CMSVidVideoRenderer
class ATL_NO_VTABLE __declspec(uuid("37B03543-A4C8-11d2-B634-00C04F79498E")) CMSVidVideoRenderer :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMSVidVideoRenderer, &__uuidof(CMSVidVideoRenderer)>,
    public IObjectWithSiteImplSec<CMSVidVideoRenderer>,
	public ISupportErrorInfo,
    public CProxy_IMSVidVideoRenderer<CMSVidVideoRenderer>,
	public IConnectionPointContainerImpl<CMSVidVideoRenderer>,
    public IMSVidVideoRendererImpl<CMSVidVideoRenderer, &LIBID_MSVidCtlLib, &GUID_NULL, IMSVidVideoRenderer2>,
    public IProvideClassInfo2Impl<&CLSID_MSVidVideoRenderer, &IID_IMSVidVideoRendererEvent, &LIBID_MSVidCtlLib>
{
public:
    CMSVidVideoRenderer() 
	{   
        m_APid = -1;
        m_compositorGuid = GUID_NULL;
        m_opacity = -1;
        m_rectPosition.top = -1;
        m_rectPosition.left = -1;
        m_rectPosition.bottom = -1;
        m_rectPosition.right = -1;
        m_SourceSize = sslFullSize;
        m_lOverScan = 1;
	}
    virtual ~CMSVidVideoRenderer() {
            m_PQIPicture.Release();
            CleanupVMR();
    }

REGISTER_AUTOMATION_OBJECT(IDS_PROJNAME,
						   IDS_REG_VIDEORENDERER_PROGID,
						   IDS_REG_VIDEORENDERER_DESC,
						   LIBID_MSVidCtlLib,
						   __uuidof(CMSVidVideoRenderer));

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMSVidVideoRenderer)
    COM_INTERFACE_ENTRY(IMSVidVideoRenderer)
	COM_INTERFACE_ENTRY(IMSVidVRGraphSegment)
	COM_INTERFACE_ENTRY(IMSVidGraphSegment)
    COM_INTERFACE_ENTRY(IMSVidVideoRenderer2)
    COM_INTERFACE_ENTRY(IMSVidOutputDevice)
	COM_INTERFACE_ENTRY(IMSVidDevice)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectWithSite)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IPersist)
	COM_INTERFACE_ENTRY(IProvideClassInfo2)
	COM_INTERFACE_ENTRY(IProvideClassInfo)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CMSVidVideoRenderer)
	IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
	IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
	IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
END_CATEGORY_MAP()

BEGIN_CONNECTION_POINT_MAP(CMSVidVideoRenderer)
//	CONNECTION_POINT_ENTRY(IID_IMSVidVideoRendererEvent2)    
    CONNECTION_POINT_ENTRY(IID_IMSVidVideoRendererEvent)    
END_CONNECTION_POINT_MAP()

// ISupportsErrorInfo
protected:
    DSPinList connectedPins;
public:
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
// IMSVidDevice
    CComBSTR __declspec(property(get=GetName)) m_Name;
    CComBSTR GetName(void) {
        CString csName;
        if(m_iVideoRenderer != -1){
            csName = (m_Filters[m_iVideoRenderer]).GetName();
        }
        if (csName.IsEmpty()) {
            csName = _T("Video Mixing Renderer");
        }
		csName += _T(" Segment");
        return CComBSTR(csName);
    }

	STDMETHOD(get_Name)(BSTR * Name) {
        if (!m_fInit) {
	 	    return Error(IDS_OBJ_NO_INIT, __uuidof(IMSVidVideoRenderer), CO_E_NOTINITIALIZED);
        }
		if (Name == NULL)
			return E_POINTER;
        try {
		    *Name = m_Name.Copy();	
        } catch(...) {
            return E_POINTER;
        }
		return NOERROR;
	}
	STDMETHOD(get_Status)(LONG * Status) {
        if (!m_fInit) {
	 	    return Error(IDS_OBJ_NO_INIT, __uuidof(IMSVidVideoRenderer), CO_E_NOTINITIALIZED);
        }
		if (Status == NULL)
			return E_POINTER;
			
		return E_NOTIMPL;
	}
	STDMETHOD(get_Segment)(IMSVidGraphSegment * * pIMSVidGraphSegment)
	{
        if (!m_fInit) {
	 	    return Error(IDS_OBJ_NO_INIT, __uuidof(IMSVidVideoRenderer), CO_E_NOTINITIALIZED);
        }
        try {
            if (pIMSVidGraphSegment == NULL) {
			    return E_POINTER;
            }
            *pIMSVidGraphSegment = reinterpret_cast<IMSVidGraphSegment*>(this);
            AddRef();
            return NOERROR;
        } catch(...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_SuppressEffects)(/*in*/ VARIANT_BOOL bSuppress);
    STDMETHOD(get_SuppressEffects)(/*out, retval*/ VARIANT_BOOL *bSuppress);
// Methods to access the allocator presenter object in the vmr
    STDMETHOD(SetAllocator)(/*[in]*/ IUnknown *Allocator, long ID = -1){
        try{
            if(!Allocator){
                return _SetAllocator(NULL, ID);
            }
            PQVMRSAlloc qiAllocator(Allocator);
            if(!qiAllocator){
                _ASSERT(false);
                return E_UNEXPECTED;
            }

            return _SetAllocator(qiAllocator, ID);
            
        }
        catch(...){
            _ASSERT(false);
            return E_UNEXPECTED;
        }
    }
    STDMETHOD(_SetAllocator)(/*[in]*/ IVMRSurfaceAllocator *Allocator, long ID = -1){
        try{
            PQVMRSAlloc qiAllocator(Allocator);

            HRESULT hr = CleanupVMR();
            if(FAILED(hr)){
                return hr;
            }

            qiSurfAlloc = qiAllocator;
            m_APid = ID;
            return S_OK;
        }
        catch(...){
            _ASSERT(false);
            return E_UNEXPECTED;
        }
    }

    STDMETHOD(get_Allocator)(/*[in]*/ IUnknown **Allocator){
        try{
            if(!Allocator){
                return E_POINTER;
            }
            if(!qiSurfAlloc){
                return E_FAIL;
            }
			PUnknown retVal(qiSurfAlloc);
            if(!retVal){
                _ASSERT(false);
                return E_UNEXPECTED;
            }
            *Allocator = retVal.Detach();
            _ASSERT(Allocator);
            return S_OK;
        }
        catch(...){
            _ASSERT(false);
            return E_UNEXPECTED;
        }
    }
    STDMETHOD(get__Allocator)(/*[in]*/ IVMRSurfaceAllocator **Allocator){
        try{
            if(!Allocator){
                return E_POINTER;
            }
            if(!qiSurfAlloc){
                return E_FAIL; // should be un-inited failure
            }
            PQVMRSAlloc qiAllocator(qiSurfAlloc);
            if(!qiAllocator){
                _ASSERT(false);
                return E_UNEXPECTED;
            }
            *Allocator = qiAllocator.Detach();
            _ASSERT(Allocator);
            return S_OK;
        }
        catch(...){
            _ASSERT(false);
            return E_UNEXPECTED;
        }
    }
    STDMETHOD(get_Allocator_ID)(long *ID){
        try{
            if(!ID){
                return E_POINTER;
            }
            *ID = m_APid;
            return S_OK;
        }
        catch(...){
            _ASSERT(false);
            return E_UNEXPECTED;
        }
    }
    STDMETHOD(OnEventNotify)(LONG lEventCode, LONG_PTR lEventParm1, LONG_PTR lEventParm2){
        if (lEventCode == EC_VMR_RENDERDEVICE_SET) {
            VARIANT_BOOL fUsingOverlay;
            get_UsingOverlay(&fUsingOverlay);
            if (fUsingOverlay == VARIANT_TRUE && !(lEventParm1 & VMR_RENDER_DEVICE_OVERLAY)) {
                put_UsingOverlay(VARIANT_FALSE);
                Fire_OverlayUnavailable();
                ReComputeSourceRect();
		return NOERROR;
            }
        }
        if (lEventCode == EC_VMR_RENDERDEVICE_SET || 
            lEventCode == EC_VIDEO_SIZE_CHANGED) {
                ReComputeSourceRect();
        }
        return E_NOTIMPL;
    }
    STDMETHOD(PostStop)(){
        TRACELSM(TRACE_ERROR, (dbgDump << "MSVidVideoRenderer2::PostStop()"), "");
        HRESULT hr = IMSVidVideoRendererImpl<CMSVidVideoRenderer, &LIBID_MSVidCtlLib, &GUID_NULL, IMSVidVideoRenderer2>::PostStop();
        if(FAILED(hr)){
            TRACELSM(TRACE_ERROR, (dbgDump << "MSVidVideoRenderer2::PostStop() base class PostStop failed; hr = " << std::hex << hr), "");
            return hr;
        }
        // need stestrops fix for deallocate on stop
        DSFilter sp_VMR = m_Filters[m_iVideoRenderer];
        if(!sp_VMR){
            TRACELSM(TRACE_ERROR, (dbgDump << "MSVidVideoRenderer2::PostStop() could not get vmr filter"), "");
            return E_UNEXPECTED;
        }

        int i = 0;
        for(DSFilter::iterator pin = sp_VMR.begin(); pin != sp_VMR.end(); ++pin, ++i){
            if( (*pin).IsConnected()){
                hr = (*pin).Disconnect();
                if(FAILED(hr)){
                    TRACELSM(TRACE_ERROR, (dbgDump << "MSVidVideoRenderer2::PostStop() disconnect failed; hr = " << std::hex << hr), "");
                    return hr;
                }
            }
        }
#ifdef _WIN64
        TRACELSM(TRACE_ERROR, (dbgDump << "MSVidVideoRenderer2::PostStop() NumPins: " << (long)connectedPins.size() << " pins."), "");
#endif
        return S_OK;
    }

    STDMETHOD(PreRun)(){
        HRESULT hr = IMSVidVideoRendererImpl<CMSVidVideoRenderer, &LIBID_MSVidCtlLib, &GUID_NULL, IMSVidVideoRenderer2>::PreRun();
        if(FAILED(hr)){
            TRACELSM(TRACE_ERROR, (dbgDump << "MSVidVideoRenderer2::PreRun() base class PostStop failed; hr = " << std::hex << hr), "");
            return hr;
        }
        // need stestrops fix for deallocate on stop
        DSFilter sp_VMR = m_Filters[m_iVideoRenderer];
        if(!sp_VMR){
            TRACELSM(TRACE_ERROR, (dbgDump << "MSVidVideoRenderer2::PostStop() could not get vmr filter"), "");
            return E_UNEXPECTED;
        }
        
        if(connectedPins.size() == 0){ // if the pin list is empty rebuild it otherwise reconnect the pins
            int i = 0;
            for(DSFilter::iterator pin = sp_VMR.begin(); pin != sp_VMR.end(); ++pin, ++i){
                if( (*pin).IsConnected()){
                    connectedPins.push_back((*pin).GetConnection());
                }
            }
#ifndef _WIN64
            TRACELSM(TRACE_ERROR, (dbgDump << "MSVidVideoRenderer2::PostStop() Storing: " << connectedPins.size() << " pins."), "");
#endif
        }
        else{
            DSFilter::iterator vmrPin = sp_VMR.begin();
            for(DSPinList::iterator pin = connectedPins.begin(); pin != connectedPins.end() && vmrPin != sp_VMR.end(); ++pin, ++vmrPin){
                if(!(*vmrPin).IsConnected()){
                    hr = (*vmrPin).Connect(*pin);
                    if(FAILED(hr)){
                        TRACELSM(TRACE_ERROR, (dbgDump << "MSVidVideoRenderer2::PreRun() connect failed; hr = " << std::hex << hr), "");
                        return hr;
                    }
                }
                else{
                    _ASSERT((*vmrPin).GetConnection() != (*pin));
                }
            }
        }

        return S_OK;
    }
    STDMETHOD(Decompose)(){
        TRACELSM(TRACE_ERROR, (dbgDump << "MSVidVideoRenderer2::Decompose() killing pin list"), "");
        connectedPins.clear();
        HRESULT hr = IMSVidVideoRendererImpl<CMSVidVideoRenderer, &LIBID_MSVidCtlLib, &GUID_NULL, IMSVidVideoRenderer2>::Decompose();
        if(FAILED(hr) && hr != E_NOTIMPL){
            TRACELSM(TRACE_ERROR, (dbgDump << "MSVidVideoRenderer2::PreRun() base class Decompose failed; hr = " << std::hex << hr), "");
            return hr;
        }

        return S_OK;

    }
#if 0
    STDMETHOD(get__CustomCompositorClass)(/*[out, retval]*/ GUID* CompositorCLSID) {
        return IMSVidVideoRendererImpl<CMSVidVideoRenderer, &LIBID_MSVidCtlLib, &GUID_NULL, IMSVidVideoRenderer2>::get__CustomCompositorClass(CompositorCLSID);
    }
#endif
};
#endif //__MSVidVIDEORENDERER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\msvidwebdvd.h ===
//===========================================================================
//
// MSVidWebDVD.h: Definition of the CMSVidWebDVD class
// Copyright (c) Microsoft Corporation 1999-2000.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_MSVIDWEBDVD_H__6CF9F624_1F3C_44FA_8F00_FCC31B2976D6__INCLUDED_)
#define AFX_MSVIDWEBDVD_H__6CF9F624_1F3C_44FA_8F00_FCC31B2976D6__INCLUDED_

#pragma once

#include <dvdevcod.h>
#include <algorithm>
#include <objectwithsiteimplsec.h>
#include "pbsegimpl.h"
#include "webdvdimpl.h"
#include "seg.h"
#include "resource.h"       // main symbols
#include "mslcid.h"
#include "MSVidWebDVDCP.h"
#include "vidrect.h"
#include <strmif.h>
#include <math.h>
#define DVD_ERROR_NoSubpictureStream   99
#define EC_DVD_PLAYING                 (EC_DVDBASE + 0xFE)
#define EC_DVD_PAUSED                  (EC_DVDBASE + 0xFF)
#define E_NO_IDVD2_PRESENT MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xFF0)
#define E_NO_DVD_VOLUME MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xFF1)
#define E_REGION_CHANGE_FAIL MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xFF2)
#define E_REGION_CHANGE_NOT_COMPLETED MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xFF3)

typedef CComQIPtr<IDvdControl2, &IID_IDvdControl2> PQDVDControl2;
typedef CComQIPtr<IDvdInfo2, &IID_IDvdInfo2> PQDVDInfo2;
typedef CComQIPtr<IMSVidWebDVD, &IID_IMSVidWebDVD> PQWebDVD;

// the following enum and struct are for DVD url parsing.
typedef enum 
{
    DVD_Playback_Default,
    DVD_Playback_Title,
    DVD_Playback_Chapter,
    DVD_Playback_Chapter_Range,
    DVD_Playback_Time,
    DVD_Playback_Time_Range
} DVDPlaybackRef;

class DVDUrlInfo{
public:
    DVDPlaybackRef enumRef;
    CComBSTR bstrPath;
    long lTitle;
    long lChapter;
    long lEndChapter;
    ULONG ulTime;
    ULONG ulEndTime; 
    DVDUrlInfo(){
        bstrPath;
        lTitle = 0;
        lChapter = 0;
        lEndChapter = 0;
        ulTime = 0;
        ulEndTime = 0; 
    }
    virtual ~DVDUrlInfo(){
    }
};
////////////////////////////////////////////////////////////////////////////////////
/*************************************************************************/
/* Local Defines to sort of abstract the implementation and make the     */
/* changes bit more convinient.                                          */
/*************************************************************************/
#define INITIALIZE_GRAPH_IF_NEEDS_TO_BE     \
        {}

#define INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY   \
        {}

#define RETRY_IF_IN_FPDOM(func)              \
        {func;}

/////////////////////////////////////////////////////////////////////////////
// CMSVidWebDVD

class ATL_NO_VTABLE __declspec(uuid("011B3619-FE63-4814-8A84-15A194CE9CE3")) CMSVidWebDVD : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IMSVidPBGraphSegmentImpl<CMSVidWebDVD, MSVidSEG_SOURCE, &GUID_NULL>,
	public IMSVidGraphSegmentUserInput,
    public IObjectWithSiteImplSec<CMSVidWebDVD>,
	public CComCoClass<CMSVidWebDVD, &__uuidof(CMSVidWebDVD)>,
	public ISupportErrorInfo,
    public IMSVidWebDVDImpl<CMSVidWebDVD, &LIBID_MSVidCtlLib, &GUID_NULL, IMSVidWebDVD>,
    public CProxy_WebDVDEvent< CMSVidWebDVD >,
    public IConnectionPointContainerImpl<CMSVidWebDVD>,
    public IObjectSafetyImpl<CMSVidWebDVD, INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA>,
    public IProvideClassInfo2Impl<&CLSID_MSVidWebDVD, &IID_IMSVidWebDVDEvent, &LIBID_MSVidCtlLib>
{
public:
	CMSVidWebDVD() : 
        m_iDVDNav(-1), 
        m_fUrlInfoSet(false), 
        m_fResetSpeed(false), 
        m_fStillOn(false),
        m_fFireNoSubpictureStream(false),
        m_fStepComplete(false),
        m_bEjected(false),
        m_DVDFilterState(dvdState_Undefined),
        m_lKaraokeAudioPresentationMode(-1),
        m_usButton(-1),
        m_Rate(1),
        m_Mode(TenthsSecondsMode)
    {
        m_fEnableResetOnStop = false;
    }

REGISTER_AUTOMATION_OBJECT(IDS_PROJNAME, 
						   IDS_REG_MSVIDWEBDVD_PROGID, 
						   IDS_REG_MSVIDWEBDVD_DESC,
						   LIBID_MSVidCtlLib,
						   __uuidof(CMSVidWebDVD));

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMSVidWebDVD)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IMSVidWebDVD)
    COM_INTERFACE_ENTRY(IObjectWithSite)
	COM_INTERFACE_ENTRY(IMSVidGraphSegment)
	COM_INTERFACE_ENTRY(IMSVidGraphSegmentUserInput)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IMSVidPlayback)
	COM_INTERFACE_ENTRY(IMSVidInputDevice)
	COM_INTERFACE_ENTRY(IMSVidDevice)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
	COM_INTERFACE_ENTRY(IProvideClassInfo2)    
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)    
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(IPersist)
    COM_INTERFACE_ENTRY(IObjectSafety)
END_COM_MAP()


BEGIN_CONNECTION_POINT_MAP(CMSVidWebDVD)
	CONNECTION_POINT_ENTRY(IID_IMSVidWebDVDEvent)    
END_CONNECTION_POINT_MAP()


// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IMSVidWebDVD
public:
    int m_iDVDNav;

    // QI for IDVDControl2 from DVDNavigator
#if 0
    PQDVDControl2 GetDVDControl2() {
        if (m_iDVDNav < 0) {
            return PQDVDControl2();
        }
        return PQDVDControl2(m_Filters[m_iDVDNav]);
    }
#endif

    // QI for IDVDInfo2 from DVDNavigator
    PQDVDInfo2 GetDVDInfo2() {
        if (m_iDVDNav < 0) {
            return PQDVDInfo2();
        }
        return PQDVDInfo2(m_Filters[m_iDVDNav]);
    }

    CComBSTR __declspec(property(get=GetName)) m_Name;
    CComBSTR GetName(void) {
        CString csName = _T("DVD Playback");
        return CComBSTR(csName);
    }
    HRESULT Unload(void) {
		m_pDVDControl2.Release();
        HRESULT hr = IMSVidGraphSegmentImpl<CMSVidWebDVD, MSVidSEG_SOURCE, &GUID_NULL>::Unload();
        return hr;
	}

    virtual ~CMSVidWebDVD() {
        CleanUp();
    }

// IMSVidGraphSegment
	STDMETHOD(put_Init)(IUnknown *pInit);

    STDMETHOD(Build)() {
        return NOERROR;
    }
    STDMETHOD(put_Rate)(double lRate){
        HRESULT hr = S_OK;
        CComQIPtr<IDvdCmd>IDCmd;
        double newRate = lRate;
        try{
            /*** Checking args and init'ing interfaces ***/
            if(!m_pDVDControl2){
                hr = Error(IDS_INVALID_STATE, __uuidof(IMSVidWebDVD), CO_E_NOTINITIALIZED);
            }
            // Change rate
            if(lRate > 0){
                // hr set in Retry macro
                long pauseCookie = 0;
                HRESULT hres = RunIfPause(&pauseCookie);
                if(FAILED(hres)){
                    return hres; 
                }

                hr = m_pDVDControl2->PlayForwards(lRate, DVD_CMD_FLAG_Flush, reinterpret_cast<IDvdCmd**>(&IDCmd));
                if(IDCmd){
                    IDCmd->WaitForEnd();
                }

                hres = PauseIfRan(pauseCookie);
                if(FAILED(hres)){
                    return hres;
                }

            }
            else if(lRate < 0){
                lRate = -lRate;
                // hr set in Retry macro

                long pauseCookie = 0;
                HRESULT hres = RunIfPause(&pauseCookie);
                if(FAILED(hres)){
                    return hres; 
                }

                hr = m_pDVDControl2->PlayBackwards(lRate, DVD_CMD_FLAG_Flush, reinterpret_cast<IDvdCmd**>(&IDCmd));
                if(IDCmd){
                    IDCmd->WaitForEnd();
                }

                hres = PauseIfRan(pauseCookie);
                if(FAILED(hres)){
                    return hres;
                }
            }
            else{
                hr = E_INVALIDARG;
            }        
        }
        catch(HRESULT hrTmp){
            // Something went bad, threw a HRESULT				
            hr = Error(IDS_INVALID_STATE, __uuidof(IMSVidWebDVD), hrTmp);
        }
        catch(...){
            // Something went bad, dont know what it threw
            hr =  E_UNEXPECTED;
        }
        // Only set rate if it succeeds
        if(SUCCEEDED(hr)){
            m_Rate = newRate;
        }
        return hr;
    }
    STDMETHOD(get_Rate)(double* lRate){
        HRESULT hr;
        try{
            if(!lRate){
                return E_POINTER;
            }
            *lRate = m_Rate;
            return S_OK;
        }
        
        catch(HRESULT hrTmp){
            // Something went bad, threw a HRESULT				
            hr = Error(IDS_INVALID_STATE, __uuidof(IMSVidWebDVD), hrTmp);
        }
        catch(...){
            // Something went bad, dont know what it threw
            hr =  E_UNEXPECTED;
        }
        return hr;
    }
    STDMETHOD(put_EnableResetOnStop)(/*in*/VARIANT_BOOL newVal){
        
        HRESULT hr = S_OK;
        
        try {
            
            bool fEnable = (VARIANT_FALSE == newVal) ? false: true;
            bool fEnableOld = m_fEnableResetOnStop;
            
            m_fEnableResetOnStop = fEnable;
            
            if(!m_pDVDControl2){
                
                throw(S_FALSE); // we might not have initialized graph as of yet, but will
                // defer this to play state
            }/* end of if statement */
            
            hr = m_pDVDControl2->SetOption(DVD_ResetOnStop, fEnable);
            
            if(FAILED(hr)){
                
                m_fEnableResetOnStop = fEnableOld; // restore the old state
            }/* end of if statement */
            
        }/* end of try statement */
        catch(HRESULT hrTmp){
            
            hr = hrTmp;
        }
        catch(...){
            
            hr = E_UNEXPECTED;
        }/* end of catch statement */
        
        return HandleError(hr);
    }/* end of function put_EnableResetOnStop */
//-----------------------------------------------------------------------------------------
// Name: DVD_HMSF_TIMECODE convertDVDSeconds(double)
// Description: Converts a seconds to a dvd timecode 
//-----------------------------------------------------------------------------------------
    DVD_HMSF_TIMECODE convertDVDSeconds(double Seconds, ULONG ulFlags, LONG mode){
        HRESULT hr = S_OK;
        DVD_HMSF_TIMECODE dvdTCode = {0,0,0,0};
        double fps;
        if(ulFlags == DVD_TC_FLAG_25fps){
            fps = 25;
        }
        else if(ulFlags == DVD_TC_FLAG_30fps){
            fps = 30;
        }
        else if(ulFlags == DVD_TC_FLAG_DropFrame){
            fps = 29.97;
        }
        else if(ulFlags == DVD_TC_FLAG_Interpolated){
            fps = 30; // is this right???
        }
        else{
            return dvdTCode;
        }
        if(mode == FrameMode){
            Seconds = Seconds / fps;
        }
        // If it is TenthsSecondsMode need to be converted from 100 nanosecond units
        else if(mode == TenthsSecondsMode){
            Seconds = Seconds / 100;
        }
        // If it is some other mode not supported by the vidctl
        else{
            return dvdTCode;
        }
        dvdTCode.bHours = (BYTE)(floor(Seconds/3600)); // Number of hours
        Seconds = Seconds - 3600 * dvdTCode.bHours;
        dvdTCode.bMinutes = (BYTE)(floor(Seconds/60));
        Seconds = Seconds - 60 *dvdTCode.bMinutes;
        dvdTCode.bSeconds = (BYTE)(floor(Seconds));
        Seconds = Seconds - dvdTCode.bSeconds;
        dvdTCode.bFrames = (BYTE)(floor(Seconds * fps));
        return dvdTCode;
    }
    //-----------------------------------------------------------------------------------------
    // Name: double convertDVDTimeCode(DVD_HMSF_TIMECODE, ULONG)
    // Description: Converts a dvd timecode with dvd flags into seconds and returns as a double 
    //-----------------------------------------------------------------------------------------
    double convertDVDTimeCode(DVD_HMSF_TIMECODE dvdTime, ULONG ulFlags, long mode ){
        double fps;
        if(ulFlags == DVD_TC_FLAG_25fps){
            fps = 25;
        } else if(ulFlags == DVD_TC_FLAG_30fps){
            fps = 30;
        } else if(ulFlags == DVD_TC_FLAG_DropFrame){
            fps = 29.97;
        } else if(ulFlags == DVD_TC_FLAG_Interpolated){
            fps = 30; // is this right???
        } else{
            return 0;
        }
        
        double time_temp = static_cast<double>( (3600*dvdTime.bHours) + (60*dvdTime.bMinutes) +
            dvdTime.bSeconds + (dvdTime.bFrames/fps) );
        if(mode == FrameMode){
            time_temp = time_temp * fps;
            return time_temp;
        } else if(mode == TenthsSecondsMode){
            // If it is TenthsSecondsMode need to be converted from 100 nanosecond units
            time_temp = time_temp * 100;
            return time_temp;
        }
        // If it is some other mode not supported by the vidctl
        return 0;
    }
    //-----------------------------------------------------------------------------------------
    // Name: get_Length(LONGLONG*)
    //-----------------------------------------------------------------------------------------
    STDMETHOD(get_Length)(/*[out, retval]*/long *lLength){
        HRESULT hr = S_OK;
        try{
            /*** Checking args and init'ing interfaces ***/
            if(!lLength){
				return E_POINTER;
			}
			PQDVDInfo2 pqDInfo2 = GetDVDInfo2();
            if(!pqDInfo2){
                hr = Error(IDS_INVALID_STATE, __uuidof(IMSVidWebDVD), CO_E_NOTINITIALIZED);
            }
            // Get length
            DVD_HMSF_TIMECODE TotalTime;
            ULONG ulFlags;
            double seconds;
            hr = pqDInfo2->GetTotalTitleTime(&TotalTime, &ulFlags);
            if(FAILED(hr)){
                return hr;
            }
            // Get the length in seconds
            seconds = convertDVDTimeCode(TotalTime, ulFlags, m_Mode);
            if(seconds == 0){
                return E_UNEXPECTED;
            }
            *lLength = static_cast<long>(seconds);
            return S_OK;
        }
        
        catch(HRESULT hrTmp){
            // Something went bad, threw a HRESULT				
            hr = Error(IDS_INVALID_STATE, __uuidof(IMSVidWebDVD), hrTmp);
        }
        catch(...){
            // Something went bad, dont know what it threw
            hr =  E_UNEXPECTED;
        }
        return hr;
    }
    
    //-----------------------------------------------------------------------------------------
    // Name: get_CurrentPosition(LONGLONG*)
    //-----------------------------------------------------------------------------------------
    STDMETHOD(get_CurrentPosition)(/*[out,retval]*/long *lPosition) {
        HRESULT hr = S_OK;
        try{
            /*** Checking args and init'ing interfaces ***/
            PQDVDInfo2 pqDInfo2 = GetDVDInfo2();
            if(!pqDInfo2){
                hr = Error(IDS_INVALID_STATE, __uuidof(IMSVidWebDVD), CO_E_NOTINITIALIZED);
            }
            // Get length
            DVD_PLAYBACK_LOCATION2 dvdLocation;
            double seconds;
            hr = pqDInfo2->GetCurrentLocation(&dvdLocation);
            if(FAILED(hr)){
                return hr;
            }
            // Get the length in seconds
            seconds = convertDVDTimeCode(dvdLocation.TimeCode, dvdLocation.TimeCodeFlags, m_Mode);
            if(seconds == 0){
                
                return E_UNEXPECTED;
            }

            *lPosition = static_cast<long>(seconds);
            return S_OK;
        }
        
        catch(HRESULT hrTmp){
            // Something went bad, threw a HRESULT				
            hr = Error(IDS_INVALID_STATE, __uuidof(IMSVidWebDVD), hrTmp);
        }
        catch(...){
            // Something went bad, dont know what it threw
            hr =  E_UNEXPECTED;
        }
        return hr;
    }
//-----------------------------------------------------------------------------------------
// Name: put_CurrentPosition(LONGLONG)
//-----------------------------------------------------------------------------------------
    STDMETHOD(put_CurrentPosition)(/*[in]*/long lPosition) {
        HRESULT hr = S_OK;
        CComQIPtr<IDvdCmd>IDCmd;
        try{
            /*** Checking args and init'ing interfaces ***/
            PQDVDInfo2 pqDInfo2 = GetDVDInfo2();
            if(!pqDInfo2 || !m_pDVDControl2){
                hr = Error(IDS_INVALID_STATE, __uuidof(IMSVidWebDVD), CO_E_NOTINITIALIZED);
            }
            // Get length
            DVD_PLAYBACK_LOCATION2 dvdLocation;
            hr = pqDInfo2->GetCurrentLocation(&dvdLocation);
            if(FAILED(hr)){
                return hr;
            }
            DVD_HMSF_TIMECODE dvdTCode;
            // Convert the length in seconds to dvd timecode
            dvdTCode = convertDVDSeconds(lPosition, dvdLocation.TimeCodeFlags, m_Mode);
            // set the dvd to play at time in the dvd
            // hr set in retry macro
            long pauseCookie = 0;
            HRESULT hres = RunIfPause(&pauseCookie);
            if(FAILED(hres)){
                return hres; 
            }

            hr = m_pDVDControl2->PlayAtTime(&dvdTCode, dvdLocation.TimeCodeFlags, reinterpret_cast<IDvdCmd**>(&IDCmd));
			if(IDCmd){
				IDCmd->WaitForEnd();
			}

            hres = PauseIfRan(pauseCookie);
            if(FAILED(hres)){
                return hres;
            }

            return hr;
        }
        
        catch(HRESULT hrTmp){
            // Something went bad, threw a HRESULT				
            hr = Error(IDS_INVALID_STATE, __uuidof(IMSVidWebDVD), hrTmp);
        }
        catch(...){
            // Something went bad, dont know what it threw
            hr =  E_UNEXPECTED;
        }

        return hr;
    }
    //-----------------------------------------------------------------------------------------
    // Name: put_PositionMode(LONGLONG)
    //-----------------------------------------------------------------------------------------
    
    STDMETHOD(put_PositionMode)(/*[in]*/PositionModeList lPositionMode) {
        HRESULT hr = S_OK;
        try{
            if(lPositionMode == FrameMode){
                m_Mode = FrameMode;
                return S_OK;
            }
            else if(lPositionMode == TenthsSecondsMode){
                m_Mode = TenthsSecondsMode;
                return S_OK;
            }
            // If it is some other mode not supported by the vidctl
            else{
                return E_UNEXPECTED;
            }           
        }        
        catch(HRESULT hrTmp){
            // Something went bad, threw a HRESULT				
            return hrTmp;
        }
        catch(...){
            // Something went bad, dont know what it threw
            return E_UNEXPECTED;
        }
    }


    //-----------------------------------------------------------------------------------------
    // Name: get_PositionMode(LONGLONG*)
    //-----------------------------------------------------------------------------------------
    STDMETHOD(get_PositionMode)(/*[out,retval]*/PositionModeList* lPositionMode) {
        HRESULT hr = S_OK;
        try{
            // Checking args and interfaces
            if(!lPositionMode){
                return E_POINTER;
            }
            *lPositionMode = m_Mode; 
            return hr;        
        }
        
        catch(HRESULT hrTmp){
            // Something went bad, threw a HRESULT				
            return hrTmp;
        }
        catch(...){
            // Something went bad, dont know what it threw
            return E_UNEXPECTED;
        }
    }
    //-----------------------------------------------------------------------------------------
    STDMETHOD(put_Container)(IMSVidGraphSegmentContainer *pCtl)
        {
            if (!m_fInit) {
                return Error(IDS_OBJ_NO_INIT, __uuidof(IMSVidWebDVD), CO_E_NOTINITIALIZED);
        }
        try {
            if (!pCtl) {
                return Unload();
            }
            if (m_pContainer) {
				if (!m_pContainer.IsEqualObject(VWSegmentContainer(pCtl))) {
					return Error(IDS_OBJ_ALREADY_INIT, __uuidof(IMSVidWebDVD), CO_E_ALREADYINITIALIZED);
				} else {
					return NO_ERROR;
				}
            }
			
            HRESULT hr = NO_ERROR;
            DSFilter pfr(CLSID_DVDNavigator);
            if (!pfr) {
                ASSERT(false);
		        return Error(IDS_CANT_CREATE_FILTER, __uuidof(IMSVidWebDVD), hr);
            }
            if (m_pContainer) {
                bool rc = m_pGraph.RemoveFilter(*m_Filters.begin());
                if (!rc) {
                    TRACELM(TRACE_ERROR,  "IMSVidWebDVD::Load() can't remove filter");
			        return Error(IDS_CANT_REMOVE_FILTER, __uuidof(IMSVidWebDVD), E_UNEXPECTED);
                }
            }
            m_Filters.clear();
            m_Filters.push_back(pfr);
            m_iDVDNav = m_Filters.size() - 1;
			m_pDVDControl2 = pfr;

            // DON'T addref the container.  we're guaranteed nested lifetimes
            // and an addref creates circular refcounts so we never unload.
            m_pContainer.p = pCtl;
            m_pGraph = m_pContainer.GetGraph();
            USES_CONVERSION;
            CString csName(_T("DVD Navigator"));
            hr = m_pGraph->AddFilter(m_Filters[m_iDVDNav], T2COLE(csName));
            if (FAILED(hr)) {
                TRACELSM(TRACE_ERROR,  (dbgDump << "IMSVidWebDVD::Load() hr = " << std::hex << hr), "");
                return Error(IDS_CANT_ADD_FILTER, __uuidof(IMSVidWebDVD), hr);
            }

        } catch (ComException &e) {
            return e;
        } catch(...) {
            return E_UNEXPECTED;
        }
		return NOERROR;
	}
// IMSVidGraphSegmentInputs
	STDMETHOD(Click)()
	{
        return E_NOTIMPL;
	}
	STDMETHOD(DblClick)()
	{
        return E_NOTIMPL;
	}
	STDMETHOD(KeyDown)(short* KeyCode, short Shift){
		return E_NOTIMPL; 
	}
	STDMETHOD(KeyPress)(short* KeyAscii){ 
		return E_NOTIMPL; 
	}
	STDMETHOD(KeyUp)(short* KeyCode, short Shift){ 
        HRESULT hr;
        switch (*KeyCode) {
        case VK_UP:
            hr = m_pDVDControl2->SelectRelativeButton(DVD_Relative_Upper);
            if (FAILED(hr)) {
                TRACELSM(TRACE_DETAIL, (dbgDump << "CVidMSWebDVD::KeyUp() select up failed hr = " << hexdump(hr)), "");
                return hr;
            } else {
                return S_FALSE;
            }
            break;
        case VK_DOWN:
            hr = m_pDVDControl2->SelectRelativeButton(DVD_Relative_Lower);
            if (FAILED(hr)) {
                TRACELSM(TRACE_DETAIL, (dbgDump << "CVidMSWebDVD::KeyUp() select down failed hr = " << hexdump(hr)), "");
                return hr;
            } else {
                return S_FALSE;
            }
            break;
        case VK_LEFT:
            hr = m_pDVDControl2->SelectRelativeButton(DVD_Relative_Left);
            if (FAILED(hr)) {
                TRACELSM(TRACE_DETAIL, (dbgDump << "CVidMSWebDVD::KeyUp() select left failed hr = " << hexdump(hr)), "");
                return hr;
            } else {
                return S_FALSE;
            }
            break;
        case VK_RIGHT:
            hr = m_pDVDControl2->SelectRelativeButton(DVD_Relative_Right);
            if (FAILED(hr)) {
                TRACELSM(TRACE_DETAIL, (dbgDump << "CVidMSWebDVD::KeyUp() select right failed hr = " << hexdump(hr)), "");
                return hr;
            } else {
                return S_FALSE;
            }
            break;
        case VK_SPACE:
        case VK_RETURN:
            hr = m_pDVDControl2->ActivateButton();
            if (FAILED(hr)) {
                TRACELSM(TRACE_DETAIL, (dbgDump << "CVidMSWebDVD::KeyUp() activate failed hr = " << hexdump(hr)), "");
                return hr;
            } else {
                return S_FALSE;
            }
            break;

        }
		return E_NOTIMPL; 
	}
	STDMETHOD(MouseDown)(short Button, short Shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y){
		if ((m_DVDFilterState & dvdState_Running) && m_pDVDControl2) {
			if (((m_usButton ^ Button) & MSVIDCTL_LEFT_BUTTON)) {
				CPoint pt(x, y);
				HRESULT hr = m_pDVDControl2->SelectAtPosition(pt);
                if (FAILED(hr)) {
                    TRACELSM(TRACE_DETAIL, (dbgDump << "CVidMSWebDVD::MouseDown() select failed hr = " << hexdump(hr)), "");
                    return hr;
                } else {
                    return S_FALSE;
                }
			}
			m_usButton = Button;
		}
		return NOERROR;
	}
	STDMETHOD(MouseMove)(short Button, short Shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y){ 
		if ((m_DVDFilterState & dvdState_Running) && m_pDVDControl2) {
			if (Button & MSVIDCTL_LEFT_BUTTON) {
				CPoint pt(x, y);
				HRESULT hr = m_pDVDControl2->SelectAtPosition(pt);
                if (FAILED(hr)) {
                    TRACELSM(TRACE_DETAIL, (dbgDump << "CVidMSWebDVD::MouseMove() select failed hr = " << hexdump(hr)), "");
                    return hr;
                } else {
                    return S_FALSE;
                }
			}
			m_usButton = Button;
		}
		return NOERROR;
	}
	STDMETHOD(MouseUp)(short Button, short Shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y){ 
		if ((m_DVDFilterState & dvdState_Running) && m_pDVDControl2) {
			if (((m_usButton ^ Button) & MSVIDCTL_LEFT_BUTTON)) {
				CPoint pt(x, y);
				HRESULT hr = m_pDVDControl2->ActivateAtPosition(pt);
                if (FAILED(hr)) {
                    TRACELSM(TRACE_DETAIL, (dbgDump << "CVidMSWebDVD::MouseUp() activate failed hr = " << hexdump(hr)), "");
                    return hr;
                } else {
                    return S_FALSE;
                }
			}
		}
		return NOERROR;
	}


// IMSVidDevice
	STDMETHOD(get_Name)(BSTR * Name)
	{
        if (!m_fInit) {
	 	    return Error(IDS_OBJ_NO_INIT, __uuidof(IMSVidFilePlayback), CO_E_NOTINITIALIZED);
        }
		if (Name == NULL)
			return E_POINTER;
        try {
		    *Name = m_Name.Copy();	
        } catch(...) {
            return E_POINTER;
        }
		return NOERROR;
	}

// IMSVidInputDevice
	STDMETHOD(IsViewable)(VARIANT* pv, VARIANT_BOOL *pfViewable)
	{
        HRESULT hr = View(pv);

        if (SUCCEEDED(hr))
        {
            *pfViewable = VARIANT_TRUE;
        }

        return hr;
	}

	STDMETHOD(View)(VARIANT* pv) {
        if (!m_fInit) {
	 	    return Error(IDS_OBJ_NO_INIT, __uuidof(IMSVidWebDVD), CO_E_NOTINITIALIZED);
        }
		if (!pv) {
			return E_POINTER;
		}
        if (pv->vt != VT_BSTR) {
			return E_INVALIDARG;
        }
        if (m_pGraph && !m_pGraph.IsStopped()) {
	        return Error(IDS_INVALID_STATE, __uuidof(IMSVidWebDVD), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
        }

        // retrieve the DVD playback info from URL
        // save the info

        DeleteUrlInfo();
        
        HRESULT hr = ParseDVDPath(pv->bstrVal);

        if (SUCCEEDED(hr))
        {
            m_fUrlInfoSet = true;
        }

        return hr;
    }

    STDMETHOD(OnEventNotify)(long lEvent, LONG_PTR lParam1, LONG_PTR lParam2);
    STDMETHOD(OnDVDEvent)(long lEvent, LONG_PTR lParam1, LONG_PTR lParam2);
    STDMETHOD(PreRun)();
    STDMETHOD(PostRun)();
    STDMETHOD(PreStop)();
    STDMETHOD(PostStop)();
    STDMETHOD(PlayTitle)(long lTitle);
    STDMETHOD(PlayChapterInTitle)(long lTitle, long lChapter);
    STDMETHOD(PlayChapter)(long lChapter);
    STDMETHOD(PlayChaptersAutoStop)(long lTitle, long lstrChapter, long lChapterCount);
    STDMETHOD(PlayAtTime)(BSTR strTime);
    STDMETHOD(PlayAtTimeInTitle)(long lTitle, BSTR strTime);
    STDMETHOD(PlayPeriodInTitleAutoStop)(long lTitle, BSTR strStartTime, BSTR strEndTime);
    STDMETHOD(ReplayChapter)();
    STDMETHOD(PlayPrevChapter)();
    STDMETHOD(PlayNextChapter)();
    STDMETHOD(StillOff)();
    STDMETHOD(get_AudioLanguage)(long lStream, VARIANT_BOOL fFormat, BSTR* strAudioLang);
    STDMETHOD(ShowMenu)(DVDMenuIDConstants MenuID);
    STDMETHOD(Resume)();
    STDMETHOD(ReturnFromSubmenu)();
    STDMETHOD(get_ButtonsAvailable)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_CurrentButton)(/*[out, retval]*/ long *pVal);
    STDMETHOD(SelectAndActivateButton)(long lButton);
    STDMETHOD(ActivateButton)();
    STDMETHOD(SelectRightButton)();
    STDMETHOD(SelectLeftButton)();
    STDMETHOD(SelectLowerButton)();
    STDMETHOD(SelectUpperButton)();
    STDMETHOD(ActivateAtPosition)(long xPos, long yPos);
    STDMETHOD(SelectAtPosition)(long xPos, long yPos);
    STDMETHOD(get_ButtonAtPosition)(long xPos, long yPos, /*[out, retval] */ long* plButton);
    STDMETHOD(get_NumberOfChapters)(long lTitle, /*[out, retval]*/ long *pVal);
    STDMETHOD(get_TotalTitleTime)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_TitlesAvailable)(/*[out, retval]*/ long* pVal);
    STDMETHOD(get_VolumesAvailable)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_CurrentVolume)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_CurrentDiscSide)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_CurrentDomain)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_CurrentChapter)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_CurrentTitle)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_CurrentTime)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(DVDTimeCode2bstr)(/*[in]*/ long timeCode, /*[out, retval]*/ BSTR *pTimeStr);
    STDMETHOD(get_DVDDirectory)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_DVDDirectory)(/*[in]*/ BSTR newVal);
    STDMETHOD(IsSubpictureStreamEnabled)(/*[in]*/ long lstream, /*[out, retval]*/ VARIANT_BOOL *fEnabled);
    STDMETHOD(IsAudioStreamEnabled)(/*[in]*/ long lstream, /*[out, retval]*/ VARIANT_BOOL *fEnabled);
    STDMETHOD(get_CurrentSubpictureStream)(/*[out, retval]*/ long *pVal);
    STDMETHOD(put_CurrentSubpictureStream)(/*[in]*/ long newVal);
    STDMETHOD(get_SubpictureLanguage)(long lStream, /*[out, retval] */ BSTR* strLanguage);
    STDMETHOD(get_CurrentAudioStream)(/*[out, retval]*/ long *pVal);
    STDMETHOD(put_CurrentAudioStream)(/*[in]*/ long newVal);
    STDMETHOD(get_AudioStreamsAvailable)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_AnglesAvailable)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_CurrentAngle)(/*[out, retval]*/ long *pVal);
    STDMETHOD(put_CurrentAngle)(/*[in]*/ long newVal);
    STDMETHOD(get_SubpictureStreamsAvailable)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_SubpictureOn)(/*[out, retval]*/ VARIANT_BOOL *pVal);
    STDMETHOD(put_SubpictureOn)(/*[in]*/ VARIANT_BOOL newVal);
    STDMETHOD(get_DVDUniqueID)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(AcceptParentalLevelChange)(VARIANT_BOOL fAccept, BSTR strUserName, BSTR strPassword);	
    STDMETHOD(NotifyParentalLevelChange)(/*[in]*/ VARIANT_BOOL newVal);
    STDMETHOD(SelectParentalCountry)(long lCountry, BSTR strUserName, BSTR strPassword);
    STDMETHOD(SelectParentalLevel)(long lParentalLevel, BSTR strUserName, BSTR strPassword);
    STDMETHOD(get_TitleParentalLevels)(long lTitle, /*[out, retval] */ long* plParentalLevels);
    STDMETHOD(get_PlayerParentalCountry)(/*[out, retval] */ long* plCountryCode);
    STDMETHOD(get_PlayerParentalLevel)(/*[out, retval] */ long* plParentalLevel);
    STDMETHOD(Eject)();
    STDMETHOD(UOPValid)(long lUOP, VARIANT_BOOL* pfValid);
    STDMETHOD(get_SPRM)(long lIndex, /*[out, retval] */ short *psSPRM);
    STDMETHOD(get_GPRM)(long lIndex, /*[out, retval] */ short *psSPRM);
    STDMETHOD(put_GPRM)(long lIndex, short sValue);
    STDMETHOD(get_DVDTextStringType)(long lLangIndex, long lStringIndex,  /*[out, retval] */ DVDTextStringType* pType);
    STDMETHOD(get_DVDTextString)(long lLangIndex, long lStringIndex, /*[out, retval] */ BSTR* pstrText);
    STDMETHOD(get_DVDTextNumberOfStrings)(long lLangIndex, /*[out, retval] */ long* plNumOfStrings);
    STDMETHOD(get_DVDTextNumberOfLanguages)(long* /*[out, retval] */ plNumOfLangs);
    STDMETHOD(get_DVDTextLanguageLCID)(/*[in]*/ long lLangIndex, /*[out, retval]*/ long* lcid);
    STDMETHOD(get_LanguageFromLCID)(/*[in]*/ long lcid, /*[out, retval]*/ BSTR* lang);
    STDMETHOD(RegionChange)();
    STDMETHOD(get_DVDAdm)(/*[out, retval]*/ IDispatch* *pVal);
    STDMETHOD(DeleteBookmark)();
    STDMETHOD(RestoreBookmark)();
    STDMETHOD(SaveBookmark)();
    STDMETHOD(SelectDefaultAudioLanguage)(long lang, long ext);
    STDMETHOD(SelectDefaultSubpictureLanguage)(long lang, DVDSPExt ext);
    STDMETHOD(get_PreferredSubpictureStream)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_DefaultMenuLanguage)(long* lang);
    STDMETHOD(put_DefaultMenuLanguage)(long lang);
    STDMETHOD(get_DefaultSubpictureLanguage)(long* lang);
    STDMETHOD(get_DefaultAudioLanguage)(long *lang);
    STDMETHOD(get_DefaultSubpictureLanguageExt)(DVDSPExt* ext);
    STDMETHOD(get_DefaultAudioLanguageExt)(long *ext);
    STDMETHOD(get_KaraokeAudioPresentationMode)(/*[out, retval]*/ long *pVal);
    STDMETHOD(put_KaraokeAudioPresentationMode)(/*[in]*/ long newVal);
    STDMETHOD(get_KaraokeChannelContent)(long lStream, long lChan, /*[out, retval] */ long* lContent);
    STDMETHOD(get_KaraokeChannelAssignment)(long lStream, /*[out, retval] */ long *lChannelAssignment);
    STDMETHOD(RestorePreferredSettings)();
    STDMETHOD(get_ButtonRect)(long lButton, /*[out, retval] */ IMSVidRect** pRect);
    STDMETHOD(get_DVDScreenInMouseCoordinates)(/*[out, retval] */ IMSVidRect** ppRect);	
    STDMETHOD(put_DVDScreenInMouseCoordinates)(IMSVidRect* pRect);
    //STDMETHOD(CanStep)(VARIANT_BOOL fBackwards, VARIANT_BOOL *pfCan);
    //STDMETHOD(Step)(long lStep);
private:
    // Private helper functions
    inline HRESULT RunIfPause(long *dwCookie){
        if(!dwCookie){
            return E_POINTER;
        }

        *dwCookie = 0;
        MSVidCtlStateList _curState = STATE_UNBUILT;   
        CComQIPtr<IMSVidCtl>_pq_VidCtl(m_pContainer);    
        if(!_pq_VidCtl){ 
            return E_UNEXPECTED;          
        } 

        HRESULT	_hr	= _pq_VidCtl->get_State(&_curState); 
        if(_curState ==	STATE_PAUSE){ 
            *dwCookie = 1;
            CComQIPtr<IMSVidAudioRenderer> _pq_AR;
            _hr = _pq_VidCtl->get_AudioRendererActive(&_pq_AR);
            if(FAILED(_hr)){
                return _hr;
            }

            _hr = _pq_AR->get_Volume(dwCookie);
            if(FAILED(_hr)){
                return _hr;
            }

            _hr = _pq_AR->put_Volume(-10000); // -10000 is volume off
            if(FAILED(_hr)){
                return _hr;
            }

            if(*dwCookie == 0){
                *dwCookie = 2;
            }

            _hr	= _pq_VidCtl->Run(); 
            if(FAILED(_hr)){ 
                return _hr;   
            }
        }

        return S_OK;
    }

    // Input is 0 not in pause state, < 0 volume settting, 1 muted audio, 2 full audio volume
    inline HRESULT PauseIfRan(long dwCookie){
        if(!dwCookie){
            return S_FALSE;
        }

        MSVidCtlStateList _curState = STATE_UNBUILT;   
        CComQIPtr<IMSVidCtl>_pq_VidCtl(m_pContainer);    
        if(!_pq_VidCtl){ 
            return E_UNEXPECTED;          
        } 

        HRESULT	_hr	= _pq_VidCtl->get_State(&_curState); 
        if(_curState !=	STATE_PAUSE){ 
            _hr	= _pq_VidCtl->Pause(); 
            if(FAILED(_hr)){ 
                return _hr;   
            }
        }

        if(dwCookie == 1){
            return S_OK;
        }

        if(dwCookie == 2){
            dwCookie = 0;
        }

        CComQIPtr<IMSVidAudioRenderer> _pq_AR;
        _hr = _pq_VidCtl->get_AudioRendererActive(&_pq_AR);
        if(FAILED(_hr)){
            return _hr;
        }

        _hr = _pq_AR->put_Volume(dwCookie);
        if(FAILED(_hr)){
            return _hr;
        }
        return S_OK;
    }   

    HRESULT PassFP_DOM();
    HRESULT HandleError(HRESULT hr);
    HRESULT CleanUp();
    HRESULT RestoreGraphState();
    HRESULT Bstr2DVDTime(DVD_HMSF_TIMECODE *ptrTimeCode, const BSTR *pbstrTime);
    HRESULT DVDTime2bstr(const DVD_HMSF_TIMECODE *pTimeCode, BSTR *pbstrTime);
    HRESULT TransformToWndwls(POINT& pt);
    HRESULT SelectParentalLevel(long lParentalLevel);
    HRESULT SelectParentalCountry(long lParentalCountry);
    HRESULT AppendString(TCHAR* strDest, INT strID, LONG dwLen);
    HRESULT GetDVDDriveLetter(TCHAR* lpDrive);
    HRESULT ParseDVDPath(BSTR pPath);
    HRESULT SetPlaybackFromUrlInfo();
    HRESULT SetDirectoryFromUrlInfo();
    void DeleteUrlInfo();
    int ParseNumber(LPWSTR& p, int nMaxDigits=0);

    // Private data members
    bool              m_fResetSpeed; 
    bool              m_fStillOn; 
    bool              m_fFireNoSubpictureStream;
    bool              m_fStepComplete;
    bool              m_bEjected;
    DVDFilterState    m_DVDFilterState;
    CComPtr<IMSVidWebDVDAdm> m_pDvdAdmin;
    MSLangID          m_LangID;
    long              m_lKaraokeAudioPresentationMode;
	PQDVDControl2     m_pDVDControl2;
	short			  m_usButton;
    DVDUrlInfo        m_urlInfo;
    bool              m_fUrlInfoSet;
    long              m_Rate;
    PositionModeList  m_Mode;
};

#endif // !defined(AFX_MSVIDWEBDVD_H__6CF9F624_1F3C_44FA_8F00_FCC31B2976D6__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\msvidxds.h ===
//==========================================================================;
// MSVidXDS.h : Declaration of the CMSVidXDS
// copyright (c) Microsoft Corp. 1998-1999.
/////////////////////////////////////////////////////////////////////////////

#pragma once

#ifndef __MSVidXDS_H_
#define __MSVidXDS_H_

#include <algorithm>
#include <tchar.h>
#include <objectwithsiteimplsec.h>
#include "segimpl.h"
#include "XDSimpl.h"

#include "seg.h"

typedef CComQIPtr<ITuner> PQMSVidXDS;

/////////////////////////////////////////////////////////////////////////////
// CMSVidXDS
class ATL_NO_VTABLE __declspec(uuid("0149EEDF-D08F-4142-8D73-D23903D21E90")) CXDS : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CXDS, &__uuidof(CXDS)>,
    public IObjectWithSiteImplSec<CXDS>,
	public ISupportErrorInfo,
	public IConnectionPointContainerImpl<CXDS>,
	public IMSVidGraphSegmentImpl<CXDS, MSVidSEG_XFORM, &GUID_NULL>,
    public IMSVidXDSImpl<CXDS, &LIBID_MSVidCtlLib, &GUID_NULL, IMSVidXDS>
{
public:
    CXDS() {
	}

REGISTER_AUTOMATION_OBJECT(IDS_PROJNAME, 
						   IDS_REG_XDS_PROGID, 
						   IDS_REG_XDS_DESC,
						   LIBID_MSVidCtlLib,
						   __uuidof(CXDS));

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CXDS)
	COM_INTERFACE_ENTRY(IMSVidGraphSegment)
	COM_INTERFACE_ENTRY(IMSVidXDS)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectWithSite)
	COM_INTERFACE_ENTRY(IMSVidFeature)
	COM_INTERFACE_ENTRY(IMSVidDevice)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(IPersist)
END_COM_MAP()

	BEGIN_CATEGORY_MAP(CXDS)
		IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
		IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
		IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
	END_CATEGORY_MAP()

BEGIN_CONNECTION_POINT_MAP(CXDS)
END_CONNECTION_POINT_MAP()


// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

public:
    PQCreateDevEnum m_pSystemEnum;
    int m_iIPSink;
    HRESULT Unload(void);
// IMSVidGraphSegment
    STDMETHOD(Build)();

    STDMETHOD(PreRun)();

	STDMETHOD(put_Container)(IMSVidGraphSegmentContainer *pCtl);
    // IMSVidDevice
	STDMETHOD(get_Name)(BSTR * Name);
};

#endif //__MSVidXDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\regbagp.c ===
#include <regbag_p.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\msvidwebdvdcp.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#ifndef _MSVIDWEBDVDCP_H_
#define _MSVIDWEBDVDCP_H_

template <class T>
class CProxy_WebDVDEvent : public CProxy_PlaybackEvent<T, &IID_IMSVidWebDVDEvent, CComDynamicUnkArray>
{
	//Warning this class may be recreated by the wizard.
public:
	VOID Fire_DVDNotify(long lEventCode, VARIANT lParam1, VARIANT lParam2)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[3];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[2] = lEventCode;
				pvars[1] = lParam1;
				pvars[0] = lParam2;
				DISPPARAMS disp = { pvars, NULL, 3, 0 };
				pDispatch->Invoke(eventidDVDNotify, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_PlayForwards(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(eventidPlayForwards, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_PlayBackwards(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(eventidPlayBackwards, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_ShowMenu(DVDMenuIDConstants __MIDL_0011, VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[2];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[1] = __MIDL_0011;
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 2, 0 };
				pDispatch->Invoke(eventidShowMenu, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_Resume(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(eventidResume, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_SelectOrActivateButton(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(eventidSelectOrActivateButton, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_StillOff(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(eventidStillOff, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_PauseOn(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(eventidPauseOn, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_ChangeCurrentAudioStream(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(eventidChangeCurrentAudioStream, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_ChangeCurrentSubpictureStream(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(eventidChangeCurrentSubpictureStream, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_ChangeCurrentAngle(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(eventidChangeCurrentAngle, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_PlayAtTimeInTitle(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(eventidPlayAtTimeInTitle, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_PlayAtTime(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(eventidPlayAtTime, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_PlayChapterInTitle(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(eventidPlayChapterInTitle, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_PlayChapter(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(eventidPlayChapter, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_ReplayChapter(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(eventidReplayChapter, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_PlayNextChapter(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(eventidPlayNextChapter, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_Stop(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(eventidStop, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_ReturnFromSubmenu(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(eventidReturnFromSubmenu, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_PlayTitle(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(eventidPlayTitle, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_PlayPrevChapter(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(eventidPlayPrevChapter, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}	
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\msvidwebdvd.cpp ===
// MSVidWebDVD.cpp : Implementation of CMSVidApp and DLL registration.

#include "stdafx.h"

#ifndef TUNING_MODEL_ONLY

#include "MSVidCtl.h"
#include "MSVidWebDVD.h"
#include "MSVidDVDAdm.h"
//#include "vidrect.h"
#include <evcode.h>
#include <atltmp.h>

DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidWebDVD, CMSVidWebDVD)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidRect, CVidRect)


/*************************************************************************/
/* Local constants and defines                                           */
/*************************************************************************/
const DWORD cdwDVDCtrlFlags = DVD_CMD_FLAG_Block | DVD_CMD_FLAG_Flush;
const DWORD cdwMaxFP_DOMWait = 30000; // 30sec for FP_DOM passing should be OK
const long cgStateTimeout = 0; // wait till the state transition occurs
                               // modify if needed

const long cgDVD_MIN_SUBPICTURE = 0;
const long cgDVD_MAX_SUBPICTURE = 31;
const long cgDVD_ALT_SUBPICTURE = 63;
const long cgDVD_MIN_ANGLE  = 0;
const long cgDVD_MAX_ANGLE = 9;
const double cgdNormalSpeed = 1.00;
const long cgDVDMAX_TITLE_COUNT = 99;
const long cgDVDMIN_TITLE_COUNT = 1;
const long cgDVDMAX_CHAPTER_COUNT = 999;
const long cgDVDMIN_CHAPTER_COUNT = 1;
const LONG cgTIME_STRING_LEN = 2;
const LONG cgMAX_DELIMITER_LEN = 4;
const LONG cgDVD_TIME_STR_LEN = (3*cgMAX_DELIMITER_LEN)+(4*cgTIME_STRING_LEN) + 1 /*NULL Terminator*/;
const long cgVOLUME_MAX = 0;
const long cgVOLUME_MIN = -10000;
const long cgBALANCE_MIN = -10000;
const long cgBALANCE_MAX = 10000;
const WORD cgWAVE_VOLUME_MIN = 0;
const WORD cgWAVE_VOLUME_MAX = 0xffff;

const DWORD cdwTimeout = 10; //100
const long  cgnStepTimeout = 100;

/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CMSVidWebDVD::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IMSVidWebDVD,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

/*************************************************************************/
/* Function: AppendString                                                */
/* Description: Appends a string to an existing one.                     */
/*      strDest is MAX_PATH in length
/*************************************************************************/
HRESULT CMSVidWebDVD::AppendString(TCHAR* strDest, INT strID, LONG dwLen){
    if(dwLen < 0){
        return E_INVALIDARG;
    }

    TCHAR strBuffer[MAX_PATH];

    if(!::LoadString(_Module.m_hInstResource, strID, strBuffer, MAX_PATH)){

        return(E_UNEXPECTED);
    }/* end of if statement */

    (void)StringCchCat(strDest, dwLen, strBuffer);

    return(S_OK);
}/* end of function AppendString */

/*************************************************************************/
/* Function: HandleError                                                 */
/* Description: Gets Error Descriptio, so we can suppor IError Info.     */
/*************************************************************************/
HRESULT CMSVidWebDVD::HandleError(HRESULT hr){

    try {

        if(FAILED(hr)){
            switch(hr){

                case E_NO_IDVD2_PRESENT: 
                    Error(IDS_E_NO_IDVD2_PRESENT); 
                    return (hr);
                case E_NO_DVD_VOLUME: 
                    Error(IDS_E_NO_DVD_VOLUME); 
                    return (hr);
                case E_REGION_CHANGE_FAIL: 
                    Error(IDS_E_REGION_CHANGE_FAIL);   
                    return (hr);
                case E_REGION_CHANGE_NOT_COMPLETED: 
                    Error(IDS_E_REGION_CHANGE_NOT_COMPLETED); 
                    return(hr);
            }/* end of switch statement */

#if 0
            TCHAR strError[MAX_ERROR_TEXT_LEN] = TEXT("");

            if(AMGetErrorText(hr , strError , MAX_ERROR_TEXT_LEN)){
                USES_CONVERSION;
                Error(T2W(strError));
            } 
            else 
            {
                ATLTRACE(TEXT("Unhandled Error Code \n")); // please add it
                ATLASSERT(FALSE);
            }/* end of if statement */
#endif
        }/* end of if statement */
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        // keep the hr same    
    }/* end of catch statement */
    
	return (hr);
}/* end of function HandleError */

/*************************************************************/
/* Name: CleanUp
/* Description: 
/*************************************************************/
HRESULT CMSVidWebDVD::CleanUp(){

    m_pDvdAdmin.Release();
    m_pDvdAdmin = NULL;
    DeleteUrlInfo();

    return NOERROR;
}

/*************************************************************/
/* Name: Init
/* Description: 
/*************************************************************/
STDMETHODIMP CMSVidWebDVD::put_Init(IUnknown *pInit)
{
    HRESULT hr = IMSVidGraphSegmentImpl<CMSVidWebDVD, MSVidSEG_SOURCE, &GUID_NULL>::put_Init(pInit);

    if (FAILED(hr)) {
        return hr;
    }
    if (pInit) {
        m_fInit = false;
        return E_NOTIMPL;
    }

    // create an event that lets us know we are past FP_DOM
    m_fResetSpeed = true;
    m_fStillOn = false;
    m_fEnableResetOnStop = false;
    m_fFireNoSubpictureStream = false;
    m_fStepComplete = false;
    m_bEjected = false;
    m_DVDFilterState = dvdState_Undefined;
    m_lKaraokeAudioPresentationMode = 0;

    // Create the DVD administrator
    m_pDvdAdmin = new CComObject<CMSVidWebDVDAdm>;

    return NOERROR;
}

/*************************************************************************/
/* Function: RestoreGraphState                                           */
/* Description: Restores the graph state.  Used when API fails.          */
/*************************************************************************/
HRESULT CMSVidWebDVD::RestoreGraphState(){

    HRESULT hr = S_OK;

    switch(m_DVDFilterState){
        case dvdState_Undefined: 
        case dvdState_Running:  // do not do anything 
            break;

        case dvdState_Unitialized:
        case dvdState_Stopped:  
            hr = Stop(); 
            break;

        case dvdState_Paused: 
            hr = Pause();		      
            break;
    }/* end of switch statement */

    return(hr);
}/* end of if statement */

/*************************************************************************/
/* Function: TwoDigitToByte                                              */
/*************************************************************************/
static BYTE TwoDigitToByte( const WCHAR* pTwoDigit ){

	int tens    = int(pTwoDigit[0] - L'0');
	return BYTE( (pTwoDigit[1] - L'0') + tens*10);
}/* end of function TwoDigitToByte */

/*************************************************************************/
/* Function: Bstr2DVDTime                                                */
/* Description: Converts a DVD Time info from BSTR into a TIMECODE.      */
/*************************************************************************/
HRESULT CMSVidWebDVD::Bstr2DVDTime(DVD_HMSF_TIMECODE *ptrTimeCode, const BSTR *pbstrTime){


    if(NULL == pbstrTime || NULL == ptrTimeCode){

        return E_INVALIDARG;
    }/* end of if statement */

    ::ZeroMemory(ptrTimeCode, sizeof(DVD_HMSF_TIMECODE));
    WCHAR *pszTime = *pbstrTime;

    ULONG lStringLength = wcslen(pszTime);

    if(0 == lStringLength){

        return E_INVALIDARG;
    }/* end of if statement */    
    TCHAR tszTimeSep[5];
    ::GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_STIME, tszTimeSep, 5);  
    
    // If the string is two long, it is seconds only
    if(lStringLength == 2){
        ptrTimeCode->bSeconds = TwoDigitToByte( &pszTime[0] );
        return S_OK;
    }

    // Otherwise it is a normal time code of the format
    // 43:32:21:10
    // Where the ':' can be replaced with a localized string of upto 4 char in len
    // There is a possible error case where the length of the delimeter is different
    // then the current delimeter

    if(lStringLength >= (4*cgTIME_STRING_LEN)+(3 * _tcslen(tszTimeSep))){ // longest string nnxnnxnnxnn e.g. 43:23:21:10
                                                                         // where n is a number and 
                                                                         // x is a time delimeter usually ':', but can be any string upto 4 char in len)
        ptrTimeCode->bFrames    = TwoDigitToByte( &pszTime[(3*cgTIME_STRING_LEN)+(3*_tcslen(tszTimeSep))]);
    }

    if(lStringLength >= (3*cgTIME_STRING_LEN)+(2 * _tcslen(tszTimeSep))) { // string nnxnnxnn e.g. 43:23:21
        ptrTimeCode->bSeconds   = TwoDigitToByte( &pszTime[(2*cgTIME_STRING_LEN)+(2*_tcslen(tszTimeSep))] );
    }

    if(lStringLength >= (2*cgTIME_STRING_LEN)+(1 * _tcslen(tszTimeSep))) { // string nnxnn e.g. 43:23
        ptrTimeCode->bMinutes   = TwoDigitToByte( &pszTime[(1*cgTIME_STRING_LEN)+(1*_tcslen(tszTimeSep))] );
    }

    if(lStringLength >= (cgTIME_STRING_LEN)) { // string nn e.g. 43
        ptrTimeCode->bHours   = TwoDigitToByte( &pszTime[0] );
    }
    return (S_OK);
}/* end of function bstr2DVDTime */

/*************************************************************************/
/* Function: DVDTime2bstr                                                */
/* Description: Converts a DVD Time info from ULONG into a BSTR.         */
/*************************************************************************/
HRESULT CMSVidWebDVD::DVDTime2bstr( const DVD_HMSF_TIMECODE *pTimeCode, BSTR *pbstrTime){

    if(NULL == pTimeCode || NULL == pbstrTime) 
        return E_INVALIDARG;

    USES_CONVERSION;

    TCHAR tszTime[cgDVD_TIME_STR_LEN];
    TCHAR tszTimeSep[5];

    ::ZeroMemory(tszTime, sizeof(TCHAR)*cgDVD_TIME_STR_LEN);

    ::GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_STIME, tszTimeSep, 5);


    (void)StringCchPrintf( tszTime, cgDVD_TIME_STR_LEN, TEXT("%02lu%s%02lu%s%02lu%s%02lu"), 
                pTimeCode->bHours,   tszTimeSep,
                pTimeCode->bMinutes, tszTimeSep,
                pTimeCode->bSeconds, tszTimeSep,
                pTimeCode->bFrames );
    
    *pbstrTime = SysAllocString(T2OLE(tszTime));
    return (S_OK);
}/* end of function DVDTime2bstr */

/*************************************************************************/
/* Function: PreRun                                                         */
/* Description: called before the filter graph is running                */
/*              set DVD_ResetOnStop to be false                          */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::PreRun(){
    
    HRESULT hr = S_OK;

    try {

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDVDControl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */        
            
        // set dvd root directory from url
        // this has to happen before IMediaControl->Run()

        hr = SetDirectoryFromUrlInfo();
        if(FAILED(hr)){
            
            throw(hr);
        }/* end of if statement */
                
        if (!m_pGraph.IsPlaying()) {
            if(FALSE == m_fEnableResetOnStop){
                
                hr = m_pDVDControl2->SetOption(DVD_ResetOnStop, FALSE);
                
                if(FAILED(hr)){
          
                    throw(hr);
                }/* end of if statement */
            }/* end of if statement */

            hr = m_pDVDControl2->SetOption( DVD_HMSF_TimeCodeEvents, TRUE);
            if(FAILED(hr)){
                
                throw(hr);
            }/* end of if statement */

        }/* end of if statement */            
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of PreRun */

/*************************************************************************/
/* Function: PostRun                                                     */
/* Description: Puts the filter graph in the running state in case not   */
/*              and reset play speed to normal                           */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::PostRun(){

    HRESULT hr = S_OK;

    try {

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        // save the state so we can restore it if an API fails
        m_DVDFilterState = (DVDFilterState) m_pGraph.GetState();

        bool bFireEvent = false;  // fire event only when we change the state
		
        if(!m_pDVDControl2){
            throw(E_UNEXPECTED);
        }/* end of if statement */        

        if(false == m_fStillOn && true == m_fResetSpeed){
            // if we are in the still do not reset the speed            
            m_pDVDControl2->PlayForwards(cgdNormalSpeed,0,0);
        }/* end of if statement */        

        // set playback references such title/chapter
        // this call will clear urlInfo

        hr = SetPlaybackFromUrlInfo();

    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function PostRun */

/*************************************************************************/
/* Function: PreStop                                                        */
/* Description: called before the filter graph is stopped                */
/*              set DVD_ResetOnStop to be true                           */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::PreStop(){
    
    HRESULT hr = S_OK;
    
    try {
        
        if(!m_pDVDControl2){
            
            throw(E_UNEXPECTED);
        }
        
        if (!m_pGraph.IsStopped()) {
            VARIANT_BOOL onStop;
            long dwDomain = 0;
            hr = get_CurrentDomain(&dwDomain);
            if(FAILED(hr)){
                return hr;
            }
            if(dwDomain != DVD_DOMAIN_Stop){
                hr = m_pDvdAdmin->get_BookmarkOnStop(&onStop);
                if(FAILED(hr)){
                    throw(hr);
                }
                
                if(VARIANT_TRUE == onStop){
                    hr = SaveBookmark();
                    if(FAILED(hr)){
                        throw(hr);
                    }
                    
                }
                
                if(FALSE == m_fEnableResetOnStop){
                    
                    hr = m_pDVDControl2->SetOption(DVD_ResetOnStop, TRUE);
                    if(FAILED(hr)){
                        throw(hr);
                    }
                    
                }
            }
        }
    }
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

	return HandleError(hr);
}/* end of function PreStop */

/*************************************************************************/
/* Function: PostStop                                                    */
/* Description: Stops the filter graph if the state does not indicate    */
/* it was stopped.                                                       */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::PostStop(){
    HRESULT hr = S_OK;

    try {
#if 0
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

		PQVidCtl pvc(m_pContainer);
		MSVidCtlStateList slState;
		HRESULT hr = pvc->get_State(&slState);
        if (SUCCEEDED(hr) && slState != STATE_STOP) {
            hr = pvc->Stop();
            if (FAILED(hr)) {

                throw (hr);
            }/* end of if statement */
        }/* end of if statement */
#endif
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of PostStop */

/*************************************************************************/
/* Function: PlayTitle                                                   */
/* Description: If fails waits for FP_DOM to pass and tries later.       */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::PlayTitle(LONG lTitle){

    HRESULT hr = S_OK;

    try {

        if(0 > lTitle){

            throw(E_INVALIDARG);
        }/* end of if statement */

        long lNumTitles = 0;
        hr = get_TitlesAvailable(&lNumTitles);
        if(FAILED(hr)){
            throw hr;
        }

        if(lTitle > lNumTitles){
            throw E_INVALIDARG;
        }

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY;

        if(!m_pDVDControl2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        long pauseCookie = 0;
        HRESULT hres = RunIfPause(&pauseCookie);
        if(FAILED(hres)){
            return hres; 
        }

        hr = m_pDVDControl2->PlayTitle(lTitle, cdwDVDCtrlFlags, 0);
        
        hres = PauseIfRan(pauseCookie);
        if(FAILED(hres)){
            return hres;
        }

    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function PlayTitle */

/*************************************************************************/
/* Function: PlayChapterInTitle                                          */
/* Description: Plays from the specified chapter without stopping        */
/* THIS NEEDS TO BE ENHANCED !!! Current implementation and queing       */
/* into the message loop is insufficient!!! TODO.                        */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::PlayChapterInTitle(LONG lTitle, LONG lChapter){

    HRESULT hr = S_OK;

    try {
        
        if ((lTitle > cgDVDMAX_TITLE_COUNT) || (lTitle < cgDVDMIN_TITLE_COUNT)){

            throw(E_INVALIDARG);
        }/* end of if statement */

        if ((lChapter > cgDVDMAX_CHAPTER_COUNT) || (lChapter < cgDVDMIN_CHAPTER_COUNT)){

            throw(E_INVALIDARG);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY;

        if(!m_pDVDControl2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        long pauseCookie = 0;
        HRESULT hres = RunIfPause(&pauseCookie);
        if(FAILED(hres)){
            return hres; 
        }

        hr = m_pDVDControl2->PlayChapterInTitle(lTitle, lChapter, cdwDVDCtrlFlags, 0);

        hres = PauseIfRan(pauseCookie);
        if(FAILED(hres)){
            return hres;
        }

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function PlayChapterInTitle */

/*************************************************************************/
/* Function: PlayChapter                                                 */
/* Description: Does chapter search. Waits for FP_DOM to pass and initi  */
/* lizes the graph as the other smar routines.                           */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::PlayChapter(LONG lChapter){

    HRESULT hr = S_OK;

    try {

        if(lChapter < 0){

            throw(E_INVALIDARG);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY;

        if(!m_pDVDControl2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        long pauseCookie = 0;
        HRESULT hres = RunIfPause(&pauseCookie);
        if(FAILED(hres)){
            return hres; 
        }

        hr = m_pDVDControl2->PlayChapter(lChapter, cdwDVDCtrlFlags, 0);

        hres = PauseIfRan(pauseCookie);
        if(FAILED(hres)){
            return hres;
        }

    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return  HandleError(hr);
}/* end of function PlayChapter */

/*************************************************************************/
/* Function: PlayChapterAutoStop                                         */
/* Description: Plays set ammount of chapters.                           */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::PlayChaptersAutoStop(LONG lTitle, LONG lChapter, 
                                          LONG lChapterCount){

    HRESULT hr = S_OK;

    try {        

        if ((lTitle > cgDVDMAX_TITLE_COUNT) || (lTitle < cgDVDMIN_TITLE_COUNT)){
            
            throw(E_INVALIDARG);
        }/* end of if statement */

        if ((lChapter > cgDVDMAX_CHAPTER_COUNT) || (lChapter < cgDVDMIN_CHAPTER_COUNT)){
            
            throw(E_INVALIDARG);
        }/* end of if statement */

        if ((lChapterCount > cgDVDMAX_CHAPTER_COUNT) || (lChapterCount < cgDVDMIN_CHAPTER_COUNT)){
            
            throw(E_INVALIDARG);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY;

        if(!m_pDVDControl2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        long pauseCookie = 0;
        HRESULT hres = RunIfPause(&pauseCookie);
        if(FAILED(hres)){
            return hres; 
        }

        hr = m_pDVDControl2->PlayChaptersAutoStop(lTitle, lChapter, lChapterCount, cdwDVDCtrlFlags, 0);

        hres = PauseIfRan(pauseCookie);
        if(FAILED(hres)){
            return hres;
        }

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function PlayChaptersAutoStop */

/*************************************************************************/
/* Function: PlayAtTime                                                  */
/* Description: TimeSearch, converts from hh:mm:ss:ff format             */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::PlayAtTime(BSTR strTime){

    HRESULT hr = S_OK;

    try {
        
        if(NULL == strTime){

            throw(E_POINTER);
        }/* end of if statement */
        
        DVD_HMSF_TIMECODE tcTimeCode;
        Bstr2DVDTime(&tcTimeCode, &strTime);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY;

        if(!m_pDVDControl2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        long pauseCookie = 0;
        HRESULT hres = RunIfPause(&pauseCookie);
        if(FAILED(hres)){
            return hres; 
        }

        hr = m_pDVDControl2->PlayAtTime( &tcTimeCode, cdwDVDCtrlFlags, 0);

        hres = PauseIfRan(pauseCookie);
        if(FAILED(hres)){
            return hres;
        }

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function PlayAtTime */

/*************************************************************************/
/* Function: PlayAtTimeInTitle                                           */
/* Description: Time plays, converts from hh:mm:ss:ff format             */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::PlayAtTimeInTitle(long lTitle, BSTR strTime){

    HRESULT hr = S_OK;

    try {        
        if(NULL == strTime){

            throw(E_POINTER);
        }/* end of if statement */
        
        DVD_HMSF_TIMECODE tcTimeCode;
        hr = Bstr2DVDTime(&tcTimeCode, &strTime);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY;

        if(!m_pDVDControl2){

            throw(E_UNEXPECTED);
        }/* end of if statement */
        long pauseCookie = 0;
        HRESULT hres = RunIfPause(&pauseCookie);
        if(FAILED(hres)){
            return hres; 
        }

        hr = m_pDVDControl2->PlayAtTimeInTitle(lTitle, &tcTimeCode, cdwDVDCtrlFlags, 0);

        hres = PauseIfRan(pauseCookie);
        if(FAILED(hres)){
            return hres;
        }

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function PlayAtTimeInTitle */

/*************************************************************************/
/* Function: PlayPeriodInTitleAutoStop                                   */
/* Description: Time plays, converts from hh:mm:ss:ff format             */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::PlayPeriodInTitleAutoStop(long lTitle, 
                                                  BSTR strStartTime, BSTR strEndTime){

    HRESULT hr = S_OK;

    try {        
        if(NULL == strStartTime){

            throw(E_POINTER);
        }/* end of if statement */

        if(NULL == strEndTime){

            throw(E_POINTER);
        }/* end of if statement */
        
        DVD_HMSF_TIMECODE tcStartTimeCode;
        hr = Bstr2DVDTime(&tcStartTimeCode, &strStartTime);

        if(FAILED(hr)){

            throw (hr);
        }

        DVD_HMSF_TIMECODE tcEndTimeCode;

        Bstr2DVDTime(&tcEndTimeCode, &strEndTime);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY;

        if(!m_pDVDControl2){

            throw(E_UNEXPECTED);
        }/* end of if statement */
        long pauseCookie = 0;
        HRESULT hres = RunIfPause(&pauseCookie);
        if(FAILED(hres)){
            return hres; 
        }

        hr = m_pDVDControl2->PlayPeriodInTitleAutoStop(lTitle, &tcStartTimeCode,
            &tcEndTimeCode,  cdwDVDCtrlFlags, 0);

        hres = PauseIfRan(pauseCookie);
        if(FAILED(hres)){
            return hres;
        }

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function PlayPeriodInTitleAutoStop */

/*************************************************************************/
/* Function: ReplayChapter                                               */
/* Description: Halts playback and restarts the playback of current      */
/* program inside PGC.                                                   */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::ReplayChapter(){

    HRESULT hr = S_OK;

    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY;

        if(!m_pDVDControl2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        long pauseCookie = 0;
        HRESULT hres = RunIfPause(&pauseCookie);
        if(FAILED(hres)){
            return hres; 
        }

        hr = m_pDVDControl2->ReplayChapter(cdwDVDCtrlFlags, 0);

        hres = PauseIfRan(pauseCookie);
        if(FAILED(hres)){
            return hres;
        }

    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return  HandleError(hr);
}/* end of function ReplayChapter */

/*************************************************************************/
/* Function: PlayPrevChapter                                             */
/* Description: Goes to previous chapter                                 */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::PlayPrevChapter(){

    HRESULT hr = S_OK;

    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY;

        if(!m_pDVDControl2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        long pauseCookie = 0;
        HRESULT hres = RunIfPause(&pauseCookie);
        if(FAILED(hres)){
            return hres; 
        }

        hr = m_pDVDControl2->PlayPrevChapter(cdwDVDCtrlFlags, 0);

        hres = PauseIfRan(pauseCookie);
        if(FAILED(hres)){
            return hres;
        }

    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return  HandleError(hr);
}/* end of function PlayPrevChapter */

/*************************************************************************/
/* Function: PlayNextChapter                                             */
/* Description: Goes to next chapter                                     */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::PlayNextChapter(){

    HRESULT hr = S_OK;
    CComQIPtr<IDvdCmd>IDCmd;
    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY;

        if(!m_pDVDControl2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        long pauseCookie = 0;
        HRESULT hres = RunIfPause(&pauseCookie);
        if(FAILED(hres)){
            return hres; 
        }

        hr = m_pDVDControl2->PlayNextChapter(cdwDVDCtrlFlags, 0);

        hres = PauseIfRan(pauseCookie);
        if(FAILED(hres)){
            return hres;
        }

    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return  HandleError(hr);
}/* end of function PlayNextChapter */


/*************************************************************************/
/* Function: StillOff                                                    */
/* Description: Turns the still off, what that can be used for is a      */
/* mistery to me.                                                        */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::StillOff(){

    if(!m_pDVDControl2){
        
        throw(E_UNEXPECTED);
    }/* end of if statement */                
    
    return HandleError(m_pDVDControl2->StillOff());
}/* end of function StillOff */

/*************************************************************************/
/* Function: GetAudioLanguage                                            */
/* Description: Returns audio language associated with a stream.         */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_AudioLanguage(LONG lStream, VARIANT_BOOL fFormat, BSTR *strAudioLang){

    HRESULT hr = S_OK;
    LPTSTR pszString = NULL;

    try {
        if(NULL == strAudioLang){

            throw(E_POINTER);
        }/* end of if statement */

        if(lStream < 0){

            throw(E_INVALIDARG);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        USES_CONVERSION;
        LCID lcid = _UI32_MAX;
                
        hr = pDvdInfo2->GetAudioLanguage(lStream, &lcid);
    
        if (SUCCEEDED( hr ) && lcid < _UI32_MAX){

            // count up the streams for the same LCID like English 2
            
            pszString = m_LangID.GetLanguageFromLCID(PRIMARYLANGID(LANGIDFROMLCID(lcid)));
            if (pszString == NULL) {
                
                pszString = new TCHAR[MAX_PATH];
                TCHAR strBuffer[MAX_PATH];
                if(!::LoadString(_Module.m_hInstResource, IDS_DVD_AUDIOTRACK, strBuffer, MAX_PATH)){
                    delete[] pszString;
                    throw(E_UNEXPECTED);
                }/* end of if statement */

                (void)StringCchPrintf(pszString, MAX_PATH, strBuffer, lStream);
            }/* end of if statement */

            DVD_AudioAttributes attr;
            if(SUCCEEDED(pDvdInfo2->GetAudioAttributes(lStream, &attr))){
                
                // If want audio format param is set
                if (fFormat != VARIANT_FALSE) {
                    switch(attr.AudioFormat){
                    case DVD_AudioFormat_AC3: AppendString(pszString, IDS_DVD_DOLBY, MAX_PATH ); break; 
                    case DVD_AudioFormat_MPEG1: AppendString(pszString, IDS_DVD_MPEG1, MAX_PATH ); break;
                    case DVD_AudioFormat_MPEG1_DRC: AppendString(pszString, IDS_DVD_MPEG1, MAX_PATH ); break;
                    case DVD_AudioFormat_MPEG2: AppendString(pszString, IDS_DVD_MPEG2, MAX_PATH ); break;
                    case DVD_AudioFormat_MPEG2_DRC: AppendString(pszString, IDS_DVD_MPEG2, MAX_PATH); break;
                    case DVD_AudioFormat_LPCM: AppendString(pszString, IDS_DVD_LPCM, MAX_PATH ); break;
                    case DVD_AudioFormat_DTS: AppendString(pszString, IDS_DVD_DTS, MAX_PATH ); break;
                    case DVD_AudioFormat_SDDS: AppendString(pszString, IDS_DVD_SDDS, MAX_PATH ); break;
                    }/* end of switch statement */                    
                }

                switch(attr.LanguageExtension){
                case DVD_AUD_EXT_NotSpecified:
                case DVD_AUD_EXT_Captions:     break; // do not add anything
                case DVD_AUD_EXT_VisuallyImpaired:   AppendString(pszString, IDS_DVD_AUDIO_VISUALLY_IMPAIRED, MAX_PATH ); break;      
                case DVD_AUD_EXT_DirectorComments1:  AppendString(pszString, IDS_DVD_AUDIO_DIRC1, MAX_PATH ); break;
                case DVD_AUD_EXT_DirectorComments2:  AppendString(pszString, IDS_DVD_AUDIO_DIRC2, MAX_PATH ); break;
                }/* end of switch statement */

            }/* end of if statement */

            *strAudioLang = ::SysAllocString( T2W(pszString) );
            delete[] pszString;
            pszString = NULL;
        }
        else {

            *strAudioLang = ::SysAllocString( L"");

            // hr used to be not failed and return nothing 
            if(SUCCEEDED(hr)) // remove this after gets fixed in DVDNav
                hr = E_FAIL;
        }/* end of if statement */
    }/* end of try statement */
    catch(HRESULT hrTmp){

        if (pszString) {
            delete[] pszString;
            pszString = NULL;
        }

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        if (pszString) {
            delete[] pszString;
            pszString = NULL;
        }

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function GetAudioLanguage */

/*************************************************************************/
/* Function: ShowMenu                                                    */
/* Description: Invokes specific menu call.                              */
/* We set our selfs to play mode so we can execute this in case we were  */
/* paused or stopped.                                                    */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::ShowMenu(DVDMenuIDConstants MenuID){
    HRESULT hr = S_OK;

    try {

        if(!m_pDVDControl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */                
            
        RETRY_IF_IN_FPDOM(m_pDVDControl2->ShowMenu((tagDVD_MENU_ID)MenuID, cdwDVDCtrlFlags, 0)); //!!keep in sync, or this cast will not work
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return  HandleError(hr);
}

/*************************************************************************/
/* Function: Resume                                                      */
/* Description: Resume from menu. We put our self in play state, just    */
/* in the case we were not in it. This might lead to some unexpected     */
/* behavior in case when we stopped and the tried to hit this button     */
/* but I think in this case might be appropriate as well.                */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::Resume(){
    HRESULT hr = S_OK;

    try {

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY

        if(!m_pDVDControl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */                

        hr = m_pDVDControl2->Resume(cdwDVDCtrlFlags, 0);
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return  HandleError(hr);
}/* end of function Resume */

/*************************************************************************/
/* Function: ReturnFromSubmenu                                                      */
/* Description: Used in menu to return into prevoius menu.               */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::ReturnFromSubmenu(){

    HRESULT hr = S_OK;

    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY

        if(!m_pDVDControl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */
            
        RETRY_IF_IN_FPDOM(m_pDVDControl2->ReturnFromSubmenu(cdwDVDCtrlFlags, 0));
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return  HandleError(hr);
}/* end of function Return */

/*************************************************************************/
/* Function: get_ButtonsAvailable                                        */
/* Description: Gets the count of the available buttons.                 */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_ButtonsAvailable(long *plNumButtons){

    HRESULT hr = S_OK;

    try {
        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        ULONG ulCurrentButton = 0L;

        hr = pDvdInfo2->GetCurrentButton((ULONG*)plNumButtons, &ulCurrentButton);

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);
}/* end of function get_ButtonsAvailable */

/*************************************************************************/
/* Function: get_CurrentButton                                           */
/* Description: Gets currently selected button.                          */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_CurrentButton(long *plCurrentButton){

    HRESULT hr = S_OK;

    try {
        if(NULL == plCurrentButton){

            throw(E_POINTER);
        }/* end of if statement */            

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        ULONG ulNumButtons = 0L;
        *plCurrentButton = 0;

        hr = pDvdInfo2->GetCurrentButton(&ulNumButtons, (ULONG*)plCurrentButton);
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);
}/* end of function get_CurrentButton */

/*************************************************************************/
/* Function: SelectUpperButton                                           */
/* Description: Selects the upper button on DVD Menu.                    */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::SelectUpperButton(){

    HRESULT hr = S_OK;

    try {

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY

        if(!m_pDVDControl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        hr = m_pDVDControl2->SelectRelativeButton(DVD_Relative_Upper);        
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return  HandleError(hr);
}/* end of function SelectUpperButton */

/*************************************************************************/
/* Function: SelectLowerButton                                           */
/* Description: Selects the lower button on DVD Menu.                    */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::SelectLowerButton(){

	HRESULT hr = S_OK;

    try {
        
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY

        if(!m_pDVDControl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        hr = m_pDVDControl2->SelectRelativeButton(DVD_Relative_Lower);                
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return  HandleError(hr);
}/* end of function SelectLowerButton */

/*************************************************************************/
/* Function: SelectLeftButton                                            */
/* Description: Selects the left button on DVD Menu.                     */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::SelectLeftButton(){

    HRESULT hr = S_OK;

    try {

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY

        if(!m_pDVDControl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        hr = m_pDVDControl2->SelectRelativeButton(DVD_Relative_Left);                
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return  HandleError(hr);
}/* end of function SelectLeftButton */

/*************************************************************************/
/* Function: SelectRightButton                                           */
/* Description: Selects the right button on DVD Menu.                    */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::SelectRightButton(){

	HRESULT hr = S_OK;

    try {

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY

        if(!m_pDVDControl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        hr = m_pDVDControl2->SelectRelativeButton(DVD_Relative_Right);        
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
    return  HandleError(hr);
}/* end of function SelectRightButton */

/*************************************************************************/
/* Function: ActivateButton                                              */
/* Description: Activates the selected button on DVD Menu.               */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::ActivateButton(){

	HRESULT hr = S_OK;

    try {

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY

        if(!m_pDVDControl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        hr = m_pDVDControl2->ActivateButton();
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return  HandleError(hr);
}/* end of function ActivateButton */

/*************************************************************************/
/* Function: SelectAndActivateButton                                     */
/* Description: Selects and activates the specific button.               */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::SelectAndActivateButton(long lButton){

    HRESULT hr = S_OK;

    try {

        if(lButton < 0){
            
            throw(E_INVALIDARG);        
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY

        if(!m_pDVDControl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        hr = m_pDVDControl2->SelectAndActivateButton((ULONG)lButton);
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return  HandleError(hr);
}/* end of function SelectAndActivateButton */

/*************************************************************************/
/* Function: TransformToWndwls                                           */
/* Description: Transforms the coordinates to screen onse.               */
/*************************************************************************/
HRESULT CMSVidWebDVD::TransformToWndwls(POINT& pt){

    HRESULT hr = S_FALSE;
#if 0
    // we are windowless we need to map the points to screen coordinates
    if(m_bWndLess){

        HWND hwnd = NULL;

        hr = GetParentHWND(&hwnd);

        if(FAILED(hr)){

            return(hr);
        }/* end of if statement */

        if(!::IsWindow(hwnd)){

            hr = E_UNEXPECTED;
            return(hr);
        }/* end of if statement */

        ::MapWindowPoints(hwnd, ::GetDesktopWindow(), &pt, 1);

        hr = S_OK;

    }/* end of if statement */
#endif
    return(hr);
}/* end of function TransformToWndwls */

/*************************************************************************/
/* Function: ActivateAtPosition                                          */
/* Description: Activates a button at selected position.                 */ 
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::ActivateAtPosition(long xPos, long yPos){

    HRESULT hr = S_OK;

    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDVDControl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        POINT pt = {xPos, yPos};

        hr = TransformToWndwls(pt);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        hr = m_pDVDControl2->ActivateAtPosition(pt);

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function ActivateAtPosition */

/*************************************************************************/
/* Function: SelectAtPosition                                            */
/* Description: Selects a button at selected position.                   */ 
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::SelectAtPosition(long xPos, long yPos){

    HRESULT hr = S_OK;

    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDVDControl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        POINT pt = {xPos, yPos};

        hr = TransformToWndwls(pt);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */
        
        hr = m_pDVDControl2->SelectAtPosition(pt);

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function SelectAtPosition */

/*************************************************************************/
/* Function: GetButtonAtPosition                                         */
/* Description: Gets the button number associated with a position.       */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_ButtonAtPosition(long xPos, long yPos, 
                                              long *plButton)
{
	HRESULT hr = S_OK;

    try {
		if(!plButton){
			return E_POINTER;
		}
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        POINT pt = {xPos, yPos};

        hr = TransformToWndwls(pt);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        ULONG ulButton;
        hr = pDvdInfo2->GetButtonAtPosition(pt, &ulButton);

        if(SUCCEEDED(hr)){
            *plButton = ulButton;
        } 
        else {
            plButton = 0;
        }/* end of if statement */

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function GetButtonAtPosition */

/*************************************************************************/
/* Function: GetNumberChapterOfChapters                                  */
/* Description: Returns the number of chapters in title.                 */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_NumberOfChapters(long lTitle, long *pVal){

    HRESULT hr = S_OK;

    try {
        if(NULL == pVal){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        hr = pDvdInfo2->GetNumberOfChapters(lTitle, (ULONG*)pVal);
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return HandleError(hr);
}/* end of function GetNumberChapterOfChapters */

/*************************************************************************/
/* Function: get_TitlesAvailable                                         */
/* Description: Gets the number of titles.                               */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_TitlesAvailable(long *pVal){

    HRESULT hr = S_OK;

    try {
        if(NULL == pVal){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        ULONG NumOfVol;
        ULONG ThisVolNum;
        DVD_DISC_SIDE Side;
        ULONG TitleCount;

        hr = pDvdInfo2->GetDVDVolumeInfo(&NumOfVol, &ThisVolNum, &Side, &TitleCount);

        *pVal = (LONG) TitleCount;
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return HandleError(hr);
}/* end of function get_TitlesAvailable */

/*************************************************************************/
/* Function: get_TotalTitleTime                                          */
/* Description: Gets total time in the title.                            */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_TotalTitleTime(BSTR *pTime){

    HRESULT hr = S_OK;

    try {
        if(NULL == pTime){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        DVD_HMSF_TIMECODE tcTime;
        ULONG ulFlags;	// contains 30fps/25fps
        hr =  pDvdInfo2->GetTotalTitleTime(&tcTime, &ulFlags);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */
        
        hr = DVDTime2bstr(&tcTime, pTime);
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function get_TotalTitleTime */ 

/*************************************************************************/
/* Function: get_VolumesAvailable                                        */
/* Description: Gets total number of volumes available.                  */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_VolumesAvailable(long *plNumOfVol){

    HRESULT hr = S_OK;

    try {    	
    
        if(NULL == plNumOfVol){

            throw(E_POINTER);
        }/* end of if statement */

        ULONG ulThisVolNum;
        DVD_DISC_SIDE discSide;
        ULONG ulNumOfTitles;

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE   

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        hr = pDvdInfo2->GetDVDVolumeInfo( (ULONG*)plNumOfVol, 
            &ulThisVolNum, 
            &discSide, 
            &ulNumOfTitles);
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return  HandleError(hr);
}/* end of function get_VolumesAvailable */

/*************************************************************************/
/* Function: get_CurrentVolume                                           */
/* Description: Gets current volume.                                     */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_CurrentVolume(long *plVolume){

    HRESULT hr = S_OK;

    try {    	
        if(NULL == plVolume){

            throw(E_POINTER);
        }/* end of if statement */

        ULONG ulNumOfVol;
        DVD_DISC_SIDE discSide;
        ULONG ulNumOfTitles;

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE   

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        hr = pDvdInfo2->GetDVDVolumeInfo( &ulNumOfVol, 
            (ULONG*)plVolume, 
            &discSide, 
            &ulNumOfTitles);
	}/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return  HandleError(hr);
}/* end of function get_CurrentVolume */

/*************************************************************************/
/* Function: get_CurrentDiscSide                                         */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_CurrentDiscSide(long *plDiscSide){

    HRESULT hr = S_OK;

    try {    	

        if(NULL == plDiscSide){

            throw(E_POINTER);
        }/* end of if statement */
        
        ULONG ulNumOfVol;
        ULONG ulThisVolNum;
        DVD_DISC_SIDE discSide;
        ULONG ulNumOfTitles;

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE   

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        hr = pDvdInfo2->GetDVDVolumeInfo( &ulNumOfVol, 
            &ulThisVolNum, 
            &discSide, 
            &ulNumOfTitles);
        *plDiscSide = discSide;
	}/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return  HandleError(hr);
}/* end of function get_CurrentDiscSide */

/*************************************************************************/
/* Function: get_CurrentDomain                                           */
/* Description: gets current DVD domain.                                 */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_CurrentDomain(long *plDomain){

    HRESULT hr = S_OK;

    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        if(NULL == plDomain){

            throw(E_POINTER);
        }/* end of if statememt */

        hr = pDvdInfo2->GetCurrentDomain((DVD_DOMAIN *)plDomain);
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return  HandleError(hr);
}/* end of function get_CurrentDomain */

/*************************************************************************/
/* Function: get_CurrentChapter                                          */
/* Description: Gets current chapter                                     */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_CurrentChapter(long *pVal){

    HRESULT hr = S_OK;

    try {        
        if(NULL == pVal){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        DVD_PLAYBACK_LOCATION2 dvdLocation;

        RETRY_IF_IN_FPDOM(pDvdInfo2->GetCurrentLocation(&dvdLocation));

        if(SUCCEEDED(hr)){

            *pVal = dvdLocation.ChapterNum;
        }
        else {

            *pVal = 0;
        }/* end of if statement */
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return  HandleError(hr);
}/* end of function get_CurrentChapter */

/*************************************************************************/
/* Function: get_CurrentTitle                                            */
/* Description: Gets current title.                                      */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_CurrentTitle(long *pVal){

    HRESULT hr = S_OK;

    try {        
        if(NULL == pVal){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        DVD_PLAYBACK_LOCATION2 dvdLocation;

        RETRY_IF_IN_FPDOM(pDvdInfo2->GetCurrentLocation(&dvdLocation));

        if(SUCCEEDED(hr)){

            *pVal = dvdLocation.TitleNum;
        }
        else {

            *pVal = 0;
        }/* end of if statement */
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return  HandleError(hr);
}/* end of function get_CurrentTitle */

/*************************************************************************/
/* Function: get_CurrentTime                                             */
/* Description: Gets current time.                                       */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_CurrentTime(BSTR *pVal){

    HRESULT hr = S_OK;

    try {       
        if(NULL == pVal){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        DVD_PLAYBACK_LOCATION2 dvdLocation;

        hr = pDvdInfo2->GetCurrentLocation(&dvdLocation);
        
        DVDTime2bstr(&(dvdLocation.TimeCode), pVal);          
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function get_CurrentTime */

/*************************************************************/
/* Name: DVDTimeCode2bstr
/* Description: returns time string for HMSF timecode
/*************************************************************/
STDMETHODIMP CMSVidWebDVD::DVDTimeCode2bstr(/*[in]*/ long timeCode, /*[out, retval]*/ BSTR *pTimeStr){
    return DVDTime2bstr((DVD_HMSF_TIMECODE*)&timeCode, pTimeStr);
}

/*************************************************************************/
/* Function: get_DVDDirectory                                            */
/* Description: Gets the root of the DVD drive.                          */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_DVDDirectory(BSTR *pVal){

    HRESULT hr = S_OK;

    try {
        if(NULL == pVal){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE   
    
        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */
        
        WCHAR szRoot[MAX_PATH];
        ULONG ulActual;

        hr = pDvdInfo2->GetDVDDirectory(szRoot, MAX_PATH, &ulActual);

        *pVal = ::SysAllocString(szRoot);
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return HandleError(hr);
}/* end of function get_DVDDirectory */

/*************************************************************************/
/* Function: put_DVDDirectory                                            */
/* Description: Sets the root for DVD control.                           */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::put_DVDDirectory(BSTR bstrRoot){

    HRESULT hr = S_OK;

    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE   
    
        if(!m_pDVDControl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        hr = m_pDVDControl2->SetDVDDirectory(bstrRoot);
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return HandleError(hr);
}/* end of function put_DVDDirectory */

/*************************************************************/
/* Name: IsSubpictureStreamEnabled
/* Description: 
/*************************************************************/
STDMETHODIMP CMSVidWebDVD::IsSubpictureStreamEnabled(long lStream, VARIANT_BOOL *fEnabled)
{
    HRESULT hr = S_OK;

    try {
        if(lStream < 0){

            throw(E_INVALIDARG);
        }/* end of if statement */

        if (fEnabled == NULL) {

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        BOOL temp;
        hr = pDvdInfo2->IsSubpictureStreamEnabled(lStream, &temp);
        if (FAILED(hr))
            throw hr;

        *fEnabled = temp==FALSE? VARIANT_FALSE:VARIANT_TRUE;

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return HandleError(hr);
}

/*************************************************************/
/* Name: IsAudioStreamEnabled
/* Description: 
/*************************************************************/
STDMETHODIMP CMSVidWebDVD::IsAudioStreamEnabled(long lStream, VARIANT_BOOL *fEnabled)
{
    HRESULT hr = S_OK;

    try {
        if(lStream < 0){

            throw(E_INVALIDARG);
        }/* end of if statement */

        if (fEnabled == NULL) {

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        BOOL temp;
        hr = pDvdInfo2->IsAudioStreamEnabled(lStream, &temp);
        if (FAILED(hr))
            throw hr;

        *fEnabled = temp==FALSE? VARIANT_FALSE:VARIANT_TRUE;

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return HandleError(hr);
}

/*************************************************************************/
/* Function: get_CurrentSubpictureStream                                 */
/* Description: Gets the current subpicture stream.                      */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_CurrentSubpictureStream(long *plSubpictureStream){

    HRESULT hr = S_OK;

    try {
        
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        ULONG ulStreamsAvailable = 0L;
        BOOL  bIsDisabled = TRUE;    

        RETRY_IF_IN_FPDOM(pDvdInfo2->GetCurrentSubpicture(&ulStreamsAvailable, (ULONG*)plSubpictureStream, &bIsDisabled ));
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return  HandleError(hr);
}/* end of function get_CurrentSubpictureStream */

/*************************************************************************/
/* Function: put_CurrentSubpictureStream                                 */
/* Description: Sets the current subpicture stream.                      */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::put_CurrentSubpictureStream(long lSubpictureStream){

    HRESULT hr = S_OK;

    try {

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        if(!m_pDVDControl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        if( lSubpictureStream < cgDVD_MIN_SUBPICTURE 
            || (lSubpictureStream > cgDVD_MAX_SUBPICTURE 
            && lSubpictureStream != cgDVD_ALT_SUBPICTURE)){

            throw(E_INVALIDARG);
        }/* end of if statement */
         
        RETRY_IF_IN_FPDOM(m_pDVDControl2->SelectSubpictureStream(lSubpictureStream,0,0));

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        // now enabled the subpicture stream if it is not enabled
        ULONG ulStraemsAvial = 0L, ulCurrentStrean = 0L;
        BOOL fDisabled = TRUE;
        hr = pDvdInfo2->GetCurrentSubpicture(&ulStraemsAvial, &ulCurrentStrean, &fDisabled);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        if(TRUE == fDisabled){

            hr = m_pDVDControl2->SetSubpictureState(TRUE,0,0); //turn it on
        }/* end of if statement */
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return  HandleError(hr);
}/* end of function put_CurrentSubpictureStream */

/*************************************************************************/
/* Function: get_SubpictureOn                                            */
/* Description: Gets the current subpicture status On or Off             */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_SubpictureOn(VARIANT_BOOL *pfDisplay){

    HRESULT hr = S_OK;

    try {
        
        if(NULL == pfDisplay){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */
    
        ULONG ulSubpictureStream = 0L, ulStreamsAvailable = 0L;
        BOOL fDisabled = TRUE;    

        RETRY_IF_IN_FPDOM(pDvdInfo2->GetCurrentSubpicture(&ulStreamsAvailable, &ulSubpictureStream, &fDisabled))
    
        if(SUCCEEDED(hr)){

            *pfDisplay = fDisabled == FALSE ? VARIANT_TRUE : VARIANT_FALSE; // compensate for -1 true in OLE
        }/* end of if statement */
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return  HandleError(hr);
}/* end of function get_SubpictureOn */

/*************************************************************************/
/* Function: put_SubpictureOn                                            */
/* Description: Turns the subpicture On or Off                           */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::put_SubpictureOn(VARIANT_BOOL fDisplay){

    HRESULT hr = S_OK;

    try {
        
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        if(!m_pDVDControl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        ULONG ulSubpictureStream = 0L, ulStreamsAvailable = 0L;
        BOOL  bIsDisabled = TRUE;    

        RETRY_IF_IN_FPDOM(pDvdInfo2->GetCurrentSubpicture(&ulStreamsAvailable, &ulSubpictureStream, &bIsDisabled ));

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        BOOL bDisplay = fDisplay == VARIANT_FALSE ? FALSE : TRUE; // compensate for -1 true in OLE

        hr = m_pDVDControl2->SetSubpictureState(bDisplay,0,0);
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return  HandleError(hr);
}/* end of function put_SubpictureOn */

/*************************************************************************/
/* Function: get_SubpictureStreamsAvailable                              */
/* Description: gets the number of streams available.                    */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_SubpictureStreamsAvailable(long *plStreamsAvailable){

    HRESULT hr = S_OK;

    try {
	    
        if (NULL == plStreamsAvailable){

            throw(E_POINTER);         
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        ULONG ulSubpictureStream = 0L;
        *plStreamsAvailable = 0L;
        BOOL  bIsDisabled = TRUE;    

        RETRY_IF_IN_FPDOM(pDvdInfo2->GetCurrentSubpicture((ULONG*)plStreamsAvailable, &ulSubpictureStream, &bIsDisabled));
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return  HandleError(hr);
}/* end of function get_SubpictureStreamsAvailable */

/*************************************************************************/
/* Function: GetSubpictureLanguage                                       */
/* Description: Gets subpicture language.                                */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_SubpictureLanguage(LONG lStream, BSTR* strSubpictLang){

    HRESULT hr = S_OK;
    LPTSTR pszString = NULL;

    try {
        if(NULL == strSubpictLang){

            throw(E_POINTER);
        }/* end of if statement */

        if(0 > lStream){

            throw(E_INVALIDARG);
        }/* end of if statement */

        if((lStream > cgDVD_MAX_SUBPICTURE 
            && lStream != cgDVD_ALT_SUBPICTURE)){

            throw(E_INVALIDARG);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        LCID lcid = _UI32_MAX;

        hr = pDvdInfo2->GetSubpictureLanguage(lStream, &lcid);
        
        if (SUCCEEDED( hr ) && lcid < _UI32_MAX){

            pszString = m_LangID.GetLanguageFromLCID(lcid);
            if (pszString == NULL) {
                
                pszString = new TCHAR[MAX_PATH];
                TCHAR strBuffer[MAX_PATH];
                if(!::LoadString(_Module.m_hInstResource, IDS_DVD_SUBPICTURETRACK, strBuffer, MAX_PATH)){
                    delete[] pszString;
                    throw(E_UNEXPECTED);
                }/* end of if statement */

                (void)StringCchPrintf(pszString, MAX_PATH, strBuffer, lStream);
            }/* end of if statement */
#if 0
            DVD_SubpictureAttributes attr;            
            if(SUCCEEDED(pDvdInfo2->GetSubpictureAttributes(lStream, &attr))){
                
                switch(attr.LanguageExtension){
                    case DVD_SP_EXT_NotSpecified:
                    case DVD_SP_EXT_Caption_Normal:  break;
                    
                    case DVD_SP_EXT_Caption_Big:  AppendString(pszString, IDS_DVD_CAPTION_BIG, MAX_PATH ); break; 
                    case DVD_SP_EXT_Caption_Children: AppendString(pszString, IDS_DVD_CAPTION_CHILDREN, MAX_PATH ); break; 
                    case DVD_SP_EXT_CC_Normal: AppendString(pszString, IDS_DVD_CLOSED_CAPTION, MAX_PATH ); break;                 
                    case DVD_SP_EXT_CC_Big: AppendString(pszString, IDS_DVD_CLOSED_CAPTION_BIG, MAX_PATH ); break; 
                    case DVD_SP_EXT_CC_Children: AppendString(pszString, IDS_DVD_CLOSED_CAPTION_CHILDREN, MAX_PATH ); break; 
                    case DVD_SP_EXT_Forced: AppendString(pszString, IDS_DVD_CLOSED_CAPTION_FORCED, MAX_PATH ); break; 
                    case DVD_SP_EXT_DirectorComments_Normal: AppendString(pszString, IDS_DVD_DIRS_COMMNETS, MAX_PATH ); break; 
                    case DVD_SP_EXT_DirectorComments_Big: AppendString(pszString, IDS_DVD_DIRS_COMMNETS_BIG, MAX_PATH ); break; 
                    case DVD_SP_EXT_DirectorComments_Children: AppendString(pszString, IDS_DVD_DIRS_COMMNETS_CHILDREN, MAX_PATH ); break; 
                }/* end of switch statement */
            }/* end of if statement */
#endif

            USES_CONVERSION;
            *strSubpictLang = ::SysAllocString( T2W(pszString) );
            delete[] pszString;
            pszString = NULL;
        }
        else {

            *strSubpictLang = ::SysAllocString( L"");

            // hr used to be not failed and return nothing 
            if(SUCCEEDED(hr)) // remove this after gets fixed in DVDNav
                hr = E_FAIL;
        }/* end of if statement */

    }/* end of try statement */
    catch(HRESULT hrTmp){

        if (pszString) {
            delete[] pszString;
            pszString = NULL;
        }

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        if (pszString) {
            delete[] pszString;
            pszString = NULL;
        }

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function GetSubpictureLanguage */

/*************************************************************************/
/* Function: get_AudioStreamsAvailable                                   */
/* Description: Gets number of available Audio Streams                   */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_AudioStreamsAvailable(long *plNumAudioStreams){

    HRESULT hr = S_OK;

    try {
        
        if(NULL == plNumAudioStreams){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        ULONG ulCurrentStream;

        RETRY_IF_IN_FPDOM(pDvdInfo2->GetCurrentAudio((ULONG*)plNumAudioStreams, &ulCurrentStream));
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function get_AudioStreamsAvailable */

/*************************************************************************/
/* Function: get_CurrentAudioStream                                      */
/* Description: Gets current audio stream.                               */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_CurrentAudioStream(long *plCurrentStream){

    HRESULT hr = S_OK;

    try {
        
        if(NULL == plCurrentStream){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        ULONG ulNumAudioStreams;

        RETRY_IF_IN_FPDOM(pDvdInfo2->GetCurrentAudio(&ulNumAudioStreams, (ULONG*)plCurrentStream ));
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function get_CurrentAudioStream */

/*************************************************************************/
/* Function: put_CurrentAudioStream                                      */
/* Description: Changes the current audio stream.                        */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::put_CurrentAudioStream(long lAudioStream){

    HRESULT hr = S_OK;

    try {
        
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDVDControl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        RETRY_IF_IN_FPDOM(m_pDVDControl2->SelectAudioStream(lAudioStream,0,0));            
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function put_CurrentAudioStream */

/*************************************************************************/
/* Function: get_CurrentAngle                                            */
/* Description: Gets current angle.                                      */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_CurrentAngle(long *plAngle){

    HRESULT hr = S_OK;

    try {
        if(NULL == plAngle){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        ULONG ulAnglesAvailable = 0;
        RETRY_IF_IN_FPDOM(pDvdInfo2->GetCurrentAngle(&ulAnglesAvailable, (ULONG*)plAngle));
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function get_CurrentAngle */

/*************************************************************************/
/* Function: put_CurrentAngle                                            */
/* Description: Sets the current angle (different DVD angle track.)      */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::put_CurrentAngle(long lAngle){

    HRESULT hr = S_OK;

    try {
        if( lAngle < cgDVD_MIN_ANGLE || lAngle > cgDVD_MAX_ANGLE ){

            throw(E_INVALIDARG);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY

        if(!m_pDVDControl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */
      
        RETRY_IF_IN_FPDOM(m_pDVDControl2->SelectAngle(lAngle,0,0));          
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function put_CurrentAngle */

/*************************************************************************/
/* Function: get_AnglesAvailable                                         */
/* Description: Gets the number of angles available.                     */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_AnglesAvailable(long *plAnglesAvailable){

    HRESULT hr = S_OK;

    try {
        if(NULL == plAnglesAvailable){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        ULONG ulCurrentAngle = 0;
        RETRY_IF_IN_FPDOM(pDvdInfo2->GetCurrentAngle((ULONG*)plAnglesAvailable, &ulCurrentAngle));
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function get_AnglesAvailable */

/*************************************************************************/
/* Function: get_DVDUniqueID                                             */
/* Description: Gets the UNIQUE ID that identifies the string.           */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_DVDUniqueID(BSTR *pStrID){

    HRESULT hr = E_FAIL;

    try {
        // TODO: Be able to get m_pDvdInfo2 without initializing the graph
	    if (NULL == pStrID){

            throw(E_POINTER);         
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE
        
        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        ULONGLONG ullUniqueID;

        hr = pDvdInfo2->GetDiscID(NULL, &ullUniqueID);
                                 
        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        //TODO: Get rid of the STDLIB call!!
        // taken out of WMP

        // Script can't handle a 64 bit value so convert it to a string.
        // Doc's say _ui64tow returns 33 bytes (chars?) max.
        // we'll use double that just in case...
        //
        WCHAR wszBuffer[66];
        _ui64tow( ullUniqueID, wszBuffer, 10);
        *pStrID = SysAllocString(wszBuffer);

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);
}/* end of function get_DVDUniqueID */

/*************************************************************************/
/* Function: AcceptParentalLevelChange                                   */
/* Description: Accepts the temprary parental level change that is       */
/* done on the fly.                                                      */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::AcceptParentalLevelChange(VARIANT_BOOL fAccept, BSTR strUserName, BSTR strPassword){

    // Comfirm password first 
    if (m_pDvdAdmin == NULL) {

        throw(E_UNEXPECTED);
    } /* end of if statement */

    VARIANT_BOOL fRight;
    HRESULT hr = m_pDvdAdmin->ConfirmPassword(NULL, strPassword, &fRight);

    // if password is wrong and want to accept, no 
    if (fAccept != VARIANT_FALSE && fRight == VARIANT_FALSE)
        return E_ACCESSDENIED;

    try {  
        // should not make sense to do initialization here, since this should
        // be a response to a callback
        //INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDVDControl2){
            
            throw(E_UNEXPECTED); 
        }/* end of if statement */

        hr = m_pDVDControl2->AcceptParentalLevelChange(VARIANT_FALSE == fAccept? FALSE : TRUE);
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function AcceptParentalLevelChange */

/*************************************************************************/
/* Function: put_NotifyParentalLevelChange                               */
/* Description: Sets the flag if to notify when parental level change    */
/* notification is required on the fly.                                  */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::NotifyParentalLevelChange(VARIANT_BOOL fNotify){

	HRESULT hr = S_OK;

    try {
        //TODO: Add IE parantal level control
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDVDControl2){
            
            throw(E_UNEXPECTED); 
        }/* end of if statement */

        hr = m_pDVDControl2->SetOption(DVD_NotifyParentalLevelChange,
                          VARIANT_FALSE == fNotify? FALSE : TRUE);
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function NotifyParentalLevelChange */

/*************************************************************************/
/* Function: SelectParentalCountry                                       */
/* Description: Selects Parental Country.                                */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::SelectParentalCountry(long lCountry, BSTR strUserName, BSTR strPassword){

    HRESULT hr = S_OK;

    try {

        if(lCountry < 0 && lCountry > 0xffff){

            throw(E_INVALIDARG);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        // Confirm password first
        if (m_pDvdAdmin == NULL) {

            throw(E_UNEXPECTED);
        }/* end of if statement */

        VARIANT_BOOL temp;
        hr = m_pDvdAdmin->ConfirmPassword(NULL, strPassword, &temp);
        if (temp == VARIANT_FALSE)
            throw (E_ACCESSDENIED);

        hr = SelectParentalCountry(lCountry);

    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

    return HandleError(hr);
}

/*************************************************************************/
/* Function: SelectParentalCountry                                       */
/* Description: Selects Parental Country.                                */
/*************************************************************************/
HRESULT CMSVidWebDVD::SelectParentalCountry(long lCountry){

    HRESULT hr = S_OK;
    try {

        if(!m_pDVDControl2){
            
            throw(E_UNEXPECTED); 
        }/* end of if statement */

        BYTE bCountryCode[2];

        bCountryCode[0] = BYTE(lCountry>>8);
        bCountryCode[1] = BYTE(lCountry);

        hr = m_pDVDControl2->SelectParentalCountry(bCountryCode);
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return (hr);
}/* end of function SelectParentalCountry */

/*************************************************************************/
/* Function: SelectParentalLevel                                         */
/* Description: Selects the parental level.                              */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::SelectParentalLevel(long lParentalLevel, BSTR strUserName, BSTR strPassword){

    HRESULT hr = S_OK;

    try {

        if (lParentalLevel != PARENTAL_LEVEL_DISABLED && 
           (lParentalLevel < 1 || lParentalLevel > 8)) {

            throw (E_INVALIDARG);
        } /* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        // Confirm password first
        if (m_pDvdAdmin == NULL) {

            throw(E_UNEXPECTED);
        } /* end of if statement */

        VARIANT_BOOL temp;
        hr = m_pDvdAdmin->ConfirmPassword(NULL, strPassword, &temp);
        if (temp == VARIANT_FALSE)
            throw (E_ACCESSDENIED);
    
        hr = SelectParentalLevel(lParentalLevel);

    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

    return HandleError(hr);
}

/*************************************************************************/
/* Function: SelectParentalLevel                                         */
/* Description: Selects the parental level.                              */
/*************************************************************************/
HRESULT CMSVidWebDVD::SelectParentalLevel(long lParentalLevel){

    HRESULT hr = S_OK;
    try {

        //INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDVDControl2){
            
            throw(E_UNEXPECTED); 
        }/* end of if statement */

        hr = m_pDVDControl2->SelectParentalLevel(lParentalLevel);
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return (hr);
}/* end of function SelectParentalLevel */

/*************************************************************************/
/* Function: GetTitleParentalLevels                                      */
/* Description: Gets the parental level associated with a specific title.*/
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_TitleParentalLevels(long lTitle, long *plParentalLevels){

	HRESULT hr = S_OK;

    try {
        if(NULL == plParentalLevels){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED); 
        }/* end of if statement */

        ULONG ulLevel;
        hr = pDvdInfo2->GetTitleParentalLevels(lTitle, &ulLevel); 

        if(SUCCEEDED(hr)){

            *plParentalLevels = ulLevel;
        } 
        else {

            *plParentalLevels = 0;
        }/* end of if statement */

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function GetTitleParentalLevels */

/*************************************************************************/
/* Function: GetPlayerParentalCountry                                    */
/* Description: Gets the player parental country.                        */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_PlayerParentalCountry(long *plCountryCode){

	HRESULT hr = S_OK;

    try {
        if(NULL == plCountryCode){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED); 
        }/* end of if statement */

        BYTE bCountryCode[2];
        ULONG ulLevel;
        hr = pDvdInfo2->GetPlayerParentalLevel(&ulLevel, bCountryCode); 

        if(SUCCEEDED(hr)){

            *plCountryCode = bCountryCode[0]<<8 | bCountryCode[1];
        } 
        else {

            *plCountryCode = 0;
        }/* end of if statement */

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function GetPlayerParentalCountry */

/*************************************************************************/
/*************************************************************************/
/* Function: GetPlayerParentalLevel                                      */
/* Description: Gets the player parental level.                          *
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_PlayerParentalLevel(long *plParentalLevel){
	HRESULT hr = S_OK;

    try {
        if(NULL == plParentalLevel){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED); 
        }/* end of if statement */

        ULONG ulLevel;
        BYTE bCountryCode[2];
        hr = pDvdInfo2->GetPlayerParentalLevel(&ulLevel, bCountryCode); 

        if(SUCCEEDED(hr)){
            *plParentalLevel = ulLevel;
        } 
        else {
            *plParentalLevel = 0;
        }/* end of if statement */

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function GetPlayerParentalLevel */

STDMETHODIMP CMSVidWebDVD::Eject(){
    USES_CONVERSION;
    BSTR bDrive;
    HRESULT hr = get_DVDDirectory(&bDrive);
    if(FAILED(hr)){
        return hr;
    }

	MCI_OPEN_PARMS  mciDrive;
	WCHAR*          pDrive = bDrive;
    TCHAR           szElementName[4];
	TCHAR           szAliasName[32];
	DWORD           dwFlags;
	DWORD           dwAliasCount = GetCurrentTime();
	DWORD           theMciErr;

    ZeroMemory( &mciDrive, sizeof(mciDrive) );
    mciDrive.lpstrDeviceType = (LPTSTR)MCI_DEVTYPE_CD_AUDIO;
    (void)StringCchPrintf( szElementName, sizeof(szElementName) / sizeof(szElementName[0]), TEXT("%c:"), pDrive[0] );
    (void)StringCchPrintf( szAliasName, sizeof(szAliasName) / sizeof(szAliasName[0]), TEXT("SJE%lu:"), dwAliasCount );
    mciDrive.lpstrAlias = szAliasName;

    mciDrive.lpstrDeviceType = (LPTSTR)MCI_DEVTYPE_CD_AUDIO;
    mciDrive.lpstrElementName = szElementName;
    dwFlags = MCI_OPEN_ELEMENT | MCI_OPEN_ALIAS |
	      MCI_OPEN_TYPE | MCI_OPEN_TYPE_ID | MCI_WAIT;

	// send mci command
    theMciErr = mciSendCommand(0, MCI_OPEN, dwFlags, reinterpret_cast<DWORD_PTR>(&mciDrive));

    if ( theMciErr != MMSYSERR_NOERROR ) 
		return E_UNEXPECTED;

    DWORD DevHandle = mciDrive.wDeviceID;
    if(m_bEjected==false){
        m_bEjected = true;
        ZeroMemory( &mciDrive, sizeof(mciDrive) );
        theMciErr = mciSendCommand( DevHandle, MCI_SET, MCI_SET_DOOR_OPEN, 
            reinterpret_cast<DWORD_PTR>(&mciDrive) );
        hr = theMciErr ? E_FAIL : S_OK; // zero for success
        if(FAILED(hr)){
            return hr;
        }
    }
    else{
        m_bEjected = false;
        ZeroMemory( &mciDrive, sizeof(mciDrive) );
        theMciErr = mciSendCommand( DevHandle, MCI_SET, MCI_SET_DOOR_CLOSED, 
            reinterpret_cast<DWORD_PTR>(&mciDrive) );
        hr = theMciErr ? E_FAIL : S_OK; // zero for success
        if(FAILED(hr)){
            return hr;
        }
    }
    ZeroMemory( &mciDrive, sizeof(mciDrive) );
	theMciErr = mciSendCommand( DevHandle, MCI_CLOSE, 0L, reinterpret_cast<DWORD_PTR>(&mciDrive) );
    hr = theMciErr ? E_FAIL : S_OK; // zero for success
    return hr;
}

/*************************************************************************/
/* Function: UOPValid                                                    */
/* Description: Tells if UOP is valid or not, valid means the feature is */
/* turned on.                                                            */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::UOPValid(long lUOP, VARIANT_BOOL *pfValid){

    HRESULT hr = S_OK;

    try {
        if (NULL == pfValid){
            
            throw(E_POINTER);
        }/* end of if statement */

        if ((lUOP > 24) || (lUOP < 0)){
            
            throw(E_INVALIDARG);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED); 
        }/* end of if statement */

        ULONG ulUOPS = 0;
        hr = pDvdInfo2->GetCurrentUOPS(&ulUOPS);

        *pfValid = ulUOPS & (1 << lUOP) ? VARIANT_FALSE : VARIANT_TRUE;
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);	
}/* end of function UOPValid */

/*************************************************************************/
/* Function: GetSPRM                                                     */
/* Description: Gets SPRM at the specific index.                         */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_SPRM(long lIndex, short *psSPRM){

    HRESULT hr = E_FAIL;

    try {
	    if (NULL == psSPRM){

            throw(E_POINTER);         
        }/* end of if statement */

        SPRMARRAY sprm;                
        int iArraySize = sizeof(SPRMARRAY)/sizeof(sprm[0]);

        if(0 > lIndex || iArraySize <= lIndex){

            return(E_INVALIDARG);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE
        
        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED); 
        }/* end of if statement */
        
        hr = pDvdInfo2->GetAllSPRMs(&sprm);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */
        
        *psSPRM = sprm[lIndex];            
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);
}/* end of function GetSPRM */

/*************************************************************************/
/* Function: SetGPRM                                                     */
/* Description: Sets a GPRM at index.                                    */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::put_GPRM(long lIndex, short sValue){

       HRESULT hr = S_OK;

    try {
        if(lIndex < 0){

            throw(E_INVALIDARG);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDVDControl2){
            
            throw(E_UNEXPECTED); 
        }/* end of if statement */

        hr = m_pDVDControl2->SetGPRM(lIndex, sValue, cdwDVDCtrlFlags, 0);
            
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function SetGPRM */

/*************************************************************************/
/* Function:  GetGPRM                                                    */
/* Description: Gets the GPRM at specified index                         */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_GPRM(long lIndex, short *psGPRM){

    HRESULT hr = E_FAIL;

    try {
	    if (NULL == psGPRM){

            throw(E_POINTER);         
        }/* end of if statement */

        GPRMARRAY gprm;
        int iArraySize = sizeof(GPRMARRAY)/sizeof(gprm[0]);

        if(0 > lIndex || iArraySize <= lIndex){

            return(E_INVALIDARG);
        }/* end of if statement */
    
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE
        
        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED); 
        }/* end of if statement */

        hr = pDvdInfo2->GetAllGPRMs(&gprm);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        *psGPRM = gprm[lIndex];        
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);
}/* end of function GetGPRM */

/*************************************************************************/
/* Function: GetDVDTextNumberOfLanguages                                 */
/* Description: Retrieves the number of languages available.             */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_DVDTextNumberOfLanguages(long *plNumOfLangs){

    HRESULT hr = S_OK;

    try {
        if (NULL == plNumOfLangs){
            
            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED); 
        }/* end of if statement */
        
        ULONG ulNumOfLangs;

        RETRY_IF_IN_FPDOM(pDvdInfo2->GetDVDTextNumberOfLanguages(&ulNumOfLangs));        

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        *plNumOfLangs = ulNumOfLangs;
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);	
}/* end of function GetDVDTextNumberOfLanguages */

/*************************************************************************/
/* Function: GetDVDTextNumberOfStrings                                   */
/* Description: Gets the number of strings in the partical language.     */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_DVDTextNumberOfStrings(long lLangIndex, long *plNumOfStrings){

    HRESULT hr = S_OK;

    try {
        if (NULL == plNumOfStrings){
            
            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED); 
        }/* end of if statement */

        LCID wLangCode;
        ULONG uNumOfStings;
        DVD_TextCharSet charSet;
        RETRY_IF_IN_FPDOM(pDvdInfo2->GetDVDTextLanguageInfo(lLangIndex, &uNumOfStings, &wLangCode, &charSet));        

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        *plNumOfStrings = uNumOfStings;
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);	
}/* end of function GetDVDTextNumberOfStrings */

/*************************************************************/
/* Name: GetDVDTextLanguageLCID
/* Description: Get the LCID of an index of the DVD texts
/*************************************************************/
STDMETHODIMP CMSVidWebDVD::get_DVDTextLanguageLCID(long lLangIndex, long *lcid)
{
    HRESULT hr = S_OK;

    try {
        if (NULL == lcid){
            
            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED); 
        }/* end of if statement */

        LCID wLangCode;
        ULONG uNumOfStings;
        DVD_TextCharSet charSet;
        RETRY_IF_IN_FPDOM(pDvdInfo2->GetDVDTextLanguageInfo(lLangIndex, &uNumOfStings, &wLangCode, &charSet));        

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        *lcid = wLangCode;
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);	
}/* end of function GetDVDTextLanguageLCID */

/*************************************************************************/
/* Function: GetDVDtextString                                            */
/* Description: Gets the DVD Text string at specific location.           */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_DVDTextString(long lLangIndex, long lStringIndex, BSTR *pstrText){

    HRESULT hr = S_OK;

    try {
        if (NULL == pstrText){
            
            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED); 
        }/* end of if statement */
        
        ULONG ulSize; 
        DVD_TextStringType type;
        RETRY_IF_IN_FPDOM(pDvdInfo2->GetDVDTextStringAsUnicode(lLangIndex, lStringIndex,  NULL, 0, &ulSize, &type));

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */
        
        if (ulSize == 0) {
            *pstrText = ::SysAllocString(L"");
        }

        else {
            // got the length so lets allocate a buffer of that size
            WCHAR* wstrBuff = new WCHAR[ulSize];
            
            ULONG ulActualSize;
            hr = pDvdInfo2->GetDVDTextStringAsUnicode(lLangIndex, lStringIndex,  wstrBuff, ulSize, &ulActualSize, &type);
            
            ATLASSERT(ulActualSize == ulSize);
            
            if(FAILED(hr)){
                
                delete [] wstrBuff;
                throw(hr);
            }/* end of if statement */
            
            *pstrText = ::SysAllocString(wstrBuff);
            delete [] wstrBuff;
        }/* end of if statement */

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);	
}/* end of function GetDVDtextString */

/*************************************************************************/
/* Function: GetDVDTextStringType                                        */
/* Description: Gets the type of the string at the specified location.   */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_DVDTextStringType(long lLangIndex, long lStringIndex, DVDTextStringType *pType){

    HRESULT hr = S_OK;

    try {
        if (NULL == pType){
            
            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED); 
        }/* end of if statement */

        ULONG ulTheSize;
        DVD_TextStringType type;
        RETRY_IF_IN_FPDOM(pDvdInfo2->GetDVDTextStringAsUnicode(lLangIndex, lStringIndex,  NULL, 0, &ulTheSize, &type));

        if(SUCCEEDED(hr)){

            *pType = (DVDTextStringType) type;
        }/* end of if statement */
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);	
}/* end of function GetDVDTextStringType */

/*************************************************************************/
/* Function: RegionChange                                                */
/* Description:Changes the region code.                                  */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::RegionChange(){

    USES_CONVERSION;
    HRESULT hr = S_OK;
    typedef BOOL (APIENTRY *DVDPPLAUNCHER) (HWND HWnd, CHAR DriveLetter);

    try {
#if 0
        HWND parentWnd;
        GetParentHWND(&parentWnd);
        if (NULL != parentWnd) {
            // take the container out of the top-most mode
            ::SetWindowPos(parentWnd, HWND_NOTOPMOST, 0, 0, 0, 0, 
                SWP_NOREDRAW|SWP_NOMOVE|SWP_NOSIZE);
        }
#endif
        BOOL regionChanged = FALSE;
        OSVERSIONINFO ver;
        ver.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        ::GetVersionEx(&ver);

        if (ver.dwPlatformId==VER_PLATFORM_WIN32_NT) {

                HINSTANCE dllInstance;
                DVDPPLAUNCHER dvdPPLauncher;
                TCHAR szCmdLine[MAX_PATH], szDriveLetter[4];
                LPSTR szDriveLetterA;

                //
                // tell the user why we are showing the dvd region property page
                //
                // DVDMessageBox(m_hWnd, IDS_REGION_CHANGE_PROMPT);

                hr = GetDVDDriveLetter(szDriveLetter);

                if(FAILED(hr)){

                    throw(hr);
                }/* end of if statement */

                szDriveLetterA = T2A(szDriveLetter);

                GetSystemDirectory(szCmdLine, MAX_PATH);
                (void)StringCchCat(szCmdLine, SIZEOF_CH(szCmdLine), _T("\\storprop.dll"));
        
                dllInstance = LoadLibrary (szCmdLine);
                if (dllInstance) {

                    dvdPPLauncher = (DVDPPLAUNCHER) GetProcAddress(
                        dllInstance,
                        "DvdLauncher");
                    
                    if (dvdPPLauncher) {
                        
                        regionChanged = dvdPPLauncher(NULL,
                            szDriveLetterA[0]);
                    }

                    FreeLibrary(dllInstance);
                }

        } 
        else {
#if 0
            // win9x code should be using complier defines rather than if0'ing it out
                INITIALIZE_GRAPH_IF_NEEDS_TO_BE

                //Get path of \windows\dvdrgn.exe and command line string
                TCHAR szCmdLine[MAX_PATH], szDriveLetter[4];
                
                hr = GetDVDDriveLetter(szDriveLetter);

                if(FAILED(hr)){

                    throw(hr);
                }/* end of if statement */

                UINT rc = GetWindowsDirectory(szCmdLine, MAX_PATH);
                if (!rc) {
                    return E_UNEXPECTED;
                }
                (void)StringCchCat(szCmdLine, SIZEOF_CH(szCmdLine), _T("\\dvdrgn.exe "));
                TCHAR strModuleName[MAX_PATH];
                lstrcpyn(strModuleName, szCmdLine, MAX_PATH);

                TCHAR csTmp[2]; ::ZeroMemory(csTmp, sizeof(TCHAR)* 2);
                csTmp[0] = szDriveLetter[0];
                (void)StringCchCat(szCmdLine, SIZEOF_CH(szCmdLine), csTmp);
        
                //Prepare and execuate dvdrgn.exe
                STARTUPINFO StartupInfo;
                PROCESS_INFORMATION ProcessInfo;
                StartupInfo.cb          = sizeof(StartupInfo);
                StartupInfo.dwFlags     = STARTF_USESHOWWINDOW;
                StartupInfo.wShowWindow = SW_SHOW;
                StartupInfo.lpReserved  = NULL;
                StartupInfo.lpDesktop   = NULL;
                StartupInfo.lpTitle     = NULL;
                StartupInfo.cbReserved2 = 0;
                StartupInfo.lpReserved2 = NULL;
                if( ::CreateProcess(strModuleName, szCmdLine, NULL, NULL, TRUE, NORMAL_PRIORITY_CLASS,
                                                  NULL, NULL, &StartupInfo, &ProcessInfo) ){

                        //Wait dvdrgn.exe finishes.
                        WaitForSingleObject(ProcessInfo.hProcess, INFINITE);
                        DWORD dwRet = 1;
                        BOOL bRet = GetExitCodeProcess(ProcessInfo.hProcess, &dwRet);
                        if(dwRet == 0){
                            //User changed the region successfully
                            regionChanged = TRUE;
    
                        }
                        else{
                            throw(E_REGION_CHANGE_NOT_COMPLETED);
                        }
                }/* end of if statement */
#endif
        }/* end of if statement */

        if (regionChanged) {

                // start playing again
                INITIALIZE_GRAPH_IF_NEEDS_TO_BE                      
        } 
        else {

            throw(E_REGION_CHANGE_FAIL);
        }/* end of if statement */
	}
    catch(HRESULT hrTmp){
        
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function RegionChange */

/*************************************************************************/
/* Function: GetDVDDriveLetter                                           */
/* Description: Gets the first three characters that denote the DVD-ROM  */
/*************************************************************************/
HRESULT CMSVidWebDVD::GetDVDDriveLetter(TCHAR* lpDrive) {

    HRESULT hr = E_FAIL;

    PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
    if(!pDvdInfo2){
        
        throw(E_UNEXPECTED);
    }/* end of if statement */
        
    WCHAR szRoot[MAX_PATH];
    ULONG ulActual;

    hr = pDvdInfo2->GetDVDDirectory(szRoot, MAX_PATH, &ulActual);

    if(FAILED(hr)){

        return(hr);
    }/* end of if statement */

    USES_CONVERSION;
    
	lstrcpyn(lpDrive, OLE2T(szRoot), 3);
    if(::GetDriveType(&lpDrive[0]) == DRIVE_CDROM){
        
		return(hr);
    }
    else {
        //possibly root=c: or drive in hard disc
        hr = E_FAIL;
        return(hr);
    }/* end of if statement */

    return(hr);
}/* end of function GetDVDDriveLetter */

/*************************************************************************/
/* Function: get_DVDAdm                                                  */
/* Description: Returns DVD admin interface.                             */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_DVDAdm(IDispatch **pVal){

    HRESULT hr = S_OK;

    try {

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if (m_pDvdAdmin){

            hr = m_pDvdAdmin->QueryInterface(IID_IDispatch, (LPVOID*)pVal);
        }
        else {

            *pVal = NULL;            
            throw(E_FAIL);
        }/* end of if statement */
    
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function get_DVDAdm */


/*************************************************************/
/* Name: SelectDefaultAudioLanguage
/* Description: 
/*************************************************************/
STDMETHODIMP CMSVidWebDVD::SelectDefaultAudioLanguage(long lang, long ext){

    HRESULT hr = S_OK;
    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDVDControl2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        hr = m_pDVDControl2->SelectDefaultAudioLanguage(lang, (DVD_AUDIO_LANG_EXT)ext);
        if (FAILED(hr))
            throw(hr);
    }

    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
    return HandleError(hr);
}

/*************************************************************/
/* Name: SelectDefaultSubpictureLanguage
/* Description: 
/*************************************************************/
STDMETHODIMP CMSVidWebDVD::SelectDefaultSubpictureLanguage(long lang, DVDSPExt ext){

    HRESULT hr = S_OK;
    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDVDControl2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        hr = m_pDVDControl2->SelectDefaultSubpictureLanguage(lang, (DVD_SUBPICTURE_LANG_EXT)ext);
        if (FAILED(hr))
            throw(hr);
    }

    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
    return HandleError(hr);
}

/*************************************************************/
/* Name: get_DefaultMenuLanguage
/* Description: 
/*************************************************************/
STDMETHODIMP CMSVidWebDVD::get_DefaultMenuLanguage(long *lang)
{
    HRESULT hr = S_OK;
    try {

        if(NULL == lang){

            throw (E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE
        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        hr = pDvdInfo2->GetDefaultMenuLanguage((LCID*)lang);
        if (FAILED(hr))
            throw(hr);
    }

    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
    return HandleError(hr);
}

/*************************************************************/
/* Name: put_DefaultMenuLanguage
/* Description: 
/*************************************************************/
STDMETHODIMP CMSVidWebDVD::put_DefaultMenuLanguage(long lang){

    HRESULT hr = S_OK;
    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDVDControl2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        hr = m_pDVDControl2->SelectDefaultMenuLanguage(lang);
        if (FAILED(hr))
            throw(hr);
    }

    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
    return HandleError(hr);
}

/*************************************************************************/
/* Function: get_PreferredSubpictureStream                                    */
/* Description: Gets current audio stream.                               */
/*************************************************************************/
STDMETHODIMP CMSVidWebDVD::get_PreferredSubpictureStream(long *plPreferredStream){

    HRESULT hr = S_OK;

    try {
	    if (NULL == plPreferredStream){

            throw(E_POINTER);         
        }/* end of if statement */

        if(!m_pDvdAdmin){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        LCID langDefaultSP;
        m_pDvdAdmin->get_DefaultSubpictureLCID((long*)&langDefaultSP);
        
        // if none has been set
        if (langDefaultSP == (LCID) -1) {
            
            *plPreferredStream = 0;
            return hr;
        } /* end of if statement */
        
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE
            
        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */
        
        USES_CONVERSION;
        LCID lcid = 0;
        
        ULONG ulNumAudioStreams = 0;
        ULONG ulCurrentStream = 0;
        BOOL  fDisabled = TRUE;
        RETRY_IF_IN_FPDOM(pDvdInfo2->GetCurrentSubpicture(&ulNumAudioStreams, &ulCurrentStream, &fDisabled));
        
        *plPreferredStream = 0;
        for (ULONG i = 0; i<ulNumAudioStreams; i++) {
            hr = pDvdInfo2->GetSubpictureLanguage(i, &lcid);
            if (SUCCEEDED( hr ) && lcid){
                if (lcid == langDefaultSP) {
                    *plPreferredStream = i;
                }
            }
        }
    }
    
    catch(HRESULT hrTmp){
        return hrTmp;
    }/* end of catch statement */

    catch(...){
        return E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}

/*************************************************************/
/* Name: get_DefaultSubpictureLanguage
/* Description: 
/*************************************************************/
STDMETHODIMP CMSVidWebDVD::get_DefaultSubpictureLanguage(long *lang)
{
    HRESULT hr = S_OK;
    try {

        if(NULL == lang){

            throw (E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE
        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        long ext;
        hr = pDvdInfo2->GetDefaultSubpictureLanguage((LCID*)lang, (DVD_SUBPICTURE_LANG_EXT*)&ext);
        if (FAILED(hr))
            throw(hr);
    }

    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
    return HandleError(hr);
}

/*************************************************************/
/* Name: get_DefaultSubpictureLanguageExt
/* Description: 
/*************************************************************/
STDMETHODIMP CMSVidWebDVD::get_DefaultSubpictureLanguageExt(DVDSPExt *ext)
{
    HRESULT hr = S_OK;
    try {

        if(NULL == ext){

            throw (E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE
        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        long lang;
        hr = pDvdInfo2->GetDefaultSubpictureLanguage((LCID*)&lang, (DVD_SUBPICTURE_LANG_EXT*)ext);
        if (FAILED(hr))
            throw(hr);
    }

    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
    return HandleError(hr);
}

/*************************************************************/
/* Name: get_DefaultAudioLanguage
/* Description: 
/*************************************************************/
STDMETHODIMP CMSVidWebDVD::get_DefaultAudioLanguage(long *lang)
{
    HRESULT hr = S_OK;
    try {

        if(NULL == lang){

            throw (E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE
        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        long ext;
        hr = pDvdInfo2->GetDefaultAudioLanguage((LCID*)lang, (DVD_AUDIO_LANG_EXT*)&ext);
        if (FAILED(hr))
            throw(hr);
    }

    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
    return HandleError(hr);
}

/*************************************************************/
/* Name: get_DefaultAudioLanguageExt
/* Description: 
/*************************************************************/
STDMETHODIMP CMSVidWebDVD::get_DefaultAudioLanguageExt(long *ext)
{
    HRESULT hr = S_OK;
    try {

        if(NULL == ext){

            throw (E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        long lang;
        hr = pDvdInfo2->GetDefaultAudioLanguage((LCID*)&lang, (DVD_AUDIO_LANG_EXT*)ext);
        if (FAILED(hr))
            throw(hr);
    }

    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
    return HandleError(hr);
}

/*************************************************************/
/* Name: GetLanguageFromLCID
/* Description: 
/*************************************************************/
STDMETHODIMP CMSVidWebDVD::get_LanguageFromLCID(long lcid, BSTR* lang)
{
    HRESULT hr = S_OK;

    try {
        if (lang == NULL) {

            throw(E_POINTER);
        }/* end of if statement */

        USES_CONVERSION;

        LPTSTR pszString = m_LangID.GetLanguageFromLCID(lcid);
    
        if (pszString) {
            *lang = ::SysAllocString(T2OLE(pszString));
            delete[] pszString;
        }
        
        else {
            *lang = ::SysAllocString( L"");
            throw(E_NOTIMPL);
        }/* end of if statement */

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return HandleError(hr);
}

/*************************************************************/
/* Name: get_KaraokeAudioPresentationMode
/* Description: 
/*************************************************************/
STDMETHODIMP CMSVidWebDVD::get_KaraokeAudioPresentationMode(long *pVal)
{
    HRESULT hr = S_OK;

    try {

        if (NULL == pVal) {

            throw (E_POINTER);
        } /* end of if statement */

        *pVal = m_lKaraokeAudioPresentationMode;

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}

/*************************************************************/
/* Name: put_KaraokeAudioPresentationMode
/* Description: 
/*************************************************************/
STDMETHODIMP CMSVidWebDVD::put_KaraokeAudioPresentationMode(long newVal)
{
    HRESULT hr = S_OK;

    try {

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDVDControl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */        

        RETRY_IF_IN_FPDOM(m_pDVDControl2->SelectKaraokeAudioPresentationMode((ULONG)newVal));

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        // Cache the value
        m_lKaraokeAudioPresentationMode = newVal;

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}

/*************************************************************/
/* Name: GetKaraokeChannelContent
/* Description: 
/*************************************************************/
STDMETHODIMP CMSVidWebDVD::get_KaraokeChannelContent(long lStream, long lChan, long *lContent)
{
    HRESULT hr = S_OK;

    try {
        if(!lContent){
            return E_POINTER;
        }   
        if(lStream < 0){

            throw(E_INVALIDARG);
        }/* end of if statement */

        if (lChan >=8 || lChan < 0 ) {

            throw(E_INVALIDARG);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        DVD_KaraokeAttributes attrib;
        RETRY_IF_IN_FPDOM(pDvdInfo2->GetKaraokeAttributes(lStream, &attrib));

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        *lContent = (long)attrib.wChannelContents[lChan];

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}

/*************************************************************/
/* Name: GetKaraokeChannelAssignment
/* Description: 
/*************************************************************/
STDMETHODIMP CMSVidWebDVD::get_KaraokeChannelAssignment(long lStream, long *lChannelAssignment)
{
    HRESULT hr = S_OK;

    try {
        if(!lChannelAssignment){
            return E_POINTER;
        }
        if(lStream < 0){

            throw(E_INVALIDARG);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        DVD_KaraokeAttributes attrib;
        RETRY_IF_IN_FPDOM(pDvdInfo2->GetKaraokeAttributes(lStream, &attrib));

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        *lChannelAssignment = (long)attrib.ChannelAssignment;

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}


STDMETHODIMP CMSVidWebDVD::OnEventNotify(long lEvent, LONG_PTR lParam1, LONG_PTR lParam2) {
    if (lEvent == EC_STEP_COMPLETE || (lEvent > EC_DVDBASE && lEvent <= EC_DVD_KARAOKE_MODE) ) {
        return OnDVDEvent(lEvent, lParam1, lParam2);
    }

    if(lEvent == EC_STATE_CHANGE && lParam1 == State_Running){
        VARIANT_BOOL onStop;
        HRESULT hr = m_pDvdAdmin->get_BookmarkOnStop(&onStop);
        if(FAILED(hr)){
            throw(hr);
        }
        if(VARIANT_TRUE == onStop){
            hr = RestoreBookmark();
            if(FAILED(hr)){
                throw(hr);
            }
        }
    }
    return IMSVidPBGraphSegmentImpl<CMSVidWebDVD, MSVidSEG_SOURCE, &GUID_NULL>::OnEventNotify(lEvent, lParam1, lParam2);
}

/*************************************************************/
/* Name: OnDVDEvent
/* Description: Deal with DVD events
/*************************************************************/
STDMETHODIMP CMSVidWebDVD::OnDVDEvent(long lEvent, LONG_PTR lParam1, LONG_PTR lParam2)
{
    if (m_fFireNoSubpictureStream) {
        m_fFireNoSubpictureStream = FALSE;
        lEvent = EC_DVD_ERROR;
        lParam1 = DVD_ERROR_NoSubpictureStream;
        lParam2 = 0;

        VARIANT varLParam1;
        VARIANT varLParam2;

#ifdef _WIN64
        varLParam1.llVal = lParam1;
        varLParam1.vt = VT_I8;
        varLParam2.llVal = lParam2;
        varLParam2.vt = VT_I8;
#else
        varLParam1.lVal = lParam1;
        varLParam1.vt = VT_I4;
        varLParam2.lVal = lParam2;
        varLParam2.vt = VT_I4;
#endif

        // fire the event now after we have processed it internally
        Fire_DVDNotify(lEvent, varLParam1, varLParam2);        
    }

    
    ATLTRACE(TEXT("CMSVidWebDVD::OnDVDEvent %x\n"), lEvent-EC_DVDBASE);
    switch (lEvent){
    //
    // First the DVD error events
    //
    case EC_DVD_ERROR:
        switch (lParam1){
            
        case DVD_ERROR_Unexpected:
            break ;
            
        case DVD_ERROR_CopyProtectFail:
            break ;
            
        case DVD_ERROR_InvalidDVD1_0Disc:
            break ;
            
        case DVD_ERROR_InvalidDiscRegion:
            PreStop();
            PostStop();
            break ;
            
        case DVD_ERROR_LowParentalLevel:
            break ;
            
        case DVD_ERROR_MacrovisionFail:
            break ;
            
        case DVD_ERROR_IncompatibleSystemAndDecoderRegions:
            break ;
            
        case DVD_ERROR_IncompatibleDiscAndDecoderRegions:
            break ;
        }
        break;

    //
    // Next the normal DVD related events
    //
    case EC_DVD_VALID_UOPS_CHANGE:
    {
        VALID_UOP_SOMTHING_OR_OTHER validUOPs = (DWORD) lParam1;
        if (validUOPs&UOP_FLAG_Play_Title_Or_AtTime) {
            Fire_PlayAtTimeInTitle(VARIANT_FALSE);
            Fire_PlayAtTime(VARIANT_FALSE);
        }
        else {
            Fire_PlayAtTimeInTitle(VARIANT_TRUE);
            Fire_PlayAtTime(VARIANT_TRUE);
        }
            
        if (validUOPs&UOP_FLAG_Play_Chapter) {
            Fire_PlayChapterInTitle(VARIANT_FALSE);
            Fire_PlayChapter(VARIANT_FALSE);
        }
        else {
            Fire_PlayChapterInTitle(VARIANT_TRUE);
            Fire_PlayChapter(VARIANT_TRUE);
        }

        if (validUOPs&UOP_FLAG_Play_Title){
            Fire_PlayTitle(VARIANT_FALSE);
            
        }
        else {
            Fire_PlayTitle(VARIANT_TRUE);
        }

        if (validUOPs&UOP_FLAG_Stop)
            Fire_Stop(VARIANT_FALSE);
        else
            Fire_Stop(VARIANT_TRUE);

        if (validUOPs&UOP_FLAG_ReturnFromSubMenu)
            Fire_ReturnFromSubmenu(VARIANT_FALSE);
        else
            Fire_ReturnFromSubmenu(VARIANT_TRUE);

        
        if (validUOPs&UOP_FLAG_Play_Chapter_Or_AtTime) {
            Fire_PlayAtTimeInTitle(VARIANT_FALSE);
            Fire_PlayChapterInTitle(VARIANT_FALSE);
        }
        else {
            Fire_PlayAtTimeInTitle(VARIANT_TRUE);
            Fire_PlayChapterInTitle(VARIANT_TRUE);
        }

        if (validUOPs&UOP_FLAG_PlayPrev_Or_Replay_Chapter){

            Fire_PlayPrevChapter(VARIANT_FALSE);
            Fire_ReplayChapter(VARIANT_FALSE);
        }                    
        else {
            Fire_PlayPrevChapter(VARIANT_TRUE);
            Fire_ReplayChapter(VARIANT_TRUE);
        }/* end of if statement */

        if (validUOPs&UOP_FLAG_PlayNext_Chapter)
            Fire_PlayNextChapter(VARIANT_FALSE);
        else
            Fire_PlayNextChapter(VARIANT_TRUE);

        if (validUOPs&UOP_FLAG_Play_Forwards)
            Fire_PlayForwards(VARIANT_FALSE);
        else
            Fire_PlayForwards(VARIANT_TRUE);
        
        if (validUOPs&UOP_FLAG_Play_Backwards)
            Fire_PlayBackwards(VARIANT_FALSE);
        else 
            Fire_PlayBackwards(VARIANT_TRUE);
                        
        if (validUOPs&UOP_FLAG_ShowMenu_Title) 
            Fire_ShowMenu(dvdMenu_Title, VARIANT_FALSE);
        else 
            Fire_ShowMenu(dvdMenu_Title, VARIANT_TRUE);
            
        if (validUOPs&UOP_FLAG_ShowMenu_Root) 
            Fire_ShowMenu(dvdMenu_Root, VARIANT_FALSE);
        else
            Fire_ShowMenu(dvdMenu_Root, VARIANT_TRUE);
        
        //TODO: Add the event for specific menus
        
        if (validUOPs&UOP_FLAG_ShowMenu_SubPic)
            Fire_ShowMenu(dvdMenu_Subpicture, VARIANT_FALSE);
        else
            Fire_ShowMenu(dvdMenu_Subpicture, VARIANT_TRUE);
        
        if (validUOPs&UOP_FLAG_ShowMenu_Audio)
            Fire_ShowMenu(dvdMenu_Audio, VARIANT_FALSE);
        else
            Fire_ShowMenu(dvdMenu_Audio, VARIANT_TRUE);
            
        if (validUOPs&UOP_FLAG_ShowMenu_Angle)
            Fire_ShowMenu(dvdMenu_Angle, VARIANT_FALSE);
        else
            Fire_ShowMenu(dvdMenu_Angle, VARIANT_TRUE);

            
        if (validUOPs&UOP_FLAG_ShowMenu_Chapter)
            Fire_ShowMenu(dvdMenu_Chapter, VARIANT_FALSE);
        else
            Fire_ShowMenu(dvdMenu_Chapter, VARIANT_TRUE);

        
        if (validUOPs&UOP_FLAG_Resume)
            Fire_Resume(VARIANT_FALSE);
        else
            Fire_Resume(VARIANT_TRUE);
        
        if (validUOPs&UOP_FLAG_Select_Or_Activate_Button)
            Fire_SelectOrActivateButton(VARIANT_FALSE);
        else 
            Fire_SelectOrActivateButton(VARIANT_TRUE);
        
        if (validUOPs&UOP_FLAG_Still_Off)
            Fire_StillOff(VARIANT_FALSE);
        else
            Fire_StillOff(VARIANT_TRUE);

        if (validUOPs&UOP_FLAG_Pause_On)
            Fire_PauseOn(VARIANT_FALSE);
        else
            Fire_PauseOn(VARIANT_TRUE);

        if (validUOPs&UOP_FLAG_Select_Audio_Stream)
            Fire_ChangeCurrentAudioStream(VARIANT_FALSE);
        else
            Fire_ChangeCurrentAudioStream(VARIANT_TRUE);
        
        if (validUOPs&UOP_FLAG_Select_SubPic_Stream)
            Fire_ChangeCurrentSubpictureStream(VARIANT_FALSE);
        else
            Fire_ChangeCurrentSubpictureStream(VARIANT_TRUE);
        
        if (validUOPs&UOP_FLAG_Select_Angle)
            Fire_ChangeCurrentAngle(VARIANT_FALSE);
        else
            Fire_ChangeCurrentAngle(VARIANT_TRUE);

        /*
        if (validUOPs&UOP_FLAG_Karaoke_Audio_Pres_Mode_Change)
            ;
        if (validUOPs&UOP_FLAG_Video_Pres_Mode_Change)
            ;
        */
        }
        break;


    case EC_DVD_STILL_ON:
        m_fStillOn = true;    
        break ;
        
    case EC_DVD_STILL_OFF:                
        m_fStillOn = false;
        break ;
        
    case EC_DVD_DOMAIN_CHANGE:
        
        switch (lParam1){
            
        case DVD_DOMAIN_FirstPlay: // = 1
            //case DVD_DOMAIN_VideoManagerMenu:  // = 2
            break;
            
        case DVD_DOMAIN_Stop:       // = 5
        case DVD_DOMAIN_VideoManagerMenu:  // = 2                    
        case DVD_DOMAIN_VideoTitleSetMenu: // = 3
        case DVD_DOMAIN_Title:      // = 4
        default:
            break;
        }/* end of switch case */
        break ;
        
    case EC_DVD_BUTTON_CHANGE:                       
        break;
        
    case EC_DVD_CHAPTER_START:              
        break ;
        
    case EC_DVD_CURRENT_TIME: 
        //ATLTRACE(TEXT("Time event \n"));
        break;
        
    //
    // Then the general DirectShow related events
    //
    case EC_DVD_PLAYBACK_STOPPED:
        // DShow doesn't stop on end; we should do that
        // call PostStop to make sure graph is stopped properly
        //PostStop();
        break;
        
    case EC_DVD_DISC_EJECTED:
        m_bEjected = true;
        break;

    case EC_DVD_DISC_INSERTED:
        m_bEjected = false;
        break;
        
    case EC_STEP_COMPLETE:                
        m_fStepComplete = true;
        break;
        
    case EC_DVD_PLAYBACK_RATE_CHANGE:
        m_Rate = lParam1 / 10000;
        break;

    default:
        break ;
    }/* end of switch case */
        
    VARIANT varLParam1;
    VARIANT varLParam2;

#ifdef _WIN64
        varLParam1.llVal = lParam1;
        varLParam1.vt = VT_I8;
        varLParam2.llVal = lParam2;
        varLParam2.vt = VT_I8;
#else
        varLParam1.lVal = lParam1;
        varLParam1.vt = VT_I4;
        varLParam2.lVal = lParam2;
        varLParam2.vt = VT_I4;
#endif

        // fire the event now after we have processed it internally
        Fire_DVDNotify(lEvent, varLParam1, varLParam2);

    return NOERROR;
}

/*************************************************************/
/* Name: RestorePreferredSettings
/* Description: 
/*************************************************************/
HRESULT CMSVidWebDVD::RestorePreferredSettings()
{
    HRESULT hr = S_OK;
    try {

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE
        
        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        // get the curent domain
        DVD_DOMAIN domain;
        
        hr = pDvdInfo2->GetCurrentDomain(&domain);
        
        if(FAILED(hr)){
            
            throw(hr);
        }/* end of if statement */
        
        // Have to be in the stop domain
        if(DVD_DOMAIN_Stop != domain)
            throw (VFW_E_DVD_INVALIDDOMAIN);
            
        if(!m_pDvdAdmin){
            
            throw (E_UNEXPECTED);
        }/* end of if statement */
        
        long level;
        hr = m_pDvdAdmin->GetParentalLevel(&level);
        if (SUCCEEDED(hr))
            SelectParentalLevel(level);
        LCID audioLCID;
        LCID subpictureLCID;
        LCID menuLCID;
        
        hr = m_pDvdAdmin->get_DefaultAudioLCID((long*)&audioLCID);
        if (SUCCEEDED(hr))
            SelectDefaultAudioLanguage(audioLCID, 0);
        
        hr = m_pDvdAdmin->get_DefaultSubpictureLCID((long*)&subpictureLCID);
        if (SUCCEEDED(hr))
            SelectDefaultSubpictureLanguage(subpictureLCID, dvdSPExt_NotSpecified);
        
        hr = m_pDvdAdmin->get_DefaultMenuLCID((long*)&menuLCID);
        if (SUCCEEDED(hr))
            put_DefaultMenuLanguage(menuLCID);
    }
    
    catch(HRESULT hrTmp){
        
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        
        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
    return HandleError(hr);
}
HRESULT CMSVidWebDVD::get_ButtonRect(long lButton, /*[out, retval] */ IMSVidRect** pRect){
    try{
        PQDVDInfo2 pDvdInfo2 = GetDVDInfo2();
        if(!pDvdInfo2){    
            throw(E_UNEXPECTED);
        }/* end of if statement */
        if(!pRect){
            return E_POINTER;
        }
        CRect oRect;
        HRESULT hr = pDvdInfo2->GetButtonRect( lButton, &oRect);
        if(FAILED(hr)){
            return hr;
        }
        *((CRect*)(*pRect)) = oRect;
    }
    catch(...){
        return E_UNEXPECTED;
    }
    return S_OK;
}
HRESULT CMSVidWebDVD::get_DVDScreenInMouseCoordinates(/*[out, retval] */ IMSVidRect** ppRect){
    return E_NOTIMPL;
}
HRESULT CMSVidWebDVD::put_DVDScreenInMouseCoordinates(IMSVidRect* pRect){
    return E_NOTIMPL;
}

#endif //TUNING_MODEL_ONLY
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\msvidxds.cpp ===
//==========================================================================;
// MSVidXDS.cpp : Declaration of the CMSVidXDS
// copyright (c) Microsoft Corp. 1998-1999.
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#ifndef TUNING_MODEL_ONLY
#include "msvidXDS.h"
#include <winerror.h>
#include <algorithm>
#include "segimpl.h"
#include "devices.h"
#include <compimpl.h>
#include <seg.h>
#include <objectwithsiteimplsec.h>
#include "resource.h"       // main symbols



DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidXDS, CXDS)

HRESULT CXDS::Unload(void) {
    IMSVidGraphSegmentImpl<CXDS, MSVidSEG_XFORM, &GUID_NULL>::Unload();
    m_iIPSink = -1;
    return NOERROR;
}
// IMSVidGraphSegment
STDMETHODIMP CXDS::Build() {
    return NOERROR;
}

STDMETHODIMP CXDS::PreRun() {
    return NOERROR;
}

STDMETHODIMP CXDS::put_Container(IMSVidGraphSegmentContainer *pCtl){
    if (!m_fInit) {
        return CO_E_NOTINITIALIZED;
    }
    try {
        if (!pCtl) {
            return Unload();
        }

        if (m_pContainer) {
            if (!m_pContainer.IsEqualObject(VWSegmentContainer(pCtl))) {
                return Error(IDS_OBJ_ALREADY_INIT, __uuidof(IMSVidXDS), CO_E_ALREADYINITIALIZED);
            } else {
                return NO_ERROR;
            }
        }
        // DON'T addref the container.  we're guaranteed nested lifetimes
        // and an addref creates circular refcounts so we never unload.
        m_pContainer.p = pCtl;
        m_pGraph = m_pContainer.GetGraph();

        if (!m_pSystemEnum) {
            HRESULT hr = m_pSystemEnum.CoCreateInstance(CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER);
            if (FAILED(hr)) {
                return E_UNEXPECTED;
            }
        }

        PQVidCtl pqCtl;
        HRESULT hr = m_pContainer->QueryInterface(IID_IMSVidCtl, reinterpret_cast<void**>(&pqCtl));
        if(FAILED(hr)){
            return hr;
        }

        PQFeatures activeFeat;
        hr = pqCtl->get_FeaturesActive(&activeFeat);
        if(FAILED(hr)){
            return hr;
        }

        CFeatures* pC = static_cast<CFeatures *>(activeFeat.p);
        DeviceCollection::iterator i;
        // Check to see if data services is active, if it is not find and load the cc codec
        for(i = pC->m_Devices.begin(); i != pC->m_Devices.end(); ++i){
            if(VWGraphSegment(*i).ClassID() == CLSID_MSVidDataServices){
                break;
            }
        }

        DSFilter ccDec;
        DSPin ccDecPin;
        if(i == pC->m_Devices.end()){
            DSDevices codeclist(m_pSystemEnum, KSCATEGORY_VBICODEC);
            DSMediaType mtL21(MEDIATYPE_AUXLine21Data, MEDIASUBTYPE_Line21_BytePair);
            for(DSDevices::iterator n = codeclist.begin(); n != codeclist.end() && !ccDec; ++n){
                DSFilter codecFilter = m_pGraph.AddMoniker((*n));
                for(DSFilter::iterator codecPin = codecFilter.begin(); codecPin != codecFilter.end(); ++codecPin){
                    if((*codecPin).GetDirection() == PINDIR_OUTPUT){
                        for(DSPin::iterator codecMediaType = (*codecPin).begin(); codecMediaType != (*codecPin).end(); ++codecMediaType){
                            if((*codecMediaType) == mtL21){
                                ccDec = codecFilter;
                                m_Filters.push_back(ccDec);
                                ccDecPin = *codecPin;                                    
                            }
                        }
                    }
                }
                if(!ccDec){
                    m_pGraph.RemoveFilter(codecFilter);
                }
            }
        }

        if(!ccDec){
            return E_UNEXPECTED;
        }

        CComBSTR xdsString(L"{C4C4C4F3-0049-4E2B-98FB-9537F6CE516D}");
        GUID2 xdsGuid(xdsString);
        // bring in xds filter
        CComPtr<IUnknown> fXDS(xdsGuid, NULL, CLSCTX_INPROC_SERVER);
        if (!fXDS) {
            TRACELM(TRACE_ERROR, "CMSVidClosedCaptioning::put_Container() can't load line 21 decoder");
            return E_FAIL;
        }

        DSFilter xdsFilter(fXDS);
        if (!xdsFilter) {
            return E_UNEXPECTED;
        }

        CString csName(_T("XDS Decoder"));
        hr = m_pGraph.AddFilter(xdsFilter, csName);
        if (FAILED(hr)) {
            return hr;
        }

        m_Filters.push_back(xdsFilter);    
        DSFilterList intermediates;
        hr = m_pGraph.Connect(ccDec, xdsFilter, intermediates); 
        if(FAILED(hr)){
            return hr;
        }

        m_Filters.insert(m_Filters.end(), intermediates.begin(), intermediates.end());
        return NOERROR;

    } catch (ComException &e) {
        return e;
    } catch(...) {
        return E_UNEXPECTED;
    }

    return NOERROR;
}

// IMSVidDevice
STDMETHODIMP CXDS::get_Name(BSTR * Name){
    if (!m_fInit) {
        return CO_E_NOTINITIALIZED;
    }
    try {
        return CComBSTR("XDS Segment").CopyTo(Name);
    } catch(...) {
        return E_POINTER;
    }
}



STDMETHODIMP CXDS::InterfaceSupportsErrorInfo(REFIID riid){
    static const IID* arr[] = 
    {
        &IID_IMSVidXDS
    };
    for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++){
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}
#endif // TUNING_MODEL_ONLY
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\regexthread.cpp ===
/////////////////////////////////////////////////////////////////////////////////////
// RegExThread.cpp : Implementation of CRegExThread
// Copyright (c) Microsoft Corporation 1999.

#include "stdafx.h"
#include "RegExThread.h"

namespace BDATuningModel {


// --- CBaseThread ----------------------




// when the thread starts, it calls this function. We unwrap the 'this'
//pointer and call ThreadProc.
DWORD WINAPI
CBaseThread::InitialThreadProc(LPVOID pv)
{
    CBaseThread * pThread = (CBaseThread *) pv;

    HRESULT hrCoInit = CBaseThread::CoInitializeHelper(pThread->m_dwCoInitFlags);
    if(FAILED(hrCoInit)) {
        return hrCoInit;
    }


    HRESULT hr = pThread->ThreadProc();

    if(SUCCEEDED(hrCoInit)) {
        CoUninitialize();
    }

    return hr;
}

BOOL
CBaseThread::Create()
{
    DWORD threadid;

    CAutoLock lock(&m_AccessLock);

    if (ThreadExists()) {
	return FALSE;
    }

    m_hThread = CreateThread(
		    NULL,
		    0,
		    CBaseThread::InitialThreadProc,
		    this,
		    0,
		    &threadid);

    if (!m_hThread) {
	return FALSE;
    }

    return TRUE;
}

DWORD
CBaseThread::CallWorker(DWORD dwParam)
{
    // lock access to the worker thread for scope of this object
    CAutoLock lock(&m_AccessLock);

    if (!ThreadExists()) {
		return (DWORD) E_FAIL;
    }

    // set the parameter
    m_dwParam = dwParam;

	m_dwReturnVal = 0;
    // signal the worker thread
    m_EventSend.Set();

    // wait for the completion to be signalled or the thread to terminate
	HANDLE h[2];
	h[0] = m_EventComplete;
	h[1] = m_hThread;
	DWORD rc = WaitForMultipleObjects(2, h, 0, INFINITE);

    // done - this is the thread's return value
    return m_dwReturnVal;
}


#if 0
// Wait for a request from the client
DWORD
CBaseThread::GetRequest()
{
    m_EventSend.Wait();
    return m_dwParam;
}
#endif

// is there a request?
BOOL
CBaseThread::CheckRequest(DWORD * pParam)
{
    if (!m_EventSend.Check()) {
	return FALSE;
    } else {
	if (pParam) {
	    *pParam = m_dwParam;
	}
	return TRUE;
    }
}

// reply to the request
void
CBaseThread::Reply(DWORD dw)
{
    m_dwReturnVal = dw;

    // The request is now complete so CheckRequest should fail from
    // now on
    //
    // This event should be reset BEFORE we signal the client or
    // the client may Set it before we reset it and we'll then
    // reset it (!)

    m_EventSend.Reset();

    // Tell the client we're finished

    m_EventComplete.Set();
}

HRESULT CBaseThread::CoInitializeHelper(DWORD dwCoInitFlags)
{
    // call CoInitializeEx and tell OLE not to create a window (this
    // thread probably won't dispatch messages and will hang on
    // broadcast msgs o/w).
    //
    // If CoInitEx is not available, threads that don't call CoCreate
    // aren't affected. Threads that do will have to handle the
    // failure. Perhaps we should fall back to CoInitialize and risk
    // hanging?
    //

    // older versions of ole32.dll don't have CoInitializeEx

    HRESULT hr = E_FAIL;
    HINSTANCE hOle = GetModuleHandle(TEXT("ole32.dll"));
    if(hOle)
    {
        typedef HRESULT (STDAPICALLTYPE *PCoInitializeEx)(
            LPVOID pvReserved, DWORD dwCoInit);
        PCoInitializeEx pCoInitializeEx =
            (PCoInitializeEx)(GetProcAddress(hOle, "CoInitializeEx"));
        if(pCoInitializeEx)
        {
            hr = (*pCoInitializeEx)(NULL, dwCoInitFlags);
        }
    }

    return hr;
}


// end of private copy of dshow stuff

};
// end of file - RegExThread.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\perfcntr.h ===
#define _100NS_IN_MS        (10*1000)
#define NANOSECONDS         10000000
#define CONVERT_PERFORMANCE_TIME(Frequency, PerformanceTime) \
    ((((ULONGLONG)(ULONG)(PerformanceTime).HighPart * NANOSECONDS / (Frequency)) << 32) + \
    ((((((ULONGLONG)(ULONG)(PerformanceTime).HighPart * NANOSECONDS) % (Frequency)) << 32) + \
    ((ULONGLONG)(PerformanceTime).LowPart * NANOSECONDS)) / (Frequency)))



#ifdef DEBUG

#include "trace.h"
#define VIDPERF(Y,X) CPerfVidCtl __cperfvidctl(Y,X);
#define VIDPERF_FUNC CPerfVidCtl __cperfvidctl(TRACE_ERROR, __FUNCTION__);
#define VIDPERF_FUNC2 CPerfVidCtl __cperfvidctl(TRACE_ALWAYS, __FUNCTION__);
class CPerfCounter
/*++

Abstract:

    This provides a simple performace counter. Simply call Start() to
    start counting.  Calling Stop() will spit out the results.  You can
    optional specify a name for your counter.

Author:

    Sam Clement (samclem) 24-Feb-2000

    Bryan A. Woodruff (bryanw) 10-Jun-2001
        Refactored for use with IOTest

    Luke W. McCullough (LukeM) 01-Jan-2002
    	Added VidCtl Specific Class and Debug state

--*/
{
public:
    CPerfCounter() : m_Name(NULL) { _Setup(); }
    explicit CPerfCounter(const char* Name) : m_Name(Name) { _Setup(); }
    ~CPerfCounter() {}

    void _Setup()
    {
        ZeroMemory(&m_StartTime, sizeof(m_StartTime));
        ZeroMemory(&m_CurrentTime, sizeof(m_CurrentTime));
        ZeroMemory(&m_CounterFreq, sizeof(m_CounterFreq));
        QueryPerformanceFrequency(&m_CounterFreq);
        QueryPerformanceCounter(&m_StartTime);
    }

    void Reset()
    {
        QueryPerformanceCounter(&m_StartTime);
    }

    LONGLONG Stop()
    {
        QueryPerformanceCounter(&m_CurrentTime);
        m_CurrentTime.QuadPart = m_CurrentTime.QuadPart - m_StartTime.QuadPart;
        m_CurrentTime.QuadPart = CONVERT_PERFORMANCE_TIME(m_CounterFreq.QuadPart, m_CurrentTime);
        return m_CurrentTime.QuadPart;
    }

    LONGLONG GetLastTime()
    {
        return m_CurrentTime.QuadPart;
    }

    void Trace()
    {
        Stop();

        (void)StringCchPrintfA(m_Outbuf, sizeof(m_Outbuf) / sizeof(m_Outbuf[0]), "\n*\n* PerfCounter: %s%s%s%ld ms\n*\n",
                (m_Name ? "(" : ""),
                (m_Name ? m_Name : ""),
                (m_Name ? ") " : ""),
                (m_CurrentTime.QuadPart / _100NS_IN_MS));

        puts( m_Outbuf );
    }

private:
    LARGE_INTEGER   m_StartTime;
    LARGE_INTEGER   m_CurrentTime;
    LARGE_INTEGER   m_CounterFreq;
    const char*     m_Name;
    char            m_Outbuf[MAX_PATH];

};

class CPerfVidCtl : public CPerfCounter{
private:
	char* dbString;
	DWORD traceLevel;
public:
	CPerfVidCtl(DWORD tLevel, char *debugString){
		traceLevel = tLevel;
		dbString = new char[strlen(debugString)+1];
		lstrcpynA(dbString, debugString, strlen(debugString)+1);
		_Setup();
		Reset();
        TRACELSM(traceLevel, (dbgDump << dbString << " : Start"), "");
	}
	~CPerfVidCtl(){
		if(!!dbString){
			LONGLONG curTime = Stop();
            TRACELSM(traceLevel, (dbgDump << dbString << " : End :" << (unsigned long)(curTime / _100NS_IN_MS) << "." << (unsigned long)(curTime % _100NS_IN_MS) << " ms"), "");
		}
		delete[] dbString;
	}

};
#else
//
// No perf counter.  Make it an empty object (should be optimized out)
//
class CPerfCounter
{
public:
    inline CPerfCounter() {}
    inline explicit CPerfCounter(const char* Name) {}
    inline ~CPerfCounter() {}
    inline void Reset() {}
    inline LONGLONG Stop() { return 0; }
    inline LONGLONG GetLastTime() { return 0; }
    inline void Trace() {}
};
#define VIDPERF(X,Y) 
#define VIDPERF_FUNC  
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\rgsbag.h ===
/////////////////////////////////////////////////////////////////////////////////////
// RGSBag.h : Declaration of the CRGSBag
// Copyright (c) Microsoft Corporation 2000.
//
// small internal class to provide readonly IPropertyBag access to a string containing
// an atl .rgs fragment

#ifndef __RGSBAG_H_
#define __RGSBAG_H_

#pragma once

#include <objectwithsiteimplsec.h>
#include <propertybag2impl.h>

namespace BDATuningModel {

using ::ATL::ATL::CRegObject;
using ::ATL::ATL::CRegParser;
        
/////////////////////////////////////////////////////////////////////////////
// CRGSBag
class ATL_NO_VTABLE DECLSPEC_UUID("7B3CAA7B-5E78-4797-95F7-BDA2FCD807A2") CRGSBagBase : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CRGSBagBase, &__uuidof(CRGSBagBase)>,
    public IObjectWithSiteImplSec<CRGSBagBase>,
	public IPropertyBag2Impl<CRGSBagBase>,
	public IPropertyBag
{
public:
    CRGSBagBase() {}
    virtual ~CRGSBagBase() {
        m_mapBag.clear();
    }

DECLARE_NOT_AGGREGATABLE(CRGSBagBase)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CRGSBagBase)
	COM_INTERFACE_ENTRY(IPropertyBag2)
	COM_INTERFACE_ENTRY(IPropertyBag)
    COM_INTERFACE_ENTRY(IObjectWithSite)
END_COM_MAP_WITH_FTM()

// IPropertyBag2
public:

// IPropertyBag
    STDMETHOD(Read)(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog) {
		if (!pVar) {
			return E_POINTER;
		}
		try {
			CString csKey(pszPropName);
			ATL_LOCK();
			RGSBag_t::iterator i = m_mapBag.find(csKey);
			if (i == m_mapBag.end()) {
				return HRESULT_FROM_WIN32(ERROR_UNKNOWN_PROPERTY);
			}
			return (*i).second.CopyTo(pVar);
        } CATCHALL();
	}
    STDMETHOD(Write)(LPCOLESTR pszPropName, VARIANT *pVar) {
		return E_NOTIMPL;
	}
    
// IPropertyBag2
	STDMETHOD(CountProperties)(ULONG * pcProperties) {
		if (!pcProperties) {
			return E_POINTER;
		}
		try {
			ATL_LOCK();
			*pcProperties = m_mapBag.size();
			return NOERROR;
        } CATCHALL();

	}
	STDMETHOD(GetPropertyInfo)(ULONG iProperty, ULONG cProperties, PROPBAG2 * pPropBag, ULONG * pcProperties) {
		return E_NOTIMPL;
	}
	STDMETHOD(LoadObject)(LPCOLESTR pstrName, ULONG dwHint, IUnknown * pUnkObject, IErrorLog * pErrLog) {
		return E_NOTIMPL;
	}

protected:
    typedef std::map<CString, CComVariant> RGSBag_t;  // id->object mapping, id's not contiguous

    RGSBag_t m_mapBag;

};


class CRGSBag : public CComObject<CRGSBagBase>,
				public CRegParser

{
public:


    CRGSBag(LPCTSTR szRGS, CRegObject& croi, int& cchEaten);  // parse string into map
	HRESULT BuildMapFromFragment(LPTSTR pszToken);
	HRESULT GetObject(CComVariant& val);
	HRESULT GetValue(CComVariant &val);

};

template<class BAGTYPE, class PERSISTTYPE> HRESULT LoadPersistedObject(PUnknown& pobj, CRegObject& cro, TCHAR** ppchCur) {
	HRESULT hr = NOERROR;
    try {
	    PERSISTTYPE pPersistObj(pobj);
	    if (!pPersistObj) {
		    return E_NOINTERFACE;
	    }
	    hr = pPersistObj->InitNew();
	    if (FAILED(hr) && hr != E_NOTIMPL) {
		    return hr;
	    }
	    int cchEaten = 0;
	    BAGTYPE pBag(new CRGSBag(*ppchCur, cro, cchEaten));
	    if (!pBag) {
		    return E_OUTOFMEMORY;
	    }
	    *ppchCur += cchEaten;
        hr = pPersistObj->Load(pBag, NULL);
        if (FAILED(hr)) {
            delete pBag;
            return hr;
        }
	    return hr;
    } CATCHALL();
};


}; // namespace
 
#endif //__RGSBAG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\regexthread.h ===
/////////////////////////////////////////////////////////////////////////////////////
// RegExThread.h : Declaration of the CSystemTuningSpaces
// Copyright (c) Microsoft Corporation 1999.

#ifndef __RegExThread_H_
#define __RegExThread_H_

#pragma once

#include "w32extend.h"
#include <regexp.h>

#define EXECUTE_ASSERT(x) x
typedef CComQIPtr<IRegExp> PQRegExp;

namespace BDATuningModel {


////////////////////////////////////////////////////////
// this is a private copy of some stuff from dshow's wxutil.h, .cpp.   i just need some of the win32 
// synchronization objects and thread stuff and i don't want to pull in all the rest of the 
// baggage in that file
// i've made some minor changes to CAMThread and renamed it to CBaseThread in order to avoid 
// any problems in the future

#ifndef __WXUTIL__
// wrapper for whatever critical section we have
class CCritSec {

    // make copy constructor and assignment operator inaccessible

    CCritSec(const CCritSec &refCritSec);
    CCritSec &operator=(const CCritSec &refCritSec);

    CRITICAL_SECTION m_CritSec;

public:
    CCritSec() {
		InitializeCriticalSection(&m_CritSec);
    };

    ~CCritSec() {
		DeleteCriticalSection(&m_CritSec);
    };

    void Lock() {
		EnterCriticalSection(&m_CritSec);
    };

    void Unlock() {
		LeaveCriticalSection(&m_CritSec);
    };
};

// locks a critical section, and unlocks it automatically
// when the lock goes out of scope
class CAutoLock {

    // make copy constructor and assignment operator inaccessible

    CAutoLock(const CAutoLock &refAutoLock);
    CAutoLock &operator=(const CAutoLock &refAutoLock);

protected:
    CCritSec * m_pLock;

public:
    CAutoLock(CCritSec * plock)
    {
        m_pLock = plock;
        m_pLock->Lock();
    };

    ~CAutoLock() {
        m_pLock->Unlock();
    };
};



// wrapper for event objects
class CAMEvent
{

    // make copy constructor and assignment operator inaccessible

    CAMEvent(const CAMEvent &refEvent);
    CAMEvent &operator=(const CAMEvent &refEvent);

protected:
    HANDLE m_hEvent;
public:
    CAMEvent(BOOL fManualReset = FALSE)
	{
		m_hEvent = CreateEvent(NULL, fManualReset, FALSE, NULL);
		ASSERT(m_hEvent);
	}
    ~CAMEvent()
	{
        HANDLE hEvent = (HANDLE)InterlockedExchangePointer(&m_hEvent, 0);
		if (hEvent) {
			EXECUTE_ASSERT(CloseHandle(hEvent));
		}
	}

    // Cast to HANDLE - we don't support this as an lvalue
    operator HANDLE () const { return m_hEvent; };

    void Set() {EXECUTE_ASSERT(SetEvent(m_hEvent));};
    BOOL Wait(DWORD dwTimeout = INFINITE) {
	return (WaitForSingleObject(m_hEvent, dwTimeout) == WAIT_OBJECT_0);
    };
    BOOL Check() { return Wait(0); };
    void Reset() { ResetEvent(m_hEvent); };
};

#endif // __WXUTIL__


// support for a worker thread

// simple thread class supports creation of worker thread, synchronization
// and communication. Can be derived to simplify parameter passing
class __declspec(novtable) CBaseThread {

    // make copy constructor and assignment operator inaccessible

    CBaseThread(const CBaseThread &refThread);
    CBaseThread &operator=(const CBaseThread &refThread);

    CAMEvent m_EventComplete;

    DWORD m_dwParam;
    DWORD m_dwReturnVal;
	DWORD m_dwCoInitFlags;

protected:
    CAMEvent m_EventSend;
    HANDLE m_hThread;

    // thread will run this function on startup
    // must be supplied by derived class
    virtual DWORD ThreadProc() = 0;

public:
    CBaseThread(DWORD dwFlags = COINIT_DISABLE_OLE1DDE) :  // standard dshow behavior
		m_EventSend(TRUE),     // must be manual-reset for CheckRequest()
		m_dwCoInitFlags(dwFlags) 
	{
		m_hThread = NULL;
	}

	virtual ~CBaseThread() {
		Close();
	}

    CCritSec m_AccessLock;	// locks access by client threads
    CCritSec m_WorkerLock;	// locks access to shared objects

    // thread initially runs this. param is actually 'this'. function
    // just gets this and calls ThreadProc
    static DWORD WINAPI InitialThreadProc(LPVOID pv);

    // start thread running  - error if already running
    BOOL Create();

    // signal the thread, and block for a response
    //
    DWORD CallWorker(DWORD);

    // accessor thread calls this when done with thread (having told thread
    // to exit)
    void Close() {
        HANDLE hThread = (HANDLE)InterlockedExchangePointer(&m_hThread, 0);
        if (hThread) {
			for (;;) {
				DWORD rc = MsgWaitForMultipleObjectsEx(1, &hThread, INFINITE, QS_ALLEVENTS, 0);
				if (rc == WAIT_OBJECT_0) {
					break;
				} else {
					// pump messages so com runs
					MSG msg;
					while(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
						TranslateMessage(&msg);
						DispatchMessage(&msg);
					}
				}
			}

            CloseHandle(hThread);
        }
    };

    // ThreadExists
    // Return TRUE if the thread exists. FALSE otherwise
    BOOL ThreadExists(void) const
    {
        if (m_hThread == 0) {
            return FALSE;
        } else {
            return TRUE;
        }
    }

#if 0
    // wait for the next request
    DWORD GetRequest();
#endif 

    // is there a request?
    BOOL CheckRequest(DWORD * pParam);

    // reply to the request
    void Reply(DWORD);

    // If you want to do WaitForMultipleObjects you'll need to include
    // this handle in your wait list or you won't be responsive
    HANDLE GetRequestHandle() const { return m_EventSend; };

    // Find out what the request was
    DWORD GetRequestParam() const { return m_dwParam; };

    // call CoInitializeEx (COINIT_DISABLE_OLE1DDE) if
    // available. S_FALSE means it's not available.
    static HRESULT CoInitializeHelper(DWORD dwCoInitFlags);
};

///////////////////////////////////////

class CRegExThread : public CBaseThread {
public:
	typedef enum OP {
		RETHREAD_NOREQUEST,
		RETHREAD_CREATEREGEX,
		RETHREAD_EXIT,
	} OP;
	
private:	
	virtual DWORD ThreadProc(void) {
		for (;;) {
			OP req = GetRequest();
			switch (req) {
			case RETHREAD_CREATEREGEX: {
				HRESULT hr = CreateRegEx();
				Reply(hr);
				if (FAILED(hr)) {
					goto exit_thread;
				}
				break;
			} case RETHREAD_EXIT:
				Reply(NOERROR);
				goto exit_thread;
			};
		};
exit_thread:
		CAutoLock lock(&m_WorkerLock);
		if (m_pGIT && m_dwCookie) {
			m_pGIT->RevokeInterfaceFromGlobal(m_dwCookie);
			m_dwCookie = 0;
			m_pGIT.Release();
		}
		return 0;
	}

	OP GetRequest() {
		HANDLE h = GetRequestHandle();
		for (;;) {
			DWORD rc = MsgWaitForMultipleObjectsEx(1, &h, INFINITE, QS_ALLEVENTS, 0);
			if (rc == WAIT_OBJECT_0) {
				return (OP)GetRequestParam();
			} else {
				// pump messages so com runs
				MSG msg;
				while(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
					TranslateMessage(&msg);
					DispatchMessage(&msg);
				}
			}

		}
	}

	HRESULT CreateRegEx() {
		CAutoLock lock(&m_WorkerLock);
		if (!m_pGIT) {
			HRESULT hr = m_pGIT.CoCreateInstance(CLSID_StdGlobalInterfaceTable, 0, CLSCTX_INPROC_SERVER);
			if (FAILED(hr)) {
				return hr;
			}
			// this is an expensive object to create.  so, once we have one we hang onto it.
			PQRegExp pRE;
			hr = pRE.CoCreateInstance(__uuidof(RegExp), NULL, CLSCTX_INPROC);
			if (FAILED(hr)) {
				return hr;
			}
			hr = pRE->put_IgnoreCase(VARIANT_TRUE);
			if (FAILED(hr)) {
				return hr;
			}
			hr = pRE->put_Global(VARIANT_TRUE);
			if (FAILED(hr)) {
				return hr;
			}
			ASSERT(!m_dwCookie);
			hr = m_pGIT->RegisterInterfaceInGlobal(pRE, __uuidof(IRegExp), &m_dwCookie);
			if (FAILED(hr)) {
				return hr;
			}
		}
		ASSERT(m_pGIT);
		ASSERT(m_dwCookie);
		return NOERROR;
	}

	PQGIT m_pGIT;
	DWORD m_dwCookie;
public:
	CRegExThread() : 
		CBaseThread(COINIT_APARTMENTTHREADED),
	    m_dwCookie(0)
			{}
	~CRegExThread() {
		CallWorker(RETHREAD_EXIT);
		Close();
	}
	DWORD GetCookie() {
		CAutoLock lock(&m_WorkerLock);
		return m_dwCookie;
	}
};  // class CRegExThread


}; // namespace BDATuningModel
 
#endif //__RegExThread_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\sbes2cc.h ===
//==========================================================================;
//
// Composition.h : Declaration of the custom composition class for gluing analog capture to ovmixer
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#ifndef SBES2CC_H
#define SBES2CC_H

#pragma once

#include <winerror.h>
#include <algorithm>
#include <compimpl.h>
#include <seg.h>
#include "resource.h"       // main symbols
#include <objectwithsiteimplsec.h>
#include "dsextend.h"

/////////////////////////////////////////////////////////////////////////////
// CSbeS2CCComp
class ATL_NO_VTABLE __declspec(uuid("9193A8F9-0CBA-400e-AA97-EB4709164576")) CSbeS2CCComp : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CSbeS2CCComp, &__uuidof(CSbeS2CCComp)>,
    public IObjectWithSiteImplSec<CSbeS2CCComp>,
	public IMSVidCompositionSegmentImpl<CSbeS2CCComp>
{
public:
    CSbeS2CCComp() {}
    virtual ~CSbeS2CCComp() {}

REGISTER_NONAUTOMATION_OBJECT(IDS_PROJNAME, 
						   IDS_REG_SBES2CC_DESC,
						   LIBID_MSVidCtlLib,
						   __uuidof(CSbeS2CCComp));

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CSbeS2CCComp)
        COM_INTERFACE_ENTRY(IMSVidCompositionSegment)
    	COM_INTERFACE_ENTRY(IMSVidGraphSegment)
        COM_INTERFACE_ENTRY(IObjectWithSite)
        COM_INTERFACE_ENTRY(IPersist)
    END_COM_MAP()

public:

	PQCreateDevEnum m_pSystemEnum;

	//////////////

// IMSVidGraphSegment
// IMSVidCompositionSegment
    STDMETHOD(Compose)(IMSVidGraphSegment * upstream, IMSVidGraphSegment * downstream)
	{
        VIDPERF_FUNC;
        if (m_fComposed) {
            return NOERROR;
        }
        ASSERT(m_pGraph);
        try {
            TRACELM(TRACE_ERROR, "CSbeS2CCComp::Compose()");
            VWGraphSegment up(upstream);
            ASSERT(up.Graph() == m_pGraph);
            VWGraphSegment down(downstream);
            ASSERT(down.Graph() == m_pGraph);
			if (upstream == downstream) {
		 	    return Error(IDS_CANT_COMPOSE_WITH_SELF, __uuidof(CSbeS2CCComp), E_INVALIDARG);
			}
            if (up.begin() == up.end()) {
                TRACELM(TRACE_ERROR, "CSbeS2CCComp::Compose() can't compose empty up segment");
		 	    return NOERROR;
            }
            if (down.begin() == down.end()) {
                TRACELM(TRACE_ERROR, "CSbeS2CCComp::Compose() can't compose empty down segment");
                // this is not an error, for example, CA is an empty segment.
		 	    return NOERROR;
            }
            // do the list backwards
            DSFilterList upF;
/*            for(VWGraphSegment::iterator upStart = up.begin(); upStart != up.end(); ++upStart){
                upF.push_back(*upStart);
            }
  */
            DSMediaType mtL21(MEDIATYPE_AUXLine21Data, MEDIASUBTYPE_Line21_BytePair);

            for (VWGraphSegment::iterator iStart = up.begin(); iStart != up.end(); ++iStart) {
                ASSERT((*iStart).GetGraph() == m_pGraph);
                DSFilter::iterator iPins;
                for(iPins = (*iStart).begin(); iPins != (*iStart).end(); ++iPins){
                    DSPin::iterator iMedias;
                    for(iMedias = (*iPins).begin(); iMedias != (*iPins).end(); ++iMedias){
                        if(mtL21 == (*iMedias)){
                            break;
                        }
                    }
                    if(iMedias != (*iPins).end()){
                        break;
                    }
                }
                if(iPins == (*iStart).end()){
                    continue;
                }
				for (VWGraphSegment::iterator iStop = down.begin(); iStop != down.end(); ++iStop) {
					ASSERT((*iStop).GetGraph() == m_pGraph);
					DSFilter pStart(*iStart);
					DSFilter pStop(*iStop);
					HRESULT hr = m_pGraph.Connect(pStart, pStop, m_Filters);
                    if (SUCCEEDED(hr)) {
						m_Segments.push_back(up);
						m_Segments.push_back(down);
						m_pDown = m_Segments.end();
						--m_pDown;
						m_pUp = m_pDown;
						--m_pUp;
						m_fComposed = true;
						return NOERROR;
					}
				}
			}
            TRACELM(TRACE_ERROR, "CSbeS2CCComp::Compose() compose didn't connect anything");
	 	    return S_FALSE;
        } catch (ComException &e) {
            return e;
        } catch (...) {
            return E_UNEXPECTED;
        }
	}
};

#endif // SBES2CC_H
// end of file - SBES2CC.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MSVidCtl.rc
//
#include "msvidctlerrors.h"
#define IDS_PROJNAME                    100
#define IDB_VidCtl                      101
#define MESSAGETABLE                    102
#define IDS_INPUTDEVICES_PROGID         243
#define IDS_OUTPUTDEVICES_PROGID        244
#define IDS_VIDEORENDERERS_PROGID       245
#define IDS_AUDIORENDERERS_PROGID       246
#define IDS_FEATURES_PROGID             247
#define IDS_INPUTDEVICES_DESCRIPTION    248
#define IDS_OUTPUTDEVICES_DESCRIPTION   249
#define IDS_VIDEORENDERERS_DESCRIPTION  250
#define IDS_AUDIORENDERERS_DESCRIPTION  251
#define IDS_FEATURES_DESCRIPTION        252
#define IDS_MUTNAME                     253
#define IDS_TSREGKEY                    254
#define IDS_REG_TUNEROBJ                1024
#define IDS_REG_COMPONENTTYPE_PROGID    1025
#define IDS_REG_COMPONENTTYPE_DESC      1026
#define IDS_REG_COMPONENT_PROGID        1027
#define IDS_REG_COMPONENT_DESC          1028
#define IDS_REG_COMPOSITION_DESC        1029
#define IDS_REG_AUDIORENDERER_PROGID    1030
#define IDS_REG_AUDIORENDERER_DESC      1031
#define IDS_REG_BDATUNER_PROGID         1032
#define IDS_REG_BDATUNER_DESC           1033
#define IDS_REG_CREATEREGBAG_DESC       1034
#define IDS_REG_FILEPLAYBACK_PROGID     1035
#define IDS_REG_FILEPLAYBACK_DESC       1036
#define IDS_REG_TVTUNER_PROGID          1037
#define IDS_REG_TVTUNER_DESC            1038
#define IDS_REG_VIDEORENDERER_PROGID    1039
#define IDS_REG_VIDEORENDERER_DESC      1040
#define IDS_REG_TUNINGSPACECONTAINER_PROGID 1041
#define IDS_REG_TUNINGSPACECONTAINER_DESC 1042
#define IDS_REG_CHANNELTUNEREQUEST_PROGID 1043
#define IDS_REG_CHANNELTUNEREQUEST_DESC 1044
#define IDS_REG_ATSCCHANNELTUNEREQUEST_PROGID 1045
#define IDS_REG_ATSCCHANNELTUNEREQUEST_DESC 1046
#define IDS_REG_COMPONENTTYPES_PROGID   1047
#define IDS_REG_COMPONENTTYPES_DESC     1048
#define IDS_REG_TVPROTOCOL_DESC         1049
#define IDS_REG_ANACAPCOMP_DESC         1050
#define IDS_REG_ANADATACOMP_DESC        1051
#define IDS_REG_DATASERVICES_PROGID     1052
#define IDS_REG_DATASERVICES_DESC       1053
#define IDS_REG_ATSCTUNINGSPACE_PROGID  1054
#define IDS_REG_ATSCTUNINGSPACE_DESC    1055
#define IDS_REG_ANALOGTVTS_PROGID       1056
#define IDS_REG_ANALOGTVTS_DESC         1057
#define IDS_REG_ANALOGRADIOTS_PROGID    1058
#define IDS_REG_ANALOGRADIOTS_DESC      1059
#define IDS_REG_LANGUAGECOMPONENTTYPE_PROGID 1060
#define IDS_REG_LANGUAGECOMPONENTTYPE_DESC 1061
#define IDS_REG_ATSCLOCATOR_PROGID      1062
#define IDS_REG_ATSCLOCATOR_DESC        1063
#define IDS_REG_MPEG2COMPONENTTYPE_PROGID 1064
#define IDS_REG_MPEG2COMPONENTTYPE_DESC 1065
#define IDS_REG_ATSCCOMPONENTTYPE_PROGID 1066
#define IDS_REG_ATSCCOMPONENTTYPE_DESC  1067
#define IDS_REG_MPEG2COMPONENT_PROGID   1068
#define IDS_REG_MPEG2COMPONENT_DESC     1069
#define IDS_REG_DVBTLOCATOR_PROGID      1070
#define IDS_REG_DVBTLOCATOR_DESC        1071
#define IDS_REG_DVBSLOCATOR_PROGID      1072
#define IDS_REG_DVBSLOCATOR_DESC        1073
#define IDS_REG_DVBTUNEREQUEST_PROGID   1074
#define IDS_REG_DVBTUNEREQUEST_DESC     1075
#define IDS_REG_DVBTUNINGSPACE_PROGID   1076
#define IDS_REG_DVBTUNINGSPACE_DESC     1077
#define IDS_TSKEYNAMEVAL                1078
#define IDS_RGSLIST_TYPE                1079
#define IDS_TUNINGSPACE_FRAGMENT_TYPE   1080
#define IDS_REG_MSVIDWEBDVD_PROGID      1081
#define IDS_REG_MSVIDWEBDVD_DESC        1082
#define IDS_REG_WEBDVDCOMP_DESC         1083
#define IDS_REG_DVDEVENTHANDLER_PROGID  1084
#define IDS_REG_DVDEVENTHANDLER_DESC    1085
#define IDS_REG_MSVIDWEBDVDADM_PROGID   1086
#define IDS_REG_MSVIDWEBDVDADM_DESC     1087
#define IDS_REG_CLOSEDCAPTIONING_PROGID 1088
#define IDS_REG_CLOSEDCAPTIONING_DESC   1089
#define IDS_REG_DVDPROTOCOL_DESC        1090
#define IDS_REG_MSEVENTBINDER_PROGID    1091
#define IDS_REG_MSEVENTBINDER_DESC      1092
#define IDS_REG_DVBSTUNINGSPACE_PROGID  1093
#define IDS_REG_DVBSTUNINGSPACE_DESC    1094
#define IDS_REG_TRIGGERPROTOCOL_DESC    1095
#define IDS_REG_LIDPROTOCOL_DESC        1096
#define IDS_REG_MSVIDSTREAMBUFFERSINK_PROGID 1097
#define IDS_REG_MSVIDSTREAMBUFFERSINK_DESC 1098
#define IDS_REG_MSVIDSTREAMBUFFERRECORDINGCONTROL_PROGID 1099
#define IDS_REG_MSVIDSTREAMBUFFERRECORDINGCONTROL_DESC 1100
#define IDS_REG_MSVIDSTREAMBUFFERSOURCE_PROGID 1101
#define IDS_REG_MSVIDSTREAMBUFFERSOURCE_DESC   1102
#define IDS_REG_AUXINTS_PROGID          1103
#define IDS_REG_AUXINTS_DESC            1104
#define IDR_CANONICAL_TUNINGSPACE_LIST  5128
#define IDR_CANONICAL_ANALOG_CABLE      5129
#define IDR_CANONICAL_ANALOG_ANTENNA    5130
#define IDR_CANONICAL_ATSC              5131
#define IDR_CANONICAL_OPEN_CABLE        5132
#define IDS_REG_MP2CCCOMP_DESC          5133
#define IDS_REG_VIDRECT_DESC            5134
#define IDS_REG_MPEG2TUNEREQUEST_DESC   5135
#define IDS_REG_MPEG2TUNEREQUEST_PROGID 5136
#define IDS_REG_MPEG2TUNEREQUESTFACTORY_DESC   5137
#define IDS_REG_MPEG2TUNEREQUESTFACTORY_PROGID 5138
#define IDS_REG_VIDCTL_PROGID           5139
#define IDS_REG_VIDCTL_DESC		        5140
#define IDS_REG_ANASINCOMP_DESC         5141
#define IDS_REG_MP2SINCOMP_DESC         5142
#define IDS_REG_FP2VRCOMP_DESC	    	5143
#define IDS_REG_WEBDVDARCOMP_DESC       5144
#define IDS_REG_ENCODER_DESC            5145
#define IDS_REG_ENCODER_PROGID          5146
#define IDS_REG_XDS_PROGID              5147
#define IDS_REG_XDS_DESC                5148
#define IDS_REG_DAT2XDSCOMP_DESC        5149
#define IDS_REG_DAT2SINCOMP_DESC        5150
#define IDS_REG_ENC2SINCOMP_DESC        5151
#define IDR_CANONICAL_AUXIN1            5152
#define IDS_REG_ANA2XDSCOMP_DESC        5153
#define IDS_REG_ANA2ENCCOMP_DESC        5154
#define IDS_REG_FP2ARCOMP_DESC          5155
#define IDS_REG_SBES2CC_DESC            5156
#define IDS_REG_SBES2VMR_DESC           5157
#define IDS_DVD_LANGFIRST               10000
#define IDS_DVD_LANG1   1+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG2   2+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG3   3+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG4   4+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG5   5+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG6   6+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG7   7+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG8   8+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG9    9+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG10   10+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG11   11+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG12   12+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG13   13+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG14   14+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG15   15+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG16   16+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG17   17+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG18   18+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG19   19+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG20   20+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG21   21+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG22   22+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG23   23+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG24   24+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG25   25+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG26   26+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG27   27+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG28   28+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG29   29+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG30   30+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG31   31+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG32   32+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG33   33+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG34   34+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG35   35+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG36   36+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG37   37+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG38   38+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG39   39+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG40   40+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG41   41+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG42   42+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG43   43+IDS_DVD_LANGFIRST
#define IDS_DVD_LANG44   44+IDS_DVD_LANGFIRST

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        255
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         255
#define _APS_NEXT_SYMED_VALUE           126
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\sbesinkcp.h ===
// Copyright (c) 1999-2002  Microsoft Corporation.  All Rights Reserved.

#pragma once 

#ifndef _SBESINKCP_H_
#define _SBESINKCP_H_

#include <deviceeventimpl.h>

template <class T, const IID* piid = &IID_IMSVidStreamBufferSinkEvent, class CDV = CComDynamicUnkArray>
class CProxy_StreamBufferSinkEvent : public CProxy_DeviceEvent<T, piid, CDV>
{
public:
	void Fire_CertificateFailure() { Fire_VoidMethod(eventidSinkCertificateFailure); }
	void Fire_CertificateSuccess() { Fire_VoidMethod(eventidSinkCertificateSuccess); }
    void Fire_WriteFailure() { Fire_VoidMethod(eventidWriteFailure); }

};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\sbes2vmr.h ===
//==========================================================================;
//
// Composition.h : Declaration of the custom composition class for gluing sbe source to the vmr
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#ifndef SBES2VMR_H
#define SBES2VMR_H

#pragma once

#include <winerror.h>
#include <algorithm>
#include <compimpl.h>
#include <seg.h>
#include "resource.h"       // main symbols
#include <objectwithsiteimplsec.h>
#include "dsextend.h"

/////////////////////////////////////////////////////////////////////////////
// CSbeS2VmrComp
class ATL_NO_VTABLE __declspec(uuid("3C4708DC-B181-46a8-8DA8-4AB0371758CD")) CSbeS2VmrComp : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CSbeS2VmrComp, &__uuidof(CSbeS2VmrComp)>,
    public IObjectWithSiteImplSec<CSbeS2VmrComp>,
	public IMSVidCompositionSegmentImpl<CSbeS2VmrComp>
{
public:
    CSbeS2VmrComp() {}
    virtual ~CSbeS2VmrComp() {}

REGISTER_NONAUTOMATION_OBJECT(IDS_PROJNAME, 
						   IDS_REG_SBES2VMR_DESC,
						   LIBID_MSVidCtlLib,
						   __uuidof(CSbeS2VmrComp));

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CSbeS2VmrComp)
        COM_INTERFACE_ENTRY(IMSVidCompositionSegment)
    	COM_INTERFACE_ENTRY(IMSVidGraphSegment)
        COM_INTERFACE_ENTRY(IObjectWithSite)
        COM_INTERFACE_ENTRY(IPersist)
    END_COM_MAP()

public:

	PQCreateDevEnum m_pSystemEnum;

	//////////////

// IMSVidGraphSegment
// IMSVidCompositionSegment
    STDMETHOD(Compose)(IMSVidGraphSegment * upstream, IMSVidGraphSegment * downstream)
	{
        VIDPERF_FUNC;
        TRACELM(TRACE_ERROR, "CSbeS2VmrComp::Compose()");
        if (m_fComposed) {
            return NOERROR;
        }
        ASSERT(m_pGraph);
        try {
            VWGraphSegment up(upstream);
            ASSERT(up.Graph() == m_pGraph);
            VWGraphSegment down(downstream);
            ASSERT(down.Graph() == m_pGraph);
            if (upstream == downstream) {
                return Error(IDS_CANT_COMPOSE_WITH_SELF, __uuidof(IMSVidCompositionSegment), E_INVALIDARG);
            }
            if (up.begin() == up.end()) {
                TRACELM(TRACE_ERROR, "CSbeS2VmrComp::Compose() can't compose empty up segment");
                return NOERROR;
            }
            if (down.begin() == down.end()) {
                TRACELM(TRACE_ERROR, "CSbeS2VmrComp::Compose() can't compose empty down segment");
                // this is not an error, for example, CA is an empty segment.
                return NOERROR;
            }
//            bool vidFound = false;
            // VMR has a bug so we need to connect the video before the cc or no cc will be displayed
            DSMediaType mtVideo(MEDIATYPE_Video);
            for (VWGraphSegment::iterator iStart = up.begin(); iStart != up.end(); ++iStart) {
                ASSERT((*iStart).GetGraph() == m_pGraph);
                for(DSFilter::iterator i = (*iStart).begin(); i != (*iStart).end(); ++i){
                    if((*i).GetDirection() == DOWNSTREAM){
                        for(DSPin::iterator p = (*i).begin(); p != (*i).end(); ++p){ 
                            if((*p) == mtVideo){
                                HRESULT hr = E_FAIL;
                                for (VWGraphSegment::iterator iStop = down.begin(); iStop != down.end(); ++ iStop) {
                                    ASSERT((*iStop).GetGraph() == m_pGraph);
                                    DSFilter pStop(*iStop);
                                    hr = (*i).IntelligentConnect(pStop, m_Filters);
                                    if(SUCCEEDED(hr)){
                                        return NOERROR;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            TRACELM(TRACE_ERROR, "CSbeS2VmrComp::Compose() compose didn't connect anything");
            return VFW_E_NO_DECOMPRESSOR;
        } catch (ComException &e) {
            return e;
        } catch (...) {
            return E_UNEXPECTED;
        }
        
	}
};

#endif // SBES2VMR_H
// end of file - SBES2VMR.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\rgsbag.cpp ===
/////////////////////////////////////////////////////////////////////////////////////
// CRGSBag.cpp : Implementation for Read Only property bag on .RGS script fragment
// Copyright (c) Microsoft Corporation 2000.

#include "stdafx.h"
#include "rgsbag.h"

using namespace ::ATL::ATL;

CRGSBag::CRGSBag(LPCTSTR szRGS, CRegObject& croi, int& cchEaten) : CRegParser(&croi) {
	TCHAR   szToken[MAX_VALUE];
	HRESULT hr = S_OK;

	LPTSTR szReg = NULL;
	hr = PreProcessBuffer(szRGS, &szReg);
	if (FAILED(hr)) {
		THROWCOM(hr);
	}

#if defined(_DEBUG) && defined(DEBUG_REGISTRATION)
	OutputDebugString(szReg); //would call ATLTRACE but szReg is > 512 bytes
	OutputDebugString(_T("\n"));
#endif //_DEBUG

    szToken[0] = 0;
	m_pchCur = szReg;
	cchEaten = 0;

	try {
		while (NULL != *m_pchCur && chRightBracket != *szToken) {
			if (FAILED(hr = NextToken(szToken))) {
				break;
			}
			if (chLeftBracket != *szToken)
			{
				ATLTRACE2(atlTraceRegistrar, 0, _T("Syntax error, expecting a {, found a %s\n"), szToken);
				hr = GenerateError(E_ATL_MISSING_OPENKEY_TOKEN);
                THROWCOM(hr);
			}
			hr = BuildMapFromFragment(szToken);
			if (FAILED(hr)) {
                THROWCOM(hr);
			}
		}
	    if (NULL != *m_pchCur) {
		    m_pchCur = CharNext(m_pchCur);  // eat the }
	    }
	    cchEaten = m_pchCur - szReg;
        if (szReg) {
		    CoTaskMemFree(szReg);
            szReg = NULL;
        }
	} catch(ComException &e) {
        if (szReg) {
		    CoTaskMemFree(szReg);
            szReg = NULL;
        }
		throw;
	}
}

HRESULT CRGSBag::BuildMapFromFragment(LPTSTR pszToken) {
	HRESULT hr = S_OK;

	if (FAILED(hr = NextToken(pszToken)))
		return hr;


	while (*pszToken != chRightBracket) // Continue till we see a }
	{
		TCHAR  szValueName[MAX_VALUE];
		CComVariant v;
		if (!lstrcmpi(pszToken, szValToken)) // need to add a value to hkParent
		{

			if (FAILED(hr = NextToken(szValueName)))
				break;
			if (FAILED(hr = NextToken(pszToken)))
				break;


			if (*pszToken != chEquals)
				return GenerateError(E_ATL_EXPECTING_EQUAL);

			hr = GetValue(v);
			if (FAILED(hr)) {
				return hr;
			}
		} else {
			if (StrChr(pszToken, chDirSep) != NULL)
				return GenerateError(E_ATL_COMPOUND_KEY);

			lstrcpyn(szValueName, pszToken, sizeof(szValueName) / sizeof(TCHAR));

			hr = GetObject(v);
			if (FAILED(hr)) {
				return hr;
			}
		}
		m_mapBag[szValueName] = v;
		if (FAILED(hr = NextToken(pszToken)))
			break;
	}

	return hr;
}

HRESULT CRGSBag::GetObject(CComVariant& val) {
	ASSERT(val.vt == VT_EMPTY || val.vt == VT_NULL);
	val.vt = VT_UNKNOWN;
	val.punkVal = NULL;
	HRESULT hr;
	TCHAR   szToken[MAX_VALUE];
	if (FAILED(hr = NextToken(szToken)))
		return hr;

	if (*szToken != chEquals) {
		return GenerateError(E_ATL_EXPECTING_EQUAL);
	}
	// currently we're just expecting a guid here with no type specifier(s'')
	// we should really take genuine .rgs syntax and report an error if it isn't a string
	if (FAILED(hr = NextToken(szToken))) {
		return GenerateError(CO_E_CLASSSTRING);
	}
	USES_CONVERSION;
	GUID2 clsid(T2COLE(szToken));
	PUnknown pobj(clsid, NULL, CLSCTX_INPROC_SERVER);
	if (!pobj) {
		return REGDB_E_CLASSNOTREG;
	}
	hr = LoadPersistedObject<PQPropertyBag2, PQPersistPropertyBag2> (pobj, *m_pRegObj, &m_pchCur);
	if (FAILED(hr)) {
		hr = LoadPersistedObject<PQPropertyBag, PQPersistPropertyBag> (pobj, *m_pRegObj, &m_pchCur);
		if (FAILED(hr)) {
			return hr;
		}
	}
	val.punkVal = pobj;
	(val.punkVal)->AddRef();

	return NOERROR;
}

HRESULT CRGSBag::GetValue(CComVariant &val) {
	USES_CONVERSION;
	HRESULT hr;

	VARTYPE     vt;
	LONG        lRes = ERROR_SUCCESS;
	UINT        nIDRes = 0;

	TCHAR*       pszToken = new TCHAR[MAX_TYPE];
    if (!pszToken) {
        return E_OUTOFMEMORY;
    }
    if (FAILED(hr = NextToken(pszToken))) {
        delete[] pszToken;
		return hr;
    }
	if (!VTFromRegType(pszToken, vt))
	{
		ATLTRACE2(atlTraceRegistrar, 0, _T("%s Type not supported\n"), pszToken);
        delete[] pszToken;
		return GenerateError(E_ATL_TYPE_NOT_SUPPORTED);
	}

    if (FAILED(hr = NextToken(pszToken))) {
        delete[] pszToken;
		return hr;
    }

	switch (vt)
	{
	case VT_BSTR:
		val.vt = VT_BSTR;
        ASSERT(val.bstrVal == NULL);
		val.bstrVal = ::SysAllocString(T2OLE(pszToken));
		break;
	case VT_UI4:
#ifdef _WIN64
		ATLASSERT(FALSE);
		val.ulVal = 0;
#pragma message( "Still need win64 version of VarUI4FromStr()." )
#else
		VarUI4FromStr(T2OLE(pszToken), 0, 0, &val.ulVal);
#endif
		val.vt = VT_UI4;
		break;
	case VT_UI1:
		{
			int cbValue = lstrlen(pszToken);
			if (cbValue & 0x00000001)
			{
				ATLTRACE2(atlTraceRegistrar, 0, _T("Binary Data does not fall on BYTE boundries\n"));
                delete[] pszToken;
				return E_FAIL;
			}
			int cbValDiv2 = cbValue/2;
			int cbLen = cbValDiv2 * sizeof(BYTE);
			BYTE* rgBinary = new BYTE[cbLen];
            if (!rgBinary) {
                delete[] pszToken;
                return E_OUTOFMEMORY;
            }
			memset(rgBinary, 0, cbValDiv2);
            if (rgBinary == NULL) {
                delete[] rgBinary;
                delete[] pszToken;
				return E_FAIL;
            }
			for (int irg = 0; irg < cbValue; irg++)
				rgBinary[(irg/2)] |= (ChToByte(pszToken[irg])) << (4*(1 - (irg & 0x00000001)));
			val.vt = VT_BSTR;
			val.bstrVal = ::SysAllocStringByteLen(reinterpret_cast<LPSTR>(rgBinary), cbLen);
            delete[] rgBinary;
			break;
		}
	}
    delete[] pszToken;

	return S_OK;
}


// end of file - crgsbag.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\sbesourcecp.h ===
// Copyright (c) 1999-2002  Microsoft Corporation.  All Rights Reserved.

#pragma once 

#ifndef _MSVIDSTREAMBUFFERSOURCECP_H_
#define _MSVIDSTREAMBUFFERSOURCECP_H_

#include "fileplaybackcp.h"

template <class T, const IID* piid = &IID_IMSVidStreamBufferSourceEvent, class CDV = CComDynamicUnkArray>
class CProxy_StreamBufferSourceEvent : public CProxy_FilePlaybackEvent<T, piid, CDV>
{

public:
	void Fire_CertificateFailure() { Fire_VoidMethod(eventidSourceCertificateFailure); }
	void Fire_CertificateSuccess() { Fire_VoidMethod(eventidSourceCertificateSuccess); }
    void Fire_RatingsBlocked() { Fire_VoidMethod(eventidRatingsBlocked); }
    void Fire_RatingsUnblocked() { Fire_VoidMethod(eventidRatingsUnlocked); }
    void Fire_RatingsChanged() { Fire_VoidMethod(eventidRatingsChanged); }
    void Fire_StaleDataRead() { Fire_VoidMethod(eventidStaleDataRead); }
    void Fire_ContentBecomingStale() { Fire_VoidMethod(eventidContentBecomingStale); }
    void Fire_StaleFilesDeleted() { Fire_VoidMethod(eventidStaleFileDeleted); }
    void Fire_TimeHole(long lParam1, long lParam2){
        T* pT = static_cast<T*>(this);
        int nConnectionIndex;
        CComVariant* pvars = new CComVariant[2];
        int nConnections = m_vec.GetSize();

        for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
        {
            pT->Lock();
            CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
            pT->Unlock();
            IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
            if (pDispatch != NULL)
            {
                pvars[1] = lParam1;
                pvars[0] = lParam2;
                DISPPARAMS disp = { pvars, NULL, 2, 0 };
                pDispatch->Invoke(eventidDVDNotify, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
            }
        }
        delete[] pvars;

    }

};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\segmentp.c ===
#ifndef TUNING_MODEL_ONLY
#include <segment_p.c>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#include <atlimpl.cpp>

#include <trace.cpp>
#include <initguid.h>
#ifndef TUNING_MODEL_ONLY
#include <encdec.h>
#ifdef BUILD_WITH_DRM
#include "DRMSecure.h"
#endif
#endif
// moved *_i.c to strmiids.lib
//nclude <regbag_i.c>
//nclude <MSVidctl_i.c>
//nclude <segment_i.c>
//nclude <tuner_i.c>

// end of file - stdafx.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\tunerp.c ===
#include <tuner_p.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\topwin.cpp ===
/////////////////////////////////////////////////////////////////////////////
// TopWin.cpp : Implementation of CTopWin, hidden top level window for handling system broadcast messages
// Copyright (c) Microsoft Corporation 1999-2000.


#include <stdafx.h>

#ifndef TUNING_MODEL_ONLY

#include <vrsegimpl.h>
#include "vidctl.h"

BOOL CTopWin::ProcessWindowMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT& lResult, DWORD dwMsgMapID) {
    switch(uMsg) {
    case WM_TIMER:
        //
        // Do something to keep the screen saver from coming alive
        //
        //PostMessage(WM_CHAR,0,0); // didn't work
        //
        // Query the screen saver timeout value and set said value
        // to the value we get.  This should have no real effect,
        // so I can't think of any possible side effects even if
        // this crashes half way through, etc.
        //
        if(m_pVidCtl){
            if(m_pVidCtl->m_State == STATE_PLAY && m_pVidCtl->m_pVideoRenderer){
                CComQIPtr<IMSVidVideoRenderer2> sp_VidVid(m_pVidCtl->m_pVideoRenderer);
                if(sp_VidVid){
                    VARIANT_BOOL effects;
                    HRESULT hr = sp_VidVid->get_SuppressEffects(&effects);
                    if(SUCCEEDED(hr) && effects == VARIANT_TRUE){
                        unsigned int TimeOut;
                        if (SystemParametersInfo(SPI_GETSCREENSAVETIMEOUT, 0, &TimeOut, 0) == 0){
                            TRACELM(TRACE_ERROR, "Could not get screen saver timeout");
                        }
                        else {
                            if (SystemParametersInfo(SPI_SETSCREENSAVETIMEOUT, TimeOut, 0, 0) == 0){
                                TRACELM(TRACE_ERROR,"Cannot set screen saver timeout");
                            }
                            else{
                                TRACELM(TRACE_PAINT,"Successfully reset screen saver timeout");
                            }
                        }
                    }
                }
            }
        }
        // No break...fall through
    case WM_MEDIAEVENT:
    case WM_POWERBROADCAST:
    case WM_DEVICECHANGE:
    case WM_DISPLAYCHANGE:
    // WM_QUERYENDSESSION?
    // WM_ENDSESSION?
        if (m_pVidCtl) {
            return m_pVidCtl->ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult, dwMsgMapID);
        }
        break;
	case WM_USER + WMUSER_INPLACE_ACTIVATE:
		if (m_pVidCtl) {
			TRACELM(TRACE_PAINT, "CTopWin::ProcessWindowMessage() InPlaceActivate()");
			m_pVidCtl->InPlaceActivate(OLEIVERB_INPLACEACTIVATE, NULL);
		}
        break;
    case WM_USER + WMUSER_SITE_RECT_WRONG:
		if (m_pVidCtl) {
			TRACELM(TRACE_PAINT, "CTopWin::ProcessWindowMessage() OnSizeChange");
			m_pVidCtl->OnSizeChange();
		}
        break;
    }

    return FALSE;
}

#endif //TUNING_MODEL_ONLY

// end of file - topwin.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__B0EDF157_910A_11D2_B632_00C04F79498E__INCLUDED_)
#define AFX_STDAFX_H__B0EDF157_910A_11D2_B632_00C04F79498E__INCLUDED_

#pragma once

#pragma warning(disable: 4786)  // identifier truncated in debug info
#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif
//#define _ATL_APARTMENT_THREADED

#define REGISTER_CANONICAL_TUNING_SPACES
#define ENABLE_WINDOWLESS_SUPPORT
#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>
#include <atltmp.h>
#include <winreg.h>
#include <comcat.h>
#include <objsafe.h>
#ifndef TUNING_MODEL_ONLY
#include <urlmon.h>
#include <shlguid.h>
#endif

#include <algorithm>
#include <functional>
#include <utility>
#include <vector>
#include <list>
#include <map>
#include <comdef.h>

#include <w32extend.h>
#ifndef TUNING_MODEL_ONLY
#include <dsextend.h>
#endif
#include <objreghelp.h>

#include <regbag.h>
#include <MSVidCtl.h>
namespace MSVideoControl {
    typedef CComQIPtr<IMSVidCtl> PQVidCtl;
};
#ifndef TUNING_MODEL_ONLY
using namespace MSVideoControl;
#endif

#include <Tuner.h>
namespace BDATuningModel {
    typedef CComQIPtr<ITuningSpaces> PQTuningSpaces;
    typedef CComQIPtr<ITuningSpace> PQTuningSpace;
    typedef CComQIPtr<ITuneRequest> PQTuneRequest;
    typedef CComQIPtr<IBroadcastEvent> PQBroadcastEvent;
};
using namespace BDATuningModel;

#define ENCRYPT_NEEDED 1

#include "resource.h"
// REV2: this limit should be an non-script accessible property in the tuning space container
// this prevents DNOS attacks from filling the registry/disk with huge tuning space properties
#define MAX_BSTR_SIZE 1024
#define CHECKBSTRLIMIT(x) if (::SysStringByteLen(x) > MAX_BSTR_SIZE) { \
						      return HRESULT_FROM_WIN32(ERROR_DS_OBJ_TOO_LARGE); \
							}								
                          

#endif // !defined(AFX_STDAFX_H__B0EDF157_910A_11D2_B632_00C04F79498E__INCLUDED)
// end of file - stdafx.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\topwin.h ===
/////////////////////////////////////////////////////////////////////////////
// TopWin.h : Declaration of CTopWin, hidden top level window for handling system broadcast messages
// Copyright (c) Microsoft Corporation 1999-2000.


#pragma once

#ifndef __TopWin_H_
#define __TopWin_H_


typedef CWinTraits<WS_OVERLAPPEDWINDOW, WS_EX_NOACTIVATE> HiddenTopTraits;

class CVidCtl;

/////////////////////////////////////////////////////////////////////////////
// CTopWin
class CTopWin : public CWindowImpl<CTopWin, CWindow, HiddenTopTraits> {
public:
	enum {
		WMUSER_INPLACE_ACTIVATE,
        WMUSER_SITE_RECT_WRONG
	};

    CTopWin(CVidCtl *pVidCtli) : m_pVidCtl(pVidCtli) {}
    
    void Init() {
        ASSERT(m_pVidCtl);  // its pointless to create one of these without associating with a main control
        Create(NULL, CRect(), _T("MSVidCtl System Broadcast Message Receiver"));
    }
        
    virtual ~CTopWin() {
        m_pVidCtl = NULL;
    }
        
    // NOTE: since this window is created by the main vidctl its message queue is associated with the appropriate
    // apartment thread for the main vidctl.  thus whoever pumps the main apartment thread will pump this window too.
    // and, thus we're automatically synchronzied with the main vidctl and can simply reflect the significant 
    // messages over to the vidctl itself and be guaranteed that we're getting the same
    // behavior for windowless and windowed since its the same code for both cases.

    virtual BOOL ProcessWindowMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT& lResult, DWORD dwMsgMapID = 0);
	void PostInPlaceActivate() {
		PostMessage(WM_USER + WMUSER_INPLACE_ACTIVATE, 0, 0);
	}

private:
    CVidCtl *m_pVidCtl;

};


#endif //__TopWin_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\surface.h ===
/////////////////////////////////////////////////////////////////////////////
// surface.h : surface management utility classes for vidctl
// Copyright (c) Microsoft Corporation 2000.

#pragma once

#ifndef SURFACE_H
#define SURFACE_H

#include <scalingrect.h>

typedef CComPtr<IOleInPlaceFrame> PQFrame;
typedef CComPtr<IOleInPlaceUIWindow> PQUIWin;


class AspectRatio : public CSize {
public:
        AspectRatio(ULONG xi = 0, ULONG yi = 0) : CSize(xi, yi) {
                Normalize();
        }
        AspectRatio(const AspectRatio& ar) : CSize(ar.cx, ar.cy) {}
        AspectRatio(const CRect& ri) : CSize(abs(ri.Width()), abs(ri.Height())) {
			Normalize();
        }
        AspectRatio(LPCRECT ri) : CSize(abs(ri->left - ri->right), 
				  				        abs(ri->top - ri->bottom)) {
			Normalize();
        }

        void Normalize() {
                ULONG d = GCD(abs(cx), abs(cy));
				if (!d) return;
                cx /= d;
                cy /= d;
        }

		// from knuth semi-numerical algorithms p. 321(sort of).
		// since >> on signed isn't guaranteed to be arithmetic in C/C++ we've made some modifications
		ULONG GCD(ULONG a, ULONG b) const {
			ULONG k = 0;
			if (!a) return b;  // by defn
			if (!b) return a;
			while ((!(a & 1)) && (!( b & 1))) {
				_ASSERT((a > 1) && (b > 1));  // since a,b != 0 and even then they must be > 1
				// if a and b are even then gcd(a,b) == 2 * gcd(a/2,b/2), so factor out all the 2s
				++k;
				a >>= 1;
				b >>= 1;
			}
			do {
				_ASSERT(a && b);  // neither can be zero otherwise we'd have returned from the top(1st time)
								  // or fallen out earlier(subsequent iterations)
				_ASSERT((a & 1) || (b & 1)); // at this point either a or b (or both) is odd
				if (!(a & 1) || !(b & 1)) {  // if one of them is even then factor out the 2s
					// since if x is even then gcd(x,y) == gcx(x/2,y)
					ULONG t = (a & 1) ? b : a;
					do {
						_ASSERT(t && (t > 1) && !(t & 1)); // t is even and non-zero(implying t > 1)
						t >>= 1;
					} while (!(t & 1));
					_ASSERT(t && (t & 1)); // t is odd and > 0
					// put t back where we got it from
					if (a & 1) {
						b = t;
					} else {
						a = t;
					}
					_ASSERT((a & 1) && (b & 1));  // they're both odd now
				}
				// replace larger with difference
				// gcd(x, y) == gcd(y, x)
				// gcd(x,y) == gcd(x - y, y)
				if (a > b) {
					a = a - b;
				} else {
					b = b - a;
				}
				_ASSERT(a | b);  // they can't both be 0 or we'd have been done last time through
			} while (a && b);  // if one of the values is 0 then we're done gcd(x,0) == x

			return (a > b ? a : b) << k;
		}

        AspectRatio& operator=(const AspectRatio& rhs) {
            if (&rhs != this) {
                cx = rhs.cx;
                cy = rhs.cy;
            }
			Normalize();
            return *this;
        }
        AspectRatio& operator=(const CRect& rhs) {
			cx = abs(rhs.Width());
			cy = abs(rhs.Height());
			Normalize();
            return *this;
        }
        AspectRatio& operator=(const CSize& rhs) {
            if (&rhs != this) {
			    cx = rhs.cx;
			    cy = rhs.cy;
            }
    	    Normalize();
            return *this;
        }
        AspectRatio& operator=(const LPSIZE rhs) {
            if (rhs != this) {
			    cx = rhs->cx;
			    cy = rhs->cy;
            }
    	    Normalize();
            return *this;
        }
        AspectRatio& operator=(LPCRECT rhs) {
			cx = abs(rhs->left - rhs->right);
			cy = abs(rhs->top - rhs->bottom);
			Normalize();
            return *this;
        }
        bool operator==(const AspectRatio& rhs) const {
                return cx == rhs.cx && cy == rhs.cy;
        }
        bool operator==(const CSize& rhs) const {
                return cx == rhs.cx && cy == rhs.cy;
        }
        bool operator!=(const AspectRatio& rhs) const {
                return !operator==(rhs);
        }
		bool operator!() {
			return !cx && !cy;
		}
        ULONG X() const { return cx; }
        ULONG Y() const { return cy; }
        ULONG X(ULONG xi) {
                cx = xi;
                Normalize();
				return cx;
        }
        ULONG Y(ULONG yi) {
                cy = yi;
                Normalize();
				return cy;
        }
        void XY(ULONG xi, ULONG yi) {
                cx = xi;
                cy = yi;
                Normalize();
        }
};

class SurfaceState : public CScalingRect {
public:
    const static int MIN_RECT_WIDTH = 4;
    const static int MIN_RECT_HEIGHT = 3;

    SurfaceState(const long l = 0,
                 const long t = 0,
                 const long r = 0,
                 const long b = 0,
				 const HWND iOwner = INVALID_HWND,
                 const bool iVis = false,
                 const bool iAspect = true,
                 const bool iSource = false) :
                     CScalingRect(l, t, r, b, iOwner),
                     m_fVisible(iVis),
                     m_fForceAspectRatio(iAspect),
                     m_fForceSourceSize(iSource) {}

    SurfaceState(const CRect& iPos,
                 const HWND iOwner = INVALID_HWND,
                 const bool iVis = false,
                 const bool iAspect = true,
                 const bool iSource = false) :
                         CScalingRect(iPos, iOwner),
                         m_fVisible(iVis),
                         m_fForceAspectRatio(iAspect),
                         m_fForceSourceSize(iSource) {}

    SurfaceState(const CScalingRect& iPos,
                 const bool iVis = false,
                 const bool iAspect = true,
                 const bool iSource = false) :
                         CScalingRect(iPos),
                         m_fVisible(iVis),
                         m_fForceAspectRatio(iAspect),
                         m_fForceSourceSize(iSource) {}

    SurfaceState(const HWND iOwner,
                 const bool iVis = false,
                 const bool iAspect = true,
                 const bool iSource = false) :
                         CScalingRect(iOwner),
                         m_fVisible(iVis),
                         m_fForceAspectRatio(iAspect),
                         m_fForceSourceSize(iSource) {}

    SurfaceState(const PQSiteWindowless& pSite, 
				 const bool iVis = false, 
				 const bool iAspect = true, 
				 const bool iSource = false) : 
                         m_fVisible(iVis),
                         m_fForceAspectRatio(iAspect),
                         m_fForceSourceSize(iSource) {
		Site(pSite);
    }

    SurfaceState(const WINDOWPOS *const wp,                  
				 const bool iAspect = true,
                 const bool iSource = false) :
                         m_fForceAspectRatio(iAspect),
                         m_fForceSourceSize(iSource) {
        ASSERT(!((wp->flags & SWP_SHOWWINDOW) && (wp->flags & SWP_HIDEWINDOW)));
        CScalingRect(CPoint(wp->x, wp->y), CSize(wp->cx, wp->cy));
        if (wp->flags & SWP_SHOWWINDOW) {
                Visible(true);
        } else  if (wp->flags & SWP_HIDEWINDOW) {
                Visible(false);
        }
	    TRACELSM(TRACE_DETAIL, (dbgDump << "SurfaceState::SurfaceState(LPWINDOWPOS) visible = " << m_fVisible), "" );
    }

    SurfaceState& operator=(const SurfaceState& rhs) {
        if (this != &rhs) {
            CScalingRect::operator=(rhs);
            m_fVisible = rhs.m_fVisible;
            m_fForceAspectRatio = rhs.m_fForceAspectRatio;
            m_fForceSourceSize = rhs.m_fForceSourceSize;
        }
        return *this;
    }

	SurfaceState& operator=(const CScalingRect& rhs) {
        if (this != &rhs) {
            CScalingRect::operator=(rhs);
        }
        return *this;
    }

	SurfaceState& operator=(const CRect& rhs) {
        if (this != &rhs) {
            CScalingRect::operator=(rhs);
        }
        return *this;
    }

    bool operator==(const SurfaceState& rhs) const {
            return CRect::operator==(rhs) &&
                    rhs.m_fVisible == m_fVisible &&
                    rhs.m_fForceAspectRatio == m_fForceAspectRatio &&
                    rhs.m_fForceSourceSize == m_fForceSourceSize;
    }
    bool operator !=(const SurfaceState& rhs) const {
            return !operator==(rhs);
    }
    bool operator==(const CScalingRect& rhs) const {
            return CScalingRect::operator==(rhs);
    }
    bool operator !=(const CScalingRect& rhs) const {
            return !operator==(rhs);
    }

    AspectRatio Aspect() const {
        return AspectRatio(*this);
    }

    bool Round(const AspectRatio& ar) {
        bool fChanged = false;
        // at some point we probably want to round the current rectangle to the 
        // nearest rectangle that has the specified aspect ratio
        // i.e. minimize total areal change
        // if we ever round we should take the monitor size into consideration 
        // i.e if we decide to round up and we go off the monitor in either direction
        // then round down instead.

        // for now we're choosing the next size down for ease of coding
        // try narrower first

		TRACELSM(TRACE_PAINT, (dbgDump << "SurfaceState::Round() ar = " << ar << "this = " << *this), "");
        NormalizeRect();

        // adjust height and width to nearest multiple of x, y to avoid fractional pixel problems
		ASSERT(ar.X() && ar.Y());
        if (Width() % ar.X()) {
            right -= Width() % ar.X();
    		TRACELSM(TRACE_PAINT, (dbgDump << "SurfaceState::Round() right adjusted to multiple =  " <<  bottom), "");
            fChanged = true;
        }
        if (Height() % ar.Y()) {
            bottom -= Height() % ar.Y();
    		TRACELSM(TRACE_PAINT, (dbgDump << "SurfaceState::Round() bottom adjusted to multiple =  " <<  bottom), "");
            fChanged = true;
        }
        // force very small rectangles to minimum size;
        if (Width() < MIN_RECT_WIDTH) {
            right = left + ar.X();
            fChanged = true;
    		TRACELSM(TRACE_PAINT, (dbgDump << "SurfaceState::Round() forcing min width =  " <<  Width()), "");
        }
        if (Height() < MIN_RECT_HEIGHT) {
            bottom = top + ar.Y();
            fChanged = true;
    		TRACELSM(TRACE_PAINT, (dbgDump << "SurfaceState::Round() forcing min height =  " <<  Height()), "");
        }
        TRACELSM(TRACE_PAINT, (dbgDump << "SurfaceState::Round() this =  " <<  *this), "");

        if (AspectRatio(this) != ar) {
        	TRACELSM(TRACE_PAINT, (dbgDump << "SurfaceState::Round() ar(this) x =  " <<  AspectRatio(this).X() 
                                           << " y = " << AspectRatio(this).Y()), "");
        	TRACELSM(TRACE_PAINT, (dbgDump << "SurfaceState::Round() terms w =  " <<  Width()
                                           << " ratio w = " << ((ar.X() * Height()) / ar.Y())), "");
            long delta = Width();
            delta -= ((ar.X() * Height()) / ar.Y());
        	TRACELSM(TRACE_PAINT, (dbgDump << "SurfaceState::Round() delta =  " <<  delta), "");
            if (delta > 0) {
                // too wide
                ASSERT( ((Height() / ar.Y()) * ar.Y()) == Height());
                right -= delta / 2;  // distribute adjustment evenly on both sides
                left += delta / 2; // shift so that adjustment is distributed evenly on both sides
                if (delta & 1) {
                    --right;  // if delta is odd distribute the extra on the right
                }
            	TRACELSM(TRACE_PAINT, (dbgDump << "SurfaceState::Round() was too wide, now this =  " <<  *this), "");
            } else {
                // too tall
                delta = Height();
                delta -= ((ar.Y() * Width()) / ar.X());
            	TRACELSM(TRACE_PAINT, (dbgDump << "SurfaceState::Round() too tall, now delta =  " <<  delta), "");
                ASSERT(delta > 0);
                ASSERT( ((Width() / ar.X()) * ar.X()) == Width());
                //bottom = (Width() / ar.X()) * ar.Y() + top;
                bottom -= (delta >> 1);
                top += (delta >> 1); // apply half of adjustment on each side
                if (delta & 1) {
                    --bottom; // if delta is odd distribute the extra on the bottom
                }
            	TRACELSM(TRACE_PAINT, (dbgDump << "SurfaceState::Round() was too tall, now this =  " <<  *this), "");
            }
            fChanged = true;
        }
        TRACELSM(TRACE_PAINT, (dbgDump << "SurfaceState::Round() complete, this =  " <<  *this << " ar.x = " << AspectRatio(this).X() << " ar.y = " << AspectRatio(this).Y()), "");
        ASSERT(AspectRatio(this) == ar);
        return fChanged;
    }
    bool IsVisible() const { return m_fVisible; }
    void Visible(const bool fVal) {
        if (m_fVisible != fVal) {
            m_fVisible = fVal;
            m_bRequiresSave = true;
        }
    }

    bool ForceAspectRatio() const { return m_fForceAspectRatio; }
    void ForceAspectRatio(const bool fVal) {
        if (m_fForceAspectRatio != fVal) {
            m_fForceAspectRatio = fVal;
            m_bRequiresSave = true;
        }
    }

    bool ForceSourceSize() const { return m_fForceSourceSize; }
    void ForceSourceSize(const bool fVal) {
        if (m_fForceSourceSize != fVal) {
            m_fForceSourceSize = fVal;
            m_bRequiresSave = true;
        }
    }

    void WindowPos(const WINDOWPOS *const wp) {
        ASSERT(!((wp->flags & SWP_SHOWWINDOW) && (wp->flags & SWP_HIDEWINDOW)));
        HWND parent = ::GetParent(Owner());
        CScalingRect newpos(CPoint(wp->x, wp->y), CSize(wp->cx, wp->cy), parent);
        operator=(newpos);
        if (wp->flags & SWP_SHOWWINDOW) {
                Visible(true);
        } else  if (wp->flags & SWP_HIDEWINDOW) {
                Visible(false);
        }
	    TRACELSM(TRACE_DETAIL, (dbgDump << "SurfaceState::SurfaceState(LPWINDOWPOS) visible = " << m_fVisible), "" );
    }

    PQSiteWindowless Site() const { return m_pSiteWndless; }

    void Site(const PQSiteWindowless& pSite) {
        PQFrame pFrame;
	    PQUIWin pDoc;

		// go ahead and reprocess even if site pointer matches existing site because the context may have changed and need
		// to be refreshed(for example we've been deactived and are being reactivated in a different size by the same site
#if 0
		if (m_pSiteWndless.IsEqualObject(static_cast<IUnknown*>(pSite.p))) {
			return;
		}
#endif
        m_pSiteWndless = static_cast<IUnknown*>(pSite.p);  // this forces the correct re-QI since atl improperly casts and overloads its pointer
        if (m_pSiteWndless) {
			CRect rc;
			CRect clip;
			OLEINPLACEFRAMEINFO frameInfo;
            // for some stupid reason none of these parms can be NULL, even if we don't care about them
            HRESULT hr = m_pSiteWndless->GetWindowContext(&pFrame, &pDoc, &rc, &clip, &frameInfo);
            if (FAILED(hr)) {
                TRACELM(TRACE_ERROR, "SurfaceState::operator=(InPlaceSite*) can't get window context with frame");
                THROWCOM(hr);
            }
			CRect SiteRect;
			SiteRect.IntersectRect(&rc, &clip);
            HWND hOwner;
            // get container window
            hr = m_pSiteWndless->GetWindow(&hOwner);
            if (FAILED(hr)) {
                hr = pDoc->GetWindow(&hOwner);
                if (FAILED(hr)) {
                    TRACELM(TRACE_DETAIL, "SurfaceState::operator=(InPlaceSite*) can't get doc Owner");
                    hr = pFrame->GetWindow(&hOwner);
                    if (FAILED(hr)) {
                        THROWCOM(hr);
                    }
                }
            }
            ASSERT(::IsWindow(hOwner));
			Owner(hOwner);
			*this = SiteRect;
            TRACELSM(TRACE_PAINT, (dbgDump << "SurfaceState::Site(InPlaceSite*) new rect = " << *this), "");
        } else {
			*this = CScalingRect(0, 0, 0, 0, INVALID_HWND);
        }

        return;		
    }
    // translate a point relative to the owner window to a point relative to the rectangle
    // for this surface
    CPoint XlateOwnerPointToSurfacePoint(CPoint &p) {
        TRACELSM(TRACE_PAINT, (dbgDump << "SurfaceState::Xlate p = " << p.x << ", " << p.y), "");
        CPoint retp(p);
        retp.x -= left;
        retp.y -= top;
        TRACELSM(TRACE_PAINT, (dbgDump << "SurfaceState::Xlate retp = " << retp.x << ", " << retp.y <<                                          " this " << *this), "");
        return retp;
    }
private:
    bool m_fVisible;
    bool m_fForceAspectRatio;
    bool m_fForceSourceSize;
    PQSiteWindowless m_pSiteWndless;
};

#endif
// end of file surface.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\tuningspacecontainer.cpp ===
/////////////////////////////////////////////////////////////////////////////////////
// TuningSpaceContainer.cpp : Implementation of CSystemTuningSpaces
// Copyright (c) Microsoft Corporation 1999-2000.

#include "stdafx.h"

#include "TuningSpaceContainer.h"
#include "rgsbag.h"
#include "ATSCTS.h"
#include "AnalogTVTS.h"
#include "AuxiliaryInTs.h"
#include "AnalogRadioTS.h"
#include "dvbts.h"
#include "dvbsts.h"

DEFINE_EXTERN_OBJECT_ENTRY(CLSID_SystemTuningSpaces, CSystemTuningSpaces)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_ATSCTuningSpace, CATSCTS)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_AnalogTVTuningSpace, CAnalogTVTS)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_AuxInTuningSpace, CAuxInTS)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_AnalogRadioTuningSpace, CAnalogRadioTS)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_DVBTuningSpace, CDVBTS)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_DVBSTuningSpace, CDVBSTS)

#define MAX_COUNT_NAME OLESTR("Max Count")
namespace BDATuningModel {

typedef CComQIPtr<ITuningSpaceContainer> PQTuningSpaceContainer;

class CAutoMutex {
public:
    const static int MAX_MUTEX_WAIT = 5000;
	CAutoMutex(HANDLE hMutex) throw(ComException) : m_hMutex(hMutex) {
        if (WaitForSingleObject(m_hMutex, MAX_MUTEX_WAIT) != WAIT_OBJECT_0)
            THROWCOM(E_FAIL);
    }

    ~CAutoMutex() throw(ComException) {
        if (!ReleaseMutex(m_hMutex))
            THROWCOM(E_FAIL);
    }

private:
    HANDLE m_hMutex;
};

// to avoid deadlock, always grab the objects critsec via ATL_LOCK before
// grabbing the registry section mutex.

/////////////////////////////////////////////////////////////////////////////
// CSystemTuningSpaces

HRESULT
CSystemTuningSpaces::FinalConstruct(void)
{
    // set up to serialize access to this point in the registry
    CString cs;
    cs.LoadString(IDS_MUTNAME);
    m_hMutex = CreateMutex(NULL, FALSE, cs);
    if (!m_hMutex)
    {
        return Error(IDS_E_NOMUTEX, __uuidof(ITuningSpaceContainer), HRESULT_FROM_WIN32(GetLastError()));
    }
    try {
        // wait for exclusive access
        CAutoMutex mutex(m_hMutex);

            // this must only be done once
        _ASSERT(!m_pFactory);

        // get the property bag class factory
        HRESULT hr = m_pFactory.CoCreateInstance(__uuidof(CreatePropBagOnRegKey));
        if (FAILED(hr))
        {
            return Error(IDS_E_NOPROPBAGFACTORY, __uuidof(ITuningSpaceContainer), hr);
        }

        hr = OpenRootKeyAndBag(KEY_READ);
        if (FAILED(hr)) {
            return Error(IDS_E_NOREGACCESS, __uuidof(ITuningSpaceContainer), hr);
        }

	    PQPropertyBag pb(m_pTSBag);
	    if (!pb) {
		    return E_UNEXPECTED;
	    }

        // discover the maximum possible number of tuning spaces that currently exist
        ULONG cTSPropCount;
        hr = m_pTSBag->CountProperties(&cTSPropCount);
        if (FAILED(hr))
        {
            return Error(IDS_E_CANNOTQUERYKEY, __uuidof(ITuningSpaceContainer), hr);
        }

        // allocate space to hold the tuning space object information entries
        PROPBAG2 *rgPROPBAG2 = new PROPBAG2[cTSPropCount];
        if (!rgPROPBAG2)
        {
            return Error(IDS_E_OUTOFMEMORY, __uuidof(ITuningSpaceContainer), E_OUTOFMEMORY);
        }

        ULONG cpb2Lim;

        // get all the property info structs at once
        hr = m_pTSBag->GetPropertyInfo(0, cTSPropCount, rgPROPBAG2, &cpb2Lim);
        if (FAILED(hr))
        {
            return Error(IDS_E_CANNOTQUERYKEY, __uuidof(ITuningSpaceContainer), hr);
        }
        _ASSERT(cTSPropCount == cpb2Lim);

	    HRESULT hrc = NOERROR;
        // go through the list of properties
        for (ULONG ipb2 = 0; ipb2 < cpb2Lim; ++ipb2)
        {
            // only deal with ones that represent sub-objects (keys)
            if (rgPROPBAG2[ipb2].vt == VT_UNKNOWN)
            {
                USES_CONVERSION;
                LPTSTR pstrName = OLE2T(rgPROPBAG2[ipb2].pstrName);
                TCHAR* pchStop;

                // check for a valid tuning space identifier
                ULONG idx = _tcstoul(pstrName, &pchStop, 10);
                if (idx != 0 && idx != ULONG_MAX && *pchStop == 0)
                {
                    CComVariant var;

                    // read the property from the bag (instantiating the tuning space object)
                    HRESULT hr2;
                    hr = m_pTSBag->Read(1, &rgPROPBAG2[ipb2], NULL, &var, &hr2);
				    if (FAILED(hr)) {
					    // even if the read fails, we should keep going.  
					    // a) this is the easiest way to prevent memory leaks from rgPROPBAG2
					    // b) a bad 3rd party uninstall could leave us with tuning space data
					    //    but no tuning space class to instantiate for that data.  we shouldn't
					    //    allow this to prevent use of other tuning spaces.
					    hrc = hr;
				    } else {
                        _ASSERT(var.vt == VT_UNKNOWN || var.vt == VT_DISPATCH);
					    PQTuningSpace pTS(((var.vt == VT_UNKNOWN) ? var.punkVal : var.pdispVal));
					    CComBSTR UniqueName(GetUniqueName(pTS));
					    if (!UniqueName.Length()) {
						    // return Error(IDS_E_NOUNIQUENAME, __uuidof(ITuningSpace), E_UNEXPECTED);
                            // seanmcd 01/04/04  don't allow a corrupt tuning space to prevent
                            // use of the rest of them.  treat this as a read failure as per the above
                            // comment
                            // but remove it from the collection otherwise we've got a name/idx
                            // cache inconsistency problem
                            hrc = hr = E_UNEXPECTED; // indicate error to delete corrupt TS below
                        } else {
					        m_mapTuningSpaces[idx] = var;
					        m_mapTuningSpaceNames[UniqueName] = idx;
                        }
    #if 0
                        // the following code has been tested and works, but i don't want to
                        // turn it on because stress testing can cause false registry
                        // read failures that resolve themselves later when the system isn't under
                        // stress and i don't want to risk deleting a good tuning space just
                        // because of a bogus read error.
                        if (FAILED(hr)) {
                            // delete the corrupt TS
                            CComVariant var2;
                            var2.vt = VT_UNKNOWN;
                            var2.punkVal = NULL;
                            // can't do anything about a failure so ignore it
                            m_pTSBag->Write(1, &rgPROPBAG2[ipb2], &var2);
                        }
    #endif
				    }
                }
            }

            // free space allocated within rgPROPBAG2 by GetPropertyInfo
            CoTaskMemFree(rgPROPBAG2[ipb2].pstrName);
        }
        delete [] rgPROPBAG2;
	    _ASSERT(m_mapTuningSpaces.size() == m_mapTuningSpaceNames.size());

	    CComVariant v;
	    v.vt = VT_UI4;
	    hr = pb->Read(MAX_COUNT_NAME, &v, NULL);
	    if (SUCCEEDED(hr)) {
		    if (v.vt != VT_UI4) {
			    hr = ::VariantChangeType(&v, &v, 0, VT_UI4);
			    if (FAILED(hr)) {
				    return E_UNEXPECTED;
			    }
		    }
		    m_MaxCount = max(v.lVal, m_mapTuningSpaces.size());
		    if (m_MaxCount != v.lVal) {
			    //someone has added stuff to the registry by hand, by defn this is secure
			    // so just update max_count to be consistent
			    hr = put_MaxCount(m_MaxCount);
			    if (FAILED(hr)) {
				    return E_UNEXPECTED;
			    }
		    }
	    } else {
		    m_MaxCount = max(DEFAULT_MAX_COUNT, m_mapTuningSpaces.size());
	    }

    #if 0
        // we'd like to return some indicator that not all of the tuning spaces we're successfully
        // read.  but ATL's base CreateInstance method has a check that deletes the object if
        // the return code != S_OK which S_FALSE triggers.  this results in a successful return code 
        // with a NULL object pointer being returned which crashes clients(specifically the network
        // provider).
	    if (FAILED(hrc)) {
		    return Error(IDS_S_INCOMPLETE_LOAD, __uuidof(ITuningSpace), S_FALSE);
	    }
    #endif

        return NOERROR;
    } CATCHCOM();
}

void CSystemTuningSpaces::FinalRelease()
{
	_ASSERT(m_mapTuningSpaces.size() == m_mapTuningSpaceNames.size());
    if (m_hMutex)
        CloseHandle(m_hMutex);
}

STDMETHODIMP CSystemTuningSpaces::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ITuningSpaceContainer
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////////////
HRESULT CSystemTuningSpaces::OpenRootKeyAndBag(REGSAM DesiredAccess) {
    CString cs;
    cs.LoadString(IDS_TSREGKEY);
    // make sure our entry exists
    LONG lRes = m_RootKey.Create(HKEY_LOCAL_MACHINE, cs, NULL, REG_OPTION_NON_VOLATILE, DesiredAccess);
    if (lRes != ERROR_SUCCESS) {
        return HRESULT_FROM_WIN32(lRes);
    }
    m_CurrentAccess = DesiredAccess;
    // create a property bag for this portion of the registry
    HRESULT hr = m_pFactory->Create
        ( m_RootKey, 0,
          0,
          m_CurrentAccess,
          __uuidof(IPropertyBag2),
          reinterpret_cast<void **>(&m_pTSBag)
        );
    if (FAILED(hr))
    {
        return Error(IDS_E_CANNOTCREATEPROPBAG, __uuidof(ITuningSpaceContainer), hr);
    }
    return NOERROR;
}

HRESULT CSystemTuningSpaces::ChangeAccess(REGSAM NewAccess) {
    if (m_CurrentAccess == NewAccess) {
        return NOERROR;
    }
    m_RootKey.Close();
    m_pTSBag.Release();
    HRESULT hr = OpenRootKeyAndBag(NewAccess);
    if (FAILED(hr)) {
        return Error(IDS_E_NOREGACCESS, __uuidof(ITuningSpaceContainer), hr);
    }
    return NOERROR;
}

CComBSTR CSystemTuningSpaces::GetUniqueName(ITuningSpace* pTS) {
// don't assert map size equality here.  this function is used to create the name map and will
// always fail during finalconstrcut()
//	_ASSERT(m_mapTuningSpaces.size() == m_mapTuningSpaceNames.size());
    CComBSTR un;
    HRESULT hr = pTS->get_UniqueName(&un);
    if (FAILED(hr)) {
		THROWCOM(hr);
	}
    return un;
}

ULONG CSystemTuningSpaces::GetID(CComBSTR& un) {
	_ASSERT(m_mapTuningSpaces.size() == m_mapTuningSpaceNames.size());
    TuningSpaceNames_t::iterator i = m_mapTuningSpaceNames.find(un);
    if (i == m_mapTuningSpaceNames.end()) {
        return 0;
    }
    return (*i).second;
}

HRESULT CSystemTuningSpaces::DeleteID(ULONG id) {
	_ASSERT(m_mapTuningSpaces.size() == m_mapTuningSpaceNames.size());
    HRESULT hr = ChangeAccess(KEY_READ | KEY_WRITE);
    if (FAILED(hr)) {
        return hr;
    }
    OLECHAR idstr[66];
    _ltow(id, idstr, 10);
    VARIANT v;
    v.vt = VT_EMPTY;
    PQPropertyBag p(m_pTSBag);
    if (!p) {
        return Error(IDS_E_NOREGACCESS, __uuidof(IPropertyBag), E_UNEXPECTED);
    }
	USES_CONVERSION;
    hr = p->Write(idstr, &v);
    if (FAILED(hr)) {
        return Error(IDS_E_NOREGACCESS, __uuidof(ITuningSpaceContainer), E_UNEXPECTED);
    }
    return NOERROR;
}

HRESULT CSystemTuningSpaces::Add(CComBSTR& UniqueName, long PreferredID, PQTuningSpace pTS, VARIANT *pvarIndex) {
    try {
        CAutoMutex mutex(m_hMutex);
	    _ASSERT(m_mapTuningSpaces.size() == m_mapTuningSpaceNames.size());
	    int newcount = m_mapTuningSpaces.size() + 1;
        if (!PreferredID || m_mapTuningSpaces.find(PreferredID) == m_mapTuningSpaces.end()) {
            // verify no unique name conflict
            TuningSpaceNames_t::iterator in;
            in = m_mapTuningSpaceNames.find(UniqueName);
            if (in != m_mapTuningSpaceNames.end()) {
                return Error(IDS_E_DUPLICATETS, __uuidof(ITuningSpace), HRESULT_FROM_WIN32(ERROR_DUP_NAME));
            }

            // hunt for first available unused id
            // start with 1, id 0 is invalid for a tuning space
            for (PreferredID = 1;
                 m_mapTuningSpaces.find(PreferredID) != m_mapTuningSpaces.end(); 
                 ++PreferredID) {

            }
        } else {
		    // this is the case for complete replacement via idx.
            // delete existing data for this id in preparation for overwriting it.
		    // they may also be changing the unique name at this point.
            HRESULT hr = DeleteID(PreferredID);
            if (FAILED(hr)){
                return hr;
            }
		    newcount--;
        }
	    if (newcount > m_MaxCount) {
		    return Error(IDS_E_MAXCOUNTEXCEEDED, __uuidof(ITuningSpaceContainer), STG_E_MEDIUMFULL);
	    }

        HRESULT hr = ChangeAccess(KEY_READ | KEY_WRITE);
        if (FAILED(hr)) {
            return hr;
        }

        OLECHAR idstr[66];
        _ltow(PreferredID, idstr, 10);

        PQPropertyBag p(m_pTSBag);
        if (!p) {
            return Error(IDS_E_NOREGACCESS, __uuidof(IPropertyBag), E_UNEXPECTED);
        }
	    USES_CONVERSION;
        VARIANT v;
        v.vt = VT_UNKNOWN;
        v.punkVal = pTS;
        hr = p->Write(idstr, &v);
	    if (FAILED(hr)) {
            return Error(IDS_E_NOREGACCESS, __uuidof(ITuningSpaceContainer), hr);
	    }

        PQTuningSpace newTS;
        hr = pTS->Clone(&newTS);
        if (FAILED(hr)) {
            return hr;
        }
        m_mapTuningSpaces[PreferredID] = newTS;
        m_mapTuningSpaceNames[UniqueName] = PreferredID;
        if (pvarIndex) {
            VARTYPE savevt = pvarIndex->vt;
            VariantClear(pvarIndex);
            switch(savevt) {
            case VT_BSTR:
                pvarIndex->vt = VT_BSTR;
                return newTS->get_UniqueName(&pvarIndex->bstrVal);
            default:
                pvarIndex->vt = VT_I4;
                pvarIndex->ulVal = PreferredID;
                return NOERROR;
            }
        }
        return NOERROR;
    } CATCHCOM();
}


HRESULT CSystemTuningSpaces::Find(TuningSpaceContainer_t::iterator &its, CComBSTR& UniqueName, TuningSpaceNames_t::iterator &itn) {
	ATL_LOCK();
	_ASSERT(m_mapTuningSpaces.size() == m_mapTuningSpaceNames.size());
    if (its == m_mapTuningSpaces.end()) {
        return Error(IDS_E_NO_TS_MATCH, __uuidof(ITuningSpace), E_FAIL);
    }
    _ASSERT(((*its).second.vt == VT_UNKNOWN) || ((*its).second.vt == VT_DISPATCH));
    PQTuningSpace pTS((*its).second.punkVal);
    if (!pTS) {
        return Error(IDS_E_NO_TS_MATCH, __uuidof(ITuningSpaceContainer), E_UNEXPECTED);
    }
    UniqueName = GetUniqueName(pTS);
    if (!UniqueName.Length()) {
        return Error(IDS_E_NOUNIQUENAME, __uuidof(ITuningSpace), E_UNEXPECTED);
    }
    itn = m_mapTuningSpaceNames.find(UniqueName);
    _ASSERT(itn != m_mapTuningSpaceNames.end());  // cache inconsistency, in container but not in names
    return NOERROR;
}

HRESULT CSystemTuningSpaces::Find(VARIANT varIndex, long& ID, TuningSpaceContainer_t::iterator &its, CComBSTR& UniqueName, TuningSpaceNames_t::iterator &itn) {
	ATL_LOCK();
	_ASSERT(m_mapTuningSpaces.size() == m_mapTuningSpaceNames.size());
    HRESULT hr = S_OK;
    VARIANT varTmp;
    its = m_mapTuningSpaces.end();
    itn = m_mapTuningSpaceNames.end();
    PQTuningSpace pTuningSpace;

    VariantInit(&varTmp);

    // Try finding a tuning space by local system ID
    hr = VariantChangeType(&varTmp, &varIndex, 0, VT_I4);
    if (!FAILED(hr))
    {
        _ASSERT(varTmp.vt == VT_I4);
        ID = V_I4(&varTmp);
        its = m_mapTuningSpaces.find(ID);
    } else {

        // Try finding a tuning space by name
        hr = VariantChangeType(&varTmp, &varIndex, 0, VT_BSTR);
        if (FAILED(hr))
        {
            // we can only get here if both VariantChangeType calls failed
            return Error(IDS_E_TYPEMISMATCH, __uuidof(ITuningSpaceContainer), DISP_E_TYPEMISMATCH);
        }
        _ASSERT(varTmp.vt == VT_BSTR);
        UniqueName = V_BSTR(&varTmp);

        itn = m_mapTuningSpaceNames.find(UniqueName);
        if (itn != m_mapTuningSpaceNames.end()) {
            ID = (*itn).second;
            its = m_mapTuningSpaces.find(ID);
        }
    }

    if (its == m_mapTuningSpaces.end()) {
        return Error(IDS_E_NO_TS_MATCH, __uuidof(ITuningSpaceContainer), E_FAIL);
    }
    _ASSERT(((*its).second.vt == VT_UNKNOWN) || ((*its).second.vt == VT_DISPATCH));
    return NOERROR;
}


//////////////////////////////////////////////////////////////////////////////////////
// ITuningSpaceContainer
//////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CSystemTuningSpaces::get_Item(/*[in]*/ VARIANT varIndex, /*[out, retval]*/ ITuningSpace **ppTuningSpace) {
	if (!ppTuningSpace) {
		return E_POINTER;
	}
	try {
	    ATL_LOCK();
		TuningSpaceContainer_t::iterator its = m_mapTuningSpaces.end();
		TuningSpaceNames_t::iterator itn = m_mapTuningSpaceNames.end();
		long id;
		CComBSTR un;
		HRESULT hr = Find(varIndex, id, its, un, itn);
		if (FAILED(hr) || its == m_mapTuningSpaces.end()) {
			return Error(IDS_E_NO_TS_MATCH, __uuidof(ITuningSpaceContainer), E_INVALIDARG);
		}
		_ASSERT(((*its).second.vt == VT_UNKNOWN) || ((*its).second.vt == VT_DISPATCH));
		PQTuningSpace pTS((*its).second.punkVal);
		if (!pTS) {
			return Error(IDS_E_NOINTERFACE, __uuidof(ITuningSpace), E_NOINTERFACE);
		}
		PQTuningSpace pTSNew;
		hr = pTS->Clone(&pTSNew);
		if (FAILED(hr)) {
			return hr;
		}
		*ppTuningSpace = pTSNew.Detach();
        return NOERROR;
	} catch(...) {
		return E_UNEXPECTED;
	}
}

STDMETHODIMP CSystemTuningSpaces::put_Item(VARIANT varIndex, ITuningSpace *pTS)
{
	if (!pTS) {
		return E_POINTER;
	}
    try {
        // wait for exclusive access
        CAutoMutex mutex(m_hMutex);
		_ASSERT(m_mapTuningSpaces.size() == m_mapTuningSpaceNames.size());

        HRESULT hr = ChangeAccess(KEY_READ | KEY_WRITE);
        if (FAILED(hr)) {
            return hr;
        }
        long id;
        CComBSTR idxun;
        TuningSpaceContainer_t::iterator its;
        TuningSpaceNames_t::iterator itn;
        hr = Find(varIndex, id, its, idxun, itn);
        if (FAILED(hr) || its == m_mapTuningSpaces.end()) {
            return Error(IDS_E_NO_TS_MATCH, __uuidof(ITuningSpaceContainer), E_INVALIDARG);
        }
        _ASSERT(((*its).second.vt == VT_UNKNOWN) || ((*its).second.vt == VT_DISPATCH));
        CComBSTR un2(GetUniqueName(pTS));
        if (!un2.Length()) {
            // no uniquename prop set in ts
            return Error(IDS_E_NOUNIQUENAME, __uuidof(ITuningSpace), E_UNEXPECTED);
        }
        if (itn != m_mapTuningSpaceNames.end() && idxun != un2) {
            // unique name prop in ts doesn't match string specified in varindex
            return Error(IDS_E_NO_TS_MATCH, __uuidof(ITuningSpace), E_INVALIDARG);
        }
        return Add(un2, id, pTS, NULL);
    } CATCHCOM();
}

STDMETHODIMP CSystemTuningSpaces::Add(ITuningSpace *pTuningSpace, VARIANT *pvarIndex)
{
    try {
        // wait for exclusive access
        CAutoMutex mutex(m_hMutex);
		_ASSERT(m_mapTuningSpaces.size() == m_mapTuningSpaceNames.size());
        HRESULT hr = ChangeAccess(KEY_READ | KEY_WRITE);
        if (FAILED(hr)) {
            return Error(IDS_E_NOREGACCESS, __uuidof(ITuningSpaceContainer), hr);
        }

        if (!pTuningSpace) {
            return E_POINTER;
        }
        VARIANT vartmp;
        vartmp.vt = VT_I4;
        vartmp.ulVal = 0;
        if (pvarIndex && pvarIndex->vt != VT_I4) {
            hr = VariantChangeType(&vartmp, pvarIndex, 0, VT_I4);
            if (FAILED(hr)) {
                vartmp.vt = VT_I4;
                vartmp.ulVal = 0;
            }
        }
        CComBSTR un(GetUniqueName(pTuningSpace));
        if (!un.Length()) {
            return Error(IDS_E_NOUNIQUENAME, __uuidof(ITuningSpace), E_FAIL);
        }
        return Add(un, vartmp.ulVal, pTuningSpace, pvarIndex);
    } CATCHCOM();
}

STDMETHODIMP CSystemTuningSpaces::Remove(VARIANT varIndex)
{
    try {
        // wait for exclusive access
        CAutoMutex mutex(m_hMutex);
		_ASSERT(m_mapTuningSpaces.size() == m_mapTuningSpaceNames.size());

        HRESULT hr = ChangeAccess(KEY_READ | KEY_WRITE);
        if (FAILED(hr)) {
            return hr;
        }

        TuningSpaceContainer_t::iterator its = m_mapTuningSpaces.end();
        TuningSpaceNames_t::iterator itn = m_mapTuningSpaceNames.end();

        long id;
        CComBSTR un;
        hr = Find(varIndex, id, its, un, itn);
        if (FAILED(hr)) {
            return Error(IDS_E_NO_TS_MATCH, __uuidof(ITuningSpaceContainer), E_INVALIDARG);
        }
        if (itn == m_mapTuningSpaceNames.end()) {
            ASSERT(its != m_mapTuningSpaces.end());  // otherwise find above should have returned failure
            hr = Find(its, un, itn);
            if (FAILED(hr) || itn == m_mapTuningSpaceNames.end()) {
                // found its but not itn, must have inconsistent cache
                return Error(IDS_E_NO_TS_MATCH, __uuidof(ITuningSpaceContainer), E_UNEXPECTED);
            }
        }
        
        m_mapTuningSpaces.erase(its);
        m_mapTuningSpaceNames.erase(itn);

        return DeleteID(id);
    } CATCHCOM();
}


STDMETHODIMP CSystemTuningSpaces::TuningSpacesForCLSID(BSTR bstrSpace, ITuningSpaces **ppTuningSpaces)
{
    try {
        return _TuningSpacesForCLSID(GUID2(bstrSpace), ppTuningSpaces);
    } catch (ComException &e) {
        return e;
    } catch (...) {
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CSystemTuningSpaces::_TuningSpacesForCLSID(REFCLSID clsidSpace, ITuningSpaces **ppTuningSpaces)
{
	if (!ppTuningSpaces) {
		return E_POINTER;
	}
	try {
	    ATL_LOCK();
		_ASSERT(m_mapTuningSpaces.size() == m_mapTuningSpaceNames.size());
		CTuningSpaces* pTSCollection = new CTuningSpaces;
		for (TuningSpaceContainer_t::iterator i = m_mapTuningSpaces.begin(); i != m_mapTuningSpaces.end(); ++i) {
			CComVariant v((*i).second);
			if (v.vt != VT_UNKNOWN && v.vt != VT_DISPATCH) {
				return E_UNEXPECTED; //corrupt in-memory collection
			}
			PQPersist pTS(v.punkVal);
			if (!pTS) {
                delete pTSCollection;
				return E_UNEXPECTED;  // corrupt in-memory collection;
			}
			GUID2 g;
			HRESULT hr = pTS->GetClassID(&g);
			if (FAILED(hr)) {
                delete pTSCollection;
				return E_UNEXPECTED;
			}
			if (g == clsidSpace) {
                PQTuningSpace newts;
                hr = PQTuningSpace(pTS)->Clone(&newts);
                if (FAILED(hr)) {
                    delete pTSCollection;
                    return hr;
                }
                pTSCollection->m_mapTuningSpaces[(*i).first] = CComVariant(newts);
			}
		}
		*ppTuningSpaces = pTSCollection;
		(*ppTuningSpaces)->AddRef();
		return NOERROR;
	} catch(...) {
		return E_UNEXPECTED;
	}

}

STDMETHODIMP CSystemTuningSpaces::TuningSpacesForName(BSTR bstrName, ITuningSpaces **ppTuningSpaces)
{
	if (!ppTuningSpaces) {
		return E_POINTER;
	}
	try {
	    ATL_LOCK();
		_ASSERT(m_mapTuningSpaces.size() == m_mapTuningSpaceNames.size());
		PQRegExp pRE;
		HRESULT hr;
		if (!m_cookieRegExp) {
            // at the time this code was written the only regex library that was readily available
            // was the one in the vbscript engine.  therefore we create and access this through
            // com.  however, this is an apartment model object this we have to create it
            // on a background apartment thread so we can always marshall over and access no matter
            // what thread we're on.
            // there is now a good c++ regex in the http://toolbox and at some point we should probably 
            // check it for thread safety and convert.
			m_pRET = new CRegExThread();
			if (!m_pRET) {
				return E_OUTOFMEMORY;
			}
			if (!m_pRET->Create()) {
				return E_UNEXPECTED;
			}
			hr = m_pRET->CallWorker(CRegExThread::RETHREAD_CREATEREGEX);
			if (FAILED(hr)) {
				return hr;
			}
			m_cookieRegExp = m_pRET->GetCookie();
			if (!m_cookieRegExp) {
				return E_UNEXPECTED;
			}
		} 
		if (!m_pGIT) {
			hr = m_pGIT.CoCreateInstance(CLSID_StdGlobalInterfaceTable, 0, CLSCTX_INPROC_SERVER);
			if (FAILED(hr)) {
				return hr;
			}
		}
		hr = m_pGIT->GetInterfaceFromGlobal(m_cookieRegExp, __uuidof(IRegExp), reinterpret_cast<LPVOID *>(&pRE));
		if (FAILED(hr)) {
			return hr;
		}
		hr = pRE->put_Pattern(bstrName);
		if (FAILED(hr)) {
			return hr;
		}

		CTuningSpaces* pTSCollection = new CTuningSpaces;
		for (TuningSpaceContainer_t::iterator i = m_mapTuningSpaces.begin(); i != m_mapTuningSpaces.end(); ++i) {
			if ((*i).second.vt != VT_UNKNOWN && (*i).second.vt != VT_DISPATCH) {
				return E_UNEXPECTED; //corrupt in-memory collection
			}
			PQTuningSpace pTS((*i).second.punkVal);
			CComBSTR name;
			hr = pTS->get_FriendlyName(&name);
			if (FAILED(hr)) {
				return E_UNEXPECTED;
			}
            PQTuningSpace newTS;
			VARIANT_BOOL bMatch = VARIANT_FALSE;
			hr = pRE->Test(name, &bMatch);
			if (FAILED(hr) || bMatch != VARIANT_TRUE) {
				hr = pTS->get_UniqueName(&name);
				if (FAILED(hr)) {
					return E_UNEXPECTED;
				}
				hr = pRE->Test(name, &bMatch);
				if (FAILED(hr) || bMatch != VARIANT_TRUE) {
                    continue;
                }
            }
            hr = pTS->Clone(&newTS);
            if (FAILED(hr)) {
                return hr;
            }
            pTSCollection->m_mapTuningSpaces[(*i).first] = newTS;
		}

		*ppTuningSpaces = pTSCollection;
		(*ppTuningSpaces)->AddRef();
		return NOERROR;
	} catch(...) {
		return E_UNEXPECTED;
	}
}

STDMETHODIMP CSystemTuningSpaces::get_MaxCount(LONG *plVal)
{
	if (!plVal) {
		return E_POINTER;
	}
	try {
	    ATL_LOCK();
		_ASSERT(m_mapTuningSpaces.size() == m_mapTuningSpaceNames.size());
		*plVal = m_MaxCount;
		return NOERROR;
	} catch(...) {
		return E_POINTER;
	}

}

STDMETHODIMP CSystemTuningSpaces::put_MaxCount(LONG lVal)
{
	try {
        if (lVal < 0) {
            return E_INVALIDARG;
        }
	    CAutoMutex mutex(m_hMutex);
		_ASSERT(m_mapTuningSpaces.size() == m_mapTuningSpaceNames.size());
        HRESULT hr = ChangeAccess(KEY_READ | KEY_WRITE);
        if (FAILED(hr)) {
            return hr;
        }
		ULONG count = max(lVal, m_mapTuningSpaces.size());
		CComVariant v;
		v.vt = VT_UI4;
		v.lVal = count;
		PQPropertyBag pb(m_pTSBag);
		if (!pb) {
			return E_UNEXPECTED;
		}
		hr = pb->Write(MAX_COUNT_NAME, &v);
		if (FAILED(hr)) {
			return hr;
		}
		m_MaxCount = count;
		if (m_MaxCount != lVal) {
			return S_FALSE;
		}
		return NOERROR;
    } CATCHCOM();
}

STDMETHODIMP CSystemTuningSpaces::FindID(ITuningSpace *pTS, long* pID)
{
    try {
		if (!pID || !pTS) {
			return E_POINTER;
		}
	    ATL_LOCK();
		_ASSERT(m_mapTuningSpaces.size() == m_mapTuningSpaceNames.size());
        CComBSTR un(GetUniqueName(pTS));
        if (!un.Length()) {
            return Error(IDS_E_NOUNIQUENAME, __uuidof(ITuningSpace), E_UNEXPECTED);
        }
        *pID = GetID(un);
        if (!(*pID)) {
            return Error(IDS_E_NO_TS_MATCH, __uuidof(ITuningSpace), E_INVALIDARG);
        }
        return NOERROR;
    } catch (...) {
        return E_UNEXPECTED;
    }
}

HRESULT CSystemTuningSpaces::RegisterTuningSpaces(HINSTANCE hMod) {
	try {
		CAutoMutex mutex(m_hMutex);
		_ASSERT(m_mapTuningSpaces.size() == m_mapTuningSpaceNames.size());
		CString cs;
		cs.LoadString(IDS_RGSLIST_TYPE);
		HRSRC hRes = ::FindResource(hMod, MAKEINTRESOURCE(IDR_CANONICAL_TUNINGSPACE_LIST), (LPCTSTR)cs);
		if (!hRes) {
			return HRESULT_FROM_WIN32(::GetLastError());
		}
		HANDLE hData = ::LoadResource(hMod, hRes);
		if (!hData) {
			return HRESULT_FROM_WIN32(::GetLastError());
		}
		DWORD *p = reinterpret_cast<DWORD *>(::LockResource(hData));
		if (!p) {
			return HRESULT_FROM_WIN32(::GetLastError());
		}
		cs.LoadString(IDS_TUNINGSPACE_FRAGMENT_TYPE);
		for (DWORD idx = 1; idx <= p[0]; ++idx) {
			hRes = ::FindResource(hMod, MAKEINTRESOURCE(p[idx]), (LPCTSTR)cs);
			if (!hRes) {
				return HRESULT_FROM_WIN32(::GetLastError());
			}
			LPCSTR psz = reinterpret_cast<LPCSTR>(::LoadResource(hMod, hRes));
			if (!psz) {
				return HRESULT_FROM_WIN32(::GetLastError());
			}
			USES_CONVERSION;
			int cch;
			CRegObject cro;  // init %mapping% macros here if desired
			PQPropertyBag rgsBag(new CRGSBag(A2CT(psz), cro, cch));
            if (!rgsBag) {
                return E_UNEXPECTED;
            }
			CString csName;
			csName.LoadString(IDS_TSKEYNAMEVAL);
			CComVariant tsval;
			HRESULT hr = rgsBag->Read(T2COLE(csName), &tsval, NULL);
			if (FAILED(hr)) {
				return E_FAIL;  // bad script, no unique name property
			}
			if (tsval.vt != VT_UNKNOWN) {
				return DISP_E_TYPEMISMATCH;
			}
			PQTuningSpace pTS(tsval.punkVal);
			if (!pTS) {
				return DISP_E_TYPEMISMATCH;
			}
			CComVariant Varidx;
			Varidx.vt = VT_UI4;
			Varidx.ulVal = 0;
			hr = Add(pTS, &Varidx);
			// ignore existing ts w/ same unique name and move one
			if (FAILED(hr) && hr != HRESULT_FROM_WIN32(ERROR_DUP_NAME)) {  
				return hr;
			}
		}
	    return NOERROR;
    } CATCHCOM();
}

HRESULT CSystemTuningSpaces::UnregisterTuningSpaces() {
    try {
        CAutoMutex mutex(m_hMutex);
	    _ASSERT(m_mapTuningSpaces.size() == m_mapTuningSpaceNames.size());
	    // currently we delete all tuning spaces when we unreg
        // its possible that it would be better to just delete the canonical ones
        // that we created when we registered.  on the other hand, that reg space
        // would leak forever if tv support is really being uninstalled.  and, since
        // we're in the os we're unlikely to ever get unregistered anyway.
        HRESULT hr = OpenRootKeyAndBag(KEY_READ | KEY_WRITE);
        if (SUCCEEDED(hr)) {
            DWORD rc = m_RootKey.RecurseDeleteKey(_T(""));
            if (rc != ERROR_SUCCESS) {
                return E_FAIL;
            }
        }
        return NOERROR;
    } CATCHCOM();
}

HRESULT UnregisterTuningSpaces() {
    PQTuningSpaceContainer pst(CLSID_SystemTuningSpaces, NULL, CLSCTX_INPROC_SERVER);
    if (!pst) {
        return E_UNEXPECTED;
    }
    CSystemTuningSpaces *pc = static_cast<CSystemTuningSpaces *>(pst.p);
    return pc->UnregisterTuningSpaces();

}

HRESULT RegisterTuningSpaces(HINSTANCE hMod) {
    PQTuningSpaceContainer pst(CLSID_SystemTuningSpaces, NULL, CLSCTX_INPROC_SERVER);
    if (!pst) {
        return E_UNEXPECTED;
    }
    CSystemTuningSpaces *pc = static_cast<CSystemTuningSpaces *>(pst.p);
    return pc->RegisterTuningSpaces(hMod);
}

};
// end of file - tuningspacecontainer.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\vidctl.cpp ===
//===========================================================================
//
// VidCtl.cpp : Implementation of CVidCtl the core viewer control class
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#ifndef TUNING_MODEL_ONLY
#define ENCODERCAT_HACK 1
#include <atlgdi.h>
#include <bdatypes.h>
#include <bdamedia.h>
#include <evcode.h>
#include <wmsdk.h>
#include <wininet.h>
#include "seg.h"
#include "MSVidtvtuner.h"
#include "msvidvideorenderer.h"
#include "msvidwebdvd.h"
#include "VidCtl.h"
#include "msvidsbesink.h"
#include "msvidsbesource.h"
#include "msvidfileplayback.h"
//#include "perfevents.h"

const WCHAR g_kwszDVDURLPrefix[] = L"DVD:";
const WCHAR g_kwszDVDSimpleURL[] = L"DVD";

DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidCtl, CVidCtl)

MediaMajorTypeList CVidCtl::VideoTypes;
MediaMajorTypeList CVidCtl::AudioTypes;


#ifndef KSCATEGORY_ENCODER
#define STATIC_KSCATEGORY_ENCODER \
    0x19689bf6, 0xc384, 0x48fd, 0xad, 0x51, 0x90, 0xe5, 0x8c, 0x79, 0xf7, 0xb
DEFINE_GUIDSTRUCT("19689BF6-C384-48fd-AD51-90E58C79F70B", KSCATEGORY_ENCODER);
#define KSCATEGORY_ENCODER DEFINE_GUIDNAMED(KSCATEGORY_ENCODER)
#endif

/////////////////////////////////////////////////////////////////////////////
// CVidCtl

STDMETHODIMP CVidCtl::get_State(MSVidCtlStateList *lState){
    try{
        if(lState){
            *lState = m_State;
            return S_OK;
        }
        return E_POINTER;
    }
    catch(HRESULT hres){
        return hres;
    }   
    catch(...){
        return E_UNEXPECTED;
    }
}

CVidCtl::~CVidCtl() {
    try {
        try {
            if (m_pGraph && !m_pGraph.IsStopped()) {
                Stop();
            }
        } catch(...) {
        }
        m_pSystemEnum.Release();
        m_pFilterMapper.Release();
        DecomposeAll(); // put_Container(NULL) on all the composition segments
        m_pComposites.clear();
        if (m_pInput) {
            PQGraphSegment(m_pInput)->put_Container(NULL);
            m_pInput.Release();
        }
        if (m_pVideoRenderer) {
            PQGraphSegment(m_pVideoRenderer)->put_Container(NULL);
            m_pVideoRenderer.Release();
        }
        if (m_pAudioRenderer) {
            PQGraphSegment(m_pAudioRenderer)->put_Container(NULL);
            m_pAudioRenderer.Release();
        }

        {
            // chosen devices&Outputs
            if (!!m_pOutputsInUse && m_pOutputsInUse.begin() != m_pOutputsInUse.end()) {

                VWOutputDevices::iterator i;
                for (i = m_pOutputsInUse.begin(); i != m_pOutputsInUse.end(); ++i) {
                    if ((*i).punkVal) {
                        PQGraphSegment((*i).punkVal)->put_Container(NULL);
                    }
                }
                m_pOutputsInUse.Release();
            }

        }

        {
            // chosen devices&features
            if(m_pFeaturesInUse && m_pFeaturesInUse.begin() != m_pFeaturesInUse.end()){
                VWFeatures::iterator i;
                for (i = m_pFeaturesInUse.begin(); i != m_pFeaturesInUse.end(); ++i) {
                    if ((*i).punkVal) {
                        PQGraphSegment((*i).punkVal)->put_Container(NULL);
                    }
                }
                m_pFeaturesInUse.Release();
            }
        }

        // available collections
        m_pInputs.Release();
        m_pOutputs.Release();
        m_pFeatures.Release();
        m_pVRs.Release();
        m_pARs.Release();

        if (m_fNotificationSet) {
            m_pGraph.SetMediaEventNotificationWindow(0, 0, 0);
        }
        if (m_pGraph) {
            if (m_dwROTCookie) {
                m_pGraph.RemoveFromROT(m_dwROTCookie);
            }
            m_pGraph.Release();
        }
        if (m_pTopWin && m_pTopWin->m_hWnd && ::IsWindow(m_pTopWin->m_hWnd)) {
            m_pTopWin->SendMessage(WM_CLOSE);
            delete m_pTopWin;
            m_pTopWin = NULL;
        }
    } catch (...) {
        TRACELM(TRACE_ERROR, "CVidCtl::~CVidCtl() catch(...)");
    }
}


void CVidCtl::Init()
{
    VIDPERF_FUNC;
    if (m_fInit) return;

    TRACELM(TRACE_DETAIL, "CVidCtl::Init()");
    ASSERT(!m_pGraph);

    m_pGraph = PQGraphBuilder(CLSID_FilterGraph, NULL, CLSCTX_INPROC_SERVER);
    if (!m_pGraph) {
        TRACELM(TRACE_ERROR, "CVidCtl::Init() can't create graph object");
        THROWCOM(E_UNEXPECTED);
    }
    PQObjectWithSite pos(m_pGraph);
    if (pos) {
        pos->SetSite(static_cast<IMSVidCtl*>(this));
    }

    HRESULT hr =  m_pGraph.AddToROT(&m_dwROTCookie);
    if (FAILED(hr)) {
        m_dwROTCookie = 0;
        TRACELM(TRACE_ERROR, "CVidCtl::Init() can't add graph to ROT");
    }

    TRACELSM(TRACE_DETAIL, (dbgDump << "CVidCtl::Init() graph = " << m_pGraph), "");
    SetTimer();
    SetMediaEventNotification();
    if (!m_pSystemEnum) {
        m_pSystemEnum = PQCreateDevEnum(CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER);
        ASSERT(m_pSystemEnum);
    }
    if (!m_pFilterMapper) {
        m_pFilterMapper = m_pGraph;
        ASSERT(m_pFilterMapper);
    }

    m_pFeaturesInUse = static_cast<IMSVidFeatures *>(new CFeatures(false, true));
    m_pOutputsInUse = static_cast<IMSVidOutputDevices *>(new COutputDevices(false, true));
    m_fInit = true;

}


HRESULT CVidCtl::GetInputs(const GUID2& catguid, VWInputDevices& pInputs)
{
    VIDPERF_FUNC;
    //undone: look up category guid to segment object mapping in registry
    // for now we're just hard coding the few we're testing with

    // inputs

    if (catguid == KSCATEGORY_TVTUNER) {
        CInputDevices *pDev = new CInputDevices(true);
        DSDevices TunerList(m_pSystemEnum, catguid);
        DSDevices::iterator i;
        for (i = TunerList.begin(); i != TunerList.end(); ++i) {
            PQGraphSegment p(CLSID_MSVidAnalogTunerDevice);
            if (!p) continue;
            p->put_Init(*i);
            pDev->m_Devices.push_back(PQDevice(p));
        }
        pDev->Valid = true;
        pInputs = static_cast<IMSVidInputDevices *>(pDev);
        return NOERROR;
    } else if (catguid == KSCATEGORY_BDA_NETWORK_PROVIDER || catguid == KSCATEGORY_BDA_NETWORK_TUNER) {
        GUID2 catguid2 = KSCATEGORY_BDA_NETWORK_PROVIDER; 
        CInputDevices *pDev = new CInputDevices(true);
        DSDevices TunerList(m_pSystemEnum, catguid2);
        DSDevices::iterator i;
        for (i = TunerList.begin(); i != TunerList.end(); ++i) {
            PQGraphSegment p(CLSID_MSVidBDATunerDevice);
            if (!p) continue;
            p->put_Init(*i);
            pDev->m_Devices.push_back(PQDevice(p));
        }
        pDev->Valid = true;
        pInputs = static_cast<IMSVidInputDevices *>(pDev);
        return NOERROR;
    } else if (catguid == GUID_NULL) {
        CInputDevices *pDev = new CInputDevices(true);
        // non cat enumerated devices
        {
            PQGraphSegment p(CLSID_MSVidFilePlaybackDevice);
            if (!p) {
                _ASSERT(false);
                pDev->Release();
                return E_NOTIMPL;
            }
            p->put_Init(NULL);
            pDev->m_Devices.push_back(PQDevice(p));
            pDev->Valid = true;
            pInputs = static_cast<IMSVidInputDevices *>(pDev);
        }
        {
            PQGraphSegment p(CLSID_MSVidWebDVD);
            if (!p) {
                _ASSERT(false);
                pDev->Release();
                return E_NOTIMPL;
            }
            p->put_Init(NULL);
            pDev->m_Devices.push_back(PQDevice(p));
            pDev->Valid = true;
            pInputs = static_cast<IMSVidInputDevices *>(pDev);
        }
        {

            PQGraphSegment p(CLSID_MSVidStreamBufferSource);
            if (!p) {
                _ASSERT(false);
                pDev->Release();
                return E_NOTIMPL;
            }
            p->put_Init(NULL);
            pDev->m_Devices.push_back(PQDevice(p));
            pDev->Valid = true;
            pInputs = static_cast<IMSVidInputDevices *>(pDev);

        }

        return NOERROR;
    }


    return E_INVALIDARG;
}

HRESULT CVidCtl::GetOutputs(const GUID2& CategoryGuid)
{
    VIDPERF_FUNC;
    // We only have one output
    if (CategoryGuid == GUID_NULL) {
        COutputDevices *pDev = new COutputDevices(true);
        PQGraphSegment p(CLSID_MSVidStreamBufferSink);
        if (!p) {
            pDev->Release();
            return E_NOTIMPL;
        }
        p->put_Init(NULL);
        pDev->m_Devices.push_back(PQDevice(p));
        pDev->Valid = true;
        m_pOutputs = static_cast<IMSVidOutputDevices *>(pDev);
    }
    return S_OK;    

}

HRESULT CVidCtl::GetVideoRenderers()
{
    VIDPERF_FUNC;
    //Video Renderers
    CVideoRendererDevices *pDevs = new CVideoRendererDevices(true);

    PQGraphSegment p(CLSID_MSVidVideoRenderer);
    if (!p) {
        pDevs->Release();
        return Error(IDS_CANT_CREATE_FILTER, __uuidof(IMSVidCtl), IDS_CANT_CREATE_FILTER);
    }

    p->put_Init(NULL);
    PQDevice pd(p);
    if (!pd) {
        pDevs->Release();
        return E_UNEXPECTED;
    }
    pDevs->m_Devices.push_back(pd);
    pDevs->Valid = true;
    m_pVRs = static_cast<IMSVidVideoRendererDevices *>(pDevs);

    return NOERROR;
}

HRESULT CVidCtl::GetAudioRenderers()
{
    VIDPERF_FUNC;
    //Audio Renderers
    CAudioRendererDevices *pDevs = new CAudioRendererDevices(true);

    PQGraphSegment p(CLSID_MSVidAudioRenderer);
    if (!p) {
        pDevs->Release();
        return Error(IDS_CANT_CREATE_FILTER, __uuidof(IMSVidCtl), IDS_CANT_CREATE_FILTER);
    }
    p->put_Init(NULL);
    PQDevice pd(p);
    if (!pd) {
        pDevs->Release();
        return E_UNEXPECTED;
    }
    pDevs->m_Devices.push_back(pd);
    pDevs->Valid = true;
    m_pARs = static_cast<IMSVidAudioRendererDevices *>(pDevs);
    return NOERROR;
}

HRESULT CVidCtl::GetFeatures()
{
    VIDPERF_FUNC;
    // available features
    // undone: change hard coded list of features into registry lookup
    if (!m_pFeatures) {
        CFeatures *pDev = new CFeatures;
        if (!pDev) {
            return E_OUTOFMEMORY;
        }
        pDev->Valid = true;
        m_pFeatures = static_cast<IMSVidFeatures *>(pDev);
        {
            PQGraphSegment p(CLSID_MSVidDataServices);
            if (p) {
                p->put_Init(NULL);
                pDev->m_Devices.push_back(PQDevice(p));
            } else {
                _ASSERT(false);
            }
        }

        {
            PQGraphSegment p(CLSID_MSVidClosedCaptioning);
            if (p) {
                p->put_Init(NULL);
                pDev->m_Devices.push_back(PQDevice(p));
            } else {
                _ASSERT(false);
            }
        }
        {
            PQGraphSegment p(CLSID_MSVidXDS);
            if (p) {
                p->put_Init(NULL);
                pDev->m_Devices.push_back(PQDevice(p));
            } else {
                _ASSERT(false);
            }
        }
#if ENCODERCAT_HACK
        bool AddedMux = false;
#endif
        {
            // Hardware mux category
            DSDevices EncoderList(m_pSystemEnum, KSCATEGORY_MULTIPLEXER);
            DSDevices::iterator i;
            for (i = EncoderList.begin(); i != EncoderList.end(); ++i) {
                PQGraphSegment p(CLSID_MSVidEncoder);
                if (!p) continue;
                p->put_Init(*i);
                pDev->m_Devices.push_back(PQDevice(p));
#if ENCODERCAT_HACK
                AddedMux = true;
#endif
            }
        }
        {
            // Software mux category
            DSDevices EncoderList(m_pSystemEnum, CLSID_MediaMultiplexerCategory);
            DSDevices::iterator i;
            for (i = EncoderList.begin(); i != EncoderList.end(); ++i) {
                PQGraphSegment p(CLSID_MSVidEncoder);
                if (!p) continue;
                p->put_Init(*i);
                pDev->m_Devices.push_back(PQDevice(p));
#if ENCODERCAT_HACK
                AddedMux = true;
#endif
            }
        }
#if ENCODERCAT_HACK
        if(!AddedMux){
            DSDevices EncoderList(m_pSystemEnum, KSCATEGORY_ENCODER);
            DSDevices::iterator i;
            for (i = EncoderList.begin(); i != EncoderList.end(); ++i) {
                PQGraphSegment p(CLSID_MSVidEncoder);
                if (!p) continue;
                p->put_Init(*i);
                pDev->m_Devices.push_back(PQDevice(p));
            }
        }
#endif

    }

    return NOERROR;
}

// Takes a variant input and a list of input devices to attempt to view the input with
HRESULT CVidCtl::SelectViewFromSegmentList(CComVariant &pVar, VWInputDevices& grList, PQInputDevice& pCurInput) {
    VIDPERF_FUNC;
    VWInputDevices::iterator i = grList.begin();
    // skip devices until we're past the current one(if there is a current one)
    for (; pCurInput && i != grList.end(); ++i) {
        PQInputDevice pInDev((*i).punkVal);
        VARIANT_BOOL f = VARIANT_FALSE;
        HRESULT hr = pCurInput->IsEqualDevice(pInDev, &f);
        if (SUCCEEDED(hr) && f == VARIANT_TRUE){
            ++i;
            break;
        }
    }  
    // run thru to the end of the list
    for (; i != grList.end(); ++i) {
        PQInputDevice pInDev((*i).punkVal);
        HRESULT hr = pInDev->View(&pVar);
        if(SUCCEEDED(hr)){
            if(m_pInput){
                PQGraphSegment(m_pInput)->put_Container(NULL);
            }
            m_pInput = pInDev;
            m_pInputNotify = m_pInput;
            m_CurView = pVar;
            m_fGraphDirty = true;
            return NOERROR;
        }   
    }  
    if (pCurInput) {
        // retry the ones we skipped
        i = grList.begin();
        for (; i != grList.end(); ++i) {
            PQInputDevice pInDev((*i).punkVal);
            HRESULT hr = pInDev->View(&pVar);
            if(SUCCEEDED(hr)){
                if(m_pInput){
                    PQGraphSegment(m_pInput)->put_Container(NULL);
                }
                m_pInput = pInDev;
                m_pInputNotify = m_pInput;
                m_CurView = pVar;
                m_fGraphDirty = true;
                return NOERROR;
            }   
        }  
    }

    return E_FAIL;
}

// non-interface functions
HRESULT CVidCtl::SelectView(VARIANT *pv, bool fNext) {
    VIDPERF_FUNC;
    HRESULT hr;
    TRACELM(TRACE_DETAIL, "CVidCtl::SelectView()");
    if (!m_fInit) {
        Init();
    }
    if (!pv) {
        m_CurView = CComVariant();
        return NOERROR;
    }
    CComVariant pVar(*pv);
    if(pv->vt & VT_BYREF){
        if(pv->vt == (VT_UNKNOWN|VT_BYREF)){
            pVar=(*reinterpret_cast<IUnknown**>(pv->punkVal));
        }
        else if(pv->vt == (VT_DISPATCH|VT_BYREF)){
            pVar = (*reinterpret_cast<IDispatch**>(pv->pdispVal));
        }
    }
    if (!pVar) {
        m_CurView = CComVariant();
        return NOERROR;
    }
    if (m_pInput && !fNext)  {
        // && pVar != m_CurView) {
        // note: only try different content on current device, 
        // if app tries to re-view the current view content then we 
        // attempt to iterate to next available device
        hr = m_pInput->View(&pVar);
        if (SUCCEEDED(hr)) {
            // currently selected device can view this new content
            return hr;
        }
    }
    if (m_pGraph.GetState() != State_Stopped) {
        return Error(IDS_INVALID_STATE, __uuidof(IMSVidCtl), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
    }

    if (m_pInput) {
        hr = DecomposeSegment(VWGraphSegment(m_pInput));
        if (FAILED(hr)) {
            return Error(IDS_CANT_REMOVE_SEG, __uuidof(IMSVidCtl), IDS_CANT_REMOVE_SEG);
        }
    }
    // Try the ATSC tune request
    if (pVar.vt == VT_UNKNOWN || pVar.vt == VT_DISPATCH) {
        PQTuneRequest ptr(pVar.vt == VT_UNKNOWN ? pVar.punkVal : pVar.pdispVal);
        if (ptr) {
            VWInputDevices pInputs;
            PQChannelTuneRequest ptr2(ptr);
            if (ptr2) {
                PQATSCChannelTuneRequest ptr3(ptr);
                if (!ptr3) {
                    hr = GetInputs(KSCATEGORY_TVTUNER, pInputs);
                    if(SUCCEEDED(hr)){
                        hr = SelectViewFromSegmentList(pVar, pInputs, m_pInput);
                        if(SUCCEEDED(hr)){
                            m_CurViewCatGuid = KSCATEGORY_TVTUNER;
                            return hr;
                        }
                    }
                }
            }

            hr = GetInputs(KSCATEGORY_BDA_NETWORK_PROVIDER, pInputs);
            if(SUCCEEDED(hr)){
                hr = SelectViewFromSegmentList(pVar, pInputs, m_pInput);
                if(SUCCEEDED(hr)){
                    m_CurViewCatGuid = KSCATEGORY_BDA_NETWORK_PROVIDER;
                    return hr;
                }
            }
            if(FAILED(hr)){
                return hr;
            }
        }
    }

    // Try to view the File input and DVD Segments
    VWInputDevices pInputs;
    hr = GetInputs(GUID_NULL, pInputs);
    hr = SelectViewFromSegmentList(pVar, pInputs, m_pInput);
    if(SUCCEEDED(hr)){
        m_CurViewCatGuid = GUID_NULL;
        return hr;
    }
    return Error(IDS_CANT_VIEW, __uuidof(IMSVidCtl), IDS_CANT_VIEW);
}


HRESULT CVidCtl::LoadDefaultVR(void) {
    VIDPERF_FUNC;
    PQVRGraphSegment pGS;
    HRESULT hr = pGS.CoCreateInstance(CLSID_MSVidVideoRenderer);
    if (FAILED(hr) || !pGS) {
        TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::LoadDefaultVR() can't instantiate default video renderer. hr = " << std::hex << hr), "");
        return Error(IDS_CANT_CREATE_FILTER, __uuidof(IMSVidCtl), IDS_CANT_CREATE_FILTER);
    }
    hr = pGS->put_Init(NULL);
    if (FAILED(hr)) {
        TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::LoadDefaultVR() can't init default video renderer. hr = " << std::hex << hr), "");
        return hr;
    }
    hr = pGS->put_Container(this);
    if (FAILED(hr)) {
        TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::LoadDefaultVR() can't load default video renderer. hr = " << std::hex << hr), "");
        return hr;
    }
    if (!m_bNegotiatedWnd) {
        if (!m_bInPlaceActive) {
            hr = InPlaceActivate(OLEIVERB_INPLACEACTIVATE, NULL);
            if (FAILED(hr)) {
                return hr;
            }
        }
    }
#if 0
    VARIANT_BOOL ov = (m_bWndLess && WindowHasHWOverlay(m_CurrentSurface.Owner())) ? VARIANT_TRUE : VARIANT_FALSE;
#else
    // always try to use overlay if we're wndless. vmr will tell us if it isn't available
    VARIANT_BOOL ov = m_bWndLess ? VARIANT_TRUE : VARIANT_FALSE;
#endif
    hr = pGS->put_UseOverlay(ov);
    if (FAILED(hr)) {
        TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::LoadDefaultVR() can't set useoverlay. hr = " << std::hex << hr), "");
        return hr;
    }
    m_pVideoRenderer = pGS;

    return NOERROR;
}

HRESULT CVidCtl::LoadDefaultAR(void) {
    VIDPERF_FUNC;
    PQGraphSegment pGS;
    HRESULT hr = pGS.CoCreateInstance(CLSID_MSVidAudioRenderer);
    if (FAILED(hr) || !pGS) {
        TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::LoadDefaultAR() can't instantiate default Audio renderer. hr = " << std::hex << hr), "");
        return Error(IDS_CANT_CREATE_FILTER, __uuidof(IMSVidCtl), IDS_CANT_CREATE_FILTER);
    }
    hr = pGS->put_Init(NULL);
    if (FAILED(hr)) {
        TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::LoadDefaultAR() can't init default Audio renderer. hr = " << std::hex << hr), "");
        return hr;
    }
    hr = pGS->put_Container(this);
    if (FAILED(hr)) {
        TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::LoadDefaultAR() can't load default Audio renderer. hr = " << std::hex << hr), "");
        return hr;
    }
    m_pAudioRenderer = pGS;

    return NOERROR;
}

HRESULT CVidCtl::Compose(VWGraphSegment &Up, VWGraphSegment &Down, int &NewIdx) {
    VIDPERF_FUNC;
    PQCompositionSegment pCS;
#if 0
    // This code is for returning error codes in failure cases for the default composition segment
    HRESULT hrExpected = S_OK;
    HRESULT hrFailed = E_FAIL;
    bool bCheckHR = false;
#endif
    _ASSERT(!!Up && !!Down);

    // Analog TV to Video Renderer Composition Segment
    if (VWGraphSegment(Up).Category() == KSCATEGORY_TVTUNER && VWGraphSegment(Down).ClassID() == CLSID_MSVidVideoRenderer) {
        HRESULT hr = pCS.CoCreateInstance(CLSID_MSVidAnalogCaptureToOverlayMixer);
        if (FAILED(hr) || !pCS) {
            TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::Compose() can't instantiate analog capture to ov mixer composite. hr = " << std::hex << hr), "");
            return Error(IDS_CANT_CREATE_CUSTOM_COMPSEG, __uuidof(IMSVidCtl), IDS_CANT_CREATE_CUSTOM_COMPSEG);
        }
    }
    // Analog TV to Stream Buffer Sink Compsition Segment
    else if (VWGraphSegment(Up).Category() == KSCATEGORY_TVTUNER && VWGraphSegment(Down).ClassID() == CLSID_MSVidStreamBufferSink) {
        HRESULT hr = pCS.CoCreateInstance(CLSID_MSVidAnalogCaptureToStreamBufferSink);
        if (FAILED(hr) || !pCS) {
            TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::Compose() can't instantiate analog capture to time shift sink composite. hr = " << std::hex << hr), "");
            return Error(IDS_CANT_CREATE_CUSTOM_COMPSEG, __uuidof(IMSVidCtl), IDS_CANT_CREATE_CUSTOM_COMPSEG);
        }
    } 
    // Digital TV (bda) to Video Renderer Compsition Segment
    else if (VWGraphSegment(Up).ClassID() == CLSID_MSVidBDATunerDevice && VWGraphSegment(Down).ClassID() == CLSID_MSVidStreamBufferSink) {
        HRESULT hr = pCS.CoCreateInstance(CLSID_MSVidDigitalCaptureToStreamBufferSink);
        if (FAILED(hr) || !pCS) {
            TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::Compose() can't instantiate analog capture to time shift sink composite. hr = " << std::hex << hr), "");
            return Error(IDS_CANT_CREATE_CUSTOM_COMPSEG, __uuidof(IMSVidCtl), IDS_CANT_CREATE_CUSTOM_COMPSEG);
        }
    } 
    // Analog TV to Data Services Compsition Segment
    else if (VWGraphSegment(Up).Category() == KSCATEGORY_TVTUNER && VWGraphSegment(Down).ClassID() == CLSID_MSVidDataServices) {
        HRESULT hr = pCS.CoCreateInstance(CLSID_MSVidAnalogCaptureToDataServices);
        if (FAILED(hr) || !pCS) {
            TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::Compose() can't instantiate analog tuner/capture to data services composite. hr = " << std::hex << hr), "");
            return Error(IDS_CANT_CREATE_CUSTOM_COMPSEG, __uuidof(IMSVidCtl), IDS_CANT_CREATE_CUSTOM_COMPSEG);
        }
    }
    // Digial TV (bda) or DVD to Closed Caption Compsition Segment
    else if ((VWGraphSegment(Up).ClassID() == CLSID_MSVidBDATunerDevice || 
        VWGraphSegment(Up).ClassID() == CLSID_MSVidWebDVD) &&
        VWGraphSegment(Down).ClassID() == CLSID_MSVidClosedCaptioning) {
            HRESULT hr = pCS.CoCreateInstance(CLSID_MSVidMPEG2DecoderToClosedCaptioning);
            if (FAILED(hr) || !pCS) {
                TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::Compose() can't instantiate mp2 to CC composite. hr = " << std::hex << hr), "");
                return Error(IDS_CANT_CREATE_CUSTOM_COMPSEG, __uuidof(IMSVidCtl), IDS_CANT_CREATE_CUSTOM_COMPSEG);
            }
        }        
        // File Playback to Video Renderer Compsition Segment
    else if ((VWGraphSegment(Up).ClassID() == CLSID_MSVidFilePlaybackDevice ) &&
        VWGraphSegment(Down).ClassID() == CLSID_MSVidVideoRenderer) {
            HRESULT hr = pCS.CoCreateInstance(CLSID_MSVidFilePlaybackToVideoRenderer);
            if (FAILED(hr) || !pCS) {
                TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::Compose() can't instantiate file playback to video renderer composite. hr = " << std::hex << hr), "");
                return Error(IDS_CANT_CREATE_CUSTOM_COMPSEG, __uuidof(IMSVidCtl), IDS_CANT_CREATE_CUSTOM_COMPSEG);
            }
        } 
        // File Playback to Audio Renderer Compsition Segment
    else if ((VWGraphSegment(Up).ClassID() == CLSID_MSVidFilePlaybackDevice ) &&
        VWGraphSegment(Down).ClassID() == CLSID_MSVidAudioRenderer) {
            HRESULT hr = pCS.CoCreateInstance(CLSID_MSVidFilePlaybackToAudioRenderer);
            if (FAILED(hr) || !pCS) {
                TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::Compose() can't instantiate file playback to audio renderer composite. hr = " << std::hex << hr), "");
                return Error(IDS_CANT_CREATE_CUSTOM_COMPSEG, __uuidof(IMSVidCtl), E_UNEXPECTED);
            }
        } 
        // DVD to Video Renderer Compsition Segment
    else if (VWGraphSegment(Up).ClassID() == CLSID_MSVidWebDVD && VWGraphSegment(Down).ClassID() == CLSID_MSVidVideoRenderer) {
        HRESULT hr = pCS.CoCreateInstance(CLSID_MSVidWebDVDToVideoRenderer);
        if (FAILED(hr) || !pCS) {
            TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::Compose() can't instantiate webdvd to video renderer, hr = " << std::hex << hr), "");
            return Error(IDS_CANT_CREATE_CUSTOM_COMPSEG, __uuidof(IMSVidCtl), IDS_CANT_CREATE_CUSTOM_COMPSEG);
        }
    }
#if 0
    else if (VWGraphSegment(Up).ClassID() == CLSID_MSVidWebDVD && VWGraphSegment(Down).ClassID() == CLSID_MSVidAudioRenderer) {
        HRESULT hr = pCS.CoCreateInstance(CLSID_MSVidWebDVDToAudioRenderer);
        if (FAILED(hr) || !pCS) {
            TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::Compose() can't instantiate time shift source to data services composite. hr = " << std::hex << hr), "");
            return Error(IDS_CANT_CREATE_CUSTOM_COMPSEG, __uuidof(IMSVidCtl), IDS_CANT_CREATE_CUSTOM_COMPSEG);
        }
    }
#endif
    ///////////////////////////////////////////////////
    // New Compostion Segments for FreeStyle Endgame //
    ///////////////////////////////////////////////////
    // XDS to Stream Buffer Sink Compsition Segment
    else if (VWGraphSegment(Up).ClassID() == CLSID_MSVidXDS && (VWGraphSegment(Down).ClassID() == CLSID_MSVidStreamBufferSink)) {
        HRESULT hr = pCS.CoCreateInstance(CLSID_MSVidDataServicesToStreamBufferSink);
        if (FAILED(hr) || !pCS) {
            TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::Compose() can't instantiate time shift source to data services composite. hr = " << std::hex << hr), "");
            return Error(IDS_CANT_CREATE_CUSTOM_COMPSEG, __uuidof(IMSVidCtl), IDS_CANT_CREATE_CUSTOM_COMPSEG);
        }
    }
    // Encoder to Stream Buffer Sink Compsition Segment
    else if (VWGraphSegment(Up).ClassID() == CLSID_MSVidEncoder && (VWGraphSegment(Down).ClassID() == CLSID_MSVidStreamBufferSink)) {
        HRESULT hr = pCS.CoCreateInstance(CLSID_MSVidEncoderToStreamBufferSink);
        if (FAILED(hr) || !pCS) {
            TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::Compose() can't instantiate encoder to time shift sink composite. hr = " << std::hex << hr), "");
            return Error(IDS_CANT_CREATE_CUSTOM_COMPSEG, __uuidof(IMSVidCtl), IDS_CANT_CREATE_CUSTOM_COMPSEG);
        }
    } 
    // StreamBufferSource to Video Renderer Compsition Segment
    else if ((VWGraphSegment(Up).ClassID() == CLSID_MSVidStreamBufferSource ) &&
        VWGraphSegment(Down).ClassID() == CLSID_MSVidVideoRenderer) {
            HRESULT hr = pCS.CoCreateInstance(CLSID_MSVidStreamBufferSourceToVideoRenderer); // name change needed
            if (FAILED(hr) || !pCS) {
                TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::Compose() can't instantiate time shift source to CC composite. hr = " << std::hex << hr), "");
                return Error(IDS_CANT_CREATE_CUSTOM_COMPSEG, __uuidof(IMSVidCtl), IDS_CANT_CREATE_CUSTOM_COMPSEG);
            }
        }
        // Analog Capture to XDS
    else if (VWGraphSegment(Up).Category() == KSCATEGORY_TVTUNER && VWGraphSegment(Down).ClassID() == CLSID_MSVidXDS){
        HRESULT hr = pCS.CoCreateInstance(CLSID_MSVidAnalogCaptureToXDS); 
        if (FAILED(hr) || !pCS) {
            TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::Compose() can't instantiate analog capture to XDS composite. hr = " << std::hex << hr), "");
            return Error(IDS_CANT_CREATE_CUSTOM_COMPSEG, __uuidof(IMSVidCtl), IDS_CANT_CREATE_CUSTOM_COMPSEG);
        }
    }
    // Analog Capture to Encoder
    else if (VWGraphSegment(Up).Category() == KSCATEGORY_TVTUNER && VWGraphSegment(Down).ClassID() == CLSID_MSVidEncoder){
        HRESULT hr = pCS.CoCreateInstance(CLSID_MSVidAnalogTVToEncoder); 
        if (FAILED(hr) || !pCS) {
            TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::Compose() can't instantiate analog capture to XDS composite. hr = " << std::hex << hr), "");
            return Error(IDS_CANT_CREATE_CUSTOM_COMPSEG, __uuidof(IMSVidCtl), IDS_CANT_CREATE_CUSTOM_COMPSEG);
        }
    }
    // StreamBufferSource to CC
    else if ((VWGraphSegment(Up).ClassID() == CLSID_MSVidStreamBufferSource ) && VWGraphSegment(Down).ClassID() == CLSID_MSVidClosedCaptioning){
        HRESULT hr = pCS.CoCreateInstance(CLSID_MSVidSBESourceToCC); 
        if (FAILED(hr) || !pCS) {
            TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::Compose() can't instantiate analog capture to XDS composite. hr = " << std::hex << hr), "");
            return Error(IDS_CANT_CREATE_CUSTOM_COMPSEG, __uuidof(IMSVidCtl), IDS_CANT_CREATE_CUSTOM_COMPSEG);
        }
    }
    else if ((VWGraphSegment(Up).ClassID() == CLSID_MSVidStreamBufferSource) && (VWGraphSegment(Down).ClassID() == CLSID_MSVidStreamBufferSink)){
            return E_FAIL;
    }
    else {
        HRESULT hr = pCS.CoCreateInstance(CLSID_MSVidGenericComposite);
        if (FAILED(hr) || !pCS) {
            TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::Compose() can't instantiate generic composite. hr = " << std::hex << hr), "");
            return Error(IDS_CANT_CREATE_CUSTOM_COMPSEG, __uuidof(IMSVidCtl), IDS_CANT_CREATE_CUSTOM_COMPSEG);
        }
    }
    HRESULT hr = pCS->put_Init(NULL);
    if (FAILED(hr) && hr != E_NOTIMPL) {
        TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::Compose() can't init new comp seg.  hr = " << std::hex << hr), "");
        return hr;
    }
    VWGraphSegment pSeg(pCS);
    ASSERT(pSeg);
    m_pComposites.push_back(pSeg);
    NewIdx = m_pComposites.size() - 1;
    hr = pCS->put_Container(this);
    if (FAILED(hr)) {
        TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::Compose() can't put_continaer for new comp segment. hr = " << std::hex << hr), "");
        return hr;
    }

    hr = pCS->Compose(PQGraphSegment(Up), PQGraphSegment(Down));
#if 0
    if(bCheckHR){
        if(hr != hrExpected){
            return hrFailed;
        }
        else{
            return hr;
        }
    }
#endif
    if (FAILED(hr)) {
        TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::Compose() can't compose up = " << Up << " with down = " << Down << " hr = " << hexdump(hr) ), "");
        return hr;
    }

    return NOERROR;
}

HRESULT CVidCtl::BuildGraph(void) {
    CPerfCounter pCounterBuild, pCounterPutC, pCounterCompose, pCounterBuilds, pCounterComp, pCounterB;
    pCounterBuild.Reset();
    TRACELM(TRACE_DETAIL, "CVidCtl::BuildGraph()");
    BOOL lRes = 0;
    OnMediaEvent(WM_MEDIAEVENT, 0, 0, lRes);
    HRESULT hr;
    ASSERT(m_pGraph);
    if(m_State != STATE_UNBUILT && m_fGraphDirty != true){
        return S_OK; // need a graph already built warning message
    }

    // make sure any needed default renderer's are selected prior to calling
    // build on the other segments so all segments are loaded before any
    // build() functions are called.

    // make sure required defaultable segments are set or assign a default
    // also make sure every segment knows the container

    bool fDefVideoRenderer = false;
    pCounterPutC.Reset();
    if (m_pVideoRenderer) {
        hr = PQGraphSegment(m_pVideoRenderer)->put_Container(this);
        if (FAILED(hr)) {
            TRACELM(TRACE_ERROR, "CVidCtl::BuildGraph() put_Container failed for Video Renderer");
            return hr;
        }
    } else if (!m_videoSetNull) {
        hr = LoadDefaultVR();
        if (FAILED(hr)) {
            TRACELM(TRACE_ERROR, "CVidCtl::BuildGraph() LoadDefaultVR failed");
            return hr;
        }
        if (!m_pVideoRenderer) {
            TRACELM(TRACE_ERROR, "CVidCtl::BuildGraph() LoadDefaultVR returned NULL Video Renderer");
            return E_UNEXPECTED;
        }
        fDefVideoRenderer = true;
    } 
    TRACELM(TRACE_DETAIL, "CVidCtl::BuildGraph() default vr checked");

    bool fDefAudioRenderer = false;
    if (m_pAudioRenderer) {
        hr = PQGraphSegment(m_pAudioRenderer)->put_Container(this);
        if (FAILED(hr)) {
            TRACELM(TRACE_ERROR, "CVidCtl::BuildGraph() put_Container failed for Audio Renderer");
            return hr;
        }
    } else if (!m_audioSetNull) {
        hr = LoadDefaultAR();
        if (FAILED(hr)) {
            TRACELM(TRACE_ERROR, "CVidCtl::BuildGraph() LoadDefaultAR failed");
            return hr;
        }
        if (!m_pAudioRenderer) {
            TRACELM(TRACE_ERROR, "CVidCtl::BuildGraph() LoadDefaultAR returned NULL Audio Renderer");
            return E_UNEXPECTED;
        }
        fDefAudioRenderer = true;
    }
    TRACELM(TRACE_DETAIL, "CVidCtl::BuildGraph() default ar checked");

    if (!m_pInput) {
        TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::BuildGraph() input segment required" << std::hex << hr), "");
        return Error(IDS_INPUT_SEG_REQUIRED, __uuidof(IMSVidCtl), IDS_INPUT_SEG_REQUIRED);
    }

    hr = PQGraphSegment(m_pInput)->put_Container(this);
    if (FAILED(hr)) {
        TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::BuildGraph() can't load input segment. hr = " << std::hex << hr), "");
        return hr;
    }


    TRACELM(TRACE_DETAIL, "CVidCtl::BuildGraph() input container set");
    {
        for (VWFeatures::iterator i = m_pFeaturesInUse.begin(); i != m_pFeaturesInUse.end(); ++i) {
            // notify them that we're building
            hr = VWGraphSegment(*i)->put_Container(this);
            if (FAILED(hr)) {
                TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::BuildGraph() can't load feature segment: " << (*i) << " hr = " << std::hex << hr), "");
                return hr;
            }

        }
    }

    {
        for (VWOutputDevices::iterator i = m_pOutputsInUse.begin(); i != m_pOutputsInUse.end(); ++i) {
            // notify them that we're building
            hr = VWGraphSegment(*i)->put_Container(this);
            if (FAILED(hr)) {
                TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::BuildGraph() can't load output segment: " << (*i) << " hr = " << std::hex << hr), "");
                return hr;
            }
        }
    }

    pCounterPutC.Stop();
    TRACELSM(TRACE_ERROR, (dbgDump << "     CVidCtl::BuildGraph() PutContainer " << (PQGraphSegment(m_pInput)) << ": " << (unsigned long)(pCounterPutC.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterPutC.GetLastTime() % _100NS_IN_MS) << " ms"), "");

    TRACELM(TRACE_DETAIL, "CVidCtl::BuildGraph() feature container set");

    pCounterBuilds.Reset();
    // Notify all of the output segments that we are about to build
    pCounterB.Reset();        
    // Notify everyone that composition is about to start
    hr = VWGraphSegment(m_pInput)->Build();
    if (FAILED(hr) && hr != E_NOTIMPL) {
        TRACELM(TRACE_ERROR, "CVidCtl::BuildGraph() Build call for input failed");
        return hr;
    }

    pCounterB.Stop(); TRACELSM(TRACE_ERROR, (dbgDump << "     CVidCtl::BuildGraph() Build call to Input: " << (unsigned long)(pCounterB.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterB.GetLastTime() % _100NS_IN_MS) << " ms"), ""); pCounterB.Reset();        

    {
        VWFeatures::iterator i;
        for (i = m_pFeaturesInUse.begin(); i != m_pFeaturesInUse.end(); ++i) {
            // notify them that we're building
            hr = VWGraphSegment(*i)->Build();
            if (FAILED(hr) && hr != E_NOTIMPL) {
                TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::BuildGraph() can't build feature segment: " << (*i) << " hr = " << std::hex << hr), "");
                return hr;
            }
            pCounterB.Stop(); TRACELSM(TRACE_ERROR, (dbgDump << "     CVidCtl::BuildGraph() Build call to Feature " << (*i) << " : " << (unsigned long)(pCounterB.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterB.GetLastTime() % _100NS_IN_MS) << " ms"), ""); pCounterB.Reset();        
        }
    }

    {
        VWOutputDevices::iterator i;
        for (i = m_pOutputsInUse.begin(); i != m_pOutputsInUse.end(); ++i) {
            // notify them that we're building
            hr = VWGraphSegment(*i)->Build();
            if (FAILED(hr) && hr != E_NOTIMPL) {
                TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::BuildGraph() can't build output segment: " << (*i) << " hr = " << std::hex << hr), "");
                return hr;
            }                
            pCounterB.Stop(); TRACELSM(TRACE_ERROR, (dbgDump << "     CVidCtl::BuildGraph() Build call to Output " << (*i) << " : " << (unsigned long)(pCounterB.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterB.GetLastTime() % _100NS_IN_MS) << " ms"), ""); pCounterB.Reset();        
        }
    }

    if (m_pVideoRenderer) {
        hr = VWGraphSegment(m_pVideoRenderer)->Build();
        if (FAILED(hr) && hr != E_NOTIMPL) {
            TRACELM(TRACE_ERROR, "CVidCtl::BuildGraph() Build call to Video Renderer Failed");
            return hr;
        }
        pCounterB.Stop(); TRACELSM(TRACE_ERROR, (dbgDump << "     CVidCtl::BuildGraph() Build call to VideoRenderer: " << (unsigned long)(pCounterB.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterB.GetLastTime() % _100NS_IN_MS) << " ms"), ""); pCounterB.Reset();        
    }
    if (m_pAudioRenderer) {
        hr = VWGraphSegment(m_pAudioRenderer)->Build();
        if (FAILED(hr) && hr != E_NOTIMPL) {
            TRACELM(TRACE_ERROR, "CVidCtl::BuildGraph() Build call to Audio Renderer Failed");
            return hr;
        }
        pCounterB.Stop(); TRACELSM(TRACE_ERROR, (dbgDump << "     CVidCtl::BuildGraph() Build call to Audio Renderer: " << (unsigned long)(pCounterB.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterB.GetLastTime() % _100NS_IN_MS) << " ms"), ""); pCounterB.Reset();        
    }
    pCounterBuilds.Stop();
    TRACELSM(TRACE_ERROR, (dbgDump << "     CVidCtl::BuildGraph() Build Calls to segments " << (PQGraphSegment(m_pInput)) << ": " << (unsigned long)(pCounterBuilds.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterBuilds.GetLastTime() % _100NS_IN_MS) << " ms"), "");

    TRACELM(TRACE_DETAIL, "CVidCtl::BuildGraph() build notifications issued");
    pCounterCompose.Reset();
    pCounterComp.Reset();
    {
        VWFeatures::iterator i;
        // composing input w/ features
        TRACELM(TRACE_DETAIL, "CVidCtl::BuildGraph() Composing Input w/ Features");
        for (i = m_pFeaturesInUse.begin(); i != m_pFeaturesInUse.end(); ++i) {
            int NewCompositionSegmentIdx = -1;
            hr = Compose(VWGraphSegment(m_pInput), VWGraphSegment(*i), NewCompositionSegmentIdx);
            if (FAILED(hr)) {
                TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::BuildGraph() can't compose input segment with feature segment: " << (*i) << " hr = " << std::hex << hr), "");
                return hr;
            }
        }
    }
    pCounterComp.Stop(); TRACELSM(TRACE_ERROR, (dbgDump << "     CVidCtl::BuildGraph() Composing Input w/ Features " << (PQGraphSegment(m_pInput)) << ": " << (unsigned long)(pCounterComp.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterComp.GetLastTime() % _100NS_IN_MS) << " ms"), ""); pCounterComp.Reset();
    // compose input w/ renderers

    TRACELM(TRACE_DETAIL, "CVidCtl::BuildGraph() Composing Input w/ Video Renderer");
    if (m_pVideoRenderer) {
        if (m_iCompose_Input_Video == -1) {
            hr = Compose(VWGraphSegment(m_pInput), VWGraphSegment(m_pVideoRenderer), m_iCompose_Input_Video);
            if (FAILED(hr) /*&& !fDefVideoRenderer*/ ) { // this should fail even if it is the default video renderer
                TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::BuildGraph() can't compose input and video. hr = " << std::hex << hr), "");
                return hr;
            }
        }
        ASSERT(m_iCompose_Input_Video != -1);
        PQCompositionSegment pCS(m_pComposites[m_iCompose_Input_Video]);
    }
    pCounterComp.Stop(); TRACELSM(TRACE_ERROR, (dbgDump << "     CVidCtl::BuildGraph() Input w/ Video Renderer " << (PQGraphSegment(m_pInput)) << ": " << (unsigned long)(pCounterComp.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterComp.GetLastTime() % _100NS_IN_MS) << " ms"), ""); pCounterComp.Reset();        

    TRACELM(TRACE_DETAIL, "CVidCtl::BuildGraph() Composing Input w/ Audio Renderer");
    if (m_pAudioRenderer) {
        if (m_iCompose_Input_Audio == -1) {
            hr = Compose(VWGraphSegment(m_pInput), VWGraphSegment(m_pAudioRenderer), m_iCompose_Input_Audio);
            if (FAILED(hr) && !fDefAudioRenderer) {
                // didn't work and the client explicitly specificed they want an audio renderer
                TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::BuildGraph() can't compose input and audio. hr = " << std::hex << hr), "");
                return hr;
            }
        }
    }
    pCounterComp.Stop(); TRACELSM(TRACE_ERROR, (dbgDump << "     CVidCtl::BuildGraph() Input w/ Audio Renderer " << (PQGraphSegment(m_pInput)) << ": " << (unsigned long)(pCounterComp.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterComp.GetLastTime() % _100NS_IN_MS) << " ms"), ""); pCounterComp.Reset();        

    // compose input w/ outputs
    {
        TRACELM(TRACE_DETAIL, "CVidCtl::BuildGraph() Composing Input w/ Outputs");
        for (VWOutputDevices::iterator i = m_pOutputsInUse.begin(); i != m_pOutputsInUse.end(); ++i) {
            int NewCompositionSegmentIdx = -1;
            hr = Compose(VWGraphSegment(m_pInput),VWGraphSegment(*i), NewCompositionSegmentIdx);
            if (FAILED(hr)) {
                TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::BuildGraph() can't compose output segment with input: " << (*i) << " hr = " << std::hex << hr), "");
                return hr;
            }

        }
    }
    pCounterComp.Stop(); TRACELSM(TRACE_ERROR, (dbgDump << "     CVidCtl::BuildGraph() inputs w/ Outputs " << (PQGraphSegment(m_pInput)) << ": " << (unsigned long)(pCounterComp.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterComp.GetLastTime() % _100NS_IN_MS) << " ms"), ""); pCounterComp.Reset();        

    // composing Features w/ Renderers
    TRACELM(TRACE_DETAIL, "CVidCtl::BuildGraph() Composing Features w/ Renderers");
    for (VWFeatures::iterator i = m_pFeaturesInUse.begin(); i != m_pFeaturesInUse.end(); ++i) {
        int NewCompositionSegmentIdx = -1;
        if (m_pVideoRenderer) {
            hr = Compose(VWGraphSegment(*i), VWGraphSegment(m_pVideoRenderer), NewCompositionSegmentIdx);
            if (FAILED(hr)) {
                TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::BuildGraph() can't compose feature segment: " << (*i) << " w/ video renderer. hr = " << std::hex << hr), "");
                // note: this is not a fatal error for building.  many features won't
                // connect to vr(such as data services)
            }
        }
        pCounterComp.Stop(); TRACELSM(TRACE_ERROR, (dbgDump << "     CVidCtl::BuildGraph() Features w/ Video Renderer " << (PQGraphSegment(m_pInput)) << ": " << (unsigned long)(pCounterComp.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterComp.GetLastTime() % _100NS_IN_MS) << " ms"), ""); pCounterComp.Reset();        

        if (m_pAudioRenderer) {
            hr = Compose(VWGraphSegment(*i), VWGraphSegment(m_pAudioRenderer), NewCompositionSegmentIdx);
            if (FAILED(hr)) {
                TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::BuildGraph() can't compose feature segment: " << (*i) << " w/ Audio renderer. hr = " << std::hex << hr), "");
                // note: this is not a fatal error for building.  many features won't
                // connect to ar(such as data services)
            }
        }
        pCounterComp.Stop(); TRACELSM(TRACE_ERROR, (dbgDump << "     CVidCtl::BuildGraph() Features w/ Audio Renderer " << (PQGraphSegment(m_pInput)) << ": " << (unsigned long)(pCounterComp.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterComp.GetLastTime() % _100NS_IN_MS) << " ms"), ""); pCounterComp.Reset();        

        {					
            for (VWOutputDevices::iterator oi = m_pOutputsInUse.begin(); oi != m_pOutputsInUse.end(); ++oi) {
                hr = Compose(VWGraphSegment(*i),VWGraphSegment(*oi), NewCompositionSegmentIdx);
                if (FAILED(hr)) {
                    TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::BuildGraph() can't compose output segment with feature: " << (*i) << " hr = " << std::hex << hr), "");
                    return hr;
                }

            }
        }
        pCounterComp.Stop(); TRACELSM(TRACE_ERROR, (dbgDump << "     CVidCtl::BuildGraph() Features w/ Outputs " << (PQGraphSegment(m_pInput)) << ": " << (unsigned long)(pCounterComp.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterComp.GetLastTime() % _100NS_IN_MS) << " ms"), ""); pCounterComp.Reset();        
    }
    pCounterCompose.Stop();
    TRACELSM(TRACE_ERROR, (dbgDump << "     CVidCtl::BuildGraph() compose segments " << (PQGraphSegment(m_pInput)) << ": " << (unsigned long)(pCounterCompose.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterCompose.GetLastTime() % _100NS_IN_MS) << " ms"), "");

    RouteStreams();
    SetExtents();

    m_fGraphDirty = false;
//    m_State = STATE_STOP;
    //SetMediaEventNotification();

    // fire state change at client
    PQMediaEventSink mes(m_pGraph);
    hr = mes->Notify(EC_BUILT, 0, 0);
    OnMediaEvent(WM_MEDIAEVENT, 0, 0, lRes);
	_ASSERT(m_State == STATE_STOP);
    TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::BuildGraph() Time" << (PQGraphSegment(m_pInput)) << ": " << (unsigned long)(pCounterBuild.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterBuild.GetLastTime() % _100NS_IN_MS) << " ms"), "");
    pCounterBuild.Stop();
    return NOERROR;
}

HRESULT CVidCtl::RunGraph(void)
{
    VIDPERF_FUNC;
    TRACELM(TRACE_DETAIL, "CVidCtl::RunGraph()");
    CPerfCounter pCounterMCRun, pCounterPostRun, pCounterPreRun, pCounterRunGraph, pCounterEachPreRun;
    pCounterRunGraph.Reset();
    if (!m_pInput || !m_pGraph) {
        return Error(IDS_OBJ_NO_INIT, __uuidof(IMSVidCtl), CO_E_NOTINITIALIZED);
    }
    BOOL lRes = 0;
    OnMediaEvent(WM_MEDIAEVENT, 0, 0, lRes);
    HRESULT hr;
    if (m_pGraph.IsPlaying()) {
        TRACELM(TRACE_DETAIL, "CVidCtl::RunGraph() already playing");
        return NOERROR;
    }
    else if (m_pGraph.IsPaused() && m_State == STATE_PAUSE) {
        TRACELM(TRACE_DETAIL, "CVidCtl::RunGraph() is paused");
        PQMediaControl pmc(m_pGraph);
        if (!pmc) {
            return Error(IDS_NO_MEDIA_CONTROL, __uuidof(IMSVidCtl), IDS_NO_MEDIA_CONTROL);
        }
        hr = pmc->Run();
        if (FAILED(hr)) {
            TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::Run() hr = " << hexdump(hr)), "");
            return Error(IDS_CANT_START_GRAPH, __uuidof(IMSVidCtl), hr);
        }        
        OnMediaEvent(WM_MEDIAEVENT, 0, 0, lRes);
        return NOERROR;
    }
    else {
        TRACELM(TRACE_DETAIL, "CVidCtl::RunGraph() build/prerun");
        // Rebuild the graph if necessary
        if (m_fGraphDirty) {
            TRACELM(TRACE_DETAIL, "CVidCtl::RunGraph() building");
            hr = BuildGraph();
            if (FAILED(hr)) {
                return hr;
            }
        }
        OAFilterState graphState = m_pGraph.GetState();

        TRACELM(TRACE_DETAIL, "CVidCtl::RunGraph() prerun notifications");
        // Notify all segments graph is about to run
        pCounterPreRun.Reset();
        pCounterEachPreRun.Reset();
        ASSERT(m_pInput);
        hr = VWGraphSegment(m_pInput)->PreRun();
        if (FAILED(hr) && hr != E_NOTIMPL) {
            return hr;
        }
        pCounterEachPreRun.Stop(); TRACELSM(TRACE_ERROR, (dbgDump << "     CVidCtl::RunGraph() PreRun Input  " << (PQGraphSegment(m_pInput)) << ": " << (unsigned long)(pCounterEachPreRun.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterEachPreRun.GetLastTime() % _100NS_IN_MS) << " ms"), ""); pCounterEachPreRun.Reset();        
        if (m_pVideoRenderer) {
            hr = VWGraphSegment(m_pVideoRenderer)->PreRun();
            if (FAILED(hr) && hr != E_NOTIMPL) {
                return hr;
            }
        }
        pCounterEachPreRun.Stop(); TRACELSM(TRACE_ERROR, (dbgDump << "     CVidCtl::RunGraph() PreRun VideoRenderer  " << (PQGraphSegment(m_pInput)) << ": " << (unsigned long)(pCounterEachPreRun.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterEachPreRun.GetLastTime() % _100NS_IN_MS) << " ms"), ""); pCounterEachPreRun.Reset();        
        if (m_pAudioRenderer) {
            hr = VWGraphSegment(m_pAudioRenderer)->PreRun();
            if (FAILED(hr) && hr != E_NOTIMPL) {
                return hr;
            }
        }
        pCounterEachPreRun.Stop(); TRACELSM(TRACE_ERROR, (dbgDump << "     CVidCtl::RunGraph() PreRun AudioRenderer  " << (PQGraphSegment(m_pInput)) << ": " << (unsigned long)(pCounterEachPreRun.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterEachPreRun.GetLastTime() % _100NS_IN_MS) << " ms"), ""); pCounterEachPreRun.Reset();        
        {
            VWOutputDevices::iterator i;
            for (i = m_pOutputsInUse.begin(); i != m_pOutputsInUse.end(); ++i) {
                hr = VWGraphSegment(*i)->PreRun();
                if (FAILED(hr) && hr != E_NOTIMPL) {
                    return hr;
                }
            }
        }
        pCounterEachPreRun.Stop(); TRACELSM(TRACE_ERROR, (dbgDump << "     CVidCtl::RunGraph() PreRun Output  " << (PQGraphSegment(m_pInput)) << ": " << (unsigned long)(pCounterEachPreRun.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterEachPreRun.GetLastTime() % _100NS_IN_MS) << " ms"), ""); pCounterEachPreRun.Reset();        
        {
            VWFeatures::iterator i;
            for (i = m_pFeaturesInUse.begin(); i != m_pFeaturesInUse.end(); ++i) {
                hr = VWGraphSegment(*i)->PreRun();
                if (FAILED(hr) && hr != E_NOTIMPL) {
                    return hr;
                }
            }
        }
        pCounterEachPreRun.Stop(); TRACELSM(TRACE_ERROR, (dbgDump << "     CVidCtl::RunGraph() PreRun Features  " << (PQGraphSegment(m_pInput)) << ": " << (unsigned long)(pCounterEachPreRun.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterEachPreRun.GetLastTime() % _100NS_IN_MS) << " ms"), ""); pCounterEachPreRun.Reset();        
        {
            VWSegmentList::iterator i;
            for(i = m_pComposites.begin(); i != m_pComposites.end(); ++i){
                hr = VWGraphSegment(*i)->PreRun();
                if (FAILED(hr) && hr != E_NOTIMPL) {
                    return hr;
                }
            }
        }
        pCounterEachPreRun.Stop(); TRACELSM(TRACE_ERROR, (dbgDump << "     CVidCtl::RunGraph() PreRun Composites  " << (PQGraphSegment(m_pInput)) << ": " << (unsigned long)(pCounterEachPreRun.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterEachPreRun.GetLastTime() % _100NS_IN_MS) << " ms"), ""); pCounterEachPreRun.Reset();        
        // Make sure graph state hasn't changed
        ASSERT(graphState == m_pGraph.GetState());
        Refresh();  // make sure we're in place active etc.
        pCounterPreRun.Stop();
        TRACELSM(TRACE_ERROR, (dbgDump << "     CVidCtl::RunGraph() PreRun Time" << (PQGraphSegment(m_pInput)) << ": " << (unsigned long)(pCounterPreRun.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterPreRun.GetLastTime() % _100NS_IN_MS) << " ms"), "");

        // Start the graph running
        PQMediaControl pmc(m_pGraph);
        if (!pmc) {
            return Error(IDS_NO_MEDIA_CONTROL, __uuidof(IMSVidCtl), IDS_NO_MEDIA_CONTROL);
        }
        pCounterMCRun.Reset();
        hr = pmc->Run();
        pCounterMCRun.Stop();
#if 0
        if(FAILED(hr)){
            hr = pmc->Run();
        }
#endif    
        TRACELSM(TRACE_ERROR, (dbgDump << "     CVidCtl::RunGraph() MediaControl Run Time" << (PQGraphSegment(m_pInput)) << ": " << (unsigned long)(pCounterMCRun.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterMCRun.GetLastTime() % _100NS_IN_MS) << " ms"), "");
        if (FAILED(hr)) {
            TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::Run() hr = " << hexdump(hr)), "");
            return Error(IDS_CANT_START_GRAPH, __uuidof(IMSVidCtl), hr);
        }        
    }
    TRACELM(TRACE_DETAIL, "CVidCtl::RunGraph() postrun");
    // Notify all segments graph is running
    pCounterPostRun.Reset();
    ASSERT(m_pInput);
    hr = VWGraphSegment(m_pInput)->PostRun();
    if (FAILED(hr) && hr != E_NOTIMPL) {
        return hr;
    }

    if (m_pVideoRenderer) {
        hr = VWGraphSegment(m_pVideoRenderer)->PostRun();
        if (FAILED(hr) && hr != E_NOTIMPL) {
            return hr;
        }
    }
    if (m_pAudioRenderer) {
        hr = VWGraphSegment(m_pAudioRenderer)->PostRun();
        if (FAILED(hr) && hr != E_NOTIMPL) {
            return hr;
        }
    }

    {
        VWOutputDevices::iterator i;
        for (i = m_pOutputsInUse.begin(); i != m_pOutputsInUse.end(); ++i) {
            hr = VWGraphSegment(*i)->PostRun();
            if (FAILED(hr) && hr != E_NOTIMPL) {
                return hr;
            }
        }
    }
    {
        VWFeatures::iterator i;
        for (i = m_pFeaturesInUse.begin(); i != m_pFeaturesInUse.end(); ++i) {
            hr = VWGraphSegment(*i)->PostRun();
            if (FAILED(hr) && hr != E_NOTIMPL) {
                return hr;
            }
        }
    }
    {
        VWSegmentList::iterator i;
        for (i = m_pComposites.begin(); i != m_pComposites.end(); ++i){
            hr = VWGraphSegment(*i)->PostRun();
            if (FAILED(hr) && hr != E_NOTIMPL) {
                return hr;
            }
        }
    }
    Refresh();
    OnMediaEvent(WM_MEDIAEVENT, 0, 0, lRes);
    pCounterPostRun.Stop();
    pCounterRunGraph.Stop();
    TRACELSM(TRACE_ERROR, (dbgDump << "     CVidCtl::RunGraph() Post Run Time" << (PQGraphSegment(m_pInput)) << ": " << (unsigned long)(pCounterPostRun.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterPostRun.GetLastTime() % _100NS_IN_MS) << " ms"), "");
    TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::RunGraph() RunGraph Total Time" << (PQGraphSegment(m_pInput)) << ": " << (unsigned long)(pCounterRunGraph.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterRunGraph.GetLastTime() % _100NS_IN_MS) << " ms"), "");

    return NOERROR;
}

HRESULT CVidCtl::DecomposeAll() {
    CPerfCounter pCounterDecompose;
    pCounterDecompose.Reset();
    HRESULT hr;

    if (!m_pGraph) {
        return NOERROR;
    }
    BOOL lRes = 0;
    OnMediaEvent(WM_MEDIAEVENT, 0, 0, lRes);
    
    if (m_pGraph.GetState() != State_Stopped) {
        hr = Stop();
        if (FAILED(hr)) {
            return Error(IDS_CANT_DECOMPOSE_GRAPH, __uuidof(IMSVidCtl), hr);
        }
    }

    {
        // decompose all the composites
        VWSegmentList::iterator i;
        for (i = m_pComposites.begin(); i != m_pComposites.end(); ++i) {
            hr = (*i)->put_Container(NULL);
            ASSERT(SUCCEEDED(hr));
        }
        m_pComposites.clear();
    }

    // Notify everyone to decompose

    if(!!m_pInput){
        hr = VWGraphSegment(m_pInput)->Decompose();
        if (FAILED(hr) && hr !=	E_NOTIMPL) {
            return hr;
        }
    }

    {
        // decompose all the features
        VWFeatures::iterator i;
        for	(i = m_pFeaturesInUse.begin(); i !=	m_pFeaturesInUse.end();	++i) {
            // notify them that	we're decomposing
            hr = VWGraphSegment(*i)->Decompose();
            if (FAILED(hr) && hr !=	E_NOTIMPL) {
                TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::DecomposeAll() can't decompose feature segment: "	<< (*i)	<< " hr	= "	<< std::hex	<< hr),	"");
                return hr;
            }
        }
    }

    {
        // decompose all the outputs
        VWOutputDevices::iterator i;
        for	(i = m_pOutputsInUse.begin(); i	!= m_pOutputsInUse.end(); ++i) {
            // notify them that	we're decomposing
            hr = VWGraphSegment(*i)->Decompose();
            if (FAILED(hr) && hr !=	E_NOTIMPL) {
                TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::DecomposeAll() can't decompose output	segment: " << (*i) << "	hr = " << std::hex << hr), "");
                return hr;
            }
        }
    }

    if (!!m_pVideoRenderer) {
        hr = VWGraphSegment(m_pVideoRenderer)->Decompose();
        if (FAILED(hr) && hr !=	E_NOTIMPL) {
            TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::DecomposeAll() can't decompose videorenderer	segment: " << "	hr = " << std::hex << hr), "");
            return hr;
        }
    }
    if (!!m_pAudioRenderer) {
        hr = VWGraphSegment(m_pAudioRenderer)->Decompose();
        if (FAILED(hr) && hr !=	E_NOTIMPL) {
            TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::DecomposeAll() can't decompose audiorenderer	segment: " << "	hr = " << std::hex << hr), "");
            return hr;
        }
    }

    TRACELM(TRACE_DETAIL, "CVidCtl::Decomose() decompose notifications issued");

    m_iCompose_Input_Video = -1;
    m_iCompose_Input_Audio = -1;

    m_fGraphDirty = true;
    PQMediaEventSink mes(m_pGraph);
    hr = mes->Notify(EC_UNBUILT, 0, 0);
    OnMediaEvent(WM_MEDIAEVENT, 0, 0, lRes);
    _ASSERT(m_State == STATE_UNBUILT);
    pCounterDecompose.Stop();
    TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::DecomposeAll() Death Time" << (PQGraphSegment(m_pInput)) << ": " << (unsigned long)(pCounterDecompose.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterDecompose.GetLastTime() % _100NS_IN_MS) << " ms"), "");
    return NOERROR;
}

HRESULT CVidCtl::DecomposeSegment(VWGraphSegment& pSegment) {
    if (m_pGraph.GetState() != State_Stopped) {
        return HRESULT_FROM_WIN32(ERROR_INVALID_STATE);
    }
    return DecomposeAll();
}

// interface functions
STDMETHODIMP CVidCtl::get_InputsAvailable(BSTR CategoryGuid, IMSVidInputDevices * * pVal)
{
    try {
        GUID2 catguid(CategoryGuid);
        return get__InputsAvailable(&catguid, pVal);
    } catch(ComException &e) {
        return e;
    } catch(...) {
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CVidCtl::get__InputsAvailable(LPCGUID CategoryGuid, IMSVidInputDevices * * pVal)
{
    if (pVal == NULL)
        return E_POINTER;
    try {
        if (!m_fInit) {
            Init();
        }
    } catch(ComException &e) {
        return e;
    } catch(...) {
        return E_UNEXPECTED;
    }
    try {
        *pVal = NULL;
    } catch(...) {
        return E_POINTER;
    }
    try {
        CInputDevices *p = NULL;
        if(m_InputsCatGuid == CategoryGuid){
            p = static_cast<CInputDevices *>(m_pInputs.p);
        }
        if (!p || !p->Valid) {
            HRESULT hr = GetInputs(GUID2(CategoryGuid), m_pInputs);
            if (FAILED(hr)) {
                return hr;
            }
            m_InputsCatGuid = CategoryGuid;
        }
        CInputDevices *d = new CInputDevices(m_pInputs);
        *pVal = PQInputDevices(d).Detach();
    } catch(ComException &e) {
        return e;
    } catch(...) {
        return E_UNEXPECTED;
    }
    return NOERROR;
}

STDMETHODIMP CVidCtl::get_OutputsAvailable(BSTR CategoryGuid, IMSVidOutputDevices * * pVal)
{
    try {
        GUID2 catguid(CategoryGuid);
        return get__OutputsAvailable(&catguid, pVal);
    } catch(ComException &e) {
        return e;
    } catch(...) {
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CVidCtl::get__OutputsAvailable(LPCGUID CategoryGuid, IMSVidOutputDevices * * pVal)
{
    if (pVal == NULL)
        return E_POINTER;
    try {
        if (!m_fInit) {
            Init();
        }
    } catch(ComException &e) {
        return e;
    } catch(...) {
        return Error(IDS_CANT_INIT, __uuidof(IMSVidCtl), IDS_CANT_INIT);
    }
    try {
        *pVal = NULL;
    } catch(...) {
        return E_POINTER;
    }
    try {
        COutputDevices *p = static_cast<COutputDevices *>(m_pOutputs.p);
        if (!p || !p->Valid) {
            HRESULT hr = GetOutputs(GUID2(CategoryGuid));
            if (FAILED(hr)) {
                return hr;
            }
        }
        COutputDevices *d = new COutputDevices(m_pOutputs);
        *pVal = PQOutputDevices(d).Detach();
    } catch(ComException &e) {
        return e;
    } catch(...) {
        return E_UNEXPECTED;
    }
    return NOERROR;
}

STDMETHODIMP CVidCtl::get_VideoRenderersAvailable(IMSVidVideoRendererDevices * * pVal)
{
    if (pVal == NULL)
        return E_POINTER;
    try {
        if (!m_fInit) {
            Init();
        }
    } catch(ComException &e) {
        return e;
    } catch(...) {
        return Error(IDS_CANT_INIT, __uuidof(IMSVidCtl), IDS_CANT_INIT);
    }
    try {
        *pVal = NULL;
    } catch(...) {
        return E_POINTER;
    }
    try {
        CVideoRendererDevices *p = static_cast<CVideoRendererDevices *>(m_pVRs.p);
        if (!p || !p->Valid) {
            HRESULT hr = GetVideoRenderers();
            if (FAILED(hr)) {
                return hr;
            }
        }
        CVideoRendererDevices *d = new CVideoRendererDevices(m_pVRs);
        if (!d) {
            return E_OUTOFMEMORY;
        }
        *pVal = PQVideoRendererDevices(d).Detach();
        if (!*pVal) {
            return E_UNEXPECTED;
        }
    } catch(ComException &e) {
        return e;
    } catch(...) {
        return E_UNEXPECTED;
    }
    return NOERROR;
}

STDMETHODIMP CVidCtl::get_AudioRenderersAvailable(IMSVidAudioRendererDevices * * pVal)
{
    if (pVal == NULL)
        return E_POINTER;
    try {
        if (!m_fInit) {
            Init();
        }
    } catch(ComException &e) {
        return e;
    } catch(...) {
        return Error(IDS_CANT_INIT, __uuidof(IMSVidCtl), IDS_CANT_INIT);
    }
    try {
        *pVal = NULL;
    } catch(...) {
        return E_POINTER;
    }
    try {
        CAudioRendererDevices *p = static_cast<CAudioRendererDevices *>(m_pARs.p);
        if (!p || !p->Valid) {
            HRESULT hr = GetAudioRenderers();
            if (FAILED(hr)) {
                return hr;
            }
        }
        CAudioRendererDevices *d = new CAudioRendererDevices(m_pARs);
        if (!d) {
            return E_OUTOFMEMORY;
        }
        *pVal = PQAudioRendererDevices(d).Detach();
        if (!*pVal) {
            return E_UNEXPECTED;
        }
        return NOERROR;
    } catch(ComException &e) {
        return e;
    } catch(...) {
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CVidCtl::get_FeaturesAvailable(IMSVidFeatures * * pVal)
{
    if (pVal == NULL)
        return E_POINTER;
    try {
        if (!m_fInit) {
            Init();
        }
    } catch(ComException &e) {
        return e;
    } catch(...) {
        return Error(IDS_CANT_INIT, __uuidof(IMSVidCtl), IDS_CANT_INIT);
    }
    try {
        *pVal = NULL;
    } catch(...) {
        return E_POINTER;
    }
    try {
        CFeatures *p = static_cast<CFeatures *>(m_pFeatures.p);
        if (!p || !p->Valid) {
            HRESULT hr = GetFeatures();
            if (FAILED(hr)) {
                return hr;
            }
        }
        CFeatures *d = new CFeatures(m_pFeatures);
        *pVal = PQFeatures(d).Detach();
        return NOERROR;
    } catch(ComException &e) {
        return e;
    } catch(...) {
        return E_UNEXPECTED;
    }
}

HRESULT CVidCtl::Pause(void)
{
    VIDPERF_FUNC;
    try {
        if (!m_pInput || !m_pGraph) {
            return Error(IDS_OBJ_NO_INIT, __uuidof(IMSVidCtl), IDS_OBJ_NO_INIT);
        }
        BOOL lRes = 0;
        OnMediaEvent(WM_MEDIAEVENT, 0, 0, lRes);
    
        if (m_pGraph.IsPaused()) {
            return NOERROR;
        }

        HRESULT hr = S_OK;
        if (m_fGraphDirty) {
            hr = BuildGraph();
        }
        if (FAILED(hr)) {
            return hr;
        }

        PQMediaControl pmc(m_pGraph);
        if (!pmc) {
            return Error(IDS_NO_MEDIA_CONTROL, __uuidof(IMSVidCtl), IDS_NO_MEDIA_CONTROL);
        }
        hr = pmc->Pause();
        if (FAILED(hr)) {
            TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::Pause() hr = " << std::hex << hr), "");
            return Error(IDS_CANT_PAUSE_GRAPH, __uuidof(IMSVidCtl), hr);
        }

        // This is to force the pause event to get thrown up to apps.
        OnMediaEvent(WM_MEDIAEVENT, 0, 0, lRes);    
        return NOERROR;

    } catch(ComException &e) {
        return e;
    } catch(...) {
        return E_UNEXPECTED;
    }
}

HRESULT CVidCtl::Stop(void)
{
    VIDPERF_FUNC;
    CPerfCounter pCounterStop;
    pCounterStop.Reset();
    try {
        TRACELM(TRACE_DETAIL, "CVidCtl::Stop()");
        if (!m_pInput || !m_pGraph) {
            return Error(IDS_OBJ_NO_INIT, __uuidof(IMSVidCtl), CO_E_NOTINITIALIZED);
        }
        BOOL lRes = 0;
        OnMediaEvent(WM_MEDIAEVENT, 0, 0, lRes);
        HRESULT hr;
        if (!m_pGraph.IsStopped()) {

            OAFilterState graphState = m_pGraph.GetState();

            // Notify all segments graph is about to stop
            ASSERT(m_pInput);
            hr = VWGraphSegment(m_pInput)->PreStop();
            if (FAILED(hr) && hr != E_NOTIMPL) {
                return hr;
            }

            if (!!m_pVideoRenderer) {
                hr = VWGraphSegment(m_pVideoRenderer)->PreStop();
                if (FAILED(hr) && hr != E_NOTIMPL) {
                    return hr;
                }
            }
            if (!!m_pAudioRenderer) {
                hr = VWGraphSegment(m_pAudioRenderer)->PreStop();
                if (FAILED(hr) && hr != E_NOTIMPL) {
                    return hr;
                }
            }

            {
                VWOutputDevices::iterator i;
                for (i = m_pOutputsInUse.begin(); i != m_pOutputsInUse.end(); ++i) {
                    hr = VWGraphSegment(*i)->PreStop();
                    if (FAILED(hr) && hr != E_NOTIMPL) {
                        return hr;
                    }
                }
            }
            {
                VWFeatures::iterator i;
                for (i = m_pFeaturesInUse.begin(); i != m_pFeaturesInUse.end(); ++i) {
                    hr = VWGraphSegment(*i)->PreStop();
                    if (FAILED(hr) && hr != E_NOTIMPL) {
                        return hr;
                    }
                }
            }
            {
                VWSegmentList::iterator i;
                for(i = m_pComposites.begin(); i != m_pComposites.end(); ++i){
                    hr = VWGraphSegment(*i)->PreStop();
                    if (FAILED(hr) && hr != E_NOTIMPL) {
                        return hr;
                    }
                }
            }
            if (!!m_pVideoRenderer) {
                m_pVideoRenderer->put_Visible(false);
                m_pVideoRenderer->put_Owner(0);
            }

            // Stop the graph
            PQMediaControl pmc(m_pGraph);
            if (!pmc) {
                return Error(IDS_NO_MEDIA_CONTROL, __uuidof(IMSVidCtl), IDS_NO_MEDIA_CONTROL);
            }
            hr = pmc->Stop();
            if (FAILED(hr)) {
                TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::Stop() hr = " << std::hex << hr), "");
                return Error(IDS_CANT_PAUSE_GRAPH, __uuidof(IMSVidCtl), hr);
            }
        }

        // Notify all segments graph is stopped
        ASSERT(m_pInput);
        hr = VWGraphSegment(m_pInput)->PostStop();
        if (FAILED(hr) && hr != E_NOTIMPL) {
            return hr;
        }

        if (!!m_pVideoRenderer) {
            hr = VWGraphSegment(m_pVideoRenderer)->PostStop();
            if (FAILED(hr) && hr != E_NOTIMPL) {
                return hr;
            }
        }
        if (!!m_pAudioRenderer) {
            hr = VWGraphSegment(m_pAudioRenderer)->PostStop();
            if (FAILED(hr) && hr != E_NOTIMPL) {
                return hr;
            }
        }

        {
            VWOutputDevices::iterator i;
            for (i = m_pOutputsInUse.begin(); i != m_pOutputsInUse.end(); ++i) {
                hr = VWGraphSegment(*i)->PostStop();
                if (FAILED(hr) && hr != E_NOTIMPL) {
                    return hr;
                }
            }
        }
        {
            VWFeatures::iterator i;
            for (i = m_pFeaturesInUse.begin(); i != m_pFeaturesInUse.end(); ++i) {
                hr = VWGraphSegment(*i)->PostStop();
                if (FAILED(hr) && hr != E_NOTIMPL) {
                    return hr;
                }
            }
        }        
        {
            VWSegmentList::iterator i;
            for(i = m_pComposites.begin(); i != m_pComposites.end(); ++i){
                hr = VWGraphSegment(*i)->PostStop();
                if (FAILED(hr) && hr != E_NOTIMPL) {
                    return hr;
                }
            }
        }
        FireViewChange();  // force refresh to repaint background immediately(black)
        OnMediaEvent(WM_MEDIAEVENT, 0, 0, lRes);
        pCounterStop.Stop();
        TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl::Stop() Stop Time" << (PQGraphSegment(m_pInput)) << ": " << (unsigned long)(pCounterStop.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterStop.GetLastTime() % _100NS_IN_MS) << " ms"), "");
        return NOERROR;

    } catch(ComException &e) {
        return e;
    } catch(...) {
        return E_UNEXPECTED;
    }
}

// Setup events handling
// If we have a window, then send notification messages to it
// If we are windowless, then set up a timer to process the messages
void CVidCtl::SetMediaEventNotification() {

    SetTimer();
    if (!m_fNotificationSet) {

        // If graph is built and notification hasn't been set
        // then set it here
        if (m_pGraph) {
            // Setup notification window for WM_MEDIAEVENT
            HRESULT hr = m_pGraph.SetMediaEventNotificationWindow(m_pTopWin->m_hWnd, WM_MEDIAEVENT, 0);
            if (FAILED(hr)) {
                THROWCOM(E_UNEXPECTED);
            }
            m_fNotificationSet = true;
        }        
    } 

    return;
}

// actually submit changes to VR
bool CVidCtl::RefreshVRSurfaceState() {
    TRACELM(TRACE_PAINT, "CVidCtl::RefreshVRSurfaceState()");
    if (m_pVideoRenderer) {
        HWND hOwner(m_CurrentSurface.Owner());
        HRESULT hr = m_pVideoRenderer->put_Owner(hOwner);
        if (FAILED(hr) || hOwner == INVALID_HWND || !::IsWindow(hOwner)) {
            TRACELM(TRACE_PAINT, "CVidCtl::RefreshVRSurfaceState() unowned, vis false");
            hr = m_pVideoRenderer->put_Visible(false);
            if (FAILED(hr)) {
                return false;
            }
        } else {
            hr = m_pVideoRenderer->put_Destination(m_CurrentSurface);
            if (FAILED(hr)) {
                return false;
            }
            hr = m_pVideoRenderer->put_Visible(m_CurrentSurface.IsVisible() ? VARIANT_TRUE : VARIANT_FALSE);
            if (FAILED(hr) && hr == E_FAIL) {
                return false;
            }
        }
        m_CurrentSurface.Dirty(false);
    }
    return true;
}


HRESULT CVidCtl::Refresh() {
    try {
        TRACELSM(TRACE_DETAIL, (dbgDump << "CVidCtl::Refresh() owner = " << m_CurrentSurface.Owner()), "");
        BOOL temp;
        if (!m_bInPlaceActive) {
            HRESULT hr = InPlaceActivate(OLEIVERB_INPLACEACTIVATE, NULL);
            if (FAILED(hr)) {
                return hr;
            }
        }
        CheckMouseCursor(temp);

        ComputeDisplaySize();
        SetExtents();
        if (m_pVideoRenderer) {
            RefreshVRSurfaceState();
            m_pVideoRenderer->Refresh();
        }
        FireViewChange();

        return NOERROR;
    } catch (...) {
        return E_UNEXPECTED;
    }
}

#if 0

// old flawed OnDraw saved for reference

HRESULT CVidCtl::OnDraw(ATL_DRAWINFO& di)
{
    try {
        SetTimer();
        //SetMediaEventNotification();
        TRACELSM(TRACE_PAINT, (dbgDump << "CVidctrl::OnDraw() visible = " << m_CurrentSurface.IsVisible() << "surf = " << m_CurrentSurface), "" );
        bool fOverlay = false;
        if (m_pVideoRenderer) {
            VARIANT_BOOL fo = VARIANT_FALSE;
            HRESULT hr = m_pVideoRenderer->get_UseOverlay(&fo);
            if (FAILED(hr)) {
                TRACELM(TRACE_ERROR, "CVidctrl::OnDraw() can't get useoverlay flag");
            }
            fOverlay = !!fo;
            hr = m_pVideoRenderer->put_ColorKey(m_clrColorKey);
            if (FAILED(hr)) {
                TRACELM(TRACE_ERROR, "CVidctrl::OnDraw() can't set color key on vr");
            }
#ifdef 0
            hr = m_pVideoRenderer->put_BorderColor(0x0000ff);
#else
            hr = m_pVideoRenderer->put_BorderColor(m_clrBackColor);
#endif
            if (FAILED(hr)) {
                TRACELM(TRACE_ERROR, "CVidctrl::OnDraw() can't set border color on vr");
            }
            hr = m_pVideoRenderer->put_MaintainAspectRatio(m_fMaintainAspectRatio);
            if (FAILED(hr)) {
                TRACELM(TRACE_ERROR, "CVidctrl::OnDraw() can't set fMaintainAspectRatio on vr");
            }
        }
        // undone: if we're straddling a monitor edge in the multimon case, then we treat the smaller
        // portion as part of the border/background

        // undone: if we're on a monitor that our input device cannot reach(video port case) then we need
        // to paint the background color

        // we only force overlay and tell vmr not to paint color key if we're windowless
        // this allows us to put the color key in the correct z-order amongst a stack of
        // multiple windowless controls. when we do this we also need to paint the letter box
        // border otherwise it won't z-order right since it isn't colorkeyed.
        // if we're windowed then gdi, ddraw, and the vmr deal 
        // with the z-order correctly so we let the vmr do the color key and border for us and we
        // fill rect the bg color

        // so, we have three cases 
        // 1: paint the whole rect the color key color
        // 2: paint the whole rect the bg color
        // 3: paint the video portion colorkey and the borders bg

        if (di.dwDrawAspect != DVASPECT_CONTENT) {
            return DV_E_DVASPECT;
        }
        if (!di.hdcDraw) {
            return NOERROR;
        }
        CDC pdc(di.hdcDraw);
        TRACELSM(TRACE_PAINT, (dbgDump << "CVidctrl::OnDraw() di.prcBounds " << *(reinterpret_cast<LPCRECT>(di.prcBounds))), "");
        CRect rcBounds(reinterpret_cast<LPCRECT>(di.prcBounds));
        TRACELSM(TRACE_PAINT, (dbgDump << "CVidctrl::OnDraw() rcBounds = " << rcBounds << " w = " << rcBounds.Width() << " h = " << rcBounds.Height()), "");
        long lBGColor = m_clrBackColor;
        TRACELSM(TRACE_PAINT, (dbgDump << "CVidctrl::OnDraw() wndless = " << m_bWndLess << " active = " << m_bInPlaceActive << " !stopped = " << (m_pGraph ? !m_pGraph.IsStopped() : 0)), "");
        if (m_bNegotiatedWnd) {
            if (m_bWndLess) {
                HWND hwndParent;
                if (m_spInPlaceSite && m_spInPlaceSite->GetWindow(&hwndParent) == S_OK) {
                    m_CurrentSurface.Owner(hwndParent);
                }
                CheckSurfaceStateChanged(CScalingRect(m_rcPos));
            } else {
                m_CurrentSurface.Owner(m_hWndCD);
                CScalingRect r(::GetDesktopWindow());
                if (!::GetWindowRect(m_hWndCD, &r)) {
                    return HRESULT_FROM_WIN32(GetLastError());
                }
                CheckSurfaceStateChanged(r);
            }
        } else {
            m_CurrentSurface.Site(PQSiteWindowless(m_spInPlaceSite));
            CheckSurfaceStateChanged(CScalingRect(m_rcPos));
        }
        if (m_bInPlaceActive && fOverlay) {
            if (m_pGraph && !m_pGraph.IsStopped()) {
                TRACELSM(TRACE_PAINT, (dbgDump << "CVidCtl::OnDraw() m_rcPos = " << m_rcPos << " m_cursurf = " << m_CurrentSurface), "");
                TRACELSM(TRACE_PAINT, (dbgDump << "CVidCtl::OnDraw() m_cursurf rounded = " << m_CurrentSurface), "");
                // get the color from the current video renderer because we always notify it
                // if we've received a colorkey change but it may not notify us if one went directly to
                // the vr object.

                if (m_fMaintainAspectRatio) {
                    AspectRatio src(SourceAspect());
                    AspectRatio surf(m_rcPos);
                    TRACELSM(TRACE_PAINT, (dbgDump << "CVidCtl::OnDraw() Checking AR() src = " << src << " surf = " << surf), "");
                    if (src != surf) {
                        CBrush hb;
                        HBRUSH hbrc = hb.CreateSolidBrush(m_clrBackColor);
                        if (!hbrc) {
                            TRACELM(TRACE_ERROR, "CVidctrl::OnDraw() can't create brush for letterbox");
                            THROWCOM(E_UNEXPECTED);
                        }

                        TRACELSM(TRACE_PAINT, (dbgDump << "CVidctrl::OnDraw() rcBounds at border paint = " << rcBounds << " w = " << rcBounds.Width() << " h = " << rcBounds.Height()), "");
                        if (!pdc.FillRect(&rcBounds, hb)) {
                            DWORD er = GetLastError();
                            TRACELSM(TRACE_ERROR, (dbgDump << "CVidctrl::OnDraw() can't fill top/left letterbox rect er = " << er), "");
                            return HRESULT_FROM_WIN32(er);
                        }
                    }
                }
                lBGColor = m_clrColorKey;
                CRect SurfDP(m_CurrentSurface);
                TRACELSM(TRACE_PAINT, (dbgDump << "CVidctrl::OnDraw() SurfDP before LPtoDP = " << SurfDP << " w = " << SurfDP.Width() << " h = " << SurfDP.Height()), "");
                if (di.hicTargetDev == di.hdcDraw) {
                    // ATL has a weird bug in the windowless case where they reset the transform 
                    // origins of hicTargetDev inadvertently.  this happens because in the windowless
                    // non metafile case ATLCreateTargetDC returns the existing hdcDraw instead
                    // of creatin a new dc so after that in CComControlBase::OnDrawAdvanced
                    // when the save hdcDraw and reset the origins, they change hicTargetDev
                    // too(since they're the same ptr).
                    // we undo this so that we can map in the same space and then put it back
                    // the way it was just to be safe
                    // currently, this works because in the non-metafile case atl always 
                    // does a prior SaveDC everywhere they call the derived control's OnDraw 
                    // since we already reject non-metafile above(it doesn't make sense for video)
                    // we can just check for pointer equality and temporarily undo their 
                    // origin change and then put it back the way it was.  if atl ever calls
                    // our ondraw for non-metafiles anywhere without doing a savedc then this
                    // will break bigtime.
                    ::RestoreDC(di.hdcDraw, -1);
                }
                if (!::LPtoDP(di.hicTargetDev, reinterpret_cast<LPPOINT>(&SurfDP), 2)) {
                    DWORD er = GetLastError();
                    TRACELSM(TRACE_ERROR, (dbgDump << "CVidctrl::OnDraw() can't LPToDP current surf er = " << er), "");
                    return HRESULT_FROM_WIN32(er);
                }
                if (di.hicTargetDev == di.hdcDraw) {
                    // restore the window state as per the above comment block
                    SaveDC(di.hdcDraw);
                    SetMapMode(di.hdcDraw, MM_TEXT);
                    SetWindowOrgEx(di.hdcDraw, 0, 0, NULL);
                    SetViewportOrgEx(di.hdcDraw, 0, 0, NULL);
                }
                TRACELSM(TRACE_PAINT, (dbgDump << "CVidctrl::OnDraw() SurfDP after LPtoDP = " << SurfDP << " w = " << SurfDP.Width() << " h = " << SurfDP.Height()), "");
#if 1
                TRACELSM(TRACE_PAINT, (dbgDump << "CVidctrl::OnDraw() rcBounds prior to boundary intersect = " << rcBounds << " w = " << rcBounds.Width() << " h = " << rcBounds.Height()), "");
                rcBounds.IntersectRect(&SurfDP);
                TRACELSM(TRACE_PAINT, (dbgDump << "CVidctrl::OnDraw() rcBounds after to boundary intersect = " << rcBounds << " w = " << rcBounds.Width() << " h = " << rcBounds.Height()), "");
#endif
            }
        } else {
            if (m_pGraph && !m_pGraph.IsStopped()) {
                lBGColor = m_clrColorKey;
                if (m_pVideoRenderer) {
                    m_pVideoRenderer->RePaint(di.hdcDraw);
                    pdc = NULL; // don't delete the DC, it isn't ours        
                    return S_OK;
                }
            }
        }
        CBrush hb;
        HBRUSH hbrc = hb.CreateSolidBrush(lBGColor);
        if (!hbrc) {
            TRACELM(TRACE_ERROR, "CVidctrl::OnDraw() can't create brush for mainrect");
            THROWCOM(E_UNEXPECTED);
        }

        TRACELSM(TRACE_PAINT, (dbgDump << "CVidctrl::OnDraw() rcBounds at main paint = " << rcBounds << " w = " << rcBounds.Width() << " h = " << rcBounds.Height()), "");
        TRACELSM(TRACE_PAINT, (dbgDump << "CVidctrl::OnDraw() bkcolor = " << hexdump(lBGColor)), "");

        if (!pdc.FillRect(&rcBounds, hb)) {
            DWORD er = GetLastError();
            TRACELSM(TRACE_ERROR, (dbgDump << "CVidctrl::OnDraw() can't fill main video rect er = " << er), "");
            return HRESULT_FROM_WIN32(er);
        }
        pdc = NULL; // don't delete the DC, it isn't ours        

        return S_OK;
    } catch(...) {
        return E_UNEXPECTED;
    }

}

#else 

HRESULT CVidCtl::OnDrawAdvanced(ATL_DRAWINFO& di)
{
    try {
        SetTimer();
        TRACELSM(TRACE_PAINT, (dbgDump << "CVidctrl::OnDraw() visible = " << m_CurrentSurface.IsVisible() << "surf = " << m_CurrentSurface), "" );
        bool fOverlay = false;
        if (m_pVideoRenderer) {
            VARIANT_BOOL fo = VARIANT_FALSE;
            HRESULT hr = m_pVideoRenderer->get_UseOverlay(&fo);
            if (FAILED(hr)) {
                TRACELM(TRACE_ERROR, "CVidctrl::OnDraw() can't get useoverlay flag");
            }
            fOverlay = !!fo;
            hr = m_pVideoRenderer->put_ColorKey(m_clrColorKey);
            if (FAILED(hr)) {
                TRACELM(TRACE_ERROR, "CVidctrl::OnDraw() can't set color key on vr");
            }
#if 0
            hr = m_pVideoRenderer->put_BorderColor(0x0000ff);
#else
            hr = m_pVideoRenderer->put_BorderColor(m_clrBackColor);
#endif
            if (FAILED(hr)) {
                TRACELM(TRACE_ERROR, "CVidctrl::OnDraw() can't set border color on vr");
            }
            hr = m_pVideoRenderer->put_MaintainAspectRatio(m_fMaintainAspectRatio);
            if (FAILED(hr)) {
                TRACELM(TRACE_ERROR, "CVidctrl::OnDraw() can't set fMaintainAspectRatio on vr");
            }
        }

        if (di.dwDrawAspect != DVASPECT_CONTENT) {
            return DV_E_DVASPECT;
        }
        if (!di.hdcDraw) {
            return NOERROR;
        }

        // we only default to force overlay if we're windowless, but overlay is an independently controllable
        // boolean property that can be overriden.  based on this, if we're in useoverlay == true mode
        // then we tell vmr not to paint color key.  if we don't have an rgb overlay available that vmr 
        // event causes useoverlay to go false.
        // when we have the overlay, this allows us to put the color key in the correct z-order 
        // amongst a stack of multiple windowless controls such as html page elements in IE.
        // when we do this we also need to paint the letter box
        // border otherwise it won't z-order right since it isn't colorkeyed.
        // if we're windowed then gdi, ddraw, and the vmr deal 
        // with the z-order correctly so we let the vmr do the color key and border for us and we
        // fill rect the bg color

        // so, we have three cases 
        // 1: paint the whole rect the color key color
        // 2: paint the whole rect the bg color
        // 3: paint the video portion colorkey and the borders bg

        TRACELSM(TRACE_PAINT, (dbgDump << "CVidctrl::OnDraw() wndless = " << m_bWndLess << " active = " << m_bInPlaceActive << " !stopped = " << (m_pGraph ? !m_pGraph.IsStopped() : 0) << " mar = " << m_fMaintainAspectRatio), "");
        CSize szSrc;
        GetSourceSize(szSrc);
        CRect rctSrc(0, 0, szSrc.cx, szSrc.cy); // rectangle representing the actual source size(and aspect ratio)
        // in zero top-left coords
        TRACELSM(TRACE_PAINT, (dbgDump << "CVidctrl::OnDraw() rctSrc =  " << rctSrc), "");


        CScalingRect rctOuterDst(reinterpret_cast<LPCRECT>(di.prcBounds));  // rectangle representing our paint area in client device coords
        TRACELSM(TRACE_PAINT, (dbgDump << "CVidctrl::OnDraw() rctOuterDst =  " << rctOuterDst), "");
        CScalingRect rctInnerDst(rctOuterDst);  // rectangle representing where the video goes that we pass through 
        // to the VMR in client logical coords. assume its the whole
        // paint area for now
        CScalingRect rctTLBorder(0, 0, 0, 0);  // rectangle representing our top/left letter box(if necessary) in client logical coords
        CScalingRect rctBRBorder(0, 0, 0, 0);  // rectangle representing our bottom/left letter box(if necessary) in client logical coords

        CDC pdc(di.hdcDraw);
        long lInnerColor = m_clrBackColor;
#if 0
        if (!m_bNegotiatedWnd) {
            if (!rctOuterDst) {
                // pull rctOuterDst from site
                //   m_CurrentSurface.Site(PQSiteWindowless(m_spInPlaceSite));
                //   CheckSurfaceStateChanged(CScalingRect(m_rcPos));
            }
        }
#endif
        if (m_bInPlaceActive) {
            if (fOverlay) {
                if (m_pGraph && !m_pGraph.IsStopped()) {
                    TRACELM(TRACE_PAINT, "CVidCtl::OnDraw() letterboxing");
                    // get the color from the current video renderer because we always notify it
                    // if we've received a colorkey change but it may not notify us if one went directly to
                    // the vr object.
                    lInnerColor = m_clrColorKey;
                    if (m_fMaintainAspectRatio) {
                        ComputeAspectRatioAdjustedRects(rctSrc, rctOuterDst, rctInnerDst, rctTLBorder, rctBRBorder);
                        ASSERT((!rctTLBorder && !rctBRBorder) || (rctTLBorder && rctBRBorder));  // both zero or both valid
                        if (rctTLBorder && rctBRBorder) {
                            CBrush lb;
                            HBRUSH hbrc = lb.CreateSolidBrush(m_clrBackColor);
                            if (!hbrc) {
                                TRACELM(TRACE_ERROR, "CVidctrl::OnDraw() can't create brush for letterbox borders");
                                THROWCOM(E_UNEXPECTED);
                            }
                            if (!pdc.FillRect(rctTLBorder, lb)) {
                                DWORD er = GetLastError();
                                TRACELSM(TRACE_ERROR, (dbgDump << "CVidctrl::OnDraw() can't fill rctTLBorder er = " << er), "");
                                return HRESULT_FROM_WIN32(er);
                            }
                            if (!pdc.FillRect(rctBRBorder, lb)) {
                                DWORD er = GetLastError();
                                TRACELSM(TRACE_ERROR, (dbgDump << "CVidctrl::OnDraw() can't fill rctBRBorder er = " << er), "");
                                return HRESULT_FROM_WIN32(er);
                            }
                        }
                    }
                }
            } else {
                if (m_pGraph && !m_pGraph.IsStopped()) {
                    TRACELM(TRACE_PAINT, "CVidctrl::OnDraw() vmr repaint");
                    lInnerColor = m_clrColorKey;
                    if (m_pVideoRenderer) {
                        CheckSurfaceStateChanged(rctInnerDst);
                        m_pVideoRenderer->RePaint(di.hdcDraw);
                        pdc = NULL; // don't delete the DC, it isn't ours        
                        return S_OK;
                    }
                }
            }
        }
        CheckSurfaceStateChanged(rctInnerDst);
        CBrush hb;
        HBRUSH hbrc = hb.CreateSolidBrush(lInnerColor);
        if (!hbrc) {
            TRACELM(TRACE_ERROR, "CVidctrl::OnDraw() can't create brush for mainrect");
            THROWCOM(E_UNEXPECTED);
        }

        TRACELSM(TRACE_PAINT, (dbgDump << "CVidctrl::OnDraw() rctInnerDst at main paint = " << rctInnerDst), "");
        TRACELSM(TRACE_PAINT, (dbgDump << "CVidctrl::OnDraw() innercolor = " << hexdump(lInnerColor)), "");

        if (!pdc.FillRect(rctInnerDst, hb)) {
            DWORD er = GetLastError();
            TRACELSM(TRACE_ERROR, (dbgDump << "CVidctrl::OnDraw() can't fill main video rect er = " << er), "");
            return HRESULT_FROM_WIN32(er);
        }
        pdc = NULL; // don't delete the DC, it isn't ours        

        return S_OK;
    } catch(...) {
        return E_UNEXPECTED;
    }

}

#endif

// this code is taken from the vmr utility library alloclib function LetterBoxDstRect().  
// its been modified to match my variable names, do inline __int64 arithmetic, use ATL CRect references,
// and always compute borders.
void CVidCtl::ComputeAspectRatioAdjustedRects(const CRect& rctSrc, const CRect& rctOuterDst, CRect& rctInnerDst, CRect& rctTLBorder, CRect& rctBRBorder) {
    // figure out src/dest scale ratios
    int iSrcWidth  = rctSrc.Width();
    int iSrcHeight = rctSrc.Height();

    int iOuterDstWidth  = rctOuterDst.Width();
    int iOuterDstHeight = rctOuterDst.Height();

    int iInnerDstWidth;
    int iInnerDstHeight;

    //
    // work out if we are Column or Row letter boxing
    //

    __int64 iWHTerm = iSrcWidth * (__int64)iOuterDstHeight;
    iWHTerm /= iSrcHeight;
    if (iWHTerm <= iOuterDstWidth) {

        //
        // column letter boxing - we add border color bars to the
        // left and right of the video image to fill the destination
        // rectangle.
        //
        iWHTerm = iOuterDstHeight * (__int64)iSrcWidth;
        iInnerDstWidth  = iWHTerm / iSrcHeight;
        iInnerDstHeight = iOuterDstHeight;
        TRACELSM(TRACE_PAINT, (dbgDump << "CVidctrl::ComputeAspectRatioAdjustedRects() col lb iw = " << iInnerDstWidth << " ih = " << iInnerDstHeight), "");
    }
    else {

        //
        // row letter boxing - we add border color bars to the top
        // and bottom of the video image to fill the destination
        // rectangle
        //
        iWHTerm = iOuterDstWidth * (__int64)iSrcHeight;
        iInnerDstHeight = iWHTerm / iSrcWidth;
        iInnerDstWidth  = iOuterDstWidth;
        TRACELSM(TRACE_PAINT, (dbgDump << "CVidctrl::ComputeAspectRatioAdjustedRects() row lb iw = " << iInnerDstWidth << " ih = " << iInnerDstHeight), "");
    }


    //
    // now create a centered inner letter-boxed rectangle within the current outer destination rect
    //

    rctInnerDst.left   = rctOuterDst.left + ((iOuterDstWidth - iInnerDstWidth) / 2);
    rctInnerDst.right  = rctInnerDst.left + iInnerDstWidth;

    rctInnerDst.top    = rctOuterDst.top + ((iOuterDstHeight - iInnerDstHeight) / 2);
    rctInnerDst.bottom = rctInnerDst.top + iInnerDstHeight;

    //
    // Fill out the border rects
    //

    if (rctOuterDst.top != rctInnerDst.top) {
        // border is on the top
        rctTLBorder = CRect(rctOuterDst.left, rctOuterDst.top,
            rctInnerDst.right, rctInnerDst.top);
    }
    else {
        // border is on the left
        rctTLBorder = CRect(rctOuterDst.left, rctOuterDst.top,
            rctInnerDst.left, rctInnerDst.bottom);
    }

    if (rctOuterDst.top != rctInnerDst.top) {
        // border is on the bottom
        rctBRBorder = CRect(rctInnerDst.left, rctInnerDst.bottom,
            rctOuterDst.right, rctOuterDst.bottom);
    }
    else {
        // border is on the right
        rctBRBorder = CRect(rctInnerDst.right, rctInnerDst.top, 
            rctOuterDst.right, rctOuterDst.bottom);
    }

    return;
}

LRESULT CVidCtl::OnShowWindow(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled) {
    bHandled = false;
    m_CurrentSurface.Visible(wParam != 0);
    TRACELSM(TRACE_DETAIL, (dbgDump << "CVidctrl::OnShowWindow() visible = " << m_CurrentSurface.IsVisible() << "surf = " << m_CurrentSurface), "" );
    RefreshVRSurfaceState();
    return  0;
}

LRESULT CVidCtl::OnMoveWindow(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled) {
    bHandled = false;
    CSize cursize(m_CurrentSurface.Width(), m_CurrentSurface.Height());
    HWND parent = ::GetParent(m_CurrentSurface.Owner());
    POINTS p(MAKEPOINTS(lParam));
    CPoint pt(p.x, p.y);
    CScalingRect newpos(pt, cursize, parent);
    ::InvalidateRect(m_CurrentSurface.Owner(), newpos, false); // force repaint to recalc letterboxing, etc.
    TRACELSM(TRACE_DETAIL, (dbgDump << "CVidctrl::OnMoveWindow() visible = " << m_CurrentSurface.IsVisible() << "surf = " << m_CurrentSurface), "" );
    return 0;
}

LRESULT CVidCtl::OnSizeWindow(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled) {
    bHandled = false;
    CScalingRect newsize(m_CurrentSurface.TopLeft(), CSize(lParam), m_CurrentSurface.Owner());
    ::InvalidateRect(m_CurrentSurface.Owner(), newsize, false); // force repaint to recalc letterboxing, etc.
    TRACELSM(TRACE_DETAIL, (dbgDump << "CVidctrl::OnSizeWindow() visible = " << m_CurrentSurface.IsVisible() << "surf = " << m_CurrentSurface), "" );
    return 0;
}

LRESULT CVidCtl::OnWindowPosChanged(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled) {
    bHandled = false;
    m_CurrentSurface.WindowPos(reinterpret_cast<LPWINDOWPOS>(lParam));
    TRACELSM(TRACE_DETAIL, (dbgDump << "CVidctrl::OnWindowPosChanged() visible = " << m_CurrentSurface.IsVisible() << "surf = " << m_CurrentSurface), "" );
    ::InvalidateRect(m_CurrentSurface.Owner(), m_CurrentSurface, false); // force repaint to recalc letterboxing, etc.
    return 0;
}

LRESULT CVidCtl::OnTerminate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled) {
    Stop();
    KillTimer();
    bHandled = false;
    return 0;
}

#if 0
[id(DISPID_CLICK)] void Click();
[id(DISPID_DBLCLICK)] void DblClick();
[id(DISPID_KEYDOWN)] void KeyDown(short* KeyCode, short Shift);
[id(DISPID_KEYPRESS)] void KeyPress(short* KeyAscii);
[id(DISPID_KEYUP)] void KeyUp(short* KeyCode, short Shift);
[id(DISPID_MOUSEDOWN)] void MouseDown(short Button, short Shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
[id(DISPID_MOUSEMOVE)] void MouseMove(short Button, short Shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
[id(DISPID_MOUSEUP)] void MouseUp(short Button, short Shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
[id(DISPID_ERROREVENT)] void Error(short Number, BSTR* Description, long Scode, BSTR Source, BSTR HelpFile, long HelpContext, boolean* CancelDisplay);
#endif

LRESULT CVidCtl::OnTimer(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled) {
    if (m_TimerID == wParam) {
        if (m_bNegotiatedWnd) {
            if (!m_bWndLess) {
                if (m_CurrentSurface.Width() && m_CurrentSurface.Height()) {
                    CScalingRect prevpos(m_CurrentSurface);
                    prevpos.Owner(::GetDesktopWindow());
                    CScalingRect curpos(::GetDesktopWindow());
                    if (!::GetWindowRect(m_CurrentSurface.Owner(), &curpos)) {
                        return HRESULT_FROM_WIN32(GetLastError());
                    }
                    if (curpos != prevpos) {
                        FireViewChange();  // force a repaint
                    }
                }
            }
        }

        BOOL lRes = 0;
        if (m_pGraph) {
            // as long as we're here, check for events too.
            OnMediaEvent(WM_MEDIAEVENT, 0, 0, lRes);
        }

        bHandled = true;
    } else {
        bHandled = false;
    }
    return 0;
}

LRESULT CVidCtl::OnPNP(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled) {
    // undone: implement pnp support
    return 0;
}

LRESULT CVidCtl::OnSetCursor(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled) {
    return CheckMouseCursor(bHandled);
}

LRESULT CVidCtl::OnPower(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled) {
    // undone: implement rational power management support
    return 0;
}

LRESULT CVidCtl::OnDisplayChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled) {
    if (m_pVideoRenderer) {
        m_pVideoRenderer->DisplayChange();
        FireViewChange();
    }
    return 0;
}

HRESULT CVidCtl::OnPreEventNotify(LONG lEvent, LONG_PTR LParam1, LONG_PTR LParam2){
    try{
        TRACELSM(TRACE_DETAIL, (dbgDump << "CVidCtl::PreEventNotify ev = " << hexdump(lEvent)), "");         
        TRACELSM(TRACE_DETAIL, (dbgDump << "CVidCtl::PreEventNotify lp1 = " << hexdump(LParam1)), "");
        TRACELSM(TRACE_DETAIL, (dbgDump << "CVidCtl::PreEventNotify lp2 = " << hexdump(LParam2)), "");
        MSVidCtlStateList prevstate = m_State;
        MSVidCtlStateList newstate = m_State;
        // Events where stop is the new state
        if (lEvent == EC_BUILT) {
            prevstate = STATE_UNBUILT;
            newstate = STATE_STOP;
        }
        if (lEvent == EC_STATE_CHANGE && LParam1 == State_Stopped) {
            newstate = STATE_STOP;
        }
        // Events where play is the new state
        if (lEvent == EC_STATE_CHANGE && LParam1 == State_Running) {
            newstate = STATE_PLAY;
        }
        // Events where unbuilt is the new state
        if( lEvent == EC_UNBUILT ) {
            newstate = STATE_UNBUILT;
        }
        // Events where paused is the new state
        if( lEvent == EC_STATE_CHANGE && LParam1 == State_Paused ) {
            newstate = STATE_PAUSE;
        }
        if( lEvent == EC_PAUSED ){
            TRACELSM(TRACE_DETAIL, (dbgDump << "CVidCtl::PreEventNotify EC_PAUSED"), "");       
        }
        if (newstate != prevstate) {
            m_State = newstate;
            Fire_StateChange(prevstate, m_State);
        }
        if (lEvent == EC_DISPLAY_CHANGED) {
            ComputeDisplaySize();
        }
        if (lEvent == EC_VMR_RECONNECTION_FAILED){
            TRACELSM(TRACE_DETAIL, (dbgDump << "CVidCtl::PreEventNotify EC_VMR_RECONNECTION_FAILED"), ""); 
            HRESULT hr = Stop();
            if(FAILED(hr)){
                return hr;
            }
            return Error(IDS_NOT_ENOUGH_VIDEO_MEMORY, __uuidof(IMSVidCtl), IDS_NOT_ENOUGH_VIDEO_MEMORY);
        }
        if(lEvent == EC_COMPLETE){
            TRACELSM(TRACE_DETAIL, (dbgDump << "CVidCtl::PreEventNotify EC_COMPLETE"), "");     
        }
        // undone: recompute displaysize if video source changes
    }
    catch (HRESULT hr){
        return hr;
    }
    catch (...){
        return E_UNEXPECTED;
    }
    return E_NOTIMPL;
}

HRESULT CVidCtl::OnPostEventNotify(LONG lEvent, LONG_PTR LParam1, LONG_PTR LParam2){
    try{
        if (lEvent == EC_VMR_RENDERDEVICE_SET) {
#if 0
            CSize s;
            GetSourceSize(s);
            TRACELSM(TRACE_DEBUG, (dbgDump << "CVidCtl::OnPostEventNotify() VMR_RENDERDEVICE_SET srcrect = " << s), "");
#endif
            Refresh();
        }
    }
    catch (HRESULT hr){
        return hr;
    }
    catch (...){
        return E_UNEXPECTED;
    }
    return E_NOTIMPL;
}

LRESULT CVidCtl::OnMediaEvent(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled) {

    PQMediaEventEx pme(m_pGraph);
    LONG        lEvent;
    LONG_PTR    lParam1, lParam2;
    HRESULT hr2;
    try{
        if (!pme) {
            return E_UNEXPECTED;
        }
        hr2 = pme->GetEvent(&lEvent, &lParam1, &lParam2, 0);
        while (SUCCEEDED(hr2)){
            TRACELSM(TRACE_DETAIL, (dbgDump << "CVidCtl::OnMediaevent ev = " << hexdump(lEvent) << " lp1 = " << hexdump(lParam1) << " lp2 = " << hexdump(lParam2)), "");       
            HRESULT hr;
            /*** Check who wants the Event ***/
            /*** If they want it should return something other than E_NOTIMPL ***/

            // Does CVidCtl want it?
            hr = OnPreEventNotify(lEvent, lParam1, lParam2);

            //Does the input want it?
            if(hr == E_NOTIMPL){
                PQGraphSegment pSeg(m_pInput);
                if (pSeg) {
                    hr = pSeg->OnEventNotify(lEvent, lParam1, lParam2);
                }
            }

            // Do any of the features want it?
            if (hr == E_NOTIMPL) {

                for ( VWFeatures::iterator i = m_pFeaturesInUse.begin(); hr == E_NOTIMPL && i != m_pFeaturesInUse.end(); ++i) {
                    hr = PQGraphSegment((*i).punkVal)->OnEventNotify(lEvent, lParam1, lParam2);
                }
            }

            //Does the video renderer want it?
            if(hr == E_NOTIMPL){
                PQGraphSegment pSeg(m_pVideoRenderer);
                if(pSeg){
                    hr = pSeg->OnEventNotify(lEvent, lParam1, lParam2);
                }
            }

            // Does the audio renderer want it?
            if(hr == E_NOTIMPL){
                PQGraphSegment pSeg(m_pAudioRenderer);
                if(pSeg){
                    hr = pSeg->OnEventNotify(lEvent, lParam1, lParam2);
                }
            }

            // Do any of the outputs want it?  
            if(hr == E_NOTIMPL){  
                if (!!m_pOutputsInUse && m_pOutputsInUse.begin() != m_pOutputsInUse.end()) {
                    for (VWOutputDevices::iterator i = m_pOutputs.begin(); hr == E_NOTIMPL && i != m_pOutputs.end(); ++i) {
                        hr = PQGraphSegment((*i).punkVal)->OnEventNotify(lEvent, lParam1, lParam2);
                    }
                }
            }

            // Finally do any of the composites want it?
            if(hr == E_NOTIMPL){
                for(VWSegmentList::iterator i = m_pComposites.begin(); hr == E_NOTIMPL && i != m_pComposites.end(); i++){    
                    hr = PQGraphSegment(*i)->OnEventNotify(lEvent, lParam1, lParam2);
                }  
            }

            // Check again to see if CVidCtl want to do anything else regardless of whether or not
            // it got handled by a segment
            hr = OnPostEventNotify(lEvent, lParam1, lParam2);

            //
            // Remember to free the event params
            //
            pme->FreeEventParams(lEvent, lParam1, lParam2) ;
            hr2 = pme->GetEvent(&lEvent, &lParam1, &lParam2, 0);
        }
    }
    catch (HRESULT hr){
        return hr;
    }
    catch (...){
        return E_UNEXPECTED;
    }
    return 0;
}

// rev2: if we ever redist to 9x then we need to examine the mfc dbcs processing
// and adapt it.
LRESULT CVidCtl::OnChar(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled) {
    //(UINT nChar, UINT nRepCnt, UINT nFlags)

    SHORT nCharShort = LOWORD(wParam);
    HRESULT hr = NOERROR;
    if (m_pInputNotify) {
        hr = m_pInputNotify->KeyPress(&nCharShort);
    }
    if (hr != S_FALSE) {
        Fire_KeyPress(&nCharShort);
    }
    if (!nCharShort) {
        return 0;
    }

    return 1;
}

LRESULT CVidCtl::OnKeyDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled) {
    if (!(KF_REPEAT & HIWORD(lParam))) {
        short keycode = LOWORD(wParam);
        short shiftstate = GetShiftState();
        HRESULT hr = NOERROR;
        if (m_pInputNotify) {
            hr = m_pInputNotify->KeyDown(&keycode, shiftstate);
        }
        if (hr != S_FALSE) {
            Fire_KeyDown(&keycode, shiftstate);
        }
        if (!keycode) {
            return 0;
        }
    }

    return 1;
}

LRESULT CVidCtl::OnKeyUp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled) {
    short keycode = LOWORD(wParam);
    short shiftstate = GetShiftState();
    HRESULT hr = NOERROR;
    if (m_pInputNotify) {
        hr = m_pInputNotify->KeyUp(&keycode, shiftstate);
    }
    if (hr != S_FALSE) {
        Fire_KeyUp(&keycode, shiftstate);
    }
    if (!keycode) {
        return 0;
    }

    return 1;
}

// undone: syskey stuff
LRESULT CVidCtl::OnMouseActivate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled) {
    if (!m_bUIActive) {
        m_bPendingUIActivation = true;
    }

    return 1;
}

LRESULT CVidCtl::OnCancelMode(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled) {
    SetControlFocus(false);
    SetControlCapture(false);
    m_bPendingUIActivation = false;

    return 1;
}

LRESULT CVidCtl::OnMouseMove(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
//(UINT /*nFlags*/, CPoint point)
{
    CheckMouseCursor(bHandled);
    CPoint point(lParam);
    HRESULT hr = NOERROR;
    if (m_pInputNotify) {
        hr = m_pInputNotify->MouseMove(m_usButtonState, m_usShiftState, point.x, point.y);
    }
    if (hr != S_FALSE) {
        Fire_MouseMove(m_usButtonState, m_usShiftState, point.x, point.y);
    }

    return 1;
}

LRESULT CVidCtl::OnLButtonDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
//(UINT nFlags, CPoint point)
{
    OnButtonDown(MSVIDCTL_LEFT_BUTTON, wParam, lParam);

    return 1;
}

LRESULT CVidCtl::OnLButtonUp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
//(UINT nFlags, CPoint point)
{
    OnButtonUp(MSVIDCTL_LEFT_BUTTON, wParam, lParam);

    return 1;
}

LRESULT CVidCtl::OnLButtonDblClk(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
//(UINT nFlags, CPoint point)
{
    OnButtonDblClk(MSVIDCTL_LEFT_BUTTON, wParam, lParam);

    return 1;
}

LRESULT CVidCtl::OnMButtonDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
//(UINT nFlags, CPoint point)
{
    OnButtonDown(MSVIDCTL_MIDDLE_BUTTON, wParam, lParam);

    return 1;
}

LRESULT CVidCtl::OnMButtonUp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
//(UINT nFlags, CPoint point)
{
    OnButtonUp(MSVIDCTL_MIDDLE_BUTTON, wParam, lParam);

    return 1;
}

LRESULT CVidCtl::OnMButtonDblClk(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
//(UINT nFlags, CPoint point)
{
    OnButtonDblClk(MSVIDCTL_MIDDLE_BUTTON, wParam, lParam);

    return 1;
}

LRESULT CVidCtl::OnRButtonDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
//(UINT nFlags, CPoint point)
{
    OnButtonDown(MSVIDCTL_RIGHT_BUTTON, wParam, lParam);

    return 1;
}

LRESULT CVidCtl::OnRButtonUp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
//(UINT nFlags, CPoint point)
{
    OnButtonUp(MSVIDCTL_RIGHT_BUTTON, wParam, lParam);

    return 1;
}

LRESULT CVidCtl::OnRButtonDblClk(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
//(UINT nFlags, CPoint point)
{
    OnButtonDblClk(MSVIDCTL_RIGHT_BUTTON, wParam, lParam);

    return 1;
}

LRESULT CVidCtl::OnXButtonDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
//(UINT nFlags, CPoint point)
{
    UINT button = HIWORD(wParam);
    if (button & XBUTTON1) {
        OnButtonDown(MSVIDCTL_X_BUTTON1, wParam, lParam);
    } else {
        OnButtonDown(MSVIDCTL_X_BUTTON2, wParam, lParam);
    }

    return 1;
}

LRESULT CVidCtl::OnXButtonUp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
//(UINT nFlags, CPoint point)
{
    UINT button = HIWORD(wParam);
    if (button & XBUTTON1) {
        OnButtonUp(MSVIDCTL_X_BUTTON1, wParam, lParam);
    } else {
        OnButtonUp(MSVIDCTL_X_BUTTON2, wParam, lParam);
    }

    return 1;
}

LRESULT CVidCtl::OnXButtonDblClk(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
//(UINT nFlags, CPoint point)
{
    UINT button = HIWORD(wParam);
    if (button & XBUTTON1) {
        OnButtonDblClk(MSVIDCTL_X_BUTTON1, wParam, lParam);
    } else {
        OnButtonDblClk(MSVIDCTL_X_BUTTON2, wParam, lParam);
    }

    return 1;
}

void CVidCtl::OnButtonDown(USHORT nButton, UINT nFlags, CPoint point)
{
    if (nButton == MSVIDCTL_LEFT_BUTTON) {
        if (m_bWndLess || m_bUIActive || m_bPendingUIActivation) {
            SetControlFocus(true);
        }
    }
    if (!m_usButtonState && (m_bUIActive || m_bPendingUIActivation)) {
        SetControlCapture(true);
    }

    m_usButtonState |= nButton;

    HRESULT hr = NOERROR;
    if (m_pInputNotify) {
        hr = m_pInputNotify->MouseDown(m_usButtonState, m_usShiftState, point.x, point.y);
    }
    if (hr != S_FALSE) {
        Fire_MouseDown(m_usButtonState, m_usShiftState, point.x, point.y);
    }

    m_iDblClkState &= ~nButton;

    return;
}

void CVidCtl::OnButtonUp(USHORT nButton, UINT nFlags, CPoint point)
{
    m_usButtonState &= nButton;

    if (!m_usButtonState) {
        SetControlCapture(false);
    }

    HRESULT hr = NOERROR;
    if (m_pInputNotify) {
        hr = m_pInputNotify->MouseUp(m_usButtonState, m_usShiftState, point.x, point.y);
    }
    if (hr != S_FALSE) {
        Fire_MouseUp(m_usButtonState, m_usShiftState, point.x, point.y);
    }

    if (!(m_iDblClkState & nButton))
    {
        bool bHitUs = false;
        if (m_bWndLess) {
            bHitUs = !!::PtInRect(&m_rcPos, point);
        } else if (m_hWnd && ::IsWindow(m_hWnd)) {
            CRect rect;
            GetClientRect(&rect);
            bHitUs = !!rect.PtInRect(point);
        }
        if (!bHitUs) {
            return;
        }
        hr = NOERROR;
        if (m_pInputNotify) {
            hr = m_pInputNotify->Click();
        }
        if (hr != S_FALSE) {
            Fire_Click();
        }
        if (!m_bInPlaceActive) {
            InPlaceActivate(OLEIVERB_INPLACEACTIVATE, NULL);
        } else if (!m_bUIActive && m_bPendingUIActivation)
        {
            InPlaceActivate(OLEIVERB_UIACTIVATE, NULL);
        }
        m_bPendingUIActivation = FALSE;
    } else {
        m_iDblClkState &= ~nButton;
    }

    return;
}

void CVidCtl::OnButtonDblClk(USHORT nButton, UINT nFlags, CPoint point)
{
    HRESULT hr = NOERROR;
    if (m_pInputNotify) {
        hr = m_pInputNotify->DblClick();
    }

    if (hr != S_FALSE) {
        Fire_DblClick();
    }

    m_iDblClkState |= nButton;
    if (!m_bInPlaceActive) {
        InPlaceActivate(OLEIVERB_INPLACEACTIVATE, NULL);
    } else if (!m_bUIActive && m_bPendingUIActivation){
        InPlaceActivate(OLEIVERB_UIACTIVATE, NULL);
    }

    m_bPendingUIActivation = FALSE;

    return;
}

// this routine sets up all the crossbar routing so the streams coming out of the
// input get where they're supposed to go
HRESULT CVidCtl::RouteStreams() {
    VIDPERF_FUNC;
    int isEncoder = -1;
    VWStream vpath;
    VWStream apath;
    // See how far we have to route the audio/video
    CComQIPtr<IMSVidAnalogTuner> qiITV(m_pInput);
    if(!!qiITV){
        CComQIPtr<ITuneRequest> qiTR;
        HRESULT hr = qiITV->get_Tune(&qiTR);
        if(SUCCEEDED(hr)){
            qiITV->put_Tune(qiTR);
        }
    }
    // undone: in win64 size() is really __int64.  fix output operator for
    // that type and remove cast
    {
        if (!!m_pOutputsInUse && m_pOutputsInUse.begin() != m_pOutputsInUse.end()) {

            for (VWOutputDevices::iterator i = m_pOutputsInUse.begin(); i != m_pOutputsInUse.end(); ++i) {
                CComQIPtr<IMSVidOutputDevice> pqODev = VWGraphSegment(*i);
                if(!pqODev){
                    return E_UNEXPECTED;
                }

                GUID2 outputID;
                HRESULT hr = pqODev->get__ClassID(&outputID);
                if(FAILED(hr)){
                    return hr;
                }

                if(outputID == CLSID_MSVidStreamBufferSink){
                    CComQIPtr<IMSVidStreamBufferSink> pqTSSink(pqODev);
                    hr = pqTSSink->NameSetLock();
                    if(FAILED(hr)){
                        return hr;
                    }
                }

            }
        }
    }
    // undone: other dest segments

    return NOERROR;
}

#if 0
CString CVidCtl::GetMonitorName(HMONITOR hm) {
    MONITORINFOEX mi;
    mi.cbSize = sizeof(mi);
    if (!GetMonitorInfo(hm, &mi)) {
        THROWCOM(HRESULT_FROM_WIN32(GetLastError()));
    }
    return CString(mi.szDevice);
}

HRESULT CVidCtl::GetDDrawNameForMonitor(HMONITOR hm, VMRGUID& guid) {
    PQVMRMonitorConfig pmc(m_pVideoRenderer);
    if (!pmc) {
        return E_UNEXPECTED;  // should always exist by now
    }
    DWORD dwCount;
    HRESULT hr = pmc->GetAvailableMonitors(NULL, 0, &dwCount);
    if (FAILED(hr)) {
        return hr;
    }
    VMRMONITORINFO* pInfo = reinterpret_cast<VMRMONITORINFO*>(_alloca(sizeof(VMRMONITORINFO) * dwCount));
    if (!pInfo) {
        return E_OUTOFMEMORY;
    }
    hr = pmc->GetAvailableMonitors(pInfo, dwCount, &dwCount);
    if (FAILED(hr)) {
        return hr;
    }
    CString csMonitorName(GetMonitorName(hm));

    for (int i = 0; i < dwCount; ++i) {
        CString csDevName(pInfo[i].szDevice);
        if (csDevName == csMonitorName) break;
    }
    if (i >= dwCount) {
        // no ddraw device exist with a name which matches the monitor name
        return HRESULT_FROM_WIN32(ERROR_DEV_NOT_EXIST);
    }
    guid = pInfo[i].guid;
    return NOERROR;
}

HRESULT CVidCtl::GetCapsForMonitor(HMONITOR hm, LPDDCAPS pDDCaps) {
    VMRGUID ddname;
    HRESULT hr = GetDDrawNameForMonitor(hm, ddname);
    if (FAILED(hr)) {
        return hr;
    }
    PQDirectDraw7 pDD;
    hr = DirectDrawCreateEx(ddname.pGUID, reinterpret_cast<LPVOID*>(&pDD), IID_IDirectDraw7, NULL);
    if (FAILED(hr)) {
        return hr;
    }
    return pDD->GetCaps(pDDCaps, NULL);
}

bool CVidCtl::MonitorHasHWOverlay(HMONITOR hm) {
    DDCAPS caps;
    HRESULT hr = GetCapsForMonitor(hm, &caps);
    if (SUCCEEDED(hr)) {
        // undone: if caps include hw overlay {
        //      return true;
        // }

    }
    return false;
}

bool CVidCtl::WindowHasHWOverlay(HWND hWnd) {
#if 0 // undone: turn on when finished
    DWORD dwFlags = MONITOR_DEFAULT_TO_NEAREST
        if (hWnd == INVALID_HWND_VALUE) {
            // if we don't have an hwnd yet, assume the primary
            hWnd = HWND_DESKTOP;
            dwFlags = MONITOR_DEFAULT_TO_PRIMARY;
        }
        HMONITOR hm = ::MonitorFromWindow(hWnd, dwFlags);
        return MonitorHasHWOverlay(hm);
#else
    return true; // mimic current behavior
#endif
}
#endif

// ISupportsErrorInfo
STDMETHODIMP CVidCtl::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] =
    {
        &__uuidof(IMSVidCtl),
    };
    for (int i=0; i<sizeof(arr)/sizeof(arr[0]); i++)
    {
        if (InlineIsEqualGUID(*arr[i], riid))
            return S_OK;
    }
    return S_FALSE;
}
STDMETHODIMP CVidCtl::put_ServiceProvider(/*[in]*/ IUnknown * pServiceP){
    if(!pServiceP){
        punkCert.Release();
        return S_FALSE;
    }
    punkCert = pServiceP;
    if(!punkCert){
        return E_NOINTERFACE;
    }
    return S_OK;
}
STDMETHODIMP CVidCtl::QueryService(REFIID service, REFIID iface, LPVOID* ppv) {  
    if (service == __uuidof(IWMReader) && iface == IID_IUnknown && 
        (VWGraphSegment(m_pInput).ClassID() == CLSID_MSVidFilePlaybackDevice || 
        VWGraphSegment(m_pInput).ClassID() == CLSID_MSVidStreamBufferSource)) {
        if (!!punkCert) {
            return punkCert.CopyTo(ppv);
        }
    }
    PQServiceProvider psp(m_spInPlaceSite);
    if (!psp) {
        if (m_spClientSite) {
            HRESULT hr = m_spClientSite->QueryInterface(IID_IServiceProvider, reinterpret_cast<LPVOID*>(&psp));
            if (FAILED(hr)) {
                return E_FAIL;
            }
        } else {
            return E_FAIL;
        }
    }
    return psp->QueryService(service, iface, ppv);
}
HRESULT CVidCtl::SetClientSite(IOleClientSite *pClientSite){
    if(!!pClientSite){
        HRESULT hr = IsSafeSite(pClientSite);
        if(FAILED(hr)){
            return hr;
        }
    }
    return IOleObjectImpl<CVidCtl>::SetClientSite(pClientSite);
}

#if 0
HRESULT CVidCtl::DoVerb(LONG iVerb, LPMSG pMsg, IOleClientSite* pActiveSite, LONG linddex,
                        HWND hwndParent, LPCRECT lprcPosRect){
                            if(!m_spClientSite){
                                return E_FAIL;
                            }
                            else{
                                return IOleObjectImpl<CVidCtl>::DoVerb(iVerb, pMsg, pActiveSite, linddex, hwndParent, lprcPosRect);
                            }
                        }
#endif

#endif //TUNING_MODEL_ONLY

                        // end of file - VidCtl.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\videorenderercp.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#ifndef _MSVIDVIDEORENDERERCP_H_
#define _MSVIDVIDEORENDERERCP_H_

template <class T>
class CProxy_IMSVidVideoRenderer : public CProxy_VRSeg<T, &IID_IMSVidVideoRendererEvent, CComDynamicUnkArray>
{
	//Warning this class may be recreated by the wizard.
public:

// TODO: add fileplayback specific events here	
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\inc\ddraw\ddagp.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddagp.h
 *  Content:	AGP memory header file
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   03-Feb-98	DrewB   Split from ddrawpr.h for user/kernel portability.
 *
 ***************************************************************************/

#ifndef __DDAGP_INCLUDED__
#define __DDAGP_INCLUDED__

// This value controls how big a chunk of GART memory to commit each time
// we need to (rather than commiting just what we need to satisfy a surface
// request). This value is in bytes.  Currently 256KB.
#define DEFAULT_AGP_COMMIT_DELTA (256 * 1024)

extern DWORD dwAGPPolicyMaxBytes;
extern DWORD dwAGPPolicyCommitDelta;

//
// OS-specific functions for AGP manipulation.
//

#ifdef WIN95
#define OsGetAGPDeviceHandle(pHeap) GetDXVxdHandle()
#define OsCloseAGPDeviceHandle(h) CloseHandle(h)
#else
#define OsGetAGPDeviceHandle(pHeap) ((pHeap)->hdevAGP)
#define OsCloseAGPDeviceHandle(h)
#endif

BOOL OsAGPReserve( HANDLE hdev, DWORD dwNumPages, BOOL fIsUC, BOOL fIsWC,
                   FLATPTR *pfpLinStart, LARGE_INTEGER *pliDevStart,
                   LPVOID *ppvReservation );
BOOL OsAGPCommit( HANDLE hdev, LPVOID pvReservation,
                  DWORD dwPageOffset, DWORD dwNumPages );
BOOL OsAGPDecommitAll( HANDLE hdev, LPVOID pvReservation, DWORD dwNumPages );
BOOL OsAGPFree( HANDLE hdev, LPVOID pvReservation );

//
// Generic functions that use the OS-specific functions.
//

DWORD AGPReserve( HANDLE hdev, DWORD dwSize, BOOL fIsUC, BOOL fIsWC,
                  FLATPTR *pfpLinStart, LARGE_INTEGER *pliDevStart,
                  LPVOID *ppvReservation );
BOOL AGPCommit( HANDLE hdev, LPVOID pvReservation,
                DWORD dwOffset, DWORD dwSize );
BOOL AGPDecommitAll( HANDLE hdev, LPVOID pvReservation, DWORD dwSize );
BOOL AGPFree( HANDLE hdev, LPVOID pvReservation );

#ifndef __NTDDKCOMP__

#ifdef WIN95
BOOL vxdIsVMMAGPAware ( HANDLE hvxd );
#endif

BOOL OSIsAGPAware( HANDLE hdev );
#endif

#endif // __DDAGP_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\vidctl.h ===
/////////////////////////////////////////////////////////////////////////////
// VidCtl.h : Declaration of the CVidCtl
// Copyright (c) Microsoft Corporation 1999-2001.


#pragma once

#ifndef __VidCtl_H_
#define __VidCtl_H_

#include <msvidctl.h>
#include "devices.h"
#include "composition.h"
#include "surface.h"
#include "topwin.h"
#include <objectwithsiteimplsec.h>
#include "msvidcp.h"
#include "perfcntr.h"

typedef CComQIPtr<IMSVidGraphSegmentUserInput, &__uuidof(IMSVidGraphSegmentUserInput)> PQGraphSegmentUserInput;

#define OCR_ARROW_DEFAULT_SYSCUR 100       // Default Windows OEM arrow system cursor

// if source size isn't known default to 480P since its most common
const int DEFAULT_SIZE_X = 640;
const int DEFAULT_SIZE_Y = 480;

#ifdef ASYNC_VR_NOTIFY
#define SURFACESTATECHANGED() \         // post message to self
                if (m_CurrentSurface.IsDirty() { \
                        ::PostMessage(self registered msg,???); \
                }
#endif

const OLE_COLOR NO_DEVICE_COLOR = 0x0; //black if no device set(Default Background Color)
const OLE_COLOR DEFAULT_COLOR_KEY_COLOR = 0xff00ff; // magenta
const int DEFAULT_TIMER_ID = 42;
const int DEFAULT_WINDOW_SYNCH_TIMER_TIME = 1000; //ms

#define WM_MEDIAEVENT               (WM_USER+101)

const CRect crect0(0, 0, 0, 0);
const LPCRECT pcrect0 = &crect0;

class CTopWin;
/////////////////////////////////////////////////////////////////////////////
// CVidCtl
class ATL_NO_VTABLE CVidCtl :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComControl<CVidCtl>,
    public CStockPropImpl<CVidCtl, IMSVidCtl, &IID_IMSVidCtl, &LIBID_MSVidCtlLib>,
    public IPersistStreamInitImpl<CVidCtl>,
    public IOleControlImpl<CVidCtl>,
    public IOleObjectImpl<CVidCtl>,
    public IOleInPlaceActiveObjectImpl<CVidCtl>,
    public IViewObjectExImpl<CVidCtl>,
    public IOleInPlaceObjectWindowlessImpl<CVidCtl>,
    public ISupportErrorInfo,
    public IConnectionPointContainerImpl<CVidCtl>,
    public IPersistStorageImpl<CVidCtl>,
    public IPersistPropertyBagImpl<CVidCtl>,
    public ISpecifyPropertyPagesImpl<CVidCtl>,
    public IQuickActivateImpl<CVidCtl>,
    public IDataObjectImpl<CVidCtl>,
    public IProvideClassInfo2Impl<&CLSID_MSVidCtl, &DIID__IMSVidCtlEvents, &LIBID_MSVidCtlLib>,
    public IPropertyNotifySinkCP<CVidCtl>,
    public IObjectSafetyImpl<CVidCtl, INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA>,
    public IMSVidGraphSegmentContainer,
    public CComCoClass<CVidCtl, &CLSID_MSVidCtl>,
    public CProxy_IMSVidCtlEvents< CVidCtl >,
    public IServiceProvider,
    public IObjectWithSiteImplSec<CVidCtl>,
	public IPointerInactiveImpl<CVidCtl>
    {
private:
// can't find this catid in any system header so we're defining our own
struct __declspec(uuid("1D06B600-3AE3-11cf-87B9-00AA006C8166")) CATID_WindowlessObject;
friend CTopWin;        
public:
    CVidCtl() :
        m_fInit(false),
        m_fGraphDirty(true),
        m_TimerID(DEFAULT_TIMER_ID),
        m_WindowSynchTime(DEFAULT_WINDOW_SYNCH_TIMER_TIME),
        m_fTimerOn(false),
        m_fNotificationSet(false),
        m_pComposites(VWSegmentList()),
        m_iCompose_Input_Video(-1),
        m_iCompose_Input_Audio(-1),
        m_clrBackColor(NO_DEVICE_COLOR),
        m_clrColorKey(DEFAULT_COLOR_KEY_COLOR),
        m_iDblClkState(0),
        m_usButtonState(0),
        m_usShiftState(0),
        m_bPendingUIActivation(false),
        m_fMaintainAspectRatio(VARIANT_FALSE),
        m_pTopWin(NULL),
		m_hCursor(NULL),
        m_dwROTCookie(0),
        m_videoSetNull(false),
        m_dslDisplaySize(dslDefaultSize),
        m_audioSetNull(false)
        // undone: default displaystyle to source size
		{
            m_State = STATE_UNBUILT;
            m_bAutoSize = false; // default to autosized
			m_bRecomposeOnResize = true;
            if (!VideoTypes.size()) {
                VideoTypes.push_back(MEDIATYPE_Video);
                VideoTypes.push_back(MEDIATYPE_AnalogVideo);

            }
            if (!AudioTypes.size()) {
                AudioTypes.push_back(MEDIATYPE_Audio);
                AudioTypes.push_back(MEDIATYPE_AnalogAudio);
            }

#ifndef ENABLE_WINDOWLESS_SUPPORT
            m_bWindowOnly = true;
#endif            
        }   
        
    virtual ~CVidCtl();
        
    // IMPORTANT: no matter how tempting don't add OLEMISC_IGNOREACTIVATEWHENVISIBLE
    // to the registration of this control.  it breaks the case where we return
    // a running vidctl from the tv: pluggable protocol.  we never get activated.
    REGISTER_FULL_CONTROL(IDS_PROJNAME,
        IDS_REG_VIDCTL_PROGID,
        IDS_REG_VIDCTL_DESC,
        LIBID_MSVidCtlLib,
        CLSID_MSVidCtl, 1, 0,
		OLEMISC_ACTIVATEWHENVISIBLE | 
		OLEMISC_RECOMPOSEONRESIZE | OLEMISC_CANTLINKINSIDE | 
		OLEMISC_INSIDEOUT);
        
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_CATEGORY_MAP(CVidCtl)
    IMPLEMENTED_CATEGORY(CATID_Control)
    IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
    IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
    IMPLEMENTED_CATEGORY(CATID_Programmable)
    IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
    IMPLEMENTED_CATEGORY(CATID_PersistsToStorage)
#ifdef ENABLE_WINDOWLESS_SUPPORT
    IMPLEMENTED_CATEGORY(__uuidof(CATID_WindowlessObject))
#endif
END_CATEGORY_MAP()

BEGIN_COM_MAP(CVidCtl)
    COM_INTERFACE_ENTRY(IMSVidCtl)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IViewObjectEx)
    COM_INTERFACE_ENTRY(IViewObject2)
    COM_INTERFACE_ENTRY(IViewObject)
#ifdef ENABLE_WINDOWLESS_SUPPORT
    COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
#endif
    COM_INTERFACE_ENTRY(IOleInPlaceObject)
    COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY(IOleControl)
    COM_INTERFACE_ENTRY(IOleObject)
    COM_INTERFACE_ENTRY(IPersistStreamInit)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(IConnectionPointContainer)
    COM_INTERFACE_ENTRY(ISpecifyPropertyPages)
    COM_INTERFACE_ENTRY(IQuickActivate)
    COM_INTERFACE_ENTRY(IPersistStorage)
    COM_INTERFACE_ENTRY(IPersistPropertyBag)
    COM_INTERFACE_ENTRY(IDataObject)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IProvideClassInfo2)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY(IMSVidGraphSegmentContainer)
	COM_INTERFACE_ENTRY(IPointerInactive)
	COM_INTERFACE_ENTRY(IServiceProvider)
	COM_INTERFACE_ENTRY(IObjectWithSite)
END_COM_MAP()

BEGIN_PROP_MAP(CVidCtl)
        PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
        PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
        PROP_ENTRY("AutoSize", DISPID_AUTOSIZE, CLSID_NULL)
        PROP_ENTRY("Enabled", DISPID_ENABLED, CLSID_NULL)
        PROP_ENTRY("TabStop", DISPID_TABSTOP, CLSID_NULL)
        PROP_ENTRY("BackColor", DISPID_BACKCOLOR, CLSID_NULL)
END_PROP_MAP()

BEGIN_CONNECTION_POINT_MAP(CVidCtl)
        CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
        CONNECTION_POINT_ENTRY(DIID__IMSVidCtlEvents)
END_CONNECTION_POINT_MAP()

void ComputeAspectRatioAdjustedRects(const CRect& rctSrc, const CRect& rctOuterDst, CRect& rctInnerDst, CRect& rctTLBorder, CRect& rctlBRBorder);
HRESULT OnDrawAdvanced(ATL_DRAWINFO& di);

static MediaMajorTypeList VideoTypes;
static MediaMajorTypeList AudioTypes;

SurfaceState m_CurrentSurface;

CTopWin* m_pTopWin;

UINT m_iDblClkState;
bool m_bPendingUIActivation;
USHORT m_usButtonState;  // stock oa event bit positions
USHORT m_usShiftState;
HCURSOR m_hCursor; // mouse cursor to use over our window when overlay active to prevent colorkey bleed through

DWORD m_dwROTCookie;

void OnButtonDown(USHORT nButton, UINT nFlags, CPoint point);
void OnButtonUp(USHORT nButton, UINT nFlags, CPoint point);
void OnButtonDblClk(USHORT nButton, UINT nFlags, CPoint point);

#define MSG_FUNC(func) LRESULT func(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)

MSG_FUNC(OnShowWindow);
MSG_FUNC(OnMoveWindow);
MSG_FUNC(OnSizeWindow);

inline MSG_FUNC(OnSurfaceStateChanged) {
        RefreshVRSurfaceState();
        return 0;
}

MSG_FUNC(OnWindowPosChanged);
MSG_FUNC(OnTerminate);
MSG_FUNC(OnTimer);
MSG_FUNC(OnMediaEvent);
MSG_FUNC(OnDisplayChange);
MSG_FUNC(OnPower);
MSG_FUNC(OnPNP);
MSG_FUNC(OnSetCursor);


MSG_FUNC(OnChar);
MSG_FUNC(OnKeyDown);
MSG_FUNC(OnKeyUp);
#if 0 // undone:
MSG_FUNC(OnSysKeyDown);
MSG_FUNC(OnSysKeyUp);
#endif

MSG_FUNC(OnCancelMode);
MSG_FUNC(OnMouseActivate);
MSG_FUNC(OnMouseMove);

MSG_FUNC(OnLButtonDown);
MSG_FUNC(OnLButtonUp);
MSG_FUNC(OnLButtonDblClk);

MSG_FUNC(OnMButtonDown);
MSG_FUNC(OnMButtonUp);
MSG_FUNC(OnMButtonDblClk);
MSG_FUNC(OnRButtonDown);
MSG_FUNC(OnRButtonUp);
MSG_FUNC(OnRButtonDblClk);
MSG_FUNC(OnXButtonDown);
MSG_FUNC(OnXButtonUp);
MSG_FUNC(OnXButtonDblClk);
#if 0 // undone:
MSG_FUNC(OnMouseWheel);
#endif


// undone: make sure we call onterminate for windowless close functions

// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
BEGIN_MSG_MAP(CVidCtl)
        MESSAGE_HANDLER(WM_SHOWWINDOW, OnShowWindow)
        MESSAGE_HANDLER(WM_MOVE, OnMoveWindow)
        MESSAGE_HANDLER(WM_SIZE, OnSizeWindow)
        MESSAGE_HANDLER(WM_WINDOWPOSCHANGED, OnWindowPosChanged)
        MESSAGE_HANDLER(WM_CLOSE, OnTerminate)
        MESSAGE_HANDLER(WM_NCDESTROY, OnTerminate)
        MESSAGE_HANDLER(WM_DESTROY, OnTerminate)
        MESSAGE_HANDLER(WM_TIMER, OnTimer)
        MESSAGE_HANDLER(WM_MEDIAEVENT, OnMediaEvent)
        MESSAGE_HANDLER(WM_DISPLAYCHANGE, OnDisplayChange)
        MESSAGE_HANDLER(WM_POWERBROADCAST, OnPower)
        MESSAGE_HANDLER(WM_DEVICECHANGE, OnPNP)
        MESSAGE_HANDLER(WM_SETCURSOR, OnSetCursor)

        // undone: decide if we also need to do something with the following:
        // WM_ENDSESSION
        // WM_QUERYENDSESSION
        // WM_QUERYPOWERBROADCAST
        // WM_DEVMODECHANGE

#if 0
        MESSAGE_HANDLER(WM_NCHITTEST, )
        MESSAGE_HANDLER(WM_NCLBUTTONDOWN, )
#endif

        MESSAGE_HANDLER(WM_KEYDOWN, OnKeyDown)
        MESSAGE_HANDLER(WM_KEYUP, OnKeyUp)
        MESSAGE_HANDLER(WM_CHAR, OnChar)
#if 0 // undone:
        MESSAGE_HANDLER(WM_SYSKEYDOWN, OnSysKeyDown)
        MESSAGE_HANDLER(WM_SYSKEYUP, OnSysKeyUp)
#endif

// Stock Events
        MESSAGE_HANDLER(WM_CANCELMODE, OnCancelMode)
        MESSAGE_HANDLER(WM_MOUSEACTIVATE, OnMouseActivate)
        MESSAGE_HANDLER(WM_MOUSEMOVE, OnMouseMove)

        MESSAGE_HANDLER(WM_LBUTTONDOWN, OnLButtonDown)
        MESSAGE_HANDLER(WM_LBUTTONUP, OnLButtonUp)
        MESSAGE_HANDLER(WM_LBUTTONDBLCLK, OnLButtonDblClk)

        MESSAGE_HANDLER(WM_MBUTTONDOWN, OnMButtonDown)
        MESSAGE_HANDLER(WM_MBUTTONUP, OnMButtonUp)
        MESSAGE_HANDLER(WM_MBUTTONDBLCLK, OnMButtonDblClk)
        MESSAGE_HANDLER(WM_RBUTTONDOWN, OnRButtonDown)
        MESSAGE_HANDLER(WM_RBUTTONUP, OnRButtonUp)
        MESSAGE_HANDLER(WM_RBUTTONDBLCLK, OnRButtonDblClk)
        MESSAGE_HANDLER(WM_XBUTTONDOWN, OnXButtonDown)
        MESSAGE_HANDLER(WM_XBUTTONUP, OnXButtonUp)
        MESSAGE_HANDLER(WM_XBUTTONDBLCLK, OnXButtonDblClk)
#if 0 // undone:
        MESSAGE_HANDLER(WM_MOUSEWHEEL, OnMouseWheel)
#endif
// also xbutton and wheel

        //       async: update MESSAGE_HANDLER(Register message, OnSurfaceStateChanged)
        CHAIN_MSG_MAP(CComControl<CVidCtl>)
        DEFAULT_REFLECTION_HANDLER()
END_MSG_MAP()
        int m_TimerID;
        bool m_fTimerOn;
        int m_WindowSynchTime;
        bool m_fNotificationSet;

		USHORT GetShiftState() {
			BOOL bShift = (GetKeyState(VK_SHIFT) < 0);
			BOOL bCtrl  = (GetKeyState(VK_CONTROL) < 0);
			BOOL bAlt   = (GetKeyState(VK_MENU) < 0);

			return (short)(bShift + (bCtrl << 1) + (bAlt << 2));
		}


// ISupportsErrorInfo
        STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);


// IViewObjectEx
        DECLARE_VIEW_STATUS(VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE)

// Helpers
public:
// IMSVidCtl
public:
    MSVidCtlStateList m_State;
    DSGraph m_pGraph;
    PQCreateDevEnum m_pSystemEnum;
    PQFilterMapper m_pFilterMapper;

    // available collections
    VWInputDevices m_pInputs;
	PQGraphSegmentUserInput m_pInputNotify;
    VWOutputDevices m_pOutputs;
    VWFeatures m_pFeatures;
    VWVideoRendererDevices m_pVRs;  // video renderers
    VWAudioRendererDevices m_pARs;  // audio renderers

    // chosen devices&features
    PQInputDevice m_pInput;
    VWOutputDevices m_pOutputsInUse;
    PQVRGraphSegment m_pVideoRenderer;
    PQAudioRenderer m_pAudioRenderer;
    VWFeatures m_pFeaturesInUse;

    // Composition Segments
    VWSegmentList m_pComposites;
    int m_iCompose_Input_Video;
    int m_iCompose_Input_Audio;
    // undone: vector of these for features and outputs

    // REV2: ultimately we probably want streams to be a core dshow facility
    // but for now they're a list of xbar input/output point pairs just like in
    // win98 gold.
    VWStreamList m_Streams;

    // stock properties
    OLE_COLOR m_clrBackColor;
    BOOL m_bEnabled;
    BOOL m_bTabStop;
    BOOL m_bValid;

    STDMETHOD(get_State)(MSVidCtlStateList *lState);
    OLE_COLOR m_clrColorKey;
    DisplaySizeList m_dslDisplaySize;
    VARIANT_BOOL m_fMaintainAspectRatio;

    GUID2 m_InputsCatGuid;
    GUID2 m_CurViewCatGuid;
    CComVariant m_CurView;
    
    // Event handler
    HRESULT OnPreEventNotify(LONG lEvent, LONG_PTR LParam1, LONG_PTR LParam2);
    HRESULT OnPostEventNotify(LONG lEvent, LONG_PTR LParam1, LONG_PTR LParam2);

protected:
    bool m_fInit;
    bool m_fGraphDirty;
    void Init(void);
    bool m_audioSetNull;
    bool m_videoSetNull;
    CComPtr<IUnknown> punkCert;
    HRESULT GetInputs(const GUID2& CategoryGuid, VWInputDevices& pInputs);
    HRESULT GetOutputs(const GUID2& CategoryGuid);
    HRESULT GetVideoRenderers(void);
    HRESULT GetAudioRenderers(void);
    HRESULT GetFeatures(void);
    HRESULT SelectView(VARIANT *pv, bool fNext);
    HRESULT SelectViewFromSegmentList(CComVariant &v, VWInputDevices& list, PQInputDevice& m_pInput);
    HRESULT LoadDefaultVR(void);
    HRESULT LoadDefaultAR(void);
    HRESULT Compose(VWGraphSegment &Up, VWGraphSegment &Down, int &NewIdx);
    HRESULT BuildGraph(void);
    HRESULT RunGraph(void);
    HRESULT DecomposeSegment(VWGraphSegment& pSegment);
    HRESULT DecomposeAll();
    HRESULT RouteStreams(void);
    void SetMediaEventNotification();


protected:

	HRESULT SetControlCapture(bool bCapture) {
		if (m_bInPlaceActive && (m_bUIActive || m_bPendingUIActivation)) {
			if (!m_bWndLess) {
				if (bCapture) {
					if (m_hWnd) {
						HWND h;
						h = ::SetCapture(m_hWnd);
						return (h = m_hWnd) ? NOERROR : E_FAIL;
					}
				} else {
					BOOL rc = ::ReleaseCapture();
					if (!rc) {
						return HRESULT_FROM_WIN32(::GetLastError());
					}
				}
			} else {
				return m_spInPlaceSite->SetFocus(bCapture);
			}
		}
		return NOERROR;
	}

  bool CheckSurfaceStateChanged(CScalingRect& pos) {
       TRACELSM(TRACE_PAINT, (dbgDump << "CVidctrl::CheckSurfaceStateChanged() pos = " << pos), "");
        m_CurrentSurface = pos;
        ValidateSurfaceState();
        return RefreshVRSurfaceState();
    }

    void CheckTopWin() {
        if (m_pTopWin) {
            return;
        }
        m_pTopWin = new CTopWin(this);
        m_pTopWin->Init();
    }

    UINT SetTimer() {
        if (!m_fTimerOn) {
            CheckTopWin();  
            m_fTimerOn = true;
            return m_pTopWin->SetTimer(m_TimerID, m_WindowSynchTime);
        }
        return 0;
    }

    void KillTimer() {
        if (m_pTopWin) {
            if (m_fTimerOn) {
                m_pTopWin->KillTimer(42);
            }
        } else if (m_fTimerOn) {
            CComControl<CVidCtl>::KillTimer(42);
        }
    }


    bool RefreshVRSurfaceState();

    void SetExtents() {
		TRACELM(TRACE_PAINT, "CVidCtl::SetExtents()");
        CSize prevNat(m_sizeNatural), prevSize(m_sizeExtent);
        CSize newsize(0, 0);
        if (m_pVideoRenderer) {
            CRect r;
            HRESULT hr = m_pVideoRenderer->get_Source(r);
            if (FAILED(hr)) {
                GetSourceSize(m_sizeNatural);
            } else {
                m_sizeNatural.cx = r.Width();
                m_sizeNatural.cy = r.Height();
            }
        } 
        if (m_bAutoSize) {
            ComputeDisplaySize();
            if (prevNat != m_sizeNatural || 
                prevSize != m_sizeExtent) {
                FireOnSizeChange();
            }
        }
    }

    void FireOnSizeChange() {
		TRACELM(TRACE_PAINT, "CVidCtl::FireOnSizeChange()");
        if (m_CurrentSurface != m_rcPos) {
            if (m_pTopWin) {
			    TRACELM(TRACE_PAINT, "CVidCtl::FireOnSizeChange() firing");
                m_pTopWin->PostMessage(WM_USER + CTopWin::WMUSER_SITE_RECT_WRONG, 0, 0);
            }
        }
    }

    void OnSizeChange() {
        // if we've already negotiated a site then 
        // notify our container that our rect size has changed
        // this can be because the source changed(such as broadcast show boundary)
        CScalingRect r(m_rcPos);
        CSize s;
        AtlHiMetricToPixel(&m_sizeExtent, &s);
        TRACELSM(TRACE_DETAIL, (dbgDump << "CVidctrl::OnSizeChange() new sz = " << s), "" );
        r.top = m_rcPos.top;
        r.left = m_rcPos.left;
        r.right = m_rcPos.left + s.cx;
        r.bottom = m_rcPos.top + s.cy;
        if (m_spInPlaceSite && r != m_rcPos && m_bAutoSize) {
            TRACELSM(TRACE_DETAIL, (dbgDump << "CVidctrl::OnSizeChange() changing to " << r << " from  " << m_rcPos), "" );
            HRESULT hr = m_spInPlaceSite->OnPosRectChange(r);
            if (FAILED(hr)) {
                TRACELSM(TRACE_DETAIL, (dbgDump << "CVidctrl::OnSizeChange() site notify failed.  hr = " << hexdump(hr)), "" );
                return;
            }
        }
        return;
    }

    AspectRatio SourceAspect() {
        AspectRatio ar(4, 3);
        if (m_pGraph) {
            if (m_pVideoRenderer) {
                CSize p, a;
                HRESULT hr = m_pVideoRenderer->get_NativeSize(&p, &a);
                if (SUCCEEDED(hr))  {
                    TRACELSM(TRACE_DETAIL, (dbgDump << "CVidctrl::SourceAspect() ar = " << a), "");
                    if (a.cx && a.cy) {
                        ar = a;
                    }
                }
            }
        }
        return ar;  // default
    }

    void GetSourceSize(SIZE& s) {
        CSize a;
		if (m_pVideoRenderer) {
			HRESULT hr = m_pVideoRenderer->get_NativeSize(&s, &a);
			if (FAILED(hr) || !s.cx || !s.cy) {
				s.cx = DEFAULT_SIZE_X;
				s.cy = DEFAULT_SIZE_Y;
			}
		} else {
			s.cx = DEFAULT_SIZE_X;
			s.cy = DEFAULT_SIZE_Y;
		}
        TRACELSM(TRACE_PAINT, (dbgDump << "CVidCtl::GetSourceSize() sz = " << s), "");
    }


    bool ValidateSurfaceState() {
#if 0
        TRACELSM(TRACE_PAINT, (dbgDump << "CVidCtl::ValidateSurfaceState() m_bAutoSize = " << m_bAutoSize << " fMaintain " << m_fMaintainAspectRatio << " cursurf " << m_CurrentSurface << " objrct = " << m_rcPos), "");
        if (m_fMaintainAspectRatio) {
            AspectRatio src;
            src = SourceAspect();
            AspectRatio surf;
            surf = m_CurrentSurface.Aspect();
            if (!!surf && !!src && surf != src) {
                TRACELM(TRACE_PAINT, "CVidctrl::ValidateSurfaceState() aspect wrong");
                if (m_CurrentSurface.Round(src)) {
                    ASSERT(src == m_CurrentSurface.Aspect());
                } else {
                    // aspect ratios don't match and Round didn't fix it.
                    _ASSERT(false);
                }

            }
        }
#endif
        return true;
    }

    void ComputeDisplaySize() {
        CSize s;
        TRACELSM(TRACE_PAINT, (dbgDump << "CVidCtl::ComputeDisplaySize() dsl = " << m_dslDisplaySize), "");
        switch (m_dslDisplaySize) {
        case dslSourceSize:
            GetSourceSize(s);
            break;
        case dslHalfSourceSize:
            GetSourceSize(s);
            s.cx >>= 1;
            s.cy >>= 1;
            break;
        case dslDoubleSourceSize:
            GetSourceSize(s);
            s.cx <<= 1;
            s.cy <<= 1;
            break;
        case dslFullScreen: {
            CRect rcdesk;
            ::GetWindowRect(::GetDesktopWindow(), &rcdesk);
            s.cx = rcdesk.Width();
            s.cy = rcdesk.Height();
            break;
        }
        case dslHalfScreen: {
            CScalingRect rcdesk;
            rcdesk.Owner(::GetDesktopWindow());
            ::GetWindowRect(rcdesk.Owner(), &rcdesk);
            rcdesk.Owner(m_CurrentSurface.Owner());
            s.cx = rcdesk.Width() * 3 / 4;
            s.cy = rcdesk.Height() * 3 / 4;
            break;
        }
        case dslQuarterScreen: {
            CScalingRect rcdesk;
            rcdesk.Owner(::GetDesktopWindow());
            ::GetWindowRect(rcdesk.Owner(), &rcdesk);
            rcdesk.Owner(m_CurrentSurface.Owner());
            s.cx = rcdesk.Width() / 2;
            s.cy = rcdesk.Height() / 2;
            break;
        }
        case dslSixteenthScreen: {
            CScalingRect rcdesk;
            rcdesk.Owner(::GetDesktopWindow());
            ::GetWindowRect(rcdesk.Owner(), &rcdesk);
            rcdesk.Owner(m_CurrentSurface.Owner());
            s.cx = rcdesk.Width() / 4;
            s.cy = rcdesk.Height() / 4;
            break;
        }}
        TRACELSM(TRACE_DETAIL, (dbgDump << "CVidctrl::ComputeDisplaySize() sz = " << s), "");
        AtlPixelToHiMetric(&s, &m_sizeExtent);
        OnSizeChange();
    }
#if 0
    CString GetMonitorName(HMONITOR hm);
    bool WindowHasHWOverlay(HWND hWnd);
    bool MonitorHasHWOverlay(HMONITOR hm);
    HRESULT GetCapsForMonitor(HMONITOR hm, LPDDCAPS pDDCaps);
    HRESULT GetDDrawNameForMonitor(HMONITOR hm, VMRGUID& guid);
#endif

public:

        STDMETHOD(SetObjectRects)(LPCRECT prcPos,LPCRECT prcClip) {
            TRACELSM(TRACE_DETAIL, (dbgDump << "CVidCtl::SetObjectRects() pos = " << *prcPos << " clip = " << *prcClip), "");
            if (prcPos == NULL || prcClip == NULL)
    		    return E_POINTER;
            bool bRectChange = !::EqualRect(prcPos, &m_rcPos);
            TRACELSM(TRACE_DETAIL, (dbgDump << "CVidCtl::SetObjectRects() bRectChange = " << bRectChange), "");
            HRESULT hr = IOleInPlaceObjectWindowlessImpl<CVidCtl>::SetObjectRects(prcPos, prcClip);
            if (FAILED(hr)) {
                return hr;
            }
            if (bRectChange) {
                FireViewChange();
            }
            return NOERROR;
        }

        HRESULT OnPostVerbShow() {
            SetTimer();
            m_CurrentSurface.Visible(true);
            RefreshVRSurfaceState();
            TRACELSM(TRACE_DETAIL, (dbgDump << "CVidctrl::OnPostVerbShow() visible = " << m_CurrentSurface.IsVisible() << " rect = " << CRect(m_CurrentSurface)), "" );
            return NOERROR;
        }

        HRESULT OnPostVerbUIActivate() {
            TRACELSM(TRACE_DETAIL, (dbgDump << "CVidctrl::OnPostVerbUIActivate() visible = " << m_CurrentSurface.IsVisible()), "" );
			return OnPostVerbInPlaceActivate();
        }

        HRESULT OnPostVerbInPlaceActivate() {
            TRACELSM(TRACE_DETAIL, (dbgDump << "CVidctrl::OnPostVerbInPlaceActivate() visible = " << m_CurrentSurface.IsVisible()), "" );
			HRESULT hr = OnPostVerbShow();
			if (FAILED(hr)) {
				return hr;
			}
			if (m_bWndLess) {
				m_CurrentSurface.Site(PQSiteWindowless(m_spInPlaceSite));
			} else {
				m_CurrentSurface.Owner(m_hWnd);
			}
            RefreshVRSurfaceState();
            return NOERROR;
        }

        HRESULT OnPreVerbHide() {
            TRACELSM(TRACE_DETAIL, (dbgDump << "CVidctrl::OnPreVerbHide() visible = " << m_CurrentSurface.IsVisible()), "" );
			HRESULT hr = OnInPlaceDeactivate();
            m_CurrentSurface.Visible(false);
            KillTimer();
            RefreshVRSurfaceState();
            return hr;
        }
		HRESULT OnInPlaceDeactivate() {
            TRACELM(TRACE_DETAIL, "CVidctrl::OnInPlaceDeactivate()");
            HRESULT hr = OnUIDeactivate();
            if((long)m_State > 0){
                Stop();
            }
			m_CurrentSurface.Owner(INVALID_HWND);
            RefreshVRSurfaceState();
			return hr;
		}

        HRESULT OnUIDeactivate() {
            SetControlCapture(false);
            m_bPendingUIActivation = false;
            return NOERROR;
        }

		HRESULT InPlaceActivate(LONG iVerb, const RECT* prcPosRect = NULL) {
            TRACELSM(TRACE_DETAIL, (dbgDump << "CVidctrl::InPlaceActivate() iverb = " << iVerb), "");
			HRESULT hr = CComControlBase::InPlaceActivate(iVerb, prcPosRect);
			if (SUCCEEDED(hr)) {
				if (DoesVerbUIActivate(iVerb)) {
					hr = OnPostVerbUIActivate();				
				} else {
					hr = OnPostVerbInPlaceActivate();
					if (FAILED(hr)) {
						return hr;
					}
				}	
			}
			return hr;
		}

#if 0
		STDMETHOD(DoVerb)(LONG iVerb, LPMSG pMsg, IOleClientSite *pActiveSite, LONG lIndex, HWND hParent, const RECT* prcPosRect) {
            TRACELSM(TRACE_DETAIL, (dbgDump << "CVidctrl::DoVerb() iverb = " << iVerb), "");
            HRESULT hr = IOleObjectImpl<CVidCtl>::DoVerb(iVerb, pMsg, pActiveSite, lIndex, hParent, prcPosRect);
			return hr;
		}
#endif

		void DoSetCursor() {
			if (!m_hCursor) {
			   // Create a default arrow cursor
				m_hCursor = (HCURSOR) LoadImage((HINSTANCE) NULL,
										  MAKEINTRESOURCE(OCR_ARROW_DEFAULT_SYSCUR),
										  IMAGE_CURSOR,0,0,0);

			}
			::SetCursor(m_hCursor);
		}
		LRESULT CheckMouseCursor(BOOL& bHandled) {
            try{
                // we can be running but not inplaceactive yet if we got started from a pluggable protocol
                if (m_pGraph && m_pGraph.IsPlaying() && m_pVideoRenderer && m_bInPlaceActive) {
                    CComQIPtr<IMSVidVideoRenderer2> sp_VidVid(m_pVideoRenderer);
                    if(sp_VidVid){
                        VARIANT_BOOL effects;
                        HRESULT hr = sp_VidVid->get_SuppressEffects(&effects);
                        if(SUCCEEDED(hr) && effects == VARIANT_TRUE){
                            DoSetCursor(); // note: we do this regardless of overlay status
                        }
                    }
                    return 0;
                }
                bHandled = FALSE;
                
                return 0;
            }
            catch(...){
                return E_UNEXPECTED;
            }
		}


#if 0
        // IOleObject::SetExtent
        STDMETHOD(SetExtent) {

        }
#endif
	STDMETHOD(InPlaceDeactivate)(void) {
		try {
			OnInPlaceDeactivate();
			return IOleInPlaceObjectWindowlessImpl<CVidCtl>::InPlaceDeactivate();
		} catch(...) {
			return E_UNEXPECTED;
		}
	}
    STDMETHOD(UIDeactivate)(void) {
		try {
			OnUIDeactivate();
			return IOleInPlaceObjectWindowlessImpl<CVidCtl>::UIDeactivate();
		} catch(...) {
			return E_UNEXPECTED;
		}
	}

    STDMETHOD(GetActivationPolicy)(DWORD* pdwPolicy) { 
		if (!pdwPolicy) {
			return E_POINTER;
		}
		try {
			*pdwPolicy = 0; 
			return NOERROR; 
		} catch(...) {
			return E_UNEXPECTED;
		}

	}
	// undone: do we need to process inactivemousemove?
	STDMETHOD(OnInactiveSetCursor)(LPCRECT pRectBounds, long x, long y, DWORD dwMouseMsg, BOOL fSetAlways)
	{
		try {
			if (fSetAlways) {
				DoSetCursor();
			} else {
				int temp;
				CheckMouseCursor(temp);
			}
			return NOERROR;
		} catch(...) {
			return E_UNEXPECTED;
		}
	}

    // IMSVidCtl
    STDMETHOD(put_ColorKey)(OLE_COLOR clr) {
        m_clrColorKey = clr;
		if (m_pVideoRenderer) {
			return m_pVideoRenderer->put_ColorKey(clr);
		}
        return NOERROR;
    }
    STDMETHOD(get_ColorKey)(OLE_COLOR* pclr) {
        try {
            if (!pclr) {
                return E_POINTER;
            }
            *pclr = m_clrColorKey;
            return NOERROR;
        } catch(...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_DisplaySize)(DisplaySizeList dslNewSize) {
        if (dslNewSize != m_dslDisplaySize) {
            m_dslDisplaySize = dslNewSize;
            if (m_bAutoSize) {
                ComputeDisplaySize();
            }
        }
        return NOERROR;
    }
    STDMETHOD(get_DisplaySize)(DisplaySizeList* pdsl) {
        try {
            if (!pdsl) {
                return E_POINTER;
            }
            *pdsl = m_dslDisplaySize;
            return NOERROR;
		} catch(...) {
			return E_POINTER;
		}
    }
    STDMETHOD(put_MaintainAspectRatio)(VARIANT_BOOL fNewSize) {
        m_fMaintainAspectRatio = fNewSize;
        return NOERROR;
    }
    STDMETHOD(get_MaintainAspectRatio)(VARIANT_BOOL* pf) {
        try {
            if (!pf) {
                return E_POINTER;
            }
            *pf = m_fMaintainAspectRatio;
            return NOERROR;
        } catch(...) {
            return E_POINTER;
        }
    }
    STDMETHOD(Refresh)();
    STDMETHOD(get_InputsAvailable)(BSTR CategoryGuid, IMSVidInputDevices * * pVal);
    STDMETHOD(get_OutputsAvailable)(BSTR CategoryGuid, IMSVidOutputDevices * * pVal);
    STDMETHOD(get__InputsAvailable)(LPCGUID CategoryGuid, IMSVidInputDevices * * pVal);
    STDMETHOD(get__OutputsAvailable)(LPCGUID CategoryGuid, IMSVidOutputDevices * * pVal);
    STDMETHOD(get_VideoRenderersAvailable)(IMSVidVideoRendererDevices * * pVal);
    STDMETHOD(get_AudioRenderersAvailable)(IMSVidAudioRendererDevices * * pVal);
    STDMETHOD(get_FeaturesAvailable)(IMSVidFeatures * * pVal);
    STDMETHOD(SetClientSite)(IOleClientSite *pClientSite);
    //STDMETHOD(DoVerb)(LONG iVerb, LPMSG pMsg, IOleClientSite* pActiveSite, LONG linddex,
    //    HWND hwndParent, LPCRECT lprcPosRect);
    STDMETHOD(get_InputActive)(IMSVidInputDevice * * pVal) {
        try {
            return m_pInput.CopyTo(pVal);
        } catch(...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_InputActive)(IMSVidInputDevice * pVal) {
        if (pVal == NULL) {
            Decompose();
            if(m_pInput){
                PQGraphSegment(m_pInput)->put_Container(NULL);
                m_pInput.Release();
            }
        } else {
            try {
                if (m_pInput) {
                    Decompose();
                    PQGraphSegment(m_pInput)->put_Container(NULL);
                }
                m_pInput = pVal;
				m_pInputNotify = pVal;  // if input device wants keyboard/mouse stuff(currently dvd only)
                m_fGraphDirty = true;
            } catch(...) {
                return E_POINTER;
            }
        }
        return NOERROR;
    }
    STDMETHOD(get_OutputsActive)(IMSVidOutputDevices * * pVal)
    {
        try {
            return m_pOutputsInUse.CopyTo(pVal);
        } catch(...) {
            return E_POINTER;
        }
        return NOERROR;
    }
    STDMETHOD(put_OutputsActive)(IMSVidOutputDevices * pVal)
    {
        if (pVal == NULL) {
            Decompose();
            m_pOutputsInUse.Release();
        } else {
            try {
                if (m_pOutputsInUse) {
                    Decompose();
                }
                m_pOutputsInUse = pVal;
                m_fGraphDirty = true;
            } catch(...) {
                return E_POINTER;
            }
        }
        return NOERROR;
    }
    STDMETHOD(get_VideoRendererActive)(IMSVidVideoRenderer * * pVal)
    {
        try {
            PQVideoRenderer vr(m_pVideoRenderer);
            *pVal = vr.Detach();
            return NOERROR;
        } catch(...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_VideoRendererActive)(IMSVidVideoRenderer * pVal)
    {
        try {
            if (pVal == NULL) {
                m_videoSetNull = true;
                Decompose();
                m_pVideoRenderer.Release();
            } else {
                if (m_pVideoRenderer) {
                    Decompose();
                }
                m_pVideoRenderer = pVal;
            }
            m_fGraphDirty = true;
        } catch(...) {
            return E_POINTER;
        }
        return NOERROR;
    }
    STDMETHOD(get_AudioRendererActive)(IMSVidAudioRenderer * * pVal)
    {
        try {
            return m_pAudioRenderer.CopyTo(pVal);
        } catch(...) {
            return E_POINTER;
        }
        return NOERROR;
    }
    STDMETHOD(put_AudioRendererActive)(IMSVidAudioRenderer * pVal)
    {
        try {
            if (pVal == NULL) {
                m_audioSetNull = true;
                Decompose();
                m_pAudioRenderer.Release();
            } else {
                if (m_pAudioRenderer) {
                    Decompose();
                }
                m_pAudioRenderer = pVal;
            }
            m_fGraphDirty = true;
        } catch(...) {
            return E_POINTER;
        }
        return NOERROR;
    }
    STDMETHOD(get_FeaturesActive)(IMSVidFeatures * * pVal)
    {
        try {
            return m_pFeaturesInUse.CopyTo(pVal);
        } catch(...) {
            return E_POINTER;
        }
                return NOERROR;
        }
    STDMETHOD(put_FeaturesActive)(IMSVidFeatures * pVal){
        VIDPERF_FUNC;
        try {
            // Release the old list of active features
            if (m_pFeaturesInUse) {
                Decompose();
            }
            for (VWFeatures::iterator i = m_pFeaturesInUse.begin(); i != m_pFeaturesInUse.end(); ++i) {
                if ((*i).punkVal) {
                    PQGraphSegment((*i).punkVal)->put_Container(NULL);
                }
            }
    	    m_pFeaturesInUse = pVal;
            m_fGraphDirty = true;
        } catch(...) {
            return E_POINTER;
        }
        return NOERROR;
    }

    STDMETHOD(View)(VARIANT* pItem) {
        VIDPERF_FUNC;
        try {
            return SelectView(pItem, false);
		} catch(ComException &e) {
			return e;
		} catch(...) {
			return E_UNEXPECTED;
		}
    }

    STDMETHOD(ViewNext)(VARIANT* pItem) {
        VIDPERF_FUNC;
        try {
            return SelectView(pItem, true);
		} catch(ComException &e) {
			return e;
		} catch(...) {
			return E_UNEXPECTED;
		}
    }

    STDMETHOD(Build)(void) {
        VIDPERF_FUNC;
        try {
            return BuildGraph();
        } catch(ComException &e) {
            return e;
        } catch(...) {
            return E_UNEXPECTED;
        }
    }
        STDMETHOD(Pause)(void);
    STDMETHOD(Run)(void) {
        VIDPERF_FUNC;
        try {
            return RunGraph();
        } catch(ComException &e) {
            return e;
        } catch(...) {
            return E_UNEXPECTED;
        }
    }
    STDMETHOD(Stop)(void);
    STDMETHOD(Decompose)() {
        VIDPERF_FUNC;
        try {
            return DecomposeAll();
        } catch(ComException &e) {
            return e;
        } catch(...) {
            return E_UNEXPECTED;
        }
    }
// ISegmentContainer
    STDMETHOD(get_Graph)(IGraphBuilder **ppGraph) {
        try {
            return m_pGraph.CopyTo(ppGraph);
        } catch(...) {
            return E_POINTER;
        }
    }
    STDMETHOD(get_Input)(IMSVidGraphSegment **ppInput) {
        try {
            return PQGraphSegment(m_pInput).CopyTo(ppInput);
        } catch(...) {
            return E_POINTER;
        }
    }
    STDMETHOD(get_Outputs)(IEnumMSVidGraphSegment **ppOutputs) {
                PQEnumSegment temp;
                try {
                        temp = new CSegEnum(static_cast<COutputDevices *>(m_pOutputs.p)->m_Devices);
                } catch(...) {
                        return E_OUTOFMEMORY;
                }
                try {
                        *ppOutputs = temp.Detach();
                } catch(...) {
                        return E_POINTER;
                }
                return NOERROR;
    }
    STDMETHOD(get_VideoRenderer)(IMSVidGraphSegment **ppVR) {
        try {
            return PQGraphSegment(m_pVideoRenderer).CopyTo(ppVR);
        } catch(...) {
            return E_POINTER;
        }
    }
    STDMETHOD(get_AudioRenderer)(IMSVidGraphSegment **ppAR) {
        try {
            return PQGraphSegment(m_pAudioRenderer).CopyTo(ppAR);
        } catch(...) {
            return E_POINTER;
        }
    }
    STDMETHOD(get_Features)(IEnumMSVidGraphSegment **ppFeatures) {
                PQEnumSegment temp;
                try {
                        temp = new CSegEnum(static_cast<CFeatures *>(m_pFeatures.p)->m_Devices);
                } catch(...) {
                        return E_OUTOFMEMORY;
                }
                try {
                        *ppFeatures = temp.Detach();
                } catch(...) {
                        return E_POINTER;
                }
                return NOERROR;
    }
    STDMETHOD(get_Composites)(IEnumMSVidGraphSegment **ppComposites) {
                PQEnumSegment temp;
                try {
                        temp = new CSegEnum(m_pComposites);
                } catch(...) {
                        return E_OUTOFMEMORY;
                }
                try {
                        *ppComposites = temp.Detach();
                } catch(...) {
                        return E_POINTER;
                }
                return NOERROR;
    }
    STDMETHOD(get_ParentContainer)(IUnknown **ppUnk) {
        try {
			if (ppUnk) {
				return E_POINTER;
			}
			if (!m_spClientSite) {
				return E_NOINTERFACE;
			}
			m_spClientSite.CopyTo(ppUnk);
            return NOERROR;
        } catch(ComException &e) {
            return e;
        } catch(...) {
            return E_UNEXPECTED;
        }
    }
    STDMETHOD(Decompose)(IMSVidGraphSegment *pSegment) {
        try {
            return DecomposeSegment(VWGraphSegment(pSegment));
        } catch(ComException &e) {
            return e;
        } catch(...) {
            return E_UNEXPECTED;
        }
    }

    STDMETHOD(DisableVideo)() {
        return put_VideoRendererActive(NULL);
    }
    STDMETHOD(DisableAudio)() {
        return put_AudioRendererActive(NULL);
    }
    STDMETHOD(IsWindowless)() {
        return m_bWndLess ? NOERROR : S_FALSE;
    }
    STDMETHOD(GetFocus)() {
		try {
			if (!SetControlFocus(TRUE)) {
				return E_FAIL;
			}
			return NOERROR;
        } catch(...) {
            return E_UNEXPECTED;
        }
    }
    STDMETHOD(QueryService)(REFIID service, REFIID iface, LPVOID* ppv);
	STDMETHOD(put_ServiceProvider)(/*[in]*/ IUnknown * pServiceP);

};

#endif //__VidCtl_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\vidprot.cpp ===
//==========================================================================;
//
// Copyright (c) Microsoft Corporation 1998-2000.
//
//--------------------------------------------------------------------------;
//
// vidprot.cpp : Implementation of CTVProt
//

#include "stdafx.h"

#ifndef TUNING_MODEL_ONLY

#include <string.h>
#include <shlwapi.h>
#include "vidprot.h"
#include "devices.h"

DEFINE_EXTERN_OBJECT_ENTRY(__uuidof(CTVProt), CTVProt)
DEFINE_EXTERN_OBJECT_ENTRY(__uuidof(CDVDProt), CDVDProt)

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CTVProt
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CTVProt -- IInternetProtocolRoot
STDMETHODIMP CTVProt::Start(LPCWSTR szUrl,
				IInternetProtocolSink* pOIProtSink,
				IInternetBindInfo* pOIBindInfo,
				DWORD grfPI,
				HANDLE_PTR /* dwReserved */)
{
    TRACELM(TRACE_DEBUG, "CTVProt::Start()");
    if (!pOIProtSink)
    {
        TRACELM(TRACE_DEBUG, "CTVProt::Start() IInternetProctocolSink * == NULL");
	    return E_POINTER;
    }
    m_pSink.Release();
    m_pSink = pOIProtSink;
    m_pSink->ReportData(BSCF_FIRSTDATANOTIFICATION, 0, 0);
#if 0
	// this bug is fixed in ie 5.5+ on whistler.  if you want to run on earlier versions of ie such as 2k gold then you need this.
	m_pSink->ReportProgress(BINDSTATUS_CONNECTING, NULL);  // put binding in downloading state so it doesn't ignore our IUnknown*
#endif

	if (!pOIBindInfo) {
		m_pSink->ReportResult(E_NOINTERFACE, 0, 0);
		return E_NOINTERFACE;
	}
    // don't run unless we're being invoked from a safe site
    HRESULT hr = IsSafeSite(m_pSink);
    if (FAILED(hr)) {
	    m_pSink->ReportResult(hr, 0, 0);
		return hr;
    }
	ULONG count;
	LPOLESTR pb;
	hr = pOIBindInfo->GetBindString(BINDSTRING_FLAG_BIND_TO_OBJECT, &pb, 1, &count);
	if (FAILED(hr)) {
	    m_pSink->ReportResult(hr, 0, 0);
		return hr;
	}
	if (wcscmp(pb, BIND_TO_OBJ_VAL)) {
		// we must be getting a bind to storage so skip the expensive stuff and 
		// wait for the bind to object which is coming next
		m_pSink->ReportData(BSCF_LASTDATANOTIFICATION | 
							BSCF_DATAFULLYAVAILABLE, 0, 0);
		m_pSink->ReportResult(S_OK, 0, 0);
		m_pSink.Release();
		return S_OK;
	}

	// and, in one of the most bizarre maneuvers i've ever seen, rather than casting, 
	// urlmon passes back the ascii value of the ibindctx pointer in the string
	hr = pOIBindInfo->GetBindString(BINDSTRING_PTR_BIND_CONTEXT, &pb, 1, &count);
	if (FAILED(hr)) {
	    m_pSink->ReportResult(hr, 0, 0);
		return hr;
	}
	_ASSERT(count == 1);	
	
	PQBindCtx pbindctx;
#define RADIX_BASE_10 (10)
#ifdef _WIN64
#if 0
	// undone: turn this back on for win64 when _wcstoxi64 get into libc.c, they're in the header
	// but not implemented so this doesn't link
	pbindctx.Attach(reinterpret_cast<IBindCtx*>(_wcstoui64(pb, NULL, RADIX_BASE_10)));	// urlmon already did an addref
#else
	swscanf(pb, L"%I64d", &pbindctx.p);
#endif
#else
	pbindctx.Attach(reinterpret_cast<IBindCtx*>(wcstol(pb, NULL, RADIX_BASE_10)));	// urlmon already did an addref
#endif

	if (!pbindctx) {
		m_pSink->ReportResult(E_NOINTERFACE, 0, 0);
		return E_NOINTERFACE;
	}	

    TRACELM(TRACE_DEBUG, "CTVProt::Start(): creating control object");
	PQVidCtl pCtl;
    hr = GetVidCtl(pCtl);
    if (FAILED(hr)) {
	    m_pSink->ReportResult(hr, 0, 0);
        return hr;
    }

	hr = pbindctx->RegisterObjectParam(OLESTR("IUnknown Pointer"), pCtl);
	if (FAILED(hr)) {
	    m_pSink->ReportResult(hr, 0, 0);
		return hr;
	}
    TRACELSM(TRACE_DEBUG, (dbgDump << "BINDSTATUS_IUNKNOWNAVAILABLE(29), " << KEY_CLSID_VidCtl), "");
    m_pSink->ReportProgress(BINDSTATUS_IUNKNOWNAVAILABLE, NULL);
    m_pSink->ReportData(BSCF_LASTDATANOTIFICATION | 
			            BSCF_DATAFULLYAVAILABLE, 0, 0);
    m_pSink->ReportResult(S_OK, 0, 0);
    m_pSink.Release();
    return S_OK;
}

HRESULT CTVProt::GetCachedVidCtl(PQVidCtl &pCtl, PQWebBrowser2& pW2) {
	// hunt for cached object
	PQServiceProvider pSP(m_pSink);
	if (!pSP) {
        return E_UNEXPECTED;
    }
	HRESULT hr = pSP->QueryService(SID_SWebBrowserApp, IID_IWebBrowser2, (LPVOID *)&pW2);
    if (FAILED(hr)) {
        return hr;
    }
	CComVariant v;
    CComBSTR propname(KEY_CLSID_VidCtl);
    if (!propname) {
        return E_UNEXPECTED;
    }
	hr = pW2->GetProperty(propname, &v);
    if (FAILED(hr)) {
        return hr;
    }
	if (v.vt == VT_UNKNOWN) {
		pCtl = v.punkVal;
	} else if (v.vt == VT_DISPATCH) {
		pCtl = v.pdispVal;
	} else {
		TRACELM(TRACE_ERROR, "CTVProt::GetCachedObject(): non-object cached w/ our key");
        pCtl.Release();
        // don't return error.  we'll ignore this and create a new one
	}
	// undone: look and see if pCtl already has a site.because
	// this means we're seeing the second tv: on this page
	// so just get the current TR/channel from it if necessary (tv: w/ no rhs)
	// and create a new ctl
	return NOERROR;
}
HRESULT CTVProt::GetVidCtl(PQVidCtl &pCtl) {
	PQWebBrowser2 pW2;
    HRESULT hr = GetCachedVidCtl(pCtl, pW2);
    if (FAILED(hr)) {
        return hr;
    }
	if (!pCtl) {
        // undone: long term, we want to move a bunch of this create/setup logic into factoryhelp
        // so we can share more code with the dvd: protocol and the behavior factory
		hr = pCtl.CoCreateInstance(CLSID_MSVidCtl, NULL, CLSCTX_INPROC_SERVER);
		if (FAILED(hr)) {
			return hr;
		}
		// cache this ctl for next time
		if (pW2) {
			VARIANT v;
			v.vt = VT_UNKNOWN;
			v.punkVal = pCtl;

            CComBSTR propname(KEY_CLSID_VidCtl);
            if (!propname) {
                return E_UNEXPECTED;
            }
			hr = pW2->PutProperty(propname, v);
			if (FAILED(hr)) {
				TRACELM(TRACE_ERROR, "CTVProt::Start() Can't cache ctl");
                // ignore this error.  it shouldn't ever happen and if it does then it will 
                // just cause a perf degradation.  trace it and move on
			}
		}

		// undone: parse rhs of url and create the right tuning request
        CComVariant pTR(CFactoryHelper::GetDefaultTR());
		if (!pTR) {
			TRACELM(TRACE_ERROR, "CTVProt::Start() Can't find default Tune Request");
			return E_INVALIDARG;
		}
		hr = pCtl->View(&pTR);
		if (FAILED(hr)) {
			TRACELM(TRACE_ERROR, "CTVProt::Start() Can't view default Tune Request");
			return hr;
		}

		// undone: once we know where vidctl will live in the registry then we need to put a flag
		// in the registry just disables including any features in the tv: prot 

		PQFeatures pF;
		hr = pCtl->get_FeaturesAvailable(&pF);
		if (FAILED(hr)) {
			TRACELM(TRACE_ERROR, "CTVProt::Start() Can't get features collection");
			return hr;
		}
		// undone: look up default feature segments for tv: in registry
		// for now we're just going to hard code the ones we want

        CFeatures* pC = static_cast<CFeatures *>(pF.p);
        CFeatures* pNewColl = new CFeatures;
        if (!pNewColl) {
            return E_OUTOFMEMORY;
        }
        for (DeviceCollection::iterator i = pC->m_Devices.begin(); i != pC->m_Devices.end(); ++i) {
            PQFeature f(*i);
            GUID2 clsid;
            hr = f->get__ClassID(&clsid);
            if (FAILED(hr)) {
    			TRACELM(TRACE_ERROR, "CTVProt::GetVidCtl() Can't get feature class id");
                continue;
            }
            if (clsid == CLSID_MSVidClosedCaptioning ||
                clsid == CLSID_MSVidDataServices) {
                pNewColl->m_Devices.push_back(*i);
            }
        }

		hr = pCtl->put_FeaturesActive(pNewColl);
		if (FAILED(hr)) {
			TRACELM(TRACE_ERROR, "CTVProt::Start() Can't put features collection");
			return hr;
		}
	}
	ASSERT(pCtl);
	hr = pCtl->Run(); 
	if (FAILED(hr)) {
		TRACELSM(TRACE_ERROR, (dbgDump << "CTVProt::Start() run failed.  hr = " << hexdump(hr)), "");
		return hr;
	}
    return NOERROR;
}


#endif // TUNING_MODEL_ONLY
// end of file vidprot.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\inc\ddraw\ddheap.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddheap.h
 *  Content:	Heap manager header file
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   03-Feb-98	DrewB   Split from ddrawpr.h for user/kernel portability.
 *
 ***************************************************************************/

#ifndef __DDHEAP_INCLUDED__
#define __DDHEAP_INCLUDED__

#include "dmemmgr.h"

#ifndef VIDMEMONLY

BOOL linVidMemInit( LPVMEMHEAP pvmh, FLATPTR start, FLATPTR end );
void linVidMemFini( LPVMEMHEAP pvmh );
void linVidMemFree( LPVMEMHEAP pvmh, FLATPTR ptr );
FLATPTR linVidMemAlloc( LPVMEMHEAP pvmh, DWORD xsize, DWORD ysize,
                        LPDWORD lpdwSize, LPSURFACEALIGNMENT lpAlignment,
                        LPLONG lpNewPitch );
DWORD linVidMemAmountAllocated( LPVMEMHEAP pvmh );
DWORD linVidMemAmountFree( LPVMEMHEAP pvmh );
DWORD linVidMemLargestFree( LPVMEMHEAP pvmh );
    
BOOL rectVidMemInit( LPVMEMHEAP pvmh, FLATPTR start, DWORD width, DWORD height,
                     DWORD stride );
void rectVidMemFini( LPVMEMHEAP pvmh );
FLATPTR rectVidMemAlloc( LPVMEMHEAP pvmh, DWORD cxThis, DWORD cyThis,
                         LPDWORD lpdwSize, LPSURFACEALIGNMENT lpAlignment );
void rectVidMemFree( LPVMEMHEAP pvmh, FLATPTR ptr );
DWORD rectVidMemAmountAllocated( LPVMEMHEAP pvmh );
DWORD rectVidMemAmountFree( LPVMEMHEAP pvmh );

BOOL IsDifferentPixelFormat( LPDDPIXELFORMAT pdpf1, LPDDPIXELFORMAT pdpf2 );

#define DDHA_SKIPRECTANGULARHEAPS       0x0001
#define DDHA_ALLOWNONLOCALMEMORY        0x0002
#define DDHA_ALLOWNONLOCALTEXTURES      0x0004
#define DDHA_USEALTCAPS                 0x0008

FLATPTR DdHeapAlloc( DWORD dwNumHeaps,
                     LPVIDMEM pvmHeaps,
                     HANDLE hdev,
                     LPVIDMEMINFO lpVidMemInfo,
                     DWORD dwWidth,
                     DWORD dwHeight,
                     LPDDRAWI_DDRAWSURFACE_LCL lpSurfaceLcl,
                     DWORD dwFlags,
                     LPVIDMEM *ppvmHeap,
                     LPLONG plNewPitch,
                     LPDWORD pdwNewCaps,
                     LPDWORD pdwSize);

LPVMEMHEAP WINAPI HeapVidMemInit( LPVIDMEM lpVidMem, DWORD pitch, HANDLE hdev,
                                  LPHEAPALIGNMENT phad);
void WINAPI HeapVidMemFini( LPVIDMEM lpVidMem, HANDLE hdev );
FLATPTR WINAPI HeapVidMemAlloc( LPVIDMEM lpVidMem, DWORD x, DWORD y,
                                HANDLE hdev, LPSURFACEALIGNMENT lpAlignment,
                                LPLONG lpNewPitch, LPDWORD pdwSize );

#endif // VIDMEMONLY

LPVMEMHEAP WINAPI VidMemInit( DWORD flags, FLATPTR start, FLATPTR end_or_width,
                              DWORD height, DWORD pitch );
void WINAPI VidMemFini( LPVMEMHEAP pvmh );
DWORD WINAPI VidMemAmountFree( LPVMEMHEAP pvmh );
DWORD WINAPI VidMemAmountAllocated( LPVMEMHEAP pvmh );
DWORD WINAPI VidMemLargestFree( LPVMEMHEAP pvmh );

#endif // __DDHEAP_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\tuningspacecontainer.h ===
/////////////////////////////////////////////////////////////////////////////////////
// TuningSpaceContainer.h : Declaration of the CSystemTuningSpaces
// Copyright (c) Microsoft Corporation 1999.

#ifndef __TUNINGSPACECONTAINER_H_
#define __TUNINGSPACECONTAINER_H_

#pragma once

#include <regexthread.h>
#include <objectwithsiteimplsec.h>
#include "tuningspacecollectionimpl.h"

namespace BDATuningModel {
	
const int DEFAULT_MAX_COUNT = 32;  // by default only allow 32 tuning spaces in order to prevent
								   // dnos attacks from filling up disk/registry with bogus
								   // tuning space entries.

/////////////////////////////////////////////////////////////////////////////
// CSystemTuningSpaces
class CSystemTuningSpaces : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CSystemTuningSpaces, &CLSID_SystemTuningSpaces>,
	public ISupportErrorInfo,
    public IObjectWithSiteImplSec<CSystemTuningSpaces>,
    public IObjectSafetyImpl<CSystemTuningSpaces, INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA>,
	public TuningSpaceCollectionImpl<CSystemTuningSpaces, ITuningSpaceContainer, &__uuidof(ITuningSpaceContainer), &LIBID_TunerLib> {
public:
    CSystemTuningSpaces() : 
	    m_CurrentAccess(KEY_READ), 
		m_MaxCount(DEFAULT_MAX_COUNT), 
		m_cookieRegExp(0),
        m_pRET(NULL) {
	}
    virtual ~CSystemTuningSpaces() {
	    ATL_LOCK();
		if (m_pRET) {
			HRESULT hr = m_pRET->CallWorker(CRegExThread::RETHREAD_EXIT);
			ASSERT(SUCCEEDED(hr));
			delete m_pRET;
			m_pRET = NULL;
		}
        m_mapTuningSpaces.clear();
        m_mapTuningSpaceNames.clear();
	}

    HRESULT FinalConstruct();
    void FinalRelease();

REGISTER_AUTOMATION_OBJECT_WITH_TM(IDS_REG_TUNEROBJ, 
						   IDS_REG_TUNINGSPACECONTAINER_PROGID, 
						   IDS_REG_TUNINGSPACECONTAINER_DESC,
						   LIBID_TunerLib,
						   CLSID_SystemTuningSpaces, tvBoth);

DECLARE_NOT_AGGREGATABLE(CSystemTuningSpaces)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSystemTuningSpaces)
	COM_INTERFACE_ENTRY(ITuningSpaceContainer)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IObjectWithSite)
	COM_INTERFACE_ENTRY(IObjectSafety)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP_WITH_FTM()

    HRESULT RegisterTuningSpaces(HINSTANCE hInst);

    HRESULT UnregisterTuningSpaces();
    PUnknown m_pSite;

public:

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// ITuningSpaceContainer
	STDMETHOD(get_Item)(/*[in]*/ VARIANT varIndex, /*[out, retval]*/ ITuningSpace **ppTuningSpace);
    STDMETHOD(put_Item)(/*[in]*/VARIANT varIndex, /*[in]*/ITuningSpace *pTuningSpace);
    STDMETHOD(Add)(/*[in]*/ ITuningSpace *pTuningSpace, /*[out]*/ VARIANT* pvarIndex);
    STDMETHOD(Remove)(/*[in]*/ VARIANT varIndex);
    STDMETHOD(TuningSpacesForCLSID)(/*[in]*/ BSTR bstrSpace, /*[out, retval]*/ ITuningSpaces **ppTuningSpaces);
    STDMETHOD(_TuningSpacesForCLSID)(/*[in]*/ REFCLSID clsidSpace, /*[out, retval]*/ ITuningSpaces **ppTuningSpaces);
    STDMETHOD(TuningSpacesForName)(/*[in]*/ BSTR bstrName, /*[out, retval]*/ ITuningSpaces **ppTuningSpaces);
    STDMETHOD(FindID)(/*[in]*/ ITuningSpace* pTS, /*[out, retval]*/ long *pID);
    STDMETHOD(get_MaxCount)(/*[out, retval]*/ LONG *plCount);
    STDMETHOD(put_MaxCount)(LONG lCount);

protected:
    typedef std::map<CComBSTR, ULONG> TuningSpaceNames_t;          // unique name->id mapping

    CComPtr<ICreatePropBagOnRegKey> m_pFactory;
    HANDLE m_hMutex;
    // REV2:  use registry change notification to refresh cache

	ULONG m_MaxCount; // prevent dnos attack from filling registry with bogus tuning spaces
    PQPropertyBag2 m_pTSBag;
    CRegKey m_RootKey;
    REGSAM m_CurrentAccess;

    TuningSpaceNames_t m_mapTuningSpaceNames;

    HRESULT OpenRootKeyAndBag(REGSAM NewAccess);
    HRESULT ChangeAccess(REGSAM DesiredAccess);
    CComBSTR GetUniqueName(ITuningSpace* pTS);
    ULONG GetID(CComBSTR& UniqueName);
    HRESULT DeleteID(ULONG id);
    HRESULT Add(CComBSTR& un, long PreferredID, PQTuningSpace pTS, VARIANT *pvarAssignedID);

    // takes a variant index and returns an iterator to the cache and possibly an interator 
    // to the name cache depending on index type
    // on return if its != end() and itn == end() and name is wanted then look up with overloaded Find
    HRESULT Find(VARIANT varIndex, long& ID, TuningSpaceContainer_t::iterator &its, CComBSTR& UniqueName, TuningSpaceNames_t::iterator &itn);

    // takes a cache iterator and returns a name cache iterator
    HRESULT Find(TuningSpaceContainer_t::iterator &its, CComBSTR& UniqueName, TuningSpaceNames_t::iterator &itn);

	PQGIT m_pGIT;
	DWORD m_cookieRegExp;
	CRegExThread *m_pRET; // shared worker thread
};

/////////////////////////////////////////////////////////////////////////////
// CSystemTuningSpaces
class ATL_NO_VTABLE DECLSPEC_UUID("969EE7DA-7058-4922-BA78-DA3905D0325F") CTuningSpacesBase : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CTuningSpacesBase, &__uuidof(CTuningSpacesBase)>,
	public ISupportErrorInfoImpl<&__uuidof(ITuningSpaces)>,
    public IObjectWithSiteImplSec<CTuningSpacesBase>,
	public TuningSpaceCollectionImpl<CTuningSpacesBase, ITuningSpaces, &IID_ITuningSpaces, &LIBID_TunerLib>,
	public IObjectSafetyImpl<CTuningSpacesBase, INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA>
{
public:
    CTuningSpacesBase() {}

DECLARE_NOT_AGGREGATABLE(CTuningSpacesBase)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CTuningSpacesBase)
	COM_INTERFACE_ENTRY(ITuningSpaces)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY(IObjectWithSite)
END_COM_MAP_WITH_FTM()

};

/////////////////////////////////////////////////////////////////////////////
class CTuningSpaces : public CComObject<CTuningSpacesBase> {
public:
	CTuningSpaces() {}
// we'd like to say:
//	CTuningSpaces(TuningSpaceContainer_t& init) : m_mapTuningSpaces(init.begin(), init.end()) {}
// but a compiler bug is causing it to match this against the explicit map ctor that just takes
// a pred and an allocator.  so, we'll do it the hard way.
	CTuningSpaces(TuningSpaceContainer_t& init) {
		for (TuningSpaceContainer_t::iterator i = init.begin(); i != init.end(); ++i) {
            CComVariant v((*i).second);
			if ((*i).second.vt != VT_UNKNOWN && (*i).second.vt != VT_DISPATCH) {
				THROWCOM(E_UNEXPECTED); //corrupt in-memory collection
			}
			PQTuningSpace pTS((*i).second.punkVal);
            PQTuningSpace newts;
            HRESULT hr = PQTuningSpace(pTS)->Clone(&newts);
            if (FAILED(hr)) {
                THROWCOM(hr);
            }
            m_mapTuningSpaces[(*i).first] = CComVariant(newts);
		}
	}

	STDMETHOD(get_Item)(/*[in]*/ VARIANT varIndex, /*[out, retval]*/ ITuningSpace **ppTuningSpace) {
		try {
			if (!ppTuningSpace) {
				return E_POINTER;
			}
			if (varIndex.vt != VT_UI4) {
                HRESULT hr = ::VariantChangeType(&varIndex, &varIndex, 0, VT_UI4);
				if (FAILED(hr))
				{
					return Error(IDS_E_TYPEMISMATCH, __uuidof(ITuningSpaces), hr);
				}
			}
			ATL_LOCK();
			TuningSpaceContainer_t::iterator its = m_mapTuningSpaces.find(varIndex.ulVal);
			if (its == m_mapTuningSpaces.end()) {
				return Error(IDS_E_NO_TS_MATCH, __uuidof(ITuningSpaces), E_INVALIDARG);
			}
			_ASSERT(((*its).second.vt == VT_UNKNOWN) || ((*its).second.vt == VT_DISPATCH));
			PQTuningSpace pTS((*its).second.punkVal);
			if (!pTS) {
				return Error(IDS_E_NOINTERFACE, __uuidof(ITuningSpaces), E_NOINTERFACE);
			}

			return pTS.CopyTo(ppTuningSpace);
		} catch(...) {
			return E_UNEXPECTED;
		}
	}
};


HRESULT RegisterTuningSpaces(HINSTANCE hInst);

HRESULT UnregisterTuningSpaces();

};


 
#endif //__TUNINGSPACECONTAINER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\vidprot.h ===
// VidProt.h : pluggable protocol for tv:

#pragma once

#ifndef VIDPROT_H
#define VIDPROT_H

#include "factoryhelp.h"

// protocol for TV

/////////////////////////////////////////////////////////////////////////////
// CTVProt
class ATL_NO_VTABLE __declspec(uuid("CBD30858-AF45-11d2-B6D6-00C04FBBDE6E")) CTVProt :
	public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CTVProt, &__uuidof(CTVProt)>,
	public IInternetProtocol {
public:

CTVProt()
{
}

~CTVProt()
{
}

REGISTER_PROTOCOL(IDS_PROJNAME, 
				  IDS_REG_TVPROTOCOL_DESC,
				  LIBID_MSVidCtlLib,
				  __uuidof(CTVProt),
				  TVPROT_SCHEME_NAME);

DECLARE_PROTECT_FINAL_CONSTRUCT()
BEGIN_COM_MAP(CTVProt)
    COM_INTERFACE_ENTRY(IInternetProtocol)
    COM_INTERFACE_ENTRY(IInternetProtocolRoot)
END_COM_MAP()

private:
    CComPtr<IInternetProtocolSink> m_pSink;

public:
    HRESULT GetVidCtl(PQVidCtl &pCtl);
    HRESULT GetCachedVidCtl(PQVidCtl &pCtl, PQWebBrowser2& pW2);

/////////////////////////////////////////////////////////////////////////////
// CTVProt -- IInternetProtocol

STDMETHODIMP Read(LPVOID pv, ULONG cb, ULONG* pcbRead)
{
    TRACELM(TRACE_DEBUG, "CTVProt::Read()");
    *pcbRead = 0;
	return S_FALSE;
}

STDMETHODIMP Seek(LARGE_INTEGER /* dlibMove */, 
			    DWORD /* dwOrigin */, 
			    ULARGE_INTEGER* /* plibNewPosition*/)
{
    TRACELM(TRACE_DEBUG, "CTVProt::Seek()");
    return E_FAIL;
}

STDMETHODIMP LockRequest(DWORD /* dwOptions */)
{
    TRACELM(TRACE_DEBUG, "CTVProt::LockRequest()");
    return S_OK;
}

STDMETHODIMP UnlockRequest()
{
    TRACELM(TRACE_DEBUG, "CTVProt::UnlockRequest()");
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CTVProt -- IInternetProtocolRoot
STDMETHOD(Start)(LPCWSTR szUrl,
				IInternetProtocolSink* pOIProtSink,
				IInternetBindInfo* pOIBindInfo,
				DWORD grfPI,
				HANDLE_PTR /* dwReserved */);

STDMETHODIMP Continue(PROTOCOLDATA* /* pProtocolData */)
{
    TRACELM(TRACE_DEBUG, "CTVProt::Continue()");
    return S_OK;
}

STDMETHODIMP Abort(HRESULT /* hrReason */, DWORD /* dwOptions */)
{
    TRACELM(TRACE_DEBUG, "CTVProt::Abort()");

    if (m_pSink)
    {
        m_pSink->ReportResult(E_ABORT, 0, 0);
    }

    return S_OK;
}

STDMETHODIMP Terminate(DWORD dwf/* dwOptions */)
{
    TRACELSM(TRACE_DEBUG, (dbgDump << "CTVProt::Terminate() " << hexdump(dwf)), "");
    return S_OK;
}

STDMETHODIMP Suspend()
{
    TRACELM(TRACE_DEBUG, "CTVProt::Suspend()");
    return E_NOTIMPL;
}

STDMETHODIMP Resume()
{
    TRACELM(TRACE_DEBUG, "CTVProt::Resume()");
    return E_NOTIMPL;
}
};

////////////////////////////////////////////////////////////////////////////////
//
//  protocol for DVD
//
/////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// CDVDProt


class ATL_NO_VTABLE __declspec(uuid("12D51199-0DB5-46fe-A120-47A3D7D937CC")) CDVDProt :
	public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CDVDProt, &__uuidof(CDVDProt)>,
	public IInternetProtocol {
public:

CDVDProt()
{
}

~CDVDProt()
{
}

REGISTER_PROTOCOL(IDS_PROJNAME, 
				  IDS_REG_DVDPROTOCOL_DESC,
				  LIBID_MSVidCtlLib,
				  __uuidof(CDVDProt),
				  DVDPROT_SCHEME_NAME);

DECLARE_PROTECT_FINAL_CONSTRUCT()
BEGIN_COM_MAP(CDVDProt)
    COM_INTERFACE_ENTRY(IInternetProtocol)
    COM_INTERFACE_ENTRY(IInternetProtocolRoot)
END_COM_MAP()

private:
    CComPtr<IInternetProtocolSink> m_pSink;

public:


/////////////////////////////////////////////////////////////////////////////
// CDVDProt -- IInternetProtocol

STDMETHODIMP Read(LPVOID pv, ULONG cb, ULONG* pcbRead)
{
    TRACELM(TRACE_DEBUG, "CDVDProt::Read()");
    *pcbRead = 0;
	return S_FALSE;
}

STDMETHODIMP Seek(LARGE_INTEGER /* dlibMove */, 
			    DWORD /* dwOrigin */, 
			    ULARGE_INTEGER* /* plibNewPosition*/)
{
    TRACELM(TRACE_DEBUG, "CDVDProt::Seek()");
    return E_FAIL;
}

STDMETHODIMP LockRequest(DWORD /* dwOptions */)
{
    TRACELM(TRACE_DEBUG, "CDVDProt::LockRequest()");
    return S_OK;
}

STDMETHODIMP UnlockRequest()
{
    TRACELM(TRACE_DEBUG, "CDVDProt::UnlockRequest()");
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CDVDProt -- IInternetProtocolRoot
STDMETHOD(Start)(LPCWSTR szUrl,
				IInternetProtocolSink* pOIProtSink,
				IInternetBindInfo* pOIBindInfo,
				DWORD grfPI,
				HANDLE_PTR /* dwReserved */);

STDMETHODIMP Continue(PROTOCOLDATA* /* pProtocolData */)
{
    TRACELM(TRACE_DEBUG, "CDVDProt::Continue()");
    return S_OK;
}

STDMETHODIMP Abort(HRESULT /* hrReason */, DWORD /* dwOptions */)
{
    TRACELM(TRACE_DEBUG, "CDVDProt::Abort()");

    if (m_pSink)
    {
        m_pSink->ReportResult(E_ABORT, 0, 0);
    }

    return S_OK;
}

STDMETHODIMP Terminate(DWORD dwf/* dwOptions */)
{
    TRACELSM(TRACE_DEBUG, (dbgDump << "CDVDProt::Terminate() " << hexdump(dwf)), "");
    return S_OK;
}

STDMETHODIMP Suspend()
{
    TRACELM(TRACE_DEBUG, "CDVDProt::Suspend()");
    return E_NOTIMPL;
}

STDMETHODIMP Resume()
{
    TRACELM(TRACE_DEBUG, "CDVDProt::Resume()");
    return E_NOTIMPL;
}
};


#endif //__VIDPROT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\inc\ddraw\ddhelp.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddhelp.c
 *  Content: 	helper app to cleanup after dead processes
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   29-mar-95	craige	initial implementation
 *   09-may-95	craige	call fn in dll
 *   20-jul-95	craige	internal reorg to prevent thunking during modeset
 *   29-nov-95  angusm  added DDHELPREQ_CREATEDSFOCUSTHREAD
 *   18-jul-96	andyco	added dplayhelp_xxx functions to allow > 1 dplay app to
 *			host a game on a single machine.
 *   3-oct-96	andyco	made the winmain crit section "cs" a global so we can take
 *			it in dphelps receive thread before forwarding requests
 *   05-oct-96  colinmc fixed build breaker with CRITICAL SECTION stuff
 *   12-oct-96  colinmc new service to load the DirectX VXD into DDHELP
 *                      (necessary for the Win16 lock stuff)
 *   18-jan-97  colinmc vxd handling stuff is no longer win16 lock specific
 *
 ***************************************************************************/
#ifndef __DDHELP_INCLUDED__
#define __DDHELP_INCLUDED__

/*
 * globals
 */
#ifndef NO_D3D
extern CRITICAL_SECTION    	cs; 	// the crit section we take in winmain
					// this is a global so dphelp can take it before
					// forwarding enum requests that come in on its
					// receive thread (manbugs 3907)
#endif

/*
 * named objects
 */
#define DDHELP_EVENT_NAME		"__DDHelpEvent__"
#define DDHELP_ACK_EVENT_NAME		"__DDHelpAckEvent__"
#define DDHELP_STARTUP_EVENT_NAME	"__DDHelpStartupEvent__"
#define DDHELP_SHARED_NAME		"__DDHelpShared__"
#define DDHELP_MUTEX_NAME		"__DDHelpMutex__"
#define DDHELP_MODESET_EVENT_NAME	"__DDHelpModeSetEvent%d__"
#define DDHELP_DOSBOX_EVENT_NAME	"__DDHelpDOSBoxSetEvent%d__"
#define DDHELP_APMSUSPEND_EVENT_NAME    "__DDHelpApmSuspendEvent__"
#define DDHELP_APMRESUME_EVENT_NAME     "__DDHelpApmResumeEvent__"

/*
 * requests
 */
#define DDHELPREQ_NEWPID		1
#define DDHELPREQ_NEWDC			2
#define DDHELPREQ_FREEDCLIST		3
#define DDHELPREQ_RETURNHELPERPID	4
#define DDHELPREQ_LOADDLL		5
#define DDHELPREQ_FREEDLL		6
#define DDHELPREQ_SUICIDE		7
#define DDHELPREQ_KILLATTACHED		8
#define DDHELPREQ_WAVEOPEN		9
#define DDHELPREQ_WAVECLOSE		10
#define DDHELPREQ_CREATETIMER		11
#define DDHELPREQ_KILLTIMER		12
#define DDHELPREQ_CREATEHELPERTHREAD	13
#define DDHELPREQ_CREATEMODESETTHREAD	14
#define DDHELPREQ_KILLMODESETTHREAD	15
#define DDHELPREQ_CREATEDSMIXERTHREAD	16
#define DDHELPREQ_CALLDSCLEANUP         17
#define DDHELPREQ_CREATEDSFOCUSTHREAD	18
#define DDHELPREQ_DPLAYADDSERVER	19
#define DDHELPREQ_DPLAYDELETESERVER	20
#ifdef WIN95
    #define DDHELPREQ_GETDSVXDHANDLE        21
#endif /* WIN95 */
#define DDHELPREQ_NOTIFYONDISPLAYCHANGE	22
#ifdef WIN95
    #define DDHELPREQ_CREATEDOSBOXTHREAD    23
    #define DDHELPREQ_KILLDOSBOXTHREAD      24
#endif /* WIN95 */
#define DDHELPREQ_LOADLIBRARY           25
#define DDHELPREQ_FREELIBRARY           26
#define DDHELPREQ_STOPWATCHPID          27
#define DDHELPREQ_ADDDEVICECHANGENOTIFY 28
#define DDHELPREQ_DELDEVICECHANGENOTIFY 29
#ifdef WIN95
    #define DDHELPREQ_GETDDVXDHANDLE        30
#endif /* WIN95 */

/*
 * callback routine
 */
typedef BOOL	(FAR PASCAL *LPHELPNOTIFYPROC)(struct DDHELPDATA *);
typedef BOOL	(FAR PASCAL *LPHELPMODESETNOTIFYPROC)( LPVOID lpDD );
typedef void    (FAR PASCAL *LPDSCLEANUP)(LPVOID pds);
typedef BOOL    (FAR PASCAL *LPDEVICECHANGENOTIFYPROC)(UINT, DWORD);

/*
 * communication data
 */
typedef struct DDHELPDATA
{
    int			req;
    HANDLE		req_id;
    DWORD		pid;
    BOOL		isdisp;
    union
    {
	LPHELPNOTIFYPROC	lpNotify;
	LPHELPMODESETNOTIFYPROC	lpModeSetNotify;
    };
    DWORD		context;
    char		fname[260];
    char		func[64];
    ULONG_PTR	        dwData1;
    ULONG_PTR	        dwData2;
    LPVOID		pData1;
    LPVOID		pData2;
    ULONG_PTR	        dwReturn;
} DDHELPDATA, *LPDDHELPDATA;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\inc\ddraw\dwininfo.h ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	wndinfo.h
 *  Content:	Direct Draw window information structure
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   08-jul-95	craige	initial implementation
 *   18-jul-95	craige	keep track of dsound/ddraw hooks with flags
 *   13-aug-95  toddla  added WININFO_ACTIVELIE
 *   09-sep-95  toddla  added WININFO_INACTIVATEAPP
 *   17-may-96  colinmc Bug 23029: Removed WININFO_WASICONIC
 *
 ***************************************************************************/

#ifndef __WNDINFO_INCLUDED__
#define __WNDINFO_INCLUDED__

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _DDWINDOWINFO
{
    DWORD                       dwSmag;
    struct _DDWINDOWINFO	*lpLink;
    WNDPROC			lpDSoundCallback;
    HWND			hWnd;
    WNDPROC			lpWndProc;
    DWORD			dwPid;
    DWORD			dwFlags;
    struct
    {
	LPDDRAWI_DIRECTDRAW_LCL	lpDD_lcl;
	DWORD			dwDDFlags;
    } DDInfo;
} DDWINDOWINFO, *LPDDWINDOWINFO;

#define WININFO_MAGIC                   0x42954295l
#define WININFO_DDRAWHOOKED		0x00000001l
#define WININFO_DSOUNDHOOKED		0x00000002l
#define WININFO_ZOMBIE                  0x00000008l
#define WININFO_UNHOOK                  0x00000010l
#define WININFO_IGNORENEXTALTTAB	0x00000020l
#define WININFO_SELFSIZE                0x00000040l
#define WININFO_INACTIVATEAPP           0x00000080l

#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\webdvdarcomp.h ===
//==========================================================================;
//
// Composition.h : Declaration of the custom composition class for gluing WebDVD to ovmixer
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#ifndef WEBDVDCOMPAR_H
#define WEBDVDCOMPAR_H

#pragma once

#include <winerror.h>
#include <algorithm>
#include <objectwithsiteimplsec.h>
#include <compimpl.h>
#include <seg.h>
#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CAnaCapComp
class ATL_NO_VTABLE __declspec(uuid("8D04238E-9FD1-41c6-8DE3-9E1EE309E935")) CWebDVDARComp : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CWebDVDARComp, &__uuidof(CWebDVDARComp)>,
    public IObjectWithSiteImplSec<CWebDVDARComp>,
	public IMSVidCompositionSegmentImpl<CWebDVDARComp>
{
public:
    CWebDVDARComp() {}
    virtual ~CWebDVDARComp() {}

REGISTER_NONAUTOMATION_OBJECT(IDS_PROJNAME, 
						   IDS_REG_WEBDVDARCOMP_DESC,
						   LIBID_MSVidCtlLib,
						   __uuidof(CWebDVDARComp));

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CWebDVDARComp)
        COM_INTERFACE_ENTRY(IMSVidCompositionSegment)
    	COM_INTERFACE_ENTRY(IMSVidGraphSegment)
        COM_INTERFACE_ENTRY(IPersist)
    	COM_INTERFACE_ENTRY(IObjectWithSite)
    END_COM_MAP()

// IMSVidComposition
public:
// IMSVidGraphSegment
// IMSVidCompositionSegment
    STDMETHOD(Compose)(IMSVidGraphSegment * upstream, IMSVidGraphSegment * downstream)
	{
        TRACELM(TRACE_DEBUG, "CWebDVDARComp::Compose()");
        if (m_fComposed) {
            return NOERROR;
        }
        
        ASSERT(m_pGraph);
        try {
            VWGraphSegment up(upstream);
            ASSERT(up.Graph() == m_pGraph);
            VWGraphSegment down(downstream);
            ASSERT(down.Graph() == m_pGraph);
            if (up.begin() == up.end()) {
                TRACELM(TRACE_ERROR, "CWebDVDARComp::Compose() can't compose empty up segment");
                return E_INVALIDARG;
            }
            if (down.begin() == down.end()) {
                TRACELM(TRACE_ERROR, "CWebDVDARComp::Compose() can't compose empty down segment");
                return E_INVALIDARG;
            }
            VWGraphSegment::iterator iNav = std::find_if(up.begin(),
                                                         up.end(),
                                                         arity1_pointer(&IsDVDNavigator));
            if (iNav == up.end()) {
                TRACELM(TRACE_ERROR, "CWebDVDARComp::Compose() upstream segment has no DVD Navigator");
                return E_FAIL;
            }
            ASSERT((*iNav).GetGraph() == m_pGraph);
            
            DSFilter pNav(*iNav);
#if 1
// Code to add mpeg2 video decoder
			CComBSTR decoder(L"{7E2E0DC1-31FD-11D2-9C21-00104B3801F6}");
			CComBSTR decoderName(L"InterVideo Audio Decoder");
			GUID2 decoderGuid(decoder);
            DSFilter pfr(decoderGuid);
            if (!pfr) {
                ASSERT(false);
		        return Error(IDS_CANT_CREATE_FILTER, __uuidof(IMSVidWebDVD), E_UNEXPECTED);
            }
            HRESULT hr = m_pGraph->AddFilter(pfr, decoderName);
            if (FAILED(hr)) {
                TRACELSM(TRACE_ERROR,  (dbgDump << "IMSVidWebDVD::Load() hr = " << std::hex << hr), "");
                return Error(IDS_CANT_ADD_FILTER, __uuidof(IMSVidWebDVD), hr);
            }
            m_Filters.push_back(pfr);

#endif
			// video
            hr = m_pGraph.Connect(pNav, pfr, m_Filters);
            if (FAILED(hr)) {
				TRACELM(TRACE_DETAIL, "CWebDVDARComp::Compose() SUCCEEDED");
				return hr;
            }  
          
			for (VWGraphSegment::iterator iStop = down.begin(); iStop != down.end(); ++iStop){
				DSFilter pStop(*iStop);
				hr = m_pGraph.Connect(pfr, pStop, m_Filters, DSGraph::RENDER_ALL_PINS | DSGraph::IGNORE_EXISTING_CONNECTIONS | DSGraph::DO_NOT_LOAD);
				if(SUCCEEDED(hr)){
					m_fComposed = true;
					return NOERROR;
				}
			}
            return NOERROR;
        } catch (ComException &e) {
            return e;
        } catch (...) {
            return E_UNEXPECTED;
        }
	}
};

#endif // WEBDVDCOMPAR_H
// end of file - WebDVDARComp.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\webdvdcomp.h ===
//==========================================================================;
//
// Composition.h : Declaration of the custom composition class for gluing WebDVD to ovmixer
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#ifndef WEBDVDCOMP_H
#define WEBDVDCOMP_H

#pragma once

#include <winerror.h>
#include <algorithm>
#include <objectwithsiteimplsec.h>
#include <compimpl.h>
#include <seg.h>
#include "resource.h"       // main symbols
#include "perfcntr.h"
/////////////////////////////////////////////////////////////////////////////
// CAnaCapComp
class ATL_NO_VTABLE __declspec(uuid("267db0b3-55e3-4902-949b-df8f5cec0191")) CWebDVDComp : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CWebDVDComp, &__uuidof(CWebDVDComp)>,
    public IObjectWithSiteImplSec<CWebDVDComp>,
	public IMSVidCompositionSegmentImpl<CWebDVDComp>
{
public:
    CWebDVDComp() {}
    virtual ~CWebDVDComp() {}

REGISTER_NONAUTOMATION_OBJECT(IDS_PROJNAME, 
						   IDS_REG_WEBDVDCOMP_DESC,
						   LIBID_MSVidCtlLib,
						   __uuidof(CWebDVDComp));

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CWebDVDComp)
        COM_INTERFACE_ENTRY(IMSVidCompositionSegment)
    	COM_INTERFACE_ENTRY(IMSVidGraphSegment)
        COM_INTERFACE_ENTRY(IPersist)
    	COM_INTERFACE_ENTRY(IObjectWithSite)
    END_COM_MAP()

// IMSVidComposition
public:
// IMSVidGraphSegment
// IMSVidCompositionSegment
    STDMETHOD(Compose)(IMSVidGraphSegment * upstream, IMSVidGraphSegment * downstream)
	{
        TRACELM(TRACE_DEBUG, "CWebDVDComp::Compose()");
        if (m_fComposed) {
            return NOERROR;
        }
        
        ASSERT(m_pGraph);
        try {
            VWGraphSegment up(upstream);
            ASSERT(up.Graph() == m_pGraph);
            VWGraphSegment down(downstream);
            ASSERT(down.Graph() == m_pGraph);
            if (up.begin() == up.end()) {
                TRACELM(TRACE_ERROR, "CWebDVDComp::Compose() can't compose empty up segment");
                return E_INVALIDARG;
            }
            if (down.begin() == down.end()) {
                TRACELM(TRACE_ERROR, "CWebDVDComp::Compose() can't compose empty down segment");
                return E_INVALIDARG;
            }
            VWGraphSegment::iterator iNav = std::find_if(up.begin(),
                                                         up.end(),
                                                         arity1_pointer(&IsDVDNavigator));
            if (iNav == up.end()) {
                TRACELM(TRACE_ERROR, "CWebDVDComp::Compose() upstream segment has no DVD Navigator");
                return E_FAIL;
            }
            ASSERT((*iNav).GetGraph() == m_pGraph);
          
            VWGraphSegment::iterator iOv = std::find_if(down.begin(),
                down.end(),
                arity1_pointer(&IsVideoRenderer));
            if (iOv == down.end()) {
                TRACELM(TRACE_ERROR, "CWebDVDComp::Compose() downstream segment has no ov mixer filter");
                return E_FAIL;
            }
            
            ASSERT((*iOv).GetGraph() == m_pGraph);
            
            DSFilter pNav(*iNav);
            DSFilter pOv(*iOv);
            
            // video
            CPerfCounter pCounterDecoder;
            pCounterDecoder.Reset();
            DSFilter::iterator iNavVideoPin = std::find_if(pNav.begin(), 
                pNav.end(),
                arity1_pointer(&IsDVDNavigatorVideoOutPin));
            if (iNavVideoPin == pNav.end()) {
                TRACELM(TRACE_ERROR, "CWebDVDComp::Compose() no video pin on DVD Navigator");
                return E_FAIL;
            }			
            DSPin pNavVideoPin(*iNavVideoPin);
            HRESULT hr = pNavVideoPin.IntelligentConnect(pOv, m_Filters);
            if (FAILED(hr)) {
                TRACELM(TRACE_DETAIL, "CWebDVDComp::Compose() SUCCEEDED");
                return hr;
            }
            pCounterDecoder.Stop();
            TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl:: Compose() connect decoder video: " << (unsigned long)(pCounterDecoder.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterDecoder.GetLastTime() % _100NS_IN_MS) << " ms"), "");
            
            // subpicture
            pCounterDecoder.Reset();
            
            iNavVideoPin = std::find_if(pNav.begin(), 
                pNav.end(),
                arity1_pointer(&IsDVDNavigatorSubpictureOutPin));
            if (iNavVideoPin == pNav.end()) {
                TRACELM(TRACE_ERROR, "CWebDVDComp::Compose() no subpicture pin on DVD Navigator");
                return E_FAIL;
            }
            pNavVideoPin = *iNavVideoPin;
            hr = pNavVideoPin.IntelligentConnect(pOv, m_Filters, DSGraph::RENDER_ALL_PINS | DSGraph::IGNORE_EXISTING_CONNECTIONS | DSGraph::DO_NOT_LOAD);
            if (FAILED(hr)) {
                TRACELSM(TRACE_ERROR, (dbgDump << "CWebDVDComp::Compose() FAILED hr = " << hexdump(hr)), "");
                return hr;
            }
            pCounterDecoder.Stop();
            TRACELSM(TRACE_ERROR, (dbgDump << "CVidCtl:: Compose() connect decoder subpicture: " << (unsigned long)(pCounterDecoder.GetLastTime() / _100NS_IN_MS) << "." << (unsigned long)(pCounterDecoder.GetLastTime() % _100NS_IN_MS) << " ms"), "");
            
            m_fComposed = true;
            return NOERROR;
        } catch (ComException &e) {
            return e;
        } catch (...) {
            return E_UNEXPECTED;
        }
	}
};

#endif // WEBDVDCOMP_H
// end of file - WebDVDComp.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\inc\ddraw\memalloc.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       memalloc.h
 *  Content:	header file for memory allocation
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   06-apr-95	craige	initial implementation
 *   22-may-95	craige	added MemAlloc16
 *   12-jun-95	craige	added MemReAlloc
 *   26-jun-95  craige  added GetPtr16
 *   26-jul-95  toddla  added MemSize and fixed MemReAlloc
 *
 ***************************************************************************/
#ifndef __MEMALLOC_INCLUDED__
#define __MEMALLOC_INCLUDED__

#ifdef __cplusplus
extern "C" {
#endif
extern void MemFini( void );
extern void MemState( void );
extern BOOL MemInit( void );
extern void MemFree( LPVOID lptr );
extern UINT __cdecl MemSize( LPVOID lptr );
extern LPVOID __cdecl MemAlloc( UINT size );
extern LPVOID __cdecl MemReAlloc( LPVOID ptr, UINT size );
extern LPVOID __cdecl MemAlloc16( UINT size, DWORD FAR *p16 );
extern LPVOID GetPtr16( LPVOID ptr );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\inc\ddraw\w95help.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       w95help.h
 *  Content:	header file for Win95 helper interface
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   06-apr-95	craige	initial implementation
 *   29-nov-95  angusm  added HelperCreateDSFocusThread
 *   18-jul-96	andyco	added Helper(Add/)DeleteDPlayServer
 *   12-oct-96  colinmc added new service to get DDHELP to get its own handle
 *                      for communicating with the DirectSound VXD
 *   22-jan-97  kipo	return an HRESULT from HelperAddDPlayServer()
 *
 ***************************************************************************/
#ifndef __W95HELP_INCLUDED__
#define __W95HELP_INCLUDED__
#include "ddhelp.h"

#ifdef __cplusplus
extern "C" {
#endif

extern void SignalNewProcess( DWORD pid, LPHELPNOTIFYPROC proc );

extern void StopWatchProcess( DWORD pid, LPHELPNOTIFYPROC proc );

extern void SignalNewDriver( LPSTR fname, BOOL isdisp );

extern BOOL CreateHelperProcess( LPDWORD ppid );

extern void DoneWithHelperProcess( void );

extern BOOL WaitForHelperStartup( void );

extern DWORD HelperLoadDLL( LPSTR dllname, LPSTR fnname, DWORD context );

extern void HelperCreateThread( void );

extern DWORD HelperWaveOpen( LPVOID lphwo, DWORD dwDeviceID, LPVOID pwfx );

extern DWORD HelperWaveClose( DWORD hwo );

extern DWORD HelperCreateTimer( DWORD dwResolution,LPVOID pTimerProc,DWORD dwInstanceData );

extern DWORD HelperKillTimer( DWORD dwTimerID );

#ifdef _WIN32
extern HANDLE HelperCreateDSMixerThread( LPTHREAD_START_ROUTINE pfnThreadFunc,
					 LPVOID pThreadParam,
					 DWORD dwFlags,
					 LPDWORD pThreadId );

extern HANDLE HelperCreateDSFocusThread( LPTHREAD_START_ROUTINE pfnThreadFunc,
					 LPVOID pThreadParam,
					 DWORD dwFlags,
					 LPDWORD pThreadId );

extern void HelperCallDSEmulatorCleanup( LPVOID pCleanupFunc,
                                         LPVOID pDirectSound );

#endif

extern BOOL HelperCreateModeSetThread( LPVOID callback, HANDLE *ph, LPVOID lpdd, DWORD hInstance );

extern BOOL HelperCreateDOSBoxThread( LPVOID callback, HANDLE *ph, LPVOID lpdd, DWORD hInstance );

extern void HelperKillModeSetThread( DWORD hInstance );

extern void HelperKillDOSBoxThread( DWORD hInstance );

extern DWORD HelperAddDPlayServer(DWORD port);
extern BOOL HelperDeleteDPlayServer();

#ifdef WIN95
extern HANDLE HelperGetDSVxd( void );

extern HANDLE HelperGetDDVxd( void );

#endif

extern void HelperSetOnDisplayChangeNotify( void *pfn );
extern HINSTANCE HelperLoadLibrary(LPCSTR pszLibraryName);
extern BOOL HelperFreeLibrary(HINSTANCE hInst);
extern void HelperAddDeviceChangeNotify(LPDEVICECHANGENOTIFYPROC);
extern void HelperDelDeviceChangeNotify(LPDEVICECHANGENOTIFYPROC);

#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\inc\ddraw\dibeng.inc ===
;/*
;----------------------------------------------------------------------------
; DIBENG.INC
; Copyright (c) 1992 Microsoft Corporation
;
; Dib Engine Interface Definitions
;----------------------------------------------------------------------------

;----------------------------------------------------------------------------
; General Comments:
; The DIB Engine is non-palettized from GDI's perspective.  When an app
; selects a DIB into a memory DC, GDI will create a DIB Engine PDevice 
; (see definition below) and will stuff in a 'DI' in the deType field.
; Subsequent operations on this DC will result in calls to the DIB Engine
; with this PDevice.  
; Device drivers can also use the DIB Engine to handle most, if not all,
; of their rendering work.  A device driver exports the DIB Engine PDevice
; as it's own PDevice to GDI.  This PDevice contains a pointer to a 
; BitmapInfo header in the driver's data segment. Immediately following
; this is an optional color table for devices less than 16 bpp.
;----------------------------------------------------------------------------
;----------------------------------------------------------------------------
; E Q U A T E S
;----------------------------------------------------------------------------
BRUSHSIZE	equ	8		;height and width in pixels.
VER_DIBENG      equ     400h            ;version = 4.0
TYPE_DIBENG     equ     'RP'            ;deType
comment ~
*/
#define BRUSHSIZE       8
#define VER_DIBENG      0x400
#define TYPE_DIBENG     0x5250
/*
end comment ~
;----------------------------------------------------------------------------
; S T R U C T U R E S
;----------------------------------------------------------------------------

;----------------------------------------------------------------------------
; PDevice Structure for the DIB Engine.  deType will contain 'DI' when GDI
; calls the DIB Engine to perform graphics operations on the dib.  deType 
; will contain a 0 or a Selector if a mini-driver is calling the DIB Engine 
; to do graphics operations. 
;----------------------------------------------------------------------------
deCursorExclude		equ deBeginAccess
deCursorUnexclude	equ deEndAccess
comment ~
*/
#define deCursorExclude	deBeginAccess
#define deCursorUnexclude deEndAccess
/*
end comment ~

DIBENGINE	    struc						      ;*/ typedef struct {                        /*
  deType            dw  ?               ; contains TYPE_DIBENG or 0           ;*/ WORD         deType;                    /*
  deWidth	    dw	?		; Width of dib in pixels	      ;*/ WORD         deWidth;                   /*
  deHeight	    dw	?		; Height of dib in pixels	      ;*/ WORD         deHeight;                  /*
  deWidthBytes	    dw	?		; #bytes per scan line		      ;*/ WORD         deWidthBytes;              /*
  dePlanes	    db	?		; # of planes in bitmap 	      ;*/ BYTE         dePlanes;                  /*
  deBitsPixel	    db	?		; # of bits per pixel		      ;*/ BYTE         deBitsPixel;               /*
  deReserved1	    dd	?		; cannot be used.		      ;*/ DWORD        deReserved1;               /*
  deDeltaScan       dd  ?               ; + or -. Displacement to next scan.  ;*/ DWORD        deDeltaScan;               /*
  delpPDevice	    dd	?		; Pointer to associated PDevice       ;*/ LPBYTE       delpPDevice;               /*
  deBits	    df	?		; fword offset to bits of dib	      ;*/ DWORD        deBitsOffset;              /*
                                        ;                                     ;*/ WORD         deBitsSelector;            /*
  deFlags	    dw	?		; additional flags		      ;*/ WORD         deFlags;                   /*
  deVersion	    dw  ?		; lsb=minor, msb=major (0400h = 4.0)  ;*/ WORD         deVersion;                 /*
  deBitmapInfo	    dd	?		; pointer to the bitmapinfo header    ;*/ LPBITMAPINFO deBitmapInfo;              /*
  deBeginAccess     dd	?		; Begin surface access call back      ;*/ void         (FAR *deBeginAccess)();    /*
  deEndAccess       dd	?		; End surface access call back	      ;*/ void         (FAR *deEndAccess)();      /*
  deDriverReserved  dd  ?		; Reserved for Minidriver use.        ;*/ DWORD        deDriverReserved;          /*
DIBENGINE	    ends		                                      ;*/ } DIBENGINE, FAR *LPDIBENGINE;          /*
;----------------------------------------------------------------------------
; Definitions for DIBEngine.deFlags
;----------------------------------------------------------------------------
MINIDRIVER      equ     0000000000000001b       ;display driver
PALETTIZED      equ     0000000000000010b       ;paletized device
SELECTEDDIB     equ     0000000000000100b       ;DIB Section
OFFSCREEN       equ     0000000000001000b       ;offscreen surface (use with VRAM)
DISABLED        equ     0000000000010000b	;going away -- please use BUSY instead [raypat]
BUSY            equ     0000000000010000b	;
NOT_FRAMEBUFFER	equ	0000000000100000b	;example: 8514/a
FIVE6FIVE	equ	0000000001000000b	;16 bpp, 565 color format.
NON64KBANK      equ     0000000010000000b       ;bank size is not 64K
VRAM            equ     1000000000000000b       ;physical surface (video memory)
BANKEDVRAM      equ     0100000000000000b       ;VFlatD simulated
BANKEDSCAN      equ     0010000000000000b       ;VFlatD simulated (broken rasters)
PALETTE_XLAT    equ     0001000000000000b       ;background palette xlat
VGADITHER       equ     0000100000000000b       ;dither to VGA colors (first 8, and last 8)
CTCHANGE        equ     0000010000000000b       ;color table has been changed
DITHER256       equ     0000001000000000b       ;dither to 256 fixed colors
FREE2           equ     0000000100000000b       ;free

BUSY_BIT        equ     4                       ;bit number to test for BUSY


comment ~
*/
#define MINIDRIVER      0x0001	  
#define PALETTIZED      0x0002	  
#define SELECTEDDIB     0x0004	  
#define OFFSCREEN       0x0008
#define DISABLED        0x0010
#define BUSY            0x0010		
#define NOT_FRAMEBUFFER 0x0020
#define FIVE6FIVE       0x0040
#define NON64KBANK      0x0080
#define VRAM            0x8000	  
#define BANKEDVRAM      0x4000	  
#define BANKEDSCAN      0x2000
#define PALETTE_XLAT    0x1000
#define VGADITHER       0x0800
#define CTCHANGE        0x0400
#define DITHER256       0x0200

#define BUSY_BIT        0x0004
/*
end comment ~

;----------------------------------------------------------------------------
; Definitions for DIBEngine.deBeginAccess flags
;----------------------------------------------------------------------------
FB_ACCESS   	equ     0000000000000001b
CURSOREXCLUDE  	equ     0000000000001000b

comment ~
*/
#define FB_ACCESS	0x0001
#define CURSOREXCLUDE	0x0008
/*
end comment ~


;----------------------------------------------------------------------------
; Definitions for most significant byte of a physical color.
;----------------------------------------------------------------------------
GREY_BIT        equ     01000000b       ;color is grey (r=g=b)
comment ~
*/
#define GREY_BIT        0x40	  
/*
end comment ~
;----------------------------------------------------------------------------
; DIB Engine Color Table entry structure. This structure is used by device
; drivers that are using DIB Engine services for rendering.  This structure
; is identical to the RGBQuad structure except for some bit definitions
; in the 4th byte.
;----------------------------------------------------------------------------
DIBColorEntry	struc							      ;*/ typedef struct {		  /*
  dceBlue	    db	?                                                     ;*/ BYTE dceBlue;	                  /*
  dceGreen	    db	?                                                     ;*/ BYTE dceGreen;                  /*
  dceRed	    db	?                                                     ;*/ BYTE dceRed;	                  /*
  dceFlags          db  ?                                                     ;*/ BYTE dceFlags;                  /*
DIBColorEntry	ends                                                          ;*/ } DIBColorEntry;                /*
;----------------------------------------------------------------------------
; Definitions for DIBColorEntry.dceFlags
;----------------------------------------------------------------------------
NONSTATIC	equ	10000000b      ;Inhibits color matching to this entry.
MAPTOWHITE	equ	00000001b      ;0=Black, 1=White
comment ~
*/
#define NONSTATIC       0x80	  
#define MAPTOWHITE      0x01	  
/*
end comment ~
;----------------------------------------------------------------------------

;----------------------------------------------------------------------------
; DIB Engine Physical Object Definitions
;----------------------------------------------------------------------------

DIB_Pen	struc                                                                 ;*/ typedef struct {                /*  
dpPenStyle	dw	?                                                     ;*/ WORD  dpPenStyle;               /*  
dpPenFlags	db	?		;currently none undefined.            ;*/ BYTE  dpPenFlags;               /*
dpPenBpp	db	?	                                              ;*/ BYTE  dpPenBpp;                 /*
dpPenMono	dd	?                                                     ;*/ DWORD dpPenMono;                /*
dpPenColor	dd	?                                                     ;*/ DWORD dpPenColor;               /*
DIB_Pen	ends                                                                  ;*/ } DIB_Pen;                      /*

DIB_Brush1	struc                                                         ;*/ typedef struct {                /*  
dp1BrushFlags   db	?		    ;Accelerator for solids           ;*/ BYTE  dp1BrushFlags;            /*
dp1BrushBpp     db	?		    ;Brush Bits per pixel format      ;*/ BYTE  dp1BrushBpp;              /*
dp1BrushStyle   dw	?		    ;Style of the brush               ;*/ WORD  dp1BrushStyle;            /*
dp1FgColor	dd	?		    ;Physical fg color                ;*/ DWORD dp1FgColor;               /*
dp1Hatch	dw	?		    ;Hatching style                   ;*/ WORD  dp1Hatch;                 /*
dp1BgColor	dd	?		    ;Physical bg color                ;*/ DWORD dp1BgColor;               /*
dp1BrushMono	db	BRUSHSIZE*4 dup (?) ;Mono portion                     ;*/ BYTE dp1BrushMono [BRUSHSIZE*4];/*
dp1BrushMask	db	BRUSHSIZE*4 dup (?) ;transparency mask (hatch pattern);*/ BYTE dp1BrushMask [BRUSHSIZE*4];/*
dp1BrushBits	db	BRUSHSIZE*4 dup (?) ;8 rows, 8 columns of 1 bit/pixel ;*/ BYTE dp1BrushBits [BRUSHSIZE*4];/* 
DIB_Brush1	ends                                                          ;*/ } DIB_Brush1;                   /*  

DIB_Brush4	struc                                                         ;*/ typedef struct {                /*  
dp4BrushFlags   db	?		    ;Accelerator for solids           ;*/ BYTE  dp4BrushFlags;            /*
dp4BrushBpp     db	?		    ;Brush Bits per pixel format      ;*/ BYTE  dp4BrushBpp;              /*
dp4BrushStyle   dw	?		    ;Style of the brush               ;*/ WORD  dp4BrushStyle;            /*
dp4FgColor	dd	?		    ;Physical fg color                 ;*/ DWORD dp4FgColor;               /*
dp4Hatch	dw	?		    ;Hatching style                   ;*/ WORD  dp4Hatch;                 /*
dp4BgColor	dd	?		    ;Physical bg color                 ;*/ DWORD dp4BgColor;               /*
dp4BrushMono	db	BRUSHSIZE*4 dup (?) ;Mono portion                     ;*/ BYTE dp4BrushMono [BRUSHSIZE*4];/*
dp4BrushMask	db	BRUSHSIZE*4 dup (?) ;transparency mask (hatch pattern);*/ BYTE dp4BrushMask [BRUSHSIZE*4];/*
dp4BrushBits	db	BRUSHSIZE*4 dup (?) ;8 rows, 8 columns of 4 bit/pixel ;*/ BYTE dp4BrushBits [BRUSHSIZE*4];/* 
DIB_Brush4	ends                                                          ;*/ } DIB_Brush4;                   /*  

DIB_Brush8	struc                                                         ;*/ typedef struct {                /*  
dp8BrushFlags   db	?		    ;Accelerator for solids           ;*/ BYTE  dp8BrushFlags;            /*
dp8BrushBpp     db	?		    ;Brush Bits per pixel format      ;*/ BYTE  dp8BrushBpp;              /*
dp8BrushStyle   dw	?		    ;Style of the brush               ;*/ WORD  dp8BrushStyle;            /*
dp8FgColor	dd	?		    ;Physical fg color                 ;*/ DWORD dp8FgColor;               /*
dp8Hatch	dw	?		    ;Hatching style                   ;*/ WORD  dp8Hatch;                 /*
dp8BgColor	dd	?		    ;Physical bg color                 ;*/ DWORD dp8BgColor;               /*
dp8BrushMono	db	BRUSHSIZE*4 dup (?) ;Mono portion                     ;*/ BYTE dp8BrushMono [BRUSHSIZE*4];/*
dp8BrushMask	db	BRUSHSIZE*4 dup (?) ;transparency mask (hatch pattern);*/ BYTE dp8BrushMask [BRUSHSIZE*4];/*
dp8BrushBits	db	BRUSHSIZE*8 dup (?) ;8 rows,8 columns of 8 bit/pixel  ;*/ BYTE dp8BrushBits [BRUSHSIZE*8];/* 
DIB_Brush8	ends                                                          ;*/ } DIB_Brush8;                   /*  

DIB_Brush16	struc                                                         ;*/ typedef struct {                /*  
dp16BrushFlags   db	?		    ;Accelerator for solids           ;*/ BYTE  dp16BrushFlags;            /*
dp16BrushBpp     db	?		    ;Brush Bits per pixel format      ;*/ BYTE  dp16BrushBpp;              /*
dp16BrushStyle   dw	?		    ;Style of the brush               ;*/ WORD  dp16BrushStyle;            /*
dp16FgColor	dd	?		    ;Physical fg color                 ;*/ DWORD dp16FgColor;               /*
dp16Hatch	dw	?		    ;Hatching style                   ;*/ WORD  dp16Hatch;                 /*
dp16BgColor	dd	?		    ;Physical bg color                 ;*/ DWORD dp16BgColor;               /*
dp16BrushMono	db	BRUSHSIZE*4 dup (?) ;Mono portion                     ;*/ BYTE dp16BrushMono [BRUSHSIZE*4];/*
dp16BrushMask	db	BRUSHSIZE*4 dup (?) ;transparency mask (hatch pattern);*/ BYTE dp16BrushMask [BRUSHSIZE*4];/*
dp16BrushBits	db	BRUSHSIZE*16 dup (?);8 rows,8 columns of 16 bit/pixel;*/ BYTE dp16BrushBits [BRUSHSIZE*16];/* 
DIB_Brush16	ends                                                          ;*/ } DIB_Brush16;                   /*  

DIB_Brush24	struc                                                         ;*/ typedef struct {                /*  
dp24BrushFlags   db	?		    ;Accelerator for solids           ;*/ BYTE  dp24BrushFlags;            /*
dp24BrushBpp     db	?		    ;Brush Bits per pixel format      ;*/ BYTE  dp24BrushBpp;              /*
dp24BrushStyle   dw	?		    ;Style of the brush               ;*/ WORD  dp24BrushStyle;            /*
dp24FgColor	dd	?		    ;Physical fg color                 ;*/ DWORD dp24FgColor;               /*
dp24Hatch	dw	?		    ;Hatching style                   ;*/ WORD  dp24Hatch;                 /*
dp24BgColor	dd	?		    ;Physical bg color                 ;*/ DWORD dp24BgColor;               /*
dp24BrushMono	db	BRUSHSIZE*4 dup (?) ;Mono portion                     ;*/ BYTE dp24BrushMono [BRUSHSIZE*4];/*
dp24BrushMask	db	BRUSHSIZE*4 dup (?) ;transparency mask (hatch pattern);*/ BYTE dp24BrushMask [BRUSHSIZE*4];/*
dp24BrushBits	db	BRUSHSIZE*24 dup (?);8 rows,8 columns of 24 bit/pixel ;*/ BYTE dp24BrushBits [BRUSHSIZE*24];/* 
DIB_Brush24	ends                                                          ;*/ } DIB_Brush24;                   /*  

DIB_Brush32	struc                                                         ;*/ typedef struct {                /*  
dp32BrushFlags   db	?		    ;Accelerator for solids           ;*/ BYTE  dp32BrushFlags;            /*
dp32BrushBpp     db	?		    ;Brush Bits per pixel format      ;*/ BYTE  dp32BrushBpp;              /*
dp32BrushStyle   dw	?		    ;Style of the brush               ;*/ WORD  dp32BrushStyle;            /*
dp32FgColor	dd	?		    ;Physical fg color                 ;*/ DWORD dp32FgColor;               /*
dp32Hatch	dw	?		    ;Hatching style                   ;*/ WORD  dp32Hatch;                 /*
dp32BgColor	dd	?		    ;Physical bg color                 ;*/ DWORD dp32BgColor;               /*
dp32BrushMono	db	BRUSHSIZE*4 dup (?) ;Mono portion                     ;*/ BYTE dp32BrushMono [BRUSHSIZE*4];/*
dp32BrushMask	db	BRUSHSIZE*4 dup (?) ;transparency mask (hatch pattern);*/ BYTE dp32BrushMask [BRUSHSIZE*4];/*
dp32BrushBits	db	BRUSHSIZE*32 dup (?);8 rows,8 columns of 32 bit/pixel ;*/ BYTE dp32BrushBits [BRUSHSIZE*32];/* 
DIB_Brush32	ends                                                          ;*/ } DIB_Brush32;                   /*  

;----------------------------------------------------------------------------
; Definitions for DIB_Brushxx.dpxxBrushFlags
;----------------------------------------------------------------------------                                      
COLORSOLID     equ      00000001b ;Color part is solid.                        
MONOSOLID      equ      00000010b ;Mono part is solid.                         
PATTERNMONO    equ      00000100b ;Pattern brush came from a mono bitmap.      
MONOVALID      equ      00001000b ;Mono part is valid.                         
MASKVALID      equ      00010000b ;Transparency Mask part is valid.
PRIVATEDATA    equ      00100000b ;Vendor specific bit for Pens, Brushes
comment ~
*/
#define  COLORSOLID     0x01         
#define  MONOSOLID      0x02         
#define  PATTERNMONO    0x04         
#define  MONOVALID      0x08         
#define  MASKVALID      0x10
#define  PRIVATEDATA    0x20
/*
end comment ~
;----------------------------------------------------------------------------
; ColorToMono
; Entry: red, green, blue
; Exit:  blue = intensity.
;----------------------------------------------------------------------------
ColorToMono	macro	red, green, blue
	add	blue,red		;R+B
        rcr     blue,1                  ;(R+B)/2
	add	blue,green		;pitch in Green
        rcr     blue,1                  ;G/2 + (R+B)/4
endm	ColorToMono

;----------------------------------------------------------------------------
; ColorToMonoBit
; Entry: red, green, blue
; Exit:  blue = 0 if color maps to black
;        blue = 1 if color maps to white
;----------------------------------------------------------------------------
ColorToMonoBit	macro	red, green, blue
	ColorToMono red,green,blue    ; Call ColorToMono to derive intensity.
	cmp	blue,127
	setnc	blue
endm ColorToMonoBit

;*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\inc\ddraw\ddd3dapi.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995,1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	ddd3dapi.h
 *  Content:	Interface between DirectDraw and Direct3D.
 *@@BEGIN_MSINTERNAL
 * 
 *  $Id$
 *
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   02/17/96   colinmc Created this file from the obsolete d3dapi.h
 *   03/23/96   colinmc Added process termination cleanup code
 *   04/17/96   colinmc Bug 17008: DirectDraw/Direct3D deadlock
 *   04/25/96	stevela Bug 16803: Name of Direct3D DLL changed.
 *   04/29/96   colinmc Bug 19954: Must query for Direct3D before texture
 *                      or device
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef _DDD3DAPI_H_
#define _DDD3DAPI_H_

// Flags for D3DDEVICEDESC dwDeviceZBufferBitDepth
// copied from direct3d\rast\d3dif\d3dif.hpp, see note there for explanation

#define D3DSWRASTERIZER_ZBUFFERBITDEPTHFLAGS (DDBD_16)

/*
 * File name of the Direct3D DLL.
 */
#define D3D_DLLNAME               "D3DIM.DLL"
#define D3DDX7_DLLNAME            "D3DIM700.DLL"

/*
 * Entry points exported by the Direct3D DLL.
 */
#define D3DCREATE_PROCNAME        "Direct3DCreate"
#define D3DCREATEDEVICE_PROCNAME  "Direct3DCreateDevice"
#define D3DCREATETEXTURE_PROCNAME "Direct3DCreateTexture"
#define D3DHALCLEANUP_PROCNAME    "Direct3D_HALCleanUp"

#ifdef USE_D3D_CSECT
    typedef HRESULT (WINAPI * D3DCreateProc)(LPUNKNOWN*         lplpD3D,
					     IUnknown*          pUnkOuter);
#else  /* USE_D3D_CSECT */
    typedef HRESULT (WINAPI * D3DCreateProc)(LPCRITICAL_SECTION lpDDCSect,
					     LPUNKNOWN*         lplpD3D,
					     IUnknown*          pUnkOuter);
#endif /* USE_D3D_CSECT */

typedef HRESULT (WINAPI * D3DCreateTextProc)(REFCLSID            riid,
                                             LPDIRECTDRAWSURFACE lpDDS,
					     LPUNKNOWN*          lplpD3DText,
					     IUnknown*           pUnkOuter);
typedef HRESULT (WINAPI * D3DCreateDeviceProc)(REFCLSID            riid,
                                               LPUNKNOWN           lpDirect3D,
                                               LPDIRECTDRAWSURFACE lpDDS,
                                               LPUNKNOWN*          lplpD3DDevice,
                                               IUnknown*           pUnkOuter,
                                               DWORD               dwVersion);

typedef DWORD (WINAPI * D3DGetSWRastPixFmtsProc)(DDPIXELFORMAT **ppDDPF);

typedef HRESULT (WINAPI * D3DHALCleanUpProc)(LPD3DHAL_CALLBACKS lpHALTable, DWORD dwPID);

#endif /* _DDD3DAPI_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\inc\ddraw\ddreg.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddreg.h
 *  Content:	DirectDraw registry entries
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   16-aug-96	craige	initial implementation
 *   06-jan-97  colinmc Initial AGP work
 *   01-feb-97  colinmc Bug 5457: Fixed Win16 lock problem causing hang
 *                      with mutliple AMovie instances on old cards
 *
 ***************************************************************************/

#ifndef __DDRAWREG_INCLUDED__
#define __DDRAWREG_INCLUDED__

#define REGSTR_PATH_DDRAW 		   "Software\\Microsoft\\DirectDraw"

#define	REGSTR_VAL_DDRAW_MODEXONLY	   "ModeXOnly"
#define	REGSTR_VAL_DDRAW_EMULATIONONLY	   "EmulationOnly"
#define REGSTR_VAL_DDRAW_SHOWFRAMERATE	   "ShowFrameRate"
#define REGSTR_VAL_DDRAW_ENABLEPRINTSCRN   "EnablePrintScreen"
#define REGSTR_VAL_DDRAW_DISABLEWIDERSURFACES "DisableWiderSurfaces"
/*
 * This one is checked in DirectDrawMsg
 */
#define REGSTR_VAL_DDRAW_DISABLEDIALOGS    "DisableDialogs"
#define REGSTR_VAL_DDRAW_NODDSCAPSINDDSD   "DisableDDSCAPSInDDSD"

#define REGSTR_VAL_DDRAW_FORCEAGPSUPPORT   "ForceAGPSupport"
#define REGSTR_VAL_DDRAW_AGPPOLICYMAXPAGES "AGPPolicyMaxPages"
#define REGSTR_VAL_DDRAW_AGPPOLICYMAXBYTES "AGPPolicyMaxBytes"
#define REGSTR_VAL_DDRAW_AGPPOLICYCOMMITDELTA "AGPPolicyCommitDelta"
#define REGSTR_VAL_DDRAW_DISABLEAGPSUPPORT "DisableAGPSupport"

#define REGSTR_VAL_DDRAW_DISABLEMMX	   "DisableMMX"

#define REGSTR_VAL_DDRAW_FORCEREFRESHRATE  "ForceRefreshRate"

#define REGSTR_VAL_DDRAW_LOADDEBUGRUNTIME  "LoadDebugRuntime"

#ifdef WIN95
#define REGSTR_KEY_RECENTMONITORS          "MostRecentMonitors"
#define REGSTR_VAL_DDRAW_MONITORSORDER     "Order"
#endif

#ifdef DEBUG
    #define REGSTR_VAL_DDRAW_DISABLENOSYSLOCK  "DisableNoSysLock"
    #define REGSTR_VAL_DDRAW_FORCENOSYSLOCK    "ForceNoSysLock"
#endif /* DEBUG */
#define REGSTR_VAL_DDRAW_DISABLEINACTIVATE "DisableInactivate"

#define REGSTR_KEY_GAMMA_CALIBRATOR        "GammaCalibrator"
#define REGSTR_VAL_GAMMA_CALIBRATOR        "Path"

#define REGSTR_KEY_APPCOMPAT		   "Compatibility"

#define REGSTR_KEY_LASTAPP		   "MostRecentApplication"

#define REGSTR_VAL_DDRAW_NAME		   "Name"
#define REGSTR_VAL_DDRAW_APPID		   "ID"
#define REGSTR_VAL_DDRAW_FLAGS		   "Flags"

#define REGSTR_VAL_D3D_USENONLOCALVIDMEM   "UseNonLocalVidMem"

#define REGSTR_VAL_DDRAW_ENUMSECONDARY     "EnumerateAttachedSecondaries"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\inc\ddraw\dpf.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpf.h
 *  Content:    header file for debug printf
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   06-apr-95  craige  initial implementation
 *   06-feb-96  colinmc added simple assertion mechanism for DirectDraw
 *   15-apr-96  kipo    added msinternal
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#ifdef NEW_DPF
#include "newdpf.h"
#else

    #ifndef __DPF_INCLUDED__
    #define __DPF_INCLUDED__

    #ifdef __cplusplus
    extern "C" {
    #endif

    #ifdef WINNT
        #undef DEBUG
        #ifdef DBG
            #define DEBUG
        #endif
    #endif

    extern void cdecl DXdprintf( UINT lvl, LPSTR szFormat, ...);
    extern void cdecl D3DInfoPrintf( UINT lvl, LPSTR szFormat, ...);
    extern void cdecl D3DWarnPrintf( UINT lvl, LPSTR szFormat, ...);
    extern void cdecl D3DErrorPrintf( LPSTR szFormat, ...);

    extern void DPFInit( void );
    #ifdef DEBUG
        #define DPF_DECLARE(szName) char * __pszDpfName=#szName":"
        #define DPFINIT()   DPFInit()
        #define DPF         DXdprintf
        #define DPF_ERR(a)  DXdprintf( 0, DPF_MODNAME ": " a );
        extern HWND hWndListBox;
        #if defined( _WIN32 ) && !defined(WINNT)
            #define DEBUG_BREAK()       _try { _asm { int 3 } } _except (EXCEPTION_EXECUTE_HANDLER) {;}
        #else
            #define DEBUG_BREAK()       DebugBreak()
        #endif
        #define USE_DDASSERT

        // New for D3D
        #define D3D_ERR       D3DErrorPrintf
        #define D3D_WARN      D3DWarnPrintf
        #define D3D_INFO      D3DInfoPrintf
    #else
        #pragma warning(disable:4002)
        #define DPF_DECLARE(szName)
        #define DPFINIT()
        #define DPF()
        #define DPF_ERR(a)
        #define DEBUG_BREAK()

        #define D3D_ERR(a)
        #define D3D_WARN()
        #define D3D_INFO()
    #endif

    #if defined(DEBUG) && defined(USE_DDASSERT)

    extern void _DDAssert(LPCSTR szFile, int nLine, LPCSTR szCondition);

    #define DDASSERT(condition) if (!(condition)) _DDAssert(__FILE__, __LINE__, #condition)

    #else  /* DEBUG && USE_DDASSERT */

    #define DDASSERT(condition)

    #endif /* DEBUG && USE_DDASSERT */

    #ifdef _WIN32

    #ifdef DEBUG
        __inline DWORD clockrate() {LARGE_INTEGER li; QueryPerformanceFrequency(&li); return li.LowPart;}
        __inline DWORD perf_clock()     {LARGE_INTEGER li; QueryPerformanceCounter(&li);   return li.LowPart;}

        #define TIMEVAR(t)    DWORD t ## T; DWORD t ## N
        #define TIMEZERO(t)   t ## T = 0, t ## N = 0
        #define TIMESTART(t)  t ## T -= perf_clock(), t ## N ++
        #define TIMESTOP(t)   t ## T += perf_clock()
        #define TIMEFMT(t)    ((DWORD)(t) / clockrate()), (((DWORD)(t) * 1000 / clockrate())%1000)
        #define TIMEOUT(t)    if (t ## N) DPF(1, #t ": %ld calls, %ld.%03ld sec (%ld.%03ld)", t ## N, TIMEFMT(t ## T), TIMEFMT(t ## T / t ## N))
    #else
        #define TIMEVAR(t)
        #define TIMEZERO(t)
        #define TIMESTART(t)
        #define TIMESTOP(t)
        #define TIMEFMT(t)
        #define TIMEOUT(t)
    #endif

    #endif
    #ifdef __cplusplus
    }
    #endif

    #endif
#endif //use new dpf
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\audiosrv\agfxs.h ===
/* agfxs.h
 * header for extern GFX functions
 * Copyright (c) 2000-2001 Microsoft Corporation
 */
BOOL GFX_DllProcessAttach(void);
void GFX_DllProcessDetach(void);

void GFX_AudioInterfaceArrival(PCTSTR DeviceInterface);
void GFX_AudioInterfaceRemove(PCTSTR DeviceInterface);

void GFX_RenderInterfaceArrival(PCTSTR DeviceInterface);
void GFX_RenderInterfaceRemove(PCTSTR DeviceInterface);

void GFX_CaptureInterfaceArrival(PCTSTR DeviceInterface);
void GFX_CaptureInterfaceRemove(PCTSTR DeviceInterface);

void GFX_DataTransformInterfaceArrival(PCTSTR DeviceInterface);
void GFX_DataTransformInterfaceRemove(PCTSTR DeviceInterface);

void GFX_SysaudioInterfaceArrival(PCTSTR DeviceInterface);
void GFX_SysaudioInterfaceRemove(PCTSTR DeviceInterface);

void GFX_SessionChange(DWORD EventType, LPVOID EventData);

void GFX_ServiceStop(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\inc\ddraw\ids.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ids.h
 *  Content:    DirectDraw resource ids
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   10-sep-95  toddla  created
 *   20-sep-95	craige	add IDS_PRIMARYDISPLAY
 *
 ***************************************************************************/

// icon ids
#define ID_ICON             42

// string ids
#define IDS_TITLE           100     // dialog box title
#define IDS_DONTWORK_BPP    101     // you must be in 256 color mode or higher.
#define IDS_DONTWORK_DRV    102     // your driver is bad.
#define IDS_PRIMARYDISPLAY  103     // primary display ident. string
#define IDS_TIME_BOMB		104		// time bomb message string
#define IDS_TIME_BOMB_TITLE	105		// time bomb title string
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\audiosrv\debug.h ===
/* debug.h
 * Copyright (c) 2000-2001 Microsoft Corporation
 */
 
//
// ISSUE-2000/09/29-FrankYe Try to use standard ntrtl debug
//    stuff.  Check winweb/wem for guidance perhaps.
//

#ifdef ASSERT
#undef ASSERT
#endif

#ifdef DBG
#define ASSERT( exp ) \
if (!(exp)) { \
    char msg[200]; \
    wsprintfA(msg, "Assert failure %s %d %s\n", __FILE__, __LINE__, #exp); \
    OutputDebugStringA(msg); \
    DebugBreak(); \
}
static int dprintf(PCTSTR pszFormat, ...)
{
    PTSTR pstrTemp;
    va_list marker;
    int result = 0;
    
    pstrTemp = (PTSTR)HeapAlloc(GetProcessHeap(), 0, 500 * sizeof(TCHAR));
    if (pstrTemp)
    {
        va_start(marker, pszFormat);
        result = wvsprintf(pstrTemp, pszFormat, marker);
        OutputDebugString(TEXT("AudioSrv: "));
        OutputDebugString(pstrTemp);
        HeapFree(GetProcessHeap(), 0, pstrTemp);
    }
    return result;
}


#else
#define ASSERT
#define dprintf
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\audiosrv\ksi.h ===
EXTERN_C
LONG
KsSerializeFilterStateToReg(
    IN HANDLE hKsObject,
    IN HKEY hKey
);

EXTERN_C
LONG
KsUnserializeFilterStateFromReg(
    IN HANDLE hKsObject,
    IN HKEY hKey
);

EXTERN_C
LONG
KsSetAudioGfxRenderTargetDeviceId(
    IN HANDLE hGfx,
    IN PCTSTR DeviceId
);

EXTERN_C
LONG
KsSetAudioGfxCaptureTargetDeviceId(
    IN HANDLE hGfx,
    IN PCTSTR DeviceId
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\audiosrv\audiosrv.cpp ===
/* audiosrv.cpp
 * Copyright (c) 2000-2001 Microsoft Corporation
 */
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#undef ASSERT
#include <stdio.h>
#include <windows.h>
#include <setupapi.h>
#include <dbt.h>
#include <ks.h>
#include <ksmedia.h>
#include <svcs.h>
#include "debug.h"
#include "list.h"
#include "audiosrv.h"
#include "service.h"
#include "agfxs.h"
#include "mme.h"
#include "ts.h"

//
// Note in general don't rely on compiler init of global
// variables since service might be stopped and restarted
// without this DLL being freed and then reloaded.
//
PSVCHOST_GLOBAL_DATA gpSvchostSharedGlobals = NULL;
BOOL       fRpcStarted;
HANDLE     hHeap;
HDEVNOTIFY hdevNotifyAudio;
HDEVNOTIFY hdevNotifyRender;
HDEVNOTIFY hdevNotifyCapture;
HDEVNOTIFY hdevNotifyDataTransform;
HDEVNOTIFY hdevNotifySysaudio;

//
// Upon loading this DLL, svchost will find this exported function
// and pass a pointer to useful shared globals.
void SvchostPushServiceGlobals(IN PSVCHOST_GLOBAL_DATA pSvchostSharedGlobals)
{
    gpSvchostSharedGlobals = pSvchostSharedGlobals;
}

//--------------------------------------------------------------------------;
//
// AudioSrvRpcIfCallback
//
// Description:
//	RPC security callback function.  See MSDN for RpcServerRegisterIfEx
// IfCallback parameter.  This security callback function will fail any
// non local RPC calls.  It checks this by using the internal RPC
// function I_RpcBindingInqTransportType.
//
// Arguments:
//	See MSDN for RPC_IF_CALLBACK_FN.
//
// Return value:
//	See MSDN for RPC_IF_CALLBACK_FN.
//
// History:
//	05/02/2002		FrankYe		Created
//
//--------------------------------------------------------------------------;
RPC_STATUS RPC_ENTRY AudioSrvRpcIfCallback(IN RPC_IF_HANDLE Interface, IN void *Context)
{
	unsigned int type;
	RPC_STATUS status;

	status = I_RpcBindingInqTransportType(Context, &type);
	if (RPC_S_OK != status) return ERROR_ACCESS_DENIED;
	if (TRANSPORT_TYPE_LPC != type) return ERROR_ACCESS_DENIED;
	return RPC_S_OK;
}

// Stub initialization function. 
DWORD MyServiceInitialization(SERVICE_STATUS_HANDLE ssh, DWORD   argc, LPTSTR  *argv, DWORD *specificError)
{
    DEV_BROADCAST_DEVICEINTERFACE dbdi;
    LONG status;

    // dprintf(TEXT("MyServiceInitialization\n"));
    
    status = ERROR_SUCCESS;;

    fRpcStarted = FALSE;
    hdevNotifyAudio = NULL;
    hdevNotifyRender = NULL;
    hdevNotifyCapture = NULL;
    hdevNotifyDataTransform = NULL;
    hdevNotifySysaudio = NULL;

    gplistSessionNotifications = new CListSessionNotifications;
    if (!gplistSessionNotifications) status = ERROR_OUTOFMEMORY;
    if (!status) status = gplistSessionNotifications->Initialize();

    if (!status) {
        ZeroMemory(&dbdi, sizeof(dbdi));
        dbdi.dbcc_size = sizeof(dbdi);
        dbdi.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
        dbdi.dbcc_classguid = KSCATEGORY_AUDIO;
        hdevNotifyAudio = RegisterDeviceNotification(ssh, &dbdi, DEVICE_NOTIFY_SERVICE_HANDLE);
        if (!hdevNotifyAudio) status = GetLastError();
    }
    
    if (!status) {
        ZeroMemory(&dbdi, sizeof(dbdi));
        dbdi.dbcc_size = sizeof(dbdi);
        dbdi.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
        dbdi.dbcc_classguid = KSCATEGORY_RENDER;
        hdevNotifyRender = RegisterDeviceNotification(ssh, &dbdi, DEVICE_NOTIFY_SERVICE_HANDLE);
        if (!hdevNotifyRender) status = GetLastError();
    }
    
    if (!status) {
        ZeroMemory(&dbdi, sizeof(dbdi));
        dbdi.dbcc_size = sizeof(dbdi);
        dbdi.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
        dbdi.dbcc_classguid = KSCATEGORY_CAPTURE;
        hdevNotifyCapture = RegisterDeviceNotification(ssh, &dbdi, DEVICE_NOTIFY_SERVICE_HANDLE);
        if (!hdevNotifyCapture) status = GetLastError();
    }
    
    if (!status) {
        ZeroMemory(&dbdi, sizeof(dbdi));
        dbdi.dbcc_size = sizeof(dbdi);
        dbdi.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
        dbdi.dbcc_classguid = KSCATEGORY_DATATRANSFORM;
        hdevNotifyDataTransform = RegisterDeviceNotification(ssh, &dbdi, DEVICE_NOTIFY_SERVICE_HANDLE);
        if (!hdevNotifyDataTransform) status = GetLastError();
    }
    
    if (!status) {
        ZeroMemory(&dbdi, sizeof(dbdi));
        dbdi.dbcc_size = sizeof(dbdi);
        dbdi.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
        dbdi.dbcc_classguid = KSCATEGORY_SYSAUDIO;
        hdevNotifySysaudio = RegisterDeviceNotification(ssh, &dbdi, DEVICE_NOTIFY_SERVICE_HANDLE);
        if (!hdevNotifySysaudio) status = GetLastError();
    }
    
    if (!status) {
        NTSTATUS ntstatus;
        ntstatus = RpcServerUseAllProtseqsIf(RPC_C_PROTSEQ_MAX_REQS_DEFAULT, AudioSrv_v1_0_s_ifspec, NULL);
        if (!ntstatus) ntstatus = RpcServerRegisterIfEx(AudioSrv_v1_0_s_ifspec, NULL, NULL, RPC_IF_AUTOLISTEN, RPC_C_LISTEN_MAX_CALLS_DEFAULT, AudioSrvRpcIfCallback);
        if (!ntstatus) {
            fRpcStarted = TRUE;
        } else {
            // ISSUE-2000/10/10-FrankYe Try to convert to proper win32 error.
            status = RPC_S_SERVER_UNAVAILABLE;
        }
    }

    if (!status) {
    	status = MME_ServiceStart();
    }

    if (status) {
        // Rely on MyServiceTerminate to clean up anything
        // that is partially initialized.
    }

    return status;
}  // end MyServiceInitialization

void MyServiceTerminate(void)
{
    //
    // Stop the Rpc server
    //
    if (fRpcStarted) {
        NTSTATUS status;
        status = RpcServerUnregisterIf(AudioSrv_v1_0_s_ifspec, NULL, 1);
        if (status) dprintf(TEXT("ServiceStop: StopRpcServerEx returned NTSTATUS=%08Xh\n"), status);
        fRpcStarted = FALSE;
    }
    
    //
    // Unregister PnP notifications
    //
    if (hdevNotifySysaudio) UnregisterDeviceNotification(hdevNotifySysaudio);
    if (hdevNotifyDataTransform) UnregisterDeviceNotification(hdevNotifyDataTransform);
    if (hdevNotifyCapture) UnregisterDeviceNotification(hdevNotifyCapture);
    if (hdevNotifyRender) UnregisterDeviceNotification(hdevNotifyRender);
    if (hdevNotifyAudio) UnregisterDeviceNotification(hdevNotifyAudio);
    hdevNotifySysaudio = NULL;
    hdevNotifyDataTransform = NULL;
    hdevNotifyCapture = NULL;
    hdevNotifyRender = NULL;
    hdevNotifyAudio = NULL;

    //
    // Clean up any remaining session notifications and delete list
    //
    if (gplistSessionNotifications) {
        POSITION pos = gplistSessionNotifications->GetHeadPosition();
        while (pos)
        {
            PSESSIONNOTIFICATION pNotification;
            pNotification = gplistSessionNotifications->GetNext(pos);
            CloseHandle(pNotification->Event);
            delete pNotification;
        }
        delete gplistSessionNotifications;
    }
    gplistSessionNotifications = NULL;

    //
    // Clean up GFX support
    //
    GFX_ServiceStop();

    return;
}

DWORD ServiceDeviceEvent(DWORD EventType, LPVOID EventData)
{
    PDEV_BROADCAST_DEVICEINTERFACE dbdi = (PDEV_BROADCAST_DEVICEINTERFACE)EventData;

    switch (EventType)
    {
    case DBT_DEVICEARRIVAL:
        if (dbdi->dbcc_devicetype != DBT_DEVTYP_DEVICEINTERFACE) break;
        
	if (dbdi->dbcc_classguid == KSCATEGORY_AUDIO) MME_AudioInterfaceArrival(dbdi->dbcc_name);
	
	if (dbdi->dbcc_classguid == KSCATEGORY_SYSAUDIO) GFX_SysaudioInterfaceArrival(dbdi->dbcc_name);
	if (dbdi->dbcc_classguid == KSCATEGORY_AUDIO) GFX_AudioInterfaceArrival(dbdi->dbcc_name);
	if (dbdi->dbcc_classguid == KSCATEGORY_RENDER) GFX_RenderInterfaceArrival(dbdi->dbcc_name);
	if (dbdi->dbcc_classguid == KSCATEGORY_CAPTURE) GFX_CaptureInterfaceArrival(dbdi->dbcc_name);
	if (dbdi->dbcc_classguid == KSCATEGORY_DATATRANSFORM) GFX_DataTransformInterfaceArrival(dbdi->dbcc_name);
	
	return NO_ERROR;

    case DBT_DEVICEQUERYREMOVEFAILED:
        if (dbdi->dbcc_devicetype != DBT_DEVTYP_DEVICEINTERFACE) break;
        
	if (dbdi->dbcc_classguid == KSCATEGORY_SYSAUDIO) GFX_SysaudioInterfaceArrival(dbdi->dbcc_name);
	if (dbdi->dbcc_classguid == KSCATEGORY_AUDIO) GFX_AudioInterfaceArrival(dbdi->dbcc_name);
	if (dbdi->dbcc_classguid == KSCATEGORY_RENDER) GFX_RenderInterfaceArrival(dbdi->dbcc_name);
	if (dbdi->dbcc_classguid == KSCATEGORY_CAPTURE) GFX_CaptureInterfaceArrival(dbdi->dbcc_name);
	if (dbdi->dbcc_classguid == KSCATEGORY_DATATRANSFORM) GFX_DataTransformInterfaceArrival(dbdi->dbcc_name);
	
	return NO_ERROR;

    case DBT_DEVICEQUERYREMOVE:
        if (dbdi->dbcc_devicetype != DBT_DEVTYP_DEVICEINTERFACE) break;
        
	if (dbdi->dbcc_classguid == KSCATEGORY_SYSAUDIO) GFX_SysaudioInterfaceRemove(dbdi->dbcc_name);
	if (dbdi->dbcc_classguid == KSCATEGORY_AUDIO) GFX_AudioInterfaceRemove(dbdi->dbcc_name);
	if (dbdi->dbcc_classguid == KSCATEGORY_RENDER) GFX_RenderInterfaceRemove(dbdi->dbcc_name);
	if (dbdi->dbcc_classguid == KSCATEGORY_CAPTURE) GFX_CaptureInterfaceRemove(dbdi->dbcc_name);
	if (dbdi->dbcc_classguid == KSCATEGORY_DATATRANSFORM) GFX_DataTransformInterfaceRemove(dbdi->dbcc_name);
	
	return NO_ERROR;

    case DBT_DEVICEREMOVEPENDING:
        if (dbdi->dbcc_devicetype != DBT_DEVTYP_DEVICEINTERFACE) break;
        
	if (dbdi->dbcc_classguid == KSCATEGORY_AUDIO) MME_AudioInterfaceRemove(dbdi->dbcc_name);
	
	if (dbdi->dbcc_classguid == KSCATEGORY_SYSAUDIO) GFX_SysaudioInterfaceRemove(dbdi->dbcc_name);
	if (dbdi->dbcc_classguid == KSCATEGORY_AUDIO) GFX_AudioInterfaceRemove(dbdi->dbcc_name);
	if (dbdi->dbcc_classguid == KSCATEGORY_RENDER) GFX_RenderInterfaceRemove(dbdi->dbcc_name);
	if (dbdi->dbcc_classguid == KSCATEGORY_CAPTURE) GFX_CaptureInterfaceRemove(dbdi->dbcc_name);
	if (dbdi->dbcc_classguid == KSCATEGORY_DATATRANSFORM) GFX_DataTransformInterfaceRemove(dbdi->dbcc_name);
	
	return NO_ERROR;

    case DBT_DEVICEREMOVECOMPLETE:
        if (dbdi->dbcc_devicetype != DBT_DEVTYP_DEVICEINTERFACE) break;
        
	if (dbdi->dbcc_classguid == KSCATEGORY_AUDIO) MME_AudioInterfaceRemove(dbdi->dbcc_name);
	
	if (dbdi->dbcc_classguid == KSCATEGORY_SYSAUDIO) GFX_SysaudioInterfaceRemove(dbdi->dbcc_name);
	if (dbdi->dbcc_classguid == KSCATEGORY_AUDIO) GFX_AudioInterfaceRemove(dbdi->dbcc_name);
	if (dbdi->dbcc_classguid == KSCATEGORY_RENDER) GFX_RenderInterfaceRemove(dbdi->dbcc_name);
	if (dbdi->dbcc_classguid == KSCATEGORY_CAPTURE) GFX_CaptureInterfaceRemove(dbdi->dbcc_name);
	if (dbdi->dbcc_classguid == KSCATEGORY_DATATRANSFORM) GFX_DataTransformInterfaceRemove(dbdi->dbcc_name);
	
	return NO_ERROR;

    default:
	return ERROR_CALL_NOT_IMPLEMENTED;
    }

    return ERROR_CALL_NOT_IMPLEMENTED;
}

void ServiceStop(void)
{
    dprintf(TEXT("ServiceStop\n"));
    
    ReportStatusToSCMgr(SERVICE_STOP_PENDING, NO_ERROR, 0);
    MyServiceTerminate();
    ReportStatusToSCMgr(SERVICE_STOPPED, NO_ERROR, 0);

    return;
}

VOID ServiceStart(SERVICE_STATUS_HANDLE ssh, DWORD dwArgc, LPTSTR *lpszArgv)
{ 
    DWORD status;
    DWORD specificError;

    // dprintf(TEXT("ServiceStart\n"));

    status = MyServiceInitialization(ssh, dwArgc, lpszArgv, &specificError); 

    if (!status) {
	// dprintf(TEXT("MyServiceInitialization succeeded\n"));
        ReportStatusToSCMgr(SERVICE_RUNNING, NO_ERROR, 0);
    } else {
	dprintf(TEXT("MyServiceInitialization returned status=%d\n"), status);
        ReportStatusToSCMgr(SERVICE_STOPPED, status, 0);
    }

    return; 
} 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t cb)
{
    return HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, cb);
}

void  __RPC_USER MIDL_user_free( void __RPC_FAR * pv)
{
    HeapFree(hHeap, 0, pv);
}

BOOL DllMain(PVOID hModule, ULONG Reason, PCONTEXT pContext)
{
    BOOL result = TRUE;
    static BOOL fGfxResult = FALSE;
    static BOOL fMmeResult = FALSE;
    
    if (DLL_PROCESS_ATTACH == Reason)
    {
        hHeap = GetProcessHeap();
        result = fGfxResult = GFX_DllProcessAttach();
        if (result) result = fMmeResult = MME_DllProcessAttach();

        if (!result)
        {
            if (fMmeResult) MME_DllProcessDetach();
            if (fGfxResult) GFX_DllProcessDetach();

            fMmeResult = FALSE;
            fGfxResult = FALSE;
        }
            
    }
    else if (DLL_PROCESS_DETACH == Reason)
    {
        if (fMmeResult) MME_DllProcessDetach();
        if (fGfxResult) GFX_DllProcessDetach();

        fMmeResult = FALSE;
        fGfxResult = FALSE;
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\audiosrv\agfxs.cpp ===
/* agfxs.cpp
 * Server side code for agfx.
 * Created by FrankYe on 7/3/2000
 * Copyright (c) 2000-2001 Microsoft Corporation
 */
extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <tchar.h>
#include <windows.h>
#include <sddl.h>
#include <winsta.h>
#include <wtsapi32.h>
#include <syslib.h>
#include <mmsystem.h>
#include <mmsysp.h>
#include <regstr.h>
#include <objbase.h>
#include <setupapi.h>
#include <wdmguid.h>
#include <ks.h>
#include <ksmedia.h>
}


#include "debug.h"
#include "list.h"
#include "service.h"
#include "audiosrv.h"
#include "reg.h"
#include "sad.h"
#include "ksi.h"
#include "agfxs.h"
#include "agfxsp.h"

/*===========================================================================//
  ===   ISSUE-2000/09/24-FrankYe TODO   Notes    ===
-
- Figure out correct way to pass handle through RPC to s_gfxOpenGfx
- Does RPC server unregister its endpoint when shutting down?
- Should turn on strick type checking
- Ensure there are no Order duplicates
- Handle NULL global lists.  Perhaps put lists in a context
- Need to listen to PnP queries and unload GFXs if PnP wishes
    to remove them.  Repro problem by Uninstalling a GFX via
    Device Manager.  Note it asks for reboot.
- Create client contexts at least to ensure input GFX IDs are
   valid for the current user.  Otherwise one user can manipulate
   the gfx settings of another user via gfxOpenGfx.
- Be consistent in whether s_* functions return LONG or RPC_STATUS
- Modify to handle Render and Capture device specs
- When loading all CuAutoLoad and CuUserLoad, confirm active
- Move all string constants to header
- Should AutoLoad HardwareId be MULTI_SZ

//===========================================================================*/


//=============================================================================
//===   Constants   ===
//=============================================================================
#define REGSTR_PATH_GFX REGSTR_PATH_MULTIMEDIA TEXT("\\Audio\\Gfx")

#define REGSTR_PATH_GFX_AUTOLOAD TEXT("AutoLoad")
#define REGSTR_PATH_GFX_USERLOAD TEXT("UserLoad")

#define REGSTR_PATH_DI_GFX TEXT("Gfx")

#define REGSTR_PATH_GFXAUTOLOAD                  REGSTR_PATH_GFX TEXT("\\") REGSTR_PATH_GFX_AUTOLOAD
#define REGSTR_PATH_GFXUSERLOAD                  REGSTR_PATH_GFX TEXT("\\") REGSTR_PATH_GFX_USERLOAD
#define REGSTR_PATH_GFXDI_USERINTERFACECLSID     TEXT("UserInterface\\CLSID")
#define REGSTR_PATH_GFXUSERLOADID_FILTERSETTINGS TEXT("FilterSettings")

#define REGSTR_VAL_GFX_IDGEN  TEXT("IdGeneration")
#define REGSTR_VAL_GFX_ZONEDI TEXT("ZoneDi")
#define REGSTR_VAL_GFX_GFXDI  TEXT("GfxDi")
#define REGSTR_VAL_GFX_TYPE   TEXT("Type")
#define REGSTR_VAL_GFX_ORDER  TEXT("Order")

#define REGSTR_VAL_GFX_ID           TEXT("Id")
#define REGSTR_VAL_GFX_CUAUTOLOADID TEXT("CuAutoLoadId")
#define REGSTR_VAL_GFX_LMAUTOLOADID TEXT("LmAutoLoadId")

#define REGSTR_VAL_GFX_HARDWAREID      TEXT("HardwareId")
#define REGSTR_VAL_GFX_REFERENCESTRING TEXT("ReferenceString")
#define REGSTR_VAL_GFX_NEWAUTOLOAD     TEXT("NewAutoLoad")





//=============================================================================
//===   Global data   ===
//=============================================================================

//
// resource object protecting GFX support initialization and termination. This
// is required since initialization/termination might happen either on RPC calls
// to s_gfxLogon/s_gfxLogoff or on SERVICE_CONTROL_STOP event to the service
// control handler.  Also, other RPC interface functions might be executing
// on one thread while s_gfxLogon, s_gfxLogoff, or SERVICE_CONTROL_STOP happens
// on another thread.
//
RTL_RESOURCE GfxResource;
BOOL gfGfxResource = FALSE;

//
// Are GFX functions initialized and functional
//
BOOL gfGfxInitialized = FALSE;

//
// The current console user
//
CUser* gpConsoleUser = NULL;

//
// The process global lists below are locked/unlocked together using
// the functions LockGlobalLists and UnlockGlobalLists.  We don't
// attempt to lock at finer granulatiry
//
CListGfxFactories  *gplistGfxFactories = NULL;
CListZoneFactories *gplistZoneFactories = NULL;
CListCuUserLoads   *gplistCuUserLoads = NULL;
                                                             
//
// The sysaudio data below is locked by a critical section accessed
// by calling LockSysaudio and UnlockSysaudio
//
PTSTR gpstrSysaudioDeviceInterface = NULL;
HANDLE ghSysaudio = INVALID_HANDLE_VALUE;
LONG gfCsSysaudio = FALSE;
CRITICAL_SECTION gcsSysaudio;

//
// If both the global lists lock and the sysaudio lock are required
// at the same time, then the global lists lock must be acquired first!
//

//=============================================================================
//===   debug helpers   ===
//=============================================================================
#ifdef DBG
#endif

//=============================================================================
//===   Heap helpers   ===
//=============================================================================
static BOOL HeapFreeIfNotNull(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem)
{
    return lpMem ? HeapFree(hHeap, dwFlags, lpMem) : TRUE;
}
void* __cdecl operator new(size_t cbBuffer)
{
    ASSERT(cbBuffer);
    return HeapAlloc(hHeap, 0, cbBuffer);
}

void __cdecl operator delete(void *p)
{
    ASSERT(p);
    HeapFree(hHeap, 0, p);
}

//=============================================================================
//===   String helpers   ===
//=============================================================================
int lstrcmpiMulti(PCTSTR pstrMulti, PCTSTR pstrKey)
{
    int iresult;
    do {
	iresult = lstrcmpi(pstrMulti, pstrKey);
	pstrMulti += lstrlen(pstrMulti)+1;
    } while (iresult && lstrlen(pstrMulti));
    return iresult;
}

PTSTR lstrDuplicate(PCTSTR pstr)
{
    PTSTR pstrDuplicate = (PTSTR)HeapAlloc(hHeap, 0, (lstrlen(pstr)+1)*sizeof(TCHAR));
    if (pstrDuplicate) lstrcpy(pstrDuplicate, pstr);
    return pstrDuplicate;
}

//=============================================================================
//===   Rtl resource helpers   ===
//=============================================================================

/*-----------------------------------------------------------------------------

    RtlInterlockedTestAcquireResourceShared

    Given a resource, and a BOOLEAN flag protected by the resource, this
    function acquires the resource shared and tests the flag.  If the flag is
    true, this function returns TREU with the resource acquired shared.  If the
    flag is false, this function releases the resource and returns FALSE.
    
-----------------------------------------------------------------------------*/
BOOL RtlInterlockedTestAcquireResourceShared(
    PRTL_RESOURCE Resource,
    PBOOL ResourceFlag
)
{
    RtlAcquireResourceShared(Resource, TRUE);
    if (*ResourceFlag) return TRUE;
    RtlReleaseResource(Resource);
    return FALSE;
}

//=============================================================================
//
//      Security helpers   
//
//  The semantics are similar to other security-related Win32 APIs.  That is
//  the return value is a BOOL where TRUE means success, FALSE means failure,
//  and GetLastError will return an error code after a failure.
//
//=============================================================================

/*-----------------------------------------------------------------------------

    GetCurrentUserTokenW

    Private function implemented in irnotif.lib.  Retrieves the token of the
    user logged onto the specified winstation.  I've been advised that the
    caller of this function is responsible for closing the returned handle.

    Returns NULL on failure.
    
-----------------------------------------------------------------------------*/
EXTERN_C HANDLE GetCurrentUserTokenW(IN WCHAR Winsta[], IN DWORD DesiredAccess);

/*-----------------------------------------------------------------------------

    CreateStringSidFromSid

    Same function as the Win32 API ConvertSidToStringSid but ensures the
    resulting string is allocated on the heap specified by the global
    variable hHeap.

-----------------------------------------------------------------------------*/
BOOL CreateStringSidFromSid(IN PSID pSid, OUT PTSTR *ppStringSid)
{
    PTSTR StringSid;
    LONG  LastError;

    ASSERT(pSid);
    
    if (ConvertSidToStringSid(pSid, &StringSid))
    {
	PTSTR outStringSid;
	    	
	// dprintf(TEXT("CreateStringSidFromSid: StringSid=%s\n"), StringSid);
	    	
	outStringSid = lstrDuplicate(StringSid);

	if (outStringSid) {
	    *ppStringSid = outStringSid;
	    LastError = NO_ERROR;
	} else {
	    LastError = ERROR_OUTOFMEMORY;
	}
	    	
        LocalFree(StringSid);
    } else {
	LastError = GetLastError();
	dprintf(TEXT("CreateStringSidFromSid: ConvertSidToStringSid LastError=%d\n"), GetLastError());
    }

    SetLastError(LastError);
    return (NO_ERROR == LastError);
}

/*-----------------------------------------------------------------------------

    CreateTokenSid

    Given a token handle, create a SID for the token user.
    
    The SID is allocated on the heap specified by the global variable hHeap.
    The caller is responsible for freeing the storage for ths SID.  The
    function returns TRUE if successful and FALSE otherwise.  LastError is
    set.
    
-----------------------------------------------------------------------------*/
BOOL CreateTokenSid(HANDLE TokenHandle, OUT PSID *ppSid)
{
    	DWORD cbTokenUserInformation;
    	LONG  LastError;

    	LastError = NO_ERROR;
    	
    	if (!GetTokenInformation(TokenHandle, TokenUser, NULL, 0, &cbTokenUserInformation)) LastError = GetLastError();
    	
    	if ((NO_ERROR == LastError) || (ERROR_INSUFFICIENT_BUFFER == LastError))
    	{
	    PTOKEN_USER TokenUserInformation;

            ASSERT(cbTokenUserInformation > 0);

	    TokenUserInformation = (PTOKEN_USER)HeapAlloc(hHeap, 0, cbTokenUserInformation);
	    if (TokenUserInformation)
	    {
    	        if (GetTokenInformation(TokenHandle, TokenUser, TokenUserInformation, cbTokenUserInformation, &cbTokenUserInformation))
    	        {
    	            DWORD cbSid = GetLengthSid(TokenUserInformation->User.Sid);
    	            PSID pSid = HeapAlloc(hHeap, 0, cbSid);
    	            if (pSid)
    	            {
    	            	if (CopySid(cbSid, pSid, TokenUserInformation->User.Sid))
    	            	{
    	            	    *ppSid = pSid;
    	            	    LastError = NO_ERROR;
    	            	} else {
    	            	    LastError = GetLastError();
                            dprintf(TEXT("CreateTokenSid: CopySid failed, LastError=%d\n"), LastError);
    	            	}
    	            } else {
    	                LastError = ERROR_OUTOFMEMORY;
    	            }
	    	} else {
	    	    LastError = GetLastError();
	    	    dprintf(TEXT("CreateTokenSid: GetTokenInformation (second) LastError=%d\n"), LastError);
	    	}
	    	HeapFree(hHeap, 0, TokenUserInformation);
	    } else {
	        LastError = ERROR_OUTOFMEMORY;
	    }
    	} else {
    	    LastError = GetLastError();
    	    dprintf(TEXT("CreateTokenSid: GetTokenInformation (first) LastError=%d\n"), LastError);
    	}

    	SetLastError(LastError);
    	return (NO_ERROR == LastError);
}

BOOL OpenSessionToken(ULONG SessionId, PHANDLE pToken)
{
    HANDLE Token;
    LONG error;

    if (GetWinStationUserToken(SessionId, &Token))
    {
    	error = NO_ERROR;
    }
    else if (0 == SessionId) 
    {
    	// ISSUE-2001-03-21-FrankYe This appears to fail during
    	// logoff notification
    	Token = GetCurrentUserTokenW(L"WinSta0", TOKEN_ALL_ACCESS);
    	if (Token)
    	{
    	    error = NO_ERROR;
    	}
    	else
    	{
    	    error = GetLastError();
    	    ASSERT(NO_ERROR != error);
    	    dprintf(TEXT("OpenSessionToken : error: GetCurrentUserTokenW failed, LastError=%d\n"), error);
    	}
    }
    else
    {
    	error = GetLastError();
    	ASSERT(NO_ERROR != error);
    }

    if (NO_ERROR == error) *pToken = Token;
    
    SetLastError(error);
    return (NO_ERROR == error);
}
    	
/*-----------------------------------------------------------------------------

    CreateSessionUserSid

    Given a session ID, create a SID for the session user.
    
    The SID is allocated on the heap specified by the global variable hHeap.
    The caller is responsible for freeing the storage for ths SID.  The
    function returns TRUE if successful and FALSE otherwise.  LastError is
    set.
    
-----------------------------------------------------------------------------*/
BOOL CreateSessionUserSid(IN DWORD dwSessionId, OUT PSID *ppSid)
{
    HANDLE hToken;
    LONG error;

    if (OpenSessionToken(dwSessionId, &hToken))
    {
        PSID pSid;
        if (CreateTokenSid(hToken, &pSid))
        {
            *ppSid = pSid;
       	    error = NO_ERROR;
        } else {
            error = GetLastError();
            dprintf(TEXT("CreateSessionUserSid: CreateTokenSid failed, LastError=%d\n"), error);
        }
        CloseHandle(hToken);
    } else {
        error = GetLastError();
        dprintf(TEXT("CreateSessionUserSid: OpenSessionToken failed, LastError=%d\n"), error);
    }

    SetLastError(error);
    return (NO_ERROR == error);
}

/*-----------------------------------------------------------------------------

    CreateThreadImpersonationSid

    Given a thread handle, create a SID for the user that the thread is
    impersonating.

    The SID is allocated on the heap specified by the global variable hHeap.
    The caller is responsible for freeing the storage for ths SID.  The
    function returns TRUE if successful and FALSE otherwise.  LastError is
    set.
    
-----------------------------------------------------------------------------*/
BOOL CreateThreadImpersonationSid(IN HANDLE ThreadHandle, OUT PSID *ppSid)
{
    HANDLE TokenHandle;
    LONG LastError;

    if (OpenThreadToken(ThreadHandle, TOKEN_QUERY, FALSE, &TokenHandle))
    {
    	if (CreateTokenSid(TokenHandle, ppSid))
    	{
    	    LastError = NO_ERROR;
    	} else {
    	    LastError = GetLastError();
    	    dprintf(TEXT("CreateThreadImpersonationSid: CreateTokenSid LastError=%d\n"), LastError);
    	}
    	CloseHandle(TokenHandle);
    } else {
        LastError = GetLastError();
        dprintf(TEXT("OpenThreadToken LastError=%d\n"), LastError);
    }

    SetLastError(LastError);
    return (NO_ERROR == LastError);
}

/*--------------------------------------------------------------------------

   IsUserProfileLoaded

   Silly way to determine whether the user's profile is loaded
  
   Arguments:
      IN HANDLE hUserToken : Token for user whose profile to check
  
   Return value:
      BOOL : Indicates whether user profile is loaded and available
        TRUE : User profile is available
        FALSE : User profie is not available or an error was encountered.
          Call GetLastError to get an error code describing what failure
          was encountered.
  
   Comments:
  
-------------------------------------------------------------------------*/
BOOL IsUserProfileLoaded(HANDLE hUserToken)
{
    PSID pSid;
    BOOL success;
    LONG error = NO_ERROR;

    success = CreateTokenSid(hUserToken, &pSid);
    if (success)
    {
    	PTSTR StringSid;
    	success = CreateStringSidFromSid(pSid, &StringSid);
    	if (success)
    	{
    	    HKEY hkUser;
    	    error = RegOpenKeyEx(HKEY_USERS, StringSid, 0, KEY_QUERY_VALUE, &hkUser);
    	    success = (NO_ERROR == error);
    	    if (success) RegCloseKey(hkUser);
    	    HeapFree(hHeap, 0, StringSid);
    	}
    	else
    	{
    	    error = GetLastError();
    	}
    	HeapFree(hHeap, 0, pSid);
    }
    else
    {
        error = GetLastError();
    }

    // if (error) dprintf(TEXT("IsUserProfileLoaded : warning: returning error %d\n"), error);

    ASSERT(success == (NO_ERROR == error));
    SetLastError(error);
    return success;
    
}

//=============================================================================
//===   Rpc helpers   ===
//=============================================================================

/*-----------------------------------------------------------------------------

    RpcClientHasUserSid

    Checks whether the current thread's RPC client's SID matches the given SID.
    It does this by impersonating the client using RpcImpersonateClient,
    calling the helper function CreateThreadImpersonationSid, and then
    RpcRevertToSelf.
    
    The function returns TRUE the SIDs are equal, or FALSE if there is an error
    or of the SIDs are not equal.  LastError is set.
    
-----------------------------------------------------------------------------*/
BOOL RpcClientHasUserSid(PSID Sid)
{
    LONG LastError;
    BOOL result = FALSE;

    LastError = RpcImpersonateClient(NULL);
    if (NO_ERROR == LastError)
    {
    	PSID ClientSid;
    	if (CreateThreadImpersonationSid(GetCurrentThread(), &ClientSid))
    	{
    	    LastError = NO_ERROR;
    	    if (EqualSid(ClientSid, Sid)) result = TRUE;
    	    HeapFree(hHeap, 0, ClientSid);
    	} else {
    	    LastError = GetLastError();
    	    dprintf(TEXT("RpcClientHasUserSid: CreateThreadImpersonationSid failed, LastError=%d\n"), LastError);
    	}
    	RpcRevertToSelf();
    }

    // We should never match the SID if there was a failure.
    ASSERT( ! ((TRUE == result) && (NO_ERROR != LastError))  );
    
    SetLastError(LastError);
    return result;
}

//=============================================================================
//===   SetupDi helpers   ===
//=============================================================================
BOOL SetupDiCreateDeviceInterfaceDetail(HDEVINFO hdi, PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData, PSP_DEVICE_INTERFACE_DETAIL_DATA *ppDeviceInterfaceDetailData, PSP_DEVINFO_DATA pDeviceInfoData)
{
    DWORD cbDeviceInterfaceDetailData;
    BOOL fresult;

    fresult = SetupDiGetDeviceInterfaceDetail(hdi, DeviceInterfaceData, NULL, 0, &cbDeviceInterfaceDetailData, NULL);

    if (fresult || ERROR_INSUFFICIENT_BUFFER == GetLastError())
    {
	PSP_DEVICE_INTERFACE_DETAIL_DATA DeviceInterfaceDetailData;

	DeviceInterfaceDetailData = (PSP_DEVICE_INTERFACE_DETAIL_DATA)HeapAlloc(hHeap, 0, cbDeviceInterfaceDetailData);
	if (DeviceInterfaceDetailData) {
	    SP_DEVINFO_DATA DeviceInfoData;

	    DeviceInterfaceDetailData->cbSize = sizeof(*DeviceInterfaceDetailData);
	    DeviceInfoData.cbSize = sizeof(DeviceInfoData);
	    fresult = SetupDiGetDeviceInterfaceDetail(hdi, DeviceInterfaceData, DeviceInterfaceDetailData, cbDeviceInterfaceDetailData, NULL, &DeviceInfoData);

	    if (fresult) {
		if (ppDeviceInterfaceDetailData) *ppDeviceInterfaceDetailData = DeviceInterfaceDetailData;
		if (pDeviceInfoData) *pDeviceInfoData = DeviceInfoData;
	    }
	    
	    if (!fresult || !ppDeviceInterfaceDetailData) {
		DWORD dw = GetLastError();
		HeapFree(hHeap, 0, DeviceInterfaceDetailData);
		SetLastError(dw);
	    }
	}
    } else {
	DWORD dw = GetLastError();
    }

    return fresult;
}

BOOL SetupDiGetDeviceInterfaceHardwareId(HDEVINFO hdi, PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData, PTSTR *ppstrHardwareId)
{
    SP_DEVINFO_DATA DeviceInfoData;
    PSP_DEVICE_INTERFACE_DETAIL_DATA pDeviceInterfaceDetailData;
    BOOL fresult;
    
    DeviceInfoData.cbSize = sizeof(DeviceInfoData);

    fresult = SetupDiCreateDeviceInterfaceDetail(hdi, DeviceInterfaceData, &pDeviceInterfaceDetailData, &DeviceInfoData);
    if (fresult) {
        DWORD cbHardwareId;
        
        fresult = SetupDiGetDeviceRegistryProperty(hdi, &DeviceInfoData,
            SPDRP_HARDWAREID, NULL, NULL, 0, &cbHardwareId);
        
        if (fresult || ERROR_INSUFFICIENT_BUFFER == GetLastError()) {
            PTSTR HardwareId;
            
            HardwareId = (PTSTR)HeapAlloc(hHeap, 0, cbHardwareId);
            fresult = SetupDiGetDeviceRegistryProperty(hdi, &DeviceInfoData,
                SPDRP_HARDWAREID, NULL, (PBYTE)HardwareId, cbHardwareId, NULL);
                
            if (fresult) {
                *ppstrHardwareId = HardwareId;
            } else {
                HeapFree(hHeap, 0, HardwareId);
            }
        }
	HeapFree(hHeap, 0, pDeviceInterfaceDetailData);
    }
    
    return fresult;
}

BOOL SetupDiGetDeviceInterfaceBusId(HDEVINFO hdi, PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData, LPGUID pBusTypeGuid)
{
    SP_DEVINFO_DATA DeviceInfoData;
    DWORD dwNeeded;
    BOOL fresult;

    DeviceInfoData.cbSize = sizeof(DeviceInfoData);
    fresult = SetupDiGetDeviceInterfaceDetail(hdi, DeviceInterfaceData, NULL, 0, &dwNeeded, &DeviceInfoData);
    if (fresult || ERROR_INSUFFICIENT_BUFFER == GetLastError()) {
        GUID BusTypeGuid;
        ULONG cbBusTypeGuid;

        cbBusTypeGuid = sizeof(BusTypeGuid);
        fresult = SetupDiGetDeviceRegistryProperty(hdi, &DeviceInfoData, SPDRP_BUSTYPEGUID, NULL, (PBYTE)&BusTypeGuid, cbBusTypeGuid, &cbBusTypeGuid);
        if (fresult) *pBusTypeGuid = BusTypeGuid;
    }

    return fresult;
}

BOOL SetupDiCreateAliasDeviceInterfaceFromDeviceInterface(
    IN PCTSTR pDeviceInterface,
    IN LPCGUID  pAliasInterfaceClassGuid,
    OUT PTSTR *ppAliasDeviceInterface
)
{
    HDEVINFO hdi;
    PSP_DEVICE_INTERFACE_DETAIL_DATA pAudioDeviceInterfaceDetail;
    PTSTR pAliasDeviceInterface;
    BOOL fresult;
    LONG error;
    
    hdi = SetupDiCreateDeviceInfoList(NULL, NULL);
    if (INVALID_HANDLE_VALUE != hdi)
    {
        SP_DEVICE_INTERFACE_DATA DeviceInterfaceData;
        
        DeviceInterfaceData.cbSize = sizeof(DeviceInterfaceData);
        fresult = SetupDiOpenDeviceInterface(hdi, pDeviceInterface, 0, &DeviceInterfaceData);
        if (fresult)
        {
            SP_DEVICE_INTERFACE_DATA AliasDeviceInterfaceData;
            PSP_DEVICE_INTERFACE_DETAIL_DATA pAliasDeviceInterfaceDetail;
            
            AliasDeviceInterfaceData.cbSize = sizeof(AliasDeviceInterfaceData);
            fresult = SetupDiGetDeviceInterfaceAlias(hdi, &DeviceInterfaceData, pAliasInterfaceClassGuid, &AliasDeviceInterfaceData);
            if (fresult)
            {
            	fresult = SetupDiCreateDeviceInterfaceDetail(hdi, &AliasDeviceInterfaceData, &pAliasDeviceInterfaceDetail, NULL);
            	if (fresult)
            	{
            	    pAliasDeviceInterface = lstrDuplicate(pAliasDeviceInterfaceDetail->DevicePath);
            	    error = pAliasDeviceInterface ? NO_ERROR : ERROR_OUTOFMEMORY;
            	    HeapFree(hHeap, 0, pAliasDeviceInterfaceDetail);
            	} else {
            	    error = GetLastError();
            	}
            } else {
                error = GetLastError();
            }
        } else {
            error = GetLastError();
        }
        SetupDiDestroyDeviceInfoList(hdi);
    } else {
        error = GetLastError();
    }

    if (NO_ERROR == error)
    {
    	*ppAliasDeviceInterface = pAliasDeviceInterface;
    }

    return (NO_ERROR == error);
}

//=============================================================================
//
//      Reg helpers
//
//  The semantics of these functions are designed to be as similar to the
//  Win32 API registry functions as reasonably possible.
//
//=============================================================================

LONG RegPrepareEnum(HKEY hkey, PDWORD pcSubkeys, PTSTR *ppstrSubkeyNameBuffer, PDWORD pcchSubkeyNameBuffer)
{
    DWORD cSubkeys;
    DWORD cchMaxSubkeyName;
    LONG lresult;

    lresult = RegQueryInfoKey(hkey, NULL, NULL, NULL, &cSubkeys, &cchMaxSubkeyName, NULL, NULL, NULL, NULL, NULL, NULL);
    if (NO_ERROR == lresult) {
        PTSTR SubkeyName;
        SubkeyName = (PTSTR)HeapAlloc(hHeap, 0, (cchMaxSubkeyName+1) * sizeof(TCHAR));
        if (SubkeyName) {
		*pcSubkeys = cSubkeys;
		*ppstrSubkeyNameBuffer = SubkeyName;
		*pcchSubkeyNameBuffer = cchMaxSubkeyName+1;
	} else {
	    lresult = ERROR_OUTOFMEMORY;
	}
    }
    return lresult;
}

LONG RegEnumOpenKey(HKEY hkey, DWORD dwIndex, PTSTR SubkeyName, DWORD cchSubkeyName, REGSAM samDesired, PHKEY phkeyResult)
{
    LONG lresult;

    lresult = RegEnumKeyEx(hkey, dwIndex, SubkeyName, &cchSubkeyName, NULL, NULL, NULL, NULL);
    if (NO_ERROR == lresult) {
	HKEY hkeyResult;
	lresult = RegOpenKeyEx(hkey, SubkeyName, 0, samDesired, &hkeyResult);
	if (NO_ERROR == lresult) *phkeyResult = hkeyResult;
    }
    return lresult;
}

LONG RegDeleteKeyRecursive(HKEY hkey, PCTSTR pstrSubkey)
{
    HKEY hkeySub;
    LONG lresult;

    lresult = RegOpenKeyEx(hkey, pstrSubkey, 0, KEY_READ | KEY_WRITE, &hkeySub);
    if (NO_ERROR == lresult)
    {
	DWORD cSubkeys;
	DWORD cchSubkeyNameBuffer;
	PTSTR pstrSubkeyNameBuffer;

	lresult = RegPrepareEnum(hkeySub, &cSubkeys, &pstrSubkeyNameBuffer, &cchSubkeyNameBuffer);
	if (NO_ERROR == lresult)
	{
	    DWORD iSubkey;

	    for (iSubkey = 0; iSubkey < cSubkeys; iSubkey++)
	    {
		DWORD cchSubkeyNameBufferT;

		cchSubkeyNameBufferT = cchSubkeyNameBuffer;
		lresult = RegEnumKeyEx(hkeySub, iSubkey, pstrSubkeyNameBuffer, &cchSubkeyNameBufferT, NULL, NULL, NULL, NULL);
		if (NO_ERROR != lresult) break;

		lresult = RegDeleteKeyRecursive(hkeySub, pstrSubkeyNameBuffer);
		if (NO_ERROR != lresult) break;
	    }
	    HeapFree(hHeap, 0, pstrSubkeyNameBuffer);
	}
	RegCloseKey(hkeySub);
    }

    if (NO_ERROR == lresult) lresult = RegDeleteKey(hkey, pstrSubkey);

    return lresult;
}

//=============================================================================
//===   Utilities   ===
//=============================================================================
LONG XxNextId(HKEY hkey, PDWORD pId)
{
    HKEY hkeyGfx;
    DWORD Id;
    LONG lresult;

    lresult = RegCreateKeyEx(hkey, REGSTR_PATH_GFX, 0, NULL, 0, KEY_QUERY_VALUE | KEY_SET_VALUE, NULL, &hkeyGfx, NULL);
    if (NO_ERROR == lresult)
    {
	lresult = RegQueryDwordValue(hkeyGfx, REGSTR_VAL_GFX_IDGEN, &Id);
	if (ERROR_FILE_NOT_FOUND == lresult) {
	    Id = 0;
	    lresult = NO_ERROR;
	}
	if (NO_ERROR == lresult) {
	    Id++;
	    lresult = RegSetDwordValue(hkeyGfx, REGSTR_VAL_GFX_IDGEN, Id);
	}
	RegCloseKey(hkeyGfx);
    }

    if (NO_ERROR == lresult) *pId = Id;
    return lresult;
}

LONG LmNextId(PDWORD pId)
{
    return XxNextId(HKEY_LOCAL_MACHINE, pId);
}

LONG CuNextId(CUser *pUser, PDWORD pId)
{
    HKEY hkeyCu;
    LONG lresult;
    lresult = pUser->RegOpen(KEY_READ, &hkeyCu);
    if (!lresult)
    {
	lresult = XxNextId(hkeyCu, pId);
	RegCloseKey(hkeyCu);
    }
    return lresult;
}

BOOL ZoneTypeHasRender(IN ULONG Type)
{
   if (ZONETYPE_RENDERCAPTURE == Type) return TRUE;
   if (ZONETYPE_RENDER == Type) return TRUE;
   return FALSE;
}

BOOL ZoneTypeHasCapture(IN ULONG Type)
{
   if (ZONETYPE_RENDERCAPTURE == Type) return TRUE;
   if (ZONETYPE_CAPTURE == Type) return TRUE;
   return FALSE;
}
	
void LockGlobalLists(void)
{
    ASSERT(gplistZoneFactories);
    ASSERT(gplistGfxFactories);
    ASSERT(gplistCuUserLoads);

    gplistZoneFactories->Lock();
    gplistGfxFactories->Lock();
    gplistCuUserLoads->Lock();

    return;
}

void UnlockGlobalLists(void)
{
    ASSERT(gplistZoneFactories);
    ASSERT(gplistGfxFactories);
    ASSERT(gplistCuUserLoads);

    gplistCuUserLoads->Unlock();
    gplistGfxFactories->Unlock();
    gplistZoneFactories->Unlock();
    
    return;
}

void LockSysaudio(void)
{
    ASSERT(gfCsSysaudio);
    EnterCriticalSection(&gcsSysaudio);
    return;
}

void UnlockSysaudio(void)
{
    ASSERT(gfCsSysaudio);
    LeaveCriticalSection(&gcsSysaudio);
    return;
}

//=============================================================================
//===   CuUserLoad   ===
//=============================================================================
CCuUserLoad::CCuUserLoad(CUser *pUser)
{
    ASSERT(pUser);
    
    m_User = pUser;
    m_ZoneFactoryDi = NULL;
    m_GfxFactoryDi = NULL;
    m_FilterHandle = INVALID_HANDLE_VALUE;
    m_ErrorFilterCreate = NO_ERROR;
    m_pZoneFactory = NULL;
    m_posZoneGfxList = NULL;
}

CCuUserLoad::~CCuUserLoad(void)
{
    RemoveFromZoneGraph();
    HeapFreeIfNotNull(hHeap, 0, m_ZoneFactoryDi);
    HeapFreeIfNotNull(hHeap, 0, m_GfxFactoryDi);
}

/*--------------------------------------------------------------------------

   CCuUserLoad::AddGfxToGraph

   Adds an instantiated gfx to the sysaudio graph for a zone factory.
  
   Arguments:
      IN CCuUserLoad *pCuUserLoad : The gfx to add to the graph

      OUT POSITION *pZoneGfxListPosition : The resulting list position
          in the zone factory's list of gfxs.
  
   Return value:
      LONG : error code defined in winerror.h
  	ERROR_OUTOFMEMORY :
  
   Comments:
     The caller should have already instantiated the gfx.

     This function walks the zone factory's gfx list (either render or
     capture list depending on the type of gfx being added) to find an
     insertion point.  The gfx list is sorted by gfx order.  Finally, the
     resulting list position is returned to the caller so that it can be
     passed back to RemoveFromGraph or ChangeGfxOrderInGraph later.
  
-------------------------------------------------------------------------*/
LONG CCuUserLoad::AddGfxToGraph(void)
{
    CListCuUserLoads *plistGfxs;
    POSITION posNextGfx;
    CCuUserLoad *pNextGfx;
    LONG error;

    // dprintf(TEXT("CCuUserLoad::AddGfxToGraph\n"));

    ASSERT(INVALID_HANDLE_VALUE != m_FilterHandle);
    ASSERT(NULL == m_posZoneGfxList);
    
    error = NO_ERROR;

    if (GFXTYPE_CAPTURE == m_Type) plistGfxs = &m_pZoneFactory->m_listCaptureGfxs;
    else if (GFXTYPE_RENDER == m_Type) plistGfxs = &m_pZoneFactory->m_listRenderGfxs;
    else ASSERT(FALSE);

    //
    // Find possible insertion point for the new gfx by scanning list up to
    // a point where all previous gfxs have lower order values.
    //
    for (posNextGfx = plistGfxs->GetHeadPosition(); posNextGfx; plistGfxs->GetNext(posNextGfx))
    {
        pNextGfx = plistGfxs->GetAt(posNextGfx);
        if (m_Order <= pNextGfx->m_Order) break;
    }

    //
    // If there is a conflict with an existing gfx at the insertion point
    // then either shift the conflicting gfx to a higher order or bump the
    // insertion point and the new gfx's order and try again, depending
    // on whether this gfx "wins the conflict" with the conflicting gfx.
    //
    while (!error && posNextGfx && (m_Order == pNextGfx->m_Order))
    {
        if (WinsConflictWith(pNextGfx))
        {
            error = pNextGfx->ModifyOrder(pNextGfx->m_Order + 1);
        }
        else
        {
            plistGfxs->GetNext(posNextGfx);
            if (posNextGfx) pNextGfx = plistGfxs->GetAt(posNextGfx);
            m_Order++;
        }
    }

    //
    // We've finally determined the proper insertion point and resolved any
    // conflicts.  Insert the gfx into the gfx list, add the gfx to the
    // sysaudio graph, and finally persist the gfx again if the final order
    // is different than original.
    //
    if (!error)
    {
        POSITION posGfx;
        
        posGfx = plistGfxs->InsertBefore(posNextGfx, this);
    	if (!posGfx) error = ERROR_OUTOFMEMORY;
    	
    	if (!error)
    	{
    	    // ISSUE-2000/09/21-FrankYe Need to pass friendly name
            error = SadAddGfxToZoneGraph(ghSysaudio, m_FilterHandle, TEXT("ISSUE-2000//09//21-FrankYe Need to pass friendly name"), m_ZoneFactoryDi, m_Type, m_Order);
            if (error) dprintf(TEXT("CCuUserLoad::AddGfxToZoneGraph : error: SadAddGfxToZoneGraph returned %d\n"), error);
    	    if (!error) m_posZoneGfxList = posGfx;
    	    else plistGfxs->RemoveAt(posGfx);
    	}
    }

    return error;
}

//--------------------------------------------------------------------------;
//
// CCuUserLoad::AddToZoneGraph
//
// Instantiates and adds a GFX filter to a zone graph.
//
// Arguments:
//    CZoneFactory *pZoneFactory : Identifies the zone to which the GFX
// is added.
//
// Return value:
//    LONG : error code defined in winerror.h
//
// Comments:
//    Instantiates the filter.
//    Advises filter of target device id.
//    Unserializes persistent properties to filter.
//    Calls AddToGraph on the ZoneFactory.
//
//--------------------------------------------------------------------------;
LONG CCuUserLoad::AddToZoneGraph(CZoneFactory *pZoneFactory)
{
    LONG error;

    dprintf(TEXT("CCuUserLoad::AddToZoneGraph : note: instantiating %s Gfx[%s] in Zone[%s]\n"), (GFXTYPE_RENDER == m_Type) ? TEXT("render") : TEXT("capture"), m_GfxFactoryDi, m_ZoneFactoryDi);

    ASSERT(NULL == m_pZoneFactory);
    ASSERT(NULL == m_posZoneGfxList);    
    ASSERT(INVALID_HANDLE_VALUE == m_FilterHandle);

    //
    // Instantiate the GFX filter
    //
    m_FilterHandle = CreateFile(m_GfxFactoryDi,
                                GENERIC_READ | GENERIC_WRITE,
                                0,
			        NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                                NULL);
    error = (INVALID_HANDLE_VALUE == m_FilterHandle) ? GetLastError() : NO_ERROR;


    //
    // Advise filter of the zone's target hardware IDs
    //
    if (!error)
    {
        switch(m_Type)
        {
            case GFXTYPE_RENDER:
                KsSetAudioGfxRenderTargetDeviceId(m_FilterHandle, pZoneFactory->GetTargetHardwareId());
                break;
            case GFXTYPE_CAPTURE:
                KsSetAudioGfxCaptureTargetDeviceId(m_FilterHandle, pZoneFactory->GetTargetHardwareId());
                break;
            case GFXTYPE_RENDERCAPTURE:
                // NTRAID#298244-2000/12/18-FrankYe Someday implement RENDERCAPTURE GFXs
                ASSERT(FALSE);
                break;
            default:
                ASSERT(FALSE);
        }
    }

    //
    // Restore filter settings from registry
    //
    if (!error)
    {
        HKEY hkFilterSettings;
        if (NO_ERROR == RegOpenFilterKey(REGSTR_PATH_GFXUSERLOADID_FILTERSETTINGS, KEY_READ, &hkFilterSettings)) {
            KsUnserializeFilterStateFromReg(m_FilterHandle, hkFilterSettings);
            RegCloseKey(hkFilterSettings);
        }
    }

    //
    // Save pointer to the zone factory to which we're adding this gfx
    //
    if (!error)
    {
    	m_pZoneFactory = pZoneFactory;
    }

    //
    // Tell zone factory to add this gfx to its graph
    //
    if (!error)
    {
    	error = AddGfxToGraph();
    }

    //
    // Unwind if error
    //
    if (error)
    {
        if (INVALID_HANDLE_VALUE != m_FilterHandle)
        {
            CloseHandle(m_FilterHandle);
            m_FilterHandle = INVALID_HANDLE_VALUE;
        }
    }

    m_ErrorFilterCreate = error;
    return error;
}

/*--------------------------------------------------------------------------

   CCuUserLoad::ChangeGfxOrderInGraph

   Changes the order of a gfx already in the zone graph.
  
   Arguments:
      IN ULONG NewGfxOrder : The new order value for the gfx.

   Return value:
      LONG : error code defined in winerror.h
        ERROR_INVALID_PARAMETER : A gfx already occupies the
          requested order.
  	ERROR_OUTOFMEMORY :
  
   Comments:
  
-------------------------------------------------------------------------*/
LONG CCuUserLoad::ChangeGfxOrderInGraph(IN ULONG NewGfxOrder)
{
    CListCuUserLoads *plistGfxs;
    CCuUserLoad *pNextGfx;
    POSITION posNextGfx;
    LONG error;

    // dprintf(TEXT("CCuUserLoad::ChangeGfxOrderInGraph\n"));

    error = NO_ERROR;
    
    if (GFXTYPE_CAPTURE == m_Type) plistGfxs = &m_pZoneFactory->m_listCaptureGfxs;
    else if (GFXTYPE_RENDER == m_Type) plistGfxs = &m_pZoneFactory->m_listRenderGfxs;
    else ASSERT(FALSE);

    error = SadRemoveGfxFromZoneGraph(ghSysaudio, m_FilterHandle, TEXT("ISSUE-2000//09//21-FrankYe Need to pass friendly name"), m_ZoneFactoryDi, m_Type, m_Order);
    if (error) dprintf(TEXT("CCuUserLoad::ChangeGfxToZoneGraph : error: SadRemoveGfxFromZoneGraph returned %d\n"), error);

    if (!error)
    {
    	POSITION posOriginalNextGfx;

    	posOriginalNextGfx = m_posZoneGfxList;
    	plistGfxs->GetNext(posOriginalNextGfx);
    	
    	// Find insertion position
    	for (posNextGfx = plistGfxs->GetHeadPosition(); posNextGfx; plistGfxs->GetNext(posNextGfx))
    	{
    	    pNextGfx = plistGfxs->GetAt(posNextGfx);
    	    if (NewGfxOrder <= pNextGfx->m_Order) break;
    	}
    	// posNextGfx is now the list position after the insertion point

    	plistGfxs->MoveBefore(posNextGfx, m_posZoneGfxList);
    	
    	if (posNextGfx && (NewGfxOrder == pNextGfx->m_Order))
    	{
            dprintf(TEXT("CCuUserLoad::ChangeGfxOrderInGraph : note: attempting to move conflicting GFX ID %08X moving from %d to %d\n"),
            	pNextGfx->GetId(), pNextGfx->m_Order, pNextGfx->m_Order + 1);
            
    	    plistGfxs->SetAt(m_posZoneGfxList, NULL);
            error = pNextGfx->ModifyOrder(pNextGfx->m_Order + 1);
            plistGfxs->SetAt(m_posZoneGfxList, this);
    	}

        if (!error)
    	{
            // ISSUE-2000/09/21-FrankYe Need to pass friendly name
            error = SadAddGfxToZoneGraph(ghSysaudio, m_FilterHandle, TEXT("ISSUE-2000//09//21-FrankYe Need to pass friendly name"), m_ZoneFactoryDi, m_Type, NewGfxOrder);
            if (error) dprintf(TEXT("CCuUserLoadFactory::ChangeGfxOrderInGraph : error: SadAddGfxToZoneGraph returned %d\n"), error);

            if (!error)
            {
    	        m_Order = NewGfxOrder;
    	        if (!error) Write();
            }
    	}
    	else
    	{
    	    plistGfxs->MoveBefore(posOriginalNextGfx, m_posZoneGfxList);
    	}
    	
    }

    return error;
}

LONG CCuUserLoad::CreateFromAutoLoad(ULONG CuAutoLoadId)
{
    LONG lresult;
    CCuAutoLoad *pCuAutoLoad = new CCuAutoLoad(m_User);

    ASSERT(!m_GfxFactoryDi);
    ASSERT(!m_ZoneFactoryDi);

    if (pCuAutoLoad)
    {
	lresult = pCuAutoLoad->Initialize(CuAutoLoadId);
	if (!lresult)
	{
	    m_CuUserLoadId = CuAutoLoadId;
	    m_CuAutoLoadId = CuAutoLoadId;
	    m_Type = pCuAutoLoad->GetType();
            m_Order = 0;

	    m_GfxFactoryDi = lstrDuplicate(pCuAutoLoad->GetGfxFactoryDi());
	    if (m_GfxFactoryDi) m_ZoneFactoryDi = lstrDuplicate(pCuAutoLoad->GetZoneFactoryDi());
	    if (!m_ZoneFactoryDi) lresult = ERROR_OUTOFMEMORY;
	}
	delete pCuAutoLoad;
    } else {
	lresult = ERROR_OUTOFMEMORY;
    }

    return lresult;
}

LONG CCuUserLoad::CreateFromUser(PCTSTR GfxFactoryDi, PCTSTR ZoneFactoryDi, ULONG Type, ULONG Order)
{
    LONG lresult;

    ASSERT((GFXTYPE_RENDER == Type) || (GFXTYPE_CAPTURE == Type));
    ASSERT(GFX_MAXORDER >= Order);
    
    ASSERT(!m_GfxFactoryDi);
    ASSERT(!m_ZoneFactoryDi);

    lresult = CuNextId(m_User, &m_CuUserLoadId);
    if (!lresult)
    {
	m_CuAutoLoadId = 0;
	m_Type = Type;
        m_Order = Order;

	m_GfxFactoryDi = lstrDuplicate(GfxFactoryDi);
	m_ZoneFactoryDi = lstrDuplicate(ZoneFactoryDi);
	if (!m_GfxFactoryDi || !m_ZoneFactoryDi) lresult = ERROR_OUTOFMEMORY;
    }

    return lresult;
}

LONG CCuUserLoad::Erase(void)
{
    HKEY hkeyCu;
    HKEY hkeyCuUserLoadEnum;
    LONG lresult;

    lresult = m_User->RegOpen(KEY_READ, &hkeyCu);
    if (!lresult)
    {
	lresult = RegOpenKeyEx(hkeyCu, REGSTR_PATH_GFXUSERLOAD, 0, KEY_CREATE_SUB_KEY, &hkeyCuUserLoadEnum);
	if (!lresult)
	{
	    TCHAR szCuUserLoad[9];

	    wsprintf(szCuUserLoad, TEXT("%08X"), m_CuUserLoadId);
	    lresult = RegDeleteKeyRecursive(hkeyCuUserLoadEnum, szCuUserLoad);

	    RegCloseKey(hkeyCuUserLoadEnum);
	}
	RegCloseKey(hkeyCu);
    }

    return lresult;
}

/*-----------------------------------------------------------------------------
    CCuUserLoad::GetGfxFactoryClsid
    
    Uses the specified list of Gfx factories (CListGfxFactories) to find the
    user interface CLSID of the Gfx factory whose device interface matches the
    one associated with this CCuUserLoad object

    Caller must acquire locks on rlistGfxFactories
    
-----------------------------------------------------------------------------*/

LONG CCuUserLoad::GetGfxFactoryClsid(CListGfxFactories &rlistGfxFactories, LPCLSID pClsid)
{
    CGfxFactory *pGfxFactory;
    LONG lresult;

    ASSERT(m_GfxFactoryDi);

    pGfxFactory = CGfxFactory::ListSearchOnDi(rlistGfxFactories, m_GfxFactoryDi);
    if (pGfxFactory)
    {
	*pClsid = pGfxFactory->GetClsid();
	lresult = NO_ERROR;
    } else {
	// ISSUE-2000/09/15-FrankYe : Best error code?
	*pClsid = GUID_NULL;
	lresult = ERROR_DEVICE_NOT_AVAILABLE;
    }

    return lresult;
}

PCTSTR CCuUserLoad::GetGfxFactoryDi(void)
{
    return m_GfxFactoryDi;
}

HANDLE CCuUserLoad::GetFilterHandle(void)
{
    ASSERT((INVALID_HANDLE_VALUE != m_FilterHandle) || (NO_ERROR != m_ErrorFilterCreate));
    SetLastError(m_ErrorFilterCreate);
    return m_FilterHandle;
}

DWORD CCuUserLoad::GetId(void)
{
    return m_CuUserLoadId;
}

ULONG CCuUserLoad::GetOrder(void)
{
    return m_Order;
}

ULONG CCuUserLoad::GetType(void)
{
    return m_Type;
}

PCTSTR CCuUserLoad::GetZoneFactoryDi(void)
{
    return m_ZoneFactoryDi;
}

LONG CCuUserLoad::Initialize(PCTSTR pstrUserLoadId)
{
    HKEY hkeyCu;
    HKEY hkeyCuUserLoadEnum;
    PTSTR pstrEnd;
    LONG lresult;
    
    m_CuUserLoadId = _tcstoul((PTSTR)pstrUserLoadId, &pstrEnd, 16);

    // dprintf(TEXT("CCuUserLoad::Initialize : subkey [%s] CuUserLoadId=%08X\n"), pstrUserLoadId, m_CuUserLoadId);
    lresult = m_User->RegOpen(KEY_READ, &hkeyCu);
    if (!lresult)
    {
	lresult = RegOpenKeyEx(hkeyCu, REGSTR_PATH_GFXUSERLOAD, 0, KEY_ENUMERATE_SUB_KEYS, &hkeyCuUserLoadEnum);
	if (!lresult)
	{
	    HKEY hkeyCuUserLoad;

	    lresult = RegOpenKeyEx(hkeyCuUserLoadEnum, pstrUserLoadId, 0, KEY_QUERY_VALUE, &hkeyCuUserLoad);
	    if (!lresult)
	    {
		lresult = RegQuerySzValue(hkeyCuUserLoad, REGSTR_VAL_GFX_ZONEDI, &m_ZoneFactoryDi);
		if (!lresult) lresult = RegQuerySzValue(hkeyCuUserLoad, REGSTR_VAL_GFX_GFXDI, &m_GfxFactoryDi);
		if (!lresult) lresult = RegQueryDwordValue(hkeyCuUserLoad, REGSTR_VAL_GFX_TYPE, &m_Type);
                if (!lresult) lresult = RegQueryDwordValue(hkeyCuUserLoad, REGSTR_VAL_GFX_ORDER, &m_Order);
                if (!lresult && (m_Order > GFX_MAXORDER)) lresult = ERROR_BADDB;
		if (!lresult)
		{
		    lresult = RegQueryDwordValue(hkeyCuUserLoad, REGSTR_VAL_GFX_CUAUTOLOADID, &m_CuAutoLoadId);
		    if (!lresult && 0 != m_CuAutoLoadId)
		    {
			CCuAutoLoad *pCuAutoLoad = new CCuAutoLoad(m_User);
			if (pCuAutoLoad)
			{
			    lresult = pCuAutoLoad->Initialize(m_CuAutoLoadId);
			    delete pCuAutoLoad;
			} else {
			    lresult = ERROR_OUTOFMEMORY;
			}
		    } else if (ERROR_FILE_NOT_FOUND == lresult) {
			m_CuAutoLoadId = 0;
			lresult = NO_ERROR;
		    }
		}
		RegCloseKey(hkeyCuUserLoad);
	    }
	    RegCloseKey(hkeyCuUserLoadEnum);
	}
	RegCloseKey(hkeyCu);
    }
    return lresult;
}

/*--------------------------------------------------------------------------

   CCuUserLoad::WinsConflictWith

   Attempts to determine which gfx factory should be given priority (i.e.,
   be closer to the render or capture device).
  
   Arguments:
      IN CCuUserLoad pOther : Other gfx to compare against.
      
   Return value:
      BOOL : True if this gfx wins the conflict.
 
   Comments:
     If both gfxs have LmAutoLoadIds then we compare those.  The higher ID
     (more recently insalled) wins.  If only one has an LmAutoLoadId then it
     wins because we favor autoload GFXs over generic GFXs.  If neither have
     LmAutoLoadIds, then this CuUserLoad object wins, arbitrarily.
  
-------------------------------------------------------------------------*/
BOOL CCuUserLoad::WinsConflictWith(IN CCuUserLoad *that)
{
    ULONG thisId = 0;
    ULONG thatId = 0;;
    
    if (this->m_CuAutoLoadId)
    {
        CCuAutoLoad *pCuAutoLoad = new CCuAutoLoad(m_User);
        if (pCuAutoLoad)
        {
    	    if (NO_ERROR == pCuAutoLoad->Initialize(this->m_CuAutoLoadId))
    	    {
    	        thisId = pCuAutoLoad->GetLmAutoLoadId();
    	    }
    	    delete pCuAutoLoad;
        }
    }

    if (that->m_CuAutoLoadId)
    {
        CCuAutoLoad *pCuAutoLoad = new CCuAutoLoad(m_User);
        if (pCuAutoLoad)
        {
    	    if (NO_ERROR == pCuAutoLoad->Initialize(that->m_CuAutoLoadId))
    	    {
    	        thatId = pCuAutoLoad->GetLmAutoLoadId();
    	    }
    	    delete pCuAutoLoad;
        }
    }

    return (thisId >= thatId);
}

//--------------------------------------------------------------------------;
//
// CCuUserLoad::ModifyOrder
//
// Modfies the position of a gfx in a zone graph.
//
// Arguments:
//    IN ULONG NewOrder : The new position for the gfx.
//
// Return value:
//    LONG : error code defined in winerror.h
//	ERROR_INVALID_FUNCTION : gfx not yet in a zone graph
//
// Comments:
//    The gfx should already be in a zone graph before calling this
// function.  Otherwise, it returns an error.  This function calls
// ChangeGfxOrderInGraph on the ZoneFactory to do the buld of the work.
//
//--------------------------------------------------------------------------;
LONG CCuUserLoad::ModifyOrder(IN ULONG NewOrder)
{
    LONG error = NO_ERROR;

    if (NO_ERROR != m_ErrorFilterCreate) return m_ErrorFilterCreate;

    ASSERT(INVALID_HANDLE_VALUE != m_FilterHandle);
    ASSERT(m_pZoneFactory);
    ASSERT(m_posZoneGfxList);

    if (m_Order != NewOrder) error = ChangeGfxOrderInGraph(NewOrder);
    else dprintf(TEXT("CCuUserLoad::ModifyOrder : warning: new order same as old\n"));

    return error;
}

LONG CCuUserLoad::RegCreateFilterKey(IN PCTSTR SubKey, IN REGSAM samDesired, OUT PHKEY phkResult)
{
    HKEY hkCu;
    LONG result;

    result = m_User->RegOpen(KEY_READ, &hkCu);
    if (NO_ERROR == result)
    {
        HKEY hkCuUserLoad;
        TCHAR strRegPath[] = REGSTR_PATH_GFXUSERLOAD TEXT("\\00000000");

        wsprintf(strRegPath, TEXT("%s\\%08X"), REGSTR_PATH_GFXUSERLOAD, m_CuUserLoadId);

	result = RegOpenKeyEx(hkCu, strRegPath, 0, KEY_CREATE_SUB_KEY, &hkCuUserLoad);
	if (NO_ERROR == result)
	{
            result = RegCreateKeyEx(hkCuUserLoad, SubKey, 0, NULL, REG_OPTION_NON_VOLATILE, samDesired, NULL, phkResult, NULL);

            RegCloseKey(hkCuUserLoad);
        }

        RegCloseKey(hkCu);
    }

    return result;
}

LONG CCuUserLoad::RegOpenFilterKey(IN PCTSTR SubKey, IN REGSAM samDesired, OUT PHKEY phkResult)
{
    HKEY hkCu;
    LONG result;

    result = m_User->RegOpen(KEY_READ, &hkCu);
    if (NO_ERROR == result)
    {
        HKEY hkCuUserLoad;
        TCHAR strRegPath[] = REGSTR_PATH_GFXUSERLOAD TEXT("\\00000000");

        wsprintf(strRegPath, TEXT("%s\\%08X"), REGSTR_PATH_GFXUSERLOAD, m_CuUserLoadId);

	result = RegOpenKeyEx(hkCu, strRegPath, 0, KEY_ENUMERATE_SUB_KEYS, &hkCuUserLoad);
	if (NO_ERROR == result)
	{
            result = RegOpenKeyEx(hkCuUserLoad, SubKey, 0, samDesired, phkResult);

            RegCloseKey(hkCuUserLoad);
        }

        RegCloseKey(hkCu);
    }

    return result;
}

/*--------------------------------------------------------------------------

   CCuUserLoad::RemoveFromGraph

   Removes a gfx from the zone factory's sysaudio graph.
  
   Arguments:

   Return value:
      LONG : error code defined in winerror.h
 
   Comments:
  
-------------------------------------------------------------------------*/
LONG CCuUserLoad::RemoveFromGraph(void)
{
    CListCuUserLoads *plistGfxs = NULL;
    LONG error;
 
    ASSERT(INVALID_HANDLE_VALUE != m_FilterHandle);
    
    error = NO_ERROR;
    
    if (GFXTYPE_CAPTURE == m_Type) plistGfxs = &m_pZoneFactory->m_listCaptureGfxs;
    else if (GFXTYPE_RENDER == m_Type) plistGfxs = &m_pZoneFactory->m_listRenderGfxs;
    else ASSERT(FALSE);

    //
    // Command Sysaudio to disconnect the filter from the
    // zone's graph.
    //
    	    
    // ISSUE-2000/09/21-FrankYe Need to pass friendly name
    error = SadRemoveGfxFromZoneGraph(ghSysaudio, m_FilterHandle, TEXT("ISSUE-2000//09//21-FrankYe Need to pass friendly name"), m_ZoneFactoryDi, m_Type, m_Order);
    if (error) dprintf(TEXT("CCuUserLoad::RemoveFromGraph : error: SadRemoveGfxFromZoneGraph returned %d\n"), error);

    if (!error && plistGfxs) plistGfxs->RemoveAt(m_posZoneGfxList);

    return error;
}

//--------------------------------------------------------------------------;
//
// CCuUserLoad::RemoveFromZoneGraph
//
// Removes a gfx from its zone graph.
//
// Arguments:
//
// Return value:
//    void
//
// Comments:
//  If the GFX has been added to a zone graph, this function removes it from
//  the graph.  First it persists any settings on the GFX, then it calls
//  RemoveFromGraph on the ZoneFactory.  Finally it finally closes the GFX
//  handle.
//  
//  This method is called from this object's destructor, so it is important
//  that this function do its best to handle any errors.
//
//--------------------------------------------------------------------------;
void CCuUserLoad::RemoveFromZoneGraph(void)
{
    if (INVALID_HANDLE_VALUE != m_FilterHandle)
    {
        HKEY hkFilterSettings;
        LONG error;

        ASSERT(m_pZoneFactory);
        ASSERT(m_posZoneGfxList);
        ASSERT(INVALID_HANDLE_VALUE != ghSysaudio);
        
        //
        // Save filter settings to registry
        //
        if (NO_ERROR == RegCreateFilterKey(REGSTR_PATH_GFXUSERLOADID_FILTERSETTINGS, KEY_WRITE, &hkFilterSettings)) {
            KsSerializeFilterStateToReg(m_FilterHandle, hkFilterSettings);
            RegCloseKey(hkFilterSettings);
        }

        error = RemoveFromGraph();
        m_pZoneFactory = NULL;
        m_posZoneGfxList = NULL;

        m_ErrorFilterCreate = error;
        
	if (!error)
	{
	    CloseHandle(m_FilterHandle);
            m_FilterHandle = INVALID_HANDLE_VALUE;
	}
	
    }

    return;
}

LONG CCuUserLoad::Write(void)
{
    HKEY hkeyCu;
    HKEY hkeyCuUserLoadEnum;
    LONG lresult;

    lresult = m_User->RegOpen(KEY_READ, &hkeyCu);
    if (!lresult)
    {
	lresult = RegCreateKeyEx(hkeyCu, REGSTR_PATH_GFXUSERLOAD, 0, NULL, 0, KEY_CREATE_SUB_KEY, NULL, &hkeyCuUserLoadEnum, NULL);
	if (NO_ERROR == lresult)
	{
	    TCHAR szUserLoad[9];
	    HKEY hkeyCuUserLoad;

	    wsprintf(szUserLoad, TEXT("%08X"), m_CuUserLoadId);
	    lresult = RegCreateKeyEx(hkeyCuUserLoadEnum, szUserLoad, 0, NULL, 0, KEY_SET_VALUE, NULL, &hkeyCuUserLoad, NULL);
	    if (!lresult)
	    {
		lresult = RegSetSzValue(hkeyCuUserLoad, REGSTR_VAL_GFX_GFXDI, m_GfxFactoryDi);
		if (!lresult) lresult = RegSetSzValue(hkeyCuUserLoad, REGSTR_VAL_GFX_ZONEDI, m_ZoneFactoryDi);
		if (!lresult) lresult = RegSetDwordValue(hkeyCuUserLoad, REGSTR_VAL_GFX_TYPE, m_Type);
		if (!lresult) lresult = RegSetDwordValue(hkeyCuUserLoad, REGSTR_VAL_GFX_ORDER, m_Order);
		if (!lresult && (0 != m_CuAutoLoadId)) lresult = RegSetDwordValue(hkeyCuUserLoad, REGSTR_VAL_GFX_CUAUTOLOADID, m_CuAutoLoadId);

		RegCloseKey(hkeyCuUserLoad);

		// Any errors writing the values would leave an invalid reg entry.  So delete if errors
		if (lresult) RegDeleteKey(hkeyCuUserLoadEnum, szUserLoad);
	    }

	    RegCloseKey(hkeyCuUserLoadEnum);
	}
	RegCloseKey(hkeyCu);
    }
    return lresult;
}

/*-----------------------------------------------------------------------------

    CCuUserLoad::FillListFromReg
    
    Adds elements to the specified list of user-loads (CListCuUserLoads) based
    on the contents of the REGSTR_PATH_GFXUSERLOAD registry information
    
    Caller must acquire any necessary locks on rlistCuUserLoads
    
-----------------------------------------------------------------------------*/
void CCuUserLoad::FillListFromReg(CUser *pUser, CListCuUserLoads &rlistCuUserLoads)
{
    HKEY hkeyCu;
    HKEY hkeyCuUserLoadEnum;
    LONG lresult;

    ASSERT(pUser);

    lresult = pUser->RegOpen(KEY_READ, &hkeyCu);
    if (!lresult)
    {
	lresult = RegOpenKeyEx(hkeyCu, REGSTR_PATH_GFXUSERLOAD, 0, KEY_READ, &hkeyCuUserLoadEnum);
	if (!lresult)
	{
	    DWORD cSubkeys;
	    DWORD cchSubkeyNameBuffer;
	    PTSTR pstrSubkeyNameBuffer;

	    lresult = RegPrepareEnum(hkeyCuUserLoadEnum, &cSubkeys, &pstrSubkeyNameBuffer, &cchSubkeyNameBuffer);
	    if (NO_ERROR == lresult)
	    {
		CListCuUserLoads listCuUserLoadsErase;

                lresult = listCuUserLoadsErase.Initialize();
                if (!lresult)
                {
                    POSITION pos;
                    DWORD dwIndex;

                    for (dwIndex = 0; dwIndex < cSubkeys; dwIndex++)
                    {
                        DWORD cchSubkeyNameBufferT;
    
                        cchSubkeyNameBufferT = cchSubkeyNameBuffer;
                        lresult = RegEnumKeyEx(hkeyCuUserLoadEnum, dwIndex, pstrSubkeyNameBuffer, &cchSubkeyNameBufferT, NULL, NULL, NULL, NULL);
                        if (!lresult)
                        {
                            CCuUserLoad *pCuUserLoad = new CCuUserLoad(pUser);
                            if (pCuUserLoad)
                            {
                                lresult = pCuUserLoad->Initialize(pstrSubkeyNameBuffer);
                                if (ERROR_FILE_NOT_FOUND == lresult) {
                                    if (!listCuUserLoadsErase.AddTail(pCuUserLoad))
                                    {
                                        lresult = ERROR_OUTOFMEMORY;
                                        delete pCuUserLoad;
                                    }
                                } else if (NO_ERROR == lresult) {
                                    if (!rlistCuUserLoads.AddTail(pCuUserLoad))
                                    {
                                        lresult = ERROR_OUTOFMEMORY;
                                        delete pCuUserLoad;
                                    }
                                } else {
                                    delete pCuUserLoad;
                                }
                            } else {
                                lresult = ERROR_OUTOFMEMORY;
                            }
                        }
                    }

                    pos = listCuUserLoadsErase.GetHeadPosition();
                    while (pos)
                    {
                        CCuUserLoad *pCuUserLoad = listCuUserLoadsErase.GetNext(pos);
                        pCuUserLoad->Erase();
                        delete pCuUserLoad;
                    }
		}

	    }

	    RegCloseKey(hkeyCuUserLoadEnum);
	}
        else
        {
    	    // dprintf(TEXT("CCuUserLoad::FillListFromReg : error: RegOpenKeyEx returned %d\n"), lresult);
        }
  
	RegCloseKey(hkeyCu);
    }
    else
    {
    	dprintf(TEXT("CCuUserLoad::FillListFromReg : error: pUser->RegOpen returned %d\n"), lresult);
    }
    
    return;
}

/*-----------------------------------------------------------------------------
    CCuUserLoad::Scan
    
    The caller must acquire any locks required for rlistZoneFactories and
    rlistGfxFactories
    
-----------------------------------------------------------------------------*/
LONG CCuUserLoad::Scan(CListZoneFactories &rlistZoneFactories, CListGfxFactories &rlistGfxFactories)
{
    LONG lresult;

    // dprintf(TEXT("CCuUserLoad::Scan\n"));

    if (m_CuAutoLoadId != 0)
    {
	// Confirm the CuAutoLoad is still valid
	CCuAutoLoad *pCuAutoLoad = new CCuAutoLoad(m_User);
	if (pCuAutoLoad)
	{
	    lresult = pCuAutoLoad->Initialize(m_CuAutoLoadId);
	    delete pCuAutoLoad;
	} else {
	    lresult = ERROR_OUTOFMEMORY;
	}
    } else {
	lresult = NO_ERROR;
    }

    LockSysaudio();

    if (!lresult && (INVALID_HANDLE_VALUE == m_FilterHandle) && (INVALID_HANDLE_VALUE != ghSysaudio))
    {
        // dprintf(TEXT("Checking Gfx[%s] and Zone[%s}\n"), m_GfxFactoryDi, m_ZoneFactoryDi);
	// See if this CuUserLoad needs loaded. It needs loaded if:
	//  a) The GfxFactory exists,
	//  b) The ZoneFactory exists
	//  c) The ZoneFactory is the proper type

	CZoneFactory *pZoneFactory = CZoneFactory::ListSearchOnDi(rlistZoneFactories, m_ZoneFactoryDi);
	if (pZoneFactory)
	{
	    CGfxFactory *pGfxFactory = CGfxFactory::ListSearchOnDi(rlistGfxFactories, m_GfxFactoryDi);
	    if (pGfxFactory)
	    {
	    	lresult = AddToZoneGraph(pZoneFactory);
	    }
	}

    }

    UnlockSysaudio();

    return lresult;
}

/*-----------------------------------------------------------------------------
    CCuUserLoad::ScanList
    
    This function walks all members of a user-load list (CListCuUserLoads)
    and invokes Scan on each of them.
    
    The caller must acquire any necessary lock on rlistCuUserLoads,
    rlistZoneFactories, and rlistGfxFactories.
    
-----------------------------------------------------------------------------*/
void CCuUserLoad::ScanList(CListCuUserLoads& rlistCuUserLoads, CListZoneFactories& rlistZoneFactories, CListGfxFactories& rlistGfxFactories)
{
    POSITION posNext;

    posNext = rlistCuUserLoads.GetHeadPosition();
    while (posNext)
    {
	POSITION posThis = posNext;
	CCuUserLoad& rCuUserLoad = *rlistCuUserLoads.GetNext(posNext);
	LONG lresult = rCuUserLoad.Scan(rlistZoneFactories, rlistGfxFactories);
	if (ERROR_FILE_NOT_FOUND == lresult)
	{
	    rCuUserLoad.Erase();
	    rlistCuUserLoads.RemoveAt(posThis);
	    delete &rCuUserLoad;
	}
    }

    return;
}

void CCuUserLoad::ListRemoveGfxFactoryDi(IN CListCuUserLoads &rlistCuUserLoads, IN PCTSTR DeviceInterface)
{
    POSITION pos;
    pos = rlistCuUserLoads.GetHeadPosition();
    while (pos) {
        CCuUserLoad& rCuUserLoad = *rlistCuUserLoads.GetNext(pos);
        if (!lstrcmpi(DeviceInterface, rCuUserLoad.GetGfxFactoryDi())) rCuUserLoad.RemoveFromZoneGraph();
    }
    return;
}

void CCuUserLoad::ListRemoveZoneFactoryDi(IN CListCuUserLoads &rlistCuUserLoads, IN PCTSTR DeviceInterface)
{
    POSITION pos;
    pos = rlistCuUserLoads.GetHeadPosition();
    while (pos) {
        CCuUserLoad& rCuUserLoad = *rlistCuUserLoads.GetNext(pos);
        if (!lstrcmpi(DeviceInterface, rCuUserLoad.GetZoneFactoryDi())) rCuUserLoad.RemoveFromZoneGraph();
    }
    return;
}

void CCuUserLoad::ListRemoveZoneFactoryDiRender(IN CListCuUserLoads &rlistCuUserLoads, IN PCTSTR DeviceInterface)
{
    POSITION pos;
    pos = rlistCuUserLoads.GetHeadPosition();
    while (pos) {
    	CCuUserLoad& rCuUserLoad = *rlistCuUserLoads.GetNext(pos);
        if (!lstrcmpi(DeviceInterface, rCuUserLoad.GetZoneFactoryDi()))
        {
            ULONG GfxType = rCuUserLoad.GetType();
            if ((GFXTYPE_RENDER == GfxType) || (GFXTYPE_RENDERCAPTURE == GfxType)) rCuUserLoad.RemoveFromZoneGraph();
        }
    }
}

void CCuUserLoad::ListRemoveZoneFactoryDiCapture(IN CListCuUserLoads &rlistCuUserLoads, IN PCTSTR DeviceInterface)
{
    POSITION pos;
    pos = rlistCuUserLoads.GetHeadPosition();
    while (pos) {
    	CCuUserLoad& rCuUserLoad = *rlistCuUserLoads.GetNext(pos);
        if (!lstrcmpi(DeviceInterface, rCuUserLoad.GetZoneFactoryDi()))
        {
            ULONG GfxType = rCuUserLoad.GetType();
            if ((GFXTYPE_CAPTURE == GfxType) || (GFXTYPE_RENDERCAPTURE == GfxType)) rCuUserLoad.RemoveFromZoneGraph();
        }
    }
}

//=============================================================================
//===   CuAutoLoad   ===
//=============================================================================
CCuAutoLoad::CCuAutoLoad(CUser *pUser)
{
    ASSERT(pUser);
    
    m_User = pUser;
    m_ZoneFactoryDi = NULL;
    m_GfxFactoryDi = NULL;
}

CCuAutoLoad::~CCuAutoLoad(void)
{
    HeapFreeIfNotNull(hHeap, 0, m_ZoneFactoryDi);
    HeapFreeIfNotNull(hHeap, 0, m_GfxFactoryDi);
}

LONG CCuAutoLoad::Create(PCTSTR ZoneFactoryDi, ULONG LmAutoLoadId)
{
	LONG lresult;
	CLmAutoLoad *pLmAutoLoad = new CLmAutoLoad;
	
	if (pLmAutoLoad)
	{
		lresult = pLmAutoLoad->Initialize(LmAutoLoadId);
		if (!lresult)
		{
			lresult = CuNextId(m_User, &m_CuAutoLoadId);
			if (!lresult)
			{
				m_LmAutoLoadId = LmAutoLoadId;
				m_Type = pLmAutoLoad->GetType();
				m_ZoneFactoryDi = lstrDuplicate(ZoneFactoryDi);
				if (m_ZoneFactoryDi) m_GfxFactoryDi = lstrDuplicate(pLmAutoLoad->GetGfxFactoryDi());
				if (!m_GfxFactoryDi) lresult = ERROR_OUTOFMEMORY;
			}
		}
		delete pLmAutoLoad;
	} else {
		lresult = ERROR_OUTOFMEMORY;
	}

	return lresult;
}

/*-----------------------------------------------------------------------------
    CCuAutoLoad::Erase
    
    This function erases the registry data representing this CCuAutoLoad object.
    
-----------------------------------------------------------------------------*/
LONG CCuAutoLoad::Erase(void)
{
    HKEY hkeyCu;
    LONG lresult;

    lresult = m_User->RegOpen(KEY_READ, &hkeyCu);
    if (!lresult)
    {
	HKEY hkeyCuAutoLoadEnum;

	lresult = RegOpenKeyEx(hkeyCu, REGSTR_PATH_GFXAUTOLOAD, 0, KEY_WRITE, &hkeyCuAutoLoadEnum);
	if (!lresult)
	{
	    TCHAR szCuAutoLoad[9];

	    wsprintf(szCuAutoLoad, TEXT("%08X"), m_CuAutoLoadId);
            lresult = RegDeleteKeyRecursive(hkeyCuAutoLoadEnum, szCuAutoLoad);

            RegCloseKey(hkeyCuAutoLoadEnum);
        }

        RegCloseKey(hkeyCu);
    }

    return lresult;
}

PCTSTR CCuAutoLoad::GetGfxFactoryDi(void)
{
	return m_GfxFactoryDi;
}

ULONG CCuAutoLoad::GetLmAutoLoadId(void)
{
	return m_LmAutoLoadId;
}

ULONG CCuAutoLoad::GetType(void)
{
	return m_Type;
}

PCTSTR CCuAutoLoad::GetZoneFactoryDi(void)
{
	return m_ZoneFactoryDi;
}

LONG CCuAutoLoad::Initialize(ULONG CuAutoLoadId)
{
    HKEY hkeyCu;
    LONG lresult;

    m_CuAutoLoadId = CuAutoLoadId;

    lresult = m_User->RegOpen(KEY_READ, &hkeyCu);
    if (!lresult)
    {
	HKEY hkeyCuAutoLoadEnum;

	lresult = RegOpenKeyEx(hkeyCu, REGSTR_PATH_GFXAUTOLOAD, 0, KEY_ENUMERATE_SUB_KEYS, &hkeyCuAutoLoadEnum);
	if (!lresult)
	{
	    HKEY hkeyCuAutoLoad;
	    TCHAR szCuAutoLoad[9];

	    wsprintf(szCuAutoLoad, TEXT("%08X"), m_CuAutoLoadId);
	    lresult = RegOpenKeyEx(hkeyCuAutoLoadEnum, szCuAutoLoad, 0, KEY_QUERY_VALUE, &hkeyCuAutoLoad);
	    if (!lresult)
	    {
		lresult = RegQuerySzValue(hkeyCuAutoLoad, REGSTR_VAL_GFX_ZONEDI, &m_ZoneFactoryDi);
		if (!lresult) lresult = RegQueryDwordValue(hkeyCuAutoLoad, REGSTR_VAL_GFX_LMAUTOLOADID, &m_LmAutoLoadId);

		if (!lresult)
		{
		    CLmAutoLoad *pLmAutoLoad = new CLmAutoLoad;

		    if (pLmAutoLoad)
		    {
			lresult = pLmAutoLoad->Initialize(m_LmAutoLoadId);
			if (!lresult)
			{
			    m_Type = pLmAutoLoad->GetType();
			    m_GfxFactoryDi = lstrDuplicate(pLmAutoLoad->GetGfxFactoryDi());
			    if (!m_GfxFactoryDi) lresult = ERROR_OUTOFMEMORY;
			}
			delete pLmAutoLoad;
		    } else {
			lresult = ERROR_OUTOFMEMORY;
		    }
		}
		// ISSUE-2000/09/25-FrankYe a FILE_NOT_FOUND error on any values would indicate a corrupt reg entry!
		RegCloseKey(hkeyCuAutoLoad);
	    }
	    RegCloseKey(hkeyCuAutoLoadEnum);
	}
	RegCloseKey(hkeyCu);
    }

    return lresult;
}

/*-----------------------------------------------------------------------------

    CCuAutoLoad::ScanReg
    
-----------------------------------------------------------------------------*/
void CCuAutoLoad::ScanReg(IN CUser *pUser, IN PCTSTR ZoneFactoryDi, IN ULONG LmAutoLoadId, IN CListCuUserLoads &rlistCuUserLoads)
{
    HKEY hkeyCu;
    LONG lresult;

    ASSERT(pUser);

    lresult = pUser->RegOpen(KEY_READ, &hkeyCu);
    if (!lresult)
    {
	HKEY hkeyCuAutoLoadEnum;

	lresult = RegOpenKeyEx(hkeyCu, REGSTR_PATH_GFXAUTOLOAD, 0, KEY_READ, &hkeyCuAutoLoadEnum);
	if (!lresult)
	{
	    DWORD cSubkeys;
	    PTSTR pstrSubkeyNameBuffer;
	    DWORD cchSubkeyNameBuffer;

	    lresult = RegPrepareEnum(hkeyCuAutoLoadEnum, &cSubkeys, &pstrSubkeyNameBuffer, &cchSubkeyNameBuffer);
	    if (!lresult)
	    {
		DWORD dwIndex;
		
		lresult = ERROR_FILE_NOT_FOUND;

		for (dwIndex = 0; (dwIndex < cSubkeys) && (ERROR_FILE_NOT_FOUND == lresult); dwIndex++)
		{
		    DWORD cchSubkeyNameBufferT = cchSubkeyNameBuffer;

		    lresult = RegEnumKeyEx(hkeyCuAutoLoadEnum, dwIndex, pstrSubkeyNameBuffer, &cchSubkeyNameBufferT, NULL, NULL, NULL, NULL);
		    if (!lresult)
		    {
                        CCuAutoLoad *pCuAutoLoad = new CCuAutoLoad(pUser);

                        if (pCuAutoLoad)
                        {
                            PTSTR pstrEnd;

                            ULONG CuAutoLoadId = _tcstoul(pstrSubkeyNameBuffer, &pstrEnd, 16);
			    
                            lresult = pCuAutoLoad->Initialize(CuAutoLoadId);
                            if (!lresult)
                            {
                                if (LmAutoLoadId != pCuAutoLoad->m_LmAutoLoadId ||
                                    lstrcmpi(ZoneFactoryDi, pCuAutoLoad->m_ZoneFactoryDi))
                                {
                                    lresult = ERROR_FILE_NOT_FOUND;
                                }
                            }
                            delete pCuAutoLoad;
                        } else {
                            lresult = ERROR_OUTOFMEMORY;
                        }
		    }
		}
		HeapFree(hHeap, 0, pstrSubkeyNameBuffer);
	    }
	    RegCloseKey(hkeyCuAutoLoadEnum);
	}

	if (ERROR_FILE_NOT_FOUND == lresult)
	{
            //
            // For this user, create and write a CuAutoLoad to the registry
            // and create and write a counterpart CuUserLoad  to the registry.
            // If writing the CuUserLoad to registry fails, we should erase
            // the CuAutoLoad from the registry.  Then, audiosrv will retry
            // creating the CuAutoLoad and CuUserLoad reg entries next time.
            //

	    CCuAutoLoad *pCuAutoLoad = new CCuAutoLoad(pUser);

	    if (pCuAutoLoad)
	    {
                CCuUserLoad *pCuUserLoad = new CCuUserLoad(pUser);

                if (pCuUserLoad)
                {
                    lresult = pCuAutoLoad->Create(ZoneFactoryDi, LmAutoLoadId);
                    if (!lresult) lresult = pCuAutoLoad->Write();
    
                    if (!lresult)
                    {
                        lresult = pCuUserLoad->CreateFromAutoLoad(pCuAutoLoad->m_CuAutoLoadId);
                        if (!lresult) lresult = pCuUserLoad->Write();
                        if (lresult) pCuAutoLoad->Erase();
                        if (!lresult) if (!rlistCuUserLoads.AddTail(pCuUserLoad))
                        if (lresult) delete pCuUserLoad;
                    }
                }
		delete pCuAutoLoad;
	    }
	}

	RegCloseKey(hkeyCu);
    }
}

/*-------------------------------------------------------------------

    CCuAutoLoad::Write
    
    Creates a registry entry in REGSTR_PATH_GFXAUTOLOAD representing
    this CCuAutoLoad object.    

-------------------------------------------------------------------*/

LONG CCuAutoLoad::Write(void)
{
    HKEY hkeyCu;
    LONG lresult;

    lresult = m_User->RegOpen(KEY_READ, &hkeyCu);
    if (!lresult)
    {
        HKEY hkeyCuAutoLoadEnum;

	lresult = RegCreateKeyEx(hkeyCu, REGSTR_PATH_GFXAUTOLOAD, 0, NULL, 0, KEY_CREATE_SUB_KEY, NULL, &hkeyCuAutoLoadEnum, NULL);
	if (!lresult)
	{
	    HKEY hkeyCuAutoLoad;
	    TCHAR szCuAutoLoad[9];

	    wsprintf(szCuAutoLoad, TEXT("%08X"), m_CuAutoLoadId);
	    lresult = RegCreateKeyEx(hkeyCuAutoLoadEnum, szCuAutoLoad, 0, NULL, 0, KEY_SET_VALUE, NULL, &hkeyCuAutoLoad, NULL);
	    if (!lresult)
	    {
		lresult = RegSetSzValue(hkeyCuAutoLoad, REGSTR_VAL_GFX_ZONEDI, m_ZoneFactoryDi);
		if (!lresult) lresult = RegSetDwordValue(hkeyCuAutoLoad, REGSTR_VAL_GFX_LMAUTOLOADID, m_LmAutoLoadId);

		RegCloseKey(hkeyCuAutoLoad);

		// If any of the above failed, let's not leave this CuAutoLoad in the registry
		if (lresult) RegDeleteKeyRecursive(hkeyCuAutoLoadEnum, szCuAutoLoad);
	    }
	    RegCloseKey(hkeyCuAutoLoadEnum);
	}
	RegCloseKey(hkeyCu);
    }
    return lresult;
}


//=============================================================================
//===   LmAutoLoad   ===
//=============================================================================
CLmAutoLoad::CLmAutoLoad(void)
{
	m_GfxFactoryDi = NULL;
	m_HardwareId = NULL;
	m_ReferenceString = NULL;
}

CLmAutoLoad::~CLmAutoLoad(void)
{
	HeapFreeIfNotNull(hHeap, 0, m_GfxFactoryDi);
	HeapFreeIfNotNull(hHeap, 0, m_HardwareId);
	HeapFreeIfNotNull(hHeap, 0, m_ReferenceString);
}

LONG CLmAutoLoad::Create(DWORD Id, PCTSTR GfxFactoryDi, PCTSTR HardwareId, PCTSTR ReferenceString, ULONG Type)
{
	ASSERT(!m_GfxFactoryDi);
	ASSERT(!m_HardwareId);
	ASSERT(!m_ReferenceString);

	m_Id = Id;
	m_Type = Type;
	m_GfxFactoryDi = lstrDuplicate(GfxFactoryDi);
	if (m_GfxFactoryDi) m_HardwareId = lstrDuplicate(HardwareId);
	if (m_HardwareId) m_ReferenceString = lstrDuplicate(ReferenceString);
	return m_ReferenceString ? NO_ERROR : ERROR_OUTOFMEMORY;
}

LONG CLmAutoLoad::Erase(void)
{
    HKEY hkeyLmAutoLoadEnum;
    LONG lresult;

    lresult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_GFXAUTOLOAD, 0, KEY_CREATE_SUB_KEY, &hkeyLmAutoLoadEnum);
    if (!lresult)
    {
        TCHAR szLmAutoLoad[9];

        wsprintf(szLmAutoLoad, TEXT("%08x"), m_Id);
        lresult = RegDeleteKeyRecursive(hkeyLmAutoLoadEnum, szLmAutoLoad);
        RegCloseKey(hkeyLmAutoLoadEnum);
    }

    return lresult;
}

PCTSTR CLmAutoLoad::GetGfxFactoryDi(void)
{
    return m_GfxFactoryDi;
}

ULONG CLmAutoLoad::GetType(void)
{
    return m_Type;
}

LONG CLmAutoLoad::Initialize(DWORD Id)
{
    HKEY hkeyLmAutoLoadEnum;
    LONG lresult;

    m_Id = Id;

    lresult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_GFXAUTOLOAD, 0, KEY_ENUMERATE_SUB_KEYS, &hkeyLmAutoLoadEnum);
    if (!lresult)
    {
	TCHAR szLmAutoLoad[9];
	HKEY hkeyLmAutoLoad;

	wsprintf(szLmAutoLoad, TEXT("%08x"), m_Id);
	lresult = RegOpenKeyEx(hkeyLmAutoLoadEnum, szLmAutoLoad, 0, KEY_QUERY_VALUE, &hkeyLmAutoLoad);
	if (!lresult)
	{
	    lresult = RegQuerySzValue(hkeyLmAutoLoad, REGSTR_VAL_GFX_GFXDI, &m_GfxFactoryDi);
	    if (!lresult) lresult = RegQuerySzValue(hkeyLmAutoLoad, REGSTR_VAL_GFX_HARDWAREID, &m_HardwareId);
	    if (!lresult) lresult = RegQuerySzValue(hkeyLmAutoLoad, REGSTR_VAL_GFX_REFERENCESTRING, &m_ReferenceString);
	    if (!lresult) lresult = RegQueryDwordValue(hkeyLmAutoLoad, REGSTR_VAL_GFX_TYPE, &m_Type);

	    RegCloseKey(hkeyLmAutoLoad);

	    if (ERROR_FILE_NOT_FOUND == lresult)
	    {
		// If any of these values are missing, then this
		// registry data is corrupt
	    	lresult = ERROR_BADDB;
	    }
	}
	RegCloseKey(hkeyLmAutoLoadEnum);
    }

    return lresult;
}

BOOL CLmAutoLoad::IsCompatibleZoneFactory(CZoneFactory& rZoneFactory)
{
    if (!rZoneFactory.HasHardwareId(m_HardwareId)) return FALSE;
    if (!rZoneFactory.HasReferenceString(m_ReferenceString)) return FALSE;
    if (!rZoneFactory.HasCompatibleType(m_Type)) return FALSE;
    return TRUE;
}

LONG CLmAutoLoad::Write(void)
{
    HKEY hkeyLmAutoLoadEnum;
    LONG lresult;

    lresult = RegCreateKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_GFXAUTOLOAD, 0, NULL, 0, KEY_CREATE_SUB_KEY, NULL, &hkeyLmAutoLoadEnum, NULL);
    if (!lresult)
    {
        TCHAR szLmAutoLoad[9];
        HKEY hkeyLmAutoLoad;

        wsprintf(szLmAutoLoad, TEXT("%08x"), m_Id);
        lresult = RegCreateKeyEx(hkeyLmAutoLoadEnum, szLmAutoLoad, 0, NULL, 0, KEY_SET_VALUE, NULL, &hkeyLmAutoLoad, NULL);
        if (!lresult)
        {
            lresult = RegSetSzValue(hkeyLmAutoLoad, REGSTR_VAL_GFX_GFXDI, m_GfxFactoryDi);
            if (!lresult) lresult = RegSetSzValue(hkeyLmAutoLoad, REGSTR_VAL_GFX_HARDWAREID, m_HardwareId);
            if (!lresult) lresult = RegSetSzValue(hkeyLmAutoLoad, REGSTR_VAL_GFX_REFERENCESTRING, m_ReferenceString);
            if (!lresult) lresult = RegSetDwordValue(hkeyLmAutoLoad, REGSTR_VAL_GFX_TYPE, m_Type);

            RegCloseKey(hkeyLmAutoLoad);

            if (lresult) RegDeleteKeyRecursive(hkeyLmAutoLoadEnum, szLmAutoLoad);
        }
        RegCloseKey(hkeyLmAutoLoadEnum);
    }

    return lresult;
}

CListLmAutoLoads* CLmAutoLoad::CreateListFromReg(void)
{
    CListLmAutoLoads *pListLmAutoLoads = new CListLmAutoLoads;

    if (pListLmAutoLoads)
    {
	LONG lresult;

        lresult = pListLmAutoLoads->Initialize();
        if (!lresult) {
            HKEY hkeyLmAutoLoadEnum;
    
            lresult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_GFXAUTOLOAD, 0, KEY_READ, &hkeyLmAutoLoadEnum);
            if (!lresult)
            {
                DWORD cSubkeys;
                PTSTR pstrSubkeyNameBuffer;
                DWORD cchSubkeyNameBuffer;
    
                lresult = RegPrepareEnum(hkeyLmAutoLoadEnum, &cSubkeys, &pstrSubkeyNameBuffer, &cchSubkeyNameBuffer);
                if (!lresult)
                {
                    DWORD dwIndex = 0;
    
                    for (dwIndex = 0; dwIndex < cSubkeys; dwIndex++)
                    {
                        DWORD cchSubkeyNameBufferT = cchSubkeyNameBuffer;
                        lresult = RegEnumKeyEx(hkeyLmAutoLoadEnum, dwIndex, pstrSubkeyNameBuffer, &cchSubkeyNameBufferT, 0, NULL, 0, NULL);
                        if (!lresult) {
                            CLmAutoLoad *pLmAutoLoad = new CLmAutoLoad;
                            if (pLmAutoLoad)
                            {
                                PTSTR pstrEnd;
                                ULONG Id = _tcstoul(pstrSubkeyNameBuffer, &pstrEnd, 16);
                                if (pLmAutoLoad->Initialize(Id) || !pListLmAutoLoads->AddTail(pLmAutoLoad))
                                {
                                    delete pLmAutoLoad;
                                }
                            }
                        }
                    }
                    HeapFree(hHeap, 0, pstrSubkeyNameBuffer);
                }
    
                RegCloseKey(hkeyLmAutoLoadEnum);
            }
        } else {
            delete pListLmAutoLoads;
            pListLmAutoLoads = NULL;
        }
    }

    return pListLmAutoLoads;
}

void CLmAutoLoad::DestroyList(CListLmAutoLoads *pListLmAutoLoads)
{
    POSITION pos = pListLmAutoLoads->GetHeadPosition();
    while (pos) delete pListLmAutoLoads->GetNext(pos);
    delete pListLmAutoLoads;
}

/*-----------------------------------------------------------------------------
    CLmAutoLoad::ScanRegOnGfxFactory
    
    This function reads the local machine auto-load instructions from the
    registry.  Given a Gfx factory (CGfxFactory) and a list of Zone factories
    (CListZoneFactories) it finds any auto loads (CLmAutoLoad) that can
    be loaded and added to a specified CCuUserLoad list.  For such auto-loads
    that it finds, it notifies any corresonding auto load for the current user.
    
    The caller must acquire any necessary locks on the GfxFactory,
    listZoneFactories, and listCuUserLoads.
    
-----------------------------------------------------------------------------*/

void CLmAutoLoad::ScanRegOnGfxFactory(CUser *pUser, CGfxFactory& rGfxFactory, CListZoneFactories& rlistZoneFactories, CListCuUserLoads &rlistCuUserLoads)
{
    CListLmAutoLoads *pListLmAutoLoads = CLmAutoLoad::CreateListFromReg();

    ASSERT(pUser);

    if (pListLmAutoLoads)
    {
	POSITION posLmAutoLoads = pListLmAutoLoads->GetHeadPosition();
	while (posLmAutoLoads)
	{
	    CLmAutoLoad& rLmAutoLoad = *pListLmAutoLoads->GetNext(posLmAutoLoads);

	    if (lstrcmpi(rGfxFactory.GetDeviceInterface(), rLmAutoLoad.m_GfxFactoryDi)) continue;

	    POSITION posZoneFactories = rlistZoneFactories.GetHeadPosition();
	    while (posZoneFactories)
	    {
		CZoneFactory& rZoneFactory = *rlistZoneFactories.GetNext(posZoneFactories);
		if (!rLmAutoLoad.IsCompatibleZoneFactory(rZoneFactory)) continue;

		// This is more like a notification than a scan
		CCuAutoLoad::ScanReg(pUser, rZoneFactory.GetDeviceInterface(), rLmAutoLoad.m_Id, rlistCuUserLoads);
	    }
	}

        CLmAutoLoad::DestroyList(pListLmAutoLoads);
    }
}

/*-----------------------------------------------------------------------------
    CLmAutoLoad::ScanRegOnZoneFactory
    
    This function reads the local machine auto load instructions from the
    registry.  Given a Zone factory (CZoneFactory) and a list of Gfx factories
    (CListGfxFactories) it finds any auto loads (CLmAutoLoad) that can
    be loaded.  For such auto loads that it finds, it notifies any
    corresonding auto load for the current user.
    
    The caller must acquire any necessary locks on the ZoneFactory and the
    listGfxFactories.
    
-----------------------------------------------------------------------------*/

void CLmAutoLoad::ScanRegOnZoneFactory(CUser *pUser, CZoneFactory& rZoneFactory, CListGfxFactories& rlistGfxFactories, CListCuUserLoads& rlistCuUserLoads)
{
    CListLmAutoLoads *pListLmAutoLoads = CLmAutoLoad::CreateListFromReg();

    ASSERT(pUser);

    if (pListLmAutoLoads)
    {
	POSITION posLmAutoLoads = pListLmAutoLoads->GetHeadPosition();
	while (posLmAutoLoads)
	{
	    CLmAutoLoad& rLmAutoLoad = *pListLmAutoLoads->GetNext(posLmAutoLoads);
	    if (!rLmAutoLoad.IsCompatibleZoneFactory(rZoneFactory)) continue;

	    POSITION posGfxFactories = rlistGfxFactories.GetHeadPosition();
	    while (posGfxFactories)
	    {
		CGfxFactory& rGfxFactory = *rlistGfxFactories.GetNext(posGfxFactories);
		if (lstrcmpi(rGfxFactory.GetDeviceInterface(), rLmAutoLoad.m_GfxFactoryDi)) continue;

		// This is more like a notification than a scan
		CCuAutoLoad::ScanReg(pUser, rZoneFactory.GetDeviceInterface(), rLmAutoLoad.m_Id, rlistCuUserLoads);
	    }
	}

        CLmAutoLoad::DestroyList(pListLmAutoLoads);
    }
}


//=============================================================================
//===   InfAutoLoad   ===
//=============================================================================
CInfAutoLoad::CInfAutoLoad(void)
{
    m_hkey = NULL;
    m_GfxFactoryDi = NULL;
    m_HardwareId = NULL;
    m_ReferenceString = NULL;
}

CInfAutoLoad::~CInfAutoLoad(void)
{
    HeapFreeIfNotNull(hHeap, 0, m_GfxFactoryDi);
    HeapFreeIfNotNull(hHeap, 0, m_HardwareId);
    HeapFreeIfNotNull(hHeap, 0, m_ReferenceString);
    if (m_hkey) RegCloseKey(m_hkey);
}

LONG CInfAutoLoad::Initialize(HKEY hkey, CGfxFactory *pGfxFactory)
{
    LONG lresult;

    m_pGfxFactory = pGfxFactory;

    m_GfxFactoryDi = lstrDuplicate(pGfxFactory->GetDeviceInterface());
    if (m_GfxFactoryDi)
    {
	lresult = RegOpenKeyEx(hkey, NULL, 0, KEY_QUERY_VALUE | KEY_SET_VALUE, &m_hkey);
        if (lresult) m_hkey = NULL;

        if (!lresult) lresult = RegQuerySzValue(m_hkey, REGSTR_VAL_GFX_HARDWAREID, &m_HardwareId);
        if (!lresult) lresult = RegQuerySzValue(m_hkey, REGSTR_VAL_GFX_REFERENCESTRING, &m_ReferenceString);
        if (!lresult) lresult = RegQueryDwordValue(m_hkey , REGSTR_VAL_GFX_TYPE, &m_Type);
        if (!lresult) lresult = RegQueryDwordValue(m_hkey , REGSTR_VAL_GFX_NEWAUTOLOAD, &m_NewAutoLoad);
        if (!lresult)
        {
            lresult = RegQueryDwordValue(m_hkey , REGSTR_VAL_GFX_ID, &m_Id);
            if (ERROR_FILE_NOT_FOUND == lresult)
            {
                m_Id = 0;
                lresult = NO_ERROR;
            }
        }
    } else {
	lresult = ERROR_OUTOFMEMORY;
    }

    return (lresult);
}

LONG CInfAutoLoad::Scan(void)
{
    LONG lresult;
    DWORD LmId;

    CLmAutoLoad *pLmAutoLoad = new CLmAutoLoad;

    if (pLmAutoLoad)
    {
	    lresult = pLmAutoLoad->Initialize(m_Id);
	    if (lresult)
		{
			delete pLmAutoLoad;
			pLmAutoLoad = NULL;
		}

    } else {
	    lresult = ERROR_OUTOFMEMORY;
    }

    // a) new infautoload, found old lmautoload -> erase and free old lmautoload, create new lmautoload and add to list
    // b) new infautolaod, no old lmautoload -> create new lmautoload and add to list
    // c) new infautoload, error on old lmautoload -> abort
    // d) current infautoload, found lmautoload -> add to list
    // e) current infautoload, no lmautoload -> create new lmautoload and add to list
    // f) current infautoload, error on lmautoload -> abort

    if (m_NewAutoLoad && !lresult)
    {
	    lresult = pLmAutoLoad->Erase();
	    delete pLmAutoLoad;
		pLmAutoLoad = NULL;
	    if (!lresult) lresult = ERROR_FILE_NOT_FOUND;
    }

    if (ERROR_FILE_NOT_FOUND == lresult)
    {
		ASSERT( pLmAutoLoad == NULL );

		// create new
		lresult = LmNextId(&LmId);
		if (!lresult)
		{
			pLmAutoLoad = new CLmAutoLoad;

			if (pLmAutoLoad)
			{
				lresult = pLmAutoLoad->Create(LmId, m_GfxFactoryDi, m_HardwareId, m_ReferenceString, m_Type);
				if (!lresult) lresult = pLmAutoLoad->Write();
				if (!lresult)
				{
					lresult = RegSetDwordValue(m_hkey, REGSTR_VAL_GFX_ID, LmId);
					if (!lresult)
					{
						m_Id = LmId;
						lresult = RegSetDwordValue(m_hkey, REGSTR_VAL_GFX_NEWAUTOLOAD, 0);
						if (!lresult) m_NewAutoLoad = 0;
					}

					if (lresult) pLmAutoLoad->Erase();
				}

				if (lresult)
				{
					delete pLmAutoLoad;
					pLmAutoLoad = NULL;
				}

			} else {
				lresult = ERROR_OUTOFMEMORY;
			}
		}
    }

    if (NO_ERROR == lresult)
    {
		ASSERT( pLmAutoLoad != NULL );

	    // add to list
	    if (!m_pGfxFactory->GetListLmAutoLoads().AddTail(pLmAutoLoad))
		{
	        delete pLmAutoLoad;
			pLmAutoLoad = NULL;
	        lresult = ERROR_OUTOFMEMORY;
		}
    }

    return lresult;
}


LONG CInfAutoLoad::ScanReg(HKEY hkey, CGfxFactory *pGfxFactory)
{
    HKEY hkeyInfAutoLoadEnum;
    BOOL lresult;

    lresult = RegOpenKeyEx(hkey, REGSTR_PATH_GFX_AUTOLOAD, 0, KEY_READ, &hkeyInfAutoLoadEnum);
    if (NO_ERROR == lresult) {
        DWORD cSubkeys;
	PTSTR SubkeyName;
        DWORD cchSubkeyName;

	lresult = RegPrepareEnum(hkeyInfAutoLoadEnum, &cSubkeys, &SubkeyName, &cchSubkeyName);
	if (NO_ERROR == lresult)
	{
            DWORD i;

            for (i = 0; i < cSubkeys; i++) {
		HKEY hkeyInfAutoLoad;
		lresult = RegEnumOpenKey(hkeyInfAutoLoadEnum, i, SubkeyName, cchSubkeyName, KEY_QUERY_VALUE | KEY_SET_VALUE, &hkeyInfAutoLoad);
                if (NO_ERROR == lresult)
		{
		    CInfAutoLoad *pInfAutoLoad = new CInfAutoLoad;

		    if (pInfAutoLoad)
		    {
		    	lresult = pInfAutoLoad->Initialize(hkeyInfAutoLoad, pGfxFactory);
			if (!lresult) lresult = pInfAutoLoad->Scan();
			delete pInfAutoLoad;
		    }
		    else
		    {
		    	lresult = ERROR_OUTOFMEMORY;
		    }
                    RegCloseKey(hkeyInfAutoLoad);
		}
	    }
	    HeapFree(hHeap, 0, SubkeyName);
	}
	RegCloseKey(hkeyInfAutoLoadEnum);
    }
    else
    {
    	// If there is no autoload information, then that's not really an error
        if (ERROR_FILE_NOT_FOUND == lresult) lresult = NO_ERROR;
    }
    return lresult;
}

//=============================================================================
//===   ZoneFactory   ===
//=============================================================================

CZoneFactory::CZoneFactory(void)
{
    m_DeviceInterface = NULL;
    m_HardwareId      = NULL;
    m_ReferenceString = NULL;
}

CZoneFactory::~CZoneFactory(void)
{
    ASSERT(m_listCaptureGfxs.IsEmpty());
    ASSERT(m_listRenderGfxs.IsEmpty());
    
    HeapFreeIfNotNull(hHeap, 0, m_DeviceInterface);
    HeapFreeIfNotNull(hHeap, 0, m_HardwareId);
    HeapFreeIfNotNull(hHeap, 0, m_ReferenceString);
}

LONG CZoneFactory::AddType(IN ULONG Type)
{
    BOOL fRender, fCapture;

    fRender = ZoneTypeHasRender(m_Type) || ZoneTypeHasRender(Type);
    fCapture = ZoneTypeHasCapture(m_Type) || ZoneTypeHasCapture(Type);
    
    ASSERT(fRender || fCapture);
    
    if (fRender && fCapture) m_Type = ZONETYPE_RENDERCAPTURE;
    else if (fRender) m_Type = ZONETYPE_RENDER;
    else if (fCapture) m_Type = ZONETYPE_CAPTURE;
    else m_Type = 0;

    ASSERT(0 != m_Type);
    return m_Type;
}

PCTSTR CZoneFactory::GetDeviceInterface(void)
{
    return m_DeviceInterface;
}

PCTSTR CZoneFactory::GetTargetHardwareId(void)
{
    return m_HardwareId;
}

BOOL CZoneFactory::HasHardwareId(IN PCTSTR HardwareId)
{
    return 0 == lstrcmpiMulti(m_HardwareId, HardwareId);
}

BOOL CZoneFactory::HasReferenceString(IN PCTSTR ReferenceString)
{
    return 0 == lstrcmpi(m_ReferenceString, ReferenceString);
}

BOOL CZoneFactory::HasCompatibleType(ULONG Type)
{
    if (ZoneTypeHasRender(Type) && !ZoneTypeHasRender(m_Type)) return FALSE;
    if (ZoneTypeHasCapture(Type) && !ZoneTypeHasCapture(m_Type)) return FALSE;
    return TRUE;
}

LONG CZoneFactory::Initialize(IN PCTSTR DeviceInterface, IN ULONG Type)
{
    HDEVINFO hdi;
    SP_DEVICE_INTERFACE_DATA DeviceInterfaceData;
    BOOL success;
    LONG error;

    hdi = NULL;

    m_Type = Type;

    error = m_listCaptureGfxs.Initialize();
    
    if (!error)
    {
    	error = m_listRenderGfxs.Initialize();
    }

    if (!error)
    {
        m_DeviceInterface = lstrDuplicate(DeviceInterface);
        if (!m_DeviceInterface) error = ERROR_OUTOFMEMORY;
    }

    if (!error)
    {
	hdi = SetupDiCreateDeviceInfoList(NULL, NULL);
	if (!hdi) error = GetLastError();
    }

    if (!error)
    {
	DeviceInterfaceData.cbSize = sizeof(DeviceInterfaceData);
	success = SetupDiOpenDeviceInterface(hdi, m_DeviceInterface, 0, &DeviceInterfaceData);
	if (!success) error = GetLastError();
    }

    if (!error)
    {
	success = SetupDiGetDeviceInterfaceHardwareId(hdi, &DeviceInterfaceData, &m_HardwareId);
	if (!success) error = GetLastError();
    }
    
    if (!error)
    {
	PTSTR pstr = m_DeviceInterface;

	pstr += 4;	// go past "\\?\"

	while ((TEXT('\\') != *pstr) && (TEXT('\0') != *pstr)) pstr++;
	if (*pstr == TEXT('\\'))
	{
	    pstr += 1;	// go past the '\' delimiter preceding the ref string
	    m_ReferenceString = lstrDuplicate(pstr);
	    if (!m_ReferenceString) error = ERROR_OUTOFMEMORY;
	}
    }

    if (hdi)
    {
    	SetupDiDestroyDeviceInfoList(hdi);
    }

    return error;
}

LONG CZoneFactory::RemoveType(IN ULONG Type)
{
    BOOL fRender, fCapture;

    fRender = ZoneTypeHasRender(m_Type) && !ZoneTypeHasRender(Type);
    fCapture = ZoneTypeHasCapture(m_Type) && !ZoneTypeHasCapture(Type);
    
    if (fRender && fCapture) m_Type = ZONETYPE_RENDERCAPTURE;
    else if (fRender) m_Type = ZONETYPE_RENDER;
    else if (fCapture) m_Type = ZONETYPE_CAPTURE;
    else m_Type = 0;
    
    return m_Type;
}

void CZoneFactory::ListRemoveZoneFactoryDi(IN CListZoneFactories &rlistZoneFactories, IN PCTSTR DeviceInterface)
{
    POSITION pos;
    
    // Scan all ZoneFactories and delete if matched
    pos = rlistZoneFactories.GetHeadPosition();
    while (pos) {
        POSITION posThis = pos;
        CZoneFactory& rZoneFactory = *rlistZoneFactories.GetNext(pos);
        if (!lstrcmpi(DeviceInterface, rZoneFactory.GetDeviceInterface())) {
            rlistZoneFactories.RemoveAt(posThis);
            delete &rZoneFactory;
        }
    }
    return;
}

void CZoneFactory::ListRemoveZoneFactoryDiRender(IN CListZoneFactories &rlistZoneFactories, IN PCTSTR DeviceInterface)
{
    POSITION pos;
    
    // Scan all ZoneFactories and delete if matched
    pos = rlistZoneFactories.GetHeadPosition();
    while (pos) {
        POSITION posThis = pos;
        CZoneFactory& rZoneFactory = *rlistZoneFactories.GetNext(pos);
        if (!lstrcmpi(DeviceInterface, rZoneFactory.GetDeviceInterface())) {
            if (0 == rZoneFactory.RemoveType(ZONETYPE_RENDER))
            {
                rlistZoneFactories.RemoveAt(posThis);
                delete &rZoneFactory;
            }
        }
    }
    return;
}

void CZoneFactory::ListRemoveZoneFactoryDiCapture(IN CListZoneFactories &rlistZoneFactories, IN PCTSTR DeviceInterface)
{
    POSITION pos;
    
    // Scan all ZoneFactories and delete if matched
    pos = rlistZoneFactories.GetHeadPosition();
    while (pos) {
        POSITION posThis = pos;
        CZoneFactory& rZoneFactory = *rlistZoneFactories.GetNext(pos);
        if (!lstrcmpi(DeviceInterface, rZoneFactory.GetDeviceInterface())) {
            if (0 == rZoneFactory.RemoveType(ZONETYPE_CAPTURE))
            {
                rlistZoneFactories.RemoveAt(posThis);
                delete &rZoneFactory;
            }
        }
    }
    return;
}

/*-----------------------------------------------------------------------------
    CZoneFactory::ListSearchOnDi
    
    Finds a zone factory (CZoneFactory) in a specified list (CListZoneFactories)
    having the specified device interface.
    
    The caller must acquire any necessary locks on rlist before calling
    this function
    
-----------------------------------------------------------------------------*/

CZoneFactory* CZoneFactory::ListSearchOnDi(CListZoneFactories& rlist, PCTSTR Di)
{
    POSITION pos = rlist.GetHeadPosition();
    while (pos)
    {
	CZoneFactory& rZoneFactory = *rlist.GetNext(pos);
	if (!lstrcmpi(rZoneFactory.GetDeviceInterface(), Di)) return &rZoneFactory;
    }
    return NULL;
}


//=============================================================================
//===   GfxFactory   ===
//=============================================================================

CGfxFactory::CGfxFactory(void)
{
    m_plistLmAutoLoads = NULL;;
    m_DeviceInterface = NULL;
}

CGfxFactory::~CGfxFactory(void)
{
    if (m_plistLmAutoLoads) CLmAutoLoad::DestroyList(m_plistLmAutoLoads);
    HeapFreeIfNotNull(hHeap, 0, m_DeviceInterface);
}

REFCLSID CGfxFactory::GetClsid(void)
{
    return m_Clsid;
}

PCTSTR CGfxFactory::GetDeviceInterface(void)
{
    return m_DeviceInterface;
}

CListLmAutoLoads& CGfxFactory::GetListLmAutoLoads(void)
{
    return *m_plistLmAutoLoads;
}

LONG CGfxFactory::Initialize(HKEY hkey, PCTSTR DeviceInterface)
{
    LONG lresult;

    m_plistLmAutoLoads = new CListLmAutoLoads;
    lresult = m_plistLmAutoLoads ? NO_ERROR : ERROR_OUTOFMEMORY;

    if (!lresult) {
        lresult = m_plistLmAutoLoads->Initialize();

        if (!lresult) {

            m_DeviceInterface = lstrDuplicate(DeviceInterface);
            lresult = m_DeviceInterface ? NO_ERROR : ERROR_OUTOFMEMORY;

            if (!lresult)
            {
                HKEY hkeyUi;
        
                m_Clsid = GUID_NULL;
        
                // Read UI CLSID from registry
                lresult = RegOpenKeyEx(hkey, REGSTR_PATH_GFXDI_USERINTERFACECLSID, 0, KEY_QUERY_VALUE, &hkeyUi);
                if (NO_ERROR == lresult)
                {
                    TCHAR strClsid[] = TEXT("{00000000-0000-0000-0000-000000000000}");
                    DWORD dwType;
                    DWORD cbstrClsid;
        
                    cbstrClsid = (lstrlen(strClsid) + 1) * sizeof(strClsid[0]);
                    dwType = REG_SZ;
        
                    lresult = RegQueryValueEx(hkeyUi, NULL, NULL, &dwType, (PBYTE)strClsid, &cbstrClsid);
                    if (NO_ERROR == lresult)
                    {
                        HRESULT hr;
                        CLSID clsid;
        
                        hr = CLSIDFromString(strClsid, &clsid);
                        if (SUCCEEDED(hr))
                        {
                            m_Clsid = clsid;
                        }
                    }
        
                    RegCloseKey(hkeyUi);
                }

                // Ignore errors reading CLSID
                lresult = NO_ERROR;
        
                // Note the following must have HKLM write priviledges
                lresult = CInfAutoLoad::ScanReg(hkey, this);
            }
        }

        // Assuming above logic leaves nothing in the list on error
        if (lresult) delete m_plistLmAutoLoads;
    }

    return lresult;
}

BOOL CGfxFactory::IsCompatibleZoneFactory(IN ULONG Type, IN CZoneFactory& rZoneFactory)
{
    // Fix 394279: Limit to one GFX per device
    if ((Type == GFXTYPE_RENDER) && (rZoneFactory.m_listRenderGfxs.GetCount() > 0))
    {
        return FALSE;
    }
    else if ((Type == GFXTYPE_CAPTURE) && (rZoneFactory.m_listCaptureGfxs.GetCount() > 0))
    {
        return FALSE;
    }
    else if ((Type == GFXTYPE_RENDERCAPTURE) && 
             ((rZoneFactory.m_listRenderGfxs.GetCount() > 0) || (rZoneFactory.m_listCaptureGfxs.GetCount() > 0)))
    {
        return FALSE;
    }

    POSITION pos;

    // dprintf(TEXT("CGfxFactory::IsCompatibleZoneFactory : checking Type compatibility: Requested Type=%d\n"), Type);
    if (!rZoneFactory.HasCompatibleType(Type)) return FALSE;
    // dprintf(TEXT("CGfxFactory::IsCompatibleZoneFactory : Type is compatible\n"));
    if (0 == m_plistLmAutoLoads->GetCount()) return FALSE; //Fix 394279: Only allow autoload GFX
    pos = m_plistLmAutoLoads->GetHeadPosition();
    while (pos) {
	CLmAutoLoad& rLmAutoLoad = *m_plistLmAutoLoads->GetNext(pos);
	if (rLmAutoLoad.IsCompatibleZoneFactory(rZoneFactory)) return TRUE;
    }
    return FALSE;
}

void CGfxFactory::ListRemoveGfxFactoryDi(IN CListGfxFactories &rlistGfxFactories, IN PCTSTR DeviceInterface)
{
    POSITION pos;
    
    // Scan all GfxFactories and delete if matched
    pos = rlistGfxFactories.GetHeadPosition();
    while (pos) {
        POSITION posThis = pos;
        CGfxFactory& rGfxFactory = *rlistGfxFactories.GetNext(pos);
        if (!lstrcmpi(DeviceInterface, rGfxFactory.GetDeviceInterface())) {
            rlistGfxFactories.RemoveAt(posThis);
            delete &rGfxFactory;
        }
    }
    return;
}

/*-----------------------------------------------------------------------------
    CGfxFactory::ListSearchOnDi
    
    The caller must acquire any necessary locks on rlist
    
-----------------------------------------------------------------------------*/
CGfxFactory* CGfxFactory::ListSearchOnDi(IN CListGfxFactories& rlist, IN PCTSTR Di)
{
    POSITION pos = rlist.GetHeadPosition();
    while (pos)	{
	CGfxFactory& rGfxFactory = *rlist.GetNext(pos);
	if (!lstrcmpi(rGfxFactory.GetDeviceInterface(), Di)) return &rGfxFactory;
    }
    return NULL;
}

//=============================================================================
//===   CUser   ===
//=============================================================================

LONG CreateUser(IN DWORD SessionId, OUT CUser **ppUser)
{
    CUser *pUser;
    LONG error;

    pUser = new CUser;
    if (pUser)
    {
    	error = pUser->Initialize(SessionId);
    	if (error) delete pUser;
    }
    else
    {
    	error = ERROR_OUTOFMEMORY;
    }

    if (!error) *ppUser = pUser;
    
    return error;
}

CUser::CUser(void)
{
    m_hUserToken = NULL;
    m_SessionId = LOGONID_NONE;
    m_pSid = NULL;
    m_fcsRegistry = FALSE;
    m_refRegistry = 0;
    m_hRegistry = NULL;
}

CUser::~CUser(void)
{
    if (m_hRegistry) RegCloseKey(m_hRegistry);

    HeapFreeIfNotNull(hHeap, 0, m_pSid);
    
    if (m_hUserToken) CloseHandle(m_hUserToken);
    
    if (m_fcsRegistry) DeleteCriticalSection(&m_csRegistry);
}

BOOL CUser::operator==(const CUser& other)
{
    if (m_SessionId != other.m_SessionId) return FALSE;
    if (!EqualSid(m_pSid, other.m_pSid)) return FALSE;
    return TRUE;
}

void CUser::CloseUserRegistry(void)
{
    ASSERT(m_pSid);
    ASSERT(m_hRegistry);
    ASSERT(m_fcsRegistry);
    
    EnterCriticalSection(&m_csRegistry);
    ASSERT(m_refRegistry > 0);
    if (0 == --m_refRegistry)
    {
        LONG result;
        result = RegCloseKey(m_hRegistry);
        ASSERT(NO_ERROR == result);
        m_hRegistry = NULL;
    }
    LeaveCriticalSection(&m_csRegistry);
    return;
}

PSID CUser::GetSid(void)
{
    ASSERT(m_pSid);
    return m_pSid;
}

LONG CUser::Initialize(DWORD SessionId)
{
    LONG error;
    
    m_SessionId = SessionId;

    // Initialize registry critical section
    __try {
	InitializeCriticalSection(&m_csRegistry);
	error = NO_ERROR;
	m_fcsRegistry = TRUE;
    } __except(EXCEPTION_EXECUTE_HANDLER) {
	error = ERROR_OUTOFMEMORY;
	m_fcsRegistry = FALSE;
    }

    // Open a user token for the session's user
    if (!error)
    {
       	if (OpenSessionToken(m_SessionId, &m_hUserToken))
       	{
       	    if (!IsUserProfileLoaded(m_hUserToken))
       	    {
       	        error = GetLastError();
       	    	CloseHandle(m_hUserToken);
       	    	m_hUserToken = NULL;
       	    }
       	}
       	else
    	{
    	    error = GetLastError();
            dprintf(TEXT("CUser::Initialize : error: OpenSessionToken returned error=%d\n"), error);
    	}
    }

    // Create a SID for this user
    if (!error)
    {
        if (!CreateTokenSid(m_hUserToken, &m_pSid))
        {
            error = GetLastError();
            dprintf(TEXT("CUser::Initialize : error: CreateTokenSid failed, LastError=%d\n"), error);
        }
    }

    return error;
}

LONG CUser::RegOpen(IN REGSAM samDesired, OUT PHKEY phkResult)
{
    LONG error;
    
    if (OpenUserRegistry())
    {
        ASSERT(m_hRegistry);
    	error = RegOpenKeyEx(m_hRegistry, NULL, 0, samDesired, phkResult);
    	CloseUserRegistry();
    }
    else
    {
    	// Can't think of a better error code
    	error = ERROR_INVALID_FUNCTION;
    }

    return error;
}

BOOL CUser::OpenUserRegistry(void)
{
    BOOL success = FALSE;
    
    ASSERT(m_fcsRegistry);
    ASSERT(m_hUserToken);

    EnterCriticalSection(&m_csRegistry);
    ASSERT(m_refRegistry >= 0);
    if (0 == m_refRegistry++)
    {
    	ASSERT(NULL == m_hRegistry);
    	
        if (ImpersonateLoggedOnUser(m_hUserToken))
    	{
    	    NTSTATUS status;
    	    	
    	    status = RtlOpenCurrentUser(MAXIMUM_ALLOWED, (PHANDLE)&m_hRegistry);
    	    if (NT_SUCCESS(status))
    	    {
                success = TRUE;
            }
    	    else
    	    {
    	        dprintf(TEXT("CUser::OpenUserRegistry : error: RtlOpenCurrentUser returned status=%08Xh\n"), status);
    	    	m_hRegistry = NULL;
    	    }
    	    RevertToSelf();
    	}
    	else
    	{
    	    LONG error = GetLastError();
    	    dprintf(TEXT("CUser::OpenUserRegistry : error: ImpersonateLoggedOnUser failed, LastError=%d\n"), error);
    	}
    	
    	if (!success) m_refRegistry--;
    }
    else
    {
        // dprintf(TEXT("CUser::OpenUserRegistry : note: reusing registry handle\n"));
        success = TRUE;
    }

    LeaveCriticalSection(&m_csRegistry);

    return success;
}

//=============================================================================
//===   ===
//=============================================================================

void
ZoneFactoryInterfaceCheck(
    IN CUser *pUser,
    IN HDEVINFO DevInfo,
    IN PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData,
    IN ULONG Type
)
{
    GUID BusTypeGuid;
    BOOL fresult;

    ASSERT(pUser);

    //
    // For now, we support GFXs only on USB bus because we want to limit
    // GFXs to only non-accelerated audio devices
    //
    fresult = SetupDiGetDeviceInterfaceBusId(DevInfo, DeviceInterfaceData, &BusTypeGuid);
    if (fresult && (GUID_BUS_TYPE_USB == BusTypeGuid))
    {
    	PSP_DEVICE_INTERFACE_DETAIL_DATA DeviceInterfaceDetail;
    	
    	fresult = SetupDiCreateDeviceInterfaceDetail(DevInfo, DeviceInterfaceData, &DeviceInterfaceDetail, NULL);
    	if (fresult)
    	{
            LockGlobalLists();
    
            CZoneFactory *pZoneFactory;
    
            // We scan AutoLoad and UserLoads only if we are enhancing the type
            // of an existing zone or we are adding a new zone
    
            pZoneFactory = CZoneFactory::ListSearchOnDi(*gplistZoneFactories, DeviceInterfaceDetail->DevicePath);
            if (pZoneFactory)
            {
    	        if (pZoneFactory->HasCompatibleType(Type))
    	        {
    	    	    pZoneFactory = NULL;
    	        }
                else
                {
                    pZoneFactory->AddType(Type);
                }
            }
            else
            {
                pZoneFactory = new CZoneFactory;
                if (pZoneFactory)
                {
                    if (pZoneFactory->Initialize(DeviceInterfaceDetail->DevicePath, Type) || !gplistZoneFactories->AddTail(pZoneFactory))
                    {
                        delete pZoneFactory;
                        pZoneFactory = NULL;
                    }
                }
            }
                
            if (pZoneFactory)
            {
                CLmAutoLoad::ScanRegOnZoneFactory(pUser, *pZoneFactory, *gplistGfxFactories, *gplistCuUserLoads);
                CCuUserLoad::ScanList(*gplistCuUserLoads, *gplistZoneFactories, *gplistGfxFactories);
            }
                
            UnlockGlobalLists();

            HeapFree(hHeap, 0, DeviceInterfaceDetail);
    	} else {
    	    dprintf(TEXT("ZoneFactoryInterfaceCheck: SetupDiCreateDeviceInterfaceDetail failed\n"));
    	}
    
    }
    else
    {
        if (fresult)
        {
            // dprintf(TEXT("ZoneFactoryInterfaceCheck found interface on non USB bus [%s]\n"), DeviceInterface);
        }
        else
        {
            // DWORD dw = GetLastError();
            // dprintf(TEXT("ZoneFactoryInterfaceCheck: error calling SetupDiGetDeviceInterfaceBusId\n")
            //         TEXT("  DeviceInterface=%s\n")
            //         TEXT("  LastError=%d\n"),
            //        DeviceInterface, dw);
        }
    }

    return;
}

void
GfxFactoryInterfaceCheck(
    IN CUser *pUser,
    IN HDEVINFO DevInfo,
    IN PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData
)
{
    HKEY hkeyDi;

    ASSERT(pUser);
            
    hkeyDi = SetupDiOpenDeviceInterfaceRegKey(DevInfo, DeviceInterfaceData, 0, KEY_ENUMERATE_SUB_KEYS);
    if (hkeyDi)
    {
        HKEY hkeyDiGfx;
        LONG lresult;
                    
        // If the KSCATEGORY_AUDIO device interface key has a GFX
        //    subkey then this is a GFX factory
                
        lresult = RegOpenKeyEx(hkeyDi, REGSTR_PATH_DI_GFX, 0, KEY_QUERY_VALUE, &hkeyDiGfx);
        if (NO_ERROR == lresult)
        {
            PSP_DEVICE_INTERFACE_DETAIL_DATA DeviceInterfaceDetail;
            BOOL fresult;
            
            fresult = SetupDiCreateDeviceInterfaceDetail(DevInfo, DeviceInterfaceData, &DeviceInterfaceDetail, NULL);
            if (fresult)
            {
                LockGlobalLists();
    
                // Ensure it's not already in the list
                if (!CGfxFactory::ListSearchOnDi(*gplistGfxFactories, DeviceInterfaceDetail->DevicePath))
                {
                    CGfxFactory *pGfxFactory = new CGfxFactory;
            
                    if (pGfxFactory)
                    {
                        if (!pGfxFactory->Initialize(hkeyDiGfx, DeviceInterfaceDetail->DevicePath) && gplistGfxFactories->AddTail(pGfxFactory))
                        {
                            CLmAutoLoad::ScanRegOnGfxFactory(pUser, *pGfxFactory, *gplistZoneFactories, *gplistCuUserLoads);
                            CCuUserLoad::ScanList(*gplistCuUserLoads, *gplistZoneFactories, *gplistGfxFactories);
                        }
                        else
                        {
                            delete pGfxFactory;
                        }
                    }
                }
    
                UnlockGlobalLists();

                HeapFree(hHeap, 0, DeviceInterfaceDetail);
            }

            RegCloseKey(hkeyDiGfx);
        }
        
        RegCloseKey(hkeyDi);
    }
    
    return;
}

/*-----------------------------------------------------------------------------
    GFX_InterfaceArrival

-----------------------------------------------------------------------------*/
void GFX_InterfaceArrival(PCTSTR ArrivalDeviceInterface)
{
    CUser *pUser;
    HDEVINFO hdi;
    SP_DEVICE_INTERFACE_DATA ArrivalDeviceInterfaceData;

    if (!RtlInterlockedTestAcquireResourceShared(&GfxResource, &gfGfxInitialized)) return;

    pUser = gpConsoleUser;
    ASSERT(pUser);

    hdi = SetupDiCreateDeviceInfoList(NULL, NULL);
    if (INVALID_HANDLE_VALUE != hdi)
    {
        BOOL fresult;
        ArrivalDeviceInterfaceData.cbSize = sizeof(ArrivalDeviceInterfaceData);
        fresult = SetupDiOpenDeviceInterface(hdi, ArrivalDeviceInterface, 0, &ArrivalDeviceInterfaceData);
        if (fresult)
        {
            SP_DEVICE_INTERFACE_DATA AudioDeviceInterfaceData;
            SP_DEVICE_INTERFACE_DATA AliasDeviceInterfaceData;
	    BOOL fRender;
            BOOL fCapture;
            BOOL fDataTransform;
            BOOL fAudio;
    
            // dprintf(TEXT("GFX_InterfaceArrival: checking interface aliases on %s\n"), ArrivalDeviceInterface);
                    
            AudioDeviceInterfaceData.cbSize = sizeof(AudioDeviceInterfaceData);
            fAudio = SetupDiGetDeviceInterfaceAlias(hdi, &ArrivalDeviceInterfaceData, &KSCATEGORY_AUDIO, &AudioDeviceInterfaceData);
            fAudio = fAudio && (AudioDeviceInterfaceData.Flags & SPINT_ACTIVE);
        
            AliasDeviceInterfaceData.cbSize = sizeof(AliasDeviceInterfaceData);
            fRender = SetupDiGetDeviceInterfaceAlias(hdi, &ArrivalDeviceInterfaceData, &KSCATEGORY_RENDER, &AliasDeviceInterfaceData);
            fRender = fRender && (AliasDeviceInterfaceData.Flags & SPINT_ACTIVE);
        
            AliasDeviceInterfaceData.cbSize = sizeof(AliasDeviceInterfaceData);
            fCapture = SetupDiGetDeviceInterfaceAlias(hdi, &ArrivalDeviceInterfaceData, &KSCATEGORY_CAPTURE, &AliasDeviceInterfaceData);
            fCapture = fCapture && (AliasDeviceInterfaceData.Flags & SPINT_ACTIVE);
            
            AliasDeviceInterfaceData.cbSize = sizeof(AliasDeviceInterfaceData);
            fDataTransform = SetupDiGetDeviceInterfaceAlias(hdi, &ArrivalDeviceInterfaceData, &KSCATEGORY_DATATRANSFORM, &AliasDeviceInterfaceData);
            fDataTransform = fDataTransform && (AliasDeviceInterfaceData.Flags & SPINT_ACTIVE);

	    /*    
            if (fAudio) dprintf(TEXT("GFX_InterfaceArrival: interface has Audio alias\n"));
            if (fRender) dprintf(TEXT("GFX_InterfaceArrival: interface has Render alias\n"));
            if (fCapture) dprintf(TEXT("GFX_InterfaceArrival: interface has Capture alias\n"));
            if (fDataTransform) dprintf(TEXT("GFX_InterfaceArrival: interface has DataTransform alias\n"));
    	    */
    	    
            if (fAudio && fDataTransform) GfxFactoryInterfaceCheck(pUser, hdi, &AudioDeviceInterfaceData);
    
            if (fAudio && fRender && fCapture) ZoneFactoryInterfaceCheck(pUser, hdi, &AudioDeviceInterfaceData, ZONETYPE_RENDERCAPTURE);
            else if (fAudio && fRender) ZoneFactoryInterfaceCheck(pUser, hdi, &AudioDeviceInterfaceData, ZONETYPE_RENDER);
            else if (fAudio && fCapture) ZoneFactoryInterfaceCheck(pUser, hdi, &AudioDeviceInterfaceData, ZONETYPE_CAPTURE);
            
        }
    
        SetupDiDestroyDeviceInfoList(hdi);
    }
    
    RtlReleaseResource(&GfxResource);
    return;
}


void GFX_AudioInterfaceArrival(PCTSTR ArrivalDeviceInterface)
{
    // dprintf(TEXT("GFX_AudioInterfaceArrival: %s\n"), ArrivalDeviceInterface);
    GFX_InterfaceArrival(ArrivalDeviceInterface);
    return;
}

void GFX_DataTransformInterfaceArrival(PCTSTR ArrivalDeviceInterface)
{
    // dprintf(TEXT("GFX_DataTransformInterfaceArrival: %s\n"), ArrivalDeviceInterface);
    GFX_InterfaceArrival(ArrivalDeviceInterface);
    return;
}

void GFX_RenderInterfaceArrival(PCTSTR ArrivalDeviceInterface)
{
    // dprintf(TEXT("GFX_RenderInterfaceArrival: %s\n"), ArrivalDeviceInterface);
    GFX_InterfaceArrival(ArrivalDeviceInterface);
    return;
}

void GFX_CaptureInterfaceArrival(PCTSTR ArrivalDeviceInterface)
{
    // dprintf(TEXT("GFX_CaptureInterfaceArrival: %s\n"), ArrivalDeviceInterface);
    GFX_InterfaceArrival(ArrivalDeviceInterface);
    return;
}

/*-----------------------------------------------------------------------------
    GFX_AudioInterfaceRemove

-----------------------------------------------------------------------------*/
void GFX_AudioInterfaceRemove(PCTSTR DeviceInterface)
{
    POSITION pos;

    // dprintf(TEXT("GFX_AudioInterfaceRemove: %s\n"), DeviceInterface);

    if (!RtlInterlockedTestAcquireResourceShared(&GfxResource, &gfGfxInitialized)) return;
    
    LockGlobalLists();

    CCuUserLoad::ListRemoveZoneFactoryDi(*gplistCuUserLoads, DeviceInterface);
    CCuUserLoad::ListRemoveGfxFactoryDi(*gplistCuUserLoads, DeviceInterface);
    CZoneFactory::ListRemoveZoneFactoryDi(*gplistZoneFactories, DeviceInterface);
    CGfxFactory::ListRemoveGfxFactoryDi(*gplistGfxFactories, DeviceInterface);

    UnlockGlobalLists();

    RtlReleaseResource(&GfxResource);

    return;
}

void GFX_DataTransformInterfaceRemove(PCTSTR DataTransformDeviceInterface)
{
    PTSTR AudioDeviceInterface;
    BOOL fresult;
    
    // dprintf(TEXT("GFX_DataTransformInterfaceRemove: %s\n"), DataTransformDeviceInterface);

    if (!RtlInterlockedTestAcquireResourceShared(&GfxResource, &gfGfxInitialized)) return;

    fresult = SetupDiCreateAliasDeviceInterfaceFromDeviceInterface(DataTransformDeviceInterface, &KSCATEGORY_AUDIO, &AudioDeviceInterface);
    if (fresult)
    {
        LockGlobalLists();
        CCuUserLoad::ListRemoveGfxFactoryDi(*gplistCuUserLoads, AudioDeviceInterface);
        CGfxFactory::ListRemoveGfxFactoryDi(*gplistGfxFactories, AudioDeviceInterface);
        UnlockGlobalLists();
        HeapFree(hHeap, 0, AudioDeviceInterface);
    }
        
    RtlReleaseResource(&GfxResource);
    return;
}

void GFX_RenderInterfaceRemove(PCTSTR RemoveDeviceInterface)
{
    PTSTR AudioDeviceInterface;
    BOOL fresult;
    
    // dprintf(TEXT("GFX_RenderInterfaceRemove: %s\n"), RemoveDeviceInterface);

    if (!RtlInterlockedTestAcquireResourceShared(&GfxResource, &gfGfxInitialized)) return;

    fresult = SetupDiCreateAliasDeviceInterfaceFromDeviceInterface(RemoveDeviceInterface, &KSCATEGORY_AUDIO, &AudioDeviceInterface);
    if (fresult)
    {
	LockGlobalLists();
        CCuUserLoad::ListRemoveZoneFactoryDiRender(*gplistCuUserLoads, AudioDeviceInterface);
        CZoneFactory::ListRemoveZoneFactoryDiRender(*gplistZoneFactories, AudioDeviceInterface);
        UnlockGlobalLists();
        HeapFree(hHeap, 0, AudioDeviceInterface);
    }
    
    RtlReleaseResource(&GfxResource);
    return;
}

void GFX_CaptureInterfaceRemove(PCTSTR RemoveDeviceInterface)
{
    PTSTR AudioDeviceInterface;
    BOOL fresult;
    
    // dprintf(TEXT("GFX_CaptureInterfaceRemove: %s\n"), RemoveDeviceInterface);

    if (!RtlInterlockedTestAcquireResourceShared(&GfxResource, &gfGfxInitialized)) return;

    fresult = SetupDiCreateAliasDeviceInterfaceFromDeviceInterface(RemoveDeviceInterface, &KSCATEGORY_AUDIO, &AudioDeviceInterface);
    if (fresult)
    {
   	LockGlobalLists();
        CCuUserLoad::ListRemoveZoneFactoryDiCapture(*gplistCuUserLoads, AudioDeviceInterface);
        CZoneFactory::ListRemoveZoneFactoryDiCapture(*gplistZoneFactories, AudioDeviceInterface);
        UnlockGlobalLists();
        HeapFree(hHeap, 0, AudioDeviceInterface);
    }
    
    RtlReleaseResource(&GfxResource);
    return;
}

/*-----------------------------------------------------------------------------
    GFX_SysaudioInterfaceArrival
    
-----------------------------------------------------------------------------*/
void GFX_SysaudioInterfaceArrival(PCTSTR DeviceInterface)
{
    if (!RtlInterlockedTestAcquireResourceShared(&GfxResource, &gfGfxInitialized)) return;
    
    LockSysaudio();

    if (INVALID_HANDLE_VALUE == ghSysaudio)
    {
        gpstrSysaudioDeviceInterface = lstrDuplicate(DeviceInterface);
        if (gpstrSysaudioDeviceInterface)
        {
            ghSysaudio =  CreateFile(gpstrSysaudioDeviceInterface,
                                     GENERIC_READ | GENERIC_WRITE,
                                     0,
                                     NULL,
                                     OPEN_EXISTING,
                                     FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                                     NULL);
    
            if (INVALID_HANDLE_VALUE == ghSysaudio)
            {
                HeapFree(hHeap, 0, gpstrSysaudioDeviceInterface);
                gpstrSysaudioDeviceInterface = NULL;
            }
        }
    
    } else {

	// Sysaudio already open
        ASSERT(gpstrSysaudioDeviceInterface);
	if (lstrcmpi(DeviceInterface, gpstrSysaudioDeviceInterface))
	{
	    // We have two Sysaudio devices in the system!!!  What to do???
            dprintf(TEXT("GFX_SysaudioInterfaceArrival: warning: received two arrivals!\n"));
	    ASSERT(FALSE);
	}
    }

    UnlockSysaudio();

    //
    // Even though we read the value of ghSysaudio here, we don't lock
    // sysaudio.  If some other thread is changing it from invalid to valid
    // then that thread will scan user-loads.  If some other thread changes
    // it from valid to invalid, it is okay that we do a wasteful scan of
    // user-loads.
    //
    if (INVALID_HANDLE_VALUE != ghSysaudio)
    {
        LockGlobalLists();
        CCuUserLoad::ScanList(*gplistCuUserLoads, *gplistZoneFactories, *gplistGfxFactories);
        UnlockGlobalLists();
    }

    RtlReleaseResource(&GfxResource);

    return;
}

/*-----------------------------------------------------------------------------
    GFX_SysaudioInterfaceRemove

    If this matches our sysaudio interface then scan all CuUserLoads and remove
    them from zones.  Then close our handle to Sysaudio.
    
-----------------------------------------------------------------------------*/
void GFX_SysaudioInterfaceRemove(PCTSTR DeviceInterface)
{
    POSITION pos;

    if (!RtlInterlockedTestAcquireResourceShared(&GfxResource, &gfGfxInitialized)) return;
    
    LockGlobalLists();
    LockSysaudio();

    //
    // Scan all CuUserLoads and remove them from zone
    //
    pos = gplistCuUserLoads->GetHeadPosition();
    while (pos) {
        CCuUserLoad& rCuUserLoad = *gplistCuUserLoads->GetNext(pos);
        rCuUserLoad.RemoveFromZoneGraph();
    }
    

    //
    // Close sysaudio
    //
    if (INVALID_HANDLE_VALUE != ghSysaudio) {
        CloseHandle(ghSysaudio);
        HeapFree(hHeap, 0, gpstrSysaudioDeviceInterface);
        ghSysaudio = INVALID_HANDLE_VALUE;
        gpstrSysaudioDeviceInterface = NULL;
    }


    UnlockSysaudio();
    UnlockGlobalLists();
    RtlReleaseResource(&GfxResource);
   return;
}

//=============================================================================
//===   RPC server interface   ===
//=============================================================================

LONG s_gfxRemoveGfx(ULONG CuUserLoadId)
{
    LONG lresult;
    
    dprintf(TEXT("gfxRemoveGfx: CuUserLoadId=%08Xh\n"), CuUserLoadId);

    if (!RtlInterlockedTestAcquireResourceShared(&GfxResource, &gfGfxInitialized)) return ERROR_INVALID_FUNCTION;

    lresult = RpcClientHasUserSid(gpConsoleUser->GetSid()) ? NO_ERROR : ERROR_INVALID_FUNCTION;
    if (!lresult)
    {
	POSITION pos;
	lresult = ERROR_BAD_DEVICE;   // Cannot find the device specified

        LockGlobalLists();

	pos = gplistCuUserLoads->GetHeadPosition();
	while (pos) {
	    CCuUserLoad *pCuUserLoad = gplistCuUserLoads->GetAt(pos);
	    if (pCuUserLoad->GetId() == CuUserLoadId) {
		lresult = pCuUserLoad->Erase();
		if (!lresult) {
		    gplistCuUserLoads->RemoveAt(pos);
		    delete pCuUserLoad;
		    lresult = NO_ERROR;
		}
		break;
	    }
	    gplistCuUserLoads->GetNext(pos);
	}

        UnlockGlobalLists();

    }

    RtlReleaseResource(&GfxResource);

    return lresult;
}

LONG s_gfxModifyGfx(ULONG CuUserLoadId, DWORD Order)
{
    LONG lresult;

    // Validate the Order parameter
    if (GFX_MAXORDER < Order)
    {
        dprintf(TEXT("gfxModifyGfx: error: Order=%d is invalid\n"), Order);
    	return ERROR_INVALID_PARAMETER;
    }

    if (!RtlInterlockedTestAcquireResourceShared(&GfxResource, &gfGfxInitialized)) return ERROR_INVALID_FUNCTION;

    lresult = RpcClientHasUserSid(gpConsoleUser->GetSid()) ? NO_ERROR : ERROR_INVALID_FUNCTION;
    if (!lresult)
    {
	POSITION pos;
	lresult = ERROR_BAD_DEVICE;    // Cannot find the device specified

        LockGlobalLists();

	pos = gplistCuUserLoads->GetHeadPosition();
	while (pos) {
	    CCuUserLoad *pCuUserLoad = gplistCuUserLoads->GetAt(pos);
	    if (pCuUserLoad->GetId() == CuUserLoadId) {
                dprintf(TEXT("gfxModify : note: Moving GFX ID %08X from %d to %d\n"), CuUserLoadId, pCuUserLoad->GetOrder(), Order);
    	    	lresult = pCuUserLoad->ModifyOrder(Order);
		break;
	    }
	    gplistCuUserLoads->GetNext(pos);
	}

        UnlockGlobalLists();

    }

    RtlReleaseResource(&GfxResource);
    
    return lresult;
}

RPC_STATUS s_gfxAddGfx(IN PWSTR ZoneFactoryDi, IN PWSTR GfxFactoryDi, IN ULONG Type, IN ULONG Order, OUT PDWORD pNewId)
{
    LONG lresult;
    
    dprintf(TEXT("gfxAddGfx: ZoneFactoryDi = %s\n"), ZoneFactoryDi);
    dprintf(TEXT("gfxAddGfx: GfxFactoryDi = %s\n"), GfxFactoryDi);
    dprintf(TEXT("gfxAddGfx: Type = %s\n"), GFXTYPE_RENDER == Type ? TEXT("Render") : TEXT("Capture"));
    dprintf(TEXT("gfxAddGfx: Order = %d\n"), Order);

    // Validate the Type parameter
    if (GFXTYPE_RENDER != Type &&
        GFXTYPE_CAPTURE != Type &&
        GFXTYPE_RENDERCAPTURE != Type)
    {
        dprintf(TEXT("gfxAddGfx: error: Type=%d is invalid\n"), Type);
        return ERROR_INVALID_PARAMETER;
    }

    // Validate the Order parameter
    if (GFX_MAXORDER < Order)
    {
        dprintf(TEXT("gfxAddGfx: error: Order=%d is invalid\n"), Order);
    	return ERROR_INVALID_PARAMETER;
    }

    if (!RtlInterlockedTestAcquireResourceShared(&GfxResource, &gfGfxInitialized)) return ERROR_INVALID_FUNCTION;

    lresult = RpcClientHasUserSid(gpConsoleUser->GetSid()) ? NO_ERROR : ERROR_INVALID_FUNCTION;
    if (!lresult)
    {
        LockGlobalLists();

	CGfxFactory *pGfxFactory = CGfxFactory::ListSearchOnDi(*gplistGfxFactories, GfxFactoryDi);
	CZoneFactory *pZoneFactory = CZoneFactory::ListSearchOnDi(*gplistZoneFactories, ZoneFactoryDi);

	if (pGfxFactory && pZoneFactory && pGfxFactory->IsCompatibleZoneFactory(Type, *pZoneFactory))
	{
	    CCuUserLoad *pCuUserLoad = new CCuUserLoad(gpConsoleUser);
	    if (pCuUserLoad) {
		lresult = pCuUserLoad->CreateFromUser(GfxFactoryDi, ZoneFactoryDi, Type, Order);
		if (!lresult)
		{
                    POSITION pos;

		    pos = gplistCuUserLoads->AddTail(pCuUserLoad);
		    if (pos)
		    {
                        lresult = pCuUserLoad->Scan(*gplistZoneFactories, *gplistGfxFactories);
                        if (!lresult)
                        {
                            pCuUserLoad->Write();	// Ignoring errors
                            *pNewId = pCuUserLoad->GetId();
			} else {
			    gplistCuUserLoads->RemoveAt(pos);
			}
		    } else {
			lresult = ERROR_OUTOFMEMORY;
		    }
		}
		if (lresult) delete pCuUserLoad;
	    } else {
		lresult = ERROR_OUTOFMEMORY;
	    }
	} else {
	    lresult = ERROR_INVALID_PARAMETER;
	}

        UnlockGlobalLists();

    }
    
    lresult ? dprintf(TEXT("gfxAddGfx: returning error=%lu\n"), lresult) :
              dprintf(TEXT("gfxAddGfx: returning NewId=%08Xh\n"), *pNewId);
              
    RtlReleaseResource(&GfxResource);
    
    return lresult;
}

RPC_STATUS s_gfxCreateGfxList(IN PWSTR ZoneFactoryDi, OUT UNIQUE_PGFXLIST *ppGfxList)
{
    UNIQUE_PGFXLIST pGfxList;
    int cGfx;
    LONG lresult;

    if (!RtlInterlockedTestAcquireResourceShared(&GfxResource, &gfGfxInitialized)) return ERROR_INVALID_FUNCTION;

    lresult = RpcClientHasUserSid(gpConsoleUser->GetSid()) ? NO_ERROR : ERROR_INVALID_FUNCTION;
    if (!lresult)
    {
        LockGlobalLists();

	if (!CZoneFactory::ListSearchOnDi(*gplistZoneFactories, ZoneFactoryDi)) lresult = ERROR_DEVICE_NOT_AVAILABLE;

	if (!lresult)
	{
	    pGfxList = NULL;
	    lresult = NO_ERROR;

	    cGfx = gplistCuUserLoads->GetCount();
	    if (cGfx > 0)
	    {
		SIZE_T cbGfxList;

		cbGfxList = sizeof(*pGfxList) - sizeof(pGfxList->Gfx[0]) + (cGfx * sizeof(pGfxList->Gfx[0]));
		pGfxList = (UNIQUE_PGFXLIST)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, cbGfxList);
		if (pGfxList)
		{
		    POSITION pos = gplistCuUserLoads->GetHeadPosition();
		    PGFX pGfx = &pGfxList->Gfx[0];

		    cGfx = 0;

		    while (pos && !lresult)
		    {
			CCuUserLoad& rCuUserLoad = *gplistCuUserLoads->GetNext(pos);
			if (!lstrcmpi(ZoneFactoryDi, rCuUserLoad.GetZoneFactoryDi()))
			{
			    pGfx->Type = rCuUserLoad.GetType();
			    pGfx->Id = rCuUserLoad.GetId();
			    pGfx->Order = rCuUserLoad.GetOrder();
			    rCuUserLoad.GetGfxFactoryClsid(*gplistGfxFactories, (LPCLSID)&pGfx->Clsid);
			    ASSERT(rCuUserLoad.GetGfxFactoryDi());
			    pGfx->GfxFactoryDi = lstrDuplicate(rCuUserLoad.GetGfxFactoryDi());
			    if (!pGfx->GfxFactoryDi) lresult = ERROR_OUTOFMEMORY;
			    pGfx++;
			    cGfx++;
			}
		    }

		    if (lresult)
		    {
			pGfx = &pGfxList->Gfx[0];
			while (cGfx > 0)
			{
			    HeapFreeIfNotNull(hHeap, 0, pGfx->GfxFactoryDi);
			    pGfx++;
			    cGfx--;
			}
			HeapFree(hHeap, 0, pGfxList);
			pGfxList = NULL;
		    }
		} else {
		    lresult = ERROR_OUTOFMEMORY;
		}
	    }

	    if (!lresult)
	    {
		if (pGfxList) pGfxList->Count = cGfx;
		*ppGfxList = pGfxList;
	    }

	}

	UnlockGlobalLists();

    }

    RtlReleaseResource(&GfxResource);

    return lresult;
}

RPC_STATUS s_gfxCreateGfxFactoriesList(IN PWSTR ZoneFactoryDi, OUT UNIQUE_PDILIST *ppDiList)
{
    RPC_STATUS status;
    CZoneFactory *pZoneFactory;

    if (!RtlInterlockedTestAcquireResourceShared(&GfxResource, &gfGfxInitialized)) return ERROR_INVALID_FUNCTION;

    status = RpcClientHasUserSid(gpConsoleUser->GetSid()) ? NO_ERROR : ERROR_INVALID_FUNCTION;
    if (!status)
    {
	LockGlobalLists();

	pZoneFactory = CZoneFactory::ListSearchOnDi(*gplistZoneFactories, ZoneFactoryDi);
	if (!pZoneFactory) status = ERROR_DEVICE_NOT_AVAILABLE;

	if (!status)
	{
	    UNIQUE_PDILIST pDiList;
	    SIZE_T cbDiList;
	    int cElements;
            PWSTR *pDi;

	    cElements = gplistGfxFactories->GetCount();

	    cbDiList = (sizeof(*pDiList) - sizeof(pDiList->DeviceInterface[0])) + (cElements * sizeof(pDiList->DeviceInterface[0]));
	    pDiList = (UNIQUE_PDILIST)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, cbDiList);

	    if (pDiList)
	    {
	        pDi = &pDiList->DeviceInterface[0];
	        POSITION pos = gplistGfxFactories->GetHeadPosition();

	        pDiList->Count = 0;

	        for (pos = gplistGfxFactories->GetHeadPosition(); pos; *gplistGfxFactories->GetNext(pos))
	        {
	            // If this gfx factory is an auto-load, then we need
	            // to check whether the zone factory is compatible before
	            // returning this gfx factory in the gfx factories list
	            CGfxFactory& rGfxFactory = *gplistGfxFactories->GetAt(pos);
	            if (rGfxFactory.GetListLmAutoLoads().GetCount())
	            {
	                // See if this ZoneFactoryDi works on any of the LmAutoLoads
	                POSITION posLmAutoLoad;
	            
	                for (posLmAutoLoad = rGfxFactory.GetListLmAutoLoads().GetHeadPosition();
	                     posLmAutoLoad;
	                     rGfxFactory.GetListLmAutoLoads().GetNext(posLmAutoLoad))
	                {
	                    CLmAutoLoad& rLmAutoLoad = *rGfxFactory.GetListLmAutoLoads().GetAt(posLmAutoLoad);
	                    if (rLmAutoLoad.IsCompatibleZoneFactory(*pZoneFactory)) break;
	                }
	                    
	                if (!posLmAutoLoad) continue;
	            } else continue; // Fix 394279: Only enumerate Auto-load GFX

	            ASSERT(rGfxFactory.GetDeviceInterface());
	            *pDi = lstrDuplicate(rGfxFactory.GetDeviceInterface());
	            if (NULL == *pDi) break;

	            pDi++;  // Next slot
	            pDiList->Count++;
	        }

	        if (pos)
	        {
	            pDi = &pDiList->DeviceInterface[0];
	            while (*pDi) HeapFree(hHeap, 0, *(pDi++));
	            HeapFree(hHeap, 0, pDiList);
	            pDiList = NULL;
	        }

	        if (pDiList) *ppDiList = pDiList;
	        status = pDiList ? NO_ERROR : ERROR_OUTOFMEMORY;

	    }
	}

	UnlockGlobalLists();

    }

    RtlReleaseResource(&GfxResource);

    return status;
}

RPC_STATUS s_gfxCreateZoneFactoriesList(OUT UNIQUE_PDILIST *ppDiList)
{
    UNIQUE_PDILIST pDiList;
    SIZE_T cbDiList;
    int cElements;
    RPC_STATUS status;


    if (!RtlInterlockedTestAcquireResourceShared(&GfxResource, &gfGfxInitialized)) return ERROR_INVALID_FUNCTION;

    status = RpcClientHasUserSid(gpConsoleUser->GetSid()) ? NO_ERROR : ERROR_INVALID_FUNCTION;
    if (!status)
    {
        PWSTR *pDi;

	LockGlobalLists();

	cElements = gplistZoneFactories->GetCount();

	cbDiList = (sizeof(*pDiList) - sizeof(pDiList->DeviceInterface[0])) + (cElements * sizeof(pDiList->DeviceInterface[0]));
	pDiList = (UNIQUE_PDILIST) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, cbDiList);

	if (pDiList)
	{
	    pDi = &pDiList->DeviceInterface[0];
	    POSITION pos = gplistZoneFactories->GetHeadPosition();

	    pDiList->Count = cElements;

	    while (pos)
	    {
	            
	        CZoneFactory& rZoneFactory = *gplistZoneFactories->GetAt(pos);
	        *pDi = lstrDuplicate(rZoneFactory.GetDeviceInterface());
	        if (NULL == *pDi) break;
	            
	        gplistZoneFactories->GetNext(pos);
	        pDi++;
	    }
	    
	    if (pos)
	    {
	        pDi = &pDiList->DeviceInterface[0];

	        while (*pDi) HeapFree(hHeap, 0, *(pDi++));

	        HeapFree(hHeap, 0, pDiList);
	        pDiList = NULL;
	    }
	        
	}

	UnlockGlobalLists();

	if (pDiList) *ppDiList = pDiList;
	status = pDiList ? NO_ERROR : ERROR_OUTOFMEMORY;

    }

    RtlReleaseResource(&GfxResource);

    return status;
}

LONG s_gfxOpenGfx(IN DWORD dwProcessId, IN DWORD dwGfxId, OUT RHANDLE *pFileHandle)
{
    HANDLE hClientProcess;
    RPC_STATUS status;
    HANDLE hGfxFilter;
    POSITION pos;

    if (!RtlInterlockedTestAcquireResourceShared(&GfxResource, &gfGfxInitialized)) return ERROR_INVALID_FUNCTION;

    status = RpcClientHasUserSid(gpConsoleUser->GetSid()) ? NO_ERROR : ERROR_INVALID_FUNCTION;
    if (!status)
    {
	LockGlobalLists();

	status = ERROR_BAD_DEVICE;    // Cannot find the device specified

	pos = gplistCuUserLoads->GetHeadPosition();
	while (pos) {
	    CCuUserLoad *pCuUserLoad = gplistCuUserLoads->GetAt(pos);
	    if (pCuUserLoad->GetId() == dwGfxId) {
	        hGfxFilter = pCuUserLoad->GetFilterHandle();
	        status = (INVALID_HANDLE_VALUE != hGfxFilter) ? NO_ERROR : GetLastError();
	        break;
	    }
	    gplistCuUserLoads->GetNext(pos);
	}

	if (!status)
	{
	    hClientProcess = OpenProcess(PROCESS_DUP_HANDLE, FALSE, dwProcessId);
	    if (hClientProcess)
	    {
	        HANDLE hGfxFilterClient;

	        if (DuplicateHandle(GetCurrentProcess(), hGfxFilter, hClientProcess, &hGfxFilterClient, 0, FALSE, DUPLICATE_SAME_ACCESS))
	        {
	            dprintf(TEXT("hGfxFilter=%p, hGfxFilterClient=%p\n"), hGfxFilter, hGfxFilterClient);
	            *pFileHandle = (RHANDLE)hGfxFilterClient;
	        } else {
	            status = GetLastError();
	        }
	        CloseHandle(hClientProcess);
	    } else {
	        status = GetLastError();
	    }
	}

	UnlockGlobalLists();

    }

    RtlReleaseResource(&GfxResource);
    
    return status;
}

//=============================================================================
//===   Startup/shutdown   ===
//=============================================================================

void EnumeratedInterface(LPCGUID ClassGuid, PCTSTR DeviceInterface)
{
    if (IsEqualGUID(KSCATEGORY_AUDIO,         *ClassGuid)) GFX_AudioInterfaceArrival(DeviceInterface);
    if (IsEqualGUID(KSCATEGORY_RENDER,        *ClassGuid)) GFX_RenderInterfaceArrival(DeviceInterface);
    if (IsEqualGUID(KSCATEGORY_CAPTURE,       *ClassGuid)) GFX_CaptureInterfaceArrival(DeviceInterface);
    if (IsEqualGUID(KSCATEGORY_DATATRANSFORM, *ClassGuid)) GFX_DataTransformInterfaceArrival(DeviceInterface);
    if (IsEqualGUID(KSCATEGORY_SYSAUDIO,      *ClassGuid)) GFX_SysaudioInterfaceArrival(DeviceInterface);
    return;
}

void EnumerateInterfaces(LPCGUID ClassGuid)
{
    HDEVINFO hdi;

    hdi = SetupDiGetClassDevs(ClassGuid, NULL, NULL, DIGCF_DEVICEINTERFACE | DIGCF_PRESENT);
    if (hdi) {
        DWORD i;
        BOOL fresult;

        i = (-1);
        do {
            SP_DEVICE_INTERFACE_DATA DeviceInterfaceData;

            i += 1;
            DeviceInterfaceData.cbSize = sizeof(DeviceInterfaceData);
            fresult = SetupDiEnumDeviceInterfaces(hdi, NULL, ClassGuid, i, &DeviceInterfaceData);
            if (fresult) {
                DWORD cbDeviceInterfaceDetailData;

                if (   SetupDiGetDeviceInterfaceDetail(hdi, &DeviceInterfaceData, NULL, 0, &cbDeviceInterfaceDetailData, NULL)
                    || ERROR_INSUFFICIENT_BUFFER == GetLastError())
                {
                    PSP_DEVICE_INTERFACE_DETAIL_DATA DeviceInterfaceDetailData;

                    DeviceInterfaceDetailData = (PSP_DEVICE_INTERFACE_DETAIL_DATA)HeapAlloc(hHeap, 0, cbDeviceInterfaceDetailData);
                    if (DeviceInterfaceDetailData) {
                        DeviceInterfaceDetailData->cbSize = sizeof(*DeviceInterfaceDetailData);
                        if (SetupDiGetDeviceInterfaceDetail(hdi, &DeviceInterfaceData, DeviceInterfaceDetailData, cbDeviceInterfaceDetailData, NULL, NULL)) {
			    EnumeratedInterface(ClassGuid, DeviceInterfaceDetailData->DevicePath);
                        }
                        HeapFree(hHeap, 0, DeviceInterfaceDetailData);
                    }
                }
            }
        } while (fresult);

        SetupDiDestroyDeviceInfoList(hdi);
    }
    return;
}


void Initialize(void)
{
    LONG result;

    ASSERT(FALSE == gfGfxInitialized);

    // dprintf(TEXT("GFX_Initialize\n"));
    
    //
    // Sysaudio critical section
    //
    ASSERT(!gfCsSysaudio);
    __try {
        InitializeCriticalSection(&gcsSysaudio);
        gfCsSysaudio = TRUE;
        result = NO_ERROR;
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        result = ERROR_OUTOFMEMORY;
    }

    //
    // Create gobal lists
    //
    if (NO_ERROR == result)
    {
        gplistGfxFactories = new CListGfxFactories;
        gplistZoneFactories = new CListZoneFactories;
        gplistCuUserLoads = new CListCuUserLoads;
        
        if (gplistGfxFactories && gplistZoneFactories && gplistCuUserLoads)
        {
            result = gplistGfxFactories->Initialize();
            if (NO_ERROR == result) result = gplistZoneFactories->Initialize();
            if (NO_ERROR == result) result = gplistCuUserLoads->Initialize();
    
        } else {
            result = ERROR_OUTOFMEMORY;
        }
    }

    if (NO_ERROR == result) {

        gfGfxInitialized = TRUE;

        //
        // Fill global lists
        //
        // Note we do not acquire global lists lock.  We assume that this
        // function is called before any other functions that might access
        // the lists.
        //
        
        CCuUserLoad::FillListFromReg(gpConsoleUser, *gplistCuUserLoads);

        // Pnp notifications are already set up.  We need to enumerate any     |
        // existing interfaces.  We don't really need to enumerate render,
        // capture, and datatransform since we check for those aliases when we
        // check audio interfaces.  If a capture, render, or datatransform
        // interface is not yet enabled when we check an audio interface, then
        // we will get it via pnp notification.
        EnumerateInterfaces(&KSCATEGORY_SYSAUDIO);
        EnumerateInterfaces(&KSCATEGORY_AUDIO);
        // EnumerateInterfaces(&KSCATEGORY_RENDER);
        // EnumerateInterfaces(&KSCATEGORY_CAPTURE);
        // EnumerateInterfaces(&KSCATEGORY_DATATRANSFORM);
        

    } else {

        //
        // Unwind due to error
        //
        if (gplistGfxFactories) delete gplistGfxFactories;
        if (gplistZoneFactories) delete gplistZoneFactories;
        if (gplistCuUserLoads) delete gplistCuUserLoads;
        gplistGfxFactories = NULL;
        gplistZoneFactories = NULL;
        gplistCuUserLoads = NULL;
        
        if (gfCsSysaudio) DeleteCriticalSection(&gcsSysaudio);
        gfCsSysaudio = FALSE;
        
    }

    return;
}


void Terminate(void)
{
    POSITION pos;

    // dprintf(TEXT("GFX_Terminate\n"));

    gfGfxInitialized = FALSE;
    
    //
    // Clean up glistGfxFactories, glistZoneFactories, glistUserLoads
    //
    if (gplistCuUserLoads) {
        pos = gplistCuUserLoads->GetHeadPosition();
        while (pos) {
                CCuUserLoad *pCuUserLoad = gplistCuUserLoads->GetNext(pos);
                delete pCuUserLoad;
        }
        gplistCuUserLoads->RemoveAll();
        delete gplistCuUserLoads;
        gplistCuUserLoads = NULL;
    }

    if (gplistGfxFactories) {
        pos = gplistGfxFactories->GetHeadPosition();
        while (pos) {
                CGfxFactory *pGfxFactory = gplistGfxFactories->GetNext(pos);
                delete pGfxFactory;
        }
        gplistGfxFactories->RemoveAll();
        delete gplistGfxFactories;
        gplistGfxFactories = NULL;
    }

    if (gplistZoneFactories) {
        pos = gplistZoneFactories->GetHeadPosition();
        while (pos) {
                CZoneFactory *pZoneFactory = gplistZoneFactories->GetNext(pos);
                delete pZoneFactory;
        }
        gplistZoneFactories->RemoveAll();
        delete gplistZoneFactories;
        gplistZoneFactories = NULL;
    }

    //
    // Close sysaudio
    //
    if (INVALID_HANDLE_VALUE != ghSysaudio) {
        CloseHandle(ghSysaudio);
        HeapFree(hHeap, 0, gpstrSysaudioDeviceInterface);
        ghSysaudio = INVALID_HANDLE_VALUE;
        gpstrSysaudioDeviceInterface = NULL;
    }

    //
    // Sysaudio critical section
    //
    if (gfCsSysaudio) DeleteCriticalSection(&gcsSysaudio);
    gfCsSysaudio = FALSE;

    //
    // Console user
    //
    if (gpConsoleUser) delete gpConsoleUser;
    gpConsoleUser = NULL;

    return;
}

/*-----------------------------------------------------------------------------

    InitializeForNewConsoleUser

    Evaluates current console user.  If the user is different than before,
    then terminate and reinitialize the GFX objects and data structures.

    Assume GfxResource is acquired exclusive.
    
    Assumes gdwConsoleSessionId has been set properly.

    Might change gpConsoleUserSid.
    
-----------------------------------------------------------------------------*/
void InitializeForNewConsoleUser(DWORD ConsoleSessionId)
{
    CUser *pOldConsoleUser = gpConsoleUser;
    CUser *pNewConsoleUser = NULL;
    BOOL IsNewConsoleUser  = TRUE;

    CreateUser(ConsoleSessionId, &pNewConsoleUser);
    
    if ((!pNewConsoleUser && !pOldConsoleUser) ||
    	(pNewConsoleUser && pOldConsoleUser && (*pNewConsoleUser == *pOldConsoleUser)))
    {
    	IsNewConsoleUser = FALSE;
    }

    if (IsNewConsoleUser)
    {
    	Terminate();
    	gpConsoleUser = pNewConsoleUser;
    	if (gpConsoleUser)
    	{
   	    #ifdef DBG
    	    {
    	        PTSTR StringSid;
    	        if (CreateStringSidFromSid(gpConsoleUser->GetSid(), &StringSid))
    	        {
    	            dprintf(TEXT("note: new console user SID %s\n"), StringSid);
    	            HeapFree(hHeap, 0, StringSid);
    	        }
    	    }
    	    #endif
    	    Initialize();
    	}

    } else {
        delete pNewConsoleUser;
    }

    return;
}

void GFX_SessionChange(DWORD EventType, LPVOID EventData)
{
    PWTSSESSION_NOTIFICATION pWtsNotification = (PWTSSESSION_NOTIFICATION)EventData;
    static DWORD ConsoleSessionId = 0;	// Initial console session ID

    switch (EventType)
    {
    	case WTS_CONSOLE_CONNECT:
    	{
            RtlAcquireResourceExclusive(&GfxResource, TRUE);
            ConsoleSessionId = pWtsNotification->dwSessionId;
            InitializeForNewConsoleUser(ConsoleSessionId);
            RtlReleaseResource(&GfxResource);
    	    break;
    	}
        case WTS_CONSOLE_DISCONNECT:
        {
            RtlAcquireResourceExclusive(&GfxResource, TRUE);
            Terminate();
            ConsoleSessionId = LOGONID_NONE;
            RtlReleaseResource(&GfxResource);
            break;
        }
        case WTS_REMOTE_CONNECT:
       	{
       	    break;
       	}
       	case WTS_REMOTE_DISCONNECT:
       	{
       	    break;
       	}
    	case WTS_SESSION_LOGON:
    	{
            RtlAcquireResourceExclusive(&GfxResource, TRUE);
            if (ConsoleSessionId == pWtsNotification->dwSessionId) InitializeForNewConsoleUser(ConsoleSessionId);
            RtlReleaseResource(&GfxResource);
	    break;
    	}
	case WTS_SESSION_LOGOFF:
	{
            RtlAcquireResourceExclusive(&GfxResource, TRUE);
            if (ConsoleSessionId == pWtsNotification->dwSessionId) Terminate();
            RtlReleaseResource(&GfxResource);
	    break;
	}
        default:
        {
            dprintf(TEXT("GFX_SessionChange: Unhandled EventType=%d\n"), EventType);
            break;
        }
    }
    
    return;
}

void GFX_ServiceStop(void)
{
    RtlAcquireResourceExclusive(&GfxResource, TRUE);
    Terminate();
    RtlReleaseResource(&GfxResource);
    return;
}

void s_gfxLogon(IN handle_t hBinding, IN DWORD dwProcessId)
{
    // dprintf(TEXT("s_gfxLogon\n"));
    // ISSUE-2001/01/29-FrankYe I should be able to completely remove this and
    // s_gfxLogoff after Windows Bugs 296884 is fixed.
    return;
}

void s_gfxLogoff(void)
{
    // dprintf(TEXT("s_gfxLogoff\n"));
    return;
}

//=============================================================================
//===   GFX-specific DLL attach/detach   ===
//=============================================================================

BOOL GFX_DllProcessAttach(void)
{
   BOOL result;
   NTSTATUS ntstatus;

    __try {
        RtlInitializeResource(&GfxResource);
        ntstatus = STATUS_SUCCESS;
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        ntstatus = GetExceptionCode();
    }
    gfGfxResource = (NT_SUCCESS(ntstatus));
    result = (NT_SUCCESS(ntstatus));

    return result;
}

void GFX_DllProcessDetach(void)
{
    if (gfGfxResource) {
    	RtlDeleteResource(&GfxResource);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\audiosrv\ksi.cpp ===
#include <windows.h>
#include <objbase.h>
#include <devioctl.h>
#include <ks.h>
#include <ksmedia.h>
#include "debug.h"
#include "reg.h"
#include "ksi.h"

extern "C" HANDLE hHeap;

const int StrLenGuid = 38; // "{01234567-0123-0123-0123-012345678901}"
__inline void MyStringFromGuid(PTSTR pstr, LPCGUID Guid)
{
    wsprintf(pstr, TEXT("{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}"),
                   Guid->Data1,
                   Guid->Data2,
                   Guid->Data3,
                   Guid->Data4[0], Guid->Data4[1],
                   Guid->Data4[2], Guid->Data4[3], Guid->Data4[4], Guid->Data4[5], Guid->Data4[6], Guid->Data4[7]);
}

LONG KsGetFilterStatePropertySets(IN HANDLE hKsObject, OUT GUID *ppaPropertySets[], OUT int *pcPropertySets)
{
    KSPROPERTY Property;
    ULONG cbData;
    LONG result;

    Property.Set = KSPROPSETID_Audio;
    Property.Id = KSPROPERTY_AUDIO_FILTER_STATE;
    Property.Flags = KSPROPERTY_TYPE_GET;

    if (DeviceIoControl(hKsObject, IOCTL_KS_PROPERTY,
                        &Property, sizeof(Property),
                        NULL, 0,
                        &cbData, NULL))
    {
        // dprintf(TEXT("KsGetFilterStatePropertySets: succeeded, cbData=%d\n"), cbData);
        result = NO_ERROR;
    } else {
        result = GetLastError();
        // dprintf(TEXT("KsGetFilterStatePropertySets: failed getting FilterState property size, LastError=%d\n"), result);
        if (ERROR_MORE_DATA == result) {
            // dprintf(TEXT("KsGetFilterStatePropertySets: note: %d bytes in FilterState\n"), cbData);
            result = NO_ERROR;
        }
    }

    if (NO_ERROR == result) {
        if (cbData > 0) {
            LPGUID paPropertySets;
            paPropertySets = (LPGUID)HeapAlloc(hHeap, 0, cbData);
            if (paPropertySets) {

                Property.Set = KSPROPSETID_Audio;
                Property.Id = KSPROPERTY_AUDIO_FILTER_STATE;
                Property.Flags = KSPROPERTY_TYPE_GET;

                if (DeviceIoControl(hKsObject, IOCTL_KS_PROPERTY,
                                    &Property, sizeof(Property),
                                    paPropertySets, cbData,
                                    &cbData, NULL))
                {
                    *ppaPropertySets = paPropertySets;
                    *pcPropertySets = cbData / sizeof(paPropertySets[0]);
                } else {
                    result = GetLastError();
                    // dprintf(TEXT("KsGetFilterStatePropertySets: failed getting FilterState property, LastError=%d\n"), result);
                }

                if (NO_ERROR != result) {
                    HeapFree(hHeap, 0, paPropertySets);
                }

            } else {
                result = ERROR_OUTOFMEMORY;
            }
        } else {
            *ppaPropertySets = NULL;
            *pcPropertySets = 0;
        }
    }

    return result;
}

LONG KsSerializePropertySetToReg(IN HANDLE hKsObject, IN LPCGUID PropertySet, IN HKEY hKey)
{
    TCHAR strGuid[StrLenGuid+1];
    KSPROPERTY Property;
    ULONG cbData;
    LONG result;

    MyStringFromGuid(strGuid, PropertySet);

    // dprintf(TEXT("KsSerializePropertySetToReg: note: serializing set %s\n"), strGuid);

    Property.Set = *PropertySet;
    Property.Id = 0;
    Property.Flags = KSPROPERTY_TYPE_SERIALIZESET;

    if (DeviceIoControl(hKsObject, IOCTL_KS_PROPERTY,
                        &Property, sizeof(Property),
                        NULL, 0,
                        &cbData, NULL))
    {
        // dprintf(TEXT("KsSerializePropertySetToReg: succeeded, cbData=%d\n"), cbData);
        result = NO_ERROR;
    } else {
        result = GetLastError();
        // dprintf(TEXT("KsSerializePropertySetToReg: failed getting serialized size, LastError=%d\n"), result);
        if (ERROR_MORE_DATA == result) {
            // dprintf(TEXT("KsSerializePropertySetToReg: note: %d bytes to serialize\n"), cbData);
            result = NO_ERROR;
        }
    }

    if (NO_ERROR == result && cbData > 0) {
        PVOID pvData = HeapAlloc(hHeap, 0, cbData);
        if (pvData) {
            Property.Set = *PropertySet;
            Property.Id = 0;
            Property.Flags = KSPROPERTY_TYPE_SERIALIZESET;

            if (DeviceIoControl(hKsObject, IOCTL_KS_PROPERTY,
                                &Property, sizeof(Property),
                                pvData, cbData,
                                &cbData, NULL))
            {
                result = RegSetBinaryValue(hKey, strGuid, (PBYTE)pvData, cbData);
            } else {
                result = GetLastError();
                // dprintf(TEXT("KsSerializePropertySetToReg: failed to serialize, LastError=%d\n"), result);
            }
            HeapFree(hHeap, 0, pvData);
        } else {
            result = ERROR_OUTOFMEMORY;
        }
    }

    return result;
}

LONG KsSerializeFilterStateToReg(IN HANDLE hKsObject, IN HKEY hKey)
{
    LPGUID paPropertySets;
    int cPropertySets;
    LONG result;
    
    result = KsGetFilterStatePropertySets(hKsObject, &paPropertySets, &cPropertySets);
    if (NO_ERROR == result && cPropertySets > 0) {
        int i;
        for (i = 0; i < cPropertySets; i++) {
            KsSerializePropertySetToReg(hKsObject, &paPropertySets[i], hKey);
        }
        HeapFree(hHeap, 0, paPropertySets);
    }

    return result;
}

LONG KsUnserializePropertySetFromReg(IN HANDLE hKsObject, IN LPCGUID PropertySet, IN HKEY hKey)
{
    TCHAR strGuid[StrLenGuid+1];
    KSPROPERTY Property;
    PBYTE pData;
    ULONG cbData;
    LONG result;

    MyStringFromGuid(strGuid, PropertySet);

    // dprintf(TEXT("KsUnserializePropertySetFromReg: note: serializing set %s\n"), strGuid);

    result = RegQueryBinaryValue(hKey, strGuid, (PBYTE*)&pData, &cbData);
    if (NO_ERROR == result) {
        Property.Set = *PropertySet;
        Property.Id = 0;
        Property.Flags = KSPROPERTY_TYPE_UNSERIALIZESET;
    
        if (DeviceIoControl(hKsObject, IOCTL_KS_PROPERTY,
                            &Property, sizeof(Property),
                            pData, cbData,
                            &cbData, NULL))
        {
            // dprintf(TEXT("KsUnserializePropertySetFromReg: succeeded\n"));
            result = NO_ERROR;
        } else {
            result = GetLastError();
            // dprintf(TEXT("KsUnserializePropertySetFromReg: failed to unserialize, LastError=%d\n"), result);
        }

        HeapFree(hHeap, 0, pData);
    }
    return result;
}

LONG KsUnserializeFilterStateFromReg(IN HANDLE hKsObject, IN HKEY hKey)
{
    LPGUID paPropertySets;
    int cPropertySets;
    LONG result;
    
    result = KsGetFilterStatePropertySets(hKsObject, &paPropertySets, &cPropertySets);
    if (NO_ERROR == result && cPropertySets > 0) {
        int i;
        for (i = 0; i < cPropertySets; i++) {
            KsUnserializePropertySetFromReg(hKsObject, &paPropertySets[i], hKey);
        }
        HeapFree(hHeap, 0, paPropertySets);
    }

    return result;
}

LONG KsSetAudioGfxXxxTargetDeviceId(IN HANDLE hGfx, IN ULONG PropertyId, IN PCTSTR DeviceId)
{
    KSPROPERTY Property;
    ULONG cbData;
    LONG result;

    ASSERT(hGfx);
    ASSERT(!IsBadStringPtr(DeviceId, (UINT_PTR)(-1)));
    ASSERT(lstrlen(DeviceId));

    Property.Set = KSPROPSETID_AudioGfx;
    Property.Id = PropertyId;
    Property.Flags = KSPROPERTY_TYPE_SET;

    cbData = (lstrlen(DeviceId) + 1) * sizeof(DeviceId[0]);

    if (DeviceIoControl(hGfx, IOCTL_KS_PROPERTY,
                        &Property, sizeof(Property),
                        (LPVOID)DeviceId, cbData,
                        &cbData, NULL))
    {
        result = NO_ERROR;
    } else {
        result = GetLastError();
        dprintf(TEXT("KsSetAudioGfxXxxTargetDeviceId: failed, LastError=%d\n"), result);
    }

    return result;
}

LONG KsSetAudioGfxRenderTargetDeviceId(IN HANDLE hGfx, IN PCTSTR DeviceId)
{
    return KsSetAudioGfxXxxTargetDeviceId(hGfx, KSPROPERTY_AUDIOGFX_RENDERTARGETDEVICEID, DeviceId);
}

LONG KsSetAudioGfxCaptureTargetDeviceId(IN HANDLE hGfx, IN PCTSTR DeviceId)
{
    return KsSetAudioGfxXxxTargetDeviceId(hGfx, KSPROPERTY_AUDIOGFX_CAPTURETARGETDEVICEID, DeviceId);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\audiosrv\agfxsp.h ===
/* agfxsp.h
 * header for agfxs.cpp
 * Copyright (c) 2000-2001 Microsoft Corporation
 */


#define ZONETYPE_RENDER 1
#define ZONETYPE_CAPTURE 2
#define ZONETYPE_RENDERCAPTURE 3

typedef CList<class CGfxFactory*, class CGfxFactory*>   CListGfxFactories;
typedef CList<class CZoneFactory*, class CZoneFactory*> CListZoneFactories;
typedef CList<class CLmAutoLoad*, class CLmAutoLoad*>   CListLmAutoLoads;
typedef CList<class CCuUserLoad*, class CCuUserLoad*>   CListCuUserLoads;

//===   CUser   ===
class CUser {
public:
	CUser(void);
	~CUser(void);

	BOOL  operator==(const CUser &other);
	
	PSID  GetSid(void);
	LONG  Initialize(DWORD SessionId);
        LONG  RegOpen(IN REGSAM samDesired, OUT PHKEY phkResult);

private:
        void  CloseUserRegistry(void);
        BOOL  OpenUserRegistry(void);
        
        HANDLE           m_hUserToken;
	DWORD            m_SessionId;
	PSID             m_pSid;
	CRITICAL_SECTION m_csRegistry;
	BOOL             m_fcsRegistry;
	LONG             m_refRegistry;
	HKEY             m_hRegistry;
};

//===   CCuUserLoad   ===
class CCuUserLoad {
public:
	CCuUserLoad(CUser *pUser);
	~CCuUserLoad(void);

	LONG     AddToZoneGraph(CZoneFactory *pZoneFactory);
	LONG     CreateFromAutoLoad(ULONG CuAutoLoadId);
	LONG     CreateFromUser(PCTSTR GfxFactoryDi, PCTSTR ZoneFactoryDi, ULONG Type, ULONG Order);
	LONG     Erase(void);
	HANDLE   GetFilterHandle(void);
	PCTSTR   GetGfxFactoryDi(void);
	LONG     GetGfxFactoryClsid(CListGfxFactories &rlistGfxFactories, LPCLSID pClsid);
	DWORD    GetId(void);
	ULONG    GetOrder(void);
	ULONG    GetType(void);
	PCTSTR   GetZoneFactoryDi(void);
	LONG     Initialize(PCTSTR pstrCuAutoLoad);
	LONG     ModifyOrder(ULONG NewOrder);
        LONG     RegCreateFilterKey(IN PCTSTR SubKey, IN REGSAM samDesired, OUT PHKEY phkResult);
        LONG     RegOpenFilterKey(IN PCTSTR SubKey, IN REGSAM samDesired, OUT PHKEY phkResult);
        void     RemoveFromZoneGraph(void);
	LONG     Scan(CListZoneFactories &rlistZoneFactories, CListGfxFactories &rlistGfxFactories);
	LONG     Write(void);

	static void FillListFromReg(CUser *pUser, CListCuUserLoads& rlistCuUserLoads);
	static void ListRemoveGfxFactoryDi(IN CListCuUserLoads &rlistCuUserLoads, IN PCTSTR DeviceInterface);
        static void ListRemoveZoneFactoryDi(IN CListCuUserLoads &rlistCuUserLoads, IN PCTSTR DeviceInterface);
        static void ListRemoveZoneFactoryDiCapture(IN CListCuUserLoads &rlistCuUserLoads, IN PCTSTR DeviceInterface);
        static void ListRemoveZoneFactoryDiRender(IN CListCuUserLoads &rlistCuUserLoads, IN PCTSTR DeviceInterface);
	static void ScanList(CListCuUserLoads& rlistCuUsrLoads, CListZoneFactories& rlistZoneFactories, CListGfxFactories& rlistGfxFactories);

private:
        LONG     AddGfxToGraph(void);
        LONG     ChangeGfxOrderInGraph(IN ULONG NewOrder);
        LONG     RemoveFromGraph(void);
	BOOL     WinsConflictWith(CCuUserLoad *pOther);
        
	CUser   *m_User;
	
	ULONG    m_CuUserLoadId;
	ULONG    m_CuAutoLoadId;
	PTSTR    m_GfxFactoryDi;
	PTSTR    m_ZoneFactoryDi;
	ULONG    m_Type;
        ULONG    m_Order;
        

	HANDLE   m_FilterHandle;
	LONG     m_ErrorFilterCreate;

        CZoneFactory *m_pZoneFactory;
	POSITION      m_posZoneGfxList;
	
};

//===   CCuAutoLoad   ===
class CCuAutoLoad {
public:
	CCuAutoLoad(CUser *pUser);
	~CCuAutoLoad(void);

	LONG   Create(PCTSTR ZoneFactoryDi, ULONG LmAutoLoadId);
	LONG   Erase(void);
	PCTSTR GetGfxFactoryDi(void);
	ULONG  GetLmAutoLoadId(void);
	ULONG  GetType(void);
	PCTSTR GetZoneFactoryDi(void);
	LONG   Initialize(ULONG CuAutoLoadId);
	LONG   Write(void);

	static void ScanReg(IN CUser *pUser, IN PCTSTR ZoneFactoryDi, IN ULONG LmAutoLoadId, IN CListCuUserLoads &rlistCuUserLoads);

private:
	CUser *m_User;
	ULONG  m_CuAutoLoadId;
	ULONG  m_LmAutoLoadId;
	PTSTR  m_ZoneFactoryDi;
	PTSTR  m_GfxFactoryDi;
	ULONG  m_Type;
};

//===   CLmAutoLoad   ===
class CLmAutoLoad {
public:
	CLmAutoLoad(void);
	~CLmAutoLoad(void);

	LONG   Create(DWORD Id, PCTSTR GfxFactoryDi, PCTSTR HardwareId, PCTSTR ReferenceString, ULONG Type);
	LONG   Erase(void);
	PCTSTR GetGfxFactoryDi(void);
	ULONG  GetType(void);
	LONG   Initialize(DWORD Id);
	BOOL   IsCompatibleZoneFactory(CZoneFactory& rZoneFactory);
	LONG   Write(void);

	static CListLmAutoLoads* CreateListFromReg(void);
	static void DestroyList(CListLmAutoLoads* pListLmAutoLoads);
	static void ScanRegOnGfxFactory(CUser *pUser, CGfxFactory& rGfxFactory, CListZoneFactories &rlistZoneFactories, CListCuUserLoads &rlistCuUserLoads);
        static void ScanRegOnZoneFactory(CUser *pUser, CZoneFactory& rZoneFactory, CListGfxFactories &rlistGfxFactories, CListCuUserLoads &rlistCuUserLoads);

private:
	DWORD m_Id;
	PTSTR m_GfxFactoryDi;
	PTSTR m_HardwareId;
	PTSTR m_ReferenceString;
	ULONG m_Type;
};

//===   CInfAutoLoad   ===
class CInfAutoLoad {
public:
	CInfAutoLoad();
	~CInfAutoLoad();

	LONG Initialize(HKEY hkey, CGfxFactory *pGfxFactory);
	LONG Scan(void);
	
        static LONG ScanReg(HKEY hkey, CGfxFactory *pGfxFactory);

private:
	CGfxFactory *m_pGfxFactory;
	HKEY  m_hkey;
	DWORD m_Id;
	DWORD m_NewAutoLoad;

	PTSTR m_GfxFactoryDi;
	PTSTR m_HardwareId;
	PTSTR m_ReferenceString;
	ULONG m_Type;
};

//===   CGfxFactory   ===
class CGfxFactory {
public:
	CGfxFactory();
	~CGfxFactory();

	REFCLSID          GetClsid(void);
	PCTSTR            GetDeviceInterface(void);
        CListLmAutoLoads& GetListLmAutoLoads(void);
	LONG              Initialize(HKEY hkey, PCTSTR DeviceInterface);
	BOOL              IsCompatibleZoneFactory(IN ULONG Type, IN CZoneFactory& rZoneFactory);

        static void         ListRemoveGfxFactoryDi(IN CListGfxFactories &rlistGfxFactories, IN PCTSTR DeviceInterface);
        static CGfxFactory* ListSearchOnDi(IN CListGfxFactories& rlistGfxFactories, IN PCTSTR GfxFactoryDi);

private:
        CListLmAutoLoads *m_plistLmAutoLoads;
	PTSTR m_DeviceInterface;
	CLSID m_Clsid;
};

//===   CZoneFactory   ===
class CZoneFactory {
public:
	CZoneFactory(void);
	~CZoneFactory(void);

	LONG          AddType(IN ULONG Type);
	PCTSTR        GetDeviceInterface(void);
        PCTSTR        GetTargetHardwareId(void);
	BOOL          HasHardwareId(IN PCTSTR HardwareId);
	BOOL          HasReferenceString(IN PCTSTR ReferenceString);
	BOOL          HasCompatibleType(IN ULONG Type);
	LONG          Initialize(IN PCTSTR DeviceInterface, IN ULONG Type);
        LONG          RemoveType(IN ULONG Type);

        static void          ListRemoveZoneFactoryDi(IN CListZoneFactories &rlistZoneFactories, IN PCTSTR DeviceInterface);
        static void          ListRemoveZoneFactoryDiCapture(IN CListZoneFactories &rlistZoneFactories, IN PCTSTR DeviceInterface);
        static void          ListRemoveZoneFactoryDiRender(IN CListZoneFactories &rlistZoneFactories, IN PCTSTR DeviceInterface);
	static CZoneFactory* ListSearchOnDi(IN CListZoneFactories& rlistZoneFactories, IN PCTSTR ZoneFactoryDi);

	CListCuUserLoads m_listCaptureGfxs;
	CListCuUserLoads m_listRenderGfxs;
	
private:
	PTSTR            m_DeviceInterface;
	PTSTR            m_HardwareId;
	PTSTR            m_ReferenceString;
	ULONG            m_Type;
	
	
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\audiosrv\mme.cpp ===
/* mme.cpp
 * Handles pnp, etc. for MME APIs
 * Created by FrankYe on 2/14/2001
 * Copyright (c) 2001-2001 Microsoft Corporation
 */

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <regstr.h>
#include <mmsystem.h>
#include <mmsysp.h>
#include <ks.h>
#include <ksmedia.h>
#include <setupapi.h>

#include "debug.h"
#include "reg.h"
#include "service.h"
#include "audiosrv.h"

//=============================================================================
//===   file scope constants   ===
//=============================================================================
#define REGSTR_VAL_SETUPPREFERREDAUDIODEVICES      TEXT("SetupPreferredAudioDevices")
#define REGSTR_VAL_SETUPPREFERREDAUDIODEVICESCOUNT TEXT("SetupPreferredAudioDevicesCount")

#define PNPINFOSIZE     (256 * 1024)

//=============================================================================
//===   file scope globals   ===
//=============================================================================
RTL_RESOURCE PnpInfoResource;
BOOL         gfPnpInfoResource = FALSE;
HANDLE       hPnpInfo = NULL;
PMMPNPINFO   pPnpInfo = NULL;

//=============================================================================
//===   security helpers   ===
//=============================================================================

PSECURITY_DESCRIPTOR BuildSecurityDescriptor(DWORD AccessMask)
{
    PSECURITY_DESCRIPTOR pSd;
    PSID pSidSystem;
    PSID pSidEveryone;
    PACL pDacl;
    ULONG cbDacl;
    BOOL fSuccess;
    BOOL f;

    SID_IDENTIFIER_AUTHORITY AuthorityNt = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY AuthorityWorld = SECURITY_WORLD_SID_AUTHORITY;

    fSuccess = FALSE;

    pSd = HeapAlloc(hHeap, 0, SECURITY_DESCRIPTOR_MIN_LENGTH);
    if (pSd)
    {
	if (InitializeSecurityDescriptor(pSd, SECURITY_DESCRIPTOR_REVISION))
	{
	    if (AllocateAndInitializeSid(&AuthorityNt, 1, SECURITY_LOCAL_SYSTEM_RID, 0, 0, 0, 0, 0, 0, 0, &pSidSystem))
	    {
		ASSERT(IsValidSid(pSidSystem));
		if (AllocateAndInitializeSid(&AuthorityWorld, 1, SECURITY_WORLD_RID, 0, 0, 0, 0, 0, 0, 0, &pSidEveryone))
		{
		    ASSERT(IsValidSid(pSidEveryone));
		    cbDacl = sizeof(ACL) +
			     2 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) +
			     GetLengthSid(pSidSystem) +
			     GetLengthSid(pSidEveryone);

		    pDacl = (PACL)HeapAlloc(hHeap, 0, cbDacl);
		    if (pDacl) {
			if (InitializeAcl(pDacl, cbDacl, ACL_REVISION))
			{
			    if (AddAccessAllowedAce(pDacl, ACL_REVISION, GENERIC_ALL, pSidSystem))
			    {
				if (AddAccessAllowedAce(pDacl, ACL_REVISION, AccessMask, pSidEveryone))
				{
				    if (SetSecurityDescriptorDacl(pSd, TRUE, pDacl, FALSE))
				    {
					fSuccess = TRUE;
				    } else {
					dprintf(TEXT("BuildSD: SetSecurityDescriptorDacl failed\n"));
				    }
				} else {
				    dprintf(TEXT("BuildSD: AddAccessAlloweAce for Everyone failed\n"));
				}
			    } else {
				dprintf(TEXT("BuildSD: AddAccessAllowedAce for System failed\n"));
			    }
			} else {
			    dprintf(TEXT("BuildSD: InitializeAcl failed\n"));
			}

			if (!fSuccess) {
			    f = HeapFree(hHeap, 0, pDacl);
			    ASSERT(f);
			}
		    }
		    FreeSid(pSidEveryone);
		} else {
		    dprintf(TEXT("BuildSD: AllocateAndInitizeSid failed for Everyone\n"));
		}
		FreeSid(pSidSystem);
	    } else {
		dprintf(TEXT("BuildSD: AllocateAndInitizeSid failed for System\n"));
	    }
	} else {
	    dprintf(TEXT("BuildSD: InitializeSecurityDescriptor failed\n"));
	}

	if (!fSuccess) {
	    f = HeapFree(hHeap, 0, pSd);
	    ASSERT(f);
	}
    }

    return fSuccess ? pSd : NULL;
}

void DestroySecurityDescriptor(PSECURITY_DESCRIPTOR pSd)
{
    PACL pDacl;
    BOOL fDaclPresent;
    BOOL fDaclDefaulted;
    BOOL f;

    if (GetSecurityDescriptorDacl(pSd, &fDaclPresent, &pDacl, &fDaclDefaulted))
    {
	if (fDaclPresent)
	{
	    f = HeapFree(hHeap, 0, pDacl);
	    ASSERT(f);
	}
    } else {
	dprintf(TEXT("DestroySD: GetSecurityDescriptorDacl failed\n"));
    }

    f = HeapFree(hHeap, 0, pSd);
    ASSERT(f);

    return;
}

//=============================================================================
//===      ===
//=============================================================================



//--------------------------------------------------------------------------;
//
// PTSTR BroadcastWinmmDeviceChange
//
// Arguments:
//
// Return value:
//
// History:
//	11/9/98		FrankYe		Created
//      2/15/2001       FrankYe         Moved from winmm to audiosrv
//
//--------------------------------------------------------------------------;
void BroadcastWinmmDeviceChange(void)
{
    static UINT uWinmmDeviceChange = 0;

    if (!uWinmmDeviceChange) {
	uWinmmDeviceChange = RegisterWindowMessage(WINMMDEVICECHANGEMSGSTRING);
	// dprintf(TEXT("BroadcastWinmmDeviceChange: WINMMDEVICECHANGEMSG = %d\n"), uWinmmDeviceChange);
	if (!uWinmmDeviceChange) {
	    dprintf(TEXT("BroadcastWinmmDeviceChange: RegisterWindowMessage failed!\n"));
	}
    }

    if (uWinmmDeviceChange) {
	DWORD dwRecipients = BSM_APPLICATIONS | BSM_ALLDESKTOPS;
	long result;

	// dprintf(TEXT("BroadcastWinmmDeviceChange: BroadcastSystemMessage\n"));
	result = BroadcastSystemMessage(BSF_POSTMESSAGE, &dwRecipients,
					uWinmmDeviceChange, 0, 0);
	if (result < 0) {
	    dprintf(TEXT("BroadcastWinmmDeviceChange: BroadcastSystemMessage failed\n"));
	}
    }
    
    return;
}

//--------------------------------------------------------------------------;
//
// PTSTR MakeRendererDeviceInstanceIdFromDeviceInterface
//
// Arguments:
//
// Return value:
//
// History:
//	11/9/98		FrankYe		Created
//
//--------------------------------------------------------------------------;
PTSTR MakeRendererDeviceInstanceIdFromDeviceInterface(PWSTR DeviceInterface)
{
    PTSTR DeviceInstanceId;
    HDEVINFO hdi;
    DWORD dwLastError;

    // dprintf(TEXT("MRDIIFDI: DeviceInterface=%ls\n"), DeviceInterface);
    DeviceInstanceId = NULL;
    hdi = SetupDiCreateDeviceInfoList(NULL, NULL);
    if (INVALID_HANDLE_VALUE != hdi)
    {
	SP_DEVICE_INTERFACE_DATA DeviceInterfaceData;

	// dprintf(TEXT("MRDIIFDI: Created empty DeviceInfoList\n"));
	DeviceInterfaceData.cbSize = sizeof(DeviceInterfaceData);
	if (SetupDiOpenDeviceInterface(hdi, DeviceInterface, 0,
					  &DeviceInterfaceData))
	{
	    SP_DEVINFO_DATA DeviceInfoData;
	    DWORD cbDeviceInterfaceDetail;

	    // dprintf(TEXT("MRDIIFDI: Opened DeviceInterface\n"));
	    DeviceInfoData.cbSize = sizeof(DeviceInfoData);
	    if (SetupDiGetDeviceInterfaceDetail(hdi, &DeviceInterfaceData, NULL, 0, &cbDeviceInterfaceDetail, &DeviceInfoData) ||
		(ERROR_INSUFFICIENT_BUFFER == GetLastError()))
	    {
		DWORD cchDeviceInstanceId;

	        // dprintf(TEXT("MRDIIFDI: Got DeviceInfoData\n"));
		if (SetupDiGetDeviceInstanceId(hdi, &DeviceInfoData, NULL, 0, &cchDeviceInstanceId) ||
		    ERROR_INSUFFICIENT_BUFFER == GetLastError())
		{
		    // dprintf(TEXT("MRDIIFDI: DeviceInstanceId is %d characters\n"), cchDeviceInstanceId);
		    DeviceInstanceId = (PTSTR)HeapAlloc(hHeap, 0, cchDeviceInstanceId * sizeof(DeviceInstanceId[0]));
		    if (DeviceInstanceId)
		    {
			// dprintf(TEXT("MRDIIFDI: Allocated storage for DeviceInstanceId\n"));
			if (SetupDiGetDeviceInstanceId(hdi, &DeviceInfoData,
			    DeviceInstanceId,
			    cchDeviceInstanceId, NULL))
			{
			    // dprintf(TEXT("MRDIIFDI: DeviceInstanceId=%ls\n"), DeviceInstanceId);
			} else {
			    BOOL f;
			    dwLastError = GetLastError();
			    dprintf(TEXT("MRDIIFDI: Couldn't query DeviceInstanceId, LastError=%d\n"), dwLastError);
			    f = HeapFree(hHeap, 0, DeviceInstanceId);
                DeviceInstanceId = NULL;
			    ASSERT(f);
			}
		    } else {
			dprintf(TEXT("MRDIIFDI: Could not allocate storage for DeviceInstanceId\n"));
		    }
		} else {
		    dwLastError = GetLastError();
		    dprintf(TEXT("MRDIIFDI: Couldn't query size of DeviceInstanceId, LastError=%d\n"), dwLastError);
		}
	    } else {
		dwLastError = GetLastError();
		dprintf(TEXT("MRDIIFDI: SetupDiGetDeviceInterfaceDetail failed LastError=%d\n"), dwLastError);
	    }
	} else {
	    dwLastError = GetLastError();
	    dprintf(TEXT("MRDIIFDI: SetupDiOpenDeviceInterface failed, LastError=%d\n"), dwLastError);
	}

	if (!SetupDiDestroyDeviceInfoList(hdi))
	{
	    dwLastError = GetLastError();
	    dprintf(TEXT("MRDIIFDI: SetupDiDestroyDeviceInfoList failed, LastError=%d\n"), dwLastError);
	}
    } else {
	dwLastError = GetLastError();
	dprintf(TEXT("MRDIIFDI: SetupDiCreateDeviceInfoList failed, LastError=%d\n"), dwLastError);
    }
    return DeviceInstanceId;
}




//--------------------------------------------------------------------------;
//
// MigrageNewDeviceInterfaceSetup
//
// Arguments:
//
// Return value:
//
// History:
//	1/19/99		FrankYe		Created
//
//--------------------------------------------------------------------------;
void MigrateNewDeviceInterfaceSetup(PMMDEVICEINTERFACEINFO pdii, DWORD CurrentSetupCount)
{
    HDEVINFO hdi;
    DWORD dwLastError;
    DWORD SetupCount;

    SetupCount = 0;

    hdi = SetupDiCreateDeviceInfoList(NULL, NULL);
    if (INVALID_HANDLE_VALUE != hdi)
    {
	SP_DEVICE_INTERFACE_DATA DeviceInterfaceData;

	DeviceInterfaceData.cbSize = sizeof(DeviceInterfaceData);
	if (SetupDiOpenDeviceInterface(hdi, pdii->szName, 0, &DeviceInterfaceData))
	{
	    HKEY hkeyDeviceInterface;

	    hkeyDeviceInterface = SetupDiCreateDeviceInterfaceRegKeyW(hdi, &DeviceInterfaceData, 0, KEY_SET_VALUE | KEY_QUERY_VALUE, NULL, NULL);
	    if (INVALID_HANDLE_VALUE != hkeyDeviceInterface)
	    {
		LONG result;

		result = RegQueryDwordValue(hkeyDeviceInterface, REGSTR_VAL_SETUPPREFERREDAUDIODEVICESCOUNT, &SetupCount);
		if ((ERROR_SUCCESS != result) || (SetupCount < CurrentSetupCount))
		{
		    SetupCount = CurrentSetupCount;
		    if (ERROR_SUCCESS == RegSetDwordValue(hkeyDeviceInterface, REGSTR_VAL_SETUPPREFERREDAUDIODEVICESCOUNT, SetupCount))
		    {
			// dprintf(TEXT("MNDIS: Success\n"));
		    } else {
			dwLastError = GetLastError();
			dprintf(TEXT("MNDIS: RegSetValueEx failed, LastError=%d\n"), dwLastError);
		    }
		}

		result = RegCloseKey(hkeyDeviceInterface);
		ASSERT(ERROR_SUCCESS == result);
	    } else {
		dwLastError = GetLastError();
		dprintf(TEXT("MNDIS: SetupDiCreateDeviceInterfaceRegKey failed, LastError=%d\n"), dwLastError);
	    }
	} else {
	    dwLastError = GetLastError();
	    dprintf(TEXT("MRDIIFDI: SetupDiOpenDeviceInterface failed, LastError=%d\n"), dwLastError);
	}

	if (!SetupDiDestroyDeviceInfoList(hdi))
	{
	    dwLastError = GetLastError();
	    dprintf(TEXT("MRDIIFDI: SetupDiDestroyDeviceInfoList failed, LastError=%d\n"), dwLastError);
	}
    } else {
	dwLastError = GetLastError();
	dprintf(TEXT("MRDIIFDI: SetupDiCreateDeviceInfoList failed, LastError=%d\n"), dwLastError);
    }

    pdii->SetupPreferredAudioCount = SetupCount;
    return;
}


//--------------------------------------------------------------------------;
//
// MigrateNewDeviceInstanceSetup
//
// Arguments:
//
// Return value:
//
// History:
//	11/9/98		FrankYe		Created
//
//--------------------------------------------------------------------------;
void MigrateNewDeviceInstanceSetup(PTSTR DeviceInstanceId, PDWORD pSetupCountOut)
{
    HDEVINFO hdi;
    DWORD dwLastError;

    *pSetupCountOut = 0;
    
    hdi = SetupDiCreateDeviceInfoList(NULL, NULL);
    if (INVALID_HANDLE_VALUE != hdi)
    {
	SP_DEVINFO_DATA DeviceInfoData;

	// dprintf(TEXT("MNDS: Created empty DeviceInfoList\n"));
	DeviceInfoData.cbSize = sizeof(DeviceInfoData);
	if (SetupDiOpenDeviceInfoW(hdi, DeviceInstanceId, NULL, 0, &DeviceInfoData))
	{
	    HKEY hkeyDriver;

	    hkeyDriver = SetupDiOpenDevRegKey(hdi, &DeviceInfoData, DICS_FLAG_GLOBAL, 0, DIREG_DRV, KEY_QUERY_VALUE | KEY_SET_VALUE);
	    if (INVALID_HANDLE_VALUE != hkeyDriver) {
	    	HKEY hkeyMmeDrivers;
	    	
		dwLastError = RegOpenKeyEx(hkeyDriver, TEXT("Drivers"), 0, KEY_QUERY_VALUE, &hkeyMmeDrivers);
		if (ERROR_SUCCESS == dwLastError)
		{
		
	    	    DWORD fNewInstall;
		    BOOL  fSetupPreferredAudioDevices;
		    DWORD cbfSetupPreferredAudioDevices;
	            DWORD SetupCount;

	            // Read the driver's existing setup count.  If it doesn't exist
	            // then this is a new install.
		    dwLastError = RegQueryDwordValue(hkeyDriver, REGSTR_VAL_SETUPPREFERREDAUDIODEVICESCOUNT, &SetupCount);
		    if (ERROR_SUCCESS == dwLastError) {
		        fNewInstall = FALSE;
		    } else if (ERROR_FILE_NOT_FOUND == dwLastError) {
		        fNewInstall = TRUE;
		        SetupCount = 0;
		        dwLastError = ERROR_SUCCESS;
		    } else {
		        fNewInstall = FALSE;
		        SetupCount = 0;
		    }

                    if (ERROR_SUCCESS == dwLastError)
                    {
		        // Read the driver's SetupPreferredAudioDevices flag.
		        cbfSetupPreferredAudioDevices = sizeof(fSetupPreferredAudioDevices);
		        dwLastError = RegQueryValueEx(hkeyDriver, REGSTR_VAL_SETUPPREFERREDAUDIODEVICES, NULL, NULL, (PBYTE)&fSetupPreferredAudioDevices, &cbfSetupPreferredAudioDevices);
		        if (ERROR_FILE_NOT_FOUND == dwLastError) {
		            fSetupPreferredAudioDevices = FALSE;
		            dwLastError = ERROR_SUCCESS;
		        }
		
        	        // If this is a new install AND the driver .inf set the
        	        // fSetupPreferredAudioDevices flag, then let's try to
        	        // increment the machine setupcount and write the driver
        	        // setupcount.
        	        if ((ERROR_SUCCESS == dwLastError) && fNewInstall && fSetupPreferredAudioDevices)
        	        {
        		    HKEY hkeySetupPreferredAudioDevices;
        
        		    dwLastError = RegCreateKey(HKEY_LOCAL_MACHINE, REGSTR_PATH_MEDIARESOURCES TEXT("\\") REGSTR_VAL_SETUPPREFERREDAUDIODEVICES, &hkeySetupPreferredAudioDevices);
        		    if (ERROR_SUCCESS == dwLastError)
        		    {
        		        dwLastError = RegQueryDwordValue(hkeySetupPreferredAudioDevices, REGSTR_VAL_SETUPPREFERREDAUDIODEVICESCOUNT, &SetupCount);
        		        if (ERROR_FILE_NOT_FOUND == dwLastError) {
        			    SetupCount = 0;
        			    dwLastError = ERROR_SUCCESS;
        		        }
        
        		        if (ERROR_SUCCESS == dwLastError)
        		        {
        			    SetupCount++;
        			    dwLastError = RegSetDwordValue(hkeySetupPreferredAudioDevices, REGSTR_VAL_SETUPPREFERREDAUDIODEVICESCOUNT, SetupCount);
        			    if (ERROR_SUCCESS != dwLastError) dprintf(TEXT("MNDIS: Couldn't set count\n"));
        		        }
        		    
        		        RegCloseKey(hkeySetupPreferredAudioDevices);
        		    } else {
        		        dprintf(TEXT("MNDIS: Couldn't create hklm\\...\\SetupPreferredAudioDevices\n"));
        		    }
        	        }
        	    
    	                if (ERROR_SUCCESS == dwLastError) {
    		            // We've successfully read, incremented, and written the
    		            // setup version to HKLM, or we've done nothing because we
    		            // didn't have to.
    		            if (fNewInstall) RegSetDwordValue(hkeyDriver, REGSTR_VAL_SETUPPREFERREDAUDIODEVICESCOUNT, SetupCount);
    		            if (fSetupPreferredAudioDevices) RegDeleteValue(hkeyDriver, REGSTR_VAL_SETUPPREFERREDAUDIODEVICES);
    		        }
    	                
                    }

		    // Return the SetupCount for the driver
		    *pSetupCountOut = SetupCount;
		
    		    RegCloseKey(hkeyMmeDrivers);
    		    
                }
		
		RegCloseKey(hkeyDriver);
    
	    } else {
		dwLastError = GetLastError();
		dprintf(TEXT("MNDS: SetupDiCreateDevRegKey failed, LastError=%d\n"), dwLastError);
	    }
	} else {
	    dwLastError = GetLastError();
	    dprintf(TEXT("MNDS: SetupDiOpenDeviceInfo failed, LastError=%d\n"), dwLastError);
	}

	if (!SetupDiDestroyDeviceInfoList(hdi))
	{
	    dwLastError = GetLastError();
	    dprintf(TEXT("MNDS: SetupDiDestroyDeviceInfoList failed, LastError=%d\n"), dwLastError);
	}
    } else {
	dwLastError = GetLastError();
	dprintf(TEXT("MNDS: SetupDiCreateDeviceInfoList failed, LastError=%d\n"), dwLastError);
    }
    return;
}

//------------------------------------------------------------------------------
//
//
//	MigrateAutoSetupPreferredAudio
//
//
//------------------------------------------------------------------------------
void MigrateAutoSetupPreferredAudio(PMMDEVICEINTERFACEINFO pdii)
{
    PTSTR pstrRendererDeviceInstanceId;
    DWORD SetupCount;

    SetupCount = 0;
    pstrRendererDeviceInstanceId = MakeRendererDeviceInstanceIdFromDeviceInterface(pdii->szName);

    if (pstrRendererDeviceInstanceId) {
	BOOL f;
	MigrateNewDeviceInstanceSetup(pstrRendererDeviceInstanceId, &SetupCount);
	f = HeapFree(hHeap, 0, pstrRendererDeviceInstanceId);
	ASSERT(f);
    }

    MigrateNewDeviceInterfaceSetup(pdii, SetupCount);
    
    return;
}


PMMDEVICEINTERFACEINFO pnpServerInstallDevice
(
    PCTSTR  pszDeviceInterface,
    BOOL    fRemove
)
{
    PMMDEVICEINTERFACEINFO  pdii;
    PWSTR                   pszDev;
    UINT                    ii;

    if (NULL == pPnpInfo)
    {
        dprintf(TEXT("pnpServerInstallDevice called at bad time\n"));
        ASSERT(FALSE);

        return NULL;
    }

    pdii = (PMMDEVICEINTERFACEINFO)&(pPnpInfo[1]);

    pdii = (PMMDEVICEINTERFACEINFO)PAD_POINTER(pdii);

    for (ii = pPnpInfo->cDevInterfaces; ii; ii--)
    {
        //  Searching for the device interface...

        pszDev = (PWSTR)(&(pdii->szName[0]));

        if (0 == lstrcmpi(pszDev, pszDeviceInterface))
        {
            break;
        }

        pdii = (PMMDEVICEINTERFACEINFO)(pszDev + lstrlenW(pszDev) + 1);
        pdii = (PMMDEVICEINTERFACEINFO)PAD_POINTER(pdii);
    }

    //  Getting the current settings...

    if (0 == ii)
    {
	PMMDEVICEINTERFACEINFO pdiiNext;
	SIZE_T sizePnpInfo;

	//  Does not exist, create it, first ensuring there is enough room

	pdiiNext = (PMMDEVICEINTERFACEINFO)(pdii->szName + ((lstrlenW(pszDeviceInterface) + 1)));
	pdiiNext = (PMMDEVICEINTERFACEINFO)PAD_POINTER(pdiiNext);
	sizePnpInfo = ((PBYTE)pdiiNext) - ((PBYTE)pPnpInfo);
	if (sizePnpInfo < PNPINFOSIZE)
	{
	    // dprintf(TEXT("pnpServerInstallDevice: note: sizePnpInfo = %p\n", sizePnpInfo);

	    pdii->cPnpEvents = 0;
	    pdii->fdwInfo    = 0L;

	    pszDev = (PWSTR)(&(pdii->szName[0]));
	    lstrcpy(pszDev, pszDeviceInterface);

	    pPnpInfo->cDevInterfaces++;
            pPnpInfo->cbSize = (DWORD)sizePnpInfo;
	} else {
	    dprintf(TEXT("pnpServerInstallDevice RAN OUT OF PNPINO STORAGE!!!\n"));
	    pdii = NULL;
	}
    }
    else
    {
        //  Already exists, increment the event count.
        pdii->cPnpEvents++;
    }

    //  Set or clear the "removed" bit.
    if (pdii)
    {
	if (fRemove)
	{
	    pdii->fdwInfo |= MMDEVICEINFO_REMOVED;
	 // dprintf("pnpServerInstallDevice removed [%ls]\n", pszDeviceInterface);
	}
	else
	{
	    pdii->fdwInfo &= (~MMDEVICEINFO_REMOVED);
	 // dprintf("pnpServerInstallDevice added [%ls]\n", pszDeviceInterface);
	}

    }

    return pdii;
}


BOOL PnpInfoEnum
(
    void
)
{
    UINT                                cDevs = 0;
    HDEVINFO                            hDevInfo;
    BOOL                                fEnum;
    DWORD                               ii, dw;
    DWORD                               cbSize;
    GUID                                guidClass = KSCATEGORY_AUDIO;
    SP_DEVICE_INTERFACE_DATA            did;
    SP_DEVINFO_DATA                     DevInfoData;
    PSP_DEVICE_INTERFACE_DETAIL_DATA    pdidd;

    cbSize = 300 * sizeof(TCHAR) + sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);

    pdidd = (PSP_DEVICE_INTERFACE_DETAIL_DATA)HeapAlloc(hHeap, 0, cbSize);

    if (NULL == pdidd)
    {
        HeapFree(hHeap, 0, pdidd);
        return FALSE;
    }

    pdidd->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);

    hDevInfo = SetupDiGetClassDevs(
                &guidClass,
                NULL,
                NULL,
                DIGCF_DEVICEINTERFACE | DIGCF_PRESENT);

    if (INVALID_HANDLE_VALUE == hDevInfo)
    {
        dprintf(TEXT("SetupDiGetClasDevs failed [0x%08lx].\n"), GetLastError());
        HeapFree(hHeap, 0, pdidd);
        return FALSE;
    }

    ZeroMemory(&did, sizeof(did));

    did.cbSize = sizeof(did);

    ZeroMemory(&DevInfoData, sizeof(SP_DEVINFO_DATA));

    DevInfoData.cbSize    = sizeof(SP_DEVINFO_DATA);
    DevInfoData.ClassGuid = KSCATEGORY_AUDIO;

    for (ii = 0; ;ii++, cDevs++)
    {
	PMMDEVICEINTERFACEINFO pdii;
	
        fEnum = SetupDiEnumDeviceInterfaces(
                    hDevInfo,
                    NULL,
                    &guidClass,
                    ii,
                    &did);

        if (!fEnum)
        {
            break;
        }

        dw = 0;

        fEnum = SetupDiGetDeviceInterfaceDetail(
                    hDevInfo,
                    &did,
                    pdidd,
                    cbSize,
                    &dw,
                    &DevInfoData);

        if (!fEnum)
        {
            dprintf(TEXT("SetupDiGetDeviceInterfaceDetail failed (0x%08lx).\n"), GetLastError());
            break;
        }

        // dprintf(TEXT("PnpInfoEnum: Enumerated[%ls]\n"), pdidd->DevicePath);

	pdii = pnpServerInstallDevice(pdidd->DevicePath, FALSE);
	if (pdii) MigrateAutoSetupPreferredAudio(pdii);
    }

    if (!SetupDiDestroyDeviceInfoList(hDevInfo))
    {
	ASSERT(!"wdmEnumerateInstalledDevices: SetupDiDestroyDeviceInfoList failed.");
    }

    HeapFree(hHeap, 0, pdidd);
    SetLastError(ERROR_SUCCESS);

    return TRUE;

} // PnpInfoEnum()


BOOL InitializePnpInfo
(
    void
)
{
    SECURITY_ATTRIBUTES sa;
    PSECURITY_DESCRIPTOR pSd;
    BOOL result;

    ASSERT(!gfPnpInfoResource);
    ASSERT(!hPnpInfo);
    ASSERT(!pPnpInfo);

    result = FALSE;
    
    __try {
        RtlInitializeResource(&PnpInfoResource);
        gfPnpInfoResource = TRUE;
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        gfPnpInfoResource = FALSE;;
    }
    
    if (!gfPnpInfoResource) return FALSE;
    
    pSd = BuildSecurityDescriptor(FILE_MAP_READ);
    if (pSd)
    {
        sa.nLength              = sizeof(SECURITY_ATTRIBUTES);
        sa.lpSecurityDescriptor = pSd;
        sa.bInheritHandle       = FALSE;

        hPnpInfo = CreateFileMapping(GetCurrentProcess(), &sa, PAGE_READWRITE, 0, PNPINFOSIZE, MMGLOBALPNPINFONAME);

        DestroySecurityDescriptor(pSd);

        if (hPnpInfo)
        {
            pPnpInfo = (PMMPNPINFO)MapViewOfFile(hPnpInfo, FILE_MAP_WRITE, 0, 0, 0);
            if (pPnpInfo)
            {
            	ZeroMemory(pPnpInfo, PNPINFOSIZE);
                pPnpInfo->cbSize = sizeof(MMPNPINFO);
                pPnpInfo->cPnpEvents = 0;

                result = TRUE;

            } else {
                dprintf(TEXT("InitializePnpInfo: MapViewOfFile failed!\n"));
            }
        } else {
            dprintf(TEXT("InitializePnpInfo: CreateFileMappingFailed!\n"));
        }
    } else {
        dprintf(TEXT("InitializePnpInfo: BuildSecurityDescriptor failed!\n"));
    }

    if (!result)
    {
    	if (pPnpInfo) UnmapViewOfFile(pPnpInfo);
    	if (hPnpInfo) CloseHandle(hPnpInfo);
    	if (gfPnpInfoResource) RtlDeleteResource(&PnpInfoResource);
    	pPnpInfo = NULL;
    	hPnpInfo = NULL;
    	gfPnpInfoResource = FALSE;
    }

    return result;
} // InitializePnpInfo()

void DeletePnpInfo(void)
{
    ASSERT(gfPnpInfoResource);
    ASSERT(hPnpInfo);
    ASSERT(pPnpInfo);

    UnmapViewOfFile(pPnpInfo);
    CloseHandle(hPnpInfo);
    RtlDeleteResource(&PnpInfoResource);
    
    pPnpInfo = NULL;
    hPnpInfo = NULL;
    gfPnpInfoResource = FALSE;
    
    return;
}

//=============================================================================
//===   rpc functions   ===
//=============================================================================

long s_wdmDriverOpenDrvRegKey(IN DWORD dwProcessId, IN LPCTSTR DeviceInterface, IN ULONG samDesired, OUT RHANDLE *phkeyClient)
{
    HDEVINFO hdi;
    HKEY hkey;
    RPC_STATUS status;

    // We impersonate the client while calling setupapi so that we are sure
    // the client actually has access to open the driver reg key

    status = RpcImpersonateClient(NULL);
    if (status) return status;
    
    hdi = SetupDiCreateDeviceInfoList(NULL, NULL);
    if (INVALID_HANDLE_VALUE != hdi)
    {
	SP_DEVICE_INTERFACE_DATA DeviceInterfaceData;

	DeviceInterfaceData.cbSize = sizeof(DeviceInterfaceData);
	if (SetupDiOpenDeviceInterface(hdi, DeviceInterface, 0,
					  &DeviceInterfaceData))
	{
	    SP_DEVINFO_DATA DeviceInfoData;
	    DWORD cbDeviceInterfaceDetail;

	    DeviceInfoData.cbSize = sizeof(DeviceInfoData);
	    if (SetupDiGetDeviceInterfaceDetail(hdi, &DeviceInterfaceData, NULL, 0, &cbDeviceInterfaceDetail, &DeviceInfoData) ||
		(ERROR_INSUFFICIENT_BUFFER == GetLastError()))
	    {
                hkey = SetupDiOpenDevRegKey(hdi, &DeviceInfoData, DICS_FLAG_GLOBAL, 0, DIREG_DRV, samDesired);
                if (INVALID_HANDLE_VALUE != hkey) 
                {
                    status = ERROR_SUCCESS;
                } else {
                    status = GetLastError();
                    dprintf(TEXT("s_wdmDriverOpenDrvRegKey: SetupDiOpenDevRegKey failed, Error=%d\n"), status);
                }
            } else {
                status = GetLastError();
                dprintf(TEXT("s_wdmDriverOpenDrvRegKey: SetupDiGetDeviceInterfaceDetail failed, Error=%d\n"), status);
            }
        } else {
            status = GetLastError();
            dprintf(TEXT("s_wdmDriverOpenDrvRegKey: SetupDiOpenDeviceInterface failed, Error=%d\n"), status);
        }

        SetupDiDestroyDeviceInfoList(hdi);
    } else {
        status = GetLastError();
        dprintf(TEXT("s_wdmDriverOpenDrvRegKey: SetupDiCreateDeviceInfoList failed, Error=%d\n"), status);
    }

    // We stop impersonating here because the remaining operations
    // should not depend on the client's privileges.
    
    RpcRevertToSelf();

    if (ERROR_SUCCESS == status)
    {
        HANDLE hClientProcess;

        hClientProcess = OpenProcess(PROCESS_DUP_HANDLE, FALSE, dwProcessId);
        if (hClientProcess)
        {
            HANDLE hkeyClient;

            if (DuplicateHandle(GetCurrentProcess(), hkey, hClientProcess, &hkeyClient, 0, FALSE, DUPLICATE_SAME_ACCESS))
            {
                // dprintf(TEXT("s_wdmDriverOpenDrvRegKey hkeyClient=%p\n"), hkeyClient);
                *phkeyClient = (RHANDLE)hkeyClient;
            } else {
                status = GetLastError();
                dprintf(TEXT("s_wdmDriverOpenDrvRegKey: DuplicateHandle failed, Error=%d\n"), status);
            }
            CloseHandle(hClientProcess);
        } else {
            status = GetLastError();
            dprintf(TEXT("s_wdmDriverOpenDrvRegKey: OpenProcess failed, Error=%d\n"), status);
        }

        RegCloseKey(hkey);
    }

    return status;
}



void s_winmmAdvisePreferredDeviceChange(void)
{
    // dprintf(TEXT("s_winmmAdvisePreferredDeviceChange\n"));
    ASSERT(pPnpInfo);
    InterlockedIncrement(&pPnpInfo->cPreferredDeviceChanges);
    BroadcastWinmmDeviceChange();
    return;
}

long s_winmmGetPnpInfo(OUT LONG *pcbPnpInfo, OUT BYTE **ppPnpInfoOut)
{
    static BOOL fEnumDone = FALSE;
    
    PBYTE pPnpInfoOut;
    LONG result;

    // dprintf(TEXT("s_winmmGetPnpInfo\n"));
    
    ASSERT(pPnpInfo);

    RtlAcquireResourceShared(&PnpInfoResource, TRUE);
    pPnpInfoOut = (PBYTE)HeapAlloc(hHeap, 0, pPnpInfo->cbSize);
    if (pPnpInfoOut)
    {
    	CopyMemory(pPnpInfoOut, pPnpInfo, pPnpInfo->cbSize);
        *pcbPnpInfo = pPnpInfo->cbSize;
        *ppPnpInfoOut = pPnpInfoOut;
    	result = NO_ERROR;
    } else {
        // ISSUE-2001/02/15-FrankYe Do we need to zero the out params?
        result = ERROR_OUTOFMEMORY;
    }
    RtlReleaseResource(&PnpInfoResource);
    return result;
}

//=============================================================================
//===   pnp interface handlers   ===
//=============================================================================
void MME_AudioInterfaceArrival(PCTSTR DeviceInterface)
{
    PMMDEVICEINTERFACEINFO pdii;
    // dprintf(TEXT("MME_AudioInterfaceArrival\n"));
    RtlAcquireResourceExclusive(&PnpInfoResource, TRUE);
    pdii = pnpServerInstallDevice(DeviceInterface, FALSE);
    if (pdii) MigrateAutoSetupPreferredAudio(pdii);
    InterlockedIncrement(&pPnpInfo->cPnpEvents);
    InterlockedIncrement(&pPnpInfo->cPreferredDeviceChanges);
    RtlReleaseResource(&PnpInfoResource);
    if (pdii) BroadcastWinmmDeviceChange();
    return;
}

void MME_AudioInterfaceRemove(PCTSTR DeviceInterface)
{
    PMMDEVICEINTERFACEINFO pdii;
    // dprintf(TEXT("MME_AudioInterfaceRemove\n"));
    RtlAcquireResourceExclusive(&PnpInfoResource, TRUE);
    pdii = pnpServerInstallDevice(DeviceInterface, TRUE);
    InterlockedIncrement(&pPnpInfo->cPnpEvents);
    InterlockedIncrement(&pPnpInfo->cPreferredDeviceChanges);
    RtlReleaseResource(&PnpInfoResource);
    if (pdii) BroadcastWinmmDeviceChange();
    return;
}

LONG MME_ServiceStart(void)
{
    ASSERT(pPnpInfo);
    // dprintf(TEXT("MME_ServiceStart\n"));
    RtlAcquireResourceExclusive(&PnpInfoResource, TRUE);
    if (!PnpInfoEnum()) dprintf(TEXT("MME_ServiceStart: PnpInfoEnum failed!\n"));
    InterlockedIncrement(&pPnpInfo->cPnpEvents);
    RtlReleaseResource(&PnpInfoResource);
    return NO_ERROR;
}

//=============================================================================
//===   DLL attach/detach   ===
//=============================================================================

BOOL MME_DllProcessAttach(void)
{
    return InitializePnpInfo();
}

void MME_DllProcessDetach(void)
{
    return DeletePnpInfo();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\audiosrv\list.h ===
//
// Lists have internal serialization so that most functions operate as atomic
// operations.  However, the results of some functions are transient (i.e.
// immediately out-of-date)  unless the caller explicitly locks the list using
// the Lock/Unlock methods.  These functions are GetCount, GetHeadPosition,
// GetNext.  Also, it is the caller's responsibility to serialize access to a
// POSITION.  The internal  serialization only ensures that two simultaneus
// AddTail calls will not make the list internally inconsistent, and nor will
// two simultaneous RemoveAt calls on _different_ POSITIONs.
//
// List elements with NULL object pointers are skipped by list iteration
// functions GetHeadPosition and GetNext.
//

typedef struct _CListElement {
	struct _CListElement *Next;
	struct _CListElement *Prev;
	const void *Object;
} CListElement, *POSITION;

template <class TYPE, class ARG_TYPE> class CList {
public:
	CList();
	~CList();

        POSITION AddHead(ARG_TYPE newElement);
	POSITION AddTail(ARG_TYPE newElement);
	TYPE     GetAt(POSITION position);
	int      GetCount(void) const;
	POSITION GetHeadPosition(void) const;
	TYPE     GetNext(POSITION& rPosition); // return *Position++
        LONG     Initialize(void);
	POSITION InsertAfter(POSITION position, ARG_TYPE newElement);
	POSITION InsertBefore(POSITION position, ARG_TYPE newElement);
        BOOL     IsEmpty(void) const;
        void     Lock(void);
        void     MoveBefore(POSITION posTarget, POSITION posMove);
	void     RemoveAll(void);
	void     RemoveAt(POSITION position);
	void     SetAt(POSITION pos, ARG_TYPE newElement);
        void     Unlock(void);

private:
        BOOL m_Initialized;
        CRITICAL_SECTION m_CriticalSection;
	int m_Count;
	CListElement m_Sentinel;
};

template<class TYPE, class ARG_TYPE>
CList<TYPE, ARG_TYPE>::CList(void)
{
    m_Initialized = FALSE;
    m_Count = 0;
    m_Sentinel.Next = &m_Sentinel;
    m_Sentinel.Prev = &m_Sentinel;
    m_Sentinel.Object = &m_Sentinel;
}

template<class TYPE, class ARG_TYPE>
CList<TYPE, ARG_TYPE>::~CList(void)
{
    if (m_Initialized) {
	RemoveAll();
	ASSERT(m_Sentinel.Next = &m_Sentinel);
	ASSERT(m_Sentinel.Prev = &m_Sentinel);
        DeleteCriticalSection(&m_CriticalSection);
        m_Initialized = FALSE;
    }
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::AddHead(ARG_TYPE newElement)
{
    POSITION pos;

    ASSERT(m_Initialized);

    pos = new CListElement;
    if (pos) {
        Lock();

        pos->Next = m_Sentinel.Next;
        pos->Prev = &m_Sentinel;

        pos->Prev->Next = pos;
        pos->Next->Prev = pos;

        pos->Object = newElement;

        m_Count++;

        Unlock();
    }
    return pos;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::AddTail(ARG_TYPE newElement)
{
    POSITION pos;

    ASSERT(m_Initialized);

    pos = new CListElement;
    if (pos) {
        Lock();

        pos->Next = &m_Sentinel;
        pos->Prev = m_Sentinel.Prev;

        pos->Prev->Next = pos;
        pos->Next->Prev = pos;

        pos->Object = newElement;

        m_Count++;

        Unlock();
    }
    return pos;
}

template<class TYPE, class ARG_TYPE>
TYPE CList<TYPE, ARG_TYPE>::GetAt(POSITION pos)
{
    ASSERT(m_Initialized);
    return (TYPE)pos->Object;
}

template<class TYPE, class ARG_TYPE>
int CList<TYPE, ARG_TYPE>::GetCount(void) const
{
    ASSERT(m_Initialized);
    return m_Count;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::GetHeadPosition(void) const
{
    POSITION pos;
    ASSERT(m_Initialized);
    pos = m_Sentinel.Next;
    // Skip NULL elements
    while (NULL == pos->Object) pos = pos->Next;
    if (pos == &m_Sentinel) return NULL;
    return pos;
}

template<class TYPE, class ARG_TYPE>
TYPE CList<TYPE, ARG_TYPE>::GetNext(POSITION& rPos)
{
    ASSERT(m_Initialized);
    
    TYPE Object = (TYPE)rPos->Object;
    
    rPos = rPos->Next;
    // Skip NULL elements.
    while (NULL == rPos->Object) rPos = rPos->Next;
    if (rPos == &m_Sentinel) rPos = NULL;

    return Object;
}

template<class TYPE, class ARG_TYPE>
LONG CList<TYPE, ARG_TYPE>::Initialize(void)
{
    LONG result;

    ASSERT(!m_Initialized);

    __try {
	InitializeCriticalSection(&m_CriticalSection);
	result = NO_ERROR;
    } __except(EXCEPTION_EXECUTE_HANDLER) {
	result = ERROR_OUTOFMEMORY;
    }

    m_Initialized = (NO_ERROR == result);

    return result;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::InsertAfter(POSITION position, ARG_TYPE newElement)
{
    ASSERT(m_Initialized);
    
    if (position == NULL)
    {
    	// insert after nothing -> head of the list
    	position = &m_Sentinel;
    }

    // Insert it after position
    CListElement* newPos = new CListElement;
    if (newPos)
    {
	Lock();
	    
	newPos->Next = position->Next;
	newPos->Prev = position;
	
	newPos->Next->Prev = newPos;
	newPos->Prev->Next = newPos;

        newPos->Object = newElement;

        m_Count++;

        Unlock();
    }
    return newPos;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::InsertBefore(POSITION position, ARG_TYPE newElement)
{
    ASSERT(m_Initialized);
    
    if (position == NULL)
    {
        // insert before nothing -> tail of list
        position = &m_Sentinel;
    }

    // Insert it before position
    CListElement* newPos = new CListElement;
    if (newPos)
    {
	Lock();
	    
	newPos->Next = position;
	newPos->Prev = position->Prev;
	
	newPos->Next->Prev = newPos;
	newPos->Prev->Next = newPos;

        newPos->Object = newElement;

        m_Count++;

        Unlock();
    }
    return newPos;
}

template<class TYPE, class ARG_TYPE>
BOOL CList<TYPE, ARG_TYPE>::IsEmpty(void) const
{
    ASSERT(m_Initialized);
    return (0 == m_Count);
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::Lock(void)
{
    EnterCriticalSection(&m_CriticalSection);
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::MoveBefore(POSITION posTarget, POSITION posMove)
{
    ASSERT(m_Initialized);

    if (posTarget == posMove) return;

    if (posTarget == NULL)	
    {
        // Move before nothing -> tail of list
        posTarget = &m_Sentinel;
    }
    
    // first remove from list
    posMove->Prev->Next = posMove->Next;
    posMove->Next->Prev = posMove->Prev;

    // Move it before posTarget
    posMove->Next = posTarget;
    posMove->Prev = posTarget->Prev;
    
    posMove->Next->Prev = posMove;
    posMove->Prev->Next = posMove;
    
    return;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::RemoveAll(void)
{
    POSITION pos;
    ASSERT(m_Initialized);
    while (pos = GetHeadPosition()) RemoveAt(pos);
    return;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::RemoveAt(POSITION pos)
{
    ASSERT(m_Initialized);
    ASSERT(m_Count > 0);
    Lock();
    pos->Prev->Next = pos->Next;
    pos->Next->Prev = pos->Prev;
    m_Count--;
    Unlock();
    delete pos;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::SetAt(POSITION pos, ARG_TYPE newElement)
{
    ASSERT(m_Initialized);
    ASSERT(m_Count > 0);
    Lock();
    pos->Object = newElement;
    Unlock();
    return;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::Unlock(void)
{
    LeaveCriticalSection(&m_CriticalSection);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\audiosrv\reg.cpp ===
#include <windows.h>
#include "debug.h"
#include "reg.h"

extern "C" HANDLE hHeap;

//------------------------------------------------------------------------------
//
//
//	Registry helpers
//
//
//------------------------------------------------------------------------------

LONG RegQueryBinaryValue(IN HKEY hkey, IN PCTSTR pValueName, OUT PBYTE *ppValue, OUT ULONG *pcbValue)
{
    LONG result;
    DWORD typeValue;
    DWORD cbValue = 0;
    BOOL f;
    
    result = RegQueryValueEx(hkey, pValueName, 0, &typeValue, NULL, &cbValue);
    if (ERROR_SUCCESS == result)
    {
	if (REG_BINARY == typeValue)
	{
            PBYTE pValue;
	    pValue = (PBYTE)HeapAlloc(hHeap, 0, cbValue);
	    if (pValue)
	    {
		result = RegQueryValueEx(hkey, pValueName, 0, &typeValue, (PBYTE)pValue, &cbValue);
		if (ERROR_SUCCESS == result)
		{
                    if (REG_BINARY == typeValue)
                    {
                        *ppValue = pValue;
                        *pcbValue = cbValue;
                    } else {
                        result = ERROR_FILE_NOT_FOUND;
                        f = HeapFree(hHeap, 0, pValue);
                        ASSERT(f);
                    }
		} else {
		    f = HeapFree(hHeap, 0, pValue);
		    ASSERT(f);
		}
	    } else {
		result = ERROR_OUTOFMEMORY;
	    }
	} else {
	    result = ERROR_FILE_NOT_FOUND;
	}
    }
    return result;
}

LONG RegQuerySzValue(HKEY hkey, PCTSTR pValueName, PTSTR *ppstrValue)
{
    LONG result;
    DWORD typeValue;
    DWORD cbstrValue = 0;
    BOOL f;
    
    result = RegQueryValueEx(hkey, pValueName, 0, &typeValue, NULL, &cbstrValue);
    if (ERROR_SUCCESS == result)
    {
	if (REG_SZ == typeValue)
	{
	    PTSTR pstrValue;
	    pstrValue = (PTSTR)HeapAlloc(hHeap, 0, cbstrValue);
	    if (pstrValue)
	    {
		result = RegQueryValueEx(hkey, pValueName, 0, &typeValue, (PBYTE)pstrValue, &cbstrValue);
		if (ERROR_SUCCESS == result)
		{
                    if (REG_SZ == typeValue)
                    {
                        *ppstrValue = pstrValue;
                    } else {
                        result = ERROR_FILE_NOT_FOUND;
                        f = HeapFree(hHeap, 0, pstrValue);
                        ASSERT(f);
                    }
		} else {
		    f = HeapFree(hHeap, 0, pstrValue);
		    ASSERT(f);
		}
	    } else {
		result = ERROR_OUTOFMEMORY;
	    }
	} else {
	    result = ERROR_FILE_NOT_FOUND;
	}
    }
    return result;
}

LONG RegQueryMultiSzValue(HKEY hkey, PCTSTR pValueName, PTSTR *ppstrValue)
{
    LONG result;
    DWORD typeValue;
    DWORD cbstrValue = 0;
    BOOL f;
    
    result = RegQueryValueEx(hkey, pValueName, 0, &typeValue, NULL, &cbstrValue);
    if (ERROR_SUCCESS == result)
    {
	if (REG_MULTI_SZ == typeValue)
	{
	    PTSTR pstrValue;
	    pstrValue = (PTSTR)HeapAlloc(hHeap, 0, cbstrValue);
	    if (pstrValue)
	    {
		result = RegQueryValueEx(hkey, pValueName, 0, &typeValue, (PBYTE)pstrValue, &cbstrValue);
		if (ERROR_SUCCESS == result)
		{
                    if (REG_MULTI_SZ == typeValue)
                    {
                        *ppstrValue = pstrValue;
                    } else {
                        result = ERROR_FILE_NOT_FOUND;
                        f = HeapFree(hHeap, 0, pstrValue);
                        ASSERT(f);
                    }
		} else {
		    f = HeapFree(hHeap, 0, pstrValue);
		    ASSERT(f);
		}
	    } else {
		result = ERROR_OUTOFMEMORY;
	    }
	} else {
	    result = ERROR_FILE_NOT_FOUND;
	}
    }
    return result;
}

LONG RegQueryDwordValue(HKEY hkey, PCTSTR pValueName, PDWORD pdwValue)
{
    DWORD cbdwValue;
    LONG result;

    cbdwValue = sizeof(*pdwValue);
    result = RegQueryValueEx(hkey, pValueName, 0, NULL, (PBYTE)pdwValue, &cbdwValue);
    return result;
}

LONG RegSetSzValue(HKEY hkey, PCTSTR pValueName, PCTSTR pstrValue)
{
    DWORD cbstrValue = (lstrlen(pstrValue) + 1) * sizeof(pstrValue[0]);
    return RegSetValueEx(hkey, pValueName, 0, REG_SZ, (PBYTE)pstrValue, cbstrValue);
}

LONG RegSetMultiSzValue(HKEY hkey, PCTSTR pValueName, PCTSTR pstrValue)
{
	PCTSTR pstr;
	DWORD cch;
	DWORD cchValue;
	DWORD cbValue;

	pstr = pstrValue;
	cchValue = 0;

	do {
		cch = lstrlen(pstr);
		cchValue += cch+1;
		pstr +=  cch+1;
	} while (cch > 0);

	cbValue = cchValue * sizeof(TCHAR);

	return RegSetValueEx(hkey, pValueName, 0, REG_MULTI_SZ, (PBYTE)pstrValue, cbValue);
}

LONG RegSetBinaryValue(IN HKEY hkey, IN PCTSTR pValueName, IN PBYTE pValue, IN ULONG cbValue)
{
    return RegSetValueEx(hkey, pValueName, 0, REG_BINARY, (PBYTE)pValue, cbValue);
}

LONG RegSetDwordValue(HKEY hkey, PCTSTR pValueName, DWORD dwValue)
{
    return RegSetValueEx(hkey, pValueName, 0, REG_DWORD, (PBYTE)&dwValue, sizeof(dwValue));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\audiosrv\mme.h ===
/* mme.h
 * External scope definitions for mme.cpp
 * Created by FrankYe on 2/14/2001
 * Copyright (c) 2001-2001 Microsoft Corporation
 */

void MME_AudioInterfaceArrival(PCTSTR DeviceInterface);
void MME_AudioInterfaceRemove(PCTSTR DeviceInterface);
LONG MME_ServiceStart(void);
BOOL MME_DllProcessAttach(void);
void MME_DllProcessDetach(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\audiosrv\reg.h ===
LONG RegQueryBinaryValue(IN HKEY hkey, IN PCTSTR pValueName, OUT PBYTE *ppData, OUT ULONG *pcbData);
LONG RegQueryDwordValue(IN HKEY hkey, IN PCTSTR pValueName, OUT DWORD *pdwValue);
LONG RegQueryMultiSzValue(IN HKEY hkey, IN PCTSTR pValueName, OUT PTSTR *ppstrValue);
LONG RegQuerySzValue(IN HKEY hkey, IN PCTSTR pValueName, OUT PTSTR *ppstrValue);
LONG RegSetBinaryValue(IN HKEY hkey, IN PCTSTR pValueName, IN PBYTE pValue, IN ULONG cbValue);
LONG RegSetDwordValue(IN HKEY hkey, IN PCTSTR pValueName, IN DWORD dwValue);
LONG RegSetMultiSzValue(IN HKEY hkey, IN PCTSTR pValueName, IN PCTSTR pstrValue);
LONG RegSetSzValue(IN HKEY hkey, IN PCTSTR pValueName, IN PCTSTR pstrValue);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\audiosrv\service.h ===
/****************************************************************************\
*
*  Module Name : service.h
*
*  Copyright (c) 1991-2000 Microsoft Corporation
*
\****************************************************************************/

#ifndef _SERVICE_H
#define _SERVICE_H


#ifdef __cplusplus
extern "C" {
#endif


//////////////////////////////////////////////////////////////////////////////
////
// internal name of the service
#define SZSERVICENAME        "AudioSrv"
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
//// todo: ServiceStart()must be defined by in your code.
////       The service should use ReportStatusToSCMgr to indicate
////       progress.  This routine must also be used by StartService()
////       to report to the SCM when the service is running.
////
////       If a ServiceStop procedure is going to take longer than
////       3 seconds to execute, it should spawn a thread to
////       execute the stop code, and return.  Otherwise, the
////       ServiceControlManager will believe that the service has
////       stopped responding
////
VOID  ServiceStart(SERVICE_STATUS_HANDLE ssh, DWORD dwArgc, LPTSTR *lpszArgv);
DWORD ServiceDeviceEvent(DWORD dwEventType, LPVOID lpEventData);
DWORD ServiceSessionChange(DWORD dwEventType, LPVOID lpEventData);
VOID  ServiceStop();
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
//// The following are procedures which
//// may be useful to call within the above procedures,
//// but require no implementation by the user.
//// They are implemented in service.c

//
//  FUNCTION: ReportStatusToSCMgr()
//
//  PURPOSE: Sets the current status of the service and
//           reports it to the Service Control Manager
//
//  PARAMETERS:
//    dwCurrentState - the state of the service
//    dwWin32ExitCode - error code to report
//    dwWaitHint - worst case estimate to next checkpoint
//
//  RETURN VALUE:
//    TRUE  - success
//    FALSE - failure
//
BOOL ReportStatusToSCMgr(DWORD dwCurrentState, DWORD dwWin32ExitCode, DWORD dwWaitHint);
extern SERVICE_STATUS ssStatus;       // current status of the service

//////////////////////////////////////////////////////////////////////////////
////
// Process heap, initialized in DllMain.
EXTERN_C HANDLE hHeap;

//////////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\audiosrv\sad.cpp ===
#include <windows.h>
#include <devioctl.h>
#include <ks.h>
#include <ksmedia.h>
#include "debug.h"
#include "sad.h"

extern "C" HANDLE hHeap;

LONG SadAddGfxToZoneGraph(HANDLE hSad, HANDLE hGfx, PCTSTR GfxFriendlyName, PCTSTR ZoneFactoryDi, ULONG Type, ULONG Order)
{
    KSPROPERTY Property;
    PSYSAUDIO_GFX pSadGfx;
    ULONG cbSadGfx;
    PTSTR pZoneFactoryDi;
    ULONG cbZoneFactoryDi;
    PTSTR pGfxFriendlyName;
    ULONG cbGfxFriendlyName;
    DWORD cbBytesReturned;
    LONG lresult;
    
    ASSERT(!IsBadStringPtr(GfxFriendlyName, 5000));
    ASSERT(!IsBadStringPtr(ZoneFactoryDi, 5000));
    
    Property.Set = KSPROPSETID_Sysaudio;
    Property.Id = KSPROPERTY_SYSAUDIO_ADDREMOVE_GFX;
    Property.Flags = KSPROPERTY_TYPE_SET;
    
    cbGfxFriendlyName = (lstrlen(GfxFriendlyName)+1) * sizeof(GfxFriendlyName[0]);
    cbZoneFactoryDi = (lstrlen(ZoneFactoryDi)+1) * sizeof(ZoneFactoryDi[0]);
    cbSadGfx = sizeof(*pSadGfx) + cbGfxFriendlyName + cbZoneFactoryDi;
    
    pSadGfx = (PSYSAUDIO_GFX)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, cbSadGfx);
    if (pSadGfx) {
        pSadGfx->Enable = TRUE;
        pSadGfx->hGfx = hGfx;
        pSadGfx->ulOrder = Order;
        pSadGfx->ulType = Type;
        pSadGfx->ulFlags = 0;
        
        pZoneFactoryDi = (PTSTR)(pSadGfx+1);
        lstrcpy(pZoneFactoryDi, ZoneFactoryDi);
        pSadGfx->ulDeviceNameOffset = (ULONG)((PBYTE)pZoneFactoryDi - (PBYTE)pSadGfx);
        
        pGfxFriendlyName = pZoneFactoryDi + lstrlen(pZoneFactoryDi) + 1;
        lstrcpy(pGfxFriendlyName, GfxFriendlyName);
        pSadGfx->ulFriendlyNameOffset = (ULONG)((PBYTE)pGfxFriendlyName - (PBYTE)pSadGfx);
        
        ASSERT((PBYTE)(pGfxFriendlyName + lstrlen(pGfxFriendlyName) + 1) == ((PBYTE)pSadGfx) + cbSadGfx);
        
        if (DeviceIoControl(hSad, IOCTL_KS_PROPERTY,
                            &Property, sizeof(Property),
                            pSadGfx, cbSadGfx,
                            &cbBytesReturned, NULL))
        {
            lresult = ERROR_SUCCESS;
        } else {
            // ISSUE-200/09/21-FrankYe Shoule we get other data regarding failure?
            lresult = GetLastError();
        }
                                  
        HeapFree(hHeap, 0, pSadGfx);
        
        
    } else {
        lresult = ERROR_OUTOFMEMORY;
    }
    
    return lresult;
}

LONG SadRemoveGfxFromZoneGraph(HANDLE hSad, HANDLE hGfx, PCTSTR GfxFriendlyName, PCTSTR ZoneFactoryDi, ULONG Type, ULONG Order)
{
    KSPROPERTY Property;
    PSYSAUDIO_GFX pSadGfx;
    ULONG cbSadGfx;
    PTSTR pZoneFactoryDi;
    ULONG cbZoneFactoryDi;
    PTSTR pGfxFriendlyName;
    ULONG cbGfxFriendlyName;
    ULONG cbBytesReturned;
    LONG lresult;
    
    ASSERT(!IsBadStringPtr(GfxFriendlyName, 5000));
    ASSERT(!IsBadStringPtr(ZoneFactoryDi, 5000));
    
    Property.Set = KSPROPSETID_Sysaudio;
    Property.Id = KSPROPERTY_SYSAUDIO_ADDREMOVE_GFX;
    Property.Flags = KSPROPERTY_TYPE_SET;
    
    cbGfxFriendlyName = (lstrlen(GfxFriendlyName)+1) * sizeof(GfxFriendlyName[0]);
    cbZoneFactoryDi = (lstrlen(ZoneFactoryDi)+1) * sizeof(ZoneFactoryDi[0]);
    cbSadGfx = sizeof(*pSadGfx) + cbGfxFriendlyName + cbZoneFactoryDi;
    
    pSadGfx = (PSYSAUDIO_GFX)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, cbSadGfx);
    if (pSadGfx) {
        pSadGfx->Enable = FALSE;
        pSadGfx->hGfx = hGfx;
        pSadGfx->ulOrder = Order;
        pSadGfx->ulType = Type;
        pSadGfx->ulFlags = 0;
        
        pZoneFactoryDi = (PTSTR)(pSadGfx+1);
        lstrcpy(pZoneFactoryDi, ZoneFactoryDi);
        pSadGfx->ulDeviceNameOffset = (ULONG)((PBYTE)pZoneFactoryDi - (PBYTE)pSadGfx);
        
        pGfxFriendlyName = pZoneFactoryDi + lstrlen(pZoneFactoryDi) + 1;
        lstrcpy(pGfxFriendlyName, GfxFriendlyName);
        pSadGfx->ulFriendlyNameOffset = (ULONG)((PBYTE)pGfxFriendlyName - (PBYTE)pSadGfx);
        
        ASSERT((PBYTE)(pGfxFriendlyName + lstrlen(pGfxFriendlyName) + 1) == ((PBYTE)pSadGfx) + cbSadGfx);
        
        if (DeviceIoControl(hSad, IOCTL_KS_PROPERTY,
                            &Property, sizeof(Property),
                            pSadGfx, cbSadGfx,
                            &cbBytesReturned, NULL))
        {
            lresult = ERROR_SUCCESS;
        } else {
            // ISSUE-200/09/21-FrankYe Shoule we get other data regarding failure?
            lresult = GetLastError();
        }
                                  
        HeapFree(hHeap, 0, pSadGfx);
        
        
    } else {
        lresult = ERROR_OUTOFMEMORY;
    }
    
    return lresult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\audiosrv\ts.h ===
typedef struct {
    HANDLE Event;
    DWORD SessionId;
} SESSIONNOTIFICATION, *PSESSIONNOTIFICATION;

typedef CList<PSESSIONNOTIFICATION, PSESSIONNOTIFICATION>   CListSessionNotifications;

extern CListSessionNotifications *gplistSessionNotifications;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\audiosrv\sad.h ===
// ISSUE-2000/09/21-FrankYe What is friendly name for?
EXTERN_C
LONG
SadAddGfxToZoneGraph
(
    HANDLE hSad,
    HANDLE hGfx,
    PCTSTR GfxFriendlyName,
    PCTSTR ZoneFactoryDi,
    ULONG  Type,
    ULONG  Order
);

EXTERN_C
LONG
SadRemoveGfxFromZoneGraph
(
    HANDLE hSad,
    HANDLE hGfx,
    PCTSTR GfxFriendlyName,
    PCTSTR ZoneFactoryDi,
    ULONG  Type,
    ULONG  Order
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\audiosrv\service.c ===
/*---------------------------------------------------------------------------
THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
PARTICULAR PURPOSE.

Copyright (C) 1993-2001.  Microsoft Corporation.  All rights reserved.

MODULE:   service.c

PURPOSE:  Implements functions required by all Windows NT services

FUNCTIONS:
  DllMain(PVOID hModule, ULONG Reason, PCONTEXT pContext)
  ServiceCtrl(DWORD dwCtrlCode, DWORD dwEventType, LPVOID lpEventData, LPVOID lpContext);
  ServiceMain(DWORD dwArgc, LPTSTR *lpszArgv);

---------------------------------------------------------------------------*/

#include <windows.h>
#include <shellapi.h>
#include <stdio.h>
#include <stdlib.h>
#include <process.h>
#include <tchar.h>
#include "debug.h"
#include "service.h"

// internal variables
SERVICE_STATUS          ssStatus;       // current status of the service
SERVICE_STATUS_HANDLE   sshStatusHandle;
DWORD                   dwErr = 0;

// internal function prototypes
DWORD WINAPI ServiceCtrl(DWORD dwCtrlCode, DWORD dwEventType, LPVOID lpEventData, LPVOID lpContext);
VOID  WINAPI ServiceMain(DWORD dwArgc, LPTSTR *lpszArgv);

//
//  FUNCTION: ServiceMain
//
//  PURPOSE: To perform actual initialization of the service
//
//  PARAMETERS:
//    dwArgc   - number of command line arguments
//    lpszArgv - array of command line arguments
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//    This routine performs the service initialization and then calls
//    the user defined ServiceStart() routine to perform majority
//    of the work.
//
void WINAPI ServiceMain(DWORD dwArgc, LPTSTR *lpszArgv)
{
    dprintf(TEXT("pid=%d\n"), GetCurrentProcessId());

   // register our service control handler:
   //
   sshStatusHandle = RegisterServiceCtrlHandlerEx(TEXT(SZSERVICENAME), ServiceCtrl, NULL);

   if (sshStatusHandle)
   {
       // SERVICE_STATUS members that don't change
       //
       ssStatus.dwServiceType = SERVICE_WIN32_SHARE_PROCESS;
       ssStatus.dwServiceSpecificExitCode = 0;
    
    
       // report the status to the service control manager.
       // ISSUE-2000/10/17-FrankYe reduce the wait hint
       if (ReportStatusToSCMgr(SERVICE_START_PENDING, // service state
                               NO_ERROR,              // exit code
                               60000))                // wait hint
       {
           ServiceStart( sshStatusHandle, dwArgc, lpszArgv );
       }
   }
   return;
}



//
//  FUNCTION: ServiceCtrl
//
//  PURPOSE: This function is called by the SCM whenever
//           ControlService() is called on this service.
//
//  PARAMETERS:
//    dwCtrlCode  - The requested control code.
//    dwEventType - The type of event that has occurred. 
//    lpEventData - Additional device information, if required. The
//                   format of this data depends on the value of the dwControl
//                   and dwEventType parameters.
//    lpContext   - The user-defined data passed from
//                   RegisterServiceCtrlHandlerEx.
// 
//  RETURN VALUE:
//    The return value for this function depends on the control code received.
//
//  COMMENTS:
//
DWORD WINAPI ServiceCtrl(DWORD dwCtrlCode, DWORD dwEventType, LPVOID lpEventData, LPVOID lpContext)
{
   // Handle the requested control code.
   //
   switch (dwCtrlCode)
   {
   // Stop the service.
   //
   // SERVICE_STOP_PENDING should be reported before
   // setting the Stop Event - hServerStopEvent - in
   // ServiceStop().  This avoids a race condition
   // which may result in a 1053 - The Service did not respond...
   // error.
   case SERVICE_CONTROL_STOP:
      ReportStatusToSCMgr(SERVICE_STOP_PENDING, NO_ERROR, 0);
      ServiceStop();
      return NO_ERROR;

   case SERVICE_CONTROL_DEVICEEVENT:
       return ServiceDeviceEvent(dwEventType, lpEventData);

   case SERVICE_CONTROL_INTERROGATE:
       ReportStatusToSCMgr(ssStatus.dwCurrentState, NO_ERROR, 0);
       return NO_ERROR;
      
   case SERVICE_CONTROL_SESSIONCHANGE:
      return ServiceSessionChange(dwEventType, lpEventData);

      // invalid control code
   default:
       return ERROR_CALL_NOT_IMPLEMENTED;
   }

   return ERROR_CALL_NOT_IMPLEMENTED;
}



//
//  FUNCTION: AddToMessageLog(LPTSTR lpszMsg)
//
//  PURPOSE: Allows any thread to log an error message
//
//  PARAMETERS:
//    lpszMsg - text for message
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
VOID AddToMessageLog(LPTSTR lpszMsg)
{
   TCHAR   szMsg[256];
   HANDLE  hEventSource;
   LPTSTR  lpszStrings[2];


  dwErr = GetLastError();

  // Use event logging to log the error.
  //
  hEventSource = RegisterEventSource(NULL, TEXT(SZSERVICENAME));

  wsprintf(szMsg, TEXT("%s error: %d"), TEXT(SZSERVICENAME), dwErr);
  lpszStrings[0] = szMsg;
  lpszStrings[1] = lpszMsg;

  if (hEventSource != NULL)
  {
     ReportEvent(hEventSource, // handle of event source
                 EVENTLOG_ERROR_TYPE,  // event type
                 0,                    // event category
                 0,                    // event ID
                 NULL,                 // current user's SID
                 2,                    // strings in lpszStrings
                 0,                    // no bytes of raw data
                 lpszStrings,          // array of error strings
                 NULL);                // no raw data

     (VOID) DeregisterEventSource(hEventSource);
  }
}

//
//  FUNCTION: ReportStatusToSCMgr()
//
//  PURPOSE: Sets the current status of the service and
//           reports it to the Service Control Manager
//
//  PARAMETERS:
//    dwCurrentState - the state of the service
//    dwWin32ExitCode - error code to report
//    dwWaitHint - worst case estimate to next checkpoint
//
//  RETURN VALUE:
//    TRUE  - success
//    FALSE - failure
//
//  COMMENTS:
//
BOOL ReportStatusToSCMgr(DWORD dwCurrentState,
                         DWORD dwWin32ExitCode,
                         DWORD dwWaitHint)
{
    static DWORD dwCheckPoint = 1;
    BOOL fResult = TRUE;
    
    
    // Accept only session notifications (no pause, stop, etc)
    ssStatus.dwControlsAccepted = SERVICE_ACCEPT_SESSIONCHANGE;
                                                   
    ssStatus.dwCurrentState = dwCurrentState;
    ssStatus.dwWin32ExitCode = dwWin32ExitCode;
    ssStatus.dwWaitHint = dwWaitHint;
    
    if ( ( dwCurrentState == SERVICE_RUNNING ) ||
       ( dwCurrentState == SERVICE_STOPPED ) )
        ssStatus.dwCheckPoint = 0;
    else
        ssStatus.dwCheckPoint = dwCheckPoint++;
    
    
    // Report the status of the service to the service control manager.
    //
    if (!(fResult = SetServiceStatus( sshStatusHandle, &ssStatus)))
    {
        AddToMessageLog(TEXT("SetServiceStatus"));
    }
    
    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\audiosrv\ts.cpp ===
// ts.cpp : Server side code for terminal server event stuff
//
// Created by FrankYe on 7/3/2000
//

#include <windows.h>
#include <wtsapi32.h>
#include "debug.h"
#include "list.h"
#include "service.h"
#include "audiosrv.h"
#include "agfxs.h"
#include "ts.h"

//=============================================================================
//===   Global data   ===
//=============================================================================

CListSessionNotifications *gplistSessionNotifications;

//=============================================================================
//===   debug helpers   ===
//=============================================================================

#ifdef DBG
PTSTR astrWtsEvent[] = {
    NULL,
    TEXT("WTS_CONSOLE_CONNECT"),
    TEXT("WTS_CONSOLE_DISCONNECT"),
    TEXT("WTS_REMOTE_CONNECT"),
    TEXT("WTS_REMOTE_DISCONNECT"),
    TEXT("WTS_SESSION_LOGON"),
    TEXT("WTS_SESSION_LOGOFF")
};
#endif

//=============================================================================
//===   xxx   ===
//=============================================================================

DWORD ServiceSessionChange(DWORD EventType, LPVOID EventData)
{
    PWTSSESSION_NOTIFICATION pWtsNotification = (PWTSSESSION_NOTIFICATION)EventData;
    
    POSITION pos;

    // dprintf(TEXT("ServiceSessionChange: %s on session %d\n"), astrWtsEvent[EventType], pWtsNotification->dwSessionId);
    
    GFX_SessionChange(EventType, EventData);
    
    gplistSessionNotifications->Lock();

    pos = gplistSessionNotifications->GetHeadPosition();

    while (pos) {
        PSESSIONNOTIFICATION pNotification;
        pNotification = gplistSessionNotifications->GetNext(pos);
        if (pWtsNotification->dwSessionId == pNotification->SessionId) {
            SetEvent(pNotification->Event);
        }
    }

    gplistSessionNotifications->Unlock();

    return NO_ERROR;
}


long s_winmmRegisterSessionNotificationEvent(IN unsigned long dwProcessId,
                                             IN RHANDLE inhEvent,
                                             OUT PHANDLE_SESSIONNOTIFICATION phNotification)
{
    PSESSIONNOTIFICATION pNotification;
    HANDLE hEvent;
    LONG lresult;
    
    ASSERT(gplistSessionNotifications);
    
    hEvent = (HANDLE)inhEvent;
    
    pNotification = new SESSIONNOTIFICATION;
    if (pNotification) {
        if (ProcessIdToSessionId(dwProcessId, &pNotification->SessionId))
        {
            HANDLE hClientProcess;
        
            hClientProcess = OpenProcess(PROCESS_DUP_HANDLE, FALSE, dwProcessId);
            if (hClientProcess) {
                if (DuplicateHandle(hClientProcess, hEvent,
                                    GetCurrentProcess(), &pNotification->Event,
                                    EVENT_MODIFY_STATE, FALSE, 0))
                {
                    POSITION posNotification;

                    posNotification = gplistSessionNotifications->AddTail(pNotification);
                    if (posNotification)
                    {
                        *phNotification = posNotification;
                        lresult = NO_ERROR;
                    } else {
                        lresult = ERROR_OUTOFMEMORY;
                    }

					if (lresult) {
                        CloseHandle(pNotification->Event);
                    }

                } else {
                    lresult = GetLastError();
                }

                CloseHandle(hClientProcess);
            } else {
                lresult = GetLastError();
            }
        } else {
            lresult = GetLastError();
        }

        if (lresult) {
            delete pNotification;
        }
    
    } else {
        lresult = ERROR_OUTOFMEMORY;
    }
    
    return lresult;
}

long s_winmmUnregisterSessionNotification(IN OUT PHANDLE_SESSIONNOTIFICATION phNotification)
{
    POSITION posNotification;
    LONG lresult;
    
    posNotification = (POSITION)*phNotification;
    
    if (posNotification) {
        PSESSIONNOTIFICATION pNotification;

        pNotification = gplistSessionNotifications->GetAt(posNotification);
        gplistSessionNotifications->RemoveAt(posNotification);

        CloseHandle(pNotification->Event);
        delete pNotification;

        *phNotification = NULL;

        lresult = NO_ERROR;
    } else {
        lresult = ERROR_INVALID_PARAMETER;
    }

    return lresult;
}

long s_winmmSessionConnectState(IN unsigned long dwProcessId, OUT int *outConnectState)
{
    DWORD dwSessionId;
    LONG lresult;

    if (ProcessIdToSessionId(dwProcessId, &dwSessionId)) {
        INT *pConnectState;
        DWORD BytesReturned;
        BOOL fresult;
        
        fresult = WTSQuerySessionInformation(WTS_CURRENT_SERVER_HANDLE,
                                             dwSessionId,
                                             WTSConnectState,
                                             (LPTSTR*)&pConnectState,
                                             &BytesReturned);
        if (fresult) {
            ASSERT(BytesReturned == sizeof(*pConnectState));
            *outConnectState = *pConnectState;
            WTSFreeMemory(pConnectState);
            lresult = NO_ERROR;
        } else {
            lresult = GetLastError();
        }
    } else {
        lresult = GetLastError();
    }
    
    return lresult;
}

void __RPC_USER HANDLE_SESSIONNOTIFICATION_rundown(HANDLE_SESSIONNOTIFICATION hNotification)
{
    ASSERT(SERVICE_STOPPED != ssStatus.dwCurrentState);
    if (SERVICE_STOPPED == ssStatus.dwCurrentState) return;
    s_winmmUnregisterSessionNotification(&hNotification);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avicap\avicapi.h ===
/****************************************************************************
 *
 *   avicapi.h
 *
 *   Internal, private definitions.
 *
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and
 *    distribute the Sample Files (and/or any modified version) in
 *    any way you find useful, provided that you agree that
 *    Microsoft has no warranty obligations or liability for any
 *    Sample Application Files which are modified.
 *
 ***************************************************************************/

#ifndef _INC_AVICAP_INTERNAL
#define _INC_AVICAP_INTERNAL

#include <avifile.h>

#include <mmreg.h>
#include <compman.h>
#include "iaverage.h"

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif  /* RC_INVOKED */

/* c8 uses underscores on all defines */
#if defined DEBUG && !defined _DEBUG
 #define _DEBUG
#elif defined _DEBUG && !defined DEBUG
 #define DEBUG
#endif

#if !defined NUMELMS
  #define NUMELMS(aa)           (sizeof(aa)/sizeof((aa)[0]))
  #define FIELDOFF(type,field)  (&(((type)0)->field))
  #define FIELDSIZ(type,field)  (sizeof(((type)0)->field))
#endif

//
// use the registry - not WIN.INI
//
#if defined(_WIN32) && defined(UNICODE)
#include "profile.h"
#endif

// switch off all references to the new vfw1.1 compman interfaces until we
// have the new compman ported to NT
#define NEW_COMPMAN

#ifndef _LPHISTOGRAM_DEFINED
#define _LPHISTOGRAM_DEFINED
typedef DWORD HUGE * LPHISTOGRAM;
#endif

#define WIDTHBYTES(i)     ((unsigned)((i+31)&(~31))/8)  /* ULONG aligned ! */
#define DIBWIDTHBYTES(bi) ((int)WIDTHBYTES((int)(bi).biWidth * (int)(bi).biBitCount))

// Swap palette entries around
#ifdef DEBUG
#define SWAPTYPE(x,y, type)  { type _temp_; _temp_=(x); (x)=(y), (y)=_temp_;}
#else
#define SWAPTYPE(x,y, type) ( (x)^=(y), (y)^=(x), (x)^=(y) )
#endif

#define ROUNDUPTOSECTORSIZE(dw, align) ((((DWORD)dw) + (align)-1) & ~((align)-1))

#define MAX_VIDEO_BUFFERS       400    // By using this number the CAPSTREAM structure fits into a page
#define MIN_VIDEO_BUFFERS       5
#define DEF_WAVE_BUFFERS        4
#define MAX_WAVE_BUFFERS        10

// MCI Capture state machine
enum mcicapstates {
   CAPMCI_STATE_Uninitialized = 0,
   CAPMCI_STATE_Initialized,

   CAPMCI_STATE_StartVideo,
   CAPMCI_STATE_CapturingVideo,
   CAPMCI_STATE_VideoFini,

   CAPMCI_STATE_StartAudio,
   CAPMCI_STATE_CapturingAudio,
   CAPMCI_STATE_AudioFini,

   CAPMCI_STATE_AllFini
};

// -------------------------
//  CAPSTREAM structure
// -------------------------
#define CAPSTREAM_VERSION 2             // Increment whenever struct changes
#define DEFAULT_BYTESPERSECTOR  512

// This structure is GlobalAlloc'd for each capture window instance.
// A pointer to the structure is stored in the Window extra bytes.
// Applications can retrieve a pointer to the stucture using
//    the WM_CAP_GET_CAPSTREAMPTR message.
// I: internal variables which the client app should not modify
// M: variables which the client app can set via Send/PostMessage

typedef struct tagCAPSTREAM {
    DWORD           dwSize;                     // I: size of structure
    UINT            uiVersion;                  // I: version of structure
    HINSTANCE       hInst;                      // I: our instance

    HANDLE          hThreadCapture;             // I: capture task handle
    DWORD           dwReturn;                   // I: capture task return value

    HWND            hwnd;                       // I: our hwnd

    // Use MakeProcInstance to create all callbacks !!!
    // Status, error callbacks
    CAPSTATUSCALLBACK   CallbackOnStatus;       // M: Status callback
    CAPERRORCALLBACK    CallbackOnError;        // M: Error callback

#ifdef UNICODE
    DWORD  fUnicode;				// I:
    // definitions for fUnicode
    #define  VUNICODE_ERRORISANSI	0x00000001      // set if error msg thunking required
    #define  VUNICODE_STATUSISANSI	0x00000002      // set if status msg thunking required
#endif

    // event used in capture loop to avoid polling
    HANDLE hCaptureEvent;		  	// I:
   #ifdef CHICAGO
    DWORD  hRing0CapEvt;			// I:
   #endif

    // Allows client to process messages during capture if set
    CAPYIELDCALLBACK    CallbackOnYield;        // M: Yield processing

    // Video and wave callbacks for Network or other specialized xfers
    CAPVIDEOCALLBACK    CallbackOnVideoFrame;   // M: Only during preview
    CAPVIDEOCALLBACK    CallbackOnVideoStream;  // M: Video buffer ready
    CAPWAVECALLBACK     CallbackOnWaveStream;   // M: Wave buffer ready
    CAPCONTROLCALLBACK  CallbackOnControl;      // M: External Start/Stop ctrl

    // Open channels on the video hardware device
    // and hardware capabilies
    CAPDRIVERCAPS   sCapDrvCaps;                // M: What can the driver do
    HVIDEO          hVideoIn;                   // I: In channel
    HVIDEO          hVideoCapture;              // I: Ext In channel
    HVIDEO          hVideoDisplay;              // I: Ext Out channel
    BOOL            fHardwareConnected;         // I: ANY open channel?

    // Flags indicating whether dialog boxes are currently displayed
#define VDLG_VIDEOSOURCE	0x00000001	// Video Source dialog
#define VDLG_VIDEOFORMAT	0x00000002	// Video Format dialog
#define VDLG_VIDEODISPLAY	0x00000004	// Video Display dialog
#define VDLG_COMPRESSION	0x00000008	// Video Compression dialog
    DWORD           dwDlgsActive;		// I: state of dialogs

    // Window to display video
    BOOL            fLiveWindow;                // M: Preview video
    BOOL            fOverlayWindow;             // M: Overlay video
    BOOL            fScale;                     // M: Scale image to client
    POINT           ptScroll;                   // I: Scroll position
    HANDLE          hdd;                        // I: hDrawDib access handle
    HCURSOR         hWaitCursor;                // I: hourglass
    UINT            uiRegion;                   // I: CheckWindowMove
    RECT            rcRegionRect;               // I: CheckWindowMove
    POINT	    ptRegionOrigin;

    // Window update timer
    UINT            idTimer;                    // I: ID of preview timer
    UINT            uTimeout;                   // M: Preview rate in mS. (not used after setting the timer)

    // Capture destination and control
    CAPTUREPARMS    sCapParms;                  // M: how to capture

    BOOL 	    fCaptureFlags;		//    state of capture

#define CAP_fCapturingToDisk		0x0001
#define CAP_fCapturingNow		0x0002
#define CAP_fStepCapturingNow           0x0004
#define CAP_fFrameCapturingNow          0x0008
#define CAP_fStopCapture                0x0010
#define CAP_fAbortCapture               0x0020

#if 0
    BOOL            fCapturingToDisk;           // M: if capturing to disk
    BOOL            fCapturingNow;              // I: if performing capture
    BOOL            fStepCapturingNow;          // I: if performing MCI step capture
    BOOL            fFrameCapturingNow;         // I: if performing single frame capture
    BOOL            fStopCapture;               // M: if stop requested
    BOOL            fAbortCapture;              // M: if abort requested

#endif
    DWORD           dwTimeElapsedMS;            // I: Capture time in millisec

    // Index
    HGLOBAL         hIndex;                     // I: handle to index mem
    DWORD           dwIndex;                    // I: index index
    DWORD           dwVideoChunkCount;          // I: # of video frames cap'd
    DWORD           dwWaveChunkCount;           // I: # of audio buffers cap'd
    LPDWORD         lpdwIndexStart;             // I: index start ptr
    LPDWORD         lpdwIndexEntry;             // I: index current ptr

    // Video format
    DWORD           dwActualMicroSecPerFrame;   // I: Actual cap rate
    LPBITMAPINFO    lpBitsInfo;                 // I: Video format
    int             dxBits;                     // I: video size x
    int             dyBits;                     // I: video size y
    LPBYTE          lpBits;                     // I: Single frame capture buf
    LPBYTE          lpBitsUnaligned;            // I: Single frame capture buf
    VIDEOHDR        VidHdr;                     // I: Single frame header

#ifdef 	NEW_COMPMAN
    COMPVARS        CompVars;                   // M: Set by ICCompressorChoose
#endif

    LPIAVERAGE      lpia;                       // I: Image averaging struct
    VIDEOHDR        VidHdr2x;                   // I: VideoHeader at 2x
    LPBITMAPINFOHEADER  lpbmih2x;               // I: lpbi at 2x

    // Video Buffer management
    DWORD           cbVideoAllocation;          // I: size of non-comp buffer incl chunk (not used)
    int             iNumVideo;                  // I: Number of actual video buffers
    int             iNextVideo;                 // I: index into video buffers
    DWORD           dwFramesDropped;            // I: number of frames dropped
    LPVIDEOHDR      alpVideoHdr[MAX_VIDEO_BUFFERS]; // I: array of buf ptrs
    BOOL            fBuffersOnHardware;         // I: if driver all'd buffers
    LPSTR           lpDropFrame;

    // Palettes
    HPALETTE        hPalCurrent;                // I: handle of current pal
    BOOL            fUsingDefaultPalette;       // I: no user defined pal
    int             nPaletteColors;             // M: only changed by UI
    LPVOID          lpCapPal;                   // I: LPCAPPAL manual pals
    LPVOID          lpCacheXlateTable;          // I: 32KB xlate table cached

    // Audio Capture Format
    BOOL            fAudioHardware;             // I: if audio hardware present
    LPWAVEFORMATEX  lpWaveFormat;               // I: wave format
    WAVEHDR         WaveHdr;                    // I: Wave header
    HWAVEIN         hWaveIn;                    // I: Wave input channel
    DWORD           dwWaveBytes;                // I: Total wave bytes cap'd
    DWORD           dwWaveSize;                 // I: wave buffer size

    // Audio Buffer management
    LPWAVEHDR       alpWaveHdr[MAX_WAVE_BUFFERS]; // I: wave buff array
    int             iNextWave;                  // I: Index into wave buffers
    int             iNumAudio;                  // I: Number of actual audio buffers
    BOOL            fAudioYield;                // I: ACM audio yield required
    BOOL            fAudioBreak;                // I: Audio underflow

    // MCI Capture
    TCHAR           achMCIDevice[MAX_PATH];     // MCI device name
    DWORD           dwMCIError;                 // I: Last MCI error value
    enum mcicapstates MCICaptureState;          // I: MCI State machine
    DWORD           dwMCICurrentMS;             // I: Current MCI position
    DWORD           dwMCIActualStartMS;         // I: Actual MCI start MS
    DWORD           dwMCIActualEndMS;           // I: Actual MCI end position

    // Output file
    TCHAR           achFile [MAX_PATH];         // M: name of capture file
    TCHAR           achSaveAsFile [MAX_PATH];   // M: name of saveas file
    LONG            lCapFileSize;               // M: in bytes
    BOOL            fCapFileExists;             // I: if have a capture file
    BOOL            fFileCaptured;              // I: if we've cap'd to file

    // async file io
    //
    DWORD           dwAsyncWriteOffset;         // I: last file write offset
    UINT            iNextAsync;                 // I: next async io header to be done
    UINT            iLastAsync;                 // I: last async io header to be written
    UINT            iNumAsync;                  // I: number of async io headers
    struct _avi_async {
        OVERLAPPED ovl;                         // I: for WriteFile call
        UINT       uType;                       // I: write type (Video/Wave/Drop)
        UINT       uIndex;                      // I: index into alpWaveHdr or alpVideoHdr
        } *        pAsync;                      // I: ptr to array of async io headers
#ifdef USE_AVIFILE
    // these 4 fields when using avifile
    //
    BOOL            bUseAvifile;
    PAVISTREAM      pvideo;
    PAVISTREAM      paudio;
    PAVIFILE        pavifile;
#endif

    HMMIO           hmmio;                      // I: MMIO handle for writing
    HANDLE          hFile;                      // I: write via CreateFile
    DWORD           dwBytesPerSector;           // I: bytes per sector
    BOOL            fUsingNonBufferedIO;        // I: FILE_FLAG_NO_BUFFERING
    DWORD           dwAVIHdrSize;               // I: size of header
    DWORD           dwAVIHdrPos;                // I: file offset of hdr

    LONG	    lUser;			// M: Data for the user
    LPVOID          lpInfoChunks;               // M: information chunks
    LONG            cbInfoChunks;               // M: sizeof information chks
    BOOL            fLastStatusWasNULL;         // I: don't repeat null msgs
    BOOL            fLastErrorWasNULL;          // I: don't repeat null msgs
} CAPSTREAM;
typedef CAPSTREAM FAR * LPCAPSTREAM;

// values for capstream.pAsync[nn].wType field
//
#define ASYNC_BUF_VIDEO 1
#define ASYNC_BUF_AUDIO 2
#define ASYNC_BUF_DROP  3

// -------------------------
//  Full color log palette
// -------------------------

typedef struct tagFCLOGPALETTE {
    WORD         palVersion;
    WORD         palNumEntries;
    PALETTEENTRY palPalEntry[256];
} FCLOGPALETTE;

typedef struct {
    DWORD       dwType;
    DWORD       dwSize;
} RIFF, *PRIFF, FAR *LPRIFF;

extern HINSTANCE ghInstDll;
#define	IDS_CAP_RTL	10000
extern BOOL gfIsRTL;

// capinit.c
BOOL CapWinDisconnectHardware(LPCAPSTREAM lpcs);
BOOL CapWinConnectHardware (LPCAPSTREAM lpcs, UINT wDeviceIndex);
BOOL capInternalGetDriverDesc (UINT wDriverIndex,
        LPTSTR lpszName, int cbName,
        LPTSTR lpszVer, int cbVer);
BOOL capInternalGetDriverDescA(UINT wDriverIndex,
        LPSTR lpszName, int cbName,
        LPSTR lpszVer, int cbVer);

// capwin.c
LONG FAR PASCAL LOADDS EXPORT CapWndProc (HWND hwnd, UINT msg, UINT wParam, LONG lParam);

#if defined CHICAGO
 VOID WINAPI OpenMMDEVLDR(
     void);

 VOID WINAPI CloseMMDEVLDR(
     void);

 VOID FreeContigMem (
     DWORD hMemContig);

 LPVOID AllocContigMem (
     DWORD   cbSize,
     LPDWORD phMemContig);
#endif


// capavi.c
LPVOID FAR PASCAL AllocSectorAlignedMem (DWORD dwRequest, DWORD dwAlign);
void FAR PASCAL FreeSectorAlignedMem(LPVOID p);
DWORDLONG GetFreePhysicalMemory(void);
DWORD CalcWaveBufferSize (LPCAPSTREAM lpcs);
BOOL AVIFileFini (LPCAPSTREAM lpcs, BOOL fWroteJunkChunks, BOOL fAbort);
UINT AVIAudioInit (LPCAPSTREAM lpcs);
UINT AVIAudioFini (LPCAPSTREAM lpcs);
UINT AVIAudioPrepare (LPCAPSTREAM lpcs);
UINT AVIAudioUnPrepare (LPCAPSTREAM lpcs);
UINT AVIVideoInit (LPCAPSTREAM lpcs);
UINT AVIVideoPrepare (LPCAPSTREAM lpcs);
UINT AVIVideoUnPrepare (LPCAPSTREAM lpcs);
void AVIFini(LPCAPSTREAM lpcs);
UINT AVIInit (LPCAPSTREAM lpcs);
BOOL FAR PASCAL SetInfoChunk(LPCAPSTREAM lpcs, LPCAPINFOCHUNK lpcic);
BOOL AVICapture (LPCAPSTREAM lpcs);

// capio.c
//
BOOL InitIndex (LPCAPSTREAM lpcs);
void FiniIndex (LPCAPSTREAM lpcs);
BOOL WriteIndex (LPCAPSTREAM lpcs, BOOL fJunkChunkWritten);
BOOL CapFileInit(LPCAPSTREAM lpcs);
BOOL WINAPI AVIWriteAudio (
    LPCAPSTREAM lpcs,
    LPWAVEHDR   lpwh,
    UINT        uIndex,
    LPUINT      lpuError,
    LPBOOL      pbPending);
BOOL WINAPI AVIWriteVideoFrame (
    LPCAPSTREAM lpcs,
    LPBYTE      lpData,
    DWORD       dwBytesUsed,
    BOOL        fKeyFrame,
    UINT        uIndex,
    UINT        nDropped,
    LPUINT      lpuError,
    LPBOOL      pbPending);
BOOL WINAPI AVIWriteDummyFrames (
    LPCAPSTREAM lpcs,
    UINT        nCount,
    LPUINT      lpuError,
    LPBOOL      pbPending);
VOID WINAPI AVIPreloadFat (LPCAPSTREAM lpcs);

// capfile.c
BOOL FAR PASCAL fileCapFileIsAVI (LPTSTR lpsz);
BOOL FAR PASCAL fileAllocCapFile(LPCAPSTREAM lpcs, DWORD dwNewSize);
BOOL FAR PASCAL fileSaveCopy(LPCAPSTREAM lpcs);
BOOL FAR PASCAL fileSavePalette(LPCAPSTREAM lpcs, LPTSTR lpszFileName);
BOOL FAR PASCAL fileOpenPalette(LPCAPSTREAM lpcs, LPTSTR lpszFileName);

//capmisc.c
UINT GetKey(BOOL fWait);
void errorDriverID (LPCAPSTREAM lpcs, DWORD dwError);
void FAR CDECL statusUpdateStatus (LPCAPSTREAM lpcs, UINT wID, ...);
void FAR CDECL errorUpdateError (LPCAPSTREAM lpcs, UINT wID, ...);

//capFrame.c
BOOL FAR PASCAL SingleFrameCaptureOpen (LPCAPSTREAM lpcs);
BOOL FAR PASCAL SingleFrameCaptureClose (LPCAPSTREAM lpcs);
BOOL FAR PASCAL SingleFrameCapture (LPCAPSTREAM lpcs);
BOOL SingleFrameWrite (
    LPCAPSTREAM             lpcs,       // capture stream
    LPVIDEOHDR              lpVidHdr,   // input header
    BOOL FAR 		    *pfKey,	// did it end up being a key frame?
    LONG FAR		    *plSize);	// size of returned image

//capMCI.c
void FAR PASCAL TimeMSToSMPTE (DWORD dwMS, LPTSTR lpTime);
int CountMCIDevicesByType ( UINT wType );
void MCIDeviceClose (LPCAPSTREAM lpcs);
BOOL MCIDeviceOpen (LPCAPSTREAM lpcs);
BOOL FAR PASCAL MCIDeviceGetPosition (LPCAPSTREAM lpcs, LPDWORD lpdwPos);
BOOL FAR PASCAL MCIDeviceSetPosition (LPCAPSTREAM lpcs, DWORD dwPos);
BOOL FAR PASCAL MCIDevicePlay (LPCAPSTREAM lpcs);
BOOL FAR PASCAL MCIDevicePause (LPCAPSTREAM lpcs);
BOOL FAR PASCAL MCIDeviceStop (LPCAPSTREAM lpcs);
BOOL FAR PASCAL MCIDeviceStep (LPCAPSTREAM lpcs, BOOL fForward);
void FAR PASCAL _LOADDS MCIStepCapture (LPCAPSTREAM lpcs);

#define AnsiToWide(lpwsz,lpsz,nChars) MultiByteToWideChar(CP_ACP, 0, lpsz, nChars, lpwsz, nChars)
#define WideToAnsi(lpsz,lpwsz,nChars) WideCharToMultiByte(CP_ACP, 0, lpwsz, nChars, lpsz, nChars, NULL, NULL)
#ifdef CHICAGO
 // chicago internal api to get a vxd visible alias for Win32 handle
 // this is used on the hCaptureEvent handle so that it can be signaled
 // from within 16 bit code.
 DWORD WINAPI OpenVxDHandle (HANDLE);
#endif

#ifdef _DEBUG
  BOOL FAR PASCAL _Assert(BOOL f, LPSTR szFile, int iLine);
  #define WinAssert(exp) (_Assert(exp, (LPSTR) __FILE__, __LINE__))
  extern void FAR CDECL dprintf(LPSTR, ...);
  #define DPF dprintf
#else
  #define dprintf ; / ## /
  #define DPF ; / ## /
  #define WinAssert(exp) 0
#endif


#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif    /* __cplusplus */

#endif /* INC_AVICAP_INTERNAL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avicap\capavi.c ===
/****************************************************************************
 *
 *   capavi.c
 *
 *   Main video capture module.
 *
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992 - 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and
 *    distribute the Sample Files (and/or any modified version) in
 *    any way you find useful, provided that you agree that
 *    Microsoft has no warranty obligations or liability for any
 *    Sample Application Files which are modified.
 *
 ***************************************************************************/

#define INC_OLE2
#pragma warning(disable:4103)
#include <windows.h>
#include <windowsx.h>
#include <win32.h>
#include <mmsystem.h>
#include <msvideo.h>
#include <drawdib.h>
#include <mmreg.h>
#include <mmddk.h>

#include "ivideo32.h"
#include "mmdebug.h"

#ifdef USE_ACM
#include <msacm.h>
#endif

#include <avifmt.h>
#include "avicap.h"
#include "avicapi.h"
#include "time.h"

#define JMK_HACK_TIMERS    TRUE

#ifdef JMK_HACK_TIMERS
 #define _INC_MMTIMERS_CODE_ TRUE
 #define CLIPBOARDLOGSIZE 1000

 #ifndef MAKEFOURCC
  #define MAKEFOURCC(a,b,c,d) ((DWORD)(a) | ((DWORD)(b) << 8) | ((DWORD)(c) << 16) | ((DWORD)(d) << 24))
 #endif

 #define RIFFTYPE(dw) (((dw & 0xFF) << 24) | ((dw & 0xFF00) << 8) | ((dw & 0xFF0000) >> 8) | ((dw & 0xFF000000) >> 24))

 #include "mmtimers.h"

typedef struct _timerstuff {
     DWORD dwFrameTickTime;	// What we think the current frame time should be
     DWORD dwFrameStampTime;	// Stamped in the VIDEOHDR
     DWORD dwTimeWritten;       // Time WriteFile called
     DWORD dwTimeToWrite;       // Time WriteFile returned
     WORD  nFramesAppended;	// Accumulated appended dropped frames
     WORD  nDummyFrames;	// frames calc'ed as dropped
     DWORD dwVideoChunkCount;   // current 'frame'
     WORD  nAudioIndex;         // next audio buffer
     WORD  nVideoIndex;         // next video buffer
     WORD  bPending;
     WORD  nSleepCount;
     DWORD dwSleepBegin;
     DWORD dwSleepEnd;
     };

 STATICDT PCTIMER  pctWriteBase;
 STATICDT struct _timerstuff * pCurTimerStuff;
 STATICDT struct _timerstuff * pTimerStuff;
 STATICDT HGLOBAL  hMemTimers;

 STATICDT struct _timerriff {
     FOURCC   fccRIFF;       // 'RIFF'
     DWORD    cbTotal;       // total (inclusive) size of riff data
     FOURCC   fccJMKD;       // 'JMKD' data type identifier
     DWORD    fccVCHD;       // 'VCHD' capture data header
     DWORD    cbVCHD;        // sizeof vchd data
     struct _vchd {
         DWORD            nPrio;
         DWORD            dwFramesCaptured;
         DWORD            dwFramesDropped;
         DWORD            dwDropFramesAppended;
         DWORD            dwDropFramesNotAppended;
         DWORD            dwTimerFrequency;
         DWORD            dwSpare[2];
         CAPTUREPARMS     cap;
         BITMAPINFOHEADER bmih;
         DWORD            nMaxVideoBuffers;
         struct _thkvideohdr {
             VIDEOHDR vh;
             LPBYTE   p32Buff;
             DWORD    p16Alloc;
             DWORD    dwMemHandle;
             DWORD    dwReserved;
             }            atvh[64];
         }    vchd;
     DWORD    fccChunk;      // chunk data type tag
     DWORD    cbChunk;       // non-inclusive size of chunk data
     } * pTimerRiff;

 STATICDT UINT nTimerIndex;
 STATICDT UINT nSleepCount;
#endif

#ifdef _DEBUG
    #define DSTATUS(lpcs, sz) statusUpdateStatus(lpcs, IDS_CAP_INFO, (LPTSTR) TEXT(sz))
#else
    #define DSTATUS(lpcs, sz)
#endif

// Allocate memory which can be page aligned

LPVOID FAR PASCAL AllocSectorAlignedMem (DWORD dwRequest, DWORD dwAlign)
{
    LPVOID pbuf;

    dwRequest = ROUNDUPTOSECTORSIZE (dwRequest, dwAlign) + dwAlign;      // round up to next page boundary

    pbuf = VirtualAlloc (NULL, dwRequest,
                        MEM_COMMIT | MEM_RESERVE,
                        PAGE_READWRITE);
    AuxDebugEx(4, DEBUGLINE "Allocated %d bytes of sector aligned memory at %8x\r\n", dwRequest, pbuf);
    return pbuf;
}

void FAR PASCAL FreeSectorAlignedMem (LPVOID pbuf)
{
   // the pointer we free had better be aligned on at least a 256 byte
   // boundary
   //
   assert (!((DWORD)pbuf & 255));
   (DWORD)pbuf &= ~255;
   VirtualFree (pbuf, 0, MEM_RELEASE);
}

#define ONEMEG (1024L * 1024L)

DWORDLONG GetFreePhysicalMemory(void)
{
	MEMORYSTATUSEX ms;

	ms.dwLength = sizeof(ms);
    
    GlobalMemoryStatusEx(&ms);

    if (ms.ullTotalPhys > 8L * ONEMEG)
        return ms.ullTotalPhys - ONEMEG * 4;

    return(ms.ullTotalPhys /2);
}

// ****************************************************************
// ******************** Audio Buffer Control **********************
// ****************************************************************

// Audio buffers are always allocated under the presumption that
// audio capture may be enabled at any time.
// AVIAudioInit must be matched with AVIAudioFini (both only called once)
// AVIAudioPrepare must be matched with AVIAudioUnPrepare
//      (which may be called multiple times to enable and disable audio)


// AVI AudioInit - Allocate and initialize buffers for audio capture.
//                 This routine is also used by MCI capture.
//                 Returns: 0 on success, otherwise an error code.

UINT AVIAudioInit (LPCAPSTREAM lpcs)
{
    int         i;
    LPVOID      pHdr;
    LPVOID      p;

    if (lpcs->sCapParms.wNumAudioRequested == 0)
        lpcs->sCapParms.wNumAudioRequested = DEF_WAVE_BUFFERS;

    // .5 second of audio per buffer (or 10K, whichever is larger)
    if (lpcs->sCapParms.dwAudioBufferSize == 0)
        lpcs->dwWaveSize = CalcWaveBufferSize (lpcs);
    else {
        lpcs->dwWaveSize = 0;
        if (lpcs->lpWaveFormat)
            lpcs->dwWaveSize = lpcs->sCapParms.dwAudioBufferSize;
    }

    // Alloc the wave memory
    for(i = 0; i < (int)lpcs->sCapParms.wNumAudioRequested; i++) {

        pHdr = GlobalAllocPtr(GPTR, sizeof(WAVEHDR));

        if (pHdr == NULL)
            break;

        lpcs->alpWaveHdr[i] = pHdr;

        p = AllocSectorAlignedMem( sizeof(RIFF) + lpcs->dwWaveSize, lpcs->dwBytesPerSector);
        if (p == NULL) {
            GlobalFreePtr (pHdr);
            lpcs->alpWaveHdr[i] = NULL;
            break;
        }

        lpcs->alpWaveHdr[i]->lpData          = (LPBYTE)p + sizeof(RIFF);
        lpcs->alpWaveHdr[i]->dwBufferLength  = lpcs->dwWaveSize;
        lpcs->alpWaveHdr[i]->dwBytesRecorded = 0;
        lpcs->alpWaveHdr[i]->dwUser          = 0;
        lpcs->alpWaveHdr[i]->dwFlags         = 0;
        lpcs->alpWaveHdr[i]->dwLoops         = 0;

        ((LPRIFF)p)->dwType = MAKEAVICKID(cktypeWAVEbytes, 1);
        ((LPRIFF)p)->dwSize = lpcs->dwWaveSize;
    }

    lpcs->iNumAudio = i;

    return ((lpcs->iNumAudio == 0) ? IDS_CAP_WAVE_ALLOC_ERROR : 0);
}


//
// AVI AudioFini    - UnPrepares headers
//                      This routine is also used by MCI capture.
//                      Returns: 0 on success, otherwise an error code.

UINT AVIAudioFini (LPCAPSTREAM lpcs)
{
    int ii;

    /* free headers and data */
    for (ii=0; ii < MAX_WAVE_BUFFERS; ++ii) {
        if (lpcs->alpWaveHdr[ii]) {
            if (lpcs->alpWaveHdr[ii]->lpData)
                FreeSectorAlignedMem((LPBYTE)lpcs->alpWaveHdr[ii]->lpData - sizeof (RIFF));
            GlobalFreePtr(lpcs->alpWaveHdr[ii]);
            lpcs->alpWaveHdr[ii] = NULL;
        }
    }

    return 0;
}

//
// AVI AudioPrepare - Opens the wave device and adds the buffers
//                    Prepares headers and adds buffers to the device
//                    This routine is also used by MCI capture.
//                    Returns: 0 on success, otherwise an error code.

UINT AVIAudioPrepare (LPCAPSTREAM lpcs)
{
    UINT uiError;
    int  ii;

    /* See if we can open that format for input */

    // register event callback to avoid polling

    uiError = waveInOpen(&lpcs->hWaveIn,
        WAVE_MAPPER, lpcs->lpWaveFormat,
        (DWORD) lpcs->hCaptureEvent,  0, CALLBACK_EVENT );

    if (uiError != MMSYSERR_NOERROR)
        return IDS_CAP_WAVE_OPEN_ERROR;

    lpcs->fAudioYield = FALSE; // ACM is separate thread, don't yield
    lpcs->fAudioBreak = FALSE;

    DPF("AudioYield = %d", lpcs->fAudioYield);

    for (ii = 0; ii < (int)lpcs->sCapParms.wNumAudioRequested; ++ii) {

        if (waveInPrepareHeader (lpcs->hWaveIn, lpcs->alpWaveHdr[ii],
                                 sizeof(WAVEHDR)))
            return IDS_CAP_WAVE_ALLOC_ERROR;

        if (waveInAddBuffer (lpcs->hWaveIn, lpcs->alpWaveHdr[ii],
                             sizeof(WAVEHDR)))
            return IDS_CAP_WAVE_ALLOC_ERROR;
	AuxDebugEx(3, DEBUGLINE "Added wave buffer %d (%8x)\r\n", ii, lpcs->alpWaveHdr[ii]);
    }

    lpcs->iNextWave = 0;        // current wave
    lpcs->dwWaveBytes = 0L;     // number of wave bytes
    lpcs->dwWaveChunkCount = 0; // number of wave frames

    return 0;
}

//
// AVI AudioUnPrepare - UnPrepares headers and closes the wave device.
//                      This routine is also used by MCI capture.
//                      Returns: 0 on success, otherwise an error code.

UINT AVIAudioUnPrepare (LPCAPSTREAM lpcs)
{
    int ii;

    if (lpcs->hWaveIn)
    {
        waveInReset(lpcs->hWaveIn);

        // unprepare any headers that have been prepared
        //
        for (ii=0; ii < lpcs->iNumAudio; ++ii)
            if (lpcs->alpWaveHdr[ii] &&
                (lpcs->alpWaveHdr[ii]->dwFlags & WHDR_PREPARED))
                waveInUnprepareHeader (lpcs->hWaveIn,
                                       lpcs->alpWaveHdr[ii],
                                       sizeof(WAVEHDR));

        waveInClose(lpcs->hWaveIn);
        lpcs->hWaveIn = NULL;
    }

    return 0;
}

// ****************************************************************
// ******************** Video Buffer Control **********************
// ****************************************************************

// AVIVideoInit -  Allocates, and initialize buffers for video capture.
//                 This routine is also used by MCI capture.
//                 Returns: 0 on success, otherwise an error code.

#if defined CHICAGO

UINT AVIVideoInit (LPCAPSTREAM lpcs)
{
    UINT           iMaxVideo;
    DWORD          mmr;
    LPTHKVIDEOHDR  ptvh;
    UINT           ii;
    DWORD          cbVideo;

    lpcs->iNumVideo = 0;
    lpcs->iNextVideo = 0;
    lpcs->dwVideoChunkCount = 0;
    lpcs->dwFramesDropped = 0;
    lpcs->fBuffersOnHardware = FALSE;

    // When performing MCI step capture, buffer array is not used
    if (lpcs->sCapParms.fStepMCIDevice)
        return 0;

    // If the user hasn't specified the number of video buffers to use,
    // assume the minimum

    if (lpcs->sCapParms.wNumVideoRequested == 0)
        lpcs->sCapParms.wNumVideoRequested = MIN_VIDEO_BUFFERS;

    cbVideo = ROUNDUPTOSECTORSIZE (lpcs->lpBitsInfo->bmiHeader.biSizeImage
                                   + sizeof(RIFF),
                                   lpcs->dwBytesPerSector)
              + lpcs->dwBytesPerSector;

    // use the number of video buffers that the user requested
    // or the maximum that will fit in memory.
    //
    iMaxVideo = min (MAX_VIDEO_BUFFERS, lpcs->sCapParms.wNumVideoRequested);

    if (iMaxVideo > 1)
    {
        DWORDLONG dwFreeMem;
        DWORDLONG dwUserRequests;
        DWORDLONG dwAudioMem;

        // How much actual free physical memory exists?
        dwFreeMem = GetFreePhysicalMemory();
        dwAudioMem = lpcs->dwWaveSize * lpcs->sCapParms.wNumAudioRequested;

        #define FOREVER_FREE 32768L   // Always keep this free for swap space

        // How much memory will be used if we allocate per the request?
        //
        dwUserRequests = dwAudioMem
                         + cbVideo * iMaxVideo
                         + FOREVER_FREE;

        // If request is greater than available memory, force fewer buffers
        //
        if (dwUserRequests > dwFreeMem)
        {
            if (dwFreeMem > dwAudioMem)
                dwFreeMem -= dwAudioMem;
            iMaxVideo = (int)(((dwFreeMem * 8) / 10) / cbVideo);
            iMaxVideo = min (MAX_VIDEO_BUFFERS, iMaxVideo);
            dprintf("iMaxVideo = %d\n", iMaxVideo);
        }
    }

    mmr = vidxAllocHeaders(lpcs->hVideoIn, iMaxVideo, &ptvh);
    if (mmr != MMSYSERR_NOERROR)
        return IDS_CAP_VIDEO_ALLOC_ERROR;

    AuxDebugEx (3, DEBUGLINE "vidxAllocHdrs returned ptvh=%X\r\n", ptvh);
    AuxDebugDump (8, ptvh, sizeof(*ptvh) * iMaxVideo);

    for (ii = 0; ii < iMaxVideo; ++ii)
    {
        LPVIDEOHDR pvh = NULL;
        LPRIFF     priff;

        // in chicago we let the thunk layer allocate memory
        // so that we can be assured that the memory can be easily
        // thunked.
        //
        // the pointer will be rounded up to a sector size boundary
        //
        mmr = vidxAllocBuffer (lpcs->hVideoIn, ii, &ptvh, cbVideo);
        if ((mmr != MMSYSERR_NOERROR) || (ptvh == NULL))
            break;

        lpcs->alpVideoHdr[ii] = pvh = &ptvh->vh;

        // vidxAllocBuffer actually returns a couple of extra fields
        // after the video header. the first of these holds the
        // linear address of the buffer.
        //
        priff = (LPVOID) ROUNDUPTOSECTORSIZE (ptvh->p32Buff, lpcs->dwBytesPerSector);

       #ifdef DEBUG
        {
        LPBYTE pb = (LPVOID)ptvh->p32Buff;
        AuxDebugEx (4, DEBUGLINE "buffer[%d] at %x linear. Doing touch test\r\n",
                    ii, ptvh->p32Buff);
        pb[0] = 0;
        pb[cbVideo-1] = 0;
        }
       #endif

        // write the riff header for this chunk.
        //
        priff->dwType = MAKEAVICKID(cktypeDIBbits, 0);
        if (lpcs->lpBitsInfo->bmiHeader.biCompression == BI_RLE8)
            priff->dwType = MAKEAVICKID(cktypeDIBcompressed, 0);
        priff->dwSize = lpcs->lpBitsInfo->bmiHeader.biSizeImage;

        // init the video header
        //
        pvh->lpData = (LPVOID)(priff + 1);
        pvh->dwBufferLength  = priff->dwSize;
        pvh->dwBytesUsed     = 0;
        pvh->dwTimeCaptured  = 0;
        pvh->dwUser          = 0;
        pvh->dwFlags         = 0;

        AuxDebugEx (4, DEBUGLINE "lpVideoHdr[%d]==%X\r\n", ii, lpcs->alpVideoHdr[ii]);
        AuxDebugDump (8, lpcs->alpVideoHdr[ii], sizeof(*ptvh));
    }
    lpcs->iNumVideo = ii;
    lpcs->cbVideoAllocation = cbVideo;

    dprintf("cbVideo = %ld \n", cbVideo);
    dprintf("iNumVideo Allocated = %d \n", lpcs->iNumVideo);
    return lpcs->iNumVideo ? 0 : IDS_CAP_VIDEO_ALLOC_ERROR;
}

//
// AVIVideoPrepare -  Prepares headers and adds buffers to the device
//                    This routine is also used by MCI capture.
//                    Returns: 0 on success, otherwise an error code.

UINT AVIVideoPrepare (LPCAPSTREAM lpcs)
{
    int ii;

    // When performing MCI step capture, buffer array is not used
    if (lpcs->sCapParms.fStepMCIDevice)
        return 0;

   #ifdef JMK_HACK_CHECKHDR
    {
    LPTHKVIDEOHDR lptvh = (LPVOID)lpcs->alpVideoHdr[0];

    if (HIWORD(lptvh->vh.lpData) != HIWORD(lptvh->p32Buff))
        {
        AuxDebugEx (0, DEBUGLINE "before stream init: hdr trouble\r\n");

        AuxDebugEx (0, DEBUGLINE "iNext=%d, ptvh=%X\r\n", lpcs->iNextVideo, lptvh);
        AuxDebugDump (0, lptvh, sizeof(*lptvh));
        AuxDebugEx (0, DEBUGLINE "alpVideoHdrs=%X\r\n", lpcs->alpVideoHdr);
        AuxDebugDump (0, lpcs->alpVideoHdr, sizeof(lpcs->alpVideoHdr[0]) * 8);

        INLINE_BREAK;
        return IDS_CAP_VIDEO_OPEN_ERROR;
        }
    }
   #endif

    // Open the video stream, setting the capture rate
    //
    if (videoStreamInit(lpcs->hVideoIn,
                        lpcs->sCapParms.dwRequestMicroSecPerFrame,
                        lpcs->hRing0CapEvt,
                        0,
                        CALLBACK_EVENT))
    {
        dprintf("cant open video device!\n");
        return IDS_CAP_VIDEO_OPEN_ERROR;
    }

   #ifdef JMK_HACK_CHECKHDR
    {
    LPTHKVIDEOHDR lptvh = (LPVOID)lpcs->alpVideoHdr[0];

    if (HIWORD(lptvh->vh.lpData) != HIWORD(lptvh->p32Buff))
        {
        AuxDebugEx (0, DEBUGLINE "after stream init: hdr trouble\r\n");

        AuxDebugEx (0, DEBUGLINE "iNext=%d, ptvh=%X\r\n", lpcs->iNextVideo, lptvh);
        AuxDebugDump (0, lptvh, sizeof(*lptvh));
        AuxDebugEx (0, DEBUGLINE "alpVideoHdrs=%X\r\n", lpcs->alpVideoHdr);
        AuxDebugDump (0, lpcs->alpVideoHdr, sizeof(lpcs->alpVideoHdr[0]) * 8);

        INLINE_BREAK;
        return IDS_CAP_VIDEO_OPEN_ERROR;
        }
    }
   #endif

    // Prepare (lock) the buffers, and give them to the device
    //
    for (ii = 0; ii < lpcs->iNumVideo; ++ii)
    {
        if (vidxAddBuffer (lpcs->hVideoIn,
                           lpcs->alpVideoHdr[ii],
                           sizeof(VIDEOHDR)))
        {
            lpcs->iNumVideo = ii;
            dprintf("**** could only prepare %d Video buffers!\n", lpcs->iNumVideo);
            break;
        }
    }

   #ifdef JMK_HACK_CHECKHDR
    {
    LPTHKVIDEOHDR lptvh = (LPVOID)lpcs->alpVideoHdr[0];

    if (IsBadWritePtr (lptvh, sizeof(*lptvh)) ||
        HIWORD(lptvh->vh.lpData) != HIWORD(lptvh->p16Alloc))
        {
        AuxDebugEx (0, DEBUGLINE "after add buffers: hdr trouble\r\n");

        AuxDebugEx (0, DEBUGLINE "iNext=%d, ptvh=%X\r\n", lpcs->iNextVideo, lptvh);
        AuxDebugDump (0, lptvh, sizeof(*lptvh));
        AuxDebugEx (0, DEBUGLINE "alpVideoHdrs=%X\r\n", lpcs->alpVideoHdr);
        AuxDebugDump (0, lpcs->alpVideoHdr, sizeof(lpcs->alpVideoHdr[0]) * 8);

        INLINE_BREAK;
        return IDS_CAP_VIDEO_OPEN_ERROR;
        }
    }
   #endif

    return 0;
}

#else // code below is !CHICAGO

// this structure is used to keep track of memory allocation
// for video buffers used in capture.  it is allocated when
// allocating a videohdr would be called for
//
typedef struct _cap_videohdr {
    VIDEOHDR vh;
    LPBYTE   pAlloc;      // address of allocated buffer
    DWORD    dwMemIdent;  // identity of allocation (used in Chicago)
    DWORD    dwReserved;  // used in chicago
    BOOL     bHwBuffer;   // TRUE if buffer is allocated using videoStreamAllocBuffer
} CAPVIDEOHDR, FAR *LPCAPVIDEOHDR;

// AVIVideoInit -  Allocates, and initialize buffers for video capture.
//                 This routine is also used by MCI capture.
//                 Returns: 0 on success, otherwise an error code.

UINT AVIVideoInit (LPCAPSTREAM lpcs)
{
    int            iMaxVideo;
    int            ii;
    LPCAPVIDEOHDR  pcvh;
    LPVOID         pbuf;
    DWORD          cbVideo;

    lpcs->iNumVideo = 0;
    lpcs->iNextVideo = 0;
    lpcs->dwVideoChunkCount = 0;
    lpcs->dwFramesDropped = 0;
    lpcs->fBuffersOnHardware = FALSE;

    // When performing MCI step capture, buffer array is not used
    if (lpcs->sCapParms.fStepMCIDevice)
        return 0;

    // If the user hasn't specified the number of video buffers to use,
    // assume the minimum

    if (lpcs->sCapParms.wNumVideoRequested == 0)
        lpcs->sCapParms.wNumVideoRequested = MIN_VIDEO_BUFFERS;

    cbVideo = ROUNDUPTOSECTORSIZE (lpcs->lpBitsInfo->bmiHeader.biSizeImage
                                   + sizeof(RIFF),
                                   lpcs->dwBytesPerSector)
              + lpcs->dwBytesPerSector;

    // use the number of video buffers that the user requested
    // or the maximum array size in CAPSTREAM
    //
    iMaxVideo = min (MAX_VIDEO_BUFFERS, lpcs->sCapParms.wNumVideoRequested);

    // Post VFW 1.1a, see if the driver can allocate memory
    //
   #ifdef ALLOW_HW_BUFFERS
    if (videoStreamAllocBuffer (lpcs->hVideoIn, (LPVOID *) &pbuf, cbVideo)
        == DV_ERR_OK)
    {
        lpcs->fBuffersOnHardware = TRUE;
        videoStreamFreeBuffer (lpcs->hVideoIn, pbuf);
    }
    else
   #endif
    {
        DWORDLONG dwFreeMem;
        DWORDLONG dwUserRequests;
        DWORDLONG dwAudioMem;

        lpcs->fBuffersOnHardware = FALSE;

        // How much actual free physical memory exists?
        dwFreeMem = GetFreePhysicalMemory();
        dwAudioMem = lpcs->dwWaveSize * lpcs->sCapParms.wNumAudioRequested;

        #define FOREVER_FREE 32768L   // Always keep this free for swap space

        // How much memory will be used if we allocate per the request?
        //
        dwUserRequests = dwAudioMem
                         + cbVideo * iMaxVideo
                         + FOREVER_FREE;

        // If request is greater than available memory, force fewer buffers
        //
        if (dwUserRequests > dwFreeMem)
        {
            if (dwFreeMem > dwAudioMem)
                dwFreeMem -= dwAudioMem;
            iMaxVideo = (int)(((dwFreeMem * 8) / 10) / cbVideo);
            iMaxVideo = min (MAX_VIDEO_BUFFERS, iMaxVideo);
            dprintf("iMaxVideo = %d\n", iMaxVideo);
        }
    }

    pcvh = GlobalAllocPtr (GMEM_MOVEABLE, iMaxVideo * sizeof(CAPVIDEOHDR));
    // note: pcvh is freed by referencing through alpVideoHdr[0]
    if ( ! pcvh)
        return IDS_CAP_VIDEO_ALLOC_ERROR;

    AuxDebugEx (3, DEBUGLINE "allocated video headers pcvh=%X\r\n", pcvh);

    // Set up the buffers presuming fixed size DIBs and Junk chunks
    // These will be modified later if the device provides compressed data

    for (ii = 0; ii < iMaxVideo; ++ii)
    {
        LPVIDEOHDR pvh = NULL;
        LPRIFF     priff;

       #ifdef ALLOW_HW_BUFFERS
        //
        // for the first buffer, always try to allocate on hardware,
        // if that fails, grab virtual memory for the buffer.
        // for all but the first buffer, we use whatever worked for
        // the first buffer, and if that fails.  we stop allocating buffers
        //
        if ((0 == ii) || lpcs->fBuffersOnHardware)
        {
            pbuf = NULL;
            mmr = videoStreamAllocBuffer (lpcs->hVideoIn, (LPVOID) &pbuf, cbVideo);
            if ((mmr != MMSYSERR_NOERROR) || (pbuf == NULL))
            {
                if (0 == ii)
                    break;

                lpcs->fBuffersOnHardware = FALSE;
                pbuf = AllocSectorAlignedMem (cbVideo, lpcs->dwBytesPerSector);
            }
            else
                lpcs->fBuffersOnHardware = TRUE;
        }
        else
            pbuf = AllocSectorAlignedMem (cbVideo, lpcs->dwBytesPerSector);

       #else ! dont allow hw buffers

        pbuf = AllocSectorAlignedMem (cbVideo, lpcs->dwBytesPerSector);

       #endif // ALLOW_HW_BUFFERS

        if (pbuf == NULL)
            break;

        // save the original allocation pointer to the buffer
        // in the extra fields of the capture header. also remember
        // whether we got the buffer from the driver or not
        //
        pcvh[ii].pAlloc = pbuf;
        pcvh[ii].bHwBuffer = lpcs->fBuffersOnHardware;
        lpcs->alpVideoHdr[ii] = pvh = &pcvh[ii].vh;
        priff = (LPVOID) ROUNDUPTOSECTORSIZE (pbuf, lpcs->dwBytesPerSector);

        // write the riff header for this frame
        //
        priff->dwType = MAKEAVICKID(cktypeDIBbits, 0);
        if (lpcs->lpBitsInfo->bmiHeader.biCompression == BI_RLE8)
            priff->dwType = MAKEAVICKID(cktypeDIBcompressed, 0);
        priff->dwSize = lpcs->lpBitsInfo->bmiHeader.biSizeImage;

        // fill in the video hdr for this frame
        //
        pvh->lpData          = (LPVOID)(priff + 1);
        pvh->dwBufferLength  = priff->dwSize;
        pvh->dwBytesUsed     = 0;
        pvh->dwTimeCaptured  = 0;
        pvh->dwUser          = 0;
        pvh->dwFlags         = 0;

        AuxDebugEx (4, DEBUGLINE "lpVideoHdr[%d]==%X\r\n", ii, lpcs->alpVideoHdr[ii]);
        AuxDebugDump (8, lpcs->alpVideoHdr[ii], sizeof(*pcvh));
    }
    lpcs->iNumVideo = ii;
    lpcs->cbVideoAllocation = cbVideo;

    // if we did not create even a single buffer, free the headers
    //
    if ( ! lpcs->iNumVideo)
        GlobalFreePtr (pcvh);

   #ifdef ALLOW_HW_BUFFERS
    if (lpcs->fBuffersOnHardware)
        dprintf("HARDWARE iNumVideo Allocated = %d \n", lpcs->iNumVideo);
    else
   #endif
        dprintf("HIGH iNumVideo Allocated = %d \n", lpcs->iNumVideo);

    return lpcs->iNumVideo ? 0 : IDS_CAP_VIDEO_ALLOC_ERROR;
}

void CALLBACK
VideoCallback(
    HVIDEO hvideo,
    UINT msg,
    DWORD dwInstance,
    DWORD lParam1,
    DWORD lParam2
)
{
    LPCAPSTREAM lpcs = (LPCAPSTREAM) dwInstance;

    if (lpcs && lpcs->hCaptureEvent) {
        SetEvent(lpcs->hCaptureEvent);
    } else {
	AuxDebugEx(1, DEBUGLINE "VideoCallback with NO instance data\r\n");
    }
}

//
// AVIVideoPrepare -  Prepares headers and adds buffers to the device
//                    This routine is also used by MCI capture.
//                    Returns: 0 on success, otherwise an error code.
UINT AVIVideoPrepare (LPCAPSTREAM lpcs)
{
    MMRESULT mmr;
    int      ii;

    // When performing MCI step capture, buffer array is not used
    //
    if (lpcs->sCapParms.fStepMCIDevice)
        return 0;

    // Open the video stream, setting the capture rate
    //
    mmr = videoStreamInit (lpcs->hVideoIn,
                           lpcs->sCapParms.dwRequestMicroSecPerFrame,
                           (DWORD) VideoCallback,
                           (DWORD) lpcs,
                           CALLBACK_FUNCTION);
    if (mmr) {
        dprintf("cannot open video device!  Error is %d\n", mmr);
        return IDS_CAP_VIDEO_OPEN_ERROR;
    }

    // Prepare (lock) the buffers, and give them to the device
    //
    for (ii = 0; ii < lpcs->iNumVideo; ++ii)
    {
        mmr = videoStreamPrepareHeader (lpcs->hVideoIn,
                                        lpcs->alpVideoHdr[ii],
                                        sizeof(VIDEOHDR));
        if (mmr)
        {
            lpcs->iNumVideo = ii;
            dprintf("**** could only prepare %d Video!\n", lpcs->iNumVideo);
            break;
        }

        mmr = videoStreamAddBuffer (lpcs->hVideoIn,
                                    lpcs->alpVideoHdr[ii],
                                    sizeof(VIDEOHDR));
        if (mmr)
             return IDS_CAP_VIDEO_ALLOC_ERROR;
	AuxDebugEx(3, DEBUGLINE "Added video buffer %d (%8x)\r\n", ii, lpcs->alpVideoHdr[ii]);
    }
    return 0;
}

#endif // not chicago

//
// AVI VideoUnPrepare - UnPrepares headers, frees memory, and
//                      resets the video in device.
//                      This routine is also used by MCI capture.
//                      Returns: 0 on success, otherwise an error code.

UINT AVIVideoUnPrepare (LPCAPSTREAM lpcs)
{
    // When performing MCI step capture, buffer array is not used
    //
    if (lpcs->sCapParms.fStepMCIDevice)
        return 0;

    // Reset the buffers so they can be freed
    //
    if (lpcs->hVideoIn) {
        videoStreamReset(lpcs->hVideoIn);

        // unprepare headers
        // Unlock and free headers and data

       #if defined CHICAGO
        vidxFreeHeaders (lpcs->hVideoIn);
        ZeroMemory (lpcs->alpVideoHdr, sizeof(lpcs->alpVideoHdr));
       #else
        {
            int ii;
            LPCAPVIDEOHDR pcvhAll = (LPVOID)lpcs->alpVideoHdr[0];

            for (ii = 0; ii < lpcs->iNumVideo; ++ii)
            {
                LPCAPVIDEOHDR pcvh = (LPVOID)lpcs->alpVideoHdr[ii];
                if (pcvh)
                {
                    if (pcvh->vh.dwFlags & VHDR_PREPARED)
                        videoStreamUnprepareHeader (lpcs->hVideoIn,
                                                    &pcvh->vh,
                                                    sizeof(VIDEOHDR));

                   #ifdef ALLOW_HW_BUFFERS
                    if (pcvh->bHwBuffer)
                    {
                        if (pcvh->pAlloc)
                            videoStreamFreeBuffer (lpcs->hVideoIn, (LPVOID)pcvh->pAlloc);
			}
                    else
                   #endif
                    {
                        if (pcvh->pAlloc)
                            FreeSectorAlignedMem (pcvh->pAlloc);
			}

                lpcs->alpVideoHdr[ii] = NULL;
                }
            }

            // free the array of video headers
            //
            if (pcvhAll)
                GlobalFreePtr (pcvhAll);
	    }
       #endif
        // Shut down the video stream
        videoStreamFini(lpcs->hVideoIn);
    }

    return 0;
}

/*
 *  AVI Fini    - undo the mess that AVIInit did.
 *
 */
void AVIFini(LPCAPSTREAM lpcs)
{
    AuxDebugEx (2, "AVIFini(%08x)\r\n", lpcs);

    if (lpcs->lpDropFrame) {
        FreeSectorAlignedMem (lpcs->lpDropFrame), lpcs->lpDropFrame = NULL;
    }

    AVIVideoUnPrepare (lpcs);           // Free the video device and buffers
    AVIAudioUnPrepare (lpcs);           // Free the audio device
    AVIAudioFini (lpcs);                // Free the audio buffers

    if (lpcs->hCaptureEvent) {
        CloseHandle (lpcs->hCaptureEvent), lpcs->hCaptureEvent = NULL;
    }

    AuxDebugEx (2, "AVIFini(...) exits\r\n");
}

//
// AVI Init
//     This routine does all the non-File initalization for AVICapture.
//     Returns: 0 on success, Error string value on failure.
//

UINT AVIInit (LPCAPSTREAM lpcs)
{
    UINT         wError = 0;    // Success
    LPBITMAPINFO lpBitsInfoOut;    // Possibly compressed output format

    // Allocate a DropFrame buffer
    if (lpcs->lpDropFrame == NULL) {
        assert (lpcs->dwBytesPerSector);
        lpcs->lpDropFrame = AllocSectorAlignedMem (lpcs->dwBytesPerSector, lpcs->dwBytesPerSector);
    }

    /* No special video format given -- use the default */
   #ifdef NEW_COMPMAN
    if (lpcs->CompVars.hic == NULL)
        lpBitsInfoOut = lpcs->lpBitsInfo;
    else
        lpBitsInfoOut = lpcs->CompVars.lpbiOut;
   #else
    lpBitsInfoOut = lpcs->lpBitsInfo;
   #endif

    // -------------------------------------------------------
    // figure out buffer sizes
    // -------------------------------------------------------

    // Init all pointers to NULL
    ZeroMemory (lpcs->alpVideoHdr, sizeof(lpcs->alpVideoHdr));
    ZeroMemory (lpcs->alpWaveHdr, sizeof(lpcs->alpWaveHdr));

    // -------------------------------------------------------
    //                    Init Sound
    // -------------------------------------------------------

    if (lpcs->sCapParms.fCaptureAudio) {
        if (wError = AVIAudioInit (lpcs)) {
            dprintf("can't init audio buffers!\n");
            goto AVIInitFailed;
        }
    }

    // -------------------------------------------------------
    //                    Init Video
    // -------------------------------------------------------

    if (wError = AVIVideoInit (lpcs)) {
        dprintf("AVIVideoInitFailed (no buffers alloc'd)!\n");
        goto AVIInitFailed;
    }

    // --------------------------------------------------------------
    //  Prepare audio buffers (lock em down) and give them to the device
    // --------------------------------------------------------------

    if (lpcs->sCapParms.fCaptureAudio) {
        if (wError = AVIAudioPrepare (lpcs)) {
            dprintf("can't prepare audio buffers!\n");
            goto AVIInitFailed;
        }
    }

    // --------------------------------------------------------------
    //  Prepare video buffers (lock em down) and give them to the device
    // --------------------------------------------------------------

    if (wError = AVIVideoPrepare (lpcs)) {
        dprintf("can't prepare video buffers!\n");
        goto AVIInitFailed;
    }

    // -------------------------------------------------------
    //   all done, return success
    // -------------------------------------------------------

    return (0);            // SUCCESS !

    // -------------------------------------------------------
    //   we got a error, return string ID of error message
    // -------------------------------------------------------
AVIInitFailed:
    AVIFini(lpcs);      // Shutdown everything
    return wError;
}

// Maintains info chunks which are written to the AVI header
//
BOOL FAR PASCAL SetInfoChunk(LPCAPSTREAM lpcs, LPCAPINFOCHUNK lpcic)
{
    DWORD       ckid   = lpcic->fccInfoID;
    LPVOID      lpData = lpcic->lpData;
    LONG        cbData = lpcic->cbData;
    LPBYTE      lp;
    LPBYTE      lpw;
    LPBYTE      lpEnd;
    LPBYTE      lpNext;
    LONG        cbSizeThis;
    BOOL        fOK = FALSE;

    // Delete all info chunks?
    if (ckid == 0) {
        if (lpcs->lpInfoChunks) {
            GlobalFreePtr (lpcs->lpInfoChunks);
            lpcs->lpInfoChunks = NULL;
            lpcs->cbInfoChunks = 0;
        }
        return TRUE;
    }

    // Try removing an entry if it already exists...
    // Also used if lpData is NULL to just remove an entry
    //
    lpw   = (LPBYTE)lpcs->lpInfoChunks;           // always points at fcc
    lpEnd = (LPBYTE)lpcs->lpInfoChunks + lpcs->cbInfoChunks;
    while (lpw < lpEnd) {
        cbSizeThis = ((DWORD UNALIGNED FAR *)lpw)[1];
        cbSizeThis += cbSizeThis & 1;           // force WORD (16 bit) alignment
        lpNext = lpw + cbSizeThis + sizeof (DWORD) * 2;
        if ((*(DWORD UNALIGNED FAR *) lpw) == ckid) {
            lpcs->cbInfoChunks -= cbSizeThis + sizeof (DWORD) * 2;
            if (lpNext <= lpEnd) {
                if (lpEnd - lpNext)
                    CopyMemory (lpw, lpNext, lpEnd - lpNext);
                if (lpcs->cbInfoChunks) {
                    lpcs->lpInfoChunks = (LPBYTE) GlobalReAllocPtr( // shrink it
                        lpcs->lpInfoChunks,
                        lpcs->cbInfoChunks,
                        GMEM_MOVEABLE);
                }
                else {
                    if (lpcs->lpInfoChunks)
                        GlobalFreePtr (lpcs->lpInfoChunks);
                    lpcs->lpInfoChunks = NULL;
                }
                fOK = TRUE;
            }
            break;
        }
        else
            lpw = lpNext;
    }

    if (lpData == NULL || cbData == 0)         // Only deleting, get out
        return fOK;

    // Add a new entry
    cbData += cbData & 1;               // force WORD (16 bit) alignment
    cbData += sizeof(RIFF);             // add sizeof RIFF
    if (lpcs->lpInfoChunks)
        lp = GlobalReAllocPtr(lpcs->lpInfoChunks, lpcs->cbInfoChunks + cbData, GMEM_MOVEABLE);
    else
        lp = GlobalAllocPtr(GMEM_MOVEABLE, cbData);

    if (!lp)
        return FALSE;

    // build RIFF chunk in block
    //
    ((LPRIFF)(lp + lpcs->cbInfoChunks))->dwType = ckid;
    ((LPRIFF)(lp + lpcs->cbInfoChunks))->dwSize = lpcic->cbData;

    CopyMemory (lp + lpcs->cbInfoChunks + sizeof(RIFF),
                lpData,
                cbData - sizeof(RIFF));
    lpcs->lpInfoChunks = lp;
    lpcs->cbInfoChunks += cbData;

    return TRUE;
}

/*+ ProcessNextVideoBuffer
 *
 *-===============================================================*/

STATICFN BOOL _inline ProcessNextVideoBuffer (
    LPCAPSTREAM  lpcs,
    BOOL         fStopping,
    LPUINT       lpuError,
    LPVIDEOHDR * plpvhDraw,
    LPBOOL       lpbPending)
{
    LPVIDEOHDR lpvh;

    *lpuError = 0;
    *plpvhDraw = NULL;
    *lpbPending = FALSE;

    lpvh = lpcs->alpVideoHdr[lpcs->iNextVideo];
    if (!(lpvh->dwFlags & VHDR_DONE)) {
        return fStopping;
    }

   #if defined CHICAGO
    {
    LPTHKVIDEOHDR lptvh = (LPVOID)lpvh;

    #ifdef JMK_HACK_CHECKHDR
     if (IsBadWritePtr (lptvh, sizeof(*lptvh)) ||
        HIWORD(lptvh->vh.lpData) != HIWORD(lptvh->p16Alloc))
        {
        OutputDebugStringA(DEBUGLINE "trouble with video hdr\r\n");

        AuxDebugEx (0, DEBUGLINE "iNext=%d, ptvh=%X\r\n", lpcs->iNextVideo, lptvh);
        AuxDebugDump (0, lptvh, sizeof(*lptvh));
        AuxDebugEx (0, DEBUGLINE "alpVideoHdrs=%X\r\n", lpcs->alpVideoHdr);
        AuxDebugDump (0, lpcs->alpVideoHdr, sizeof(lpcs->alpVideoHdr[0]) * 8);

        INLINE_BREAK;

        return TRUE;
        }
    #endif

    // Swap the linear pointer back (was swapped in vidxAddBuffer)
    //
    lptvh->vh.lpData = (LPVOID)(ROUNDUPTOSECTORSIZE(lptvh->p32Buff, lpcs->dwBytesPerSector) + sizeof(RIFF));
    }
   #endif

    if (lpvh->dwBytesUsed)
    {
        DWORD  dwTime;
        DWORD  dwBytesUsed = lpvh->dwBytesUsed;
        BOOL   fKeyFrame = lpvh->dwFlags & VHDR_KEYFRAME;
        LPVOID lpData = lpvh->lpData;

        // get expected time for this frame in milliseconds
        //
        dwTime = MulDiv (lpcs->dwVideoChunkCount + 1,
                         lpcs->sCapParms.dwRequestMicroSecPerFrame,
                         1000);

       #ifdef NEW_COMPMAN
        //
        // We are automatically compressing during capture, so
        // compress the frame before we pass it on to be written
        //
        if (lpcs->CompVars.hic)
        {
            LPRIFF priff;

            dwBytesUsed = 0;
            lpData = ICSeqCompressFrame(&lpcs->CompVars, 0,
                                        lpvh->lpData,
                                        &fKeyFrame,
                                        &dwBytesUsed);

            priff = ((LPRIFF)lpData) -1;
            priff->dwType = MAKEAVICKID(cktypeDIBbits, 0);
            priff->dwSize = dwBytesUsed;
        }
       #endif // NEW_COMPMAN

        // do video stream callback for this frame
        //
        if (lpcs->CallbackOnVideoStream)
            lpcs->CallbackOnVideoStream (lpcs->hwnd, lpvh);
        lpvh->dwFlags &= ~VHDR_DONE;

        // if we are not capturing to disk, just increment
        // the 'chunk count' (i.e. frame count?) and go on
        // otherwise we want to queue the frame up to write
        // here
        //
        if ( ! (lpcs->fCaptureFlags & CAP_fCapturingToDisk))
        {
            // Warning: Kludge to create frame chunk count when net capture
            // follows.
            ++lpcs->dwVideoChunkCount;
        }
        else
        {
            int nAppendDummyFrames = 0;

            // if the expected time for this frame is less than the
            // timestamp for the frame.  we may have dropped some frames
            // before this frame.
            //
            if (lpcs->dwVideoChunkCount && (dwTime < lpvh->dwTimeCaptured))
            {
                int  nDropCount;
                BOOL bPending;

                // calculate how many frames have been dropped.
                // NOTE: this number may be zero if dwTimeCaptured is just
                // a little bit late.
                //
                nDropCount = MulDiv(lpvh->dwTimeCaptured - dwTime,
                                    1000,
                                    lpcs->sCapParms.dwRequestMicroSecPerFrame);

               #ifdef JMK_HACK_TIMERS
                if (pTimerRiff)
                    pTimerRiff->vchd.dwDropFramesNotAppended += nDropCount;
               #endif

                // If any frames have been dropped, write them out before
                // we get back to writing the current frame.
                //
                if (nDropCount > 0)
                {
                    lpcs->dwFramesDropped += nDropCount;
                    if (! AVIWriteDummyFrames (lpcs, nDropCount, lpuError, &bPending))
                        fStopping = TRUE;
                }
            }

           #ifdef JMK_HACK_TIMERS
	    if (pTimerRiff) {
	        if (nTimerIndex == CLIPBOARDLOGSIZE)
		    nTimerIndex = 0;
	
// nTimerIndex will be OK	if ((nTimerIndex < CLIPBOARDLOGSIZE) && pTimerStuff)
		if (pTimerStuff)
		{
	
		    pCurTimerStuff = &pTimerStuff[nTimerIndex];
                    ++nTimerIndex;

		    pCurTimerStuff->nFramesAppended = 0;
		    pCurTimerStuff->nDummyFrames  = (WORD)lpcs->dwFramesDropped;
		    pCurTimerStuff->dwFrameTickTime = dwTime;
		    pCurTimerStuff->dwFrameStampTime = lpvh->dwTimeCaptured;
		    pCurTimerStuff->dwVideoChunkCount = lpcs->dwVideoChunkCount;
                    pCurTimerStuff->dwTimeWritten = pcDeltaTicks(&pctWriteBase);
		    pCurTimerStuff->dwTimeToWrite = 0;
		    pCurTimerStuff->nVideoIndex = lpcs->iNextVideo;
		    pCurTimerStuff->nAudioIndex = lpcs->iNextWave;
		}
	    } // fClipboardLogging
           #endif // JMK_HACK_TIMERS

           // look ahead for dummy frames and try to
           // append them to the current frame
           //
           nAppendDummyFrames = 0;

           #define LOOKAHEAD_FOR_DUMMYS 1
           #ifdef LOOKAHEAD_FOR_DUMMYS
           {
            int        iNext;
            LPVIDEOHDR lpvhNext;
            iNext = lpcs->iNextVideo+1;
            if (iNext >= lpcs->iNumVideo)
                iNext = 0;

            // is the next frame done already?  if so
            // we can append any dropped frames to the end of
            // this frame before we write it out
            //
            lpvhNext = lpcs->alpVideoHdr[iNext];
            if (lpvhNext->dwFlags & VHDR_DONE)
            {
		// Recalculate the current time, which may have
		// changed if dummy frames were inserted above
		dwTime = MulDiv (lpcs->dwVideoChunkCount + 1,
                         lpcs->sCapParms.dwRequestMicroSecPerFrame,
                         1000);
	
                nAppendDummyFrames =
                    MulDiv (lpvhNext->dwTimeCaptured - dwTime,
                            1000,
                            lpcs->sCapParms.dwRequestMicroSecPerFrame);

                if ((--nAppendDummyFrames) < 0)
                    nAppendDummyFrames = 0;
		else {
		    AuxDebugEx(3, DEBUGLINE "Appending %d dummy frames", nAppendDummyFrames);
		}

                lpcs->dwFramesDropped += nAppendDummyFrames;

               #ifdef JMK_HACK_TIMERS
                if (pTimerRiff) {
                    pTimerRiff->vchd.dwDropFramesAppended += nAppendDummyFrames;
		    pCurTimerStuff->nFramesAppended = nAppendDummyFrames;
		}
               #endif
            }
           }
           #endif

            if ( ! AVIWriteVideoFrame (lpcs,
                                       lpData,
                                       dwBytesUsed,
                                       fKeyFrame,
                                       lpcs->iNextVideo,
                                       nAppendDummyFrames,
                                       lpuError, lpbPending))
                fStopping = TRUE;

           #ifdef JMK_HACK_TIMERS
            if (pCurTimerStuff)
            {
                pCurTimerStuff->dwTimeToWrite = pcDeltaTicks(&pctWriteBase);
                pCurTimerStuff->bPending = *lpbPending;
            }
           #endif
        }

    }

    // return lpvh to the caller so that the frame can be
    // drawn (time permitting)
    //
    *plpvhDraw = lpvh;

    // increment the next Video buffer pointer
    //
    if (++lpcs->iNextVideo >= lpcs->iNumVideo)
        lpcs->iNextVideo = 0;

    return fStopping;
}

/*+ ProcessAudioBuffers
 *
 *-===============================================================*/

STATICFN BOOL _inline ProcessAudioBuffers (
    LPCAPSTREAM lpcs,
    BOOL        fStopping,
    LPUINT      lpuError)
{
    int       iLastWave;
    UINT      ii;
    LPWAVEHDR lpwh;

    *lpuError = 0;
    assert (lpcs->sCapParms.fCaptureAudio);

    // if all buffers are done, we have broke audio.
    //
    iLastWave = lpcs->iNextWave == 0 ? lpcs->iNumAudio -1 : lpcs->iNextWave-1;
    if (!fStopping && lpcs->alpWaveHdr[iLastWave]->dwFlags & WHDR_DONE)
        lpcs->fAudioBreak = TRUE;

    // process all done buffers, but no more than iNumAudio at one
    // pass (to avoid getting stuck here forever)
    //
    for (ii = 0; ii < (UINT)lpcs->iNumAudio; ++ii)
    {
        BOOL bPending;

        // if the next buffer is not done, break out of the loop
        // and return to the caller
        //
        lpwh = lpcs->alpWaveHdr[lpcs->iNextWave];
        if (!(lpwh->dwFlags & WHDR_DONE))
            break;
        lpwh->dwFlags &= ~WHDR_DONE;

        // is there any data in the buffer ?
        // if so, do wave stream callback, then write the
        // buffer
        //
        bPending = FALSE;
        if (lpwh->dwBytesRecorded)
        {
            if (lpcs->CallbackOnWaveStream)
               lpcs->CallbackOnWaveStream (lpcs->hwnd, lpwh);

            if ( ! (lpcs->fCaptureFlags & CAP_fCapturingToDisk))
            {
                lpcs->dwWaveChunkCount++;
                lpcs->dwWaveBytes += lpwh->dwBytesRecorded;
            }
            else
            {
                // write the audio buffer, bPending will be true
                // if the write will complete asynchronously
                //
                if ( ! AVIWriteAudio (lpcs, lpwh, lpcs->iNextWave,
                                      lpuError, &bPending))
                    fStopping = TRUE;
            }
        }

        // if we are not writing async, we can put the buffer
        // back on the wave driver's queue now
        //
        if ( ! bPending)
        {
            lpwh->dwBytesRecorded = 0;
	    AuxDebugEx(3, DEBUGLINE "Calling waveInAddBuffer for address %8x", lpwh);
            if (waveInAddBuffer(lpcs->hWaveIn, lpwh, sizeof(WAVEHDR)))
            {
                fStopping = TRUE;
                *lpuError = IDS_CAP_WAVE_ADD_ERROR;
            }
        }

        // increment the next wave buffer pointer
        //
        if (++lpcs->iNextWave >= lpcs->iNumAudio)
            lpcs->iNextWave = 0;
    }

    return fStopping;
}

/*+ ProcessAsyncIOBuffers
 *
 *-===============================================================*/

STATICFN BOOL _inline ProcessAsyncIOBuffers (
    LPCAPSTREAM lpcs,
    BOOL        fStopping,
    LPUINT      lpuError)
{
    UINT      ii;
    struct _avi_async * lpah;

    // if there are no async buffer headers, there is nothing to do!
    //
    *lpuError = 0;
    assert (lpcs->pAsync);

    // process all done buffers, but no more than iNumAsync
    //
    for (ii = 0; ii < lpcs->iNumAsync; ++ii)
    {
        DWORD dwUsed;

        // if this async header has never been used,
        // we are done
        //
        lpah = &lpcs->pAsync[lpcs->iNextAsync];
        assert (lpah->uType);

        AuxDebugEx (2, DEBUGLINE "processing async io buffer %d off=%x\r\n",
                    lpcs->iNextAsync, lpah->ovl.Offset);

        // if the next buffer is not done, or failed break
        // out of the loop
        //
        if ( ! GetOverlappedResult (lpcs->hFile, &lpah->ovl, &dwUsed, FALSE))
        {
            if (GetLastError() != ERROR_IO_INCOMPLETE)
            {
                *lpuError = IDS_CAP_FILE_WRITE_ERROR;
                fStopping = TRUE;
            }
            break;
        }
	//#pragma message (SQUAWK "get rid of this hack when GetOverlappedResult is fixed!")	
	if (lpah->ovl.Internal != 0) {
	    // if internal is non-zero io is still pending
	    // NOTE: this needs to be changed as soon as possible.
	    //	The current state of play means that GetOverlappedResult CAN return
	    //	something other than ERROR_IO_COMPLETE and the IO will still be
	    //	pending.  This causes us to make the wrong decision.
	    break;
	}

        // the buffer is done, so now we need to queue the wave/video
        // buffer back to the wave/video driver
        //

        switch (lpah->uType)
        {
            case ASYNC_BUF_VIDEO:
            {
                LPVIDEOHDR lpvh = lpcs->alpVideoHdr[lpah->uIndex];
               #if defined CHICAGO
                if (vidxAddBuffer(lpcs->hVideoIn, lpvh, sizeof (VIDEOHDR)))
               #else
		AuxDebugEx(3, DEBUGLINE "Queueing video buffer lpvh=%x (index %d)\r\n", lpvh, lpah->uIndex);
                if (videoStreamAddBuffer(lpcs->hVideoIn, lpvh, sizeof (VIDEOHDR)))
               #endif
                {
                    fStopping = TRUE;
                    *lpuError = IDS_CAP_VIDEO_ADD_ERROR;
                }
            }
            break;

            case ASYNC_BUF_AUDIO:
            {
                LPWAVEHDR lpwh = lpcs->alpWaveHdr[lpah->uIndex];
                lpwh->dwBytesRecorded = 0;
		AuxDebugEx(3, DEBUGLINE "Queueing audio buffer lpwh=%x (index %d)\r\n", lpwh, lpah->uIndex);
                if (waveInAddBuffer (lpcs->hWaveIn, lpwh, sizeof(WAVEHDR)))
                {
                    fStopping = TRUE;
                    *lpuError = IDS_CAP_WAVE_ADD_ERROR;
                }
            }
            break;

            //case ASYNC_BUF_DROP:
            //{
            //}
            //break;
        }

        lpah->uType = 0;
        lpah->uIndex = 0;

        // increment to the next async io buffer
        //
        if (++lpcs->iNextAsync >= lpcs->iNumAsync)
            lpcs->iNextAsync = 0;
    }

    return fStopping;
}

/*+ ShowCompletionStatus
 *
 *-===============================================================*/

STATICFN void ShowCompletionStatus (
    LPCAPSTREAM lpcs,
    BOOL        fCapturedOK)
{
    // Notify if there was an error while recording
    //
    if ( ! fCapturedOK)
        errorUpdateError (lpcs, IDS_CAP_RECORDING_ERROR);

    // put up completion message on status line
    //
    if (lpcs->fCaptureFlags & CAP_fCapturingToDisk)
    {
        DWORD dw;

        // The muldiv32 doesn't give 0 if numerator is zero
        dw = 0;
        if (lpcs->dwVideoChunkCount)
            dw = muldiv32(lpcs->dwVideoChunkCount,1000000,lpcs->dwTimeElapsedMS);

        if (lpcs->sCapParms.fCaptureAudio)
        {
            // "Captured %d.%03d sec.  %ld frames (%ld dropped) (%d.%03d fps).  %ld audio bytes (%d.%03d sps)"
            statusUpdateStatus(lpcs, IDS_CAP_STAT_VIDEOAUDIO,
                  (UINT)(lpcs->dwTimeElapsedMS/1000),
                  (UINT)(lpcs->dwTimeElapsedMS%1000),
                  lpcs->dwVideoChunkCount,
                  lpcs->dwFramesDropped,
                  (UINT)(dw / 1000),
                  (UINT)(dw % 1000),
                  lpcs->dwWaveBytes,
                  (UINT) lpcs->lpWaveFormat->nSamplesPerSec / 1000,
                  (UINT) lpcs->lpWaveFormat->nSamplesPerSec % 1000);
        }
        else
        {
            // "Captured %d.%03d sec.  %ld frames (%ld dropped) (%d.%03d fps)."
            statusUpdateStatus(lpcs, IDS_CAP_STAT_VIDEOONLY,
                  (UINT)(lpcs->dwTimeElapsedMS/1000),
                  (UINT)(lpcs->dwTimeElapsedMS%1000),
                  lpcs->dwVideoChunkCount,
                  lpcs->dwFramesDropped,
                  (UINT)(dw / 1000),
                  (UINT)(dw % 1000));
        }
    } // endif capturing to disk (no warnings or errors if to net)

    // if capture was successful, warn the user about various abnormal
    // conditions.
    //
    if (fCapturedOK)
    {
        if (lpcs->dwVideoChunkCount == 0)
        {
            // No frames captured, warn user that interrupts are probably not enabled.
            errorUpdateError (lpcs, IDS_CAP_NO_FRAME_CAP_ERROR);
        }
        else if (lpcs->sCapParms.fCaptureAudio && lpcs->dwWaveBytes == 0)
        {
            // No audio captured, warn user audio card is hosed
            errorUpdateError (lpcs, IDS_CAP_NO_AUDIO_CAP_ERROR);
        }
        else if (lpcs->sCapParms.fCaptureAudio && lpcs->fAudioBreak)
        {
            // some of the audio was dropped
            if(lpcs->CompVars.hic) {
		errorUpdateError (lpcs, IDS_CAP_AUDIO_DROP_COMPERROR);
	    } else {
		errorUpdateError (lpcs, IDS_CAP_AUDIO_DROP_ERROR);
	    }
        }
        else if (lpcs->fCaptureFlags & CAP_fCapturingToDisk)
        {
            DWORD dwPctDropped;

            assert (lpcs->dwVideoChunkCount);
            dwPctDropped = 100 * lpcs->dwFramesDropped / lpcs->dwVideoChunkCount;
            //
            // dropped > 10% (default) of the frames
            //
            if (dwPctDropped > lpcs->sCapParms.wPercentDropForError)
                errorUpdateError (lpcs, IDS_CAP_STAT_FRAMESDROPPED,
                      lpcs->dwFramesDropped,
                      lpcs->dwVideoChunkCount,
                      (UINT)(muldiv32(lpcs->dwFramesDropped,10000,lpcs->dwVideoChunkCount)/100),
                      (UINT)(muldiv32(lpcs->dwFramesDropped,10000,lpcs->dwVideoChunkCount)%100)/10
                      );
        }
    }
}

/*
 *  AVI Capture
 *      This is the main streaming capture loop for both audio and
 * video.  It will first init all buffers and drivers and then go into a
 * loop checking for buffers to be filled.  When a buffer is filled then
 * the data for it is written out.
 * Afterwards it cleans up after itself (frees buffers etc...)
 * Returns: 0 on success, else error code
 */
void FAR PASCAL _LOADDS AVICapture1(LPCAPSTREAM lpcs)
{
    BOOL        fCapturedOK = TRUE;
    BOOL        fStopping;         // True when finishing capture
    BOOL        fStopped;          // True if driver notified to stop
    TCHAR       ach[128];
    TCHAR       achMsg[128];
    UINT        wError;         // Error String ID
    LPVIDEOHDR  lpVidHdr;
    LPWAVEHDR   lpWaveHdr;
    DWORD       dwTimeStarted;  // When did we start in milliseconds
    DWORD       dwTimeStopped;
    DWORD       dwTimeToStop;   // Lesser of MCI capture time or frame limit
    BOOL        fTryToPaint = FALSE;
    BOOL        fTryToPaintAgain = FALSE;
    HDC         hdc;
    HPALETTE    hpalT;
    HCURSOR     hOldCursor;
    RECT        rcDrawRect;
    CAPINFOCHUNK cic;
    DWORD       dwOldPrio;
    BOOL        bVideoWritePending;
    LPVIDEOHDR  lpvhDraw;

    lpcs->fCaptureFlags |= CAP_fCapturingNow;
    lpcs->dwReturn = DV_ERR_OK;

    hOldCursor = SetCursor(lpcs->hWaitCursor);

    statusUpdateStatus(lpcs, IDS_CAP_BEGIN);  // Always the first message

    // If not 1 Meg. free, give it up!!!
    if (GetFreePhysicalMemory () < (1024L * 1024L)) {
        errorUpdateError (lpcs, IDS_CAP_OUTOFMEM);
        goto EarlyExit;
    }

    statusUpdateStatus(lpcs, IDS_CAP_STAT_CAP_INIT);

    // Try painting the DIB only if Live window
    fTryToPaintAgain = fTryToPaint = lpcs->fLiveWindow;

    if (fTryToPaint) {
        hdc = GetDC(lpcs->hwnd);
        SetWindowOrgEx(hdc, lpcs->ptScroll.x, lpcs->ptScroll.y, NULL);
        hpalT = DrawDibGetPalette (lpcs->hdd);
        if (hpalT)
            hpalT = SelectPalette( hdc, hpalT, FALSE);
        RealizePalette(hdc);
        if (lpcs->fScale)
            GetClientRect (lpcs->hwnd, &rcDrawRect);
        else
            SetRect (&rcDrawRect, 0, 0, lpcs->dxBits, lpcs->dyBits);
    }

    // -------------------------------------------------------
    //   When should capture stop?
    // -------------------------------------------------------

    // If using MCI, capture for the shorter of the MCI period,
    // or the capture limit

    if (lpcs->sCapParms.fLimitEnabled)
        dwTimeToStop = (DWORD) ((DWORD) 1000 * lpcs->sCapParms.wTimeLimit);
    else
        dwTimeToStop = (DWORD) -1L; // very large

    if (lpcs->sCapParms.fMCIControl) {
        DWORD dwTime;

        // if MCI stop time not given, use lpcs->sCapParms.wTimeLimit
        if (lpcs->sCapParms.dwMCIStopTime == lpcs->sCapParms.dwMCIStartTime)
                    lpcs->sCapParms.dwMCIStopTime = lpcs->sCapParms.dwMCIStartTime +
                    (DWORD) ((DWORD)1000 * lpcs->sCapParms.wTimeLimit);

        dwTime = lpcs->sCapParms.dwMCIStopTime - lpcs->sCapParms.dwMCIStartTime;

        if (lpcs->sCapParms.fLimitEnabled)
            dwTimeToStop = min (dwTime, dwTimeToStop);
        else
            dwTimeToStop = dwTime;
    }

    //
    // never ever try to capture more than the index size!
    //
    if (lpcs->fCaptureFlags & CAP_fCapturingToDisk)
    {
        DWORD dwTime = MulDiv (lpcs->sCapParms.dwIndexSize,
                               lpcs->sCapParms.dwRequestMicroSecPerFrame,
                               1000l);

        dwTimeToStop = min (dwTime, dwTimeToStop);
    }

    // if doing MCI capture, initialize MCI device.  if init fails
    // go straight to the exit code
    //
    if (lpcs->sCapParms.fMCIControl)
    {
        if ( ! MCIDeviceOpen (lpcs) ||
             ! MCIDeviceSetPosition (lpcs, lpcs->sCapParms.dwMCIStartTime))
        {
            fCapturedOK = FALSE;
            errorUpdateError (lpcs, IDS_CAP_MCI_CONTROL_ERROR);
            statusUpdateStatus(lpcs, 0);    // Clear status
            goto EarlyExit;
        }
    }

    //
    // If we're compressing while capturing, warm up the compressor
    //
   #ifdef NEW_COMPMAN
    if (lpcs->CompVars.hic)
    {
        if ( ! ICSeqCompressFrameStart (&lpcs->CompVars, lpcs->lpBitsInfo))
        {
            // !!! We're in trouble here!
            dprintf("ICSeqCompressFrameStart failed !!!\n");
            errorUpdateError (lpcs, IDS_CAP_COMPRESSOR_ERROR);
            goto EarlyExit;
        }

        // Kludge, offset the lpBitsOut ptr
        // Compman allocates the compress buffer too large by
        // 2048 + 16 so we will still have room
        //
        ((LPBYTE)lpcs->CompVars.lpBitsOut) += 8;

        assert(lpcs->CompVars.lpbiOut != NULL);
    }
   #endif

    // -------------------------------------------------------
    //  Open the output file
    // -------------------------------------------------------

    if (lpcs->fCaptureFlags & CAP_fCapturingToDisk) {
	if (!CapFileInit(lpcs))
	{
	    errorUpdateError (lpcs, IDS_CAP_FILE_OPEN_ERROR);
	    goto EarlyExit;
	}
    } else {
        AuxDebugEx (3, DEBUGLINE "Setting dwBytesPerSector to %d\r\n",DEFAULT_BYTESPERSECTOR);
        lpcs->dwBytesPerSector=DEFAULT_BYTESPERSECTOR;
    }

   #ifdef JMK_HACK_TIMERS
    // Allocate memory for logging capture results to the clipboard if requested
    if (GetProfileIntA ("Avicap32", "ClipboardLogging", FALSE))
    {
        AuxDebugEx (2, DEBUGLINE "ClipboardLogging Enabled\r\n");
        InitPerformanceCounters();
        pcBegin(), pctWriteBase = pc.base;

	hMemTimers = GlobalAlloc(GHND | GMEM_ZEROINIT,
                             sizeof(struct _timerriff) +
                             sizeof(struct _timerstuff) * CLIPBOARDLOGSIZE);

	if (hMemTimers && (pTimerRiff = GlobalLock (hMemTimers)))
	    ;
	else if (hMemTimers)
	{
	    GlobalFree(hMemTimers);
	    pTimerRiff = 0;
	    pTimerStuff = 0;
	    hMemTimers = 0;
	}
	nTimerIndex = 0;
	nSleepCount = 0;
    }  // if ClipboardLogging
   #endif  // JMK_HACK_TIMERS

    // Make sure the parent has been repainted
    //
    UpdateWindow(lpcs->hwnd);

    //
    // call AVIInit() to get all the capture memory we will need
    //

    wError = IDS_CAP_AVI_INIT_ERROR;
    lpcs->hCaptureEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (lpcs->hCaptureEvent)
    {
       #ifdef CHICAGO
        lpcs->hRing0CapEvt = OpenVxDHandle (lpcs->hCaptureEvent);
        if ( ! lpcs->hRing0CapEvt)
            CloseHandle (lpcs->hCaptureEvent), lpcs->hCaptureEvent = NULL;
        else
       #endif
            wError = AVIInit(lpcs);

    }

    // if avifile init failed, cleanup and return error.
    //
    if (wError)
    {
        // Error in initalization - return
        //
        errorUpdateError (lpcs, wError);
        AVIFini(lpcs);
        AVIFileFini(lpcs, TRUE, TRUE);
        statusUpdateStatus(lpcs, 0);    // Clear status
        goto EarlyExit;
    }

    // Click OK to capture string (must follow AVIInit)
    //
    LoadString(lpcs->hInst, IDS_CAP_SEQ_MSGSTART, ach, NUMELMS(ach));
    wsprintf(achMsg, ach, (LPBYTE)lpcs->achFile);

    // clear status
    //
    statusUpdateStatus(lpcs, 0);

    // -------------------------------------------------------
    //   Ready to go, make the user click OK?
    // -------------------------------------------------------

    if (lpcs->sCapParms.fMakeUserHitOKToCapture && (lpcs->fCaptureFlags & CAP_fCapturingToDisk))
    {
        UINT idBtn;

        idBtn = MessageBox (lpcs->hwnd, achMsg, TEXT(""),
                            MB_OKCANCEL | MB_ICONEXCLAMATION);

        if (idBtn == IDCANCEL)
        {
            AVIFini(lpcs);
            AVIFileFini (lpcs, TRUE, TRUE);
            statusUpdateStatus (lpcs, 0);
            goto EarlyExit;
        }
    }

    // update the status, so the user knows how to stop
    //
    statusUpdateStatus(lpcs, IDS_CAP_SEQ_MSGSTOP);
    UpdateWindow(lpcs->hwnd);

    lpcs->fCaptureFlags |= CAP_fCapturingNow;

    // query async key states to 'reset' them to current values
    //
    GetAsyncKeyState(lpcs->sCapParms.vKeyAbort);
    GetAsyncKeyState(VK_ESCAPE);
    GetAsyncKeyState(VK_LBUTTON);
    GetAsyncKeyState(VK_RBUTTON);

    // Insert the digitization time
    // strings written to the file should be ascii, since this is
    // an ascii file format.
    //
    //
    // no point in pulling in the whole C runtime just to get a silly
    // timestamp, so we just cook the system time into ascii right here.
    //
    {
    SYSTEMTIME time;
    static char szDay[] = "Sun\0Mon\0Tue\0Wed\0Thu\0Fri\0Sat\0";
    static char szMonth[] = "Jan\0Feb\0Mar\0Apr\0May\0Jun\0Jul\0Aug\0Sep\0Oct\0Nov\0Dec\0";
    char sz[30];

    GetLocalTime (&time);

    //example: Fri Apr 29 12:25:12 1994
    wsprintfA(sz, "%s %s %2d %2d:%02d:%02d %4d",
              szDay + time.wDayOfWeek * 4,
              szMonth + time.wMonth * 4,
              time.wDay, time.wHour, time.wMinute, time.wSecond, time.wYear);

    cic.fccInfoID = mmioFOURCC ('I','D','I','T');
    cic.lpData = sz;
    cic.cbData  = 26;
    SetInfoChunk (lpcs, &cic);
    }

    // -------------------------------------------------------
    //   Start MCI, Audio, and video streams
    // -------------------------------------------------------

    // Callback will preroll, then return on frame accurate postion
    // The 1 indicates recording is about to start
    // Callback can return FALSE to exit without capturing
    //
    if (lpcs->CallbackOnControl &&
        !lpcs->CallbackOnControl(lpcs->hwnd, CONTROLCALLBACK_PREROLL))
    {
        AVIFini(lpcs);
        AVIFileFini(lpcs, TRUE, TRUE);
        statusUpdateStatus(lpcs, 0);
        goto EarlyExit;
    }

    dwOldPrio = GetThreadPriority(GetCurrentThread());
    if (dwOldPrio != THREAD_PRIORITY_HIGHEST)
        SetThreadPriority (GetCurrentThread(), THREAD_PRIORITY_HIGHEST);

   #ifdef JMK_HACK_TIMERS
    if (pTimerRiff)
    {
	UINT ii;

        pTimerRiff->fccRIFF = RIFFTYPE('RIFF'); //MAKEFOURCC('R','I','F','F');
	pTimerRiff->cbTotal = sizeof(struct _timerriff) - 8 +
	    		  sizeof(struct _timerstuff) * CLIPBOARDLOGSIZE;
        pTimerRiff->fccJMKD = RIFFTYPE('JMKD'); //MAKEFOURCC('J','M','K','D');
        pTimerRiff->fccVCHD = RIFFTYPE('VCHD'); //MAKEFOURCC('V','C','H','D');
	
	pTimerRiff->cbVCHD  = sizeof(struct _vchd);
	pTimerRiff->vchd.nPrio = GetThreadPriority(GetCurrentThread());
	pTimerRiff->vchd.bmih = lpcs->lpBitsInfo->bmiHeader;
	pTimerRiff->vchd.cap  = lpcs->sCapParms;
	pTimerRiff->vchd.dwDropFramesAppended = 0;
	pTimerRiff->vchd.dwDropFramesNotAppended = 0;
        pTimerRiff->vchd.dwTimerFrequency = pcGetTickRate();
	
	for (ii = 0; ii < NUMELMS(pTimerRiff->vchd.atvh); ++ii)
	{
	    if (lpcs->alpVideoHdr[ii])
            {
	        struct _thkvideohdr * ptvh = (LPVOID)lpcs->alpVideoHdr[ii];
               #ifndef CHICAGO
                assert (sizeof(CAPVIDEOHDR) == sizeof(*ptvh));
               #endif
                pTimerRiff->vchd.atvh[ii] = *ptvh;
                pTimerRiff->vchd.nMaxVideoBuffers = ii;
            }
        }
	
        pTimerRiff->fccChunk = RIFFTYPE('VCAP'); //MAKEFOURCC('V','C','A','P');
	pTimerRiff->cbChunk = pTimerRiff->cbTotal - sizeof(*pTimerRiff);
	
	pTimerStuff = (LPVOID)(pTimerRiff + 1);
	pCurTimerStuff = &pTimerStuff[0];
    }  // fClipboardLogging
   #endif  // JMK_HACK_TIMERS

    // make sure that the fat is loaded before we begin capturing
    //
    AVIPreloadFat (lpcs);

    // start the MCI device
    //
    if (lpcs->sCapParms.fMCIControl)
        MCIDevicePlay (lpcs);

    dwTimeStarted = timeGetTime();

    // start audio & video streams
    //
    if (lpcs->sCapParms.fCaptureAudio)
        waveInStart(lpcs->hWaveIn);
    videoStreamStart(lpcs->hVideoIn);

    // -------------------------------------------------------
    //   MAIN CAPTURE LOOP
    // -------------------------------------------------------

    fCapturedOK=TRUE;
    fStopping = FALSE;    // TRUE when we need to stop
    fStopped = FALSE;     // TRUE if drivers notified we have stopped
    lpcs->dwTimeElapsedMS = 0;

    assert (lpcs->iNextVideo == 0);
    if (lpcs->sCapParms.fCaptureAudio) {
	assert (lpcs->iNextWave == 0);
	lpWaveHdr = lpcs->alpWaveHdr[lpcs->iNextWave];
	// lpWaveHdr is only interesting when we capture audio
    }

    lpVidHdr = lpcs->alpVideoHdr[lpcs->iNextVideo];

    DPF("Start of main capture loop");

    for (;;)
    {

        // The INTEL driver uses the GetError message to
        // process buffers, so call it often...
        // FIX JAYBO        videoStreamGetError (lpcs->hVideoIn, &dwStreamError, &dwDriverDropCount);


        // if there are no buffers to process, we either wait
        // or leave the loop forever (depending on whether we expect
        // more buffers to be done in the future)
        //
        if (!(lpVidHdr->dwFlags & VHDR_DONE) &&
            !(lpcs->sCapParms.fCaptureAudio
	        && (lpWaveHdr->dwFlags & WHDR_DONE)))
        {
            if (fStopped)
                break;

           #ifdef JMK_HACK_TIMERS
            if (pCurTimerStuff)
            {
               pCurTimerStuff->nSleepCount = ++nSleepCount;
               pCurTimerStuff->dwSleepBegin = pcGetTicks();
            }
           #endif

	    AuxDebugEx(2,DEBUGLINE "***** Waiting for something interesting to happen while capturing\r\n");
            WaitForSingleObject (lpcs->hCaptureEvent, 300);

           #ifdef JMK_HACK_TIMERS
            if (pCurTimerStuff)
	    {
               pCurTimerStuff->dwSleepEnd = pcGetTicks();
	    }
           #endif
        }

        // What time is it?
        lpcs->dwTimeElapsedMS = timeGetTime() - dwTimeStarted;

        // -------------------------------------------------------
        //        Is video buffer ready to be written?
        // -------------------------------------------------------

        if (fStopping = ProcessNextVideoBuffer (lpcs,
                                                fStopping,
                                                &wError,
                                                &lpvhDraw,  // captured frame to draw if time permits
                                                &bVideoWritePending)) // TRUE if Write pending on lpvhDraw
        {
            AuxDebugEx (1, DEBUGLINE "ProcessVideo stopping\r\n");
            if (wError)
            {
                AuxDebugEx (1, DEBUGLINE "ProcessVideo return error %d\r\n", wError);
                errorUpdateError (lpcs, wError);
                fCapturedOK = FALSE;
                break;
            }
        }
        lpVidHdr = lpcs->alpVideoHdr[lpcs->iNextVideo];

        // if there is still more time, (or at least every 100 frames)
        // show status if we're not ending the capture
        //
        if (!fStopping &&
            (lpcs->fCaptureFlags & CAP_fCapturingToDisk) &&
            (!(lpVidHdr->dwFlags & VHDR_DONE) ||
              (lpcs->dwVideoChunkCount && (lpcs->dwVideoChunkCount % 100 == 0))))
        {
            // Captured %ld frames (Dropped %ld) %d.%03d sec. Hit Escape to Stop
            //
            statusUpdateStatus(lpcs, IDS_CAP_STAT_VIDEOCURRENT,
                               lpcs->dwVideoChunkCount,
                               lpcs->dwFramesDropped,
                               (UINT)(lpcs->dwTimeElapsedMS/1000),
                               (UINT)(lpcs->dwTimeElapsedMS%1000));
        }

        // If the yield callback returns FALSE, abort
        //
        if (lpcs->CallbackOnYield && !lpcs->CallbackOnYield (lpcs->hwnd))
            fStopping = TRUE;

       #if 0 // this is a 16 bit ism??
        // Don't do peekMessage yield for ACM
        if (lpcs->sCapParms.fYield) {
            MSG msg;

            if (PeekMessage(&msg,NULL,0,0,PM_REMOVE)) {
                // Kludge to get rid of timers from lpcs->hwnd
                if (msg.message == WM_TIMER && msg.hwnd == lpcs->hwnd)
                    ;
                else {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
            }
        }
       #endif

        // Outside routine is handling when to stop
        // The CONTROLCALLBACK_CAPTURING indicates we're asking when to stop
        //
        if (lpcs->CallbackOnControl &&
            !lpcs->CallbackOnControl (lpcs->hwnd, CONTROLCALLBACK_CAPTURING))
            fStopping = TRUE;

        // -------------------------------------------------------
        //        Is audio buffer ready to be written?
        // -------------------------------------------------------

        if (lpcs->sCapParms.fCaptureAudio) {
            if (fStopping = ProcessAudioBuffers (lpcs, fStopping, &wError))
            {
                AuxDebugEx (1, DEBUGLINE "ProcessAudio stopping\r\n");
                if (wError)
                {
                    AuxDebugEx (1, DEBUGLINE "ProcessAudio return error %d\r\n", wError);
                    errorUpdateError (lpcs, wError);
                    fCapturedOK = FALSE;
                    break;
                }
            }
	    lpWaveHdr = lpcs->alpWaveHdr[lpcs->iNextWave];
	}

        // if we are not writing the frame async, we can put the video buffer
        // back on the video driver's queue now
        //
        if (lpvhDraw)
        {

            // if the next video header is not ready yet, and
            // we have no outstanding io buffers (in async mode) draw
            // the current one
            //
            if ( !(lpVidHdr->dwFlags & VHDR_DONE) &&
                (!lpcs->pAsync || (lpcs->iNextAsync == lpcs->iLastAsync)) &&
                lpvhDraw->dwBytesUsed)
            {
                AuxDebugEx (4, DEBUGLINE "time enough to draw!\r\n");
                if (fTryToPaintAgain &&
                    lpcs->dwVideoChunkCount &&
                    lpvhDraw->dwFlags & VHDR_KEYFRAME)
                {
                    fTryToPaintAgain = DrawDibDraw(lpcs->hdd, hdc,
                            0, 0,
                            rcDrawRect.right - rcDrawRect.left,
                            rcDrawRect.bottom - rcDrawRect.top,
                            /*lpcs->dxBits, lpcs->dyBits, */
                            (LPBITMAPINFOHEADER)lpcs->lpBitsInfo,
                            lpvhDraw->lpData, 0, 0, -1, -1,
                            DDF_SAME_HDC | DDF_SAME_DIB | DDF_SAME_SIZE);
                }
            }

            // if there is not a write pending for the draw frame
            // put it back into the video drivers queue now
            //
            if ( ! bVideoWritePending)
            {
		AuxDebugEx(3, DEBUGLINE "Queueing video buffer, lpvh=%8x", lpvhDraw);

                // return the emptied buffer to the que
                //
               #if defined CHICAGO
                if (vidxAddBuffer(lpcs->hVideoIn, lpvhDraw, sizeof (VIDEOHDR)))
               #else

                if (videoStreamAddBuffer(lpcs->hVideoIn, lpvhDraw, sizeof (VIDEOHDR)))
               #endif
                {
                    AuxDebugEx (2, DEBUGLINE "Failed to Queue Video buffer %08x\r\n", lpvhDraw);
                    errorUpdateError (lpcs, IDS_CAP_VIDEO_ADD_ERROR);
                    fCapturedOK = FALSE;
                    fStopping = TRUE;
                    break;
                }
            }
        }

        // ------------------------------------------------------------
        //        Any completed I/O buffers?
        // ------------------------------------------------------------

        if (lpcs->pAsync)
            if (fStopping = ProcessAsyncIOBuffers (lpcs, fStopping, &wError))
            {
                if (wError)
                {
                    errorUpdateError (lpcs, wError);
                    fCapturedOK = FALSE;
                    break;
                }
            }

        // -------------------------------------------------------
        //        is there any reason to stop?
        // -------------------------------------------------------

        if (!fStopping)
        {
            if (lpcs->sCapParms.vKeyAbort &&
                (GetAsyncKeyState(lpcs->sCapParms.vKeyAbort & 0x00ff) & 0x0001))
            {
                BOOL fT = TRUE;
                if (lpcs->sCapParms.vKeyAbort & 0x8000)  // Ctrl?
                    fT = fT && (GetAsyncKeyState(VK_CONTROL) & 0x8000);
                if (lpcs->sCapParms.vKeyAbort & 0x4000)  // Shift?
                    fT = fT && (GetAsyncKeyState(VK_SHIFT) & 0x8000);
                fStopping = fT;      // User aborts
            }
            if (lpcs->sCapParms.fAbortLeftMouse && (GetAsyncKeyState(VK_LBUTTON) & 0x0001))
                fStopping = TRUE;      // User aborts
            if (lpcs->sCapParms.fAbortRightMouse && (GetAsyncKeyState(VK_RBUTTON) & 0x0001))
                fStopping = TRUE;      // User aborts
            if ((lpcs->fCaptureFlags & CAP_fAbortCapture) || (lpcs->fCaptureFlags & CAP_fStopCapture))
                fStopping = TRUE;          // Somebody above wants us to quit
            if (lpcs->dwTimeElapsedMS > dwTimeToStop)
                fStopping = TRUE;      // all done

           #ifdef DEBUG
            if (fStopping)
               AuxDebugEx (1, DEBUGLINE "user stop\r\n");
           #endif
        }

        // -------------------------------------------------------
        //        Tell all the devices to stop
        // -------------------------------------------------------

        if (fStopping)
        {
            if ( ! fStopped)
            {
                fStopped = TRUE;
                DSTATUS(lpcs, "Stopping....");

                if (lpcs->sCapParms.fCaptureAudio)
                {
                    DSTATUS(lpcs, "Stopping Audio");
                    waveInStop(lpcs->hWaveIn);
                }

                DSTATUS(lpcs, "Stopping Video");
                videoStreamStop(lpcs->hVideoIn);         // Stop everybody

                dwTimeStopped = timeGetTime ();

                if (lpcs->sCapParms.fMCIControl)
                {
                    DSTATUS(lpcs, "Stopping MCI");
                    MCIDevicePause (lpcs);
                }
                DSTATUS(lpcs, "Stopped");

                // Force cursor back to hourglass
                //
                SetCursor(lpcs->hWaitCursor);
            }

            // "Finished capture, now writing frame %ld"
            //
            if (fCapturedOK)
                statusUpdateStatus(lpcs, IDS_CAP_STAT_CAP_FINI, lpcs->dwVideoChunkCount);
            else
            {
                statusUpdateStatus(lpcs, IDS_CAP_RECORDING_ERROR2);
                break;
            }

	    // Wait for all the async IO to complete ??
	    //
        }

    // -------------------------------------------------------
    //   END OF MAIN CAPTURE LOOP
    // -------------------------------------------------------
    }

    DPF("End of main capture loop");

    // eat any keys that have been pressed
    //
    while(GetKey(FALSE))
        ;

    // flush stuff to disk, close everything etc.
    //
    AVIFini(lpcs);
    AVIFileFini(lpcs, TRUE, !fCapturedOK);

    // This is the corrected capture duration, based on audio samples
    lpcs->dwTimeElapsedMS = lpcs->dwActualMicroSecPerFrame *
                            lpcs->dwVideoChunkCount / 1000;

    // update the status line with information about the completed
    // capture, or with erroor information
    //
    ShowCompletionStatus (lpcs, fCapturedOK);

EarlyExit:
    DPF("at EarlyExit\n");

    //
    // If we we're compressing while capturing, close it down
    //
   #ifdef NEW_COMPMAN
    if (lpcs->CompVars.hic) {
        // Kludge, reset the lpBitsOut pointer
        if (lpcs->CompVars.lpBitsOut)
            ((LPBYTE) lpcs->CompVars.lpBitsOut) -= 8;
        ICSeqCompressFrameEnd(&lpcs->CompVars);
    }
   #endif

    if (fTryToPaint) {
        if (hpalT)
             SelectPalette(hdc, hpalT, FALSE);
        ReleaseDC (lpcs->hwnd, hdc);
    }

    if (lpcs->sCapParms.fMCIControl)
        MCIDeviceClose (lpcs);

    // Let the user see where capture stopped
    if ((!lpcs->fLiveWindow) && (!lpcs->fOverlayWindow))
        videoFrame( lpcs->hVideoIn, &lpcs->VidHdr );
    InvalidateRect( lpcs->hwnd, NULL, TRUE);

    SetThreadPriority (GetCurrentThread(), dwOldPrio);
    SetCursor(hOldCursor);

    lpcs->fCapFileExists = (lpcs->dwReturn == DV_ERR_OK);
    lpcs->fCaptureFlags &= ~CAP_fCapturingNow;

    statusUpdateStatus(lpcs, IDS_CAP_END);      // Always the last message

   #ifdef JMK_HACK_TIMERS
    if (pTimerRiff)
    {
        UINT    ii;
	UINT	kk;
        LPSTR   psz;
        HGLOBAL hMem;

        kk = (lpcs->dwVideoChunkCount >= CLIPBOARDLOGSIZE) ?
			CLIPBOARDLOGSIZE : nTimerIndex;

        hMem = GlobalAlloc (GHND, (16 * 5 + 2) * kk + 80);
	
        if (hMem && (psz = GlobalLock (hMem)))
        {
            pTimerRiff->vchd.dwFramesCaptured = lpcs->dwVideoChunkCount;
            pTimerRiff->vchd.dwFramesDropped = lpcs->dwFramesDropped;

            pTimerRiff->cbTotal = sizeof(struct _timerriff) - 8 +
                                  sizeof(struct _timerstuff) * nTimerIndex;
            pTimerRiff->cbChunk = pTimerRiff->cbTotal - sizeof(*pTimerRiff);

            lstrcpyA(psz, "Slot#, VideoIndex, ExpectedTime, DriverTime, AccumulatedDummyFrames, CurrentAppendedDummies");
            for (ii = 0; ii < kk; ++ii)
            {
                psz += lstrlenA(psz);
                wsprintfA(psz, "\r\n%d, %ld, %ld, %ld, %d, %d",
			  ii,
			  pTimerStuff[ii].dwVideoChunkCount,
                          pTimerStuff[ii].dwFrameTickTime,
                          pTimerStuff[ii].dwFrameStampTime,
                          pTimerStuff[ii].nDummyFrames,
			  pTimerStuff[ii].nFramesAppended
                          );
            }

            GlobalUnlock (hMem);
            GlobalUnlock (hMemTimers);

            if (OpenClipboard (lpcs->hwnd))
            {
                EmptyClipboard ();
                SetClipboardData (CF_RIFF, hMemTimers);
                SetClipboardData (CF_TEXT, hMem);
                CloseClipboard ();
            }
            else
            {
                GlobalFree (hMem);
                GlobalFree (hMemTimers);
            }
        }
        else
        {
            // Failed to allocate or lock hMem.  Cleanup.
            //
            if (hMem)
                GlobalFree(hMem);

            // Free off the timer block.  (We have not set the
            // clipboard data.)
            //
            if (hMemTimers)
            {
                GlobalUnlock(hMemTimers);
                GlobalFree(hMemTimers);
            }
        }

        hMemTimers = NULL;
        pTimerRiff = NULL;
	pTimerStuff = NULL;
	pCurTimerStuff = NULL;
    }
   #endif

    return;
}


// Returns TRUE if the capture task was created, or
// capture completed OK.

BOOL AVICapture (LPCAPSTREAM lpcs)
{
    CAPINFOCHUNK cic;
    TCHAR szSMPTE[40];
    void (WINAPI _LOADDS * pfnCapture) (LPCAPSTREAM lpcs);

    if (lpcs->fCaptureFlags & CAP_fCapturingNow)
        return IDS_CAP_VIDEO_OPEN_ERROR;

    // if there is a previous capture thread, wait for it to finish and
    // clean it up
    // -it has set fCapturingNow to FALSE, so it will end 'soon' !
    if (lpcs->hThreadCapture) {
        WaitForSingleObject(lpcs->hThreadCapture, INFINITE);

	CloseHandle(lpcs->hThreadCapture);
	lpcs->hThreadCapture = NULL;
    }

    // Turn off the STOP and ABORT capture bits
    lpcs->fCaptureFlags &= ~(CAP_fStopCapture | CAP_fAbortCapture);
    lpcs->dwReturn      = 0;

#if DONT_CLEAR_SMPTE_JAYBO
    // Prior to Win95, we always cleared out old SMPTE chunks,
    // but since Adobe may have created a chunk manually, don't
    // zap existing chunks.
    cic.fccInfoID = mmioFOURCC ('I','S','M','T');
    cic.lpData = NULL;
    cic.cbData = 0;
    SetInfoChunk (lpcs, &cic);
#endif

    // And get ready to write a SMPTE info chunk
    if (lpcs->sCapParms.fMCIControl) {
        // create SMPTE string
        TimeMSToSMPTE (lpcs->sCapParms.dwMCIStartTime, (LPTSTR) szSMPTE);
        cic.lpData = szSMPTE;
        cic.cbData = lstrlen (szSMPTE) + 1;
        cic.fccInfoID = mmioFOURCC ('I','S','M','T');
        SetInfoChunk (lpcs, &cic);
    }

    // set pfnCapture to point to the capture function of choice.
    // Use an MCI device to do step capture capture???
    // assume No MCI device, just a normal streaming capture
    //
    pfnCapture = AVICapture1;
    if (lpcs->sCapParms.fStepMCIDevice && lpcs->sCapParms.fMCIControl)
        pfnCapture = MCIStepCapture;

    // if the fYield flag is true, create a thread to do the
    // capture loop.  otherwise do the capture loop inline
    //
    if (lpcs->sCapParms.fYield)
    {
        DWORD tid;

        lpcs->hThreadCapture = CreateThread (NULL,
                                             0,
                                             (LPVOID) pfnCapture,
                                             lpcs,
                                             0,
                                             &tid);

        // if thread creation failed, turn off the capturing flag
        //
        if ( ! lpcs->hThreadCapture)
            lpcs->fCaptureFlags &= ~CAP_fCapturingNow;

        return (lpcs->hThreadCapture != NULL);
    }
    else
    {
        pfnCapture (lpcs);
        return (0 == lpcs->dwReturn);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avicap\avicap.h ===
/****************************************************************************
 *
 *   avicap.h
 *
 *   Main include file.
 *
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and
 *    distribute the Sample Files (and/or any modified version) in
 *    any way you find useful, provided that you agree that
 *    Microsoft has no warranty obligations or liability for any
 *    Sample Application Files which are modified.
 *
 ***************************************************************************/

#ifndef _INC_AVICAP
#define _INC_AVICAP

#if !defined(RC_INVOKED) && !defined(VFWAPI)
#ifdef _WIN32
    #define VFWAPI  WINAPI
    #define VFWAPIV WINAPIV
    #define _LOADDS
#else
    #define VFWAPI  FAR PASCAL
    #define VFWAPIV FAR CDECL
#endif
#endif

#if !defined _WIN32  && !defined LPTSTR
    #define LPTSTR LPSTR
#endif

// begin_vfw32
#ifdef __cplusplus
/* SendMessage in C++*/
#define AVICapSM(hwnd,m,w,l) ( (IsWindow(hwnd)) ? ::SendMessage(hwnd,m,w,l) : 0)
#else
/* SendMessage in C */
#define AVICapSM(hwnd,m,w,l) ( (IsWindow(hwnd)) ?   SendMessage(hwnd,m,w,l) : 0)
#endif  /* __cplusplus */

// end_vfw32
#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif  /* RC_INVOKED */

// begin_vfw32
#ifndef RC_INVOKED

// ------------------------------------------------------------------
//  Window Messages  WM_CAP... which can be sent to an AVICAP window
// ------------------------------------------------------------------



// UNICODE
//
// The Win32 version of AVICAP on NT supports UNICODE applications:
// for each API or message that takes a char or string parameter, there are
// two versions, ApiNameA and ApiNameW. The default name ApiName is #defined
// to one or other depending on whether UNICODE is defined. Apps can call
// the A and W apis directly, and mix them.
//
// The 32-bit AVICAP on NT uses unicode exclusively internally.
// ApiNameA() will be implemented as a call to ApiNameW() together with
// translation of strings.




// Defines start of the message range
#define WM_CAP_START                    WM_USER

// start of unicode messages
#define WM_CAP_UNICODE_START            WM_USER+100

#define WM_CAP_GET_CAPSTREAMPTR         (WM_CAP_START+  1)

// end_vfw32
#ifdef _WIN32
// begin_vfw32
#define WM_CAP_SET_CALLBACK_ERRORW     (WM_CAP_UNICODE_START+  2)
#define WM_CAP_SET_CALLBACK_STATUSW    (WM_CAP_UNICODE_START+  3)
#define WM_CAP_SET_CALLBACK_ERRORA     (WM_CAP_START+  2)
#define WM_CAP_SET_CALLBACK_STATUSA    (WM_CAP_START+  3)
#ifdef UNICODE
#define WM_CAP_SET_CALLBACK_ERROR       WM_CAP_SET_CALLBACK_ERRORW
#define WM_CAP_SET_CALLBACK_STATUS      WM_CAP_SET_CALLBACK_STATUSW
#else
#define WM_CAP_SET_CALLBACK_ERROR       WM_CAP_SET_CALLBACK_ERRORA
#define WM_CAP_SET_CALLBACK_STATUS      WM_CAP_SET_CALLBACK_STATUSA
#endif
// end_vfw32
#else
#define WM_CAP_SET_CALLBACK_ERROR       (WM_CAP_START+  2)
#define WM_CAP_SET_CALLBACK_STATUS      (WM_CAP_START+  3)
#endif
// begin_vfw32


#define WM_CAP_SET_CALLBACK_YIELD       (WM_CAP_START+  4)
#define WM_CAP_SET_CALLBACK_FRAME       (WM_CAP_START+  5)
#define WM_CAP_SET_CALLBACK_VIDEOSTREAM (WM_CAP_START+  6)
#define WM_CAP_SET_CALLBACK_WAVESTREAM  (WM_CAP_START+  7)
#define WM_CAP_GET_USER_DATA		(WM_CAP_START+  8)
#define WM_CAP_SET_USER_DATA		(WM_CAP_START+  9)

#define WM_CAP_DRIVER_CONNECT           (WM_CAP_START+  10)
#define WM_CAP_DRIVER_DISCONNECT        (WM_CAP_START+  11)

// end_vfw32
#ifdef _WIN32
// begin_vfw32
#define WM_CAP_DRIVER_GET_NAMEA        (WM_CAP_START+  12)
#define WM_CAP_DRIVER_GET_VERSIONA     (WM_CAP_START+  13)
#define WM_CAP_DRIVER_GET_NAMEW        (WM_CAP_UNICODE_START+  12)
#define WM_CAP_DRIVER_GET_VERSIONW     (WM_CAP_UNICODE_START+  13)
#ifdef UNICODE
#define WM_CAP_DRIVER_GET_NAME          WM_CAP_DRIVER_GET_NAMEW
#define WM_CAP_DRIVER_GET_VERSION       WM_CAP_DRIVER_GET_VERSIONW
#else
#define WM_CAP_DRIVER_GET_NAME          WM_CAP_DRIVER_GET_NAMEA
#define WM_CAP_DRIVER_GET_VERSION       WM_CAP_DRIVER_GET_VERSIONA
#endif
// end_vfw32
#else
#define WM_CAP_DRIVER_GET_NAME          (WM_CAP_START+  12)
#define WM_CAP_DRIVER_GET_VERSION       (WM_CAP_START+  13)
#endif
// begin_vfw32

#define WM_CAP_DRIVER_GET_CAPS          (WM_CAP_START+  14)

// end_vfw32
#ifdef _WIN32
// begin_vfw32
#define WM_CAP_FILE_SET_CAPTURE_FILEA  (WM_CAP_START+  20)
#define WM_CAP_FILE_GET_CAPTURE_FILEA  (WM_CAP_START+  21)
#define WM_CAP_FILE_SAVEASA            (WM_CAP_START+  23)
#define WM_CAP_FILE_SAVEDIBA           (WM_CAP_START+  25)
#define WM_CAP_FILE_SET_CAPTURE_FILEW  (WM_CAP_UNICODE_START+  20)
#define WM_CAP_FILE_GET_CAPTURE_FILEW  (WM_CAP_UNICODE_START+  21)
#define WM_CAP_FILE_SAVEASW            (WM_CAP_UNICODE_START+  23)
#define WM_CAP_FILE_SAVEDIBW           (WM_CAP_UNICODE_START+  25)
#ifdef UNICODE
#define WM_CAP_FILE_SET_CAPTURE_FILE    WM_CAP_FILE_SET_CAPTURE_FILEW
#define WM_CAP_FILE_GET_CAPTURE_FILE    WM_CAP_FILE_GET_CAPTURE_FILEW
#define WM_CAP_FILE_SAVEAS              WM_CAP_FILE_SAVEASW
#define WM_CAP_FILE_SAVEDIB             WM_CAP_FILE_SAVEDIBW
#else
#define WM_CAP_FILE_SET_CAPTURE_FILE    WM_CAP_FILE_SET_CAPTURE_FILEA
#define WM_CAP_FILE_GET_CAPTURE_FILE    WM_CAP_FILE_GET_CAPTURE_FILEA
#define WM_CAP_FILE_SAVEAS              WM_CAP_FILE_SAVEASA
#define WM_CAP_FILE_SAVEDIB             WM_CAP_FILE_SAVEDIBA
#endif
// end_vfw32
#else
#define WM_CAP_FILE_SET_CAPTURE_FILE    (WM_CAP_START+  20)
#define WM_CAP_FILE_GET_CAPTURE_FILE    (WM_CAP_START+  21)
#define WM_CAP_FILE_SAVEAS              (WM_CAP_START+  23)
#define WM_CAP_FILE_SAVEDIB             (WM_CAP_START+  25)
#endif
// begin_vfw32

// out of order to save on ifdefs
#define WM_CAP_FILE_ALLOCATE            (WM_CAP_START+  22)
#define WM_CAP_FILE_SET_INFOCHUNK       (WM_CAP_START+  24)

#define WM_CAP_EDIT_COPY                (WM_CAP_START+  30)

#define WM_CAP_SET_AUDIOFORMAT          (WM_CAP_START+  35)
#define WM_CAP_GET_AUDIOFORMAT          (WM_CAP_START+  36)

#define WM_CAP_DLG_VIDEOFORMAT          (WM_CAP_START+  41)
#define WM_CAP_DLG_VIDEOSOURCE          (WM_CAP_START+  42)
#define WM_CAP_DLG_VIDEODISPLAY         (WM_CAP_START+  43)
#define WM_CAP_GET_VIDEOFORMAT          (WM_CAP_START+  44)
#define WM_CAP_SET_VIDEOFORMAT          (WM_CAP_START+  45)
#define WM_CAP_DLG_VIDEOCOMPRESSION     (WM_CAP_START+  46)

#define WM_CAP_SET_PREVIEW              (WM_CAP_START+  50)
#define WM_CAP_SET_OVERLAY              (WM_CAP_START+  51)
#define WM_CAP_SET_PREVIEWRATE          (WM_CAP_START+  52)
#define WM_CAP_SET_SCALE                (WM_CAP_START+  53)
#define WM_CAP_GET_STATUS               (WM_CAP_START+  54)
#define WM_CAP_SET_SCROLL               (WM_CAP_START+  55)

#define WM_CAP_GRAB_FRAME               (WM_CAP_START+  60)
#define WM_CAP_GRAB_FRAME_NOSTOP        (WM_CAP_START+  61)

#define WM_CAP_SEQUENCE                 (WM_CAP_START+  62)
#define WM_CAP_SEQUENCE_NOFILE          (WM_CAP_START+  63)
#define WM_CAP_SET_SEQUENCE_SETUP       (WM_CAP_START+  64)
#define WM_CAP_GET_SEQUENCE_SETUP       (WM_CAP_START+  65)

// end_vfw32
#ifdef _WIN32
// begin_vfw32
#define WM_CAP_SET_MCI_DEVICEA         (WM_CAP_START+  66)
#define WM_CAP_GET_MCI_DEVICEA         (WM_CAP_START+  67)
#define WM_CAP_SET_MCI_DEVICEW         (WM_CAP_UNICODE_START+  66)
#define WM_CAP_GET_MCI_DEVICEW         (WM_CAP_UNICODE_START+  67)
#ifdef UNICODE
#define WM_CAP_SET_MCI_DEVICE           WM_CAP_SET_MCI_DEVICEW
#define WM_CAP_GET_MCI_DEVICE           WM_CAP_GET_MCI_DEVICEW
#else
#define WM_CAP_SET_MCI_DEVICE           WM_CAP_SET_MCI_DEVICEA
#define WM_CAP_GET_MCI_DEVICE           WM_CAP_GET_MCI_DEVICEA
#endif
// end_vfw32
#else
#define WM_CAP_SET_MCI_DEVICE           (WM_CAP_START+  66)
#define WM_CAP_GET_MCI_DEVICE           (WM_CAP_START+  67)
#endif
// begin_vfw32



#define WM_CAP_STOP                     (WM_CAP_START+  68)
#define WM_CAP_ABORT                    (WM_CAP_START+  69)

#define WM_CAP_SINGLE_FRAME_OPEN        (WM_CAP_START+  70)
#define WM_CAP_SINGLE_FRAME_CLOSE       (WM_CAP_START+  71)
#define WM_CAP_SINGLE_FRAME             (WM_CAP_START+  72)

// end_vfw32
#ifdef _WIN32
// begin_vfw32
#define WM_CAP_PAL_OPENA               (WM_CAP_START+  80)
#define WM_CAP_PAL_SAVEA               (WM_CAP_START+  81)
#define WM_CAP_PAL_OPENW               (WM_CAP_UNICODE_START+  80)
#define WM_CAP_PAL_SAVEW               (WM_CAP_UNICODE_START+  81)
#ifdef UNICODE
#define WM_CAP_PAL_OPEN                 WM_CAP_PAL_OPENW
#define WM_CAP_PAL_SAVE                 WM_CAP_PAL_SAVEW
#else
#define WM_CAP_PAL_OPEN                 WM_CAP_PAL_OPENA
#define WM_CAP_PAL_SAVE                 WM_CAP_PAL_SAVEA
#endif
// end_vfw32
#else
#define WM_CAP_PAL_OPEN                 (WM_CAP_START+  80)
#define WM_CAP_PAL_SAVE                 (WM_CAP_START+  81)
#endif
// begin_vfw32

#define WM_CAP_PAL_PASTE                (WM_CAP_START+  82)
#define WM_CAP_PAL_AUTOCREATE           (WM_CAP_START+  83)
#define WM_CAP_PAL_MANUALCREATE         (WM_CAP_START+  84)

// Following added post VFW 1.1
#define WM_CAP_SET_CALLBACK_CAPCONTROL  (WM_CAP_START+  85)


// Defines end of the message range
// end_vfw32
#ifdef _WIN32
// begin_vfw32
#define WM_CAP_UNICODE_END              WM_CAP_PAL_SAVEW
#define WM_CAP_END                      WM_CAP_UNICODE_END
// end_vfw32
#else
#define WM_CAP_END                      WM_CAP_SET_CALLBACK_CAPCONTROL
#endif
// begin_vfw32

// ------------------------------------------------------------------
//  Message crackers for above
// ------------------------------------------------------------------

// message wrapper macros are defined for the default messages only. Apps
// that wish to mix Ansi and UNICODE message sending will have to
// reference the _A and _W messages directly

#define capSetCallbackOnError(hwnd, fpProc)        ((BOOL)AVICapSM(hwnd, WM_CAP_SET_CALLBACK_ERROR, 0, (LPARAM)(LPVOID)(fpProc)))
#define capSetCallbackOnStatus(hwnd, fpProc)       ((BOOL)AVICapSM(hwnd, WM_CAP_SET_CALLBACK_STATUS, 0, (LPARAM)(LPVOID)(fpProc)))
#define capSetCallbackOnYield(hwnd, fpProc)        ((BOOL)AVICapSM(hwnd, WM_CAP_SET_CALLBACK_YIELD, 0, (LPARAM)(LPVOID)(fpProc)))
#define capSetCallbackOnFrame(hwnd, fpProc)        ((BOOL)AVICapSM(hwnd, WM_CAP_SET_CALLBACK_FRAME, 0, (LPARAM)(LPVOID)(fpProc)))
#define capSetCallbackOnVideoStream(hwnd, fpProc)  ((BOOL)AVICapSM(hwnd, WM_CAP_SET_CALLBACK_VIDEOSTREAM, 0, (LPARAM)(LPVOID)(fpProc)))
#define capSetCallbackOnWaveStream(hwnd, fpProc)   ((BOOL)AVICapSM(hwnd, WM_CAP_SET_CALLBACK_WAVESTREAM, 0, (LPARAM)(LPVOID)(fpProc)))
#define capSetCallbackOnCapControl(hwnd, fpProc)   ((BOOL)AVICapSM(hwnd, WM_CAP_SET_CALLBACK_CAPCONTROL, 0, (LPARAM)(LPVOID)(fpProc)))

#define capSetUserData(hwnd, lUser)        ((BOOL)AVICapSM(hwnd, WM_CAP_SET_USER_DATA, 0, (LPARAM)lUser))
#define capGetUserData(hwnd)               (AVICapSM(hwnd, WM_CAP_GET_USER_DATA, 0, 0))

#define capDriverConnect(hwnd, i)                  ((BOOL)AVICapSM(hwnd, WM_CAP_DRIVER_CONNECT, (WPARAM)(i), 0L))
#define capDriverDisconnect(hwnd)                  ((BOOL)AVICapSM(hwnd, WM_CAP_DRIVER_DISCONNECT, (WPARAM)0, 0L))
#define capDriverGetName(hwnd, szName, wSize)      ((BOOL)AVICapSM(hwnd, WM_CAP_DRIVER_GET_NAME, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPTSTR)(szName)))
#define capDriverGetVersion(hwnd, szVer, wSize)    ((BOOL)AVICapSM(hwnd, WM_CAP_DRIVER_GET_VERSION, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPTSTR)(szVer)))
#define capDriverGetCaps(hwnd, s, wSize)           ((BOOL)AVICapSM(hwnd, WM_CAP_DRIVER_GET_CAPS, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPCAPDRIVERCAPS)(s)))

#define capFileSetCaptureFile(hwnd, szName)        ((BOOL)AVICapSM(hwnd, WM_CAP_FILE_SET_CAPTURE_FILE, 0, (LPARAM)(LPVOID)(LPTSTR)(szName)))
#define capFileGetCaptureFile(hwnd, szName, wSize) ((BOOL)AVICapSM(hwnd, WM_CAP_FILE_GET_CAPTURE_FILE, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPTSTR)(szName)))
#define capFileAlloc(hwnd, dwSize)                 ((BOOL)AVICapSM(hwnd, WM_CAP_FILE_ALLOCATE, 0, (LPARAM)(DWORD)(dwSize)))
#define capFileSaveAs(hwnd, szName)                ((BOOL)AVICapSM(hwnd, WM_CAP_FILE_SAVEAS, 0, (LPARAM)(LPVOID)(LPTSTR)(szName)))
#define capFileSetInfoChunk(hwnd, lpInfoChunk)     ((BOOL)AVICapSM(hwnd, WM_CAP_FILE_SET_INFOCHUNK, (WPARAM)0, (LPARAM)(LPCAPINFOCHUNK)(lpInfoChunk)))
#define capFileSaveDIB(hwnd, szName)               ((BOOL)AVICapSM(hwnd, WM_CAP_FILE_SAVEDIB, 0, (LPARAM)(LPVOID)(LPTSTR)(szName)))

#define capEditCopy(hwnd)                          ((BOOL)AVICapSM(hwnd, WM_CAP_EDIT_COPY, 0, 0L))

#define capSetAudioFormat(hwnd, s, wSize)          ((BOOL)AVICapSM(hwnd, WM_CAP_SET_AUDIOFORMAT, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPWAVEFORMATEX)(s)))
#define capGetAudioFormat(hwnd, s, wSize)          ((DWORD)AVICapSM(hwnd, WM_CAP_GET_AUDIOFORMAT, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPWAVEFORMATEX)(s)))
#define capGetAudioFormatSize(hwnd)                ((DWORD)AVICapSM(hwnd, WM_CAP_GET_AUDIOFORMAT, (WPARAM)0, (LPARAM)0L))

#define capDlgVideoFormat(hwnd)                    ((BOOL)AVICapSM(hwnd, WM_CAP_DLG_VIDEOFORMAT, 0, 0L))
#define capDlgVideoSource(hwnd)                    ((BOOL)AVICapSM(hwnd, WM_CAP_DLG_VIDEOSOURCE, 0, 0L))
#define capDlgVideoDisplay(hwnd)                   ((BOOL)AVICapSM(hwnd, WM_CAP_DLG_VIDEODISPLAY, 0, 0L))
#define capDlgVideoCompression(hwnd)               ((BOOL)AVICapSM(hwnd, WM_CAP_DLG_VIDEOCOMPRESSION, 0, 0L))

#define capGetVideoFormat(hwnd, s, wSize)          ((DWORD)AVICapSM(hwnd, WM_CAP_GET_VIDEOFORMAT, (WPARAM)(wSize), (LPARAM)(LPVOID)(s)))
#define capGetVideoFormatSize(hwnd)            ((DWORD)AVICapSM(hwnd, WM_CAP_GET_VIDEOFORMAT, 0, 0L))
#define capSetVideoFormat(hwnd, s, wSize)          ((BOOL)AVICapSM(hwnd, WM_CAP_SET_VIDEOFORMAT, (WPARAM)(wSize), (LPARAM)(LPVOID)(s)))

#define capPreview(hwnd, f)                        ((BOOL)AVICapSM(hwnd, WM_CAP_SET_PREVIEW, (WPARAM)(BOOL)(f), 0L))
#define capPreviewRate(hwnd, wMS)                  ((BOOL)AVICapSM(hwnd, WM_CAP_SET_PREVIEWRATE, (WPARAM)(wMS), 0))
#define capOverlay(hwnd, f)                        ((BOOL)AVICapSM(hwnd, WM_CAP_SET_OVERLAY, (WPARAM)(BOOL)(f), 0L))
#define capPreviewScale(hwnd, f)                   ((BOOL)AVICapSM(hwnd, WM_CAP_SET_SCALE, (WPARAM)(BOOL)f, 0L))
#define capGetStatus(hwnd, s, wSize)               ((BOOL)AVICapSM(hwnd, WM_CAP_GET_STATUS, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPCAPSTATUS)(s)))
#define capSetScrollPos(hwnd, lpP)                 ((BOOL)AVICapSM(hwnd, WM_CAP_SET_SCROLL, (WPARAM)0, (LPARAM)(LPPOINT)(lpP)))

#define capGrabFrame(hwnd)                         ((BOOL)AVICapSM(hwnd, WM_CAP_GRAB_FRAME, (WPARAM)0, (LPARAM)0L))
#define capGrabFrameNoStop(hwnd)                   ((BOOL)AVICapSM(hwnd, WM_CAP_GRAB_FRAME_NOSTOP, (WPARAM)0, (LPARAM)0L))

#define capCaptureSequence(hwnd)                   ((BOOL)AVICapSM(hwnd, WM_CAP_SEQUENCE, (WPARAM)0, (LPARAM)0L))
#define capCaptureSequenceNoFile(hwnd)             ((BOOL)AVICapSM(hwnd, WM_CAP_SEQUENCE_NOFILE, (WPARAM)0, (LPARAM)0L))
#define capCaptureStop(hwnd)                       ((BOOL)AVICapSM(hwnd, WM_CAP_STOP, (WPARAM)0, (LPARAM)0L))
#define capCaptureAbort(hwnd)                      ((BOOL)AVICapSM(hwnd, WM_CAP_ABORT, (WPARAM)0, (LPARAM)0L))

#define capCaptureSingleFrameOpen(hwnd)            ((BOOL)AVICapSM(hwnd, WM_CAP_SINGLE_FRAME_OPEN, (WPARAM)0, (LPARAM)0L))
#define capCaptureSingleFrameClose(hwnd)           ((BOOL)AVICapSM(hwnd, WM_CAP_SINGLE_FRAME_CLOSE, (WPARAM)0, (LPARAM)0L))
#define capCaptureSingleFrame(hwnd)                ((BOOL)AVICapSM(hwnd, WM_CAP_SINGLE_FRAME, (WPARAM)0, (LPARAM)0L))

#define capCaptureGetSetup(hwnd, s, wSize)         ((BOOL)AVICapSM(hwnd, WM_CAP_GET_SEQUENCE_SETUP, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPCAPTUREPARMS)(s)))
#define capCaptureSetSetup(hwnd, s, wSize)         ((BOOL)AVICapSM(hwnd, WM_CAP_SET_SEQUENCE_SETUP, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPCAPTUREPARMS)(s)))

#define capSetMCIDeviceName(hwnd, szName)          ((BOOL)AVICapSM(hwnd, WM_CAP_SET_MCI_DEVICE, 0, (LPARAM)(LPVOID)(LPTSTR)(szName)))
#define capGetMCIDeviceName(hwnd, szName, wSize)   ((BOOL)AVICapSM(hwnd, WM_CAP_GET_MCI_DEVICE, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPTSTR)(szName)))

#define capPaletteOpen(hwnd, szName)               ((BOOL)AVICapSM(hwnd, WM_CAP_PAL_OPEN, 0, (LPARAM)(LPVOID)(LPTSTR)(szName)))
#define capPaletteSave(hwnd, szName)               ((BOOL)AVICapSM(hwnd, WM_CAP_PAL_SAVE, 0, (LPARAM)(LPVOID)(LPTSTR)(szName)))
#define capPalettePaste(hwnd)                      ((BOOL)AVICapSM(hwnd, WM_CAP_PAL_PASTE, (WPARAM) 0, (LPARAM)0L))
#define capPaletteAuto(hwnd, iFrames, iColors)     ((BOOL)AVICapSM(hwnd, WM_CAP_PAL_AUTOCREATE, (WPARAM)(iFrames), (LPARAM)(DWORD)(iColors)))
#define capPaletteManual(hwnd, fGrab, iColors)     ((BOOL)AVICapSM(hwnd, WM_CAP_PAL_MANUALCREATE, (WPARAM)(fGrab), (LPARAM)(DWORD)(iColors)))

// ------------------------------------------------------------------
//  Structures
// ------------------------------------------------------------------

typedef struct tagCapDriverCaps {
    UINT        wDeviceIndex;               // Driver index in system.ini
    BOOL        fHasOverlay;                // Can device overlay?
    BOOL        fHasDlgVideoSource;         // Has Video source dlg?
    BOOL        fHasDlgVideoFormat;         // Has Format dlg?
    BOOL        fHasDlgVideoDisplay;        // Has External out dlg?
    BOOL        fCaptureInitialized;        // Driver ready to capture?
    BOOL        fDriverSuppliesPalettes;    // Can driver make palettes?

// following always NULL on Win32.
    HANDLE      hVideoIn;                   // Driver In channel
    HANDLE      hVideoOut;                  // Driver Out channel
    HANDLE      hVideoExtIn;                // Driver Ext In channel
    HANDLE      hVideoExtOut;               // Driver Ext Out channel
} CAPDRIVERCAPS, *PCAPDRIVERCAPS, FAR *LPCAPDRIVERCAPS;

typedef struct tagCapStatus {
    UINT        uiImageWidth;               // Width of the image
    UINT        uiImageHeight;              // Height of the image
    BOOL        fLiveWindow;                // Now Previewing video?
    BOOL        fOverlayWindow;             // Now Overlaying video?
    BOOL        fScale;                     // Scale image to client?
    POINT       ptScroll;                   // Scroll position
    BOOL        fUsingDefaultPalette;       // Using default driver palette?
    BOOL        fAudioHardware;             // Audio hardware present?
    BOOL        fCapFileExists;             // Does capture file exist?
    DWORD       dwCurrentVideoFrame;        // # of video frames cap'td
    DWORD       dwCurrentVideoFramesDropped;// # of video frames dropped
    DWORD       dwCurrentWaveSamples;       // # of wave samples cap'td
    DWORD       dwCurrentTimeElapsedMS;     // Elapsed capture duration
    HPALETTE    hPalCurrent;                // Current palette in use
    BOOL        fCapturingNow;              // Capture in progress?
    DWORD       dwReturn;                   // Error value after any operation
    UINT        wNumVideoAllocated;         // Actual number of video buffers
    UINT        wNumAudioAllocated;         // Actual number of audio buffers
} CAPSTATUS, *PCAPSTATUS, FAR *LPCAPSTATUS;

                                            // Default values in parenthesis
typedef struct tagCaptureParms {
    DWORD       dwRequestMicroSecPerFrame;  // Requested capture rate
    BOOL        fMakeUserHitOKToCapture;    // Show "Hit OK to cap" dlg?
    UINT        wPercentDropForError;       // Give error msg if > (10%)
    BOOL        fYield;                     // Capture via background task?
    DWORD       dwIndexSize;                // Max index size in frames (32K)
    UINT        wChunkGranularity;          // Junk chunk granularity (2K)
    BOOL        fUsingDOSMemory;            // Use DOS buffers?
    UINT        wNumVideoRequested;         // # video buffers, If 0, autocalc
    BOOL        fCaptureAudio;              // Capture audio?
    UINT        wNumAudioRequested;         // # audio buffers, If 0, autocalc
    UINT        vKeyAbort;                  // Virtual key causing abort
    BOOL        fAbortLeftMouse;            // Abort on left mouse?
    BOOL        fAbortRightMouse;           // Abort on right mouse?
    BOOL        fLimitEnabled;              // Use wTimeLimit?
    UINT        wTimeLimit;                 // Seconds to capture
    BOOL        fMCIControl;                // Use MCI video source?
    BOOL        fStepMCIDevice;             // Step MCI device?
    DWORD       dwMCIStartTime;             // Time to start in MS
    DWORD       dwMCIStopTime;              // Time to stop in MS
    BOOL        fStepCaptureAt2x;           // Perform spatial averaging 2x
    UINT        wStepCaptureAverageFrames;  // Temporal average n Frames
    DWORD       dwAudioBufferSize;          // Size of audio bufs (0 = default)
    BOOL        fDisableWriteCache;         // Attempt to disable write cache
    UINT        AVStreamMaster;             // Which stream controls length?
} CAPTUREPARMS, *PCAPTUREPARMS, FAR *LPCAPTUREPARMS;

// ------------------------------------------------------------------
//  AVStreamMaster
//  Since Audio and Video streams generally use non-synchronized capture
//  clocks, this flag determines whether the audio stream is to be considered
//  the master or controlling clock when writing the AVI file:
//
//  AVSTREAMMASTER_AUDIO  - Audio is master, video frame duration is forced
//                          to match audio duration (VFW 1.0, 1.1 default)
//  AVSTREAMMASTER_NONE   - No master, audio and video streams may be of
//                          different lengths
// ------------------------------------------------------------------
#define AVSTREAMMASTER_AUDIO            0 /* Audio master (VFW 1.0, 1.1) */
#define AVSTREAMMASTER_NONE             1 /* No master */

typedef struct tagCapInfoChunk {
    FOURCC      fccInfoID;                  // Chunk ID, "ICOP" for copyright
    LPVOID      lpData;                     // pointer to data
    LONG        cbData;                     // size of lpData
} CAPINFOCHUNK, *PCAPINFOCHUNK, FAR *LPCAPINFOCHUNK;


// ------------------------------------------------------------------
//  Callback Definitions
// ------------------------------------------------------------------

typedef LRESULT (CALLBACK* CAPYIELDCALLBACK)  (HWND hWnd);
// end_vfw32
#ifdef _WIN32
// begin_vfw32
typedef LRESULT (CALLBACK* CAPSTATUSCALLBACKW) (HWND hWnd, int nID, LPCWSTR lpsz);
typedef LRESULT (CALLBACK* CAPERRORCALLBACKW)  (HWND hWnd, int nID, LPCWSTR lpsz);
typedef LRESULT (CALLBACK* CAPSTATUSCALLBACKA) (HWND hWnd, int nID, LPCSTR lpsz);
typedef LRESULT (CALLBACK* CAPERRORCALLBACKA)  (HWND hWnd, int nID, LPCSTR lpsz);
#ifdef UNICODE
#define CAPSTATUSCALLBACK  CAPSTATUSCALLBACKW
#define CAPERRORCALLBACK   CAPERRORCALLBACKW
#else
#define CAPSTATUSCALLBACK  CAPSTATUSCALLBACKA
#define CAPERRORCALLBACK   CAPERRORCALLBACKA
#endif
// end_vfw32
#else
typedef LRESULT (CALLBACK* CAPSTATUSCALLBACK) (HWND hWnd, int nID, LPCSTR lpsz);
typedef LRESULT (CALLBACK* CAPERRORCALLBACK)  (HWND hWnd, int nID, LPCSTR lpsz);
#endif
// begin_vfw32
typedef LRESULT (CALLBACK* CAPVIDEOCALLBACK)  (HWND hWnd, LPVIDEOHDR lpVHdr);
typedef LRESULT (CALLBACK* CAPWAVECALLBACK)   (HWND hWnd, LPWAVEHDR lpWHdr);
typedef LRESULT (CALLBACK* CAPCONTROLCALLBACK)(HWND hWnd, int nState);

// ------------------------------------------------------------------
//  CapControlCallback states
// ------------------------------------------------------------------
#define CONTROLCALLBACK_PREROLL         1 /* Waiting to start capture */
#define CONTROLCALLBACK_CAPTURING       2 /* Now capturing */

// ------------------------------------------------------------------
//  The only exported functions from AVICAP.DLL
// ------------------------------------------------------------------

// end_vfw32
#ifdef _WIN32
// begin_vfw32
HWND VFWAPI capCreateCaptureWindowA (
        LPCSTR lpszWindowName,
        DWORD dwStyle,
        int x, int y, int nWidth, int nHeight,
        HWND hwndParent, int nID);

BOOL VFWAPI capGetDriverDescriptionA (UINT wDriverIndex,
        LPSTR lpszName, int cbName,
        LPSTR lpszVer, int cbVer);

HWND VFWAPI capCreateCaptureWindowW (
        LPCWSTR lpszWindowName,
        DWORD dwStyle,
        int x, int y, int nWidth, int nHeight,
        HWND hwndParent, int nID);

BOOL VFWAPI capGetDriverDescriptionW (UINT wDriverIndex,
        LPWSTR lpszName, int cbName,
        LPWSTR lpszVer, int cbVer);
#ifdef UNICODE
#define capCreateCaptureWindow  capCreateCaptureWindowW
#define capGetDriverDescription capGetDriverDescriptionW
#else
#define capCreateCaptureWindow  capCreateCaptureWindowA
#define capGetDriverDescription capGetDriverDescriptionA
#endif
// end_vfw32
#else //_WIN32... what follows is 16 bit stuff
HWND VFWAPI capCreateCaptureWindow (
        LPCSTR lpszWindowName,
        DWORD dwStyle,
        int x, int y, int nWidth, int nHeight,
        HWND hwndParent, int nID);

BOOL VFWAPI capGetDriverDescription (WORD wDriverIndex,
        LPSTR lpszName, int cbName,
        LPSTR lpszVer, int cbVer);
#endif
// begin_vfw32

#endif  /* RC_INVOKED */

// ------------------------------------------------------------------
// New Information chunk IDs
// ------------------------------------------------------------------
#define infotypeDIGITIZATION_TIME  mmioFOURCC ('I','D','I','T')
#define infotypeSMPTE_TIME         mmioFOURCC ('I','S','M','P')

// ------------------------------------------------------------------
// String IDs from status and error callbacks
// ------------------------------------------------------------------

#define IDS_CAP_BEGIN               300  /* "Capture Start" */
#define IDS_CAP_END                 301  /* "Capture End" */

#define IDS_CAP_INFO                401  /* "%s" */
#define IDS_CAP_OUTOFMEM            402  /* "Out of memory" */
#define IDS_CAP_FILEEXISTS          403  /* "File '%s' exists -- overwrite it?" */
#define IDS_CAP_ERRORPALOPEN        404  /* "Error opening palette '%s'" */
#define IDS_CAP_ERRORPALSAVE        405  /* "Error saving palette '%s'" */
#define IDS_CAP_ERRORDIBSAVE        406  /* "Error saving frame '%s'" */
#define IDS_CAP_DEFAVIEXT           407  /* "avi" */
#define IDS_CAP_DEFPALEXT           408  /* "pal" */
#define IDS_CAP_CANTOPEN            409  /* "Cannot open '%s'" */
#define IDS_CAP_SEQ_MSGSTART        410  /* "Select OK to start capture\nof video sequence\nto %s." */
#define IDS_CAP_SEQ_MSGSTOP         411  /* "Hit ESCAPE or click to end capture" */

#define IDS_CAP_VIDEDITERR          412  /* "An error occurred while trying to run VidEdit." */
#define IDS_CAP_READONLYFILE        413  /* "The file '%s' is a read-only file." */
#define IDS_CAP_WRITEERROR          414  /* "Unable to write to file '%s'.\nDisk may be full." */
#define IDS_CAP_NODISKSPACE         415  /* "There is no space to create a capture file on the specified device." */
#define IDS_CAP_SETFILESIZE         416  /* "Set File Size" */
#define IDS_CAP_SAVEASPERCENT       417  /* "SaveAs: %2ld%%  Hit Escape to abort." */

#define IDS_CAP_DRIVER_ERROR        418  /* Driver specific error message */

#define IDS_CAP_WAVE_OPEN_ERROR     419  /* "Error: Cannot open the wave input device.\nCheck sample size, frequency, and channels." */
#define IDS_CAP_WAVE_ALLOC_ERROR    420  /* "Error: Out of memory for wave buffers." */
#define IDS_CAP_WAVE_PREPARE_ERROR  421  /* "Error: Cannot prepare wave buffers." */
#define IDS_CAP_WAVE_ADD_ERROR      422  /* "Error: Cannot add wave buffers." */
#define IDS_CAP_WAVE_SIZE_ERROR     423  /* "Error: Bad wave size." */

#define IDS_CAP_VIDEO_OPEN_ERROR    424  /* "Error: Cannot open the video input device." */
#define IDS_CAP_VIDEO_ALLOC_ERROR   425  /* "Error: Out of memory for video buffers." */
#define IDS_CAP_VIDEO_PREPARE_ERROR 426  /* "Error: Cannot prepare video buffers." */
#define IDS_CAP_VIDEO_ADD_ERROR     427  /* "Error: Cannot add video buffers." */
#define IDS_CAP_VIDEO_SIZE_ERROR    428  /* "Error: Bad video size." */

#define IDS_CAP_FILE_OPEN_ERROR     429  /* "Error: Cannot open capture file." */
#define IDS_CAP_FILE_WRITE_ERROR    430  /* "Error: Cannot write to capture file.  Disk may be full." */
#define IDS_CAP_RECORDING_ERROR     431  /* "Error: Cannot write to capture file.  Data rate too high or disk full." */
#define IDS_CAP_RECORDING_ERROR2    432  /* "Error while recording" */
#define IDS_CAP_AVI_INIT_ERROR      433  /* "Error: Unable to initialize for capture." */
#define IDS_CAP_NO_FRAME_CAP_ERROR  434  /* "Warning: No frames captured.\nConfirm that vertical sync interrupts\nare configured and enabled." */
#define IDS_CAP_NO_PALETTE_WARN     435  /* "Warning: Using default palette." */
#define IDS_CAP_MCI_CONTROL_ERROR   436  /* "Error: Unable to access MCI device." */
#define IDS_CAP_MCI_CANT_STEP_ERROR 437  /* "Error: Unable to step MCI device." */
#define IDS_CAP_NO_AUDIO_CAP_ERROR  438  /* "Error: No audio data captured.\nCheck audio card settings." */
#define IDS_CAP_AVI_DRAWDIB_ERROR   439  /* "Error: Unable to draw this data format." */
#define IDS_CAP_COMPRESSOR_ERROR    440  /* "Error: Unable to initialize compressor." */
#define IDS_CAP_AUDIO_DROP_ERROR    441  /* "Error: Audio data was lost during capture, reduce capture rate." */
#define IDS_CAP_AUDIO_DROP_COMPERROR 442  /* "Error: Audio data was lost during capture.  Try capturing without compressing." */

/* status string IDs */
#define IDS_CAP_STAT_LIVE_MODE      500  /* "Live window" */
#define IDS_CAP_STAT_OVERLAY_MODE   501  /* "Overlay window" */
#define IDS_CAP_STAT_CAP_INIT       502  /* "Setting up for capture - Please wait" */
#define IDS_CAP_STAT_CAP_FINI       503  /* "Finished capture, now writing frame %ld" */
#define IDS_CAP_STAT_PALETTE_BUILD  504  /* "Building palette map" */
#define IDS_CAP_STAT_OPTPAL_BUILD   505  /* "Computing optimal palette" */
#define IDS_CAP_STAT_I_FRAMES       506  /* "%d frames" */
#define IDS_CAP_STAT_L_FRAMES       507  /* "%ld frames" */
#define IDS_CAP_STAT_CAP_L_FRAMES   508  /* "Captured %ld frames" */
#define IDS_CAP_STAT_CAP_AUDIO      509  /* "Capturing audio" */
#define IDS_CAP_STAT_VIDEOCURRENT   510  /* "Captured %ld frames (%ld dropped) %d.%03d sec." */
#define IDS_CAP_STAT_VIDEOAUDIO     511  /* "Captured %d.%03d sec.  %ld frames (%ld dropped) (%d.%03d fps).  %ld audio bytes (%d,%03d sps)" */
#define IDS_CAP_STAT_VIDEOONLY      512  /* "Captured %d.%03d sec.  %ld frames (%ld dropped) (%d.%03d fps)" */
#define IDS_CAP_STAT_FRAMESDROPPED  513  /* "Dropped %ld of %ld frames (%d.%02d%%) during capture." */
// end_vfw32
#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif    /* __cplusplus */

#endif /* INC_AVICAP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avicap\capdib.h ===
/****************************************************************************
 *
 *   capdib.h
 *
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992-1994 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and
 *    distribute the Sample Files (and/or any modified version) in
 *    any way you find useful, provided that you agree that
 *    Microsoft has no warranty obligations or liability for any
 *    Sample Application Files which are modified.
 *
 ***************************************************************************/

void SetDefaultCaptureFormat (LPBITMAPINFOHEADER lpbih);
DWORD AllocNewGlobalBitmapInfo (LPCAPSTREAM lpcs, LPBITMAPINFOHEADER lpbi);
DWORD AllocNewBitSpace (LPCAPSTREAM lpcs, LPBITMAPINFOHEADER lpbih);
DWORD DibInit (LPCAPSTREAM lpcs);
void DibFini (LPCAPSTREAM lpcs);
DWORD SendDriverFormat (LPCAPSTREAM lpcs, LPBITMAPINFOHEADER lpbih, DWORD dwInfoHeaderSize);
DWORD SetFormatFromDIB (LPCAPSTREAM lpcs, LPBITMAPINFOHEADER lpbih);
LPBITMAPINFO DibGetCurrentFormat (LPCAPSTREAM lpcs);
DWORD DibGetNewFormatFromDriver (LPCAPSTREAM lpcs);
BOOL DibNewFormatFromApp (LPCAPSTREAM lpcs, LPBITMAPINFO lpbi, UINT dwSize);
DWORD DibNewPalette (LPCAPSTREAM lpcs, HPALETTE hPalNew);
void DibPaint(LPCAPSTREAM lpcs, HDC hdc);
HANDLE CreatePackedDib (LPBITMAPINFO lpBitsInfo, LPBYTE lpSrcBits, HPALETTE hPalette);
BOOL FAR PASCAL dibIsWritable (LPBITMAPINFO lpBitsInfo);
BOOL FAR PASCAL dibWrite(LPCAPSTREAM lpcs, HMMIO hmmio);
BOOL FAR PASCAL fileSaveDIB(LPCAPSTREAM lpcs, LPTSTR lpszFileName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avicap\capdib.c ===
/****************************************************************************
 *
 *   capdib.c
 *
 *   DIB processing module.
 *
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992, 1993 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and
 *    distribute the Sample Files (and/or any modified version) in
 *    any way you find useful, provided that you agree that
 *    Microsoft has no warranty obligations or liability for any
 *    Sample Application Files which are modified.
 *
 ***************************************************************************/

#define INC_OLE2
#pragma warning(disable:4103)
#include <windows.h>
#include <windowsx.h>
#include <win32.h>
#include <mmsystem.h>
#include <msvideo.h>
#include <drawdib.h>

#include "ivideo32.h"
#include "avicap.h"
#include "avicapi.h"


//
// Initialize a DIB to the default format of 160x120x8, BI_RGB
//
void SetDefaultCaptureFormat (LPBITMAPINFOHEADER lpbih)
{
    lpbih->biSize              = sizeof (BITMAPINFOHEADER);
    lpbih->biWidth             = 160;
    lpbih->biHeight            = 120;
    lpbih->biBitCount          = 8;
    lpbih->biPlanes            = 1;
    lpbih->biCompression       = BI_RGB;
    lpbih->biSizeImage         = DIBWIDTHBYTES (*lpbih) * lpbih->biHeight;
    lpbih->biXPelsPerMeter     = 0;
    lpbih->biYPelsPerMeter     = 0;
    lpbih->biClrUsed           = 256;
    lpbih->biClrImportant      = 0;
}

//
// Whenever we get a new format from the driver, OR
// start using a new palette, we must reallocate
// our global BITMAPINFOHEADER.  This allows JPEG
// quantization tables to be tacked onto the BITMAPINFO
// or any other format specific stuff.  The color table
// is always offset biSize from the start of the BITMAPINFO.
// Returns: 0 on success, or DV_ERR_... code
//

DWORD AllocNewGlobalBitmapInfo (LPCAPSTREAM lpcs, LPBITMAPINFOHEADER lpbi)
{
    DWORD dwSize;

    dwSize = lpbi->biSize + 256 * sizeof (RGBQUAD);

    // The 256 entry above is HARDWIRED ON PURPOSE
    // If biClrUsed was used instead, we would have to realloc
    // whenever a palette is pasted (during DibNewPalette())!!!

    if (lpcs->lpBitsInfo)
         lpcs->lpBitsInfo = (LPBITMAPINFO) GlobalReAllocPtr (lpcs->lpBitsInfo,
                dwSize, GHND);
    else
         lpcs->lpBitsInfo = (LPBITMAPINFO) GlobalAllocPtr (GHND, dwSize);

    if (!lpcs->lpBitsInfo)
         return (DV_ERR_NOMEM);

    // Copy over the BITMAPINFOHEADER
    CopyMemory (lpcs->lpBitsInfo, lpbi, lpbi->biSize);

    return DV_ERR_OK;
}

//
// Whenever we get a new format from the driver
// allocate a new global bitspace.  This bitspace is used
// in preview mode and single frame capture.
// Returns: 0 on success, or DV_ERR_... code
//

DWORD AllocNewBitSpace (LPCAPSTREAM lpcs, LPBITMAPINFOHEADER lpbih)
{
    DWORD dwSize;

    // Allow room for a RIFF chunk prepended to the actual image,
    // and a junk chunk on the tail end

#define  RESERVE_FOR_RIFF  (512+sizeof(RIFF))

    dwSize = lpbih->biSizeImage + RESERVE_FOR_RIFF;

    if (lpcs->lpBitsUnaligned) {
#ifdef CHICAGO
         vidxFreePreviewBuffer (lpcs->hVideoIn, 
                lpcs->lpBitsUnaligned);
#else
         FreeSectorAlignedMem (lpcs->lpBitsUnaligned);
#endif
         lpcs->lpBitsUnaligned = NULL;
         lpcs->lpBits = NULL;
    }

#ifdef CHICAGO
    if (MMSYSERR_NOERROR == vidxAllocPreviewBuffer (
                lpcs->hVideoIn,
                &lpcs->lpBitsUnaligned,
                dwSize)) {
        lpcs->lpBits = (LPBYTE) (ROUNDUPTOSECTORSIZE(lpcs->lpBitsUnaligned, 512)
                        + sizeof(RIFF));
    }

#else
    if (lpcs->lpBitsUnaligned = ((LPBYTE)AllocSectorAlignedMem (dwSize, 512))) {
        lpcs->lpBits = (LPBYTE) (ROUNDUPTOSECTORSIZE(lpcs->lpBitsUnaligned, 512)
                        + sizeof(RIFF));
    }
#endif

    if (!lpcs->lpBits)
         return (DV_ERR_NOMEM);

    return DV_ERR_OK;
}

//
// Dib Initialization code
// Returns: 0 on success, or DV_ERR_... code
//

DWORD DibInit (LPCAPSTREAM lpcs)
{
    BITMAPINFOHEADER bmih;

    SetDefaultCaptureFormat (&bmih);
    return ((WORD) AllocNewGlobalBitmapInfo (lpcs, &bmih));
}

//
// Fini code to free all bitmap resources
//
void DibFini (LPCAPSTREAM lpcs)
{
    if (lpcs->lpBits) {
#ifdef CHICAGO
        vidxFreePreviewBuffer (lpcs->hVideoIn, lpcs->lpBitsUnaligned);
#else
        FreeSectorAlignedMem (lpcs->lpBitsUnaligned);
#endif
        lpcs->lpBits = NULL;
        lpcs->lpBitsUnaligned = NULL;
    }
    if (lpcs->lpBitsInfo) {
        GlobalFreePtr (lpcs->lpBitsInfo);
        lpcs->lpBitsInfo = NULL;
    }
    lpcs->dxBits = 0;
    lpcs->dyBits = 0;
}

//
// Send a format to the driver.
// Whenever we do a format change, send the driver the
// Source and destination rects.
// Returns: 0 on success, or DV_ERR_... code
//
DWORD SendDriverFormat (LPCAPSTREAM lpcs, LPBITMAPINFOHEADER lpbih, DWORD dwInfoHeaderSize)
{
    RECT rc;
    DWORD dwError = DV_ERR_NOTSUPPORTED;

    rc.left = rc.top = 0;
    rc.right = (int) lpbih->biWidth;
    rc.bottom = (int) lpbih->biHeight;

    if (dwError = videoConfigure(lpcs->hVideoIn,
            DVM_FORMAT,
            VIDEO_CONFIGURE_SET, NULL,
            (LPBITMAPINFOHEADER)lpbih, dwInfoHeaderSize,
            NULL, 0 ) ) {
        return dwError;
    } else {
        videoSetRect (lpcs->hVideoCapture, DVM_DST_RECT, rc);
        videoSetRect (lpcs->hVideoIn, DVM_SRC_RECT, rc);
        videoSetRect (lpcs->hVideoIn, DVM_DST_RECT, rc);
    }
    return dwError;
}


//
// Given a DIB, see if the driver likes it, then
//  allocate the global BITMAPINFOHEADER and bitspace.
//
//
DWORD SetFormatFromDIB (LPCAPSTREAM lpcs, LPBITMAPINFOHEADER lpbih)
{
    DWORD dwError;

    // Fill optional fields in the DIB header
    if (lpbih->biSizeImage == 0)
        lpbih->biSizeImage = DIBWIDTHBYTES (*lpbih) * lpbih->biHeight;

    // Is the format palatized or full-color
    if (lpbih->biBitCount <= 8 && lpbih->biClrUsed == 0)
        lpbih->biClrUsed = (1 << lpbih->biBitCount);     // paletized

    // See if the driver will support it
    if (dwError = SendDriverFormat (lpcs, lpbih, lpbih->biSize) )
        return dwError;

    // Realloc our global header
    if (dwError = AllocNewGlobalBitmapInfo (lpcs, lpbih))
        return dwError;

    // Realloc the bits
    if (dwError = AllocNewBitSpace (lpcs, lpbih))
        return dwError;

    lpcs->dxBits = (int)lpbih->biWidth;
    lpcs->dyBits = (int)lpbih->biHeight;

    lpcs->VidHdr.lpData = lpcs->lpBits;
    lpcs->VidHdr.dwBufferLength = lpbih->biSizeImage;
    lpcs->VidHdr.dwUser = 0;
    lpcs->VidHdr.dwFlags = 0;

    return (DV_ERR_OK);
}


//
// Returns: a LPBITMAPINFO allocated from global memory
//      containing the current format, or NULL on error.
//      Note that this structure can be larger than
//      sizeof (BITMAPINFO), ie. JPEG !!!
//

LPBITMAPINFO DibGetCurrentFormat (LPCAPSTREAM lpcs)
{
    DWORD               dwError;
    DWORD               dwSize = 0;
    LPBITMAPINFO        lpBInfo = NULL;

    if (!lpcs->fHardwareConnected)
        return NULL;

    // How large is the BITMAPINFOHEADER?
    videoConfigure( lpcs->hVideoIn,
            DVM_FORMAT,
             VIDEO_CONFIGURE_GET | VIDEO_CONFIGURE_QUERYSIZE,
             &dwSize, 0, 0, NULL, 0);

    if (!dwSize)
        dwSize = sizeof (BITMAPINFOHEADER);

    if (!(lpBInfo = (LPBITMAPINFO) GlobalAllocPtr (GMEM_MOVEABLE, dwSize)))
         return (NULL);

    if (dwError = videoConfigure( lpcs->hVideoIn,
            DVM_FORMAT,
             VIDEO_CONFIGURE_GET | VIDEO_CONFIGURE_CURRENT, NULL,
             (LPBITMAPINFOHEADER) lpBInfo, dwSize,
             NULL, 0 ) ) {
        // very bad. the driver can't tell us its format. we're hosed.
        GlobalFreePtr (lpBInfo);
        return NULL;
     }

    return (lpBInfo);
}

//
// Main entry point when changing capture formats.
// This is called when the user closes the drivers format dialog.
// Returns: 0 on success, or DV_ERR_... code
//
DWORD DibGetNewFormatFromDriver (LPCAPSTREAM lpcs)
{
    BOOL                f;
    BITMAPINFOHEADER    bih;
    DWORD               dwError;
    LPBITMAPINFO        lpBInfo;

    if (!lpcs->fHardwareConnected)
        return DV_ERR_OK;       // Return OK if no hardware exists

    lpBInfo = DibGetCurrentFormat (lpcs);

    if (lpBInfo == NULL)
        return DV_ERR_NOTSUPPORTED;

    // Set our internal state
    if (dwError = SetFormatFromDIB (lpcs, (LPBITMAPINFOHEADER) lpBInfo)) {
        // couldn't change formats, time to punt!
        // Try to switch back to minimal format (120x160x8)

        errorDriverID (lpcs, dwError);

        SetDefaultCaptureFormat (&bih);
        dwError = SetFormatFromDIB (lpcs, &bih);
    }

    // Force a new frame to be taken, so the DIB contains good
    // data.  Especially important to prevent codecs from exploding!
    if (!dwError)
        videoFrame (lpcs->hVideoIn, &lpcs->VidHdr);

    if (lpBInfo)
        GlobalFreePtr (lpBInfo);

    f = DrawDibBegin(lpcs->hdd,NULL,-1,-1,(LPBITMAPINFOHEADER)(lpcs->lpBitsInfo),-1,-1,0);
    if (!f) {
        errorUpdateError(lpcs, IDS_CAP_AVI_DRAWDIB_ERROR);
    }

    return (dwError);
}

//
// Main entry point when changing capture formats via App message.
// Returns: TRUE on success, or FALSE if format not supported
//
BOOL DibNewFormatFromApp (LPCAPSTREAM lpcs, LPBITMAPINFO lpbiNew, UINT dwSize)
{
    BOOL                f;
    DWORD               dwError;
    LPBITMAPINFO        lpBInfo;

    if (!lpcs->fHardwareConnected)
        return FALSE;

    lpBInfo = DibGetCurrentFormat (lpcs);  // Allocs memory!!!

    if (lpBInfo == NULL)
        return FALSE;

    // Set our internal state
    if (dwError = SetFormatFromDIB (lpcs, (LPBITMAPINFOHEADER) lpbiNew)) {
        // Driver didn't accept the format,
        // switch back to the original

        errorDriverID (lpcs, dwError);

        SetFormatFromDIB (lpcs, (LPBITMAPINFOHEADER)lpBInfo);
    }

    // Force a new frame to be taken, so the DIB contains good
    // data.  Especially important to prevent codecs from exploding!
    videoFrame (lpcs->hVideoIn, &lpcs->VidHdr);

    if (lpBInfo)
        GlobalFreePtr (lpBInfo);

    f = DrawDibBegin(lpcs->hdd,NULL,-1,-1,(LPBITMAPINFOHEADER)(lpcs->lpBitsInfo),-1,-1,0);
    if (!f) {
        errorUpdateError(lpcs, IDS_CAP_AVI_DRAWDIB_ERROR);
        //errorDriverID (lpcs, IDS_CAP_AVI_DRAWDIB_ERROR);
    }

    return (dwError == DV_ERR_OK);
}


void xlatClut8 (BYTE HUGE *pb, DWORD dwSize, BYTE HUGE *xlat)
{
    DWORD dw;

    for (dw = 0; dw < dwSize; dw++, ((BYTE huge *)pb)++)
        *pb = xlat[*pb];
}

//
// DibNewPalette
//
// Performs three functions:
// 1. Updates the biClrUsed field if biBitCount <= 8.
// 2. Remaps BI_RGB images through a LUT when a new palette is assigned.
// 3. Copies the palette entries into our global BITMAPINFO
//
// Returns: TRUE on success
//
DWORD DibNewPalette (LPCAPSTREAM lpcs, HPALETTE hPalNew)
{
    LPBITMAPINFOHEADER  lpbi;
    int                 n;
    short               nColors;
    BYTE FAR *          lpBits;
    RGBQUAD FAR *       lpRgb;
    BYTE                xlat[256];
    DWORD               dwSize;
    PALETTEENTRY        pe;

    if (!hPalNew || !lpcs->lpBits || !lpcs->lpBitsInfo)
        return FALSE;

    lpbi   = &(lpcs->lpBitsInfo->bmiHeader);
    lpRgb  = (RGBQUAD FAR *)((LPSTR)lpbi + (UINT)lpbi->biSize);
    lpBits = lpcs->lpBits;

    GetObject(hPalNew, sizeof(short), (LPSTR) &nColors);
    if (nColors > 256)
        nColors = 256;

    // Get the palette entries regardless of the compression
    // Supermac uses non BI_RGB with a palette!

    if (lpbi->biBitCount == 8) {
        for (n=0; n<nColors; n++) {
            GetPaletteEntries(hPalNew, n, 1, &pe);
            lpRgb[n].rgbRed   = pe.peRed;
            lpRgb[n].rgbGreen = pe.peGreen;
            lpRgb[n].rgbBlue  = pe.peBlue;
        }
    }

    if (lpbi->biBitCount == 8 && lpbi->biCompression == BI_RGB) {

        //
        //  build a xlat table. from the old Palette to the new palette.
        //
        for (n=0; n<(int)lpbi->biClrUsed; n++) {
            xlat[n] = (BYTE)GetNearestPaletteIndex(hPalNew,
                RGB(lpRgb[n].rgbRed,lpRgb[n].rgbGreen,lpRgb[n].rgbBlue));
        }

        //
        // translate the DIB bits
        //
        if ((dwSize = lpbi->biSizeImage) == 0)
            dwSize = lpbi->biHeight * DIBWIDTHBYTES(*lpbi);

        switch ((WORD)lpbi->biCompression)
        {
            case BI_RGB:
                xlatClut8(lpBits, dwSize, xlat);
        }
    }

    // Fix for Supermac, force biClrUsed to the number of palette entries
    // even if non-BI_RGB formats.

    if (lpbi->biBitCount <= 8)
        lpbi->biClrUsed = nColors;

    return TRUE;
}


/* DibPaint(LPCAPSTREAM lpcs, hdc)
 *
 * Paint the current DIB into the window;
 */
void DibPaint(LPCAPSTREAM lpcs, HDC hdc)
{
    RECT        rc;
    BOOL        fOK;

    fOK = (lpcs->lpBits != NULL);

    if (fOK) {
        if (lpcs->fScale) {
            GetClientRect(lpcs->hwnd, &rc);
            fOK = DrawDibDraw(lpcs->hdd, hdc, 0, 0,
                  rc.right - rc.left, rc.bottom - rc.top,
                  (LPBITMAPINFOHEADER)lpcs->lpBitsInfo, lpcs->lpBits,
                   0, 0, -1, -1,
#if defined _WIN32 && defined UNICODE
		    0 	// we don't support BACKGROUNDPAL yet in drawdib
#else
		   DDF_BACKGROUNDPAL
#endif
		   );
        }
        else
            fOK = DrawDibDraw(lpcs->hdd, hdc, 0, 0,
                lpcs->dxBits, lpcs->dyBits,
                (LPBITMAPINFOHEADER)lpcs->lpBitsInfo, lpcs->lpBits,
                0, 0, -1, -1,
#if defined _WIN32 && defined UNICODE
		    0 	// we don't support BACKGROUNDPAL yet in drawdib
#else
		   DDF_BACKGROUNDPAL
#endif
		   );

    }
    if (!fOK) {
        SelectObject(hdc, GetStockObject(BLACK_BRUSH));
        GetClientRect(lpcs->hwnd, &rc);
        PatBlt(hdc, 0, 0, rc.right, rc.bottom, PATCOPY);
    }
}

/*
 *
 * CreatePackedDib() - return the current DIB in packed (ie CF_DIB) format
 *
 */

HANDLE CreatePackedDib (LPBITMAPINFO lpBitsInfo, LPSTR lpSrcBits, HPALETTE hPalette)
{
    HANDLE              hdib;
    LPBITMAPINFO        lpbi;
    int                 i;
    DWORD               dwSize;
    PALETTEENTRY        pe;
    LPBYTE              lpBits;
    RGBQUAD FAR *       lpRgb;

    // If the data is compressed, let ICM do the work for us...
    if (lpBitsInfo->bmiHeader.biCompression != BI_RGB &&
         lpBitsInfo->bmiHeader.biCompression != BI_RLE8 &&
        (lpBitsInfo->bmiHeader.biBitCount != 8 ||
         lpBitsInfo->bmiHeader.biBitCount != 24 )) {

        LPBITMAPINFO lpOutFormat = NULL;
        HANDLE hPackedDIBOut = NULL;

        if (!(lpOutFormat = (LPBITMAPINFO)GlobalAllocPtr(
                        GMEM_MOVEABLE, sizeof (BITMAPINFOHEADER) +
                        256 * sizeof (RGBQUAD))))
            return NULL;

        CopyMemory (lpOutFormat, lpBitsInfo, sizeof (BITMAPINFOHEADER));

        // Try to get an RGB format
        lpOutFormat->bmiHeader.biSize = sizeof (BITMAPINFOHEADER);
        lpOutFormat->bmiHeader.biCompression = BI_RGB;
        lpOutFormat->bmiHeader.biClrUsed = 0;
        lpOutFormat->bmiHeader.biClrImportant = 0;

        // Uh, oh, force to a 24-bit DIB if > 8 BPP
        if (lpBitsInfo->bmiHeader.biBitCount <= 8)
            lpOutFormat->bmiHeader.biBitCount = 8;
        else
            lpOutFormat->bmiHeader.biBitCount = 24;

        lpOutFormat->bmiHeader.biSizeImage =
                WIDTHBYTES (lpOutFormat->bmiHeader.biWidth *
                (lpOutFormat->bmiHeader.biBitCount == 8 ? 1 : 3)) *
                lpOutFormat->bmiHeader.biHeight;

        hPackedDIBOut = ICImageDecompress (
                NULL,           /*hic*/
                0,              /*uiFlags*/
                lpBitsInfo,     /*lpbiIn*/
                lpSrcBits,      /*lpBits*/
                lpOutFormat);   /*use default format chosen by compressor*/

        if (lpOutFormat)
            GlobalFreePtr (lpOutFormat);

        return (hPackedDIBOut);
    }

    dwSize = lpBitsInfo->bmiHeader.biSize +
              lpBitsInfo->bmiHeader.biClrUsed * sizeof(RGBQUAD) +
              lpBitsInfo->bmiHeader.biSizeImage;

    hdib = GlobalAlloc(GMEM_MOVEABLE, dwSize);

    if (!hdib)
         return NULL;

    lpbi = (LPVOID)GlobalLock(hdib);

    //
    // copy the header
    //
    CopyMemory (lpbi, lpBitsInfo, lpBitsInfo->bmiHeader.biSize);

    //
    // copy the color table
    //
    lpRgb  = (RGBQUAD FAR *)((LPSTR)lpbi + (WORD)lpbi->bmiHeader.biSize);
    for (i=0; i < (int)lpBitsInfo->bmiHeader.biClrUsed; i++) {
        GetPaletteEntries(hPalette, i, 1, &pe);
        lpRgb[i].rgbRed   = pe.peRed;
        lpRgb[i].rgbGreen = pe.peGreen;
        lpRgb[i].rgbBlue  = pe.peBlue;
        lpRgb[i].rgbReserved = 0;
    }

    //
    // copy the bits.
    //
    lpBits  =   (LPBYTE)lpbi +
                lpbi->bmiHeader.biSize +
                lpbi->bmiHeader.biClrUsed * sizeof(RGBQUAD);

    CopyMemory (lpBits, lpSrcBits,
                lpbi->bmiHeader.biSizeImage);

    GlobalUnlock (hdib);

    return hdib;
 }


 /*---------------------------------------------------------------------+
 | dibIsWritable() - return TRUE if the dib format is writable,                  |
 |                     by out dibWrite() function, FALSE if not.                 |
 |                                                                               |
 +---------------------------------------------------------------------*/
BOOL FAR PASCAL dibIsWritable (LPBITMAPINFO lpBitsInfo)
{
    if (!lpBitsInfo)
        return FALSE;

     // For now, just assume that all capture formats have an installed
     // codec which can convert to RGB.  In the future, each time the
     // format is changed, test that the codec actually accepts the format.

     return TRUE;
 }


 /*---------------------------------------------------------------------+
 | dibWrite() - write out the DIB to a file. The global header is       |
 |                in <glpBitsInfo> and the actual dib bits are in                |
 |                <glpBits>.  If it is palettized then the palette is in         |
 |                <ghPalCurrent>.                                                |
 |                                                                               |
 |  We won't do error reporting in this function, let the caller take   |
 |  care of that along with Opening and Closing the HMMIO.              |
 |                                                                               |
 +---------------------------------------------------------------------*/
BOOL FAR PASCAL dibWrite(LPCAPSTREAM lpcs, HMMIO hmmio)
 {
     BITMAPFILEHEADER   bfh;
     DWORD              dw;
     HANDLE             hPackedDib = NULL;
     LPBITMAPINFO       lpbi = NULL;
     BOOL               fOK = FALSE;

     /* do some checking */
    WinAssert(hmmio != 0);

    if (!lpcs->lpBits || !lpcs->lpBitsInfo)
        return FALSE;

    // Create a packed DIB, converting from a compressed format,
    // if necessary.
    hPackedDib = CreatePackedDib (lpcs->lpBitsInfo,
                        lpcs->lpBits,
                        lpcs->hPalCurrent);

    lpbi = (LPBITMAPINFO) GlobalLock (hPackedDib);

    if (!lpbi)
        goto WriteError;

    /* initialize the bitmap file header */
    bfh.bfType = 'B' | 'M' << 8;
    bfh.bfSize = sizeof(bfh) + sizeof(BITMAPINFOHEADER) +
        lpbi->bmiHeader.biSizeImage +
        (lpbi->bmiHeader.biBitCount > 8 ? 0 : (lpbi->bmiHeader.biClrUsed * sizeof(RGBQUAD)));

    bfh.bfReserved1 = bfh.bfReserved2 = 0;
    bfh.bfOffBits = bfh.bfSize - lpbi->bmiHeader.biSizeImage ;

    // dw is the size of the BITMAPINFO + color table + image
    dw = bfh.bfSize - sizeof(bfh);

    /* write out the file header portion */
    if (mmioWrite(hmmio, (HPSTR)&bfh, (LONG)sizeof(BITMAPFILEHEADER)) !=
                sizeof(BITMAPFILEHEADER)){
         goto WriteError;
    }

    /* now write out the header and bits */
    if (mmioWrite(hmmio, (HPSTR)lpbi, (LONG) dw) == (LONG) dw) {
         fOK = TRUE;
    }

WriteError:
    if (lpbi)
        GlobalUnlock (hPackedDib);
    if (hPackedDib)
        GlobalFree (hPackedDib);

    return fOK;
}

/*--------------------------------------------------------------+
| fileSaveDIB - save the frame as a DIB                         |
|   Top level routine to save a single frame                    |
+--------------------------------------------------------------*/
BOOL FAR PASCAL fileSaveDIB(LPCAPSTREAM lpcs, LPTSTR lpszFileName)
{
    HMMIO               hmmio;
    HCURSOR             hOldCursor;
    BOOL                fOK;

    hmmio = mmioOpen(lpszFileName, NULL, MMIO_WRITE);
    if( !hmmio ) {
	/* try and create */
        hmmio = mmioOpen(lpszFileName, NULL, MMIO_CREATE | MMIO_WRITE);
	if( !hmmio ) {
	    /* find out if the file was read only or we are just */
	    /* totally hosed up here.				 */
	    hmmio = mmioOpen(lpszFileName, NULL, MMIO_READ);
	    if (hmmio){
		/* file was read only, error on it */
                errorUpdateError (lpcs, IDS_CAP_READONLYFILE, (LPSTR)lpszFileName);
		mmioClose(hmmio, 0);
		return FALSE;
	    } else {
		/* even weirder error has occured here, give CANTOPEN */
                errorUpdateError (lpcs, IDS_CAP_CANTOPEN, (LPSTR) lpszFileName);
		return FALSE;
	    }
	}
    }

    hOldCursor = SetCursor( lpcs->hWaitCursor );

    mmioSeek(hmmio, 0, SEEK_SET);

    fOK = dibWrite(lpcs, hmmio);

    mmioClose( hmmio, 0 );

    SetCursor( hOldCursor );

    if (!fOK)
       errorUpdateError (lpcs, IDS_CAP_ERRORDIBSAVE, (LPSTR) lpszFileName);

    return fOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avicap\capframe.c ===
/****************************************************************************
 *
 *   capframe.c
 *
 *   Single frame capture
 *
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992, 1993 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and
 *    distribute the Sample Files (and/or any modified version) in
 *    any way you find useful, provided that you agree that
 *    Microsoft has no warranty obligations or liability for any
 *    Sample Application Files which are modified.
 *
 ***************************************************************************/

#define INC_OLE2
#pragma warning(disable:4103)
#include <windows.h>
#include <windowsx.h>
#include <win32.h>
#include <mmsystem.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <msvideo.h>
#include <drawdib.h>
#include <mmddk.h>
#include <avifmt.h>

#include "ivideo32.h"
#include "avicap.h"
#include "avicapi.h"

#include "mmdebug.h"

#ifdef _DEBUG
    #define DSTATUS(lpcs, sz) statusUpdateStatus(lpcs, IDS_CAP_INFO, (LPTSTR) TEXT(sz))
#else
    #define DSTATUS(lpcs, sz)
#endif


/*
 *  SingleFrameCaptureOpen
 *
 */
BOOL FAR PASCAL SingleFrameCaptureOpen (LPCAPSTREAM lpcs)
{
    UINT err;
    if ((lpcs->fCaptureFlags & CAP_fCapturingNow) || (lpcs->fCaptureFlags & CAP_fFrameCapturingNow)) {
        err = IDS_CAP_FILE_OPEN_ERROR;
        goto EarlyExit;
    }

#ifdef NEW_COMPMAN
    /* Warm up the compressor function */
    if (lpcs->CompVars.hic) {
        if (ICSeqCompressFrameStart(&lpcs->CompVars, lpcs->lpBitsInfo) == FALSE) {
            err = IDS_CAP_COMPRESSOR_ERROR;
            goto EarlyExit;
	}
        // Kludge, offset the lpBitsOut ptr
        // Compman allocates the compress buffer too large by
        // 2048 + 16 so we will still have room
        ((LPBYTE) lpcs->CompVars.lpBitsOut) += 8;
    }
#endif

    if (!CapFileInit(lpcs)) {
        err = IDS_CAP_FILE_OPEN_ERROR;
        goto EarlyExit;
    }

    lpcs->fCaptureFlags |= (CAP_fCapturingNow | CAP_fFrameCapturingNow);
    lpcs->dwReturn = DV_ERR_OK;

    statusUpdateStatus(lpcs, IDS_CAP_BEGIN);  // Always the first message

    return TRUE;

EarlyExit:
    errorUpdateError(lpcs, (UINT) err);
    return FALSE;
}


/*
 *  SingleFrameCaptureClose
 *
 *
 */
BOOL FAR PASCAL SingleFrameCaptureClose (LPCAPSTREAM lpcs)
{

    if ((!(lpcs->fCaptureFlags & CAP_fCapturingNow)) && (!(lpcs->fCaptureFlags & CAP_fFrameCapturingNow))) {
        errorUpdateError(lpcs, IDS_CAP_FILE_OPEN_ERROR);
        return FALSE;
    }

    AVIFileFini(lpcs, TRUE /* fWroteJunkChunks */, FALSE /* fAbort */);

#ifdef NEW_COMPMAN
    if (lpcs->CompVars.hic) {
        // Kludge, offset the lpBitsOut ptr
        if (lpcs->CompVars.lpBitsOut)
        ((LPBYTE) lpcs->CompVars.lpBitsOut) -= 8;
	ICSeqCompressFrameEnd(&lpcs->CompVars);
    }
#endif

    lpcs->fCapFileExists = (lpcs->dwReturn == DV_ERR_OK);
    lpcs->fCaptureFlags &= ~(CAP_fCapturingNow | CAP_fFrameCapturingNow);

    statusUpdateStatus(lpcs, IDS_CAP_END);  // Always the last message

    return TRUE;
}

/*
 *  SingleFrameCapture
 *
 *  Append to the open single frame capture file.
 */
BOOL FAR PASCAL SingleFrameCapture (LPCAPSTREAM lpcs)
{
    LPVIDEOHDR lpVidHdr = &lpcs->VidHdr;
    BOOL       fOK = FALSE;
    DWORD      dwBytesUsed;
    BOOL       fKeyFrame;
    LPSTR      lpData;

    if ((!(lpcs->fCaptureFlags & CAP_fCapturingNow)) ||
        (!((lpcs->fCaptureFlags & CAP_fStepCapturingNow) || (lpcs->fCaptureFlags & CAP_fFrameCapturingNow)))
        ) {
        errorUpdateError(lpcs, IDS_CAP_FILE_OPEN_ERROR);
        return FALSE;
    }

    videoFrame (lpcs->hVideoIn, &lpcs->VidHdr);
    InvalidateRect (lpcs->hwnd, NULL, TRUE);

    if (lpVidHdr->dwBytesUsed) {
        UINT wError;
        BOOL bPending = FALSE;

        if (lpcs->CallbackOnVideoFrame)
            lpcs->CallbackOnVideoFrame (lpcs->hwnd, lpVidHdr);

        // Prepend a RIFF chunk
        ((LPRIFF)lpVidHdr->lpData)[-1].dwType = MAKEAVICKID(cktypeDIBbits, 0);
        ((LPRIFF)lpVidHdr->lpData)[-1].dwSize = lpcs->VidHdr.dwBytesUsed;

       #ifdef NEW_COMPMAN
        //
        // We are automatically compressing during capture, so
        // compress the frame before we pass it on to be written
        //
        if (lpcs->CompVars.hic)
        {
            LPRIFF priff;

            dwBytesUsed = 0;
            lpData = ICSeqCompressFrame(&lpcs->CompVars, 0,
                                        lpVidHdr->lpData,
                                        &fKeyFrame,
                                        &dwBytesUsed);

            priff = ((LPRIFF)lpData) -1;
            priff->dwType = MAKEAVICKID(cktypeDIBbits, 0);
            priff->dwSize = dwBytesUsed;
        }
        else {
            lpData = lpVidHdr->lpData;
            dwBytesUsed = lpVidHdr->dwBytesUsed;
            fKeyFrame = lpVidHdr->dwFlags & VHDR_KEYFRAME;
        }
       #endif // NEW_COMPMAN

        // AVIWriteVideoFrame can compress while writing,
        // in this case, the dwBytesUsed and KeyFrame settings
        // may be modified, so pick these up after the write is finished

        AVIWriteVideoFrame (lpcs,
                        lpData,
                        dwBytesUsed,
                        fKeyFrame,
                        (UINT)-1, 0, &wError, &bPending);
        if (wError) {
            errorUpdateError(lpcs, wError);
        }
        else {
            fOK = TRUE;
            statusUpdateStatus (lpcs, IDS_CAP_STAT_CAP_L_FRAMES,
                                lpcs->dwVideoChunkCount);
        }
    } // if the frame is done
    else
        errorUpdateError (lpcs, IDS_CAP_RECORDING_ERROR2);

    return fOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avicap\capinit.c ===
/****************************************************************************
 *
 *   capinit.c
 *
 *   Initialization code.
 *
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992 - 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and
 *    distribute the Sample Files (and/or any modified version) in
 *    any way you find useful, provided that you agree that
 *    Microsoft has no warranty obligations or liability for any
 *    Sample Application Files which are modified.
 *
 ***************************************************************************/

#define INC_OLE2
#pragma warning(disable:4103)
#include <windows.h>
#include <windowsx.h>
#include <win32.h>

#define MODULE_DEBUG_PREFIX "AVICAP32\\"
#define _INC_MMDEBUG_CODE_ TRUE
#include "MMDEBUG.H"

#if !defined CHICAGO
 #include <ntverp.h>
#endif

#include <mmsystem.h>

#include <msvideo.h>
#include "ivideo32.h"
#include <drawdib.h>
#include "avicap.h"
#include "avicapi.h"

HINSTANCE ghInstDll;
TCHAR szCaptureWindowClass[] = TEXT("ClsCapWin");

#if !defined CHICAGO
  typedef struct tagVS_VERSION
  {
      WORD wTotLen;
      WORD wValLen;
      TCHAR szSig[16];
      VS_FIXEDFILEINFO vffInfo;
  } VS_VERSION;

  typedef struct tagLANGANDCP
  {
      WORD wLanguage;
      WORD wCodePage;
  } LANGANDCP;
#endif
BOOL gfIsRTL;

BOOL FAR PASCAL RegisterCaptureClass (HINSTANCE hInst)
{
    WNDCLASS cls;

    // If we're already registered, we're OK
    if (GetClassInfo(hInst, szCaptureWindowClass, &cls))
	return TRUE;

    cls.hCursor           = LoadCursor(NULL, IDC_ARROW);
    cls.hIcon             = NULL;
    cls.lpszMenuName      = NULL;
    cls.lpszClassName     = szCaptureWindowClass;
    cls.hbrBackground     = (HBRUSH)(COLOR_APPWORKSPACE + 1);
    cls.hInstance         = hInst;
    cls.style             = CS_HREDRAW|CS_VREDRAW | CS_BYTEALIGNCLIENT |
                            CS_GLOBALCLASS | CS_DBLCLKS;
    cls.lpfnWndProc       = (WNDPROC) CapWndProc;
    cls.cbClsExtra        = 0;
    // Kludge, VB Status and Error GlobalAlloc'd ptrs + room to grow...
    cls.cbWndExtra        = sizeof (LPCAPSTREAM) + sizeof (DWORD) * 4;

    RegisterClass(&cls);

    return TRUE;
}

//
// Internal version
// Get the name and version of the video device
//
BOOL capInternalGetDriverDesc (UINT wDriverIndex,
        LPTSTR lpszName, int cbName,
        LPTSTR lpszVer, int cbVer)
{
   #ifdef CHICAGO
    // This calls into 16-bit AVICAP via a thunk
    return (BOOL) capxGetDriverDescription ((WORD) wDriverIndex,
                lpszName, (WORD) cbName,
                lpszVer, (WORD) cbVer);
   #else
    LPTSTR  lpVersion;
    UINT    wVersionLen;
    BOOL    bRetCode;
    TCHAR   szGetName[MAX_PATH];
    DWORD   dwVerInfoSize;
    DWORD   dwVerHnd;
    TCHAR   szBuf[MAX_PATH];
    BOOL    fGetName;
    BOOL    fGetVersion;

    const static TCHAR szNull[]        = TEXT("");
    const static TCHAR szVideo[]       = TEXT("msvideo");
    const static TCHAR szSystemIni[]   = TEXT("system.ini");
    const static TCHAR szDrivers[]     = TEXT("Drivers32");
          static TCHAR szKey[sizeof(szVideo)/sizeof(TCHAR) + 2];

    fGetName = lpszName != NULL && cbName != 0;
    fGetVersion = lpszVer != NULL && cbVer != 0;

    if (fGetName)
        lpszName[0] = TEXT('\0');
    if (fGetVersion)
        lpszVer [0] = TEXT('\0');

    lstrcpy(szKey, szVideo);
    szKey[sizeof(szVideo)/sizeof(TCHAR) - 1] = TEXT('\0');
    if( wDriverIndex > 0 ) {
        szKey[sizeof(szVideo)/sizeof(TCHAR)] = TEXT('\0');
        szKey[(sizeof(szVideo)/sizeof(TCHAR))-1] = (TCHAR)(TEXT('1') + (wDriverIndex-1) );  // driver ordinal
    }

    if (GetPrivateProfileString(szDrivers, szKey, szNull,
                szBuf, sizeof(szBuf)/sizeof(TCHAR), szSystemIni) < 2)
        return FALSE;

    // Copy in the driver name initially, just in case the driver
    // has omitted a description field.
    if (fGetName)
        lstrcpyn(lpszName, szBuf, cbName);

    // You must find the size first before getting any file info
    dwVerInfoSize = GetFileVersionInfoSize(szBuf, &dwVerHnd);

    if (dwVerInfoSize) {
        LPTSTR   lpstrVffInfo;             // Pointer to block to hold info
        HANDLE  hMem;                     // handle to mem alloc'ed

        // Get a block big enough to hold version info
        hMem          = GlobalAlloc(GMEM_MOVEABLE, dwVerInfoSize);
        lpstrVffInfo  = GlobalLock(hMem);

        // Get the File Version first
        if (GetFileVersionInfo(szBuf, 0L, dwVerInfoSize, lpstrVffInfo)) {
             VS_VERSION FAR *pVerInfo = (VS_VERSION FAR *) lpstrVffInfo;

             // fill in the file version
             wsprintf(szBuf,
                      TEXT("Version:  %d.%d.%d.%d"),
                      HIWORD(pVerInfo->vffInfo.dwFileVersionMS),
                      LOWORD(pVerInfo->vffInfo.dwFileVersionMS),
                      HIWORD(pVerInfo->vffInfo.dwFileVersionLS),
                      LOWORD(pVerInfo->vffInfo.dwFileVersionLS));
             if (fGetVersion)
                lstrcpyn (lpszVer, szBuf, cbVer);
        }

        // Now try to get the FileDescription
        // First try this for the "Translation" entry, and then
        // try the American english translation.
        // Keep track of the string length for easy updating.
        // 040904E4 represents the language ID and the four
        // least significant digits represent the codepage for
        // which the data is formatted.  The language ID is
        // composed of two parts: the low ten bits represent
        // the major language and the high six bits represent
        // the sub language.

        lstrcpy(szGetName, TEXT("\\StringFileInfo\\040904E4\\FileDescription"));

        wVersionLen   = 0;
        lpVersion     = NULL;

        // Look for the corresponding string.
        bRetCode      =  VerQueryValue((LPVOID)lpstrVffInfo,
                        (LPTSTR)szGetName,
                        (void FAR* FAR*)&lpVersion,
                        (UINT FAR *) &wVersionLen);

        if (fGetName && bRetCode && wVersionLen && lpVersion)
           lstrcpyn (lpszName, lpVersion, cbName);

        // Let go of the memory
        GlobalUnlock(hMem);
        GlobalFree(hMem);
    }
    return TRUE;
   #endif
}

#ifdef UNICODE
// ansi thunk for above (called from ansi thunk functions
// for capGetDriverDescriptionA, and WM_GET_DRIVER_NAMEA etc)
BOOL capInternalGetDriverDescA(UINT wDriverIndex,
        LPSTR lpszName, int cbName,
        LPSTR lpszVer, int cbVer)
{
    LPWSTR pName = NULL, pVer = NULL;
    BOOL bRet;

    if (lpszName) {
        pName = LocalAlloc(LPTR, cbName * sizeof(WCHAR));
    }

    if (lpszVer) {
        pVer = LocalAlloc(LPTR, cbVer * sizeof(WCHAR));
    }

    bRet = capInternalGetDriverDesc(
            wDriverIndex,
            pName, cbName,
            pVer, cbVer);

    if (lpszName) {
        WideToAnsi(lpszName, pName, cbName);
    }

    if (lpszVer) {
        WideToAnsi(lpszVer, pVer, cbVer);
    }

    if (pVer) {
        LocalFree(pVer);
    }

    if (pName) {
        LocalFree(pName);
    }

    return bRet;
}
#endif


//
// Exported version
// Get the name and version of the video device
//
// unicode and win-16 version - see ansi thunk below
BOOL VFWAPI capGetDriverDescription (UINT wDriverIndex,
        LPTSTR lpszName, int cbName,
        LPTSTR lpszVer, int cbVer)
{
    return (capInternalGetDriverDesc (wDriverIndex,
        lpszName, cbName,
        lpszVer, cbVer));
}

#ifdef UNICODE
// ansi thunk for above
BOOL VFWAPI capGetDriverDescriptionA(UINT wDriverIndex,
        LPSTR lpszName, int cbName,
        LPSTR lpszVer, int cbVer)
{
    return capInternalGetDriverDescA(wDriverIndex,
        lpszName, cbName, lpszVer, cbVer);
}
#endif


//
// Disconnect from hardware resources
//
BOOL CapWinDisconnectHardware(LPCAPSTREAM lpcs)
{
    if( lpcs->hVideoCapture ) {
        videoStreamFini (lpcs->hVideoCapture);
        videoClose( lpcs->hVideoCapture );
    }
    if( lpcs->hVideoDisplay ) {
        videoStreamFini (lpcs->hVideoDisplay);
        videoClose( lpcs->hVideoDisplay );
    }
    if( lpcs->hVideoIn ) {
        videoClose( lpcs->hVideoIn );
    }

    lpcs->fHardwareConnected = FALSE;

    lpcs->hVideoCapture = NULL;
    lpcs->hVideoDisplay = NULL;
    lpcs->hVideoIn = NULL;

    lpcs->sCapDrvCaps.fHasDlgVideoSource = FALSE;
    lpcs->sCapDrvCaps.fHasDlgVideoFormat = FALSE;
    lpcs->sCapDrvCaps.fHasDlgVideoDisplay = FALSE;
    lpcs->sCapDrvCaps.fHasDlgVideoDisplay = FALSE;
    lpcs->sCapDrvCaps.fHasOverlay = FALSE;
    lpcs->sCapDrvCaps.fDriverSuppliesPalettes = FALSE;

    lpcs->sCapDrvCaps.hVideoIn          = NULL;
    lpcs->sCapDrvCaps.hVideoOut         = NULL;
    lpcs->sCapDrvCaps.hVideoExtIn       = NULL;
    lpcs->sCapDrvCaps.hVideoExtOut      = NULL;

    return TRUE;
}

//
// Connect to hardware resources
// Return: TRUE if hardware connected to the stream
//
BOOL CapWinConnectHardware (LPCAPSTREAM lpcs, UINT wDeviceIndex)
{
    DWORD dwError;
    CHANNEL_CAPS VideoCapsExternalOut;
    TCHAR ach1[MAX_PATH];
    TCHAR ach2[MAX_PATH * 3];
    CAPINFOCHUNK cic;
    HINSTANCE hInstT;

    lpcs->hVideoCapture = NULL;
    lpcs->hVideoDisplay = NULL;
    lpcs->hVideoIn = NULL;
    lpcs->fHardwareConnected = FALSE;
    lpcs->fUsingDefaultPalette = TRUE;
    lpcs->sCapDrvCaps.fHasDlgVideoSource = FALSE;
    lpcs->sCapDrvCaps.fHasDlgVideoFormat = FALSE;
    lpcs->sCapDrvCaps.fHasDlgVideoDisplay = FALSE;
    lpcs->sCapDrvCaps.wDeviceIndex = wDeviceIndex;

    // Clear any existing capture device name chunk
    cic.fccInfoID = mmioFOURCC ('I','S','F','T');
    cic.lpData = NULL;
    cic.cbData = 0;
    SetInfoChunk (lpcs, &cic);

    // try and open the video hardware!!!
    if( !(dwError = videoOpen( &lpcs->hVideoIn, wDeviceIndex, VIDEO_IN ) ) ) {
        if( !(dwError = videoOpen( &lpcs->hVideoCapture, wDeviceIndex, VIDEO_EXTERNALIN ) ) ) {
            // We don't require the EXTERNALOUT channel,
            // but do require EXTERNALIN and IN
            videoOpen( &lpcs->hVideoDisplay, wDeviceIndex, VIDEO_EXTERNALOUT );
            if( (!dwError) && lpcs->hVideoCapture && lpcs->hVideoIn ) {

                lpcs->fHardwareConnected = TRUE;
                capInternalGetDriverDesc (wDeviceIndex,
                        ach1, sizeof (ach1) / sizeof(TCHAR),
                        ach2, sizeof (ach2) / sizeof(TCHAR));
                lstrcat (ach1, TEXT(", "));
                lstrcat (ach1, ach2);

                statusUpdateStatus (lpcs, IDS_CAP_INFO, (LPTSTR) ach1);

                // Make a string of the current task and capture driver
                ach2[0] = '\0';
                if (hInstT = GetWindowInstance (GetParent(lpcs->hwnd)))
                    GetModuleFileName (hInstT, ach2, sizeof (ach2)/sizeof(TCHAR));
                lstrcat (ach2, TEXT(" -AVICAP32- "));
                lstrcat (ach2, ach1);

                // Set software chunk with name of capture device
                if (*ach2) {
                    cic.lpData = ach2;
                    cic.cbData = lstrlen(ach2) + 1;
                    SetInfoChunk (lpcs, &cic);
                }
            }
        }
    }
    if (dwError)
        errorDriverID (lpcs, dwError);

    if(!lpcs->fHardwareConnected) {
       CapWinDisconnectHardware(lpcs);
    }
    else {
        if (lpcs->hVideoDisplay && videoGetChannelCaps (lpcs->hVideoDisplay,
                &VideoCapsExternalOut,
                sizeof (CHANNEL_CAPS)) == DV_ERR_OK) {
            lpcs->sCapDrvCaps.fHasOverlay = (BOOL)(VideoCapsExternalOut.dwFlags &
                (DWORD)VCAPS_OVERLAY);
        }
        else
             lpcs->sCapDrvCaps.fHasOverlay = FALSE;
        // if the hardware doesn't support it, make sure we don't enable
        if (!lpcs->sCapDrvCaps.fHasOverlay)
            lpcs->fOverlayWindow = FALSE;

       // Start the external in channel streaming continuously
       videoStreamInit (lpcs->hVideoCapture, 0L, 0L, 0L, 0L);
    } // end if hardware is available

#if 0
    // if we don't have a powerful machine, disable capture
    if (GetWinFlags() & (DWORD) WF_CPU286)
       CapWinDisconnectHardware(lpcs);
#endif

    if (!lpcs->fHardwareConnected){
        lpcs->fLiveWindow = FALSE;
        lpcs->fOverlayWindow = FALSE;
    }

    if (lpcs->hVideoIn)
        lpcs->sCapDrvCaps.fHasDlgVideoFormat = !videoDialog (lpcs->hVideoIn,
                        lpcs->hwnd, VIDEO_DLG_QUERY);

    if (lpcs->hVideoCapture)
         lpcs->sCapDrvCaps.fHasDlgVideoSource = !videoDialog (lpcs->hVideoCapture,
                        lpcs->hwnd, VIDEO_DLG_QUERY);

    if (lpcs->hVideoDisplay)
         lpcs->sCapDrvCaps.fHasDlgVideoDisplay = !videoDialog (lpcs->hVideoDisplay,
                        lpcs->hwnd, VIDEO_DLG_QUERY);

    // these handles are not supported on WIN32 for the good reason that
    // the videoXXX api set is not published for 32-bit
    // we might want to make use of the handles ourselves...???
    lpcs->sCapDrvCaps.hVideoIn          = NULL;
    lpcs->sCapDrvCaps.hVideoOut         = NULL;
    lpcs->sCapDrvCaps.hVideoExtIn       = NULL;
    lpcs->sCapDrvCaps.hVideoExtOut      = NULL;

    return lpcs->fHardwareConnected;
}



//
// Creates a child window of the capture class
// Normally:
//   Set lpszWindowName to NULL
//   Set dwStyle to WS_CHILD | WS_VISIBLE
//   Set hmenu to a unique child id

// Unicode and Win-16 version. See ansi thunk below
HWND VFWAPI capCreateCaptureWindow (
        LPCTSTR lpszWindowName,
        DWORD dwStyle,
        int x, int y, int nWidth, int nHeight,
        HWND hwndParent, int nID)
{
    DWORD   dwExStyle;

    dwExStyle = gfIsRTL ? WS_EX_LEFTSCROLLBAR | WS_EX_RIGHT | WS_EX_RTLREADING : 0;
    RegisterCaptureClass(ghInstDll);

#ifdef USE_AVIFILE
    AVIFileInit();
#endif

    return CreateWindowEx(dwExStyle,
                szCaptureWindowClass,
                lpszWindowName,
                dwStyle,
                x, y, nWidth, nHeight,
                hwndParent, (HMENU) nID,
                ghInstDll,
                NULL);
}

#ifdef UNICODE
// ansi thunk
HWND VFWAPI capCreateCaptureWindowA (
                LPCSTR lpszWindowName,
                DWORD dwStyle,
                int x, int y, int nWidth, int nHeight,
                HWND hwndParent, int nID)
{
    LPWSTR pw;
    int chsize;
    HWND hwnd;

    if (lpszWindowName == NULL) {
        pw = NULL;
    } else {
        // remember the null
        chsize = lstrlenA(lpszWindowName) + 1;
        pw = LocalLock(LocalAlloc(LPTR, chsize * sizeof(WCHAR)));

        AnsiToWide(pw, lpszWindowName, chsize);
    }

    hwnd = capCreateCaptureWindowW(pw, dwStyle, x, y, nWidth, nHeight,
                hwndParent, nID);

    if (pw != NULL) {
        LocalFree(LocalHandle(pw));
    }
    return(hwnd);
}
#endif


#ifdef CHICAGO

static char pszDll16[] = "AVICAP.DLL";
static char pszDll32[] = "AVICAP32.DLL";

BOOL PASCAL avicapf_ThunkConnect32(LPCSTR pszDll16, LPCSTR pszDll32, HINSTANCE hinst, DWORD dwReason);

BOOL WINAPI DllMain(
    HANDLE hInstance,
    DWORD  dwReason,
    LPVOID reserved)
{
    #if defined DEBUG || defined DEBUG_RETAIL
    DebugSetOutputLevel (GetProfileInt ("Debug", "Avicap32", 0));
    AuxDebugEx (1, DEBUGLINE "DllEntryPoint, %08x,%08x,%08x\r\n", hInstance, dwReason, reserved);
    #endif

    if (dwReason == DLL_PROCESS_ATTACH)
    {
        char   ach[2];
        ghInstDll = hInstance;

        LoadString(ghInstDll, IDS_CAP_RTL, ach, sizeof(ach));
        gfIsRTL = ach[0] == TEXT('1');

        // INLINE_BREAK;
        if (!avicapf_ThunkConnect32(pszDll16, pszDll32, hInstance, dwReason))
            return FALSE;

       #if defined _WIN32 && defined CHICAGO
        // we do this so that we can Get LinPageLock & PageAllocate services
        //
        ;
//        OpenMMDEVLDR();
       #endif

    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {

       #if defined _WIN32 && defined CHICAGO
       ;
//        CloseMMDEVLDR();
       #endif

        return avicapf_ThunkConnect32(pszDll16, pszDll32, hInstance, dwReason);
    }

    return TRUE;
}

#else // this is the NT dll entry point

static char szMSVIDEO[] = "MSVideo";

BOOL DllInstanceInit(HANDLE hInstance, DWORD dwReason, LPVOID reserved)
{
#if 0
    static BOOL bFixedUp = FALSE;
#endif

    if (dwReason == DLL_PROCESS_ATTACH) {
	TCHAR  ach[2];
#if 0
// this hack has been superceded by correct thunking of capGetDriverDescription
// in an nt-supplied 16-bit avicap.dll
	if (!bFixedUp) {
	    HKEY hkey16=NULL;
	    HKEY hkey32=NULL;
	    char achValue[256];
	    DWORD dwType, cbValue = sizeof(achValue);

	    // In order to get 16 bit capture applications to work, a 16 bit
	    // application must believe that there is a capture driver
	    // installed.  Because these applications look in the 16 bit
	    // registry (equates to INI file) then we fudge the situation.
	    // IF there is no information on the 16 bit side, BUT we have
	    // installed a 32 bit driver, then copy the 32 bit driver
	    // information to the 16 bit registry.  Note: this does NOT mean
	    // that the capture will happen in 16 bit.  The 32 bit code will
	    // still get invoked to do the capture.

	    RegCreateKeyA(HKEY_LOCAL_MACHINE,
		"Software\\Microsoft\\Windows NT\\CurrentVersion\\Drivers",
		&hkey16);

	    RegOpenKeyA(HKEY_LOCAL_MACHINE,
		    "Software\\Microsoft\\Windows NT\\CurrentVersion\\Drivers32",
		    &hkey32);

	    if (hkey16 && hkey32) {
		LONG result =
		    RegQueryValueExA(
		    hkey16,
		    szMSVIDEO,
		    NULL,
		    &dwType,
		    achValue,
		    &cbValue);

		// If there is no value stored in the 16 bit section of the
		// registry (equates to INI file) then see if we have a
		// 32 bit driver installed.
		if ((result != ERROR_SUCCESS) && (result != ERROR_MORE_DATA)) {
                    cbValue = sizeof(achValue);
		    if (RegQueryValueExA(
			hkey32,
			szMSVIDEO,
			NULL,
			&dwType,
			achValue,
			&cbValue) == ERROR_SUCCESS) {

			// there is a 32-bit MSVideo and no 16-bit MSVideo -
			// write the 32-bit one into the 16-bit list so that
			// capGetDriverDescription will work
			// cbValue will be set correctly from the previous
			// query call
			RegSetValueExA(
			    hkey16,
			    szMSVIDEO,
			    0,
			    dwType,
			    achValue,
			    cbValue);
		    }
		}
	    }

	    if (hkey16) {
		RegCloseKey(hkey16);
	    }
	    if (hkey32) {
		RegCloseKey(hkey32);
	    }
	    bFixedUp = TRUE;
	}
#endif

	ghInstDll = hInstance;
	DisableThreadLibraryCalls(hInstance);
        LoadString(ghInstDll, IDS_CAP_RTL, ach, NUMELMS(ach));
        gfIsRTL = ach[0] == TEXT('1');
	DebugSetOutputLevel (GetProfileIntA("Debug", "Avicap32", 0));
        videoInitHandleList();
    } else if (dwReason == DLL_PROCESS_DETACH) {
        videoDeleteHandleList();
    }
    return TRUE;
}

#endif // CHICAGO / NT dll entry point
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avicap\capfile.c ===
/****************************************************************************
 *
 *   capfile.c
 *
 *   AVI file writing module.
 *
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992 - 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and
 *    distribute the Sample Files (and/or any modified version) in
 *    any way you find useful, provided that you agree that
 *    Microsoft has no warranty obligations or liability for any
 *    Sample Application Files which are modified.
 *
 ***************************************************************************/

#define INC_OLE2
#pragma warning(disable:4103)
#include <windows.h>
#include <windowsx.h>
#include <win32.h>
#include <mmsystem.h>
#include <msvideo.h>
#include <avifmt.h>
#include <drawdib.h>

#include "ivideo32.h"
#include "avicap.h"
#include "avicapi.h"


/*----------------------------------------------------------------------+
| fileCapFileIsAVI() - Returns TRUE if the capture file is a valid AVI  |
|                                                                       |
+----------------------------------------------------------------------*/
BOOL FAR PASCAL fileCapFileIsAVI (LPTSTR lpsz)
{
    BOOL        fReturn = TRUE;
    HMMIO       hmmioSource = NULL;
    MMCKINFO    ckRIFF;

    // Does the file exist?
    hmmioSource = mmioOpen(lpsz, NULL, MMIO_READ);
    if (!hmmioSource)
        return FALSE;

    // Is there an AVI RIFF chunk?
    // !!! Don't do a FINDRIFF for an AVI chunk or it'll take several minutes to
    // !!! come back from checking a really big file
    fReturn = (mmioDescend(hmmioSource, &ckRIFF, NULL, 0) == 0) &&
		(ckRIFF.ckid == FOURCC_RIFF) &&
		(ckRIFF.fccType == formtypeAVI);

    if (hmmioSource)
        mmioClose(hmmioSource, 0);

    return fReturn;
}

/*----------------------------------------------------------------------+
| fileSaveCopy() - save a copy of the current capture file.             |
|                                                                       |
+----------------------------------------------------------------------*/
BOOL FAR PASCAL fileSaveCopy(LPCAPSTREAM lpcs)
{
#define INITFILE_BUFF_SIZE  (1024L * 256L)
    BOOL        fReturn = TRUE;
    char        achCaption[80]; // caption on Open File dialog

    HMMIO       hmmioSource = NULL, hmmioDest = NULL;
    LONG        lFileSize, lFileSizeTotal, lTemp;
    HANDLE      hMem = NULL;
    LPBYTE      lpstr = NULL;
    LONG        lBuffSize = INITFILE_BUFF_SIZE;
    MMCKINFO    ckRIFF;
    HCURSOR     hOldCursor;

    UpdateWindow(lpcs->hwnd);             // Make everything pretty

    hOldCursor = SetCursor( lpcs->hWaitCursor );
    if (0 == lstrcmpi(lpcs->achSaveAsFile, lpcs->achFile)) {
        // IF the source and destination names are the same, then there
        // is nothing to do
        return(TRUE);
    }


    /* grab a big buffer to xfer the file in, start the */
    /* buffer size at 32K and hope we get that much.    */
TRYAGAIN:
    hMem = GlobalAlloc(GMEM_MOVEABLE, lBuffSize);
    if (!hMem){
        /* we don't have this much mem, go for half that */
        lBuffSize /= 2;
        if (lBuffSize)
            goto TRYAGAIN;
        else {
            fReturn = FALSE;
            goto SAVECOPYOUT;
        }
    }

    /* open up the source file and find the size                       */
    /* Open the source first in case source==destination. Despite the  */
    /* test above this may still be the case (consider two net use     */
    /* commands to the same share point with different drive letters). */
    /* When we open the destination we truncate the file, which will   */
    /* lose any existing data.                                         */
    hmmioSource = mmioOpen(lpcs->achFile, NULL, MMIO_READ | MMIO_DENYWRITE);
    if (!hmmioSource){
        /* we are totally hosed here, the source file can't even */
        /* be opened up, error out.              */
        errorUpdateError (lpcs, IDS_CAP_CANTOPEN, (LPTSTR)lpcs->achFile);
        fReturn = FALSE;
        goto SAVECOPYOUT;
    }

    /* let's go and create the destination file */

    hmmioDest = mmioOpen(lpcs->achSaveAsFile, NULL, MMIO_CREATE|MMIO_WRITE);
    if (!hmmioDest){
        /* we've got an error of some kind here, let's bail out */
        /* on this one.                     */
        errorUpdateError (lpcs, IDS_CAP_CANTOPEN, (LPTSTR)lpcs->achSaveAsFile);
        fReturn = FALSE;
        goto SAVECOPYOUT;
    }


    /* go down to the RIFF chunk and find out the size of this  */
    /* thing.  If there is no RIFF chunk then we can safely */
    /* assume that the file is of 0 length.         */
    ckRIFF.fccType = formtypeAVI;
    if (mmioDescend(hmmioSource, &ckRIFF, NULL, MMIO_FINDRIFF) != 0){
        /* we are done, this file has no RIFF chunk so it's size */
        /* is 0 bytes.  Just close up and leave.         */
        goto SAVECOPYOUT;
    } else {
        /* there is a RIFF chunk, get the size of the file and  */
        /* get back to the start of the file.           */
        lFileSizeTotal = lFileSize = ckRIFF.cksize + 8;
        mmioAscend(hmmioSource, &ckRIFF, 0);
        mmioSeek(hmmioSource, 0L, SEEK_SET);
    }

    /* Before trying to write, seek to the end of the destination  */
    /* file and write one byte.  This both preallocates the file,  */
    /* and confirms enough disk is available for the copy, without */
    /* going through the trial and error of writing each byte.     */

    mmioSeek( hmmioDest, lFileSizeTotal - 1, SEEK_SET );
    mmioWrite( hmmioDest, (HPSTR) achCaption, 1L );
    if (mmioSeek (hmmioDest, 0, SEEK_END) < lFileSizeTotal) {

        /* Notify user with message that disk may be full. */
        errorUpdateError (lpcs, IDS_CAP_WRITEERROR, (LPTSTR)lpcs->achSaveAsFile);

        /* close the file and delete it */
        mmioClose(hmmioDest, 0);
        mmioOpen(lpcs->achSaveAsFile, NULL, MMIO_DELETE);
        hmmioDest = NULL;
        fReturn = FALSE;
        goto SAVECOPYOUT;
    }

    mmioSeek (hmmioDest, 0L, SEEK_SET); // Back to the beginning

    UpdateWindow(lpcs->hwnd);             // Make everything pretty

    hOldCursor = SetCursor( lpcs->hWaitCursor );


    /* lock our buffer and start xfering data */
    lpstr = GlobalLock(hMem);
    if (!lpstr) {
        fReturn = FALSE;
        goto SAVECOPYOUT;
    }

    while (lFileSize > 0) {

        if (lFileSize < lBuffSize)
            lBuffSize = lFileSize;
        mmioRead(hmmioSource, (HPSTR)lpstr, lBuffSize);
        if (mmioWrite(hmmioDest, (HPSTR)lpstr, lBuffSize) <= 0) {
            /* we got a write error on the file, error on it */
            errorUpdateError (lpcs, IDS_CAP_WRITEERROR, (LPTSTR)lpcs->achSaveAsFile);

            /* close the file and delete it */
            mmioClose(hmmioDest, 0);
            mmioOpen(lpcs->achSaveAsFile, NULL, MMIO_DELETE);
            hmmioDest = NULL;
            fReturn = FALSE;
            goto SAVECOPYOUT0;
        }

        // Let the user hit escape to get out
        if (GetAsyncKeyState(VK_ESCAPE) & 0x0001) {
            /* close the file and delete it */
            mmioClose(hmmioDest, 0);
            mmioOpen(lpcs->achSaveAsFile, NULL, MMIO_DELETE);
            hmmioDest = NULL;
            goto SAVECOPYOUT0;
        }

        lFileSize -= lBuffSize;

        // lTemp is percentage complete
        lTemp = MulDiv (lFileSizeTotal - lFileSize, 100L, lFileSizeTotal);
        statusUpdateStatus (lpcs, IDS_CAP_SAVEASPERCENT, lTemp);

        Yield();
    } // endwhile more bytes to copy

SAVECOPYOUT:
SAVECOPYOUT0:
    SetCursor( hOldCursor );

    /* close files, free up mem, restore cursor and get out */
    if (hmmioSource) mmioClose(hmmioSource, 0);
    if (hmmioDest){
        mmioSeek(hmmioDest, 0L, SEEK_END);
        mmioClose(hmmioDest, 0);
    }
    if (hMem) {
        if (lpstr) {
            GlobalUnlock(hMem);
        }
        GlobalFree(hMem);
    }
    statusUpdateStatus (lpcs, 0);
    return fReturn;
}


/*--------------------------------------------------------------+
| fileAllocCapFile - allocate the capture file			|
|								|
+--------------------------------------------------------------*/
BOOL FAR PASCAL fileAllocCapFile(LPCAPSTREAM lpcs, DWORD dwNewSize)
{
    BOOL        fOK = FALSE;
    HMMIO       hmmio;
    UINT	w;
    HCURSOR     hOldCursor;

    lpcs->fCapFileExists = FALSE;
    hmmio = mmioOpen(lpcs->achFile, NULL, MMIO_WRITE);
    if( !hmmio ) {
	/* try and create */
        hmmio = mmioOpen(lpcs-> achFile, NULL,
		MMIO_CREATE | MMIO_WRITE);
	if( !hmmio ) {
	    /* find out if the file was read only or we are just */
	    /* totally hosed up here.				 */
	    hmmio = mmioOpen(lpcs-> achFile, NULL, MMIO_READ);
	    if (hmmio){
		/* file was read only, error on it */
                errorUpdateError (lpcs, IDS_CAP_READONLYFILE, (LPTSTR)lpcs-> achFile);
		mmioClose(hmmio, 0);
		return FALSE;
	    } else {
		/* even weirder error has occured here, give CANTOPEN */
                errorUpdateError (lpcs, IDS_CAP_CANTOPEN, (LPTSTR) lpcs-> achFile);
		return FALSE;
	    }
	}
    }

    /* find the size */
    lpcs-> lCapFileSize = mmioSeek(hmmio, 0L, SEEK_END);

    if( dwNewSize == 0 )
        dwNewSize = 1;
	    	
    lpcs-> lCapFileSize = dwNewSize;
    hOldCursor = SetCursor( lpcs-> hWaitCursor );

    // Delete the existing file so we can recreate to the correct size
    mmioClose(hmmio, 0);	// close the file before deleting
    mmioOpen(lpcs-> achFile, NULL, MMIO_DELETE);

    /* now create a new file with that name */
    hmmio = mmioOpen(lpcs-> achFile, NULL, MMIO_CREATE | MMIO_WRITE);
    if( !hmmio ) {
        return FALSE;
    }

    /*
     * rather than just leaving the allocated space as garbage, we
     * create it as a junk filler chunk
     */
    {
        MMCKINFO ck;

        ck.ckid = mmioFOURCC('J', 'U', 'N', 'K');
        ck.cksize = dwNewSize - 8L;
        fOK = (mmioCreateChunk(hmmio, &ck, 0) == 0);
        fOK &= (mmioSeek(hmmio, dwNewSize - 9, SEEK_CUR) == (LONG)dwNewSize-1);
        fOK &= (mmioWrite( hmmio, (HPSTR) &w, 1L ) == 1);
        mmioAscend(hmmio, &ck, 0);
    }


    mmioClose( hmmio, 0 );

    SetCursor( hOldCursor );

    if (!fOK)
        errorUpdateError (lpcs, IDS_CAP_NODISKSPACE);

    return fOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avicap\capio.c ===
/****************************************************************************
 *
 *   capio.c
 *
 *   i/o routines for video capture
 *
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992 - 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and
 *    distribute the Sample Files (and/or any modified version) in
 *    any way you find useful, provided that you agree that
 *    Microsoft has no warranty obligations or liability for any
 *    Sample Application Files which are modified.
 *
 ***************************************************************************/

//#define USE_AVIFILE 1
#define JMK_HACK_DONTWRITE TRUE

#define INC_OLE2
#pragma warning(disable:4103)
#include <windows.h>
#include <windowsx.h>
#include <win32.h>
#include <mmsystem.h>
#include <msvideo.h>
#include <drawdib.h>
#include <mmreg.h>
#include <mmddk.h>

#include "ivideo32.h"
#include "mmdebug.h"

#ifdef USE_ACM
#include <msacm.h>
#endif

#include <avifmt.h>
#include "avicap.h"
#include "avicapi.h"
#include "time.h"

extern UINT GetSizeOfWaveFormat (LPWAVEFORMATEX lpwf);
STATICFN BOOL IndexVideo (LPCAPSTREAM lpcs, DWORD dwSize, BOOL bKeyFrame);
STATICFN BOOL IndexAudio (LPCAPSTREAM lpcs, DWORD dwSize);

#ifdef _DEBUG
    #define DSTATUS(lpcs, sz) statusUpdateStatus(lpcs, IDS_CAP_INFO, (LPTSTR) TEXT(sz))
#else
    #define DSTATUS(lpcs, sz)
#endif

#ifdef USE_AVIFILE
VOID WINAPI AVIPreloadFat (LPCAPSTREAM lpcs)
{
    return;
}

// Add an index entry for an audio buffer
// dwSize is the size of data ONLY, not including the chunk or junk
// Returns: TRUE if index space is not exhausted
//
STATICFN BOOL IndexAudio (LPCAPSTREAM lpcs, DWORD dwSize)
{
    ++lpcs->dwWaveChunkCount;
    return TRUE;
}

// Add an index entry for a video frame
// dwSize is the size of data ONLY, not including the chunk or junk
// Returns: TRUE if index space is not exhausted
//
STATICFN BOOL IndexVideo (LPCAPSTREAM lpcs, DWORD dwSize, BOOL bKeyFrame)
{
    ++lpcs->dwVideoChunkCount;
    return TRUE;
}

STATICFN void AVIFileCleanup(LPCAPSTREAM lpcs)
{
    if (lpcs->paudio)
        AVIStreamClose(lpcs->paudio), lpcs->paudio = NULL;
    if (lpcs->pvideo)
        AVIStreamClose(lpcs->pvideo), lpcs->pvideo = NULL;
    if (lpcs->pavifile)
        AVIFileClose(lpcs->pavifile), lpcs->pavifile = NULL;
}

/*
 * CapFileInit
 *
 *       Perform all initialization required to write a capture file.
 *
 *       We take a slightly strange approach: We don't write
 *       out the header until we're done capturing.  For now,
 *       we just seek 2K into the file, which is where all of
 *       the real data will go.
 *
 *       When we're done, we'll come back and write out the header,
 *       because then we'll know all of the values we need.
 *
 *      Also allocate and init the index.
 */

BOOL CapFileInit (
    LPCAPSTREAM lpcs)
{
    AVISTREAMINFOW si;
    LPBYTE ptr = NULL;
    UINT   cksize;
    RGBQUAD FAR * prgb;
    PALETTEENTRY aPalEntry[256];
    LPBITMAPINFO lpBitsInfoOut;    // Possibly compressed output format
    LONG lRet;
    UINT ii;

    // No special video format given -- use the default
    //
    lpBitsInfoOut = lpcs->CompVars.lpbiOut;
    if (lpcs->CompVars.hic == NULL)
        lpBitsInfoOut = lpcs->lpBitsInfo;

    // use avifile to access the data

    // create the avifile object, create a video and audio stream and
    // set the format for each stream.


    assert(lpcs->pavifile == NULL);

    /* if the capture file has not been set then error */
    if (!(*lpcs->achFile))
        goto error_exit;

    // !!! how to avoid truncating the file if already created ?

    lRet = AVIFileOpen(&lpcs->pavifile,
                    lpcs->achFile,
                    OF_WRITE | OF_CREATE,
                    NULL);
    if (lRet || !lpcs->pavifile)
        goto error_exit;

    // create video stream
    ZeroMemory (&si, sizeof(si));
    si.fccType = streamtypeVIDEO;

    if (lpcs->CompVars.hic)
        si.fccHandler = lpcs->CompVars.fccHandler;
    else
        si.fccHandler = lpBitsInfoOut->bmiHeader.biCompression;

    // A bit of history...
    // In VFW 1.0, we set fccHandler to 0 for BI_RLE8 formats
    // as a kludge to make Mplayer and Videdit play the files.
    // Just prior to 1.1 release, we found this broke Premiere,
    // so now (after AVICAP beta is on Compuserve), we change the
    // fccHandler to "MRLE".  Just ask Todd...
    // And now, at RC1, we change it again to "RLE ", Just ask Todd...
    if (si.fccHandler == BI_RLE8)
        si.fccHandler = mmioFOURCC('R', 'L', 'E', ' ');

    // !!!need to change this after capture
    si.dwScale = lpcs->sCapParms.dwRequestMicroSecPerFrame;



    si.dwRate = 1000000L;
    si.dwStart = 0L;
    si.dwQuality = (DWORD) -1L;         /* !!! ICQUALITY_DEFAULT */
    si.dwSampleSize = 0L;

    lRet = AVIFileCreateStream(lpcs->pavifile, &lpcs->pvideo, &si);
    if (lRet || !lpcs->pvideo)
        goto error_exit;

    // set format of video stream
    //  !!! dont write palette for full color?
    if (lpBitsInfoOut->bmiHeader.biBitCount > 8)
        lpBitsInfoOut->bmiHeader.biClrUsed = 0;

    // need to alloc a single block that we can fill with hdr + palette
    cksize = lpBitsInfoOut->bmiHeader.biSize
             + lpBitsInfoOut->bmiHeader.biClrUsed * sizeof(RGBQUAD);
    ptr = GlobalAllocPtr(GPTR, cksize);
    if (!ptr)
        goto error_exit;

    CopyMemory (ptr, (LPBYTE)&lpBitsInfoOut->bmiHeader,
                lpBitsInfoOut->bmiHeader.biSize);
    prgb = (RGBQUAD FAR *) &ptr[lpBitsInfoOut->bmiHeader.biSize];

    if (lpBitsInfoOut->bmiHeader.biClrUsed > 0) {
        // Get Palette info
        UINT nPalEntries = GetPaletteEntries(lpcs->hPalCurrent, 0,
                                             lpBitsInfoOut->bmiHeader.biClrUsed,
                                             aPalEntry);

        if (nPalEntries != lpBitsInfoOut->bmiHeader.biClrUsed)
            goto error_exit;

        for (ii = 0; ii < lpBitsInfoOut->bmiHeader.biClrUsed; ++ii)  {
            prgb[ii].rgbRed = aPalEntry[ii].peRed;
            prgb[ii].rgbGreen = aPalEntry[ii].peGreen;
            prgb[ii].rgbBlue = aPalEntry[ii].peBlue;
        }
    }
    if (AVIStreamSetFormat(lpcs->pvideo, 0, ptr, cksize))
        goto error_exit;

    GlobalFreePtr(ptr), ptr = NULL;


    // create audio stream if sound capture enabled
    if (lpcs->sCapParms.fCaptureAudio) {

         ZeroMemory (&si, sizeof(si));
         si.fccType = streamtypeAUDIO;
         si.fccHandler = 0L;
         si.dwScale = lpcs->lpWaveFormat->nBlockAlign;
         si.dwRate = lpcs->lpWaveFormat->nAvgBytesPerSec;
         si.dwStart = 0L;
         si.dwLength =  lpcs->dwWaveBytes / lpcs->lpWaveFormat->nBlockAlign;
         si.dwQuality = (DWORD)-1L;    /* !!! ICQUALITY_DEFAULT */
         si.dwSampleSize = lpcs->lpWaveFormat->nBlockAlign;

        lRet = AVIFileCreateStream(lpcs->pavifile, &lpcs->paudio, &si);
        if (lRet || !lpcs->paudio)
            goto error_exit;

        // write wave stream format

        cksize = GetSizeOfWaveFormat (lpcs->lpWaveFormat);

        if (AVIStreamSetFormat(lpcs->paudio, 0, lpcs->lpWaveFormat, cksize))
            goto error_exit;
    }

    // start streaming
    //
    // parameters are random for now, and are not used at all by current impl.
    // probably covered by above call but you never know
    //
    AVIStreamBeginStreaming(lpcs->pvideo, 0, 32000, 1000);
    if (lpcs->sCapParms.fCaptureAudio)
        AVIStreamBeginStreaming(lpcs->paudio, 0, 32000, 1000);

    // this is used for timing calcs, not just indexing
    //
    lpcs->dwVideoChunkCount = 0;
    lpcs->dwWaveChunkCount  = 0;

    // !!! write info chunks here

    return TRUE;

error_exit:
    if (ptr) {
        GlobalFreePtr(ptr); ptr = NULL;
    }
    AVIFileCleanup (lpcs);
    return FALSE;
}

/*
 * AVIFileFini
 *
 *       Write out the index, deallocate the index, and close the file.
 *
 */

BOOL AVIFileFini (LPCAPSTREAM lpcs, BOOL fWroteJunkChunks, BOOL fAbort)
{
    AVISTREAMINFOW si;

    DPF("AVICap32:    Start of AVIFileFini\n");

    AVIStreamEndStreaming(lpcs->pvideo);
    if (lpcs->sCapParms.fCaptureAudio)
        AVIStreamEndStreaming(lpcs->paudio);

    // if we got a good file, allow editing of it
    lpcs->fFileCaptured = !fAbort;

    // -----------------------------------------------------------
    // adjust audio & video streams to be the same length
    // -----------------------------------------------------------

   #if 0 // old technique - match video to audio unconditionally
    // share the captured frames out evenly over the captured audio

    if (lpcs->sCapParms.fCaptureAudio && lpcs->dwVideoChunkCount &&
            (lpcs->dwWaveBytes > 0)) {

         /* HACK HACK */
         /* Set rate that was captured based on length of audio data */

        lpcs->dwActualMicroSecPerFrame = (DWORD)
            MulDiv((LONG)lpcs->dwWaveBytes,
                     1000000,
                     (LONG)(lpcs->lpWaveFormat->nAvgBytesPerSec * lpcs->dwVideoChunkCount));
    } else {
        lpcs->dwActualMicroSecPerFrame = lpcs->sCapParms.dwRequestMicroSecPerFrame;
    }
   #else // new technique for stream length munging
    //
    // Init a value in case we're not capturing audio
    //
    lpcs->dwActualMicroSecPerFrame = lpcs->sCapParms.dwRequestMicroSecPerFrame;

    switch (lpcs->sCapParms.AVStreamMaster) {
        case AVSTREAMMASTER_NONE:
            lpcs->dwActualMicroSecPerFrame = lpcs->sCapParms.dwRequestMicroSecPerFrame;
            break;

        case AVSTREAMMASTER_AUDIO:
        default:
            // VFW 1.0 and 1.1 ALWAYS munged frame rate to match audio
            // duration.
            if (lpcs->sCapParms.fCaptureAudio && lpcs->dwVideoChunkCount) {
                // Modify the video framerate based on audio duration
                lpcs->dwActualMicroSecPerFrame = (DWORD)
                    ((double)lpcs->dwWaveBytes * 1000000. /
                    ((double)lpcs->lpWaveFormat->nAvgBytesPerSec *
                    lpcs->dwVideoChunkCount + 0.5));
            }
            break;
    }
   #endif

    // ------------------------------------------------------------
    // write corrected stream timing back to the file
    // ------------------------------------------------------------

   #ifdef CHICAGO
    AVIStreamInfo (lpcs->pvideo, (LPAVISTREAMINFOA) &si, sizeof(si));
   #else
    AVIStreamInfo (lpcs->pvideo, &si, sizeof(si));
   #endif

    si.dwRate = 1000000L;
    si.dwScale = lpcs->dwActualMicroSecPerFrame;

    // no api for this- have to call the member directly!
    //
    lpcs->pvideo->lpVtbl->SetInfo(lpcs->pvideo, &si, sizeof(si));

    // Add the info chunks
    // This includes the capture card driver name, client app, date and time

    if (lpcs->lpInfoChunks) {
        LPBYTE  lpInfo;
        DWORD   cbData;

        lpInfo = lpcs->lpInfoChunks;
        while (lpInfo < (LPBYTE) lpcs->lpInfoChunks + lpcs->cbInfoChunks) {
            cbData = * (LPDWORD) (lpInfo + sizeof(DWORD));
            AVIFileWriteData (lpcs->pavifile,
                        (DWORD) * (LPDWORD) lpInfo,        // FOURCC
                        lpInfo + sizeof (DWORD) * 2,       // lpData
                        cbData);                           // cbData
            lpInfo += cbData + sizeof (DWORD) * 2;
        }
    }


    AVIFileCleanup(lpcs);

    return lpcs->fFileCaptured;
}

//
// Prepends dummy frame entries to the current valid video frame.
// Bumps the index, but does not actually trigger a write operation.
// nCount is a count of the number of frames to write
// Returns: TRUE on a successful write

BOOL WINAPI AVIWriteDummyFrames (
    LPCAPSTREAM lpcs,
    UINT        nCount,
    LPUINT      lpuError,
    LPBOOL      lpbPending)
{
    LONG lRet;

    lpcs->dwVideoChunkCount += nCount;

    lRet = AVIStreamWrite(lpcs->pvideo,
                    -1,             // current position
                    nCount,         // this many samples
                    NULL,           // no actual data
                    0,              // no data
                    0,              // not keyframe
                    NULL, NULL);    // no return of samples or bytes
    *lpbPending = FALSE;
    *lpuError = 0;
    if (lRet)
        *lpuError = IDS_CAP_FILE_WRITE_ERROR;
    return !(*lpuError);
}

// Writes compressed or uncompressed frames to the AVI file
// returns TRUE if no error, FALSE if end of file.

BOOL WINAPI AVIWriteVideoFrame (
    LPCAPSTREAM lpcs,
    LPBYTE      lpData,
    DWORD       dwBytesUsed,
    BOOL        fKeyFrame,
    UINT        uIndex,
    UINT        nDropped,
    LPUINT      lpuError,
    LPBOOL      lpbPending)
{
    LONG   lRet;

    lRet = AVIStreamWrite(lpcs->pvideo,     // write to video stream
                    -1,                     // next sample
                    1,                      // 1 sample only
                    lpData,                 // video buffer (no riff header)
                    dwBytesUsed,            // length of data
                    fKeyFrame ? AVIIF_KEYFRAME : 0,
                    NULL, NULL);    // no return of sample or byte count

    *lpbPending = FALSE;
    *lpuError = 0;
    if (lRet)
    {
        dprintf("AVIStreamWrite returned 0x%x", lRet);
        *lpuError = IDS_CAP_FILE_WRITE_ERROR;
    }
    else
    {
        ++lpcs->dwVideoChunkCount;
        if (nDropped)
            AVIWriteDummyFrames (lpcs, nDropped, lpuError, lpbPending);
    }
    return !(*lpuError);
}

BOOL WINAPI AVIWriteAudio (
    LPCAPSTREAM lpcs,
    LPWAVEHDR   lpWaveHdr,
    UINT        uIndex,
    LPUINT      lpuError,
    LPBOOL      lpbPending)
{
    LONG lRet;

    lRet = AVIStreamWrite(lpcs->paudio,
                -1,                 // next sample
                lpWaveHdr->dwBytesRecorded /
                    lpcs->lpWaveFormat->nBlockAlign,    // nr samples
                lpWaveHdr->lpData,
                lpWaveHdr->dwBytesRecorded,
                0,
                NULL,
                NULL);

    *lpbPending = FALSE;
    *lpuError = 0;
    if (lRet)
    {
        dprintf("AVIStreamWrite returned 0x%x", lRet);
        *lpuError = IDS_CAP_FILE_WRITE_ERROR;
    }
    else
        ++lpcs->dwWaveChunkCount;

    return !(*lpuError);
}

#else //---------------- ! using Avifile ----------------------------

// The following are anded with the size in the index
#define IS_AUDIO_CHUNK        0x80000000
#define IS_KEYFRAME_CHUNK     0x40000000
#define IS_DUMMY_CHUNK        0x20000000
#define IS_GRANULAR_CHUNK     0x10000000
#define INDEX_MASK  (IS_AUDIO_CHUNK | IS_KEYFRAME_CHUNK | IS_DUMMY_CHUNK | IS_GRANULAR_CHUNK)


// Add an index entry for a video frame
// dwSize is the size of data ONLY, not including the chunk or junk
// Returns: TRUE if index space is not exhausted
//
STATICFN BOOL IndexVideo (LPCAPSTREAM lpcs, DWORD dwSize, BOOL bKeyFrame)
{
    if (lpcs->dwIndex < lpcs->sCapParms.dwIndexSize) {
        *lpcs->lpdwIndexEntry = dwSize | (bKeyFrame ? IS_KEYFRAME_CHUNK : 0);
        ++lpcs->lpdwIndexEntry;
        ++lpcs->dwIndex;
        ++lpcs->dwVideoChunkCount;
        return TRUE;
    }
    dprintf("\n***WARNING*** Indexvideo space exhausted\n");
    return FALSE;
}

// Add an index entry for an audio buffer
// dwSize is the size of data ONLY, not including the chunk or junk
// Returns: TRUE if index space is not exhausted
//
STATICFN BOOL IndexAudio (LPCAPSTREAM lpcs, DWORD dwSize)
{
    if (lpcs->dwIndex < lpcs->sCapParms.dwIndexSize) {
       *lpcs->lpdwIndexEntry = dwSize | IS_AUDIO_CHUNK;
       ++lpcs->lpdwIndexEntry;
       ++lpcs->dwIndex;
       ++lpcs->dwWaveChunkCount;
       return TRUE;
    }
    dprintf("\n***WARNING*** Indexaudio space exhausted\n");
    return FALSE;
}

DWORD CalcWaveBufferSize (LPCAPSTREAM lpcs)
{
    DWORD dw;

    if (!lpcs->lpWaveFormat)
        return 0L;

    // at least .5 second
    dw = lpcs->lpWaveFormat->nAvgBytesPerSec / 2;
    if (lpcs->sCapParms.wChunkGranularity) {
        if (dw % lpcs->sCapParms.wChunkGranularity) {
            dw += lpcs->sCapParms.wChunkGranularity -
                dw % lpcs->sCapParms.wChunkGranularity;
        }
    }
    dw = max ((1024L * 16), dw);                // at least 16K
    dw -= sizeof(RIFF);

    dprintf("Wave buffer size = %ld", dw);
    return dw;
}

/*
 * AVIPreloadFat
 *
 *   Force FAT for this file to be loaded into the FAT cache
 *
 */

VOID WINAPI AVIPreloadFat (LPCAPSTREAM lpcs)
{
    DWORD dw;
   #ifdef CHICAGO
    DWORD dwPos;

    assert (lpcs->lpDropFrame);

    // save the current file pointer then seek to the end of the file
    //
    dwPos = SetFilePointer (lpcs->hFile, 0, NULL, FILE_CURRENT);
    dw = SetFilePointer (lpcs->hFile, 0, NULL, FILE_END);
    if ((dw == (DWORD)-1) || (dw < lpcs->dwBytesPerSector)) {
        // put the file pointer back to where it was
        SetFilePointer (lpcs->hFile, dwPos, NULL, FILE_BEGIN);
        return;
    }

    // read the last sector of the file, just to force
    // the fat for the file to be loaded
    //
    ReadFile (lpcs->hFile, lpcs->lpDropFrame, lpcs->dwBytesPerSector, &dw, NULL);

    // put the file pointer back to where it was
    //
    SetFilePointer (lpcs->hFile, dwPos, NULL, FILE_BEGIN);
   #else
    // Load all the FAT information.   On NT this is sufficient for FAT
    // files.  On NTFS partitiions there is no way we can read in all the
    // mapping information.
    GetFileSize(lpcs->hFile, &dw);
   #endif
}


#ifdef JMK_HACK_DONTWRITE
static BOOL bDontWrite;
#endif

// Write data to the capture file
// Returns: TRUE on a successful write
//
UINT NEAR PASCAL AVIWrite (
    LPCAPSTREAM lpcs,
    LPVOID      pbuf,
    DWORD       dwSize,
    UINT        uIndex, // index of header for this buffer, -1 for step capture
    UINT        uType,
    LPBOOL      lpbPending)
{
    DWORD dwWritten;
    DWORD dwGran;

    // the buffer must be sector aligned if using non-buffered IO
    // and the size must be at least word aligned
    // uIndex == -1 if this is a dummy frame write
    // uIndex == Index into alpVideoHdr OR index in alpWaveHdr based on uType
    //
    assert (!lpcs->fUsingNonBufferedIO || (!((DWORD)pbuf & (lpcs->dwBytesPerSector - 1))));
    assert (!(dwSize & 1));
    assert (dwSize);

    assert (*lpbPending == FALSE);

    // if we are doing non-buffered io, we need to pad each write
    // to an even multiple of sector size bytes, we do this by adding
    // a junk riff chunk into the write buffer after dwSize bytes
    //
    dwGran = lpcs->sCapParms.wChunkGranularity;
    if (lpcs->fUsingNonBufferedIO)
       dwGran = max (lpcs->dwBytesPerSector,
                (DWORD) lpcs->sCapParms.wChunkGranularity);

    assert (dwGran);

    if (dwSize % dwGran)
    {
        DWORD dwSizeT = dwGran - (dwSize % dwGran);
        LPRIFF priff = (LPRIFF)((LPBYTE)pbuf + dwSize + (dwSize & 1));

        if (dwSizeT < sizeof(RIFF))
            dwSizeT += dwGran;

        // add the junk riff chunk to the end of the buffer
        //
        priff->dwType = ckidAVIPADDING;
        priff->dwSize = dwSizeT - sizeof(RIFF);
        dwSize += dwSizeT;
    }

   #ifdef _DEBUG
    if (dwSize)
    {
        volatile BYTE bt;
        AuxDebugEx (8, DEBUGLINE "touch test of AviWrite buffer %08X\r\n", pbuf);
        bt = ((LPBYTE)pbuf)[dwSize-1];
    }

    // List all of the RIFF chunks within the block being written
    //
    dwWritten = 0;
    while (dwWritten < dwSize)
    {
        LPRIFF priff = (LPVOID)((LPBYTE)pbuf + dwWritten);
        AuxDebugEx (4, DEBUGLINE "RIFF=%.4s size=%08X\r\n",
                   &priff->dwType, priff->dwSize);
        dwWritten += priff->dwSize + sizeof(RIFF);
    }
   #endif


    // BUGBUG, Remove the following line when done performance testing
   #ifdef JMK_HACK_DONTWRITE
    if (bDontWrite)
        return 0;
   #endif

    if (lpcs->pAsync)
    {
        struct _avi_async * lpah = &lpcs->pAsync[lpcs->iLastAsync];
        UINT  iLastAsync;

        // set iLastAsync to point to what lpcs->iLastAsync
        // would be if we were to increment it.  If we end up
        // with an i/o that does not complete synchronously
        // we will then update lpcs->iLastAsync so that we can
        // remember to check for completion later
        //
        if ((iLastAsync = lpcs->iLastAsync+1) >= lpcs->iNumAsync)
            iLastAsync = 0;

        // is the async buffer that we are trying to use
        // already in use?
        //
        if (iLastAsync == lpcs->iNextAsync) {
	    AuxDebugEx(1, DEBUGLINE "async buffer already in use\r\n");
            return IDS_CAP_FILE_WRITE_ERROR;
	}
        assert (!lpah->uType);

        // init the async buffer with the info that we will need
        // to release the buffer when the io is complete
        //
        ZeroMemory (&lpah->ovl, sizeof(lpah->ovl));
        lpah->ovl.hEvent = lpcs->hCaptureEvent;
        lpah->ovl.Offset = lpcs->dwAsyncWriteOffset;
        // attempt an async write.  if WriteFile fails, we then
        // need to check if it's a real failure, or just an instance
        // of delayed completion.  if delayed completion, we fill out
        // the lpah structure so that we know what buffer to re-use
        // when the io finally completes.
        //
	if ( ! WriteFile (lpcs->hFile, pbuf, dwSize, &dwWritten, &lpah->ovl))
        {
            if (GetLastError() == ERROR_IO_PENDING)
            {

                // if we are passed a index of -1, that means that
                // this buffer is not associated with any entry in the
                // header array.  in this case, we must have the io complete
                // before we return from this function.
               //
               if (uIndex == (UINT)-1)
               {
                   while (1) {
                    if ( ! GetOverlappedResult (lpcs->hFile, &lpah->ovl, &dwWritten, TRUE))
                    {
                        AuxDebugEx (0, DEBUGLINE "WriteFile failed %d\r\n", GetLastError());
                        return IDS_CAP_FILE_WRITE_ERROR;
                    }
			// if Internal is non-zero, the io is still pending
	    // NOTE: this needs to be changed as soon as possible.
	    //	The current state of play means that GetOverlappedResult CAN return
	    //	something other than ERROR_IO_COMPLETE and the IO will still be
	    //	pending.  This causes us to make the wrong decision.
                        if (lpah->ovl.Internal != 0) {
			    Sleep(100);  // release some cycles
			}
			else
			    break;
                   }
                   //#pragma message(SQUAWK "get rid of this hack when GetOverlappedResult is fixed!")
                }
                else
                {
                    // io is begun, but not yet completed. so setup info in
                    // the pending io array so that we can check later for completion
                    //
                    *lpbPending = TRUE;
                    lpah->uType = uType;
                    lpah->uIndex = uIndex;
		    AuxDebugEx(2, DEBUGLINE "IOPending... iLastAsync was %d, will be %d, uIndex=%d, Event=%d\r\n",lpcs->iLastAsync , iLastAsync, uIndex, lpah->ovl.hEvent);
                    lpcs->iLastAsync = iLastAsync;
                }
            }
            else
            {
                AuxDebugEx (0, DEBUGLINE "WriteFile failed %d\r\n", GetLastError());
                return IDS_CAP_FILE_WRITE_ERROR;
	    }
	}

        // we get to here only when the io succeeds or is pending
        // so update the seek offset for use in the next write operation
        //
        lpcs->dwAsyncWriteOffset += dwSize;
    }
    else
    {
	// We are writing synchronously to the file
        if (!WriteFile (lpcs->hFile, pbuf, dwSize, &dwWritten, NULL) ||
            !(dwWritten == dwSize))
            return IDS_CAP_FILE_WRITE_ERROR;
    }

    return 0;
}

/*
 * CapFileInit
 *
 *       Perform all initialization required to write a capture file.
 *
 *       We take a slightly strange approach: We don't write
 *       out the header until we're done capturing.  For now,
 *       we just seek 2K into the file, which is where all of
 *       the real data will go.
 *
 *       When we're done, we'll come back and write out the header,
 *       because then we'll know all of the values we need.
 *
 *      Also allocate and init the index.
 */
BOOL CapFileInit (LPCAPSTREAM lpcs)
{
    LONG l;
    LPBITMAPINFO lpBitsInfoOut;    // Possibly compressed output format
    DWORD dwOpenFlags;

    // No special video format given -- use the default
    lpBitsInfoOut = lpcs->CompVars.lpbiOut;
    if (lpcs->CompVars.hic == NULL)
        lpBitsInfoOut = lpcs->lpBitsInfo;


    assert (lpcs->hmmio == NULL);   // Should never have a file handle on entry

    // if the capture file has not been set then set it now
    if (!(*lpcs->achFile))
         goto INIT_FILE_OPEN_ERROR;

    // Get the Bytes per sector for the drive
    {
        DWORD dwSectorsPerCluster;
        DWORD dwFreeClusters;
        DWORD dwClusters;
        TCHAR szFullPathName[MAX_PATH];
        LPTSTR pszFilePart;

        GetFullPathName (lpcs->achFile,
                NUMELMS (szFullPathName),
                szFullPathName,
                &pszFilePart);

        if (szFullPathName[1] == TEXT(':') && szFullPathName[2] == TEXT('\\')) {
            szFullPathName[3] = TEXT('\0');  // Terminate after "x:\"

            GetDiskFreeSpace (szFullPathName,
                   &dwSectorsPerCluster,
                   &lpcs->dwBytesPerSector,
                   &dwFreeClusters,
                   &dwClusters);
            AuxDebugEx (3, DEBUGLINE "BytesPerSector=%d\r\n",
                lpcs->dwBytesPerSector);
        }
        else {
            // This handles cases where we do not have a "x:\" filename
            // Principally this will be "\\server\name\path..."
            lpcs->dwBytesPerSector = DEFAULT_BYTESPERSECTOR;
            AuxDebugEx (3, DEBUGLINE "FullPath=%s\r\n", szFullPathName);
            AuxDebugEx (3, DEBUGLINE "GetFullPath failed, Forcing dwBytesPerSector to %d\r\n",DEFAULT_BYTESPERSECTOR);
        }

    // bytes per sector must be non-zero and a power of two
    //
    assert (lpcs->dwBytesPerSector);
    assert (!(lpcs->dwBytesPerSector & (lpcs->dwBytesPerSector-1)));
    }

   #ifdef ZERO_THE_FILE_FOR_TESTING
    {
    char c[64 * 1024];
    DWORD dwSize;
    DWORD dwBW;
    // Open the file just to zero it

    lpcs->hFile = CreateFile (lpcs->achFile,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

    if (lpcs->hFile == INVALID_HANDLE_VALUE) {
        lpcs->hFile = 0;
        goto INIT_FILE_OPEN_ERROR;
    }

    ZeroMemory (c, sizeof(c));
    SetFilePointer (lpcs->hFile, 0, NULL, FILE_BEGIN);
    dwSize = GetFileSize (lpcs->hFile, NULL);

    while (SetFilePointer (lpcs->hFile, 0, NULL, FILE_CURRENT) < dwSize)
            WriteFile (lpcs->hFile, c, sizeof(c), &dwBW, NULL);
    }

    CloseHandle(lpcs->hFile);  // Close the "normal" open
   #endif

    // We can use non-buffered I/O if the ChunkGranularity is
    // a multiple of BytesPerSector.  Better check that wChunkGranularity
    // has indeed been set

    if (0 == lpcs->sCapParms.wChunkGranularity)
        lpcs->sCapParms.wChunkGranularity = lpcs->dwBytesPerSector;

    lpcs->fUsingNonBufferedIO =
            (lpcs->sCapParms.wChunkGranularity >= lpcs->dwBytesPerSector) &&
           ((lpcs->sCapParms.wChunkGranularity % lpcs->dwBytesPerSector) == 0) &&
            (lpcs->CompVars.hic == NULL) &&
            (!(lpcs->fCaptureFlags & CAP_fStepCapturingNow)) &&
            (!(lpcs->fCaptureFlags & CAP_fFrameCapturingNow));

    AuxDebugEx (3, DEBUGLINE "fUsingNonBufferedIO=%d\r\n", lpcs->fUsingNonBufferedIO);

    // setup CreateFile flags based on whether we are using
    // non-buffered io and/or overlapped io
    //
    dwOpenFlags = FILE_ATTRIBUTE_NORMAL;
    if (lpcs->fUsingNonBufferedIO)
    {
        dwOpenFlags |= FILE_FLAG_NO_BUFFERING;
       #ifdef CHICAGO
        #pragma message (SQUAWK "find a better way to set AsyncIO flag")
        if (GetProfileIntA ("Avicap32", "AsyncIO", FALSE))
       #else
            // give a way to override the async default option.
            if (!GetProfileIntA ("Avicap32", "AsyncIO", TRUE)) {
		AuxDebugEx (2, DEBUGLINE "NOT doing Async IO\r\n");
	    } else
       #endif
        {
            AuxDebugEx (3, DEBUGLINE "Doing Async IO\r\n");
            dwOpenFlags |= FILE_FLAG_OVERLAPPED;

            // We are requested to do async io.  Allocate an array
            // of async io headers and initialize the async io fields
            // in the CAPSTREAM structure
            //
            {
                UINT iNumAsync = NUMELMS(lpcs->alpVideoHdr) + NUMELMS(lpcs->alpWaveHdr) + 2;
		// This is quite a lot of buffers.  Perhaps we should limit
		// ourselves to lpcs->iNumVideo and lpcs->iNumAudio EXCEPT
		// these fields have not yet been set up.  We would need
		// to look in the cap stream structure to get the information.
		// It is simpler to assume the maximum numbers.
                lpcs->dwAsyncWriteOffset = lpcs->dwAVIHdrSize;
                lpcs->iNextAsync = lpcs->iLastAsync = 0;
                lpcs->pAsync = GlobalAllocPtr (GMEM_MOVEABLE | GMEM_ZEROINIT,
                                               sizeof(*lpcs->pAsync) * iNumAsync);
                if (lpcs->pAsync) {
                    lpcs->iNumAsync = iNumAsync;
                } else {
                    // cannot allocate the memory.  Go synchronous
                    dprintf("Failed to allocate async buffers");
                    dwOpenFlags &= ~(FILE_FLAG_OVERLAPPED);
		}
            }
        }
    }

    // Open the capture file, using Non Buffered I/O
    // if possible, given sector size, and buffer granularity
    //
    lpcs->hFile = CreateFile (lpcs->achFile,
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_ALWAYS,
                    dwOpenFlags,
                    NULL);

    if (lpcs->hFile == INVALID_HANDLE_VALUE) {
        lpcs->hFile = 0;
        goto INIT_FILE_OPEN_ERROR;
    }

    // BUGBUG, Remove the following line when done performance testing
   #ifdef JMK_HACK_DONTWRITE
    bDontWrite = GetProfileIntA("AVICAP32", "DontWrite", FALSE);
   #endif

    // Seek to a multiple of ChunkGranularity + AVIHEADERSIZE.
    // This is the point at which we'll start writing
    // Later, we'll come back and fill in the AVI header and index.

    // l is zero for standard wave and video formats
    l = (GetSizeOfWaveFormat ((LPWAVEFORMATEX) lpcs->lpWaveFormat) -
                sizeof (PCMWAVEFORMAT)) +
                (lpBitsInfoOut->bmiHeader.biSize -
                sizeof (BITMAPINFOHEADER));

    // (2K + size of wave and video stream headers) rounded to next 2K
    lpcs->dwAVIHdrSize = AVI_HEADERSIZE +
        (((lpcs->cbInfoChunks + l + lpcs->sCapParms.wChunkGranularity - 1)
        / lpcs->sCapParms.wChunkGranularity) * lpcs->sCapParms.wChunkGranularity);


    dprintf("AVIHdrSize = %ld", lpcs->dwAVIHdrSize);

    SetFilePointer (lpcs->hFile, lpcs->dwAVIHdrSize, NULL, FILE_BEGIN);
    if (lpcs->pAsync)
        lpcs->dwAsyncWriteOffset = lpcs->dwAVIHdrSize;

    // do all Index allocations
    if (!InitIndex (lpcs))
        CloseHandle (lpcs->hFile), lpcs->hFile = 0;

    lpcs->dwVideoChunkCount = 0;
    lpcs->dwWaveChunkCount = 0;

INIT_FILE_OPEN_ERROR:
    if (lpcs->hFile) {
	return(TRUE);
    }
    if (lpcs->pAsync) {
	GlobalFreePtr(lpcs->pAsync), lpcs->pAsync=NULL;
    }
    return (FALSE);
}

///////////////////////////////////////////////////////////////////////////
//  The index array is used to record the positions
//  of every chunk in the RIFF (avi) file.
//
//  what this array is:
//
//      each entry contains the size of the data
//      high order bits encode the type of data (audio / video)
//      and whether the video chunk is a key frame, dropped frame, etc.
///////////////////////////////////////////////////////////////////////////

// Allocate the index table
// Returns: TRUE if index can be allocated
//
BOOL InitIndex (LPCAPSTREAM lpcs)
{
    lpcs->dwIndex = 0;

    // we assume that we have not already allocated an index
    //
    assert (lpcs->lpdwIndexStart == NULL);

    // Limit index size between 1 minute at 30fps and 3 hours at 30fps
    lpcs->sCapParms.dwIndexSize = max (lpcs->sCapParms.dwIndexSize, 1800);
    lpcs->sCapParms.dwIndexSize = min (lpcs->sCapParms.dwIndexSize, 324000L);
    dprintf("Max Index Size = %ld", lpcs->sCapParms.dwIndexSize);

    if (lpcs->hIndex = GlobalAlloc (GMEM_MOVEABLE,
                lpcs->sCapParms.dwIndexSize * sizeof (DWORD))) {
        if (lpcs->lpdwIndexEntry =
            lpcs->lpdwIndexStart = (LPDWORD)GlobalLock (lpcs->hIndex))
            return TRUE;        // Success

        GlobalFree (lpcs->hIndex);
	lpcs->hIndex = NULL;
    }
    lpcs->lpdwIndexStart = NULL;
    return FALSE;
}

// Deallocate the index table
//
void FiniIndex (LPCAPSTREAM lpcs)
{
    if (lpcs->hIndex) {
        if (lpcs->lpdwIndexStart)
            GlobalUnlock (lpcs->hIndex);
        GlobalFree (lpcs->hIndex);
	lpcs->hIndex = NULL;
    }
    lpcs->lpdwIndexStart = NULL;
}



// Write out the index at the end of the capture file.
// The single frame capture methods do not append
// JunkChunks!  Audio chunks also now may have junk appended.
//
BOOL WriteIndex (LPCAPSTREAM lpcs, BOOL fJunkChunkWritten)
{
    BOOL  fChunkIsAudio;
    BOOL  fChunkIsKeyFrame;
    BOOL  fChunkIsDummy;
    BOOL  fChunkIsGranular;
    DWORD dwIndex;
    DWORD dw;
    DWORD dwJunk;
    DWORD off;
    AVIINDEXENTRY   avii;
    MMCKINFO    ck;
    LPDWORD lpdw;
    DWORD   dwGran;

    // determine which granularity (if any) to use
    // when calulating junk appended
    //
    dwGran = 0;
    if (fJunkChunkWritten)
    {
        dwGran = lpcs->sCapParms.wChunkGranularity;
        if (lpcs->fUsingNonBufferedIO)
           dwGran = max (lpcs->dwBytesPerSector, dwGran);
    }


    if (lpcs->dwIndex > lpcs->sCapParms.dwIndexSize)
        return TRUE;

    off        = lpcs->dwAVIHdrSize;

    ck.cksize  = 0;
    ck.ckid    = ckidAVINEWINDEX;
    ck.fccType = 0;

    if (mmioCreateChunk(lpcs->hmmio,&ck,0)) {
	dprintf("Failed to create chunk for index");
        return FALSE;
    }

    lpdw = lpcs->lpdwIndexStart;
    for (dwIndex= 0; dwIndex < lpcs->dwIndex; dwIndex++) {

        dw = *lpdw++;

        fChunkIsAudio      = (BOOL) ((dw & IS_AUDIO_CHUNK) != 0);
        fChunkIsKeyFrame   = (BOOL) ((dw & IS_KEYFRAME_CHUNK) != 0);
        fChunkIsDummy      = (BOOL) ((dw & IS_DUMMY_CHUNK) != 0);
        fChunkIsGranular   = (BOOL) ((dw & IS_GRANULAR_CHUNK) != 0);
        dw &= ~(INDEX_MASK);

        if (fChunkIsAudio) {
            avii.ckid         = MAKEAVICKID(cktypeWAVEbytes, 1);
            avii.dwFlags      = 0;
        } else {
            if (lpcs->lpBitsInfo->bmiHeader.biCompression == BI_RLE8)
                avii.ckid         = MAKEAVICKID(cktypeDIBcompressed, 0);
            else
                avii.ckid         = MAKEAVICKID(cktypeDIBbits, 0);
            avii.dwFlags      = fChunkIsKeyFrame ? AVIIF_KEYFRAME : 0;
        }
        avii.dwChunkLength    = dw;
        avii.dwChunkOffset    = off;

        if (mmioWrite(lpcs->hmmio, (LPVOID)&avii, sizeof(avii)) != sizeof(avii)) {
	    dprintf("Failed to write index chunk %d", dwIndex);
            return FALSE;
	}

        dw += sizeof (RIFF);
        // round to word boundary
        //
        dw += (dw & 1);
        off += dw;

        // If a Junk chunk was appended, move past it
        //
        if (fChunkIsGranular && dwGran && (off % dwGran)) {
            dwJunk = dwGran - (off % dwGran);

            if (dwJunk < sizeof (RIFF))
                off += dwGran;
            off += dwJunk;
        }
    }

    if (mmioAscend(lpcs->hmmio, &ck, 0)){
	dprintf("Failed to ascend at end of index writing");
        return FALSE;
    }

    return TRUE;
}

/*
 * AVIFileFini
 *
 *       Write out the index, deallocate the index, and close the file.
 *
 */
BOOL AVIFileFini (LPCAPSTREAM lpcs, BOOL fWroteJunkChunks, BOOL fAbort)
{
    MMCKINFO      ckRiff;
    MMCKINFO      ckList;
    MMCKINFO      ckStream;
    MMCKINFO      ck;
    UINT          ii;
    DWORD         dw;
    AVIStreamHeader        strhdr;
    DWORD         dwDataEnd;
    BOOL          fRet = TRUE;
    RGBQUAD       argbq[256];
    MainAVIHeader aviHdr;
    BOOL          fSound;
    LPBITMAPINFO  lpBitsInfoOut;    // Possibly compressed output format

    // No special video format given -- use the default
    //
    lpBitsInfoOut = lpcs->lpBitsInfo;
   #ifdef NEW_COMPMAN
    if (lpcs->CompVars.hic != NULL)
        lpBitsInfoOut = lpcs->CompVars.lpbiOut;
   #endif

    // if the capture file has not been opened, we have nothing to do
    //
    if (lpcs->hFile == 0)
        return FALSE;

    // save off the current seek position.  this is the end of the capture
    // data.  then close the capture file,  we will do the final work
    // on the capture file using mmio & buffered io.
    //
    if (lpcs->pAsync)
        dwDataEnd = lpcs->dwAsyncWriteOffset;
    else
        dwDataEnd = SetFilePointer (lpcs->hFile, 0, NULL, FILE_CURRENT);

    CloseHandle (lpcs->hFile), lpcs->hFile = 0;

    // if we had allocated space for async buffers, free them now
    //
    if (lpcs->pAsync)
    {
        GlobalFreePtr (lpcs->pAsync);
        lpcs->pAsync = NULL;
        lpcs->iNextAsync = lpcs->iLastAsync = lpcs->iNumAsync = 0;
    }

    // if we are aborting capture, we are done
    lpcs->hmmio = mmioOpen(lpcs->achFile, NULL, MMIO_WRITE);
    assert (lpcs->hmmio != NULL);

    //
    if (fAbort)
        goto FileError;

    if (!lpcs->dwWaveBytes)
        fSound = FALSE;
    else
        fSound = lpcs->sCapParms.fCaptureAudio && (!(lpcs->fCaptureFlags & CAP_fFrameCapturingNow));

    // Seek to beginning of file, so we can write the header.
    mmioSeek(lpcs->hmmio, 0, SEEK_SET);

    DSTATUS(lpcs, "Writing AVI header");

    // Create RIFF chunk
    ckRiff.cksize = 0;
    ckRiff.fccType = formtypeAVI;
    if (mmioCreateChunk(lpcs->hmmio,&ckRiff,MMIO_CREATERIFF))
         goto FileError;

    // Create header list
    ckList.cksize = 0;
    ckList.fccType = listtypeAVIHEADER;
    if (mmioCreateChunk(lpcs->hmmio,&ckList,MMIO_CREATELIST))
         goto FileError;

    // Create AVI header chunk
    ck.cksize = sizeof(MainAVIHeader);
    ck.ckid = ckidAVIMAINHDR;
    if (mmioCreateChunk(lpcs->hmmio,&ck,0))
         goto FileError;

    lpcs->dwAVIHdrPos = ck.dwDataOffset;

    // Calculate AVI header info
    //
    ZeroMemory (&aviHdr, sizeof(aviHdr));

    //
    // Set the stream lengths based on the Master stream
    //
   #if 0 // stream length calc with unconditional audio master
    aviHdr.dwMicroSecPerFrame = lpcs->sCapParms.dwRequestMicroSecPerFrame;
    if (fSound && lpcs->dwVideoChunkCount) {
         /* HACK HACK */
         /* Set rate that was captured based on length of audio data */

         aviHdr.dwMicroSecPerFrame = (DWORD) MulDiv ((LONG)lpcs->dwWaveBytes,
                   1000000,
                   (LONG)(lpcs->lpWaveFormat->nAvgBytesPerSec * lpcs->dwVideoChunkCount));
    }
   #else

    // Init a value in case we're not capturing audio
    aviHdr.dwMicroSecPerFrame = lpcs->sCapParms.dwRequestMicroSecPerFrame;

    switch (lpcs->sCapParms.AVStreamMaster) {
        case AVSTREAMMASTER_NONE:
            break;

        case AVSTREAMMASTER_AUDIO:
        default:
            // VFW 1.0 and 1.1 ALWAYS munged frame rate to match audio
            // duration.
            if (fSound && lpcs->sCapParms.fCaptureAudio && lpcs->dwVideoChunkCount) {
                // Modify the video framerate based on audio duration
                aviHdr.dwMicroSecPerFrame = (DWORD)
                    ((double)lpcs->dwWaveBytes * 1000000. /
                    ((double)lpcs->lpWaveFormat->nAvgBytesPerSec *
                    lpcs->dwVideoChunkCount + 0.5));
            }
            break;
    }
   #endif
    lpcs->dwActualMicroSecPerFrame = aviHdr.dwMicroSecPerFrame;

    aviHdr.dwMaxBytesPerSec = (DWORD) MulDiv (lpBitsInfoOut->bmiHeader.biSizeImage,
                                      1000000,
                                      lpcs->sCapParms.dwRequestMicroSecPerFrame) +
                                      (fSound ? lpcs->lpWaveFormat->nAvgBytesPerSec : 0);
    aviHdr.dwPaddingGranularity = 0L;
    aviHdr.dwFlags = AVIF_WASCAPTUREFILE | AVIF_HASINDEX;
    aviHdr.dwStreams = fSound ? 2 : 1;
    aviHdr.dwTotalFrames = lpcs->dwVideoChunkCount;
    aviHdr.dwInitialFrames = 0L;
    aviHdr.dwSuggestedBufferSize = 0L;
    aviHdr.dwWidth = lpBitsInfoOut->bmiHeader.biWidth;
    aviHdr.dwHeight = lpBitsInfoOut->bmiHeader.biHeight;

    aviHdr.dwReserved[0] = 0;
    aviHdr.dwReserved[1] = 0;
    aviHdr.dwReserved[2] = 0;
    aviHdr.dwReserved[3] = 0;
    //aviHdr.dwRate = 1000000L;
    //aviHdr.dwScale = aviHdr.dwMicroSecPerFrame;
    //aviHdr.dwStart = 0L;
    //aviHdr.dwLength = lpcs->dwVideoChunkCount;

    // Write AVI header info
    if (mmioWrite(lpcs->hmmio, (LPBYTE)&aviHdr, sizeof(aviHdr)) != sizeof(aviHdr) ||
        mmioAscend(lpcs->hmmio, &ck, 0))
        goto FileError;

    DSTATUS(lpcs, "Writing AVI Stream header");

    // Create stream header list
    ckStream.cksize = 0;
    ckStream.fccType = listtypeSTREAMHEADER;
    if (mmioCreateChunk(lpcs->hmmio,&ckStream,MMIO_CREATELIST))
        goto FileError;

    ZeroMemory (&strhdr, sizeof(strhdr));
    strhdr.fccType = streamtypeVIDEO;
    strhdr.fccHandler = lpBitsInfoOut->bmiHeader.biCompression;
   #ifdef NEW_COMPMAN
    if (lpcs->CompVars.hic)
        strhdr.fccHandler = lpcs->CompVars.fccHandler;
   #endif

    // A bit of history...
    // In VFW 1.0, we set fccHandler to 0 for BI_RLE8 formats
    // as a kludge to make Mplayer and Videdit play the files.
    // Just prior to 1.1 release, we found this broke Premiere,
    // so now (after AVICAP beta is on Compuserve), we change the
    // fccHandler to "MRLE".  Just ask Todd...
    // And now, at RC1, we change it again to "RLE ", Just ask Todd...
    if (strhdr.fccHandler == BI_RLE8)
        strhdr.fccHandler = mmioFOURCC('R', 'L', 'E', ' ');

    //strhdr.dwFlags = 0L;
   #ifdef NEW_COMPMAN
    //strhdr.wPriority = 0L;
    //strhdr.wLanguage = 0L;
   #else
    //strhdr.dwPriority = 0L;
   #endif

    //strhdr.dwInitialFrames = 0L;
    strhdr.dwScale = aviHdr.dwMicroSecPerFrame;
    strhdr.dwRate = 1000000L;
    //strhdr.dwStart = 0L;
    strhdr.dwLength = lpcs->dwVideoChunkCount;        /* Needs to get filled in! */
    strhdr.dwQuality = (DWORD) -1L;         /* !!! ICQUALITY_DEFAULT */
    //strhdr.dwSampleSize = 0L;

    //
    // Write stream header data
    //
    ck.ckid = ckidSTREAMHEADER;
    if (mmioCreateChunk(lpcs->hmmio,&ck,0) ||
        mmioWrite(lpcs->hmmio, (LPBYTE)&strhdr, sizeof(strhdr)) != sizeof(strhdr) ||
        mmioAscend(lpcs->hmmio, &ck, 0))
        goto FileError;

    /*
    **  !!! dont write palette for full color?
    */
    if (lpBitsInfoOut->bmiHeader.biBitCount > 8)
        lpBitsInfoOut->bmiHeader.biClrUsed = 0;

    /* Create DIB header chunk */
    ck.cksize = lpBitsInfoOut->bmiHeader.biSize +
                           lpBitsInfoOut->bmiHeader.biClrUsed *
                           sizeof(RGBQUAD);
    ck.ckid = ckidSTREAMFORMAT;
    if (mmioCreateChunk(lpcs->hmmio,&ck,0))
         goto FileError;

    /* Write DIB header data */
    if (mmioWrite(lpcs->hmmio, (LPBYTE)&lpBitsInfoOut->bmiHeader,
                               lpBitsInfoOut->bmiHeader.biSize) !=
             (LONG) lpBitsInfoOut->bmiHeader.biSize)
         goto FileError;

    if (lpBitsInfoOut->bmiHeader.biClrUsed > 0) {
        // Get Palette info
        if ((ii = GetPaletteEntries(lpcs->hPalCurrent, 0,
                                (UINT) lpBitsInfoOut->bmiHeader.biClrUsed,
                                (LPPALETTEENTRY) argbq)) !=
                    (UINT)lpBitsInfoOut->bmiHeader.biClrUsed)
            goto FileError;

	// Reorder the palette from PALETTEENTRY order to RGBQUAD order
	// by swapping the red and blue palette entries.
        //for (ii = 0; ii < lpBitsInfoOut->bmiHeader.biClrUsed; ++ii)
        while (ii--)
            SWAPTYPE(argbq[ii].rgbRed, argbq[ii].rgbBlue, BYTE);


        // Write Palette Info
        dw = sizeof(RGBQUAD) * lpBitsInfoOut->bmiHeader.biClrUsed;
        if (mmioWrite(lpcs->hmmio, (LPBYTE)argbq, dw) != (long)dw)
            goto FileError;
    }

    if (mmioAscend(lpcs->hmmio, &ck, 0))
         goto FileError;

    // ADD FOURCC stuff here!!! for Video stream

    // Ascend out of stream header
    if (mmioAscend(lpcs->hmmio, &ckStream, 0))
         goto FileError;

    /* If sound is enabled, then write WAVE header */
    if (fSound) {

         /* Create stream header list */
         ckStream.cksize = 0;
         ckStream.fccType = listtypeSTREAMHEADER;
         if (mmioCreateChunk(lpcs->hmmio,&ckStream,MMIO_CREATELIST))
             goto FileError;

         ZeroMemory (&strhdr, sizeof(strhdr));
         strhdr.fccType = streamtypeAUDIO;
         strhdr.fccHandler = 0L;
         strhdr.dwFlags = 0L;
        #ifdef NEW_COMPMAN
         strhdr.wPriority = 0L;
         strhdr.wLanguage = 0L;
        #else
         strhdr.dwPriority  = 0L;
        #endif
         strhdr.dwInitialFrames = 0L;
         strhdr.dwScale = lpcs->lpWaveFormat->nBlockAlign;
         strhdr.dwRate = lpcs->lpWaveFormat->nAvgBytesPerSec;
         strhdr.dwStart = 0L;
         strhdr.dwLength =  lpcs->dwWaveBytes /
                        lpcs->lpWaveFormat->nBlockAlign;
         strhdr.dwQuality = (DWORD)-1L;    /* !!! ICQUALITY_DEFAULT */
         strhdr.dwSampleSize = lpcs->lpWaveFormat->nBlockAlign;

         ck.ckid = ckidSTREAMHEADER;
         if (mmioCreateChunk(lpcs->hmmio,&ck,0) ||
             mmioWrite(lpcs->hmmio, (LPBYTE)&strhdr, sizeof(strhdr)) != sizeof(strhdr) ||
             mmioAscend(lpcs->hmmio, &ck, 0))
             goto FileError;

         ck.cksize = (LONG) GetSizeOfWaveFormat ((LPWAVEFORMATEX) lpcs->lpWaveFormat);
         ck.ckid = ckidSTREAMFORMAT;
         if (mmioCreateChunk(lpcs->hmmio,&ck,0) ||
             mmioWrite(lpcs->hmmio, (LPBYTE)lpcs->lpWaveFormat, ck.cksize) != (LONG) ck.cksize ||
             mmioAscend(lpcs->hmmio, &ck, 0))
             goto FileError;

         /* Ascend out of stream header */
         if (mmioAscend(lpcs->hmmio, &ckStream, 0))
             goto FileError;
    }

    // ADD FOURCC stuff here!!! for entire file
    DSTATUS(lpcs, "Writing Info chunks");
    if (lpcs->lpInfoChunks) {
        DSTATUS(lpcs, "Writing Info chunks");
        if (mmioWrite (lpcs->hmmio, lpcs->lpInfoChunks, lpcs->cbInfoChunks) !=
                lpcs->cbInfoChunks)
            goto FileError;
    }

    /* ascend from the Header list */
    if (mmioAscend(lpcs->hmmio, &ckList, 0))
         goto FileError;


    ck.ckid = ckidAVIPADDING;
    if (mmioCreateChunk(lpcs->hmmio,&ck,0))
         goto FileError;

    mmioSeek(lpcs->hmmio, lpcs->dwAVIHdrSize - 3 * sizeof(DWORD), SEEK_SET);

    if (mmioAscend(lpcs->hmmio, &ck, 0))
         goto FileError;

    DSTATUS(lpcs, "Writing Movie LIST");

    /* Start the movi list */
    ckList.cksize = 0;
    ckList.fccType = listtypeAVIMOVIE;
    if (mmioCreateChunk(lpcs->hmmio,&ckList,MMIO_CREATELIST))
         goto FileError;

    // Force the chunk to end on the next word boundary
    dprintf("IndexStartOffset = %8X\n", dwDataEnd);
    mmioSeek(lpcs->hmmio, dwDataEnd + (dwDataEnd & 1L), SEEK_SET);

    /* Ascend out of the movi list and the RIFF chunk so that */
    /* the sizes can be fixed */
    mmioAscend(lpcs->hmmio, &ckList, 0);

    /*
    ** Now write index out!
    */
    DSTATUS(lpcs, "Writing Index...");
    WriteIndex(lpcs, fWroteJunkChunks);

    lpcs->fFileCaptured = TRUE;     // we got a good file, allow editing of it
    goto Success;

FileError:
    lpcs->fFileCaptured = fRet = FALSE;      // bogus file - no editing allowed

Success:
    DSTATUS(lpcs, "Freeing Index...");
    FiniIndex (lpcs);
    mmioAscend(lpcs->hmmio, &ckRiff, 0);

    mmioSeek(lpcs->hmmio, 0, SEEK_END);

    mmioFlush(lpcs->hmmio, 0);

    // Close the file
    mmioClose(lpcs->hmmio, 0);
    lpcs->hmmio = NULL;

    return fRet;
}

//
// Prepends dummy frame entries to the current valid video frame.
// Bumps the index, but does not actually trigger a write operation.
// nCount is a count of the number of frames to write
// Returns: TRUE on a successful write

BOOL WINAPI AVIWriteDummyFrames (
    LPCAPSTREAM lpcs,
    UINT        nCount,
    LPUINT      lpuError,
    LPBOOL      lpbPending)
{
    DWORD  dwBytesToWrite;
    DWORD  dwType;
    LPRIFF priff;
    UINT   jj;

    *lpbPending = FALSE;
    *lpuError = 0;
    if ( ! nCount)
        return TRUE;

    // create a buffer full of dummy chunks to act as placeholders
    // for the dropped frames
    //
    dwType = MAKEAVICKID(cktypeDIBbits, 0);
    if (lpcs->lpBitsInfo->bmiHeader.biCompression == BI_RLE8)
        dwType = MAKEAVICKID(cktypeDIBcompressed, 0);

    // dont try to write more than 1 'sector' worth of dummy
    // frames
    //
    dwBytesToWrite = nCount * sizeof(RIFF);
    if (dwBytesToWrite > lpcs->dwBytesPerSector)
    {
#ifdef DEBUG
	UINT n = nCount;
#endif
        dwBytesToWrite = lpcs->dwBytesPerSector;
#ifdef DEBUG
        nCount = dwBytesToWrite / sizeof(RIFF);
	assert(nCount*sizeof(RIFF) == dwBytesToWrite);
	dprintf("Forced to reduce dummy frames from %d to %d", n, nCount);
#endif
    }

    // create index entries for the dummy chunks
    //
    for (jj = 0; jj < nCount-1; ++jj)
        IndexVideo (lpcs, IS_DUMMY_CHUNK, FALSE);
    IndexVideo (lpcs, IS_DUMMY_CHUNK | IS_GRANULAR_CHUNK, FALSE);

    // fill in the drop frame buffer with dummy frames
    //
    priff = (LPRIFF)lpcs->lpDropFrame;
    for (jj = 0; jj < nCount; ++jj, ++priff)
    {
        priff->dwSize  = 0;
        priff->dwType  = dwType;
    }

    //
    // cant use a single dummy frame buffer when we are doing async
    // write because we cant write 'n' dummy frames to the buffer
    // if it is currently already queued to an IO.
    //
    // perhaps several dummy frames?  1 frame, 2 frames, 3 frames, etc
    // create dynamically?
    //

    // write out the dummy frames
    //
    AuxDebugEx (3, DEBUGLINE "DummyFrames  Count=%d, ToWrite=%d\r\n",
                nCount, dwBytesToWrite);

    *lpuError = AVIWrite (lpcs,
                          lpcs->lpDropFrame,
                          dwBytesToWrite,
                          (UINT)-1,  // force sync completion
                          ASYNC_BUF_DROP,
                          lpbPending);
    return !(*lpuError);
}

// Writes compressed or uncompressed frames to the AVI file
// returns TRUE if no error, FALSE if end of file.
//
BOOL WINAPI AVIWriteVideoFrame (
    LPCAPSTREAM lpcs,
    LPBYTE      lpData,
    DWORD       dwBytesUsed,
    BOOL        fKeyFrame,
    UINT        uIndex,
    UINT        nDropped,
    LPUINT      lpuError,
    LPBOOL      lpbPending)
{
    DWORD  dwBytesToWrite;
    LPRIFF priff;

    *lpuError = 0;
    *lpbPending = FALSE;
    if (!IndexVideo (lpcs,
                dwBytesUsed | (nDropped ? 0 : IS_GRANULAR_CHUNK),
                fKeyFrame))
        return FALSE;

    // adjust the size field of the RIFF chunk that preceeds the
    // data to be written
    //
    priff = ((LPRIFF)lpData)-1;
    priff->dwSize = dwBytesUsed;
    dwBytesUsed += dwBytesUsed & 1;
    dwBytesToWrite = dwBytesUsed + sizeof(RIFF);

    if (nDropped)
    {
        UINT  jj;
        DWORD dwType;

        // determine the 'type' of the dummy chunks
        //
        //dwType = priff->dwType;
        dwType = MAKEAVICKID(cktypeDIBbits, 0);
        if (lpcs->lpBitsInfo->bmiHeader.biCompression == BI_RLE8)
            dwType = MAKEAVICKID(cktypeDIBcompressed, 0);

        // dont try to write more than 1 'sector' worth of dummy
        // frames
        //
        if (nDropped > (lpcs->dwBytesPerSector / sizeof(RIFF)))
            nDropped = lpcs->dwBytesPerSector / sizeof(RIFF);

        // create index entries for the dummy chunks
        //
        for (jj = 0; jj < nDropped-1; ++jj)
            IndexVideo (lpcs, IS_DUMMY_CHUNK, FALSE);

        IndexVideo (lpcs, IS_DUMMY_CHUNK | IS_GRANULAR_CHUNK, FALSE);

        // fill in the drop frame buffer with dummy frames
        //
        priff = (LPRIFF)(lpData + dwBytesToWrite - sizeof(RIFF));
        for (jj = 0; jj < nDropped; ++jj, ++priff)
        {
            priff->dwSize  = 0;
            priff->dwType  = dwType;
        }
        dwBytesToWrite += nDropped * sizeof(RIFF);
    }

    // AviWrite will write the data and create any trailing junk
    // that is necessary
    //

    // write out the chunk, video data, and possibly the junk chunk
    //
    AuxDebugEx (3, DEBUGLINE "Calling AVIWrite - Video=%8x dw=%8x\r\n",
                (LPBYTE)lpData - sizeof(RIFF), dwBytesToWrite);

    *lpuError = AVIWrite (lpcs,
                          (LPBYTE)lpData - sizeof(RIFF),
                          dwBytesToWrite,
                          uIndex,
                          ASYNC_BUF_VIDEO,
                          lpbPending);
    return !(*lpuError);
}

// New for Chicago, align audio buffers on wChunkGranularity boundaries!
//
BOOL WINAPI AVIWriteAudio (
    LPCAPSTREAM lpcs,
    LPWAVEHDR   lpwh,
    UINT        uIndex,
    LPUINT      lpuError,
    LPBOOL      lpbPending)
{
    DWORD  dwBytesToWrite;
    LPRIFF priff;

    *lpuError = 0;
    *lpbPending = FALSE;

    // change the dwSize field in the RIFF chunk
    priff = ((LPRIFF)lpwh->lpData) -1;
    priff->dwSize = lpwh->dwBytesRecorded;

    if ( ! IndexAudio (lpcs, lpwh->dwBytesRecorded | IS_GRANULAR_CHUNK))
        return FALSE;

    // update total bytes of wave audio recorded
    //
    lpcs->dwWaveBytes += lpwh->dwBytesRecorded;

    // pad the data to be written to a WORD (16 bit) boundary
    //
    lpwh->dwBytesRecorded += lpwh->dwBytesRecorded & 1;
    dwBytesToWrite = lpwh->dwBytesRecorded + sizeof(RIFF);

    // write out the chunk, audio data, and possibly the junk chunk
    AuxDebugEx (3, DEBUGLINE "Audio=%8x dw=%8x\r\n",
                lpwh->lpData - sizeof(RIFF), dwBytesToWrite);
    *lpuError = AVIWrite (lpcs,
                          lpwh->lpData - sizeof(RIFF),
                          dwBytesToWrite,
                          uIndex,
                          ASYNC_BUF_AUDIO,
                          lpbPending);
    return !(*lpuError);
}
    #endif  //---------------- USE_AVIFILE ----------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avicap\capmci.c ===
/****************************************************************************
 *
 *   capmci.c
 *
 *   Control of MCI devices during capture.
 *
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992 - 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and
 *    distribute the Sample Files (and/or any modified version) in
 *    any way you find useful, provided that you agree that
 *    Microsoft has no warranty obligations or liability for any
 *    Sample Application Files which are modified.
 *
 ***************************************************************************/

#define INC_OLE2
#pragma warning(disable:4103)
#include <windows.h>
#include <windowsx.h>
#include <win32.h>
#include <mmsystem.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <msvideo.h>
#include <drawdib.h>
#include <mmddk.h>

#include <avifmt.h>
#include "ivideo32.h"
#include "avicap.h"
#include "avicapi.h"

#include "mmdebug.h"

#ifdef _DEBUG
    #define DSTATUS(lpcs, sz) statusUpdateStatus(lpcs, IDS_CAP_INFO, (LPTSTR) TEXT(sz))
#else
    #define DSTATUS(lpcs, sz)
#endif

DWORD SendDriverFormat (LPCAPSTREAM lpcs, LPBITMAPINFOHEADER lpbih, DWORD dwInfoHeaderSize);

/*--------------------------------------------------------------+
| TimeMSToHMSString() - change milliseconds into SMPTE time     |
+--------------------------------------------------------------*/
void FAR PASCAL TimeMSToSMPTE (DWORD dwMS, LPTSTR lpTime)
{
	DWORD	dwTotalSecs;
	LONG	lHundredths;
	WORD	wSecs;
	WORD	wMins;
	WORD	wHours;

	/* convert to number of seconds */
	dwTotalSecs = dwMS / 1000;
	
	/* keep the remainder part */
	lHundredths = (dwMS - (dwTotalSecs * 1000)) / 10;
		
	/* break down into other components */
	wHours = (WORD)(dwTotalSecs / 3600);	// get # Hours
	dwTotalSecs -= (wHours * 3600);
	
	wMins = (WORD)(dwTotalSecs / 60);	// get # Mins
	dwTotalSecs -= (wMins * 60);
	
	wSecs = (WORD)dwTotalSecs;	// what's left is # seconds
	
	/* build the string */
	/* KLUDGE, force hundredths to SMPTE approximation of PAL frames */
	wsprintf((LPTSTR)lpTime, TEXT("%02u:%02u:%02u:%02lu"), wHours, wMins,
		    wSecs, (lHundredths * 25) / 100);
}


/*--------------------------------------------------------------+
| START OF MCI CONTROL SECTION                                 |
+--------------------------------------------------------------*/

/*
 *  CountMCIDevicesByType
 *      Returns a count of the number of VCR or Videodisc
 *      devices that MCI claims to know about.
 */

int CountMCIDevicesByType ( UINT wType )
{
   int nTotal;
   DWORD dwCount;
   MCI_SYSINFO_PARMS mciSIP;

   mciSIP.dwCallback = 0;
   mciSIP.lpstrReturn = (LPTSTR) (LPVOID) &dwCount;
   mciSIP.dwRetSize = sizeof (dwCount);

   mciSIP.wDeviceType = wType;

   if (!mciSendCommand (0, MCI_SYSINFO, MCI_SYSINFO_QUANTITY,
        (DWORD) (LPVOID) &mciSIP))
       nTotal = (int) *( (LPDWORD) mciSIP.lpstrReturn);

   return nTotal;
}

/*
 *  MCIDeviceClose
 *      This routine closes the open MCI device.
 */

void MCIDeviceClose (LPCAPSTREAM lpcs)
{
    mciSendString( TEXT("close mciframes"), NULL, 0, NULL );
}

/*
 *  MCIDeviceOpen
 *      This routine opens the mci device for use, and sets the
 *      time format to milliseconds.
 *      Return FALSE on error;
 */

BOOL MCIDeviceOpen (LPCAPSTREAM lpcs)
{
    TCHAR        ach[160];

    wsprintf( ach, TEXT("open %s shareable alias mciframes"),
                (LPTSTR) lpcs->achMCIDevice);
    lpcs->dwMCIError = mciSendString( ach, NULL, 0, NULL );
    if( lpcs->dwMCIError ) {
        DPF (" MCI Error, open %s shareable alias mciframes", lpcs->achMCIDevice);
        goto err_return;
    }
    lpcs->dwMCIError = mciSendString( TEXT("set mciframes time format milliseconds"),
        NULL, 0, NULL );
    if( lpcs->dwMCIError ) {
        DPF (" MCI Error, set mciframes time format milliseconds");
        goto err_close;
    }
    return ( TRUE );

err_close:
    MCIDeviceClose (lpcs);
err_return:
    return ( FALSE );
}


/*
 *  MCIDeviceGetPosition
 *      Stores the current device position in milliseconds in lpdwPos.
 *      Returns TRUE on success, FALSE if error.
 */
BOOL FAR PASCAL MCIDeviceGetPosition (LPCAPSTREAM lpcs, LPDWORD lpdwPos)
{
    TCHAR        ach[80];
    LPTSTR       p;
    LONG        lv;

    lpcs->dwMCIError = mciSendString( TEXT("status mciframes position wait"),
        ach, sizeof(ach)/sizeof(TCHAR), NULL );
    if( lpcs->dwMCIError ) {
        DPF (" MCI Error, status mciframes position wait");
        *lpdwPos = 0L;
        return FALSE;
    }

    p = ach;

    while (*p == ' ') p++;
    for (lv = 0; *p >= '0' && *p <= '9'; p++)
        lv = (10 * lv) + (*p - '0');
    *lpdwPos = lv;
    return TRUE;
}

/*
 *  MCIDeviceSetPosition
 *      Sets the current device position in milliseconds.
 *      Returns TRUE on success, FALSE if error.
 */
BOOL FAR PASCAL MCIDeviceSetPosition (LPCAPSTREAM lpcs, DWORD dwPos)
{
    TCHAR        achCommand[40];
    TCHAR        ach[80];

    lpcs->dwMCIError = mciSendString( TEXT("pause mciframes wait"), ach, sizeof(ach)/sizeof(TCHAR), NULL );
    if (lpcs->dwMCIError) {
        DPF (" MCI Error, pause mciframes wait");
        return FALSE;
    }
    wsprintf(achCommand, TEXT("seek mciframes to %ld wait"), dwPos);
    lpcs->dwMCIError = mciSendString( achCommand, ach, sizeof(ach)/sizeof(TCHAR), NULL );
    if (lpcs->dwMCIError)
        DPF (" MCI Error, seek mciframes to %ld wait", dwPos);
    return ( lpcs->dwMCIError == 0 ? TRUE : FALSE );
}


/*
 *  MCIDevicePlay
 *      Start playing the current MCI device from the current position
 *      Returns TRUE on success, FALSE if error.
 */
BOOL FAR PASCAL MCIDevicePlay (LPCAPSTREAM lpcs)
{
    TCHAR        ach[80];

    lpcs->dwMCIError = mciSendString( TEXT("play mciframes"), ach, sizeof(ach)/sizeof(TCHAR), NULL );
    if (lpcs->dwMCIError)
        DPF (" MCI Error, play mciframes");
    return ( lpcs->dwMCIError == 0 ? TRUE : FALSE );
}

/*
 *  MCIDevicePause
 *      Pauses the current MCI device at the current position
 *      Returns TRUE on success, FALSE if error.
 */
BOOL FAR PASCAL MCIDevicePause (LPCAPSTREAM lpcs)
{
    TCHAR        ach[80];

    lpcs->dwMCIError = mciSendString( TEXT("pause mciframes wait"), ach, sizeof(ach)/sizeof(TCHAR), NULL );
    if (lpcs->dwMCIError)
        DPF (" MCI Error, pause mciframes wait");
    return ( lpcs->dwMCIError == 0 ? TRUE : FALSE );
}

/*
 *  MCIDeviceStop
 *      Stops the current MCI device
 *      Returns TRUE on success, FALSE if error.
 */
BOOL FAR PASCAL MCIDeviceStop (LPCAPSTREAM lpcs)
{
    TCHAR        ach[80];

    lpcs->dwMCIError = mciSendString( TEXT("stop mciframes wait"), ach, sizeof(ach)/sizeof(TCHAR), NULL );
    if (lpcs->dwMCIError)
        DPF (" MCI Error, stop mciframes wait");
    return ( lpcs->dwMCIError == 0 ? TRUE : FALSE );
}

/*
 *  MCIDeviceStep
 *      Step the current MCI at the current position
 *      Returns TRUE on success, FALSE if error.
 */
BOOL FAR PASCAL MCIDeviceStep (LPCAPSTREAM lpcs, BOOL fForward)
{
    TCHAR        ach[80];

    lpcs->dwMCIError = mciSendString(
                          fForward ? TEXT("step mciframes wait") :
                TEXT("step mciframes reverse wait"), ach, sizeof(ach)/sizeof(TCHAR), NULL );
    if (lpcs->dwMCIError)
        DPF (" MCI Error, step mciframes wait");
    return ( lpcs->dwMCIError == 0 ? TRUE : FALSE );
}

/*
 *  MCIDeviceFreeze
 *      freeze the current frame
 *      Returns TRUE on success, FALSE if error.
 */
BOOL FAR PASCAL MCIDeviceFreeze(LPCAPSTREAM lpcs, BOOL fFreeze)
{
    lpcs->dwMCIError = mciSendString( fFreeze ? TEXT("freeze mciframes wait") :
                TEXT("unfreeze mciframes wait"), NULL, 0, NULL);
    if (lpcs->dwMCIError)
        DPF (" MCI Error, freeze mciframes wait");
    return ( lpcs->dwMCIError == 0 ? TRUE : FALSE );
}


/*
 *  MCIStepCapture
 *      Main routine for performing MCI step capture.
 *
 */
void FAR PASCAL _LOADDS MCIStepCapture (LPCAPSTREAM lpcs)
{
    BOOL        fOK = TRUE;
    BOOL        fT;
    BOOL        fStopping;         // True when finishing capture
    DWORD       dw;
    int         iNumAudio;
    UINT        wError;         // Error String ID
    LPVIDEOHDR  lpVidHdr;
    LPWAVEHDR   lpWaveHdr;
    DWORD       dwTimeToStop;   // Lesser of MCI capture time or frame limit
    BOOL        fTryToPaint = FALSE;
    HDC         hdc;
    HPALETTE    hpalT;
    RECT        rcDrawRect;
#define PROMPTFORSTEPCAPTURE
#ifdef PROMPTFORSTEPCAPTURE
    TCHAR       ach[128];
    TCHAR       achMsg[128];
#endif

    statusUpdateStatus(lpcs, IDS_CAP_BEGIN);  // Always the first message

    // Verify capture parameters
    if ((!lpcs->sCapParms.fMCIControl) ||
        (!lpcs->sCapParms.fStepMCIDevice))
        goto EarlyExit;

    lpcs->MCICaptureState = CAPMCI_STATE_Uninitialized;

    lpcs->fCaptureFlags |= (CAP_fCapturingNow | CAP_fStepCapturingNow);
    lpcs->dwReturn = DV_ERR_OK;

    // If not 1 Meg. free, give it up!!!
    if (GetFreePhysicalMemory () < (1024L * 1024L)) {
        errorUpdateError (lpcs, IDS_CAP_OUTOFMEM);
        goto EarlyExit;
    }

    statusUpdateStatus(lpcs, IDS_CAP_STAT_CAP_INIT);

    // Try painting the DIB only if Live window
    fTryToPaint = lpcs->fLiveWindow;

    if (fTryToPaint) {
        hdc = GetDC(lpcs->hwnd);
        SetWindowOrgEx(hdc, lpcs->ptScroll.x, lpcs->ptScroll.y, NULL);
        hpalT = DrawDibGetPalette (lpcs->hdd);
        if (hpalT)
            hpalT = SelectPalette( hdc, hpalT, FALSE);
        RealizePalette(hdc);
        if (lpcs->fScale)
            GetClientRect (lpcs->hwnd, &rcDrawRect);
        else
            SetRect (&rcDrawRect, 0, 0, lpcs->dxBits, lpcs->dyBits);
    }

    // -------------------------------------------------------
    //   When should capture stop?
    // -------------------------------------------------------

    // If using MCI, capture for the shorter of the MCI period,
    // or the capture limit

    if (lpcs->sCapParms.fLimitEnabled)
        dwTimeToStop = (DWORD) ((DWORD) 1000 * lpcs->sCapParms.wTimeLimit);
    else
        dwTimeToStop = (DWORD) -1L; // very large

    if (lpcs->sCapParms.fMCIControl) {
        // if MCI stop time not given, use lpcs->sCapParms.wTimeLimit
        if (lpcs->sCapParms.dwMCIStopTime == lpcs->sCapParms.dwMCIStartTime)
                    lpcs->sCapParms.dwMCIStopTime = lpcs->sCapParms.dwMCIStartTime +
                    (DWORD) ((DWORD)1000 * lpcs->sCapParms.wTimeLimit);

        dw = lpcs->sCapParms.dwMCIStopTime - lpcs->sCapParms.dwMCIStartTime;

        if (lpcs->sCapParms.fLimitEnabled)
            dwTimeToStop = min (dw, dwTimeToStop);
        else
            dwTimeToStop = dw;
    }

    //
    // never ever try to capture more than the index size!
    //
    if (lpcs->fCaptureFlags & CAP_fCapturingToDisk) {
	dw = MulDiv(lpcs->sCapParms.dwIndexSize,
                lpcs->sCapParms.dwRequestMicroSecPerFrame,
                1000l);
	dwTimeToStop = min (dw, dwTimeToStop);
    }

    fOK = FALSE;            // Assume the worst
    if (MCIDeviceOpen (lpcs)) {
        if (MCIDeviceSetPosition (lpcs, lpcs->sCapParms.dwMCIStartTime))
            if (MCIDeviceStep (lpcs, TRUE))
                fOK = TRUE;
    }
    if (!fOK) {
        errorUpdateError (lpcs, IDS_CAP_MCI_CONTROL_ERROR);
        statusUpdateStatus(lpcs, 0);    // Clear status
        goto EarlyExit;
    }

    // -------------------------------------------------------
    //  Spatial and temporal averaging
    // -------------------------------------------------------

    // Frame Averaging, capture the same frame multiple times...
    lpcs->lpia = NULL;
    if (lpcs->sCapParms.wStepCaptureAverageFrames == 0)
        lpcs->sCapParms.wStepCaptureAverageFrames = 1;

    // Only allow averaging if an RGB format
    if (lpcs->lpBitsInfo->bmiHeader.biCompression != BI_RGB)
        lpcs->sCapParms.wStepCaptureAverageFrames = 1;

    // 2x Scaling
    lpcs->lpbmih2x = NULL;
    lpcs->VidHdr2x = lpcs->VidHdr;        // Init the 2x copy

    if (lpcs->sCapParms.fStepCaptureAt2x &&
                lpcs->lpBitsInfo->bmiHeader.biCompression == BI_RGB) {
        lpcs->VidHdr2x.lpData = NULL;
        lpcs->lpbmih2x = (LPBITMAPINFOHEADER) GlobalAllocPtr (GHND,
                sizeof (BITMAPINFOHEADER) +
                256 * sizeof (RGBQUAD));
        CopyMemory (lpcs->lpbmih2x, lpcs->lpBitsInfo,
                    sizeof (BITMAPINFOHEADER) + 256 * sizeof (RGBQUAD));

        // Try to force the driver into 2x mode
        lpcs->lpbmih2x->biHeight    *= 2;
        lpcs->lpbmih2x->biWidth     *= 2;
        lpcs->lpbmih2x->biSizeImage *= 4;
        if (!SendDriverFormat (lpcs, lpcs->lpbmih2x, sizeof (BITMAPINFOHEADER))) {
            // Success, allocate new bitspace
            lpcs->VidHdr2x.lpData = GlobalAllocPtr (GHND,
                        lpcs->lpbmih2x->biSizeImage);
            lpcs->VidHdr2x.dwBufferLength = lpcs->lpbmih2x->biSizeImage;
        }

        // Something went wrong, no memory, or driver failed request
        // so revert back to original settings
        if (!lpcs->VidHdr2x.lpData) {
            SendDriverFormat (lpcs, (LPBITMAPINFOHEADER) lpcs->lpBitsInfo,
                sizeof (BITMAPINFOHEADER));
            lpcs->sCapParms.fStepCaptureAt2x = FALSE;
            lpcs->VidHdr2x = lpcs->VidHdr;        // Back to the original settings
        }
    }
    else
        lpcs->sCapParms.fStepCaptureAt2x = FALSE;

    DPF (" StepCaptureAt2x = %d\r\n", (int) lpcs->sCapParms.fStepCaptureAt2x);

    //
    // If we're compressing while capturing, warm up the compressor
    //
#ifdef NEW_COMPMAN
    if (lpcs->CompVars.hic) {
        if (ICSeqCompressFrameStart(&lpcs->CompVars, lpcs->lpBitsInfo) == 0) {

	    // !!! We're in trouble here!
            dprintf("ICSeqCompressFrameStart failed !!!\n");
            errorUpdateError (lpcs, IDS_CAP_COMPRESSOR_ERROR);
            goto EarlyExit;
        }
        // Kludge, offset the lpBitsOut ptr
        // Compman allocates the compress buffer too large by
        // 2048 + 16 so we will still have room
        ((LPBYTE) lpcs->CompVars.lpBitsOut) += 8;
    }

    // No compression desired
    if (!lpcs->CompVars.hic)
	WinAssert(lpcs->CompVars.lpbiOut == NULL);
#endif


    // -------------------------------------------------------
    //  Open the output file
    // -------------------------------------------------------

    if (lpcs->fCaptureFlags & CAP_fCapturingToDisk) {
        if (!CapFileInit(lpcs)) {
            errorUpdateError (lpcs, IDS_CAP_FILE_OPEN_ERROR);
            goto EarlyExit;
        }
    }

    /* Make sure the parent has been repainted */
    UpdateWindow(lpcs->hwnd);

    //
    // AVIInit will allocate sound buffers, but not video buffers
    // when performing step capture.
    //

    wError = IDS_CAP_AVI_INIT_ERROR;
    lpcs->hCaptureEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (lpcs->hCaptureEvent)
    {
       #ifdef CHICAGO
        lpcs->hRing0CapEvt = OpenVxDHandle (lpcs->hCaptureEvent);
        if ( ! lpcs->hRing0CapEvt)
            CloseHandle (lpcs->hCaptureEvent), lpcs->hCaptureEvent = NULL;
        else
       #endif
	wError = AVIInit(lpcs);
    }

    if (wError) {
        lpcs->sCapParms.fUsingDOSMemory = FALSE;
        wError = AVIInit(lpcs);
    }

    if (wError) {
        /* Error in initalization - return */
        errorUpdateError (lpcs, wError);
        AVIFini(lpcs);
        AVIFileFini(lpcs, TRUE /* fWroteJunkChunks */, TRUE /* fAbort */);
        statusUpdateStatus(lpcs, 0);    // Clear status
	// assert(lpcs->dwReturn == wError);
        goto EarlyExit;
    }

#ifdef PROMPTFORSTEPCAPTURE
    // -------------------------------------------------------
    //   Ready to go, make the user click OK?
    // -------------------------------------------------------

    // Click OK to capture string (must follow AVIInit)
    //
    LoadString(lpcs->hInst, IDS_CAP_SEQ_MSGSTART, ach, NUMELMS(ach));
    wsprintf(achMsg, ach, (LPBYTE)lpcs->achFile);

    if (lpcs->sCapParms.fMakeUserHitOKToCapture && (lpcs->fCaptureFlags & CAP_fCapturingToDisk))
    {
        UINT idBtn;

        idBtn = MessageBox (lpcs->hwnd, achMsg, TEXT(""),
                            MB_OKCANCEL | MB_ICONEXCLAMATION);

        if (idBtn == IDCANCEL)
        {
            AVIFini(lpcs);
            AVIFileFini (lpcs, TRUE, TRUE);
            statusUpdateStatus (lpcs, 0);
            goto EarlyExit;
        }
    }
#endif // PROMPTFORSTEPCAPTURE

    /* update the status, so the user knows how to stop */
    statusUpdateStatus(lpcs, IDS_CAP_SEQ_MSGSTOP);
    UpdateWindow(lpcs->hwnd);


    if (lpcs->sCapParms.fStepCaptureAt2x || (lpcs->sCapParms.wStepCaptureAverageFrames != 1)) {
        LPIAVERAGE FAR * lppia = (LPIAVERAGE FAR *) &lpcs->lpia;

        statusUpdateStatus (lpcs, IDS_CAP_STAT_PALETTE_BUILD);
        if (!iaverageInit (lppia, lpcs->lpBitsInfo, lpcs->hPalCurrent)) {
            lpcs->dwReturn = IDS_CAP_OUTOFMEM;
            goto CompressFrameFailure;
        }
        statusUpdateStatus(lpcs, 0);
    }
    DPF (" Averaging %d frames\r\n", lpcs->sCapParms.wStepCaptureAverageFrames);

    GetAsyncKeyState(lpcs->sCapParms.vKeyAbort);
    GetAsyncKeyState(VK_ESCAPE);
    GetAsyncKeyState(VK_LBUTTON);
    GetAsyncKeyState(VK_RBUTTON);


    // -------------------------------------------------------
    //   MAIN VIDEO CAPTURE LOOP
    // -------------------------------------------------------

    fOK=TRUE;             // Set FALSE on write errors
    fStopping = FALSE;    // TRUE when we need to stop

    lpVidHdr  = &lpcs->VidHdr;
    lpWaveHdr = lpcs->alpWaveHdr[lpcs->iNextWave];

    lpcs->MCICaptureState = CAPMCI_STATE_Initialized;
    lpcs->dwTimeElapsedMS = 0;

    // Move back to the starting position
    MCIDeviceSetPosition (lpcs, lpcs->sCapParms.dwMCIStartTime);
    MCIDevicePause (lpcs);

    // Where are we *really*
    MCIDeviceGetPosition (lpcs, &lpcs->dwMCIActualStartMS);

    // freeze video
    MCIDeviceFreeze(lpcs, TRUE);

    while (lpcs->MCICaptureState != CAPMCI_STATE_AllFini) {

        // -------------------------------------------------------
        //   is there any reason to stop or change states
        // -------------------------------------------------------
        if (lpcs->sCapParms.vKeyAbort) {
            if (GetAsyncKeyState(lpcs->sCapParms.vKeyAbort & 0x00ff) & 0x0001) {
                fT = TRUE;
                if (lpcs->sCapParms.vKeyAbort & 0x8000)  // Ctrl?
                    fT = fT && (GetAsyncKeyState(VK_CONTROL) & 0x8000);
                if (lpcs->sCapParms.vKeyAbort & 0x4000)  // Shift?
                    fT = fT && (GetAsyncKeyState(VK_SHIFT) & 0x8000);
                fStopping = fT;      // User aborts
            }
        }
#if 0
        // Ignore Left mouse on MCI Capture!!!
        if (lpcs->sCapParms.fAbortLeftMouse)
            if (GetAsyncKeyState(VK_LBUTTON) & 0x0001)
                fStopping = TRUE;      // User aborts
#endif

        if (lpcs->sCapParms.fAbortRightMouse)
            if (GetAsyncKeyState(VK_RBUTTON) & 0x0001)
                fStopping = TRUE;      // User aborts
        if (lpcs->fCaptureFlags & CAP_fAbortCapture) {
            fStopping = TRUE;          // Somebody above wants us to quit
        }
        if (lpcs->dwTimeElapsedMS > dwTimeToStop)
            fStopping = TRUE;      // all done


        // -------------------------------------------------------
        //    State machine
        // -------------------------------------------------------
        switch (lpcs->MCICaptureState) {

        case CAPMCI_STATE_Initialized:
            // Begin video step capture
            DSTATUS(lpcs, "MCIState: Initialized");
            lpcs->MCICaptureState = CAPMCI_STATE_StartVideo;
            break;

        case CAPMCI_STATE_StartVideo:
            // Begin video step capture
            lpcs->dwTimeElapsedMS = 0;
            lpcs->MCICaptureState = CAPMCI_STATE_CapturingVideo;
            break;

        case CAPMCI_STATE_CapturingVideo:
            // In the state of capturing video
            if ((lpcs->fCaptureFlags & CAP_fStopCapture) || (lpcs->fCaptureFlags & CAP_fAbortCapture))
                fStopping = TRUE;

            if (fStopping) {
                MCIDeviceGetPosition (lpcs, &lpcs->dwMCIActualEndMS);
                MCIDevicePause (lpcs);

                DSTATUS(lpcs, "MCIState: StoppingVideo");

                if (fOK && !(lpcs->fCaptureFlags & CAP_fAbortCapture))
                    lpcs->MCICaptureState = CAPMCI_STATE_VideoFini;
                else
                    lpcs->MCICaptureState = CAPMCI_STATE_AllFini;

                lpcs->fCaptureFlags &= ~CAP_fStopCapture;
                lpcs->fCaptureFlags &= ~CAP_fAbortCapture;
                fStopping = FALSE;
            }
            break;

        case CAPMCI_STATE_VideoFini:
            // Wait for all buffers to be returned from the driver
            // Then move on to audio capture
            lpcs->MCICaptureState = CAPMCI_STATE_StartAudio;
            DSTATUS(lpcs, "MCIState: VideoFini");
            break;

        case CAPMCI_STATE_StartAudio:
            // If no audio, go to AllFini state
            if (!lpcs->sCapParms.fCaptureAudio || !fOK) {
                lpcs->MCICaptureState = CAPMCI_STATE_AllFini;
                break;
            }

            // Move back to the starting position
            MCIDeviceSetPosition (lpcs, lpcs->dwMCIActualStartMS);
            MCIDeviceGetPosition (lpcs, &lpcs->dwMCICurrentMS);
            DSTATUS(lpcs, "MCIState: StartAudio");
            MCIDevicePlay (lpcs);
            waveInStart(lpcs->hWaveIn);
            lpcs->MCICaptureState = CAPMCI_STATE_CapturingAudio;
            lpcs->dwTimeElapsedMS = 0;
            fStopping = FALSE;
            break;

        case CAPMCI_STATE_CapturingAudio:
            // In the state of capturing audio
            if ((lpcs->fCaptureFlags & CAP_fStopCapture) || (lpcs->fCaptureFlags & CAP_fAbortCapture))
                fStopping = TRUE;

            MCIDeviceGetPosition (lpcs, &lpcs->dwMCICurrentMS);
            if (lpcs->dwMCICurrentMS + 100 > lpcs->dwMCIActualEndMS)
                fStopping = TRUE;
            if (fStopping) {
                waveInStop(lpcs->hWaveIn);
                MCIDevicePause (lpcs);
                waveInReset(lpcs->hWaveIn);
                lpcs->MCICaptureState = CAPMCI_STATE_AudioFini;
            }
            break;

        case CAPMCI_STATE_AudioFini:
            // While more audio buffers to process
            if (lpWaveHdr->dwFlags & WHDR_DONE)
                break;
            lpcs->MCICaptureState = CAPMCI_STATE_AllFini;
            break;

        case CAPMCI_STATE_AllFini:
            DSTATUS(lpcs, "MCIState: AllFini");
            if (fOK)
                statusUpdateStatus(lpcs, IDS_CAP_STAT_CAP_FINI, lpcs->dwVideoChunkCount);
            else
                statusUpdateStatus(lpcs, IDS_CAP_RECORDING_ERROR2);
            break;
        }

        // -------------------------------------------------------
        //        If we are in the video capture phase
        // -------------------------------------------------------

        if (lpcs->MCICaptureState == CAPMCI_STATE_CapturingVideo) {
            BOOL   fKeyFrame;
            LPBYTE lpData;
            DWORD  dwBytesUsed;

            // if averaging...
            if (lpcs->lpia) {
                int j;

                iaverageZero (lpcs->lpia);

                // sum together a bunch of frames
                for (j = 0; j < (int)lpcs->sCapParms.wStepCaptureAverageFrames; j++) {

                    videoFrame( lpcs->hVideoIn, &lpcs->VidHdr2x);

    	            // Shrink by 2x??
                    if (lpcs->sCapParms.fStepCaptureAt2x) {
                        CrunchDIB(
                            lpcs->lpia,        // image averaging structure
                            (LPBITMAPINFOHEADER)  lpcs->lpbmih2x,  // BITMAPINFO src
                            (LPVOID) lpcs->VidHdr2x.lpData,      // input bits
                            (LPBITMAPINFOHEADER)  lpcs->lpBitsInfo, // BITMAPINFO dst
                            (LPVOID) lpcs->VidHdr.lpData);       // output bits
                    }
                    iaverageSum (lpcs->lpia, lpcs->lpBits);
                }
                iaverageDivide (lpcs->lpia, lpcs->lpBits);
            }
            // otherwise, not averaging, just get a frame
            else {
                videoFrame( lpcs->hVideoIn, &lpcs->VidHdr);
            }
            fKeyFrame = lpVidHdr->dwFlags & VHDR_KEYFRAME;

            #ifdef NEW_COMPMAN
            //
            // If we are automatically compressing during capture
            // compress the frame before we write it
            //
            if (lpcs->CompVars.hic)
            {
                LPRIFF priff;

                dwBytesUsed = 0;
                lpData = ICSeqCompressFrame(&lpcs->CompVars, 0,
                                            lpVidHdr->lpData,
                                            &fKeyFrame,
                                            &dwBytesUsed);

                // so what if compression fails??

                priff = ((LPRIFF)lpData) -1;
                priff->dwType = MAKEAVICKID(cktypeDIBbits, 0);
                priff->dwSize = dwBytesUsed;
            } else
            #endif // NEW_COMPMAN
            {
                 lpData = lpVidHdr->lpData;
                 dwBytesUsed = lpVidHdr->dwBytesUsed;
            }

            if (lpcs->CallbackOnVideoFrame)
                lpcs->CallbackOnVideoFrame(lpcs->hwnd, &lpcs->VidHdr);

            // Update the display
	    InvalidateRect(lpcs->hwnd, NULL, TRUE);
	    UpdateWindow(lpcs->hwnd);
	
            if (lpcs->fCaptureFlags & CAP_fCapturingToDisk) {
                UINT wError;
                BOOL bPending;
                if (!AVIWriteVideoFrame (lpcs,
                        lpData,
                        dwBytesUsed,
                        fKeyFrame,
                        (UINT)-1, 0, &wError, &bPending)) {
                    fStopping = TRUE;
                    if (wError)
                    {
                        fOK = FALSE;
                        errorUpdateError(lpcs, wError);
                    }
                assert (!bPending);
                }
            } // endif fCapturingToDisk
            // Warning: Kludge to create frame chunk count when net capture
            // follows.
            else
                lpcs->dwVideoChunkCount++;

            // if there is still more time, (or at least every 100 frames)
            // show status if we're not ending the capture
            if ((!fStopping) && (lpcs->fCaptureFlags & CAP_fCapturingToDisk) &&
                    (lpcs->dwVideoChunkCount)) {

                // "Captured %ld frames (Dropped %ld) %d.%03d sec. Hit Escape to Stop"
                statusUpdateStatus(lpcs, IDS_CAP_STAT_VIDEOCURRENT,
                        lpcs->dwVideoChunkCount, lpcs->dwFramesDropped,
                        (int)(lpcs->dwTimeElapsedMS/1000),
                        (int)(lpcs->dwTimeElapsedMS%1000)
                        );
            } // endif next buffer not ready

            // Move the MCI source to the next capture point
            // unfreeze video
            MCIDeviceFreeze(lpcs, FALSE);
            for (;;) {
                MCIDeviceGetPosition (lpcs, &lpcs->dwMCICurrentMS);
                if (lpcs->dwMCICurrentMS > ((DWORD) (lpcs->dwMCIActualStartMS +
                          MulDiv (lpcs->dwVideoChunkCount,
                                lpcs->sCapParms.dwRequestMicroSecPerFrame,
                                1000L))))
                    break;
                MCIDeviceStep (lpcs, TRUE);
            }
            // freeze video
            MCIDeviceFreeze(lpcs, TRUE);
            lpcs->dwTimeElapsedMS =
                    lpcs->dwMCICurrentMS - lpcs->dwMCIActualStartMS;

             /* return the emptied buffer to the que */
            lpVidHdr->dwFlags &= ~VHDR_DONE;
        }

        if (lpcs->CallbackOnYield) {
            // If the yield callback returns FALSE, abort
            if ( ! lpcs->CallbackOnYield(lpcs->hwnd))
                fStopping = TRUE;
        }

        if (lpcs->sCapParms.fYield) {
            MSG msg;

            if (PeekMessage(&msg,NULL,0,0,PM_REMOVE)) {
                // Kludge to get rid of timers from lpcs->hwnd
                if (msg.message == WM_TIMER && msg.hwnd == lpcs->hwnd)
                    ;
                else {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
            }
        }

        // -------------------------------------------------------
        //        Is audio buffer ready to be written?
        // -------------------------------------------------------
        if (lpcs->sCapParms.fCaptureAudio &&
                (lpcs->MCICaptureState == CAPMCI_STATE_CapturingAudio ||
                lpcs->MCICaptureState == CAPMCI_STATE_StartAudio ||
                lpcs->MCICaptureState == CAPMCI_STATE_AudioFini)) {
            int iLastWave;

            //
            // we may need to yield for audio to get converted.
            //
            if (lpcs->fAudioYield)
                Yield();

            //
            // if all buffers are done, we have broke audio.
            //
            iLastWave = lpcs->iNextWave == 0 ?
                        lpcs->iNumAudio -1 : lpcs->iNextWave-1;

            if (!fStopping &&
                    lpcs->alpWaveHdr[iLastWave]->dwFlags & WHDR_DONE)
                lpcs->fAudioBreak = TRUE;

            iNumAudio = lpcs->iNumAudio; // don't get stuck here forever...
	    // We should probably assert that iNumAudio is >= 0...

            while (iNumAudio && fOK && (lpWaveHdr->dwFlags & WHDR_DONE)) {
                iNumAudio--;
                if (lpWaveHdr->dwBytesRecorded) {
                    /* Chunk info is included in the wave data */
                    /* Reset Chunk Size in buffer */
                    ((LPRIFF)(lpWaveHdr->lpData))[-1].dwSize =
                                lpWaveHdr->dwBytesRecorded;
                    if (lpcs->CallbackOnWaveStream) {
                        lpcs->CallbackOnWaveStream(lpcs->hwnd, lpWaveHdr);
                    }
                    if (lpcs->fCaptureFlags & CAP_fCapturingToDisk) {
                        BOOL bPending = FALSE;
                        UINT wError;

                        if(!AVIWriteAudio(lpcs, lpWaveHdr, lpcs->iNextWave, &wError, &bPending)) {
                            fStopping = TRUE;
                            if (wError) {
                                fOK = FALSE;
                                errorUpdateError (lpcs, wError);
                            }
                         }
                    } // endif capturing to disk
                    // Warning: Kludge to create wave chunk count when net capture
                    // follows.
                    else {
                        lpcs->dwWaveChunkCount++;
                        lpcs->dwWaveBytes += lpWaveHdr->dwBytesRecorded;
                    }
                } // endif dwBytesRecorded

                lpWaveHdr->dwBytesRecorded = 0;
                lpWaveHdr->dwFlags &= ~WHDR_DONE;

                 /* return the emptied buffer to the device que */
                if(waveInAddBuffer(lpcs->hWaveIn, lpWaveHdr, sizeof(WAVEHDR))) {
                    fOK = FALSE;
                    fStopping = TRUE;
                    errorUpdateError(lpcs, IDS_CAP_WAVE_ADD_ERROR);
                }

                /* increment the next wave buffer pointer */
                if(++lpcs->iNextWave >= lpcs->iNumAudio)
                    lpcs->iNextWave = 0;

                lpWaveHdr = lpcs->alpWaveHdr[lpcs->iNextWave];

            } // endwhile buffer available
        } // endif sound enabled
    } // end of forever

CompressFrameFailure:

    iaverageFini (lpcs->lpia);

    // Switch back to the normal format
    if (lpcs->sCapParms.fStepCaptureAt2x) {
        SendDriverFormat (lpcs, (LPBITMAPINFOHEADER) lpcs->lpBitsInfo,
                sizeof (BITMAPINFOHEADER));
        GlobalFreePtr (lpcs->VidHdr2x.lpData);
        lpcs->VidHdr2x.lpData = NULL;
    }

    // And free the 2x memory
    if (lpcs->lpbmih2x) {
        GlobalFreePtr (lpcs->lpbmih2x);
        lpcs->lpbmih2x = NULL;
    }

    // -------------------------------------------------------
    //   END OF MAIN CAPTURE LOOP
    // -------------------------------------------------------

    lpcs->dwTimeElapsedMS = lpcs->dwMCIActualEndMS - lpcs->dwMCIActualStartMS;

    /* eat any keys that have been pressed */
    while(GetKey(FALSE))
        ;

    AVIFini(lpcs);  // does the Reset, and frees all buffers
    AVIFileFini(lpcs, TRUE /* fWroteJunkChunks */, FALSE /* fAbort */);


    /* Notify if there was an error while recording */

    if(!fOK) {
	dprintf("Replacing error %x with %x (IDS_CAP_RECORDING_ERROR)\n", lpcs->dwReturn, IDS_CAP_RECORDING_ERROR);
        errorUpdateError (lpcs, IDS_CAP_RECORDING_ERROR);
    }

    if (lpcs->fCaptureFlags & CAP_fCapturingToDisk) {
        if (lpcs->dwVideoChunkCount)
            dw = MulDiv(lpcs->dwVideoChunkCount,1000000,lpcs->dwTimeElapsedMS);
        else
            dw = 0;     // The MulDiv doesn't give 0 if numerator is zero

        if(lpcs->sCapParms.fCaptureAudio) {
            // "Captured %d.%03d sec.  %ld frames (%d dropped) (%d.%03d fps).  %ld audio bytes (%d.%03d sps)"
            statusUpdateStatus(lpcs, IDS_CAP_STAT_VIDEOAUDIO,
                  (UINT)(lpcs->dwTimeElapsedMS/1000),
                  (UINT)(lpcs->dwTimeElapsedMS%1000),
                  lpcs->dwVideoChunkCount,
                  lpcs->dwFramesDropped,
                  (UINT)(dw / 1000),
                  (UINT)(dw % 1000),
                  lpcs->dwWaveBytes,
                  (UINT) lpcs->lpWaveFormat->nSamplesPerSec / 1000,
                  (UINT) lpcs->lpWaveFormat->nSamplesPerSec % 1000);
        } else {
            // "Captured %d.%03d sec.  %ld frames (%d dropped) (%d.%03d fps)."
            statusUpdateStatus(lpcs, IDS_CAP_STAT_VIDEOONLY,
                  (UINT)(lpcs->dwTimeElapsedMS/1000),
                  (UINT)(lpcs->dwTimeElapsedMS%1000),
                  lpcs->dwVideoChunkCount,
                  lpcs->dwFramesDropped,
                  (UINT)(dw / 1000),
                  (UINT)(dw % 1000));
        }
    } // endif capturing to disk (no warnings or errors if to net)

    if (fOK) {
        // No frames captured, warn user that interrupts are probably not enabled.
        if (lpcs->dwVideoChunkCount == 0) {
            errorUpdateError (lpcs, IDS_CAP_NO_FRAME_CAP_ERROR);
        }
        // No audio captured, (but enabled), warn user audio card is hosed
        else if (lpcs->sCapParms.fCaptureAudio && (lpcs->dwWaveBytes == 0)) {
            errorUpdateError (lpcs, IDS_CAP_NO_AUDIO_CAP_ERROR);
        }

        // Audio underrun, inform user
        else if (lpcs->sCapParms.fCaptureAudio && lpcs->fAudioBreak) {
            if(lpcs->CompVars.hic) {
    	    errorUpdateError (lpcs, IDS_CAP_AUDIO_DROP_COMPERROR);
            } else {
    	    errorUpdateError (lpcs, IDS_CAP_AUDIO_DROP_ERROR);
            }
        }

        // If frames dropped, or changed capture rate, warn the user
        else if (lpcs->dwVideoChunkCount && (lpcs->fCaptureFlags & CAP_fCapturingToDisk)) {

            // Warn user if dropped > 10% (default) of the frames
            if ((DWORD)100 * lpcs->dwFramesDropped / lpcs->dwVideoChunkCount >
                        lpcs->sCapParms.wPercentDropForError) {

                // "%d of %ld frames (%d.%03d\%) dropped during capture."
                errorUpdateError (lpcs, IDS_CAP_STAT_FRAMESDROPPED,
                      lpcs->dwFramesDropped,
                      lpcs->dwVideoChunkCount,
                      (UINT)(MulDiv(lpcs->dwFramesDropped,10000,lpcs->dwVideoChunkCount)/100),
                      (UINT)(MulDiv(lpcs->dwFramesDropped,10000,lpcs->dwVideoChunkCount)%100)/10
                      );
            }
        }
    }

EarlyExit:

    //
    // If we were compressing while capturing, close it down
    //
#ifdef NEW_COMPMAN
    if (lpcs->CompVars.hic) {
        // Kludge, reset the lpBitsOut pointer
        if (lpcs->CompVars.lpBitsOut)
            ((LPBYTE) lpcs->CompVars.lpBitsOut) -= 8;
	ICSeqCompressFrameEnd(&lpcs->CompVars);
    }
#endif

    if (fTryToPaint) {
        if (hpalT)
             SelectPalette(hdc, hpalT, FALSE);
        ReleaseDC (lpcs->hwnd, hdc);
    }

    if (lpcs->sCapParms.fMCIControl)
        MCIDeviceClose (lpcs);

    // Let the user see where capture stopped
    if ((!lpcs->fLiveWindow) && (!lpcs->fOverlayWindow))
        videoFrame( lpcs->hVideoIn, &lpcs->VidHdr );
    InvalidateRect( lpcs->hwnd, NULL, TRUE);

    lpcs->fCapFileExists = (lpcs->dwReturn == DV_ERR_OK);
    lpcs->fCaptureFlags &= ~CAP_fCapturingNow;
    lpcs->fCaptureFlags &= ~CAP_fStepCapturingNow;

    statusUpdateStatus(lpcs, IDS_CAP_END);  // Always the last message

    return;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avicap\capwin.c ===
/****************************************************************************
 *
 *   capwin.c
 *
 *   Main window proceedure.
 *
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992 - 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and
 *    distribute the Sample Files (and/or any modified version) in
 *    any way you find useful, provided that you agree that
 *    Microsoft has no warranty obligations or liability for any
 *    Sample Application Files which are modified.
 *
 ***************************************************************************/

#define INC_OLE2
#pragma warning(disable:4103)
#include <windows.h>
#include <windowsx.h>
#include <win32.h>
#include <mmsystem.h>
#include <msvideo.h>
#include <drawdib.h>
#include <mmreg.h>
#include <memory.h>

#include "ivideo32.h"
#include "avicap.h"
#include "avicapi.h"
#include "cappal.h"
#include "capdib.h"
#include "dibmap.h"

#ifdef UNICODE
#include <stdlib.h>
#endif

// GetWindowLong assignments
#define GWL_CAPSTREAM   0
#define GWL_CAPVBSTATUS 4       // Used by VB Status callback
#define GWL_CAPVBERROR  8       // Used by VB Error callback
#define GWL_CAP_SPARE1  12      // Room to grow
#define GWL_CAP_SPARE2  16      // Room to grow

#define ID_PREVIEWTIMER 9

//#ifdef _DEBUG
#ifdef PLASTIQUE
    #define MB(lpsz) MessageBoxA(NULL, lpsz, "", MB_OK);
#else
    #define MB(lpsz)
#endif


// #if defined _WIN32 && defined CHICAGO
#if defined NO_LONGER_USED

#include <mmdevldr.h>
#include <vmm.h>
#include "mmdebug.h"

#pragma message (SQUAWK "move these defines later")
#define MMDEVLDR_IOCTL_PAGEALLOCATE  7
#define MMDEVLDR_IOCTL_PAGEFREE      8
#define PageContig      0x00000004
#define PageFixed       0x00000008
//end

HANDLE hMMDevLdr = NULL;

/*****************************************************************************

  @doc INTERNAL

  @function HANDLE | OpenMMDEVLDR | Open a file handle to the MMDEVLDR VxD
  in order to access the DeviceIoControl functions.

  @rdesc opens a shared handle to MMDEVLDR

*****************************************************************************/

VOID WINAPI OpenMMDEVLDR(
    void)
{
    AuxDebugEx (5, DEBUGLINE "OpenMMDEVLDR()r\n");

    if (hMMDevLdr)
        return;

    hMMDevLdr = CreateFile(
        "\\\\.\\MMDEVLDR.VXD", // magic name to attach to an already loaded vxd
        GENERIC_WRITE,
        FILE_SHARE_WRITE,
        NULL,
        OPEN_ALWAYS,
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_GLOBAL_HANDLE,
        NULL);

    AuxDebugEx (5, DEBUGLINE "OpenMMDEVLDR returns %08Xr\n", hMMDevLdr);
    return;
}

VOID WINAPI CloseMMDEVLDR(
    void)
{
    if (! hMMDevLdr)
        return;

    CloseHandle (hMMDevLdr);
    hMMDevLdr = NULL;
}

/*****************************************************************************

  @doc INTERNAL

  @function DWORD | LinPageLock | Call the VMM service LinPageLock via
   DeviceIoControl through MMDEVLDR.

  @parm DWORD | dwStartPage | Starting page of the linear region to lock.

  @parm DWORD | dwPageCount | Number of 4K pages to lock.

  @parm DWORD | fdwLinPageLock | Flags expected by the VMM service.
   @flag PAGEMAPGLOBAL | Return an alias to the locked region which
    is valid in all process contexts.

  @rdesc Meaningless unless PAGEMAPGLOBAL specified. If it was, then the
   return value is the alias pointer to the start of the linear region
   (NOTE: A *POINTER*, NOT a page address). The pointer will be page
   aligned (i.e. the low 12 bits will be zero.)

*****************************************************************************/

DWORD WINAPI LinPageLock(
    DWORD           dwStartPage,
    DWORD           dwPageCount,
    DWORD           fdwLinPageLock)
{
    LOCKUNLOCKPARMS lup;
    DWORD           dwRet;
    DWORD           cbRet;

    AuxDebugEx (6, DEBUGLINE "LinPageLock(%08x,%08x,%08x)\r\n",
                 dwStartPage, dwPageCount, fdwLinPageLock);

    assert (hMMDevLdr != NULL);
    if (INVALID_HANDLE_VALUE == hMMDevLdr)
        return 0;

    lup.dwStartPage = dwStartPage;
    lup.dwPageCount = dwPageCount;
    lup.fdwOperation= fdwLinPageLock;


    if ( ! DeviceIoControl (hMMDevLdr,
                            MMDEVLDR_IOCTL_LINPAGELOCK,
                            &lup,
                            sizeof(lup),
                            &dwRet,
                            sizeof(dwRet),
                            &cbRet,
                            NULL))
    {
        AuxDebug("LinPageLock failed!!!");
        dwRet = 0;
    }

    return dwRet;
}

/*****************************************************************************

  @doc INTERNAL

  @function DWORD | LinPageUnLock | Call the VMM service LinPageUnLock via
   DeviceIoControl through MMDEVLDR.

  @parm DWORD | dwStartPage | Starting page of the linear region to unlock.

  @parm DWORD | dwPageCount | Number of 4K pages to lock.

  @parm DWORD | fdwLinPageLock | Flags expected by the VMM service.
   @flag PAGEMAPGLOBAL | Return an alias to the locked region which
    is valid in all process contexts.

  @comm
   If PAGEMAPGLOBAL was specified on the <f LinPageLock> call, it must
   also be specified here. In this case, <p dwStartPage> should be the
   page address of the returned alias pointer in global memory.

*****************************************************************************/

void WINAPI LinPageUnLock(
    DWORD           dwStartPage,
    DWORD           dwPageCount,
    DWORD           fdwLinPageLock)
{
    LOCKUNLOCKPARMS lup;

    AuxDebugEx (6, DEBUGLINE "LinPageUnLock (%08x,%08x,%08x)\r\n",
                dwStartPage, dwPageCount, fdwLinPageLock);

    assert (hMMDevLdr != NULL);
    assert (INVALID_HANDLE_VALUE != hMMDevLdr);
    if (INVALID_HANDLE_VALUE == hMMDevLdr)
        return;

    lup.dwStartPage = dwStartPage;
    lup.dwPageCount = dwPageCount;
    lup.fdwOperation = fdwLinPageLock;

    DeviceIoControl (hMMDevLdr,
                     MMDEVLDR_IOCTL_LINPAGEUNLOCK,
                     &lup,
                     sizeof(lup),
                     NULL,
                     0,
                     NULL,
                     NULL);
}

/*+ FreeContigMem
 *
 *-==================================================================*/

VOID FreeContigMem (
    DWORD hMemContig)
{
    DWORD dwRet;
    DWORD cbRet;

    assert (hMMDevLdr != NULL);
    assert (INVALID_HANDLE_VALUE != hMMDevLdr);
    if (INVALID_HANDLE_VALUE == hMMDevLdr)
        return;

    DeviceIoControl (hMMDevLdr,
                     MMDEVLDR_IOCTL_PAGEFREE,
                     &hMemContig,
                     sizeof(hMemContig),
                     &dwRet,
                     sizeof(dwRet),
                     &cbRet,
                     NULL);
}

/*+ AllocContigMem
 *
 *-==================================================================*/

LPVOID AllocContigMem (
    DWORD   cbSize,
    LPDWORD phMemContig)
{
    struct _memparms {
       DWORD flags;
       DWORD nPages;
       } mp;
    struct _memret {
       LPVOID lpv;
       DWORD  hMem;
       DWORD  nPages;
       DWORD  dwPhys;
       } mr;
    DWORD  cbRet;

    mr.lpv = NULL;
    *phMemContig = 0;

    mp.nPages = (cbSize + 4095) >> 12;
    mp.flags = PageContig+PageFixed;

    AuxDebugEx (2, DEBUGLINE "Contig allocate %08X pages\r\n", mp.nPages);

    assert (hMMDevLdr != NULL);
    assert (INVALID_HANDLE_VALUE != hMMDevLdr);
    if (INVALID_HANDLE_VALUE == hMMDevLdr)
        return NULL;

    if ( ! DeviceIoControl (hMMDevLdr,
                            MMDEVLDR_IOCTL_PAGEALLOCATE,
                            &mp,
                            sizeof(mp),
                            &mr,
                            sizeof(mr),
                            &cbRet,
                            NULL))
    {
        AuxDebugEx(0, "Contig Allocate failed!!!\r\n");
        mr.lpv = NULL;
        mr.hMem = 0;
        mr.nPages = 0;
        mr.dwPhys = 0;
    }

    *phMemContig = mr.hMem;

    AuxDebugEx(2, "Contig Allocate returns %08X\r\n", mr.lpv);
    return mr.lpv;
}

/*+
 *
 *-================================================================*/

PVOID WINAPI CreateGlobalAlias (
    PVOID   pOriginal,
    DWORD   cbOriginal,
    LPDWORD pnPages)
{
    DWORD   dwStartPage;
    DWORD   dwPageCount;
    DWORD   dwPageOffset;
    DWORD   dwAliasBase;
    PVOID   pAlias;

    AuxDebugEx (6, DEBUGLINE "CreateGlobalAlias(%08X,%08X,..)\r\n",
                pOriginal, cbOriginal);

    dwStartPage  = ((DWORD)pOriginal) >> 12;
    dwPageOffset = ((DWORD)pOriginal) & ((1 << 12)-1);
    dwPageCount  = ((((DWORD)pOriginal) + cbOriginal - 1) >> 12) - dwStartPage + 1;

    *pnPages = 0;
    dwAliasBase = LinPageLock (dwStartPage, dwPageCount, PAGEMAPGLOBAL);
    if ( ! dwAliasBase)
        return NULL;

    pAlias = (PVOID)(dwAliasBase + dwPageOffset);
    *pnPages = dwPageCount;

    AuxDebugEx (6, DEBUGLINE "CreateGlobalAlias returns %08X nPages %d\r\n", pAlias, dwPageCount);
    return pAlias;
}

/*+
 *
 *-================================================================*/

VOID WINAPI FreeGlobalAlias(
    PVOID        pAlias,
    DWORD        nPages)
{
    AuxDebugEx (6, DEBUGLINE "FreeGlobalAlias(%08X,%08X)\r\n", pAlias, nPages);

    LinPageUnLock (((DWORD)pAlias) >> 12, nPages, PAGEMAPGLOBAL);
}
#endif


#if defined _WIN32 && defined CHICAGO


/*+ videoFrame
 *
 *-================================================================*/

DWORD WINAPI videoFrame (
    HVIDEO hVideo,
    LPVIDEOHDR lpVHdr)
{
    return vidxFrame (hVideo, lpVHdr);
}

#endif



//
// Set the overlay rectangles on capture cards which support
// overlay, and then enable/disable the key color.
//
static void SetOverlayRectangles (LPCAPSTREAM lpcs)
{
    HDC hdc;
    BOOL fVisible;
    RECT rc;

    if (!lpcs->hVideoDisplay)
        return;

    hdc = GetDC (lpcs->hwnd);
    fVisible = (GetClipBox (hdc, &rc) != NULLREGION);
    ReleaseDC (lpcs->hwnd, hdc);

    if (!fVisible)  // disable the overlay if iconic
        videoStreamFini (lpcs->hVideoDisplay);
    else {
        // Destination
        GetClientRect (lpcs->hwnd, &rc);
        ClientToScreen (lpcs->hwnd, (LPPOINT)&rc);
        ClientToScreen (lpcs->hwnd, (LPPOINT)&rc+1);

        videoSetRect (lpcs->hVideoDisplay, DVM_DST_RECT, rc);

        // Overlay channel Source rectangle
        SetRect (&rc, lpcs->ptScroll.x, lpcs->ptScroll.y,
                lpcs->ptScroll.x + rc.right - rc.left,
                lpcs->ptScroll.y + rc.bottom - rc.top);
        videoSetRect (lpcs->hVideoDisplay, DVM_SRC_RECT, rc);

        videoStreamInit (lpcs->hVideoDisplay, 0L, 0L, 0L, 0L);
    }
}

// WM_POSITIONCHANGED and WM_POSITIONCHANGING don't do enough to
// handle clipping of the overlay window on the Intel board,
// which keys on black.  Do this routine on WM_PAINT and
// WM_ENTERIDLE messages.

void CheckWindowMove(LPCAPSTREAM lpcs, HDC hdcWnd, BOOL fForce)
{
    UINT    wRgn;
    RECT    rc;
#ifdef _WIN32
    POINT   ptOrg;
#else
    DWORD   dwOrg;
#endif
    HDC     hdc;
    BOOL    f;

    if (!lpcs->hwnd || !lpcs->hVideoDisplay || !lpcs->fOverlayWindow)
        return;

    //
    //  when the screen is locked for update by a window move operation
    //  we dont want to turn off the video.
    //
    //  we can tell if the screen is locked by checking a DC to the screen.
    //
    hdc = GetDC(NULL);
    f = GetClipBox(hdc, &rc) == NULLREGION;
    ReleaseDC(NULL, hdc);

    if (f) {
        lpcs->uiRegion = (UINT) -1;
        return;
    }

    if (fForce)
        lpcs->uiRegion = (UINT) -1;

    hdc = GetDC (lpcs->hwnd);
    wRgn = GetClipBox(hdc, &rc);
#ifdef _WIN32
    GetDCOrgEx(hdc, &ptOrg);
#else
    dwOrg = GetDCOrg(hdc);
#endif
    ReleaseDC(lpcs->hwnd, hdc);

    if (wRgn == lpcs->uiRegion &&
#ifdef _WIN32
                ptOrg.x == lpcs->ptRegionOrigin.x &&
		ptOrg.y == lpcs->ptRegionOrigin.y &&
#else
                dwOrg == lpcs->dwRegionOrigin &&
#endif
                EqualRect(&rc, &lpcs->rcRegionRect))
        return;

    lpcs->uiRegion       = wRgn;
#ifdef _WIN32
    lpcs->ptRegionOrigin = ptOrg;
#else
    lpcs->dwRegionOrigin = dwOrg;
#endif

    lpcs->rcRegionRect   = rc;

    SetOverlayRectangles (lpcs);

    if (hdcWnd)
        videoUpdate (lpcs->hVideoDisplay, lpcs->hwnd, hdcWnd);
    else
        InvalidateRect (lpcs->hwnd, NULL, TRUE);
}

//
// Create our little world
//
LPCAPSTREAM CapWinCreate (HWND hwnd)
{
    LPCAPSTREAM lpcs;
    WAVEFORMATEX wfex;

    if (!(lpcs = (LPCAPSTREAM) GlobalAllocPtr (GHND, sizeof (CAPSTREAM))))
        return NULL;

    SetWindowLong (hwnd, GWL_CAPSTREAM, (LONG)lpcs);

    lpcs->dwSize = sizeof (CAPSTREAM);
    lpcs->uiVersion = CAPSTREAM_VERSION;
    lpcs->hwnd = hwnd;
    lpcs->hInst = ghInstDll;
    lpcs->hWaitCursor = LoadCursor(NULL, IDC_WAIT);
    lpcs->hdd = DrawDibOpen();
    lpcs->fAudioHardware = !!waveOutGetNumDevs();    // force 1 or 0


    // Video defaults
    lpcs->sCapParms.dwRequestMicroSecPerFrame = 66667;   // 15fps
    lpcs->sCapParms.vKeyAbort          = VK_ESCAPE;
    lpcs->sCapParms.fAbortLeftMouse    = TRUE;
    lpcs->sCapParms.fAbortRightMouse   = TRUE;
    lpcs->sCapParms.wNumVideoRequested = MIN_VIDEO_BUFFERS;
    lpcs->sCapParms.wPercentDropForError = 10;   // error msg if dropped > 10%
    lpcs->sCapParms.wChunkGranularity  = 0;
    lpcs->fCaptureFlags |= CAP_fCapturingToDisk;

    // Audio defaults to 11K, 8bit, Mono
    lpcs->sCapParms.fCaptureAudio = lpcs->fAudioHardware;
    lpcs->sCapParms.wNumAudioRequested = DEF_WAVE_BUFFERS;

    wfex.wFormatTag = WAVE_FORMAT_PCM;
    wfex.nChannels = 1;
    wfex.nSamplesPerSec = 11025;
    wfex.nAvgBytesPerSec = 11025;
    wfex.nBlockAlign = 1;
    wfex.wBitsPerSample = 8;
    wfex.cbSize = 0;
    SendMessage (hwnd, WM_CAP_SET_AUDIOFORMAT, 0, (LONG)(LPVOID)&wfex);

    // Palette defaults
    lpcs->nPaletteColors = 256;

    // Capture defaults
    lpcs->sCapParms.fUsingDOSMemory = FALSE;
    lstrcpy (lpcs->achFile, TEXT("C:\\CAPTURE.AVI"));    // Default capture file
    lpcs->fCapFileExists = fileCapFileIsAVI (lpcs->achFile);

    // Allocate index to 32K frames plus proportionate number of audio chunks
    lpcs->sCapParms.dwIndexSize = (32768ul + (32768ul / 15));
    lpcs->sCapParms.fDisableWriteCache = FALSE;

#ifdef NEW_COMPMAN
    // Init the COMPVARS structure
    lpcs->CompVars.cbSize = sizeof (COMPVARS);
    lpcs->CompVars.dwFlags = 0;
#endif

    return lpcs;
}

//
// Destroy our little world
//
void CapWinDestroy (LPCAPSTREAM lpcs)
{
    // Uh, oh.  Somebodys trying to kill us while capturing
    if (lpcs->fCaptureFlags & CAP_fCapturingNow) {
	if (lpcs->fCaptureFlags & CAP_fFrameCapturingNow) {
	    // Single frame capture in progress
	    SingleFrameCaptureClose (lpcs);
	}
	else {
	    // Streaming capture in progress, OR
	    // MCI step capture in progress

	    lpcs->fCaptureFlags |= CAP_fAbortCapture;
#ifdef _WIN32
	    // wait for capture thread to go away

	    // we must have a capture thread
	    WinAssert(lpcs->hThreadCapture != 0);
	    while (MsgWaitForMultipleObjects(1, &lpcs->hThreadCapture, FALSE,
		INFINITE, QS_SENDMESSAGE) != WAIT_OBJECT_0) {
		MSG msg;

		// just a single peekmessage with NOREMOVE will
		// process the inter-thread send and not affect the queue
		PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE);
	    }
	    CloseHandle(lpcs->hThreadCapture);
	    lpcs->hThreadCapture = 0;

	    // it should have stopped capturing
	    WinAssert(!(lpcs->fCaptureFlags & CAP_fCapturingNow));

#else
	    while (lpcs->fCapturingNow)
		Yield ();
#endif
    	}
    }

    if (lpcs->idTimer)
        KillTimer(lpcs->hwnd, lpcs->idTimer);

    PalFini (lpcs);
    DibFini (lpcs);

    CapWinDisconnectHardware (lpcs);

    DrawDibClose (lpcs->hdd);

    if (lpcs->lpWaveFormat)
        GlobalFreePtr (lpcs->lpWaveFormat);

#ifdef NEW_COMPMAN
    if (lpcs->CompVars.hic)
        ICCompressorFree(&lpcs->CompVars);
#endif

    if (lpcs->lpInfoChunks)
        GlobalFreePtr(lpcs->lpInfoChunks);

    WinAssert (!lpcs->pAsync);
    GlobalFreePtr (lpcs);       // Free the instance memory
}

UINT GetSizeOfWaveFormat (LPWAVEFORMATEX lpwf)
{
    UINT wSize;

    if ((lpwf == NULL) || (lpwf->wFormatTag == WAVE_FORMAT_PCM))
        wSize = sizeof (PCMWAVEFORMAT);
    else
        wSize = sizeof (WAVEFORMATEX) + lpwf->cbSize;

    return wSize;
}

// Returns TRUE if we got a new frame, else FALSE
// if fForce, then always get a new frame
BOOL GetAFrameThenCallback (LPCAPSTREAM lpcs, BOOL fForce)
{
    BOOL fOK = FALSE;
    static BOOL fRecursion = FALSE;
    BOOL fVisible;
    RECT rc;
    HDC  hdc;

    if (fRecursion)
        return FALSE;

    if (!lpcs->sCapDrvCaps.fCaptureInitialized)
        return fOK;

    fRecursion = TRUE;

    // Update the preview window if we got a timer and not saving to disk
    if (lpcs->fOverlayWindow)
        CheckWindowMove(lpcs, NULL, FALSE);

    if ((!(lpcs->fCaptureFlags & CAP_fCapturingNow))
       || (lpcs->fCaptureFlags & CAP_fStepCapturingNow)
       || (lpcs->fCaptureFlags & CAP_fFrameCapturingNow)) {
        hdc = GetDC (lpcs->hwnd);
        fVisible = (GetClipBox (hdc, &rc) != NULLREGION);
        ReleaseDC (lpcs->hwnd, hdc);

        if (fForce || (fVisible && (lpcs->fLiveWindow || lpcs->CallbackOnVideoFrame))) {
            videoFrame (lpcs->hVideoIn, &lpcs->VidHdr);
            fOK = TRUE;

            if (lpcs->CallbackOnVideoFrame)
                lpcs->CallbackOnVideoFrame(lpcs->hwnd, &lpcs->VidHdr);

            if (fForce || lpcs->fLiveWindow) {
                InvalidateRect (lpcs->hwnd, NULL, TRUE);
                UpdateWindow (lpcs->hwnd);
            }
        } // if visible
    } // if we're not streaming

    fRecursion = FALSE;

    return fOK;
}

// Clear the Status and Error strings via callback
__inline void FAR PASCAL ClearStatusAndError (LPCAPSTREAM lpcs)
{
    statusUpdateStatus(lpcs, 0);     // Clear status
    errorUpdateError(lpcs, 0);       // Clear error

}

// Process class specific commands >= WM_USER

DWORD PASCAL ProcessCommandMessages (LPCAPSTREAM lpcs, UINT msg, UINT wParam, LPARAM lParam)
{
    DWORD dwReturn = 0L;
    DWORD dwT;

    switch (msg) {
        // Don't clear status and error on the following innocuous msgs
        case WM_CAP_GET_CAPSTREAMPTR:
        case WM_CAP_GET_USER_DATA:
        case WM_CAP_DRIVER_GET_NAME:
        case WM_CAP_DRIVER_GET_VERSION:
        case WM_CAP_DRIVER_GET_CAPS:
        case WM_CAP_GET_AUDIOFORMAT:
        case WM_CAP_GET_VIDEOFORMAT:
        case WM_CAP_GET_STATUS:
        case WM_CAP_SET_SEQUENCE_SETUP:
        case WM_CAP_GET_SEQUENCE_SETUP:
        case WM_CAP_GET_MCI_DEVICE:
        case WM_CAP_SET_PREVIEWRATE:
        case WM_CAP_SET_SCROLL:
#ifdef UNICODE
        // ...or on the ansi thunks for these messages
        case WM_CAP_DRIVER_GET_NAMEA:
        case WM_CAP_DRIVER_GET_VERSIONA:
        case WM_CAP_GET_MCI_DEVICEA:
#endif
            break;

        default:
            ClearStatusAndError (lpcs);
            break;
    }

    switch (msg) {
    case WM_CAP_GET_CAPSTREAMPTR:
        // return a pointer to the CAPSTREAM
        return (DWORD) (LPVOID) lpcs;

    case WM_CAP_GET_USER_DATA:
	return lpcs->lUser;

    // unicode and win-16 version - see ansi thunk below
    case WM_CAP_DRIVER_GET_NAME:
        // Return the name of the capture driver in use
        // wParam is the length of the buffer pointed to by lParam
        if (!lpcs->fHardwareConnected)
            return FALSE;
        return (capInternalGetDriverDesc (lpcs->sCapDrvCaps.wDeviceIndex,
                (LPTSTR) lParam, (int) wParam, NULL, 0));

    // unicode and win-16 version - see ansi thunk below
    case WM_CAP_DRIVER_GET_VERSION:
        // Return the version of the capture driver in use as text
        // wParam is the length of the buffer pointed to by lParam
        if (!lpcs->fHardwareConnected)
            return FALSE;
        return (capInternalGetDriverDesc (lpcs->sCapDrvCaps.wDeviceIndex,
                NULL, 0, (LPTSTR) lParam, (int) wParam));

#ifdef UNICODE
    // ansi/unicode thunk versions of the above entrypoint
    case WM_CAP_DRIVER_GET_NAMEA:
        if (!lpcs->fHardwareConnected)
            return FALSE;
        return capInternalGetDriverDescA(lpcs->sCapDrvCaps.wDeviceIndex,
                (LPSTR) lParam, (int) wParam, NULL, 0);

    // ansi/unicode thunk versions of the above entrypoint
    case WM_CAP_DRIVER_GET_VERSIONA:
        if (!lpcs->fHardwareConnected)
            return FALSE;
        return capInternalGetDriverDescA(lpcs->sCapDrvCaps.wDeviceIndex,
                NULL, 0, (LPSTR) lParam, (int) wParam);
#endif


    case WM_CAP_DRIVER_GET_CAPS:
        // wParam is the size of the CAPDRIVERCAPS struct
        // lParam points to a CAPDRIVERCAPS struct
        if (!lpcs->fHardwareConnected)
            return FALSE;
        if (wParam <= sizeof (CAPDRIVERCAPS) &&
                !IsBadWritePtr ((LPVOID) lParam, (UINT) wParam)) {
            dwT = min (wParam, sizeof (CAPDRIVERCAPS));
            _fmemcpy ((LPVOID) lParam, (LPVOID) &lpcs->sCapDrvCaps, (UINT) dwT);
            dwReturn = TRUE;
        }
        break;


    // unicode and win-16 version - see ansi thunk below
    case WM_CAP_FILE_GET_CAPTURE_FILE:
        // wParam is the size (in characters)
        // lParam points to a buffer in which capture file name is copied
        if (lParam) {
            lstrcpyn ((LPTSTR) lParam, lpcs->achFile, wParam);
            dwReturn = TRUE;
        }
        break;
#ifdef UNICODE
    // ansi/unicode thunk
    case WM_CAP_FILE_GET_CAPTURE_FILEA:
        if (lParam) {
            Iwcstombs((LPSTR) lParam, lpcs->achFile, (int) wParam);
            dwReturn = TRUE;
        }
        break;
#endif


    case WM_CAP_GET_AUDIOFORMAT:
        // if lParam == NULL, return the size
        // if lParam != NULL, wParam is the size, return bytes copied
        if (lpcs->lpWaveFormat == NULL)
            return FALSE;
        dwT = GetSizeOfWaveFormat ((LPWAVEFORMATEX) lpcs->lpWaveFormat);
        if (lParam == 0)
            return (dwT);
        else {
            if (wParam < (UINT) dwT)
                return FALSE;
            else {
                hmemcpy ((LPVOID) lParam, (LPVOID) lpcs->lpWaveFormat, dwT);
                dwReturn = dwT;
            }
        }
        break;

    // unicode and win-16 version - see ansi thunk below
    case WM_CAP_GET_MCI_DEVICE:
        // wParam is the size in characters
        // lParam points to a buffer in which MCI device name is copied
        if (lParam) {
            lstrcpyn ((LPTSTR) lParam, lpcs->achMCIDevice, wParam);
            dwReturn = TRUE;
        }
        break;
#ifdef UNICODE
    // ansi thunk of above
    case WM_CAP_GET_MCI_DEVICEA:
        if (lParam) {
            Iwcstombs( (LPSTR) lParam, lpcs->achMCIDevice, (int) wParam);
            dwReturn = TRUE;
        }
        break;
#endif

    case WM_CAP_GET_STATUS:
        // wParam is the size of the CAPSTATUS struct pointed to by lParam
        if (!lpcs->fHardwareConnected)
            return FALSE;
        if (IsBadWritePtr ((LPVOID) lParam, (UINT) wParam))
            return FALSE;

        if (wParam >= sizeof (CAPSTATUS)) {
            LPCAPSTATUS lpcc = (LPCAPSTATUS) lParam;

            lpcc->fLiveWindow          = lpcs->fLiveWindow;
            lpcc->fOverlayWindow       = lpcs->fOverlayWindow;
            lpcc->fScale               = lpcs->fScale;
            lpcc->ptScroll             = lpcs->ptScroll;
            lpcc->fUsingDefaultPalette = lpcs->fUsingDefaultPalette;
            lpcc->fCapFileExists       = lpcs->fCapFileExists;
            lpcc->fAudioHardware       = lpcs->fAudioHardware;
            lpcc->uiImageWidth         = lpcs->dxBits;
            lpcc->uiImageHeight        = lpcs->dyBits;

            // The following are updated dynamically during capture
            lpcc->dwCurrentVideoFrame          = lpcs->dwVideoChunkCount;
            lpcc->dwCurrentVideoFramesDropped  = lpcs->dwFramesDropped;
            if (lpcs->lpWaveFormat != NULL) {
            lpcc->dwCurrentWaveSamples         =
                  MulDiv (lpcs->dwWaveBytes,
                          lpcs->lpWaveFormat->nSamplesPerSec,
                          lpcs->lpWaveFormat->nAvgBytesPerSec);
            }
            lpcc->dwCurrentTimeElapsedMS       = lpcs->dwTimeElapsedMS;

            // Added post alpha release
	    if (lpcs->fCaptureFlags & CAP_fCapturingNow) {
		lpcc->fCapturingNow    = TRUE;
	    } else {
		lpcc->fCapturingNow    = FALSE;
	    }
            lpcc->hPalCurrent          = lpcs->hPalCurrent;
            lpcc->dwReturn             = lpcs->dwReturn;
            lpcc->wNumVideoAllocated   = lpcs->iNumVideo;
            lpcc->wNumAudioAllocated   = lpcs->iNumAudio;

            dwReturn = TRUE;
        }
        break;

    case WM_CAP_GET_SEQUENCE_SETUP:
        // wParam is sizeof CAPTUREPARMS
        // lParam = LPCAPTUREPARMS
        if (wParam <= sizeof (CAPTUREPARMS) &&
                !IsBadWritePtr ((LPVOID) lParam, (UINT) wParam)) {
            dwT = min (wParam, sizeof (CAPTUREPARMS));
            _fmemcpy ((LPVOID) lParam, (LPVOID) &lpcs->sCapParms, (UINT) dwT);
            dwReturn = TRUE;
        }
        break;

    case WM_CAP_STOP:
        // Stop capturing a sequence
        if (lpcs->fCaptureFlags & CAP_fCapturingNow) {
            lpcs->fCaptureFlags |= CAP_fStopCapture;
            dwReturn = TRUE;
        }
        break;

    case WM_CAP_ABORT:
        // Stop capturing a sequence
        if (lpcs->fCaptureFlags & CAP_fCapturingNow) {
            lpcs->fCaptureFlags |= CAP_fAbortCapture;
            dwReturn = TRUE;
        }
        break;

    case WM_CAP_GET_VIDEOFORMAT:
        // if lParam == NULL, return the size
        // if lParam != NULL, wParam is the size, return bytes copied
        if (!lpcs->fHardwareConnected)
            return FALSE;
        dwT = ((LPBITMAPINFOHEADER)lpcs->lpBitsInfo)->biSize +
	      ((LPBITMAPINFOHEADER)lpcs->lpBitsInfo)->biClrUsed * sizeof(RGBQUAD);
        if (lParam == 0)
            return dwT;
        else {
            if (wParam < (UINT) dwT)
                return FALSE;
            else {
                hmemcpy ((LPVOID) lParam, (LPVOID) lpcs->lpBitsInfo, dwT);
                dwReturn = dwT;
            }
        }
        break;

    case WM_CAP_SINGLE_FRAME_OPEN:
        // wParam is not used
        // lParam is not used
        if (!lpcs->fHardwareConnected)
            return FALSE;
        return SingleFrameCaptureOpen (lpcs);

    case WM_CAP_SINGLE_FRAME_CLOSE:
        // wParam is not used
        // lParam is not used
        if (!lpcs->fHardwareConnected)
            return FALSE;
        return SingleFrameCaptureClose (lpcs);

    case WM_CAP_SINGLE_FRAME:
        // wParam is not used
        // lParam is not used
        if (!lpcs->fHardwareConnected)
            return FALSE;
        return SingleFrameCapture (lpcs);

    // unicode and win-16 version - see ansi thunk below
    case WM_CAP_SET_CALLBACK_STATUS:
        // Set the status callback proc
        if (lParam != 0 && IsBadCodePtr ((FARPROC) lParam))
            return FALSE;
        lpcs->CallbackOnStatus = (CAPSTATUSCALLBACK) lParam;
	lpcs->fLastStatusWasNULL = TRUE;
#ifdef UNICODE
        lpcs->fUnicode &= ~VUNICODE_STATUSISANSI;
#endif
        return TRUE;

#ifdef UNICODE
    // ansi thunk for above
    case WM_CAP_SET_CALLBACK_STATUSA:
        // Set the status callback proc
        if (lParam != 0 && IsBadCodePtr ((FARPROC) lParam))
            return FALSE;
        lpcs->CallbackOnStatus = (CAPSTATUSCALLBACK) lParam;
	lpcs->fLastStatusWasNULL = TRUE;
        lpcs->fUnicode |= VUNICODE_STATUSISANSI;
        return TRUE;
#endif

    // unicode and win-16 version - see ansi version below
    case WM_CAP_SET_CALLBACK_ERROR:
        // Set the error callback proc
        if (lParam != 0 && IsBadCodePtr ((FARPROC) lParam))
            return FALSE;
        lpcs->CallbackOnError = (CAPERRORCALLBACK) lParam;
	lpcs->fLastErrorWasNULL = TRUE;
#ifdef UNICODE
        lpcs->fUnicode &= ~VUNICODE_ERRORISANSI;
#endif
        return TRUE;


#ifdef UNICODE
    // ansi version of above
    case WM_CAP_SET_CALLBACK_ERRORA:
        // Set the error callback proc
        if (lParam != 0 && IsBadCodePtr ((FARPROC) lParam))
            return FALSE;
        lpcs->CallbackOnError = (CAPERRORCALLBACK) lParam;
	lpcs->fLastErrorWasNULL = TRUE;
        lpcs->fUnicode |= VUNICODE_ERRORISANSI;
        return TRUE;
#endif

    case WM_CAP_SET_CALLBACK_FRAME:
        // Set the callback proc for single frame during preview
        if (lParam != 0 && IsBadCodePtr ((FARPROC) lParam))
            return FALSE;
        lpcs->CallbackOnVideoFrame = (CAPVIDEOCALLBACK) lParam;
        return TRUE;

    default:
        break;
    }

    // Once we start capturing, don't change anything
    if (lpcs->fCaptureFlags & CAP_fCapturingNow)
        return dwReturn;

    switch (msg) {

    case WM_CAP_SET_CALLBACK_YIELD:
        // Set the callback proc for wave buffer processing to net
        if (lParam != 0 && IsBadCodePtr ((FARPROC) lParam))
            return FALSE;
        lpcs->CallbackOnYield = (CAPYIELDCALLBACK) lParam;
        return TRUE;

    case WM_CAP_SET_CALLBACK_VIDEOSTREAM:
        // Set the callback proc for video buffer processing to net
        if (lParam != 0 && IsBadCodePtr ((FARPROC) lParam))
            return FALSE;
        lpcs->CallbackOnVideoStream = (CAPVIDEOCALLBACK) lParam;
        return TRUE;

    case WM_CAP_SET_CALLBACK_WAVESTREAM:
        // Set the callback proc for wave buffer processing to net
        if (lParam != 0 && IsBadCodePtr ((FARPROC) lParam))
            return FALSE;
        lpcs->CallbackOnWaveStream = (CAPWAVECALLBACK) lParam;
        return TRUE;

    case WM_CAP_SET_CALLBACK_CAPCONTROL:
        // Set the callback proc for frame accurate capture start/stop
        if (lParam != 0 && IsBadCodePtr ((FARPROC) lParam))
            return FALSE;
        lpcs->CallbackOnControl = (CAPCONTROLCALLBACK) lParam;
        return TRUE;

    case WM_CAP_SET_USER_DATA:
	lpcs->lUser = lParam;
	return TRUE;

    case WM_CAP_DRIVER_CONNECT:
        // Connect to a device
        // wParam contains the index of the driver

        // If the same driver ID is requested, skip the request
        // Prevents multiple Inits from VB apps
        if (lpcs->fHardwareConnected &&
                (lpcs->sCapDrvCaps.wDeviceIndex == wParam))
            return TRUE;

        // First disconnect from any (possibly) existing device
        SendMessage (lpcs->hwnd, WM_CAP_DRIVER_DISCONNECT, 0, 0l);

        // and then connect to the new device
        if (CapWinConnectHardware (lpcs, (UINT) wParam /*wDeviceIndex*/)) {
            if (!DibGetNewFormatFromDriver (lpcs)) {  // Allocate our bitspace
                // Use the cached palette if available
                if (lpcs->hPalCurrent && lpcs->lpCacheXlateTable) {
                    PalSendPaletteToDriver (lpcs, lpcs->hPalCurrent, lpcs->lpCacheXlateTable);
                }
                else
                    PalGetPaletteFromDriver (lpcs);

                // Get a frame using the possibly cached palette
                videoFrame (lpcs->hVideoIn, &lpcs->VidHdr);
        	InvalidateRect(lpcs->hwnd, NULL, TRUE);
                lpcs->sCapDrvCaps.fCaptureInitialized = TRUE; // everything AOK!
                dwReturn = TRUE;
            }
        }
        break;

    case WM_CAP_DRIVER_DISCONNECT:
        MB ("About to disconnect from driver");
        // Disconnect from a device
        // wParam and lParam unused
        if (!lpcs->fHardwareConnected)
            return FALSE;
        CapWinDisconnectHardware (lpcs);
        DibFini (lpcs);
        /* PalFini (lpcs); keep the palette cached for reconnections */
        InvalidateRect(lpcs->hwnd, NULL, TRUE);
        lpcs->sCapDrvCaps.fCaptureInitialized = FALSE;
        dwReturn = TRUE;
        break;

    // unicode and win-16 version - see ansi thunk below
    case WM_CAP_FILE_SET_CAPTURE_FILE:
        // lParam points to the name of the capture file
        if (lParam) {
            BOOL fAlreadyExists;        // Don't create a file if new name
#ifndef _WIN32
            OFSTRUCT of;
#endif
            HANDLE hFile;

            // Check for valid file names...
#ifdef _WIN32
    // can't use OpenFile for UNICODE names
            if ((hFile = CreateFile(
                            (LPTSTR) lParam,
                            GENERIC_WRITE,
                            0,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL)) == INVALID_HANDLE_VALUE) {
                if ((hFile = CreateFile(
                                (LPTSTR) lParam,
                                GENERIC_WRITE,
                                0,
                                NULL,
                                CREATE_NEW,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL)) == INVALID_HANDLE_VALUE) {
#else

            if ((hFile = OpenFile ((LPTSTR) lParam, &of, OF_WRITE)) == -1) {
                if ((hFile = OpenFile ((LPTSTR) lParam, &of, OF_CREATE | OF_WRITE)) == -1) {
#endif
                    return FALSE;
                }
                fAlreadyExists = FALSE;
            }
            else
                fAlreadyExists = TRUE;

#ifdef _WIN32
            CloseHandle(hFile);
#else
            _lclose (hFile);
#endif
            lstrcpyn (lpcs->achFile, (LPTSTR) lParam, NUMELMS(lpcs->achFile));
            lpcs->fCapFileExists = fileCapFileIsAVI (lpcs->achFile);

            if (!fAlreadyExists) {
		// Delete the file created by CREATE_NEW (or OF_CREATE)
		// when verifying that we can write to this file location
#ifdef _WIN32
                DeleteFile ((LPTSTR) lParam);
#else
                OpenFile ((LPTSTR) lParam, &of, OF_DELETE);
#endif
            }
            dwReturn = TRUE;
        }
        break;

#ifdef UNICODE
    // Ansi thunk for above.
    case WM_CAP_FILE_SET_CAPTURE_FILEA:
        // lParam points to the name of the capture file
        if (lParam) {
            LPWSTR pw;
            int chsize;

            // remember the null
            chsize = lstrlenA( (LPSTR) lParam) + 1;
            pw = LocalAlloc(LPTR, chsize * sizeof(WCHAR));
	    if (pw) {
                Imbstowcs(pw, (LPSTR) lParam, chsize);
                dwReturn = ProcessCommandMessages(lpcs, WM_CAP_FILE_SET_CAPTURE_FILEW,
                                0, (LPARAM)pw);
                LocalFree(pw);
	    }
        }
        break;
#endif

    case WM_CAP_FILE_ALLOCATE:
        // lParam contains the size to preallocate the capture file in bytes
        return fileAllocCapFile(lpcs, lParam);

    // unicode and win-16 version - see ansi thunk below
    case WM_CAP_FILE_SAVEAS:
        // lParam points to the name of the SaveAs file
        if (lParam) {
            lstrcpyn (lpcs->achSaveAsFile, (LPTSTR) lParam,
                        NUMELMS(lpcs->achSaveAsFile));
            return (fileSaveCopy(lpcs));
        }
        break;

#ifdef UNICODE
    // ansi thunk for above
    case WM_CAP_FILE_SAVEASA:
        // lParam points to the name of the SaveAs file
        if (lParam) {
            LPWSTR pw;
            int chsize;

            // remember the null
            chsize = lstrlenA( (LPSTR) lParam)+1;
            pw = LocalAlloc(LPTR, chsize * sizeof(WCHAR));
	    if (pw) {
                Imbstowcs(pw, (LPSTR) lParam, chsize);
                dwReturn = ProcessCommandMessages(lpcs, WM_CAP_FILE_SAVEASW,
                                0, (LPARAM)pw);
                LocalFree(pw);
	    }
        }
        break;
#endif

    case WM_CAP_FILE_SET_INFOCHUNK:
        // wParam is not used
        // lParam is an LPCAPINFOCHUNK
        if (lParam) {
            return (SetInfoChunk(lpcs, (LPCAPINFOCHUNK) lParam));
        }
        break;

    // unicode and win-16 version - see ansi thunk below
    case WM_CAP_FILE_SAVEDIB:
        // lParam points to the name of the DIB file
        if (lParam) {
            if (lpcs->fOverlayWindow)
                GetAFrameThenCallback (lpcs, TRUE /*fForce*/);

            return (fileSaveDIB(lpcs, (LPTSTR)lParam));
        }
        break;

#ifdef UNICODE
    // ansi thunk for above
    case WM_CAP_FILE_SAVEDIBA:
        if (lParam) {
            LPWSTR pw;
            int chsize;

            if (lpcs->fOverlayWindow)
                GetAFrameThenCallback (lpcs, TRUE /*fForce*/);

            // remember the null
            chsize = lstrlenA( (LPSTR) lParam)+1;
            pw = LocalAlloc(LPTR, chsize * sizeof(WCHAR));
	    if (pw) {
                Imbstowcs(pw, (LPSTR) lParam, chsize);
                dwReturn = fileSaveDIB(lpcs, pw);
                LocalFree(pw);
	    }
        }
        break;
#endif


    case WM_CAP_EDIT_COPY:
        // Copy the current image and palette to the clipboard
        // wParam and lParam unused
        if (!lpcs->fHardwareConnected)
            return FALSE;
        if (lpcs->fOverlayWindow)
            GetAFrameThenCallback (lpcs, TRUE /*fForce*/);

        if (lpcs->sCapDrvCaps.fCaptureInitialized && OpenClipboard (lpcs->hwnd)) {
            EmptyClipboard();

            // put a copy of the current palette in the clipboard
            if (lpcs->hPalCurrent && lpcs->lpBitsInfo->bmiHeader.biBitCount <= 8)
                SetClipboardData(CF_PALETTE, CopyPalette (lpcs->hPalCurrent));

            // make a packed DIB out of the current image
            if (lpcs->lpBits && lpcs->lpBitsInfo ) {
                if (SetClipboardData (CF_DIB, CreatePackedDib (lpcs->lpBitsInfo,
                        lpcs->lpBits, lpcs->hPalCurrent)))
                    dwReturn = TRUE;
                else
                    errorUpdateError (lpcs, IDS_CAP_OUTOFMEM);
            }

            CloseClipboard();
        }
        break;

    case WM_CAP_SET_AUDIOFORMAT:
        {
            // wParam is unused
            // lParam is LPWAVEFORMAT or LPWAVEFORMATEX
            UINT wSize;
            LPWAVEFORMATEX lpwf = (LPWAVEFORMATEX) lParam;
            UINT uiError;

            // Verify the waveformat is valid
            uiError = waveInOpen(NULL, WAVE_MAPPER, lpwf, 0, 0L,WAVE_FORMAT_QUERY);

            if (uiError) {
                errorUpdateError (lpcs, IDS_CAP_WAVE_OPEN_ERROR);
                return FALSE;
            }

            if (lpcs->lpWaveFormat)
                GlobalFreePtr (lpcs->lpWaveFormat);

            wSize = GetSizeOfWaveFormat (lpwf);
            if (lpcs->lpWaveFormat = (LPWAVEFORMATEX)
                    GlobalAllocPtr (GHND, sizeof (CAPSTREAM))) {
                hmemcpy (lpcs->lpWaveFormat, lpwf, (LONG) wSize);
            }
            dwReturn = TRUE;
        }
        break;

    case WM_CAP_DLG_VIDEOSOURCE:
        // Show the dialog which controls the video source
        // NTSC vs PAL, input channel selection, etc.
        // wParam and lParam are unused
        if (!lpcs->fHardwareConnected)
            return FALSE;
        if (lpcs->dwDlgsActive & VDLG_VIDEOSOURCE)
            return FALSE;
        if (lpcs->sCapDrvCaps.fHasDlgVideoSource) {
	    lpcs->dwDlgsActive |= VDLG_VIDEOSOURCE;
            videoDialog (lpcs->hVideoCapture, lpcs->hwnd, 0L );
            // Changing from NTSC to PAL could affect image dimensions!!!
            DibGetNewFormatFromDriver (lpcs);
            PalGetPaletteFromDriver (lpcs);

            // May need to inform parent of new layout here!
            InvalidateRect(lpcs->hwnd, NULL, TRUE);
            UpdateWindow(lpcs->hwnd);
	    lpcs->dwDlgsActive &= ~VDLG_VIDEOSOURCE;
        }
        return (lpcs->sCapDrvCaps.fHasDlgVideoSource);

    case WM_CAP_DLG_VIDEOFORMAT:
        // Show the format dialog, user selects dimensions, depth, compression
        // wParam and lParam are unused
        if (!lpcs->fHardwareConnected)
            return FALSE;
        if (lpcs->dwDlgsActive & VDLG_VIDEOFORMAT)
            return FALSE;
        if (lpcs->sCapDrvCaps.fHasDlgVideoFormat) {
	    lpcs->dwDlgsActive |= VDLG_VIDEOFORMAT;
            videoDialog (lpcs->hVideoIn, lpcs->hwnd, 0L );
            DibGetNewFormatFromDriver (lpcs);
            PalGetPaletteFromDriver (lpcs);

            // May need to inform parent of new layout here!
            InvalidateRect(lpcs->hwnd, NULL, TRUE);
            UpdateWindow(lpcs->hwnd);
	    lpcs->dwDlgsActive &= ~VDLG_VIDEOFORMAT;
        }
        return (lpcs->sCapDrvCaps.fHasDlgVideoFormat);

    case WM_CAP_DLG_VIDEODISPLAY:
        // Show the dialog which controls output.
        // This dialog only affects the presentation, never the data format
        // wParam and lParam are unused
        if (!lpcs->fHardwareConnected)
            return FALSE;
        if (lpcs->dwDlgsActive & VDLG_VIDEODISPLAY)
            return FALSE;
        if (lpcs->sCapDrvCaps.fHasDlgVideoDisplay) {
	    lpcs->dwDlgsActive |= VDLG_VIDEODISPLAY;
            videoDialog (lpcs->hVideoDisplay, lpcs->hwnd, 0L);
	    lpcs->dwDlgsActive &= ~VDLG_VIDEODISPLAY;
        }
        return (lpcs->sCapDrvCaps.fHasDlgVideoDisplay);

    case WM_CAP_DLG_VIDEOCOMPRESSION:
#ifndef NEW_COMPMAN
	return FALSE;
#else
        // Show the dialog which selects video compression options.
        // wParam and lParam are unused
        if (!lpcs->fHardwareConnected)
            return FALSE;
	if (lpcs->dwDlgsActive & VDLG_COMPRESSION)
            return FALSE;
	lpcs->dwDlgsActive |= VDLG_COMPRESSION;
        ICCompressorChoose(
                lpcs->hwnd,            // parent window for dialog
                ICMF_CHOOSE_KEYFRAME,  // want "key frame every" box
                lpcs->lpBitsInfo,      // input format (optional)
                NULL,                  // input data (optional)
                &lpcs->CompVars,       // data about the compressor/dlg
                NULL);                 // title bar (optional)
	lpcs->dwDlgsActive &= ~VDLG_COMPRESSION;
        return TRUE;
#endif

    case WM_CAP_SET_VIDEOFORMAT:
        // wParam is the size of the BITMAPINFO
        // lParam is an LPBITMAPINFO
        if (!lpcs->fHardwareConnected)
            return FALSE;
        if (IsBadReadPtr ((LPVOID) lParam, (UINT) wParam))
            return FALSE;

        return (DibNewFormatFromApp (lpcs, (LPBITMAPINFO) lParam, (UINT) wParam));

    case WM_CAP_SET_PREVIEW:
        // if wParam, enable preview via drawdib
        if (!lpcs->fHardwareConnected)
            return FALSE;
        if (wParam) {
            // turn off the overlay, if it is in use
            if (lpcs->fOverlayWindow)
                SendMessage(lpcs->hwnd, WM_CAP_SET_OVERLAY, 0, 0L);
            lpcs->fLiveWindow = TRUE;
            statusUpdateStatus(lpcs, IDS_CAP_STAT_LIVE_MODE);
         } // endif enabling preview
         else {
            lpcs->fLiveWindow = FALSE;
        }
        InvalidateRect (lpcs->hwnd, NULL, TRUE);
        return TRUE;

    case WM_CAP_SET_OVERLAY:
        // if wParam, enable overlay in hardware
        if (!lpcs->fHardwareConnected)
            return FALSE;
        if (wParam && lpcs->sCapDrvCaps.fHasOverlay) {
            if (lpcs->fLiveWindow)   // turn off preview mode
                SendMessage(lpcs->hwnd, WM_CAP_SET_PREVIEW, 0, 0L);
            lpcs->fOverlayWindow = TRUE;
            statusUpdateStatus(lpcs, IDS_CAP_STAT_OVERLAY_MODE);
        }
        else {
            lpcs->fOverlayWindow = FALSE;
            videoStreamFini (lpcs->hVideoDisplay); // disable overlay on hardware
        }
        InvalidateRect (lpcs->hwnd, NULL, TRUE);
        return (lpcs->sCapDrvCaps.fHasOverlay);

    case WM_CAP_SET_PREVIEWRATE:
        // wParam contains preview update rate in mS.
        // if wParam == 0 no timer is in use.
        if (lpcs->idTimer) {
            KillTimer(lpcs->hwnd, ID_PREVIEWTIMER);
            lpcs->idTimer = 0;
        }
        if (wParam != 0) {
            lpcs->idTimer = SetTimer (lpcs->hwnd, ID_PREVIEWTIMER,
                        (UINT) wParam, NULL);
        }
        lpcs->uTimeout = (UINT) wParam;
        dwReturn = TRUE;
        break;

    case WM_CAP_GRAB_FRAME:
        // grab a single frame
        // wParam and lParam unused
        if (!lpcs->fHardwareConnected)
            return FALSE;
        if (lpcs->sCapDrvCaps.fCaptureInitialized) {

           dwReturn = (DWORD) GetAFrameThenCallback (lpcs, TRUE /*fForce*/);

           // disable live and overlay mode when capturing a single frame
           if (lpcs->fLiveWindow)
               SendMessage(lpcs->hwnd, WM_CAP_SET_PREVIEW, 0, 0L);
           else if (lpcs->fOverlayWindow)
               SendMessage(lpcs->hwnd, WM_CAP_SET_OVERLAY, 0, 0L);
        }
        break;

    case WM_CAP_GRAB_FRAME_NOSTOP:
        // grab a single frame, but don't change state of overlay/preview
        // wParam and lParam unused
        if (!lpcs->fHardwareConnected)
            return FALSE;
        dwReturn = (LONG) GetAFrameThenCallback (lpcs, TRUE /*fForce*/);
        break;

    case WM_CAP_SEQUENCE:
        // This is the main entry for streaming video capture
        // wParam is unused
        // lParam is unused
        if (!lpcs->fHardwareConnected)
            return FALSE;
        if (lpcs->sCapDrvCaps.fCaptureInitialized) {
            lpcs->fCaptureFlags |= CAP_fCapturingToDisk;
            return (AVICapture(lpcs));
        }
        break;

    case WM_CAP_SEQUENCE_NOFILE:
        // wParam is unused
        // lParam is unused
        if (!lpcs->fHardwareConnected)
            return FALSE;
        if (lpcs->sCapDrvCaps.fCaptureInitialized) {
            lpcs->fCaptureFlags &= ~CAP_fCapturingToDisk;
            return (AVICapture(lpcs));
        }
        break;

    case WM_CAP_SET_SEQUENCE_SETUP:
        // wParam is sizeof CAPTUREPARMS
        // lParam = LPCAPTUREPARMS
        // The following were added after the Beta, init in case the client
        // has a smaller structure and doesn't access them.
	// WHICH BETA ?? (SteveDav)  We should change the comment to include a date

        lpcs->sCapParms.dwAudioBufferSize = 0;
        lpcs->sCapParms.fDisableWriteCache = TRUE;
        lpcs->sCapParms.AVStreamMaster = AVSTREAMMASTER_AUDIO;

        if (wParam <= sizeof (CAPTUREPARMS)) {
            dwT = min (sizeof (CAPTUREPARMS), wParam);
            if (IsBadReadPtr ((LPVOID) lParam, (UINT) dwT))
                break;

            _fmemcpy ((LPVOID) &lpcs->sCapParms, (LPVOID) lParam, (UINT) dwT);

            // Validate stuff that isn't handled elsewhere
            if (lpcs->sCapParms.wChunkGranularity != 0 &&
                lpcs->sCapParms.wChunkGranularity < 16)
                lpcs->sCapParms.wChunkGranularity = 16;
            if (lpcs->sCapParms.wChunkGranularity > 16384)
                lpcs->sCapParms.wChunkGranularity = 16384;

            if (lpcs->sCapParms.fLimitEnabled && (lpcs->sCapParms.wTimeLimit == 0))
                lpcs->sCapParms.wTimeLimit = 1;

            // Force Step MCI off if not using MCI control
            if (lpcs->sCapParms.fStepMCIDevice && !lpcs->sCapParms.fMCIControl)
                    lpcs->sCapParms.fStepMCIDevice = FALSE;

            // Prevent audio capture if no audio hardware
            lpcs->sCapParms.fCaptureAudio =
                lpcs->fAudioHardware && lpcs->sCapParms.fCaptureAudio;

            // Limit audio buffers
            lpcs->sCapParms.wNumAudioRequested =
                min (MAX_WAVE_BUFFERS, lpcs->sCapParms.wNumAudioRequested);

            // Limit video buffers
            lpcs->sCapParms.wNumVideoRequested =
                min (MAX_VIDEO_BUFFERS, lpcs->sCapParms.wNumVideoRequested);

            dwReturn = TRUE;
        }
        break;

    // unicode and win-16 version - see ansi thunk below
    case WM_CAP_SET_MCI_DEVICE:
        // lParam points to the name of the MCI Device
        if (IsBadStringPtr ((LPVOID) lParam, 1))
            return FALSE;
        if (lParam) {
            lstrcpyn (lpcs->achMCIDevice, (LPTSTR) lParam, NUMELMS(lpcs->achMCIDevice));
            dwReturn = TRUE;
        }
        break;
#ifdef UNICODE
    // ansi thunk for above
    case WM_CAP_SET_MCI_DEVICEA:
        // lParam points to Ansi name of MCI device
        if (lParam) {
            //remember the null
            int chsize = lstrlenA( (LPSTR) lParam)+1;
            Imbstowcs(lpcs->achMCIDevice, (LPSTR) lParam,
                min(chsize, NUMELMS(lpcs->achMCIDevice)));
            dwReturn = TRUE;
        }
        break;
#endif


    case WM_CAP_SET_SCROLL:
        // lParam is an LPPOINT which points to the new scroll position
        if (!lpcs->fHardwareConnected)
            return FALSE;
        if (IsBadReadPtr ((LPVOID) lParam, sizeof (POINT)))
            return FALSE;

        {
            LPPOINT lpP = (LPPOINT) lParam;

            if (lpP->x < lpcs->dxBits && lpP->y < lpcs->dyBits) {
                lpcs->ptScroll = *lpP;
                InvalidateRect (lpcs->hwnd, NULL, TRUE);
                dwReturn = TRUE;
            }
        }
        break;

    case WM_CAP_SET_SCALE:
        // if wParam, Scale the window to the client region?
        if (!lpcs->fHardwareConnected)
            return FALSE;
        lpcs->fScale = (BOOL) wParam;
        return TRUE;

    // unicode and win-16 version - see ansi thunk below
    case WM_CAP_PAL_OPEN:
        // Open a new palette
        // wParam is unused
        // lParam contains an LPTSTR to the file
        if (!lpcs->fHardwareConnected)
            return FALSE;
        if (IsBadStringPtr ((LPVOID) lParam, 1))
            return FALSE;
        return fileOpenPalette(lpcs, (LPTSTR) lParam /*lpszFileName*/);
#ifdef UNICODE
    // ansi thunk for above
    case WM_CAP_PAL_OPENA:
        // lParam contains (ANSI) lpstr for filename
        if (lParam) {
            // remember the null
            int chsize = lstrlenA( (LPSTR) lParam)+1;
            LPWSTR pw = LocalAlloc(LPTR, chsize * sizeof(WCHAR));
	    if (pw) {
                Imbstowcs(pw, (LPSTR) lParam, chsize);
                dwReturn = fileOpenPalette(lpcs, pw);
                LocalFree(pw);
	    }
        }
        break;
#endif

    // unicode and win-16 version - see ansi thunk below
    case WM_CAP_PAL_SAVE:
        // Save the current palette in a file
        // wParam is unused
        // lParam contains an LPTSTR to the file
        if (!lpcs->fHardwareConnected)
            return FALSE;
        if (IsBadStringPtr ((LPVOID) lParam, 1))
            return FALSE;
        return fileSavePalette(lpcs, (LPTSTR) lParam /*lpszFileName*/);
#ifdef UNICODE
    // ansi thunk for above
    case WM_CAP_PAL_SAVEA:
        // lParam contains (ANSI) lpstr for filename
        if (lParam) {
            // remember the null
            int chsize = lstrlenA( (LPSTR) lParam)+1;
            LPWSTR pw = LocalAlloc(LPTR, chsize * sizeof(WCHAR));
	    if (pw) {
                Imbstowcs(pw, (LPSTR) lParam, chsize);
                dwReturn = fileSavePalette(lpcs, pw);
                LocalFree(pw);
	    }
        }
        break;
#endif


    case WM_CAP_PAL_AUTOCREATE:
        // Automatically capture a palette
        // wParam contains a count of the number of frames to average
        // lParam contains the number of colors desired in the palette
        if (!lpcs->fHardwareConnected)
            return FALSE;
        return CapturePaletteAuto (lpcs, (int) wParam, (int) lParam);

    case WM_CAP_PAL_MANUALCREATE:
        // Manually capture a palette
        // wParam contains TRUE for each frame to capture, FALSE when done
        // lParam contains the number of colors desired in the palette
        if (!lpcs->fHardwareConnected)
            return FALSE;
        return CapturePaletteManual (lpcs, (BOOL) wParam, (int) lParam);

    case WM_CAP_PAL_PASTE:
        // Paste a palette from the clipboard, send to the driver
        if (!lpcs->fHardwareConnected)
            return FALSE;
        if (lpcs->sCapDrvCaps.fCaptureInitialized && OpenClipboard(lpcs->hwnd)) {
            HANDLE  hPal;

            hPal = GetClipboardData(CF_PALETTE);
            CloseClipboard();
            if (hPal) {
                PalSendPaletteToDriver (lpcs, CopyPalette(hPal),  NULL /* XlateTable */);
                InvalidateRect(lpcs->hwnd, NULL, TRUE);
                dwReturn = TRUE;
            }
        }
        break;

    default:
        break;
    }
    return dwReturn;
}


/*--------------------------------------------------------------+
| ****************** THE WINDOW PROCEDURE ********************* |
+--------------------------------------------------------------*/
LONG FAR PASCAL LOADDS EXPORT CapWndProc (HWND hwnd, UINT msg, UINT wParam, LONG lParam)
{
    LPCAPSTREAM lpcs;
    PAINTSTRUCT ps;
    HDC         hdc;
    MSG         PMsg;
    int         f;

    lpcs = (LPCAPSTREAM) GetWindowLong (hwnd, GWL_CAPSTREAM);

    if (msg >= WM_CAP_START && msg <= WM_CAP_END)
        return (ProcessCommandMessages (lpcs, msg, wParam, lParam));

    switch (msg) {

    case WM_CREATE:
        lpcs = CapWinCreate (hwnd);
        break;

    case WM_TIMER:
        // Update the preview window if we got a timer and not saving to disk
        GetAFrameThenCallback (lpcs, FALSE /*fForce*/);

        // Added VFW 1.1b, Clear the queue of additional timer msgs!!!

        // Even in Win32, processing frame timers can swamp all other
        // activity in the app, so clear the queue after each frame is done.

        // This successfully corrected a problem with the "Hit OK to continue"
        // dialog not appearing bug due to app message queue
        // swamping with timer messages at large
        // image dimensions and preview rates.

        PeekMessage (&PMsg, hwnd, WM_TIMER, WM_TIMER,PM_REMOVE|PM_NOYIELD);
        break;

    case WM_CLOSE:
        break;

    case WM_DESTROY:
        CapWinDestroy (lpcs);
        break;

    case WM_PALETTECHANGED:
        if (lpcs->hdd == NULL)
            break;

        hdc = GetDC(hwnd);
        if (f = DrawDibRealize(lpcs->hdd, hdc, TRUE /*fBackground*/))
            InvalidateRect(hwnd,NULL,TRUE);
        ReleaseDC(hwnd,hdc);
        return f;

    case WM_QUERYNEWPALETTE:
        if (lpcs->hdd == NULL)
            break;
        hdc = GetDC(hwnd);
        f = DrawDibRealize(lpcs->hdd, hdc, FALSE);
        ReleaseDC(hwnd, hdc);

        if (f)
            InvalidateRect(hwnd, NULL, TRUE);
        return f;

    case WM_SIZE:
    case WM_MOVE:
        if (lpcs->fOverlayWindow)    // Make the driver paint the key color
            InvalidateRect(hwnd, NULL, TRUE);
        break;

    case WM_WINDOWPOSCHANGED:
        if (lpcs->fOverlayWindow)    // Make the driver paint the key color
            InvalidateRect(hwnd, NULL, TRUE);
        return 0;

    case WM_ERASEBKGND:
        return 0;  // don't bother to erase it

    case WM_PAINT:
        hdc = BeginPaint(hwnd, &ps);
        if (lpcs->fOverlayWindow) {
            CheckWindowMove(lpcs, ps.hdc, TRUE);
        }
        else {
#ifdef _WIN32
            SetWindowOrgEx(hdc, lpcs->ptScroll.x, lpcs->ptScroll.y, NULL);
#else
            SetWindowOrg(hdc, lpcs->ptScroll.x, lpcs->ptScroll.y);
#endif
            DibPaint(lpcs, hdc);
        }
        EndPaint(hwnd, &ps);
        break;

    default:
        break;
    }
    return DefWindowProc(hwnd, msg, wParam, lParam);
}

#if 0
void dummyTest ()
{
    HWND hwnd;
    FARPROC fpProc;
    DWORD dwSize;
    WORD  wSize;
    BOOL f;
    int i;
    char szName[80];
    char szVer[80];
    DWORD dwMS;
    int iFrames, iColors;
    char s;
    LPPOINT lpP;

    capSetCallbackOnError(hwnd, fpProc);
    capSetCallbackOnStatus(hwnd, fpProc);
    capSetCallbackOnYield(hwnd, fpProc);
    capSetCallbackOnFrame(hwnd, fpProc);
    capSetCallbackOnVideoStream(hwnd, fpProc);
    capSetCallbackOnWaveStream(hwnd, fpProc);

    capDriverConnect(hwnd, i);
    capDriverDisconnect(hwnd);
    capDriverGetName(hwnd, szName, wSize);
    capDriverGetVersion(hwnd, szVer, wSize);
    capDriverGetCaps(hwnd, s, wSize);

    capFileSetCaptureFile(hwnd, szName);
    capFileGetCaptureFile(hwnd, szName, wSize);
    capFileAlloc(hwnd, dwSize);
    capFileSaveAs(hwnd, szName);

    capEditCopy(hwnd);

    capSetAudioFormat(hwnd, s, wSize);
    capGetAudioFormat(hwnd, s, wSize);
    capGetAudioFormatSize(hwnd);

    capDlgVideoFormat(hwnd);
    capDlgVideoSource(hwnd);
    capDlgVideoDisplay(hwnd);

    capPreview(hwnd, f);
    capPreviewRate(hwnd, dwMS);
    capOverlay(hwnd, f);
    capPreviewScale(hwnd, f);
    capGetStatus(hwnd, s, wSize);
    capSetScrollPos(hwnd, lpP);

    capGrabFrame(hwnd);
    capGrabFrameNoStop(hwnd);
    capCaptureSequence(hwnd);
    capCaptureSequenceNoFile(hwnd);
    capCaptureGetSetup(hwnd, s, wSize);
    capCaptureSetSetup(hwnd, s, wSize);

    capCaptureSingleFrameOpen(hwnd);
    capCaptureSingleFrameClose(hwnd);
    capCaptureSingleFrame(hwnd);

    capSetMCIDeviceName(hwnd, szName);
    capGetMCIDeviceName(hwnd, szName, wSize);

    capPalettePaste(hwnd);
    capPaletteAuto(hwnd, iFrames, iColors);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avicap\dibmap.h ===
/****************************************************************************
 *
 *   dibmap.h
 *
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992-1994 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and
 *    distribute the Sample Files (and/or any modified version) in
 *    any way you find useful, provided that you agree that
 *    Microsoft has no warranty obligations or liability for any
 *    Sample Application Files which are modified.
 *
 ***************************************************************************/

#ifndef _LPHISTOGRAM_DEFINED
#define _LPHISTOGRAM_DEFINED
typedef DWORD HUGE * LPHISTOGRAM;
#endif

#define RGB16(r,g,b) (\
            (((WORD)(r) >> 3) << 10) |  \
            (((WORD)(g) >> 3) << 5)  |  \
            (((WORD)(b) >> 3) << 0)  )

LPHISTOGRAM     InitHistogram(LPHISTOGRAM lpHistogram);
void            FreeHistogram(LPHISTOGRAM lpHistogram);
HPALETTE        HistogramPalette(LPHISTOGRAM lpHistogram, LPBYTE lp16to8, int nColors);
BOOL            DibHistogram(LPBITMAPINFOHEADER lpbi, LPBYTE lpBits, int x, int y, int dx, int dy, LPHISTOGRAM lpHistogram);
HANDLE          DibReduce(LPBITMAPINFOHEADER lpbi, LPBYTE lpBits, HPALETTE hpal, LPBYTE lp16to8);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avicap\cappal.h ===
/****************************************************************************
 *
 *   cappal.h
 *
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992-1994 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and
 *    distribute the Sample Files (and/or any modified version) in
 *    any way you find useful, provided that you agree that
 *    Microsoft has no warranty obligations or liability for any
 *    Sample Application Files which are modified.
 *
 ***************************************************************************/

// Structure used when capturing a palette
typedef struct tagCAPPAL {
    WORD                wNumFrames;
    WORD                wNumColors;
    LPBYTE              lpBits;
    LPBYTE              lp16to8;
    VIDEOHDR            vHdr;
    BITMAPINFOHEADER    bi16;
    LPHISTOGRAM         lpHistogram;
    LPBITMAPINFO        lpbiSave;
} CAPPAL, FAR * LPCAPPAL;

BOOL PalInit (LPCAPSTREAM lpcs);
void PalFini (LPCAPSTREAM lpcs);
void PalDeleteCurrentPalette (LPCAPSTREAM lpcs);
BOOL PalGetPaletteFromDriver (LPCAPSTREAM lpcs);
DWORD PalSendPaletteToDriver (LPCAPSTREAM lpcs, HPALETTE hpal, LPBYTE lpXlateTable);
HPALETTE CopyPalette (HPALETTE hpal);
DWORD CapturePaletteInit (LPCAPSTREAM lpcs, LPCAPPAL lpcp);
DWORD CapturePaletteFini (LPCAPSTREAM lpcs, LPCAPPAL lpcp);
DWORD CapturePaletteFrames (LPCAPSTREAM lpcs, LPCAPPAL lpCapPal, int nCount);
BOOL CapturePaletteAuto (LPCAPSTREAM lpcs, int nCount, int nColors);
BOOL CapturePaletteManual (LPCAPSTREAM lpcs, BOOL fGrab, int nColors);
void CapturePaletteDialog (LPCAPSTREAM lpcs);
LONG FAR PASCAL EXPORT cappalDlgProc(HWND hwnd, unsigned msg, UINT wParam, LONG lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avicap\capmisc.c ===
/****************************************************************************
 *
 *   capmisc.c
 *
 *   Miscellaneous status and error routines.
 *
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992, 1993 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and
 *    distribute the Sample Files (and/or any modified version) in
 *    any way you find useful, provided that you agree that
 *    Microsoft has no warranty obligations or liability for any
 *    Sample Application Files which are modified.
 *
 ***************************************************************************/

#define INC_OLE2
#pragma warning(disable:4103)
#include <windows.h>
#include <windowsx.h>
#include <win32.h>
#include <mmsystem.h>
#include <msvideo.h>
#include <drawdib.h>

#include "ivideo32.h"
#include "avicap.h"
#include "avicapi.h"

#include <stdarg.h>

static TCHAR szNull[] = TEXT("");

/*
 *
 *   GetKey
 *           Peek into the message que and get a keystroke
 *
 */
UINT GetKey(BOOL fWait)
{
    MSG msg;

    msg.wParam = 0;

    if (fWait)
         GetMessage(&msg, NULL, WM_KEYFIRST, WM_KEYLAST);

    while(PeekMessage(&msg, NULL, WM_KEYFIRST, WM_KEYLAST, PM_REMOVE|PM_NOYIELD))
         ;
    return msg.wParam;
}

// wID is the string resource, which can be a format string
//
void FAR CDECL statusUpdateStatus (LPCAPSTREAM lpcs, UINT wID, ...)
{
    TCHAR ach[256];
    TCHAR szFmt[132];
    va_list va;

    if (!lpcs->CallbackOnStatus)
        return;

    if (wID == 0) {
        if (lpcs->fLastStatusWasNULL)   // No need to send NULL twice in a row
            return;
        lpcs->fLastStatusWasNULL = TRUE;
        ach[0] = 0;
    }
    else {
        lpcs->fLastStatusWasNULL = FALSE;
        if (!LoadString(lpcs->hInst, wID, szFmt, NUMELMS(szFmt))) {
            MessageBeep (0);
            return;
        }
        else {
            va_start(va, wID);
            wvsprintf(ach, szFmt, va);
            va_end(va);
        }
    }

   #ifdef UNICODE
    //
    // if the status callback function is expecting ansi
    // strings, then convert the UNICODE status string to
    // ansi before calling him
    //
    if (lpcs->fUnicode & VUNICODE_STATUSISANSI) {

        char achAnsi[256];

        // convert string to Ansi and callback.
        // that we cast achAnsi to WChar on the call to
        // avoid a bogus warning.
        //
        WideToAnsi(achAnsi, ach, lstrlen(ach)+1);
        lpcs->CallbackOnStatus(lpcs->hwnd, wID, (LPWSTR)achAnsi);
    }
    else
   #endif
       lpcs->CallbackOnStatus(lpcs->hwnd, wID, ach);
}

// wID is the string resource, which can be a format string
//
void FAR CDECL errorUpdateError (LPCAPSTREAM lpcs, UINT wID, ...)
{
    TCHAR ach[256];
    TCHAR szFmt[132];
    va_list va;

    lpcs->dwReturn = wID;

    if (!lpcs->CallbackOnError)
        return;

    if (wID == 0) {
        if (lpcs->fLastErrorWasNULL)   // No need to send NULL twice in a row
            return;
        lpcs->fLastErrorWasNULL = TRUE;
        ach[0] = 0;
    }
    else if (!LoadString(lpcs->hInst, wID, szFmt, NUMELMS(szFmt))) {
        MessageBeep (0);
        lpcs->fLastErrorWasNULL = FALSE;
        return;
    }
    else {
        lpcs->fLastErrorWasNULL = FALSE;
        va_start(va, wID);
        wvsprintf(ach, szFmt, va);
        va_end(va);
    }

   #ifdef UNICODE
    if (lpcs->fUnicode & VUNICODE_ERRORISANSI)
    {
        char achAnsi[256];

        // convert string to Ansi and callback.
        // that we cast achAnsi to WChar on the call to
        // avoid a bogus warning.
        //
        WideToAnsi(achAnsi, ach, lstrlen(ach)+1);
        lpcs->CallbackOnError(lpcs->hwnd, wID, (LPWSTR)achAnsi);
    }
    else
   #endif
    {
        lpcs->CallbackOnError(lpcs->hwnd, wID, ach);
    }
}

// Callback client with ID of driver error msg
void errorDriverID (LPCAPSTREAM lpcs, DWORD dwError)
{
    // this is the correct code, but NT VfW 1.0 has a bug
    // that videoGetErrorText is ansi. need vfw1.1 to fix this

#ifndef UNICODE
    char ach[132];
#endif

    lpcs->fLastErrorWasNULL = FALSE;
    lpcs->dwReturn = dwError;

    if (!lpcs->CallbackOnError)
        return;


   #ifdef UNICODE
    if (lpcs->fUnicode & VUNICODE_ERRORISANSI) {
        char achAnsi[256];
	achAnsi[0]=0;
        if (dwError)
            videoGetErrorTextA(lpcs->hVideoIn, dwError, achAnsi, NUMELMS(achAnsi));
        lpcs->CallbackOnError (lpcs->hwnd, IDS_CAP_DRIVER_ERROR, (LPWSTR)achAnsi);
    } else {
	// pass unicode string to error handler
        WCHAR achWide[256];
	achWide[0]=0;
        if (dwError)
            videoGetErrorTextW(lpcs->hVideoIn, dwError, achWide, NUMELMS(achWide));
        lpcs->CallbackOnError (lpcs->hwnd, IDS_CAP_DRIVER_ERROR, (LPWSTR)achWide);
    }
   #else  // not unicode
    ach[0] = 0;
    if (dwError)
        videoGetErrorText (lpcs->hVideoIn, dwError, ach, NUMELMS(ach));
        lpcs->CallbackOnError(lpcs->hwnd, IDS_CAP_DRIVER_ERROR, ach);
   #endif
}

#ifdef  _DEBUG

void FAR cdecl dprintf(LPSTR szFormat, ...)
{
    UINT n;
    char ach[256];
    va_list va;

    static BOOL fDebug = -1;

    if (fDebug == -1)
        fDebug = GetProfileIntA("Debug", "AVICAP32", FALSE);

    if (!fDebug)
        return;

#ifdef _WIN32
    n = wsprintfA(ach, "AVICAP32: (tid %x) ", GetCurrentThreadId());
#else
    strcpy(ach, "AVICAP32: ");
    n = strlen(ach);
#endif

    va_start(va, szFormat);
    wvsprintfA(ach+n, szFormat, va);
    va_end(va);

    lstrcatA(ach, "\r\n");

    OutputDebugStringA(ach);
}

/* _Assert(fExpr, szFile, iLine)
 *
 * If <fExpr> is TRUE, then do nothing.  If <fExpr> is FALSE, then display
 * an "assertion failed" message box allowing the user to abort the program,
 * enter the debugger (the "Retry" button), or igore the error.
 *
 * <szFile> is the name of the source file; <iLine> is the line number
 * containing the _Assert() call.
 */

BOOL FAR PASCAL
_Assert(BOOL fExpr, LPSTR szFile, int iLine)
{
    static char       ach[300];         // debug output (avoid stack overflow)
    int               id;
    int               iExitCode;
    void FAR PASCAL DebugBreak(void);

    /* check if assertion failed */
    if (fExpr)
             return fExpr;

    /* display error message */
    wsprintfA(ach, "File %s, line %d", (LPSTR) szFile, iLine);
    MessageBeep(MB_ICONHAND);
    id = MessageBoxA (NULL, ach, "Assertion Failed",
                      MB_SYSTEMMODAL | MB_ICONHAND | MB_ABORTRETRYIGNORE);

    /* abort, debug, or ignore */
    switch (id)
    {
    case IDABORT: /* kill this application */
        iExitCode = 0;
        ExitProcess(0);
        break;

    case IDRETRY: /* break into the debugger */
        DebugBreak();
        break;

    case IDIGNORE:
        /* ignore the assertion failure */
        break;
    }

    return FALSE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avicap\cappal.c ===
/****************************************************************************
 *
 *   cappal.c
 *
 *   Palette processing module.
 *
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992, 1993 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and
 *    distribute the Sample Files (and/or any modified version) in
 *    any way you find useful, provided that you agree that
 *    Microsoft has no warranty obligations or liability for any
 *    Sample Application Files which are modified.
 *
 ***************************************************************************/

#define INC_OLE2
#pragma warning(disable:4103)
#include <windows.h>
#include <windowsx.h>
#include <win32.h>
#include <mmsystem.h>
#include <msvideo.h>
#include <drawdib.h>

#include "ivideo32.h"
#include "avicap.h"
#include "avicapi.h"
#include "cappal.h"
#include "capdib.h"
#include "dibmap.h"

//
// Allocate and initialize palette resources at Window create time
//
BOOL PalInit (LPCAPSTREAM lpcs)
{
    return (PalGetPaletteFromDriver (lpcs));
}

//
// FreePaletteCache - free the RGB555 Xlate table
//
void FreePaletteCache (LPCAPSTREAM lpcs)
{
    if (lpcs->lpCacheXlateTable) {
        GlobalFreePtr (lpcs->lpCacheXlateTable);
	lpcs->lpCacheXlateTable = NULL;
    }
}

//
// Release palette resources at Window destroy time
//
void PalFini (LPCAPSTREAM lpcs)
{
    PalDeleteCurrentPalette (lpcs);

    FreePaletteCache (lpcs);
}

//
// Delete our palette if it isn't the system default palette
//
void PalDeleteCurrentPalette (LPCAPSTREAM lpcs)
{
    if (lpcs->hPalCurrent &&
            (lpcs->hPalCurrent != GetStockObject(DEFAULT_PALETTE)))
        DeleteObject (lpcs->hPalCurrent);
    lpcs->hPalCurrent = NULL;
}

//
// Get the current palette (from the driver)
// Returns: TRUE if the driver can supply a palette
//

BOOL PalGetPaletteFromDriver (LPCAPSTREAM lpcs)
{
    FCLOGPALETTE        pal;

    PalDeleteCurrentPalette (lpcs);

    pal.palVersion = 0x0300;
    pal.palNumEntries = 256;

    lpcs->sCapDrvCaps.fDriverSuppliesPalettes = FALSE;  // assume the worst

    if (lpcs->fHardwareConnected) {
        if (videoConfigure (lpcs->hVideoIn,
                DVM_PALETTE,
                VIDEO_CONFIGURE_GET | VIDEO_CONFIGURE_CURRENT, NULL,
                (LPVOID)&pal, sizeof(pal),
                NULL, 0 ) == DV_ERR_OK) {
            if (lpcs->hPalCurrent = CreatePalette ((LPLOGPALETTE) &pal))
                lpcs->sCapDrvCaps.fDriverSuppliesPalettes = TRUE;
        }
    }
    if (!lpcs->hPalCurrent)
        lpcs->hPalCurrent = GetStockObject (DEFAULT_PALETTE);

    DibNewPalette (lpcs, lpcs->hPalCurrent);

    return (lpcs->sCapDrvCaps.fDriverSuppliesPalettes);
}

//
// Set the current palette used for capture by sending a copy to the driver
// and then copying the entries to out DIB.
// This may also be called when reconnecting a driver and using a cached
// copy of the palette.
// Returns TRUE on success, or FALSE on failure.
//
DWORD PalSendPaletteToDriver (LPCAPSTREAM lpcs, HPALETTE hpal, LPBYTE lpXlateTable)
{
    short               nColors;
    FCLOGPALETTE        pal;
    HCURSOR             hOldCursor;

    // The following can take a while so repaint our parent
    UpdateWindow (GetParent (lpcs-> hwnd));
    UpdateWindow (lpcs->hwnd);

    if (!hpal)
        return FALSE;

    // Allocate a xlate table cache?
    if (lpXlateTable) {
        if (lpcs->lpCacheXlateTable == NULL) {
            lpcs->lpCacheXlateTable = GlobalAllocPtr (GHND, 0x8000l);
            if (!lpcs->lpCacheXlateTable)
                return FALSE;
        }

        // If we're not using the cached table, update the cache
        if (lpcs->lpCacheXlateTable != lpXlateTable)
            _fmemcpy (lpcs->lpCacheXlateTable, lpXlateTable, (UINT) 0x8000l);
    }
    else {
        FreePaletteCache (lpcs);
    }

    // Don't destroy the current palette when reconnecting...
    if (hpal != lpcs->hPalCurrent) {
        PalDeleteCurrentPalette (lpcs);
        lpcs->hPalCurrent = hpal;
    }

    GetObject(hpal, sizeof(short), (LPVOID)&nColors);

    if( nColors <= 1 ) {    //!!>
        return( FALSE );
    }

    nColors = min(256, nColors);

    hOldCursor = SetCursor (lpcs-> hWaitCursor);

    statusUpdateStatus (lpcs, IDS_CAP_STAT_PALETTE_BUILD);

    pal.palVersion = 0x0300;
    pal.palNumEntries = nColors;

    GetPaletteEntries(hpal, 0, nColors, pal.palPalEntry);

    if (lpcs-> fHardwareConnected) {

        // first try to send both the xlate table and the palette
        if ((!lpXlateTable) || (videoConfigure( lpcs->hVideoIn,
                    DVM_PALETTERGB555,
                    VIDEO_CONFIGURE_SET, NULL,
                    (LPLOGPALETTE)&pal, sizeof(pal),
                    lpXlateTable, (DWORD) 0x8000) != 0)) {

            // else send just the palette and make the driver build the table
            if (videoConfigure( lpcs->hVideoIn,
                    DVM_PALETTE,
                    VIDEO_CONFIGURE_SET, NULL,
                    (LPLOGPALETTE)&pal, sizeof(pal),
                    NULL, 0 )) {
                // Scrncap doesn't support setting a palette, so
                // delete the palette cache
                FreePaletteCache (lpcs);
            }
        }
    }

    // Supermac wants us to get the palette again, they might have
    // mucked with it!
    PalGetPaletteFromDriver (lpcs);

    // Since the palette has changed, delete any existing compression
    // output format;  this forces a new output format to be selected
    if (lpcs->CompVars.lpbiOut) {
        GlobalFreePtr (lpcs->CompVars.lpbiOut);
        lpcs->CompVars.lpbiOut = NULL;
    }
    if (lpcs->CompVars.hic) {
        if (ICSeqCompressFrameStart(&lpcs->CompVars, lpcs->lpBitsInfo) == 0) {
            errorUpdateError (lpcs, IDS_CAP_COMPRESSOR_ERROR);
        }
    }

    InvalidateRect (lpcs->hwnd, NULL, TRUE);
    UpdateWindow (lpcs->hwnd);

    SetCursor (hOldCursor);
    statusUpdateStatus (lpcs, 0);

    return (TRUE);
}

//
// CopyPalette, makes a copy of a GDI logical palette
// Returns: a handle to the newly created palette, or NULL if error
//

HPALETTE CopyPalette (HPALETTE hpal)
{
    LPLOGPALETTE        lppal;
    short               nNumEntries;

    if (!hpal)
        return NULL;

    GetObject (hpal,sizeof(short),(LPVOID)&nNumEntries);

    if (nNumEntries == 0)
        return NULL;

    lppal = (LPLOGPALETTE) GlobalAllocPtr (GHND,
                sizeof(LOGPALETTE) + nNumEntries * sizeof(PALETTEENTRY));

    if (!lppal)
        return NULL;

    lppal->palVersion    = 0x300;
    lppal->palNumEntries = nNumEntries;

    GetPaletteEntries(hpal,0,nNumEntries,lppal->palPalEntry);

    hpal = CreatePalette(lppal);

    GlobalFreePtr (lppal);

    return hpal;
}


//
// Allocate resources needed for palette capture
// Returns DV_ERR_OK on success, or DV_ERR... on failure.
// Note: if Init fails, you MUST call the Fini function to
// release resources.
//
DWORD CapturePaletteInit (LPCAPSTREAM lpcs, LPCAPPAL lpcp)
{
    DWORD dwError = DV_ERR_OK;

    lpcp->lpBits = NULL;
    lpcp->lp16to8 = NULL;
    lpcp->lpHistogram = NULL;
    lpcp->lpbiSave = NULL;
    lpcp->wNumFrames = 0;

    // Init an RGB16 header
    lpcp->bi16.biSize         = sizeof(BITMAPINFOHEADER);
    lpcp->bi16.biWidth        = lpcs->dxBits;
    lpcp->bi16.biHeight       = lpcs->dyBits;
    lpcp->bi16.biPlanes       = 1;
    lpcp->bi16.biBitCount     = 16;
    lpcp->bi16.biCompression  = BI_RGB;
    lpcp->bi16.biSizeImage    = DIBWIDTHBYTES(lpcp->bi16) * lpcp->bi16.biHeight;
    lpcp->bi16.biXPelsPerMeter= 0;
    lpcp->bi16.biYPelsPerMeter= 0;
    lpcp->bi16.biClrUsed      = 0;
    lpcp->bi16.biClrImportant = 0;

    // Allocate memory for the histogram, DIB, and XLate table
    lpcp->lpBits  = GlobalAllocPtr (GHND, lpcp->bi16.biSizeImage);
    lpcp->lp16to8 = GlobalAllocPtr (GHND, 0x8000l);
    lpcp->lpHistogram = InitHistogram(NULL);

    if (!lpcp->lpBits || !lpcp->lp16to8 || !lpcp->lpHistogram) {
        dwError = DV_ERR_NOMEM;
        goto PalInitError;
    }

    // Init the video header
    lpcp->vHdr.lpData = lpcp->lpBits;
    lpcp->vHdr.dwBufferLength = lpcp->bi16.biSizeImage;
    lpcp->vHdr.dwUser = 0;
    lpcp->vHdr.dwFlags = 0;

    // Save the current format
    lpcp->lpbiSave = DibGetCurrentFormat (lpcs);

    // Make sure we can set the format to 16 bit RGB
    if(dwError = videoConfigure( lpcs->hVideoIn, DVM_FORMAT,
            VIDEO_CONFIGURE_SET, NULL,
            (LPBITMAPINFOHEADER)&lpcp->bi16, sizeof(BITMAPINFOHEADER),
            NULL, 0 ) ) {
        goto PalInitError;
    }

    // Put everything back the way it was
    if (dwError = videoConfigure( lpcs->hVideoIn, DVM_FORMAT,
            VIDEO_CONFIGURE_SET, NULL,
            (LPBITMAPINFOHEADER)lpcp->lpbiSave, lpcp->lpbiSave->bmiHeader.biSize,
            NULL, 0 )) {
        goto PalInitError;
    }

PalInitError:
    return dwError;
}

//
// Free resources used for palette capture
//
DWORD CapturePaletteFini (LPCAPSTREAM lpcs, LPCAPPAL lpcp)
{
    if (lpcp->lpBits) {
        GlobalFreePtr (lpcp->lpBits);
        lpcp->lpBits = NULL;
    }
    if (lpcp->lp16to8) {
        GlobalFreePtr (lpcp->lp16to8);
        lpcp->lp16to8 = NULL;
    }
    if (lpcp->lpHistogram) {
        FreeHistogram(lpcp->lpHistogram);
        lpcp->lpHistogram = NULL;
    }
    if (lpcp->lpbiSave) {
        GlobalFreePtr (lpcp->lpbiSave);
        lpcp->lpbiSave = NULL;
    }
    return DV_ERR_OK;
}

//
//  CapturePaletteFrames() The workhorse of capture palette.
//
DWORD CapturePaletteFrames (LPCAPSTREAM lpcs, LPCAPPAL lpcp, int nCount)
{
    int j;
    DWORD dwError;

    // switch to RGB16 format
    if (dwError = videoConfigure( lpcs->hVideoIn,
                DVM_FORMAT,
                VIDEO_CONFIGURE_SET, NULL,
                (LPBITMAPINFOHEADER)&lpcp->bi16, sizeof(BITMAPINFOHEADER),
                NULL, 0 ))
        goto CaptureFramesError;

    for (j = 0; j < nCount; j++){
        // Get a frame
        dwError = videoFrame(lpcs->hVideoIn, &lpcp->vHdr);

        // Let the user see it
        InvalidateRect (lpcs->hwnd, NULL, TRUE);
        UpdateWindow (lpcs->hwnd);

        // Histogram it
        DibHistogram(&lpcp->bi16, lpcp->lpBits, 0, 0, -1, -1, lpcp->lpHistogram);
        lpcp->wNumFrames++;
    }

    dwError = videoConfigure( lpcs->hVideoIn,
                DVM_FORMAT,
                VIDEO_CONFIGURE_SET, NULL,
                (LPBITMAPINFOHEADER)lpcp->lpbiSave,
                lpcp->lpbiSave->bmiHeader.biSize,
                NULL, 0 );

//    videoFrame( lpcs->hVideoIn, &lpcs->VidHdr );

CaptureFramesError:
    return dwError;
}

//
//  CapturePaletteAuto() capture a palette from the video source
//  without user intervention.
//  Returns TRUE on success, FALSE on error
//
BOOL CapturePaletteAuto (LPCAPSTREAM lpcs, int nCount, int nColors)
{
    HPALETTE    hpal;
    HCURSOR     hOldCursor;
    DWORD       dwError = DV_ERR_OK;
    CAPPAL      cappal;
    LPCAPPAL    lpcp;

    lpcp = &cappal;

    if (!lpcs->sCapDrvCaps.fDriverSuppliesPalettes)
        return FALSE;

    if (nColors <= 0 || nColors > 256)
        return FALSE;

    lpcp->wNumColors = max (nColors, 2);  // at least 2 colors

    if (nCount <= 0)
        return FALSE;

    if (dwError = CapturePaletteInit (lpcs, lpcp))
        goto PalAutoExit;

    hOldCursor = SetCursor(lpcs->hWaitCursor);

    CapturePaletteFrames (lpcs, lpcp, nCount);

    /* we grabbed a frame, time to compute a palette */
    statusUpdateStatus(lpcs, IDS_CAP_STAT_OPTPAL_BUILD);

    // The HPALETTE returned in the following becomes
    // our "global" palette, hence is not deleted here.
    hpal = HistogramPalette(lpcp->lpHistogram, lpcp->lp16to8, lpcp->wNumColors);

    // Send driver both the pal and xlate table
    PalSendPaletteToDriver(lpcs, hpal, (LPBYTE)lpcp->lp16to8 );

    videoFrame( lpcs->hVideoIn, &lpcs->VidHdr );  // Update the display with a new image

    SetCursor(hOldCursor);

    InvalidateRect(lpcs->hwnd, NULL, TRUE);
    UpdateWindow(lpcs->hwnd);
    lpcs->fUsingDefaultPalette = FALSE;

PalAutoExit:
    CapturePaletteFini (lpcs, lpcp);
    statusUpdateStatus(lpcs, 0);

   // If an error happened, display it
   if (dwError)
        errorDriverID (lpcs, dwError);

    return (dwError == DV_ERR_OK);
}

//
//  CapturePaletteManual() capture a palette from the video source
//  with user intervention.
//  fGrab is TRUE on all but the last frame captured
//  Returns TRUE on success, FALSE on error
//
BOOL CapturePaletteManual (LPCAPSTREAM lpcs, BOOL fGrab, int nColors)
{
    HPALETTE    hpal;
    HCURSOR     hOldCursor;
    LPCAPPAL    lpcp;
    DWORD       dwError = DV_ERR_OK;

    if (!lpcs->sCapDrvCaps.fDriverSuppliesPalettes)
        return FALSE;

    hOldCursor = SetCursor(lpcs->hWaitCursor);

    // We're initializing for the first time, so alloc everything
    if (lpcs->lpCapPal == NULL) {

        if (lpcp = (LPCAPPAL) GlobalAllocPtr (GHND, sizeof(CAPPAL))) {
            lpcs->lpCapPal = lpcp;

            if (nColors == 0)
                nColors = 256;
            lpcp->wNumColors = min (nColors, 256);
            dwError = CapturePaletteInit (lpcs, lpcp);
        }
        else
            dwError = IDS_CAP_OUTOFMEM;
    }
    lpcp = lpcs->lpCapPal;

    if (dwError != DV_ERR_OK)
        goto PalManualExit;

    // Add a frame to the histogram
    // Handle the case of telling us to stop before we ever started
    if (fGrab || !fGrab && (lpcp->wNumFrames == 0)) {
        CapturePaletteFrames (lpcs, lpcp, 1);
        lpcs->fUsingDefaultPalette = FALSE;
    }
    // All done, send the new palette to the driver
    if (!fGrab) {
        statusUpdateStatus(lpcs, IDS_CAP_STAT_OPTPAL_BUILD);

        // The HPALETTE returned in the following becomes
        // our "global" palette, hence is not deleted here.
        hpal = HistogramPalette(lpcp->lpHistogram,
                        lpcp->lp16to8, lpcp->wNumColors);

        // Send driver both the pal and xlate table
        PalSendPaletteToDriver(lpcs, hpal, (LPBYTE)lpcp->lp16to8 );
    }

    videoFrame( lpcs->hVideoIn, &lpcs->VidHdr );  // Update the display with a new image
    InvalidateRect(lpcs->hwnd, NULL, TRUE);
    UpdateWindow(lpcs->hwnd);

PalManualExit:
    if (!fGrab || (dwError != DV_ERR_OK)) {
        if (lpcp != NULL) {
            CapturePaletteFini (lpcs, lpcp);
            GlobalFreePtr (lpcp);
            lpcs->lpCapPal = NULL;
        }
    }

    SetCursor(hOldCursor);
    statusUpdateStatus(lpcs, 0);

    // If an error happened, display it
    if (dwError) {
        errorUpdateError (lpcs, (UINT) dwError);
    }

    return (dwError == DV_ERR_OK);
}



/*--------------------------------------------------------------+
| fileSavePalette - save the current palette in a file  	|
|								|
+--------------------------------------------------------------*/
BOOL FAR PASCAL fileSavePalette(LPCAPSTREAM lpcs, LPTSTR lpszFileName)
{
    HPALETTE            hpal;
    HMMIO               hmmio;
    WORD	        w;
    HCURSOR             hOldCursor;
    MMCKINFO            ckRiff;
    MMCKINFO            ck;
    short               nColors;
    FCLOGPALETTE        pal;
    BOOL                fOK = FALSE;

    if ((hpal = lpcs->hPalCurrent) == NULL)
        return FALSE;

    hmmio = mmioOpen(lpszFileName, NULL, MMIO_WRITE);
    if( !hmmio ) {
	/* try and create */
        hmmio = mmioOpen(lpszFileName, NULL, MMIO_CREATE | MMIO_WRITE);
	if( !hmmio ) {
	    /* find out if the file was read only or we are just */
	    /* totally hosed up here.				 */
	    hmmio = mmioOpen(lpszFileName, NULL, MMIO_READ);
	    if (hmmio){
		/* file was read only, error on it */
                errorUpdateError (lpcs, IDS_CAP_READONLYFILE, (LPTSTR) lpszFileName);
		mmioClose(hmmio, 0);
		return FALSE;
	    } else {
		/* even weirder error has occured here, give CANTOPEN */
                errorUpdateError (lpcs, IDS_CAP_CANTOPEN, (LPTSTR) lpszFileName);
		return FALSE;
	    }
	}
    }

    hOldCursor = SetCursor( lpcs-> hWaitCursor );

    /* Seek to beginning of file, so we can write the header. */
    mmioSeek(hmmio, 0, SEEK_SET);

    /* Create RIFF chunk */
    ckRiff.fccType = mmioFOURCC('P','A','L',' ');
    if(mmioCreateChunk (hmmio,&ckRiff,MMIO_CREATERIFF)) {
         goto FileError;
    }

    /* Create Palette chunk */
    ck.cksize = 0;
    ck.ckid = mmioFOURCC('d','a','t','a');
    if(mmioCreateChunk(hmmio,&ck,0)) {
         goto FileError;
    }

    // Get the palette data here
    GetObject(hpal, sizeof(short), (LPVOID)&nColors);

    pal.palVersion = 0x0300;
    pal.palNumEntries = nColors;

    GetPaletteEntries(hpal, 0, nColors, pal.palPalEntry);

    // Calc the size of the logpalette
    // which is the sizeof palVersion + sizeof palNumEntries + colors
    w = sizeof (WORD) + sizeof (WORD) + nColors * sizeof (PALETTEENTRY);

    // Write out the palette
    if(mmioWrite(hmmio, (LPBYTE)&pal, (DWORD) w) != (LONG) w) {
        goto FileError;
    }

    if(mmioAscend(hmmio, &ck, 0)) {
        goto FileError;
    }

    if(mmioAscend(hmmio, &ckRiff, 0)) {
        goto FileError;
    }

    fOK = TRUE;

FileError:
    mmioClose( hmmio, 0 );

    SetCursor( hOldCursor );

    if (!fOK)
        errorUpdateError (lpcs, IDS_CAP_ERRORPALSAVE, (LPTSTR) lpszFileName);

    return fOK;
}


/*--------------------------------------------------------------+
| fileOpenPalette - use a new palette from the specified file   |
|								|
+--------------------------------------------------------------*/
BOOL FAR PASCAL fileOpenPalette(LPCAPSTREAM lpcs, LPTSTR lpszFileName)
{
    HPALETTE            hpal;
    HMMIO               hmmio;
    WORD	        w;
    HCURSOR             hOldCursor;
    MMCKINFO            ckRiff;
    MMCKINFO            ck;
    FCLOGPALETTE        pal;
    BOOL                fOK = FALSE;

    if ((hpal = lpcs->hPalCurrent) == NULL)
        return FALSE;

    hmmio = mmioOpen(lpszFileName, NULL, MMIO_READ);
    if( !hmmio ) {
        errorUpdateError (lpcs, IDS_CAP_ERRORPALOPEN, (LPTSTR) lpszFileName);
        return FALSE;
    }

    hOldCursor = SetCursor( lpcs-> hWaitCursor );

    /* Seek to beginning of file, so we can read the header. */
    mmioSeek(hmmio, 0, SEEK_SET);

    /* Find the RIFF chunk */
    ckRiff.fccType = mmioFOURCC('P','A','L',' ');
    if(mmioDescend (hmmio, &ckRiff, NULL, MMIO_FINDRIFF)) {
         goto PalOpenError;
    }

    /* Find the data chunk */
    ck.cksize = 0;
    ck.ckid = mmioFOURCC('d','a','t','a');
    if(mmioDescend (hmmio, &ck, &ckRiff, MMIO_FINDCHUNK)) {
         goto PalOpenError;
    }

    // First read just the Version and number of entries
    // which is the sizeof palVersion + sizeof palNumEntries
    w = sizeof (WORD) + sizeof (WORD);
    if(mmioRead(hmmio, (LPBYTE)&pal, (DWORD) w) != (LONG) w) {
        goto PalOpenError;
    }

    // Do a bit of checking
    if ((pal.palVersion != 0x0300) || (pal.palNumEntries > 256))
        goto PalOpenError;

    // Now get the actual palette data
    // which is the sizeof palVersion + sizeof palNumEntries
    w = pal.palNumEntries * sizeof (PALETTEENTRY);
    if(mmioRead(hmmio, (LPBYTE)&pal.palPalEntry, (DWORD) w) != (LONG) w) {
        goto PalOpenError;
    }

    if (hpal = CreatePalette ((LPLOGPALETTE) &pal)) {
        PalSendPaletteToDriver (lpcs, hpal, NULL /*lpXlateTable */);
        fOK = TRUE;
    }

    videoFrame( lpcs->hVideoIn, &lpcs->VidHdr );  // grab a new frame

PalOpenError:
    mmioClose( hmmio, 0 );

    SetCursor( hOldCursor );
    InvalidateRect(lpcs->hwnd, NULL, TRUE);
    UpdateWindow(lpcs->hwnd);		// update the display with new frame

    if (!fOK)
        errorUpdateError (lpcs, IDS_CAP_ERRORPALOPEN, (LPTSTR) lpszFileName);
    else
    lpcs->fUsingDefaultPalette = FALSE;

    return fOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avicap\dibmap.c ===
/****************************************************************************
 *
 *   dibmap.c
 *
 *   Histrogram and optimal palette processing module.
 *
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992, 1993 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and
 *    distribute the Sample Files (and/or any modified version) in
 *    any way you find useful, provided that you agree that
 *    Microsoft has no warranty obligations or liability for any
 *    Sample Application Files which are modified.
 *
 ***************************************************************************/

#include <windows.h>
#include <win32.h>
#include "dibmap.h"

#ifndef _WIN32
extern NEAR PASCAL MemCopy(LPVOID,LPVOID,DWORD);
#endif

extern NEAR PASCAL MemFill(LPVOID,DWORD,BYTE);

void Histogram24(BYTE huge *pb, int dx, int dy, WORD WidthBytes, LPHISTOGRAM lpHistogram);
void Histogram16(BYTE huge *pb, int dx, int dy, WORD WidthBytes, LPHISTOGRAM lpHistogram);
void Histogram8(BYTE huge *pb, int dx, int dy, WORD WidthBytes, LPHISTOGRAM lpHistogram, LPWORD lpColors);
void Histogram4(BYTE huge *pb, int dx, int dy, WORD WidthBytes, LPHISTOGRAM lpHistogram, LPWORD lpColors);
void Histogram1(BYTE huge *pb, int dx, int dy, WORD WidthBytes, LPHISTOGRAM lpHistogram, LPWORD lpColors);

void Reduce24(BYTE huge *pbIn, int dx, int dy, WORD cbIn, BYTE huge *pbOut, WORD cbOut, LPBYTE lp16to8);
void Reduce16(BYTE huge *pbIn, int dx, int dy, WORD cbIn, BYTE huge *pbOut, WORD cbOut, LPBYTE lp16to8);
void Reduce8(BYTE huge *pbIn, int dx, int dy, WORD cbIn, BYTE huge *pbOut, WORD cbOut, LPBYTE lp8to8);
void Reduce4(BYTE huge *pbIn, int dx, int dy, WORD cbIn, BYTE huge *pbOut, WORD cbOut, LPBYTE lp8to8);
void Reduce1(BYTE huge *pbIn, int dx, int dy, WORD cbIn, BYTE huge *pbOut, WORD cbOut, LPBYTE lp8to8);

//
//  InitHistogram
//
//  create a zero'ed histogram table, or initialize a existing table
//  to all zeros.
//
LPHISTOGRAM InitHistogram(LPHISTOGRAM lpHistogram)
{
    if (lpHistogram == NULL)
        lpHistogram = (LPVOID)GlobalAllocPtr(GHND,32768l*sizeof(DWORD));

#if 0
    if (lpHistogram)
        MemFill(lpHistogram, 32768l * sizeof(DWORD), 0);
#endif

    return lpHistogram;
}

//
//  FreeHistogram
//
//  free a histogram table
//
void FreeHistogram(LPHISTOGRAM lpHistogram)
{
    GlobalFreePtr(lpHistogram);
}

//
//  DibHistogram
//
//  take all colors in a dib and increment its entry in the Histogram table
//
//  supports the following DIB formats: 1,4,8,16,24
//
BOOL DibHistogram(LPBITMAPINFOHEADER lpbi, LPBYTE lpBits, int x, int y, int dx, int dy, LPHISTOGRAM lpHistogram)
{
    int             i;
    WORD            WidthBytes;
    RGBQUAD FAR *   prgbq;
    WORD            argb16[256];

    if (lpbi == NULL || lpHistogram == NULL)
        return FALSE;

    if (lpbi->biClrUsed == 0 && lpbi->biBitCount <= 8)
        lpbi->biClrUsed = (1 << (int)lpbi->biBitCount);

    if (lpBits == NULL)
        lpBits = (LPBYTE)lpbi + (int)lpbi->biSize + (int)lpbi->biClrUsed*sizeof(RGBQUAD);

    WidthBytes = (WORD)((lpbi->biBitCount * lpbi->biWidth + 7) / 8 + 3) & ~3;

    ((BYTE huge *)lpBits) += (DWORD)y*WidthBytes + ((x*(int)lpbi->biBitCount)/8);

    if (dx < 0 || dx > (int)lpbi->biWidth)
        dx = (int)lpbi->biWidth;

    if (dy < 0 || dy > (int)lpbi->biHeight)
        dy = (int)lpbi->biHeight;

    if ((int)lpbi->biBitCount <= 8)
    {
        prgbq = (LPVOID)((LPBYTE)lpbi + lpbi->biSize);

        for (i=0; i<(int)lpbi->biClrUsed; i++)
        {
            argb16[i] = RGB16(prgbq[i].rgbRed,prgbq[i].rgbGreen,prgbq[i].rgbBlue);
        }

        for (i=(int)lpbi->biClrUsed; i<256; i++)
        {
            argb16[i] = 0x0000;     // just in case!
        }
    }

    switch ((int)lpbi->biBitCount)
    {
        case 24:
            Histogram24(lpBits, dx, dy, WidthBytes, lpHistogram);
            break;

        case 16:
            Histogram16(lpBits, dx, dy, WidthBytes, lpHistogram);
            break;

        case 8:
            Histogram8(lpBits, dx, dy, WidthBytes, lpHistogram, argb16);
            break;

        case 4:
            Histogram4(lpBits, dx, dy, WidthBytes, lpHistogram, argb16);
            break;

        case 1:
            Histogram1(lpBits, dx, dy, WidthBytes, lpHistogram, argb16);
            break;
    }
}

//
// will convert the given DIB to a 8bit DIB with the specifed palette
//
HANDLE DibReduce(LPBITMAPINFOHEADER lpbiIn, LPBYTE pbIn, HPALETTE hpal, LPBYTE lp16to8)
{
    HANDLE              hdib;
    short               nPalColors;
    int                 nDibColors;
    WORD                cbOut;
    WORD                cbIn;
    BYTE                xlat[256];
    BYTE HUGE *         pbOut;
    RGBQUAD FAR *       prgb;
    DWORD               dwSize;
    int                 i;
    int                 dx;
    int                 dy;
    PALETTEENTRY        pe;
    LPBITMAPINFOHEADER  lpbiOut;

    dx    = (int)lpbiIn->biWidth;
    dy    = (int)lpbiIn->biHeight;
    cbIn  = ((lpbiIn->biBitCount*dx+7)/8+3)&~3;
    cbOut = (dx+3)&~3;

    //
    // careful with GetObject in Win32: this (counter-intuitively) writes
    // a short not an INT for the number of colours
    //
    GetObject(hpal, sizeof(short), (LPVOID)&nPalColors);
    nDibColors = (int)lpbiIn->biClrUsed;

    if (nDibColors == 0 && lpbiIn->biBitCount <= 8)
        nDibColors = (1 << (int)lpbiIn->biBitCount);

    if (pbIn == NULL)
        pbIn = (LPBYTE)lpbiIn + (int)lpbiIn->biSize + nDibColors*sizeof(RGBQUAD);

    dwSize = (DWORD)cbOut * dy;

    hdib = GlobalAlloc(GMEM_MOVEABLE,sizeof(BITMAPINFOHEADER)
        + nPalColors*sizeof(RGBQUAD) + dwSize);

    if (!hdib)
        return NULL;

    lpbiOut = (LPVOID)GlobalLock(hdib);
    lpbiOut->biSize         = sizeof(BITMAPINFOHEADER);
    lpbiOut->biWidth        = lpbiIn->biWidth;
    lpbiOut->biHeight       = lpbiIn->biHeight;
    lpbiOut->biPlanes       = 1;
    lpbiOut->biBitCount     = 8;
    lpbiOut->biCompression  = BI_RGB;
    lpbiOut->biSizeImage    = dwSize;
    lpbiOut->biXPelsPerMeter= 0;
    lpbiOut->biYPelsPerMeter= 0;
    lpbiOut->biClrUsed      = nPalColors;
    lpbiOut->biClrImportant = 0;

    pbOut = (LPBYTE)lpbiOut + (int)lpbiOut->biSize + nPalColors*sizeof(RGBQUAD);
    prgb  = (LPVOID)((LPBYTE)lpbiOut + (int)lpbiOut->biSize);

    for (i=0; i<nPalColors; i++)
    {
        GetPaletteEntries(hpal, i, 1, &pe);

        prgb[i].rgbRed      = pe.peRed;
        prgb[i].rgbGreen    = pe.peGreen;
        prgb[i].rgbBlue     = pe.peBlue;
        prgb[i].rgbReserved = 0;
    }

    if ((int)lpbiIn->biBitCount <= 8)
    {
        prgb = (LPVOID)((LPBYTE)lpbiIn + lpbiIn->biSize);

        for (i=0; i<nDibColors; i++)
            xlat[i] = lp16to8[RGB16(prgb[i].rgbRed,prgb[i].rgbGreen,prgb[i].rgbBlue)];

        for (; i<256; i++)
            xlat[i] = 0;
    }

    switch ((int)lpbiIn->biBitCount)
    {
        case 24:
            Reduce24(pbIn, dx, dy, cbIn, pbOut, cbOut, lp16to8);
            break;

        case 16:
            Reduce16(pbIn, dx, dy, cbIn, pbOut, cbOut, lp16to8);
            break;

        case 8:
            Reduce8(pbIn, dx, dy, cbIn, pbOut, cbOut, xlat);
            break;

        case 4:
            Reduce4(pbIn, dx, dy, cbIn, pbOut, cbOut, xlat);
            break;

        case 1:
            Reduce1(pbIn, dx, dy, cbIn, pbOut, cbOut, xlat);
            break;
    }

    return hdib;
}

///////////////////////////////////////////////////////////////////////////////
//  cluster.c
///////////////////////////////////////////////////////////////////////////////

#define  IN_DEPTH    5               // # bits/component kept from input
#define  IN_SIZE     (1 << IN_DEPTH) // max value of a color component

typedef enum { red, green, blue } color;

typedef struct tagCut {
   int cutpoint;
   color cutaxis;
   } Cut;

typedef struct tagColorBox {    // from cluster.c
   struct tagColorBox *next;                /* pointer to next box */
   int   rmin, rmax, gmin, gmax, bmin, bmax;    /* bounding box */
   long variance, wt;                           /* weighted variance */
   long sum[3];                                 /* sum of values */
   } ColorBox;

static int InitBoxes(int nBoxes);
static void DeleteBoxes(void);
static int SplitBoxAxis(ColorBox *box, Cut cutaxis);
static void ShrinkBox(ColorBox *box);
static int ComputePalette(LPHISTOGRAM lpHistogram, LPBYTE lp16to8, LPPALETTEENTRY palette);
static COLORREF DetermineRepresentative(ColorBox *box, int palIndex);
static Cut FindSplitAxis(ColorBox *box);
static void SplitBox(ColorBox *box);
static void SortBoxes(void);

HANDLE hBoxes;
ColorBox *UsedBoxes;
ColorBox *FreeBoxes;
LPBYTE   glp16to8;

#ifdef _WIN32

/*
 * to avoid all this 16 bit assembler with minimal changes to the
 * rest of the code the Win32 version will use a global pointer set by
 * UseHistogram and accessed by the hist() and IncHistogram macros.
 */
DWORD HUGE* glpHistogram;

#define UseHistogram(p)	(glpHistogram = (p))

#define hist(r,g,b)  ((DWORD HUGE *)glpHistogram)[(WORD)(b) | ((WORD)(g)<<IN_DEPTH) | ((WORD)(r)<<(IN_DEPTH*2))]

#define IncHistogram(w) if (lpHistogram[(WORD)(w)] < 0xFFFFFFFF) {  \
			    lpHistogram[(WORD)(w)]++;\
			}

#else

#define hist(r,g,b)  GetHistogram((BYTE)(r),(BYTE)(g),(BYTE)(b))



#pragma optimize ("", off)
//
//  set FS == lpHistogram.sel, so we can get at it quickly!
//
void NEAR PASCAL UseHistogram(LPHISTOGRAM lpHistogram)
{
    _asm {
        mov     ax,word ptr lpHistogram[2]

        _emit   08Eh                     ; mov  fs,ax
        _emit   0E0h
    }
}



//
//  get the DWORD histogram count of a RGB
//
DWORD NEAR _FASTCALL GetHistogram(BYTE r, BYTE g, BYTE b)
{

    if (0)              // avoid compiler warning NO RETURN VALUE
        return 0;

    _asm {
        ;
        ; on entry al=r, dl=g, bl=b  [0-31]
        ;
        ; map to a RGB16
        ;
        xor     ah,ah
        shl     ax,5
        or      al,dl
        shl     ax,5
        or      al,bl

        ; now ax = RGB16

        _emit 66h _asm xor bx,bx           ; xor ebx,ebx
                  _asm mov bx,ax           ; mov  bx,ax
        _emit 66h _asm shl bx,2            ; shl ebx,2

        _emit 64h _asm _emit 67h           ; mov dx,fs:[ebx][2]
        _emit 8Bh _asm _emit 53h
        _emit 02h

        _emit 64h _asm _emit 67h           ; mov ax,fs:[ebx][0]
        _emit 8Bh _asm _emit 03h
    }
}

//
//  increment the histogram count of a RGB16
//
//
//  #define IncHistogram(w) if (lpHistogram[(WORD)(w)] < 0xFFFFFFFF)
//                              lpHistogram[(WORD)(w)]++;
//
void NEAR _FASTCALL IncHistogram(WORD rgb16)
{
    _asm {
        ;
        ; on entry ax = rgb16
        ;
        _emit 66h _asm xor bx,bx           ; xor ebx,ebx
                  _asm mov bx,ax           ; mov bx,ax
        _emit 66h _asm shl bx,2            ; shl ebx,2

        _emit 64h _asm _emit 67h           ; cmp dword ptr fs:[ebx], -1
        _emit 66h _asm _emit 83h
        _emit 3Bh _asm _emit 0FFh

        _emit 74h _asm _emit 05h           ; je  short @f

        _emit 64h _asm _emit 67h           ; inc dword ptr fs:[ebx]
        _emit 66h _asm _emit 0FFh
        _emit 03h
    }
}

#pragma optimize ("", on)

// !!! C8 generates a Jump into the middle of a 2 byte instruction
// 
#pragma optimize ("", off)

#endif  //_WIN32

//
//  HistogramPalette
//
//  given a histogram, will reduce it to 'nColors' number of colors.
//  returns a optimal palette.  if specifed lp16to8 will contain the
//  translate table from RGB16 to the palette index.
//
//  you can specify lpHistogram as lp16to8
//
HPALETTE HistogramPalette(LPHISTOGRAM lpHistogram, LPBYTE lp16to8, int nColors)
{
    WORD     w;
    DWORD    dwMax;
    COLORREF rgb;
    ColorBox *box;
    int i;
    // Had to make this global to prevent VB 2.0 stack explosion
    static struct {
        WORD         palVersion;
        WORD         palNumEntries;
        PALETTEENTRY palPalEntry[256];
    }   pal;

    //
    //  the 'C' code cant handle >64k histogram counts.
    //  !!!fix this
    //
    for (dwMax=0,w=0; w<0x8000; w++)
        dwMax = max(dwMax,lpHistogram[w]);

    while (dwMax > 0xFFFFl)
    {
        for (w=0; w<0x8000; w++)
            lpHistogram[w] /= 2;

        dwMax /= 2;
    }

    if (!InitBoxes(min(nColors, 236)))
        return NULL;

    UseHistogram(lpHistogram);
    glp16to8 = lp16to8;

    /* while there are free boxes left, split the largest */

    i = 0;

    do {
       i++;
       SplitBox(UsedBoxes);
       }
    while (FreeBoxes && UsedBoxes->variance);

    SortBoxes();

    i=0;

    //
    // add some standard colors to the histogram
    //
    if (nColors > 236)
    {
        HDC hdc;
	HPALETTE hpal;

        hdc = GetDC(NULL);

        if (GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE)
        {
        GetSystemPaletteEntries(hdc, 0,   10, &pal.palPalEntry[0]);
        GetSystemPaletteEntries(hdc, 246, 10, &pal.palPalEntry[246]);

        i = 10;
        } else {	// we're a true colour device, so get the system
			// colours from the default palette.
	    hpal = GetStockObject(DEFAULT_PALETTE);
            GetPaletteEntries(hpal, 0, 10, &pal.palPalEntry[0]);
            GetPaletteEntries(hpal, 10, 10, &pal.palPalEntry[246]);
            i = 10;
	}

        ReleaseDC(NULL, hdc);
    }

    // probably not needed on C-only versions (NT).
    UseHistogram(lpHistogram); // Register FS trashed by above!


    /* Generate the representitives and the associated Palette mapping */
    /* NOTE:  Might loop less than nColors times.                      */
    for (box = UsedBoxes; box; box = box->next, i++)
    {
        rgb = DetermineRepresentative(box, i);
        pal.palPalEntry[i].peRed   = GetRValue(rgb);
        pal.palPalEntry[i].peGreen = GetGValue(rgb);
        pal.palPalEntry[i].peBlue  = GetBValue(rgb);
        pal.palPalEntry[i].peFlags = 0;
    }

    DeleteBoxes();

    if (nColors > 236)
    {
        for (; i<246; i++)
        {
            pal.palPalEntry[i].peRed   = 0;
            pal.palPalEntry[i].peGreen = 0;
            pal.palPalEntry[i].peBlue  = 0;
            pal.palPalEntry[i].peFlags = 0;
        }

        i = 256;
    }

    glp16to8 = NULL;

    pal.palVersion    = 0x300;
    pal.palNumEntries = i;
    return CreatePalette((LPLOGPALETTE)&pal);
}

#pragma optimize ("", on)

static void SortBoxes()
{
    ColorBox *box;
    ColorBox *newList;
    ColorBox *insBox;
    ColorBox *nextBox;

    newList = UsedBoxes;
    nextBox = newList->next;
    newList->next = NULL;

    for (box = nextBox; box; box = nextBox) { // just an insertion sort...
            nextBox = box->next;
            if (box->wt > newList->wt) {
                    box->next = newList;
                    newList = box;
            } else {
                    for (insBox = newList;
                            insBox->next && (box->wt < insBox->next->wt);
                            insBox = insBox->next) ;
                    box->next = insBox->next;
                    insBox->next = box;
            }
    }

    UsedBoxes = newList;
}


/*
   allocate space for nBoxes boxes, set up links.  On exit UsedBoxes
   points to one box, FreeBoxes points to remaining (nBoxes-1) boxes.
   return 0 if successful.
*/

static BOOL InitBoxes(int nBoxes)
{
    int i;

    hBoxes = LocalAlloc(LHND, nBoxes*sizeof(ColorBox));
    if (!hBoxes)
        return FALSE;

    UsedBoxes = (ColorBox*)LocalLock(hBoxes);
    FreeBoxes = UsedBoxes + 1;
    UsedBoxes->next = NULL;

    for (i = 0; i < nBoxes - 1; ++i)
    {
        FreeBoxes[i].next = FreeBoxes + i + 1;
    }
    FreeBoxes[nBoxes-2].next = NULL;

    /* save the bounding box */
    UsedBoxes->rmin = UsedBoxes->gmin = UsedBoxes->bmin = 0;
    UsedBoxes->rmax = UsedBoxes->gmax = UsedBoxes->bmax = IN_SIZE - 1;
    UsedBoxes->variance = 9999999;    /* arbitrary large # */

    return TRUE;
}

static void DeleteBoxes()
{
   LocalUnlock(hBoxes);
   LocalFree(hBoxes);
   hBoxes = NULL;
}

static void SplitBox(ColorBox *box)
{
   /*
      split box into two roughly equal halves and update the data structures
      appropriately.
   */
   Cut cutaxis;
   ColorBox *temp, *temp2, *prev;

   cutaxis = FindSplitAxis(box);

   /* split the box along that axis.  If rc != 0 then the box contains
      one color, and should not be split */
   if (SplitBoxAxis(box, cutaxis))
      return;

   /* shrink each of the boxes to fit the points they enclose */
   ShrinkBox(box);
   ShrinkBox(FreeBoxes);

   /* move old box down in list, if necessary */
   if (box->next && box->variance < box->next->variance)
   {
      UsedBoxes = box->next;
      temp = box;
      do {
         prev = temp;
         temp = temp->next;
         } while (temp && temp->variance > box->variance);
      box->next = temp;
      prev->next = box;
   }

   /* insert the new box in sorted order (descending), removing it
      from the free list. */
   if (FreeBoxes->variance >= UsedBoxes->variance)
   {
      temp = FreeBoxes;
      FreeBoxes = FreeBoxes->next;
      temp->next = UsedBoxes;
      UsedBoxes = temp;
   }
   else
   {
      temp = UsedBoxes;
      do {
         prev = temp;
         temp = temp->next;
         } while (temp && temp->variance > FreeBoxes->variance);
      temp2 = FreeBoxes->next;
      FreeBoxes->next = temp;
      prev->next = FreeBoxes;
      FreeBoxes = temp2;
   }
}

static Cut FindSplitAxis(ColorBox *box)
{
        unsigned long   proj_r[IN_SIZE],proj_g[IN_SIZE],proj_b[IN_SIZE];
        unsigned long   f;
        double          currentMax,mean;
        unsigned long   w,w1,m,m1;
        short           r,g,b;
        short           bestCut;
        color           bestAxis;
        Cut             cutRet;
        double          temp1,temp2;

        for (r = 0; r < IN_SIZE; r++) {
                proj_r[r] = proj_g[r] = proj_b[r] = 0;
        }

        w = 0;

        // Project contents of box down onto axes
        for (r = box->rmin; r <= box->rmax; r++) {
                for (g = box->gmin; g <= box->gmax; ++g) {
                        for (b = box->bmin; b <= box->bmax; ++b) {
                                f = hist(r,g,b);
                                proj_r[r] += f;
                                proj_g[g] += f;
                                proj_b[b] += f;
                        }
                }
                w += proj_r[r];
        }

        currentMax = 0.0f;

#define Check_Axis(l,color)                                     \
        m = 0;                                                  \
        for (l = box->l##min; l <= box->l##max; (l)++) {        \
                m += l * proj_##l[l];                           \
        }                                                       \
        mean = ((double) m) / ((double) w);                     \
                                                                \
        w1 = 0;                                                 \
        m1 = 0;                                                 \
        for (l = box->l##min; l <= box->l##max; l++) {          \
                w1 += proj_##l[l];                              \
                if (w1 == 0)                                    \
                        continue;                               \
                if (w1 == w)                                    \
                        break;                                  \
                m1 += l * proj_##l[l];                          \
                temp1 = mean - (((double) m1) / ((double) w1)); \
                temp2 = (((double) w1) / ((double) (w-w1))) * temp1 * temp1; \
                if (temp2 > currentMax) {                       \
                        bestCut = l;                            \
                        bestAxis = color;                       \
                        currentMax = temp2;                     \
                }                                               \
        }

        Check_Axis(r,red);
        Check_Axis(g,green);
        Check_Axis(b,blue);

        cutRet.cutaxis = bestAxis;
        cutRet.cutpoint = bestCut;


        return cutRet;
}

static int SplitBoxAxis(ColorBox *box, Cut cutaxis)
{
   /*
      Split box along splitaxis into two boxes, one of which is placed
      back in box, the other going in the first free box (FreeBoxes)
      If the box only contains one color, return non-zero, else return 0.
   */
   ColorBox *next;

   if ( box->variance == 0)
      return 1;

   /* copy all non-link information to new box */
   next = FreeBoxes->next;
   *FreeBoxes = *box;
   FreeBoxes->next = next;

   switch (cutaxis.cutaxis)
   {
      case red:
         box->rmax = cutaxis.cutpoint;
         FreeBoxes->rmin = cutaxis.cutpoint+1;
         break;
      case green:
         box->gmax = cutaxis.cutpoint;
         FreeBoxes->gmin = cutaxis.cutpoint+1;
         break;
      case blue:
         box->bmax = cutaxis.cutpoint;
         FreeBoxes->bmin = cutaxis.cutpoint+1;
         break;
   }

   return 0;
}

static void ShrinkBox(ColorBox *box)
{
        unsigned long n, sxx, sx2, var, quotient, remainder;
        int r,g,b;
        unsigned long   f;
        unsigned long   proj_r[IN_SIZE],proj_g[IN_SIZE],proj_b[IN_SIZE];

        n = 0;

        for (r = 0; r < IN_SIZE; r++) {
                proj_r[r] = proj_g[r] = proj_b[r] = 0;
        }

        // Project contents of box down onto axes
        for (r = box->rmin; r <= box->rmax; r++) {
                for (g = box->gmin; g <= box->gmax; ++g) {
                        for (b = box->bmin; b <= box->bmax; ++b) {
                                f = hist(r,g,b);
                                proj_r[r] += f;
                                proj_g[g] += f;
                                proj_b[b] += f;
                        }
                }
                n += proj_r[r];
        }

        box->wt = n;
        var = 0;

#define AddAxisVariance(c)                                              \
        sxx = 0; sx2 = 0;                                               \
        for (c = box->c##min; c <= box->c##max; c++) {                  \
                sxx += proj_##c[c] * c * c;                             \
                sx2 += proj_##c[c] * c;                                 \
        }                                                               \
        quotient = sx2 / n; /* This stuff avoids overflow */            \
        remainder = sx2 % n;                                            \
        var += sxx - quotient * sx2 - ((remainder * sx2)/n);

        AddAxisVariance(r);
        AddAxisVariance(g);
        AddAxisVariance(b);

        box->variance = var;
}

static COLORREF DetermineRepresentative(ColorBox *box, int palIndex)
{
   /*
      determines the rgb value to represent the pixels contained in
      box.  nbits is the # bits/component we're allowed to return.
   */
   long f;
   long Rval, Gval, Bval;
   unsigned long total;
   int r, g, b;
   WORD w;

   /* compute the weighted sum of the elements in the box */
   Rval = Gval = Bval = total = 0;
   for (r = box->rmin; r <= box->rmax; ++r)
   {
      for (g = box->gmin; g <= box->gmax; ++g)
      {
         for (b = box->bmin; b <= box->bmax; ++b)
         {
            if (glp16to8)
            {
                w = (WORD)(b) | ((WORD)(g)<<IN_DEPTH) | ((WORD)(r)<<(IN_DEPTH*2));
                glp16to8[w] = (BYTE)palIndex;
            }

            f = hist(r,g,b);
            if (f == 0L)
               continue;

            Rval += f * (long) r;
            Gval += f * (long) g;
            Bval += f * (long) b;

            total += f;
         }
      }
   }

   /* Bias the sum so that we round up at .5 */
   Rval += total / 2;
   Gval += total / 2;
   Bval += total / 2;

   return RGB(Rval*255/total/IN_SIZE, Gval*255/total/IN_SIZE, Bval*255/total/IN_SIZE);
}

///////////////////////////////////////////////////////////////////////////////
//
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
//
//  write this stuff in ASM!
//
///////////////////////////////////////////////////////////////////////////////

void Histogram24(BYTE HUGE *pb, int dx, int dy, WORD WidthBytes, LPHISTOGRAM lpHistogram)
{
    int x,y;
    BYTE r,g,b;
    WORD w;

    UseHistogram(lpHistogram);

    WidthBytes -= dx*3;

    for (y=0; y<dy; y++)
    {
        for (x=0; x<dx; x++)
        {
            b = *pb++;
            g = *pb++;
            r = *pb++;
            w = RGB16(r,g,b);
            IncHistogram(w);
        }
        pb += WidthBytes;
    }
}

void Histogram16(BYTE HUGE *pb, int dx, int dy, WORD WidthBytes, LPHISTOGRAM lpHistogram)
{
    int x,y;
    WORD w;

    UseHistogram(lpHistogram);

    WidthBytes -= dx*2;

    for (y=0; y<dy; y++)
    {
        for (x=0; x<dx; x++)
        {
            w = *((WORD HUGE *)pb)++;
            w &= 0x7FFF;
            IncHistogram(w);
        }
        pb += WidthBytes;
    }
}

void Histogram8(BYTE HUGE *pb, int dx, int dy, WORD WidthBytes, LPHISTOGRAM lpHistogram, LPWORD lpColors)
{
    int x,y;
    WORD w;

    UseHistogram(lpHistogram);

    WidthBytes -= dx;

    for (y=0; y<dy; y++)
    {
        for (x=0; x<dx; x++)
        {
            w = lpColors[*pb++];
            IncHistogram(w);
        }
        pb += WidthBytes;
    }
}

void Histogram4(BYTE HUGE *pb, int dx, int dy, WORD WidthBytes, LPHISTOGRAM lpHistogram, LPWORD lpColors)
{
    int x,y;
    BYTE b;
    WORD w;

    UseHistogram(lpHistogram);

    WidthBytes -= (dx+1)/2;

    for (y=0; y<dy; y++)
    {
        for (x=0; x<(dx+1)/2; x++)
        {
            b = *pb++;

            w = lpColors[b>>4];
            IncHistogram(w);

            w = lpColors[b&0x0F];
            IncHistogram(w);
        }
        pb += WidthBytes;
    }
}

void Histogram1(BYTE HUGE *pb, int dx, int dy, WORD WidthBytes, LPHISTOGRAM lpHistogram, LPWORD lpColors)
{
    int x,y,i;
    BYTE b;
    WORD w;

    UseHistogram(lpHistogram);

    WidthBytes -= (dx+7)/8;

    for (y=0; y<dy; y++)
    {
        for (x=0; x<(dx+7)/8; x++)
        {
            b = *pb++;

            for (i=0; i<8; i++)
            {
                w = lpColors[b>>7];
                IncHistogram(w);
                b<<=1;
            }
        }
        pb += WidthBytes;
    }
}

///////////////////////////////////////////////////////////////////////////////
//
//  write this stuff in ASM! too
//  -- if you do - please leave the C version #ifdef _WIN32
//
///////////////////////////////////////////////////////////////////////////////

void Reduce24(BYTE HUGE *pbIn, int dx, int dy, WORD cbIn, BYTE HUGE *pbOut, WORD cbOut, LPBYTE lp16to8)
{
    int x,y;
    BYTE r,g,b;

    cbOut -= dx;
    cbIn  -= dx*3;

    for (y=0; y<dy; y++)
    {
        for (x=0; x<dx; x++)
        {
            b = *pbIn++;
            g = *pbIn++;
            r = *pbIn++;
            *pbOut++ = lp16to8[RGB16(r,g,b)];
        }
        pbIn += cbIn;
        pbOut+= cbOut;
    }
}

void Reduce16(BYTE huge *pbIn, int dx, int dy, WORD cbIn, BYTE huge *pbOut, WORD cbOut, LPBYTE lp16to8)
{
    int x,y;
    WORD w;

    cbOut -= dx;
    cbIn  -= dx*2;

    for (y=0; y<dy; y++)
    {
        for (x=0; x<dx; x++)
        {
            w = *((WORD HUGE *)pbIn)++;
            *pbOut++ = lp16to8[w&0x7FFF];
        }
        pbIn += cbIn;
        pbOut+= cbOut;
    }
}

void Reduce8(BYTE HUGE *pbIn, int dx, int dy, WORD cbIn, BYTE HUGE *pbOut, WORD cbOut, LPBYTE lp8to8)
{
    int x,y;

    cbIn  -= dx;
    cbOut -= dx;

    for (y=0; y<dy; y++)
    {
        for (x=0; x<dx; x++)
        {
            *pbOut++ = lp8to8[*pbIn++];
        }
        pbIn  += cbIn;
        pbOut += cbOut;
    }
}

void Reduce4(BYTE HUGE *pbIn, int dx, int dy, WORD cbIn, BYTE HUGE *pbOut, WORD cbOut, LPBYTE lp8to8)
{
    int x,y;
    BYTE b;

    cbIn  -= (dx+1)/2;
    cbOut -= (dx+1)&~1;

    for (y=0; y<dy; y++)
    {
        for (x=0; x<(dx+1)/2; x++)
        {
            b = *pbIn++;
            *pbOut++ = lp8to8[b>>4];
            *pbOut++ = lp8to8[b&0x0F];
        }
        pbIn  += cbIn;
        pbOut += cbOut;
    }
}

void Reduce1(BYTE HUGE *pbIn, int dx, int dy, WORD cbIn, BYTE HUGE *pbOut, WORD cbOut, LPBYTE lp8to8)
{
    int x,y;
    BYTE b;

    cbIn  -= (dx+7)/8;
    cbOut -= dx;

    for (y=0; y<dy; y++)
    {
        for (x=0; x<dx; x++)
        {
            if (x%8 == 0)
                b = *pbIn++;

            *pbOut++ = lp8to8[b>>7];
            b<<=1;
        }
        pbIn  += cbIn;
        pbOut += cbOut;
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avicap\iaverage.c ===
/*
 *
 * iaverage.c   Image averaging
 *
 * (C) Copyright Microsoft Corporation 1993. All rights reserved.
 *
 */

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <win32.h>
#include <memory.h>
#include <stdlib.h>
#include <ctype.h>
#include <memory.h>
#include <string.h>
#include <msvideo.h>

#include "ivideo32.h"
#include "iaverage.h"

#define WIDTHBYTES(i)     ((unsigned)((i+31)&(~31))/8)  /* ULONG aligned ! */
#define DIBWIDTHBYTES(bi) (int)WIDTHBYTES((int)(bi).biWidth * (int)(bi).biBitCount)
#define RGB16(r,g,b)      ((((WORD)(r) >> 3) << 10) | \
                          (((WORD)(g) >> 3) << 5)  | \
                          (((WORD)(b) >> 3) ) )

typedef BYTE HUGE  *   HPBYTE;
typedef WORD HUGE  *   HPWORD;
typedef DWORD HUGE *   HPDWORD;

#ifdef _WIN32
typedef RGBQUAD FAR * LPRGBQUAD;
#endif

#ifdef _WIN32
#define _fmemcpy	memcpy
#endif

/* Description:
        A sequence of images are averaged together using 16 bit
        accumulators for each of the Red, Green, and Blue components.
        The final processing step is to divide the accumulated values
        by the number of frames averaged, and transfer the results back
        into the destination DIB.

        Certain death will result if the image format is changed between
        iaverageInit and iaverageFini calls.
*/

//
// table to map a 5bit index (0-31) to a 8 bit value (0-255)
//
static BYTE aw5to8[32] = {(BYTE)-1};



/*
 *  iaverageInit
 *      Allocate memory for subsequent image averaging
 *      Return FALSE on error
 *
 */
BOOL iaverageInit (LPIAVERAGE FAR * lppia, LPBITMAPINFO lpbi, HPALETTE hPal)
{
    DWORD       dwSizeImage;
    LPIAVERAGE  lpia;
    int         i;

    *lppia = NULL;

    // Check for legal DIB formats
    if (lpbi->bmiHeader.biCompression != BI_RGB)
        return FALSE;

    if (lpbi->bmiHeader.biBitCount != 8 &&
        lpbi->bmiHeader.biBitCount != 16 &&
        lpbi->bmiHeader.biBitCount != 24 &&
        lpbi->bmiHeader.biBitCount != 32)
        return FALSE;

    //
    // init the 5bit to 8bit conversion table.
    //
    if (aw5to8[0] != 0)
        for (i=0; i<32; i++)
            aw5to8[i] = (BYTE)(i * 255 / 31);

    // Alloc memory for the image average structure
    lpia = (LPIAVERAGE) GlobalAllocPtr(GHND, sizeof (IAVERAGE));

    if (!lpia)
        return FALSE;

    // Save a copy of the header
    lpia->bi.bmiHeader = lpbi->bmiHeader;

    // and a copy of the color table and an inverse mapping table
    // if the image is 8 bit
    if (lpbi->bmiHeader.biBitCount == 8) {
        WORD r, g, b;
        LPBYTE lpB;

        hmemcpy (lpia->bi.bmiColors,
                        lpbi->bmiColors,
                        lpbi->bmiHeader.biClrUsed * sizeof (RGBQUAD));

        // Allocate and init the inverse LUT
        lpia->lpInverseMap= (LPBYTE) GlobalAllocPtr(GHND, 1024L * 32);
        lpB = lpia-> lpInverseMap;
        for (r = 0; r < 256; r += 8)
            for (g = 0; g < 256; g += 8)
                for (b = 0; b < 256; b += 8)
                    *lpB++ = (BYTE) GetNearestPaletteIndex (hPal, RGB(r,g,b));

    }

    dwSizeImage = lpbi->bmiHeader.biSizeImage;

    lpia->lpRGB = (LPWORD) GlobalAllocPtr(GHND,
					dwSizeImage * sizeof (WORD) * 3);

    if (lpia->lpRGB == 0) {
        // Allocation failed, clean up
        iaverageFini (lpia);
        return FALSE;
    }

    *lppia = lpia;

    return TRUE;
}


/*
 *  iaverageFini
 *      Free memory used for image averaging
 *      and the iaverage structure itself
 *
 */
BOOL iaverageFini (LPIAVERAGE lpia)
{
    if (lpia == NULL)
        return FALSE;

    if (lpia->lpInverseMap)
        GlobalFreePtr(lpia->lpInverseMap);
    if (lpia->lpRGB)
        GlobalFreePtr(lpia->lpRGB);

    GlobalFreePtr(lpia);

    return TRUE;
}


/*
 *  iaverageZero
 *      Zeros the accumulator
 *
 */
BOOL iaverageZero (LPIAVERAGE lpia)
{
    DWORD   dwC;
    HPWORD  hpW;

    if (lpia == NULL)
        return FALSE;

    hpW = (HPWORD) lpia->lpRGB;
    dwC = lpia->bi.bmiHeader.biSizeImage * 3;
    while (--dwC)
        *hpW++ = 0;

    lpia-> iCount = 0;

    return TRUE;
}

/*
 *  iaverageSum
 *      Add the current image into the accumulator
 *      Image format must be 16 or 24 bit RGB
 */
BOOL iaverageSum (LPIAVERAGE lpia, LPVOID lpBits)
{
    HPWORD      hpRGB;
    DWORD       dwC;
    WORD        wRGB16;
    HPWORD      hpW;
    HPBYTE      hpB;
    WORD        w;

    if (lpia == NULL)
        return FALSE;

    hpRGB   = (HPWORD) lpia->lpRGB;

    if (lpia->bi.bmiHeader.biBitCount == 8) {
        hpB = (HPBYTE) lpBits;
        for (dwC = lpia->bi.bmiHeader.biSizeImage; --dwC; ) {
            w = (WORD) *hpB++;
            *hpRGB++   += lpia->bi.bmiColors[w].rgbBlue;
            *hpRGB++   += lpia->bi.bmiColors[w].rgbGreen;
            *hpRGB++   += lpia->bi.bmiColors[w].rgbRed;
        }
    }

    else if (lpia->bi.bmiHeader.biBitCount == 16) {
        hpW = (HPWORD) lpBits;
        for (dwC = lpia->bi.bmiHeader.biSizeImage / 2; --dwC; ) {
            wRGB16 = *hpW++;

            *hpRGB++  += aw5to8 [wRGB16         & 0x1f]; // b
            *hpRGB++  += aw5to8 [(wRGB16 >> 5)  & 0x1f]; // g
            *hpRGB++  += aw5to8 [(wRGB16 >> 10) & 0x1f]; // r

        }
    }

    else if (lpia->bi.bmiHeader.biBitCount == 24) {
        hpB = (HPBYTE) lpBits;
        for (dwC = lpia->bi.bmiHeader.biSizeImage; --dwC; ) {
            *hpRGB++  += *hpB++;
        }
    }

    else if (lpia->bi.bmiHeader.biBitCount == 32) {
        hpB = (HPBYTE) lpBits;
        for (dwC = lpia->bi.bmiHeader.biSizeImage / 4; --dwC; ) {
            *hpRGB++  += *hpB++; // b
            *hpRGB++  += *hpB++; // g
            *hpRGB++  += *hpB++; // r
            hpB++;
        }
    }

    lpia-> iCount++;            // Image counter

    return TRUE;
}

/*
 *  iaverageDivide
 *      Divide by the number of images captured, and xfer back into the
 *      destination DIB.
 *
 */
BOOL iaverageDivide (LPIAVERAGE lpia, LPVOID lpBits)
{
    HPWORD      hpRGB;
    WORD        r, g, b, w;
    DWORD       dwC;
    HPWORD      hpW;
    HPBYTE      hpB;

    if (lpia == NULL || lpia-> iCount == 0)
        return FALSE;

    hpRGB   = (HPWORD) lpia->lpRGB;

    if (lpia->bi.bmiHeader.biBitCount == 8) {
        hpB = (HPBYTE) lpBits;
        for (dwC = lpia->bi.bmiHeader.biSizeImage; --dwC; ) {
            b = *hpRGB++ / lpia-> iCount;
            g = *hpRGB++ / lpia-> iCount;
            r = *hpRGB++ / lpia-> iCount;

            w = RGB16(r,g,b) & 0x7FFF;
            *hpB++ = * (lpia->lpInverseMap + w);

        }
    }

    else if (lpia->bi.bmiHeader.biBitCount == 16) {
        hpW = (HPWORD) lpBits;
        for (dwC = lpia->bi.bmiHeader.biSizeImage / 2; --dwC; ) {
            b = *hpRGB++ / lpia-> iCount;
            g = *hpRGB++ / lpia-> iCount;
            r = *hpRGB++ / lpia-> iCount;

            *hpW++ = RGB16 (r, g, b);
        }
    }

    else if (lpia->bi.bmiHeader.biBitCount == 24) {
        hpB = (HPBYTE) lpBits;
        for (dwC = lpia->bi.bmiHeader.biSizeImage; --dwC; ) {
            *hpB++ = (BYTE) (*hpRGB++  / lpia-> iCount);
        }
    }

    else if (lpia->bi.bmiHeader.biBitCount == 32) {
        hpB = (HPBYTE) lpBits;
        for (dwC = lpia->bi.bmiHeader.biSizeImage / 4; --dwC; ) {
            *hpB++ = (BYTE) (*hpRGB++ / lpia-> iCount); // b
            *hpB++ = (BYTE) (*hpRGB++ / lpia-> iCount); // g
            *hpB++ = (BYTE) (*hpRGB++ / lpia-> iCount); // r
            hpB++;
        }
    }

    return TRUE;
}

// The following appropriated from Toddla's CDIB

/*****************************************************************************
 *
 *  SumRGB
 *
 *****************************************************************************/

#define SumRGB16(b0,b1,b2,b3) (\
             ((((WORD)pal.palPalEntry[b0].peRed +         \
                (WORD)pal.palPalEntry[b1].peRed +         \
                (WORD)pal.palPalEntry[b2].peRed +         \
                (WORD)pal.palPalEntry[b3].peRed)          \
                & 0x03E) << 5) |                          \
                                                          \
             ((((WORD)pal.palPalEntry[b0].peGreen +       \
                (WORD)pal.palPalEntry[b1].peGreen +       \
                (WORD)pal.palPalEntry[b2].peGreen +       \
                (WORD)pal.palPalEntry[b3].peGreen)        \
                & 0x003E)) |                              \
                                                          \
             ((((WORD)pal.palPalEntry[b0].peBlue +        \
                (WORD)pal.palPalEntry[b1].peBlue +        \
                (WORD)pal.palPalEntry[b2].peBlue +        \
                (WORD)pal.palPalEntry[b3].peBlue)         \
                & 0x003E) >> 5) )

/*****************************************************************************
 *
 *  RGB16
 *
 *****************************************************************************/

typedef struct { BYTE b,g,r; } RGB24;

#define rgb16(r,g,b) (\
            ((UINT)(r) << 10) |  \
            ((UINT)(g) << 5)  |  \
            ((UINT)(b) << 0)  )

#define RGB16R(rgb)     aw5to8[((UINT)(rgb) >> 10) & 0x1F]
#define RGB16G(rgb)     aw5to8[((UINT)(rgb) >> 5)  & 0x1F]
#define RGB16B(rgb)     aw5to8[((UINT)(rgb) >> 0)  & 0x1F]
#define RGB16r(rgb)     ((BYTE)((UINT)(rgb) >> 10) & 0x1F)
#define RGB16g(rgb)     ((BYTE)((UINT)(rgb) >> 5)  & 0x1F)
#define RGB16b(rgb)     ((BYTE)((UINT)(rgb) >> 0)  & 0x1F)

/*****************************************************************************
 *
 *  Pel() used for 24bit Crunch
 *
 *****************************************************************************/

#define Pel(p,x) (BYTE)(BitCount == 1 ? Pel1(p,x) : \
                        BitCount == 4 ? Pel4(p,x) : Pel8(p,x))

#define Pel1(p,x)   (BYTE)bit(((HPBYTE)(p))[(x)/8],7-((x)%8))
#define Pel4(p,x)   (BYTE)((x & 1) ? (((HPBYTE)(p))[(x)/2] & 15) : (((HPBYTE)(p))[(x)/2] >> 4))
#define Pel8(p,x)   (BYTE)(((HPBYTE)(p))[(x)])
#define Pel16(p,x)  (((HPWORD)(p))[(x)])
#define Pel24(p,x)  (((RGB24 HUGE *)(p))[(x)])

/*****************************************************************************
 *
 *  CrunchDIB  - shrink a DIB down by 2 with color averaging
 *
 *     this routine works on 8, 16, 24, and 32 bpp DIBs
 *
 *     this routine can't be used "in place"
 *
 *****************************************************************************/

BOOL CrunchDIB(
    LPIAVERAGE lpia,                // image averaging structure
    LPBITMAPINFOHEADER  lpbiSrc,    // BITMAPINFO of source
    LPVOID              lpSrc,      // input bits to crunch
    LPBITMAPINFOHEADER  lpbiDst,    // BITMAPINFO of dest
    LPVOID              lpDst)      // output bits to crunch
{
    HPBYTE      pbSrc;
    HPBYTE      pbDst;
    HPBYTE      pb;
    HPWORD      pw;
    BYTE        r,g,b,b0,b1,b2,b3;
    WORD        w0,w1,w2,w3;
    RGB24       rgb0,rgb1,rgb2,rgb3;
    int         WidthBytesSrc;
    int         WidthBytesDst;
    UINT        x;
    UINT        y;
    UINT        dx;
    UINT        dy;
    int         i;
    COLORREF    rgb;
    int         BitCount;
    UINT        aw5to8[32];

     struct {
        WORD         palVersion;
	WORD         palNumEntries;
	PALETTEENTRY palPalEntry[256];
    }   pal;

   if (lpbiSrc->biCompression != BI_RGB)
        return FALSE;

    BitCount = (int)lpbiSrc->biBitCount;

    if (BitCount == 16)
        for (i=0; i<32; i++)
            aw5to8[i] = (UINT)i * 255u / 31u;

    dx = (int)lpbiDst->biWidth;
    WidthBytesDst = (((UINT)lpbiDst->biBitCount * dx + 31)&~31) / 8;

    dy = (int)lpbiSrc->biHeight;
    dx = (int)lpbiSrc->biWidth;
    WidthBytesSrc = (((UINT)lpbiSrc->biBitCount * dx + 31)&~31) / 8;

    dx &= ~1;
    dy &= ~1;

    pbSrc = lpSrc;
    pbDst = lpDst;

    if (lpbiSrc->biClrUsed == 0 && lpbiSrc->biBitCount <= 8)
        lpbiSrc->biClrUsed = (1 << (int)lpbiSrc->biBitCount);

    pal.palVersion = 0x300;
    pal.palNumEntries = (int)lpbiSrc->biClrUsed;

    for (i=0; i<(int)pal.palNumEntries; i++)
    {
        pal.palPalEntry[i].peRed   = ((LPRGBQUAD)(lpbiSrc+1))[i].rgbRed;
        pal.palPalEntry[i].peGreen = ((LPRGBQUAD)(lpbiSrc+1))[i].rgbGreen;
        pal.palPalEntry[i].peBlue  = ((LPRGBQUAD)(lpbiSrc+1))[i].rgbBlue;
        pal.palPalEntry[i].peFlags = 0;
    }

    if (lpbiDst->biBitCount == 8)
        _fmemcpy(lpbiDst+1,lpbiSrc+1,(int)lpbiSrc->biClrUsed*sizeof(RGBQUAD));

    if ((int)lpbiDst->biBitCount == (int)lpbiSrc->biBitCount)
    {
        switch((int)lpbiSrc->biBitCount)
        {
        case 8:
            for (y=0; y<dy; y+=2)
            {
                pb = pbDst;

                for (x=0; x<dx; x+=2)
                {
                    b0 = Pel8(pbSrc,x);
                    b1 = Pel8(pbSrc+WidthBytesSrc, x);
                    b2 = Pel8(pbSrc,x+1);
                    b3 = Pel8(pbSrc+WidthBytesSrc,x+1);

                    r = (BYTE) ((
                        (WORD)pal.palPalEntry[b0].peRed +
                        (WORD)pal.palPalEntry[b1].peRed +
                        (WORD)pal.palPalEntry[b2].peRed +
                        (WORD)pal.palPalEntry[b3].peRed) >> 2);

                    g = (BYTE) ((
                        (WORD)pal.palPalEntry[b0].peGreen +
                        (WORD)pal.palPalEntry[b1].peGreen +
                        (WORD)pal.palPalEntry[b2].peGreen +
                        (WORD)pal.palPalEntry[b3].peGreen) >> 2);

                    b = (BYTE) ((
                        (WORD)pal.palPalEntry[b0].peBlue +
                        (WORD)pal.palPalEntry[b1].peBlue +
                        (WORD)pal.palPalEntry[b2].peBlue +
                        (WORD)pal.palPalEntry[b3].peBlue) >> 2);

                    *pb++ = (BYTE)(*(lpia->lpInverseMap +
                                RGB16 (r, g, b)));
                }

                pbSrc += WidthBytesSrc*2;
                pbDst += WidthBytesDst;
            }
            break;

        case 16:
            for (y=0; y<dy; y+=2)
            {
                pw = (HPWORD)pbDst;

		for (x=0; x<dx; x += 2)
                {
                    w0 = Pel16(pbSrc,x);
                    w1 = Pel16(pbSrc,x+1);
                    w2 = Pel16(pbSrc+WidthBytesSrc,x);
                    w3 = Pel16(pbSrc+WidthBytesSrc,x+1);

                    r = ((BYTE)RGB16r(w0) + RGB16r(w1) + RGB16r(w2) + RGB16r(w3)) >> 2;
                    g = ((BYTE)RGB16g(w0) + RGB16g(w1) + RGB16g(w2) + RGB16g(w3)) >> 2;
                    b = ((BYTE)RGB16b(w0) + RGB16b(w1) + RGB16b(w2) + RGB16b(w3)) >> 2;

                    *pw++ = rgb16(r,g,b);
                }

                pbSrc += WidthBytesSrc*2;
                pbDst += WidthBytesDst;
            }
            break;

        case 24:
            for (y=0; y<dy; y+=2)
            {
                pb = pbDst;

		for (x=0; x<dx; x += 2)
                {
                    rgb0 = Pel24(pbSrc,x);
                    rgb1 = Pel24(pbSrc,x+1);
                    rgb2 = Pel24(pbSrc+WidthBytesSrc,x);
                    rgb3 = Pel24(pbSrc+WidthBytesSrc,x+1);

                    rgb = RGB(
                        ((UINT)rgb0.r + rgb1.r + rgb2.r + rgb3.r)/4,
                        ((UINT)rgb0.g + rgb1.g + rgb2.g + rgb3.g)/4,
                        ((UINT)rgb0.b + rgb1.b + rgb2.b + rgb3.b)/4);

                    *pb++ = GetBValue(rgb);
                    *pb++ = GetGValue(rgb);
                    *pb++ = GetRValue(rgb);
                }

                pbSrc += WidthBytesSrc*2;
                pbDst += WidthBytesDst;
            }
            break;

        case 32:
            for (y=0; y<dy; y+=2)
            {
                pb = pbDst;

		for (x=0; x<dx; x += 2)
                {
                    rgb0 = Pel24(pbSrc,x);
                    rgb1 = Pel24(pbSrc,x+1);
                    rgb2 = Pel24(pbSrc+WidthBytesSrc,x);
                    rgb3 = Pel24(pbSrc+WidthBytesSrc,x+1);

                    rgb = RGB(
                        ((UINT)rgb0.r + rgb1.r + rgb2.r + rgb3.r)/4,
                        ((UINT)rgb0.g + rgb1.g + rgb2.g + rgb3.g)/4,
                        ((UINT)rgb0.b + rgb1.b + rgb2.b + rgb3.b)/4);

                    *pb++ = GetBValue(rgb);
                    *pb++ = GetGValue(rgb);
                    *pb++ = GetRValue(rgb);
                    pb++;
                }

                pbSrc += WidthBytesSrc*2;
                pbDst += WidthBytesDst;
            }
            break;

        default:
            return FALSE;
        }
    }
    else
    {
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avicap\memcopy.asm ===
?PLM=1	    ; PASCAL Calling convention is DEFAULT
?WIN=0      ; Windows calling convention
PMODE=1

.xlist
include cmacros.inc
include windows.inc
.list

	externA	    __WinFlags	    ; in KERNEL
	externA	    __AHINCR	    ; in KERNEL
	externA	    __AHSHIFT	    ; in KERNEL

; The following structure should be used to access high and low
; words of a DWORD.  This means that "word ptr foo[2]" -> "foo.hi".

LONG	struc
lo	dw	?
hi	dw	?
LONG	ends

FARPOINTER	struc
off	dw	?
sel	dw	?
FARPOINTER	ends

; -------------------------------------------------------
;		DATA SEGMENT DECLARATIONS
; -------------------------------------------------------

ifndef SEGNAME
    SEGNAME equ <_TEXT>
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE

sBegin Data
sEnd Data

sBegin CodeSeg
        assumes cs,CodeSeg
        assumes ds,DATA

;---------------------------Public-Routine------------------------------;
; MemCopy
;
;   copy memory
;
; Entry:
;	lpSrc	HPSTR to copy from
;	lpDst	HPSTR to copy to
;	cbMem	DWORD count of bytes to move
;
; Returns:
;	destination pointer
; Error Returns:
;	None
; Registers Preserved:
;	BP,DS,SI,DI
; Registers Destroyed:
;	AX,BX,CX,DX,FLAGS
; Calls:
;	nothing
;-----------------------------------------------------------------------;

cProc MemCopy,<NEAR,PASCAL,PUBLIC>,<ds>
	ParmD	lpDst
	ParmD	lpSrc
	ParmD	cbMem
cBegin
	.386
	push	edi
	push	esi
	cld

	mov	ecx,cbMem
	jecxz	mc386_exit

	movzx	edi,di
	movzx	esi,si
	lds	si,lpSrc
        les     di,lpDst

        mov     ebx,ecx
	shr	ecx,2		; get count in DWORDs
	rep	movs dword ptr es:[edi], dword ptr ds:[esi]
        mov     ecx,ebx
	and	ecx,3
	rep	movs byte ptr es:[edi], byte ptr ds:[esi]

mc386_exit:
	cld
	pop	esi
	pop	edi
	.286
cEnd

sEnd CodeSeg
end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avicap\libentry.asm ===
PAGE,132
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;       LIBENTRY.ASM
;
;       Windows dynamic link library entry routine
;
;   This module generates a code segment called INIT_TEXT.
;   It initializes the local heap if one exists and then calls
;   the C routine LibMain() which should have the form:
;   BOOL FAR PASCAL LibMain(HANDLE hInstance,
;                           WORD   wDataSeg,
;                           WORD   cbHeap,
;                           DWORD  ignore);     /* Always NULL - ignore */
;        
;   The result of the call to LibMain is returned to Windows.
;   The C routine should return TRUE if it completes initialization
;   successfully, FALSE if some error occurs.
;
;   Note - The last parameter to LibMain is included for compatibility
;   reasons.  Applications that wish to modify this file and remove the
;   parameter from LibMain may do so by simply removing the two
;   "push" instructions below marked with "****".
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

include cmacros.inc

externFP <LibMain>               ; the C routine to be called

createSeg INIT_TEXT, INIT_TEXT, BYTE, PUBLIC, CODE
sBegin	INIT_TEXT
assumes CS,INIT_TEXT

?PLM=0                           ; 'C'naming
externA  <_acrtused>             ; ensures that Win DLL startup code is linked

?PLM=1                           ; 'PASCAL' naming
externFP <LocalInit>             ; Windows heap init routine

cProc   LibEntry, <PUBLIC,FAR>   ; entry point into DLL

include CONVDLL.INC

cBegin
        push    di               ; handle of the module instance
        push    ds               ; library data segment
        push    cx               ; heap size
        push    es               ; Always NULL  ****  May remove (see above)
        push    si               ; Always NULL  ****  May remove (see above)

        ; if we have some heap then initialize it
        jcxz    callc            ; jump if no heap specified

        ; call the Windows function LocalInit() to set up the heap
        ; LocalInit((LPSTR)start, WORD cbHeap);
        
        xor     ax,ax
        cCall   LocalInit <ds, ax, cx>
        or      ax,ax            ; did it do it ok ?
        jz      error            ; quit if it failed

        ; invoke the C routine to do any special initialization

callc:
        call    LibMain          ; invoke the 'C' routine (result in AX)
        jmp short exit           ; LibMain is responsible for stack clean up

error:
	pop	si		 ; clean up stack on a LocalInit error
        pop     es               
        pop     cx               
        pop     ds
        pop     di

exit:

cEnd

sEnd	INIT_TEXT

end LibEntry

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avicap\ivideo32.h ===
/****************************************************************************/
/*                                                                          */
/*  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY   */
/*  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE     */
/*  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR   */
/*  PURPOSE.								    */
/*        MSVIDEO.H - Include file for Video APIs                           */
/*                                                                          */
/*        Note: You must include WINDOWS.H before including this file.      */
/*                                                                          */
/*        Copyright (c) 1990-1993, Microsoft Corp.  All rights reserved.    */
/*                                                                          */
/****************************************************************************/

#ifndef _INC_IVIDEO32
#define _INC_IVIDEO32   50      /* version number */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#include <msvideo.h>

#define LOADDS
#define EXPORT

#if defined(_WIN32) && defined(UNICODE)
// unicode conversions

int Iwcstombs(LPSTR lpstr, LPCWSTR lpwstr, int len);
int Imbstowcs(LPWSTR lpwstr, LPCSTR lpstr, int len);

#endif

//#ifndef _RCINVOKED
///* video data types */
//DECLARE_HANDLE(HVIDEO);                 // generic handle
//typedef HVIDEO FAR * LPHVIDEO;
//#endif                                  // ifndef RCINVOKED

/****************************************************************************

                        video APIs

****************************************************************************/

#if defined _WIN32

#if defined DAYTONA
void videoInitHandleList(void);
void videoDeleteHandleList(void);
#endif

#if defined CHICAGO

  typedef struct _thk_videohdr {
      VIDEOHDR vh;
      LPBYTE   p32Buff;
      DWORD    p16Alloc;
      DWORD    dwMemHandle;
      DWORD    dwReserved;
  } THKVIDEOHDR, FAR *LPTHKVIDEOHDR;

  WORD FAR PASCAL _loadds capxGetDriverDescription (WORD wDriverIndex,
        LPSTR lpszName, WORD cbName,
        LPSTR lpszVer, WORD cbVer);

  DWORD WINAPI vidxAllocHeaders(
      HVIDEO          hVideo,
      UINT            nHeaders,
      LPTHKVIDEOHDR * lpHdrs);

  DWORD WINAPI vidxFreeHeaders(
      HVIDEO hv);

  DWORD WINAPI vidxAllocBuffer (
      HVIDEO          hv,
      UINT            iHdr,
      LPTHKVIDEOHDR * pp32Hdr,
      DWORD           dwSize);

  DWORD vidxFreeBuffer (
      HVIDEO hv,
      DWORD  p32Hdr);

  DWORD WINAPI vidxSetRect (
      HVIDEO hv,
      UINT wMsg,
      int left,
      int top,
      int right,
      int bottom);

  DWORD WINAPI vidxFrame (
      HVIDEO     hVideo,
      LPVIDEOHDR lpVHdr);

  #define videoSetRect(h,msg,rc) vidxSetRect (h, msg, rc.left, rc.top, rc.right, rc.bottom)

  DWORD WINAPI vidxAddBuffer (
      HVIDEO     hVideo,
      LPVIDEOHDR lpVHdr,
      DWORD      cbData);

  DWORD WINAPI vidxAllocPreviewBuffer (
      HVIDEO     hVideo,
      LPVOID     *lpBits,
      DWORD      cbData);

  DWORD WINAPI vidxFreePreviewBuffer (
      HVIDEO     hVideo,
      LPVOID     lpBits);

  DWORD WINAPI videoOpen  (LPHVIDEO lphVideo,
              DWORD dwDevice, DWORD dwFlags);
  DWORD WINAPI videoClose (HVIDEO hVideo);
  DWORD WINAPI videoDialog(HVIDEO hVideo, HWND hWndParent, DWORD dwFlags);
  DWORD WINAPI videoGetChannelCaps(HVIDEO hVideo, LPCHANNEL_CAPS lpChannelCaps,
              DWORD dwSize);
  DWORD WINAPI videoUpdate (HVIDEO hVideo, HWND hWnd, HDC hDC);
  DWORD WINAPI videoConfigure (HVIDEO hVideo, UINT msg, DWORD dwFlags,
              LPDWORD lpdwReturn, LPVOID lpData1, DWORD dwSize1,
              LPVOID lpData2, DWORD dwSize2);

  DWORD WINAPI videoFrame(HVIDEO hVideo, LPVIDEOHDR lpVHdr);
  DWORD WINAPI videoGetErrorText(HVIDEO hVideo, UINT wError,
              LPSTR lpText, UINT wSize);
  DWORD WINAPI videoStreamInit(HVIDEO hVideo,
              DWORD dwMicroSecPerFrame, DWORD dwCallback,
              DWORD dwCallbackInst, DWORD dwFlags);
  DWORD WINAPI videoStreamFini(HVIDEO hVideo);

  //DWORD WINAPI videoStreamPrepareHeader(HVIDEO hVideo,
  //            LPVIDEOHDR lpVHdr, DWORD dwSize);
  //DWORD WINAPI videoStreamAddBuffer(HVIDEO hVideo,
  //            LPVIDEOHDR lpVHdr, DWORD dwSize);
  DWORD WINAPI videoStreamReset(HVIDEO hVideo);
  DWORD WINAPI videoStreamStart(HVIDEO hVideo);
  DWORD WINAPI videoStreamStop(HVIDEO hVideo);
  DWORD WINAPI videoStreamUnprepareHeader(HVIDEO hVideo,
              LPVIDEOHDR lpVHdr, DWORD dwSize);


#else
 #define videoSetRect(h,msg,rc) videoMessage (h, msg, (DWORD)(LPVOID)&rc, VIDEO_CONFIGURE_SET)

DWORD WINAPI videoGetNumDevs(void);

DWORD WINAPI videoOpen  (LPHVIDEO lphVideo,
              DWORD dwDevice, DWORD dwFlags);
DWORD WINAPI videoClose (HVIDEO hVideo);
DWORD WINAPI videoDialog(HVIDEO hVideo, HWND hWndParent, DWORD dwFlags);
DWORD WINAPI videoGetChannelCaps(HVIDEO hVideo, LPCHANNEL_CAPS lpChannelCaps,
                DWORD dwSize);
DWORD WINAPI videoUpdate (HVIDEO hVideo, HWND hWnd, HDC hDC);
DWORD WINAPI videoConfigure (HVIDEO hVideo, UINT msg, DWORD dwFlags,
		LPDWORD lpdwReturn, LPVOID lpData1, DWORD dwSize1,
                LPVOID lpData2, DWORD dwSize2);

DWORD WINAPI videoConfigureStorage (HVIDEO hVideo,
                      LPTSTR lpstrIdent, DWORD dwFlags);

DWORD WINAPI videoFrame(HVIDEO hVideo, LPVIDEOHDR lpVHdr);
DWORD WINAPI videoMessage(HVIDEO hVideo, UINT msg, DWORD dwP1, DWORD dwP2);

/* streaming APIs */
DWORD WINAPI videoStreamAddBuffer(HVIDEO hVideo,
              LPVIDEOHDR lpVHdr, DWORD dwSize);
DWORD WINAPI videoStreamGetError(HVIDEO hVideo, LPDWORD lpdwErrorFirst,
        LPDWORD lpdwErrorLast);

DWORD WINAPI videoGetErrorTextA(HVIDEO hVideo, UINT wError,
              LPSTR lpText, UINT wSize);
DWORD WINAPI videoGetErrorTextW(HVIDEO hVideo, UINT wError,
              LPWSTR lpText, UINT wSize);

#ifdef UNICODE
  #define videoGetErrorText  videoGetErrorTextW
#else
  #define videoGetErrorText  videoGetErrorTextA
#endif // !UNICODE

DWORD WINAPI videoStreamGetPosition(HVIDEO hVideo, MMTIME FAR* lpInfo,
              DWORD dwSize);
DWORD WINAPI videoStreamInit(HVIDEO hVideo,
              DWORD dwMicroSecPerFrame, DWORD dwCallback,
              DWORD dwCallbackInst, DWORD dwFlags);
DWORD WINAPI videoStreamFini(HVIDEO hVideo);
DWORD WINAPI videoStreamPrepareHeader(HVIDEO hVideo,
              LPVIDEOHDR lpVHdr, DWORD dwSize);
DWORD WINAPI videoStreamReset(HVIDEO hVideo);
DWORD WINAPI videoStreamStart(HVIDEO hVideo);
DWORD WINAPI videoStreamStop(HVIDEO hVideo);
DWORD WINAPI videoStreamUnprepareHeader(HVIDEO hVideo,
              LPVIDEOHDR lpVHdr, DWORD dwSize);

// Added for Win95 & NT PPC
//
DWORD WINAPI videoStreamAllocBuffer(HVIDEO hVideo,
              LPVOID FAR * plpBuffer, DWORD dwSize);
DWORD WINAPI videoStreamFreeBuffer(HVIDEO hVideo,
              LPVOID lpBuffer);
#endif // CHICAGO
#endif // _WIN32

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif  /* _INC_MSVIDEO */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avicap\mmdebug.h ===
/*
 * johnkn's debug logging and assert macros
 *
 */

#if !defined _INC_MMDEBUG_
#define _INC_MMDEBUG_
//
// prototypes for debug functions.
//
#if !defined(_WIN32) && !defined(LPTSTR)
    #define LPTSTR LPSTR
#endif

    #define SQUAWKNUMZ(num) #num
    #define SQUAWKNUM(num) SQUAWKNUMZ(num)
    #define SQUAWK __FILE__ "(" SQUAWKNUM(__LINE__) ") ----"
    #define DEBUGLINE __FILE__ "(" SQUAWKNUM(__LINE__) ") "

    #if defined DEBUG || defined _DEBUG || defined DEBUG_RETAIL

        int  FAR _cdecl AuxDebugEx(int, LPSTR, ...);
        VOID WINAPI AuxDebugDump (int, LPVOID, int);
        int  WINAPI DebugSetOutputLevel (int);

       #if defined DEBUG_RETAIL
        #define INLINE_BREAK
       #else
        #ifdef _X86_
         #define INLINE_BREAK _asm {int 3}
        #else
         #define INLINE_BREAK DebugBreak()
        #endif
       #endif

       #if 0
        #undef  assert
        #define assert(exp) \
            (void)((exp) ? 0 : AuxDebugEx(-2, DEBUGLINE "assert failed: " #exp "\r\n", (int)__LINE__))

        #undef  assert2
        #define assert2(exp,sz) \
            (void)((exp) ? 0 : AuxDebugEx(-2, DEBUGLINE "assert failed: " sz "\r\n", (int)__LINE__))
       #else
        #undef  assert
        #define assert(exp); {\
            if (!(exp)) {\
                AuxDebugEx(-2, DEBUGLINE "assert failed: " #exp "\r\n", (int)__LINE__); \
                INLINE_BREAK;\
                }\
            }
        #undef  assert2
        #define assert2(exp,sz); {\
            if (!(exp)) {\
                AuxDebugEx(-2, DEBUGLINE "assert failed: " sz "\r\n", (int)__LINE__); \
                INLINE_BREAK;\
                }\
            }
        #undef  assert3
        #define assert3(exp,sz,arg); {\
            if (!(exp)) {\
                AuxDebugEx(-2, DEBUGLINE "assert failed: " sz "\r\n", (int)__LINE__, (arg)); \
                INLINE_BREAK;\
                }\
            }
       #endif

     #ifndef STATICFN
      #define STATICFN
     #endif

    #else // defined(DEBUG)

      #define AuxDebugEx  1 ? (void)0 : (void)
      #define AuxDebugDump(a,b,c)

      #define assert(a)      ((void)0)
      #define assert2(a,b)   ((void)0)
      #define assert3(a,b,c) ((void)0)

      #define INLINE_BREAK
      #define DebugSetOutputLevel(i)
     #ifndef STATICFN
      #define STATICFN static
     #endif

   #endif // defined(DEBUG)

   #define AuxDebug(sz) AuxDebugEx (1, DEBUGLINE sz "\r\n")
   #define AuxDebug2(sz,a) AuxDebugEx (1, DEBUGLINE sz "\r\n", (a))

#endif //_INC_MMDEBUG_

// =============================================================================

//
// include this in only one module in a DLL or APP
//
#if defined DEBUG || defined _DEBUG || defined DEBUG_RETAIL
    #if (defined _INC_MMDEBUG_CODE_) && (_INC_MMDEBUG_CODE_ != FALSE)
    #undef _INC_MMDEBUG_CODE_
    #define _INC_MMDEBUG_CODE_ FALSE

    #include <stdarg.h>

    #if !defined _WIN32 && !defined wvsprintfA
     #define wvsprintfA wvsprintf
    #endif

    int    debug_OutputOn = 0;

    /*+ AuxDebug - create a formatted string and output to debug terminal
     *
     *-=================================================================*/

    int FAR _cdecl AuxDebugEx (
       int    iLevel,
       LPSTR lpFormat,
       ...)
       {
      #ifdef _WIN32
       char     szBuf[1024];
      #else
       static char  szBuf[512];
      #endif
       int      cb;
       va_list  va;
       char FAR * psz;

       if (debug_OutputOn >= iLevel)
          {
          va_start (va, lpFormat);
          cb = wvsprintfA (szBuf, lpFormat, va);
          va_end (va);

          // eat leading ..\..\ which we get from __FILE__ since
          // george's wierd generic makefile stuff.
          //
          psz = szBuf;
          while (psz[0] == '.' && psz[1] == '.' && psz[2] == '\\')
             psz += 3;

          #ifdef MODULE_DEBUG_PREFIX
           if (psz != szBuf)
              OutputDebugStringA (MODULE_DEBUG_PREFIX);
          #endif

          OutputDebugStringA (psz);
          }

       return cb;
       }

    /*+ AuxDebugDump -
     *
     *-=================================================================*/

    VOID WINAPI AuxDebugDump (
       int    iLevel,
       LPVOID lpvData,
       int    nCount)
       {
       LPBYTE   lpData = lpvData;
       char     szBuf[128];
       LPSTR    psz;
       int      cb;
       int      ix;
       BYTE     abRow[8];

       if (debug_OutputOn <= iLevel || nCount <= 0)
          return;

       do {
          cb = wsprintfA(szBuf, "\t%08X: ", lpData);
          psz = szBuf + cb;

          for (ix = 0; ix < 8; ++ix)
             {
             LPBYTE lpb = lpData;

             abRow[ix] = '.';
             if (IsBadReadPtr (lpData + ix, 1))
                lstrcpyA (psz, ".. ");
             else
                {
                wsprintfA (psz, "%02X ", lpData[ix]);
                if (lpData[ix] >= 32 && lpData[ix] < 127)
                    abRow[ix] = lpData[ix];
                }
             psz += 3;
             }
          for (ix = 0; ix < 8; ++ix)
             *psz++ = abRow[ix];

          lstrcpyA (psz, "\r\n");

          OutputDebugStringA (szBuf);

          } while (lpData += 8, (nCount -= 8) > 0);

       return;
       }

    /*+ DebugSetOutputLevel
     *
     *-=================================================================*/

    BOOL  WINAPI DebugSetOutputLevel (
        int nLevel)
        {
        int nOldLevel = debug_OutputOn;
        debug_OutputOn = nLevel;
        return nOldLevel;
        }

    #endif // _INC_MMDEBUG_CODE_
#endif // DEBUG || _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avicap\iaverage.h ===
/****************************************************************************
 *
 *   iaverage.h
 *
 *   Image averaging
 *
 *   Copyright (c) 1992-1994 Microsoft Corporation.  All Rights Reserved.
 *
 ***************************************************************************/

#ifndef _INC_AVERAGE
#define _INC_AVERAGE

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif  /* RC_INVOKED */

#ifndef RC_INVOKED

// -------------------------
//  Structures
// -------------------------

typedef struct tagiAverage {
    BITMAPINFO      bi;                 // Copy of source format
    RGBQUAD         pe[256];            // Copy of color table
    LPBYTE          lpInverseMap;       // rgb15 to palette index
    LPWORD          lpRGB;              // accumulator
    WORD            iCount;             // Count of images accumulated
} IAVERAGE, *PIAVERAGE, FAR *LPIAVERAGE;

BOOL iaverageInit   (LPIAVERAGE FAR * lppia, LPBITMAPINFO lpbi, HPALETTE hPal);
BOOL iaverageFini   (LPIAVERAGE lpia);
BOOL iaverageZero   (LPIAVERAGE lpia);
BOOL iaverageSum    (LPIAVERAGE lpia, LPVOID lpBits);
BOOL iaverageDivide (LPIAVERAGE lpia, LPVOID lpBits);
BOOL CrunchDIB(
    LPIAVERAGE lpia,
    LPBITMAPINFOHEADER  lpbiSrc,    // BITMAPINFO of source
    LPVOID              lpSrc,      // input bits to crunch
    LPBITMAPINFOHEADER  lpbiDst,    // BITMAPINFO of dest
    LPVOID              lpDst);     // output bits to crunch

#endif  /* RC_INVOKED */


#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif    /* __cplusplus */

#endif /* INC_AVERAGE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avicap\mmtimers.h ===
/* + mmtimers.h
 *
 * Accurate timers using pentium cpu clock, QueryPerformanceCounter
 * or GetTickCount depending on what system the code is run on
 *
 * Copyright (C) 1995, Microsoft Corporation, all rights reserved
 *
 *-========================================================================*/
 
#if !defined _INC_MMTIMERS_
#define _INC_MMTIMERS_

  typedef struct {
    DWORD dwlo;
    DWORD dwhi;
    } PCTIMER, NEAR * PPCTIMER;

  struct _pctimer_global {
    DWORD    dwRawHz;
    DWORD    dwMicroAdjust;
    union {
      DWORD    dwRawKhz;
      WORD     wRawKhz;
    };
    union {
      DWORD    dwRawMhz;
      WORD     wRawMhz;
    };
    DWORD    dwTimerKhz;
    PCTIMER  base;
    DWORD (WINAPI * DifTicks     )(PCTIMER *);
    DWORD (WINAPI * DifMicrosec  )(PCTIMER *);
    DWORD (WINAPI * DifMillisec  )(PCTIMER *);
    DWORD (WINAPI * DeltaTicks   )(PCTIMER *);
    DWORD (WINAPI * DeltaMicrosec)(PCTIMER *);
    DWORD (WINAPI * DeltaMillisec)(PCTIMER *);
    UINT     uTimerType;
    };
  extern struct _pctimer_global pc;

  extern VOID WINAPI InitPerformanceCounters ();

  #define pcBegin()          pc.DeltaTicks(&pc.base)
  #define pcGetTime()        pc.DifMillisec(&pc.base)
  #define pcGetTicks()       pc.DifMicrosec(&pc.base)
  #define pcGetTickRate()   (pc.dwTimerKhz * 1000)
  #define pcBeginTimer(ppt) (pc.DeltaMicrosec(ppt), 0)
  #define pcDeltaTicks(ppt)  pc.DeltaMicrosec(ppt)

#endif //_INC_MMTIMERS_

// =============================================================================

//
// include this in only one module in a DLL or APP
//   
#if (defined _INC_MMTIMERS_CODE_) && (_INC_MMTIMERS_CODE_ != FALSE)
#undef _INC_MMTIMERS_CODE_
#define _INC_MMTIMERS_CODE_ FALSE

  static DWORD WINAPI tgtDeltaTime (PCTIMER *pctimer)
  {
        DWORD dwTime = timeGetTime();
        DWORD dwDelta = dwTime - pctimer->dwlo;
        pctimer->dwlo = dwTime;
        return dwDelta;
  }

  static DWORD WINAPI tgtDiffTime (PCTIMER *pctimer)
  {
        return timeGetTime() - pctimer->dwlo;
  }

  struct _pctimer_global pc = {1000, 0, 1, 0, 1,
                               0, 0,
                               (LPVOID)tgtDiffTime,
                               (LPVOID)tgtDiffTime,
                               (LPVOID)tgtDiffTime,
                               (LPVOID)tgtDeltaTime,
                               (LPVOID)tgtDeltaTime,
                               (LPVOID)tgtDeltaTime,
                               0,
                               };

  #if defined WIN32 || defined _WIN32

    #if !defined _X86_
      #define Scale(value,scalar) (DWORD)((value).QuadPart / (scalar))
    #else
      //
      // c9 wants to do LARGE_INTEGER division by calling a library
      // routine. We get a link error for projects that are not
      // already using the C-runtime, so to avoid that, we do the division
      // using x86 assembler
      //
      #pragma warning(disable:4704)
      #pragma warning(disable:4035)
      DWORD _inline Scale(
          LARGE_INTEGER value,
          DWORD         scalar)
      {
          _asm {
            mov  ecx, scalar
            mov  eax, value.LowPart
            mov  edx, value.HighPart
            jecxz bail
            cmp  edx, ecx
            jb ok_to_divide
            push eax
            mov  eax, edx
            xor  edx, edx
            div  ecx
            pop  eax
          ok_to_divide:
            div  ecx
          bail:
          }
      }
    #endif

    static VOID WINAPI qpcInitTimer (PCTIMER * pbase)
    {
       QueryPerformanceCounter ((LPVOID)pbase);
    }

    static DWORD WINAPI qpcDiffTicks (PCTIMER * pbase)
    {
       LARGE_INTEGER *plarge = (LPVOID)pbase;
       LARGE_INTEGER ticks;

       QueryPerformanceCounter (&ticks);
       ticks.QuadPart -= plarge->QuadPart;
       return ticks.LowPart;
    }

    static DWORD WINAPI qpcDiffMicrosec (PCTIMER * pbase)
    {
       LARGE_INTEGER *plarge = (LPVOID)pbase;
       LARGE_INTEGER ticks;

       QueryPerformanceCounter (&ticks);
       ticks.QuadPart -= plarge->QuadPart;
       ticks.LowPart = Scale(ticks, pc.dwRawMhz);
       if (pc.dwMicroAdjust)
           return MulDiv (ticks.LowPart, 1000000, pc.dwMicroAdjust);
       return ticks.LowPart;
    }

    static DWORD WINAPI qpcDiffMillisec (PCTIMER * pbase)
    {
       LARGE_INTEGER *plarge = (LPVOID)pbase;
       LARGE_INTEGER ticks;

       QueryPerformanceCounter (&ticks);
       ticks.QuadPart -= plarge->QuadPart;
       return Scale(ticks, pc.dwRawKhz);
    }

    static DWORD WINAPI qpcDeltaTicks (PCTIMER * pbase)
    {
       LARGE_INTEGER *plarge = (LPVOID)pbase;
       LARGE_INTEGER ticks = *plarge;

       QueryPerformanceCounter (plarge);
       ticks.QuadPart = plarge->QuadPart - ticks.QuadPart;
       return ticks.LowPart;
    }

    static DWORD WINAPI qpcDeltaMicrosec (PCTIMER * pbase)
    {
       LARGE_INTEGER *plarge = (LPVOID)pbase;
       LARGE_INTEGER ticks = *plarge;

       QueryPerformanceCounter (plarge);
       ticks.QuadPart = plarge->QuadPart - ticks.QuadPart;
       ticks.LowPart = Scale(ticks, pc.dwRawMhz);
       if (pc.dwMicroAdjust)
           return MulDiv (ticks.LowPart, 1000000, pc.dwMicroAdjust);
       return ticks.LowPart;
    }

    static DWORD WINAPI qpcDeltaMillisec (PCTIMER * pbase)
    {
       LARGE_INTEGER *plarge = (LPVOID)pbase;
       LARGE_INTEGER ticks = *plarge;

       QueryPerformanceCounter (plarge);
       ticks.QuadPart = plarge->QuadPart - ticks.QuadPart;
       return Scale(ticks, pc.dwRawKhz);
    }

    static DWORD WINAPI qpcTimerFreq ()
    {
       LARGE_INTEGER freq;
       if (QueryPerformanceFrequency (&freq))
          return freq.LowPart;
       return 0;
    }

    #ifdef _X86_

      #pragma warning(disable:4704)
      #pragma warning(disable:4035)

      static VOID WINAPI p5InitTimer (PCTIMER * pBase)
      {
         _asm {
            _emit 0x0f
            _emit 0x31

            mov ebx, pBase
            mov [ebx], eax
            mov [ebx+4], edx
         }
      }

      static DWORD WINAPI p5DiffTicks (PCTIMER * pBase)
      {
         _asm {
            _emit 0x0f
            _emit 0x31

            mov ebx, pBase
            sub eax, [ebx]
            sbb edx, [ebx+4]
         }
      }

      static DWORD WINAPI p5DiffMicrosec (PCTIMER * pBase)
      {
         _asm {
            _emit 0x0f
            _emit 0x31

            mov ebx, pBase
            sub eax, [ebx]
            sbb edx, [ebx+4]

            mov  ecx, pc.dwRawMhz
            jecxz bail
            cmp  edx, ecx
            jb ok_to_divide
            push eax
            mov  eax, edx
            xor  edx, edx
            div  ecx
            pop  eax
          ok_to_divide:
            div  ecx
          bail:
         }
      }

      static DWORD WINAPI p5DiffMillisec (PCTIMER * pBase)
      {
         _asm {
            _emit 0x0f
            _emit 0x31

            mov ebx, pBase
            sub eax, [ebx]
            sbb edx, [ebx+4]

            mov  ecx, pc.dwRawKhz
            jecxz bail
            cmp  edx, ecx
            jb ok_to_divide
            push eax
            mov  eax, edx
            xor  edx, edx
            div  ecx
            pop  eax
          ok_to_divide:
            div  ecx
          bail:
         }
      }

      static DWORD WINAPI p5DeltaTicks (PCTIMER * pBase)
      {
         _asm {
            _emit 0x0f
            _emit 0x31

            mov  ebx, pBase
            mov  ecx, eax
            sub  eax, [ebx]
            mov  [ebx], ecx
            mov  ecx, edx
            sbb  edx, [ebx+4]
            mov  [ebx+4], ecx
         }
      }
      static DWORD WINAPI p5DeltaMicrosec (PCTIMER * pBase)
      {
         _asm {
            _emit 0x0f
            _emit 0x31

            mov  ebx, pBase
            mov  ecx, eax
            sub  eax, [ebx]
            mov  [ebx], ecx
            mov  ecx, edx
            sbb  edx, [ebx+4]
            mov  [ebx+4], ecx

            mov  ecx, pc.dwRawMhz
            jecxz bail
            cmp  edx, ecx
            jb ok_to_divide
            push eax
            mov  eax, edx
            xor  edx, edx
            div  ecx
            pop  eax
          ok_to_divide:
            div  ecx
          bail:
         }
      }

      static DWORD WINAPI p5DeltaMillisec (PCTIMER * pBase)
      {
         _asm {
            _emit 0x0f
            _emit 0x31

            mov  ebx, pBase
            mov  ecx, eax
            sub  eax, [ebx]
            mov  [ebx], ecx
            mov  ecx, edx
            sbb  edx, [ebx+4]
            mov  [ebx+4], ecx

            mov  ecx, pc.dwRawKhz
            jecxz bail
            cmp  edx, ecx
            jb ok_to_divide
            push eax
            mov  eax, edx
            xor  edx, edx
            div  ecx
            pop  eax
          ok_to_divide:
            div  ecx
          bail:
         }
      }

      static DWORD WINAPI p5TimerFreq ()
      {
          SYSTEM_INFO si;

          GetSystemInfo(&si);
          if (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL &&
              si.wProcessorLevel == 5
             )
          {
             PCTIMER timer;
             LARGE_INTEGER qpc1, qpc2;
             DWORD   dwTime;
             DWORD   dwTicks;
             OSVERSIONINFO osv;
             #define MS_INTERVAL 500

             // pentium timers dont work correctly on NT so
             // dont use them
             //
             {
             osv.dwOSVersionInfoSize = sizeof(osv);
             GetVersionEx (&osv);
             }

             // dont use pentium timers if they take more
             // than about 12 microsec to execute
             //
             p5InitTimer  (&timer);
             if (p5DeltaTicks (&timer) > (60 * 12) &&
                 p5DeltaTicks (&timer) > (60 * 12))
             {
                // pentium timers are too slow to try and use them.
                // just go with QueryPerformanceCounter instead
                //
                return 0;
             }

             // for some reason, if you use timeBeginPeriod
             // on NT.  it decides that my 90mhz pentium is an 88mhz
             // pentium.
             //
             //if (osv.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
             //   timeBeginPeriod (1);

             p5InitTimer (&timer);
             QueryPerformanceCounter (&qpc1);
             Sleep(MS_INTERVAL);
             QueryPerformanceCounter (&qpc2);
             dwTicks = p5DiffTicks(&timer);

             //if (osv.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
             //   timeEndPeriod (1);

             dwTime = (DWORD)(qpc2.QuadPart - qpc1.QuadPart);
             QueryPerformanceFrequency (&qpc1);
             dwTime = MulDiv(dwTime, 1000, qpc1.LowPart);

             if (dwTime < MS_INTERVAL * 9 / 10)
                return 0;

             pc.dwRawMhz = (dwTicks + dwTime * 1000/2) /dwTime /1000;
             pc.dwRawKhz = pc.dwRawMhz * 1000;
             pc.dwRawHz  = pc.dwRawKhz * 1000;
             pc.dwMicroAdjust = 0;
             pc.dwTimerKhz = 1000;

             return pc.dwRawHz;
          }

          return 0;
      }

    #endif

    VOID WINAPI InitPerformanceCounters (void)
    {
        DWORD dwFreq;

       #ifdef _X86_
        if (p5TimerFreq())
        {
            pc.DifTicks      = p5DiffTicks;
            pc.DifMicrosec   = p5DiffMicrosec;
            pc.DifMillisec   = p5DiffMillisec;
            pc.DeltaTicks    = p5DeltaTicks;
            pc.DeltaMicrosec = p5DeltaMicrosec;
            pc.DeltaMillisec = p5DeltaMillisec;
            pc.uTimerType    = 5;
            return;
        }
       #endif

        if (dwFreq = qpcTimerFreq())
        {
            pc.dwRawKhz = dwFreq / 1000;
            pc.dwRawMhz = pc.dwRawKhz / 1000;
            pc.dwMicroAdjust = dwFreq / pc.dwRawMhz;
            if (pc.dwMicroAdjust == 1000000)
                pc.dwMicroAdjust = 0;
            pc.dwTimerKhz = 1000;

            pc.DifTicks      = qpcDiffTicks;
            pc.DifMicrosec   = qpcDiffMicrosec;
            pc.DifMillisec   = qpcDiffMillisec;
            pc.DeltaTicks    = qpcDeltaTicks;
            pc.DeltaMicrosec = qpcDeltaMicrosec;
            pc.DeltaMillisec = qpcDeltaMillisec;
            pc.uTimerType    = 1;
        }
    }

  #else // win16

    #pragma warning(disable:4704)
    #pragma warning(disable:4035)

    static VOID WINAPI p5InitTimer (PCTIMER * pBase)
    {
       _asm {
          _emit 0x0f
          _emit 0x31

          _emit 0x66
          xor bx, bx
          mov bx, pBase
          _emit 0x66
          mov [bx], ax
          _emit 0x66
          mov [bx+4], dx
       }
    }

    static DWORD WINAPI p5DiffTicks (PCTIMER * pBase)
    {
       _asm {
          _emit 0x0f
          _emit 0x31

          _emit 0x66
          xor bx, bx
          mov bx, pBase
          _emit 0x66
          sub ax, [bx]
          _emit 0x66
          sbb dx, [bx+4]
       }
    }

    static DWORD WINAPI p5DiffMicrosec (PCTIMER * pBase)
    {
       _asm {
          _emit 0x0f
          _emit 0x31

          _emit 0x66
          xor bx, bx
          mov bx, pBase
          _emit 0x66
          sub ax, [bx]
          _emit 0x66
          sbb dx, [bx+4]

          //_emit 0x66
          mov  cx, pc.wRawMhz
          _emit 0x66
          jcxz bail
          _emit 0x66
          cmp  dx, cx
          jb ok_to_divide
          _emit 0x66
          push ax
          _emit 0x66
          mov  ax, dx
          _emit 0x66
          xor  dx, dx
          _emit 0x66
          div  cx
          _emit 0x66
          pop  ax
        ok_to_divide:
          _emit 0x66
          div  cx
        bail:
       }
    }

    static DWORD WINAPI p5DiffMillisec (PCTIMER * pBase)
    {
       _asm {
          _emit 0x0f
          _emit 0x31

          _emit 0x66
          xor bx, bx
          mov bx, pBase
          _emit 0x66
          sub ax, [bx]
          _emit 0x66
          sbb dx, [bx+4]

          _emit 0x66
          mov  cx, pc.wRawKhz
          _emit 0x66
          jcxz  bail
          _emit 0x66
          cmp  dx, cx
          jb ok_to_divide
          _emit 0x66
          push ax
          _emit 0x66
          mov  ax, dx
          _emit 0x66
          xor  dx, dx
          _emit 0x66
          div  cx
          _emit 0x66
          pop  ax
        ok_to_divide:
          _emit 0x66
          div  cx
        bail:
       }
    }

    static DWORD WINAPI p5DeltaTicks (PCTIMER * pBase)
    {
       _asm {
          _emit 0x0f
          _emit 0x31

          _emit 0x66
          mov  bx, pBase
          _emit 0x66
          mov  cx, ax
          _emit 0x66
          sub  ax, [bx]
          _emit 0x66
          mov  [bx], cx
          _emit 0x66
          mov  cx, dx
          _emit 0x66
          sbb  dx, [bx+4]
          _emit 0x66
          mov  [bx+4], cx
       }
    }
    static DWORD WINAPI p5DeltaMicrosec (PCTIMER * pBase)
    {
       _asm {
          _emit 0x0f
          _emit 0x31

          _emit 0x66
          mov  bx, pBase
          _emit 0x66
          mov  cx, ax
          _emit 0x66
          sub  ax, [bx]
          _emit 0x66
          mov  [bx], cx
          _emit 0x66
          mov  cx, dx
          _emit 0x66
          sbb  dx, [bx+4]
          _emit 0x66
          mov  [bx+4], cx

          _emit 0x66
          mov  cx, pc.wRawMhz
          _emit 0x66
          jcxz  bail
          _emit 0x66
          cmp  dx, cx
          jb ok_to_divide
          _emit 0x66
          push ax
          _emit 0x66
          mov  ax, dx
          _emit 0x66
          xor  dx, dx
          _emit 0x66
          div  cx
          _emit 0x66
          pop  ax
        ok_to_divide:
          _emit 0x66
          div  cx
        bail:
       }
    }

    static DWORD WINAPI p5DeltaMillisec (PCTIMER * pBase)
    {
       _asm {
          _emit 0x0f
          _emit 0x31

          _emit 0x66
          mov  bx, pBase
          _emit 0x66
          mov  cx, ax
          _emit 0x66
          sub  ax, [bx]
          _emit 0x66
          mov  [bx], cx
          _emit 0x66
          mov  cx, dx
          _emit 0x66
          sbb  dx, [bx+4]
          _emit 0x66
          mov  [bx+4], cx

          //_emit 0x66
          mov  cx, pc.wRawKhz
          _emit 0x66
          jcxz  bail
          _emit 0x66
          cmp  dx, cx
          jb ok_to_divide
          _emit 0x66
          push ax
          _emit 0x66
          mov  ax, dx
          _emit 0x66
          xor  dx, dx
          _emit 0x66
          div  cx
          _emit 0x66
          pop  ax
        ok_to_divide:
          _emit 0x66
          div  cx
        bail:

       }
    }

    // 16 bit code for detecting CPU type so we can decide
    // whether or not it is ok to use the pentium timing stuff
    //
    int WINAPI pcGetCpuID ()
    {
    _asm {
        _emit 0x66
        pushf       ; save eflags

        // check for 486 by attempting to set the 0x40000 bit
        // in eflags.  if we can set it, the processor is 486 or better
        //
        _emit 0x66
        pushf               ; push eflags
        pop   ax            ; move eflags to dx:ax
        pop   dx
        or    dx, 4         ; set 0x40000 bit in eflags
        push  dx            ; put back onto stack
        push  ax
        _emit 0x66
        popf                ; pop modified flags back into eflags
        _emit 0x66
        pushf               ; push eflags back onto stack
        pop   ax            ; move eflags in to dx:bx
        pop   dx

        _emit 0x66
        popf        ; restore origonal eflags

        mov   bx, 3 ; assume 386
        test  dx, 4 ; 486 will preserve 0x40000 bit on push/pop of eflags
        jz    ret_procid
        inc   bx    ; this is a 486 or higher

        // if we get to here it is a 486 or greater

        // check for pentium or higher by attempting to toggle the
        // ID bit (0x200000) in eflags.
        // on a pentium, this bit will toggle, on 486 it will not
        //
        _emit  0x66
        pushf                   ; save eflags
        _emit  0x66
        pushf                   ; get eflags
        pop    ax               ; put eflags into dx:ax
        pop    dx
        xor    dx, 0x20         ; toggle 0x200000 bit in eflags
        push   dx
        push   ax               ; push modified eflags from dx:ax
        _emit  0x66
        popf                    ; load changed eflags
        _emit  0x66
        pushf                   ; get eflags again
        pop    ax               ; discard eflags lo
        pop    ax               ; get eflags hi
        xor    dx, ax           ; did anything change?
        _emit  0x66             ; restore old eflags
        popf

        test   dx, 0x20         ; did we change the 20 bit?
        jz     ret_procid       ; if not, bx already has 4, return that

        // if we get to here, it is a pentium or greater

        // use the pentium CPUID instruction to detect exact processor
        // type
        //
        _emit 0x0F            ; cpuid instruction
        _emit 0xA2
        shr   ax, 8           ; extract family field
        and   ax, 0x0F
        mov   bx, ax          ; 5 is pentium, others are higher

       ret_procid:
        mov   ax, bx
        }
    }

    static DWORD WINAPI p5TimerFreq ()
    {
        if (pcGetCpuID() >= 5)
        {
           DWORD   dw;
           DWORD   dwTicks;
           static PCTIMER timer;

           p5InitTimer (&timer);
           dw = timeGetTime() + 200;
           while (timeGetTime() < dw)
               ;
           dw = timeGetTime() - dw;
           dwTicks = p5DiffTicks(&timer);

           pc.dwRawMhz = (dwTicks + dw * 1000/2) /dw /1000;
           pc.dwRawKhz = pc.dwRawMhz * 1000;
           pc.dwRawHz  = pc.dwRawKhz * 1000;
           pc.dwMicroAdjust = 0;
           pc.dwTimerKhz = 1000;

           return pc.dwRawHz;
        }

        return 0;
    }

    VOID WINAPI InitPerformanceCounters (void)
    {
        if (p5TimerFreq() != 0l)
        {
            pc.DifTicks      = p5DiffTicks;
            pc.DifMicrosec   = p5DiffMicrosec;
            pc.DifMillisec   = p5DiffMillisec;
            pc.DeltaTicks    = p5DeltaTicks;
            pc.DeltaMicrosec = p5DeltaMicrosec;
            pc.DeltaMillisec = p5DeltaMillisec;
            pc.uTimerType    = 5;
            return;
        }
    }

  #endif // WIN32

#endif // _INC_MMTIMERS_CODE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avicap\msvideoi.h ===
/****************************************************************************/
/*                                                                          */
/* NOTE: The original location of this file was in the (ms)video            */
/*       subdirectory.  It was moved to AVICAP when the video thunks were   */
/*       moved to AVICAP.  There is probably some spurious information.     */
/*                                                                          */
/*        MSVIDEOI.H - Internal Include file for Video APIs                 */
/*                                                                          */
/*        Note: You must include WINDOWS.H before including this file.      */
/*                                                                          */
/*        Copyright (c) 1990-1994, Microsoft Corp.  All rights reserved.    */
/*                                                                          */
/****************************************************************************/

#ifdef BUILDDLL
#undef WINAPI
#define WINAPI FAR PASCAL _loadds
#endif

/****************************************************************************

                   Digital Video Driver Structures

****************************************************************************/

#define MAXVIDEODRIVERS 10

/****************************************************************************

                            Globals

****************************************************************************/

//extern UINT      wTotalVideoDevs;                  // total video devices
// The module handle is used in drawdib to load strings from the resource file
//extern HINSTANCE ghInst;                           // our module handle

extern SZCODE szNull[];
extern SZCODE szVideo[];
extern SZCODE szSystemIni[];
extern SZCODE szDrivers[];

/* internal video function prototypes */

#ifdef _WIN32
/*
 * don't lock pages in NT
 */
#define HugePageLock(x, y)		(TRUE)
#define HugePageUnlock(x, y)
#else

BOOL FAR PASCAL HugePageLock(LPVOID lpArea, DWORD dwLength);
void FAR PASCAL HugePageUnlock(LPVOID lpArea, DWORD dwLength);

#define videoGetErrorTextW videoGetErrorText

#endif

/****************************************************************************
****************************************************************************/

#ifdef DEBUG_RETAIL
    #define DebugErr(flags, sz)         {static SZCODE ach[] = "MSVIDEO: "sz; DebugOutput((flags)   | DBF_DRIVER, ach); }
#else
    #define DebugErr(flags, sz)
#endif

/****************************************************************************
****************************************************************************/

#ifdef DEBUG
    extern int videoDebugLevel;
    extern void FAR CDECL dprintf(LPSTR szFormat, ...);
    #define DPF( _x_ )	if (videoDebugLevel >= 1) thkdprintf _x_
    #define DPF0( _x_ )                           thkdprintf _x_
    #define DPF1( _x_ )	if (videoDebugLevel >= 1) thkdprintf _x_
    #define DPF2( _x_ )	if (videoDebugLevel >= 2) thkdprintf _x_
    #define DPF3( _x_ )	if (videoDebugLevel >= 3) thkdprintf _x_
    #define DPF4( _x_ ) if (videoDebugLevel >= 4) thkdprintf _x_
#else
    /* debug printf macros */
    #define DPF( x )
    #define DPF0( x )
    #define DPF1( x )
    #define DPF2( x )
    #define DPF3( x )
    #define DPF4( x )
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avicap\muldiv32.asm ===
page    ,132
;---------------------------Module-Header-------------------------------;
; Module Name: MATH.ASM
;
; Contains FIXED point math routines.
;
; Created:  Sun 30-Aug-1987 19:28:30
; Author: Charles Whitmer [chuckwh]
;
; Copyright (c) 1987  Microsoft Corporation
;-----------------------------------------------------------------------;

?WIN	= 0
?PLM	= 1
?NODATA = 0

        .286

        .xlist
        include cmacros.inc
        include windows.inc
        .list

        externA __WinFlags

UQUAD   struc
uq0     dw      ?
uq1     dw      ?
uq2     dw      ?
uq3     dw      ?
UQUAD	ends

;       The following two equates are just used as shorthand
;       for the "word ptr" and "byte ptr" overrides.

wptr    equ     word ptr
bptr    equ     byte ptr

; The following structure should be used to access high and low
; words of a DWORD.  This means that "word ptr foo[2]" -> "foo.hi".

LONG    struc
lo      dw      ?
hi      dw      ?
LONG    ends

EAXtoDXAX   macro
        shld    edx,eax,16      ; move HIWORD(eax) to dx
        endm

DXAXtoEAX   macro
        ror     eax,16          ; xchg HIWORD(eax) and LOWORD(eax)
        shrd    eax,edx,16      ; move LOWORD(edx) to HIWORD(eax)
        endm

neg32       macro hi, lo
        neg lo
        adc hi,0                ; carry set unless lo zero
        neg hi
        endm

ifndef SEGNAME
    SEGNAME equ <_TEXT>
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE

sBegin  CodeSeg
        assumes cs,CodeSeg
	assumes ds,nothing
        assumes es,nothing

;---------------------------Public-Routine------------------------------;
; long muldiv32(long, long, long)
;
; multiples two 32 bit values and then divides the result by a third
; 32 bit value with full 64 bit presision
;
; lResult = (lNumber * lNumerator) / lDenominator with correct rounding
;
; Entry:
;       lNumber = number to multiply by nNumerator
;       lNumerator = number to multiply by nNumber
;       lDenominator = number to divide the multiplication result by.
;   
; Returns:
;       DX:AX = result of multiplication and division.
;
; Error Returns:
;       none
; Registers Preserved:
;       DS,ES,SI,DI
; History:
;   Fri 05-Oct-1990 -by- Rob Williams [Robwi] 
;   Behavior consistent with MulDiv16 routine (signed, no int 0 on overflow)
;   Stole muldiv16 psuedocode
;
;   Wed 14-June-1990 -by-  Todd Laney [ToddLa]
;   converted it to 386/286 code. (by checking __WinFlags)
;
;   Tue 08-May-1990 -by-  Rob Williams [Robwi]
;   Wrote it.
;
;----------------------------Pseudo-Code--------------------------------;
; long FAR PASCAL muldiv32(long, long, long)
; long l;
; long Numer;
; long Denom;
; {
;
;   Sign = sign of Denom;   // Sign will keep track of final sign //
;
;
;   if (Denom < 0)
;   {
;	negate Denom;	// make sure Denom is positive //
;   }
;
;   if (l < 0)
;   {
;	negate l;	// make sure l is positive //
;   }
;
;   make Sign reflect any sign change;
;
;
;   if (Numer < 0)
;   {
;	negate Numer;	// make sure Numer is positive //
;   }
;
;   make Sign reflect any sign change;
;
;   Numer *= l;
;   Numer += (Denom/2); // adjust for rounding //
;
;   if (overflow)   // check for overflow, and handle divide by zero //
;   {
;	jump to md5;
;   }
;
;   result = Numer/Denom;
;
;   if (overflow)   // check again to see if overflow occured //
;   {
;	jump to md5;
;   }
;
;   if (Sign is negative)   // put sign on the result //
;   {
;	negate result;
;   }
;
;md6:
;   return(result);
;
;md5:
;   DX = 7FFF;	    // indicate overflow by //
;   AX = 0xFFFF     // return largest integer //
;   if (Sign is negative)
;   {
;	DX = 0x8000;	// with correct sign //
;	AX = 0x0000;	
;   }
;
;   jump to md6;
; }
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   muldiv32,<PUBLIC,FAR,NODATA,NONWIN>,<>
;       ParmD  lNumber
;       ParmD  lNumerator
;       ParmD  lDenominator
cBegin	<nogen>
	mov	ax,__WinFlags
        test    ax,WF_CPU286+WF_CPU086+WF_CPU186
        jz      md32_1
        jmp     NEAR PTR muldiv32_286
md32_1:
        errn$   muldiv32_386
cEnd    <nogen>

cProc   muldiv32_386,<PUBLIC,FAR,NODATA,NONWIN>,<>
        ParmD   lNumber
        ParmD   lNumerator
        ParmD   lDenominator
cBegin
        .386


        mov     ebx,lDenominator    ; get the demoninator
        mov     ecx,ebx	            ; ECX holds the final sign in hiword
        or      ebx,ebx             ; ensure the denominator is positive
        jns     md386_1
        neg     ebx

md386_1:
        mov     eax,lNumber         ; get the long we are multiplying
        xor     ecx,eax	            ; make ECX reflect any sign change
        or      eax,eax             ; ensure the long is positive
        jns     md386_2
        neg     eax

md386_2:
        mov     edx,lNumerator      ; get the numerator
        xor     ecx,edx	            ; make ECX reflect any sign change
        or      edx,edx             ; ensure the numerator is positive
        jns     md386_3
        neg     edx

md386_3:
        mul     edx                 ; multiply
        mov     cx,bx               ; get half of the demoninator to adjust for rounding
        sar     ebx,1               
        add     eax,ebx             ; adjust for possible rounding error
        adc     edx,0               ; this is really a long addition
        sal     ebx,1               ; restore the demoninator
        or      bx,cx               ; fix bottom bit
        cmp     edx,ebx             ; check for overflow
        jae     md386_5                 ; (ae handles /0 case)
        div     ebx                 ; divide
        or      eax,eax             ; If sign is set, then overflow occured
        js      md386_5                 ; Overflow.
        or      ecx,ecx             ; put the sign on the result
        jns     md386_6
        neg     eax

md386_6:
        EAXtoDXAX                   ; convert eax to dx:ax for 16 bit programs

        .286
cEnd 
        .386

md386_5:
        mov     eax,7FFFFFFFh       ; return the largest integer
        or      ecx,ecx             ; with the correct sign
        jns     md386_6
        not     eax
        jmp     md386_6

        .286

cProc   muldiv32_286,<PUBLIC,FAR,NODATA,NONWIN>,<di,si>
        ParmD  lNumber             
        ParmD  lNumerator
        ParmD  lDenominator
        LocalW wSign

cBegin

        mov     dx,lDenominator.hi      ; get the demoninator
        mov     si,dx	                ; SI holds the final sign 
        or      dx,dx                   ; ensure the denominator is positive
        jns     md286_1
        neg32   dx, lDenominator.lo
        mov     lDenominator.hi, dx


md286_1:
        mov     ax,lNumber.lo           ; get the long we are multiplying
        mov     dx,lNumber.hi           
        xor     si,dx	                ; make ECX reflect any sign change
        or      dx,dx                   ; ensure the long is positive
        jns     md286_2
        neg32   dx, ax

md286_2:
        mov     bx,lNumerator.lo        ; get the numerator
        mov     cx,lNumerator.hi        ; get the numerator
        xor     si,cx	                ; make ECX reflect any sign change
        or      cx,cx                   ; ensure the numerator is positive
        jns     md286_3
        neg32   cx, bx

md286_3:
        mov     wSign, si               ; save sign
        call    dmul                    ; multiply (result in dx:cx:bx:ax)
        mov     si, lDenominator.hi
        mov     di, lDenominator.lo
        sar     si, 1                   ; get half of the demoninator 
        rcr     di, 1                   ; to adjust for rounding
        add     ax, di                  ; adjust for possible rounding error
        adc     bx, si
        adc     cx, 0
        adc     dx, 0                   ; this is really a long addition

        sal     di, 1                   ; restore the demoninator
        rcl     si, 1

        or      di, lDenominator.lo     ; fix bottom bit

        cmp     dx, si                  ; begin overflow check (unsigned for div 0 check)
        ja      md286_5                 ; overflow
        jb      md286_7                 ; no overflow
        cmp     cx, di       
        jae     md286_5                 ; overflow

md286_7:
        call    qdiv                    ; DX:AX is quotient     
        or      dx,dx                   ; If sign is set, then overflow occured
        js      md286_5                 ; Overflow.
        mov     cx, wSign
        or      cx,cx                   ; put the sign on the result
        jns     md286_6
        neg32   dx,ax

md286_6:

cEnd

md286_5:
        mov     cx, wSign
        mov     ax, 0FFFFh              ; return the largest integer
        mov     dx, 7FFFh
        or      cx, cx                  ; with the correct sign
        jns     md286_6
        not     dx
        not     ax
        jmp     md286_6


;---------------------------Public-Routine------------------------------;
; idmul
;
; This is an extended precision multiply routine, intended to emulate
; 80386 imul instruction.
;
; Entry:
;       DX:AX = LONG
;       CX:BX = LONG
; Returns:
;       DX:CX:BX:AX = QUAD product
; Registers Destroyed:
;       none
; History:
;  Tue 26-Jan-1988 23:47:02  -by-  Charles Whitmer [chuckwh]
; Wrote it.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   idmul,<PUBLIC,NEAR>,<si,di>
        localQ  qTemp
cBegin

; put one argument in safe registers

        mov     si,dx
        mov     di,ax

; do the low order unsigned product

        mul     bx
        mov     qTemp.uq0,ax
        mov     qTemp.uq1,dx

; do the high order signed product

        mov     ax,si
        imul    cx
        mov     qTemp.uq2,ax
        mov     qTemp.uq3,dx

; do a mixed product

        mov     ax,si
        cwd
        and     dx,bx
        sub     qTemp.uq2,dx            ; adjust for sign bit
        sbb     qTemp.uq3,0
        mul     bx
        add     qTemp.uq1,ax
        adc     qTemp.uq2,dx
        adc     qTemp.uq3,0

; do the other mixed product

        mov     ax,cx
        cwd
	and	dx,di
        sub     qTemp.uq2,dx
        sbb     qTemp.uq3,0
        mul     di

; pick up the answer

        mov     bx,ax
        mov     cx,dx
        xor     dx,dx

        mov     ax,qTemp.uq0
        add     bx,qTemp.uq1
        adc     cx,qTemp.uq2
        adc     dx,qTemp.uq3
cEnd

;---------------------------Public-Routine------------------------------;
; dmul
;
; This is an extended precision multiply routine, intended to emulate
; 80386 mul instruction.
;
; Entry:
;       DX:AX = LONG
;       CX:BX = LONG
; Returns:
;       DX:CX:BX:AX = QUAD product
; Registers Destroyed:
;       none
; History:
;  Tue 02-Feb-1988 10:50:44  -by-  Charles Whitmer [chuckwh]
; Copied from idmul and modified.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   dmul,<PUBLIC,NEAR>,<si,di>
        localQ  qTemp
cBegin

; put one argument in safe registers

        mov     si,dx
        mov     di,ax

; do the low order product

        mul     bx
        mov     qTemp.uq0,ax
        mov     qTemp.uq1,dx

; do the high order product

        mov     ax,si
        mul     cx
        mov     qTemp.uq2,ax
        mov     qTemp.uq3,dx

; do a mixed product

        mov     ax,si
        mul     bx
        add     qTemp.uq1,ax
        adc     qTemp.uq2,dx
        adc     qTemp.uq3,0

; do the other mixed product

        mov     ax,cx
        mul     di

; pick up the answer

        mov     bx,ax
        mov     cx,dx
        xor     dx,dx
        mov     ax,qTemp.uq0
        add     bx,qTemp.uq1
        adc     cx,qTemp.uq2
        adc     dx,qTemp.uq3
cEnd

;---------------------------Public-Routine------------------------------;
; iqdiv
;
; This is an extended precision divide routine which is intended to
; emulate the 80386 64 bit/32 bit IDIV instruction.  We don't have the
; 32 bit registers to work with, but we pack the arguments and results
; into what registers we do have.  We will divide two signed numbers
; and return the quotient and remainder.  We will do INT 0 for overflow,
; just like the 80386 microcode.  This should ease conversion later.
;
; This routine just keeps track of the signs and calls qdiv to do the
; real work.
;
; Entry:
;       DX:CX:BX:AX = QUAD Numerator
;       SI:DI       = LONG Denominator
; Returns:
;       DX:AX = quotient
;       CX:BX = remainder
; Registers Destroyed:
;       DI,SI
; History:
;  Tue 26-Jan-1988 02:49:19  -by-  Charles Whitmer [chuckwh]
; Wrote it.
;-----------------------------------------------------------------------;

WIMP    equ     1

IQDIV_RESULT_SIGN       equ     1
IQDIV_REM_SIGN          equ     2

        assumes ds,nothing
        assumes es,nothing

cProc   iqdiv,<PUBLIC,NEAR>
        localB  flags
cBegin
        mov     flags,0

; take the absolute value of the denominator

        or      si,si
        jns     denominator_is_cool
        xor     flags,IQDIV_RESULT_SIGN
        neg     di
        adc     si,0
        neg     si
denominator_is_cool:

; take the absolute value of the denominator

        or      dx,dx
        jns     numerator_is_cool
        xor     flags,IQDIV_RESULT_SIGN + IQDIV_REM_SIGN
        not     ax
        not     bx
        not     cx
        not     dx
        add     ax,1
        adc     bx,0
        adc     cx,0
        adc     dx,0
numerator_is_cool:

; do the unsigned division

        call    qdiv
ifdef WIMP
        jo      iqdiv_exit
endif

; check for overflow

        or      dx,dx
        jns     have_a_bit_to_spare
ifdef WIMP
        mov     ax,8000h
        dec     ah
        jmp     short iqdiv_exit
else
        int     0                       ; You're toast, Jack!
endif
have_a_bit_to_spare:

; negate the result, if required

        test    flags,IQDIV_RESULT_SIGN
        jz      result_is_done
        neg     ax
        adc     dx,0
        neg     dx
result_is_done:

; negate the remainder, if required

        test    flags,IQDIV_REM_SIGN
        jz      remainder_is_done
        neg     bx
        adc     cx,0
        neg     cx
remainder_is_done:
iqdiv_exit:
cEnd

;---------------------------Public-Routine------------------------------;
; qdiv
;
; This is an extended precision divide routine which is intended to
; emulate the 80386 64 bit/32 bit DIV instruction.  We don't have the
; 32 bit registers to work with, but we pack the arguments and results
; into what registers we do have.  We will divide two unsigned numbers
; and return the quotient and remainder.  We will do INT 0 for overflow,
; just like the 80386 microcode.  This should ease conversion later.
;
; Entry:
;       DX:CX:BX:AX = UQUAD Numerator
;       SI:DI       = ULONG Denominator
; Returns:
;       DX:AX = quotient
;       CX:BX = remainder
; Registers Destroyed:
;       none
; History:
;  Tue 26-Jan-1988 00:02:09  -by-  Charles Whitmer [chuckwh]
; Wrote it.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   qdiv,<PUBLIC,NEAR>,<si,di>
        localQ  uqNumerator
        localD  ulDenominator
        localD  ulQuotient
        localW  cShift
cBegin

; stuff the quad word into local memory

        mov     uqNumerator.uq0,ax
        mov     uqNumerator.uq1,bx
        mov     uqNumerator.uq2,cx
        mov     uqNumerator.uq3,dx


; check for overflow

qdiv_restart:
        cmp     si,dx
        ja      qdiv_no_overflow
        jb      qdiv_overflow
        cmp     di,cx
        ja      qdiv_no_overflow
qdiv_overflow:
ifdef WIMP
        mov     ax,8000h
        dec     ah
        jmp     qdiv_exit
else
        int     0                       ; You're toast, Jack!
        jmp     qdiv_restart
endif
qdiv_no_overflow:

; check for a zero Numerator

        or      ax,bx
        or      ax,cx
        or      ax,dx
        jz      qdiv_exit_relay         ; quotient = remainder = 0

; handle the special case when the denominator lives in the low word

        or      si,si
        jnz     not_that_special

; calculate (DX=0):CX:BX:uqNumerator.uq0 / (SI=0):DI

        cmp     di,1                    ; separate out the trivial case
        jz      div_by_one
        xchg    dx,cx                   ; CX = remainder.hi = 0
        mov     ax,bx
        div     di
        mov     bx,ax                   ; BX = quotient.hi
        mov     ax,uqNumerator.uq0
        div     di                      ; AX = quotient.lo
        xchg    bx,dx                   ; DX = quotient.hi, BX = remainder.lo
ifdef WIMP
        or      ax,ax           ; clear OF
endif
qdiv_exit_relay:
        jmp     qdiv_exit

; calculate (DX=0):(CX=0):BX:uqNumerator.uq0 / (SI=0):(DI=1)

div_by_one:
        xchg    dx,bx                   ; DX = quotient.hi, BX = remainder.lo = 0
        mov     ax,uqNumerator.uq0      ; AX = quotient.lo
        jmp     qdiv_exit
not_that_special:

; handle the special case when the denominator lives in the high word

        or      di,di
        jnz     not_this_special_either

; calculate DX:CX:BX:uqNumerator.uq0 / SI:(DI=0)

        cmp     si,1                    ; separate out the trivial case
        jz      div_by_10000h
        mov     ax,cx
        div     si
        mov     cx,ax                   ; CX = quotient.hi
        mov     ax,bx
        div     si                      ; AX = quotient.lo
        xchg    cx,dx                   ; DX = quotient.hi, CX = remainder.hi
        mov     bx,uqNumerator.uq0      ; BX = remainder.lo
ifdef WIMP
        or      ax,ax           ; clear OF
endif
        jmp     qdiv_exit

; calculate (DX=0):CX:BX:uqNumerator.uq0 / (SI=1):(DI=0)

div_by_10000h:
        xchg    cx,dx                   ; DX = quotient.hi, CX = remainder.hi = 0
        mov     ax,bx                   ; AX = quotient.lo
        mov     bx,uqNumerator.uq0      ; BX = remainder.lo
        jmp     qdiv_exit
not_this_special_either:

; normalize the denominator

        mov     dx,si
        mov     ax,di
        call    ulNormalize             ; DX:AX = normalized denominator
        mov     cShift,cx               ; CX < 16
        mov     ulDenominator.lo,ax
        mov     ulDenominator.hi,dx


; shift the Numerator by the same amount

        jcxz    numerator_is_shifted
        mov     si,-1
        shl     si,cl
        not     si                      ; SI = mask
        mov     bx,uqNumerator.uq3
        shl     bx,cl
        mov     ax,uqNumerator.uq2
        rol     ax,cl
        mov     di,si
        and     di,ax
        or      bx,di
        mov     uqNumerator.uq3,bx
        xor     ax,di
        mov     bx,uqNumerator.uq1
        rol     bx,cl
        mov     di,si
        and     di,bx
        or      ax,di
        mov     uqNumerator.uq2,ax
        xor     bx,di
        mov     ax,uqNumerator.uq0
        rol     ax,cl
        mov     di,si
        and     di,ax
        or      bx,di
        mov     uqNumerator.uq1,bx
        xor     ax,di
        mov     uqNumerator.uq0,ax
numerator_is_shifted:

; set up registers for division

        mov     dx,uqNumerator.uq3
        mov     ax,uqNumerator.uq2
        mov     di,uqNumerator.uq1
        mov     cx,ulDenominator.hi
        mov     bx,ulDenominator.lo

; check for case when Denominator has only 16 bits

        or      bx,bx
        jnz     must_do_long_division
        div     cx
        mov     si,ax
        mov     ax,uqNumerator.uq1
        div     cx
        xchg    si,dx                   ; DX:AX = quotient
        mov     di,uqNumerator.uq0      ; SI:DI = remainder (shifted)
        jmp     short unshift_remainder
must_do_long_division:

; do the long division, part IZ@NL@%

        cmp     dx,cx                   ; we only know that DX:AX < CX:BX!
        jb      first_division_is_safe
        mov     ulQuotient.hi,0         ; i.e. 10000h, our guess is too big
        mov     si,ax
        sub     si,bx                   ; ... remainder is negative
        jmp     short first_adjuster
first_division_is_safe:
        div     cx
        mov     ulQuotient.hi,ax
        mov     si,dx
        mul     bx                      ; fix remainder for low order term
        sub     di,ax
        sbb     si,dx
        jnc     first_adjuster_done     ; The remainder is UNSIGNED!  We have
first_adjuster:                         ; to use the carry flag to keep track
        dec     ulQuotient.hi           ; of the sign.  The adjuster loop
        add     di,bx                   ; watches for a change to the carry
        adc     si,cx                   ; flag which would indicate a sign
        jnc     first_adjuster          ; change IF we had more bits to keep
first_adjuster_done:                    ; a sign in.

; do the long division, part II

        mov     dx,si
        mov     ax,di
        mov     di,uqNumerator.uq0
        cmp     dx,cx                   ; we only know that DX:AX < CX:BX!
        jb      second_division_is_safe
        mov     ulQuotient.lo,0         ; i.e. 10000h, our guess is too big
        mov     si,ax
        sub     si,bx                   ; ... remainder is negative
        jmp     short second_adjuster
second_division_is_safe:
        div     cx
        mov     ulQuotient.lo,ax
        mov     si,dx
        mul     bx                      ; fix remainder for low order term
        sub     di,ax
        sbb     si,dx
        jnc     second_adjuster_done
second_adjuster:
        dec     ulQuotient.lo
        add     di,bx
        adc     si,cx
        jnc     second_adjuster
second_adjuster_done:
        mov     ax,ulQuotient.lo
        mov     dx,ulQuotient.hi

; unshift the remainder in SI:DI

unshift_remainder:
        mov     cx,cShift
        jcxz    remainder_unshifted
        mov     bx,-1
        shr     bx,cl
        not     bx
        shr     di,cl
        ror     si,cl
        and     bx,si
        or      di,bx
        xor     si,bx
remainder_unshifted:
        mov     cx,si
        mov     bx,di
ifdef WIMP
        or      ax,ax           ; clear OF
endif
qdiv_exit:
cEnd

;---------------------------Public-Routine------------------------------;
; ulNormalize
;
; Normalizes a ULONG so that the highest order bit is 1.  Returns the
; number of shifts done.  Also returns ZF=1 if the ULONG was zero.
;
; Entry:
;       DX:AX = ULONG
; Returns:
;       DX:AX = normalized ULONG
;       CX    = shift count
;       ZF    = 1 if the ULONG is zero, 0 otherwise
; Registers Destroyed:
;       none
; History:
;  Mon 25-Jan-1988 22:07:03  -by-  Charles Whitmer [chuckwh]
; Wrote it.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   ulNormalize,<PUBLIC,NEAR>
cBegin

; shift by words

        xor     cx,cx
        or      dx,dx
        js      ulNormalize_exit
        jnz     top_word_ok
        xchg    ax,dx
        or      dx,dx
        jz      ulNormalize_exit        ; the zero exit
        mov     cl,16
        js      ulNormalize_exit
top_word_ok:

; shift by bytes

        or      dh,dh
        jnz     top_byte_ok
        xchg    dh,dl
        xchg    dl,ah
        xchg    ah,al
        add     cl,8
        or      dh,dh
        js      ulNormalize_exit
top_byte_ok:

; do the rest by bits

        inc     cx
        add     ax,ax
        adc     dx,dx
        js      ulNormalize_exit
        inc     cx
        add     ax,ax
        adc     dx,dx
        js      ulNormalize_exit
        inc     cx
        add     ax,ax
        adc     dx,dx
        js      ulNormalize_exit
        inc     cx
        add     ax,ax
        adc     dx,dx
        js      ulNormalize_exit
        inc     cx
        add     ax,ax
        adc     dx,dx
        js      ulNormalize_exit
        inc     cx
        add     ax,ax
        adc     dx,dx
        js      ulNormalize_exit
        inc     cx
        add     ax,ax
        adc     dx,dx
ulNormalize_exit:
cEnd

sEnd   CodeSeg

       end

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avicap\profile.h ===
/*
 * AVICAP32:
 *
 * utility functions to read and write values to the profile,
 * using win.ini for Win16/Win95 or current
 * the registry for Win32 NT.  (Trivial to change to registry for Win95)
 *
 * The only routine that AVICAP32 uses is GetProfileIntA
 */

#if defined(_WIN32) && defined(UNICODE)

/*
 * read a UINT from the profile, or return default if
 * not found.
 */
UINT mmGetProfileIntA(LPCSTR appname, LPCSTR valuename, INT uDefault);

// Now map all instances of GetProfileIntA to mmGetProfileIntA
#define GetProfileIntA mmGetProfileIntA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avicap\pentime.h ===
/*+ pentime.h
 *
 * pentium specific high precision timer functions for 16 or 32 bit apps
 * (16 bit also needs pentime.asm)
 *
 *-======================================================================*/

#ifndef PENTIME_H
#define PENTIME_H

typedef struct {
    DWORD dwlo;
    DWORD dwhi;
    } PENTIMER, NEAR * PPENTIMER;

void FAR PASCAL pentimeInitTimer (
    PPENTIMER pptimer);

DWORD FAR PASCAL pentimeGetMicrosecs (
    PPENTIMER pptimer);

DWORD FAR PASCAL pentimeGetMicrosecDelta (
    PPENTIMER pptimer);

DWORD FAR PASCAL pentimeGetMillisecs (
    PPENTIMER pptimer);

struct _pentime_global {
    DWORD    dwTimerKhz;
    BOOL     bActive;
    PENTIMER base;
    DWORD    dwCpuMhz;
    DWORD    dwCpuKhz;
    };
extern struct _pentime_global pentime;

//
// macros to make whether to use pentium timers or not a runtime option
//
#ifdef _X86_

  #define pentimeGetTime()       pentime.bActive ? pentimeGetMillisecs(&pentime.base) : timeGetTime()
  #define pentimeGetTicks()      pentime.bActive ? pentimeGetMicrosecs(&pentime.base) : timeGetTime()
  #define pentimeBegin()         pentime.bActive ? (pentimeInitTimer(&pentime.base), 0l) : (void)(pentime.base.dwlo = timeGetTime())
  #define pentimeGetTickRate()   (pentime.bActive ? (pentime.dwTimerKhz * 1000) : 1000l)
  #define pentimeGetDeltaTicks(ppt) pentime.bActive ? pentimeGetMicrosecDelta(ppt) : \
    ((ppt)->dwhi = (ppt)->dwlo, (ppt)->dwlo = timeGetTime(), (ppt)->dwlo - (ppt)->dwhi)

#else

  #define pentimeGetTime()       timeGetTime()
  #define pentimeGetTicks()      timeGetTime()
  #define pentimeBegin()         (pentime.base.dwlo = timeGetTime())
  #define pentimeGetTickRate()   (1000l)
  #define pentimeGetDeltaTicks(ppt) \
    ((ppt)->dwhi = (ppt)->dwlo, (ppt)->dwlo = timeGetTime(), (ppt)->dwlo - (ppt)->dwhi)

#endif

#if (defined _INC_PENTIME_CODE_) && (_INC_PENTIME_CODE_ != FALSE)
    #undef _INC_PENTIME_CODE_
    #define _INC_PENTIME_CODE_ FALSE

    struct _pentime_global pentime = {1, 0};

   #ifdef _WIN32
     #ifdef _X86_
      static BYTE opGetP5Ticks[] = {
          0x0f, 0x31,                   // rtdsc
          0xc3                          // ret
          };

      static void (WINAPI * GetP5Ticks)() = (LPVOID)opGetP5Ticks;

      #pragma warning(disable:4704)
      #pragma warning(disable:4035)

      void FAR PASCAL pentimeInitTimer (
          PPENTIMER pptimer)
      {
          GetP5Ticks();
          _asm {
              mov  ebx, pptimer
              mov  [ebx], eax
              mov  [ebx+4], edx
          };
      }

      DWORD FAR PASCAL pentimeGetCpuTicks (
          PPENTIMER pptimer)
      {
          GetP5Ticks();
          _asm {
              mov  ebx, pptimer
              sub  eax, [ebx]
              sbb  edx, [ebx+4]
          };
      }

      DWORD FAR PASCAL pentimeGetMicrosecs (
          PPENTIMER pptimer)
      {
          GetP5Ticks();
          _asm {
              mov  ebx, pptimer
              sub  eax, [ebx]
              sbb  edx, [ebx+4]
              and  edx, 31               // to prevent overflow
              mov  ecx, pentime.dwCpuMhz
              div  ecx
          };
      }

      DWORD WINAPI pentimeGetMicrosecDelta (
          PPENTIMER pptimer)
      {
          GetP5Ticks();
          _asm {
              mov  ebx, pptimer
              mov  ecx, eax
              sub  eax, [ebx]
              mov  [ebx], ecx
              mov  ecx, edx
              sbb  edx, [ebx+4]
              mov  [ebx+4], ecx
              and  edx, 31
              mov  ecx, pentime.dwCpuMhz
              div  ecx
          };
      }

      DWORD FAR PASCAL pentimeGetMillisecs (
          PPENTIMER pptimer)
      {
          GetP5Ticks();
          _asm {
              mov  ebx, pptimer
              sub  eax, [ebx]
              sbb  edx, [ebx+4]
              and  edx, 0x7fff           // to prevent overflow
              mov  ecx, pentime.dwCpuKhz
              div  ecx
          };
      }
     #endif

      void FAR PASCAL pentimeSetMhz (
          DWORD dwCpuMhz)
      {
          pentime.dwCpuMhz = dwCpuMhz;
          pentime.dwCpuKhz = dwCpuMhz * 1000;
      }
   #else // 16 bit - set mhz is in ASM file

    void FAR PASCAL pentimeSetMhz (
        DWORD dwCpuMhz);

   #endif

    void FAR PASCAL pentimeInit (
        BOOL  bIsPentium,
        DWORD dwCpuMhz)
    {
        if (pentime.bActive = bIsPentium)
        {
            pentimeSetMhz (dwCpuMhz);
            pentime.dwTimerKhz = 1000;
        }
        else
            pentime.dwTimerKhz = 1;

        pentimeBegin();
    }

   #ifdef _WIN32
    VOID WINAPI pentimeDetectCPU ()
    {
        SYSTEM_INFO si;
        static DWORD MS_INTERVAL = 500; // measure pentium cpu clock for this
                                        // many millisec.  the larger this number
                                        // the more accurate our Mhz measurement.
                                        // numbers less than 100 are unlikely
                                        // to be reliable because of the slop
                                        // in GetTickCount

       #ifdef _X86_
        GetSystemInfo(&si);
        if (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL &&
            si.wProcessorLevel == 5
           )
        {
            DWORD     dw;
            PENTIMER  qwTicks;
            DWORD     dwTicks;

            pentime.bActive = TRUE;
            pentime.dwTimerKhz = 1000;

            timeBeginPeriod(1);
            dw = timeGetTime ();
            pentimeInitTimer (&qwTicks);

            Sleep(MS_INTERVAL);

            dw = timeGetTime() - dw;
            dwTicks = pentimeGetCpuTicks (&qwTicks);
            timeEndPeriod(1);

            // calculate the CPU Mhz value and Khz value
            // to use as millisec and microsec divisors
            //
            pentime.dwCpuMhz = (dwTicks + dw*500)/dw/1000;
            pentime.dwCpuKhz = pentime.dwCpuMhz * 1000;
        }
        else
       #endif
        {
            pentime.bActive = FALSE;
            pentime.dwTimerKhz = 1;
        }
    }
   #else // win16
    VOID WINAPI pentimeDetectCPU ()
    {
        pentimeInit (FALSE, 33);
    }
   #endif


#endif // _INC_PENTIME_CODE_
#endif // PENTIME_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avicap\profile.c ===
/*
 * AVICAP32:
 *
 * profile.c
 *
 * win32/win16 utility functions to read and write profile items
 * for VFW
 *
 * ONLY mmGetProfileIntA is supported here
 *
 */

#if defined(_WIN32) && defined(UNICODE)
// This whole file is only used for 32 bit code.  It is the implementation
// that allows Win GetProfilexxx calls to use the registry.

#include <windows.h>
#include <windowsx.h>

#include <profile.key>
#include <win32.h>
#include <stdlib.h>  // for atoi

#include "profile.h"

static HKEY GetKeyA(LPCSTR appname, BOOL fCreate)
{
    HKEY key = 0;
    char achName[MAX_PATH];

    lstrcpyA(achName, KEYNAMEA);
    lstrcatA(achName, appname);

    if ((!fCreate && RegOpenKeyA(ROOTKEY, achName, &key) == ERROR_SUCCESS)
        || (fCreate && RegCreateKeyA(ROOTKEY, achName, &key) == ERROR_SUCCESS)) {
    }

    return(key);
}

#define GetKey GetKeyA

/*
 * read a UINT from the profile, or return default if
 * not found.
 */
UINT
mmGetProfileIntA(LPCSTR appname, LPCSTR valuename, INT uDefault)
{
    DWORD dwType;
    INT value = uDefault;
    DWORD dwData;
    int cbData;

    HKEY key = GetKeyA(appname, FALSE);

    if (key) {

        cbData = sizeof(dwData);
        if (RegQueryValueExA(
            key,
            (LPSTR)valuename,
            NULL,
            &dwType,
            (PBYTE) &dwData,
            &cbData) == ERROR_SUCCESS) {
            if (dwType == REG_DWORD || dwType == REG_BINARY) {
                value = (INT)dwData;
            } else if (dwType == REG_SZ) {
		value = atoi((LPSTR) &dwData);
	    }
	}

        RegCloseKey(key);
    }

    return((UINT)value);
}

#endif // DAYTONA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avicap\thunk32.c ===
//==========================================================================;
//  thunk32.c
//
//  Copyright (c) 1991-1994 Microsoft Corporation.  All Rights Reserved.
//
//  Description:
//      This module contains routines for thunking the video APIs
//      from 16-bit Windows to 32-bit WOW.
//
//  History:
//
//==========================================================================;

/*

    WOW Thunking design:

        Thunks are generated as follows :

        16-bit :

*/

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <mmreg.h>
#include <memory.h>
#include <win32.h>
#ifdef _WIN32
#include <ivideo32.h>
#else
#include <msvideo.h>
#endif
#include <msviddrv.h>
#include <msvideoi.h>
#ifdef _WIN32
    #include <wownt32.h>
    #include <stdlib.h>        // for mbstowcs and wcstombs
    #include <video16.h>
#ifdef UNICODE
    #include "profile.h"       // NT only (for now?)
#endif
#endif // WIN32

// in capinit.c
BOOL capInternalGetDriverDescA(UINT wDriverIndex,
        LPSTR lpszName, int cbName,
        LPSTR lpszVer, int cbVer);

//
// pick up the function definitions
//

#include "vidthunk.h"

#ifdef DEBUG
#define MODNAME "AVICAP32"
int videoDebugLevel = -1;
void videoDebugInit(VOID)
{
    if (videoDebugLevel == -1)
        videoDebugLevel = GetProfileIntA("Debug", MODNAME, 0);
}
#else
    #define videoDebugInit()
#endif

/* -------------------------------------------------------------------------
** Handle and memory mapping functions.
** -------------------------------------------------------------------------
*/
LPWOWHANDLE32          lpWOWHandle32;
LPWOWHANDLE16          lpWOWHandle16;
LPWOWCALLBACK16        lpWOWCallback16;
LPGETVDMPOINTER        GetVdmPointer;
int                    ThunksInitialized;

#ifdef WIN32
#ifdef DEBUG
void FAR cdecl thkdprintf(LPSTR szFormat, ...)
{
    char ach[128];
    va_list va;

#define MARKER "AVICAP (thunk): "
    lstrcpyA(ach, MARKER);

    va_start(va, szFormat);
    wvsprintfA(ach+sizeof(MARKER), szFormat, va);
    va_end(va);
    OutputDebugStringA(ach);
}
#endif
#endif

//
//  Useful functions
//

//
//  CopyAlloc - allocate a new piece of memory, and copy the data in
//  Must use LocalFree to release the memory later
//
PVOID CopyAlloc(PVOID   pvSrc, UINT    uSize)
{
    PVOID   pvDest;

    pvDest = (PVOID)LocalAlloc(LMEM_FIXED, uSize);

    if (pvDest != NULL) {
        CopyMemory(pvDest, pvSrc, uSize);
    }

    return pvDest;
}

/*
 *  Copy data from source to dest where source is a 32bit pointer
 *  and dest is a 16bit pointer
 */
void CopyTo16Bit(LPVOID Dest16, LPVOID Src32, DWORD Length)
{
    PVOID Dest32;

    if (Src32 == NULL) {
        return;
    }

    Dest32 = GetVdmPointer((DWORD)Dest16, Length, TRUE);

    CopyMemory(Dest32, Src32, Length);
}


/*
 *  Copy data from source to dest where source is a 16bit pointer
 *  and dest is a 32bit pointer
 */
void CopyTo32Bit(LPVOID Dest32, LPVOID Src16, DWORD Length)
{
    PVOID Src32;

    if (Src16 == NULL) {
        return;
    }

    Src32 = GetVdmPointer((DWORD)Src16, Length, TRUE);

    CopyMemory(Dest32, Src32, Length);
}

/*
 *  Copy data from source to dest where source is a 16bit pointer
 *  and dest is a 32bit pointer ONLY if the source is not aligned
 *
 *  Returns which pointer to use (src or dest)
 */
LPVOID CopyIfNotAligned(LPVOID Dest32, LPVOID Src16, DWORD Length)
{
    PVOID Src32;

    if (Src16 == NULL) {
        return Dest32;
    }

    Src32 = GetVdmPointer((DWORD)Src16, Length, TRUE);

    CopyMemory(Dest32, Src32, Length);

    return Dest32;
}


typedef struct _callback {
    WORD flags;
    WORD hVideo16;
    WORD msg;
    DWORD dwCallback16inst;
    DWORD dw1;
    DWORD dw2;
}  CALLBACK16;
typedef CALLBACK16 * PCALLBACK16;

/*
 *  Callbacks
 */

void MyVideoCallback(HANDLE handle,
                     UINT msg,
                     DWORD dwUser,
                     DWORD dw1,
                     DWORD dw2)
{
    PVIDEOINSTANCEDATA32 pInst;
    BOOL fFree = FALSE;

    pInst = (PVIDEOINSTANCEDATA32)dwUser;

    DPF3(("Video callback - handle = %8X, msg = %8X, dwUser = %8X, dw1 = %8X, dw2 = %8X\n",
              handle, msg, dwUser, dw1, dw2));

    switch (msg) {

   /*
    *  What are the parameters for these messages ??
    */

    case MM_DRVM_OPEN:

       /*
        *  We get this when we INIT_STREAM
        */

        break;

    case MM_DRVM_CLOSE:

       /*
        *  Device is closing - this is where we free our structures
        *  (just in case the 32-bit side called close to clean up).
        *  dwUser points to our data
        */

        fFree = TRUE;

        break;

    case MM_DRVM_DATA:

       /*
        *  We have data - this means a buffer has been returned in
        *  dw1
        */

        {
            PVIDEOHDR32 pHdr32;

            pHdr32 = CONTAINING_RECORD((PVIDEOHDR)dw1,
                                       VIDEOHDR32,
                                       videoHdr);

            dw1 = (DWORD)pHdr32->pHdr16; // For callback below

           /*
            *  Map back the data and free our structure
            */

            {
                VIDEOHDR Hdr16;
                Hdr16 = pHdr32->videoHdr;
                Hdr16.lpData = pHdr32->lpData16;
                memcpy(pHdr32->pHdr32, (LPVOID)&Hdr16, sizeof(VIDEOHDR));
            }

           /*
            *  Clean up our local structure
            */

            LocalFree((HLOCAL)pHdr32);

        }

        break;

    case MM_DRVM_ERROR:
       /*
        *  dw1 = frames skipped - unfortunately there's nobody to tell!
        */

        break;
    }

   /*
    *  Call back the application if appropriate
    */

    switch (pInst->dwFlags & CALLBACK_TYPEMASK) {
        case CALLBACK_WINDOW:
            PostMessage(ThunkHWND(LOWORD(pInst->dwCallback)),
                    msg, (WPARAM)handle, (LPARAM)dw1);
            break;

        case CALLBACK_FUNCTION:
#if 0
            // Must call a generic 16 bit callback passing a pointer to
            // a parameter array.
            {

                WORD hMem;
                PCALLBACK16 pCallStruct;
                pCallStruct = WOWGlobalAllocLock16(0, sizeof(CALLBACK16), &hMem);
                if (pCallStruct) {
                    pCallStruct->flags = HIWORD(pInst->dwFlags);
                    pCallStruct->hVideo16 = (WORD)pInst->hVideo;
                    pCallStruct->msg = (WORD)msg;
                    pCallStruct->dwCallback16inst = pInst->dwCallbackInst;
                    pCallStruct->dw1 = (DWORD)dw1;
                    pCallStruct->dw2 = (DWORD)dw2;

                    lpWOWCallback16(pInst->dwCallback, pCallStruct);

                    // Now free off the callback structure
                    WOWGlobalUnlockFree16(pCallStruct);

                }
            }
#endif
            break;
    }

    if (fFree) {
        LocalFree((HLOCAL)pInst);
    }
}

//
//  Thunking callbacks to WOW32 (or wherever)
//

//--------------------------------------------------------------------------;
//
//  DWORD videoThunk32
//
//  Description:
//
//      32-bit function dispatcher for thunks.
//
//  Arguments:
//      DWORD dwThunkId:
//
//      DWORD dw1:
//
//      DWORD dw2:
//
//      DWORD dw3:
//
//      DWORD dw4:
//
//  Return (DWORD):
//
//  History:
//
//--------------------------------------------------------------------------;

DWORD videoThunk32(DWORD dwThunkId,DWORD dw1,DWORD dw2,DWORD dw3,DWORD dw4)
{
    //
    //  Make sure we've got thunking functionality
    //
    if (ThunksInitialized <= 0) {

        HMODULE hMod;

        if (ThunksInitialized == -1) {
            return MMSYSERR_ERROR;
        }

        videoDebugInit();

        hMod = GetModuleHandle(GET_MAPPING_MODULE_NAME);
        if (hMod != NULL) {

            GetVdmPointer =
                (LPGETVDMPOINTER)GetProcAddress(hMod, GET_VDM_POINTER_NAME);
            lpWOWHandle32 =
                (LPWOWHANDLE32)GetProcAddress(hMod, GET_HANDLE_MAPPER32 );
            lpWOWHandle16 =
                (LPWOWHANDLE16)GetProcAddress(hMod, GET_HANDLE_MAPPER16 );
            lpWOWCallback16 =
                (LPWOWCALLBACK16)GetProcAddress(hMod, GET_CALLBACK16 );
        }

        if ( GetVdmPointer == NULL
          || lpWOWHandle16 == NULL
          || lpWOWHandle32 == NULL ) {

            ThunksInitialized = -1;
            return MMSYSERR_ERROR;

        } else {
            ThunksInitialized = 1;
        }
    }


    //
    //  Perform the requested function
    //

    switch (dwThunkId) {

        case vidThunkvideoMessage32:
            return videoMessage32((HVIDEO)dw1, (UINT)dw2, dw3, dw4);
            break;

        case vidThunkvideoGetNumDevs32:
            return videoGetNumDevs32();
            break;

        case vidThunkvideoOpen32:
            return videoOpen32((LPHVIDEO)dw1, dw2, dw3);
            break;

        case vidThunkvideoClose32:
            return videoClose32((HVIDEO)dw1);
            break;

	case vidThunkvideoGetDriverDesc32:
	{
	    LPSTR lpszName = NULL, lpszVer = NULL;
	    short cbName, cbVer;
	    DWORD dwRet;

	    cbName = (short) LOWORD(dw4);
	    cbVer = (short) HIWORD(dw4);

	    // for chicago, need to call WOW32GetVdmPointerFix
	    // (via getprocaddr!)

	    if ((dw2 != 0) && (cbName > 0)) {
		lpszName = WOW32ResolveMemory(dw2);
	    }
	    if ((dw3 != 0) && (cbVer > 0)) {
		lpszVer = WOW32ResolveMemory(dw3);
	    }


	    dwRet = capInternalGetDriverDescA(
	    		dw1,   // device id
			lpszName,
			cbName,
			lpszVer,
			cbVer);

#if 0 //should do this for chicago
	    if (lpszName) {
		WOWGetVDMPointerUnfix(dw2);
	    }
	    if (lpszVer) {
		WOWGetVDMPointerUnfix(dw3);
	    }
#endif
	    return dwRet;
	}


        default:
            return(0);
    }
}


DWORD FAR PASCAL videoMessage32(HVIDEO hVideo, UINT msg, DWORD dwP1, DWORD dwP2)
{
    StartThunk(videoMessage);
    DPF2(("\tvideoMessage id = %4X, lParam1 = %8X, lParam2 = %8X",
              msg, dwP1, dwP2));

   /*
    *  We ONLY support (and we only ever will support) messages which
    *  have ALREADY been defined.  New 32-bit driver messages will NOT
    *  be supported from 16-bit apps.
    */

    switch (msg) {
    case DVM_GETVIDEOAPIVER:
        {
            DWORD ApiVer;

            ReturnCode = videoMessage((HVIDEO)hVideo,
                                      (UINT)msg,
                                      (DWORD)&ApiVer,
                                      dwP2);

            if (ReturnCode == DV_ERR_OK) {
                CopyTo16Bit((LPVOID)dwP1, &ApiVer, sizeof(DWORD));
            }
        }
        break;

    case DVM_GETERRORTEXT:
        {
            VIDEO_GETERRORTEXT_PARMS vet;
            VIDEO_GETERRORTEXT_PARMS MappedVet;

           /*
            *  Get the parameter block
            */

            CopyTo32Bit((LPVOID)&vet, (LPVOID)dwP1, sizeof(vet));
            MappedVet = vet;

           /*
            *  Map the string pointer
            */

            MappedVet.lpText = WOW32ResolveMemory(vet.lpText);

            ReturnCode = videoMessage(hVideo,
                                      msg,
                                      (DWORD)&MappedVet,
                                      0);
        }
        break;

    case DVM_GET_CHANNEL_CAPS:
        {
            CHANNEL_CAPS Caps;

            ReturnCode = videoMessage((HVIDEO)hVideo,
                                      (UINT)msg,
                                      (DWORD)&Caps,
                                      dwP2);

           /*
            *  If successful return the data to the 16-bit app
            */

            if (ReturnCode == DV_ERR_OK) {
                 CopyTo16Bit((LPVOID)dwP1, (LPVOID)&Caps,
                             sizeof(Caps));
            }

        }
        break;

    case DVM_UPDATE:
        {
            ReturnCode = videoMessage(hVideo,
                                      msg,
                                      (DWORD)ThunkHWND(dwP1),
                                      (DWORD)ThunkHDC(dwP2));
        }
        break;

    case DVM_PALETTE:
    case DVM_PALETTERGB555:
    case DVM_FORMAT:
       /*
        *  This stuff all comes from videoConfigure
        *
        *  Let's hope this data is all DWORDs!
        */
        {
            VIDEOCONFIGPARMS vcp, MappedVcp;
            DWORD dwReturn;

            BOOL Ok;

            Ok = TRUE;

            CopyTo32Bit((LPVOID)&vcp, (LPVOID)dwP2, sizeof(vcp));
            MappedVcp.lpdwReturn = &dwReturn;
            MappedVcp.dwSize1 = vcp.dwSize1;
            MappedVcp.dwSize2 = vcp.dwSize2;

           /*
            *  Get some storage to store the answer
            */

            if (MappedVcp.dwSize1 != 0) {
                MappedVcp.lpData1 = (LPSTR)LocalAlloc(LPTR, MappedVcp.dwSize1);
                if (MappedVcp.lpData1 == NULL) {
                    Ok = FALSE;
                } else {
                    if (MappedVcp.dwSize2 != 0) {
                        MappedVcp.lpData2 = (LPSTR)LocalAlloc(LPTR, MappedVcp.dwSize2);
                        if (MappedVcp.lpData2 == NULL) {
                            Ok = FALSE;

                            if (MappedVcp.dwSize1 != 0) {
                                LocalFree((HLOCAL)MappedVcp.lpData1);
                            }
                        }
                    }
                }
            }

            if (Ok) {

                CopyTo32Bit(MappedVcp.lpData1, vcp.lpData1, MappedVcp.dwSize1);
                CopyTo32Bit(MappedVcp.lpData2, vcp.lpData2, MappedVcp.dwSize2);

                ReturnCode = videoMessage(hVideo,
                                          msg,
                                          dwP1,
                                          (DWORD)&MappedVcp);

                if (ReturnCode == DV_ERR_OK) {

                    if (vcp.lpdwReturn != NULL) {
                        CopyTo16Bit(vcp.lpdwReturn, MappedVcp.lpdwReturn,
                                    sizeof(DWORD));
                    }

                    CopyTo16Bit(vcp.lpData1, MappedVcp.lpData1, MappedVcp.dwSize1);
                    CopyTo16Bit(vcp.lpData2, MappedVcp.lpData2, MappedVcp.dwSize2);
                }

                if (MappedVcp.dwSize1 != 0) {
                    LocalFree((HLOCAL)MappedVcp.lpData1);
                }
                if (MappedVcp.dwSize2 != 0) {
                    LocalFree((HLOCAL)MappedVcp.lpData2);
                }
            } else {
                ReturnCode = DV_ERR_NOMEM;
            }
        }
        break;

    case DVM_CONFIGURESTORAGE:
        {
            LPSTR lpStrIdent;
            lpStrIdent = WOW32ResolveMemory(dwP1);

            ReturnCode = videoMessage(hVideo,
                                      msg,
                                      (DWORD)lpStrIdent,
                                      dwP2);

        }
        break;

    case DVM_DIALOG:
        {
            ReturnCode = videoMessage(hVideo,
                                      msg,
                                      (DWORD)ThunkHWND(dwP1),
                                      dwP2);
        }
        break;

    case DVM_SRC_RECT:
    case DVM_DST_RECT:
       /*
        *  If it's a query only then don't bother with the
        *  rectangle
        */

        if (dwP2 & VIDEO_CONFIGURE_QUERY) {
            ReturnCode = videoMessage(hVideo,
                                      msg,
                                      dwP1,
                                      dwP2);
        } else {

           /*
            *  The rectangle is regarded as 'in' and 'out'
            *  We need to translate between 16-bit and 32-bit rectangle structures
            */

            RECT_SHORT SRect;
            RECT Rect;

            CopyTo32Bit((LPVOID)&SRect, (LPVOID)dwP1, sizeof(SRect));

            SHORT_RECT_TO_RECT(Rect, SRect);

            ReturnCode = videoMessage(hVideo,
                                      msg,
                                      (DWORD)&Rect,
                                      dwP2);

            if (ReturnCode == DV_ERR_OK) {
                RECT_TO_SHORT_RECT(SRect, Rect);
                CopyTo16Bit((LPVOID)dwP1, (LPVOID)&SRect, sizeof(SRect));
            }
        }
        break;

    case DVM_STREAM_PREPAREHEADER:
    case DVM_STREAM_UNPREPAREHEADER:
    case DVM_FRAME:
    case DVM_STREAM_ADDBUFFER:
        {
            VIDEOHDR Hdr32;
            LPBYTE pData16, pData32;
            DWORD dwSize;

            dwSize = (UINT)msg == DVM_FRAME ? sizeof(VIDEOHDR) :
                                    min(dwP2, sizeof(VIDEOHDR));

            CopyTo32Bit((LPVOID)&Hdr32, (LPVOID)dwP1, dwSize);

            pData16 = Hdr32.lpData;

           /*
            *  Create a mapping for the pointer
            */

            pData32 = GetVdmPointer((DWORD)pData16, Hdr32.dwBufferLength, TRUE);
            Hdr32.lpData = pData32;

            if (msg == DVM_STREAM_ADDBUFFER) {

                PVIDEOHDR32 pHdr32;

               /*
                *  Allocate our callback structure and pass this
                *  as our header (suitably offset to the video header part).
                */

                pHdr32 = (PVIDEOHDR32)LocalAlloc(LPTR, sizeof(VIDEOHDR32));

                if (pHdr32 == NULL) {
                    ReturnCode = DV_ERR_NOMEM;
                } else {

                   /*
                    *  Remember the old header so we can pass it back
                    *  and the old data pointer so we can flush it
                    */

                    pHdr32->pHdr16 = (LPVOID)dwP1;

                    /*
                     *  Some systems can't handle GetVdmPointer at interrupt
                     *  time so get a pointer here
                     */

                    pHdr32->pHdr32 = WOW32ResolveMemory(dwP1);
                    pHdr32->lpData16 = pData16;
                    pHdr32->videoHdr = Hdr32;

                    ReturnCode = videoMessage(hVideo,
                                              msg,
                                              (DWORD)&pHdr32->videoHdr,
                                              dwP2);
                   /*
                    *  If everything was OK copy it back
                    */

                    if (ReturnCode == DV_ERR_OK) {
                        Hdr32.lpData = pData16;
                        CopyTo16Bit((LPVOID)dwP1, (LPVOID)&Hdr32, dwSize);
                    }
                }

            } else {

               /*
                *  Prepare/unprepare the header for 32bit
                */

                ReturnCode = videoMessage(hVideo,
                                          msg,
                                          (DWORD)&Hdr32,
                                          dwP2);

               /*
                *  If everything was OK copy it back
                */

                if (ReturnCode == DV_ERR_OK) {
                    Hdr32.lpData = pData16;
                    CopyTo16Bit((LPVOID)dwP1, (LPVOID)&Hdr32, dwSize);
                }
            }
        }
        break;

    case DVM_STREAM_RESET:
    case DVM_STREAM_FINI:
    case DVM_STREAM_STOP:
    case DVM_STREAM_START:

       /*
        *  Note that the MM_DRVM_CLOSE message will cause us to clean up our
        *  callback structures on DVM_STREAM_FINI.
        */

        ReturnCode = videoMessage(hVideo,
                                  msg,
                                  0,
                                  0);
        break;

    case DVM_STREAM_GETPOSITION:
        {
            MMTIME mmTime;
            MMTIME16 mmTime16;

            ReturnCode = videoMessage(hVideo,
                                      msg,
                                      (DWORD)&mmTime,
                                      sizeof(mmTime));

            if (ReturnCode == DV_ERR_OK) {
                mmTime16.wType = (WORD)mmTime.wType;
                CopyMemory((LPVOID)&mmTime16.u,
                           (LPVOID)&mmTime.u, sizeof(mmTime16.u));

                CopyTo16Bit((LPVOID)dwP1, (LPVOID)&mmTime16,
                            min(sizeof(mmTime16), dwP2));

            }
        }

        break;

    case DVM_STREAM_INIT:
        {
            VIDEO_STREAM_INIT_PARMS vsip;
            VIDEO_STREAM_INIT_PARMS * pvsip = WOW32ResolveMemory(dwP1);
            PVIDEOINSTANCEDATA32 pInst32;

#if 0
// always do callback
            if (!(pvsip->dwFlags & CALLBACK_TYPEMASK)) {
                // No callback wanted by the 16 bit code.  Pass call
                // straight through

                ReturnCode = videoMessage((HVIDEO)hVideo,
                                          (UINT)msg,
                                          (DWORD)pvsip,
                                          (DWORD)dwP2);

            } else
#endif
	    {
                // We set up a callback to a 32 bit routine, that in
                // turn will callback to the 16 bit function/window
                pInst32 = (PVIDEOINSTANCEDATA32)
                            LocalAlloc(LPTR, sizeof(VIDEOINSTANCEDATA32));

                if (pInst32 == NULL) {
                    ReturnCode = DV_ERR_NOMEM;
                } else {
                    CopyTo32Bit((LPVOID)&vsip, (LPVOID)dwP1,
                                min(sizeof(vsip), dwP2));

                    pInst32->dwFlags = vsip.dwFlags;
                    pInst32->dwCallbackInst = vsip.dwCallbackInst;
                    pInst32->dwCallback = vsip.dwCallback;
                    pInst32->hVideo = (HVIDEO16)vsip.hVideo;

                   /*
                    *  Make up our own parms.  Only set up a callback if
                    *  the user wanted one
                    */

                    vsip.dwCallback = (DWORD)MyVideoCallback;
                    vsip.dwFlags = (vsip.dwFlags & ~CALLBACK_TYPEMASK) |
                                   CALLBACK_FUNCTION;
                    vsip.dwCallbackInst = (DWORD)pInst32;

                    ReturnCode = videoMessage((HVIDEO)hVideo,
                                              (UINT)msg,
                                              (DWORD)&vsip,
                                              (DWORD)dwP2);

                    if (ReturnCode != DV_ERR_OK) {
                        LocalFree((HLOCAL)pInst32);
                    } else {
                        // The instance block will be freed off by the
                        // 32 bit callback routine when all over
                    }
                }
            }
        }
        break;

    case DVM_STREAM_GETERROR:
        {
            DWORD dwError;
            DWORD dwFramesSkipped;

            ReturnCode = videoMessage(hVideo,
                                      msg,
                                      (DWORD)&dwError,
                                      (DWORD)&dwFramesSkipped);

            if (ReturnCode == DV_ERR_OK) {
                CopyTo16Bit((LPVOID)dwP1, &dwError, sizeof(DWORD));
                CopyTo16Bit((LPVOID)dwP2, &dwFramesSkipped, sizeof(DWORD));
            }
        }
        break;

    default:
        DPF2(("videoMessage - Message not implemented %X\n", (UINT)msg));
        ReturnCode = DV_ERR_NOTSUPPORTED;

    }
    EndThunk();
}

INLINE DWORD FAR PASCAL videoGetNumDevs32(void)
{
    StartThunk(videoGetNumDevs);
    ReturnCode = videoGetNumDevs();
    EndThunk();
}

DWORD FAR PASCAL videoClose32(HVIDEO hVideo)
{
    StartThunk(videoClose)
    ReturnCode = videoClose(hVideo);
    EndThunk();
}

DWORD FAR PASCAL videoOpen32(LPHVIDEO lphVideo, DWORD dwDeviceID, DWORD dwFlags)
{
    HVIDEO  hVideo;
    StartThunk(videoOpen);

    ReturnCode = videoOpen(
                      &hVideo,
                      dwDeviceID,
                      dwFlags);

    if (ReturnCode == DV_ERR_OK) {
        lphVideo = WOW32ResolveMemory((PVOID)lphVideo);
        * (HVIDEO UNALIGNED *)lphVideo = hVideo;
    }
    EndThunk();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avicap\video.c ===
/****************************************************************************
    video.c

    Contains video APIs

    Copyright (c) Microsoft Corporation 1992 - 1995. All rights reserved.

****************************************************************************/

#include <windows.h>
#include <mmsystem.h>

#include "win32.h"
#include "msviddrv.h"
#include "msvideo.h"
#include <ivideo32.h>
#include "msvideoi.h"
#ifdef WIN32
#include <mmddk.h>
#include <stdlib.h>
#endif

/*****************************************************************************
 * Variables
 *
 ****************************************************************************/

SZCODE  szNull[]        = TEXT("");
SZCODE  szVideo[]       = TEXT("msvideo");
#ifndef WIN32
SZCODE  szDrivers[]     = "Drivers";
#else
STATICDT SZCODE  szDrivers[]     = DRIVERS_SECTION;
#endif

STATICDT SZCODE  szSystemIni[]   = TEXT("system.ini");

UINT    wTotalVideoDevs;                  // total video devices
extern HINSTANCE ghInstDll;               // our module handle


// ----------------------------------------------------------------------
//
// To clean up when a WOW app exits, we need to maintain a list of
// open devices. A list of HANDLEINFO structs is hung off g_pHandles.
// An item is added to the head of this list in videoOpen, and removed
// in videoClose. When a WOW app exits, winmm will call our WOWAppExit
// function: for each entry in the list that is owned by the exiting thread,
// we call videoClose to close the device and remove the handle entry.
//

// one of these per open handle
typedef struct _HANDLEINFO {
    HVIDEO hv;
    HANDLE hThread;
    struct _HANDLEINFO * pNext;
} HANDLEINFO, * PHANDLEINFO;

// head of global list of open handles
PHANDLEINFO g_pHandles;

// critical section that protects global list
CRITICAL_SECTION csHandles;

// init list and critsec
void
videoInitHandleList()
{
    g_pHandles = NULL;
    InitializeCriticalSection(&csHandles);
}

// finished with critsec list
void
videoDeleteHandleList()
{
    // don't need critical section as no-one else can be using
    // it now (we are about to delete the critsec)

    // empty everything out of the list
    while (g_pHandles) {
        videoClose(g_pHandles->hv);
    }

    DeleteCriticalSection(&csHandles);
}



// add a handle to the list
void
videoAddHandle(HVIDEO hv)
{
    PHANDLEINFO pinfo = HeapAlloc(GetProcessHeap(), 0, sizeof(HANDLEINFO));

    if (!pinfo) {
        // couldn't allocate the memory - best thing to do is
        // forget it - nothing bad will happen except that we
        // might possibly fail to clean up if this is a wow app and
        // it exits without closing the capture device.
        return;
    }

    pinfo->hv = hv;
    pinfo->hThread = GetCurrentTask();

    EnterCriticalSection(&csHandles);

    pinfo->pNext = g_pHandles;
    g_pHandles = pinfo;

    LeaveCriticalSection(&csHandles);
}

// delete an entry from the handle list given the HVIDEO.
// caller must close the HVIDEO
// should be called before closing (in case the HVIDEO is reassigned after
// closing and before removing from the list
void
videoDelete(HVIDEO hv)
{
    PHANDLEINFO * ppNext;
    PHANDLEINFO pinfo;

    EnterCriticalSection(&csHandles);

    ppNext = &g_pHandles;
    while (*ppNext) {
        if ((*ppNext)->hv == hv) {
            pinfo = *ppNext;
            *ppNext = pinfo->pNext;
            HeapFree(GetProcessHeap(), 0, pinfo);
            break;

        } else {
            ppNext = &(*ppNext)->pNext;
        }
    }

    LeaveCriticalSection(&csHandles);
}

// close any handles open by this task
void
AppCleanup(HANDLE hTask)
{
    PHANDLEINFO pinfo;

    EnterCriticalSection(&csHandles);

    pinfo = g_pHandles;
    while (pinfo) {

        if (pinfo->hThread == hTask) {

            // get the next pointer before videoClose deletes the entry
            HVIDEO hv = pinfo->hv;
            pinfo = pinfo->pNext;

            videoClose(hv);
        } else {
            pinfo = pinfo->pNext;
        }
    }

    LeaveCriticalSection(&csHandles);
}


// ----------------------------------------------------------------------




/*****************************************************************************
 * @doc INTERNAL  VIDEO validation code for VIDEOHDRs
 ****************************************************************************/

#define IsVideoHeaderPrepared(hVideo, lpwh)      ((lpwh)->dwFlags &  VHDR_PREPARED)
#define MarkVideoHeaderPrepared(hVideo, lpwh)    ((lpwh)->dwFlags |= VHDR_PREPARED)
#define MarkVideoHeaderUnprepared(hVideo, lpwh)  ((lpwh)->dwFlags &=~VHDR_PREPARED)



/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @func DWORD | videoMessage | This function sends messages to a
 *   video device channel.
 *
 * @parm HVIDEO | hVideo | Specifies the handle to the video device channel.
 *
 * @parm UINT | wMsg | Specifies the message to send.
 *
 * @parm DWORD | dwP1 | Specifies the first parameter for the message.
 *
 * @parm DWORD | dwP2 | Specifies the second parameter for the message.
 *
 * @rdesc Returns the message specific value returned from the driver.
 *
 * @comm This function is used for configuration messages such as
 *      <m DVM_SRC_RECT> and <m DVM_DST_RECT>, and
 *      device specific messages.
 *
 * @xref <f videoConfigure>
 *
 ****************************************************************************/
DWORD WINAPI videoMessage(HVIDEO hVideo, UINT msg, DWORD dwP1, DWORD dwP2)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    return SendDriverMessage ((HDRVR)hVideo, msg, dwP1, dwP2);
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoGetNumDevs | This function returns the number of MSVIDEO
 *   devices installed.
 *
 * @rdesc Returns the number of MSVIDEO devices listed in the
 *  [drivers] (or [drivers32] for NT) section of the SYSTEM.INI file.
 *
 * @comm Because the indexes of the MSVIDEO devices in the SYSTEM.INI
 *       file can be non-contiguous, applications should not assume
 *       the indexes range between zero and the number of devices minus
 *       one.
 *
 * @xref <f videoOpen>
 ****************************************************************************/
DWORD WINAPI videoGetNumDevs(void)
{
    TCHAR szKey[(sizeof(szVideo)/sizeof(TCHAR)) + 2];
    TCHAR szbuf[3];
    int i;

    wTotalVideoDevs = 0;

    lstrcpy(szKey, szVideo);
    szKey[(sizeof(szVideo)/sizeof(TCHAR)) - 1] = (TCHAR) 0;
    szKey[sizeof(szVideo)/sizeof(TCHAR)] = (TCHAR) 0;
    for (i=0; i < MAXVIDEODRIVERS; i++) {
        if (GetPrivateProfileString(szDrivers,szKey,szNull,
                szbuf,sizeof(szbuf)/sizeof(TCHAR),szSystemIni))
            wTotalVideoDevs++;

        szKey[(sizeof(szVideo)/sizeof(TCHAR))-1] = (TCHAR) TEXT('1'+ i); // advance driver ordinal
    }
    return (DWORD)wTotalVideoDevs;
}

/*****************************************************************************
 * @doc EXTERNAL VIDEO
 *
 * @func DWORD | videoGetErrorText | This function retrieves a
 *   description of the error identified by the error number.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *	This might be NULL if the error is not device specific.
 *
 * @parm UINT | wError | Specifies the error number.
 *
 * @parm LPSTR | lpText | Specifies a far pointer to a buffer used to
 *       return the zero-terminated string corresponding to the error number.
 *
 * @parm UINT | wSize | Specifies the length, in bytes, of the buffer
 *       referenced by <p lpText>.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following error is defined:
 *   @flag DV_ERR_BADERRNUM | Specified error number is out of range.
 *   @flag DV_ERR_SIZEFIELD | The return buffer is not large enough
 *         to handle the error text.
 *
 * @comm If the error description is longer than the buffer,
 *   the description is truncated. The returned error string is always
 *   zero-terminated. If <p wSize> is zero, nothing is copied and zero
 *   is returned.
 ****************************************************************************/
#ifdef UNICODE  // Translate UNICODE response to ansi
DWORD WINAPI videoGetErrorTextA(HVIDEO hVideo, UINT wError,
			LPSTR lpText, UINT wSize)
{
    VIDEO_GETERRORTEXT_PARMS vet;

    if (IsBadWritePtr (lpText, wSize))
        return DV_ERR_PARAM1;

    lpText[0] = 0;
    if (((wError >= DV_ERR_BASE) && (wError <= DV_ERR_LASTERROR))) {
        if (wSize > 1) {
            if (!LoadStringA(ghInstDll, wError, lpText, wSize))
                return DV_ERR_BADERRNUM;
            else
                return DV_ERR_OK;
        }
        else
            return DV_ERR_SIZEFIELD;
    }
    else if (wError >= DV_ERR_USER_MSG && hVideo) {
        DWORD dwResult;
        LPWSTR lpwstr = LocalAlloc(LPTR, wSize*sizeof(WCHAR));
        if (NULL == lpwstr) {
            return(DV_ERR_NOMEM);
        }
        vet.dwError = (DWORD) wError;
        vet.lpText = lpwstr;
        vet.dwLength = (DWORD) wSize;
        dwResult = videoMessage (hVideo, DVM_GETERRORTEXT, (DWORD) (LPVOID) &vet,
                        (DWORD) NULL);
        if (DV_ERR_OK == dwResult) {
            Iwcstombs(lpText, lpwstr, wSize);
        }
        LocalFree(lpwstr);
        return(dwResult);
    }
    else
        return DV_ERR_BADERRNUM;
}
#endif //UNICODE

//
// The unicode/Win16 equivalent of the above
//

DWORD WINAPI videoGetErrorText(HVIDEO hVideo, UINT wError,
			LPTSTR lpText, UINT wSize)
{
    VIDEO_GETERRORTEXT_PARMS vet;
    lpText[0] = 0;

    if (((wError > DV_ERR_BASE) && (wError <= DV_ERR_LASTERROR))) {
        if (wSize > 1) {
            if (!LoadString(ghInstDll, wError, lpText, wSize))
                return DV_ERR_BADERRNUM;
            else
                return DV_ERR_OK;
        }
        else
            return DV_ERR_SIZEFIELD;
    }
    else if (wError >= DV_ERR_USER_MSG && hVideo) {
        vet.dwError = (DWORD) wError;
        vet.lpText = lpText;
        vet.dwLength = (DWORD) wSize;
        return videoMessage (hVideo, DVM_GETERRORTEXT, (DWORD) (LPVOID) &vet,
                        (DWORD) NULL);
    }
    else
        return DV_ERR_BADERRNUM;
}


/*****************************************************************************
 * @doc EXTERNAL VIDEO
 *
 * @func DWORD | videoGetChannelCaps | This function retrieves a
 *   description of the capabilities of a channel.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @parm LPCHANNEL_CAPS | lpChannelCaps | Specifies a far pointer to a
 *      <t CHANNEL_CAPS> structure.
 *
 * @parm DWORD | dwSize | Specifies the size, in bytes, of the
 *       <t CHANNEL_CAPS> structure.
 *
 * @rdesc Returns zero if the function is successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag DV_ERR_UNSUPPORTED | Function is not supported.
 *
 * @comm The <t CHANNEL_CAPS> structure returns the capability
 *   information. For example, capability information might
 *   include whether or not the channel can crop and scale images,
 *   or show overlay.
 ****************************************************************************/
DWORD WINAPI videoGetChannelCaps(HVIDEO hVideo, LPCHANNEL_CAPS lpChannelCaps,
			DWORD dwSize)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if (IsBadWritePtr (lpChannelCaps, sizeof (CHANNEL_CAPS)))
        return DV_ERR_PARAM1;

    // _fmemset (lpChannelCaps, 0, sizeof (CHANNEL_CAPS));

    lpChannelCaps->dwFlags = 0;
    lpChannelCaps->dwSrcRectXMod = 0;
    lpChannelCaps->dwSrcRectYMod = 0;
    lpChannelCaps->dwSrcRectWidthMod = 0;
    lpChannelCaps->dwSrcRectHeightMod = 0;
    lpChannelCaps->dwDstRectXMod = 0;
    lpChannelCaps->dwDstRectYMod = 0;
    lpChannelCaps->dwDstRectWidthMod = 0;
    lpChannelCaps->dwDstRectHeightMod = 0;

    return videoMessage(hVideo, DVM_GET_CHANNEL_CAPS, (DWORD) lpChannelCaps,
	    (DWORD) dwSize);
}


/*****************************************************************************
 * @doc EXTERNAL VIDEO
 *
 * @func DWORD | videoUpdate | This function directs a channel to
 *   repaint the display.  It applies only to VIDEO_EXTERNALOUT channels.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @parm HWND | hWnd | Specifies the handle of the window to be used
 *      by the channel for image display.
 *
 * @parm HDC | hDC | Specifies a handle to a device context.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_UNSUPPORTED | Specified message is unsupported.
 *   @flag DV_ERR_INVALHANDLE | Indicates the device handle specified is invalid.
 *
 * @comm This message is normally sent
 *   whenever the client window receives a <m WM_MOVE>, <m WM_SIZE>,
 *   or <m WM_PAINT> message.
 ****************************************************************************/
DWORD WINAPI videoUpdate (HVIDEO hVideo, HWND hWnd, HDC hDC)
{
    if ((!hVideo) || (!hWnd) || (!hDC) )
        return DV_ERR_INVALHANDLE;

    return videoMessage(hVideo, DVM_UPDATE, (DWORD) hWnd, (DWORD) hDC);
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoOpen | This function opens a channel on the
 *  specified video device.
 *
 * @parm LPHVIDEO | lphvideo | Specifies a far pointer to a buffer
 *   used to return an <t HVIDEO> handle. The video capture driver
 *   uses this location to return
 *   a handle that uniquely identifies the opened video device channel.
 *   Use the returned handle to identify the device channel when
 *   calling other video functions.
 *
 * @parm DWORD | dwDeviceID | Identifies the video device to open.
 *      The value of <p dwDeviceID> varies from zero to one less
 *      than the number of video capture devices installed in the system.
 *
 * @parm DWORD | dwFlags | Specifies flags for opening the device.
 *      The following flags are defined:
 *
 *   @flag VIDEO_EXTERNALIN| Specifies the channel is opened
 *	     for external input. Typically, external input channels
 *      capture images into a frame buffer.
 *
 *   @flag VIDEO_EXTERNALOUT| Specifies the channel is opened
 *      for external output. Typically, external output channels
 *      display images stored in a frame buffer on an auxilary monitor
 *      or overlay.
 *
 *   @flag VIDEO_IN| Specifies the channel is opened
 *      for video input. Video input channels transfer images
 *      from a frame buffer to system memory buffers.
 *
 *   @flag VIDEO_OUT| Specifies the channel is opened
 *      for video output. Video output channels transfer images
 *      from system memory buffers to a frame buffer.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_BADDEVICEID | Indicates the specified device ID is out of range.
 *   @flag DV_ERR_ALLOCATED | Indicates the specified resource is already allocated.
 *   @flag DV_ERR_NOMEM | Indicates the device is unable to allocate or lock memory.
 *
 * @comm
 *   At a minimum, all capture drivers support a VIDEO_EXTERNALIN
 *   and a VIDEO_IN channel.
 *   Use <f videoGetNumDevs> to determine the number of video
 *   devices present in the system.
 *
 * @xref <f videoClose>
 ****************************************************************************/
DWORD WINAPI videoOpen (LPHVIDEO lphVideo, DWORD dwDeviceID, DWORD dwFlags)
{
    TCHAR szKey[sizeof(szVideo)/sizeof(TCHAR) + 2];
    TCHAR szbuf[128];
    UINT w;
    VIDEO_OPEN_PARMS vop;       // Same as IC_OPEN struct!!!
    DWORD dwVersion = VIDEOAPIVERSION;

    if (IsBadWritePtr ((LPVOID) lphVideo, sizeof (HVIDEO)) )
        return DV_ERR_PARAM1;

    vop.dwSize = sizeof (VIDEO_OPEN_PARMS);
    vop.fccType = OPEN_TYPE_VCAP;       // "vcap"
    vop.fccComp = 0L;
    vop.dwVersion = VIDEOAPIVERSION;
    vop.dwFlags = dwFlags;      // In, Out, External In, External Out
    vop.dwError = DV_ERR_OK;

    w = (UINT)dwDeviceID;
    *lphVideo = NULL;

    if (!wTotalVideoDevs)   // trying to open without finding how many devs.
        videoGetNumDevs();

    if (!wTotalVideoDevs)              // No drivers installed
        return DV_ERR_BADINSTALL;

    if (w >= MAXVIDEODRIVERS)
        return DV_ERR_BADDEVICEID;

    lstrcpy(szKey, szVideo);
    szKey[(sizeof(szVideo)/sizeof(TCHAR)) - 1] = (TCHAR)0;
    if( w > 0 ) {
        szKey[(sizeof(szVideo)/sizeof(TCHAR))] = (TCHAR)0;
        szKey[(sizeof(szVideo)/sizeof(TCHAR))-1] = (TCHAR) TEXT('1' + (w-1) );  // driver ordinal
    }
    if (GetPrivateProfileString(szDrivers, szKey, szNull,
                szbuf, sizeof(szbuf)/sizeof(TCHAR), szSystemIni)) {

#ifdef THIS_IS_ANCIENT_CODE
        // Removed for VFW1.1
        // Only early Alpha 1.0 drivers required this...

        // Check driver version number by doing a configuration open...
        // Version 1 used LPARAM = dwFlags
        // Version 2 uses LPARAM = LPVIDEO_OPEN_PARMS

        if (hVideoTemp = OpenDriver(szKey, szDrivers, (LPARAM) NULL)) {
            HVIDEO hVideoTemp;

            // Version 1 drivers had the added bug of returning
            // the version from this message, instead of in
            // lParam1
            if (videoMessage (hVideoTemp, DVM_GETVIDEOAPIVER,
                        (LPARAM) (LPVOID) &dwVersion, 0L) == 1)
                dwVersion = 1;
            CloseDriver(hVideoTemp, 0L, 0L );
        }

        if (dwVersion == 1)
            *lphVideo = OpenDriver(szKey, szDrivers, dwFlags);
        else
#endif // THIS_IS_ANCIENT_CODE

        *lphVideo = (HVIDEO)OpenDriver(szKey, szDrivers, (LPARAM) (LPVOID) &vop);

	if( ! *lphVideo ) {
            if (vop.dwError)    // if driver returned an error code...
                return vop.dwError;
            else {
#ifdef WIN32
		if (GetFileAttributes(szbuf) == (DWORD) -1)
#else
                OFSTRUCT of;

                if (OpenFile (szbuf, &of, OF_EXIST) == HFILE_ERROR)
#endif
                    return (DV_ERR_BADINSTALL);
                else
                    return (DV_ERR_NOTDETECTED);
            }
	}
    } else {
        return( DV_ERR_BADINSTALL );
    }

    videoAddHandle(*lphVideo);

    return DV_ERR_OK;

}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoClose | This function closes the specified video
 *   device channel.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *  If this function is successful, the handle is invalid
 *   after this call.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag DV_ERR_NONSPECIFIC | The driver failed to close the channel.
 *
 * @comm If buffers have been sent with <f videoStreamAddBuffer> and
 *   they haven't been returned to the application,
 *   the close operation fails. You can use <f videoStreamReset> to mark all
 *   pending buffers as done.
 *
 * @xref <f videoOpen> <f videoStreamInit> <f videoStreamFini> <f videoStreamReset>
 ****************************************************************************/
DWORD WINAPI videoClose (HVIDEO hVideo)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    videoDelete(hVideo);

    return (CloseDriver((HDRVR)hVideo, 0L, 0L ) ? DV_ERR_OK : DV_ERR_NONSPECIFIC);
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoConfigure | This function sets or retrieves
 *      the options for a configurable driver.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @parm UINT | msg  | Specifies the option to set or retrieve. The
 *       following options are defined:
 *
 *   @flag DVM_PALETTE | Indicates a palette is being sent to the driver
 *         or retrieved from the driver.
 *
 *   @flag DVM_PALETTERGB555 | Indicates an RGB555 palette is being
 *         sent to the driver.
 *
 *   @flag DVM_FORMAT | Indicates format information is being sent to
 *         the driver or retrieved from the driver.
 *
 * @parm DWORD | dwFlags | Specifies flags for configuring or
 *   interrogating the device driver. The following flags are defined:
 *
 *   @flag VIDEO_CONFIGURE_SET | Indicates values are being sent to the driver.
 *
 *   @flag VIDEO_CONFIGURE_GET | Indicates values are being obtained from the driver.
 *
 *   @flag VIDEO_CONFIGURE_QUERY | Determines if the
 *      driver supports the option specified by <p msg>. This flag
 *      should be combined with either the VIDEO_CONFIGURE_SET or
 *      VIDEO_CONFIGURE_GET flag. If this flag is
 *      set, the <p lpData1>, <p dwSize1>, <p lpData2>, and <p dwSize2>
 *      parameters are ignored.
 *
 *   @flag VIDEO_CONFIGURE_QUERYSIZE | Returns the size, in bytes,
 *      of the configuration option in <p lpdwReturn>. This flag is only valid if
 *      the VIDEO_CONFIGURE_GET flag is also set.
 *
 *   @flag VIDEO_CONFIGURE_CURRENT | Requests the current value.
 *      This flag is valid only if  the VIDEO_CONFIGURE_GET flag is also set.
 *   @flag VIDEO_CONFIGURE_NOMINAL | Requests the nominal value.
 *      This flag is valid only if  the VIDEO_CONFIGURE_GET flag is also set.
 *   @flag VIDEO_CONFIGURE_MIN | Requests the minimum value.
 *      This flag is valid only if  the VIDEO_CONFIGURE_GET flag is also set.
 *   @flag VIDEO_CONFIGURE_MAX | Get the maximum value.
 *      This flag is valid only if  the VIDEO_CONFIGURE_GET flag is also set.
 *	
 * @parm LPDWORD | lpdwReturn  | Points to a DWORD used for returning information
 *      from the driver.  If
 *      the VIDEO_CONFIGURE_QUERYSIZE flag is set, <p lpdwReturn> is
 *      filled with the size of the configuration option.
 *
 * @parm LPVOID | lpData1  |Specifies a pointer to message specific data.
 *
 * @parm DWORD | dwSize1  | Specifies the size, in bytes, of the <p lpData1>
 *       buffer.
 *
 * @parm LPVOID | lpData2  | Specifies a pointer to message specific data.
 *
 * @parm DWORD | dwSize2  | Specifies the size, in bytes, of the <p lpData2>
 *       buffer.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag DV_ERR_NOTSUPPORTED | Function is not supported.
 *
 * @xref <f videoOpen> <f videoMessage>
 *
 ****************************************************************************/
DWORD WINAPI videoConfigure (HVIDEO hVideo, UINT msg, DWORD dwFlags,
		LPDWORD lpdwReturn, LPVOID lpData1, DWORD dwSize1,
                LPVOID lpData2, DWORD dwSize2)
{
    VIDEOCONFIGPARMS    vcp;

    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if (lpData1)
        if (IsBadHugeReadPtr (lpData1, dwSize1))
            return DV_ERR_CONFIG1;

    if (lpData2)
        if (IsBadHugeReadPtr (lpData2, dwSize2))
            return DV_ERR_CONFIG2;

    if (dwFlags & VIDEO_CONFIGURE_QUERYSIZE) {
        if (!lpdwReturn)
            return DV_ERR_NONSPECIFIC;
        if (IsBadWritePtr (lpdwReturn, sizeof (DWORD)) )
            return DV_ERR_NONSPECIFIC;
    }

    vcp.lpdwReturn = lpdwReturn;
    vcp.lpData1 = lpData1;
    vcp.dwSize1 = dwSize1;
    vcp.lpData2 = lpData2;
    vcp.dwSize2 = dwSize2;

    return videoMessage(hVideo, msg, dwFlags,
	    (DWORD)(LPVIDEOCONFIGPARMS)&vcp );
}



/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoConfigureStorage | This function saves or loads
 *	     all configurable options for a channel.  Options
 *      can be saved and recalled for each application or each application
 *      instance.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @parm LPSTR | lpstrIdent  | Identifies the application or instance.
 *      Use an arbitrary string which uniquely identifies your application
 *      or instance.
 *
 * @parm DWORD | dwFlags | Specifies any flags for the function. The following
 *   flags are defined:
 *   @flag VIDEO_CONFIGURE_GET | Requests that the values be loaded.
 *   @flag VIDEO_CONFIGURE_SET | Requests that the values be saved.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag DV_ERR_NOTSUPPORTED | Function is not supported.
 *
 * @comm The method used by a driver to save configuration options is
 *      device dependent.
 *
 * @xref <f videoOpen>
 ****************************************************************************/
#ifdef UNICODE
DWORD WINAPI videoConfigureStorageA(HVIDEO hVideo,
			LPSTR lpstrIdent, DWORD dwFlags)
{
    DWORD ret;
    LPWSTR lpwstr;

    if (!hVideo)
        return DV_ERR_INVALHANDLE;


    // Convert the input string to Unicode
    // Call the driver, free the Unicode string and return the result
    ret = strlen(lpstrIdent);
    lpwstr = LocalAlloc(LPTR, ret*sizeof(WCHAR));
    if (!lpwstr) {
        return(DV_ERR_NOMEM);
    }

    Imbstowcs(lpwstr, lpstrIdent, ret);

    ret = videoMessage(hVideo, DVM_CONFIGURESTORAGE,
	    (DWORD)lpwstr, dwFlags);

    LocalFree(lpwstr);
    return(ret);
}

#endif

// On NT the header file will have ensured that videoConfigureStorage is
// defined by a macro to videoConfigureStorageW
DWORD WINAPI videoConfigureStorage(HVIDEO hVideo,
			LPWSTR lpstrIdent, DWORD dwFlags)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    return videoMessage(hVideo, DVM_CONFIGURESTORAGE,
	    (DWORD)lpstrIdent, dwFlags);
}




/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoDialog | This function displays a channel-specific
 *     dialog box used to set configuration parameters.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @parm HWND | hWndParent | Specifies the parent window handle.
 *
 * @parm DWORD | dwFlags | Specifies flags for the dialog box. The
 *   following flag is defined:
 *   @flag VIDEO_DLG_QUERY | If this flag is set, the driver immediately
 *	     returns zero if it supplies a dialog box for the channel,
 *           or DV_ERR_NOTSUPPORTED if it does not.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag DV_ERR_NOTSUPPORTED | Function is not supported.
 *
 * @comm Typically, each dialog box displayed by this
 *      function lets the user select options appropriate for the channel.
 *      For example, a VIDEO_IN channel dialog box lets the user select
 *      the image dimensions and bit depth.
 *
 * @xref <f videoOpen> <f videoConfigureStorage>
 ****************************************************************************/
DWORD WINAPI videoDialog (HVIDEO hVideo, HWND hWndParent, DWORD dwFlags)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if ((!hWndParent) || (!IsWindow (hWndParent)) )
        return DV_ERR_INVALHANDLE;

    return videoMessage(hVideo, DVM_DIALOG, (DWORD)hWndParent, dwFlags);
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////


/*****************************************************************************
 * @doc INTERNAL  VIDEO
 *
 * @api DWORD | videoPrepareHeader | This function prepares the
 *	header and data
 *	by performing a <f GlobalPageLock>.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it
 *   specifies an error number.
 ****************************************************************************/
DWORD WINAPI videoPrepareHeader(LPVIDEOHDR lpVideoHdr, DWORD dwSize)
{
    if (!HugePageLock(lpVideoHdr, (DWORD)sizeof(VIDEOHDR)))
        return DV_ERR_NOMEM;

    if (!HugePageLock(lpVideoHdr->lpData, lpVideoHdr->dwBufferLength)) {
        HugePageUnlock(lpVideoHdr, (DWORD)sizeof(VIDEOHDR));
        return DV_ERR_NOMEM;
    }

    lpVideoHdr->dwFlags |= VHDR_PREPARED;

    return DV_ERR_OK;
}

/*****************************************************************************
 * @doc INTERNAL  VIDEO
 *
 * @api DWORD | videoUnprepareHeader | This function unprepares the header and
 *   data if the driver returns DV_ERR_NOTSUPPORTED.
 *
 * @rdesc Currently always returns DV_ERR_OK.
 ****************************************************************************/
DWORD WINAPI videoUnprepareHeader(LPVIDEOHDR lpVideoHdr, DWORD dwSize)
{

    HugePageUnlock(lpVideoHdr->lpData, lpVideoHdr->dwBufferLength);
    HugePageUnlock(lpVideoHdr, (DWORD)sizeof(VIDEOHDR));

    lpVideoHdr->dwFlags &= ~VHDR_PREPARED;

    return DV_ERR_OK;
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamAllocHdrAndBuffer | This function is used to allow
 *      drivers to optionally allocate video buffers.  Normally, the client
 *      application is responsible for allocating buffer memory, but devices
 *      which have on-board memory may optionally allocate headers and buffers
 *      using this function. Generally, this will avoid an additional data copy,
 *      resulting in faster capture rates.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video
 *   device channel.
 *
 * @parm LPVIDEOHDR FAR * | plpvideoHdr | Specifies a pointer to the address of a
 *   <t VIDEOHDR> structure.  The driver saves the buffer address in this
 *   location, or NULL if it cannot allocate a buffer.
 *
 * @parm DWORD | dwSize | Specifies the size of the <t VIDEOHDR> structure
 *      and associated video buffer in bytes.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Indicates the specified device handle is invalid.
 *   @flag DV_ERR_NOMEM | Indicates the device is unable to allocate or lock memory.
 *   @flag DV_ERR_NOTSUPPORTED | Indicates the driver does not have on-board memory.
 *
 * @comm If the driver
 *   allocates buffers via this method, the <f videoStreamPrepareHeader> and
 *   <f videoStreamUnprepareHeader> functions should be used.
 *
 *   The buffer allocated must be accessible for DMA by the host.
 *
 * @xref <f videoStreamPrepareHeader>
 ****************************************************************************/
DWORD WINAPI videoStreamAllocHdrAndBuffer(HVIDEO hVideo,
		LPVIDEOHDR FAR * plpvideoHdr, DWORD dwSize)
{
#ifdef OBSOLETE
    DWORD         wRet;

    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if (IsBadWritePtr (plpvideoHdr, sizeof (VIDEOHDR *)) )
        return DV_ERR_PARAM1;

    *plpvideoHdr = NULL;        // Init to NULL ptr

    wRet = (DWORD)videoMessage((HVIDEO)hVideo, DVM_STREAM_ALLOCHDRANDBUFFER,
            (DWORD)plpvideoHdr, (DWORD)dwSize);

    if (*plpvideoHdr == NULL ||
                IsBadHugeWritePtr (*plpvideoHdr, dwSize)) {
        DebugErr(DBF_WARNING,"videoStreamAllocHdrAndBuffer: Allocation failed.");
        *plpvideoHdr = NULL;
        return wRet;
    }

    if (IsVideoHeaderPrepared(HVIDEO, *plpvideoHdr))
    {
        DebugErr(DBF_WARNING,"videoStreamAllocHdrAndBuffer: header is already prepared.");
        return DV_ERR_OK;
    }

    (*plpvideoHdr)->dwFlags = 0;

    if (wRet == DV_ERR_OK)
        MarkVideoHeaderPrepared(hVideo, *plpvideoHdr);

    return wRet;
#endif
    return DV_ERR_NOTSUPPORTED;
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamFreeHdrAndBuffer | This function is used to free
 *      buffers allocated by the driver using the <f videoStreamAllocHdrAndBuffer>
 *      function.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video
 *   device channel.
 *
 * @parm LPVIDEOHDR | lpvideoHdr | Specifies a pointer to the
 *   <t VIDEOHDR> structure and associated buffer to be freed.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Indicates the specified device handle is invalid.
 *   @flag DV_ERR_NOTSUPPORTED | Indicates the driver does not have on-board memory.
 *
 * @comm If the driver
 *   allocates buffers via this method, the <f videoStreamPrepareHeader> and
 *   <f videoStreamUnprepareHeader> functions should be used.
 *
 * @xref <f videoStreamPrepareHeader>
 ****************************************************************************/

DWORD WINAPI videoStreamFreeHdrAndBuffer(HVIDEO hVideo,
		LPVIDEOHDR lpvideoHdr)
{
#ifdef OBSOLETE
    DWORD         wRet;

    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if (IsBadWritePtr (lpvideoHdr, sizeof (VIDEOHDR)) )
        return DV_ERR_PARAM1;

    if (lpvideoHdr->dwFlags & VHDR_INQUEUE)
    {
        DebugErr(DBF_WARNING, "videoStreamFreeHdrAndBuffer: buffer still in queue.");
        return DV_ERR_STILLPLAYING;
    }

    if (!IsVideoHeaderPrepared(hVideo, lpvideoHdr))
    {
        DebugErr(DBF_WARNING,"videoStreamFreeHdrAndBuffer: header is not prepared.");
    }

    wRet = (DWORD)videoMessage((HVIDEO)hVideo, DVM_STREAM_FREEHDRANDBUFFER,
            (DWORD)lpvideoHdr, (DWORD)0);

    if (wRet != DV_ERR_OK)
    {
        DebugErr(DBF_WARNING,"videoStreamFreeHdrAndBuffer: Error freeing buffer.");
    }

    return wRet;
#endif
    return DV_ERR_NOTSUPPORTED;
}


/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamPrepareHeader | This function prepares a buffer
 *   for video streaming.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video
 *   device channel.
 *
 * @parm LPVIDEOHDR | lpvideoHdr | Specifies a pointer to a
 *   <t VIDEOHDR> structure identifying the buffer to be prepared.
 *
 * @parm DWORD | dwSize | Specifies the size of the <t VIDEOHDR> structure in bytes.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Indicates the specified device handle is invalid.
 *   @flag DV_ERR_NOMEM | Indicates the device is unable to allocate or lock memory.
 *
 * @comm Use this function after <f videoStreamInit> or
 *   after <f videoStreamReset> to prepare the data buffers
 *   for streaming data.
 *
 *   The <t VIDEOHDR> data structure and the data block pointed to by its
 *   <e VIDEOHDR.lpData> member must be allocated with <f GlobalAlloc> using the
 *   GMEM_MOVEABLE and GMEM_SHARE flags, and locked with <f GlobalLock>.
 *   Preparing a header that has already been prepared will have no effect
 *   and the function will return zero. Typically, this function is used
 *   to ensure that the buffer will be available for use at interrupt time.
 *
 * @xref <f videoStreamUnprepareHeader>
 ****************************************************************************/
DWORD WINAPI videoStreamPrepareHeader(HVIDEO hVideo,
		LPVIDEOHDR lpvideoHdr, DWORD dwSize)
{
    DWORD         wRet;

    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if (IsBadWritePtr (lpvideoHdr, sizeof (VIDEOHDR)) )
        return DV_ERR_PARAM1;

    if (IsVideoHeaderPrepared(HVIDEO, lpvideoHdr))
    {
        DebugErr(DBF_WARNING,"videoStreamPrepareHeader: header is already prepared.");
        return DV_ERR_OK;
    }

    lpvideoHdr->dwFlags = 0;

    wRet = (DWORD)videoMessage((HVIDEO)hVideo, DVM_STREAM_PREPAREHEADER,
            (DWORD)lpvideoHdr, (DWORD)dwSize);

    if (wRet == DV_ERR_NOTSUPPORTED)
        wRet = videoPrepareHeader(lpvideoHdr, dwSize);

    if (wRet == DV_ERR_OK)
        MarkVideoHeaderPrepared(hVideo, lpvideoHdr);

    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamUnprepareHeader | This function clears the
 *  preparation performed by <f videoStreamPrepareHeader>.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video
 *   device channel.
 *
 * @parm LPVIDEOHDR | lpvideoHdr |  Specifies a pointer to a <t VIDEOHDR>
 *   structure identifying the data buffer to be unprepared.
 *
 * @parm DWORD | dwSize | Specifies the size of the <t VIDEOHDR> structure in bytes.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Indicates the device handle specified is invalid.
 *   @flag DV_ERR_STILLPLAYING | Indicates the structure identified by <p lpvideoHdr>
 *   is still in the queue.
 *
 * @comm This function is the complementary function to <f videoStreamPrepareHeader>.
 *   You must call this function before freeing the data buffer with <f GlobalFree>.
 *   After passing a buffer to the device driver with <f videoStreamAddBuffer>, you
 *   must wait until the driver is finished with the buffer before calling
 *   <f videoStreamUnprepareHeader>. Unpreparing a buffer that has not been
 *   prepared or has been already unprepared has no effect,
 *   and the function returns zero.
 *
 * @xref <f videoStreamPrepareHeader>
 ****************************************************************************/
DWORD WINAPI videoStreamUnprepareHeader(HVIDEO hVideo, LPVIDEOHDR lpvideoHdr, DWORD dwSize)
{
    DWORD         wRet;

    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if (IsBadWritePtr (lpvideoHdr, sizeof (VIDEOHDR)) )
        return DV_ERR_PARAM1;

    if (lpvideoHdr->dwFlags & VHDR_INQUEUE)
    {
        DebugErr(DBF_WARNING, "videoStreamUnprepareHeader: buffer still in queue.");
        return DV_ERR_STILLPLAYING;
    }

    if (!IsVideoHeaderPrepared(hVideo, lpvideoHdr))
    {
        DebugErr(DBF_WARNING,"videoStreamUnprepareHeader: header is not prepared.");
        return DV_ERR_OK;
    }

    wRet = (DWORD)videoMessage((HVIDEO)hVideo, DVM_STREAM_UNPREPAREHEADER,
            (DWORD)lpvideoHdr, (DWORD)dwSize);

    if (wRet == DV_ERR_NOTSUPPORTED)
        wRet = videoUnprepareHeader(lpvideoHdr, dwSize);

    if (wRet == DV_ERR_OK)
        MarkVideoHeaderUnprepared(hVideo, lpvideoHdr);

    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamAddBuffer | This function sends a buffer to a
 *   video-capture device. After the buffer is filled by the device,
 *   the device sends it back to the application.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @parm LPVIDEOHDR | lpvideoHdr | Specifies a far pointer to a <t VIDEOHDR>
 *   structure that identifies the buffer.
 *
 * @parm DWORD | dwSize | Specifies the size of the <t VIDEOHDR> structure in bytes.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Indicates the device handle specified is invalid.
 *   @flag DV_ERR_UNPREPARED | Indicates the <p lpvideoHdr> structure hasn't been prepared.
 *   @flag DV_ERR_STILLPLAYING | Indicates a buffer is still in the queue.
 *   @flag DV_ERR_PARAM1 | The <p lpvideoHdr> parameter is invalid or
 *       the <e VIDEOHDR.dwBufferLength> member of the <t VIDEOHDR>
 *       structure is not set to the proper value.
 *
 * @comm The data buffer must be prepared with <f videoStreamPrepareHeader>
 *   before it is passed to <f videoStreamAddBuffer>. The <t VIDEOHDR> data
 *   structure and the data buffer referenced by its <e VIDEOHDR.lpData>
 *   member must be allocated with <f GlobalAlloc> using the GMEM_MOVEABLE
 *   and GMEM_SHARE flags, and locked with <f GlobalLock>. Set the
 *   <e VIDEOHDR.dwBufferLength> member to the size of the header.
 *
 * @xref <f videoStreamPrepareHeader>
 ****************************************************************************/
DWORD WINAPI videoStreamAddBuffer(HVIDEO hVideo, LPVIDEOHDR lpvideoHdr, DWORD dwSize)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if (IsBadWritePtr (lpvideoHdr, sizeof (VIDEOHDR)) )
        return DV_ERR_PARAM1;

    if (!IsVideoHeaderPrepared(hVideo, lpvideoHdr))
    {
        DebugErr(DBF_WARNING, "videoStreamAddBuffer: buffer not prepared.");
        return DV_ERR_UNPREPARED;
    }

    if (lpvideoHdr->dwFlags & VHDR_INQUEUE)
    {
        DebugErr(DBF_WARNING, "videoStreamAddBuffer: buffer already in queue.");
        return DV_ERR_STILLPLAYING;
    }

    return (DWORD)videoMessage((HVIDEO)hVideo, DVM_STREAM_ADDBUFFER, (DWORD)lpvideoHdr, (DWORD)dwSize);
}



/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamStop | This function stops streaming on a video channel.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video
 *   device channel.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following error is defined:
 *   @flag DV_ERR_INVALHANDLE | Indicates the specified device handle is invalid.
 *
 *   @flag DV_ERR_NOTSUPPORTED | Indicates the device does not support this
 *         function.
 * @comm If there are any buffers in the queue, the current buffer will be
 *   marked as done (the <e VIDEOHDR.dwBytesRecorded> member in
 *   the <t VIDEOHDR> header will contain the actual length of data), but any
 *   empty buffers in the queue will remain there. Calling this
 *   function when the channel is not started has no effect, and the
 *   function returns zero.
 *
 * @xref <f videoStreamStart> <f videoStreamReset>
 ****************************************************************************/
DWORD WINAPI videoStreamStop(HVIDEO hVideo)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    return videoMessage((HVIDEO)hVideo, DVM_STREAM_STOP, 0L, 0L);
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamReset | This function stops streaming
 *	     on the specified video device channel and resets the current position
 *      to zero.  All pending buffers are marked as done and
 *      are returned to the application.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *
 *   @flag DV_ERR_INVALHANDLE | Indicates the device handle specified is invalid.
 *
 *   @flag DV_ERR_NOTSUPPORTED | Indicates the device does not support this
 *         function.
 *
 * @xref <f videoStreamReset> <f videoStreamStop> <f videoStreamAddBuffer> <f videoStreamClose>
/****************************************************************************/
DWORD WINAPI videoStreamReset(HVIDEO hVideo)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    return videoMessage((HVIDEO)hVideo, DVM_STREAM_RESET, 0L, 0L);
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamGetPosition | This function retrieves the current
 *   position of the specified video device channel.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @parm LPMMTIME | lpInfo | Specifies a far pointer to an <t MMTIME>
 *   structure.
 *
 * @parm DWORD | dwSize | Specifies the size of the <t MMTIME> structure in bytes.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *
 *   @flag DV_ERR_INVALHANDLE | Indicates the specified device handle is invalid.
 *
 * @comm Before using <f videoStreamGetPosition>, set the
 *   <e MMTIME.wType> member of the <t MMTIME> structure to indicate
 *   the time format desired. After
 *   <f videoStreamGetPosition> returns, check the <e MMTIME.wType>
 *   member to  determine if the your time format is supported. If
 *   not, <e MMTIME.wType> specifies an alternate format.
 *   Video capture drivers typically provide the millisecond time
 *   format.
 *
 *   The position is set to zero when streaming is started with
 *   <f videoStreamStart>.
 ****************************************************************************/
DWORD WINAPI videoStreamGetPosition(HVIDEO hVideo, LPMMTIME lpInfo, DWORD dwSize)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if (IsBadWritePtr (lpInfo, sizeof (MMTIME)) )
        return DV_ERR_PARAM1;

    return videoMessage(hVideo, DVM_STREAM_GETPOSITION,
            (DWORD)lpInfo, (DWORD)dwSize);
}

// ============================================

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamInit | This function initializes a video
 *     device channel for streaming.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @parm DWORD | dwMicroSecPerFrame | Specifies the number of microseconds
 *     between frames.
 *
 * @parm DWORD | dwCallback | Specifies the address of a callback
 *   function or a handle to a window called during video
 *   streaming. The callback function or window processes
 *  messages related to the progress of streaming.
 *
 * @parm DWORD | dwCallbackInstance | Specifies user
 *  instance data passed to the callback function. This parameter is not
 *  used with window callbacks.
 *
 * @parm DWORD | dwFlags | Specifies flags for opening the device channel.
 *   The following flags are defined:
 *   @flag CALLBACK_WINDOW | If this flag is specified, <p dwCallback> is
 *      a window handle.
 *   @flag CALLBACK_FUNCTION | If this flag is specified, <p dwCallback> is
 *      a callback procedure address.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_BADDEVICEID | Indicates the device ID specified in
 *         <p hVideo> is not valid.
 *   @flag DV_ERR_ALLOCATED | Indicates the resource specified is already allocated.
 *   @flag DV_ERR_NOMEM | Indicates the device is unable to allocate or lock memory.
 *
 * @comm If a window or function is chosen to receive callback information, the following
 *   messages are sent to it to indicate the
 *   progress of video input:
 *
 *   <m MM_DRVM_OPEN> is sent at the time of <f videoStreamInit>
 *
 *   <m MM_DRVM_CLOSE> is sent at the time of <f videoStreamFini>
 *
 *   <m MM_DRVM_DATA> is sent when a buffer of image data is available
 *
 *   <m MM_DRVM_ERROR> is sent when an error occurs
 *
 *   Callback functions must reside in a DLL.
 *   You do not have to use <f MakeProcInstance> to get
 *   a procedure-instance address for the callback function.
 *
 * @cb void CALLBACK | videoFunc | <f videoFunc> is a placeholder for an
 *   application-supplied function name. The actual name must be exported by
 *   including it in an EXPORTS statement in the DLL's module-definition file.
 *   This is used only when a callback function is specified in
 *   <f videoStreamInit>.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel
 *   associated with the callback.
 *
 * @parm DWORD | wMsg | Specifies the <m MM_DRVM_> messages. Messages indicate
 *       errors and when image data is available. For information on
 *       these messages, see <f videoStreamInit>.
 *
 * @parm DWORD | dwInstance | Specifies the user instance
 *   data specified with <f videoStreamInit>.
 *
 * @parm DWORD | dwParam1 | Specifies a parameter for the message.
 *
 * @parm DWORD | dwParam2 | Specifies a parameter for the message.
 *
 * @comm Because the callback is accessed at interrupt time, it must reside
 *   in a DLL and its code segment must be specified as FIXED in the
 *   module-definition file for the DLL. Any data the callback accesses
 *   must be in a FIXED data segment as well. The callback may not make any
 *   system calls except for <f PostMessage>, <f timeGetSystemTime>,
 *   <f timeGetTime>, <f timeSetEvent>, <f timeKillEvent>,
 *   <f midiOutShortMsg>, <f midiOutLongMsg>, and <f OutputDebugStr>.
 *
 * @xref <f videoOpen> <f videoStreamFini> <f videoClose>
 ****************************************************************************/
DWORD WINAPI videoStreamInit(HVIDEO hVideo,
              DWORD dwMicroSecPerFrame, DWORD dwCallback,
              DWORD dwCallbackInst, DWORD dwFlags)
{
    VIDEO_STREAM_INIT_PARMS vsip;

    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if (dwCallback && ((dwFlags & CALLBACK_TYPEMASK) == CALLBACK_FUNCTION) ) {
        if (IsBadCodePtr ((FARPROC) dwCallback) )
            return DV_ERR_PARAM2;
        if (!dwCallbackInst)
            return DV_ERR_PARAM2;
    }

    if (dwCallback && ((dwFlags & CALLBACK_TYPEMASK) == CALLBACK_WINDOW) ) {
        if (!IsWindow((HWND)(dwCallback)) )
            return DV_ERR_PARAM2;
    }

    vsip.dwMicroSecPerFrame = dwMicroSecPerFrame;
    vsip.dwCallback = dwCallback;
    vsip.dwCallbackInst = dwCallbackInst;
    vsip.dwFlags = dwFlags;
    vsip.hVideo = (DWORD)hVideo;

    return videoMessage(hVideo, DVM_STREAM_INIT,
                (DWORD) (LPVIDEO_STREAM_INIT_PARMS) &vsip,
                (DWORD) sizeof (VIDEO_STREAM_INIT_PARMS));
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamFini | This function terminates streaming
 *     from the specified device channel.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Indicates the device handle specified is invalid.
 *   @flag DV_ERR_STILLPLAYING | Indicates there are still buffers in the queue.
 *
 * @comm If there are buffers that have been sent with
 *   <f videoStreamAddBuffer> that haven't been returned to the application,
 *   this operation will fail. Use <f videoStreamReset> to return all
 *   pending buffers.
 *
 *   Each call to <f videoStreamInit> must be matched with a call to
 *   <f videoStreamFini>.
 *
 *   For VIDEO_EXTERNALIN channels, this function is used to
 *   halt capturing of data to the frame buffer.
 *
 *   For VIDEO_EXTERNALOUT channels supporting overlay,
 *   this function is used to disable the overlay.
 *
 * @xref <f videoStreamInit>
 ****************************************************************************/
DWORD WINAPI videoStreamFini(HVIDEO hVideo)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    return videoMessage(hVideo, DVM_STREAM_FINI, 0L, 0L);
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamStart | This function starts streaming on the
 *   specified video device channel.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Indicates the device handle specified is invalid.
 *
 *   @flag DV_ERR_NOTSUPPORTED | Indicates the device does not support this
 *         function.
 *
 * @xref <f videoStreamReset> <f videoStreamStop> <f videoStreamAddBuffer> <f videoStreamClose>
/****************************************************************************/
DWORD WINAPI videoStreamStart(HVIDEO hVideo)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    return videoMessage(hVideo, DVM_STREAM_START, 0L, 0L);
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamGetError | This function returns the error
 *   most recently encountered.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @parm LPDWORD | lpdwErrorID | Specifies a far pointer to the <t DWORD>
 *      used to return the error ID.
 *
 * @parm LPDWORD | lpdwErrorValue | Specifies a far pointer to the <t DWORD>
 *      used to return the number of frames skipped.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following error is defined:
 *   @flag DV_ERR_INVALHANDLE | Indicates the device handle specified is invalid.
 *
 * @comm While streaming video data, a capture
 *      driver can fill buffers faster than the client application can
 *      save the buffers to disk.  In this case, the
 *      DV_ERR_NO_BUFFERS error is returned in <p lpdwErrorID>
 *      and <p lpdwErrorValue> contains a count of the number of
 *      frames missed.  After
 *      receiving this message and returning the error status, a driver
 *      should reset its internal error flag to DV_ERR_OK and
 *      the count of missed frames to zero.
 *
 *      Applications should send this message frequently during capture
 *      since some drivers which do not have access to interrupts use
 *      this message to trigger buffer processing.
 *
 * @xref <f videoOpen>
/****************************************************************************/
DWORD WINAPI videoStreamGetError(HVIDEO hVideo, LPDWORD lpdwError,
        LPDWORD lpdwFramesSkipped)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if (IsBadWritePtr (lpdwError, sizeof (DWORD)) )
        return DV_ERR_PARAM1;

    if (IsBadWritePtr (lpdwFramesSkipped, sizeof (DWORD)) )
        return DV_ERR_PARAM2;

    return videoMessage(hVideo, DVM_STREAM_GETERROR, (DWORD) lpdwError,
        (DWORD) lpdwFramesSkipped);
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoFrame | This function transfers a single frame
 *   to or from a video device channel.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *      The channel must be of type VIDEO_IN or VIDEO_OUT.
 *
 * @parm LPVIDEOHDR | lpVHdr | Specifies a far pointer to an <t VIDEOHDR>
 *      structure.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag DV_ERR_PARAM1 | The <p lpVDHdr> parameter is invalid or
 *       the <e VIDEOHDR.dwBufferLength> member of the <t VIDEOHDR>
 *       structure is not set to the proper value.
 *
 * @comm Use this function with a VIDEO_IN channel to transfer a single
 *      image from the frame buffer.
 *      Use this function with a VIDEO_OUT channel to transfer a single
 *      image to the frame buffer.
 *
 * @xref <f videoOpen>
/****************************************************************************/
DWORD WINAPI videoFrame (HVIDEO hVideo, LPVIDEOHDR lpVHdr)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if (!lpVHdr)
        return DV_ERR_PARAM1;

    if (IsBadWritePtr (lpVHdr, sizeof (VIDEOHDR)) )
        return DV_ERR_PARAM1;

    return videoMessage(hVideo, DVM_FRAME, (DWORD) lpVHdr,
                        sizeof(VIDEOHDR));
}

/**************************************************************************
* @doc INTERNAL VIDEO
*
* @api void | videoCleanup | clean up video stuff
*   called in MSVIDEOs WEP()
*
**************************************************************************/
void FAR PASCAL videoCleanup(HTASK hTask)
{
}

//
//  Assist with unicode conversions
//

int Iwcstombs(LPSTR lpstr, LPCWSTR lpwstr, int len)
{
    return WideCharToMultiByte(GetACP(), 0, lpwstr, -1, lpstr, len, NULL, NULL);
}

int Imbstowcs(LPWSTR lpwstr, LPCSTR lpstr, int len)
{
    return MultiByteToWideChar(GetACP(),
                               MB_PRECOMPOSED,
                               lpstr,
                               -1,
                               lpwstr,
                               len);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avicap\vidthunk.h ===
/****************************************************************************
    vidthunk.h

    Contains definitions for video thunks (16/32 bit) (for avicap32.dll)

    Copyright (c) Microsoft Corporation 1994. All rights reserved

****************************************************************************/

//
// NOTE - 32bit handles have 0x8000 'or'ed in - this makes a BIG ASSUMPTION
// about how handles are generated on the 32-bit side.  We ASSUME here
// that :
//
//    32bit msvideo.dll always uses OpenDriver to create handles
//
//    The OpenDriver returns indices into its table (ie small positive
//    numbers).
//

#define  Is32bitHandle(h) (((h) & 0x8000) != 0)
#define  Make32bitHandle(h) ((h) | 0x8000)
#define  Map32bitHandle(h) ((h) & 0x7FFF)

#ifdef WIN32
#include <wownt32.h>
//
//  Thunking support
//

#define GET_VDM_POINTER_NAME            "WOWGetVDMPointer"
#define GET_HANDLE_MAPPER16             "WOWHandle16"
#define GET_HANDLE_MAPPER32             "WOWHandle32"
#define GET_CALLBACK16                  "WOWCallback16"
#define GET_MAPPING_MODULE_NAME         TEXT("wow32.dll")

typedef LPVOID (APIENTRY *LPGETVDMPOINTER)( DWORD Address, DWORD dwBytes, BOOL fProtectMode );
#define WOW32ResolveMemory( p ) (LPVOID)(GetVdmPointer( (DWORD)(p), 0, TRUE ))

typedef HANDLE  (APIENTRY *LPWOWHANDLE32)(WORD, WOW_HANDLE_TYPE);
typedef WORD    (APIENTRY *LPWOWHANDLE16)(HANDLE, WOW_HANDLE_TYPE);
typedef DWORD   (APIENTRY *LPWOWCALLBACK16)(DWORD vpfn16, DWORD dwParam);

#define StartThunk(Function)                           \
          DWORD ReturnCode = 0;                        \
          DPF2(("Entering function %s", #Function));

#define EndThunk()                                     \
          DPF2(("  Returned %4X :%4X\n",               \
                   HIWORD(ReturnCode),                 \
                   LOWORD(ReturnCode)));               \
          return ReturnCode;

#define ThunkHWND(h16) ((HWND)lpWOWHandle32((WORD)h16, WOW_TYPE_HWND))
#define ThunkHDC(h16)  ((HDC) lpWOWHandle32((WORD)h16, WOW_TYPE_HDC))
#define ThunkHPAL(h16) ((HPALETTE)lpWOWHandle32((WORD)h16, WOW_TYPE_HPALETTE))

#endif // WIN32

/*
 *  Useful structures and mapping
 */

typedef struct {
    short left, top, right, bottom;
} RECT_SHORT;


#define SHORT_RECT_TO_RECT(OutRect, InRect)  \
    OutRect.left = (LONG)InRect.left;        \
    OutRect.top = (LONG)InRect.top;          \
    OutRect.right = (LONG)InRect.right;      \
    OutRect.bottom = (LONG)InRect.bottom;

#define RECT_TO_SHORT_RECT(OutRect, InRect)  \
    OutRect.left = (short)InRect.left;       \
    OutRect.top = (short)InRect.top;         \
    OutRect.right = (short)InRect.right;     \
    OutRect.bottom = (short)InRect.bottom;


//
//  Function ids across the thunking layer (used by 32 and 16 bit)
//
enum {
   vidThunkvideoMessage32=1,
   vidThunkvideoGetNumDevs32,
   vidThunkvideoOpen32,
   vidThunkvideoClose32,

   compThunkICInfo32,
   compThunkICSendMessage32,
   compThunkICOpen32,
   compThunkICClose32,

   vidThunkvideoGetDriverDesc32
};

#ifndef WIN32
typedef struct _VIDTHUNK
{
//
//  Thunking stuff
//
    DWORD           (FAR PASCAL *lpfnCallproc32W)(DWORD, DWORD, DWORD,
                                                  DWORD, DWORD,
                                                  LPVOID, DWORD, DWORD);
    LPVOID          lpvThunkEntry;
    DWORD           dwVideo32Handle;


} VIDTHUNK, *PVIDTHUNK, FAR *LPVIDTHUNK;
#endif // !WIN32

//
// The following functions generate calls to the 32-bit side
//

#ifdef _INC_MSVIDEO

DWORD FAR PASCAL videoMessage32(HVIDEO hVideo, UINT msg, DWORD dwP1, DWORD dwP2);
DWORD FAR PASCAL videoGetNumDevs32(void);
DWORD FAR PASCAL videoClose32(HVIDEO hVideo);
DWORD FAR PASCAL videoOpen32(LPHVIDEO lphVideo, DWORD dwDeviceID, DWORD dwFlags);
DWORD FAR PASCAL videoGetDriverDesc32(DWORD wDriverIndex,
        			LPSTR lpszName, short cbName,
        			LPSTR lpszVer, short cbVer);

#endif // _INC_MSVIDEO
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avicap\video16.h ===
/***************************************************************************
 *
 *  video16.h
 *
 *  Copyright (c) 1994  Microsoft Corporation
 *
 *  32-bit Thunks for avicap32.dll
 *
 *  Structures for mapping video
 *
 **************************************************************************/


/*
 *  Make sure the compiler doesn't think it knows better about packing
 *  The 16-bit stack is effectively pack(2)
 */

 #pragma pack(2)

/*
 *  Definitions to help with thunking video calls
 */

 typedef WORD HVIDEO16;
 typedef HVIDEO16 *LPHVIDEO16;


/*
 *  Note that everything is in the reverse order to keep with the PASCAL
 *  calling convention on the other side
 */


/****************************************************************************

   video entry point parameter lists

 ****************************************************************************/


typedef struct {
    DWORD    dwP2;
    DWORD    dwP1;
    WORD     msg;
    HVIDEO16 hVideo;
} UNALIGNED *PvideoMessageParms16;

typedef struct {
    DWORD    dwFlags;
    DWORD    dwDeviceId;
    LPHVIDEO16 lphVideo;
} UNALIGNED *PvideoOpenParms16;

typedef struct {
    HVIDEO16 hVideo;
} UNALIGNED *PvideoCloseParms16;


/*
 *  Our shadow header structure for use with callbacks
 *  (see videoStreamAddBuffer)
 */

typedef struct {
    LPVOID      pHdr16;        /* Remember address on 16-bit side */
    LPVOID      pHdr32;        /* 32-bit version of pHdr16        */
    LPBYTE      lpData16;      /* Remember pointer for flushing   */
    VIDEOHDR    videoHdr;
} VIDEOHDR32, *PVIDEOHDR32;


/*
 *  Instance data for videoStreamInit - contains pointer to 16-bit side
 *  instance data
 */

typedef struct {
    DWORD dwFlags;                // Real flags
    DWORD dwCallbackInst;         // Real instance data
    DWORD dwCallback;
    HVIDEO16 hVideo;
} VIDEOINSTANCEDATA32, *PVIDEOINSTANCEDATA32;

/*
 *  Thunk 16-bit mmtime
 */

#pragma pack(2)

typedef struct {
   WORD    wType;              /* indicates the contents of the union */
   union {
       DWORD ms;               /* milliseconds */
       DWORD sample;           /* samples */
       DWORD cb;               /* byte count */
       struct {                /* SMPTE */
           BYTE hour;          /* hours */
           BYTE min;           /* minutes */
           BYTE sec;           /* seconds */
           BYTE frame;         /* frames  */
           BYTE fps;           /* frames per second */
           BYTE dummy;         /* pad */
           } smpte;
       struct {                /* MIDI */
           DWORD songptrpos;   /* song pointer position */
           } midi;
       } u;
   } MMTIME16;

#pragma pack()



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avicap.16\avicap.h ===
/****************************************************************************
 *
 *   avicap.h
 * 
 *   Main include file.
 *
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992 - 1994 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and 
 *    distribute the Sample Files (and/or any modified version) in 
 *    any way you find useful, provided that you agree that 
 *    Microsoft has no warranty obligations or liability for any 
 *    Sample Application Files which are modified. 
 *
 ***************************************************************************/

#ifndef _INC_AVICAP
#define _INC_AVICAP

#ifndef VFWAPI
#ifdef WIN32
    #define VFWAPI  _stdcall
    #define VFWAPIV _stdcall
#else
    #define VFWAPI  FAR PASCAL
    #define VFWAPIV FAR CDECL
#endif
#endif
      
#ifdef __cplusplus
#define AVICapSM ::SendMessage  /* SendMessage in C++*/
#else
#define AVICapSM SendMessage    /* SendMessage in C */
#endif  /* __cplusplus */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif  /* RC_INVOKED */

#ifndef RC_INVOKED

// ------------------------------------------------------------------
//  Window Messages  WM_CAP... which can be sent to an AVICAP window
// ------------------------------------------------------------------

// Defines start of the message range
#define WM_CAP_START                    WM_USER

#define WM_CAP_GET_CAPSTREAMPTR         (WM_CAP_START+  1)

#define WM_CAP_SET_CALLBACK_ERROR       (WM_CAP_START+  2)
#define WM_CAP_SET_CALLBACK_STATUS      (WM_CAP_START+  3)
#define WM_CAP_SET_CALLBACK_YIELD       (WM_CAP_START+  4)
#define WM_CAP_SET_CALLBACK_FRAME       (WM_CAP_START+  5)
#define WM_CAP_SET_CALLBACK_VIDEOSTREAM (WM_CAP_START+  6)
#define WM_CAP_SET_CALLBACK_WAVESTREAM  (WM_CAP_START+  7)
#define WM_CAP_GET_USER_DATA            (WM_CAP_START+  8)
#define WM_CAP_SET_USER_DATA            (WM_CAP_START+  9)
    
#define WM_CAP_DRIVER_CONNECT           (WM_CAP_START+  10)
#define WM_CAP_DRIVER_DISCONNECT        (WM_CAP_START+  11)
#define WM_CAP_DRIVER_GET_NAME          (WM_CAP_START+  12) 
#define WM_CAP_DRIVER_GET_VERSION       (WM_CAP_START+  13) 
#define WM_CAP_DRIVER_GET_CAPS          (WM_CAP_START+  14) 

#define WM_CAP_FILE_SET_CAPTURE_FILE    (WM_CAP_START+  20)
#define WM_CAP_FILE_GET_CAPTURE_FILE    (WM_CAP_START+  21)
#define WM_CAP_FILE_ALLOCATE            (WM_CAP_START+  22)
#define WM_CAP_FILE_SAVEAS              (WM_CAP_START+  23)
#define WM_CAP_FILE_SET_INFOCHUNK       (WM_CAP_START+  24)
#define WM_CAP_FILE_SAVEDIB             (WM_CAP_START+  25)

#define WM_CAP_EDIT_COPY                (WM_CAP_START+  30)

#define WM_CAP_SET_AUDIOFORMAT          (WM_CAP_START+  35) 
#define WM_CAP_GET_AUDIOFORMAT          (WM_CAP_START+  36)

#define WM_CAP_DLG_VIDEOFORMAT          (WM_CAP_START+  41)
#define WM_CAP_DLG_VIDEOSOURCE          (WM_CAP_START+  42)
#define WM_CAP_DLG_VIDEODISPLAY         (WM_CAP_START+  43)
#define WM_CAP_GET_VIDEOFORMAT          (WM_CAP_START+  44)
#define WM_CAP_SET_VIDEOFORMAT          (WM_CAP_START+  45)
#define WM_CAP_DLG_VIDEOCOMPRESSION     (WM_CAP_START+  46)

#define WM_CAP_SET_PREVIEW              (WM_CAP_START+  50)
#define WM_CAP_SET_OVERLAY              (WM_CAP_START+  51)
#define WM_CAP_SET_PREVIEWRATE          (WM_CAP_START+  52)
#define WM_CAP_SET_SCALE                (WM_CAP_START+  53)
#define WM_CAP_GET_STATUS               (WM_CAP_START+  54)
#define WM_CAP_SET_SCROLL               (WM_CAP_START+  55)

#define WM_CAP_GRAB_FRAME               (WM_CAP_START+  60)
#define WM_CAP_GRAB_FRAME_NOSTOP        (WM_CAP_START+  61)

#define WM_CAP_SEQUENCE                 (WM_CAP_START+  62)
#define WM_CAP_SEQUENCE_NOFILE          (WM_CAP_START+  63)
#define WM_CAP_SET_SEQUENCE_SETUP       (WM_CAP_START+  64)
#define WM_CAP_GET_SEQUENCE_SETUP       (WM_CAP_START+  65)
#define WM_CAP_SET_MCI_DEVICE           (WM_CAP_START+  66)
#define WM_CAP_GET_MCI_DEVICE           (WM_CAP_START+  67)
#define WM_CAP_STOP                     (WM_CAP_START+  68)
#define WM_CAP_ABORT                    (WM_CAP_START+  69)

#define WM_CAP_SINGLE_FRAME_OPEN        (WM_CAP_START+  70) 
#define WM_CAP_SINGLE_FRAME_CLOSE       (WM_CAP_START+  71) 
#define WM_CAP_SINGLE_FRAME             (WM_CAP_START+  72) 

#define WM_CAP_PAL_OPEN                 (WM_CAP_START+  80) 
#define WM_CAP_PAL_SAVE                 (WM_CAP_START+  81) 
#define WM_CAP_PAL_PASTE                (WM_CAP_START+  82)
#define WM_CAP_PAL_AUTOCREATE           (WM_CAP_START+  83)
#define WM_CAP_PAL_MANUALCREATE         (WM_CAP_START+  84)

// Following added post VFW 1.1
#define WM_CAP_SET_CALLBACK_CAPCONTROL  (WM_CAP_START+  85)

// Defines end of the message range
#define WM_CAP_END                      WM_CAP_SET_CALLBACK_CAPCONTROL
                                        
// ------------------------------------------------------------------
//  Message crackers for above
// ------------------------------------------------------------------

#define capSetCallbackOnError(hwnd, fpProc)        ((BOOL)AVICapSM(hwnd, WM_CAP_SET_CALLBACK_ERROR, 0, (LPARAM)(LPVOID)(fpProc)))
#define capSetCallbackOnStatus(hwnd, fpProc)       ((BOOL)AVICapSM(hwnd, WM_CAP_SET_CALLBACK_STATUS, 0, (LPARAM)(LPVOID)(fpProc)))
#define capSetCallbackOnYield(hwnd, fpProc)        ((BOOL)AVICapSM(hwnd, WM_CAP_SET_CALLBACK_YIELD, 0, (LPARAM)(LPVOID)(fpProc)))
#define capSetCallbackOnFrame(hwnd, fpProc)        ((BOOL)AVICapSM(hwnd, WM_CAP_SET_CALLBACK_FRAME, 0, (LPARAM)(LPVOID)(fpProc)))
#define capSetCallbackOnVideoStream(hwnd, fpProc)  ((BOOL)AVICapSM(hwnd, WM_CAP_SET_CALLBACK_VIDEOSTREAM, 0, (LPARAM)(LPVOID)(fpProc)))
#define capSetCallbackOnWaveStream(hwnd, fpProc)   ((BOOL)AVICapSM(hwnd, WM_CAP_SET_CALLBACK_WAVESTREAM, 0, (LPARAM)(LPVOID)(fpProc)))
#define capSetCallbackOnCapControl(hwnd, fpProc)   ((BOOL)AVICapSM(hwnd, WM_CAP_SET_CALLBACK_CAPCONTROL, 0, (LPARAM)(LPVOID)(fpProc)))

#define capSetUserData(hwnd, lUser)                ((BOOL)AVICapSM(hwnd, WM_CAP_SET_USER_DATA, 0, (LPARAM)lUser))
#define capGetUserData(hwnd)                       (AVICapSM(hwnd, WM_CAP_GET_USER_DATA, 0, 0))

#define capDriverConnect(hwnd, i)                  ((BOOL)AVICapSM(hwnd, WM_CAP_DRIVER_CONNECT, (WPARAM)(i), 0L))
#define capDriverDisconnect(hwnd)                  ((BOOL)AVICapSM(hwnd, WM_CAP_DRIVER_DISCONNECT, (WPARAM)0, 0L))
#define capDriverGetName(hwnd, szName, wSize)      ((BOOL)AVICapSM(hwnd, WM_CAP_DRIVER_GET_NAME, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPSTR)(szName)))
#define capDriverGetVersion(hwnd, szVer, wSize)    ((BOOL)AVICapSM(hwnd, WM_CAP_DRIVER_GET_VERSION, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPSTR)(szVer)))
#define capDriverGetCaps(hwnd, s, wSize)           ((BOOL)AVICapSM(hwnd, WM_CAP_DRIVER_GET_CAPS, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPCAPDRIVERCAPS)(s)))

#define capFileSetCaptureFile(hwnd, szName)        ((BOOL)AVICapSM(hwnd, WM_CAP_FILE_SET_CAPTURE_FILE, 0, (LPARAM)(LPVOID)(LPSTR)(szName)))
#define capFileGetCaptureFile(hwnd, szName, wSize) ((BOOL)AVICapSM(hwnd, WM_CAP_FILE_GET_CAPTURE_FILE, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPSTR)(szName)))
#define capFileAlloc(hwnd, dwSize)                 ((BOOL)AVICapSM(hwnd, WM_CAP_FILE_ALLOCATE, 0, (LPARAM)(DWORD)(dwSize)))
#define capFileSaveAs(hwnd, szName)                ((BOOL)AVICapSM(hwnd, WM_CAP_FILE_SAVEAS, 0, (LPARAM)(LPVOID)(LPSTR)(szName)))
#define capFileSetInfoChunk(hwnd, lpInfoChunk)     ((BOOL)AVICapSM(hwnd, WM_CAP_FILE_SET_INFOCHUNK, (WPARAM)0, (LPARAM)(LPCAPINFOCHUNK)(lpInfoChunk)))
#define capFileSaveDIB(hwnd, szName)               ((BOOL)AVICapSM(hwnd, WM_CAP_FILE_SAVEDIB, 0, (LPARAM)(LPVOID)(LPSTR)(szName)))

#define capEditCopy(hwnd)                          ((BOOL)AVICapSM(hwnd, WM_CAP_EDIT_COPY, 0, 0L))

#define capSetAudioFormat(hwnd, s, wSize)          ((BOOL)AVICapSM(hwnd, WM_CAP_SET_AUDIOFORMAT, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPWAVEFORMATEX)(s)))
#define capGetAudioFormat(hwnd, s, wSize)          ((DWORD)AVICapSM(hwnd, WM_CAP_GET_AUDIOFORMAT, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPWAVEFORMATEX)(s)))
#define capGetAudioFormatSize(hwnd)                ((DWORD)AVICapSM(hwnd, WM_CAP_GET_AUDIOFORMAT, (WPARAM)0, (LPARAM) NULL))

#define capDlgVideoFormat(hwnd)                    ((BOOL)AVICapSM(hwnd, WM_CAP_DLG_VIDEOFORMAT, 0, 0L))
#define capDlgVideoSource(hwnd)                    ((BOOL)AVICapSM(hwnd, WM_CAP_DLG_VIDEOSOURCE, 0, 0L))
#define capDlgVideoDisplay(hwnd)                   ((BOOL)AVICapSM(hwnd, WM_CAP_DLG_VIDEODISPLAY, 0, 0L))
#define capDlgVideoCompression(hwnd)               ((BOOL)AVICapSM(hwnd, WM_CAP_DLG_VIDEOCOMPRESSION, 0, 0L))

#define capGetVideoFormat(hwnd, s, wSize)          ((DWORD)AVICapSM(hwnd, WM_CAP_GET_VIDEOFORMAT, (WPARAM)(wSize), (LPARAM)(LPVOID)(s)))
#define capGetVideoFormatSize(hwnd)                ((DWORD)AVICapSM(hwnd, WM_CAP_GET_VIDEOFORMAT, 0, NULL))
#define capSetVideoFormat(hwnd, s, wSize)          ((BOOL)AVICapSM(hwnd, WM_CAP_SET_VIDEOFORMAT, (WPARAM)(wSize), (LPARAM)(LPVOID)(s)))

#define capPreview(hwnd, f)                        ((BOOL)AVICapSM(hwnd, WM_CAP_SET_PREVIEW, (WPARAM)(BOOL)(f), 0L))
#define capPreviewRate(hwnd, wMS)                  ((BOOL)AVICapSM(hwnd, WM_CAP_SET_PREVIEWRATE, (WPARAM)(wMS), 0))
#define capOverlay(hwnd, f)                        ((BOOL)AVICapSM(hwnd, WM_CAP_SET_OVERLAY, (WPARAM)(BOOL)(f), 0L))
#define capPreviewScale(hwnd, f)                   ((BOOL)AVICapSM(hwnd, WM_CAP_SET_SCALE, (WPARAM)(BOOL)f, 0L))
#define capGetStatus(hwnd, s, wSize)               ((BOOL)AVICapSM(hwnd, WM_CAP_GET_STATUS, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPCAPSTATUS)(s)))
#define capSetScrollPos(hwnd, lpP)                 ((BOOL)AVICapSM(hwnd, WM_CAP_SET_SCROLL, (WPARAM)0, (LPARAM)(LPPOINT)(lpP)))

#define capGrabFrame(hwnd)                         ((BOOL)AVICapSM(hwnd, WM_CAP_GRAB_FRAME, (WPARAM)0, (LPARAM)0L))
#define capGrabFrameNoStop(hwnd)                   ((BOOL)AVICapSM(hwnd, WM_CAP_GRAB_FRAME_NOSTOP, (WPARAM)0, (LPARAM)0L))

#define capCaptureSequence(hwnd)                   ((BOOL)AVICapSM(hwnd, WM_CAP_SEQUENCE, (WPARAM)0, (LPARAM)0L))
#define capCaptureSequenceNoFile(hwnd)             ((BOOL)AVICapSM(hwnd, WM_CAP_SEQUENCE_NOFILE, (WPARAM)0, (LPARAM)0L))
#define capCaptureStop(hwnd)                       ((BOOL)AVICapSM(hwnd, WM_CAP_STOP, (WPARAM)0, (LPARAM)0L))
#define capCaptureAbort(hwnd)                      ((BOOL)AVICapSM(hwnd, WM_CAP_ABORT, (WPARAM)0, (LPARAM)0L))

#define capCaptureSingleFrameOpen(hwnd)            ((BOOL)AVICapSM(hwnd, WM_CAP_SINGLE_FRAME_OPEN, (WPARAM)0, (LPARAM)0L))
#define capCaptureSingleFrameClose(hwnd)           ((BOOL)AVICapSM(hwnd, WM_CAP_SINGLE_FRAME_CLOSE, (WPARAM)0, (LPARAM)0L))
#define capCaptureSingleFrame(hwnd)                ((BOOL)AVICapSM(hwnd, WM_CAP_SINGLE_FRAME, (WPARAM)0, (LPARAM)0L))

#define capCaptureGetSetup(hwnd, s, wSize)         ((BOOL)AVICapSM(hwnd, WM_CAP_GET_SEQUENCE_SETUP, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPCAPTUREPARMS)(s)))
#define capCaptureSetSetup(hwnd, s, wSize)         ((BOOL)AVICapSM(hwnd, WM_CAP_SET_SEQUENCE_SETUP, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPCAPTUREPARMS)(s)))

#define capSetMCIDeviceName(hwnd, szName)          ((BOOL)AVICapSM(hwnd, WM_CAP_SET_MCI_DEVICE, 0, (LPARAM)(LPVOID)(LPSTR)(szName)))
#define capGetMCIDeviceName(hwnd, szName, wSize)   ((BOOL)AVICapSM(hwnd, WM_CAP_GET_MCI_DEVICE, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPSTR)(szName)))

#define capPaletteOpen(hwnd, szName)               ((BOOL)AVICapSM(hwnd, WM_CAP_PAL_OPEN, 0, (LPARAM)(LPVOID)(LPSTR)(szName)))
#define capPaletteSave(hwnd, szName)               ((BOOL)AVICapSM(hwnd, WM_CAP_PAL_SAVE, 0, (LPARAM)(LPVOID)(LPSTR)(szName)))
#define capPalettePaste(hwnd)                      ((BOOL)AVICapSM(hwnd, WM_CAP_PAL_PASTE, (WPARAM) 0, (LPARAM)0L))
#define capPaletteAuto(hwnd, iFrames, iColors)     ((BOOL)AVICapSM(hwnd, WM_CAP_PAL_AUTOCREATE, (WPARAM)(iFrames), (LPARAM)(DWORD)(iColors)))
#define capPaletteManual(hwnd, fGrab, iColors)     ((BOOL)AVICapSM(hwnd, WM_CAP_PAL_MANUALCREATE, (WPARAM)(fGrab), (LPARAM)(DWORD)(iColors)))

// ------------------------------------------------------------------
//  Structures 
// ------------------------------------------------------------------

typedef struct tagCapDriverCaps {
    WORD        wDeviceIndex;               // Driver index in system.ini
    BOOL        fHasOverlay;                // Can device overlay?
    BOOL        fHasDlgVideoSource;         // Has Video source dlg?
    BOOL        fHasDlgVideoFormat;         // Has Format dlg?
    BOOL        fHasDlgVideoDisplay;        // Has External out dlg?
    BOOL        fCaptureInitialized;        // Driver ready to capture?
    BOOL        fDriverSuppliesPalettes;    // Can driver make palettes?
    HVIDEO      hVideoIn;                   // Driver In channel
    HVIDEO      hVideoOut;                  // Driver Out channel
    HVIDEO      hVideoExtIn;                // Driver Ext In channel
    HVIDEO      hVideoExtOut;               // Driver Ext Out channel
} CAPDRIVERCAPS, *PCAPDRIVERCAPS, FAR *LPCAPDRIVERCAPS;

typedef struct tagCapStatus {
    UINT        uiImageWidth;               // Width of the image
    UINT        uiImageHeight;              // Height of the image
    BOOL        fLiveWindow;                // Now Previewing video?
    BOOL        fOverlayWindow;             // Now Overlaying video?
    BOOL        fScale;                     // Scale image to client?
    POINT       ptScroll;                   // Scroll position
    BOOL        fUsingDefaultPalette;       // Using default driver palette?
    BOOL        fAudioHardware;             // Audio hardware present?
    BOOL        fCapFileExists;             // Does capture file exist?
    DWORD       dwCurrentVideoFrame;        // # of video frames cap'td
    DWORD       dwCurrentVideoFramesDropped;// # of video frames dropped
    DWORD       dwCurrentWaveSamples;       // # of wave samples cap'td
    DWORD       dwCurrentTimeElapsedMS;     // Elapsed capture duration
    HPALETTE    hPalCurrent;                // Current palette in use
    BOOL        fCapturingNow;              // Capture in progress?
    DWORD       dwReturn;                   // Error value after any operation
    WORD        wNumVideoAllocated;         // Actual number of video buffers
    WORD        wNumAudioAllocated;         // Actual number of audio buffers
} CAPSTATUS, *PCAPSTATUS, FAR *LPCAPSTATUS;

                                            // Default values in parenthesis
typedef struct tagCaptureParms {
    DWORD       dwRequestMicroSecPerFrame;  // Requested capture rate
    BOOL        fMakeUserHitOKToCapture;    // Show "Hit OK to cap" dlg?
    WORD        wPercentDropForError;       // Give error msg if > (10%)
    BOOL        fYield;                     // Capture via background task?
    DWORD       dwIndexSize;                // Max index size in frames (32K)
    WORD        wChunkGranularity;          // Junk chunk granularity (2K)
    BOOL        fUsingDOSMemory;            // Use DOS buffers?
    WORD        wNumVideoRequested;         // # video buffers, If 0, autocalc
    BOOL        fCaptureAudio;              // Capture audio?
    WORD        wNumAudioRequested;         // # audio buffers, If 0, autocalc
    WORD        vKeyAbort;                  // Virtual key causing abort
    BOOL        fAbortLeftMouse;            // Abort on left mouse?
    BOOL        fAbortRightMouse;           // Abort on right mouse?
    BOOL        fLimitEnabled;              // Use wTimeLimit?
    WORD        wTimeLimit;                 // Seconds to capture
    BOOL        fMCIControl;                // Use MCI video source?
    BOOL        fStepMCIDevice;             // Step MCI device?
    DWORD       dwMCIStartTime;             // Time to start in MS
    DWORD       dwMCIStopTime;              // Time to stop in MS
    BOOL        fStepCaptureAt2x;           // Perform spatial averaging 2x
    WORD        wStepCaptureAverageFrames;  // Temporal average n Frames
    DWORD       dwAudioBufferSize;          // Size of audio bufs (0 = default)
    BOOL        fDisableWriteCache;         // Attempt to disable write cache
} CAPTUREPARMS, *PCAPTUREPARMS, FAR *LPCAPTUREPARMS;

typedef struct tagCapInfoChunk {
    FOURCC      fccInfoID;                  // Chunk ID, "ICOP" for copyright
    LPVOID      lpData;                     // pointer to data
    LONG        cbData;                     // size of lpData
} CAPINFOCHUNK, *PCAPINFOCHUNK, FAR *LPCAPINFOCHUNK;


// ------------------------------------------------------------------
//  Callback Definitions
// ------------------------------------------------------------------

typedef LRESULT (CALLBACK* CAPYIELDCALLBACK)  (HWND hWnd);
typedef LRESULT (CALLBACK* CAPSTATUSCALLBACK) (HWND hWnd, int nID, LPCSTR lpsz);
typedef LRESULT (CALLBACK* CAPERRORCALLBACK)  (HWND hWnd, int nID, LPCSTR lpsz);
typedef LRESULT (CALLBACK* CAPVIDEOCALLBACK)  (HWND hWnd, LPVIDEOHDR lpVHdr);
typedef LRESULT (CALLBACK* CAPWAVECALLBACK)   (HWND hWnd, LPWAVEHDR lpWHdr);
typedef LRESULT (CALLBACK* CAPCONTROLCALLBACK)(HWND hWnd, int nState);

// ------------------------------------------------------------------
//  CapControlCallback states
// ------------------------------------------------------------------
#define CONTROLCALLBACK_PREROLL         1 /* Waiting to start capture */
#define CONTROLCALLBACK_CAPTURING       2 /* Now capturing */

// ------------------------------------------------------------------
//  The only exported functions from AVICAP.DLL
// ------------------------------------------------------------------

HWND VFWAPI capCreateCaptureWindow (
        LPCSTR lpszWindowName, 
        DWORD dwStyle,
        int x, int y, int nWidth, int nHeight,
        HWND hwndParent, int nID);

BOOL VFWAPI capGetDriverDescription (WORD wDriverIndex,
        LPSTR lpszName, int cbName,
        LPSTR lpszVer, int cbVer);

#endif  /* RC_INVOKED */

// ------------------------------------------------------------------
// New Information chunk IDs
// ------------------------------------------------------------------
#define infotypeDIGITIZATION_TIME  mmioFOURCC ('I','D','I','T')
#define infotypeSMPTE_TIME         mmioFOURCC ('I','S','M','P')

// ------------------------------------------------------------------
// String IDs from status and error callbacks
// ------------------------------------------------------------------

#define IDS_CAP_BEGIN               300  /* "Capture Start" */
#define IDS_CAP_END                 301  /* "Capture End" */

#define IDS_CAP_INFO                401  /* "%s" */
#define IDS_CAP_OUTOFMEM            402  /* "Out of memory" */
#define IDS_CAP_FILEEXISTS          403  /* "File '%s' exists -- overwrite it?" */
#define IDS_CAP_ERRORPALOPEN        404  /* "Error opening palette '%s'" */
#define IDS_CAP_ERRORPALSAVE        405  /* "Error saving palette '%s'" */
#define IDS_CAP_ERRORDIBSAVE        406  /* "Error saving frame '%s'" */
#define IDS_CAP_DEFAVIEXT           407  /* "avi" */
#define IDS_CAP_DEFPALEXT           408  /* "pal" */
#define IDS_CAP_CANTOPEN            409  /* "Cannot open '%s'" */
#define IDS_CAP_SEQ_MSGSTART        410  /* "Select OK to start capture\nof video sequence\nto %s." */
#define IDS_CAP_SEQ_MSGSTOP         411  /* "Hit ESCAPE or click to end capture" */
                
#define IDS_CAP_VIDEDITERR          412  /* "An error occurred while trying to run VidEdit." */
#define IDS_CAP_READONLYFILE        413  /* "The file '%s' is a read-only file." */
#define IDS_CAP_WRITEERROR          414  /* "Unable to write to file '%s'.\nDisk may be full." */
#define IDS_CAP_NODISKSPACE         415  /* "There is no space to create a capture file on the specified device." */
#define IDS_CAP_SETFILESIZE         416  /* "Set File Size" */
#define IDS_CAP_SAVEASPERCENT       417  /* "SaveAs: %2ld%%  Hit Escape to abort." */
                
#define IDS_CAP_DRIVER_ERROR        418  /* Driver specific error message */

#define IDS_CAP_WAVE_OPEN_ERROR     419  /* "Error: Cannot open the wave input device.\nCheck sample size, frequency, and channels." */
#define IDS_CAP_WAVE_ALLOC_ERROR    420  /* "Error: Out of memory for wave buffers." */
#define IDS_CAP_WAVE_PREPARE_ERROR  421  /* "Error: Cannot prepare wave buffers." */
#define IDS_CAP_WAVE_ADD_ERROR      422  /* "Error: Cannot add wave buffers." */
#define IDS_CAP_WAVE_SIZE_ERROR     423  /* "Error: Bad wave size." */
                
#define IDS_CAP_VIDEO_OPEN_ERROR    424  /* "Error: Cannot open the video input device." */
#define IDS_CAP_VIDEO_ALLOC_ERROR   425  /* "Error: Out of memory for video buffers." */
#define IDS_CAP_VIDEO_PREPARE_ERROR 426  /* "Error: Cannot prepare video buffers." */
#define IDS_CAP_VIDEO_ADD_ERROR     427  /* "Error: Cannot add video buffers." */
#define IDS_CAP_VIDEO_SIZE_ERROR    428  /* "Error: Bad video size." */
                
#define IDS_CAP_FILE_OPEN_ERROR     429  /* "Error: Cannot open capture file." */
#define IDS_CAP_FILE_WRITE_ERROR    430  /* "Error: Cannot write to capture file.  Disk may be full." */
#define IDS_CAP_RECORDING_ERROR     431  /* "Error: Cannot write to capture file.  Data rate too high or disk full." */
#define IDS_CAP_RECORDING_ERROR2    432  /* "Error while recording" */
#define IDS_CAP_AVI_INIT_ERROR      433  /* "Error: Unable to initialize for capture." */
#define IDS_CAP_NO_FRAME_CAP_ERROR  434  /* "Warning: No frames captured.\nConfirm that vertical sync interrupts\nare configured and enabled." */
#define IDS_CAP_NO_PALETTE_WARN     435  /* "Warning: Using default palette." */
#define IDS_CAP_MCI_CONTROL_ERROR   436  /* "Error: Unable to access MCI device." */
#define IDS_CAP_MCI_CANT_STEP_ERROR 437  /* "Error: Unable to step MCI device." */
#define IDS_CAP_NO_AUDIO_CAP_ERROR  438  /* "Error: No audio data captured.\nCheck audio card settings." */
#define IDS_CAP_AVI_DRAWDIB_ERROR   439  /* "Error: Unable to draw this data format." */
#define IDS_CAP_COMPRESSOR_ERROR    440  /* "Error: Unable to initialize compressor." */
#define IDS_CAP_AUDIO_DROP_ERROR    441  /* "Error: Audio data was lost during capture, reduce capture rate." */
                
/* status string IDs */
#define IDS_CAP_STAT_LIVE_MODE      500  /* "Live window" */
#define IDS_CAP_STAT_OVERLAY_MODE   501  /* "Overlay window" */
#define IDS_CAP_STAT_CAP_INIT       502  /* "Setting up for capture - Please wait" */
#define IDS_CAP_STAT_CAP_FINI       503  /* "Finished capture, now writing frame %ld" */
#define IDS_CAP_STAT_PALETTE_BUILD  504  /* "Building palette map" */
#define IDS_CAP_STAT_OPTPAL_BUILD   505  /* "Computing optimal palette" */
#define IDS_CAP_STAT_I_FRAMES       506  /* "%d frames" */
#define IDS_CAP_STAT_L_FRAMES       507  /* "%ld frames" */
#define IDS_CAP_STAT_CAP_L_FRAMES   508  /* "Captured %ld frames" */
#define IDS_CAP_STAT_CAP_AUDIO      509  /* "Capturing audio" */
#define IDS_CAP_STAT_VIDEOCURRENT   510  /* "Captured %ld frames (%ld dropped) %d.%03d sec." */
#define IDS_CAP_STAT_VIDEOAUDIO     511  /* "Captured %d.%03d sec.  %ld frames (%ld dropped) (%d.%03d fps).  %ld audio bytes (%d,%03d sps)" */
#define IDS_CAP_STAT_VIDEOONLY      512  /* "Captured %d.%03d sec.  %ld frames (%ld dropped) (%d.%03d fps)" */
#define IDS_CAP_STAT_FRAMESDROPPED  513  /* "Dropped %ld of %ld frames (%d.%02d%%) during capture." */
#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif    /* __cplusplus */

#endif /* INC_AVICAP */



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avicap.16\avicapi.h ===
/****************************************************************************
 *
 *   avicapi.h
 * 
 *   Internal, private definitions.
 *
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992, 1993 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and 
 *    distribute the Sample Files (and/or any modified version) in 
 *    any way you find useful, provided that you agree that 
 *    Microsoft has no warranty obligations or liability for any 
 *    Sample Application Files which are modified. 
 *
 ***************************************************************************/

#ifndef _INC_AVICAP_INTERNAL
#define _INC_AVICAP_INTERNAL

#include <mmreg.h>
#include <compman.h>
#include "iaverage.h"

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif  /* RC_INVOKED */
                          
/* c8 uses underscores on all defines */
#ifdef DEBUG
#ifndef _DEBUG
#define _DEBUG
#endif
#endif

#define	IDS_CAP_RTL	10000

#ifndef LPHISTOGRAM
typedef DWORD huge * LPHISTOGRAM;
#endif

#define WIDTHBYTES(i)     ((unsigned)((i+31)&(~31))/8)  /* ULONG aligned ! */
#define DIBWIDTHBYTES(bi) ((int)WIDTHBYTES((int)(bi).biWidth * (int)(bi).biBitCount))
#define SWAP(x,y)   ((x)^=(y)^=(x)^=(y))

#define AVICAP                  DWORD FAR PASCAL
#define DROP_BUFFER_SIZE        2048
#define MAX_VIDEO_BUFFERS       1000
#define MIN_VIDEO_BUFFERS       5
#define DEF_WAVE_BUFFERS        4
#define MAX_WAVE_BUFFERS        10
#define _MAX_CAP_PATH           MAX_PATH  /* 260 */

// MCI Capture state machine
enum mcicapstates {
   CAPMCI_STATE_Uninitialized = 0,
   CAPMCI_STATE_Initialized,

   CAPMCI_STATE_StartVideo,
   CAPMCI_STATE_CapturingVideo,
   CAPMCI_STATE_VideoFini,

   CAPMCI_STATE_StartAudio,
   CAPMCI_STATE_CapturingAudio,
   CAPMCI_STATE_AudioFini,

   CAPMCI_STATE_AllFini
};

// -------------------------
//  CAPSTREAM structure
// -------------------------
#define CAPSTREAM_VERSION 1             // Increment whenever struct changes

// This structure is GlobalAlloc'd for each capture window instance.
// A pointer to the structure is stored in the Window extra bytes.
// Applications can retrieve a pointer to the stucture using 
//    the WM_CAP_GET_CAPSTREAMPTR message.
// I: internal variables which the client app should not modify
// M: variables which the client app can set via Send/PostMessage

typedef struct tagCAPSTREAM {
    DWORD           dwSize;                     // I: size of structure
    UINT            uiVersion;                  // I: version of structure
    HINSTANCE       hInst;                      // I: our instance
    HTASK           hTaskCapture;               // I: capture task handle
    DWORD           dwReturn;                   // I: capture task return val
    HWND            hwnd;                       // I: our hwnd

    // Use MakeProcInstance to create all callbacks !!!

    // Status, error callbacks 
    CAPSTATUSCALLBACK   CallbackOnStatus;       // M: Status callback
    CAPERRORCALLBACK    CallbackOnError;        // M: Error callback

    // Allows client to process messages during capture if set
    CAPYIELDCALLBACK    CallbackOnYield;        // M: Yield processing

    // Video and wave callbacks for Network or other specialized xfers
    CAPVIDEOCALLBACK    CallbackOnVideoFrame;   // M: Only during preview
    CAPVIDEOCALLBACK    CallbackOnVideoStream;  // M: Video buffer ready
    CAPWAVECALLBACK     CallbackOnWaveStream;   // M: Wave buffer ready
    CAPCONTROLCALLBACK  CallbackOnControl;      // M: External Start/Stop ctrl

    // Open channels on the video hardware device
    // and hardware capabilies
    CAPDRIVERCAPS   sCapDrvCaps;                // M: What can the driver do    
    HVIDEO          hVideoIn;                   // I: In channel
    HVIDEO          hVideoCapture;              // I: Ext In channel
    HVIDEO          hVideoDisplay;              // I: Ext Out channel
    BOOL            fHardwareConnected;         // I: ANY open channel?
     
    // Window to display video
    BOOL            fLiveWindow;                // M: Preview video
    BOOL            fOverlayWindow;             // M: Overlay video
    BOOL            fScale;                     // M: Scale image to client
    POINT           ptScroll;                   // I: Scroll position
    HANDLE          hdd;                        // I: hDrawDib access handle
    HCURSOR         hWaitCursor;                // I: hourglass
    UINT            uiRegion;                   // I: CheckWindowMove
    RECT            rcRegionRect;               // I: CheckWindowMove
    DWORD           dwRegionOrigin;             // I: CheckWindowMove

    // Window update timer
    UINT            idTimer;                    // I: ID of preview timer
    UINT            uTimeout;                   // M: Preview rate in mS.

    // Capture destination and control
    CAPTUREPARMS    sCapParms;                  // M: how to capture
    BOOL            fCapturingToDisk;           // M: if capturing to disk
    BOOL            fCapturingNow;              // I: if performing capture
    BOOL            fStepCapturingNow;          // I: if performing MCI step capture
    BOOL            fFrameCapturingNow;         // I: if performing single frame capture
    BOOL            fStopCapture;               // M: if stop requested
    BOOL            fAbortCapture;              // M: if abort requested
    DWORD           dwTimeElapsedMS;            // I: Capture time in millisec

    // Index 
    HGLOBAL         hIndex;                     // I: handle to index mem
    DWORD           dwIndex;                    // I: index index
    DWORD           dwVideoChunkCount;          // I: # of video frames cap'd
    DWORD           dwWaveChunkCount;           // I: # of audio buffers cap'd
    DWORD _huge *   lpdwIndexStart;             // I: index start ptr
    DWORD _huge *   lpdwIndexEntry;             // I: index current ptr
    LPBYTE          lpDOSWriteBuffer;           // I: ptr to DOS buffer
    DWORD           dwDOSBufferSize;            // I: DOS buffer size

    // Video format
    DWORD           dwActualMicroSecPerFrame;   // I: Actual cap rate
    LPBITMAPINFO    lpBitsInfo;                 // I: Video format
    int             dxBits;                     // I: video size x
    int             dyBits;                     // I: video size y
    LPSTR           lpBits;                     // I: Single frame capture buf
    VIDEOHDR        VidHdr;                     // I: Single frame header
    COMPVARS        CompVars;                   // M: Set by ICCompressorChoose
    LPIAVERAGE      lpia;                       // I: Image averaging struct
    VIDEOHDR        VidHdr2x;                   // I: VideoHeader at 2x
    LPBITMAPINFOHEADER  lpbmih2x;               // I: lpbi at 2x

    // Video Buffer management
    BOOL            fVideoDataIsCompressed;     // I: if don't use dwVideoSize
    DWORD           dwVideoSize;                // I: size of non-comp buffer incl chunk 
    DWORD           dwVideoJunkSize;            // I: Initial non-comp. junk size
    int             iNumVideo;                  // I: Number of actual video buffers
    int             iNextVideo;                 // I: index into video buffers
    DWORD           dwFramesDropped;            // I: number of frames dropped
    BYTE            DropFrame[DROP_BUFFER_SIZE];    // I: Create a Dummy VideoHdr
    LPVIDEOHDR      alpVideoHdr[MAX_VIDEO_BUFFERS]; // I: array of buf ptrs
    BOOL            fBuffersOnHardware;         // I: if driver all'd buffers

    // Palettes
    HPALETTE        hPalCurrent;                // I: handle of current pal
    BOOL            fUsingDefaultPalette;       // I: no user defined pal
    int             nPaletteColors;             // M: only changed by UI
    LPVOID          lpCapPal;                   // I: LPCAPPAL manual pals
    
    // Audio Capture Format
    BOOL            fAudioHardware;             // I: if audio hardware present
    LPWAVEFORMATEX  lpWaveFormat;               // I: wave format
    WAVEHDR         WaveHdr;                    // I: Wave header
    HWAVE           hWaveIn;                    // I: Wave input channel
    DWORD           dwWaveBytes;                // I: Total wave bytes cap'd
    DWORD           dwWaveSize;                 // I: wave buffer size

    // Audio Buffer management
    LPWAVEHDR       alpWaveHdr[MAX_WAVE_BUFFERS]; // I: wave buff array
    int             iNextWave;                  // I: Index into wave buffers
    int             iNumAudio;                  // I: Number of actual audio buffers
    BOOL            fAudioYield;                // I: ACM audio yield required
    BOOL            fAudioBreak;                // I: Audio underflow

    // MCI Capture
    char            achMCIDevice[_MAX_CAP_PATH];// MCI device name
    DWORD           dwMCIError;                 // I: Last MCI error value
    enum mcicapstates MCICaptureState;          // I: MCI State machine
    DWORD           dwMCICurrentMS;             // I: Current MCI position
    DWORD           dwMCIActualStartMS;         // I: Actual MCI start MS
    DWORD           dwMCIActualEndMS;           // I: Actual MCI end position

    // Output file
    char            achFile [_MAX_CAP_PATH];    // M: name of capture file
    char            achSaveAsFile [_MAX_CAP_PATH]; // M: name of saveas file
    BOOL            fCapFileExists;             // I: if have a capture file
    LONG            lCapFileSize;               // M: in bytes
    BOOL            fFileCaptured;              // I: if we've cap'd to file
    HMMIO           hmmio;                      // I: MMIO handle for writing
    DWORD           dwAVIHdrSize;               // I: size of header
    DWORD           dwAVIHdrPos;                // I: file offset of hdr
    
    LONG	    lUser;			// M: Data for the user
    LPVOID          lpInfoChunks;               // M: information chunks
    LONG            cbInfoChunks;               // M: sizeof information chks
    BOOL            fLastStatusWasNULL;         // I: don't repeat null msgs
    BOOL            fLastErrorWasNULL;          // I: don't repeat null msgs
} CAPSTREAM;
typedef CAPSTREAM FAR * LPCAPSTREAM;

// -------------------------
//  Full color log palette
// -------------------------

typedef struct tagFCLOGPALETTE {
    WORD         palVersion;
    WORD         palNumEntries;
    PALETTEENTRY palPalEntry[256];
} FCLOGPALETTE;

typedef struct {
    DWORD       dwType;
    DWORD       dwSize;
} RIFF, *PRIFF, FAR *LPRIFF;

extern HINSTANCE ghInst;
extern BOOL gfIsRTL;

// capinit.c
BOOL CapWinDisconnectHardware(LPCAPSTREAM lpcs);
BOOL CapWinConnectHardware (LPCAPSTREAM lpcs, WORD wDeviceIndex);
BOOL capInternalGetDriverDesc (WORD wDriverIndex,
        LPSTR lpszName, int cbName,
        LPSTR lpszVer, int cbVer);

// capwin.c
LONG FAR PASCAL _loadds CapWndProc (HWND hwnd, unsigned msg, WORD wParam, LONG lParam);
                  
// capavi.c                              
BOOL InitIndex (LPCAPSTREAM lpcs);
void FiniIndex (LPCAPSTREAM lpcs);
BOOL IndexVideo (LPCAPSTREAM lpcs, DWORD dwSize, BOOL bKeyFrame);
BOOL IndexAudio (LPCAPSTREAM lpcs, DWORD dwSize);
BOOL WriteIndex (LPCAPSTREAM lpcs, BOOL fJunkChunkWritten);
DWORD GetFreePhysicalMemory(void);
DWORD CalcWaveBufferSize (LPCAPSTREAM lpcs);
BOOL AVIFileInit(LPCAPSTREAM lpcs);
BOOL AVIFileFini (LPCAPSTREAM lpcs, BOOL fWroteJunkChunks, BOOL fAbort);
WORD AVIAudioInit (LPCAPSTREAM lpcs);
WORD AVIAudioFini (LPCAPSTREAM lpcs);
WORD AVIAudioPrepare (LPCAPSTREAM lpcs, HWND hWndCallback);
WORD AVIAudioUnPrepare (LPCAPSTREAM lpcs);
WORD AVIVideoInit (LPCAPSTREAM lpcs);
WORD AVIVideoPrepare (LPCAPSTREAM lpcs);
WORD AVIVideoUnPrepare (LPCAPSTREAM lpcs);
void AVIFini(LPCAPSTREAM lpcs);
WORD AVIInit (LPCAPSTREAM lpcs);
BOOL NEAR PASCAL AVIWrite(LPCAPSTREAM lpcs, LPVOID p, DWORD dwSize);
BOOL AVIWriteDummyFrames (LPCAPSTREAM lpcs, int nCount);
BOOL AVIWriteVideoFrame (LPCAPSTREAM lpcs, LPVIDEOHDR lpVidHdr);
BOOL FAR PASCAL SetInfoChunk(LPCAPSTREAM lpcs, LPCAPINFOCHUNK lpcic);

BOOL AVICapture (LPCAPSTREAM lpcs);


// capfile.c
BOOL FAR PASCAL fileCapFileIsAVI (LPSTR lpsz);
BOOL FAR PASCAL fileAllocCapFile(LPCAPSTREAM lpcs, DWORD dwNewSize);
BOOL FAR PASCAL fileSaveCopy(LPCAPSTREAM lpcs);
BOOL FAR PASCAL fileSavePalette(LPCAPSTREAM lpcs, LPSTR lpszFileName);
BOOL FAR PASCAL fileOpenPalette(LPCAPSTREAM lpcs, LPSTR lpszFileName);

//capmisc.c
WORD GetKey(BOOL fWait);
void errorDriverID (LPCAPSTREAM lpcs, DWORD dwError);
void FAR _cdecl statusUpdateStatus (LPCAPSTREAM lpcs, WORD wID, ...);
void FAR _cdecl errorUpdateError (LPCAPSTREAM lpcs, WORD wID, ...);

//capFrame.c
BOOL FAR PASCAL SingleFrameCaptureOpen (LPCAPSTREAM lpcs);
BOOL FAR PASCAL SingleFrameCaptureClose (LPCAPSTREAM lpcs);
BOOL FAR PASCAL SingleFrameCapture (LPCAPSTREAM lpcs);
BOOL SingleFrameWrite (
    LPCAPSTREAM             lpcs,       // capture stream
    LPVIDEOHDR              lpVidHdr,   // input header
    BOOL FAR 		    *pfKey,	// did it end up being a key frame?
    LONG FAR		    *plSize);	// size of returned image

//capMCI.c
void FAR PASCAL TimeMSToSMPTE (DWORD dwMS, LPSTR lpTime);
int CountMCIDevicesByType ( WORD wType );
void MCIDeviceClose (LPCAPSTREAM lpcs);
BOOL MCIDeviceOpen (LPCAPSTREAM lpcs);
BOOL FAR PASCAL MCIDeviceGetPosition (LPCAPSTREAM lpcs, LPDWORD lpdwPos);
BOOL FAR PASCAL MCIDeviceSetPosition (LPCAPSTREAM lpcs, DWORD dwPos);
BOOL FAR PASCAL MCIDevicePlay (LPCAPSTREAM lpcs);
BOOL FAR PASCAL MCIDevicePause (LPCAPSTREAM lpcs);
BOOL FAR PASCAL MCIDeviceStop (LPCAPSTREAM lpcs);
BOOL FAR PASCAL MCIDeviceStep (LPCAPSTREAM lpcs, BOOL fForward);
void FAR PASCAL _loadds MCIStepCapture (LPCAPSTREAM lpcs);

long FAR PASCAL muldiv32(long, long, long);
                        
#ifdef _DEBUG
  BOOL FAR PASCAL _Assert(BOOL f, LPSTR szFile, int iLine); 
  #define WinAssert(exp) (_Assert(exp, (LPSTR) __FILE__, __LINE__))
  extern void FAR CDECL dprintf(LPSTR, ...);
  #define DPF dprintf
#else
  #define dprintf ; / ## /
  #define DPF ; / ## /
  #define WinAssert(exp) 0
#endif                      


#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif    /* __cplusplus */

#endif /* INC_AVICAP_INTERNAL */


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avicap.16\capavi.c ===
/****************************************************************************
 *
 *   capavi.c
 *
 *   Main video capture module.
 *
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992, 1993 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and
 *    distribute the Sample Files (and/or any modified version) in
 *    any way you find useful, provided that you agree that
 *    Microsoft has no warranty obligations or liability for any
 *    Sample Application Files which are modified.
 *
 ***************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <memory.h>         // for _fmemset
#include <msvideo.h>
#include <drawdib.h>
#include <mmreg.h>
#include <mmddk.h>
#include <msacm.h>
#include <avifmt.h>
#include "avicap.h"
#include "avicapi.h"
#include "time.h"

time_t      ltime;

extern void NEAR PASCAL MemCopy(LPVOID, LPVOID, DWORD); // in memcopy.asm
extern WORD FAR PASCAL SmartDrv(char chDrive, WORD w);
extern WORD GetSizeOfWaveFormat (LPWAVEFORMATEX lpwf);

/* dialog function prototype */
LONG FAR PASCAL _export capseqDlgProc(HWND hwnd, unsigned msg, WORD wParam, LONG lParam);

#ifdef _DEBUG
    #define DSTATUS(lpcs, sz) statusUpdateStatus(lpcs, IDS_CAP_INFO, (LPSTR) sz)
#else
    #define DSTATUS(lpcs, sz)
#endif

///////////////////////////////////////////////////////////////////////////
//  The index array is used to record the positions
//  of every chunk in the RIFF (avi) file.
//
//  what this array is:
//
//      each entry contains the size of the data
//      high order bits encode the type of data (audio / video)
//      and whether the video chunk is a key frame, dropped frame, etc.
///////////////////////////////////////////////////////////////////////////

// The following are anded with the size in the index
#define IS_AUDIO_CHUNK        0x80000000
#define IS_KEYFRAME_CHUNK     0x40000000
#define IS_DUMMY_CHUNK        0x20000000
#define IS_LAST_DUMMY_CHUNK   0x10000000
#define INDEX_MASK  (IS_AUDIO_CHUNK | IS_KEYFRAME_CHUNK | IS_DUMMY_CHUNK | IS_LAST_DUMMY_CHUNK)


// Allocate the index table
// Returns: TRUE if index can be allocated
BOOL InitIndex (LPCAPSTREAM lpcs)
{
    lpcs->dwIndex = 0;

    WinAssert (lpcs->lpdwIndexStart == NULL);

    // Limit index size between 1 minute at 30fps and 3 hours at 30fps
    lpcs->sCapParms.dwIndexSize = max (lpcs->sCapParms.dwIndexSize, 1800);
    lpcs->sCapParms.dwIndexSize = min (lpcs->sCapParms.dwIndexSize, 324000L);
    dprintf("Max Index Size = %ld \n", lpcs->sCapParms.dwIndexSize);

    if (lpcs->hIndex = GlobalAlloc (GMEM_MOVEABLE,
                lpcs->sCapParms.dwIndexSize * sizeof (DWORD))) {
        if (lpcs->lpdwIndexEntry =
                lpcs->lpdwIndexStart =
                (DWORD _huge *)GlobalLock (lpcs->hIndex)) {
            GlobalPageLock (lpcs->hIndex);
            return TRUE;        // Success
        }
        GlobalFree (lpcs->hIndex);
    }
    lpcs->hIndex = NULL;
    lpcs->lpdwIndexStart = NULL;
    return FALSE;
}

// Deallocate the index table
void FiniIndex (LPCAPSTREAM lpcs)
{
    if (lpcs->hIndex) {
        GlobalPageUnlock (lpcs->hIndex);
        if (lpcs->lpdwIndexStart)
            GlobalUnlock (lpcs->hIndex);
        GlobalFree (lpcs->hIndex);
    }
    lpcs->hIndex = NULL;
    lpcs->lpdwIndexStart = NULL;
}


// Add an index entry for a video frame
// dwSize is the size of data ONLY, not including the chunk or junk
// Returns: TRUE if index space is not exhausted
BOOL IndexVideo (LPCAPSTREAM lpcs, DWORD dwSize, BOOL bKeyFrame)
{
    BOOL fOK = lpcs->dwIndex < lpcs->sCapParms.dwIndexSize;

    if (fOK) {
        *lpcs->lpdwIndexEntry++ = dwSize | (bKeyFrame ? IS_KEYFRAME_CHUNK : 0);
        lpcs->dwIndex++;
        lpcs->dwVideoChunkCount++;
    }
    return (fOK);
}


// Add an index entry for an audio buffer
// dwSize is the size of data ONLY, not including the chunk or junk
// Returns: TRUE if index space is not exhausted
BOOL IndexAudio (LPCAPSTREAM lpcs, DWORD dwSize)
{
    BOOL fOK = lpcs->dwIndex < lpcs->sCapParms.dwIndexSize;

    if (fOK) {
        *lpcs->lpdwIndexEntry++ = dwSize | IS_AUDIO_CHUNK;
        lpcs->dwIndex++;
        lpcs->dwWaveChunkCount++;
    }
    return (fOK);
}


// Write out the index at the end of the capture file.
// The single frame capture methods do not append
// JunkChunks!  Audio chunks do not have junk appended.
BOOL WriteIndex (LPCAPSTREAM lpcs, BOOL fJunkChunkWritten)
{
    BOOL  fChunkIsAudio;
    BOOL  fChunkIsKeyFrame;
    BOOL  fChunkIsDummy;
    BOOL  fChunkIsLastDummy;
    DWORD dwIndex;
    DWORD dw;
    DWORD dwDummySize;
    DWORD dwJunk;
    DWORD off;
    AVIINDEXENTRY   avii;
    MMCKINFO    ck;
    DWORD _huge *lpdw;

    if (lpcs->dwIndex > lpcs->sCapParms.dwIndexSize)
        return TRUE;

    off        = lpcs->dwAVIHdrSize;

    ck.cksize  = 0;
    ck.ckid    = ckidAVINEWINDEX;
    ck.fccType = 0;

    if (mmioCreateChunk(lpcs->hmmio,&ck,0))
        return FALSE;

    lpdw = lpcs->lpdwIndexStart;
    for (dwIndex= 0; dwIndex< lpcs->dwIndex; dwIndex++) {

        dw = *lpdw++;

        fChunkIsAudio      = (BOOL) ((dw & IS_AUDIO_CHUNK) != 0);
        fChunkIsKeyFrame   = (BOOL) ((dw & IS_KEYFRAME_CHUNK) != 0);
        fChunkIsDummy      = (BOOL) ((dw & IS_DUMMY_CHUNK) != 0);
        fChunkIsLastDummy  = (BOOL) ((dw & IS_LAST_DUMMY_CHUNK) != 0);
        dw &= ~(INDEX_MASK);

        if (fChunkIsAudio) {
            avii.ckid         = MAKEAVICKID(cktypeWAVEbytes, 1);
            avii.dwFlags      = 0;
        } else {
        if (lpcs->lpBitsInfo->bmiHeader.biCompression == BI_RLE8)
            avii.ckid         = MAKEAVICKID(cktypeDIBcompressed, 0);
        else
            avii.ckid         = MAKEAVICKID(cktypeDIBbits, 0);
            avii.dwFlags      = fChunkIsKeyFrame ? AVIIF_KEYFRAME : 0;
        }
        avii.dwChunkLength    = dw;
        avii.dwChunkOffset    = off;

        if (mmioWrite(lpcs->hmmio, (LPVOID)&avii, sizeof(avii)) != sizeof(avii))
            return FALSE;

        dw += sizeof (RIFF);
        off += dw;

        // ooh, getting messy. We know that dummy chunks come in a group
        // (1 or more) and are always terminated by a IS_LAST_DUMMY_CHUNK flag.
        // only the last one gets junk append to round out to 2K
        if (fChunkIsDummy) {
            dwDummySize += sizeof(RIFF);
            if (!fChunkIsLastDummy)
                continue;
            else
                dw = dwDummySize;   // total size of all dummy entries in group
        }
        else
            dwDummySize = 0;

        if (fJunkChunkWritten & !fChunkIsAudio) {
           // If a Junk chunk was appended, move past it
           if (dw % lpcs->sCapParms.wChunkGranularity) {
                dwJunk = lpcs->sCapParms.wChunkGranularity - (dw % lpcs->sCapParms.wChunkGranularity);

                if (dwJunk < sizeof (RIFF))
                    off += lpcs->sCapParms.wChunkGranularity + dwJunk;
                else
                    off += dwJunk;
           }
        }

         if (off & 1)
             off++;
    }

    if (mmioAscend(lpcs->hmmio, &ck, 0))
        return FALSE;

    return TRUE;
}



// Allocate DOS memory for faster disk writes
LPVOID NEAR PASCAL AllocDosMem (DWORD dw)
{
    HANDLE h;

    if (h = LOWORD (GlobalDosAlloc(dw)))
        return (GlobalLock (h));
    return NULL;
}

// General purpose memory allocator
LPVOID NEAR PASCAL AllocMem (DWORD dw, BOOL fUseDOSMemory)
{
#if 0
    if (fUseDOSMemory)
        return AllocDosMem(dw);
#endif

    return GlobalAllocPtr (GMEM_MOVEABLE, dw);
}

void NEAR PASCAL FreeMem(LPVOID p)
{
    GlobalFreePtr(p);
}


#pragma optimize ("", off)

DWORD GetFreePhysicalMemory(void)
{
    DWORD   adw[ 0x30 / sizeof(DWORD) ];
    WORD    fFail;

    //
    //  if standard mode just ask KERNEL how much memory is free
    //
    //  if enhanced mode, call DPMI and find out how much *real*
    //  memory is free.
    //
    if (GetWinFlags() & WF_STANDARD)
    {
        return GetFreeSpace(0);
    }
    else _asm
    {
        mov     ax, 0500h
        push    ss
        pop     es
        lea     di, word ptr adw
        int     31h
        sbb     ax, ax
        mov     fFail, ax
    }

    if (fFail)
        return (0l);

    return (adw[2] * 4096);
}
#pragma optimize ("", on)

/*
 *  CalcWaveBufferSize   - Figure out how large to make the wave buffers
 *    a. At least .5 seconds
 *    b. But not less than 10K, (else capture frmae rate suffers)
 *    c. A multiple of lpcs->sCapParms.wChunkGranularity
 */
DWORD CalcWaveBufferSize (LPCAPSTREAM lpcs)
{
    DWORD dw;

    if (!lpcs-> lpWaveFormat)
        return 0L;

    // at least .5 second
    dw = (DWORD) lpcs->lpWaveFormat->nChannels *
         (DWORD) lpcs->lpWaveFormat->nSamplesPerSec *
         (lpcs->lpWaveFormat->wBitsPerSample / 8) / 2L;
    dw -= dw % lpcs->sCapParms.wChunkGranularity;
    dw = max ((1024L * 10), dw);                // at least 10K

//    dprintf("Wave buffer size = %ld \n", dw);
    return dw;
}

static BOOL IsWaveInDeviceMapped(HWAVEIN hWaveIn)
{
    DWORD err;
    DWORD dw;

    err = waveInMessage(hWaveIn,
        WIDM_MAPPER_STATUS,
        WAVEIN_MAPPER_STATUS_MAPPED,
        (DWORD)(LPVOID)&dw);

    return err == 0 && dw != 0;
}

// ****************************************************************
// ******************** Capture File Routines *********************
// ****************************************************************


/*
 * AVIFileInit
 *
 *       Perform all initialization required to write a capture file.
 *
 *       We take a slightly strange approach: We don't write
 *       out the header until we're done capturing.  For now,
 *       we just seek 2K into the file, which is where all of
 *       the real data will go.
 *
 *       When we're done, we'll come back and write out the header,
 *       because then we'll know all of the values we need.
 *
 *      Also allocate and init the index.
 */
BOOL AVIFileInit(LPCAPSTREAM lpcs)
{
#define TEMP_BUFF_SIZE  128
    LONG l;
    char ach[TEMP_BUFF_SIZE];
    LPBITMAPINFO lpBitsInfoOut;    // Possibly compressed output format

    /* No special video format given -- use the default */
    if (lpcs->CompVars.hic == NULL)
	lpBitsInfoOut = lpcs->lpBitsInfo;
    else
	lpBitsInfoOut = lpcs->CompVars.lpbiOut;

    WinAssert (lpcs->hmmio == NULL);   // Should never have a file handle on entry

    /* if the capture file has not been set then set it now */
    if (!(*lpcs->achFile)){
//       if (!fileSetCapFile())
             goto INIT_FILE_OPEN_ERROR;
    }

    /* we have a capture file, open it and set it up */
    lpcs->hmmio = mmioOpen(lpcs->achFile, NULL, MMIO_WRITE);
    if (!lpcs->hmmio) {
         /* try and create */
         lpcs->hmmio = mmioOpen(lpcs->achFile, NULL, MMIO_CREATE | MMIO_WRITE);
         if (!lpcs->hmmio) {
             goto INIT_FILE_OPEN_ERROR;
         }
    }

    /* pre-read the file */
    l = mmioSeek( lpcs->hmmio, 0L, SEEK_END );
    while( l > 0 ) {
         l = mmioSeek( lpcs->hmmio, -min(l, 50000L), SEEK_CUR );
        mmioRead( lpcs->hmmio, ach, sizeof(ach) );
    }

    /* Seek to 2K (or multiple of 2K), where we're going to write our data.
    ** later, we'll come back and fill in the file.
    */

    // l is zero for standard wave and video formats
    l = (GetSizeOfWaveFormat ((LPWAVEFORMATEX) lpcs->lpWaveFormat) -
                sizeof (PCMWAVEFORMAT)) +
                (lpBitsInfoOut->bmiHeader.biSize -
                sizeof (BITMAPINFOHEADER));

    // (2K + size of wave and video stream headers) rounded to next 2K
    lpcs->dwAVIHdrSize = AVI_HEADERSIZE +
        (((lpcs->cbInfoChunks + l + lpcs->sCapParms.wChunkGranularity - 1)
        / lpcs->sCapParms.wChunkGranularity) * lpcs->sCapParms.wChunkGranularity);


    dprintf("AVIHdrSize = %ld \n", lpcs->dwAVIHdrSize);
    mmioSeek(lpcs->hmmio, lpcs->dwAVIHdrSize, SEEK_SET);

    if (!InitIndex (lpcs))           // do all Index allocations
        mmioClose (lpcs->hmmio, 0);

    lpcs->dwVideoChunkCount = 0;
    lpcs->dwWaveChunkCount = 0;

INIT_FILE_OPEN_ERROR:
    return (lpcs->hmmio != NULL);
}

/*
 * AVIFileFini
 *
 *       Write out the index, deallocate the index, and close the file.
 *
 */
BOOL AVIFileFini (LPCAPSTREAM lpcs, BOOL fWroteJunkChunks, BOOL fAbort)
{
    MMCKINFO      ckRiff;
    MMCKINFO      ckList;
    MMCKINFO      ckStream;
    MMCKINFO      ck;
    int           i;
    DWORD         dw;
    AVIStreamHeader        strhdr;
    DWORD         dwDataEnd;
    BOOL        fRet = TRUE;
    RGBQUAD     argbq[256];
    MainAVIHeader   aviHdr;
    BOOL        fSound = lpcs->sCapParms.fCaptureAudio;
    LPBITMAPINFO lpBitsInfoOut;    // Possibly compressed output format

    /* No special video format given -- use the default */
    if (lpcs->CompVars.hic == NULL)
	lpBitsInfoOut = lpcs->lpBitsInfo;
    else
	lpBitsInfoOut = lpcs->CompVars.lpbiOut;

    if (lpcs->hmmio == NULL)  // This can be called even though never opened
        return FALSE;

    if (fAbort)
        goto FileError;

    if (!lpcs->dwWaveBytes)
        fSound = FALSE;

    dwDataEnd = mmioSeek(lpcs->hmmio, 0, SEEK_CUR);

    /* Seek to beginning of file, so we can write the header. */
    mmioSeek(lpcs->hmmio, 0, SEEK_SET);

    DSTATUS(lpcs, "Writing AVI header");

    /* Create RIFF chunk */
    ckRiff.cksize = 0;
    ckRiff.fccType = formtypeAVI;
    if(mmioCreateChunk(lpcs->hmmio,&ckRiff,MMIO_CREATERIFF)) {
         goto FileError;
    }

    /* Create header list */
    ckList.cksize = 0;
    ckList.fccType = listtypeAVIHEADER;
    if(mmioCreateChunk(lpcs->hmmio,&ckList,MMIO_CREATELIST)) {
         goto FileError;
    }

    /* Create AVI header chunk */
    ck.cksize = sizeof(MainAVIHeader);
    ck.ckid = ckidAVIMAINHDR;
    if(mmioCreateChunk(lpcs->hmmio,&ck,0)) {
         goto FileError;
    }

    lpcs->dwAVIHdrPos = ck.dwDataOffset;

    /* Calculate AVI header info */
    _fmemset(&aviHdr, 0, sizeof(aviHdr));
    if (fSound && lpcs->dwVideoChunkCount) {
         /* HACK HACK */
         /* Set rate that was captured based on length of audio data */

         aviHdr.dwMicroSecPerFrame = (DWORD)
                ((double)lpcs->dwWaveBytes * 1000000. /
                ((double)lpcs->lpWaveFormat->nAvgBytesPerSec *
                lpcs->dwVideoChunkCount + 0.5));
    } else {
         aviHdr.dwMicroSecPerFrame = lpcs->sCapParms.dwRequestMicroSecPerFrame;
    }
    lpcs->dwActualMicroSecPerFrame = aviHdr.dwMicroSecPerFrame;

    aviHdr.dwMaxBytesPerSec = (DWORD) muldiv32 (lpBitsInfoOut->bmiHeader.biSizeImage,
                                      1000000,
                                      lpcs->sCapParms.dwRequestMicroSecPerFrame) +
                                      (fSound ? lpcs->lpWaveFormat->nAvgBytesPerSec : 0);
    aviHdr.dwPaddingGranularity = 0L;
    aviHdr.dwFlags = AVIF_WASCAPTUREFILE | AVIF_HASINDEX;
    aviHdr.dwStreams = fSound ? 2 : 1;
    aviHdr.dwTotalFrames = lpcs->dwVideoChunkCount;
    aviHdr.dwInitialFrames = 0L;
    aviHdr.dwSuggestedBufferSize = 0L;
    aviHdr.dwWidth = lpBitsInfoOut->bmiHeader.biWidth;
    aviHdr.dwHeight = lpBitsInfoOut->bmiHeader.biHeight;

//  The following were set for all versions before Chicago Beta2
//  They are now listed as reserved...
//    aviHdr.dwRate = 1000000L;
//    aviHdr.dwScale = aviHdr.dwMicroSecPerFrame;
//    aviHdr.dwStart = 0L;
//    aviHdr.dwLength = lpcs->dwVideoChunkCount;

    /* Write AVI header info */
    if(mmioWrite(lpcs->hmmio, (LPSTR)&aviHdr, sizeof(aviHdr)) !=
             sizeof(aviHdr)) {
         goto FileError;
    }

    if(mmioAscend(lpcs->hmmio, &ck, 0)) {
         goto FileError;
    }

    DSTATUS(lpcs, "Writing AVI Stream header");

    /* Create stream header list */
    ckStream.cksize = 0;
    ckStream.fccType = listtypeSTREAMHEADER;
    if(mmioCreateChunk(lpcs->hmmio,&ckStream,MMIO_CREATELIST)) {
         goto FileError;
    }

    _fmemset(&strhdr, 0, sizeof(strhdr));
    strhdr.fccType = streamtypeVIDEO;
    if (lpcs->CompVars.hic)
        strhdr.fccHandler = lpcs->CompVars.fccHandler;
    else
        strhdr.fccHandler = lpBitsInfoOut->bmiHeader.biCompression;

    // A bit of history...
    // In VFW 1.0, we set fccHandler to 0 for BI_RLE8 formats
    // as a kludge to make Mplayer and Videdit play the files.
    // Just prior to 1.1 release, we found this broke Premiere,
    // so now (after AVICAP beta is on Compuserve), we change the
    // fccHandler to "MRLE".  Just ask Todd...
    // And now, at RC1, we change it again to "RLE ", Just ask Todd...
    if (strhdr.fccHandler == BI_RLE8)
        strhdr.fccHandler = mmioFOURCC('R', 'L', 'E', ' ');

    strhdr.dwFlags = 0L;
    strhdr.wPriority = 0L;
    strhdr.wLanguage = 0L;
    strhdr.dwInitialFrames = 0L;
    strhdr.dwScale = aviHdr.dwMicroSecPerFrame;
    strhdr.dwRate = 1000000L;
    strhdr.dwStart = 0L;
    strhdr.dwLength = lpcs->dwVideoChunkCount;        /* Needs to get filled in! */
    strhdr.dwQuality = (DWORD) -1L;         /* !!! ICQUALITY_DEFAULT */
    strhdr.dwSampleSize = 0L;

    ck.ckid = ckidSTREAMHEADER;
    if(mmioCreateChunk(lpcs->hmmio,&ck,0)) {
         goto FileError;
    }

    /* Write stream header data */
    if(mmioWrite(lpcs->hmmio, (LPSTR)&strhdr, sizeof(strhdr)) != sizeof(strhdr)) {
         goto FileError;
    }

    if(mmioAscend(lpcs->hmmio, &ck, 0)) {
         goto FileError;
    }

    /*
    **  !!! dont write palette for full color?
    */
    if (lpBitsInfoOut->bmiHeader.biBitCount > 8)
        lpBitsInfoOut->bmiHeader.biClrUsed = 0;

    /* Create DIB header chunk */
    ck.cksize = lpBitsInfoOut->bmiHeader.biSize +
                           lpBitsInfoOut->bmiHeader.biClrUsed *
                           sizeof(RGBQUAD);
    ck.ckid = ckidSTREAMFORMAT;
    if(mmioCreateChunk(lpcs->hmmio,&ck,0)) {
         goto FileError;
    }

    /* Write DIB header data */
    if(mmioWrite(lpcs->hmmio, (LPSTR)&lpBitsInfoOut->bmiHeader,
                               lpBitsInfoOut->bmiHeader.biSize) !=
             (LONG) lpBitsInfoOut->bmiHeader.biSize) {
         goto FileError;
    }

    if (lpBitsInfoOut->bmiHeader.biClrUsed > 0) {
        /* Get Palette info */
        if(GetPaletteEntries(lpcs->hPalCurrent, 0,
                                (WORD) lpBitsInfoOut->bmiHeader.biClrUsed,
                                (LPPALETTEENTRY) argbq) !=
                    (WORD)lpBitsInfoOut->bmiHeader.biClrUsed) {
            goto FileError;
        }

        for(i = 0; i < (int) lpBitsInfoOut->bmiHeader.biClrUsed; i++)
            SWAP(argbq[i].rgbRed, argbq[i].rgbBlue);

        /* Write Palette Info */
        dw = sizeof(RGBQUAD) * lpBitsInfoOut->bmiHeader.biClrUsed;
        if (mmioWrite(lpcs->hmmio, (LPSTR)argbq, dw) != (long)dw) {
            goto FileError;
        }
    }

    if(mmioAscend(lpcs->hmmio, &ck, 0)) {
         goto FileError;
    }

    // ADD FOURCC stuff here!!! for Video stream

    /* Ascend out of stream header */
    if(mmioAscend(lpcs->hmmio, &ckStream, 0)) {
         goto FileError;
    }

    /* If sound is enabled, then write WAVE header */
    if(fSound) {

         /* Create stream header list */
         ckStream.cksize = 0;
         ckStream.fccType = listtypeSTREAMHEADER;
         if(mmioCreateChunk(lpcs->hmmio,&ckStream,MMIO_CREATELIST)) {
             goto FileError;
         }

         _fmemset(&strhdr, 0, sizeof(strhdr));
         strhdr.fccType = streamtypeAUDIO;
         strhdr.fccHandler = 0L;
         strhdr.dwFlags = 0L;
         strhdr.wPriority = 0L;
         strhdr.wLanguage = 0L;
         strhdr.dwInitialFrames = 0L;
         strhdr.dwScale = lpcs->lpWaveFormat->nBlockAlign;
         strhdr.dwRate = lpcs->lpWaveFormat->nAvgBytesPerSec;
         strhdr.dwStart = 0L;
         strhdr.dwLength =  lpcs->dwWaveBytes /
                        lpcs->lpWaveFormat->nBlockAlign;
         strhdr.dwQuality = (DWORD)-1L;    /* !!! ICQUALITY_DEFAULT */
         strhdr.dwSampleSize = lpcs->lpWaveFormat->nBlockAlign;

         ck.ckid = ckidSTREAMHEADER;
         if(mmioCreateChunk(lpcs->hmmio,&ck,0)) {
             goto FileError;
         }

         if(mmioWrite(lpcs->hmmio, (LPSTR)&strhdr, sizeof(strhdr)) != sizeof(strhdr)) {
             goto FileError;
         }

         if(mmioAscend(lpcs->hmmio, &ck, 0)) {
             goto FileError;
         }

         ck.cksize = (LONG) GetSizeOfWaveFormat ((LPWAVEFORMATEX) lpcs->lpWaveFormat);
         ck.ckid = ckidSTREAMFORMAT;
         if(mmioCreateChunk(lpcs->hmmio,&ck,0)) {
             goto FileError;
         }

         /* Write WAVE header info */
         if(mmioWrite(lpcs->hmmio, (LPSTR)lpcs->lpWaveFormat, ck.cksize) != (LONG) ck.cksize) {
             goto FileError;
         }

         if(mmioAscend(lpcs->hmmio, &ck, 0)) {
             goto FileError;
         }

         /* Ascend out of stream header */
         if(mmioAscend(lpcs->hmmio, &ckStream, 0)) {
             goto FileError;
         }

    }

    // ADD FOURCC stuff here!!! for entire file
    DSTATUS(lpcs, "Writing Info chunks");
    if (lpcs->lpInfoChunks) {
        DSTATUS(lpcs, "Writing Info chunks");
        if (mmioWrite (lpcs->hmmio, lpcs->lpInfoChunks, lpcs->cbInfoChunks) !=
                lpcs->cbInfoChunks)
            goto FileError;
    }

    /* ascend from the Header list */
    if(mmioAscend(lpcs->hmmio, &ckList, 0)) {
         goto FileError;
    }


    ck.ckid = ckidAVIPADDING;
    if(mmioCreateChunk(lpcs->hmmio,&ck,0)) {
         goto FileError;
    }

    mmioSeek(lpcs->hmmio, lpcs->dwAVIHdrSize - 3 * sizeof(DWORD), SEEK_SET);

    if(mmioAscend(lpcs->hmmio, &ck, 0)) {
         goto FileError;
    }

    DSTATUS(lpcs, "Writing Movie LIST");

    /* Start the movi list */
    ckList.cksize = 0;
    ckList.fccType = listtypeAVIMOVIE;
    if(mmioCreateChunk(lpcs->hmmio,&ckList,MMIO_CREATELIST)) {
         goto FileError;
    }

    // Force the chunk to end on the next word boundary
    mmioSeek(lpcs->hmmio, dwDataEnd + (dwDataEnd & 1L), SEEK_SET);

    /* Ascend out of the movi list and the RIFF chunk so that */
    /* the sizes can be fixed */
    mmioAscend(lpcs->hmmio, &ckList, 0);

    /*
    ** Now write index out!
    */
    DSTATUS(lpcs, "Writing Index...");
    WriteIndex(lpcs, fWroteJunkChunks);

    lpcs->fFileCaptured = TRUE;     // we got a good file, allow editing of it
    goto Success;

FileError:
    lpcs->fFileCaptured = fRet = FALSE;      // bogus file - no editing allowed

Success:
    DSTATUS(lpcs, "Freeing Index...");
    FiniIndex (lpcs);
    mmioAscend(lpcs->hmmio, &ckRiff, 0);

    mmioSeek(lpcs->hmmio, 0, SEEK_END);

    mmioFlush(lpcs->hmmio, 0);

    /* Close the file */
    mmioClose(lpcs->hmmio, 0);
    lpcs->hmmio = NULL;

    return fRet;
}


// ****************************************************************
// ******************** Audio Buffer Control **********************
// ****************************************************************

// Audio buffers are always allocated under the presumption that
// audio capture may be enabled at any time.
// AVIAudioInit must be matched with AVIAudioFini (both only called once)
// AVIAudioPrepare must be matched with AVIAudioUnPrepare
//      (which may be called multiple times to enable and disable audio)


// AVI AudioInit - Allocate and initialize buffers for audio capture.
//                 This routine is also used by MCI capture.
//                 Returns: 0 on success, otherwise an error code.

WORD AVIAudioInit (LPCAPSTREAM lpcs)
{
    int         i;
    LPVOID        p;

    if (lpcs->sCapParms.wNumAudioRequested == 0)
        lpcs->sCapParms.wNumAudioRequested = DEF_WAVE_BUFFERS;

    // Alloc the wave memory
    for(i = 0; i < (int)lpcs->sCapParms.wNumAudioRequested; i++) {

        p = AllocMem(sizeof(WAVEHDR) + lpcs->dwWaveSize, FALSE /* DOSMem */);

        if (p == NULL)
            break;

        lpcs->alpWaveHdr[i] = p;
        lpcs->alpWaveHdr[i]->lpData          = (LPBYTE)p
                                               + sizeof(WAVEHDR) + sizeof(RIFF);
        lpcs->alpWaveHdr[i]->dwBufferLength  = lpcs->dwWaveSize - sizeof(RIFF);
        lpcs->alpWaveHdr[i]->dwBytesRecorded = 0;
        lpcs->alpWaveHdr[i]->dwUser          = 0;
        lpcs->alpWaveHdr[i]->dwFlags         = 0;
        lpcs->alpWaveHdr[i]->dwLoops         = 0;

        /* Set Chunk ID, Size in buffer */
        p = (LPBYTE)p + sizeof(WAVEHDR);

        ((LPRIFF)p)->dwType = MAKEAVICKID(cktypeWAVEbytes, 1);
        ((LPRIFF)p)->dwSize = lpcs->dwWaveSize - sizeof(RIFF);
    }

    lpcs->iNumAudio = i;

    return ((lpcs->iNumAudio == 0) ? IDS_CAP_WAVE_ALLOC_ERROR : 0);
}


//
// AVI AudioFini    - UnPrepares headers and resets the wave device.
//                      This routine is also used by MCI capture.
//                      Returns: 0 on success, otherwise an error code.

WORD AVIAudioFini (LPCAPSTREAM lpcs)
{
    int i;

    /* free headers and data */
    for(i=0; i < MAX_WAVE_BUFFERS; i++) {
        if (lpcs->alpWaveHdr[i]) {
            FreeMem(lpcs->alpWaveHdr[i]);
            lpcs->alpWaveHdr[i] = NULL;
        }
    }

    return 0;
}


//
// AVI AudioPrepare - Opens the wave device and adds the buffers
//                    Prepares headers and adds buffers to the device
//                    This routine is also used by MCI capture.
//                    Returns: 0 on success, otherwise an error code.

WORD AVIAudioPrepare (LPCAPSTREAM lpcs, HWND hWndCallback)
{
    UINT        uiError;
    int i;

    /* See if we can open that format for input */

    uiError = waveInOpen((LPHWAVEIN)&lpcs->hWaveIn,
        (UINT)WAVE_MAPPER, lpcs->lpWaveFormat,
        (DWORD) hWndCallback, 0L,
        (hWndCallback ? CALLBACK_WINDOW : 0L));

    if (uiError != MMSYSERR_NOERROR)
        return IDS_CAP_WAVE_OPEN_ERROR;

    lpcs->fAudioYield = IsWaveInDeviceMapped(lpcs->hWaveIn);
    lpcs->fAudioBreak = FALSE;
    DPF("AVICap:    AudioYield = %d \n", lpcs->fAudioYield);

    for(i = 0; i < (int)lpcs->sCapParms.wNumAudioRequested; i++) {
        if (waveInPrepareHeader(lpcs->hWaveIn, lpcs->alpWaveHdr[i],
                sizeof(WAVEHDR)))
            return IDS_CAP_WAVE_ALLOC_ERROR;

        if (waveInAddBuffer(lpcs->hWaveIn, lpcs->alpWaveHdr[i],
                sizeof(WAVEHDR)))
            return IDS_CAP_WAVE_ALLOC_ERROR;
    }

    lpcs->iNextWave = 0;        // current wave
    lpcs->dwWaveBytes = 0L;     // number of wave bytes
    lpcs->dwWaveChunkCount = 0; // number of wave frames

    return 0;
}

//
// AVI AudioUnPrepare - UnPrepares headers and closes the wave device.
//                      This routine is also used by MCI capture.
//                      Returns: 0 on success, otherwise an error code.

WORD AVIAudioUnPrepare (LPCAPSTREAM lpcs)
{
    int i;

    if (lpcs->hWaveIn) {
        waveInReset(lpcs->hWaveIn);

        /* unprepare headers by unlocking them */
        for(i=0; i < lpcs->iNumAudio; i++) {
            if (lpcs->alpWaveHdr[i]) {
                if (lpcs->alpWaveHdr[i]->dwFlags & WHDR_PREPARED)
                    waveInUnprepareHeader(lpcs->hWaveIn, lpcs->alpWaveHdr[i],
                                sizeof(WAVEHDR));
            }
        }

        waveInClose(lpcs->hWaveIn);
        lpcs->hWaveIn = NULL;
    }
    return 0;
}

// ****************************************************************
// ******************** Video Buffer Control **********************
// ****************************************************************

// AVIVideoInit -  Allocates, and initialize buffers for video capture.
//                 This routine is also used by MCI capture.
//                 Returns: 0 on success, otherwise an error code.

WORD AVIVideoInit (LPCAPSTREAM lpcs)
{
    int         iMaxVideo;
    DWORD       dwFreeMem;
    DWORD       dwUserRequests;
    DWORD       dwAudioMem;
    int         i;
    LPVOID      p;

    lpcs->iNextVideo = 0;
    lpcs->dwVideoChunkCount = 0;
    lpcs->dwFramesDropped = 0;

    // When performing MCI step capture, buffer array is not used
    if (lpcs->sCapParms.fStepMCIDevice)
        return 0;

    // If the user hasn't specified the number of video buffers to use,
    // assume the minimum

    if (lpcs->sCapParms.wNumVideoRequested == 0)
        lpcs->sCapParms.wNumVideoRequested = MIN_VIDEO_BUFFERS;

    iMaxVideo = min (MAX_VIDEO_BUFFERS, lpcs->sCapParms.wNumVideoRequested);

    // Post VFW 1.1a, see if the driver can allocate memory
    if (videoStreamAllocHdrAndBuffer (lpcs->hVideoIn,
                (LPVIDEOHDR FAR *) &p, (DWORD) sizeof(VIDEOHDR) + lpcs->dwVideoSize)
                        == DV_ERR_OK) {
        lpcs-> fBuffersOnHardware = TRUE;
        videoStreamFreeHdrAndBuffer (lpcs->hVideoIn, (LPVIDEOHDR) p);
    }
    else {
        lpcs-> fBuffersOnHardware = FALSE;

        // How much actual free physical memory exists?
        dwFreeMem = GetFreePhysicalMemory();

        dwAudioMem = lpcs->dwWaveSize * lpcs->sCapParms.wNumAudioRequested;

#define FOREVER_FREE 32768L   // Always keep this free for swap space

        // How much memory will be used if we allocate per the request?
        dwUserRequests = dwAudioMem +
                     lpcs->dwVideoSize * iMaxVideo +
                     FOREVER_FREE;

        // If request is greater than available memory, force fewer buffers
        if (dwUserRequests > dwFreeMem) {
            if (dwFreeMem > dwAudioMem)
                dwFreeMem -= dwAudioMem;
            iMaxVideo = (int)(((dwFreeMem * 8) / 10) / lpcs->dwVideoSize);
            iMaxVideo = min (MAX_VIDEO_BUFFERS, iMaxVideo);
            dprintf("iMaxVideo = %d\n", iMaxVideo);
        }
    } // endif not allocating buffers from hardware

    // Set up the buffers presuming fixed size DIBs and Junk chunks
    // These will be modified later if the device provides compressed data

    for (i=0; i < iMaxVideo; i++) {

        if (lpcs-> fBuffersOnHardware)
            videoStreamAllocHdrAndBuffer (lpcs->hVideoIn,
                (LPVIDEOHDR FAR *) &p, sizeof(VIDEOHDR) + lpcs->dwVideoSize);
        else
            p = AllocMem(sizeof(VIDEOHDR) + lpcs->dwVideoSize, lpcs->sCapParms.fUsingDOSMemory /* DOSMem */);

        if (p == NULL)
            break;

        lpcs->alpVideoHdr[i] = p;
        lpcs->alpVideoHdr[i]->lpData          = (LPBYTE)p + sizeof(VIDEOHDR) + sizeof(RIFF);
        lpcs->alpVideoHdr[i]->dwBufferLength  = lpcs->lpBitsInfo->bmiHeader.biSizeImage;
        lpcs->alpVideoHdr[i]->dwBytesUsed     = 0;
        lpcs->alpVideoHdr[i]->dwTimeCaptured  = 0;
        lpcs->alpVideoHdr[i]->dwUser          = 0;
        // Buffers on hardware are marked prepared during allocation!
        if (!lpcs-> fBuffersOnHardware)
            lpcs->alpVideoHdr[i]->dwFlags     = 0;

        p = (LPBYTE)p + sizeof(VIDEOHDR);

        if (lpcs->lpBitsInfo->bmiHeader.biCompression == BI_RLE8)
             ((LPRIFF)p)->dwType = MAKEAVICKID(cktypeDIBcompressed, 0);
        else
             ((LPRIFF)p)->dwType = MAKEAVICKID(cktypeDIBbits, 0);
         ((LPRIFF)p)->dwSize = lpcs->lpBitsInfo->bmiHeader.biSizeImage;

         if(lpcs->dwVideoJunkSize) {
             p = ((BYTE huge *)p) + ((LPRIFF)p)->dwSize + sizeof(RIFF);

             ((LPRIFF)p)->dwType = ckidAVIPADDING;;
             ((LPRIFF)p)->dwSize = lpcs->dwVideoJunkSize;
         }
    }

    lpcs->iNumVideo = i;

    if (lpcs-> fBuffersOnHardware)
        dprintf("HARDWARE iNumVideo Allocated = %d \n", lpcs->iNumVideo);
    else if (lpcs->sCapParms.fUsingDOSMemory)
        dprintf("DOS iNumVideo Allocated = %d \n", lpcs->iNumVideo);
    else
        dprintf("HIGH iNumVideo Allocated = %d \n", lpcs->iNumVideo);

    return ((lpcs->iNumVideo == 0) ? IDS_CAP_VIDEO_ALLOC_ERROR : 0);
}

//
// AVIVideoPrepare -  Prepares headers and adds buffers to the device
//                    This routine is also used by MCI capture.
//                    Returns: 0 on success, otherwise an error code.
WORD AVIVideoPrepare (LPCAPSTREAM lpcs)
{
    int i;

    // When performing MCI step capture, buffer array is not used
    if (lpcs->sCapParms.fStepMCIDevice)
        return 0;

    // Open the video stream, setting the capture rate
    if (videoStreamInit(lpcs->hVideoIn,
                lpcs->sCapParms.dwRequestMicroSecPerFrame,
                0L, 0L, 0L )) {
        dprintf("cant open video device!\n");
        return IDS_CAP_VIDEO_OPEN_ERROR;
    }

    // Prepare (lock) the buffers, and give them to the device
    for (i=0; i < lpcs->iNumVideo; i++) {
        // If the buffers are on the hardware, don't Prepare them
        if (!lpcs-> fBuffersOnHardware) {
            if (videoStreamPrepareHeader (lpcs->hVideoIn,
                        lpcs->alpVideoHdr[i], sizeof(VIDEOHDR))) {
                lpcs->iNumVideo = i;
                dprintf("**** could only prepare %d Video!\n", lpcs->iNumVideo);
                break;
            }
        }

        if (videoStreamAddBuffer(lpcs->hVideoIn, lpcs->alpVideoHdr[i], sizeof(VIDEOHDR)))
             return IDS_CAP_VIDEO_ALLOC_ERROR;
    }
    return 0;
}

//
// AVI VideoUnPrepare - UnPrepares headers, frees memory, and
//                      resets the video in device.
//                      This routine is also used by MCI capture.
//                      Returns: 0 on success, otherwise an error code.

WORD AVIVideoUnPrepare (LPCAPSTREAM lpcs)
{
    int i;

    // When performing MCI step capture, buffer array is not used
    if (lpcs->sCapParms.fStepMCIDevice)
        return 0;

    /* Reset the buffers so they can be freed */
    if (lpcs->hVideoIn) {
        videoStreamReset(lpcs->hVideoIn);

        /* unprepare headers */
        /* Unlock and free headers and data */

        for(i = 0; i < MAX_VIDEO_BUFFERS; i++) {
            if (lpcs->alpVideoHdr[i]) {
                if (!lpcs-> fBuffersOnHardware) {
                    if (lpcs->alpVideoHdr[i]->dwFlags & VHDR_PREPARED)
                        videoStreamUnprepareHeader(lpcs->hVideoIn,
                            lpcs->alpVideoHdr[i],sizeof(VIDEOHDR));

                    FreeMem(lpcs->alpVideoHdr[i]);
                }
                else
                    videoStreamFreeHdrAndBuffer(lpcs->hVideoIn, lpcs->alpVideoHdr[i]);
                lpcs->alpVideoHdr[i] = NULL;
            }
        }
        // Shut down the video stream
        videoStreamFini(lpcs->hVideoIn);
    }
    return 0;
}

/*
 *  AVI Fini    - undo the mess that AVIInit did.
 *
 */
void AVIFini(LPCAPSTREAM lpcs)
{
    if (lpcs->lpDOSWriteBuffer) {
        FreeMem(lpcs->lpDOSWriteBuffer);
        lpcs->lpDOSWriteBuffer = NULL;
    }

    AVIVideoUnPrepare (lpcs);           // Free the video device and buffers

    AVIAudioUnPrepare (lpcs);           // Free the audio device
    AVIAudioFini (lpcs);                // Free the audio buffers
}

//
// AVI Init
//     This routine does all the non-File initalization for AVICapture.
//     Returns: 0 on success, Error string value on failure.
//

WORD AVIInit (LPCAPSTREAM lpcs)
{
    WORD         wError = 0;    // Success
    int          i;
    LPBITMAPINFO lpBitsInfoOut;    // Possibly compressed output format

    /* No special video format given -- use the default */
    if (lpcs->CompVars.hic == NULL)
	lpBitsInfoOut = lpcs->lpBitsInfo;
    else
	lpBitsInfoOut = lpcs->CompVars.lpbiOut;

    // -------------------------------------------------------
    // figure out buffer sizes
    // -------------------------------------------------------

    // Init all pointers to NULL
    for(i = 0; i < MAX_VIDEO_BUFFERS; i++)
        lpcs->alpVideoHdr[i] = NULL;

    for(i = 0; i < MAX_WAVE_BUFFERS; i++)
        lpcs->alpWaveHdr[i] = NULL;

    // .5 second of audio per buffer (or 10K, whichever is larger)
    if (lpcs->sCapParms.dwAudioBufferSize == 0)
        lpcs->dwWaveSize =  CalcWaveBufferSize (lpcs);
    else {
        if (!lpcs-> lpWaveFormat)
            lpcs->dwWaveSize = 0;
        else
            lpcs->dwWaveSize = lpcs->sCapParms.dwAudioBufferSize;
    }
    /* Set video buffer size to Image size
        (normally dx * dy * (depth / 8)) + sizeof(RIFF) */
    lpcs->dwVideoSize = lpcs->lpBitsInfo->bmiHeader.biSizeImage + sizeof(RIFF);
    lpcs->fVideoDataIsCompressed = (lpBitsInfoOut->bmiHeader.biCompression
                != BI_RGB);

    /* Pad out to multiple of lpcs->sCapParms.wChunkGranularity (2K) size */
    // Calc dwVideoJunkSize

    if (lpcs->dwVideoJunkSize = lpcs->sCapParms.wChunkGranularity - (lpcs->dwVideoSize % lpcs->sCapParms.wChunkGranularity)) {
         if (lpcs->dwVideoJunkSize < sizeof(RIFF))
             lpcs->dwVideoJunkSize += lpcs->sCapParms.wChunkGranularity;

         lpcs->dwVideoSize += lpcs->dwVideoJunkSize;

         lpcs->dwVideoJunkSize -= sizeof(RIFF);
    } else {
         lpcs->dwVideoJunkSize = 0L;
    }

    // -------------------------------------------------------
    //                    DOS copy buffer
    // -------------------------------------------------------

    lpcs->dwDOSBufferSize = max (lpcs->dwWaveSize, lpcs->dwVideoSize);

#if 0
    // Only get a DOS copy buffer if we're not trying to get DOS video buffers
    if (!lpcs->sCapParms.fUsingDOSMemory) {
        lpcs->lpDOSWriteBuffer = AllocDosMem(lpcs->dwDOSBufferSize);

        if (lpcs->lpDOSWriteBuffer) {
            dprintf("Allocated DOS write buffer (%ld bytes).\n", lpcs->dwDOSBufferSize);
        } else {
            dprintf("Unable to allocate DOS write buffer.\n");
        }
    }
#endif

    // -------------------------------------------------------
    //                    Init Sound
    // -------------------------------------------------------

    if (lpcs->sCapParms.fCaptureAudio) {
        if (wError = AVIAudioInit (lpcs)) {
            dprintf("can't init audio buffers!\n");
            goto AVIInitFailed;
        }
    }

    // -------------------------------------------------------
    //                    Init Video
    // -------------------------------------------------------

    if (wError = AVIVideoInit (lpcs)) {
        dprintf("AVIVideoInitFailed (no buffers alloc'd)!\n");
        goto AVIInitFailed;
    }

    // --------------------------------------------------------------
    //  Prepare audio buffers (lock em down) and give them to the device
    // --------------------------------------------------------------

    if (lpcs->sCapParms.fCaptureAudio) {
        if (wError = AVIAudioPrepare (lpcs, NULL)) {
            dprintf("can't prepare audio buffers!\n");
            goto AVIInitFailed;
        }
    }

    // --------------------------------------------------------------
    //  Prepare video buffers (lock em down) and give them to the device
    // --------------------------------------------------------------

    if (wError = AVIVideoPrepare (lpcs)) {
        dprintf("can't prepare video buffers!\n");
        goto AVIInitFailed;
    }

    // -------------------------------------------------------
    //   all done, return success
    // -------------------------------------------------------

    return (0);            // SUCCESS !

    // -------------------------------------------------------
    //   we got a error, return string ID of error message
    // -------------------------------------------------------
AVIInitFailed:
    AVIFini(lpcs);      // Shutdown everything
    return wError;
}

// Write data to the capture file
// Returns: TRUE on a successful write
BOOL NEAR PASCAL AVIWrite(LPCAPSTREAM lpcs, LPVOID p, DWORD dwSize)
{
    if (lpcs->lpDOSWriteBuffer) {
        MemCopy(lpcs->lpDOSWriteBuffer, p, dwSize);
        p = lpcs->lpDOSWriteBuffer;
    }

    return mmioWrite(lpcs->hmmio, p, (long)dwSize) == (long)dwSize;
}

//
// Writes dummy frames which on playback just repeat the previous frame
// nCount is a count of the number of frames to write
// Returns: TRUE on a successful write
BOOL AVIWriteDummyFrames (LPCAPSTREAM lpcs, int nCount)
{
    DWORD dwBytesToWrite;
    DWORD dwJunkSize;
    LPRIFF p;
    int j;

    p = (LPRIFF) lpcs->DropFrame;
    for (j = 0; j < nCount; j++) {
        // The index includes info on if this is a dummy chunk,
        // AND if this is the last dummy chunk in a sequence
        IndexVideo (lpcs, IS_DUMMY_CHUNK |
                ((j == nCount - 1) ? IS_LAST_DUMMY_CHUNK : 0), FALSE);
        if (lpcs->lpBitsInfo->bmiHeader.biCompression == BI_RLE8)
            p->dwType = MAKEAVICKID(cktypeDIBcompressed, 0);
        else
            p->dwType  = MAKEAVICKID(cktypeDIBbits, 0);
        p->dwSize  = 0;
        p++;
    }

    dwBytesToWrite = nCount * sizeof(RIFF);

    /* Pad out to multiple of lpcs->sCapParms.wChunkGranularity (2K) size */

    if (dwJunkSize = (dwBytesToWrite % lpcs->sCapParms.wChunkGranularity)) {
       dwJunkSize = lpcs->sCapParms.wChunkGranularity - dwJunkSize;
       if (dwJunkSize < sizeof(RIFF))
            dwJunkSize += lpcs->sCapParms.wChunkGranularity;

        dwBytesToWrite += dwJunkSize;

        dwJunkSize -= sizeof(RIFF);
    } else {
        dwJunkSize = 0L;
    }

    // Now create a new junk chunk at the end of the compressed data
    if(dwJunkSize) {
        p->dwType = ckidAVIPADDING;
        p->dwSize = dwJunkSize;
    }

    /* write out the dummy frames, and possibly the junk chunk */
    return (AVIWrite(lpcs, lpcs->DropFrame, dwBytesToWrite));
}

// Writes compressed or uncompressed frames to the AVI file
// returns TRUE if no error, FALSE if end of file.

BOOL AVIWriteVideoFrame (LPCAPSTREAM lpcs, LPVIDEOHDR lpVidHdr)
{
    DWORD dwBytesToWrite;
    DWORD dwJunkSize;
    LPVOID p;
    LPVOID lpData;

    // If the device compresses the data, calculate new junk chunk
    // and fix the RIFF header

    //
    // We are automatically compressing during capture, so
    // first compress the frame.
    //
    if (lpcs->CompVars.hic) {
        DWORD       dwBytesUsed = 0;	// don't force a data rate
        BOOL        fKeyFrame;

        lpData = ICSeqCompressFrame(&lpcs->CompVars, 0,
            lpVidHdr->lpData, &fKeyFrame, &dwBytesUsed);

        ((RIFF FAR*)lpData)[-1].dwType = MAKEAVICKID(cktypeDIBbits, 0);
        ((RIFF FAR*)lpData)[-1].dwSize = dwBytesUsed;

        if (fKeyFrame)
            lpVidHdr->dwFlags |= VHDR_KEYFRAME;
        else
            lpVidHdr->dwFlags &= ~VHDR_KEYFRAME;

        lpVidHdr->dwBytesUsed = dwBytesUsed;
    }
    else {
        lpData = lpVidHdr->lpData;
    }

    if (lpcs->fVideoDataIsCompressed) {       // ie. if not BI_RGB

        // change the dwSize field in the RIFF chunk
        *((LPDWORD)((BYTE _huge *)lpVidHdr->lpData - sizeof(DWORD)))
                = lpVidHdr->dwBytesUsed;

         // Make sure that the JUNK chunk starts on a WORD boundary
         if (lpVidHdr->dwBytesUsed & 1)
             ++lpVidHdr->dwBytesUsed;

        dwBytesToWrite = lpVidHdr->dwBytesUsed + sizeof(RIFF);

        /* Pad out to multiple of lpcs->sCapParms.wChunkGranularity (2K) size */

        if (dwJunkSize = (dwBytesToWrite % lpcs->sCapParms.wChunkGranularity)) {
             dwJunkSize = lpcs->sCapParms.wChunkGranularity - dwJunkSize;
             if (dwJunkSize < sizeof(RIFF))
                dwJunkSize += lpcs->sCapParms.wChunkGranularity;

            dwBytesToWrite += dwJunkSize;

             // Now create a new junk chunk at the end of the compressed data
             p = (BYTE huge *)lpVidHdr->lpData + lpVidHdr->dwBytesUsed;

             ((LPRIFF)p)->dwType = ckidAVIPADDING;
             ((LPRIFF)p)->dwSize = dwJunkSize - sizeof(RIFF);
        }
    } // endif compressed data
    else {
        dwBytesToWrite = lpcs->dwVideoSize;
    } // endif not compressed data

    /* write out the chunk, video data, and possibly the junk chunk */
    return (AVIWrite(lpcs, (LPBYTE)lpData - sizeof(RIFF), dwBytesToWrite));
}

//
// Maintains info chunks which are written to the AVI header
//
BOOL FAR PASCAL SetInfoChunk(LPCAPSTREAM lpcs, LPCAPINFOCHUNK lpcic)
{
    DWORD       ckid   = lpcic->fccInfoID;
    LPVOID      lpData = lpcic->lpData;
    LONG        cbData = lpcic->cbData;
    LPBYTE      lp;
    LPBYTE      lpw;
    LPBYTE      lpEnd;
    LPBYTE      lpNext;
    LONG        cbSizeThis;
    BOOL        fOK = FALSE;

    // Delete all info chunks?
    if (ckid == 0) {
        if (lpcs->lpInfoChunks) {
            GlobalFreePtr (lpcs->lpInfoChunks);
            lpcs->lpInfoChunks = NULL;
            lpcs->cbInfoChunks = 0;
        }
        return TRUE;
    }

    // Try removing an entry if it already exists...
    // Also used if lpData is NULL to just remove an entry
    lpw   = (LPBYTE)lpcs->lpInfoChunks;           // always points at fcc
    lpEnd = (LPBYTE)lpcs->lpInfoChunks + lpcs->cbInfoChunks;
    while (lpw < lpEnd) {
        cbSizeThis = ((LPDWORD)lpw)[1];
        cbSizeThis += cbSizeThis & 1;           // force WORD alignment
        lpNext = lpw + cbSizeThis + sizeof (DWORD) * 2;
        if ((*(LPDWORD) lpw) == ckid) {
            lpcs->cbInfoChunks -= cbSizeThis + sizeof (DWORD) * 2;
            if (lpNext <= lpEnd) {
                if (lpEnd - lpNext)
                    hmemcpy(lpw, lpNext, lpEnd - lpNext);
                if (lpcs->cbInfoChunks) {
	           lpcs->lpInfoChunks = (LPBYTE) GlobalReAllocPtr( // shrink it
                        lpcs->lpInfoChunks,
                        lpcs->cbInfoChunks,
                        GMEM_MOVEABLE);
                }
                else {
                    if (lpcs->lpInfoChunks)
                        GlobalFreePtr (lpcs->lpInfoChunks);
                    lpcs->lpInfoChunks = NULL;
                }
                fOK = TRUE;
            }
            break;
        }
        else
            lpw = lpNext;
    }

    if (lpData == NULL || cbData == 0)         // Only deleting, get out
        return fOK;

    // Add a new entry
    cbData += cbData & 1;               // force WORD alignment
    cbData += sizeof(DWORD) * 2;        // add sizeof 2 FOURCCs
    if (lpcs->lpInfoChunks) {
	lp = (LPBYTE) GlobalReAllocPtr(lpcs->lpInfoChunks, lpcs->cbInfoChunks + cbData, GMEM_MOVEABLE);
    } else {
	lp = (LPBYTE) GlobalAllocPtr(GMEM_MOVEABLE, cbData);
    }

    if (!lp)
	return FALSE;

    // build RIFF chunk in block
    ((DWORD FAR *) (lp + lpcs->cbInfoChunks))[0] = ckid;
    ((DWORD FAR *) (lp + lpcs->cbInfoChunks))[1] = lpcic->cbData;

    hmemcpy(lp + lpcs->cbInfoChunks + sizeof(DWORD) * 2,
	    lpData,
	    cbData - sizeof(DWORD) * 2);
    lpcs->lpInfoChunks = lp;
    lpcs->cbInfoChunks += cbData;

    return TRUE;
}


/*
 *  AVI Capture
 *      This is the main streaming capture loop for both audio and
 * video.  It will first init all buffers and drivers and then go into a
 * loop checking for buffers to be filled.  When a buffer is filled then
 * the data for it is written out.
 * Afterwards it cleans up after itself (frees buffers etc...)
 * Returns: 0 on success, else error code
 */
void FAR PASCAL _loadds AVICapture1(LPCAPSTREAM lpcs)
{
    BOOL        fOK = TRUE;
    BOOL        fT;
    BOOL        fVideoBuffersInDOSMem;
    BOOL        fStopping;         // True when finishing capture
    BOOL        fStopped;          // True if driver notified to stop
    DWORD       dw;
    char        ach[128];
    char        achMsg[128];
    WORD        w;
    WORD        wError;         // Error String ID
    DWORD       dwDriverDropCount;
    WORD        wSmartDrv;
    LPVIDEOHDR  lpVidHdr;
    LPWAVEHDR   lpWaveHdr;
    DWORD       dwTimeStarted;  // When did we start in milliseconds
    DWORD       dwTimeStopped;
    DWORD       dwTimeToStop;   // Lesser of MCI capture time or frame limit
    BOOL        fTryToPaint = FALSE;
    HDC         hdc;
    HPALETTE    hpalT;
    HCURSOR     hOldCursor;
    RECT        rcDrawRect;
    DWORD       dwStreamError;
    CAPINFOCHUNK cic;

    lpcs-> dwReturn = DV_ERR_OK;

    hOldCursor = SetCursor(lpcs->hWaitCursor);

    statusUpdateStatus(lpcs, IDS_CAP_BEGIN);  // Always the first message

    // If not 1 Meg. free, give it up!!!
    if (GetFreePhysicalMemory () < (1024L * 1024L)) {
        errorUpdateError (lpcs, IDS_CAP_OUTOFMEM);
        lpcs-> dwReturn = IDS_CAP_OUTOFMEM;
        goto EarlyExit;
    }

    statusUpdateStatus(lpcs, IDS_CAP_STAT_CAP_INIT);

    // Try painting the DIB only if Live window
    fTryToPaint = lpcs->fLiveWindow;

    if (fTryToPaint) {
        hdc = GetDC(lpcs->hwnd);
        SetWindowOrg(hdc, lpcs->ptScroll.x, lpcs->ptScroll.y);
        hpalT = DrawDibGetPalette (lpcs->hdd);
        if (hpalT)
            hpalT = SelectPalette( hdc, hpalT, FALSE);
        RealizePalette(hdc);
        if (lpcs-> fScale)
            GetClientRect (lpcs->hwnd, &rcDrawRect);
        else
            SetRect (&rcDrawRect, 0, 0, lpcs->dxBits, lpcs->dyBits);
    }

    // -------------------------------------------------------
    //   When should capture stop?
    // -------------------------------------------------------

    // If using MCI, capture for the shorter of the MCI period,
    // or the capture limit

    if (lpcs->sCapParms.fLimitEnabled)
        dwTimeToStop = (DWORD) ((DWORD) 1000 * lpcs->sCapParms.wTimeLimit);
    else
        dwTimeToStop = (DWORD) -1L; // very large

    if (lpcs->sCapParms.fMCIControl) {
        // if MCI stop time not given, use lpcs->sCapParms.wTimeLimit
        if (lpcs->sCapParms.dwMCIStopTime == lpcs->sCapParms.dwMCIStartTime)
                    lpcs->sCapParms.dwMCIStopTime = lpcs->sCapParms.dwMCIStartTime +
                    (DWORD) ((DWORD)1000 * lpcs->sCapParms.wTimeLimit);

        dw = lpcs->sCapParms.dwMCIStopTime - lpcs->sCapParms.dwMCIStartTime;

        if (lpcs->sCapParms.fLimitEnabled)
            dwTimeToStop = min (dw, dwTimeToStop);
        else
            dwTimeToStop = dw;
    }

    //
    // never ever try to capture more than the index size!
    //
    if (lpcs->fCapturingToDisk) {
        dw = muldiv32(lpcs->sCapParms.dwIndexSize,
                lpcs->sCapParms.dwRequestMicroSecPerFrame,
                1000l);

        dwTimeToStop = min (dw, dwTimeToStop);
    }

    if (lpcs->sCapParms.fMCIControl) {
        fOK = FALSE;            // Assume the worst
        if (MCIDeviceOpen (lpcs)) {
            if (MCIDeviceSetPosition (lpcs, lpcs->sCapParms.dwMCIStartTime))
                fOK = TRUE;
        }
        if (!fOK) {
            errorUpdateError (lpcs, IDS_CAP_MCI_CONTROL_ERROR);
            statusUpdateStatus(lpcs, NULL);    // Clear status
            lpcs-> dwReturn = IDS_CAP_MCI_CONTROL_ERROR;
            goto EarlyExit;
        }
    }

    //
    // If we're compressing while capturing, warm up the compressor
    //
    if (lpcs->CompVars.hic) {
        if (ICSeqCompressFrameStart(&lpcs->CompVars, lpcs->lpBitsInfo) == NULL) {

	    // !!! We're in trouble here!
            dprintf("ICSeqCompressFrameStart failed !!!\n");
            lpcs-> dwReturn = IDS_CAP_COMPRESSOR_ERROR;
            errorUpdateError (lpcs, IDS_CAP_COMPRESSOR_ERROR);
            goto EarlyExit;
        }
        // Kludge, offset the lpBitsOut ptr
        // Compman allocates the compress buffer too large by
        // 2048 + 16 so we will still have room
        ((LPBYTE) lpcs->CompVars.lpBitsOut) += 8;
    }

    // No compression desired
    if (!lpcs->CompVars.hic)
	WinAssert(lpcs->CompVars.lpbiOut == NULL);

    // -------------------------------------------------------
    //  Open the output file
    // -------------------------------------------------------

    if (lpcs->fCapturingToDisk) {
        if (!AVIFileInit(lpcs)) {
            lpcs-> dwReturn = IDS_CAP_FILE_OPEN_ERROR;
            errorUpdateError (lpcs, IDS_CAP_FILE_OPEN_ERROR);
            goto EarlyExit;
        }
    }

    /* Make sure the parent has been repainted */
    UpdateWindow(lpcs->hwnd);

    //
    // call AVIInit() to get all the capture memory we will need
    //

    // Don't use DOS memory if capturing to Net
    fVideoBuffersInDOSMem = lpcs->sCapParms.fUsingDOSMemory;

    wError = AVIInit(lpcs);

    if (wError && fVideoBuffersInDOSMem) {
        lpcs->sCapParms.fUsingDOSMemory = FALSE;
        wError = AVIInit(lpcs);
    }

    if (wError) {
        /* Error in initalization - return */
        errorUpdateError (lpcs, wError);
        AVIFini(lpcs);
        AVIFileFini(lpcs, TRUE /* fWroteJunkChunks */, TRUE /* fAbort */);
        statusUpdateStatus(lpcs, NULL);    // Clear status
        lpcs-> dwReturn = wError;
        goto EarlyExit;
    }

    /* Click OK to capture string (must follow AVIInit) */
    LoadString(lpcs->hInst, IDS_CAP_SEQ_MSGSTART, ach, sizeof(ach));
    wsprintf(achMsg, ach, (LPSTR)lpcs->achFile);

    statusUpdateStatus(lpcs, NULL);

    // -------------------------------------------------------
    //   Ready to go, make the user click OK?
    // -------------------------------------------------------

    if (lpcs->sCapParms.fMakeUserHitOKToCapture && lpcs->fCapturingToDisk) {
	w = MessageBox(lpcs->hwnd, achMsg, "", MB_OKCANCEL | MB_ICONEXCLAMATION);
        if (w == IDCANCEL) {
            /* clean-up and get out */
            AVIFini(lpcs);
            AVIFileFini(lpcs, TRUE /* fWroteJunkChunks */, TRUE /* fAbort */);
            statusUpdateStatus(lpcs, NULL);    // Clear status
            goto EarlyExit;
        }
    } // endif forcing user to hit OK

    /* update the status, so the user knows how to stop */
    statusUpdateStatus(lpcs, IDS_CAP_SEQ_MSGSTOP);
    UpdateWindow(lpcs->hwnd);

    lpcs-> fCapturingNow = TRUE;

    GetAsyncKeyState(lpcs->sCapParms.vKeyAbort);
    GetAsyncKeyState(VK_ESCAPE);
    GetAsyncKeyState(VK_LBUTTON);
    GetAsyncKeyState(VK_RBUTTON);

    if (lpcs->sCapParms.fDisableWriteCache)
        wSmartDrv = SmartDrv(lpcs->achFile[0], (WORD)-1);  // turn all off....

    // Insert the digitization time
    cic.fccInfoID = mmioFOURCC ('I','D','I','T');
    time (&ltime);
    cic.lpData = (LPSTR) ctime(&ltime);
    cic.cbData  = 26;
    SetInfoChunk (lpcs, &cic);


    // -------------------------------------------------------
    //   Start MCI, Audio, and video streams
    // -------------------------------------------------------

    if (lpcs-> CallbackOnControl) {
        // Callback will preroll, then return on frame accurate postion
        // The 1 indicates recording is about to start
        // Callback can return FALSE to exit without capturing
        if (!((*(lpcs->CallbackOnControl)) (lpcs->hwnd, CONTROLCALLBACK_PREROLL ))) {
            /* clean-up and get out */
            AVIFini(lpcs);
            AVIFileFini(lpcs, TRUE /* fWroteJunkChunks */, TRUE /* fAbort */);
            statusUpdateStatus(lpcs, NULL);    // Clear status
            goto EarlyExit;
        }
    }

    if (lpcs->sCapParms.fMCIControl)
        MCIDevicePlay (lpcs);

    dwTimeStarted = timeGetTime();

    if(lpcs->sCapParms.fCaptureAudio)
        waveInStart(lpcs->hWaveIn);

    videoStreamStart(lpcs->hVideoIn);

    // -------------------------------------------------------
    //   MAIN CAPTURE LOOP
    // -------------------------------------------------------

    fOK=TRUE;
    fStopping = FALSE;    // TRUE when we need to stop
    fStopped = FALSE;     // TRUE if drivers notified we have stopped
    lpcs->dwTimeElapsedMS = 0;

    lpVidHdr = lpcs->alpVideoHdr[lpcs->iNextVideo];
    lpWaveHdr = lpcs->alpWaveHdr[lpcs->iNextWave];

    for (;;) {

        // The INTEL driver uses the GetError message to
        // process buffers, so call it often...
        videoStreamGetError (lpcs->hVideoIn, &dwStreamError, &dwDriverDropCount);

        // What time is it?
        lpcs->dwTimeElapsedMS = timeGetTime() - dwTimeStarted;

        // -------------------------------------------------------
        //        Is video buffer ready to be written?
        // -------------------------------------------------------
        if ((lpVidHdr->dwFlags & VHDR_DONE)) {
            if (lpVidHdr-> dwBytesUsed) {
                // Current time in milliseconds
                dw = muldiv32 ((lpcs->dwVideoChunkCount + 1),
                                lpcs->sCapParms.dwRequestMicroSecPerFrame, 1000);
                if (lpcs->CallbackOnVideoStream)
                    (*(lpcs->CallbackOnVideoStream)) (lpcs->hwnd, lpVidHdr);

                if (lpcs-> fCapturingToDisk) {
                    if (lpcs->dwVideoChunkCount &&
                                (dw < lpVidHdr->dwTimeCaptured)) {
                        // Has the capture device skipped frames?
                        // w = # of frames skipped
                        w = (WORD) muldiv32 ((lpVidHdr-> dwTimeCaptured - dw),
                                1000,
                                lpcs->sCapParms.dwRequestMicroSecPerFrame);
                        w = min (w, (sizeof (lpcs->DropFrame) / sizeof (RIFF) - sizeof (RIFF) ) );
                        lpcs->dwFramesDropped+= w;
                        fOK = AVIWriteDummyFrames (lpcs, w);

                        if (!fOK)
                            fStopping = TRUE;
                    } // end if writing dummy frames

                    if (!AVIWriteVideoFrame (lpcs, lpVidHdr)) {
                        fOK = FALSE;
                        fStopping = TRUE;
                        // "ERROR: Could not write to file."
                        errorUpdateError(lpcs, IDS_CAP_FILE_WRITE_ERROR);
                    }
                    else {
                        if (!IndexVideo(lpcs, lpVidHdr-> dwBytesUsed,
                                (BOOL) (lpVidHdr->dwFlags & VHDR_KEYFRAME)))
                            fStopping = TRUE;
                    }
                } // endif fCapturingToDisk
                // Warning: Kludge to create frame chunk count when net capture
                // follows.
                else
                    lpcs->dwVideoChunkCount++;

                // -------------------------------------------------------
                //         if we have *nothing* to do paint or show status.
                // -------------------------------------------------------
                w = (lpcs->iNextVideo + 1) % lpcs->iNumVideo;
                if (!(lpcs->alpVideoHdr[w]-> dwFlags & VHDR_DONE)) {
                    if (fTryToPaint && lpcs->dwVideoChunkCount &&
                                lpVidHdr-> dwFlags & VHDR_KEYFRAME) {
                        fTryToPaint = DrawDibDraw(lpcs->hdd, hdc,
                                0, 0,
                                rcDrawRect.right - rcDrawRect.left,
                                rcDrawRect.bottom - rcDrawRect.top,
                                /*lpcs->dxBits, lpcs->dyBits, */
                                (LPBITMAPINFOHEADER)lpcs->lpBitsInfo,
                                lpVidHdr-> lpData, 0, 0, -1, -1,
                                DDF_SAME_HDC | DDF_SAME_DIB | DDF_SAME_SIZE);
                    }
                }
                // if there is still more time, (or at least every 100 frames)
                // show status if we're not ending the capture
                if ((!fStopping) && (lpcs-> fCapturingToDisk) &&
                        ((lpcs->dwVideoChunkCount && (lpcs->dwVideoChunkCount % 100 == 0)) ||
                        (!(lpcs->alpVideoHdr[w]-> dwFlags & VHDR_DONE)) ) ) {

                    // "Captured %ld frames (Dropped %ld) %d.%03d sec. Hit Escape to Stop"
                    statusUpdateStatus(lpcs, IDS_CAP_STAT_VIDEOCURRENT,
                            lpcs->dwVideoChunkCount, lpcs->dwFramesDropped,
                            (int)(lpcs-> dwTimeElapsedMS/1000), (int)(lpcs-> dwTimeElapsedMS%1000)
                            );
                } // endif next buffer not ready
            } // endif any bytes used in the buffer

             /* return the emptied buffer to the que */
            lpVidHdr->dwFlags &= ~VHDR_DONE;
            if (videoStreamAddBuffer(lpcs->hVideoIn,
                        lpVidHdr, sizeof (VIDEOHDR))) {
                fOK = FALSE;
                fStopping = TRUE;
                // "ERROR: Could not re-add buffer."
                  errorUpdateError (lpcs, IDS_CAP_VIDEO_ADD_ERROR);
            }

            /* increment the next Video buffer pointer */
            if (++lpcs->iNextVideo >= lpcs->iNumVideo)
                lpcs->iNextVideo = 0;

            lpVidHdr = lpcs->alpVideoHdr[lpcs->iNextVideo];
        }

        if (lpcs-> CallbackOnYield) {
            // If the yield callback returns FALSE, abort
            if (!((*(lpcs->CallbackOnYield)) (lpcs->hwnd)))
                fStopping = TRUE;
        }

        // Don't do peekMessage yield for ACM
        if (lpcs->sCapParms.fYield) {
            MSG msg;

            if (PeekMessage(&msg,NULL,0,0,PM_REMOVE)) {
                // Kludge to get rid of timers from lpcs->hwnd
                if (msg.message == WM_TIMER && msg.hwnd == lpcs->hwnd)
                    ;
                else {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
            }
        }

        if (lpcs-> CallbackOnControl) {
            // Outside routine is handling when to stop
            // The CONTROLCALLBACK_CAPTURING indicates we're asking when to stop
            if (!((*(lpcs->CallbackOnControl)) (lpcs->hwnd, CONTROLCALLBACK_CAPTURING )))
                fStopping = TRUE;
        }

        // -------------------------------------------------------
        //        Is audio buffer ready to be written?
        // -------------------------------------------------------
        if (lpcs->sCapParms.fCaptureAudio) {
            int iLastWave;

            //
            // we may need to yield for audio to get converted.
            //
            if (lpcs->fAudioYield)
                Yield();

            //
            // if all buffers are done, we have broke audio.
            //
            iLastWave = lpcs->iNextWave == 0 ?
                        lpcs->iNumAudio -1 : lpcs->iNextWave-1;

            if (!fStopping &&
                    lpcs->alpWaveHdr[iLastWave]->dwFlags & WHDR_DONE)
                lpcs->fAudioBreak = TRUE;

            w = lpcs->iNumAudio; // don't get stuck here forever...
            while (w && fOK && (lpWaveHdr-> dwFlags & WHDR_DONE)) {
                w--;
                if (lpWaveHdr-> dwBytesRecorded) {
                    /* Chunk info is included in the wave data */
                    /* Reset Chunk Size in buffer */
                    ((LPRIFF)(lpWaveHdr->lpData))[-1].dwSize =
                                lpWaveHdr-> dwBytesRecorded;
                    if (lpcs-> CallbackOnWaveStream) {
                        (*(lpcs->CallbackOnWaveStream)) (lpcs->hwnd, lpWaveHdr);
                    }
                    if (lpcs-> fCapturingToDisk) {
                        if(!AVIWrite (lpcs, lpWaveHdr-> lpData - sizeof(RIFF),
                                (lpWaveHdr-> dwBytesRecorded +
                                sizeof (RIFF) + 1) & ~1L)) {
                            fOK = FALSE;
                            fStopping = TRUE;
                            errorUpdateError (lpcs, IDS_CAP_FILE_WRITE_ERROR);
                         } else {
                            if (IndexAudio (lpcs, lpWaveHdr-> dwBytesRecorded))
                                lpcs->dwWaveBytes += lpWaveHdr-> dwBytesRecorded;
                            else
                                fStopping = TRUE;
                         }
                    } // endif capturing to disk
                    // Warning: Kludge to create wave chunk count when net capture
                    // follows.
                    else {
                        lpcs->dwWaveChunkCount++;
                        lpcs->dwWaveBytes += lpWaveHdr-> dwBytesRecorded;
                    }
                } // endif dwBytesRecorded

                lpWaveHdr-> dwBytesRecorded = 0;
                lpWaveHdr-> dwFlags &= ~WHDR_DONE;

                 /* return the emptied buffer to the que */
                if(waveInAddBuffer(lpcs->hWaveIn, lpWaveHdr, sizeof(WAVEHDR))) {
                    fOK = FALSE;
                    fStopping = TRUE;
                    errorUpdateError(lpcs, IDS_CAP_WAVE_ADD_ERROR);
                }

                /* increment the next wave buffer pointer */
                if(++lpcs->iNextWave >= lpcs->iNumAudio)
                    lpcs->iNextWave = 0;

                lpWaveHdr = lpcs->alpWaveHdr[lpcs->iNextWave];

            } // endwhile buffer available
         } // endif sound enabled

        // -------------------------------------------------------
        //        is there any reason to stop?
        // -------------------------------------------------------
        if (lpcs->sCapParms.vKeyAbort) {
            if (GetAsyncKeyState(lpcs->sCapParms.vKeyAbort & 0x00ff) & 0x0001) {
                fT = TRUE;
                if (lpcs->sCapParms.vKeyAbort & 0x8000)  // Ctrl?
                    fT = fT && (GetAsyncKeyState(VK_CONTROL) & 0x8000);
                if (lpcs->sCapParms.vKeyAbort & 0x4000)  // Shift?
                    fT = fT && (GetAsyncKeyState(VK_SHIFT) & 0x8000);
                fStopping = fT;      // User aborts
            }
        }
        if (lpcs->sCapParms.fAbortLeftMouse)
            if (GetAsyncKeyState(VK_LBUTTON) & 0x0001)
                fStopping = TRUE;      // User aborts
        if (lpcs->sCapParms.fAbortRightMouse)
            if (GetAsyncKeyState(VK_RBUTTON) & 0x0001)
                fStopping = TRUE;      // User aborts
        if (lpcs-> fAbortCapture || lpcs-> fStopCapture)
            fStopping = TRUE;          // Somebody above wants us to quit

        if (lpcs-> dwTimeElapsedMS > dwTimeToStop)
            fStopping = TRUE;      // all done

        // -------------------------------------------------------
        //        Quit only when we have stopped, and
        //      no more buffers are pending from any device.
        // -------------------------------------------------------
        if (fStopped) {
            if (!(lpVidHdr-> dwFlags & VHDR_DONE)) {
                if (lpcs->sCapParms.fCaptureAudio) {
                   if (!(lpWaveHdr-> dwFlags & WHDR_DONE))
                        break;
                }
                else
                    break;
            }
        }

        // -------------------------------------------------------
        //        Tell all the devices to stop
        // -------------------------------------------------------
        if (fStopping && !fStopped) {
            fStopped = TRUE;

            DSTATUS(lpcs, "Stopping....");

            if(lpcs->sCapParms.fCaptureAudio) {
                DSTATUS(lpcs, "Stopping Audio");
                waveInStop(lpcs->hWaveIn);
            }

            DSTATUS(lpcs, "Stopping Video");
            videoStreamStop(lpcs->hVideoIn);         // Stop everybody

            dwTimeStopped = timeGetTime ();

            if (lpcs->sCapParms.fMCIControl) {
                DSTATUS(lpcs, "Stopping MCI");
                MCIDevicePause (lpcs);
            }
            DSTATUS(lpcs, "Stopped");

            SetCursor(lpcs->hWaitCursor);  // Force cursor back to hourglass

        }


        if (fStopping) {
            // "Finished capture, now writing frame %ld"
            if (fOK) {
                statusUpdateStatus(lpcs, IDS_CAP_STAT_CAP_FINI, lpcs->dwVideoChunkCount);
            }
            else {               // Exit if problems
                statusUpdateStatus(lpcs, IDS_CAP_RECORDING_ERROR2);
                break;
            }
        }

    } // end of forever

    // -------------------------------------------------------
    //   END OF MAIN CAPTURE LOOP
    // -------------------------------------------------------

    if (lpcs->sCapParms.fDisableWriteCache)
        SmartDrv(lpcs->achFile[0], wSmartDrv);  // turn Smartdrive back on

    /* eat any keys that have been pressed */
    while(GetKey(FALSE))
        ;

    AVIFini(lpcs);  // does the Reset, and frees all buffers
    AVIFileFini(lpcs, TRUE /* fWroteJunkChunks */, FALSE /* fAbort */);

    // This is the corrected capture duration, based on audio samples
    lpcs->dwTimeElapsedMS = lpcs->dwActualMicroSecPerFrame *
                lpcs->dwVideoChunkCount / 1000;

    /* Notify if there was an error while recording */

    if(!fOK) {
        errorUpdateError (lpcs, IDS_CAP_RECORDING_ERROR);
    }


    if (lpcs-> fCapturingToDisk) {
        if (lpcs->dwVideoChunkCount)
            dw = muldiv32(lpcs->dwVideoChunkCount,1000000,lpcs-> dwTimeElapsedMS);
        else
            dw = 0;     // The muldiv32 doesn't give 0 if numerator is zero

        if(lpcs->sCapParms.fCaptureAudio) {
            // "Captured %d.%03d sec.  %ld frames (%ld dropped) (%d.%03d fps).  %ld audio bytes (%d.%03d sps)"
            statusUpdateStatus(lpcs, IDS_CAP_STAT_VIDEOAUDIO,
                  (WORD)(lpcs-> dwTimeElapsedMS/1000),
                  (WORD)(lpcs-> dwTimeElapsedMS%1000),
                  lpcs->dwVideoChunkCount,
                  lpcs->dwFramesDropped,
                  (WORD)(dw / 1000),
                  (WORD)(dw % 1000),
                  lpcs->dwWaveBytes,
                  (WORD) lpcs->lpWaveFormat->nSamplesPerSec / 1000,
                  (WORD) lpcs->lpWaveFormat->nSamplesPerSec % 1000);
        } else {
            // "Captured %d.%03d sec.  %ld frames (%ld dropped) (%d.%03d fps)."
            statusUpdateStatus(lpcs, IDS_CAP_STAT_VIDEOONLY,
                  (WORD)(lpcs-> dwTimeElapsedMS/1000),
                  (WORD)(lpcs-> dwTimeElapsedMS%1000),
                  lpcs->dwVideoChunkCount,
                  lpcs->dwFramesDropped,
                  (WORD)(dw / 1000),
                  (WORD)(dw % 1000));
        }
    } // endif capturing to disk (no warnings or errors if to net)

    // No frames captured, warn user that interrupts are probably not enabled.
    if (fOK && (lpcs->dwVideoChunkCount == 0)) {
        errorUpdateError (lpcs, IDS_CAP_NO_FRAME_CAP_ERROR);
    }
    // No audio captured, (but enabled), warn user audio card is hosed
    else if (fOK && lpcs->sCapParms.fCaptureAudio && (lpcs->dwWaveBytes == 0)) {
        errorUpdateError (lpcs, IDS_CAP_NO_AUDIO_CAP_ERROR);
    }
    // Audio underrun, inform user
    else if (fOK && lpcs->sCapParms.fCaptureAudio && lpcs->fAudioBreak) {
        errorUpdateError (lpcs, IDS_CAP_AUDIO_DROP_ERROR);
    }

    // If frames dropped, or changed capture rate, warn the user
    else if (fOK && lpcs->dwVideoChunkCount && lpcs->fCapturingToDisk) {

        // Warn user if dropped > 10% (default) of the frames
        if ((DWORD)100 * lpcs->dwFramesDropped / lpcs->dwVideoChunkCount >
                    lpcs-> sCapParms.wPercentDropForError) {

            // "%ld of %ld frames (%d.%03d\%) dropped during capture."
            errorUpdateError (lpcs, IDS_CAP_STAT_FRAMESDROPPED,
                  lpcs->dwFramesDropped,
                  lpcs->dwVideoChunkCount,
                  (WORD)(muldiv32(lpcs->dwFramesDropped,10000,lpcs->dwVideoChunkCount)/100),
                  (WORD)(muldiv32(lpcs->dwFramesDropped,10000,lpcs->dwVideoChunkCount)%100)
                  );
        }
    }

EarlyExit:

    //
    // If we were compressing while capturing, close it down
    //
    if (lpcs->CompVars.hic) {
        // Kludge, reset the lpBitsOut pointer
        if (lpcs->CompVars.lpBitsOut)
            ((LPBYTE) lpcs->CompVars.lpBitsOut) -= 8;
	ICSeqCompressFrameEnd(&lpcs->CompVars);
    }

    if (fTryToPaint) {
        if (hpalT)
             SelectPalette(hdc, hpalT, FALSE);
        ReleaseDC (lpcs->hwnd, hdc);
    }

    if (lpcs->sCapParms.fMCIControl)
        MCIDeviceClose (lpcs);

    // Let the user see where capture stopped
    if ((!lpcs->fLiveWindow) && (!lpcs->fOverlayWindow))
        videoFrame( lpcs->hVideoIn, &lpcs->VidHdr );
    InvalidateRect( lpcs->hwnd, NULL, TRUE);

    SetCursor(hOldCursor);

    lpcs->fCapFileExists = (lpcs-> dwReturn == DV_ERR_OK);
    lpcs->fCapturingNow = FALSE;

    statusUpdateStatus(lpcs, IDS_CAP_END);      // Always the last message

    return;
}


// Returns TRUE if the capture task was created, or
// capture completed OK.

BOOL AVICapture (LPCAPSTREAM lpcs)
{
    WORD w;
    CAPINFOCHUNK cic;
    char szSMPTE[40];

    if (lpcs-> fCapturingNow)
        return IDS_CAP_VIDEO_OPEN_ERROR;

    lpcs-> fStopCapture  = FALSE;
    lpcs-> fAbortCapture = FALSE;
    lpcs-> hTaskCapture  = NULL;
    lpcs-> dwReturn      = 0;

    // Clear any SMPTE info chunk
    cic.fccInfoID = mmioFOURCC ('I','S','M','T');
    cic.lpData = NULL;
    cic.cbData = 0;
    SetInfoChunk (lpcs, &cic);

#if 1
    // And get ready to write a SMPTE info chunk
    if (lpcs->sCapParms.fMCIControl) {
        // create SMPTE string
        TimeMSToSMPTE (lpcs->sCapParms.dwMCIStartTime, (LPSTR) szSMPTE);
        cic.lpData = szSMPTE;
        cic.cbData = lstrlen (szSMPTE) + 1;
        SetInfoChunk (lpcs, &cic);
    }
#endif

    // Use an MCI device to do step capture capture???
    if (lpcs->sCapParms.fStepMCIDevice && lpcs->sCapParms.fMCIControl) {
        if (lpcs->sCapParms.fYield) {
            w = (WORD) mmTaskCreate((LPTASKCALLBACK) MCIStepCapture,
                        &lpcs->hTaskCapture, (DWORD) lpcs);
            // if task creation failed, turn off the capturing flag
            if (w != 0)
                lpcs->fCapturingNow = FALSE;
            return ((BOOL) !w);
        }
        else  {
            MCIStepCapture (lpcs);
            return ((BOOL) !lpcs->dwReturn);
        }
    }

    // No MCI device, just a normal streaming capture
    else if (lpcs->sCapParms.fYield) {
        w = (WORD) mmTaskCreate((LPTASKCALLBACK) AVICapture1,
                &lpcs->hTaskCapture, (DWORD) lpcs);
        // if task creation failed, turn off the capturing flag
        if (w != 0)
            lpcs->fCapturingNow = FALSE;
        return ((BOOL) !w);
    }
    else  {
        AVICapture1 (lpcs);
        return ((BOOL) !lpcs->dwReturn);
    }
}





=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avicap.16\capdib.c ===
/****************************************************************************
 *
 *   capdib.c
 * 
 *   DIB processing module.
 *
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992, 1993 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and 
 *    distribute the Sample Files (and/or any modified version) in 
 *    any way you find useful, provided that you agree that 
 *    Microsoft has no warranty obligations or liability for any 
 *    Sample Application Files which are modified. 
 *
 ***************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <msvideo.h>
#include <drawdib.h>
#include "avicap.h"
#include "avicapi.h"


//
// Initialize a DIB to the default format of 160x120x8, BI_RGB
//
void SetDefaultCaptureFormat (LPBITMAPINFOHEADER lpbih)
{
    lpbih->biSize              = sizeof (BITMAPINFOHEADER);
    lpbih->biWidth             = 160;
    lpbih->biHeight            = 120;
    lpbih->biBitCount          = 8;
    lpbih->biPlanes            = 1;
    lpbih->biCompression       = BI_RGB;
    lpbih->biSizeImage         = DIBWIDTHBYTES (*lpbih) * lpbih->biHeight;
    lpbih->biXPelsPerMeter     = 0;
    lpbih->biYPelsPerMeter     = 0;
    lpbih->biClrUsed           = 256;
    lpbih->biClrImportant      = 0;
}

// 
// Whenever we get a new format from the driver, OR
// start using a new palette, we must reallocate
// our global BITMAPINFOHEADER.  This allows JPEG
// quantization tables to be tacked onto the BITMAPINFO
// or any other format specific stuff.  The color table
// is always offset biSize from the start of the BITMAPINFO.
// Returns: 0 on success, or DV_ERR_... code
// 

DWORD AllocNewGlobalBitmapInfo (LPCAPSTREAM lpcs, LPBITMAPINFOHEADER lpbi)
{
    DWORD dwSize;

    dwSize = lpbi->biSize + 256 * sizeof (RGBQUAD);

    // The 256 entry above is HARDWIRED ON PURPOSE
    // If biClrUsed was used instead, we would have to realloc
    // whenever a palette is pasted (during DibNewPalette())!!!

    if (lpcs->lpBitsInfo) 
         lpcs->lpBitsInfo = (LPBITMAPINFO) GlobalReAllocPtr (lpcs->lpBitsInfo,
                dwSize, GHND);
    else
         lpcs->lpBitsInfo = (LPBITMAPINFO) GlobalAllocPtr (GHND, dwSize);

    if (!lpcs->lpBitsInfo)
         return (DV_ERR_NOMEM);

    // Copy over the BITMAPINFOHEADER
    hmemcpy ((HPSTR)lpcs->lpBitsInfo, (HPSTR)lpbi, lpbi->biSize);

    return DV_ERR_OK;
}

// 
// Whenever we get a new format from the driver
// allocate a new global bitspace.  This bitspace is used
// in preview mode and single frame capture.
// Returns: 0 on success, or DV_ERR_... code
// 

DWORD AllocNewBitSpace (LPCAPSTREAM lpcs, LPBITMAPINFOHEADER lpbih)
{
    DWORD dwSize;

    dwSize = lpbih->biSizeImage;

    if (lpcs->lpBits) 
         lpcs->lpBits = GlobalReAllocPtr (lpcs->lpBits, dwSize, GHND);
    else
         lpcs->lpBits = GlobalAllocPtr (GHND, dwSize);

    if (!lpcs->lpBits)
         return (DV_ERR_NOMEM);

    return DV_ERR_OK;    
}

//
// Dib Inititialization code
// Returns: 0 on success, or DV_ERR_... code
//

DWORD DibInit (LPCAPSTREAM lpcs)
{
    BITMAPINFOHEADER bmih;
    
    SetDefaultCaptureFormat (&bmih);
    return ((WORD) AllocNewGlobalBitmapInfo (lpcs, &bmih));
}

//
// Fini code to free all bitmap resources
//
void DibFini (LPCAPSTREAM lpcs)
{
    if (lpcs->lpBits) {
        GlobalFreePtr (lpcs->lpBits);
        lpcs->lpBits = NULL;
    }
    if (lpcs->lpBitsInfo) {
        GlobalFreePtr (lpcs->lpBitsInfo);
        lpcs->lpBitsInfo = NULL;
    }
    lpcs->dxBits = 0;
    lpcs->dyBits = 0;
}

//
// Send a format to the driver.
// Whenever we do a format change, send the driver the 
// Source and destination rects.
// Returns: 0 on success, or DV_ERR_... code
//
DWORD SendDriverFormat (LPCAPSTREAM lpcs, LPBITMAPINFOHEADER lpbih, DWORD dwInfoHeaderSize)
{
    RECT rc;
    DWORD dwError = DV_ERR_NOTSUPPORTED;

    rc.left = rc.top = 0;
    rc.right = (int) lpbih->biWidth;
    rc.bottom = (int) lpbih->biHeight;

    if (dwError = videoConfigure(lpcs->hVideoIn,
            DVM_FORMAT,
            VIDEO_CONFIGURE_SET, NULL, 
            (LPBITMAPINFOHEADER)lpbih, dwInfoHeaderSize,
            NULL, NULL ) ) {
        return dwError;
    }
    else {
         // Set the ExternalIn Destination rectangle to the same size
         videoMessage (lpcs->hVideoCapture,
                DVM_DST_RECT, 
                (DWORD) (LPVOID)&rc, VIDEO_CONFIGURE_SET);

         // Set the VideoIn Source Rectangle to the same size
         videoMessage (lpcs->hVideoIn,
                DVM_SRC_RECT, 
                (DWORD) (LPVOID)&rc, VIDEO_CONFIGURE_SET);

         // Set the VideoIn Destination Rectangle to the same size
         videoMessage (lpcs->hVideoIn,
                DVM_DST_RECT, 
                (DWORD) (LPVOID)&rc, VIDEO_CONFIGURE_SET);
    }
    return dwError;
}


//
// Given a DIB, see if the driver likes it, then
//  allocate the global BITMAPINFOHEADER and bitspace.  
//
//
DWORD SetFormatFromDIB (LPCAPSTREAM lpcs, LPBITMAPINFOHEADER lpbih)
{
    DWORD dwError;

    // Fill optional fields in the DIB header
    if (lpbih->biSizeImage == 0) 
        lpbih->biSizeImage = DIBWIDTHBYTES (*lpbih) * lpbih->biHeight;

    // Is the format palatized or full-color
    if (lpbih->biBitCount <= 8 && lpbih->biClrUsed == 0)
        lpbih->biClrUsed = (1 << lpbih-> biBitCount);     // paletized

    // See if the driver will support it
    if (dwError = SendDriverFormat (lpcs, lpbih, lpbih->biSize) )
        return dwError;

    // Realloc our global header
    if (dwError = AllocNewGlobalBitmapInfo (lpcs, lpbih))
        return dwError;

    // Realloc the bits
    if (dwError = AllocNewBitSpace (lpcs, lpbih))
        return dwError;

    lpcs->dxBits = (int)lpbih->biWidth;
    lpcs->dyBits = (int)lpbih->biHeight;

    lpcs->VidHdr.lpData = lpcs->lpBits;
    lpcs->VidHdr.dwBufferLength = lpbih->biSizeImage;
    lpcs->VidHdr.dwUser = 0;
    lpcs->VidHdr.dwFlags = 0;
    
    return (DV_ERR_OK);
}


//
// Returns: a LPBITMAPINFO allocated from global memory
//      containing the current format, or NULL on error.
//      Note that this structure can be larger than 
//      sizeof (BITMAPINFO), ie. JPEG !!!
//

LPBITMAPINFO DibGetCurrentFormat (LPCAPSTREAM lpcs)
{
    DWORD               dwError;
    DWORD               dwSize = 0;
    LPBITMAPINFO        lpBInfo = NULL;

    if (!lpcs->fHardwareConnected)
        return NULL;

    // How large is the BITMAPINFOHEADER?
    videoConfigure( lpcs->hVideoIn,
            DVM_FORMAT,
             VIDEO_CONFIGURE_GET | VIDEO_CONFIGURE_QUERYSIZE,
             &dwSize, NULL, NULL, NULL, NULL);

    if (!dwSize)
        dwSize = sizeof (BITMAPINFOHEADER);

    if (!(lpBInfo = (LPBITMAPINFO) GlobalAllocPtr (GMEM_MOVEABLE, dwSize)))
         return (NULL);

    if (dwError = videoConfigure( lpcs->hVideoIn,
            DVM_FORMAT,
             VIDEO_CONFIGURE_GET | VIDEO_CONFIGURE_CURRENT, NULL, 
             (LPBITMAPINFOHEADER) lpBInfo, dwSize,
             NULL, NULL ) ) {
        // very bad. the driver can't tell us its format. we're hosed.
        GlobalFreePtr (lpBInfo);
        return NULL;
     }

    return (lpBInfo);
}

//
// Main entry point when changing capture formats.
// This is called when the user closes the drivers format dialog.
// Returns: 0 on success, or DV_ERR_... code
//
DWORD DibGetNewFormatFromDriver (LPCAPSTREAM lpcs)
{
    BOOL                f;
    BITMAPINFOHEADER    bih;
    DWORD               dwError;
    LPBITMAPINFO        lpBInfo;

    if (!lpcs->fHardwareConnected)
        return DV_ERR_OK;       // Return OK if no hardware exists

    lpBInfo = DibGetCurrentFormat (lpcs);

    if (lpBInfo == NULL)
        return DV_ERR_NOTSUPPORTED;

    // Set our internal state
    if (dwError = SetFormatFromDIB (lpcs, (LPBITMAPINFOHEADER) lpBInfo)) {
        // couldn't change formats, time to punt!
        // Try to switch back to minimal format (120x160x8)

        errorDriverID (lpcs, dwError);

        SetDefaultCaptureFormat (&bih);
        dwError = SetFormatFromDIB (lpcs, &bih);
    }

    // Force a new frame to be taken, so the DIB contains good
    // data.  Especially important to prevent codecs from exploding!
    if (!dwError)
        videoFrame (lpcs->hVideoIn, &lpcs->VidHdr);

    if (lpBInfo) 
        GlobalFreePtr (lpBInfo);

    f = DrawDibBegin(lpcs->hdd,NULL,-1,-1,(LPBITMAPINFOHEADER)(lpcs->lpBitsInfo),-1,-1,0);
    if (!f)
        errorUpdateError (lpcs, IDS_CAP_AVI_DRAWDIB_ERROR);

    return (dwError);
}

//
// Main entry point when changing capture formats via App message.
// Returns: TRUE on success, or FALSE if format not supported
//
BOOL DibNewFormatFromApp (LPCAPSTREAM lpcs, LPBITMAPINFO lpbiNew, WORD dwSize)
{
    BOOL                f;
    DWORD               dwError;
    LPBITMAPINFO        lpBInfo;

    if (!lpcs->fHardwareConnected)
        return FALSE;

    lpBInfo = DibGetCurrentFormat (lpcs);  // Allocs memory!!!

    if (lpBInfo == NULL)
        return FALSE;

    // Set our internal state
    if (dwError = SetFormatFromDIB (lpcs, (LPBITMAPINFOHEADER) lpbiNew)) {
        // Driver didn't accept the format, 
        // switch back to the original

        errorDriverID (lpcs, dwError);

        SetFormatFromDIB (lpcs, (LPBITMAPINFOHEADER)lpBInfo);
    }

    // Force a new frame to be taken, so the DIB contains good
    // data.  Especially important to prevent codecs from exploding!
    videoFrame (lpcs->hVideoIn, &lpcs->VidHdr);

    if (lpBInfo) 
        GlobalFreePtr (lpBInfo);

    f = DrawDibBegin(lpcs->hdd,NULL,-1,-1,(LPBITMAPINFOHEADER)(lpcs->lpBitsInfo),-1,-1,0);
    if (!f)
        errorDriverID (lpcs, IDS_CAP_AVI_DRAWDIB_ERROR);

    return (dwError == DV_ERR_OK);
}


void xlatClut8 (BYTE _huge *pb, DWORD dwSize, BYTE _huge *xlat)
{
    DWORD dw;

    for (dw = 0; dw < dwSize; dw++, ((BYTE huge *)pb)++)
        *pb = xlat[*pb];
}

//
// DibNewPalette
//
// Performs three functions:
// 1. Updates the biClrUsed field if biBitCount <= 8.
// 2. Remaps BI_RGB images through a LUT when a new palette is assigned.
// 3. Copies the palette entries into our global BITMAPINFO
//
// Returns: TRUE on success
//
DWORD DibNewPalette (LPCAPSTREAM lpcs, HPALETTE hPalNew)
{
    LPBITMAPINFOHEADER  lpbi;
    int                 n;
    int                 nColors;
    BYTE FAR *          lpBits;
    RGBQUAD FAR *       lpRgb;
    BYTE                xlat[256];
    DWORD               dwSize;
    PALETTEENTRY        pe;

    if (!hPalNew || !lpcs->lpBits || !lpcs->lpBitsInfo)
        return FALSE;

    lpbi   = &(lpcs->lpBitsInfo->bmiHeader);
    lpRgb  = (RGBQUAD FAR *)((LPSTR)lpbi + (WORD)lpbi->biSize);
    lpBits = lpcs->lpBits;

    GetObject(hPalNew, sizeof(int), (LPSTR) &nColors);
    if (nColors > 256)
        nColors = 256;

    // Get the palette entries regardless of the compression
    // Supermac uses non BI_RGB with a palette!

    if (lpbi->biBitCount == 8) {
        for (n=0; n<nColors; n++) {
            GetPaletteEntries(hPalNew, n, 1, &pe);
            lpRgb[n].rgbRed   = pe.peRed;
            lpRgb[n].rgbGreen = pe.peGreen;
            lpRgb[n].rgbBlue  = pe.peBlue;
        }
    }

    if (lpbi->biBitCount == 8 && lpbi->biCompression == BI_RGB) {

        //
        //  build a xlat table. from the old Palette to the new palette.
        //
        for (n=0; n<(int)lpbi->biClrUsed; n++) {
            xlat[n] = (BYTE)GetNearestPaletteIndex(hPalNew,
                RGB(lpRgb[n].rgbRed,lpRgb[n].rgbGreen,lpRgb[n].rgbBlue));
        }

        //
        // translate the DIB bits
        //
        if ((dwSize = lpbi->biSizeImage) == 0)
            dwSize = lpbi->biHeight * DIBWIDTHBYTES(*lpbi);

        switch ((WORD)lpbi->biCompression)
        {
            case BI_RGB:
                xlatClut8(lpBits, dwSize, xlat);
        }
    }

    // Fix for Supermac, force biClrUsed to the number of palette entries
    // even if non-BI_RGB formats.

    if (lpbi-> biBitCount <= 8)
        lpbi->biClrUsed = nColors;

    return TRUE;
}


/* DibPaint(LPCAPSTREAM lpcs, hdc)
 *
 * Paint the current DIB into the window;
 */
void DibPaint(LPCAPSTREAM lpcs, HDC hdc)
{
    RECT        rc;
    BOOL        fOK;
    
    fOK = (lpcs->lpBits != NULL);
    
    if (fOK) {
        if (lpcs-> fScale) {
            GetClientRect(lpcs->hwnd, &rc);
            fOK = DrawDibDraw(lpcs->hdd, hdc, 0, 0, 
                  rc.right - rc.left, rc.bottom - rc.top,
                  (LPBITMAPINFOHEADER)lpcs->lpBitsInfo, lpcs->lpBits,
                   0, 0, -1, -1, DDF_BACKGROUNDPAL);
        }
        else 
            fOK = DrawDibDraw(lpcs->hdd, hdc, 0, 0, 
                lpcs->dxBits, lpcs->dyBits,
                (LPBITMAPINFOHEADER)lpcs->lpBitsInfo, lpcs->lpBits,
                0, 0, -1, -1, DDF_BACKGROUNDPAL);
    }
    if (!fOK) {
        SelectObject(hdc, GetStockObject(BLACK_BRUSH));
        GetClientRect(lpcs->hwnd, &rc);
        PatBlt(hdc, 0, 0, rc.right, rc.bottom, PATCOPY);
    }
}

/*
 *
 * CreatePackedDib() - return the current DIB in packed (ie CF_DIB) format
 *
 */

HANDLE CreatePackedDib (LPBITMAPINFO lpBitsInfo, LPSTR lpSrcBits, HPALETTE hPalette)
{
    HANDLE              hdib;
    LPBITMAPINFO        lpbi;
    int                 i;
    DWORD               dwSize;
    PALETTEENTRY        pe;
    LPBYTE              lpBits;
    RGBQUAD FAR *       lpRgb;

   // If the data is compressed, let ICM do the work for us...
    if ( lpBitsInfo->bmiHeader.biCompression != BI_RGB &&
         lpBitsInfo->bmiHeader.biCompression != BI_RLE8 &&
        (lpBitsInfo->bmiHeader.biBitCount != 8 ||
         lpBitsInfo->bmiHeader.biBitCount != 24 )) {

        LPBITMAPINFO lpOutFormat = NULL;
        HANDLE hPackedDIBOut = NULL;

        if (!(lpOutFormat = (LPBITMAPINFO)GlobalAllocPtr(
                        GMEM_MOVEABLE, sizeof (BITMAPINFOHEADER) + 
                        256 * sizeof (RGBQUAD))))
            return NULL;

        hmemcpy ((HPSTR)lpOutFormat, (HPSTR)lpBitsInfo, sizeof (BITMAPINFOHEADER));

        // Try to get an RGB format
        lpOutFormat->bmiHeader.biSize = sizeof (BITMAPINFOHEADER);
        lpOutFormat->bmiHeader.biCompression = BI_RGB;
        lpOutFormat->bmiHeader.biClrUsed = 0;
        lpOutFormat->bmiHeader.biClrImportant = 0;

        // Uh, oh, force to a 24-bit DIB if > 8 BPP
        if (lpBitsInfo->bmiHeader.biBitCount <= 8) 
            lpOutFormat->bmiHeader.biBitCount = 8;
        else
            lpOutFormat->bmiHeader.biBitCount = 24;

        lpOutFormat->bmiHeader.biSizeImage = 
                WIDTHBYTES (lpOutFormat->bmiHeader.biWidth * 
                (lpOutFormat->bmiHeader.biBitCount == 8 ? 1 : 3)) * 
                lpOutFormat->bmiHeader.biHeight;

        hPackedDIBOut = ICImageDecompress (
                NULL,           /*hic*/ 
                0,              /*uiFlags*/
                lpBitsInfo,     /*lpbiIn*/
                lpSrcBits,      /*lpBits*/
                lpOutFormat);   /*use default format chosen by compressor*/

        if (lpOutFormat)
            GlobalFreePtr (lpOutFormat);

        return (hPackedDIBOut);
    }

    dwSize = lpBitsInfo->bmiHeader.biSize +
              lpBitsInfo->bmiHeader.biClrUsed * sizeof(RGBQUAD) +
              lpBitsInfo->bmiHeader.biSizeImage;

    hdib = GlobalAlloc(GMEM_MOVEABLE, dwSize);

    if (!hdib)
         return NULL;

    lpbi = (LPVOID)GlobalLock(hdib);

    //
    // copy the header
    //
    hmemcpy ((HPSTR)lpbi, (HPSTR)lpBitsInfo, lpBitsInfo->bmiHeader.biSize);
    
    //
    // copy the color table
    //
    lpRgb  = (RGBQUAD FAR *)((LPSTR)lpbi + (WORD)lpbi->bmiHeader.biSize);
    for (i=0; i < (int)lpBitsInfo->bmiHeader.biClrUsed; i++) {
        GetPaletteEntries(hPalette, i, 1, &pe);
        lpRgb[i].rgbRed   = pe.peRed;
        lpRgb[i].rgbGreen = pe.peGreen;
        lpRgb[i].rgbBlue  = pe.peBlue;
        lpRgb[i].rgbReserved = 0;
    }

    //
    // copy the bits.
    //
    lpBits  =   (LPBYTE)lpbi + 
                lpbi->bmiHeader.biSize +
                lpbi->bmiHeader.biClrUsed * sizeof(RGBQUAD);

    hmemcpy ((LPSTR)lpBits, (LPSTR)lpSrcBits, 
                lpbi->bmiHeader.biSizeImage);

    GlobalUnlock (hdib);

    return hdib;
 }


 /*---------------------------------------------------------------------+
 | dibIsWritable() - return TRUE if the dib format is writable,                  |
 |                     by out dibWrite() function, FALSE if not.                 |
 |                                                                               |
 +---------------------------------------------------------------------*/
BOOL FAR PASCAL dibIsWritable (LPBITMAPINFO lpBitsInfo)
{
    if (!lpBitsInfo)
        return FALSE;

     // For now, just assume that all capture formats have an installed
     // codec which can convert to RGB.  In the future, each time the 
     // format is changed, test that the codec actually accepts the format.

     return TRUE;
 }
 
 
 /*---------------------------------------------------------------------+
 | dibWrite() - write out the DIB to a file. The global header is       |
 |                in <glpBitsInfo> and the actual dib bits are in                |
 |                <glpBits>.  If it is palettized then the palette is in         |
 |                <ghPalCurrent>.                                                |
 |                                                                               |
 |  We won't do error reporting in this function, let the caller take   |
 |  care of that along with Opening and Closing the HMMIO.              |
 |                                                                               |
 +---------------------------------------------------------------------*/
BOOL FAR PASCAL dibWrite(LPCAPSTREAM lpcs, HMMIO hmmio)
 {
     BITMAPFILEHEADER   bfh;
     DWORD              dw;
     HANDLE             hPackedDib = NULL;
     LPBITMAPINFO       lpbi = NULL;
     BOOL               fOK = FALSE;

     /* do some checking */
    WinAssert(hmmio != 0);
     
    if (!lpcs->lpBits || !lpcs->lpBitsInfo)
        return FALSE;

    // Create a packed DIB, converting from a compressed format,
    // if necessary.
    hPackedDib = CreatePackedDib (lpcs->lpBitsInfo,
                        lpcs->lpBits,
                        lpcs->hPalCurrent);

    lpbi = (LPBITMAPINFO) GlobalLock (hPackedDib);

    if (!lpbi)
        goto WriteError;

    /* initialize the bitmap file header */
    bfh.bfType = 'B' | 'M' << 8;
    bfh.bfSize = sizeof(bfh) + sizeof(BITMAPINFOHEADER) +
        lpbi->bmiHeader.biSizeImage + 
        (lpbi->bmiHeader.biBitCount > 8 ? 0 : (lpbi->bmiHeader.biClrUsed * sizeof(RGBQUAD)));
  
    bfh.bfReserved1 = bfh.bfReserved2 = 0;
    bfh.bfOffBits = bfh.bfSize - lpbi->bmiHeader.biSizeImage ;

    // dw is the size of the BITMAPINFO + color table + image
    dw = bfh.bfSize - sizeof(bfh);

    /* write out the file header portion */
    if (mmioWrite(hmmio, (HPSTR)&bfh, (LONG)sizeof(BITMAPFILEHEADER)) != 
                sizeof(BITMAPFILEHEADER)){
         goto WriteError;
    }
    
    /* now write out the header and bits */
    if (mmioWrite(hmmio, (HPSTR)lpbi, (LONG) dw) == (LONG) dw) {
         fOK = TRUE;
    }
    
WriteError:
    if (lpbi)
        GlobalUnlock (hPackedDib);
    if (hPackedDib)
        GlobalFree (hPackedDib);

    return fOK;
}

/*--------------------------------------------------------------+
| fileSaveDIB - save the frame as a DIB                         |
|   Top level routine to save a single frame                    |
+--------------------------------------------------------------*/
BOOL FAR PASCAL fileSaveDIB(LPCAPSTREAM lpcs, LPSTR lpszFileName)
{
    HMMIO               hmmio;
    HCURSOR             hOldCursor;
    BOOL                fOK;

    hmmio = mmioOpen(lpszFileName, NULL, MMIO_WRITE);
    if( !hmmio ) {
	/* try and create */    
        hmmio = mmioOpen(lpszFileName, NULL, MMIO_CREATE | MMIO_WRITE);
	if( !hmmio ) {
	    /* find out if the file was read only or we are just */
	    /* totally hosed up here.				 */
	    hmmio = mmioOpen(lpszFileName, NULL, MMIO_READ);
	    if (hmmio){
		/* file was read only, error on it */
                errorUpdateError (lpcs, IDS_CAP_READONLYFILE, (LPSTR)lpszFileName);
		mmioClose(hmmio, 0);
		return FALSE;
	    } else {
		/* even weirder error has occured here, give CANTOPEN */
                errorUpdateError (lpcs, IDS_CAP_CANTOPEN, (LPSTR) lpszFileName);
		return FALSE;
	    }
	}
    }

    hOldCursor = SetCursor( lpcs-> hWaitCursor );

    mmioSeek(hmmio, 0, SEEK_SET);

    fOK = dibWrite(lpcs, hmmio);

    mmioClose( hmmio, 0 );

    SetCursor( hOldCursor );

    if (!fOK)
       errorUpdateError (lpcs, IDS_CAP_ERRORDIBSAVE, (LPSTR) lpszFileName);

    return fOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avicap.16\capdriv.c ===
/****************************************************************************
 *
 *   capdriv.c
 * 
 *   Smartdrv control.
 *
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992, 1993 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and 
 *    distribute the Sample Files (and/or any modified version) in 
 *    any way you find useful, provided that you agree that 
 *    Microsoft has no warranty obligations or liability for any 
 *    Sample Application Files which are modified. 
 *
 ***************************************************************************/

#include <windows.h>
#include <windowsx.h>

#pragma optimize ("", off)

// SD_CACHE_DRIVE:
// FUNCTION:
//        Enables and disables read or write caching for a particular
//        drive unit.  Returns the cache state of the drive in DL. Get
//        takes no action, but simply returns cache state for drive unit
//        in DL.
//
//        INPUT:
//                AX=MULT_SMARTDRV  (4A10h)
//                BX=SD_CACHE_DRIVE (3)
//                DL=CACHE_DRIVE_<get,read|write enable|disable>
//                BP=unit number of drive
//        OUTPUT:
//                DL=cache state of unit:
//                        Bit 7 set -> no caching enabled for this unit
//                        Bit 7 not set -> read caching enabled for this unit
//                        Bit 6 set -> write caching not enabled for this unit
//                        Bit 6 not set -> write caching enabled for this unit
//                        -1 -> not a cachable drive
//        USES:
//                ALL except DS,ES
//

#define MULT_SMARTDRV               0x4a10
#define SD_CACHE_DRIVE              3
#define CACHE_DRIVE_GET             0
#define CACHE_DRIVE_READ_ENABLE     1
#define CACHE_DRIVE_READ_DISABLE    2
#define CACHE_DRIVE_WRITE_ENABLE    3
#define CACHE_DRIVE_WRITE_DISABLE   4

#define F_WRITE_CACHE  (1 << 7)
#define F_READ_CACHE   (1 << 6)

WORD NEAR PASCAL SmartDrvCache(int iDrive, BYTE cmd)
{
    WORD    w;

    _asm {
        push    bp
        mov     ax, MULT_SMARTDRV
        mov     bx, SD_CACHE_DRIVE
        mov     dl, cmd
        mov     bp, iDrive
        int     2fh
        mov     al,dl
        xor     ah,ah
        pop     bp
        mov     w,ax
    }

    return w;
}

WORD FAR PASCAL SmartDrv(char chDrive, WORD w)
{
    WORD wCur;
    int  iDrive;

    iDrive = (chDrive | 0x20) - 'a';

    wCur = SmartDrvCache(iDrive, CACHE_DRIVE_GET);

    if (w & F_WRITE_CACHE)
        SmartDrvCache(iDrive, CACHE_DRIVE_WRITE_DISABLE);
    else
        SmartDrvCache(iDrive, CACHE_DRIVE_WRITE_ENABLE);

    if (w & F_READ_CACHE)
        SmartDrvCache(iDrive, CACHE_DRIVE_READ_DISABLE);
    else
        SmartDrvCache(iDrive, CACHE_DRIVE_READ_ENABLE);

    return wCur;
}

#pragma optimize ("", on)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avicap.16\capdib.h ===
/****************************************************************************
 *
 *   capdib.h
 * 
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992, 1993 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and 
 *    distribute the Sample Files (and/or any modified version) in 
 *    any way you find useful, provided that you agree that 
 *    Microsoft has no warranty obligations or liability for any 
 *    Sample Application Files which are modified. 
 *
 ***************************************************************************/

void SetDefaultCaptureFormat (LPBITMAPINFOHEADER lpbih);
DWORD AllocNewGlobalBitmapInfo (LPCAPSTREAM lpcs, LPBITMAPINFOHEADER lpbi);
DWORD AllocNewBitSpace (LPCAPSTREAM lpcs, LPBITMAPINFOHEADER lpbih);
DWORD DibInit (LPCAPSTREAM lpcs);
void DibFini (LPCAPSTREAM lpcs);
DWORD SendDriverFormat (LPCAPSTREAM lpcs, LPBITMAPINFOHEADER lpbih, DWORD dwInfoHeaderSize);
DWORD SetFormatFromDIB (LPCAPSTREAM lpcs, LPBITMAPINFOHEADER lpbih);
LPBITMAPINFO DibGetCurrentFormat (LPCAPSTREAM lpcs);
DWORD DibGetNewFormatFromDriver (LPCAPSTREAM lpcs);
BOOL DibNewFormatFromApp (LPCAPSTREAM lpcs, LPBITMAPINFO lpbi, WORD dwSize);
DWORD DibNewPalette (LPCAPSTREAM lpcs, HPALETTE hPalNew);
void DibPaint(LPCAPSTREAM lpcs, HDC hdc);
HANDLE CreatePackedDib (LPBITMAPINFO lpBitsInfo, LPSTR lpSrcBits, HPALETTE hPalette);
BOOL FAR PASCAL dibIsWritable (LPBITMAPINFO lpBitsInfo);
BOOL FAR PASCAL dibWrite(LPCAPSTREAM lpcs, HMMIO hmmio);
BOOL FAR PASCAL fileSaveDIB(LPCAPSTREAM lpcs, LPSTR lpszFileName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avicap.16\capframe.c ===
/****************************************************************************
 *
 *   capframe.c
 * 
 *   Single frame capture
 *
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992, 1993 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and 
 *    distribute the Sample Files (and/or any modified version) in 
 *    any way you find useful, provided that you agree that 
 *    Microsoft has no warranty obligations or liability for any 
 *    Sample Application Files which are modified. 
 *
 ***************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <memory.h>         // for _fmemset 
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <msvideo.h>
#include <drawdib.h>
#include <mmddk.h>
#include <avifmt.h>

#include "avicap.h"
#include "avicapi.h"        

#ifdef _DEBUG
    #define DSTATUS(lpcs, sz) statusUpdateStatus(lpcs, IDS_CAP_INFO, (LPSTR) sz)
#else
    #define DSTATUS(lpcs, sz) 
#endif


/*
 *  SingleFrameCaptureOpen
 *      
 */
BOOL FAR PASCAL SingleFrameCaptureOpen (LPCAPSTREAM lpcs)
{
    if (lpcs-> fCapturingNow || lpcs-> fFrameCapturingNow) {
        lpcs-> dwReturn = IDS_CAP_FILE_OPEN_ERROR;
        goto EarlyExit;
    }
    
    /* Warm up the compressor function */
    if (lpcs->CompVars.hic) {
        if (ICSeqCompressFrameStart(&lpcs->CompVars, lpcs->lpBitsInfo) == FALSE) {
            lpcs-> dwReturn = IDS_CAP_COMPRESSOR_ERROR;
            goto EarlyExit;
	}
        // Kludge, offset the lpBitsOut ptr 
        // Compman allocates the compress buffer too large by 
        // 2048 + 16 so we will still have room 
        ((LPBYTE) lpcs->CompVars.lpBitsOut) += 8;
    }

    if (!AVIFileInit(lpcs)) {
        lpcs-> dwReturn = IDS_CAP_FILE_OPEN_ERROR;
        goto EarlyExit;
    }

    lpcs-> fCapturingNow = TRUE;
    lpcs-> fFrameCapturingNow = TRUE;
    lpcs-> dwReturn = DV_ERR_OK;

    statusUpdateStatus(lpcs, IDS_CAP_BEGIN);  // Always the first message

    return TRUE;
            
EarlyExit:
    errorUpdateError(lpcs, (WORD) lpcs->dwReturn);
    return FALSE;
}


/*
 *  SingleFrameCaptureClose
 *      
 *      
 */
BOOL FAR PASCAL SingleFrameCaptureClose (LPCAPSTREAM lpcs)
{

    if ((!lpcs-> fCapturingNow) && (!lpcs-> fFrameCapturingNow)) {
        lpcs-> dwReturn = IDS_CAP_FILE_OPEN_ERROR;
        errorUpdateError(lpcs, (WORD) lpcs->dwReturn);
        return FALSE;
    }
    
    AVIFileFini(lpcs, FALSE /* fWroteJunkChunks */, FALSE /* fAbort */);
    
    if (lpcs->CompVars.hic) {
        // Kludge, offset the lpBitsOut ptr 
        if (lpcs->CompVars.lpBitsOut)
            ((LPBYTE) lpcs->CompVars.lpBitsOut) -= 8;
	ICSeqCompressFrameEnd(&lpcs->CompVars);
    }    

    lpcs->fCapFileExists = (lpcs-> dwReturn == DV_ERR_OK);
    lpcs->fCapturingNow = FALSE;
    lpcs->fFrameCapturingNow = FALSE;
    
    statusUpdateStatus(lpcs, IDS_CAP_END);  // Always the last message

    return TRUE;
}


// Writes compressed or uncompressed frames to the AVI file
// returns TRUE if no error, FALSE if end of file,
// and sets pfKey and plSize on exit.

BOOL SingleFrameWrite (
    LPCAPSTREAM             lpcs,       // capture stream
    LPVIDEOHDR              lpVidHdr,   // input header
    BOOL FAR 		    *pfKey,	// did it end up being a key frame?
    LONG FAR		    *plSize)	// size of returned image
{
    MMCKINFO    ck;
    BOOL        fOK = TRUE;
    DWORD	dwBytesUsed;
    BOOL	fKeyFrame;
    LPSTR	lpBits;

    if ((!lpcs-> fCapturingNow) ||
                (!(lpcs-> fStepCapturingNow || lpcs-> fFrameCapturingNow)) ||
                (!lpcs->hmmio)) {
        lpcs-> dwReturn = IDS_CAP_FILE_OPEN_ERROR;
        return FALSE;
    }
    
    /* Now compress the DIB to the format they chose */
    if (lpcs->CompVars.hic) {
	dwBytesUsed = 0;	// don't force a data rate
        lpBits = ICSeqCompressFrame(&lpcs->CompVars, 0,
    	        lpcs->lpBits, &fKeyFrame, &dwBytesUsed);

    /* They don't want it compressed */
    } else {
        // Use current values for writing the DIB to disk
        dwBytesUsed = lpcs->VidHdr.dwBytesUsed;
        fKeyFrame = (BOOL)(lpcs->VidHdr.dwFlags & VHDR_KEYFRAME);
        lpBits = lpcs->lpBits;
    }

    /* Create DIB Bits chunk */
    ck.cksize = dwBytesUsed;
    ck.ckid = MAKEAVICKID(cktypeDIBbits,0);
    ck.fccType = 0;
    if (mmioCreateChunk(lpcs->hmmio,&ck,0)) {
        fOK = FALSE;
    }

    /* Write DIB  data */
    if (fOK && mmioWrite(lpcs->hmmio, lpBits, dwBytesUsed) != 
                (LONG) dwBytesUsed) {
        fOK = FALSE;
    }
    
    if (fOK && mmioAscend(lpcs->hmmio, &ck, 0)) {
        fOK = FALSE;
    }

    *pfKey = fKeyFrame;
    *plSize = dwBytesUsed;

    return fOK;
}


/*
 *  SingleFrameCapture
 *      
 *  Append to the open single frame capture file.
 */
BOOL FAR PASCAL SingleFrameCapture (LPCAPSTREAM lpcs)
{
    LPVIDEOHDR lpVidHdr = &lpcs->VidHdr;
    BOOL fOK = FALSE;
    BOOL fKey;
    LONG lSize;

    if ((!lpcs-> fCapturingNow) ||
                (!(lpcs-> fStepCapturingNow || lpcs-> fFrameCapturingNow)) ||
                (!lpcs->hmmio)) {
        lpcs-> dwReturn = IDS_CAP_FILE_OPEN_ERROR;
        errorUpdateError(lpcs, (WORD) lpcs->dwReturn);
        return FALSE;
    }

    videoFrame( lpcs->hVideoIn, &lpcs->VidHdr );
    InvalidateRect( lpcs->hwnd, NULL, TRUE);

    if (lpVidHdr-> dwBytesUsed) {
        if (lpcs->CallbackOnVideoFrame)
            (*(lpcs->CallbackOnVideoFrame)) (lpcs->hwnd, lpVidHdr);

        if (!SingleFrameWrite (lpcs, lpVidHdr, &fKey, &lSize)) {
            // "ERROR: Could not write to file."
            errorUpdateError(lpcs, IDS_CAP_FILE_WRITE_ERROR);
        } 
        else {
            fOK = IndexVideo(lpcs, lSize, fKey);
            statusUpdateStatus (lpcs, IDS_CAP_STAT_CAP_L_FRAMES,
                            lpcs-> dwVideoChunkCount);
        }
    } // if the frame is done
    else
        errorUpdateError (lpcs, IDS_CAP_RECORDING_ERROR2);

    return fOK;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avicap.16\capmci.c ===
/****************************************************************************
 *
 *   capmci.c
 * 
 *   Control of MCI devices during capture.
 *
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992, 1993 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and 
 *    distribute the Sample Files (and/or any modified version) in 
 *    any way you find useful, provided that you agree that 
 *    Microsoft has no warranty obligations or liability for any 
 *    Sample Application Files which are modified. 
 *
 ***************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <memory.h>         // for _fmemset 
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <msvideo.h>
#include <drawdib.h>
#include <mmddk.h>

#include "avicap.h"
#include "avicapi.h"        

#ifdef _DEBUG
    #define DSTATUS(lpcs, sz) statusUpdateStatus(lpcs, IDS_CAP_INFO, (LPSTR) sz)
#else
    #define DSTATUS(lpcs, sz) 
#endif

DWORD SendDriverFormat (LPCAPSTREAM lpcs, LPBITMAPINFOHEADER lpbih, DWORD dwInfoHeaderSize);

/*--------------------------------------------------------------+
| TimeMSToHMSString() - change milliseconds into SMPTE time     |
+--------------------------------------------------------------*/
void FAR PASCAL TimeMSToSMPTE (DWORD dwMS, LPSTR lpTime)
{
	DWORD	dwTotalSecs;
	LONG	lHundredths;
	WORD	wSecs;
	WORD	wMins;
	WORD	wHours;

	/* convert to number of seconds */
	dwTotalSecs = dwMS / 1000;
	
	/* keep the remainder part */
	lHundredths = (dwMS - (dwTotalSecs * 1000)) / 10;
		    
	/* break down into other components */
	wHours = (WORD)(dwTotalSecs / 3600);	// get # Hours
	dwTotalSecs -= (wHours * 3600);
	
	wMins = (WORD)(dwTotalSecs / 60);	// get # Mins
	dwTotalSecs -= (wMins * 60);
	
	wSecs = (WORD)dwTotalSecs;	// what's left is # seconds
	
	/* build the string */
	/* KLUDGE, force hundredths to SMPTE approximation of PAL frames */
	wsprintf((char far *)lpTime, "%02u:%02u:%02u:%02lu", wHours, wMins,
		    wSecs, (lHundredths * 25) / 100);
}


/*--------------------------------------------------------------+
| START OF MCI CONTROL SECTION                                 |
+--------------------------------------------------------------*/

/*
 *  CountMCIDevicesByType 
 *      Returns a count of the number of VCR or Videodisc
 *      devices that MCI claims to know about.
 */

int CountMCIDevicesByType ( WORD wType )
{
   int nTotal;
   DWORD dwCount;
   MCI_SYSINFO_PARMS mciSIP;

   mciSIP.dwCallback = NULL;
   mciSIP.lpstrReturn = (LPSTR) (LPVOID) &dwCount;
   mciSIP.dwRetSize = sizeof (dwCount);

   mciSIP.wDeviceType = wType;
   
   if (!mciSendCommand (NULL, MCI_SYSINFO, MCI_SYSINFO_QUANTITY,
        (DWORD) (LPVOID) &mciSIP))
       nTotal = (int) *( (LPDWORD) mciSIP.lpstrReturn);

   return nTotal;
}

/*
 *  MCIDeviceClose
 *      This routine closes the open MCI device.
 */

void MCIDeviceClose (LPCAPSTREAM lpcs)
{
    mciSendString( "close mciframes", NULL, 0, NULL );
}

/*
 *  MCIDeviceOpen
 *      This routine opens the mci device for use, and sets the
 *      time format to milliseconds.
 *      Return FALSE on error;
 */

BOOL MCIDeviceOpen (LPCAPSTREAM lpcs)
{
    char        ach[160];

    wsprintf( ach, "open %s shareable alias mciframes",
                (LPSTR) lpcs-> achMCIDevice);
    lpcs-> dwMCIError = mciSendString( ach, NULL, 0, NULL );
    if( lpcs-> dwMCIError ) {
        DPF (" MCI Error, open %s shareable alias mciframes", lpcs-> achMCIDevice);
        goto err_return;
    }    
    lpcs-> dwMCIError = mciSendString( "set mciframes time format milliseconds", 
        NULL, 0, NULL );
    if( lpcs-> dwMCIError ) {
        DPF (" MCI Error, set mciframes time format milliseconds");
        goto err_close;
    }
    return ( TRUE );
   
err_close:
    MCIDeviceClose (lpcs);
err_return:
    return ( FALSE );
}


/*
 *  MCIDeviceGetPosition
 *      Stores the current device position in milliseconds in lpdwPos.
 *      Returns TRUE on success, FALSE if error.
 */
BOOL FAR PASCAL MCIDeviceGetPosition (LPCAPSTREAM lpcs, LPDWORD lpdwPos)
{
    char        ach[80];
    LPSTR       p;
    LONG        lv;
        
    lpcs-> dwMCIError = mciSendString( "status mciframes position wait", 
        ach, sizeof(ach), NULL );
    if( lpcs-> dwMCIError ) {
        DPF (" MCI Error, status mciframes position wait");
        *lpdwPos = 0L;
        return FALSE;
    }

    p = ach; 
    
    while (*p == ' ') p++;
    for (lv = 0; *p >= '0' && *p <= '9'; p++)
        lv = (10 * lv) + (*p - '0');
    *lpdwPos = lv;
    return TRUE;
}

/*
 *  MCIDeviceSetPosition
 *      Sets the current device position in milliseconds.
 *      Returns TRUE on success, FALSE if error.
 */
BOOL FAR PASCAL MCIDeviceSetPosition (LPCAPSTREAM lpcs, DWORD dwPos)
{
    char        achCommand[40];
    char        ach[80];
    
    lpcs-> dwMCIError = mciSendString( "pause mciframes wait", ach, sizeof(ach), NULL );
    if (lpcs-> dwMCIError) {
        DPF (" MCI Error, pause mciframes wait");
        return FALSE;
    }    
    wsprintf(achCommand, "seek mciframes to %ld wait", dwPos);
    lpcs-> dwMCIError = mciSendString( achCommand, ach, sizeof(ach), NULL );
    if (lpcs-> dwMCIError)
        DPF (" MCI Error, seek mciframes to %ld wait", dwPos);
    return ( lpcs-> dwMCIError == 0 ? TRUE : FALSE );
}


/*
 *  MCIDevicePlay
 *      Start playing the current MCI device from the current position
 *      Returns TRUE on success, FALSE if error.
 */
BOOL FAR PASCAL MCIDevicePlay (LPCAPSTREAM lpcs)
{
    char        ach[80];
    
    lpcs-> dwMCIError = mciSendString( "play mciframes", ach, sizeof(ach), NULL );
    if (lpcs-> dwMCIError)
        DPF (" MCI Error, play mciframes");
    return ( lpcs-> dwMCIError == 0 ? TRUE : FALSE );
}

/*
 *  MCIDevicePause
 *      Pauses the current MCI device at the current position
 *      Returns TRUE on success, FALSE if error.
 */
BOOL FAR PASCAL MCIDevicePause (LPCAPSTREAM lpcs)
{
    char        ach[80];
    
    lpcs-> dwMCIError = mciSendString( "pause mciframes wait", ach, sizeof(ach), NULL );
    if (lpcs-> dwMCIError)
        DPF (" MCI Error, pause mciframes wait");
    return ( lpcs-> dwMCIError == 0 ? TRUE : FALSE );
}

/*
 *  MCIDeviceStop
 *      Stops the current MCI device
 *      Returns TRUE on success, FALSE if error.
 */
BOOL FAR PASCAL MCIDeviceStop (LPCAPSTREAM lpcs)
{
    char        ach[80];
    
    lpcs-> dwMCIError = mciSendString( "stop mciframes wait", ach, sizeof(ach), NULL );
    if (lpcs-> dwMCIError)
        DPF (" MCI Error, stop mciframes wait");
    return ( lpcs-> dwMCIError == 0 ? TRUE : FALSE );
}

/*
 *  MCIDeviceStep
 *      Step the current MCI at the current position
 *      Returns TRUE on success, FALSE if error.
 */
BOOL FAR PASCAL MCIDeviceStep (LPCAPSTREAM lpcs, BOOL fForward)
{
    char        ach[80];
    
    lpcs-> dwMCIError = mciSendString( fForward ? "step mciframes wait" : 
                "step mciframes reverse wait", ach, sizeof(ach), NULL );
    if (lpcs-> dwMCIError)
        DPF (" MCI Error, step mciframes wait");
    return ( lpcs-> dwMCIError == 0 ? TRUE : FALSE );
}

/*
 *  MCIDeviceFreeze
 *      freeze the current frame
 *      Returns TRUE on success, FALSE if error.
 */
BOOL FAR PASCAL MCIDeviceFreeze(LPCAPSTREAM lpcs, BOOL fFreeze)
{
    lpcs-> dwMCIError = mciSendString( fFreeze ? "freeze mciframes wait" : 
                "unfreeze mciframes wait", NULL, 0, NULL);
    if (lpcs-> dwMCIError)
        DPF (" MCI Error, freeze mciframes wait");
    return ( lpcs-> dwMCIError == 0 ? TRUE : FALSE );
}


/*
 *  MCIStepCapture
 *      Main routine for performing MCI step capture.
 *      
 */
void FAR PASCAL _loadds MCIStepCapture (LPCAPSTREAM lpcs)
{
    BOOL        fOK = TRUE;
    BOOL        fT;
    BOOL        fKey;
    BOOL        fStopping;         // True when finishing capture
    DWORD       dw;
    WORD        w;
    WORD        wError;         // Error String ID
    LPVIDEOHDR  lpVidHdr;
    LPWAVEHDR   lpWaveHdr;
    DWORD       dwTimeToStop;   // Lesser of MCI capture time or frame limit
    BOOL        fTryToPaint = FALSE;
    HDC         hdc;
    HPALETTE    hpalT;
    RECT        rcDrawRect;
    LONG        lSize;

    statusUpdateStatus(lpcs, IDS_CAP_BEGIN);  // Always the first message

    // Verify capture parameters
    if ((!lpcs->sCapParms.fMCIControl) ||
        (!lpcs->sCapParms.fStepMCIDevice))
        goto EarlyExit;

    lpcs->MCICaptureState = CAPMCI_STATE_Uninitialized;

    lpcs-> fCapturingNow = TRUE;
    lpcs-> fStepCapturingNow = TRUE;
    lpcs-> dwReturn = DV_ERR_OK;

    // If not 1 Meg. free, give it up!!!
    if (GetFreePhysicalMemory () < (1024L * 1024L)) {
        errorUpdateError (lpcs, IDS_CAP_OUTOFMEM);
        lpcs-> dwReturn = IDS_CAP_OUTOFMEM;
        goto EarlyExit;
    }

    statusUpdateStatus(lpcs, IDS_CAP_STAT_CAP_INIT);

    // Try painting the DIB only if Live window
    fTryToPaint = lpcs->fLiveWindow;

    if (fTryToPaint) {
        hdc = GetDC(lpcs->hwnd);
        SetWindowOrg(hdc, lpcs->ptScroll.x, lpcs->ptScroll.y);
        hpalT = DrawDibGetPalette (lpcs->hdd);
        if (hpalT)
            hpalT = SelectPalette( hdc, hpalT, FALSE);
        RealizePalette(hdc);
        if (lpcs-> fScale)
            GetClientRect (lpcs->hwnd, &rcDrawRect);
        else
            SetRect (&rcDrawRect, 0, 0, lpcs->dxBits, lpcs->dyBits);
    }

    // -------------------------------------------------------
    //   When should capture stop?
    // -------------------------------------------------------

    // If using MCI, capture for the shorter of the MCI period,
    // or the capture limit

    if (lpcs->sCapParms.fLimitEnabled)
        dwTimeToStop = (DWORD) ((DWORD) 1000 * lpcs->sCapParms.wTimeLimit);
    else
        dwTimeToStop = (DWORD) -1L; // very large

    if (lpcs->sCapParms.fMCIControl) {
        // if MCI stop time not given, use lpcs->sCapParms.wTimeLimit
        if (lpcs->sCapParms.dwMCIStopTime == lpcs->sCapParms.dwMCIStartTime)
                    lpcs->sCapParms.dwMCIStopTime = lpcs->sCapParms.dwMCIStartTime +
                    (DWORD) ((DWORD)1000 * lpcs->sCapParms.wTimeLimit);

        dw = lpcs->sCapParms.dwMCIStopTime - lpcs->sCapParms.dwMCIStartTime;

        if (lpcs->sCapParms.fLimitEnabled) 
            dwTimeToStop = min (dw, dwTimeToStop);
        else 
            dwTimeToStop = dw;
    }

    //
    // never ever try to capture more than the index size!
    //
    if (lpcs->fCapturingToDisk) {
        dw = muldiv32(lpcs->sCapParms.dwIndexSize,
                lpcs->sCapParms.dwRequestMicroSecPerFrame,
                1000l);
        dwTimeToStop = min (dw, dwTimeToStop);
    }

    fOK = FALSE;            // Assume the worst
    if (MCIDeviceOpen (lpcs)) {
        if (MCIDeviceSetPosition (lpcs, lpcs->sCapParms.dwMCIStartTime))
            if (MCIDeviceStep (lpcs, TRUE))
                fOK = TRUE;
    }
    if (!fOK) {
        errorUpdateError (lpcs, IDS_CAP_MCI_CONTROL_ERROR);
        statusUpdateStatus(lpcs, NULL);    // Clear status
        lpcs-> dwReturn = IDS_CAP_MCI_CONTROL_ERROR;
        goto EarlyExit;
    }

    // -------------------------------------------------------
    //  Spatial and temporal averaging
    // -------------------------------------------------------

    // Frame Averaging, capture the same frame multiple times...
    lpcs->lpia = NULL;
    if (lpcs->sCapParms.wStepCaptureAverageFrames == 0)
        lpcs->sCapParms.wStepCaptureAverageFrames = 1;

    // Only allow averaging if an RGB format
    if (lpcs->lpBitsInfo->bmiHeader.biCompression != BI_RGB)
        lpcs->sCapParms.wStepCaptureAverageFrames = 1;

    // 2x Scaling
    lpcs->lpbmih2x = NULL;
    lpcs->VidHdr2x = lpcs->VidHdr;        // Init the 2x copy 

    if (lpcs->sCapParms.fStepCaptureAt2x && 
                lpcs->lpBitsInfo->bmiHeader.biCompression == BI_RGB) {
        lpcs->VidHdr2x.lpData = NULL;
        lpcs->lpbmih2x = (LPBITMAPINFOHEADER) GlobalAllocPtr (GHND, 
                sizeof (BITMAPINFOHEADER) +
                256 * sizeof (RGBQUAD));
        _fmemcpy (lpcs->lpbmih2x, lpcs->lpBitsInfo, sizeof (BITMAPINFOHEADER) +
                256 * sizeof (RGBQUAD));

        // Try to force the driver into 2x mode
        lpcs->lpbmih2x->biHeight    *= 2;
        lpcs->lpbmih2x->biWidth     *= 2;
        lpcs->lpbmih2x->biSizeImage *= 4;
        if (!SendDriverFormat (lpcs, lpcs->lpbmih2x, sizeof (BITMAPINFOHEADER))) {
            // Success, allocate new bitspace
            lpcs->VidHdr2x.lpData = GlobalAllocPtr (GHND, 
                        lpcs->lpbmih2x->biSizeImage);
            lpcs->VidHdr2x.dwBufferLength = lpcs->lpbmih2x->biSizeImage;
        }

        // Something went wrong, no memory, or driver failed request
        // so revert back to original settings
        if (!lpcs->VidHdr2x.lpData) {
            SendDriverFormat (lpcs, (LPBITMAPINFOHEADER) lpcs->lpBitsInfo, 
                sizeof (BITMAPINFOHEADER));
            lpcs->sCapParms.fStepCaptureAt2x = FALSE;
            lpcs->VidHdr2x = lpcs->VidHdr;        // Back to the original settings
        }
    }
    else
        lpcs->sCapParms.fStepCaptureAt2x = FALSE;

    DPF (" StepCaptureAt2x = %d\r\n", (int) lpcs->sCapParms.fStepCaptureAt2x);

    //
    // If we're compressing while capturing, warm up the compressor
    //
    if (lpcs->CompVars.hic) {
        if (ICSeqCompressFrameStart(&lpcs->CompVars, lpcs->lpBitsInfo) == NULL) {

	    // !!! We're in trouble here!  
            dprintf("ICSeqCompressFrameStart failed !!!\n");
            lpcs-> dwReturn = IDS_CAP_COMPRESSOR_ERROR;
            errorUpdateError (lpcs, IDS_CAP_COMPRESSOR_ERROR);
            goto EarlyExit;
        }
        // Kludge, offset the lpBitsOut ptr 
        // Compman allocates the compress buffer too large by 
        // 2048 + 16 so we will still have room 
        ((LPBYTE) lpcs->CompVars.lpBitsOut) += 8;
    }

    // No compression desired
    if (!lpcs->CompVars.hic)
	WinAssert(lpcs->CompVars.lpbiOut == NULL);

    // -------------------------------------------------------
    //  Open the output file
    // -------------------------------------------------------

    if (lpcs->fCapturingToDisk) {
        if (!AVIFileInit(lpcs)) {
            lpcs-> dwReturn = IDS_CAP_FILE_OPEN_ERROR;
            errorUpdateError (lpcs, IDS_CAP_FILE_OPEN_ERROR);
            goto EarlyExit;
        }
    }    

    /* Make sure the parent has been repainted */
    UpdateWindow(lpcs->hwnd);

    //
    // AVIInit will allocate sound buffers, but not video buffers
    // when performing step capture.
    //

    wError = AVIInit(lpcs);

    if (wError) {
        lpcs->sCapParms.fUsingDOSMemory = FALSE;
        wError = AVIInit(lpcs);
    }

    if (wError) {
        /* Error in initalization - return */
        errorUpdateError (lpcs, wError);
        AVIFini(lpcs);  
        AVIFileFini(lpcs, TRUE /* fWroteJunkChunks */, TRUE /* fAbort */);
        statusUpdateStatus(lpcs, NULL);    // Clear status
        lpcs-> dwReturn = wError;
        goto EarlyExit;
    }

    /* update the status, so the user knows how to stop */
    statusUpdateStatus(lpcs, IDS_CAP_SEQ_MSGSTOP);
    UpdateWindow(lpcs->hwnd);


    if (lpcs->sCapParms.fStepCaptureAt2x || (lpcs->sCapParms.wStepCaptureAverageFrames != 1)) {
        LPIAVERAGE FAR * lppia = (LPIAVERAGE FAR *) &lpcs->lpia;

        statusUpdateStatus (lpcs, IDS_CAP_STAT_PALETTE_BUILD);
        if (!iaverageInit (lppia, lpcs->lpBitsInfo, lpcs->hPalCurrent)) {
            lpcs-> dwReturn = IDS_CAP_OUTOFMEM;
            goto CompressFrameFailure;                
        }
        statusUpdateStatus(lpcs, NULL);
    }
    DPF (" Averaging %d frames\r\n", lpcs->sCapParms.wStepCaptureAverageFrames);

    GetAsyncKeyState(lpcs->sCapParms.vKeyAbort);
    GetAsyncKeyState(VK_ESCAPE);
    GetAsyncKeyState(VK_LBUTTON);
    GetAsyncKeyState(VK_RBUTTON);


    // -------------------------------------------------------
    //   MAIN VIDEO CAPTURE LOOP
    // -------------------------------------------------------

    fOK=TRUE;             // Set FALSE on write errors
    fStopping = FALSE;    // TRUE when we need to stop

    lpVidHdr  = &lpcs->VidHdr;
    lpWaveHdr = lpcs->alpWaveHdr[lpcs->iNextWave];

    lpcs->MCICaptureState = CAPMCI_STATE_Initialized;
    lpcs->dwTimeElapsedMS = 0;

    // Move back to the starting position
    MCIDeviceSetPosition (lpcs, lpcs->sCapParms.dwMCIStartTime);
    MCIDevicePause (lpcs);

    // Where are we *really*
    MCIDeviceGetPosition (lpcs, &lpcs->dwMCIActualStartMS);

    // freeze video
    MCIDeviceFreeze(lpcs, TRUE);
    
    while (lpcs->MCICaptureState != CAPMCI_STATE_AllFini) {

        // -------------------------------------------------------
        //   is there any reason to stop or change states
        // -------------------------------------------------------
        if (lpcs->sCapParms.vKeyAbort) {
            if (GetAsyncKeyState(lpcs->sCapParms.vKeyAbort & 0x00ff) & 0x0001) {
                fT = TRUE;
                if (lpcs->sCapParms.vKeyAbort & 0x8000)  // Ctrl?
                    fT = fT && (GetAsyncKeyState(VK_CONTROL) & 0x8000);
                if (lpcs->sCapParms.vKeyAbort & 0x4000)  // Shift?
                    fT = fT && (GetAsyncKeyState(VK_SHIFT) & 0x8000);
                fStopping = fT;      // User aborts
            }
        }
#if 0
        // Ignore Left mouse on MCI Capture!!!
        if (lpcs->sCapParms.fAbortLeftMouse)
            if (GetAsyncKeyState(VK_LBUTTON) & 0x0001)
                fStopping = TRUE;      // User aborts
#endif

        if (lpcs->sCapParms.fAbortRightMouse)
            if (GetAsyncKeyState(VK_RBUTTON) & 0x0001)
                fStopping = TRUE;      // User aborts
        if (lpcs-> fAbortCapture) {
            fStopping = TRUE;          // Somebody above wants us to quit
        }
        if (lpcs-> dwTimeElapsedMS > dwTimeToStop)
            fStopping = TRUE;      // all done


        // -------------------------------------------------------
        //    State machine 
        // -------------------------------------------------------
        switch (lpcs-> MCICaptureState) {

        case CAPMCI_STATE_Initialized:
            // Begin video step capture
            DSTATUS(lpcs, "MCIState: Initialized");
            lpcs->MCICaptureState = CAPMCI_STATE_StartVideo;
            break;

        case CAPMCI_STATE_StartVideo:
            // Begin video step capture
            lpcs->dwTimeElapsedMS = 0;
            lpcs->MCICaptureState = CAPMCI_STATE_CapturingVideo;
            break;

        case CAPMCI_STATE_CapturingVideo:
            // In the state of capturing video
            if (lpcs-> fStopCapture || lpcs-> fAbortCapture)
                fStopping = TRUE;

            if (fStopping) {
                MCIDeviceGetPosition (lpcs, &lpcs->dwMCIActualEndMS);
                MCIDevicePause (lpcs);

                DSTATUS(lpcs, "MCIState: StoppingVideo");

                if (fOK && !lpcs-> fAbortCapture)
                    lpcs->MCICaptureState = CAPMCI_STATE_VideoFini;
                else
                    lpcs->MCICaptureState = CAPMCI_STATE_AllFini;

                lpcs-> fStopCapture  = FALSE;
                lpcs-> fAbortCapture = FALSE;
                fStopping = FALSE;
            }
            break;

        case CAPMCI_STATE_VideoFini:
            // Wait for all buffers to be returned from the driver
            // Then move on to audio capture
            lpcs->MCICaptureState = CAPMCI_STATE_StartAudio;
            DSTATUS(lpcs, "MCIState: VideoFini");
            break;

        case CAPMCI_STATE_StartAudio:
            // If no audio, go to AllFini state
            if (!lpcs->sCapParms.fCaptureAudio || !fOK) {
                lpcs->MCICaptureState = CAPMCI_STATE_AllFini;
                break;
            }

            // Move back to the starting position
            MCIDeviceSetPosition (lpcs, lpcs->dwMCIActualStartMS);
            MCIDeviceGetPosition (lpcs, &lpcs->dwMCICurrentMS);
            DSTATUS(lpcs, "MCIState: StartAudio");
            MCIDevicePlay (lpcs);
            waveInStart(lpcs->hWaveIn);
            lpcs->MCICaptureState = CAPMCI_STATE_CapturingAudio;
            lpcs->dwTimeElapsedMS = 0;
            fStopping = FALSE;
            break;

        case CAPMCI_STATE_CapturingAudio:
            // In the state of capturing audio
            if (lpcs-> fStopCapture || lpcs-> fAbortCapture)
                fStopping = TRUE;

            MCIDeviceGetPosition (lpcs, &lpcs->dwMCICurrentMS);
            if (lpcs->dwMCICurrentMS + 100 > lpcs->dwMCIActualEndMS)
                fStopping = TRUE;
            if (fStopping) {
                waveInStop(lpcs->hWaveIn);
                MCIDevicePause (lpcs);
                waveInReset(lpcs->hWaveIn);
                lpcs->MCICaptureState = CAPMCI_STATE_AudioFini;
            }
            break;

        case CAPMCI_STATE_AudioFini:
            // While more audio buffers to process
            if (lpWaveHdr-> dwFlags & WHDR_DONE)
                break;
            lpcs->MCICaptureState = CAPMCI_STATE_AllFini;
            break;

        case CAPMCI_STATE_AllFini:
            DSTATUS(lpcs, "MCIState: AllFini");
            if (fOK)
                statusUpdateStatus(lpcs, IDS_CAP_STAT_CAP_FINI, lpcs->dwVideoChunkCount);
            else 
                statusUpdateStatus(lpcs, IDS_CAP_RECORDING_ERROR2);
            break;
        }

        // -------------------------------------------------------
        //        If we are in the video capture phase
        // -------------------------------------------------------

        if (lpcs->MCICaptureState == CAPMCI_STATE_CapturingVideo) {

            // if averaging...
            if (lpcs-> lpia) {
                int j;

                iaverageZero (lpcs-> lpia);

                // sum together a bunch of frames
                for (j = 0; j < (int)lpcs->sCapParms.wStepCaptureAverageFrames; j++) {
                        
	            videoFrame( lpcs-> hVideoIn, &lpcs-> VidHdr2x);

    	            // Shrink by 2x??
                    if (lpcs-> sCapParms.fStepCaptureAt2x) {
                        CrunchDIB(
                            lpcs-> lpia,        // image averaging structure
                            (LPBITMAPINFOHEADER)  lpcs-> lpbmih2x,  // BITMAPINFO src
                            (LPVOID) lpcs-> VidHdr2x.lpData,      // input bits 
                            (LPBITMAPINFOHEADER)  lpcs->lpBitsInfo, // BITMAPINFO dst
                            (LPVOID) lpcs->VidHdr.lpData);       // output bits
                    }
                    iaverageSum (lpcs-> lpia, lpcs->lpBits);
                }
                iaverageDivide (lpcs-> lpia, lpcs->lpBits);
            }
            // otherwise, not averaging, just get a frame
            else {
	        videoFrame( lpcs-> hVideoIn, &lpcs->VidHdr);
            }                           
                                    
            if (lpcs->CallbackOnVideoFrame)
                (*(lpcs->CallbackOnVideoFrame)) (lpcs->hwnd, &lpcs->VidHdr);

            // Update the display
	    InvalidateRect(lpcs->hwnd, NULL, TRUE);
	    UpdateWindow(lpcs->hwnd);
	    
            if (lpcs-> fCapturingToDisk) {
                if (!SingleFrameWrite (lpcs, lpVidHdr, &fKey, &lSize)) {
                    fOK = FALSE;
                    fStopping = TRUE;
                    // "ERROR: Could not write to file."
                    errorUpdateError(lpcs, IDS_CAP_FILE_WRITE_ERROR);
                } 
                else {
                    if (!IndexVideo(lpcs, lSize, fKey))
                        fStopping = TRUE;
                }
            } // endif fCapturingToDisk
            // Warning: Kludge to create frame chunk count when net capture
            // follows.
            else
                lpcs->dwVideoChunkCount++;
            
            // if there is still more time, (or at least every 100 frames) 
            // show status if we're not ending the capture
            if ((!fStopping) && (lpcs-> fCapturingToDisk) &&
                    (lpcs->dwVideoChunkCount)) {

                // "Captured %ld frames (Dropped %ld) %d.%03d sec. Hit Escape to Stop"
                statusUpdateStatus(lpcs, IDS_CAP_STAT_VIDEOCURRENT, 
                        lpcs->dwVideoChunkCount, lpcs->dwFramesDropped,
                        (int)(lpcs-> dwTimeElapsedMS/1000),
                        (int)(lpcs-> dwTimeElapsedMS%1000)
                        );
            } // endif next buffer not ready

            // Move the MCI source to the next capture point
            // unfreeze video
            MCIDeviceFreeze(lpcs, FALSE);
            for (;;) {
                MCIDeviceGetPosition (lpcs, &lpcs->dwMCICurrentMS);
                if (lpcs->dwMCICurrentMS > ((DWORD) (lpcs->dwMCIActualStartMS + 
                          muldiv32 (lpcs->dwVideoChunkCount,
                                lpcs->sCapParms.dwRequestMicroSecPerFrame,
                                1000L))))
                    break;
                MCIDeviceStep (lpcs, TRUE);
            }
            // freeze video
            MCIDeviceFreeze(lpcs, TRUE);
            lpcs-> dwTimeElapsedMS =
                    lpcs->dwMCICurrentMS - lpcs->dwMCIActualStartMS;

             /* return the emptied buffer to the que */
            lpVidHdr->dwFlags &= ~VHDR_DONE;
        }

        if (lpcs-> CallbackOnYield) {
            // If the yield callback returns FALSE, abort
            if (!((*(lpcs->CallbackOnYield)) (lpcs->hwnd)))
                fStopping = TRUE;
        }

        if (lpcs->sCapParms.fYield) { 
            MSG msg;

            if (PeekMessage(&msg,NULL,0,0,PM_REMOVE)) {
                // Kludge to get rid of timers from lpcs->hwnd
                if (msg.message == WM_TIMER && msg.hwnd == lpcs->hwnd)
                    ;
                else {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
            }
        }

        // -------------------------------------------------------
        //        Is audio buffer ready to be written?
        // -------------------------------------------------------
        if (lpcs->sCapParms.fCaptureAudio && 
                (lpcs-> MCICaptureState == CAPMCI_STATE_CapturingAudio ||
                lpcs-> MCICaptureState == CAPMCI_STATE_StartAudio ||
                lpcs-> MCICaptureState == CAPMCI_STATE_AudioFini)) {
            int iLastWave;

            //
            // we may need to yield for audio to get converted.
            //
            if (lpcs->fAudioYield)
                Yield();

            //
            // if all buffers are done, we have broke audio.
            //
            iLastWave = lpcs->iNextWave == 0 ? 
                        lpcs->iNumAudio -1 : lpcs->iNextWave-1;

            if (!fStopping && 
                    lpcs->alpWaveHdr[iLastWave]->dwFlags & WHDR_DONE)
                lpcs->fAudioBreak = TRUE;

            w = lpcs->iNumAudio; // don't get stuck here forever...
            while (w && fOK && (lpWaveHdr-> dwFlags & WHDR_DONE)) {
                w--;
                if (lpWaveHdr-> dwBytesRecorded) {
                    /* Chunk info is included in the wave data */
                    /* Reset Chunk Size in buffer */
                    ((LPRIFF)(lpWaveHdr->lpData))[-1].dwSize = 
                                lpWaveHdr-> dwBytesRecorded;
                    if (lpcs-> CallbackOnWaveStream) {
                        (*(lpcs->CallbackOnWaveStream)) (lpcs->hwnd, lpWaveHdr);
                    }
                    if (lpcs-> fCapturingToDisk) {
                        if(!AVIWrite (lpcs, lpWaveHdr-> lpData - sizeof(RIFF),
                                (lpWaveHdr-> dwBytesRecorded +
                                sizeof (RIFF) + 1) & ~1L)) {
                            fOK = FALSE;
                            fStopping = TRUE;
                            errorUpdateError (lpcs, IDS_CAP_FILE_WRITE_ERROR);
                         } else {
                            if (IndexAudio (lpcs, lpWaveHdr-> dwBytesRecorded))
                                lpcs->dwWaveBytes += lpWaveHdr-> dwBytesRecorded;
                            else
                                fStopping = TRUE;                                
                         }
                    } // endif capturing to disk
                    // Warning: Kludge to create wave chunk count when net capture
                    // follows.
                    else {
                        lpcs->dwWaveChunkCount++;
                        lpcs->dwWaveBytes += lpWaveHdr-> dwBytesRecorded;
                    }
                } // endif dwBytesRecorded
                
                lpWaveHdr-> dwBytesRecorded = 0;
                lpWaveHdr-> dwFlags &= ~WHDR_DONE;

                 /* return the emptied buffer to the que */
                if(waveInAddBuffer(lpcs->hWaveIn, lpWaveHdr, sizeof(WAVEHDR))) {
                    fOK = FALSE;
                    fStopping = TRUE;
                    errorUpdateError(lpcs, IDS_CAP_WAVE_ADD_ERROR);
                }

                /* increment the next wave buffer pointer */
                if(++lpcs->iNextWave >= lpcs->iNumAudio)
                    lpcs->iNextWave = 0;

                lpWaveHdr = lpcs->alpWaveHdr[lpcs->iNextWave];

            } // endwhile buffer available
        } // endif sound enabled
    } // end of forever

CompressFrameFailure:

    iaverageFini (lpcs->lpia);

    // Switch back to the normal format
    if (lpcs->sCapParms.fStepCaptureAt2x) {
        SendDriverFormat (lpcs, (LPBITMAPINFOHEADER) lpcs->lpBitsInfo, 
                sizeof (BITMAPINFOHEADER));
        GlobalFreePtr (lpcs->VidHdr2x.lpData);
        lpcs->VidHdr2x.lpData = NULL;
    }
    
    // And free the 2x memory
    if (lpcs->lpbmih2x) {
        GlobalFreePtr (lpcs->lpbmih2x);
        lpcs->lpbmih2x = NULL;
    }

    // -------------------------------------------------------
    //   END OF MAIN CAPTURE LOOP
    // -------------------------------------------------------
    
    lpcs-> dwTimeElapsedMS = lpcs-> dwMCIActualEndMS - lpcs->dwMCIActualStartMS;

    /* eat any keys that have been pressed */
    while(GetKey(FALSE))
        ;

    AVIFini(lpcs);  // does the Reset, and frees all buffers
    AVIFileFini(lpcs, FALSE /* fWroteJunkChunks */, FALSE /* fAbort */);
    

    /* Notify if there was an error while recording */

    if(!fOK) {
        errorUpdateError (lpcs, IDS_CAP_RECORDING_ERROR);
    }
    
    if (lpcs-> fCapturingToDisk) {
        if (lpcs->dwVideoChunkCount)
            dw = muldiv32(lpcs->dwVideoChunkCount,1000000,lpcs-> dwTimeElapsedMS);
        else 
            dw = 0;     // The muldiv32 doesn't give 0 if numerator is zero

        if(lpcs->sCapParms.fCaptureAudio) {
            // "Captured %d.%03d sec.  %ld frames (%d dropped) (%d.%03d fps).  %ld audio bytes (%d.%03d sps)"
            statusUpdateStatus(lpcs, IDS_CAP_STAT_VIDEOAUDIO,
                  (WORD)(lpcs-> dwTimeElapsedMS/1000),
                  (WORD)(lpcs-> dwTimeElapsedMS%1000),
                  lpcs->dwVideoChunkCount,
                  lpcs->dwFramesDropped,
                  (WORD)(dw / 1000),
                  (WORD)(dw % 1000),
                  lpcs->dwWaveBytes,
                  (WORD) lpcs->lpWaveFormat->nSamplesPerSec / 1000,
                  (WORD) lpcs->lpWaveFormat->nSamplesPerSec % 1000);
        } else {
            // "Captured %d.%03d sec.  %ld frames (%d dropped) (%d.%03d fps)."
            statusUpdateStatus(lpcs, IDS_CAP_STAT_VIDEOONLY,
                  (WORD)(lpcs-> dwTimeElapsedMS/1000),
                  (WORD)(lpcs-> dwTimeElapsedMS%1000),
                  lpcs->dwVideoChunkCount,
                  lpcs->dwFramesDropped,
                  (WORD)(dw / 1000),
                  (WORD)(dw % 1000));
        }
    } // endif capturing to disk (no warnings or errors if to net)

    // No frames captured, warn user that interrupts are probably not enabled.
    if (fOK && (lpcs->dwVideoChunkCount == 0)) {
        errorUpdateError (lpcs, IDS_CAP_NO_FRAME_CAP_ERROR);
    }
    // No audio captured, (but enabled), warn user audio card is hosed
    else if (fOK && lpcs->sCapParms.fCaptureAudio && (lpcs->dwWaveBytes == 0)) {
        errorUpdateError (lpcs, IDS_CAP_NO_AUDIO_CAP_ERROR);
    }

    // Audio underrun, inform user
    else if (fOK && lpcs->sCapParms.fCaptureAudio && lpcs->fAudioBreak) {
        errorUpdateError (lpcs, IDS_CAP_AUDIO_DROP_ERROR);
    }

    // If frames dropped, or changed capture rate, warn the user
    else if (fOK && lpcs->dwVideoChunkCount && lpcs->fCapturingToDisk) {

        // Warn user if dropped > 10% (default) of the frames
        if ((DWORD)100 * lpcs->dwFramesDropped / lpcs->dwVideoChunkCount >
                    lpcs-> sCapParms.wPercentDropForError) {

            // "%d of %ld frames (%d.%03d\%) dropped during capture."
            errorUpdateError (lpcs, IDS_CAP_STAT_FRAMESDROPPED,
                  lpcs->dwFramesDropped,
                  lpcs->dwVideoChunkCount,
                  (WORD)(muldiv32(lpcs->dwFramesDropped,10000,lpcs->dwVideoChunkCount)/100),
                  (WORD)(muldiv32(lpcs->dwFramesDropped,10000,lpcs->dwVideoChunkCount)%100)
                  );
        }
    }

EarlyExit:

    //
    // If we were compressing while capturing, close it down
    //
    if (lpcs->CompVars.hic) {
        // Kludge, reset the lpBitsOut pointer
        if (lpcs->CompVars.lpBitsOut)
            ((LPBYTE) lpcs->CompVars.lpBitsOut) -= 8;
	ICSeqCompressFrameEnd(&lpcs->CompVars);
    }

    if (fTryToPaint) {
        if (hpalT)
             SelectPalette(hdc, hpalT, FALSE);
        ReleaseDC (lpcs->hwnd, hdc);
    }

    if (lpcs->sCapParms.fMCIControl) 
        MCIDeviceClose (lpcs);

    // Let the user see where capture stopped
    if ((!lpcs->fLiveWindow) && (!lpcs->fOverlayWindow)) 
        videoFrame( lpcs->hVideoIn, &lpcs->VidHdr );  
    InvalidateRect( lpcs->hwnd, NULL, TRUE);

    lpcs->fCapFileExists = (lpcs-> dwReturn == DV_ERR_OK);
    lpcs->fCapturingNow      = FALSE;
    lpcs-> fStepCapturingNow = FALSE;
    
    statusUpdateStatus(lpcs, IDS_CAP_END);  // Always the last message

    return;
}



       


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avicap.16\capfile.c ===
/****************************************************************************
 *
 *   capfile.c
 * 
 *   AVI file writing module.
 *
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992, 1993 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and 
 *    distribute the Sample Files (and/or any modified version) in 
 *    any way you find useful, provided that you agree that 
 *    Microsoft has no warranty obligations or liability for any 
 *    Sample Application Files which are modified. 
 *
 ***************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <msvideo.h>
#include <avifmt.h>
#include <drawdib.h>
#include "avicap.h"
#include "avicapi.h"


/*----------------------------------------------------------------------+
| fileCapFileIsAVI() - Returns TRUE if the capture file is a valid AVI |
|                                   |
+----------------------------------------------------------------------*/
BOOL FAR PASCAL fileCapFileIsAVI (LPSTR lpsz)
{
    BOOL        fReturn = TRUE;
    HMMIO       hmmioSource = NULL;
    MMCKINFO    ckRIFF;
    
    // Does the file exist?
    hmmioSource = mmioOpen(lpsz, NULL, MMIO_READ);
    if (!hmmioSource)
        return FALSE;
    
    // Is there an AVI RIFF chunk?
    // !!! Don't do a FINDRIFF for an AVI chunk or it'll take several minutes to
    // !!! come back from checking a really big file
    fReturn = (mmioDescend(hmmioSource, &ckRIFF, NULL, 0) == 0) &&
		(ckRIFF.ckid == FOURCC_RIFF) &&
		(ckRIFF.fccType == formtypeAVI);

    if (hmmioSource)
        mmioClose(hmmioSource, 0);

    return fReturn;
}

/*----------------------------------------------------------------------+
| fileSaveCopy() - save a copy of the current capture file.     |
|                                   |
+----------------------------------------------------------------------*/
BOOL FAR PASCAL fileSaveCopy(LPCAPSTREAM lpcs)
{
#define INITFILE_BUFF_SIZE  (1024L * 256L)
    BOOL        fReturn = TRUE;
    char        achCaption[80]; // caption on Open File dialog
    
    HMMIO       hmmioSource = NULL, hmmioDest = NULL;
    LONG        lFileSize, lFileSizeTotal, lTemp;
    HANDLE      hMem = NULL;
    LPSTR       lpstr = NULL;
    LONG        lBuffSize = INITFILE_BUFF_SIZE;
    MMCKINFO    ckRIFF;
    HCURSOR     hOldCursor;

    
    /* grab a big buffer to xfer the file in, start the */
    /* buffer size at 32K and hope we get that much.    */
TRYAGAIN:    
    hMem = GlobalAlloc(GMEM_MOVEABLE, lBuffSize);
    if (!hMem){
        /* we don't have this much mem, go for half that */
        lBuffSize /= 2;
        if (lBuffSize)
            goto TRYAGAIN;
        else {
            fReturn = FALSE;
            goto SAVECOPYOUT;
        }
    }

    /* let's go and create the destination file */
    hmmioDest = mmioOpen(lpcs->achSaveAsFile, NULL, MMIO_CREATE|MMIO_WRITE);
    if (!hmmioDest){
        /* we've got an error of some kind here, let's bail out */
        /* on this one.                     */
        errorUpdateError (lpcs, IDS_CAP_CANTOPEN, (LPSTR)lpcs->achSaveAsFile);
        fReturn = FALSE;
        goto SAVECOPYOUT;
    }
    
    /* open up the source file and find the size */
    hmmioSource = mmioOpen(lpcs->achFile, NULL, MMIO_READ);
    if (!hmmioSource){
        /* we are totally hosed here, the source file can't even */
        /* be opened up, error out.              */
        errorUpdateError (lpcs, IDS_CAP_CANTOPEN, (LPSTR)lpcs->achFile);
        fReturn = FALSE;
        goto SAVECOPYOUT;
    }
    
    /* go down to the RIFF chunk and find out the size of this  */
    /* thing.  If there is no RIFF chunk then we can safely */
    /* assume that the file is of 0 length.         */
    ckRIFF.fccType = formtypeAVI;
    if (mmioDescend(hmmioSource, &ckRIFF, NULL, MMIO_FINDRIFF) != 0){
        /* we are done, this file has no RIFF chunk so it's size */
        /* is 0 bytes.  Just close up and leave.         */
        goto SAVECOPYOUT;
    } else {
        /* there is a RIFF chunk, get the size of the file and  */
        /* get back to the start of the file.           */
        lFileSizeTotal = lFileSize = ckRIFF.cksize + 8;
        mmioAscend(hmmioSource, &ckRIFF, 0);
        mmioSeek(hmmioSource, 0L, SEEK_SET);
    }
    
    /* Before trying to write, seek to the end of the destination  */
    /* file and write one byte.  This both preallocates the file,  */
    /* and confirms enough disk is available for the copy, without */
    /* going through the trial and error of writing each byte.     */

    mmioSeek( hmmioDest, lFileSizeTotal - 1, SEEK_SET );
    mmioWrite( hmmioDest, (HPSTR) achCaption, 1L );
    if (mmioSeek (hmmioDest, 0, SEEK_END) < lFileSizeTotal) {

        /* Notify user with message that disk may be full. */
        errorUpdateError (lpcs, IDS_CAP_WRITEERROR, (LPSTR)lpcs->achSaveAsFile);
    
        /* close the file and delete it */
        mmioClose(hmmioDest, 0);
        mmioOpen(lpcs->achSaveAsFile, NULL, MMIO_DELETE);
        hmmioDest = NULL;
        fReturn = FALSE;
        goto SAVECOPYOUT;
    }
    
    mmioSeek (hmmioDest, 0L, SEEK_SET); // Back to the beginning

    UpdateWindow(lpcs->hwnd);             // Make everything pretty 

    hOldCursor = SetCursor( lpcs->hWaitCursor );

    /* lock our buffer and start xfering data */
    lpstr = GlobalLock(hMem);

    while (lFileSize > 0) {

        if (lFileSize < lBuffSize)
            lBuffSize = lFileSize;
        mmioRead(hmmioSource, (HPSTR)lpstr, lBuffSize);
        if (mmioWrite(hmmioDest, (HPSTR)lpstr, lBuffSize) <= 0) {
            /* we got a write error on the file, error on it */
            errorUpdateError (lpcs, IDS_CAP_WRITEERROR, (LPSTR)lpcs->achSaveAsFile);
        
            /* close the file and delete it */
            mmioClose(hmmioDest, 0);
            mmioOpen(lpcs->achSaveAsFile, NULL, MMIO_DELETE);
            hmmioDest = NULL;
            fReturn = FALSE;
            goto SAVECOPYOUT0;
        }

        // Let the user hit escape to get out
        if (GetAsyncKeyState(VK_ESCAPE) & 0x0001) {
            /* close the file and delete it */
            mmioClose(hmmioDest, 0);
            mmioOpen(lpcs->achSaveAsFile, NULL, MMIO_DELETE);
            hmmioDest = NULL;
            goto SAVECOPYOUT0;
        }

        lFileSize -= lBuffSize;

        // lTemp is percentage complete
        lTemp = muldiv32 (lFileSizeTotal - lFileSize, 100L, lFileSizeTotal);
        statusUpdateStatus (lpcs, IDS_CAP_SAVEASPERCENT, lTemp);

        Yield();
    } // endwhile more bytes to copy
SAVECOPYOUT0:
    SetCursor( hOldCursor );
    

SAVECOPYOUT:
    /* close files, free up mem, restore cursor and get out */
    if (hmmioSource) mmioClose(hmmioSource, 0);
    if (hmmioDest){
        mmioSeek(hmmioDest, 0L, SEEK_END);
        mmioClose(hmmioDest, 0);    
    }
    if (hMem) {
        GlobalUnlock(hMem);
        GlobalFree(hMem);
    }
    statusUpdateStatus (lpcs, NULL);    
    return fReturn;
}


/*--------------------------------------------------------------+
| fileAllocCapFile - allocate the capture file			|
|								|
+--------------------------------------------------------------*/
BOOL FAR PASCAL fileAllocCapFile(LPCAPSTREAM lpcs, DWORD dwNewSize)
{
    BOOL        fOK = FALSE;
    HMMIO       hmmio;
    WORD	w;
    HCURSOR     hOldCursor;

    lpcs->fCapFileExists = FALSE;
    hmmio = mmioOpen(lpcs->achFile, NULL, MMIO_WRITE);
    if( !hmmio ) {
	/* try and create */    
        hmmio = mmioOpen(lpcs-> achFile, NULL,
		MMIO_CREATE | MMIO_WRITE);
	if( !hmmio ) {
	    /* find out if the file was read only or we are just */
	    /* totally hosed up here.				 */
	    hmmio = mmioOpen(lpcs-> achFile, NULL, MMIO_READ);
	    if (hmmio){
		/* file was read only, error on it */
                errorUpdateError (lpcs, IDS_CAP_READONLYFILE, (LPSTR)lpcs-> achFile);
		mmioClose(hmmio, 0);
		return FALSE;
	    } else {
		/* even weirder error has occured here, give CANTOPEN */
                errorUpdateError (lpcs, IDS_CAP_CANTOPEN, (LPSTR) lpcs-> achFile);
		return FALSE;
	    }
	}
    }

    /* find the size */
    lpcs-> lCapFileSize = mmioSeek(hmmio, 0L, SEEK_END);

    if( dwNewSize == 0 )
        dwNewSize = 1;
	    	    
    lpcs-> lCapFileSize = dwNewSize;
    hOldCursor = SetCursor( lpcs-> hWaitCursor );

    // Delete the existing file so we can recreate to the correct size
    mmioClose(hmmio, 0);	// close the file before deleting 
    mmioOpen(lpcs-> achFile, NULL, MMIO_DELETE);

    /* now create a new file with that name */
    hmmio = mmioOpen(lpcs-> achFile, NULL, MMIO_CREATE | MMIO_WRITE);
    if( !hmmio ) {
        return FALSE;
    }
   
    /* Seek to end of new file */
    fOK = (mmioSeek( hmmio, dwNewSize - 1, SEEK_SET ) == (LONG) dwNewSize - 1);

    // write any garbage byte at the end of the file
    fOK &= (mmioWrite( hmmio, (HPSTR) &w, 1L ) == 1); 
    mmioClose( hmmio, 0 );

    SetCursor( hOldCursor );

    if (!fOK)
        errorUpdateError (lpcs, IDS_CAP_NODISKSPACE);

    return fOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avicap.16\capmisc.c ===
/****************************************************************************
 *
 *   capmisc.c
 * 
 *   Miscellaneous status and error routines.
 *
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992, 1993 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and 
 *    distribute the Sample Files (and/or any modified version) in 
 *    any way you find useful, provided that you agree that 
 *    Microsoft has no warranty obligations or liability for any 
 *    Sample Application Files which are modified. 
 *
 ***************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <msvideo.h>
#include <drawdib.h>
#include "avicap.h"
#include "avicapi.h"

static char szNull[] = "";

/*
 *
 *   GetKey
 *           Peek into the message que and get a keystroke
 *
 */
WORD GetKey(BOOL fWait)
{
    MSG msg;

    msg.wParam = 0;

    if (fWait)
         GetMessage(&msg, NULL, WM_KEYFIRST, WM_KEYLAST);

    while(PeekMessage(&msg, NULL, WM_KEYFIRST, WM_KEYLAST, PM_REMOVE|PM_NOYIELD))
         ;
    return msg.wParam;
}


// wID is the string resource, which can be a format string
void FAR _cdecl statusUpdateStatus (LPCAPSTREAM lpcs, WORD wID, ...)
{
    char ach[256];
    char szFmt[132];
    int j, k;
    BOOL fHasFormatChars = FALSE;
    
    if (lpcs-> CallbackOnStatus) {
        if (wID == NULL) {
            if (lpcs->fLastStatusWasNULL)   // No need to send NULL twice in a row
                return;
            lpcs->fLastStatusWasNULL = TRUE;
            lstrcpy (ach, szNull);
        }
        else if (!LoadString(lpcs->hInst, wID, szFmt, sizeof (szFmt))) {
            lpcs->fLastStatusWasNULL = FALSE;
            MessageBeep (0);
            return;
        }
        else {
            lpcs->fLastStatusWasNULL = FALSE;
            k = lstrlen (szFmt);
            for (j = 0; j < k; j++) {
                if (szFmt[j] == '%') {
                   fHasFormatChars = TRUE;
                   break;
                }
            }
            if (fHasFormatChars)
                wvsprintf(ach, szFmt, (LPSTR)(((WORD FAR *)&wID) + 1));
            else
                lstrcpy (ach, szFmt);
        }

        (*(lpcs->CallbackOnStatus)) (lpcs->hwnd, wID, ach);
    }
}

// wID is the string resource, which can be a format string
void FAR _cdecl errorUpdateError (LPCAPSTREAM lpcs, WORD wID, ...)
{
    char ach[256];
    char szFmt[132];
    int j, k;
    BOOL fHasFormatChars = FALSE;
    
    lpcs->dwReturn = wID;

    if (lpcs-> CallbackOnError) {
        if (wID == NULL) {
            if (lpcs->fLastErrorWasNULL)   // No need to send NULL twice in a row
                return;
            lpcs->fLastErrorWasNULL = TRUE;
            lstrcpy (ach, szNull);
        }
        else if (!LoadString(lpcs->hInst, wID, szFmt, sizeof (szFmt))) {
            MessageBeep (0);
            lpcs->fLastErrorWasNULL = FALSE;
            return;
        }
        else {
            lpcs->fLastErrorWasNULL = FALSE;
            k = lstrlen (szFmt);
            for (j = 0; j < k; j++) {
                if (szFmt[j] == '%') {
                   fHasFormatChars = TRUE;
                   break;
                }
            }
            if (fHasFormatChars)
                wvsprintf(ach, szFmt, (LPSTR)(((WORD FAR *)&wID) + 1));
            else
                lstrcpy (ach, szFmt);
        }

        (*(lpcs->CallbackOnError)) (lpcs->hwnd, wID, ach);
    }
}

// Callback client with ID of driver error msg
void errorDriverID (LPCAPSTREAM lpcs, DWORD dwError)
{
    char ach[132];
    
    lpcs->fLastErrorWasNULL = FALSE;
    lpcs->dwReturn = dwError;

    if (lpcs-> CallbackOnError) {
        if (!dwError)
            lstrcpy (ach, szNull);
        else {
            videoGetErrorText (lpcs->hVideoIn,
                        (UINT)dwError, ach, sizeof(ach));
        }
        (*(lpcs->CallbackOnError)) (lpcs->hwnd, IDS_CAP_DRIVER_ERROR, ach);
    }
}


#ifdef  _DEBUG

void FAR cdecl dprintf(LPSTR szFormat, ...)
{
    char ach[128];

    static BOOL fDebug = -1;

    if (fDebug == -1)
        fDebug = GetProfileInt("Debug", "AVICAP", FALSE);

    if (!fDebug)
        return;

    lstrcpy(ach, "AVICAP: ");
    wvsprintf(ach+8,szFormat,(LPSTR)(&szFormat+1));
    lstrcat(ach, "\r\n");

    OutputDebugString(ach);
}

/* _Assert(fExpr, szFile, iLine)
 *
 * If <fExpr> is TRUE, then do nothing.  If <fExpr> is FALSE, then display
 * an "assertion failed" message box allowing the user to abort the program,
 * enter the debugger (the "Retry" button), or igore the error.
 *
 * <szFile> is the name of the source file; <iLine> is the line number
 * containing the _Assert() call.
 */
#pragma optimize("", off)
BOOL FAR PASCAL
_Assert(BOOL fExpr, LPSTR szFile, int iLine)
{
         static char       ach[300];         // debug output (avoid stack overflow)
         int               id;
         int               iExitCode;
         void FAR PASCAL DebugBreak(void);

         /* check if assertion failed */
         if (fExpr)
                  return fExpr;

         /* display error message */
         wsprintf(ach, "File %s, line %d", (LPSTR) szFile, iLine);
         MessageBeep(MB_ICONHAND);
	 id = MessageBox(NULL, ach, "Assertion Failed", MB_SYSTEMMODAL | MB_ICONHAND | MB_ABORTRETRYIGNORE);

         /* abort, debug, or ignore */
         switch (id)
         {

         case IDABORT:

                  /* kill this application */
                  iExitCode = 0;
#ifndef WIN32
                  _asm
                  {
                           mov      ah, 4Ch
                           mov      al, BYTE PTR iExitCode
                           int     21h
                  }
#endif // WIN16
                  break;

         case IDRETRY:

                  /* break into the debugger */
                  DebugBreak();
                  break;

         case IDIGNORE:

                  /* ignore the assertion failure */
                  break;

         }
         
         return FALSE;
}
#pragma optimize("", on)

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avicap.16\capinit.c ===
/****************************************************************************
 *
 *   capinit.c
 *
 *   Initialization code.
 *
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992, 1993 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and
 *    distribute the Sample Files (and/or any modified version) in
 *    any way you find useful, provided that you agree that
 *    Microsoft has no warranty obligations or liability for any
 *    Sample Application Files which are modified.
 *
 ***************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include <ver.h>
#include <mmsystem.h>

//
// define these before any msvideo.h, so our functions get declared right.
//
#ifndef WIN32
#define VFWAPI  FAR PASCAL _loadds
#define VFWAPIV FAR CDECL  _loadds
#endif

#include "msvideo.h"
#include <drawdib.h>
#include "avicap.h"
#include "avicapi.h"

// for correct handling of capGetDriverDescription on NT and Chicago
// this is used by the NT version of avicap.dll (16bit) but not intended for
// public use, hence not in msvideo.h
DWORD WINAPI videoCapDriverDescAndVer (
        DWORD wDriverIndex,
        LPSTR lpszName, UINT cbName,
        LPSTR lpszVer, UINT cbVer);

HINSTANCE ghInst;
BOOL gfIsRTL;
char szCaptureWindowClass[] = "ClsCapWin";

typedef struct tagVS_VERSION
{
    WORD wTotLen;
    WORD wValLen;
    char szSig[16];
    VS_FIXEDFILEINFO vffInfo;
} VS_VERSION;

typedef struct tagLANGANDCP
{
    WORD wLanguage;
    WORD wCodePage;
} LANGANDCP;


BOOL FAR PASCAL RegisterCaptureClass (HINSTANCE hInst)
{
    WNDCLASS cls;

    // If we're already registered, we're OK
    if (GetClassInfo(hInst, szCaptureWindowClass, &cls))
	return TRUE;

    cls.hCursor           = LoadCursor(NULL, IDC_ARROW);
    cls.hIcon             = NULL;
    cls.lpszMenuName      = NULL;
    cls.lpszClassName     = szCaptureWindowClass;
    cls.hbrBackground     = (HBRUSH)(COLOR_APPWORKSPACE + 1);
    cls.hInstance         = hInst;
    cls.style             = CS_HREDRAW|CS_VREDRAW | CS_BYTEALIGNCLIENT |
                            CS_GLOBALCLASS;
    cls.lpfnWndProc       = (WNDPROC) CapWndProc;
    cls.cbClsExtra        = 0;
    // Kludge, VB Status and Error GlobalAlloc'd ptrs + room to grow...
    cls.cbWndExtra        = sizeof (LPCAPSTREAM) + sizeof (DWORD) * 4;

    RegisterClass(&cls);

    return TRUE;
}

//
// Internal version
// Get the name and version of the video device
//
BOOL capInternalGetDriverDesc (WORD wDriverIndex,
        LPSTR lpszName, int cbName,
        LPSTR lpszVer, int cbVer)
{
   return (BOOL) videoCapDriverDescAndVer(
                     wDriverIndex,
                  lpszName, cbName,
                  lpszVer, cbVer);

}

//
// Exported version
// Get the name and version of the video device
//
BOOL VFWAPI capGetDriverDescription (WORD wDriverIndex,
        LPSTR lpszName, int cbName,
        LPSTR lpszVer, int cbVer)
{
    return (capInternalGetDriverDesc (wDriverIndex,
        lpszName, cbName,
        lpszVer, cbVer));
}

//
// Disconnect from hardware resources
//
BOOL CapWinDisconnectHardware(LPCAPSTREAM lpcs)
{
    if( lpcs->hVideoCapture ) {
        videoStreamFini (lpcs->hVideoCapture);
        videoClose( lpcs->hVideoCapture );
    }
    if( lpcs->hVideoDisplay ) {
        videoStreamFini (lpcs->hVideoDisplay);
        videoClose( lpcs->hVideoDisplay );
    }
    if( lpcs->hVideoIn ) {
        videoClose( lpcs->hVideoIn );
    }

    lpcs->fHardwareConnected = FALSE;

    lpcs->hVideoCapture = NULL;
    lpcs->hVideoDisplay = NULL;
    lpcs->hVideoIn = NULL;

    lpcs->sCapDrvCaps.fHasDlgVideoSource = FALSE;
    lpcs->sCapDrvCaps.fHasDlgVideoFormat = FALSE;
    lpcs->sCapDrvCaps.fHasDlgVideoDisplay = FALSE;
    lpcs->sCapDrvCaps.fHasDlgVideoDisplay = FALSE;

    lpcs->sCapDrvCaps.hVideoIn          = NULL;
    lpcs->sCapDrvCaps.hVideoOut         = NULL;
    lpcs->sCapDrvCaps.hVideoExtIn       = NULL;
    lpcs->sCapDrvCaps.hVideoExtOut      = NULL;

    return TRUE;
}

//
// Connect to hardware resources
// Return: TRUE if hardware connected to the stream
//
BOOL CapWinConnectHardware (LPCAPSTREAM lpcs, WORD wDeviceIndex)
{
    DWORD dwError;
    CHANNEL_CAPS VideoCapsExternalOut;
    char ach1[_MAX_CAP_PATH];
    char ach2[_MAX_CAP_PATH * 3];
    CAPINFOCHUNK cic;
    HINSTANCE hInstT;

    lpcs->hVideoCapture = NULL;
    lpcs->hVideoDisplay = NULL;
    lpcs->hVideoIn = NULL;
    lpcs->fHardwareConnected = FALSE;
    lpcs->fUsingDefaultPalette = TRUE;
    lpcs->sCapDrvCaps.fHasDlgVideoSource = FALSE;
    lpcs->sCapDrvCaps.fHasDlgVideoFormat = FALSE;
    lpcs->sCapDrvCaps.fHasDlgVideoDisplay = FALSE;
    lpcs->sCapDrvCaps.wDeviceIndex = wDeviceIndex;

    // Clear any existing capture device name chunk
    cic.fccInfoID = mmioFOURCC ('I','S','F','T');
    cic.lpData = NULL;
    cic.cbData = 0;
    SetInfoChunk (lpcs, &cic);

    // try and open the video hardware!!!
    if( !(dwError = videoOpen( &lpcs->hVideoIn, wDeviceIndex, VIDEO_IN ) ) ) {
        if( !(dwError = videoOpen( &lpcs->hVideoCapture, wDeviceIndex, VIDEO_EXTERNALIN ) ) ) {
            // We don't require the EXTERNALOUT channel,
            // but do require EXTERNALIN and IN
            videoOpen( &lpcs->hVideoDisplay, wDeviceIndex, VIDEO_EXTERNALOUT );
            if( (!dwError) && lpcs->hVideoCapture && lpcs->hVideoIn ) {

                lpcs->fHardwareConnected = TRUE;
                capInternalGetDriverDesc (wDeviceIndex,
                        ach1, sizeof (ach1),
                        ach2, sizeof (ach2));
                lstrcat (ach1, ", ");
                lstrcat (ach1, ach2);

                statusUpdateStatus (lpcs, IDS_CAP_INFO, (LPSTR) ach1);

                // Make a string of the current task and capture driver
                ach2[0] = '\0';
                if (hInstT = GetWindowWord (GetParent (lpcs->hwnd), GWW_HINSTANCE))
                    GetModuleFileName (hInstT, ach2, sizeof (ach2));
                lstrcat (ach2, " -AVICAP- ");
                lstrcat (ach2, ach1);

                // Set software chunk with name of capture device
                if (*ach2) {
                    cic.lpData = ach2;
                    cic.cbData = lstrlen(ach2) + 1;
                    SetInfoChunk (lpcs, &cic);
                }
            }
        }
    }
    if (dwError)
        errorDriverID (lpcs, dwError);

    if(!lpcs->fHardwareConnected) {
       CapWinDisconnectHardware(lpcs);
    }
    else {
        if (lpcs->hVideoDisplay && videoGetChannelCaps (lpcs->hVideoDisplay,
                &VideoCapsExternalOut,
                sizeof (CHANNEL_CAPS)) == DV_ERR_OK) {
            lpcs->sCapDrvCaps.fHasOverlay = (BOOL)(VideoCapsExternalOut.dwFlags &
                (DWORD)VCAPS_OVERLAY);
        }
        else
             lpcs->sCapDrvCaps.fHasOverlay = FALSE;
        // if the hardware doesn't support it, make sure we don't enable
        if (!lpcs->sCapDrvCaps.fHasOverlay)
            lpcs->fOverlayWindow = FALSE;

       // Start the external in channel streaming continuously
       videoStreamInit (lpcs->hVideoCapture, 0L, 0L, 0L, 0L);
    } // end if hardware is available

#if 0
    // if we don't have a powerful machine, disable capture
    if (GetWinFlags() & (DWORD) WF_CPU286)
       CapWinDisconnectHardware(lpcs);
#endif

    if (!lpcs->fHardwareConnected){
        lpcs->fLiveWindow = FALSE;
        lpcs->fOverlayWindow = FALSE;
    }

    if (lpcs->hVideoIn)
        lpcs->sCapDrvCaps.fHasDlgVideoFormat = !videoDialog (lpcs-> hVideoIn,
                        lpcs-> hwnd, VIDEO_DLG_QUERY);

    if (lpcs->hVideoCapture)
         lpcs->sCapDrvCaps.fHasDlgVideoSource = !videoDialog (lpcs-> hVideoCapture,
                        lpcs-> hwnd, VIDEO_DLG_QUERY);

    if (lpcs->hVideoDisplay)
         lpcs->sCapDrvCaps.fHasDlgVideoDisplay = !videoDialog (lpcs-> hVideoDisplay,
                        lpcs-> hwnd, VIDEO_DLG_QUERY);

    lpcs->sCapDrvCaps.hVideoIn          = lpcs->hVideoIn;
    lpcs->sCapDrvCaps.hVideoOut         = NULL;
    lpcs->sCapDrvCaps.hVideoExtIn       = lpcs->hVideoCapture;
    lpcs->sCapDrvCaps.hVideoExtOut      = lpcs->hVideoDisplay;

    return lpcs->fHardwareConnected;
}



//
// Creates a child window of the capture class
// Normally:
//   Set lpszWindowName to NULL
//   Set dwStyle to WS_CHILD | WS_VISIBLE
//   Set hmenu to a unique child id

HWND VFWAPI capCreateCaptureWindow (
        LPCSTR lpszWindowName,
        DWORD dwStyle,
        int x, int y, int nWidth, int nHeight,
        HWND hwndParent, int nID)
{
    DWORD   fdwFlags;

#ifndef WS_EX_LEFTSCROLLBAR
#define WS_EX_LEFTSCROLLBAR 0
#define WS_EX_RIGHT         0
#define WS_EX_RTLREADING    0
#endif

    RegisterCaptureClass(ghInst);
    fdwFlags = gfIsRTL ? WS_EX_LEFTSCROLLBAR | WS_EX_RIGHT | WS_EX_RTLREADING : 0;
    return CreateWindowEx(fdwFlags,
	        szCaptureWindowClass,
                lpszWindowName,
                dwStyle,
                x, y, nWidth, nHeight,
                hwndParent, (HMENU) nID,
	        ghInst,
                NULL);
}


int CALLBACK LibMain(HINSTANCE hinst, WORD wDataSeg, WORD cbHeap,
    LPSTR lpszCmdLine )
{
    char   ach[2];

    ghInst = hinst;
    LoadString(ghInst, IDS_CAP_RTL, ach, sizeof(ach));
    gfIsRTL = ach[0] == '1';
    return TRUE;
}

int FAR PASCAL WEP(int i)
{
    return 1;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avicap.16\capmisc.h ===
/****************************************************************************
 *
 *   capmisc.h
 * 
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992, 1993 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and 
 *    distribute the Sample Files (and/or any modified version) in 
 *    any way you find useful, provided that you agree that 
 *    Microsoft has no warranty obligations or liability for any 
 *    Sample Application Files which are modified. 
 *
 ***************************************************************************/

void statusUpdateFromID (LPCAPSTREAM lpcs, DWORD dwError);
void statusUpdateStatus (LPCAPSTREAM lpcs, LPSTR lpc);
void ErrMsgID (LPCAPSTREAM lpcs, DWORD dwID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avicap.16\cappal.h ===
/****************************************************************************
 *
 *   cappal.h
 *
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992, 1993 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and 
 *    distribute the Sample Files (and/or any modified version) in 
 *    any way you find useful, provided that you agree that 
 *    Microsoft has no warranty obligations or liability for any 
 *    Sample Application Files which are modified. 
 *
 ***************************************************************************/

// Structure used when capturing a palette
typedef struct tagCAPPAL {
    WORD                wNumFrames;
    WORD                wNumColors;
    LPBYTE              lpBits;
    LPBYTE              lp16to8;
    VIDEOHDR            vHdr;
    BITMAPINFOHEADER    bi16;
    LPHISTOGRAM         lpHistogram;
    LPBITMAPINFO        lpbiSave;
} CAPPAL, FAR * LPCAPPAL;

BOOL PalInit (LPCAPSTREAM lpcs);
void PalFini (LPCAPSTREAM lpcs);
void PalDeleteCurrentPalette (LPCAPSTREAM lpcs);
BOOL PalGetPaletteFromDriver (LPCAPSTREAM lpcs);
DWORD PalSendPaletteToDriver (LPCAPSTREAM lpcs, HPALETTE hpal, LPBYTE lpXlateTable);
HPALETTE CopyPalette (HPALETTE hpal);
DWORD CapturePaletteInit (LPCAPSTREAM lpcs, LPCAPPAL lpcp);
DWORD CapturePaletteFini (LPCAPSTREAM lpcs, LPCAPPAL lpcp);
DWORD CapturePaletteFrames (LPCAPSTREAM lpcs, LPCAPPAL lpCapPal, int nCount);
BOOL CapturePaletteAuto (LPCAPSTREAM lpcs, int nCount, int nColors);
BOOL CapturePaletteManual (LPCAPSTREAM lpcs, BOOL fGrab, int nColors);
void CapturePaletteDialog (LPCAPSTREAM lpcs);
LONG FAR PASCAL _export cappalDlgProc(HWND hwnd, unsigned msg, WORD wParam, LONG lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avicap.16\cappal.c ===
/****************************************************************************
 *
 *   cappal.c
 * 
 *   Palette processing module.
 *
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992, 1993 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and 
 *    distribute the Sample Files (and/or any modified version) in 
 *    any way you find useful, provided that you agree that 
 *    Microsoft has no warranty obligations or liability for any 
 *    Sample Application Files which are modified. 
 *
 ***************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <msvideo.h>
#include <drawdib.h>
#include "avicap.h"
#include "avicapi.h"
#include "cappal.h"
#include "capdib.h"
#include "dibmap.h"

// 
// Allocate and initialize palette resources at Window create time
//
BOOL PalInit (LPCAPSTREAM lpcs)
{
    return (PalGetPaletteFromDriver (lpcs));
}

//
// Release palette resources at Window destroy time
// 
void PalFini (LPCAPSTREAM lpcs)
{
    PalDeleteCurrentPalette (lpcs);
}

//
// Delete our palette if it isn't the system default palette
//
void PalDeleteCurrentPalette (LPCAPSTREAM lpcs)
{
    if (lpcs->hPalCurrent &&
            (lpcs->hPalCurrent != GetStockObject(DEFAULT_PALETTE)))
        DeleteObject (lpcs->hPalCurrent);
    lpcs->hPalCurrent = NULL;
}

//
// Get the current palette (from the driver)
// Returns: TRUE if the driver can supply a palette
//

BOOL PalGetPaletteFromDriver (LPCAPSTREAM lpcs)
{
    FCLOGPALETTE        pal;

    PalDeleteCurrentPalette (lpcs); 
    
    pal.palVersion = 0x0300;
    pal.palNumEntries = 256;

    lpcs->sCapDrvCaps.fDriverSuppliesPalettes = FALSE;  // assume the worst

    if (lpcs->fHardwareConnected) {
        if (videoConfigure (lpcs->hVideoIn,
                DVM_PALETTE,
                VIDEO_CONFIGURE_GET | VIDEO_CONFIGURE_CURRENT, NULL, 
                (LPVOID)&pal, sizeof(pal),
                NULL, NULL ) == DV_ERR_OK) {
            if (lpcs->hPalCurrent = CreatePalette ((LPLOGPALETTE) &pal))
                lpcs->sCapDrvCaps.fDriverSuppliesPalettes = TRUE;
        }
    }
    if (!lpcs->hPalCurrent)
        lpcs->hPalCurrent = GetStockObject (DEFAULT_PALETTE);

    DibNewPalette (lpcs, lpcs->hPalCurrent);
    
    return (lpcs->sCapDrvCaps.fDriverSuppliesPalettes);
}

// 
// Set the current palette used for capture by sending a copy to the driver
// and then copying the entries to out DIB.
// Returns DV_ERR_OK on success, or DV_ERR... on failure.
//
DWORD PalSendPaletteToDriver (LPCAPSTREAM lpcs, HPALETTE hpal, LPBYTE lpXlateTable)
{
    int                 nColors;
    FCLOGPALETTE        pal;
    HCURSOR             hOldCursor;

    // The following can take a while so repaint our parent
    UpdateWindow (GetParent (lpcs-> hwnd));
    UpdateWindow (lpcs->hwnd);

    if (!hpal)
        return FALSE;

    PalDeleteCurrentPalette (lpcs);

    lpcs->hPalCurrent = hpal;

    GetObject(hpal, sizeof(int), (LPVOID)&nColors);

    if( nColors <= 1 ) {    //!!>
        return( FALSE );
    }

    if (nColors > 256)      //???
        ;

    nColors = min(256, nColors);
    
    hOldCursor = SetCursor (lpcs-> hWaitCursor);

    statusUpdateStatus (lpcs, IDS_CAP_STAT_PALETTE_BUILD);

    pal.palVersion = 0x0300;
    pal.palNumEntries = nColors;

    GetPaletteEntries(hpal, 0, nColors, pal.palPalEntry);

    if (lpcs-> fHardwareConnected) {

        // first try to send both the xlate table and the palette
        if ((!lpXlateTable) || (videoConfigure( lpcs->hVideoIn,
                    DVM_PALETTERGB555,
                    VIDEO_CONFIGURE_SET, NULL, 
                    (LPLOGPALETTE)&pal, sizeof(pal),
                    lpXlateTable, (DWORD) 0x8000) != 0)) {
            
            // else send just the palette and make the driver build the table
            videoConfigure( lpcs->hVideoIn,
                    DVM_PALETTE,
                    VIDEO_CONFIGURE_SET, NULL, 
                    (LPLOGPALETTE)&pal, sizeof(pal),
                    NULL, NULL );
        }
    }
    
    // Supermac wants us to get the palette again, they might have
    // mucked with it!
    PalGetPaletteFromDriver (lpcs);     

    // Since the palette has changed, delete any existing compression
    // output format;  this forces a new output format to be selected
    if (lpcs->CompVars.lpbiOut) {
        GlobalFreePtr (lpcs->CompVars.lpbiOut);
        lpcs->CompVars.lpbiOut = NULL;
    }
    if (lpcs->CompVars.hic) {
        if (ICSeqCompressFrameStart(&lpcs->CompVars, lpcs->lpBitsInfo) == NULL) {
            lpcs-> dwReturn = IDS_CAP_COMPRESSOR_ERROR;
            errorUpdateError (lpcs, IDS_CAP_COMPRESSOR_ERROR);
        }
    }

    InvalidateRect (lpcs->hwnd, NULL, TRUE);
    UpdateWindow (lpcs->hwnd);

    SetCursor (hOldCursor);
    statusUpdateStatus (lpcs, NULL);
    
    return (TRUE);
}

//
// CopyPalette, makes a copy of a GDI logical palette
// Returns: a handle to the newly created palette, or NULL if error
//

HPALETTE CopyPalette (HPALETTE hpal)
{
    LPLOGPALETTE        lppal;
    int                 nNumEntries;

    if (!hpal)
        return NULL;

    GetObject (hpal,sizeof(int),(LPVOID)&nNumEntries);

    if (nNumEntries == 0)
        return NULL;

    lppal = (LPLOGPALETTE) GlobalAllocPtr (GHND,
                sizeof(LOGPALETTE) + nNumEntries * sizeof(PALETTEENTRY));

    if (!lppal)
        return NULL;

    lppal->palVersion    = 0x300;
    lppal->palNumEntries = nNumEntries;

    GetPaletteEntries(hpal,0,nNumEntries,lppal->palPalEntry);

    hpal = CreatePalette(lppal);

    GlobalFreePtr (lppal);

    return hpal;
}


//
// Allocate resources needed for palette capture
// Returns DV_ERR_OK on success, or DV_ERR... on failure.
// Note: if Init fails, you MUST call the Fini function to
// release resources.
//
DWORD CapturePaletteInit (LPCAPSTREAM lpcs, LPCAPPAL lpcp)
{
    DWORD dwError = DV_ERR_OK;
 
    lpcp->lpBits = NULL;
    lpcp->lp16to8 = NULL;
    lpcp->lpHistogram = NULL;
    lpcp->lpbiSave = NULL;
    lpcp->wNumFrames = 0;

    // Init an RGB16 header
    lpcp->bi16.biSize         = sizeof(BITMAPINFOHEADER);
    lpcp->bi16.biWidth        = lpcs->dxBits;
    lpcp->bi16.biHeight       = lpcs->dyBits;
    lpcp->bi16.biPlanes       = 1;
    lpcp->bi16.biBitCount     = 16;
    lpcp->bi16.biCompression  = BI_RGB;
    lpcp->bi16.biSizeImage    = DIBWIDTHBYTES(lpcp->bi16) * lpcp->bi16.biHeight;
    lpcp->bi16.biXPelsPerMeter= 0;
    lpcp->bi16.biYPelsPerMeter= 0;
    lpcp->bi16.biClrUsed      = 0;
    lpcp->bi16.biClrImportant = 0;

    // Allocate memory for the histogram, DIB, and XLate table
    lpcp->lpBits  = GlobalAllocPtr (GHND, lpcp->bi16.biSizeImage);
    lpcp->lp16to8 = GlobalAllocPtr (GHND, 0x8000l);
    lpcp->lpHistogram = InitHistogram(NULL);

    if (!lpcp->lpBits || !lpcp->lp16to8 || !lpcp->lpHistogram) {
        dwError = DV_ERR_NOMEM;
        goto PalInitError;
    }

    // Init the video header
    lpcp->vHdr.lpData = lpcp->lpBits;
    lpcp->vHdr.dwBufferLength = lpcp->bi16.biSizeImage;
    lpcp->vHdr.dwUser = 0;
    lpcp->vHdr.dwFlags = 0;

    // Save the current format
    lpcp->lpbiSave = DibGetCurrentFormat (lpcs);
        
    // Make sure we can set the format to 16 bit RGB
    if(dwError = videoConfigure( lpcs->hVideoIn, DVM_FORMAT,
            VIDEO_CONFIGURE_SET, NULL, 
            (LPBITMAPINFOHEADER)&lpcp->bi16, sizeof(BITMAPINFOHEADER),
            NULL, NULL ) ) {
        goto PalInitError;
    }
    
    // Put everything back the way it was
    if (dwError = videoConfigure( lpcs->hVideoIn, DVM_FORMAT,
            VIDEO_CONFIGURE_SET, NULL, 
            (LPBITMAPINFOHEADER)lpcp->lpbiSave, lpcp->lpbiSave->bmiHeader.biSize,
            NULL, NULL )) {
        goto PalInitError;
    }

PalInitError:
    return dwError;
}

//
// Free resources used for palette capture
//
DWORD CapturePaletteFini (LPCAPSTREAM lpcs, LPCAPPAL lpcp)
{
    if (lpcp->lpBits)
        GlobalFreePtr (lpcp->lpBits);
    if (lpcp->lp16to8)
        GlobalFreePtr (lpcp->lp16to8);
    if (lpcp->lpHistogram)
        FreeHistogram(lpcp->lpHistogram);
    if (lpcp->lpbiSave)
        GlobalFreePtr (lpcp->lpbiSave);
    return DV_ERR_OK;
}

//
//  CapturePaletteFrames() The workhorse of capture palette.
//
DWORD CapturePaletteFrames (LPCAPSTREAM lpcs, LPCAPPAL lpcp, int nCount)
{
    int j;
    DWORD dwError;

    // switch to RGB16 format
    if (dwError = videoConfigure( lpcs->hVideoIn,
                DVM_FORMAT,
                VIDEO_CONFIGURE_SET, NULL, 
                (LPBITMAPINFOHEADER)&lpcp->bi16, sizeof(BITMAPINFOHEADER),
                NULL, NULL ))
        goto CaptureFramesError;

    for (j = 0; j < nCount; j++){
        // Get a frame
        dwError = videoFrame(lpcs->hVideoIn, &lpcp->vHdr);

        // Let the user see it
        InvalidateRect (lpcs->hwnd, NULL, TRUE);
        UpdateWindow (lpcs->hwnd);

        // Histogram it
        DibHistogram(&lpcp->bi16, lpcp->lpBits, 0, 0, -1, -1, lpcp->lpHistogram);
        lpcp->wNumFrames++;
    }

    dwError = videoConfigure( lpcs->hVideoIn,
                DVM_FORMAT,
                VIDEO_CONFIGURE_SET, NULL, 
                (LPBITMAPINFOHEADER)lpcp->lpbiSave,
                lpcp->lpbiSave->bmiHeader.biSize,
                NULL, NULL );

//    videoFrame( lpcs->hVideoIn, &lpcs->VidHdr );

CaptureFramesError:
    return dwError;
}

//
//  CapturePaletteAuto() capture a palette from the video source
//  without user intervention.
//  Returns TRUE on success, FALSE on error
//
BOOL CapturePaletteAuto (LPCAPSTREAM lpcs, int nCount, int nColors)
{
    HPALETTE    hpal;
    HCURSOR     hOldCursor;
    DWORD       dwError = DV_ERR_OK;
    CAPPAL      cappal;
    LPCAPPAL    lpcp;

    lpcp = &cappal;
    
    if (nColors == 0)
        nColors = 256;
    
    lpcp->wNumColors = min (nColors, 256);

    if (nCount <= 0)            // Bug 175
        nCount = 1;
    
    if (dwError = CapturePaletteInit (lpcs, lpcp))
        goto PalAutoExit;

    hOldCursor = SetCursor(lpcs->hWaitCursor);

    CapturePaletteFrames (lpcs, lpcp, nCount);

    /* we grabbed a frame, time to compute a palette */
    statusUpdateStatus(lpcs, IDS_CAP_STAT_OPTPAL_BUILD);

    // The HPALETTE returned in the following becomes
    // our "global" palette, hence is not deleted here.
    hpal = HistogramPalette(lpcp->lpHistogram, lpcp->lp16to8, lpcp->wNumColors);

    // Send driver both the pal and xlate table
    PalSendPaletteToDriver(lpcs, hpal, (LPBYTE)lpcp->lp16to8 );     

    videoFrame( lpcs->hVideoIn, &lpcs->VidHdr );  // Update the display with a new image
    
    SetCursor(hOldCursor);

    InvalidateRect(lpcs->hwnd, NULL, TRUE);
    UpdateWindow(lpcs->hwnd);
    lpcs->fUsingDefaultPalette = FALSE;

PalAutoExit:
    CapturePaletteFini (lpcs, lpcp);
    statusUpdateStatus(lpcs, NULL);

   // If an error happened, display it
   if (dwError) 
        errorDriverID (lpcs, dwError);

    return (dwError == DV_ERR_OK);
}

//
//  CapturePaletteManual() capture a palette from the video source
//  with user intervention.
//  fGrab is TRUE on all but the last frame captured
//  Returns TRUE on success, FALSE on error
//
BOOL CapturePaletteManual (LPCAPSTREAM lpcs, BOOL fGrab, int nColors)
{
    HPALETTE    hpal;
    HCURSOR     hOldCursor;
    LPCAPPAL    lpcp;
    DWORD       dwError = DV_ERR_OK;

    hOldCursor = SetCursor(lpcs->hWaitCursor);

    // We're initializing for the first time, so alloc everything
    if (lpcs->lpCapPal == NULL) {

        if (lpcp = (LPCAPPAL) GlobalAllocPtr (GHND, sizeof(CAPPAL))) {
            lpcs->lpCapPal = lpcp;

            if (nColors == 0)
                nColors = 256;
            lpcp->wNumColors = min (nColors, 256);
            dwError = CapturePaletteInit (lpcs, lpcp);
        }
        else 
            dwError = IDS_CAP_OUTOFMEM;
    }
    lpcp = lpcs->lpCapPal;

    if (dwError != DV_ERR_OK) 
        goto PalManualExit;

    // Add a frame to the histogram 
    // Handle the case of telling us to stop before we ever started
    if (fGrab || !fGrab && (lpcp->wNumFrames == 0)) {
        CapturePaletteFrames (lpcs, lpcp, 1);
        lpcs->fUsingDefaultPalette = FALSE;
    }    
    // All done, send the new palette to the driver
    if (!fGrab) {
        statusUpdateStatus(lpcs, IDS_CAP_STAT_OPTPAL_BUILD);

        // The HPALETTE returned in the following becomes
        // our "global" palette, hence is not deleted here.
        hpal = HistogramPalette(lpcp->lpHistogram,
                        lpcp->lp16to8, lpcp->wNumColors);

        // Send driver both the pal and xlate table
        PalSendPaletteToDriver(lpcs, hpal, (LPBYTE)lpcp->lp16to8 );
    }

    videoFrame( lpcs->hVideoIn, &lpcs->VidHdr );  // Update the display with a new image
    InvalidateRect(lpcs->hwnd, NULL, TRUE);
    UpdateWindow(lpcs->hwnd);

PalManualExit:
    if (!fGrab || (dwError != DV_ERR_OK)) {
        if (lpcp != NULL) {
            CapturePaletteFini (lpcs, lpcp);
            GlobalFreePtr (lpcp);
            lpcs->lpCapPal = NULL;
        }
    }

    SetCursor(hOldCursor);
    statusUpdateStatus(lpcs, NULL);

   // If an error happened, display it
   if (dwError) {
        errorUpdateError (lpcs, (WORD) dwError);
        lpcs-> dwReturn = dwError;
    }       

    return (dwError == DV_ERR_OK);
}



/*--------------------------------------------------------------+
| fileSavePalette - save the current palette in a file  	|
|								|
+--------------------------------------------------------------*/
BOOL FAR PASCAL fileSavePalette(LPCAPSTREAM lpcs, LPSTR lpszFileName)
{
    HPALETTE            hpal;
    HMMIO               hmmio;
    WORD	        w;
    HCURSOR             hOldCursor;
    MMCKINFO            ckRiff;
    MMCKINFO            ck;
    int                 nColors;
    FCLOGPALETTE        pal;
    BOOL                fOK = FALSE;

    if ((hpal = lpcs->hPalCurrent) == NULL)
        return FALSE;

    hmmio = mmioOpen(lpszFileName, NULL, MMIO_WRITE);
    if( !hmmio ) {
	/* try and create */    
        hmmio = mmioOpen(lpszFileName, NULL, MMIO_CREATE | MMIO_WRITE);
	if( !hmmio ) {
	    /* find out if the file was read only or we are just */
	    /* totally hosed up here.				 */
	    hmmio = mmioOpen(lpszFileName, NULL, MMIO_READ);
	    if (hmmio){
		/* file was read only, error on it */
                errorUpdateError (lpcs, IDS_CAP_READONLYFILE, (LPSTR)lpszFileName);
		mmioClose(hmmio, 0);
		return FALSE;
	    } else {
		/* even weirder error has occured here, give CANTOPEN */
                errorUpdateError (lpcs, IDS_CAP_CANTOPEN, (LPSTR) lpszFileName);
		return FALSE;
	    }
	}
    }

    hOldCursor = SetCursor( lpcs-> hWaitCursor );

    /* Seek to beginning of file, so we can write the header. */
    mmioSeek(hmmio, 0, SEEK_SET);

    /* Create RIFF chunk */
    ckRiff.fccType = mmioFOURCC('P','A','L',' ');
    if(mmioCreateChunk (hmmio,&ckRiff,MMIO_CREATERIFF)) {
         goto FileError;
    }

    /* Create Palette chunk */
    ck.cksize = 0;
    ck.ckid = mmioFOURCC('d','a','t','a');
    if(mmioCreateChunk(hmmio,&ck,0)) {
         goto FileError;
    }

    // Get the palette data here
    GetObject(hpal, sizeof(int), (LPVOID)&nColors);

    pal.palVersion = 0x0300;
    pal.palNumEntries = nColors;

    GetPaletteEntries(hpal, 0, nColors, pal.palPalEntry);

    // Calc the size of the logpalette
    // which is the sizeof palVersion + sizeof palNumEntries + colors
    w = sizeof (WORD) + sizeof (WORD) + nColors * sizeof (PALETTEENTRY);

    // Write out the palette
    if(mmioWrite(hmmio, (LPSTR)&pal, (DWORD) w) != (LONG) w) {
        goto FileError;
    }

    if(mmioAscend(hmmio, &ck, 0)) {
        goto FileError;
    }

    if(mmioAscend(hmmio, &ckRiff, 0)) {
        goto FileError;
    }

    fOK = TRUE;
    
FileError:
    mmioClose( hmmio, 0 );

    SetCursor( hOldCursor );

    if (!fOK)
        errorUpdateError (lpcs, IDS_CAP_ERRORPALSAVE, (LPSTR) lpszFileName);

    return fOK;
}
    

/*--------------------------------------------------------------+
| fileOpenPalette - use a new palette from the specified file   |
|								|
+--------------------------------------------------------------*/
BOOL FAR PASCAL fileOpenPalette(LPCAPSTREAM lpcs, LPSTR lpszFileName)
{
    HPALETTE            hpal;
    HMMIO               hmmio;
    WORD	        w;
    HCURSOR             hOldCursor;
    MMCKINFO            ckRiff;
    MMCKINFO            ck;
    FCLOGPALETTE        pal;
    BOOL                fOK = FALSE;

    if ((hpal = lpcs->hPalCurrent) == NULL)
        return FALSE;

    hmmio = mmioOpen(lpszFileName, NULL, MMIO_READ);
    if( !hmmio ) {
        errorUpdateError (lpcs, IDS_CAP_ERRORPALOPEN, (LPSTR) lpszFileName);
        return FALSE;
    }

    hOldCursor = SetCursor( lpcs-> hWaitCursor );

    /* Seek to beginning of file, so we can read the header. */
    mmioSeek(hmmio, 0, SEEK_SET);

    /* Find the RIFF chunk */
    ckRiff.fccType = mmioFOURCC('P','A','L',' ');
    if(mmioDescend (hmmio, &ckRiff, NULL, MMIO_FINDRIFF)) {
         goto PalOpenError;
    }

    /* Find the data chunk */
    ck.cksize = 0;
    ck.ckid = mmioFOURCC('d','a','t','a');
    if(mmioDescend (hmmio, &ck, &ckRiff, MMIO_FINDCHUNK)) {
         goto PalOpenError;
    }

    // First read just the Version and number of entries
    // which is the sizeof palVersion + sizeof palNumEntries
    w = sizeof (WORD) + sizeof (WORD);
    if(mmioRead(hmmio, (LPSTR)&pal, (DWORD) w) != (LONG) w) {
        goto PalOpenError;
    }

    // Do a bit of checking
    if ((pal.palVersion != 0x0300) || (pal.palNumEntries > 256))
        goto PalOpenError;
        
    // Now get the actual palette data
    // which is the sizeof palVersion + sizeof palNumEntries
    w = pal.palNumEntries * sizeof (PALETTEENTRY);
    if(mmioRead(hmmio, (LPSTR)&pal.palPalEntry, (DWORD) w) != (LONG) w) {
        goto PalOpenError;
    }

    if (hpal = CreatePalette ((LPLOGPALETTE) &pal)) {
        PalSendPaletteToDriver (lpcs, hpal, NULL /*lpXlateTable */);
        fOK = TRUE;
    }    
    
    videoFrame( lpcs->hVideoIn, &lpcs->VidHdr );  // grab a new frame

PalOpenError:
    mmioClose( hmmio, 0 );

    SetCursor( hOldCursor );
    InvalidateRect(lpcs->hwnd, NULL, TRUE);
    UpdateWindow(lpcs->hwnd);		// update the display with new frame

    if (!fOK)
        errorUpdateError (lpcs, IDS_CAP_ERRORPALOPEN, (LPSTR) lpszFileName);
    else
        lpcs->fUsingDefaultPalette = FALSE;

    return fOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avicap.16\capwin.c ===
/****************************************************************************
 *
 *   capwin.c
 *
 *   Main window proceedure.
 *
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992, 1993 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and
 *    distribute the Sample Files (and/or any modified version) in
 *    any way you find useful, provided that you agree that
 *    Microsoft has no warranty obligations or liability for any
 *    Sample Application Files which are modified.
 *
 ***************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <msvideo.h>
#include <drawdib.h>
#include <mmreg.h>
#include <memory.h>
#include "avicap.h"
#include "avicapi.h"
#include "cappal.h"
#include "capdib.h"
#include "dibmap.h"

// GetWindowLong assignments
#define GWL_CAPSTREAM   0
#define GWL_CAPVBSTATUS 4       // Used by VB Status callback
#define GWL_CAPVBERROR  8       // Used by VB Error callback
#define GWL_CAP_SPARE1  12      // Room to grow
#define GWL_CAP_SPARE2  16      // Room to grow

#define ID_PREVIEWTIMER 9

//#ifdef _DEBUG
#ifdef PLASTIQUE
    #define MB(lpsz) MessageBox(NULL, lpsz, "", MB_OK);
#else
    #define MB(lpsz)
#endif


//
// Set the overlay rectangles on capture cards which support
// overlay, and then enable/disable the key color.
//
static void SetOverlayRectangles (LPCAPSTREAM lpcs)
{
    HDC hdc;
    BOOL fVisible;
    RECT rc;

    if (!lpcs->hVideoDisplay)
        return;

    hdc = GetDC (lpcs->hwnd);
    fVisible = (GetClipBox (hdc, &rc) != NULLREGION);
    ReleaseDC (lpcs->hwnd, hdc);

    if (!fVisible)  // disable the overlay if iconic
        videoStreamFini (lpcs->hVideoDisplay);
    else {
        // Destination
        GetClientRect (lpcs->hwnd, &rc);
        ClientToScreen (lpcs->hwnd, (LPPOINT)&rc);
        ClientToScreen (lpcs->hwnd, (LPPOINT)&rc+1);
        videoMessage (lpcs->hVideoDisplay,
                        DVM_DST_RECT,
                        (DWORD) (LPVOID) &rc, VIDEO_CONFIGURE_SET);

        // Overlay channel Source rectangle
        SetRect (&rc, lpcs->ptScroll.x, lpcs->ptScroll.y,
                lpcs->ptScroll.x + rc.right - rc.left,
                lpcs->ptScroll.y + rc.bottom - rc.top);
        videoMessage (lpcs->hVideoDisplay,
                        DVM_SRC_RECT,
                        (DWORD) (LPVOID) &rc, VIDEO_CONFIGURE_SET);

        videoStreamInit (lpcs->hVideoDisplay, 0L, 0L, 0L, 0L);
    }
}

// WM_POSITIONCHANGED and WM_POSITIONCHANGING don't do enough to
// handle clipping of the overlay window on the Intel board,
// which keys on black.  Do this routine on WM_PAINT and
// WM_ENTERIDLE messages.

void CheckWindowMove(LPCAPSTREAM lpcs, HDC hdcWnd, BOOL fForce)
{
    UINT    wRgn;
    RECT    rc;
    DWORD   dwOrg;
    HDC     hdc;
    BOOL    f;

    if (!lpcs->hwnd || !lpcs->hVideoDisplay || !lpcs->fOverlayWindow)
        return;

    //
    //  when the screen is locked for update by a window move operation
    //  we dont want to turn off the video.
    //
    //  we can tell if the screen is locked by checking a DC to the screen.
    //
    hdc = GetDC(NULL);
    f = GetClipBox(hdc, &rc) == NULLREGION;
    ReleaseDC(NULL, hdc);

    if (f) {
        lpcs->uiRegion = (UINT) -1;
        return;
    }

    if (fForce)
        lpcs->uiRegion = (UINT) -1;

    hdc = GetDC (lpcs->hwnd);
    wRgn = GetClipBox(hdc, &rc);
    dwOrg = GetDCOrg(hdc);
    ReleaseDC(lpcs->hwnd, hdc);

    if (wRgn == lpcs->uiRegion &&
                dwOrg == lpcs->dwRegionOrigin &&
                EqualRect(&rc, &lpcs->rcRegionRect))
        return;

    lpcs->uiRegion       = wRgn;
    lpcs->dwRegionOrigin = dwOrg;
    lpcs->rcRegionRect   = rc;

    SetOverlayRectangles (lpcs);

    if (hdcWnd)
        videoUpdate (lpcs->hVideoDisplay, lpcs->hwnd, hdcWnd);
    else
        InvalidateRect (lpcs->hwnd, NULL, TRUE);
}

//
// Create our little world
//
LPCAPSTREAM CapWinCreate (HWND hwnd)
{
    LPCAPSTREAM lpcs;
    WAVEFORMATEX wfex;

    if (!(lpcs = (LPCAPSTREAM) GlobalAllocPtr (GHND, sizeof (CAPSTREAM))))
        return NULL;

    SetWindowLong (hwnd, GWL_CAPSTREAM, (LONG)lpcs);

    lpcs-> dwSize = sizeof (CAPSTREAM);
    lpcs-> uiVersion = CAPSTREAM_VERSION;
    lpcs-> hwnd = hwnd;
    lpcs-> hInst = ghInst;
    lpcs-> hWaitCursor = LoadCursor(NULL, IDC_WAIT);
    lpcs-> hdd = DrawDibOpen();
    lpcs-> fAudioHardware = !!waveOutGetNumDevs();    // force 1 or 0


    // Video defaults
    lpcs-> sCapParms.dwRequestMicroSecPerFrame = 66667;   // 15fps
    lpcs-> sCapParms.vKeyAbort          = VK_ESCAPE;
    lpcs-> sCapParms.fAbortLeftMouse    = TRUE;
    lpcs-> sCapParms.fAbortRightMouse   = TRUE;
    lpcs-> sCapParms.wNumVideoRequested = MIN_VIDEO_BUFFERS;
    lpcs-> fCapturingToDisk             = TRUE;
    lpcs-> sCapParms.wPercentDropForError = 10;   // error msg if dropped > 10%
    lpcs-> sCapParms.wChunkGranularity  = 2048;

    // Audio defaults to 11K, 8bit, Mono
    lpcs-> sCapParms.fCaptureAudio = lpcs-> fAudioHardware;
    lpcs-> sCapParms.wNumAudioRequested = DEF_WAVE_BUFFERS;

    wfex.wFormatTag = WAVE_FORMAT_PCM;
    wfex.nChannels = 1;
    wfex.nSamplesPerSec = 11025;
    wfex.nAvgBytesPerSec = 11025;
    wfex.nBlockAlign = 1;
    wfex.wBitsPerSample = 8;
    wfex.cbSize = 0;
    SendMessage (hwnd, WM_CAP_SET_AUDIOFORMAT, 0, (LONG)(LPVOID)&wfex);

    // Palette defaults
    lpcs-> nPaletteColors = 256;

    // Capture defaults
    lpcs-> sCapParms.fUsingDOSMemory = FALSE;
    lstrcpy (lpcs-> achFile, "C:\\CAPTURE.AVI");    // Default capture file
    lpcs->fCapFileExists = fileCapFileIsAVI (lpcs->achFile);

    // Allocate index to 32K frames plus proportionate number of audio chunks
    lpcs->sCapParms.dwIndexSize = (32768ul + (32768ul / 15));

    lpcs->sCapParms.fDisableWriteCache = TRUE;

    // Init the COMPVARS structure
    lpcs->CompVars.cbSize = sizeof (COMPVARS);
    lpcs->CompVars.dwFlags = 0;

    return lpcs;
}

//
// Destroy our little world
//
void CapWinDestroy (LPCAPSTREAM lpcs)
{
    // Uh, oh.  Somebodys trying to kill us while capturing
    if (lpcs->fCapturingNow && lpcs->fFrameCapturingNow) {
        // Single frame capture in progress
        SingleFrameCaptureClose (lpcs);
    }
    else if (lpcs->fCapturingNow) {
        // Streaming capture in progress, OR
        // MCI step capture in progress

        lpcs->fAbortCapture = TRUE;
        while (lpcs->fCapturingNow)
            Yield ();
    }

    if (lpcs->idTimer)
        KillTimer(lpcs->hwnd, lpcs->idTimer);

    PalFini (lpcs);
    DibFini (lpcs);

    CapWinDisconnectHardware (lpcs);

    DrawDibClose (lpcs->hdd);

    if (lpcs->lpWaveFormat)
        GlobalFreePtr (lpcs-> lpWaveFormat);

    if (lpcs->CompVars.hic)
        ICCompressorFree(&lpcs->CompVars);

    if (lpcs->lpInfoChunks)
        GlobalFreePtr(lpcs->lpInfoChunks);

    GlobalFreePtr (lpcs);       // Free the instance memory
}

WORD GetSizeOfWaveFormat (LPWAVEFORMATEX lpwf)
{
    WORD wSize;

    if (lpwf == NULL)
        return sizeof (PCMWAVEFORMAT);

    if (lpwf->wFormatTag == WAVE_FORMAT_PCM)
        wSize = sizeof (PCMWAVEFORMAT);
    else
        wSize = sizeof (WAVEFORMATEX) + lpwf -> cbSize;

    return wSize;
}

// Returns TRUE if we got a new frame, else FALSE
// if fForce, then always get a new frame
BOOL GetAFrameThenCallback (LPCAPSTREAM lpcs, BOOL fForce)
{
    BOOL fOK = FALSE;
    static BOOL fRecursion = FALSE;
    BOOL fVisible;
    RECT rc;
    HDC  hdc;

    if (fRecursion)
        return FALSE;

    if (!lpcs->sCapDrvCaps.fCaptureInitialized)
        return fOK;

    fRecursion = TRUE;

    // Update the preview window if we got a timer and not saving to disk
    if (lpcs->fOverlayWindow)
        CheckWindowMove(lpcs, NULL, FALSE);

    if ((!lpcs->fCapturingNow) || lpcs->fStepCapturingNow || lpcs->fFrameCapturingNow) {
        hdc = GetDC (lpcs->hwnd);
        fVisible = (GetClipBox (hdc, &rc) != NULLREGION);
        ReleaseDC (lpcs->hwnd, hdc);

        if (fForce || (fVisible && (lpcs->fLiveWindow || lpcs->CallbackOnVideoFrame))) {
            videoFrame (lpcs->hVideoIn, &lpcs->VidHdr );
            fOK = TRUE;

            if (lpcs->CallbackOnVideoFrame)
                (*(lpcs->CallbackOnVideoFrame)) (lpcs->hwnd, &lpcs->VidHdr);

            if (fForce || lpcs->fLiveWindow) {
                InvalidateRect (lpcs->hwnd, NULL, TRUE);
                UpdateWindow (lpcs->hwnd);
            }
        } // if visible
    } // if we're not streaming

    fRecursion = FALSE;

    return fOK;
}

// Clear the Status and Error strings via callback
void FAR PASCAL ClearStatusAndError (LPCAPSTREAM lpcs)
{
    statusUpdateStatus(lpcs, NULL);     // Clear status
    errorUpdateError(lpcs, NULL);       // Clear error

}

// Process class specific commands >= WM_USER

DWORD PASCAL ProcessCommandMessages (LPCAPSTREAM lpcs, unsigned msg, WORD wParam, LPARAM lParam)
{
    DWORD dwReturn = 0L;
    DWORD dwT;

    switch (msg) {
        // Don't clear status and error on the following innocuous msgs
        case WM_CAP_GET_CAPSTREAMPTR:
        case WM_CAP_GET_USER_DATA:
        case WM_CAP_DRIVER_GET_NAME:
        case WM_CAP_DRIVER_GET_VERSION:
        case WM_CAP_DRIVER_GET_CAPS:
        case WM_CAP_GET_AUDIOFORMAT:
        case WM_CAP_GET_VIDEOFORMAT:
        case WM_CAP_GET_STATUS:
        case WM_CAP_SET_SEQUENCE_SETUP:
        case WM_CAP_GET_SEQUENCE_SETUP:
        case WM_CAP_GET_MCI_DEVICE:
            break;

        default:
            ClearStatusAndError (lpcs);
            break;
    }

    switch (msg) {
    case WM_CAP_GET_CAPSTREAMPTR:
        // return a pointer to the CAPSTREAM
        return (DWORD) (LPVOID) lpcs;

    case WM_CAP_GET_USER_DATA:
	return lpcs->lUser;

    case WM_CAP_DRIVER_GET_NAME:
        // Return the name of the capture driver in use
        // wParam is the length of the buffer pointed to by lParam
        if (!lpcs->fHardwareConnected)
            return FALSE;
        return (capInternalGetDriverDesc (lpcs->sCapDrvCaps.wDeviceIndex,
                (LPSTR) lParam, (int) wParam, NULL, 0));

    case WM_CAP_DRIVER_GET_VERSION:
        // Return the version of the capture driver in use as text
        // wParam is the length of the buffer pointed to by lParam
        if (!lpcs->fHardwareConnected)
            return FALSE;
        return (capInternalGetDriverDesc (lpcs->sCapDrvCaps.wDeviceIndex,
                NULL, 0, (LPSTR) lParam, (int) wParam));

    case WM_CAP_DRIVER_GET_CAPS:
        // wParam is the size of the CAPDRIVERCAPS struct
        // lParam points to a CAPDRIVERCAPS struct
        if (!lpcs->fHardwareConnected)
            return FALSE;
        if (wParam <= sizeof (CAPDRIVERCAPS) &&
                !IsBadWritePtr ((LPVOID) lParam, (UINT) wParam)) {
            dwT = min (wParam, sizeof (CAPDRIVERCAPS));
            _fmemcpy ((LPVOID) lParam, (LPVOID) &lpcs-> sCapDrvCaps, (WORD) dwT);
            dwReturn = TRUE;
        }
        break;

    case WM_CAP_FILE_GET_CAPTURE_FILE:
        // wParam is the size
        // lParam points to a buffer in which capture file name is copied
        if (lParam) {
            lstrcpyn ((LPSTR) lParam, lpcs->achFile, wParam);
            dwReturn = TRUE;
        }
        break;

    case WM_CAP_GET_AUDIOFORMAT:
        // if lParam == NULL, return the size
        // if lParam != NULL, wParam is the size, return bytes copied
        if (lpcs->lpWaveFormat == NULL)
            return FALSE;
        dwT = GetSizeOfWaveFormat ((LPWAVEFORMATEX) lpcs->lpWaveFormat);
        if (lParam == NULL)
            return (dwT);
        else {
            if (wParam < (WORD) dwT)
                return FALSE;
            else {
                hmemcpy ((LPVOID) lParam, (LPVOID) lpcs->lpWaveFormat, dwT);
                dwReturn = dwT;
            }
        }
        break;

    case WM_CAP_GET_MCI_DEVICE:
        // wParam is the size
        // lParam points to a buffer in which capture file name is copied
        if (lParam) {
            lstrcpyn ((LPSTR) lParam, lpcs->achMCIDevice, wParam);
            dwReturn = TRUE;
        }
        break;

    case WM_CAP_GET_STATUS:
        // wParam is the size of the CAPSTATUS struct pointed to by lParam
        if (!lpcs->fHardwareConnected)
            return FALSE;
        if (IsBadWritePtr ((LPVOID) lParam, (UINT) wParam))
            return FALSE;

        if (wParam >= sizeof (CAPSTATUS)) {
            LPCAPSTATUS lpcc = (LPCAPSTATUS) lParam;

            lpcc-> fLiveWindow          = lpcs-> fLiveWindow;
            lpcc-> fOverlayWindow       = lpcs-> fOverlayWindow;
            lpcc-> fScale               = lpcs-> fScale;
            lpcc-> ptScroll             = lpcs-> ptScroll;
            lpcc-> fUsingDefaultPalette = lpcs-> fUsingDefaultPalette;
            lpcc-> fCapFileExists       = lpcs-> fCapFileExists;
            lpcc-> fAudioHardware       = lpcs-> fAudioHardware;
            lpcc-> uiImageWidth         = lpcs-> dxBits;
            lpcc-> uiImageHeight        = lpcs-> dyBits;

            // The following are updated dynamically during capture
            lpcc-> dwCurrentVideoFrame          = lpcs-> dwVideoChunkCount;
            lpcc-> dwCurrentVideoFramesDropped  = lpcs-> dwFramesDropped;
            if (lpcs->lpWaveFormat != NULL) {
                lpcc-> dwCurrentWaveSamples         =
                        muldiv32 (lpcs-> dwWaveBytes,
                                  lpcs-> lpWaveFormat-> nSamplesPerSec,
                                  lpcs-> lpWaveFormat-> nAvgBytesPerSec);
            }
            lpcc-> dwCurrentTimeElapsedMS       = lpcs-> dwTimeElapsedMS;

            // Added post alpha release
            lpcc-> fCapturingNow        = lpcs-> fCapturingNow;
            lpcc-> hPalCurrent          = lpcs-> hPalCurrent;
            lpcc-> dwReturn             = lpcs-> dwReturn;
            lpcc-> wNumVideoAllocated   = lpcs-> iNumVideo;
            lpcc-> wNumAudioAllocated   = lpcs-> iNumAudio;

            dwReturn = TRUE;
        }
        break;

    case WM_CAP_GET_SEQUENCE_SETUP:
        // wParam is sizeof CAPTUREPARMS
        // lParam = LPCAPTUREPARMS
        if (wParam <= sizeof (CAPTUREPARMS) &&
                !IsBadWritePtr ((LPVOID) lParam, (UINT) wParam)) {
            dwT = min (wParam, sizeof (CAPTUREPARMS));
            _fmemcpy ((LPVOID) lParam, (LPVOID) &lpcs->sCapParms, (WORD) dwT);
            dwReturn = TRUE;
        }
        break;

    case WM_CAP_STOP:
        // Stop capturing a sequence
        if (lpcs-> fCapturingNow) {
            lpcs-> fStopCapture = TRUE;
            dwReturn = TRUE;
        }
        break;

    case WM_CAP_ABORT:
        // Stop capturing a sequence
        if (lpcs-> fCapturingNow) {
            lpcs-> fAbortCapture = TRUE;
            dwReturn = TRUE;
        }
        break;

    case WM_CAP_GET_VIDEOFORMAT:
        // if lParam == NULL, return the size
        // if lParam != NULL, wParam is the size, return bytes copied
        if (!lpcs->fHardwareConnected)
            return FALSE;
        dwT = ((LPBITMAPINFOHEADER)lpcs->lpBitsInfo)-> biSize +
	      ((LPBITMAPINFOHEADER)lpcs->lpBitsInfo)->biClrUsed * sizeof(RGBQUAD);
        if (lParam == NULL)
            return dwT;
        else {
            if (wParam < (WORD) dwT)
                return FALSE;
            else {
                hmemcpy ((LPVOID) lParam, (LPVOID) lpcs->lpBitsInfo, dwT);
                dwReturn = dwT;
            }
        }
        break;

    case WM_CAP_SINGLE_FRAME_OPEN:
        // wParam is not used
        // lParam is not used
        if (!lpcs->fHardwareConnected)
            return FALSE;
        return SingleFrameCaptureOpen (lpcs);

    case WM_CAP_SINGLE_FRAME_CLOSE:
        // wParam is not used
        // lParam is not used
        if (!lpcs->fHardwareConnected)
            return FALSE;
        return SingleFrameCaptureClose (lpcs);

    case WM_CAP_SINGLE_FRAME:
        // wParam is not used
        // lParam is not used
        if (!lpcs->fHardwareConnected)
            return FALSE;
        return SingleFrameCapture (lpcs);

    case WM_CAP_SET_CALLBACK_STATUS:
     