), and bitmap.

FONTINFO        ends                                                        ;*/ } FONTINFO;                    /*

SCALABLEFONTINFO    struc                                                   ;*/ typedef     struct  {          /*
  erType            dw      0   ; Type field for the font.                  ;*/ short int   erType;            /*
  erPoints          dw      0   ; Point size of font.                       ;*/ short int   erPoints;          /*
  erVertRes         dw      0   ; Vertical digitization.                    ;*/ short int   erVertRes;         /*
  erHorizRes        dw      0   ; Horizontal digitization.                  ;*/ short int   erHorizRes;        /*
  erAscent          dw      0   ; Baseline offset from char cell top.       ;*/ short int   erAscent;          /*
  erInternalLeading dw      0   ; Internal leading included in font         ;*/ short int   erInternalLeading; /*
  erExternalLeading dw      0   ; Prefered extra space between lines        ;*/ short int   erExternalLeading; /*
  erItalic          db      0   ; Flag specifying if italic.                ;*/ BYTE        erItalic;          /*
  erUnderline       db      0   ; Flag specifying if underlined.            ;*/ BYTE        erUnderline;       /*
  erStrikeOut       db      0   ; Flag specifying if struck out.            ;*/ BYTE        erStrikeOut;       /*
  erWeight          dw      0   ; Weight of font.                           ;*/ short int   erWeight;          /*
  erCharSet         db      0   ; Character set of font.                    ;*/ BYTE        erCharSet;         /*
  erPixWidth        dw      0   ; Width field for the font.                 ;*/ short int   erPixWidth;        /*
  erPixHeight       dw      0   ; Height field for the font.                ;*/ short int   erPixHeight;       /*
  erPitchAndFamily  db      0   ; Flag specifying pitch and family.         ;*/ BYTE        erPitchAndFamily;  /*
  erAvgWidth        dw      0   ; Average character width.                  ;*/ short int   erAvgWidth;        /*
  erMaxWidth        dw      0   ; Maximum character width.                  ;*/ short int   erMaxWidth;        /*
  erFirstChar       db      0   ; First character in the font.              ;*/ BYTE        erFirstChar;       /*
  erLastChar        db      0   ; Last character in the font.               ;*/ BYTE        erLastChar;        /*
  erDefaultChar     db      0   ; Default character for out of range.       ;*/ BYTE        erDefaultChar;     /*
  erBreakChar       db      0   ; Character to define wordbreaks.           ;*/ BYTE        erBreakChar;       /*
  erWidthBytes      dw      0   ; Number of bytes in each row.              ;*/ short int   erWidthBytes;      /*
  erDevice          dd      0   ; Offset to device name.                    ;*/ unsigned long int   erDevice;  /*
  erFace            dd      0   ; Offset to face name.                      ;*/ unsigned long int   erFace;    /*
  erBitsPointer     dd      0   ; Bits pointer.                             ;*/ unsigned long int   erBitsPointer;/*
  erBitsOffset      dd      0   ; Offset to the begining of the bitmap.     ;*/ unsigned long int   erBitsOffset;/*
  erFlags           db      0   ; flags, and word align the stuff to come   ;*/ BYTE erReservedByte;            /*
  erUnderlinePos    dw      0   ; underline position relative to cell origin    ;*/ short int   erUnderlinePos;  /*
  erUnderlineThick  dw      0   ; underline thickness                           ;*/ short int   erUnderlineThick;/*
  erStrikeoutPos    dw      0   ; Strikeout position relative to cell origin    ;*/ short int   erStrikeoutPos;  /*
  erStrikeoutThick  dw      0   ; strikeout thickness                           ;*/ short int   erStrikeoutThick;/*
SCALABLEFONTINFO    ends                                                    ;*/ } SCALABLEFONTINFO;            /*


;------------------------------------------------------------------------------
;--------------------------  4.0 font structures  -----------------------------
;------------------------------------------------------------------------------
; This font format has a simple font header. It contains a version field
; followed by a glyph format field, the total number of glyphs in the
; entire font, and the dword offset to the array of glyph offsets.
;------------------------------------------------------------------------------

;------------------------------------------------------------------------------
; The NF_LARGE flag indicates that the glyph offset table is
;  array of DWORDs instead of WORD offsets AND that the glyphs
;  have LARGExxxGLYPH headers instead of SMALLxxxGLYPH headers.
;------------------------------------------------------------------------------
NF_BYTE_PACKED  equ     0001h           ; Byte aligned row format
NF_BIT_PACKED   equ     0002h           ; Bit packed row format
NF_FROM_BMP     equ     0040h           ; Derived from bitmap font
NF_LARGE        equ     0080h           ; Large offsets and glyph headers

NewFontSeg      struct
 nfVersion      dw      0               ; Font version (0x0400)
 nfFormat       dw      0               ; Font format flags
 nfNumGlyphs    dw      0               ; Number of glyphs in font
 nfGlyphOffset  dd      0               ; Offset to glyph offset table
 nfAWTable      dd      0               ; Offset to advance width table

 nfHeight       dw      0               ; Height of font in pixels
 nfAscent       dw      0               ; Distance from baseline to top
 nfUniqueID     dd      0               ; Unique identifier for this PFont
NewFontSeg      ends


;----------------------  Byte-packed glyph structures  ------------------------
;
; This structure is the header for a glyph stored in byte-packed
; row-oriented format. The glyph bitmap is stored immediately after
; the ROWGLYPH structure.
;------------------------------------------------------------------------------
SMALLROWGLYPH   struc
 srgOrgX        db      0               ; Vector to glyph origin in bitmap
 srgOrgY        db      0               ;  from upper left corner
 srgWidth       db      0               ; Width and height of glyph bmp in
 srgHeight      db      0               ;  pixels
SMALLROWGLYPH   ends

LARGEROWGLYPH   struc
 lrgOrgX        dw      0               ; Vector to glyph origin in bitmap
 lrgOrgY        dw      0               ;  from upper left corner
 lrgWidth       dw      0               ; Width and height of glyph bmp in
 lrgHeight      dw      0               ;  pixels
LARGEROWGLYPH   ends

;----------------------  Bit-packed glyph structures  -------------------------
;
; This structure is the header for a glyph stored in bit-packed row-oriented
; format. The glyph bitmap is stored immediately after the BITGLYPH structure.
;
; Bit-packed format means that the glyph rows are packed together end-to-end.
; There is no padding out to byte boundaries at the end of a row. This
; format results in the highest performance on some accelerated cards and
; the smallest memory footprint.
;------------------------------------------------------------------------------
SMALLBITGLYPH   struc
 sbgOrgX        db      0               ; Vector to glyph origin in bitmap
 sbgOrgY        db      0               ;  from upper left corner
 sbgWidth       db      0               ; Width and height of glyph bmp in
 sbgHeight      db      0               ;  pixels
 sbgPixels      dw      0               ; Total # of pixels in the glyph
SMALLBITGLYPH   ends

LARGEBITGLYPH   struc
 lbgOrgX        dw      0               ; Vector to glyph origin in bitmap
 lbgOrgY        dw      0               ;  from upper left corner
 lbgWidth       dw      0               ; Width and height of glyph bmp in
 lbgHeight      dw      0               ;  pixels
 lbgPixels      dd      0               ; Total # of pixels in the glyph
LARGEBITGLYPH   ends


TEXTXFORM       struc                                                       ;*/ typedef     struct  {          /*

  ftHeight            dw  0                                                 ;*/ short int ftHeight;            /*
  ftWidth             dw  0                                                 ;*/ short int ftWidth;             /*
  ftEscapement        dw  0                                                 ;*/ short int ftEscapement;        /*
  ftOrientation       dw  0                                                 ;*/ short int ftOrientation;       /*
  ftWeight            dw  0                                                 ;*/ short int ftWeight;            /*
  ftItalic            db  0                                                 ;*/ BYTE ftItalic;                 /*
  ftUnderline         db  0                                                 ;*/ BYTE ftUnderline;              /*
  ftStrikeOut         db  0                                                 ;*/ BYTE ftStrikeOut;              /*
  ftOutPrecision      db  0                                                 ;*/ BYTE ftOutPrecision;           /*
  ftClipPrecision     db  0                                                 ;*/ BYTE ftClipPrecision;          /*
  ftAccelerator       dw  0                                                 ;*/ unsigned short int             /*
                                                                            ;*/                 ftAccelerator; /*
  ftOverhang          dw  0                                                 ;*/ short int ftOverhang;          /*

TEXTXFORM       ends                                                        ;*/ } TEXTXFORM;                   /*



TEXTMETRIC      struc                                                       ;*/ typedef struct {               /*

  tmHeight              dw  0     ; Ascent+Descent                          ;*/ short int tmHeight;            /*
  tmAscent              dw  0     ; Pixels above the baseline               ;*/ short int tmAscent;            /*
  tmDescent             dw  0     ; Pixels below the baseline               ;*/ short int tmDescent;           /*
  tmInternalLeading     dw  0     ; Internal leading included in font       ;*/ short int tmInternalLeading;   /*
  tmExternalLeading     dw  0     ; Prefered extra space between lines      ;*/ short int tmExternalLeading;   /*
  tmAveCharWidth        dw  0     ; Of the letter 'X'                       ;*/ short int tmAveCharWidth;      /*
  tmMaxCharWidth        dw  0                                               ;*/ short int tmMaxCharWidth;      /*
  tmWeight              dw  0                                               ;*/ short int tmWeight;            /*
  tmItalic              db  0                                               ;*/ BYTE      tmItalic;            /*
  tmUnderlined          db  0                                               ;*/ BYTE      tmUnderlined;        /*
  tmStruckOut           db  0                                               ;*/ BYTE      tmStruckOut;         /*
  tmFirstChar           db  0                                               ;*/ BYTE      tmFirstChar;         /*
  tmLastChar            db  0                                               ;*/ BYTE      tmLastChar;          /*
  tmDefaultChar         db  0     ; dfDefaultChar+dfFirstChar               ;*/ BYTE      tmDefaultChar;       /*
  tmBreakChar           db  0     ; dfBreakChar+dfFirstChar                 ;*/ BYTE      tmBreakChar;         /*
  tmPitchAndFamily      db  0     ; Low bit zero if fixed pitch, one if     ;*/ BYTE      tmPitchAndFamily;    /*
                                  ; variable. Family in high nibble.
  tmCharSet             db  0                                               ;*/ BYTE      tmCharSet;           /*
  tmOverhang            dw  0                                               ;*/ short int tmOverhang;          /*
  tmDigitizedAspectX    dw  0     ; Digitization aspect ratio               ;*/ short int tmDigitizedAspectX;  /*
  tmDigitizedAspectY    dw  0     ; in X and Y.                             ;*/ short int tmDigitizedAspectY;  /*

TEXTMETRIC     ends                                                         ;*/ } TEXTMETRIC;                  /*



                endif
                endif
page
;       Drawing mode definitions - incDrawMode


                ifdef   incDrawMode
                if      incDrawMode


DRAWMODE        struc                                                       ;*/ typedef     struct {         /*

  Rop2          dw      0       ;The 16-bit encoded Logical op              ;*/ short int         Rop2;       /*
  bkMode        dw      0       ;Background Mode (for text only)            ;*/ short int         bkMode;     /*
  bkColor       dd      0       ;Physical background Color                  ;*/ unsigned long int bkColor;    /*
  TextColor     dd      0       ;Physical text (forground) color            ;*/ unsigned long int TextColor;  /*
  TBreakExtra   dw      0       ; total pixles to stuff into a line         ;*/ short int         TBreakExtra;/*
  BreakExtra    dw      0       ; div(TBreakExtra, BreakCount)              ;*/ short int         BreakExtra; /*
  BreakErr      dw      0       ; running error term                        ;*/ short int         BreakErr;   /*
  BreakRem      dw      0       ; mod(TBreakExtra, BreakCount)              ;*/ short int         BreakRem;   /*
  BreakCount    dw      0       ; count of breaks in the line               ;*/ short int         BreakCount; /*
  CharExtra     dw      0       ; extra pixles to stuff after each char     ;*/ short int         CharExtra;  /*
                                ;   (used to space out a font)
  LbkColor      dd      0       ;Logical background color                   ;*/ unsigned long int LbkColor;   /*
  LTextColor    dd      0       ;Logical Text (forground) color             ;*/ unsigned long int LTextColor; /*
  ICMCXform     dd      0       ;Transform for DIC image color matcher      ;*/ DWORD             ICMCXform;  /*
  StretchBltMode dw     0       ;Stretch Blt mode                           ;*/ short         StretchBltMode; /*
  eMiterLimit   dd      0       ;Miter Limit (single precision IEEE float)  ;*/ DWORD             eMiterLimit;/*

DRAWMODE        ends                                                        ;*/ } DRAWMODE;                   /*



;       Background Mode definitions

TRANSPARENT     equ     1
OPAQUE          equ     2

BKMODE_TRANSPARENT      equ     1
BKMODE_OPAQUE           equ     2
BKMODE_LEVEL1           equ     3
BKMODE_LEVEL2           equ     4
BKMODE_LEVEL3           equ     5
BKMODE_TRANSLATE        equ     6


;       StretchBlt Mode definitions

STRETCH_ANDSCANS        equ     1
STRETCH_ORSCANS         equ     2
STRETCH_DELETESCANS     equ     3
STRETCH_HALFTONE        equ     4

SBM_BLACKONWHITE        equ     STRETCH_ANDSCANS
SBM_WHITEONBLACK        equ     STRETCH_ORSCANS
SBM_COLORONCOLOR        equ     STRETCH_DELETESCANS
SBM_HALFTONE            equ     STRETCH_HALFTONE

    if  0
*/
/* Background Mode definitions used by GDI support routines written in C */

#define     TRANSPARENT         1
#define     OPAQUE              2

#define BKMODE_TRANSPARENT      1
#define BKMODE_OPAQUE           2
#define BKMODE_LEVEL1           3
#define BKMODE_LEVEL2           4
#define BKMODE_LEVEL3           5
#define BKMODE_TRANSLATE        6

/* StretchBlt Mode definitions used by GDI support routines written in C */

#define STRETCH_ANDSCANS        1
#define STRETCH_ORSCANS         2
#define STRETCH_DELETESCANS     3
#define STRETCH_HALFTONE        4

#define SBM_BLACKONWHITE        STRETCH_ANDSCANS
#define SBM_WHITEONBLACK        STRETCH_ORSCANS
#define SBM_COLORONCOLOR        STRETCH_DELETESCANS
#define SBM_HALFTONE            STRETCH_HALFTONE

/*
    endif



                endif
                endif
page

;       The SCAN structure used by OS_POLYSCANLINE and DRAWESCAPE.
;       The DRAWESCAPE structure is used by the DrawEcape DDI.

                ifdef   incPolyScanline
                if      incPolyScanline

SCAN            struc                                                   ;*/  typedef struct {           /*
  scnPntCnt     dw      ?               ;Count of X coords (not pairs)  ;*/  short int scnPntCnt;       /*
  scnPntTop     dw      ?               ;Top of scan (inclusive)        ;*/  short int scnPntTop;       /*
  scnPntBottom  dw      ?               ;Bottom of scan (exclusive)     ;*/  short int scnPntBottom;    /*
  scnPntX       dw      2 dup (?)       ;Var. length array of X pairs   ;*/  short int scnPntX[2];      /*
  scnPntCntToo  dw      ?               ;=scnPntCnt                     ;*/  short int scnPntCntToo;    /*
SCAN            ends                                                    ;*/  } SCAN, FAR* LPSCAN;       /*

DRAWESCAPE      struc                                                   ;*/  typedef struct {           /*
  de_cbSize     dd      ?               ;sizeof(DRAWESCAPE)             ;*/  DWORD      cbSize;         /*
  de_lpDestDev  dd      ?               ;PDEVICE or PBITMAP             ;*/  LPVOID     lpDestDev;      /*
  de_nEscape    dd      ?               ;API parameter                  ;*/  DWORD      nEscape;        /*
  de_cbInput    dd      ?               ;API parameter                  ;*/  DWORD      cbInput;        /*
  de_lpszInput  dd      ?               ;API parameter                  ;*/  LPVOID     lpInput;        /*
  de_ptOrigin   dd      ?               ;origin of window               ;*/  POINT      ptOrigin;       /*
  de_dwUniq     dd      ?               ;region uniqueness value        ;*/  DWORD      dwUniq;         /*
  de_rcBBox     dw      4 dup (?)       ;bounding box of region         ;*/  RECT       rcBBox;         /*
  de_cScans     dd      ?               ;count of scans in region       ;*/  DWORD      cScans;         /*
  de_lpScan     dd      ?               ;ptr to first scan in region    ;*/  LPSCAN     lpScan;         /*
DRAWESCAPE      ends                                                    ;*/  } DRAWESCAPE, FAR* LPDRAWESCAPE; /*

REGION          struc                                                   ;*/  typedef struct {           /*
  rgn_id        dw      ?               ;if LPREGION 0x8000 else LPRECT ;*/  WORD       id;             /*
  rgn_cbSize    dw      ?               ;sizeof(REGION)                 ;*/  WORD       cbSize;         /*
  rgn_lprcClip  dd      ?               ;NULL or region walking opt.    ;*/  LPRECT     lprcClip;       /*
  rgn_dwUniq    dd      ?               ;region uniqueness value        ;*/  DWORD      dwUniq;         /*
  rgn_rcBBox    dw      4 dup (?)       ;bounding box of region         ;*/  RECT       rcBBox;         /*
  rgn_cScans    dd      ?               ;count of scans in region       ;*/  DWORD      cScans;         /*
  rgn_lpScan    dd      ?               ;ptr to first scan in region    ;*/  LPSCAN     lpScan;         /*
REGION          ends                                                    ;*/  } REGION, FAR* LPREGION;   /*

                endif   ;incPolyScanline
                endif   ;incPolyScanline

;       Output Definitions - incOutput

                ifdef   incOutput
                if      incOutput


;       Output Style definitions used by GDI


OS_POLYBEZIER   equ     1
OS_ARC          equ     3
OS_SCANLINES    equ     4
OS_POLYSCANLINE equ     5
OS_RECTANGLE    equ     6
OS_ELLIPSE      equ     7
OS_MARKER       equ     8
OS_POLYLINE     equ     18
OS_WINDPOLYGON  equ     20
OS_TRAPEZOID    equ     20      ; replaced with WINDPOLYGON
OS_ALTPOLYGON   equ     22
OS_POLYGON      equ     22      ; replaced with ALTPOLYGON
OS_PIE          equ     23
OS_POLYMARKER   equ     24
OS_CHORD        equ     39
OS_CIRCLE       equ     55

OS_POLYPOLYGON  equ     4000h   ; this bit is ORd with OS_WIND/ALTPOLYGON

OS_BEGINNSCAN   equ     80
OS_ENDNSCAN     equ     81
    if  0
*/

/* Output Style definitions used by GDI support routines written in C */

#define     OS_POLYBEZIER       1
#define     OS_ARC              3
#define     OS_SCANLINES        4
#define     OS_POLYSCANLINE     5
#define     OS_RECTANGLE        6
#define     OS_ELLIPSE          7
#define     OS_MARKER           8
#define     OS_POLYLINE         18
#define     OS_TRAPEZOID        20      /* should really be WINDPOLYGON */
#define     OS_WINDPOLYGON      OS_TRAPEZOID
#define     OS_POLYGON          22      /* should really be ALTPOLYGON */
#define     OS_ALTPOLYGON       OS_POLYGON
#define     OS_PIE              23
#define     OS_POLYMARKER       24
#define     OS_CHORD            39
#define     OS_CIRCLE           55

#define     OS_POLYPOLYGON      0x4000  /* this bit is ORd with OS_WIND/ALTPOLYGON */

#define     OS_BEGINNSCAN       80
#define     OS_ENDNSCAN         81
/*
    endif


                endif
                endif


                ifdef   incControl
                if      incControl

OEM_FAILED      equ     8000000

;       GDI escape constants

NEWFRAME          equ     1
ABORTDOC          equ     2
NEXTBAND          equ     3
SETCOLORTABLE     equ     4
GETCOLORTABLE     equ     5
FLUSHOUTPUT       equ     6
DRAFTMODE         equ     7
QUERYESCSUPPORT   equ     8
SETPRINTERDC      equ     9
SETABORTPROC      equ     9
STARTDOC          equ     10
ENDDOC            equ     11
GETPHYSPAGESIZE   equ     12
GETPRINTINGOFFSET equ     13
GETSCALINGFACTOR  equ     14
MFCOMMENT         equ     15
GETPENWIDTH       equ     16
SETCOPYCOUNT      equ     17
SELECTPAPERSOURCE equ     18
DEVICEDATA        equ     19
PASSTHROUGH       equ     19
GETTECHNOLGY      equ     20
GETTECHNOLOGY     equ     20
SETLINECAP        equ     21
SETLINEJOIN        equ    22
SETMITERLIMIT      equ    23
BANDINFO           equ    24
DRAWPATTERNRECT    equ    25
GETVECTORPENSIZE   equ    26
GETVECTORBRUSHSIZE equ    27
ENABLEDUPLEX       equ    28
GETSETPAPERBINS    equ    29
GETSETPRINTORIENT  equ    30
ENUMPAPERBINS      equ    31
SETDIBSCALING      equ    32
EPSPRINTING        equ    33
ENUMPAPERMETRICS   equ    34
GETSETPAPERMETRICS equ    35
GETVERSION         equ    36
POSTSCRIPT_DATA    equ    37
POSTSCRIPT_IGNORE  equ    38
MOUSETRAILS        equ    39
QUERYROPSUPPORT    equ    40
GETDEVICEUNITS     equ    42
RESETDEVICE        equ    128
GETEXTENDEDTEXTMETRICS equ 256
GETEXTENTTABLE         equ 257
GETPAIRKERNTABLE       equ 258
GETTRACKKERNTABLE      equ 259
EXTTEXTOUT             equ 512
GETFACENAME            equ 513
DOWNLOADFACE           equ 514
ENABLERELATIVEWIDTHS   equ 768
ENABLEPAIRKERNING      equ 769
SETKERNTRACK           equ 770
SETALLJUSTVALUES       equ 771
SETCHARSET             equ 772

STRETCHBLT             equ 2048
QUERYDIBSUPPORT        equ 3073
QDI_SETDIBITS          equ 1h
QDI_GETDIBITS          equ 2h
QDI_DIBTOSCREEN        equ 4h
QDI_STRETCHDIB         equ 8h
DCICOMMAND             equ 3075
BEGIN_PATH             equ 4096
CLIP_TO_PATH           equ 4097
END_PATH               equ 4098
EXT_DEVICE_CAPS        equ 4099
RESTORE_CTM            equ 4100
SAVE_CTM               equ 4101
SET_ARC_DIRECTION      equ 4102
SET_BACKGROUND_COLOR   equ 4103
SET_POLY_MODE          equ 4104
SET_SCREEN_ANGLE       equ 4105
SET_SPREAD             equ 4106
TRANSFORM_CTM          equ 4107
SET_CLIP_BOX           equ 4108
SET_BOUNDS             equ 4109
OPENCHANNEL            equ 4110
DOWNLOADHEADER         equ 4111
CLOSECHANNEL           equ 4112
SETGDIXFORM            equ 4113
RESETPAGE              equ 4114
POSTSCRIPT_PASSTHROUGH equ 4115

ENCAPSULATED_POSTSCRIPT equ 4116



    if 0
*/
#define OEM_FAILED          0x80000000L

#define NEWFRAME                     1
#define ABORTDOC                     2
#define NEXTBAND                     3
#define SETCOLORTABLE                4
#define GETCOLORTABLE                5
#define FLUSHOUTPUT                  6
#define DRAFTMODE                    7
#define QUERYESCSUPPORT              8
#define SETPRINTERDC                 9          // DDK - between GDI and Driver
#define SETABORTPROC                 9          // SDK - between APP and GDI
#define STARTDOC                     10
#define ENDDOC                       11
#define GETPHYSPAGESIZE              12
#define GETPRINTINGOFFSET            13
#define GETSCALINGFACTOR             14
#define MFCOMMENT                    15
#define GETPENWIDTH                  16
#define SETCOPYCOUNT                 17
#define SELECTPAPERSOURCE            18
#define DEVICEDATA                   19
#define PASSTHROUGH                  19
#define GETTECHNOLGY                 20
#define GETTECHNOLOGY                20
#define SETLINECAP                   21
#define SETLINEJOIN                  22
#define SETMITERLIMIT                23
#define BANDINFO                     24
#define DRAWPATTERNRECT              25
#define GETVECTORPENSIZE             26
#define GETVECTORBRUSHSIZE           27
#define ENABLEDUPLEX                 28
#define GETSETPAPERBINS              29
#define GETSETPRINTORIENT            30
#define ENUMPAPERBINS                31
#define SETDIBSCALING                32
#define EPSPRINTING                  33
#define ENUMPAPERMETRICS             34
#define GETSETPAPERMETRICS           35
#define GETVERSION                   36         /* ADOBE_11_1_88 */
#define POSTSCRIPT_DATA              37
#define POSTSCRIPT_IGNORE            38
#define QUERYROPSUPPORT              40
#define GETDEVICEUNITS               42
#define RESETDEVICE                  128
#define GETEXTENDEDTEXTMETRICS       256
#define GETEXTENTTABLE               257
#define GETPAIRKERNTABLE             258
#define GETTRACKKERNTABLE            259
#define EXTTEXTOUT                   512
#define GETFACENAME                  513
#define DOWNLOADFACE                 514       /* ADOBE_11_1_88 */
#define ENABLERELATIVEWIDTHS         768
#define ENABLEPAIRKERNING            769
#define SETKERNTRACK                 770
#define SETALLJUSTVALUES             771
#define SETCHARSET                   772
#define STRETCHBLT                   2048
#define QUERYDIBSUPPORT              3073
#define QDI_SETDIBITS                0x0001
#define QDI_GETDIBITS                0x0002
#define QDI_DIBTOSCREEN              0x0004
#define QDI_STRETCHDIB               0x0008
#define DCICOMMAND                   3075
#define BEGIN_PATH                   4096
#define CLIP_TO_PATH                 4097
#define END_PATH                     4098
#define EXT_DEVICE_CAPS              4099
#define RESTORE_CTM                  4100
#define SAVE_CTM                     4101
#define SET_ARC_DIRECTION            4102
#define SET_BACKGROUND_COLOR         4103
#define SET_POLY_MODE                4104
#define SET_SCREEN_ANGLE             4105
#define SET_SPREAD                   4106
#define TRANSFORM_CTM                4107
#define SET_CLIP_BOX                 4108
#define SET_BOUNDS                   4109
#define OPENCHANNEL                  4110
#define DOWNLOADHEADER               4111
#define CLOSECHANNEL                 4112
#define SETGDIXFORM                  4113
#define RESETPAGE                    4114
#define POSTSCRIPT_PASSTHROUGH       4115
#define ENCAPSULATED_POSTSCRIPT      4116


typedef FONTINFO    FAR *LPFONTINFO;
typedef DRAWMODE    FAR *LPDRAWMODE;
typedef TEXTXFORM   FAR *LPTEXTXFORM;
typedef TEXTMETRIC  FAR *LPTEXTMETRIC;
typedef LOGFONT     FAR *LPLOGFONT;
typedef LOGPEN      FAR *LPLOGPEN;
typedef LOGBRUSH    FAR *LPLOGBRUSH;
typedef BITMAP      FAR *LPBITMAP;
typedef FARPROC     FAR *LPFARPROC;
typedef GDIINFO     FAR *LPGDIINFO;
typedef SCALABLEFONTINFO FAR * LPSCALABLEFONTINFO;


/*
    endif



                endif
                endif
;*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\INCLUDE\GNGDI.INC ===
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Copyright (C) 1998-1999, Nvidia Corporation
;
; File:         gngdi.inc
;
; Purpose:      This file holds the interface to the generic
;               service routines.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

; gnblt.asm
EXTERNDEF       GN_BitBltPunt:NEAR
EXTERNDEF       GN_BitBltFail:NEAR
EXTERNDEF       GN_BitBltSuccess:NEAR

; gnclrblt.asm
EXTERNDEF       GN_BitBltSrcColorDstVram:NEAR
EXTERNDEF       GN_StretchBltSrcColorDstVram:NEAR

; gninit.asm
EXTERNDEF       wNVTEXT32_Alias_In_NVTEXT32:WORD
EXTERNDEF       wNVTEXT16_Alias_In_NVTEXT32:WORD
EXTERNDEF       wFlatDataSel:WORD
EXTERNDEF	GN_LoadDllAndGetExports:FAR16
CLOSESEG _NVTEXT32
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
OPENSEG  _NVTEXT16, USE16, CODE
; gninit.asm
EXTERNDEF       wNVTEXT32_Alias_In_NVTEXT16:WORD
EXTERNDEF       wNVTEXT16_Alias_In_NVTEXT16:WORD
EXTERNDEF       wFlatDataSel_In_NVTEXT16:WORD

; gnthk16.asm
EXTERNDEF       wBreak16:WORD
EXTERNDEF       GENERIC_OutputDebugString:FAR16

; gnutil.asm
EXTERNDEF       GN_GetDeviceLocalBasePath:FAR16
EXTERNDEF       GN_AllocSelectorAndMapIt:FAR16
EXTERNDEF       GN_UnmapAndFreeSelector:FAR16
EXTERNDEF       GN_GetSelectorBase:FAR16
EXTERNDEF       GN_MemoryAlloc:FAR16
EXTERNDEF       GN_MemoryFree:FAR16
EXTERNDEF       GN_GetSelectorBase:FAR16
EXTERNDEF       GN_AllocSelectorAndNullIt:FAR16
EXTERNDEF       GN_AllocSelectorAndMapIt:FAR16
EXTERNDEF       GN_UnmapAndFreeSelector:FAR16
EXTERNDEF       GN_CheckInterlacedStereoConnection:FAR16
CLOSESEG _NVTEXT16
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Now the Kernel exports
EXTERNDEF       AllocCSToDSAlias:FAR16
EXTERNDEF       GetSelectorBase:FAR16
EXTERNDEF       SetSelectorBase:FAR16
EXTERNDEF       SetSelectorLimit:FAR16
EXTERNDEF       SetLastError:FAR16
EXTERNDEF       SelectorAccessRights:FAR16
EXTERNDEF       FreeSelector:FAR16
EXTERNDEF       GetModuleHandle:FAR16
EXTERNDEF       GetProcAddress:FAR16
EXTERNDEF       GlobalAlloc:FAR16
EXTERNDEF       GlobalFree:FAR16
EXTERNDEF       GlobalHandle:FAR16
EXTERNDEF       GlobalLock:FAR16
EXTERNDEF       GlobalUnlock:FAR16
EXTERNDEF       LoadLibrary:FAR16
EXTERNDEF       FreeLibrary:FAR16
EXTERNDEF       RegOpenKey:FAR16
EXTERNDEF       RegCloseKey:FAR16
EXTERNDEF       RegEnumKey:FAR16
EXTERNDEF       RegQueryValueEx:FAR16
EXTERNDEF       RegCreateKey:FAR16
EXTERNDEF       RegSetValueEx:FAR16
EXTERNDEF       RegDeleteValue:FAR16
EXTERNDEF       OutputDebugString:FAR16
EXTERNDEF       GetVersionEx:FAR16
EXTERNDEF       IsBadReadPtr:FAR16
EXTERNDEF       IsBadWritePtr:FAR16

; A few things for the Registry functions so I don't have to include
; all the windows header files.
MAX_KEY_LEN             TEXTEQU <80H>

HKEY_CLASSES_ROOT       TEXTEQU <80000000H>
HKEY_CURRENT_USER       TEXTEQU <80000001H>
HKEY_LOCAL_MACHINE      TEXTEQU <80000002H>
HKEY_USERS              TEXTEQU <80000003H>
HKEY_PERFORMANCE_DATA   TEXTEQU <80000004H>
HKEY_CURRENT_CONFIG     TEXTEQU <80000005H>
HKEY_DYN_DATA           TEXTEQU <80000006H>
ERROR_SUCCESS           TEXTEQU <00H>

REG_NONE                TEXTEQU <000000000h>
REG_SZ                  TEXTEQU <000000001h>
REG_EXPAND_SZ           TEXTEQU <000000002h>
REG_BINARY              TEXTEQU <000000003h>
REG_DWORD               TEXTEQU <000000004h>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
MSG_PREMODESET          	TEXTEQU <00000000H>
MSG_POSTMODESET         	TEXTEQU <00000001H>
MSG_DIRECTX_ENUM		TEXTEQU	<00000002H>
MSG_DIRECTXON           	TEXTEQU <00000003H>
MSG_DIRECTXOFF          	TEXTEQU <00000004H>
MSG_DOSON               	TEXTEQU <00000005H>
MSG_DOSOFF              	TEXTEQU <00000006H>
MSG_DISABLE             	TEXTEQU <00000007H>
MSG_LOGDEVMOVED         	TEXTEQU <00000008H>
MSG_DEVICESREMAPPED		TEXTEQU	<00000009H>
MSG_DISPLAY_DRIVER_UNLOADING	TEXTEQU	<0000000AH>
MSG_POWERON             	TEXTEQU <0000000BH>
MSG_POWEROFF            	TEXTEQU <0000000CH>

; MSG_PREMODESET, MSG_POSTMODESET
; These two are given in the order shown above. The mode is set after
; the PREMODESET message returns and before the POSTMODESET message
; is sent. These messages are when the logical mode changes only!
; If the CRTC is being set to a different mode, but the desktop size
; is not changing, then these messages will not be sent.
; No one processing these messages should screw up the screen,
; change the pitch, etc in any way. They are just information to
; allow the various objects to set some internal state variables
; alloc and free resources. All calls that change state affecting
; the screens appearance will be outside of the message stuff,
; thus allowing for better control and serialization.

; MSG_PREMODESET
; dwData1 is a context ptr to a DIBENGINE structure which reflects the
; current logical mode - not the new mode being set. This gives everyone
; a chance to shutdown anything in the old mode before the modeset.
; dwData2 is the 16:16 ptr to the same thing.

; MSG_POSTMODESET
; dwData1 is a context ptr to a DIBENGINE structure which reflects the
; new logical mode that is being set.
; dwData2 is the 16:16 ptr to the same thing.

; MSG_DIRECTX_ENUM, MSG_DIRECTX_ON, MSG_DIRECTX_OFF
; MSG_DIRECTX_ENUM means that the system is at the very least enumerating
; all the DirectX devices and that includes issuing an escape to all the
; display drivers that power the 2D side of the device.
; MSG_DIRECTXON means that the first app has attached to the DirectX
; Context. This is when offscreen video memory should be releaseed
; for use by DirectX.
; MSG_DIRECTXOFF means that the last app has released the DirectX Context.
; Thi is when the 2D driver can reclaim offscreen video memory.
; dwData1 and dwData2 are unused.

; MSG_DOSON, MSG_DOSOFF, MSG_POWERON, MSG_POWEROFF
; dwData1 is a context ptr to a DIBENGINE structure which reflects the
; new logical mode that is being set.
; dwData2 is the 16:16 ptr to the same thing.

; MSG_DISABLE
; The device is being disabled. In general, the action here should
; be similar to a DOSON msg. In both cases, it probably means that
; the driver is temporarily losing control of the screen and the
; hardware.
; dwData1 and dwData2 are unused.

; MSG_LOGDEVMOVED
; dwData1 is the new pGNLogdevCX.
; dwData2 is the old pGNLogdevCX.

; MSG_DEVICESREMAPPED
; This message says that the hardware has remapped the device
; to head assignments. Although the generic code may not know
; exactly what this means, the idea is that things relating to
; head DAC speeds, etc, may be different.
; dwData1 is ignored
; dwData2 is ignored

; MSG_PRE_RESETTING_VIDEO_MEMORY_HEAP
; MSG_POST_RESETTING_VIDEO_MEMORY_HEAP
; This message is only sent down in catastrophic cases where we were
; unable to allocate even a 640x480x8 primary surface for one of the
; displays ona modeset. Since the code in the display driver should
; always allow us to get at least this surface size, it must be that
; somehow the heap is corrupted. In that case, we reset it so that
; it is completely clean and inform everyone so they can do any clean
; up. The pre message is sent just before the heap is purged. The post
; message is sent after a new one has been allocated. These messages
; may well be sent nested inside a MSG_PREMODESET and MSG_POSTMODESET
; pair, because it is on a modeset that we discover we can't get the
; primary surface.
; dwData1 is a ptr to the DIBENGINEHDR structure describing the
;	  current mode. Since we are probably inside a PREMODESET/
;	  POSTMODESET pair, dwData1 will describe the mode that
;	  exists BEFORE the mode change.
; dwData2 is not used

PLABEL	MACRO	name
	public	&name&
&name&	proc	near
&name&	endp
	ENDM
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\INCLUDE\HWGDI.INC ===
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Copyright (C) 1998-1999, Nvidia Corporation
;
; File:         hwgdi.inc
;
; Purpose:      This file holds the interface to the harware specific
;               service routines.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; I put these equates inside things that I think are wrong or not necessary
; but they break verdict so I made the changes.
MAKE_VERDICT_WORK       TEXTEQU <1>

IF      (MAKE_VERDICT_WORK NE 0)
INTERSECT_TEXTXFORM_WITH_CLIP   TEXTEQU <1>
CHIP_SORTS_RECT_AND_TEXT_COORDS TEXTEQU <1>
ELSE

; The DIBENG intersects the rectangle specified by the lpTextXForm
; argument to ExtTextOut with the rectangle specified by lpClipRect
; to generate the real clip rect. I think that this is wrong.
; lpClipRect gives the clip rectangle period.
INTERSECT_TEXTXFORM_WITH_CLIP   TEXTEQU <0>
ENDIF

; This enables font cache.  It is off by default for now because font cache
; is actually slower on a very fast machine like Camino 700 Mhz.  On a slower
; machine like PIII-500 it is slightly faster than the traditional text.
RENDER_TEXT_WITH_FONT_CACHE     TEXTEQU <0>

; Enables support for A8R8G8B8 color cursors with alpha
USE_ALPHA_CURSOR        TEXTEQU <1>

; Enables cursor shadows.  Down and right are the number of pixels the
; shadow is displaced.
CURSOR_SHADOW           TEXTEQU <0>
CURSOR_SHADOW_DOWN      TEXTEQU <3>
CURSOR_SHADOW_RIGHT     TEXTEQU <3>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
OPENSEG  _NVTEXT16, USE16, CODE
; hwaccess.asm
EXTERNDEF       HW_GetGraphicsTimeStamp:NEAR

; hwcntrl.asm
EXTERNDEF       HW_ControlQuery:NEAR
EXTERNDEF       HW_ControlAction:NEAR

; hwinit.asm
EXTERNDEF       HW_CreateConstants:FAR16
EXTERNDEF       HW_DestroyConstants:FAR16
EXTERNDEF       HW_AllocFlatMemory:FAR16
EXTERNDEF       HW_FreeFlatMemory:FAR16
EXTERNDEF       HW_GetLogdevToBoardPtr:FAR16

; hwlogdev.asm
EXTERNDEF       HW_CreateLogdevContext:FAR16
EXTERNDEF       HW_DestroyLogdevContext:FAR16
EXTERNDEF       HW_LogdevAttachCrtc:FAR16
EXTERNDEF       HW_LogdevDetachCrtc:FAR16
EXTERNDEF       HW_Get16BppPixelFormat:FAR16
EXTERNDEF       HW_GetTextFormat:FAR16

; hwlogdev2.asm
EXTERNDEF       HW_LogdevMessage:FAR16
EXTERNDEF       HW_DriverTwinviewStateChanging:FAR16
EXTERNDEF       HW_AllocLogicalSurface:FAR16
EXTERNDEF       HW_FreeLogicalSurface:FAR16
EXTERNDEF       HW_GetDirectXRuntimeVersion:FAR16
EXTERNDEF       HW_GetDirectXDllNameAndEntryPoint:FAR16
EXTERNDEF       HW_SetNewDirxCallbacks:FAR16
EXTERNDEF       HW_GetDirectXInstance:FAR16
EXTERNDEF       HW_GetOpenGLRegistryName:FAR16
EXTERNDEF       HW_TellResManSpanningState:FAR16

; mvision
EXTERNDEF       HW_SetMacrovisionMode:NEAR
CLOSESEG _NVTEXT16


OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE
; hwaccess.asm
EXTERNDEF       HW_BeginAccess:NEAR
EXTERNDEF       HW_BeginAccess_Far32:FAR32
EXTERNDEF       HW_EndAccess:NEAR
EXTERNDEF       HW_CreateOffscreenBitmap:NEAR
EXTERNDEF       HW_DeleteOffscreenBitmap:NEAR

; hwboard.asm
EXTERNDEF       HW_CreateBoardContext:FAR32
EXTERNDEF       HW_DestroyBoardContext:FAR32
EXTERNDEF       HW_SetDesktopState:FAR32
EXTERNDEF       NV_SetInterlacedStereoMode:FAR32
DESKTOP_STATE_NORMAL    TEXTEQU <0>
DESKTOP_STATE_MULTIMON  TEXTEQU <1>
DESKTOP_STATE_CLONE     TEXTEQU <2>

; hwboard2.asm
EXTERNDEF       HW_BoardMessage:FAR32
EXTERNDEF       HW_GetLargestOffscreenBlock:FAR32
EXTERNDEF       HW_GetLargestOffscreenSpace:FAR32
EXTERNDEF       HW_AllocOffscreenBlock:FAR32
EXTERNDEF       HW_FreeOffscreenBlock:FAR32
EXTERNDEF       HW_OffscreenHeapPurge:FAR32
EXTERNDEF       HW_DxHeapPurge:FAR32
EXTERNDEF       HW_HeapPurgeAllExceptPrimarySurface:FAR32
EXTERNDEF       HW_AllocPrimarySurface:FAR32
EXTERNDEF       HW_FreePrimarySurface:FAR32
EXTERNDEF       HW_PrimarySurfaceHeapPurge:FAR32
EXTERNDEF       HW_GetPciDeviceID:FAR32
EXTERNDEF       HW_GetFrameBufferSelector:FAR32
EXTERNDEF       HW_GetModeDimensions:FAR32
EXTERNDEF       HW_GetNumCRTCs:FAR32
EXTERNDEF       HW_GetAllAttachedDevices:FAR32
EXTERNDEF       HW_IsDeviceAttached:FAR32
EXTERNDEF       HW_CanDevicesBeMapped:FAR32
EXTERNDEF       HW_MapDevices:FAR32
EXTERNDEF       HW_BeginDisplayChange:FAR32
EXTERNDEF       HW_EndDisplayChange:FAR32
EXTERNDEF       Enable_VGA:FAR32

; hwclrblt.asm
EXTERNDEF       HW_BitBltSrcColorDstVram:NEAR
EXTERNDEF       HW_BeginSrcColorDstVram:NEAR
EXTERNDEF       HW_BlockSrcColorDstVram:NEAR
EXTERNDEF       HW_EndSrcColorDstVram:NEAR

; hwcrtc.asm
EXTERNDEF       HW_CreateCrtcContext:FAR32
EXTERNDEF       HW_DestroyCrtcContext:FAR32
EXTERNDEF       HW_GetDacLimits:FAR32
EXTERNDEF       HW_BitsPerColorGun:FAR32
EXTERNDEF       HW_SizeCursorCache:FAR32
EXTERNDEF       HW_IsCRTConnected:FAR32
EXTERNDEF       HW_IsDFPConnected:FAR32
EXTERNDEF       HW_IsTVConnected:FAR32
EXTERNDEF       HW_GetMaxDfpScaledXRes:FAR32
EXTERNDEF       HW_IsMacroVisionEncoderAttached:FAR32
EXTERNDEF       HW_ReadEdid:FAR32
EXTERNDEF       HW_ReadEdidForDevice:FAR32
EXTERNDEF       HW_GetPhysicalCrtcIndex:FAR32
EXTERNDEF       HW_GetBootDevice:FAR32
EXTERNDEF       HW_GetResManTvFormat:FAR32
EXTERNDEF       HW_SetResManTvFormat:FAR32
EXTERNDEF       HW_GetMaxTVOutResolution:FAR32

; hwcrtc2.asm
EXTERNDEF       HW_CrtcMessage:FAR32
EXTERNDEF       HW_SetCrtcMode:FAR32
EXTERNDEF       HW_SetStopImage:FAR32
EXTERNDEF       HW_SetPanOffset:FAR32
EXTERNDEF       HW_SetGamma:FAR32
EXTERNDEF       HW_SetPalette:FAR32
EXTERNDEF       HW_MapHWDeviceTypeToGNDeviceType:FAR32
EXTERNDEF       HW_MapGNDeviceTypeToHWDeviceType:FAR32
EXTERNDEF       HW_MapHWTvFormatToGNTvFormat:FAR32
EXTERNDEF       HW_MapGNTvFormatToHWTvFormat:FAR32
EXTERNDEF       HW_IsBandwidthOK:FAR32

; hwcursor.asm
EXTERNDEF       HW_CursorEnable_FAR32:FAR32
EXTERNDEF       HW_CursorEnable:NEAR
EXTERNDEF       HW_CursorSet:NEAR
EXTERNDEF       HW_CursorSelect:NEAR
EXTERNDEF       HW_CursorMove:NEAR

; hwldpat.asm
EXTERNDEF       HW_LoadSolidPattern:NEAR
EXTERNDEF       HW_LoadMonoPattern:NEAR
EXTERNDEF       HW_LoadColorPattern:NEAR

; hwline.asm
EXTERNDEF       HW_Polyline:NEAR
EXTERNDEF       HW_PolyStyledLine:NEAR
EXTERNDEF       SETUPPATTERNHWFORSTYLELINE:NEAR

; hwmonblt.asm
EXTERNDEF       HW_BeginSrcMonoDstVram:NEAR
EXTERNDEF       HW_BlockSrcMonoDstVram:NEAR
EXTERNDEF       HW_EndSrcMonoDstVram:NEAR

; hwpatblt.asm
EXTERNDEF       HW_BitBltSolidPatDstRop:NEAR
EXTERNDEF       HW_BitBltColorPatDstRop:NEAR
EXTERNDEF       HW_BitBltMonoPatDstRop:NEAR

; hwrect.asm
EXTERNDEF       HW_DrawRectAndBorder:NEAR
EXTERNDEF       HW_BeginRect:NEAR
EXTERNDEF       HW_BlockRect:NEAR
EXTERNDEF       HW_BorderRect:NEAR
EXTERNDEF       HW_EndRect:NEAR
EXTERNDEF       HW_SolidColorRectangle:NEAR

; hwstrblt.asm
EXTERNDEF       HW_BeginStretchSrcColorDstVram:NEAR
EXTERNDEF       HW_BlockStretchSrcColorDstVram:NEAR
EXTERNDEF       HW_EndStretchSrcColorDstVram:NEAR

; hwsysblt.asm
EXTERNDEF       HW_BeginSrcVramDstSystem:NEAR
EXTERNDEF       HW_BlockSrcVramDstSystem:NEAR
EXTERNDEF       HW_WaitSrcVramDstSystem:NEAR
EXTERNDEF       HW_EndSrcVramDstSystem:NEAR

; hwtext.asm
EXTERNDEF       HW_DrawOpaqueRects:NEAR
EXTERNDEF       HW_TextBegin:NEAR
EXTERNDEF       HW_TextBlt:NEAR
EXTERNDEF       HW_TextEnd:NEAR

; hwvrmblt.asm
EXTERNDEF       HW_BitBltSrcVramDstVram:NEAR
CLOSESEG _NVTEXT32
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; BITBLT

; This will be the frame for BitBlt that is shared between the generic
; code and SOME of the hardware specific bitblt routines. You may add
; locals as you need them.
BITBLT_FRAME_AND_LOCALS MACRO
PARMD   lpDstDev
PARMW   wDstX
PARMW   wDstY
PARMD   lpSrcDev
PARMW   wSrcX
PARMW   wSrcY
PARMW   wExtX
PARMW   wExtY
PARMD   dwRop3
PARMD   lpBrush
PARMD   lpDrawMode

; Generic code needs these
LOCALD  dwSrcBitsOffset
LOCALD  dwScansPerSeg

; Add hardware specific ones here.
ENDM
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; EXTTEXTOUT

; This will be the frame for ExtTextOut that is shared between the generic
; code and the hardware specific code. You may add locals as you need them.
EXTTEXTOUT_FRAME_AND_LOCALS     MACRO
PARMD   lpDstDev
PARMW   wDstX
PARMW   wDstY
PARMD   lpClipRect
PARMD   lpString
PARMW   wCount
PARMD   lpFontInfo
PARMD   lpDrawMode
PARMD   lpTextXForm
PARMD   lpKerning
PARMD   lpOpaqueRects
PARMW   wOptions

; Generic code needs these
LOCALD  dwDstBitsOffset
LOCALD  dwDstBitsDeltaScan
LOCALD  dwFgColor
LOCALD  dwBgColor
LOCALD  dwStringOffset
LOCALD  dwGlyphWidth
LOCALD  dwKerningOffset
LOCALD  dwDstYDstX
LOCALD  dwClipRight
LOCALD  dwGlyphCount
LOCALD  pHWLogDevCXOffset_ForExtTextOut
LOCALD  pHWBoardCXOffset_ForExtTextOut
LOCALV  wOpaqueClipRect,RECT
LOCALV  wTextClipRect,RECT
ENDM
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This macro allows you to call through function ptrs in other segments.
; I was using this alot in both the HWSPEC and GENERIC code so I put a
; macro in here to make it simple.
CALLFAR16IND    MACRO   lpfnFunc,sreg,reg
        mov     reg,SEG lpfnFunc
        mov     sreg,reg
        call    FFP16 PTR sreg:[lpfnFunc]
ENDM
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\INCLUDE\MINIVDD.INC ===
ifndef _MINIVDD_H_
_MINIVDD_H_     EQU     1
ifndef Not_VxD
ifdef MINIVDD
ifdef NEC_98
Begin_Service_Table VDD
VDD_Service      VDD_Get_Version
VDD_Service      VDD_PIF_State
VDD_Service      VDD_Get_GrabRtn
VDD_Service      VDD_Hide_Cursor
VDD_Service      VDD_Set_VMType
VDD_Service      VDD_Get_ModTime
VDD_Service      VDD_Set_HCurTrk
VDD_Service      VDD_Msg_ClrScrn
VDD_Service      VDD_Msg_ForColor
VDD_Service      VDD_Msg_BakColor
VDD_Service      VDD_Msg_TextOut
VDD_Service      VDD_Msg_SetCursPos
VDD_Service      VDD_Query_Access
VDD_Service      VDD_Check_Update_Soon
VDD_Service      VDD_Get_Mini_Dispatch_Table
VDD_Service      VDD_Register_Virtual_Port
VDD_Service      VDD_Get_VM_Info
VDD_Service      VDD_Get_Special_VM_IDs
VDD_Service      VDD_Register_Extra_Screen_Selector
VDD_Service      VDD_Takeover_VGA_Port
VDD_Service      VDD_Get_DISPLAYINFO
VDD_Service      VDD_Do_Physical_IO
VDD_Service      VDD_Register_Mini_VDD
VDD_Service      VDD_Install_IO_Handler
VDD_Service      VDD_Install_Mult_IO_Handlers
VDD_Service      VDD_Enable_Local_Trapping
VDD_Service      VDD_Disable_Local_Trapping
VDD_Service      VDD_Trap_Suspend
VDD_Service      Test_Vid_VM_Handle
VDD_Service      VDD_Set_Core_Graphics
VDD_Service      VDD_Load_AccBIOS
VDD_Service      VDD_Map_AccBIOS
VDD_Service      VDD_Map_VRAM
VDD_Service      VDD_EnableDevice
End_Service_Table VDD
else
Begin_Service_Table VDD
VDD_Service      VDD_Get_Version
VDD_Service      VDD_PIF_State
VDD_Service      VDD_Get_GrabRtn
VDD_Service      VDD_Hide_Cursor
VDD_Service      VDD_Set_VMType
VDD_Service      VDD_Get_ModTime
VDD_Service      VDD_Set_HCurTrk
VDD_Service      VDD_Msg_ClrScrn
VDD_Service      VDD_Msg_ForColor
VDD_Service      VDD_Msg_BakColor
VDD_Service      VDD_Msg_TextOut
VDD_Service      VDD_Msg_SetCursPos
VDD_Service      VDD_Query_Access
VDD_Service      VDD_Check_Update_Soon
VDD_Service      VDD_Get_Mini_Dispatch_Table
VDD_Service      VDD_Register_Virtual_Port
VDD_Service      VDD_Get_VM_Info
VDD_Service      VDD_Get_Special_VM_IDs
VDD_Service      VDD_Register_Extra_Screen_Selector
VDD_Service      VDD_Takeover_VGA_Port
VDD_Service      VDD_Get_DISPLAYINFO
VDD_Service      VDD_Do_Physical_IO
VDD_Service      VDD_Set_Sleep_Flag_Addr
VDD_Service      VDD_EnableDevice
End_Service_Table VDD
endif
endif
VDD_VerNum                      EQU     0400H
VDD_MinVerNum                   EQU     030AH
ifdef NEC_98
bVidTextMd                      EQU     4
fVidTextMd                      EQU     (1 SHL 4)
bVidNTModeFF                    EQU     0
fVidNTModeFF                    EQU     (1 SHL 0)
bVidNTModeFFC16                 EQU     1
fVidNTModeFFC16                 EQU     (1 SHL 1)
bVidNTDispRW                    EQU     2
fVidNTDispRW                    EQU     (1 SHL 2)
bVidNTPal                       EQU     3
fVidNTPal                       EQU     (1 SHL 3)
bVidNTGDC                       EQU     5
fVidNTGDC                       EQU     (1 SHL 5)
bVidNTGDCTON                    EQU     6
fVidNTGDCTON                    EQU     (1 SHL 6)
bVidNTGDCGON                    EQU     7
fVidNTGDCGON                    EQU     (1 SHL 7)
bVidNTFont                      EQU     8
fVidNTFont                      EQU     (1 SHL 8)
bVidCRTC                        EQU     9
fVidCRTC                        EQU     (1 SHL 9)
bVidDispDataXfer                EQU     10
fVidDispDataXfer                EQU     (1 SHL 10)
bVidXFERPlane0                  EQU     11
fVidXFERPlane0                  EQU     (1 SHL 11)
bVidXFERPlane1                  EQU     12
fVidXFERPlane1                  EQU     (1 SHL 12)
bVidXFERPlane2                  EQU     13
fVidXFERPlane2                  EQU     (1 SHL 13)
bVidXFERPlane3                  EQU     14
fVidXFERPlane3                  EQU     (1 SHL 14)
mVidXFERPlane                   EQU     (fVidXFERPlane0+fVidXFERPlane1+fVidXFERPlane2+fVidXFERPlane3)
mVidNTH98                       EQU     (fVidNTModeFF+fVidNTModeFFC16+fVidNTDispRW+fVidNTPal+fVidNTGDC+fVidNTGDCTON+fVidNTGDCGON)
else
fVidTxtEmulate                  EQU     0001H
fVidNoTrpTxt                    EQU     0002H
fVidNoTrpLRGrfx                 EQU     0004H
fVidNoTrpHRGrfx                 EQU     0008H
fVidTextMd                      EQU     0010H
fVidLowRsGrfxMd                 EQU     0020H
fVidHghRsGrfxMd                 EQU     0040H
fVidRetainAllo                  EQU     0080H
endif

ifdef NEC_98
REGISTER_DISPLAY_DRIVER         EQU     0
PRE_HIRES_TO_VGA                EQU     1
SAVE_REGISTERS                  EQU     2
RESTORE_REGISTERS               EQU     3
ENABLE_TRAPS                    EQU     4
DISABLE_TRAPS                   EQU     5
DISPLAY_DRIVER_DISABLING        EQU     6
ENABLE_ACCELERATER              EQU     7
DISABLE_ACCELERATER             EQU     8
CHECK_UPDATE                    EQU     9
CHECK_WINDOWED                  EQU     10
ACC_VBE_PM                      EQU     11
ACC_VBE_DDC                     EQU     12
ACC_INT_10                      EQU     13
ACC_GET_CAPABILITIES            EQU     14
ACC_GET_EXT_MODE_INFO           EQU     15
ACC_GET_FLAT_SELECTOR           EQU     16
ACC_ENABLE_BIOS                 EQU     17
ACC_DISABLE_BIOS                EQU     18
ACC_SET_PALETTE                 EQU     19
ACC_GET_PALETTE                 EQU     20
ACC_SET_CURSOR                  EQU     21
ACC_SHOW_CURSOR                 EQU     22
ACC_HIDE_CURSOR                 EQU     23
ACC_SET_CURSOR_POS              EQU     24
ACC_GET_CURSOR_POS              EQU     25
NBR_MINI_VDD_FUNCTIONS_40       EQU     26
GET_NUM_UNITS                   EQU     26
SET_ADAPTER_POWER_STATE         EQU     27
GET_ADAPTER_POWER_STATE_CAPS    EQU     28
SET_MONITOR_POWER_STATE         EQU     29
GET_MONITOR_POWER_STATE_CAPS    EQU     30
GET_MONITOR_INFO                EQU     31
I2C_OPEN                        EQU     32
I2C_ACCESS                      EQU     33
GPIO_OPEN                       EQU     34
GPIO_ACCESS                     EQU     35
COPYPROTECTION_ACCESS           EQU     36
NBR_MINI_VDD_FUNCTIONS_41       EQU     37
ifdef MAINVDD
NBR_MINI_VDD_FUNCTIONS          EQU     NBR_MINI_VDD_FUNCTIONS_41
else
NBR_MINI_VDD_FUNCTIONS          EQU     NBR_MINI_VDD_FUNCTIONS_40
endif
else
REGISTER_DISPLAY_DRIVER         EQU     0
GET_VDD_BANK                    EQU     1
SET_VDD_BANK                    EQU     2
RESET_BANK                      EQU     3
PRE_HIRES_TO_VGA                EQU     4
POST_HIRES_TO_VGA               EQU     5
PRE_VGA_TO_HIRES                EQU     6
POST_VGA_TO_HIRES               EQU     7
SAVE_REGISTERS                  EQU     8
RESTORE_REGISTERS               EQU     9
MODIFY_REGISTER_STATE           EQU     10
ACCESS_VGA_MEMORY_MODE          EQU     11
ACCESS_LINEAR_MEMORY_MODE       EQU     12
ENABLE_TRAPS                    EQU     13
DISABLE_TRAPS                   EQU     14
MAKE_HARDWARE_NOT_BUSY          EQU     15
VIRTUALIZE_CRTC_IN              EQU     16
VIRTUALIZE_CRTC_OUT             EQU     17
VIRTUALIZE_SEQUENCER_IN         EQU     18
VIRTUALIZE_SEQUENCER_OUT        EQU     19
VIRTUALIZE_GCR_IN               EQU     20
VIRTUALIZE_GCR_OUT              EQU     21
SET_LATCH_BANK                  EQU     22
RESET_LATCH_BANK                EQU     23
SAVE_LATCHES                    EQU     24
RESTORE_LATCHES                 EQU     25
DISPLAY_DRIVER_DISABLING        EQU     26
SELECT_PLANE                    EQU     27
PRE_CRTC_MODE_CHANGE            EQU     28
POST_CRTC_MODE_CHANGE           EQU     29
VIRTUALIZE_DAC_OUT              EQU     30
VIRTUALIZE_DAC_IN               EQU     31
GET_CURRENT_BANK_WRITE          EQU     32
GET_CURRENT_BANK_READ           EQU     33
SET_BANK                        EQU     34
CHECK_HIRES_MODE                EQU     35
GET_TOTAL_VRAM_SIZE             EQU     36
GET_BANK_SIZE                   EQU     37
SET_HIRES_MODE                  EQU     38
PRE_HIRES_SAVE_RESTORE          EQU     39
POST_HIRES_SAVE_RESTORE         EQU     40
VESA_SUPPORT                    EQU     41
GET_CHIP_ID                     EQU     42
CHECK_SCREEN_SWITCH_OK          EQU     43
VIRTUALIZE_BLTER_IO             EQU     44
SAVE_MESSAGE_MODE_STATE         EQU     45
SAVE_FORCED_PLANAR_STATE        EQU     46
VESA_CALL_POST_PROCESSING       EQU     47
PRE_INT_10_MODE_SET             EQU     48
NBR_MINI_VDD_FUNCTIONS_40       EQU     49
GET_NUM_UNITS                   EQU     49
TURN_VGA_OFF                    EQU     50
TURN_VGA_ON                     EQU     51
SET_ADAPTER_POWER_STATE         EQU     52
GET_ADAPTER_POWER_STATE_CAPS    EQU     53
SET_MONITOR_POWER_STATE         EQU     54
GET_MONITOR_POWER_STATE_CAPS    EQU     55
GET_MONITOR_INFO                EQU     56
I2C_OPEN                        EQU     57
I2C_ACCESS                      EQU     58
GPIO_OPEN                       EQU     59
GPIO_ACCESS                     EQU     60
COPYPROTECTION_ACCESS           EQU     61
NBR_MINI_VDD_FUNCTIONS_41       EQU     62
ifdef MAINVDD
NBR_MINI_VDD_FUNCTIONS          EQU     NBR_MINI_VDD_FUNCTIONS_41
else
NBR_MINI_VDD_FUNCTIONS          EQU     NBR_MINI_VDD_FUNCTIONS_40
endif
endif
endif
VDD_QUERY_VERSION               EQU     0
MINIVDD_SVC_BASE_OFFSET         EQU     80H
VDD_DRIVER_REGISTER             EQU     (0+MINIVDD_SVC_BASE_OFFSET)
VDD_DRIVER_UNREGISTER           EQU     (1+MINIVDD_SVC_BASE_OFFSET)
VDD_SAVE_DRIVER_STATE           EQU     (2+MINIVDD_SVC_BASE_OFFSET)
VDD_REGISTER_DISPLAY_DRIVER_INFO EQU    (3+MINIVDD_SVC_BASE_OFFSET)
VDD_REGISTER_SSB_FLAGS          EQU     (4+MINIVDD_SVC_BASE_OFFSET)
VDD_GET_DISPLAY_CONFIG          EQU     (5+MINIVDD_SVC_BASE_OFFSET)
VDD_PRE_MODE_CHANGE             EQU     (6+MINIVDD_SVC_BASE_OFFSET)
VDD_POST_MODE_CHANGE            EQU     (7+MINIVDD_SVC_BASE_OFFSET)
VDD_SET_USER_FLAGS              EQU     (8+MINIVDD_SVC_BASE_OFFSET)
VDD_SET_BUSY_FLAG_ADDR          EQU     (9+MINIVDD_SVC_BASE_OFFSET)
VDD_PC98_RESERVED               EQU     (10+MINIVDD_SVC_BASE_OFFSET)
VDD_VBE_PM                      EQU     (10+MINIVDD_SVC_BASE_OFFSET)
VDD_ENABLE                      EQU     (11+MINIVDD_SVC_BASE_OFFSET)
VDD_GETMEMBASE                  EQU     (12+MINIVDD_SVC_BASE_OFFSET)
VDD_OPEN                        EQU     (13+MINIVDD_SVC_BASE_OFFSET)
VDD_CLOSE                       EQU     (14+MINIVDD_SVC_BASE_OFFSET)
VDD_OPEN_KEY                    EQU     (15+MINIVDD_SVC_BASE_OFFSET)
VDD_SET_POWER_STATE             EQU     (16+MINIVDD_SVC_BASE_OFFSET)
VDD_GET_POWER_STATE_CAPS        EQU     (17+MINIVDD_SVC_BASE_OFFSET)
VDD_GET_DISPLAY_CONFIG2         EQU     8085H
ENABLE_IO                       EQU     00000001H
ENABLE_MEM                      EQU     00000002H
ENABLE_VGA                      EQU     00000030H
ENABLE_ROM                      EQU     00000080H
ENABLE_ALL                      EQU     000000FFH
ENABLE_NONE                     EQU     00000000H
ENABLE_VALID                    EQU     000000FFH
ENABLE_ERROR                    EQU     0FFFFFFFFH
VDD_OPEN_EXIST                  EQU     00000001H
VDD_OPEN_ENUM                   EQU     00000002H
VDD_OPEN_LOCK                   EQU     00000000H
VDD_OPEN_TEST                   EQU     VDD_OPEN_EXIST
VDD_OPEN_KEY_WRITE              EQU     00000001H
VDD_OPEN_KEY_READ               EQU     00000002H
VDD_OPEN_KEY_USER               EQU     00000010H
VDD_OPEN_KEY_GLOBAL             EQU     00000020H
VDD_IOCTL_SET_NOTIFY            EQU     10000001H
VDD_IOCTL_GET_DDHAL             EQU     10000002H
VDD_IOCTL_COPY_PROTECTION       EQU     10000003H
VDD_IOCTL_I2C_OPEN              EQU     10000004H
VDD_IOCTL_I2C_ACCESS            EQU     10000005H

tagVDD_IOCTL_SET_NOTIFY_INPUT   STRUC
        NotifyMask      DD      ?
        NotifyType      DD      ?
        NotifyProc      DD      ?
        NotifyData      DD      ?
tagVDD_IOCTL_SET_NOTIFY_INPUT   ENDS

VDD_NOTIFY_START_MODE_CHANGE    EQU     00000001H
VDD_NOTIFY_END_MODE_CHANGE      EQU     00000002H
VDD_NOTIFY_ENABLE               EQU     00000004H
VDD_NOTIFY_DISABLE              EQU     00000008H
VDD_NOTIFY_TYPE_CALLBACK        EQU     1
BYTE_LENGTHED                   EQU     1
WORD_LENGTHED                   EQU     2
GOING_TO_WINDOWS_MODE           EQU     1
GOING_TO_VGA_MODE               EQU     2
DISPLAY_DRIVER_DISABLED         EQU     4
IN_WINDOWS_HIRES_MODE           EQU     8

DISPLAYINFO     STRUC
        diHdrSize               DW      ?
        diInfoFlags             DW      ?
        diDevNodeHandle         DD      ?
        diDriverName            DB      16 DUP (?)
        diXRes                  DW      ?
        diYRes                  DW      ?
        diDPI                   DW      ?
        diPlanes                DB      ?
        diBpp                   DB      ?
        diRefreshRateMax        DW      ?
        diRefreshRateMin        DW      ?
        diLowHorz               DW      ?
        diHighHorz              DW      ?
        diLowVert               DW      ?
        diHighVert              DW      ?
        diMonitorDevNodeHandle  DD      ?
        diHorzSyncPolarity      DB      ?
        diVertSyncPolarity      DB      ?
        diUnitNumber            DD      ?
        diDisplayFlags          DD      ?
        diXDesktopPos           DD      ?
        diYDesktopPos           DD      ?
        diXDesktopSize          DD      ?
        diYDesktopSize          DD      ?
DISPLAYINFO     ENDS

DISPLAYINFO_SIZE                equ     diRefreshRateMax+2-diHdrSize
DISPLAYINFO_SIZE1               equ     diBpp+1-diHdrSize
DISPLAYINFO_SIZE2               equ     diVertSyncPolarity+1-diHdrSize
DISPLAYINFO_SIZE3               equ     diMemorySize+4-diHdrSize

RETURNED_DATA_IS_STALE          EQU     0001H
MINIVDD_FAILED_TO_LOAD          EQU     0002H
MINIVDD_CHIP_ID_DIDNT_MATCH     EQU     0004H
REGISTRY_BPP_NOT_VALID          EQU     0008H
REGISTRY_RESOLUTION_NOT_VALID   EQU     0010H
REGISTRY_DPI_NOT_VALID          EQU     0020H
MONITOR_DEVNODE_NOT_ACTIVE      EQU     0040H
MONITOR_INFO_NOT_VALID          EQU     0080H
MONITOR_INFO_DISABLED_BY_USER   EQU     0100H
REFRESH_RATE_MAX_ONLY           EQU     0200H
CARD_VDD_LOADED_OK              EQU     0400H
DEVICE_IS_NOT_VGA               EQU     0800H
NoTrace_VIRTUALIZE_CRTC_IN      EQU     1
NoTrace_VIRTUALIZE_CRTC_OUT     EQU     1
NoTrace_VIRTUALIZE_SEQUENCER_IN EQU     1
NoTrace_VIRTUALIZE_SEQUENCER_OUT EQU    1
NoTrace_VIRTUALIZE_GCR_IN       EQU     1
NoTrace_VIRTUALIZE_GCR_OUT      EQU     1
NoTrace_VIRTUALIZE_DAC_OUT      EQU     1
NoTrace_VIRTUALIZE_DAC_IN       EQU     1
NoTrace_CHECK_HIRES_MODE        EQU     1

ifdef NEC_98

                            
vFlg_Machine_Std                equ                     00000001b
vFlg_Machine_Multi              equ                     00000010b
vFlg_Machine_Mate               equ                     00000100b
vFlg_Machine_H98                equ                     00001000b
vFlg_CRT_New                    equ                     00010000b
vFlg_CRT_NonInter               equ                     00100000b
vFlg_GDC_5MHz                   equ                     01000000b
vFlg_GDC_Emulate                equ                     10000000b
vFlg_Acc_Internal               equ             0000000100000000b
vFlg_Acc_External               equ             0000001000000000b
vFlg_Acc_PCI                    equ             0000010000000000b
vFlg_Acc_ML                     equ             0000100000000000b
vFlg_Acc_PVD                    equ             0001000000000000b
vFlg_Mode_NH                    equ             0010000000000000b
vFlg_Mode_H                     equ             0100000000000000b
vFlg_Initialized                equ             1000000000000000b
vFlg_Opt_MFR                    equ     000000010000000000000000b
vFlg_Opt_NewMFR                 equ     000000100000000000000000b
vFlg_Opt_VDP                    equ     000001000000000000000000b
vFlg_Opt_NewVDP                 equ     000010000000000000000000b

vFlg_Local                      equ     000000000100000010000000b


MaxMiniVDD                      equ     16
MaxMiniTrap                     equ     32
MaxMultiTrap                    equ     3
MaxMultiFunc                    equ     MaxMiniVDD





LT_Enable                       equ     00000001b
LT_Enable_bit                   equ     0
LT_Initialized                  equ     10000000b
LT_Initialized_bit              equ     7



Vids_struct struc



        Vids_SFlags             dd      ?
        Vids_CB_Offset          dd      ?
        Vids_Msg_Pseudo_VM      dd      ?




        VDD_TGDC_Draw_Off       dd      ?
        VDD_TGDC_Sync_Off       dd      ?
        VDD_TGDC_Sync_On        dd      ?
        VDD_TGDC_FIFO_Empty     dd      ?
        VDD_GGDC_Draw_Off       dd      ?
        VDD_GGDC_Sync_Off       dd      ?
        VDD_GGDC_Sync_On        dd      ?
        VDD_GGDC_FIFO_Empty     dd      ?
        VDD_GGDC_MOD_Emulate    dd      ?




        H98_FLORA_Change        dd      ?
        H98_Clear_Text          dd      ?
        H98_Rest_GCs            dd      ?
        H98_Rest_etc            dd      ?
        H98_Save_ModeFF         dd      ?

Vids_struct ends


Vid_SFlags                      equ     <Vids.Vids_SFlags>
VDD_CB_Offset                   equ     <Vids.Vids_CB_Offset>
VDD_Msg_Pseudo_VM               equ     <Vids.Vids_Msg_Pseudo_VM>

TGDC_Draw_Off                   equ     <Vids.VDD_TGDC_Draw_Off>
GGDC_Draw_Off                   equ     <Vids.VDD_GGDC_Draw_Off>
TGDC_Sync_On                    equ     <Vids.VDD_TGDC_Sync_On>
TGDC_Sync_Off                   equ     <Vids.VDD_TGDC_Sync_Off>
TGDC_FIFO_Empty                 equ     <Vids.VDD_TGDC_FIFO_Empty>
GGDC_FIFO_Empty                 equ     <Vids.VDD_GGDC_FIFO_Empty>





MiniFuncStruct  STRUC
        MF_ProcAddr             dd      ?
MiniFuncStruct  ENDS


MiniVDD_Proc_Struct     STRUC
        Proc_Address            dd      ?
        Proc_Order              dw      ?
        Proc_MiniID             db      ?
        Proc_Flags              db      ?
MiniVDD_Proc_Struct     ENDS

.errnz  (size MiniVDD_Proc_Struct) mod 4





MiniVDD_GTrap_Struct    STRUC
        GTrap_ProcAddr          dd      ?
        GTrap_PortAddr          dw      ?
        GTrap_NumMini           dw      ?
        GTrap_ProcTable         db      ((size MiniVDD_Proc_Struct) * MaxMultiTrap) dup (?)
MiniVDD_GTrap_Struct    ENDS

MiniVDD_LTrap_Struct    STRUC
        LTrap_ProcAddr          dd      ?
        LTrap_Status            db      ?
        LTrap_Flags             db      MaxMultiTrap dup (?)
MiniVDD_LTrap_Struct    ENDS




EndMiniFunc_    MACRO   n
ifdef   MiniFunc&n
        dd      OFFSET32 MiniFunc&n
else
        dd      0
endif
                ENDM

MiniFunc_       MACRO   FuncID, FuncName
                MiniFunc&FuncID equ <FuncName>
                ENDM

BeginMiniFunc   MACRO   TableName
public  TableName
TableName       label   near
                ENDM

if 1
EndMiniFunc     MACRO   TableName
                x = 0
                REPT    NBR_MINI_VDD_FUNCTIONS_41
                EndMiniFunc_    %x
                x = x + 1
                ENDM
                ENDM
else
EndMiniFunc     MACRO   TableName
                x = 0
                REPT    NBR_MINI_VDD_FUNCTIONS
                EndMiniFunc_    %x
                x = x + 1
                ENDM
                ENDM
endif

MiniFunc        MACRO   FuncID, FuncName
                MiniFunc_ %(FuncID), <FuncName>
                ENDM




MiniVDDCall     MACRO   FuncID, SetCarry
                local   MiniCall_Loop
                local   MiniCall_Exit

                push    ecx
                push    esi
                lea     esi, [MiniVDD_Func_Table][(size MiniVDD_Proc_Struct) * MaxMultiFunc * FuncID]
                mov     ecx, [MiniVDD_NumMini]
MiniCall_Loop:
                cmp     dword ptr [esi.Proc_Address], 0
                jz      MiniCall_Exit
                pushad
ifnb <SetCarry>
                stc
endif
                call    dword ptr [esi.Proc_Address]
                popad
                jc      MiniCall_Exit
                add     esi, size MiniVDD_Proc_Struct
                loop    MiniCall_Loop
MiniCall_Exit:
                pop     esi
                pop     ecx
                ENDM



MiniVDDCall2    MACRO   FuncID, SetCarry
                local   MiniCall_Exit
                local   MiniCall_Proc

                push    ecx
                push    esi
                lea     esi, [MiniVDD_Func_Table][(size MiniVDD_Proc_Struct) * MaxMultiFunc * FuncID]
MiniCall_Proc:
                cmp     dword ptr [esi.Proc_Address], 0
                jz      MiniCall_Exit
                pushad
ifnb <SetCarry>
                stc
endif
                call    dword ptr [esi.Proc_Address]
                popad
MiniCall_Exit:
                pop     esi
                pop     ecx
                ENDM



MiniVDDCall3    MACRO   FuncID, MiniID, SetCarry
                local   MiniCall_Exit
                local   MiniCall_Loop
                local   MiniCall_Proc

                push    ecx
                push    esi
                lea     esi, [MiniVDD_Func_Table][(size MiniVDD_Proc_Struct) * MaxMultiFunc * FuncID]
                movzx   ecx, MiniID
MiniCall_Loop:
                cmp     ecx, 0
                jz      MiniCall_Proc
                add     esi, size MiniVDD_Proc_Struct
                dec     ecx
                jmp     MiniCall_Loop
MiniCall_Proc:
                cmp     dword ptr [esi.Proc_Address], 0
                jz      MiniCall_Exit
                pushad
ifnb <SetCarry>
                stc
endif
                call    dword ptr [esi.Proc_Address]
                popad
MiniCall_Exit:
                pop     esi
                pop     ecx
                ENDM




MiniVDDFunc     MACRO   TmpReg, FuncID
                mov     TmpReg, [MiniVDD_Func_Table.Proc_Address][(size MiniVDD_Proc_Struct) * MaxMultiFunc * FuncID]
                ENDM











ExecModeLL      macro   Num
ExecMode_L&Num:
                endm

ExecModeLE      macro   Num
ExecMode_E&Num:
                endm

ExecModeJE      macro   Num
        jmp     ExecMode_E&Num
                endm

ExecModeJZ      macro   Num
        jz      ExecMode_L&Num
                endm

ExecModeJNZ     macro   Num
        jnz     ExecMode_L&Num
                endm

ExecModeJEZ     macro   Num
        jz      ExecMode_E&Num
                endm

ExecModeJENZ    macro   Num
        jnz     ExecMode_E&Num
                endm


ExecModeTest    macro   ModeFlag, CB_Reg
if      ModeFlag and vFlg_Local
ifidni  <CB_Reg>, <Vid>
        push    ebx
        mov     ebx, [Vid_VM_Handle]
        add     ebx, [VDD_CB_Offset]
        test    [ebx.VDD_SFlags], ModeFlag
        pop     ebx
else
ifidni  <CB_Reg>, <Cur>
        push    ebx
        VMMCall Get_Cur_VM_Handle
        add     ebx, [VDD_CB_Offset]
        test    [ebx.VDD_SFlags], ModeFlag
        pop     ebx
else
ifb     <CB_Reg>
        push    ebx
        add     ebx, [VDD_CB_Offset]
        test    [ebx.VDD_SFlags], ModeFlag
        pop     ebx
else
        test    [CB_Reg.VDD_SFlags], ModeFlag
endif
endif
endif
else
        test    [Vid_SFlags], ModeFlag
endif
        endm


ExecModeChk     macro   HdrFlag, JmpFlag, JmpLabel, ModeFlag, CB_Reg
ifidni  <HdrFlag>, <Jmp>
.erre   FlgExecMode
        ExecModeJE      %EndExecMode
endif
ExecModeLL      %NumExecMode
NumExecMode = NumExecMode + 1
FlgExecMode = 1
ifnb    <ModeFlag>
        ExecModeTest    <ModeFlag>, <CB_Reg>
ifidni  <JmpLabel>, <End>
ifidni  <JmpFlag>, <Not>
        ExecModeJENZ    %EndExecMode
else
        ExecModeJEZ     %EndExecMode
endif
else
ifidni  <JmpFlag>, <Not>
        ExecModeJNZ     %NumExecMode
else
        ExecModeJZ      %NumExecMode
endif
endif
endif
                endm

ExecModeEnd     macro
ExecModeLL      %NumExecMode
ExecModeLE      %EndExecMode
NumExecMode = NumExecMode + 1
EndExecMode = EndExecMode + 1
FlgExecMode = 0
                endm





ExecModeJmp     macro   JmpLabel, ModeFlag, CB_Reg
        ExecModeTest    %ModeFlag, <CB_Reg>
        jnz     JmpLabel
                endm

ExecModeJmpNot  macro   JmpLabel, ModeFlag, CB_Reg
        ExecModeTest    %ModeFlag, <CB_Reg>
        jz      JmpLabel
                endm

ExecMode        macro   ModeFlag, CB_Reg
        ExecModeChk Top, Equ, Next, %ModeFlag, CB_Reg
                endm

ExecModeNot     macro   ModeFlag, CB_Reg
        ExecModeChk Top, Not, Next, %ModeFlag, CB_Reg
                endm

ExecModeOnly    macro   ModeFlag, CB_Reg
        ExecModeChk Top, Equ, End, %ModeFlag, CB_Reg
                endm

ExecModeOnlyNot macro   ModeFlag, CB_Reg
        ExecModeChk Top, Not, End, %ModeFlag, CB_Reg
                endm

ExecModeElse    macro   ModeFlag, CB_Reg
        ExecModeChk Jmp, Equ, Next, %ModeFlag, CB_Reg
                endm

ExecModeElseNot macro   ModeFlag, CB_Reg
        ExecModeChk Jmp, Not, Next, %ModeFlag, CB_Reg
                endm

ExecModeThru    macro   ModeFlag, CB_Reg
        ExecModeChk Thru, Equ, Next, %ModeFlag, CB_Reg
                endm

ExecModeThruNot macro   ModeFlag, CB_Reg
        ExecModeChk Thru, Not, Next, %ModeFlag, CB_Reg
                endm

NumExecMode = 1
EndExecMode = 1
FlgExecMode = 0

else




ifdef MAINVDD
externdef       MiniVDDDispatchTable:dword
endif


MiniVDDDispatch         macro   FunctionCode, HandlerAddr
        mov     [edi+(FunctionCode*4)],OFFSET32 MiniVDD_&HandlerAddr
endm


CardVDDDispatch         macro   FunctionCode, HandlerAddr
        mov     [edi+(FunctionCode*4)],OFFSET32 CardVDD_&HandlerAddr
endm


MiniVDDCall             macro   FunctionCode, SaveFlags
local   MiniVDDCallExit, MiniVDDCallLeave

ifdef MAXDEBUG
  ifndef NoTrace_&FunctionCode&
        Trace_Out "MiniVDDCall: &FunctionCode&"
  endif
endif
        push    edi
ifnb    <SaveFlags>
        pushfd
endif
        mov     edi,OFFSET32 MiniVDDDispatchTable
        cmp     dword ptr [edi+(FunctionCode*4)],0
        je      MiniVDDCallLeave
ifnb    <SaveFlags>
        popfd
endif
        call    dword ptr [edi+(FunctionCode*4)]
ifnb    <SaveFlags>
        jmp     MiniVDDCallExit
endif

MiniVDDCallLeave:
ifnb    <SaveFlags>
        popfd
endif

MiniVDDCallExit:
        pop     edi
endm
endif

endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\INCLUDE\SYSDATA.H ===
/*=============================================================================

    Copyright (C) 1997, NVidia Coporation

    File:       sysdata.h

    Purpose:    This file holds structures and equates dealing with the
                pdevice.

=============================================================================*/

typedef unsigned char   UCHAR;
typedef unsigned short  USHORT;
typedef unsigned long   ULONG;

// ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
typedef struct _tagDIBHEADER
{
    ULONG       biSize;
    ULONG       biWidth;
    ULONG       biHeight;
    USHORT      biPlanes;
    USHORT      biBitCount;
    ULONG       biCompression;
    ULONG       biSizeImage;
    ULONG       biXPelsPerMeter;
    ULONG       biYPelsPerMeter;
    ULONG       biClrUsed;
    ULONG       biClrImportant;
}   DIBHEADER;
// ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


// ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
// This structure is similar to what is defined in dibeng.inc.
// The differences are we use the reserved field for a few things.
// Hence this is essentially the DIBENGINE structure with
// different names for the modified fields.
typedef struct  _tagDIBENGINEHDR
{
    USHORT      deType;
    USHORT      deWidth;
    USHORT      deHeight;
    USHORT      deWidthBytes;
    UCHAR       dePlanes;
    UCHAR       deBitsPixel;
    ULONG       deReserved1;            // cannot be used. (bug #32933)
    ULONG       deDeltaScan;
    ULONG       delpPDevice;
    ULONG       deBitsOffset;
    USHORT      deBitsSelector;
    USHORT      deFlags;
    USHORT      deVersion;
    ULONG       deBitmapInfo;
    ULONG       deBeginAccess;
    ULONG       deEndAccess;

    // We're using this field to store the three fields that follow. In
    // multi-mon mode, we do not get the opportunity to create the bitmap
    // header so we can not increase the size.
//    ULONG       deDriverReserved;

    // This field should be filled in with the same value as is in the
    // deBitsPixel field except when the display driver is running
    // 15bpp. In this case, the deBitsPixel field will have 16 in it
    // and the bRealBpp field will have 15 in it.
    UCHAR       bRealBpp;

    // Reserved fields
    UCHAR       bTemp1;
    USHORT      wTemp2;
}   DIBENGINEHDR;
// ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


// ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
// This structure is passed into ValidateMode
typedef struct  _tagMYDISPVALMODE
{
    USHORT  dvmSize;
    USHORT  dvmBpp;
    USHORT  dvmXRes;
    USHORT  dvmYRes;
}   MYDISPVALMODE;

#define MYVALMODE_YES           0
#define MYVALMODE_NO_WRONGDRV   1
#define MYVALMODE_NO_NOMEM      2
#define MYVALMODE_NO_NODAC      3
#define MYVALMODE_NO_UNKNOWN    4
// ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


// ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
// This structure is returned by a call to VddGetDisplayInfo
typedef struct _tagDISPLAYINFO
{
    USHORT  diHdrSize;
    USHORT  diInfoFlags;

    ULONG   diDevNodeHandle;
    UCHAR   diDriverName[16];
    USHORT  diXRes;
    USHORT  diYRes;
    USHORT  diDPI;
    UCHAR   diPlanes;
    UCHAR   diBpp;
    USHORT  diRefreshRateMax;
    USHORT  diRefreshRateMin;
    USHORT  diLowHorz;
    USHORT  diHighHorz;
    USHORT  diLowVert;
    USHORT  diHighVert;
    ULONG   diMonitorDevNodeHandle;
    UCHAR   diHorzSyncPolarity;
    UCHAR   diVertSyncPolarity;

    // Only for Windows 98
    ULONG   diUnitNumber;             // device unit number
    ULONG   diDisplayFlags;           // mode specific flags
    ULONG   diXDesktopPos;            // position of desktop
    ULONG   diYDesktopPos;            // ...
    ULONG   diXDesktopSize;           // size of desktop (for panning)
    ULONG   diYDesktopSize;           // ...

    USHORT  wJimKellerRoundToDwordSize; // Solely to make the structure
                                        // size a multiple of a dword.
}   MYDISPLAYINFO;
// ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


// ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
// These are some DirectDraw Init structures that get passed into the
// display driver.
typedef struct  _tagMYDDHALDDRAWFNS
{
    ULONG       dwSize;
    ULONG       lpSetInfo;
    ULONG       lpVidMemAlloc;
    ULONG       lpVidMemFree;
}   MYDDHALDDRAWFNS;

typedef struct _MYDCICMD
{
    ULONG   dwCommand;
    ULONG   dwParam1;
    ULONG   dwParam2;
    ULONG   dwVersion;
    ULONG   dwReserved;
} MYDCICMD;

typedef struct
{
    UCHAR   szName[260];            // 32-bit driver name
    UCHAR   szEntryPoint[64];       // entry point
    ULONG   dwContext;              // context to pass to entry point
} MYDD32BITDRIVERDATA;

typedef struct
{
    ULONG   dwHALVersion;           // Version of DirectDraw for which the
                                    //   HAL was created
    ULONG   dwReserved1;            // Reserved for future use
    ULONG   dwReserved2;            // Reserved for future use
} MYDDVERSIONDATA;

#define DDNVCREATEDRIVEROBJECT  98
#define DDNVDESTROYDRIVEROBJECT 99
// ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


// ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
// A few others things
typedef struct  _MYRECTL
{
    ULONG       dwLeft;
    ULONG       dwTop;
    ULONG       dwRight;
    ULONG       dwBottom;
}   MYRECTL;
// ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


///////////////////////////////////////////////////////////////////////
// Cursor information
#define CURSOR_SIZE     0x20        // 32x32 cursors
#define CURSOR_WIDTH    CURSOR_SIZE
#define CURSOR_HEIGHT   CURSOR_SIZE
#define AND_MASK_SIZE   ((CURSOR_WIDTH * CURSOR_HEIGHT) / 8)

// Not a true structure since bCursorXorMask is actually a variable
// length array, but this is good enough.
typedef struct  _tagCURSORDESC
{
    USHORT      wHotX;
    USHORT      wHotY;
    USHORT      wWidth;
    USHORT      wHeight;
    USHORT      wWidthBytes;
    UCHAR       bPlanes;
    UCHAR       bBitsPerPixel;
    UCHAR       bCursorAndMask[AND_MASK_SIZE];
    UCHAR       bCursorXorMask;
}   CURSORDESC;
///////////////////////////////////////////////////////////////////////

// Not a true structure since bCursorXorMask is actually a variable
// length array, but this is good enough.
typedef struct  _tagCURSORHEADER
{
    USHORT      wHotX;
    USHORT      wHotY;
    USHORT      wWidth;
    USHORT      wHeight;
    USHORT      wWidthBytes;
    UCHAR       bPlanes;
    UCHAR       bBitsPerPixel;
}   CURSORHEADER;
///////////////////////////////////////////////////////////////////////

typedef struct  _tagMODULELINK
{
    ULONG       lpfnFunc;
    USHORT      wOrdinal;
}   MODULELINK;
///////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////
// Since we don't know whether we will be running on a wide OS or not,
// we will need to define both.
typedef struct _OSVERSIONINFOW
{
    ULONG   dwOSVersionInfoSize;
    ULONG   dwMajorVersion;
    ULONG   dwMinorVersion;
    ULONG   dwBuildNumber;
    ULONG   dwPlatformId;
    USHORT  szCSDVersion[128];
}   OSVERSIONINFOW;

typedef struct _OSVERSIONINFOA
{
    ULONG   dwOSVersionInfoSize;
    ULONG   dwMajorVersion;
    ULONG   dwMinorVersion;
    ULONG   dwBuildNumber;
    ULONG   dwPlatformId;
    UCHAR   szCSDVersion[128];
}   OSVERSIONINFOA;
///////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////
#define MAX_ATTACHED_CRTCS      2
///////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\ddraw\nv4\blt32.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995,1997 NVidia Corporation.  All Rights Reserved.
 *
 *  File:       Nv4Blt32.c
 *  Content:    Windows95 DirectDraw 32 bit driver
 *
 ***************************************************************************/
#include "nvprecomp.h"
#include "nvalpha.h"
#include "ddminint.h"
#include "nv32.h"

#include "nvos.h"
#include "nvntioctl.h"
#include "nvntddctl.h"
#include "nvapi.h"
#include "nvsubch.h"

#define NvGetFreeCount(NN, CH)\
                 (NN)->subchannel[CH].control.Free
/*
 * Nv4Blt32
 *
 * NV4 Blt function for 32bpp surfaces.
 */
DWORD __stdcall Nv4Blt32( PDD_BLTDATA pbd )
    {
    FAST Nv3ChannelPio *npDev;
    FAST USHORT freeCount;
    DWORD       dwFlags;
    DWORD       dwDDFX = 0;
    DWORD       dwDstCaps;
    DWORD       dwSrcCaps;
    DWORD       dwRop;
    NVCOORD     wXYext;
    NVCOORD     wDestXY;
    NVCOORD     wSrcXY;
    BYTE        wStretch = 0;
    BYTE        doMirrorUpDown = 0;
    BYTE        isVideo = 0;
//    BYTE        doAlpha = 0;

    DWORD       dwFillColor;
    DWORD       dwColorKey;

    DWORD       dwDstOffset;
    DWORD       dwDstPitch;
    DWORD       dwDstWidth;
    DWORD       dwDstHeight;

    DWORD       dwSrcOffset;
    DWORD       dwSrcPitch;
    DWORD       dwSrcWidth;
    DWORD       dwSrcHeight;

    PDD_SURFACE_LOCAL  srcx;
    PDD_SURFACE_LOCAL  dstx;
    PDD_SURFACE_GLOBAL  src;
    PDD_SURFACE_GLOBAL  dst;
    PDEV    *ppdev;

    dstx = pbd->lpDDDestSurface;
    dst = dstx->lpGbl;
    ppdev = (PDEV *) pbd->lpDD->dhpdev;

    /*
     * NOTES:
     *
     * Everything you need is in pdb->bltFX .
     * Look at pdb->dwFlags to determine what kind of blt you are doing,
     * DDBLT_xxxx are the flags.
     *
     * ALPHA NOTES:
     *
     * Alpha ALWAYS comes in BLTFX.   You don't need to go looking for
     * the attached surface. If DDBLT_ALPHA is specified, then either a
     * constant alpha or alpha surface has been specified. Just look for
     * DDBLT_ALPHASURFACEOVERRIDE or DDBLT_ALPHACONSTANTOVERRIDE
     *
     * Look for DDBLT_ALPHASURFACEDESTRECT to use the destination rectangle
     * for choosing the rectangle in the alpha surface.   Otherwise use the
     * source rectangle.
     *
     * Z BUFFER NOTES:
     *
     * ZBuffer ALWAYS comes in BLTFX.   You don't need to go looking for
     * the attached surface. If DDBLT_ZBUFFER is specified, then either a
     * constant z or z buffer surface has been specified for the source and
     * destination. Just look for the DDBLT_ZBUFFERDESTOVERRIDE,
     * DDBLT_ZBUFFERSRCOVERRIDE, DDBLT_ZBUFFERCONSTANTDESTOVERRIDE, or
     * DDBLT_ZBUFFERCONSTANTSRCOVERRIDE.
     *
     * COLORKEY NOTES:
     *
     * ColorKey ALWAY comes in BLTFX.   You don't have to look it up in
     * the surface.
     */


    dwFlags   = pbd->dwFlags;
    dwDstCaps = dstx->ddsCaps.dwCaps;

    if (dwFlags & DDBLT_DDFX)
        dwDDFX = pbd->bltFX.dwDDFX;

//    if (dwFlags & DDOVER_ANYALPHA) {
//        DPF("Overlay Alpha failed");
//        pbd->ddRVal = DDERR_NOOVERLAYHW;
//        return DDHAL_DRIVER_HANDLED;
//    }

//    if (dwFlags & DDBLT_ANYALPHA) {
//        DPF("Alpha requested");
//        if ((dwFlags & DDBLT_ALPHASRCCONSTOVERRIDE) == 0) {
//            pbd->ddRVal = DDERR_NOALPHAHW;
//            return DDHAL_DRIVER_HANDLED;
//        } else
//            doAlpha = 1;
//    }

    if (dwFlags & (DDBLT_KEYDEST | DDBLT_KEYDESTOVERRIDE))
        {
        DPF("Dest color key failed");
        pbd->ddRVal = DDERR_NOCOLORKEYHW;
        return DDHAL_DRIVER_HANDLED;
        }


    /*
     * get offset, width, and height for destination
     */
    dwDstOffset = dst->fpVidMem;
    dwDstPitch  = dst->lPitch;
    dwDstWidth  = pbd->rDest.right  - pbd->rDest.left;
    dwDstHeight = pbd->rDest.bottom - pbd->rDest.top;
    wXYext.wh16.w = (unsigned short)dwDstWidth;
    wXYext.wh16.h = (unsigned short)dwDstHeight;

    wDestXY.xy16.x = (short)pbd->rDest.left;
    wDestXY.xy16.y = (short)pbd->rDest.top;

    if (dwDstCaps & (DDSCAPS_SYSTEMMEMORY | DDSCAPS_TEXTURE | DDSCAPS_NONLOCALVIDMEM))
        return DDHAL_DRIVER_NOTHANDLED;

    npDev = (Nv3ChannelPio*)ppdev->pjMmBase;

    if (npDev == NULL)
        {
        pbd->ddRVal = DDERR_SURFACELOST;
        return DDHAL_DRIVER_HANDLED;
        }

    freeCount = ppdev->NVFreeCount;

    /*
     * If async, then only work if bltter isn't busy
     * This should probably be a little more specific to each call, but
     * waiting for 32 is pretty close
     */
    if ( dwFlags & DDBLT_ASYNC )
        {
        if (freeCount < 32)
            freeCount = NvGetFreeCount(npDev, NV_DD_ROP);

        if ( freeCount < 32 )
            {
            DPF("ASYNC FAILED");
            pbd->ddRVal = DDERR_WASSTILLDRAWING;
            ppdev->NVFreeCount = freeCount;
            return DDHAL_DRIVER_HANDLED;
            }
        }

    if (dwFlags & DDBLT_ROP)
        {

        dwRop = pbd->bltFX.dwROP >> 16;

        if ((dwRop == BLACKNESSINDEX) || (dwRop == WHITENESSINDEX))
            {
            ppdev->NVFreeCount = freeCount;
            DDRAW_SET_PRIMARY(ppdev, dwDstOffset, dwDstPitch);
            freeCount = ppdev->NVFreeCount;

            while (freeCount < 4*4)
                freeCount = NvGetFreeCount(npDev, NV_DD_ROP);
            freeCount -= 4*4;

            npDev->dDrawRop.SetRop5 = dwRop;
            npDev->subchannel[NV_DD_RECT_AND_TEXT].Nv04GdiRectangleText.Color1A = 0;

            npDev->subchannel[NV_DD_RECT_AND_TEXT].Nv04GdiRectangleText.UnclippedRectangle[0].point =
            asmMergeCoords(wDestXY.xy16.y, wDestXY.xy16.x);

            npDev->subchannel[NV_DD_RECT_AND_TEXT].Nv04GdiRectangleText.UnclippedRectangle[0].size =
            asmMergeCoords(wXYext.wh16.h, wXYext.wh16.w);
            }
        else if ((dwRop == PATCOPYINDEX) || (dwRop == PATINVERTINDEX))
            {

            dwFillColor = (pbd->bltFX.dwFillColor & ppdev->physicalColorMask) | ppdev->AlphaEnableValue;

            if (dwRop == PATCOPYINDEX)
                dwRop = SRCCOPYINDEX;
            else if (dwRop == PATINVERTINDEX)
                dwRop = SRCINVERTINDEX;


            ppdev->NVFreeCount = freeCount;
            DDRAW_SET_PRIMARY(ppdev, dwDstOffset, dwDstPitch);
            freeCount = ppdev->NVFreeCount;

            while (freeCount < 4*4)
                freeCount = NvGetFreeCount(npDev, NV_DD_ROP);
            freeCount -= 4*4;

            npDev->subchannel[NV_DD_RECT_AND_TEXT].Nv04GdiRectangleText.Color1A = dwFillColor;
            npDev->dDrawRop.SetRop5 = dwRop;
            npDev->subchannel[NV_DD_RECT_AND_TEXT].Nv04GdiRectangleText.UnclippedRectangle[0].point =
            asmMergeCoords(wDestXY.xy16.y, wDestXY.xy16.x);

            npDev->subchannel[NV_DD_RECT_AND_TEXT].Nv04GdiRectangleText.UnclippedRectangle[0].size =
            asmMergeCoords(wXYext.wh16.h, wXYext.wh16.w);

            }
        else if ((dwRop == SRCCOPYINDEX) || (dwRop == SRCPAINTINDEX) ||
                 (dwRop == SRCANDINDEX) || (dwRop == NOTSRCCOPYINDEX) ||
                 (dwRop == SRCINVERTINDEX) || (dwRop == MERGEPAINTINDEX) ||
                 (dwRop == SRCERASEINDEX) || (dwRop == NOTSRCERASEINDEX))
            {

            srcx = pbd->lpDDSrcSurface;
            src = srcx->lpGbl;

            dwSrcCaps = srcx->ddsCaps.dwCaps;

            /* We must treat AGP source memory as system memory */
            if (dwSrcCaps & DDSCAPS_NONLOCALVIDMEM)
                {
                dwSrcCaps &= ~(DDSCAPS_VIDEOMEMORY | DDSCAPS_NONLOCALVIDMEM);
                }

            dwSrcOffset = src->fpVidMem;
            dwSrcPitch  = src->lPitch;
            dwSrcWidth  = pbd->rSrc.right  - pbd->rSrc.left;
            dwSrcHeight = pbd->rSrc.bottom - pbd->rSrc.top;
            dwColorKey  = pbd->bltFX.ddckSrcColorkey.dwColorSpaceLowValue;

            wSrcXY.xy16.x = (short)pbd->rSrc.left;
            wSrcXY.xy16.y = (short)pbd->rSrc.top;

            if (//(srcx->dwFlags & DDRAWISURF_HASPIXELFORMAT) &&
                (src->ddpfSurface.dwFlags & DDPF_FOURCC))
                {

                if (src->ddpfSurface.dwFourCC == FOURCC_RGB0)
                    {
                    if ((src->ddpfSurface.dwRBitMask == 0x00FF0000) &&
                        (src->ddpfSurface.dwGBitMask == 0x0000FF00) &&
                        (src->ddpfSurface.dwBBitMask == 0x000000FF))
                        {
                        if (dwSrcCaps & DDSCAPS_SYSTEMMEMORY)
                            isVideo = 1;
                        goto srcRGB;
                        }
                    else
                        {
                        pbd->ddRVal = DDERR_UNSUPPORTEDFORMAT;
                        ppdev->NVFreeCount = freeCount;
                        return DDHAL_DRIVER_HANDLED;
                        }
                    }

                while (freeCount < 4 )
                    freeCount = NvGetFreeCount(npDev, NV_DD_ROP);
                freeCount -= 4;

                npDev->dDrawRop.SetRop5 = SRCCOPYINDEX;

                ppdev->NVFreeCount = freeCount;

                DDRAW_SET_SOURCE(ppdev, dwSrcOffset, dwSrcPitch);
                DDRAW_SET_PRIMARY(ppdev, dwDstOffset, dwDstPitch);

                freeCount = ppdev->NVFreeCount;

                switch (src->ddpfSurface.dwFourCC)
                    {
                    case FOURCC_YUY2:
                    case FOURCC_UYVY:

//                     if (dwSrcWidth & 1) {  NEC MPEG CODEC DOESN'T RESPOND TO THIS ERROR
//                           pbd->ddRVal = DDERR_INVALIDRECT;
//                           return DDHAL_DRIVER_HANDLED;
//                       }

                        if (wSrcXY.xy16.x & 1)
                            {
                            pbd->ddRVal = DDERR_INVALIDRECT;
                            ppdev->NVFreeCount = freeCount;
                            return DDHAL_DRIVER_HANDLED;
                            }

                        if (src->ddpfSurface.dwFourCC == FOURCC_UYVY)
                            {
                            isVideo = 2;
                            // Is this surface DMAable ?
                            if ((ppdev->fNvActiveFloatingContexts &
                                 NV_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY) &&
                                (ppdev->NvFloating0UYVYSurfaceMem == src->fpVidMem))
                                isVideo = 4;
                            else if ((ppdev->fNvActiveFloatingContexts &
                                      NV_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY) &&
                                     (ppdev->NvFloating1UYVYSurfaceMem == src->fpVidMem))
                                isVideo = 5;
                            }
                        else
                            { // YUY2
                            isVideo = 3;
                            // Is this surface DMAable ?
                            if ((ppdev->fNvActiveFloatingContexts &
                                 NV_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY) &&
                                (ppdev->NvFloating0YUYVSurfaceMem == src->fpVidMem))
                                isVideo = 6;
                            else if ((ppdev->fNvActiveFloatingContexts &
                                      NV_FLOATING1_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY) &&
                                     (ppdev->NvFloating1YUYVSurfaceMem == src->fpVidMem))
                                isVideo = 7;
                            }
                        goto srcRGB;
                        break;
#ifdef YV12_SUPPORT
                    case FOURCC_YV12:
                        // Size has to be always * 4, to use VU subsampling
                        if ((dwSrcWidth & 3) || (dwSrcHeight & 3))
                            {
                            pbd->ddRVal = DDERR_INVALIDRECT;
                            ppdev->NVFreeCount = freeCount;
                            return DDHAL_DRIVER_HANDLED;
                            }

//                     pbd->ddRVal = nvStretchYVU12ToDev (pbd, src->ddpfSurface.dwFourCC);
                        ppdev->NVFreeCount = freeCount;
                        return DDHAL_DRIVER_HANDLED;
                        break;
#endif // #ifdef YV12_SUPPORT
                    }
                pbd->ddRVal = DDERR_UNSUPPORTEDFORMAT;
                ppdev->NVFreeCount = freeCount;
                return DDHAL_DRIVER_HANDLED;
                }

            srcRGB:     if (dwDDFX & DDBLTFX_MIRRORUPDOWN)
                doMirrorUpDown = 1;

            if ((dwSrcWidth != dwDstWidth) || (dwSrcHeight != dwDstHeight))
                wStretch = 1;

            if (isVideo > 1) /* YUV video */
                wStretch = 1;

            if (dwFlags & DDBLT_KEYSRCOVERRIDE)
                {

                dwColorKey = pbd->bltFX.ddckSrcColorkey.dwColorSpaceLowValue;

                while (freeCount < 2*4)
                    freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);

                // load and enable chroma key
                freeCount -= 2*4;
                if (ppdev->dDrawSpareSubchannelObject != NV_DD_IMAGE_SOLID)
                    {
                    npDev->dDrawSpare.SetObject = NV_DD_IMAGE_SOLID;
                    ppdev->dDrawSpareSubchannelObject = NV_DD_IMAGE_SOLID;
                    }
                npDev->dDrawTransColor.SetColor =
                (dwColorKey & ppdev->physicalColorMask) | NV_ALPHA_1_32;

                }

            // screen to screen bitblt
            if (wStretch == 0)
                {
                if ((dwDstCaps & DDSCAPS_VIDEOMEMORY) &&
                    (dwSrcCaps & DDSCAPS_VIDEOMEMORY) &&
                    ((dwSrcCaps & DDSCAPS_TEXTURE) == 0) &&
                    (doMirrorUpDown == 0) &&
                    (isVideo == 0))
                    {
                    ppdev->NVFreeCount = freeCount;
                    DDRAW_SET_PRIMARY(ppdev, dwDstOffset, dwDstPitch);
                    DDRAW_SET_SOURCE(ppdev, dwSrcOffset, dwSrcPitch);
                    freeCount = ppdev->NVFreeCount;

                    while (freeCount < 16)
                        freeCount = NvGetFreeCount(npDev, NV_DD_ROP);
                    freeCount -= 16;

                    npDev->dDrawRop.SetRop5 = dwRop;
                    npDev->dDrawBlit.ControlPointIn = wSrcXY.xy;
                    npDev->dDrawBlit.ControlPointOut = wDestXY.xy;
                    npDev->dDrawBlit.Size = wXYext.wh;

                    }
                else
                    {
                    // memory to screen blt (src may be in system memory or in video memory)
                    unsigned long temp;
                    long srcScanLength;
                    long nxtSrcScan;
                    short n = wXYext.wh16.h;
                    FAST short pxlCount;
                    unsigned long *pSrcInitBits;

                    pSrcInitBits = (unsigned long *)src->fpVidMem;
                    if (dwSrcCaps & DDSCAPS_VIDEOMEMORY)
                        pSrcInitBits += (ULONG) ppdev->pjFrameBufbase;

                    srcScanLength = src->lPitch >> 2;

                    if (doMirrorUpDown)
                        wSrcXY.xy16.y += (short)(n - 1);

                    pSrcInitBits += (wSrcXY.xy16.y * srcScanLength);

                    temp = wXYext.wh16.w;

                    nxtSrcScan = srcScanLength - temp;

                    if (doMirrorUpDown)
                        nxtSrcScan = -srcScanLength - temp;

                    pSrcInitBits += wSrcXY.xy16.x;

                    ppdev->NVFreeCount = freeCount;
                    DDRAW_SET_PRIMARY(ppdev, dwDstOffset, dwDstPitch);
                    freeCount = ppdev->NVFreeCount;

                    while (freeCount < 4*4)
                        freeCount = NvGetFreeCount(npDev, NV_DD_ROP);
                    freeCount -= 4*4;

                    npDev->dDrawRop.SetRop5 = dwRop;

                    npDev->dDrawImageFromCpu.Point = wDestXY.xy;
                    npDev->dDrawImageFromCpu.SizeOut = wXYext.wh;
                    npDev->dDrawImageFromCpu.SizeIn = wXYext.wh;

                    {
                        FAST unsigned long *pSrcBits = (unsigned long *)pSrcInitBits;
                        FAST unsigned long tmpPxls0, tmpPxls1, tmpPxls2;

                        while (--n >= 0)
                            {
                            pxlCount = (short)temp;

                            while (pxlCount >= 16)
                                {
                                pxlCount -= 16;

                                while (freeCount < 64)
                                    freeCount = NvGetFreeCount(npDev, NV_DD_IMAGE);
                                freeCount -= 64;

                                tmpPxls0 = pSrcBits[0];
                                tmpPxls1 = pSrcBits[1];
                                npDev->dDrawImageFromCpu.Color[0] = tmpPxls0;
                                tmpPxls2 = pSrcBits[2];
                                npDev->dDrawImageFromCpu.Color[1] = tmpPxls1;
                                tmpPxls0 = pSrcBits[3];
                                tmpPxls1 = pSrcBits[4];
                                npDev->dDrawImageFromCpu.Color[2] = tmpPxls2;
                                npDev->dDrawImageFromCpu.Color[3] = tmpPxls0;
                                tmpPxls2 = pSrcBits[5];
                                tmpPxls0 = pSrcBits[6];
                                npDev->dDrawImageFromCpu.Color[4] = tmpPxls1;
                                npDev->dDrawImageFromCpu.Color[5] = tmpPxls2;
                                tmpPxls1 = pSrcBits[7];
                                tmpPxls2 = pSrcBits[8];
                                npDev->dDrawImageFromCpu.Color[6] = tmpPxls0;
                                npDev->dDrawImageFromCpu.Color[7] = tmpPxls1;
                                tmpPxls0 = pSrcBits[9];
                                tmpPxls1 = pSrcBits[10];
                                npDev->dDrawImageFromCpu.Color[8] = tmpPxls2;
                                npDev->dDrawImageFromCpu.Color[9] = tmpPxls0;
                                tmpPxls2 = pSrcBits[11];
                                tmpPxls0 = pSrcBits[12];
                                npDev->dDrawImageFromCpu.Color[10] = tmpPxls1;
                                npDev->dDrawImageFromCpu.Color[11] = tmpPxls2;
                                tmpPxls1 = pSrcBits[13];
                                tmpPxls2 = pSrcBits[14];
                                npDev->dDrawImageFromCpu.Color[12] = tmpPxls0;
                                npDev->dDrawImageFromCpu.Color[13] = tmpPxls1;
                                tmpPxls0 = pSrcBits[15];
                                npDev->dDrawImageFromCpu.Color[14] = tmpPxls2;
                                pSrcBits += 16;
                                npDev->dDrawImageFromCpu.Color[15] = tmpPxls0;
                                }

                            if (pxlCount > 0)
                                {
                                while (freeCount < 64)
                                    freeCount = NvGetFreeCount(npDev, NV_DD_IMAGE);

                                while (--pxlCount >= 0)
                                    {
                                    tmpPxls0 = pSrcBits[0];
                                    freeCount -= 4;
                                    pSrcBits += 1;
                                    npDev->dDrawImageFromCpu.Color[0] = tmpPxls0;
                                    }
                                }

                            pSrcBits += nxtSrcScan;
                            }
                    }
                    }
                }
            else
                { // stretch
                DWORD dwStatus;
                RECTL rDummy;
                BOOL isOverlappingVmem = FALSE;
                ULONG lpSurfTemp = 0;
                // if the source and destination overlap, then we must do this in 2 passes, first copy the source
                // image somewhere else, and then so the stretch from there.
                if ((dwSrcCaps & DDSCAPS_VIDEOMEMORY) &&
                    dwSrcOffset == dwDstOffset &&
                    bIntersect((RECTL *)(&pbd->rSrc), (RECTL *)(&pbd->rDest), &rDummy))
                    {
                    ULONG tmpBmpPitch = (((dwSrcWidth * (ppdev->cBitsPerPel / 8)) + ppdev->ulSurfaceAlign) & ~ppdev->ulSurfaceAlign);
                    NVHEAP_ALLOC(dwStatus,lpSurfTemp, (DWORD)dwSrcHeight * tmpBmpPitch,  TYPE_IMAGE);
                    if (dwStatus!=0)
                    {
                        bMoveAllDfbsFromOffscreenToDibs(ppdev);
                        NVHEAP_ALLOC(dwStatus,lpSurfTemp, (DWORD)dwSrcHeight * tmpBmpPitch,  TYPE_IMAGE);
                    }

                    if (dwStatus==0)
                        {
                        isOverlappingVmem = TRUE;
                        DDRAW_SET_PRIMARY(ppdev, lpSurfTemp, tmpBmpPitch);
                        DDRAW_SET_SOURCE(ppdev, dwSrcOffset, dwSrcPitch);

                        while (freeCount < 6*4)
                            freeCount = NvGetFreeCount(npDev, 0);
                        freeCount -= 6*4;

						{
							NVCOORD     srcSize;

							srcSize.wh16.w = (unsigned short)dwSrcWidth;
							srcSize.wh16.h = (unsigned short)dwSrcHeight;

							npDev->dDrawRop.SetRop5 = SRCCOPYINDEX;
							npDev->dDrawBlit.ControlPointIn = wSrcXY.xy;
							npDev->dDrawBlit.ControlPointOut = 0;
							npDev->dDrawBlit.Size = srcSize.wh;
						}

                        dwSrcOffset = lpSurfTemp;
                        dwSrcPitch = tmpBmpPitch;
                        wSrcXY.xy = 0;
                        wSrcXY.xy16.x = 0;
                        wSrcXY.xy16.y = 0;
                        }
                    else
                        {
                        // FIXME: vmem heap alloc failed, must do system mem alloc and copy there
                        }
                        // WARNING: carefully consider each use of src->fpVidMem and src->lPitch beyond this point
                        //          it could screw up overlapping stretchblits
                    }
                if (dwFlags & DDBLT_KEYSRCOVERRIDE)
                    { // If color key then MUST use STRETCHED IMAGE instead of SCALED IMAGE
                    NvNotification *pDmaToMemNotifier;
                    unsigned char *pScanlineBuffer;
                    long srcScanLength;
                    long nxtSrcScan;
                    long n;
                    short m;
                    FAST short pxlCount;
                    unsigned char *pSrcInitBits;
                    unsigned char *pSaveSrcBits;
                    unsigned char *pSrcCurScan;
                    long deltaX;
                    long deltaY;
                    long deltaDstY;
                    long curDstY;
                    long lastDstY;
                    long skipSrcBytes = 0;
                    NVCOORD wSrcExt;
                    NVCOORD wDstPoint;
                    unsigned long srcStrtX;
                    BYTE srcInVideoMemory = 0;
                    BYTE bufState = 0;
                    short skipV = 0;

                    pSrcInitBits = (unsigned char *) dwSrcOffset;
                    if (dwSrcCaps & DDSCAPS_VIDEOMEMORY)
                        pSrcInitBits += (ULONG) ppdev->pjFrameBufbase;

                    srcScanLength = dwSrcPitch;

                    if (dwSrcPitch <= 1600)
                        m = 8;
                    else if (dwSrcPitch <= 3200)
                        m = 4;
                    else
                        m = 2;

                    ppdev->NVFreeCount = freeCount;
                    DDRAW_SET_PRIMARY(ppdev, dwDstOffset, dwDstPitch);
                    freeCount = ppdev->NVFreeCount;

                    while (freeCount < 4)
                        freeCount = NvGetFreeCount(npDev, NV_DD_ROP);
                    freeCount -= 4;

                    npDev->dDrawRop.SetRop5 = dwRop;

                    /* calculate deltas in 12.20 format */
                    n = (dwDstWidth << 20) / dwSrcWidth;

                    if ((n & 0xFFFFF) == 0)
                        n = 0;
                    else
                        {
                        n >>= 20;
                        n += 1;
                        }

                    deltaX = (dwDstWidth + n) << 20;
                    deltaX /= dwSrcWidth;

                    n = (dwDstHeight << 20) / dwSrcHeight;

                    if ((n & 0xFFFFF) == 0)
                        n = 0;
                    else
                        {
                        n >>= 20;
                        n += 1;
                        }

                    deltaY = (dwDstHeight + n) << 20;
                    deltaY /= dwSrcHeight;

                    deltaDstY = (dwDstHeight << 20);
                    deltaDstY /= dwSrcHeight;

                    wSrcExt.wh16.w = (unsigned short)dwSrcWidth;
                    wSrcExt.wh16.h = (unsigned short)dwSrcHeight;

                    n = (short)dwSrcHeight;

                    if ((ULONG) (wSrcXY.xy16.y + n) > src->wHeight)
                        n = src->wHeight - wSrcXY.xy16.y;

                    nxtSrcScan = srcScanLength;

                    if (doMirrorUpDown)
                        {
                        wSrcXY.xy16.y += (short)(n - 1);
                        nxtSrcScan = -nxtSrcScan;
                        skipSrcBytes = -skipSrcBytes;
                        }

                    if ((dwSrcCaps & DDSCAPS_VIDEOMEMORY) &&
                        ((dwSrcCaps & DDSCAPS_TEXTURE) == 0)
                        || isOverlappingVmem)
                        {
                        srcInVideoMemory = 1;
                        }
                    else
                        {
                        pSaveSrcBits = (unsigned char *)(pSrcInitBits +
                                                         (wSrcXY.xy16.y * srcScanLength));
                        pSaveSrcBits += (wSrcXY.xy16.x << 2);
                        pSrcCurScan = pSaveSrcBits;
                        }

                    if (srcInVideoMemory)
                        {
                        pDmaToMemNotifier = (NvNotification *)ppdev->Notifiers->DmaToMem;
                        pScanlineBuffer = (unsigned char *)ppdev->NvScanlineBufferFlat;

                        wSrcExt.wh16.w = (unsigned short)dwSrcWidth;
                        wSrcExt.wh16.h = m;

                        srcStrtX = wSrcXY.xy16.x;

                        while (freeCount < 4)
                            freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);
                        freeCount -= 4;

                        npDev->subchannel[NV_DD_SPARE].SetObject =
                        NV_DD_VIDEO_MEM_TO_SYSTEM_MEM_FORMAT;
                        ppdev->dDrawSpareSubchannelObject =
                        NV_DD_VIDEO_MEM_TO_SYSTEM_MEM_FORMAT;

                        // wait for any pending notification operation to finish
                        while ((volatile)pDmaToMemNotifier[NV039_NOTIFIERS_BUFFER_NOTIFY].status == NV_IN_PROGRESS);

                        pDmaToMemNotifier[NV039_NOTIFIERS_BUFFER_NOTIFY].status = NV_IN_PROGRESS;

                        while (freeCount < 32)
                            freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);
                        freeCount -= 32;

                        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.OffsetIn =
                        dwSrcOffset +
                        ((dwSrcPitch + skipSrcBytes) * (unsigned long)wSrcXY.xy16.y) +
                        ((unsigned long)wSrcXY.xy16.x << 2);

                        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.OffsetOut =
                        (srcStrtX << 2);

                        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.PitchIn =
                        (dwSrcPitch + skipSrcBytes);

                        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.PitchOut =
                        dwSrcPitch;

                        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.LineLengthIn =
                        (unsigned long)(wSrcExt.wh16.w << 2);

                        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.LineCount =
                        m;

                        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.Format =
                        1 | (1 << 8);
                        //NV_MTMF_FORMAT_INPUT_INC_1 | NV_MTMF_FORMAT_OUTPUT_INC_1;

                        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.BufferNotify =
                        0;

                        // wait for Dma operation to finish
                        while ((volatile)pDmaToMemNotifier[NV039_NOTIFIERS_BUFFER_NOTIFY].status == NV_IN_PROGRESS);

                        if (doMirrorUpDown)
                            wSrcXY.xy16.y -= (m + skipV);
                        else
                            wSrcXY.xy16.y += (m + skipV);
                        }

                    /* Convert to 12.4 format */
                    wDstPoint.xy16.x = (wDestXY.xy16.x << 4);
                    wDstPoint.xy16.y = (wDestXY.xy16.y << 4);

                    /* convert to 16.16 */
                    lastDstY = (wDestXY.xy16.y + wXYext.wh16.h) << 16;

                    /* convert to 16.16 */
                    curDstY = (wDestXY.xy16.y << 16);

                    while (freeCount < 7*4)
                        freeCount = NvGetFreeCount(npDev, NV_DD_STRETCH);
                    freeCount -= 7*4;

                    npDev->dDrawStretch.SetObject = NV_DD_STRETCHED_IMAGE_FROM_CPU;
                    ppdev->dDrawSpareSubchannelObject = NV_DD_STRETCHED_IMAGE_FROM_CPU;

                    npDev->dDrawStretch.nv4StretchedImageFromCpu.ClipPoint =
                    wDestXY.xy;

                    npDev->dDrawStretch.nv4StretchedImageFromCpu.ClipSize =
                    wXYext.wh;

                    npDev->dDrawStretch.nv4StretchedImageFromCpu.SizeIn = wSrcExt.wh;

                    npDev->dDrawStretch.nv4StretchedImageFromCpu.DeltaDxDu = deltaX;

                    npDev->dDrawStretch.nv4StretchedImageFromCpu.DeltaDyDv = deltaY;

                    npDev->dDrawStretch.nv4StretchedImageFromCpu.Point12d4 = wDstPoint.xy;

                    while ((n > 0) && (curDstY < lastDstY))
                        {
                        FAST unsigned long *pSrcBits;
                        FAST unsigned long tmpPxls0, tmpPxls1, tmpPxls2;

                        if (srcInVideoMemory)
                            {
                            if (bufState == 0)
                                pSrcBits = (unsigned long *)(pScanlineBuffer +
                                                             (srcStrtX << 2));
                            else
                                pSrcBits = (unsigned long *)(pScanlineBuffer +
                                                             (NV_DMA_SCANLINE_BUF_SIZE >> 1) +
                                                             (srcStrtX << 2));

                            pSrcCurScan = (unsigned char *)pSrcBits;

                            if (m > 0)
                                {
                                pDmaToMemNotifier[NV039_NOTIFIERS_BUFFER_NOTIFY].status = NV_IN_PROGRESS;

                                while (freeCount < 9*4)
                                    freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);
                                freeCount -= 9*4;
                                npDev->subchannel[NV_DD_SPARE].SetObject = NV_DD_VIDEO_MEM_TO_SYSTEM_MEM_FORMAT;
                                ppdev->dDrawSpareSubchannelObject = NV_DD_VIDEO_MEM_TO_SYSTEM_MEM_FORMAT;

                                npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.OffsetIn =
                                dwSrcOffset +
                                ((dwSrcPitch + skipSrcBytes) * (unsigned long)wSrcXY.xy16.y) +
                                ((unsigned long)wSrcXY.xy16.x << 2);

                                if (bufState == 0)
                                    npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.OffsetOut =
                                    (NV_DMA_SCANLINE_BUF_SIZE >> 1) +
                                    (srcStrtX << 2);
                                else
                                    npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.OffsetOut =
                                    (srcStrtX << 2);

                                npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.PitchIn =
                                (dwSrcPitch + skipSrcBytes);

                                npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.PitchOut =
                                dwSrcPitch;

                                npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.LineLengthIn =
                                (unsigned long)(wSrcExt.wh16.w << 2);

                                npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.LineCount =
                                m;

                                npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.Format =
                                1 | (1 << 8);
                                //NV_MTMF_FORMAT_INPUT_INC_1 | NV_MTMF_FORMAT_OUTPUT_INC_1;

                                npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.BufferNotify =                                0;

                                bufState ^= 1;

                                if (doMirrorUpDown)
                                    wSrcXY.xy16.y -= (m + skipV);
                                else
                                    wSrcXY.xy16.y += (m + skipV);

                                while (freeCount < 7*4)
                                    freeCount = NvGetFreeCount(npDev, NV_DD_STRETCH);
                                freeCount -= 7*4;
                                npDev->dDrawStretch.SetObject = NV_DD_STRETCHED_IMAGE_FROM_CPU;
                                ppdev->dDrawSpareSubchannelObject = NV_DD_STRETCHED_IMAGE_FROM_CPU;

                                npDev->dDrawStretch.nv4StretchedImageFromCpu.ClipPoint =
                                wDestXY.xy;
                                npDev->dDrawStretch.nv4StretchedImageFromCpu.ClipSize =
                                wXYext.wh;
                                npDev->dDrawStretch.nv4StretchedImageFromCpu.SizeIn =
                                wSrcExt.wh;
                                npDev->dDrawStretch.nv4StretchedImageFromCpu.DeltaDxDu =
                                deltaX;
                                npDev->dDrawStretch.nv4StretchedImageFromCpu.DeltaDyDv =
                                deltaY;
                                npDev->dDrawStretch.nv4StretchedImageFromCpu.Point12d4 =
                                wDstPoint.xy;
                                }
                            }
                        else
                            { // source in system memory
                            pSrcBits = (unsigned long *)pSrcCurScan;
                            pSrcCurScan += (nxtSrcScan + skipSrcBytes);
                            n--;
                            }

                        doNxtSrcScan:          pxlCount = (short)dwSrcWidth;

                        while (pxlCount >= 16)
                            {

                            pxlCount -= 16;

                            while (freeCount < 64)
                                freeCount = NvGetFreeCount(npDev, NV_DD_STRETCH);
                            freeCount -= 64;

                            tmpPxls0 = pSrcBits[0];
                            tmpPxls1 = pSrcBits[1];
                            npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[0] = tmpPxls0;
                            tmpPxls2 = pSrcBits[2];
                            npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[1] = tmpPxls1;
                            tmpPxls0 = pSrcBits[3];
                            tmpPxls1 = pSrcBits[4];
                            npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[2] = tmpPxls2;
                            npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[3] = tmpPxls0;
                            tmpPxls2 = pSrcBits[5];
                            tmpPxls0 = pSrcBits[6];
                            npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[4] = tmpPxls1;
                            npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[5] = tmpPxls2;
                            tmpPxls1 = pSrcBits[7];
                            tmpPxls2 = pSrcBits[8];
                            npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[6] = tmpPxls0;
                            npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[7] = tmpPxls1;
                            tmpPxls0 = pSrcBits[9];
                            tmpPxls1 = pSrcBits[10];
                            npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[8] = tmpPxls2;
                            npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[9] = tmpPxls0;
                            tmpPxls2 = pSrcBits[11];
                            tmpPxls0 = pSrcBits[12];
                            npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[10] = tmpPxls1;
                            npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[11] = tmpPxls2;
                            tmpPxls1 = pSrcBits[13];
                            tmpPxls2 = pSrcBits[14];
                            npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[12] = tmpPxls0;
                            npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[13] = tmpPxls1;
                            tmpPxls0 = pSrcBits[15];
                            npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[14] = tmpPxls2;
                            pSrcBits += 16;
                            npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[15] = tmpPxls0;
                            }

                        while (pxlCount >= 8)
                            {

                            pxlCount -= 8;

                            while (freeCount < 32)
                                freeCount = NvGetFreeCount(npDev, NV_DD_STRETCH);
                            freeCount -= 32;

                            tmpPxls0 = pSrcBits[0];
                            tmpPxls1 = pSrcBits[1];
                            npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[0] = tmpPxls0;
                            tmpPxls2 = pSrcBits[2];
                            npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[1] = tmpPxls1;
                            tmpPxls0 = pSrcBits[3];
                            tmpPxls1 = pSrcBits[4];
                            npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[2] = tmpPxls2;
                            npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[3] = tmpPxls0;
                            tmpPxls2 = pSrcBits[5];
                            tmpPxls0 = pSrcBits[6];
                            npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[4] = tmpPxls1;
                            npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[5] = tmpPxls2;
                            tmpPxls1 = pSrcBits[7];
                            pSrcBits += 8;
                            npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[6] = tmpPxls0;
                            npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[7] = tmpPxls1;
                            }

                        while (freeCount < 32)
                            freeCount = NvGetFreeCount(npDev, NV_DD_STRETCH);
                        freeCount -= 32;

                        while (--pxlCount >= 0)
                            {
                            tmpPxls0 = pSrcBits[0];
                            npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[0] = tmpPxls0;
                            pSrcBits += 1;
                            }

                        if (srcInVideoMemory)
                            {
                            if (--m > 0)
                                {
                                pSrcCurScan += dwSrcPitch;

                                pSrcBits = (unsigned long *)pSrcCurScan;

                                goto doNxtSrcScan;
                                }
                            else
                                {
                                if (dwSrcPitch <= 1600)
                                    {
                                    m = 8;
                                    curDstY += (deltaDstY >> 1);
                                    }
                                else if (dwSrcPitch <= 3200)
                                    {
                                    m = 4;
                                    curDstY += (deltaDstY >> 2);
                                    }
                                else
                                    {
                                    m = 2;
                                    curDstY += (deltaDstY >> 3);
                                    }
                                /* convert 16.16 to 12.4 */
                                wDstPoint.xy16.y = (short)(curDstY >> 12);

                                // wait for DMA operation to finish
                                while ((volatile)pDmaToMemNotifier[NV076_NOTIFIERS_NOTIFY].status == NV_IN_PROGRESS);
                                }
                            }
                        }
                    /* restore default object */
                    while (freeCount < 4)
                        freeCount = NvGetFreeCount(npDev, NV_DD_STRETCH);
                    freeCount -= 4;

                    npDev->dDrawStretch.SetObject = NV_DD_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY;
                    ppdev->dDrawSpareSubchannelObject = NV_DD_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY;

                    }
                else
                    { // OK to use SCALED IMAGE
                    NvNotification *pDmaToMemNotifier;
                    unsigned char *pScanlineBuffer;
                    unsigned char *npPixelBuf;
                    long srcScanLength;
                    long nxtSrcScan;
                    unsigned long n;
                    unsigned char *pSrcInitBits;
                    unsigned char *pSaveSrcInitBits;
                    unsigned long *pSaveSrcBits;
                    unsigned long *pSrcCurScan;
                    long srcDeltaX;
                    long srcDeltaY;
                    unsigned long dstDeltaScans;
                    unsigned long dstDeltaX;
                    unsigned long dstDeltaY;
                    long srcInitFract;
                    long srcStartFract;
                    long srcCurFract;
                    long srcDeltaFract;
                    long srcDeltaScans;
                    long xStretch;
                    long yStretch;
                    long srcBufferPitch;
                    long skipSrcBytes = 0;
                    long dstStartY;
                    long dstCurY;
                    long curV;
                    long skipV = 0;
                    long m;
                    long srcFinalHeight;
                    NVCOORD wSrcPoint;
                    NVCOORD wSrcExt;
                    NVCOORD wDstPoint;
                    NVCOORD wDstExt;
                    BYTE srcInVideoMemory = 0;
                    BYTE srcTooWide = 0;
                    short curBuffer;

                    pSrcInitBits = (unsigned char *) dwSrcOffset;
                    if (dwSrcCaps & DDSCAPS_VIDEOMEMORY)
                        pSrcInitBits += (ULONG) ppdev->pjFrameBufbase;

                    if (isVideo < 2)
                        srcScanLength = dwSrcPitch;
                    else
                        srcScanLength = dwSrcPitch >> 1;

                    ppdev->NVFreeCount = freeCount;
                    DDRAW_SET_PRIMARY(ppdev, dwDstOffset, dwDstPitch);
                    freeCount = ppdev->NVFreeCount;

                    while (freeCount < 4)
                        freeCount = NvGetFreeCount(npDev, NV_DD_ROP);
                    freeCount -= 4;

                    npDev->dDrawRop.SetRop5 = dwRop;

                    if (isVideo < 2)
                        srcBufferPitch = dwSrcWidth << 2;
                    else
                        srcBufferPitch = dwSrcWidth << 1;

                    srcDeltaScans = (NV_DMA_SCANLINE_BUF_SIZE >> 1) -   /* allow for 2 extra src scanlines */
                                    - (srcBufferPitch << 1);
                    srcDeltaScans /= srcBufferPitch;

                    /* limiting source scans per DMA increases parallelism */
                    if (srcDeltaScans > 32)
                        srcDeltaScans = 32;
                    else if (srcDeltaScans > 16)
                        srcDeltaScans = 16;
                    else if (srcDeltaScans > 8)
                        srcDeltaScans = 8;
                    else if (srcDeltaScans > 4)
                        srcDeltaScans = 4;
                    else
                        srcDeltaScans = 2;

                    /* check for divide by 0 */
                    if ((dwDstWidth < 1) || (dwDstHeight < 1))
                        {
                        pbd->ddRVal = DDERR_INVALIDRECT;
                        ppdev->NVFreeCount = freeCount;
                        return DDHAL_DRIVER_HANDLED;
                        }

                    n = (dwSrcWidth << 20) / dwDstWidth;

                    if (n == 0x100000)
                        n = 0;
                    else
                        {
                        n >>= 20;
                        n += 1;
                        }

                    srcDeltaX = dwSrcWidth << 20;
                    srcDeltaX /= (dwDstWidth + n);

                    n = (dwSrcHeight << 20) / dwDstHeight;

                    if (n == 0x100000)
                        n = 0;
                    else
                        {
                        n >>= 20;
                        n += 1;
                        }

                    srcDeltaY = dwSrcHeight << 20;
                    srcDeltaY /= (dwDstHeight + n);

                    /* Algorithm can't handle a scale factor that is too large */
                    if (srcDeltaY > 0x40000000)
                        {
                        pbd->ddRVal = DDERR_INVALIDRECT;
                        ppdev->NVFreeCount = freeCount;
                        return DDHAL_DRIVER_HANDLED;
                        }

                    /* If shrinking in vertical direction then adjust to skip src scanlines */
                    if (srcDeltaY >= (srcDeltaScans << 20))
                        { /* limit Y delta range to acceptable range */
                        skipSrcBytes = srcScanLength;
                        skipV = 1;
                        while (srcDeltaY >= (srcDeltaScans << 20))
                            {
                            srcDeltaY >>= 1;
                            skipSrcBytes <<= 1;
                            skipV <<= 1;
                            }
                        skipSrcBytes -= srcScanLength;
                        skipV -= 1;
                        }

                    /* Algorithm can't handle scale factor that is too small */
                    if ((srcDeltaY & 0xFFFFFC00) == 0)
                        {
                        pbd->ddRVal = DDERR_INVALIDRECT;
                        ppdev->NVFreeCount = freeCount;
                        return DDHAL_DRIVER_HANDLED;
                        }

                    yStretch = 0x40000000 / ((srcDeltaY + 0x00000200) >> 10);

                    dstDeltaY = srcDeltaScans * yStretch;  // how many dst scanlines will srcDeltaScans scanlines generate

                    dstDeltaScans = dstDeltaY >> 20;

                    if (dstDeltaScans == 0)
                        { /* if shrinking too much then can't handle */
                        pbd->ddRVal = DDERR_INVALIDRECT;
                        ppdev->NVFreeCount = freeCount;
                        return DDHAL_DRIVER_HANDLED;
                        }

                    if (wSrcXY.xy16.y + dwSrcHeight > src->wHeight)
                        dwSrcHeight = src->wHeight - wSrcXY.xy16.y;

                    if (isVideo < 2)
                        nxtSrcScan = (srcScanLength >> 2);
                    else
                        nxtSrcScan = (srcScanLength >> 1);

                    if (doMirrorUpDown)
                        {
                        wSrcXY.xy16.y += (short)(dwSrcHeight - 1);
                        srcDeltaY =- srcDeltaY;
                        nxtSrcScan = -nxtSrcScan;
                        skipSrcBytes = -skipSrcBytes;
                        }

                    pDmaToMemNotifier = (NvNotification *)ppdev->Notifiers->DmaToMem;
                    pScanlineBuffer = (unsigned char *)ppdev->NvScanlineBufferFlat;

                    srcDeltaFract = (dstDeltaScans << 20) / srcDeltaScans;

                    srcDeltaFract &= 0xFFFFF;

                    wSrcPoint.xy = 0;

                    /* Calculate initial source fractional X */
                    if ((srcDeltaX > 0x40000000) || ((srcDeltaX & 0xFFFFFC00) == 0))
                        {
                        pbd->ddRVal = DDERR_INVALIDRECT;
                        ppdev->NVFreeCount = freeCount;
                        return DDHAL_DRIVER_HANDLED;
                        }

                    /* Do this math in 16.16 precision to avoid 12. overflow */
                    dstDeltaX = ((long)wSrcXY.xy16.x << 16) / (srcDeltaX >> 4);

                    /* Do this math in 16.16 precision to avoid 12. overflow */
                    srcInitFract = dstDeltaX * (srcDeltaX >> 4);

                    /* Do this math in 16.16 precision to avoid 12. overflow */
                    while (srcInitFract >> 16 < wSrcXY.xy16.x)
                        srcInitFract += (srcDeltaX >> 4);

                    /* Convert to 12.4 format */
                    wSrcPoint.xy16.x = (short)(srcInitFract & 0xFFFF) >> 12;

                    // DMAable ?
                    if ((isVideo > 3) || ((dwSrcCaps & DDSCAPS_VIDEOMEMORY) &&
                                          ((dwSrcCaps & DDSCAPS_TEXTURE) == 0) ||
                                          isOverlappingVmem))
                        {

                        /* Calculate initial source fractional Y */
                        /* Do this math in 16.16 precision to avoid 12. overflow */
                        dstDeltaY = ((long)wSrcXY.xy16.y << 16) / (srcDeltaY >> 4);

                        /* Do this math in 16.16 precision to avoid 12. overflow */
                        srcInitFract = dstDeltaY * (srcDeltaY >> 4);

                        /* Do this math in 16.16 precision to avoid 12. overflow */
                        while (srcInitFract >> 16 < wSrcXY.xy16.y)
                            srcInitFract += (srcDeltaY >> 4);

                        /* Convert result back to 12.20 precision */
                        srcInitFract <<= 4;

                        srcInitFract &= 0xFFFFF;

                        srcCurFract = srcInitFract;

                        if (isVideo < 4)
                            {
                            srcInVideoMemory = 1;

                            wSrcPoint.xy16.y += (short)srcCurFract >> 16;

                            if (doMirrorUpDown)
                                {
                                pSaveSrcBits = (unsigned long *)
                                               (pSrcInitBits - ppdev->pjFrameBufbase);
                                wSrcPoint.xy16.y += ((short)(dwSrcHeight - 1) << 4);
                                }
                            else
                                {
                                if (isVideo < 2)
                                    pSaveSrcBits = (unsigned long *)
                                                   ((pSrcInitBits - ppdev->pjFrameBufbase) +
                                                    (wSrcXY.xy16.y * srcScanLength));
                                else
                                    pSaveSrcBits = (unsigned long *)
                                                   ((pSrcInitBits - ppdev->pjFrameBufbase) +
                                                    (wSrcXY.xy16.y * (srcScanLength << 1)));
                                }
                            }
                        else
                            {

                            wSrcPoint.xy16.y += (short)srcCurFract >> 16;

                            if (doMirrorUpDown)
                                {
                                pSaveSrcBits = 0;
                                wSrcPoint.xy16.y += ((short)(dwSrcHeight - 1) << 4);
                                }
                            else
                                {
                                pSaveSrcBits = (unsigned long *)
                                               (wSrcXY.xy16.y * (srcScanLength << 1));
                                }
                            }

                        if (isVideo < 2)
                            pSaveSrcBits += wSrcXY.xy16.x;
                        else
                            pSaveSrcBits += (wSrcXY.xy16.x >> 1);

                        while (freeCount < 4)
                            freeCount = NvGetFreeCount(npDev, NV_DD_STRETCH);
                        freeCount -= 4;

                        if (isVideo < 2)
                            {
                            npDev->subchannel[NV_DD_STRETCH].SetObject =
                            NV_DD_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY;
                            ppdev->dDrawSpareSubchannelObject = NV_DD_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY;
                            }
                        else if (isVideo == 2)
                            {
                            npDev->subchannel[NV_DD_STRETCH].SetObject =
                            NV_DD_SCALED_UYVY_IMAGE_FROM_VIDEO_MEMORY;
                            ppdev->dDrawSpareSubchannelObject = NV_DD_SCALED_UYVY_IMAGE_FROM_VIDEO_MEMORY;
                            }
                        else if (isVideo == 3)
                            {
                            npDev->subchannel[NV_DD_STRETCH].SetObject =
                            NV_DD_SCALED_YUYV_IMAGE_FROM_VIDEO_MEMORY;
                            ppdev->dDrawSpareSubchannelObject = NV_DD_SCALED_YUYV_IMAGE_FROM_VIDEO_MEMORY;
                            }
                        else if (isVideo == 4)
                            {
                            npDev->subchannel[NV_DD_STRETCH].SetObject =
                            NV_DD_FLOATING0_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
                            ppdev->dDrawSpareSubchannelObject = NV_DD_FLOATING0_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
                            }
                        else if (isVideo == 5)
                            {
                            npDev->subchannel[NV_DD_STRETCH].SetObject =
                            NV_DD_FLOATING1_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
                            ppdev->dDrawSpareSubchannelObject = NV_DD_FLOATING1_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
                            }
                        else if (isVideo == 6)
                            {
                            npDev->subchannel[NV_DD_STRETCH].SetObject =
                            NV_DD_FLOATING0_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
                            ppdev->dDrawSpareSubchannelObject = NV_DD_FLOATING0_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
                            }
                        else if (isVideo == 7)
                            {
                            npDev->subchannel[NV_DD_STRETCH].SetObject =
                            NV_DD_FLOATING1_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
                            ppdev->dDrawSpareSubchannelObject = NV_DD_FLOATING1_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
                            }

                        }
                    else
                        {
                        if (isVideo < 2)
                            {
                            pSaveSrcBits = (unsigned long *)(pSrcInitBits +
                                                             (wSrcXY.xy16.y * srcScanLength));
                            pSaveSrcBits += wSrcXY.xy16.x;
                            }
                        else
                            {
                            pSaveSrcBits = (unsigned long *)(pSrcInitBits +
                                                             (wSrcXY.xy16.y * (srcScanLength << 1)));
                            pSaveSrcBits += (wSrcXY.xy16.x >> 1);
                            }

                        pSrcCurScan = pSaveSrcBits;

                        while (freeCount < 1*4)
                            freeCount = NvGetFreeCount(npDev, NV_DD_STRETCH);
                        freeCount -= 1*4;

                        if (isVideo == 2)
                            {
                            npDev->subchannel[NV_DD_STRETCH].SetObject =
                            NV_DD_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
                            ppdev->dDrawSpareSubchannelObject = NV_DD_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
                            }
                        else if (isVideo == 3)
                            {
                            npDev->subchannel[NV_DD_STRETCH].SetObject =
                            NV_DD_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
                            ppdev->dDrawSpareSubchannelObject = NV_DD_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
                            }
                        }

                    while (freeCount < 4*4)
                        freeCount = NvGetFreeCount(npDev, NV_DD_STRETCH);
                    freeCount -= 4*4;

                    pSaveSrcInitBits = (unsigned char *)pSaveSrcBits;

                    npDev->dDrawStretch.nv4ScaledImageFromMemory.ClipPoint =
                    wDestXY.xy;

                    npDev->dDrawStretch.nv4ScaledImageFromMemory.ClipSize =
                    wXYext.wh;

                    npDev->dDrawStretch.nv4ScaledImageFromMemory.DeltaDuDx = srcDeltaX;
                    npDev->dDrawStretch.nv4ScaledImageFromMemory.DeltaDvDy = srcDeltaY;


                    wDstExt.wh = wXYext.wh;

                    /* NV3 hardware can only handle a maximum source width of 1024 */
                    if (dwSrcWidth > 1024)
                        {
                        srcTooWide = 1;
                        xStretch = 0x40000000 / (srcDeltaX >> 10);
                        dstDeltaX = (xStretch * 1024) >> 20;
                        wDstExt.wh16.w = (unsigned short)dstDeltaX;
                        srcBufferPitch = 4096;
                        }

                    // wait for any pending notification operation to finish
                    while ((volatile)pDmaToMemNotifier[NV077_NOTIFIERS_NOTIFY].status == NV_IN_PROGRESS);

                    // Let the world know we are doing DMA operations
                    ppdev->NvDmaFromMemSurfaceMem = dwSrcOffset;
                    if (dwSrcCaps & DDSCAPS_VIDEOMEMORY)
                        ppdev->NvDmaFromMemSurfaceMem += (ULONG) ppdev->pjFrameBufbase;


                    oneMorePass:       n = dwDstHeight;

                    /* Calculate initial source fractional Y */
                    /* Do this math in 16.16 precision to avoid 12. overflow */
                    dstDeltaY = ((long)wSrcXY.xy16.y << 16) / (srcDeltaY >> 4);

                    /* Do this math in 16.16 precision to avoid 12. overflow */
                    srcInitFract = dstDeltaY * (srcDeltaY >> 4);

                    /* Do this math in 16.16 precision to avoid 12. overflow */
                    while (srcInitFract >> 16 < wSrcXY.xy16.y)
                        srcInitFract += (srcDeltaY >> 4);

                    /* Convert result back to 12.20 precision */
                    srcInitFract <<= 4;

                    srcInitFract &= 0xFFFFF;

                    srcCurFract = srcInitFract;

                    curV = 0;

                    wDstPoint.xy = wDestXY.xy;

                    dstStartY = dstCurY = wDestXY.xy16.y;

                    curBuffer = 0;

                    if ((srcInVideoMemory) || (isVideo > 3))
                        { // DMAable ?

                        // wait for any pending notification operation to finish
                        while ((volatile)pDmaToMemNotifier[NV077_NOTIFIERS_NOTIFY].status == NV_IN_PROGRESS);

                        pDmaToMemNotifier[NV077_NOTIFIERS_NOTIFY].status = NV_IN_PROGRESS;

                        while (freeCount < 28)
                            freeCount = NvGetFreeCount(npDev, NV_DD_STRETCH);
                        freeCount -= 28;

                        npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageOutPoint =
                        wDstPoint.xy;
                        npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageOutSize =
                        wDstExt.wh;

                        if ((dwSrcWidth < 16))
                            { // workaround for NV5 hardware bug
                            npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInSize =
                            asmMergeCoords((unsigned short)((dwSrcPitch + 1) & ~1), dwSrcHeight);
                            }
                        else
                            {
                            npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInSize =
                            asmMergeCoords((unsigned short) ((dwSrcWidth + 1) & ~1), dwSrcHeight);
                            }

                        npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInFormat =
                            (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_FOH << 24) |
                            (NV077_IMAGE_IN_FORMAT_ORIGIN_CENTER << 16) |
                            dwSrcPitch;


                        npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInOffset =
                        (unsigned long)pSaveSrcBits;
                        npDev->dDrawStretch.nv4ScaledImageFromMemory.Notify =
                        0;
                        npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInPoint =
                        wSrcPoint.xy;

                        n = 0;
                        }

                    while (n >= dstDeltaScans)
                        {
                        FAST unsigned long *pSrcBits;

                        n -= dstDeltaScans;
                        srcStartFract = srcCurFract;
                        srcCurFract += srcDeltaFract;
                        if (curBuffer == 0)
                            npPixelBuf = (unsigned char *)pScanlineBuffer;
                        else
                            npPixelBuf = (unsigned char *)(pScanlineBuffer +
                                                           (NV_DMA_SCANLINE_BUF_SIZE >> 1));

                        /* Must recalculate on each pass since src scanlines may be used more than once */
                        pSrcBits = (unsigned long *)(pSaveSrcInitBits +
                                                     (curV * (nxtSrcScan << 2)));

                        pSrcCurScan = pSrcBits;

                        m = srcDeltaScans + (srcCurFract >> 20) + 1;

                        if (skipV)
                            {
                            if ((long)dwSrcHeight - curV < (m * (skipV + 1)))
                                m = ((long)dwSrcHeight - curV) / (skipV + 1);
                            }
                        else
                            {
                            if ((long)dwSrcHeight - curV < m)
                                m = (long)dwSrcHeight - curV;
                            }

                        /* Copy and convert a block of source pixels to transfer buffer */
                        while (--m >= 0)
                            {
                            if (pSrcBits >= (unsigned long *)pSrcInitBits)
                                {
                                //                           asmCopyScan(pSrcBits, npPixelBuf, srcBufferPitch);
                                _asm
                                {
#ifdef P6
                                    mov ecx, dword ptr srcBufferPitch
                                    mov esi, dword ptr pSrcBits
                                    shr ecx, 5
                                    nxtCacheLine: mov eax, [esi]
                                    add esi, 32
                                    dec ecx
                                    jg nxtCacheLine
#endif /* P6 */
                                    mov ecx, dword ptr srcBufferPitch
                                    mov esi, dword ptr pSrcBits
                                    shr ecx, 2
                                    mov edi, dword ptr npPixelBuf
                                    test ecx, 1
                                    jz doQwords
                                    mov eax, [esi]
                                    add esi, 4
                                    mov [edi], eax
                                    add edi, 4
                                    doQwords: shr ecx, 1
                                    jz copyDone
                                    nxtQword: mov eax, [esi]
                                    mov edx, [esi+4]
                                    add edi, 8
                                    add esi, 8
                                    dec ecx
                                    mov [edi-8], eax
                                    mov [edi-4], edx
                                    copyDone: jg nxtQword
                                }
                                }
                            npPixelBuf += srcBufferPitch;
                            pSrcCurScan += (nxtSrcScan + skipSrcBytes);
                            pSrcBits = (unsigned long *)pSrcCurScan;
                            curV += skipV;
                            }

                        /* wait for Dma operation to finish */
                        while (pDmaToMemNotifier[NV077_NOTIFIERS_NOTIFY].status == NV_IN_PROGRESS);

                        pDmaToMemNotifier[NV077_NOTIFIERS_NOTIFY].status = NV_IN_PROGRESS;

                        wDstPoint.xy16.y = (short)dstCurY;
                        wDstExt.wh16.h = (unsigned short)dstDeltaScans;
                        wSrcPoint.xy16.y = (short)srcStartFract >> 16; /* convert V to 12.4 */
                        wSrcExt.wh = srcDeltaScans + (srcCurFract >> 20) + 1;
                        wSrcExt.wh <<= 16;    /* shift V extent into place */
                        wSrcExt.wh |= (unsigned short) ((dwSrcWidth + 1) & ~1);

                        while (freeCount < 28)
                            freeCount = NvGetFreeCount(npDev, NV_DD_STRETCH);
                        freeCount -= 28;

                        npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageOutPoint =
                        wDstPoint.xy;
                        npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageOutSize =
                        wDstExt.wh;
                        if (dwSrcWidth < 16)
                            {
                            npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInSize =
                                (wSrcExt.wh & 0xffff0000) | dwSrcPitch;
                            }
                        else
                            {
                            npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInSize =
                            wSrcExt.wh;
                            }

                        npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInFormat =
                            (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_FOH << 24) |
                            (NV077_IMAGE_IN_FORMAT_ORIGIN_CENTER << 16) |
                            srcBufferPitch;

                        if (curBuffer == 0)
                            npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInOffset =
                            0;
                        else
                            npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInOffset =
                            (NV_DMA_SCANLINE_BUF_SIZE >> 1);

                        npDev->dDrawStretch.nv4ScaledImageFromMemory.Notify =
                        0;
                        npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInPoint =
                        wSrcPoint.xy;

                        curBuffer ^= 1;
                        dstCurY += dstDeltaScans;

                        srcCurFract = ((dstCurY - dstStartY) * srcDeltaY) + srcInitFract;

                        curV = srcCurFract >> 20;
                        srcCurFract &= 0xFFFFF;

                        curV += (curV - 1) * skipV;
                        if (curV > (long)dwSrcHeight - 1)
                            curV = (long)dwSrcHeight - 1;
                        }

                    if (n > 0)
                        {
                        FAST unsigned long *pSrcBits;

                        srcStartFract = srcCurFract;
                        srcCurFract += srcDeltaFract;
                        if (curBuffer == 0)
                            npPixelBuf = (unsigned char *)pScanlineBuffer;
                        else
                            npPixelBuf = (unsigned char *)(pScanlineBuffer +
                                                           (NV_DMA_SCANLINE_BUF_SIZE >> 1));

                        /* Must recalculate since src scanlines may be used more than once */
                        pSrcBits = (unsigned long *)(pSaveSrcInitBits +
                                                     (curV * (nxtSrcScan << 2)));

                        pSrcCurScan = pSrcBits;

                        m = srcDeltaScans + (srcCurFract >> 20) + 1;

                        srcFinalHeight = m;

                        if (skipV)
                            {
                            if ((long)dwSrcHeight - curV < (m * (skipV + 1)))
                                srcFinalHeight = ((long)dwSrcHeight - curV) / (skipV + 1);
                            }
                        else
                            {
                            if ((long)dwSrcHeight - curV < m)
                                srcFinalHeight = (long)dwSrcHeight - curV;
                            }

                        /* Copy and convert a block of source pixels to transfer buffer */
                        while (--m >= 0)
                            {
                            if (pSrcBits >= (unsigned long *)pSrcInitBits)
                                {
                                //                           asmCopyScan(pSrcBits, npPixelBuf, srcBufferPitch);
                                _asm
                                {
#ifdef P6
                                    mov ecx, dword ptr srcBufferPitch
                                    mov esi, dword ptr pSrcBits
                                    shr ecx, 5
                                    nxtCacheLine2: mov eax, [esi]
                                    add esi, 32
                                    dec ecx
                                    jg nxtCacheLine2
#endif /* P6 */
                                    mov ecx, dword ptr srcBufferPitch
                                    mov esi, dword ptr pSrcBits
                                    shr ecx, 2
                                    mov edi, dword ptr npPixelBuf
                                    test ecx, 1
                                    jz doQwords2
                                    mov eax, [esi]
                                    add esi, 4
                                    mov [edi], eax
                                    add edi, 4
                                    doQwords2: shr ecx, 1
                                    jz copyDone2
                                    nxtQword2: mov eax, [esi]
                                    mov edx, [esi+4]
                                    add edi, 8
                                    add esi, 8
                                    dec ecx
                                    mov [edi-8], eax
                                    mov [edi-4], edx
                                    copyDone2: jg nxtQword2
                                }
                                }
                            npPixelBuf += srcBufferPitch;
                            if (--srcFinalHeight > 0)
                                pSrcCurScan += (nxtSrcScan + skipSrcBytes);
                            pSrcBits = (unsigned long *)pSrcCurScan;
                            curV += skipV;
                            }

                        /* wait for Dma operation to finish */
                        while (pDmaToMemNotifier[NV077_NOTIFIERS_NOTIFY].status == NV_IN_PROGRESS);

                        pDmaToMemNotifier[NV077_NOTIFIERS_NOTIFY].status = NV_IN_PROGRESS;

                        wDstPoint.xy16.y = (short)dstCurY;
                        wDstExt.wh16.h = (unsigned short)n;
                        wSrcPoint.xy16.y = (short)srcStartFract >> 16; /* convert V to 12.4 */
                        wSrcExt.wh = srcDeltaScans + (srcCurFract >> 20) + 1;
                        wSrcExt.wh <<= 16;    /* shift V extent into place */
                        wSrcExt.wh |= (unsigned short)((dwSrcWidth + 1) & ~1);

                        while (freeCount < 28)
                            freeCount = NvGetFreeCount(npDev, NV_DD_STRETCH);
                        freeCount -= 28;

                        npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageOutPoint =
                        wDstPoint.xy;
                        npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageOutSize =
                        wDstExt.wh;

                        // NV5 hw bug workaround
                        if (dwSrcWidth < 16)
                            {
                            npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInSize =
                                (wSrcExt.wh & 0xffff0000) | dwSrcPitch;
                            }
                        else
                            {
                            npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInSize =
                            wSrcExt.wh;
                            }

                        npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInFormat =
                            (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_FOH << 24) |
                            (NV077_IMAGE_IN_FORMAT_ORIGIN_CENTER << 16) |
                            srcBufferPitch;

                        if (curBuffer == 0)
                            npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInOffset =
                            0;
                        else
                            npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInOffset =
                            (NV_DMA_SCANLINE_BUF_SIZE >> 1);

                        npDev->dDrawStretch.nv4ScaledImageFromMemory.Notify =
                        0;
                        npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInPoint =
                        wSrcPoint.xy;
                        }

                    if (srcTooWide)
                        {
                        srcTooWide = 0;
                        wDestXY.xy16.x += (short)dstDeltaX;
                        wDstExt.wh16.w = wXYext.wh16.w - wDstExt.wh16.w;
                        if ((srcInVideoMemory) || (isVideo > 3))
                            wSrcPoint.xy16.x += (1024 << 4);
                        srcBufferPitch = dwSrcWidth << 2;
                        srcBufferPitch -= 4096;
                        pSaveSrcInitBits += 1024;
                        pSaveSrcBits = (unsigned long *)pSaveSrcInitBits;
                        pSrcCurScan = pSaveSrcBits;
                        goto oneMorePass;
                        }

                    if ((srcInVideoMemory) || (isVideo > 1))
                        {

                        while (freeCount < 4)
                            freeCount = NvGetFreeCount(npDev, NV_DD_STRETCH);
                        freeCount -= 4;

                        npDev->subchannel[NV_DD_STRETCH].SetObject =
                        NV_DD_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY;
                        ppdev->dDrawSpareSubchannelObject = NV_DD_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY;
                        }
                    }
                    if (isOverlappingVmem && lpSurfTemp)
                        {
                        NVHEAP_FREE(lpSurfTemp);
                        }
                }

            if (dwFlags & DDBLT_KEYSRCOVERRIDE)
                {
                /* disable chroma key */
                while (freeCount < 2*4)
                    freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);
                freeCount -= 2*4;
                if (ppdev->dDrawSpareSubchannelObject != NV_DD_IMAGE_SOLID)
                    {
                    npDev->dDrawSpare.SetObject = NV_DD_IMAGE_SOLID;
                    ppdev->dDrawSpareSubchannelObject = NV_DD_IMAGE_SOLID;
                    }
                npDev->dDrawTransColor.SetColor = 0;
                }
            }
        else
            {
            DPF("BLT     blt not handled by driver");
            ppdev->NVFreeCount = freeCount;
            return DDHAL_DRIVER_NOTHANDLED;
            }
        }
    else if (dwFlags & DDBLT_COLORFILL)
        {
        dwFillColor = (pbd->bltFX.dwFillColor & ppdev->physicalColorMask) | ppdev->AlphaEnableValue;

        ppdev->NVFreeCount = freeCount;
        DDRAW_SET_PRIMARY(ppdev, dwDstOffset, dwDstPitch);
        freeCount = ppdev->NVFreeCount;

        while (freeCount < 16)
            freeCount = NvGetFreeCount(npDev, NV_DD_ROP);
        freeCount -= 16;

        npDev->dDrawRop.SetRop5 = SRCCOPYINDEX;
        npDev->subchannel[NV_DD_RECT_AND_TEXT].Nv04GdiRectangleText.Color1A = dwFillColor;

        npDev->subchannel[NV_DD_RECT_AND_TEXT].Nv04GdiRectangleText.UnclippedRectangle[0].point =
        asmMergeCoords(wDestXY.xy16.y, wDestXY.xy16.x);

        npDev->subchannel[NV_DD_RECT_AND_TEXT].Nv04GdiRectangleText.UnclippedRectangle[0].size =
        asmMergeCoords(wXYext.wh16.h, wXYext.wh16.w);

        }
    else if (dwFlags & DDBLT_ZBUFFER)
        {
        /* Hardware Z buffer fills not currently supported when in 32bpp mode */
        DPF("HARDWARE Z BUFFER BLT FAILED");
        ppdev->NVFreeCount = freeCount;
        return DDHAL_DRIVER_NOTHANDLED;
        }
    else
        {
        /* We don't handle any other type of BLT operation */
        ppdev->NVFreeCount = freeCount;
        return DDHAL_DRIVER_NOTHANDLED;
        }

    ppdev->NVFreeCount = freeCount;
    pbd->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;

    } /* Nv4Blt32 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\ddraw\nv4\blt8.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995,1997 NVidia Corporation.  All Rights Reserved.
 *
 *  File:       Nv4Blt8.c
 *  Content:    Windows95 DirectDraw 32 bit driver
 *
 ***************************************************************************/
#include "nvprecomp.h"
#include "nvalpha.h"

#include "ddminint.h"
#include "nv32.h"

#include "nvos.h"
#include "nvntioctl.h"
#include "nvntddctl.h"
#include "nvapi.h"
#include "nvsubch.h"

#define NvGetFreeCount(NN, CH)\
                 (NN)->subchannel[CH].control.Free

/*
 * Nv4Blt8
 *
 * Blt function for 8bpp surfaces.
 */
DWORD __stdcall Nv4Blt8( PDD_BLTDATA pbd )
    {
    FAST Nv3ChannelPio *npDev;
    FAST USHORT freeCount;
    DWORD       dwFlags;
    DWORD       dwDDFX = 0;
    DWORD       dwDstCaps;
    DWORD       dwSrcCaps;
    DWORD       dwRop;
    NVCOORD     wXYext;
    NVCOORD     wDestXY;
    NVCOORD     wSrcXY;
    BYTE        wStretch = 0;
    BYTE        doMirrorUpDown = 0;
    BYTE        isVideo = 0;

    DWORD       dwFillColor;
    DWORD       dwColorKey;

    DWORD       dwDstOffset;
    DWORD       dwDstPitch;
    DWORD       dwDstWidth;
    DWORD       dwDstHeight;

    DWORD       dwSrcOffset;
    DWORD       dwSrcPitch;
    DWORD       dwSrcWidth;
    DWORD       dwSrcHeight;

    PDD_SURFACE_LOCAL  srcx;
    PDD_SURFACE_LOCAL  dstx;
    PDD_SURFACE_GLOBAL  src;
    PDD_SURFACE_GLOBAL  dst;

    PDEV   *ppdev;

    ppdev = (PDEV *) pbd->lpDD->dhpdev;
    dstx = pbd->lpDDDestSurface;
    dst = dstx->lpGbl;
    /*
     * NOTES:
     *
     * Everything you need is in pdb->bltFX .
     * Look at pdb->dwFlags to determine what kind of blt you are doing,
     * DDBLT_xxxx are the flags.
     *
     * ALPHA NOTES:
     *
     * Alpha ALWAYS comes in BLTFX.   You don't need to go looking for
     * the attached surface. If DDBLT_ALPHA is specified, then either a
     * constant alpha or alpha surface has been specified. Just look for
     * DDBLT_ALPHASURFACEOVERRIDE or DDBLT_ALPHACONSTANTOVERRIDE
     *
     * Look for DDBLT_ALPHASURFACEDESTRECT to use the destination rectangle
     * for choosing the rectangle in the alpha surface.   Otherwise use the
     * source rectangle.
     *
     * Z BUFFER NOTES:
     *
     * ZBuffer ALWAYS comes in BLTFX.   You don't need to go looking for
     * the attached surface. If DDBLT_ZBUFFER is specified, then either a
     * constant z or z buffer surface has been specified for the source and
     * destination. Just look for the DDBLT_ZBUFFERDESTOVERRIDE,
     * DDBLT_ZBUFFERSRCOVERRIDE, DDBLT_ZBUFFERCONSTANTDESTOVERRIDE, or
     * DDBLT_ZBUFFERCONSTANTSRCOVERRIDE.
     *
     * COLORKEY NOTES:
     *
     * ColorKey ALWAYS comes in BLTFX.   You don't have to look it up in
     * the surface.
     */

    dwFlags   = pbd->dwFlags;
    dwDstCaps = dstx->ddsCaps.dwCaps;

    if (dwFlags & DDBLT_DDFX)
        dwDDFX = pbd->bltFX.dwDDFX;

//    if (dwFlags & DDOVER_ANYALPHA) {
//        DPF("OVERLAY ALPHA FAILED");
//        pbd->ddRVal = DDERR_NOOVERLAYHW;
//        return DDHAL_DRIVER_HANDLED;
//    }

//    if (dwFlags & DDBLT_ANYALPHA) {
//        DPF("ALPHA ON 8BPP SURFACE FAILED");
//        pbd->ddRVal = DDERR_NOALPHAHW;
//        return DDHAL_DRIVER_HANDLED;
//    }

    if (dwFlags & (DDBLT_KEYDEST | DDBLT_KEYDESTOVERRIDE))
        {
        DPF("DEST COLOR KEY FAILED");
        pbd->ddRVal = DDERR_NOCOLORKEYHW;
        return DDHAL_DRIVER_HANDLED;
        }

    /*
     * get offset, width, and height for destination
     */
    dwDstOffset = dst->fpVidMem;
    dwDstPitch  = dst->lPitch;
    dwDstWidth  = pbd->rDest.right  - pbd->rDest.left;
    dwDstHeight = pbd->rDest.bottom - pbd->rDest.top;
    wXYext.wh16.w = (unsigned short)dwDstWidth;
    wXYext.wh16.h = (unsigned short)dwDstHeight;

    wDestXY.xy16.x = (short)pbd->rDest.left;
    wDestXY.xy16.y = (short)pbd->rDest.top;

    if (dwDstCaps & (DDSCAPS_SYSTEMMEMORY | DDSCAPS_TEXTURE | DDSCAPS_NONLOCALVIDMEM))
        return DDHAL_DRIVER_NOTHANDLED;

    npDev = (Nv3ChannelPio *) ppdev->pjMmBase;

    if (npDev == NULL)
        {
        pbd->ddRVal = DDERR_SURFACELOST;
        return DDHAL_DRIVER_HANDLED;
        }

    freeCount = ppdev->NVFreeCount;

    /*
     * If async, then only work if bltter isn't busy
     * This should probably be a little more specific to each call, but
     * waiting for 32 is pretty close
     */
    if (dwFlags & DDBLT_ASYNC )
        {
        if (freeCount < 32)
            freeCount = NvGetFreeCount(npDev, NV_DD_ROP);

        if ( freeCount < 32 )
            {
            DPF("ASYNC FAILED");
            pbd->ddRVal = DDERR_WASSTILLDRAWING;
            ppdev->NVFreeCount = freeCount;
            return DDHAL_DRIVER_HANDLED;
            }
        }

    if (dwFlags & DDBLT_ROP)
        {
        dwRop = pbd->bltFX.dwROP >> 16;

        if ((dwRop == BLACKNESSINDEX) || (dwRop == WHITENESSINDEX))
            {

            while (freeCount < 7*4)
                freeCount = NvGetFreeCount(npDev, NV_DD_ROP);
            freeCount -= 7*4;

            npDev->dDrawRop.SetRop5 = dwRop;
            npDev->subchannel[NV_DD_PRIMARY].nv4ContextSurfaces2D.SetOffsetSource =
                dwDstOffset;

            npDev->subchannel[NV_DD_PRIMARY].nv4ContextSurfaces2D.SetOffsetDestin =
                dwDstOffset;

            npDev->subchannel[NV_DD_PRIMARY].nv4ContextSurfaces2D.SetPitch = dwDstPitch;

            npDev->subchannel[NV_DD_RECT_AND_TEXT].Nv04GdiRectangleText.Color1A = 0;

            npDev->subchannel[NV_DD_RECT_AND_TEXT].Nv04GdiRectangleText.UnclippedRectangle[0].point =
            asmMergeCoords(wDestXY.xy16.y, wDestXY.xy16.x);

            npDev->subchannel[NV_DD_RECT_AND_TEXT].Nv04GdiRectangleText.UnclippedRectangle[0].size =
            asmMergeCoords(wXYext.wh16.h, wXYext.wh16.w);

            }
        else if ((dwRop == PATCOPYINDEX) || (dwRop == PATINVERTINDEX))
            {

            dwFillColor = (pbd->bltFX.dwFillColor & ppdev->physicalColorMask) | ppdev->AlphaEnableValue;

            if (dwRop == PATCOPYINDEX)
                dwRop = SRCCOPYINDEX;
            else if (dwRop == PATINVERTINDEX)
                dwRop = SRCINVERTINDEX;

            ppdev->NVFreeCount = freeCount;
            DDRAW_SET_PRIMARY(ppdev, dwDstOffset, dwDstPitch);
            freeCount = ppdev->NVFreeCount;

            while (freeCount < 4*4)
                freeCount = NvGetFreeCount(npDev, NV_DD_ROP);
            freeCount -= 4*4;

            npDev->dDrawRop.SetRop5 = dwRop;

            npDev->subchannel[NV_DD_RECT_AND_TEXT].Nv04GdiRectangleText.Color1A = dwFillColor;

            npDev->subchannel[NV_DD_RECT_AND_TEXT].Nv04GdiRectangleText.UnclippedRectangle[0].point =
            asmMergeCoords(wDestXY.xy16.y, wDestXY.xy16.x);

            npDev->subchannel[NV_DD_RECT_AND_TEXT].Nv04GdiRectangleText.UnclippedRectangle[0].size =
            asmMergeCoords(wXYext.wh16.h, wXYext.wh16.w);

            }
        else if ((dwRop == SRCCOPYINDEX) || (dwRop == SRCPAINTINDEX) ||
                 (dwRop == SRCANDINDEX) || (dwRop == NOTSRCCOPYINDEX) ||
                 (dwRop == SRCINVERTINDEX) || (dwRop == MERGEPAINTINDEX) ||
                 (dwRop == SRCERASEINDEX) || (dwRop == NOTSRCERASEINDEX))
            {

            srcx = pbd->lpDDSrcSurface;
            src = srcx->lpGbl;

            dwSrcCaps = srcx->ddsCaps.dwCaps;

            /* We must treat AGP source memory as system memory */
            if (dwSrcCaps & DDSCAPS_NONLOCALVIDMEM)
                {
                dwSrcCaps &= ~(DDSCAPS_VIDEOMEMORY | DDSCAPS_NONLOCALVIDMEM);
                }

            dwSrcOffset = src->fpVidMem;
            dwSrcPitch  = src->lPitch;
            dwSrcWidth  = pbd->rSrc.right  - pbd->rSrc.left;
            dwSrcHeight = pbd->rSrc.bottom - pbd->rSrc.top;
            dwColorKey  = pbd->bltFX.ddckSrcColorkey.dwColorSpaceLowValue;

            wSrcXY.xy16.x = (short)pbd->rSrc.left;
            wSrcXY.xy16.y = (short)pbd->rSrc.top;

            /* We don't handle FOURCC_RGB0 format in 8bpp mode */
            if (//(srcx->dwFlags & DDRAWISURF_HASPIXELFORMAT) &&
                (src->ddpfSurface.dwFlags & DDPF_FOURCC))
                {

                if (src->ddpfSurface.dwFourCC == FOURCC_RGB0)
                    {
                    if ((src->ddpfSurface.dwRBitMask == 0) &&
                        (src->ddpfSurface.dwGBitMask == 0) &&
                        (src->ddpfSurface.dwBBitMask == 0))
                        {
                        if (dwSrcCaps & DDSCAPS_SYSTEMMEMORY)
                            isVideo = 1;
                        goto srcRGB;
                        }
                    else
                        {
                        pbd->ddRVal = DDERR_UNSUPPORTEDFORMAT;
                        ppdev->NVFreeCount = freeCount;
                        return DDHAL_DRIVER_HANDLED;
                        }
                    }
                pbd->ddRVal = DDERR_UNSUPPORTEDFORMAT;
                ppdev->NVFreeCount = freeCount;
                return DDHAL_DRIVER_HANDLED;
                }

            srcRGB:     if (dwDDFX & DDBLTFX_MIRRORUPDOWN)
                doMirrorUpDown = 1;

            if ((dwSrcWidth != dwDstWidth) || (dwSrcHeight != dwDstHeight))
                {
                wStretch = 1;
                }

            if (dwFlags & DDBLT_KEYSRCOVERRIDE)
                {

                dwColorKey = pbd->bltFX.ddckSrcColorkey.dwColorSpaceLowValue;

                while (freeCount < 2*4)
                    freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);
                freeCount -= 2*4;

                if (ppdev->dDrawSpareSubchannelObject != NV_DD_IMAGE_SOLID)
                    {
                    ppdev->dDrawSpareSubchannelObject = NV_DD_IMAGE_SOLID;
                    npDev->dDrawSpare.SetObject = NV_DD_IMAGE_SOLID;
                    }

                // load and enable chroma key
                npDev->dDrawTransColor.SetColor =
                (dwColorKey & ppdev->physicalColorMask) | NV_ALPHA_1_08;
                }

            // screen to screen bitblt
            if (wStretch == 0)
                {

                if ((dwDstCaps & DDSCAPS_VIDEOMEMORY) &&
                    (dwSrcCaps & DDSCAPS_VIDEOMEMORY) &&
                    ((dwSrcCaps & DDSCAPS_TEXTURE) == 0) &&
                    (doMirrorUpDown == 0) &&
                    (isVideo == 0))
                    {


                    ppdev->NVFreeCount = freeCount;
                    DDRAW_SET_PRIMARY(ppdev, dwDstOffset, dwDstPitch);
                    DDRAW_SET_SOURCE(ppdev, dwSrcOffset, dwSrcPitch);

                    freeCount = ppdev->NVFreeCount;
                    while (freeCount < 4*4)
                        freeCount = NvGetFreeCount(npDev, NV_DD_ROP);
                    freeCount -= 4*4;

                    npDev->dDrawRop.SetRop5 = dwRop;

                    npDev->dDrawBlit.ControlPointIn = wSrcXY.xy;
                    npDev->dDrawBlit.ControlPointOut = wDestXY.xy;
                    npDev->dDrawBlit.Size = wXYext.wh;

                    }
                else
                    {
                    // memory to screen blt (src may be in system memory or in video memory)
                    unsigned long temp;
                    long srcScanLength;
                    long nxtSrcScan;
                    short n = wXYext.wh16.h;
                    FAST short pxlCount;
                    unsigned short srcOffset;
                    unsigned char *pSrcInitBits;

                    pSrcInitBits = (unsigned char *) src->fpVidMem;
                    if (dwSrcCaps & DDSCAPS_VIDEOMEMORY)
                        pSrcInitBits += (ULONG) ppdev->pjFrameBufbase;

                    srcScanLength = src->lPitch;

                    if (doMirrorUpDown)
                        wSrcXY.xy16.y += (short)(n - 1);

                    pSrcInitBits += (wSrcXY.xy16.y * srcScanLength);

                    srcOffset = wSrcXY.xy16.x & 3;

                    temp = ((wXYext.wh16.w + srcOffset + 3) & 0xFFFC);

                    nxtSrcScan = srcScanLength - temp;

                    if (doMirrorUpDown)
                        nxtSrcScan = -srcScanLength - temp;

                    pSrcInitBits += (wSrcXY.xy16.x & 0xFFFC);

                    ppdev->NVFreeCount = freeCount;
                    DDRAW_SET_PRIMARY(ppdev, dwDstOffset, dwDstPitch);
                    freeCount = ppdev->NVFreeCount;

                    while (freeCount < 24)
                        freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);
                    freeCount -= 24;

                    // changing canvas clip avoids manually aligning 8-bit source
                    npDev->subchannel[NV_DD_CLIP].Nv01ContextClipRectangle.SetPoint =
                    wDestXY.xy;
                    npDev->subchannel[NV_DD_CLIP].Nv01ContextClipRectangle.SetSize =
                    wXYext.wh;

                    npDev->dDrawRop.SetRop5 = dwRop;

                    /* compiler screws up this expression when it goes negative in following macro */
                    temp = wDestXY.xy16.x - srcOffset;

                    npDev->dDrawImageFromCpu.Point =
                    asmMergeCoords(temp, wDestXY.xy16.y);
                    npDev->dDrawImageFromCpu.SizeOut =
                    asmMergeCoords(wXYext.wh16.w + srcOffset, wXYext.wh16.h);

                    temp = ((wXYext.wh16.w + srcOffset + 3) & 0xFFFC);

                    npDev->dDrawImageFromCpu.SizeIn =
                    asmMergeCoords(temp, wXYext.wh16.h);

                    {
                        FAST unsigned char *pSrcBits = pSrcInitBits;
                        FAST unsigned long tmpPxls0, tmpPxls1, tmpPxls2;

                        while (--n >= 0)
                            {
                            pxlCount = (short)temp;

                            while (pxlCount >= 32)
                                {
                                pxlCount -= 32;

                                while (freeCount < 32)
                                    freeCount = NvGetFreeCount(npDev, NV_DD_IMAGE);
                                freeCount -= 32;

                                tmpPxls0 = *(unsigned long *)&pSrcBits[0];
                                tmpPxls1 = *(unsigned long *)&pSrcBits[4];
                                npDev->dDrawImageFromCpu.Color[0] = tmpPxls0;
                                tmpPxls2 = *(unsigned long *)&pSrcBits[8];
                                npDev->dDrawImageFromCpu.Color[1] = tmpPxls1;
                                tmpPxls0 = *(unsigned long *)&pSrcBits[12];
                                tmpPxls1 = *(unsigned long *)&pSrcBits[16];
                                npDev->dDrawImageFromCpu.Color[2] = tmpPxls2;
                                npDev->dDrawImageFromCpu.Color[3] = tmpPxls0;
                                tmpPxls2 = *(unsigned long *)&pSrcBits[20];
                                tmpPxls0 = *(unsigned long *)&pSrcBits[24];
                                npDev->dDrawImageFromCpu.Color[4] = tmpPxls1;
                                npDev->dDrawImageFromCpu.Color[5] = tmpPxls2;
                                tmpPxls1 = *(unsigned long *)&pSrcBits[28];
                                npDev->dDrawImageFromCpu.Color[6] = tmpPxls0;
                                pSrcBits += 32;
                                npDev->dDrawImageFromCpu.Color[7] = tmpPxls1;
                                }

                            if (pxlCount > 0)
                                {
                                while (freeCount < 32)
                                    freeCount = NvGetFreeCount(npDev, NV_DD_IMAGE);

                                while (pxlCount >= 8)
                                    {
                                    tmpPxls0 = *(unsigned long *)&pSrcBits[0];
                                    tmpPxls1 = *(unsigned long *)&pSrcBits[4];
                                    pxlCount -= 8;
                                    freeCount -= 8;
                                    npDev->dDrawImageFromCpu.Color[0] = tmpPxls0;
                                    npDev->dDrawImageFromCpu.Color[1] = tmpPxls1;
                                    pSrcBits += 8;
                                    }

                                if (pxlCount > 0)
                                    {
                                    tmpPxls0 = *(unsigned long *)&pSrcBits[0];
                                    freeCount -= 4;
                                    pxlCount -= 4;
                                    pSrcBits += 4;
                                    npDev->dDrawImageFromCpu.Color[0] = tmpPxls0;
                                    if (pxlCount > 0)
                                        {
                                        tmpPxls1 = *(unsigned long *)&pSrcBits[0];
                                        npDev->dDrawImageFromCpu.Color[0] = tmpPxls1;
                                        pSrcBits += 4;
                                        freeCount -= 4;
                                        }
                                    }
                                }
                            pSrcBits += nxtSrcScan;
                            }
                    }

                    while (freeCount < 8)
                        freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);
                    freeCount -= 8;

                    // restore canvas clip to something not likely to interfere with rendering
                    npDev->subchannel[NV_DD_CLIP].Nv01ContextClipRectangle.SetPoint =
                    0;
                    npDev->subchannel[NV_DD_CLIP].Nv01ContextClipRectangle.SetSize =
                    asmMergeCoords(ppdev->cxScreen,
                                   ppdev->cyScreen);
                    }
                }
            else
                { // stretch
                DWORD dwStatus;
                NvNotification *pDmaToMemNotifier;
                unsigned char *pScanlineBuffer;
                long srcScanLength;
                long nxtSrcScan;
                long n;
                short m;
                FAST short pxlCount;
                unsigned char *pSrcInitBits;
                unsigned char *pSaveSrcBits;
                unsigned char *pSrcCurScan;
                long deltaX;
                long deltaY;
                long deltaDstY;
                long curDstY;
                long lastDstY;
                long skipSrcBytes = 0;
                NVCOORD wSrcExt;
                NVCOORD wDstPoint;
                unsigned long srcStrtX;
                BYTE srcInVideoMemory = 0;
                BYTE bufState = 0;
                short skipV = 0;
                RECTL rDummy;
                BOOL isOverlappingVmem = FALSE;
                ULONG lpSurfTemp = 0;

                // if the source and destination overlap, then we must do this in 2 passes, first copy the source
                // image somewhere else, and then so the stretch from there.
                if ((dwSrcCaps & DDSCAPS_VIDEOMEMORY) &&
                    dwSrcOffset == dwDstOffset &&
                    bIntersect((RECTL *)(&pbd->rSrc), (RECTL *)(&pbd->rDest), &rDummy))
                    {
                    ULONG tmpBmpPitch = (((dwSrcWidth * (ppdev->cBitsPerPel / 8)) + ppdev->ulSurfaceAlign) & ~ppdev->ulSurfaceAlign);
                    NVHEAP_ALLOC(dwStatus,lpSurfTemp, (DWORD)dwSrcHeight * tmpBmpPitch,  TYPE_IMAGE);
                    if (dwStatus!=0)
                    {
                        bMoveAllDfbsFromOffscreenToDibs(ppdev);
                        NVHEAP_ALLOC(dwStatus,lpSurfTemp, (DWORD)dwSrcHeight * tmpBmpPitch,  TYPE_IMAGE);
                    }

                    if (dwStatus==0)
                        {
                        isOverlappingVmem = TRUE;
                        DDRAW_SET_PRIMARY(ppdev, lpSurfTemp, tmpBmpPitch);
                        DDRAW_SET_SOURCE(ppdev, dwSrcOffset, dwSrcPitch);

                        while (freeCount < 6*4)
                            freeCount = NvGetFreeCount(npDev, 0);
                        freeCount -= 6*4;

						{
							NVCOORD     srcSize;

							srcSize.wh16.w = (unsigned short)dwSrcWidth;
							srcSize.wh16.h = (unsigned short)dwSrcHeight;

							npDev->dDrawRop.SetRop5 = SRCCOPYINDEX;
							npDev->dDrawBlit.ControlPointIn = wSrcXY.xy;
							npDev->dDrawBlit.ControlPointOut = 0;
							npDev->dDrawBlit.Size = srcSize.wh;
						}

                        dwSrcOffset = lpSurfTemp;
                        dwSrcPitch = tmpBmpPitch;
                        wSrcXY.xy = 0;
                        wSrcXY.xy16.x = 0;
                        wSrcXY.xy16.y = 0;
                        }
                    else
                        {
                        // FIXME: vmem heap alloc failed, must do system mem alloc and copy there
                        }
                        // WARNING: carefully consider each use of src->fpVidMem and src->lPitch beyond this point
                        //          it could screw up overlapping stretchblits
                    }

                pSrcInitBits = (unsigned char *) dwSrcOffset;
                if (dwSrcCaps & DDSCAPS_VIDEOMEMORY)
                    pSrcInitBits += (ULONG) ppdev->pjFrameBufbase;

                srcScanLength = dwSrcPitch;

                if (dwSrcPitch <= 800)
                    m = 16;
                else
                    m = 8;

                while (freeCount < 4)
                    freeCount = NvGetFreeCount(npDev, NV_DD_ROP);
                freeCount -= 4;

                npDev->dDrawRop.SetRop5 = dwRop;

                ppdev->NVFreeCount = freeCount;
                DDRAW_SET_PRIMARY(ppdev, dwDstOffset, dwDstPitch);
                freeCount = ppdev->NVFreeCount;

                /* calculate deltas in 12.20 format */
                n = (dwDstWidth << 20) / dwSrcWidth;

                if ((n & 0xFFFFF) == 0)
                    n = 0;
                else
                    {
                    n >>= 20;
                    n += 1;
                    }

                deltaX = (dwDstWidth + n) << 20;
                deltaX /= dwSrcWidth;

                n = (dwDstHeight << 20) / dwSrcHeight;

                if ((n & 0xFFFFF) == 0)
                    n = 0;
                else
                    {
                    n >>= 20;
                    n += 1;
                    }

                deltaY = (dwDstHeight + n) << 20;
                deltaY /= dwSrcHeight;

                deltaDstY = (dwDstHeight << 20);
                deltaDstY /= dwSrcHeight;

                wSrcExt.wh16.w = (unsigned short)((dwSrcWidth + 3) & ~3L);
                wSrcExt.wh16.h = (unsigned short)dwSrcHeight;

                n = (short)dwSrcHeight;

                if ((ULONG) (wSrcXY.xy16.y + n) > src->wHeight)
                    n = src->wHeight - wSrcXY.xy16.y;

                nxtSrcScan = srcScanLength;

                if (doMirrorUpDown)
                    {
                    wSrcXY.xy16.y += (short)(n - 1);
                    nxtSrcScan = -nxtSrcScan;
                    skipSrcBytes = -skipSrcBytes;
                    }

                if ((dwSrcCaps & DDSCAPS_VIDEOMEMORY) &&
                    ((dwSrcCaps & DDSCAPS_TEXTURE) == 0) ||
                    isOverlappingVmem)
                    {
                    srcInVideoMemory = 1;
                    }
                else
                    {
                    pSaveSrcBits = (unsigned char *)(pSrcInitBits +
                                                     (wSrcXY.xy16.y * srcScanLength));
                    pSaveSrcBits += wSrcXY.xy16.x;
                    pSrcCurScan = pSaveSrcBits;
                    }

                if (srcInVideoMemory)
                    {
                    pDmaToMemNotifier = (NvNotification *)ppdev->Notifiers->DmaToMem;
                    pScanlineBuffer = (unsigned char *)ppdev->NvScanlineBufferFlat;

                    wSrcExt.wh16.w = (unsigned short)((dwSrcWidth + 3) & ~3);
                    wSrcExt.wh16.h = m;

                    srcStrtX = wSrcXY.xy16.x;

                    while (freeCount < 4)
                        freeCount = NvGetFreeCount(npDev, NV_DD_IMAGE);
                    freeCount -= 4;

                    npDev->subchannel[NV_DD_SPARE].SetObject =
                        NV_DD_VIDEO_MEM_TO_SYSTEM_MEM_FORMAT;
                    ppdev->dDrawSpareSubchannelObject = NV_DD_VIDEO_MEM_TO_SYSTEM_MEM_FORMAT;

                    // wait for any pending notification operation to finish
                    while ((volatile)pDmaToMemNotifier[NV039_NOTIFIERS_BUFFER_NOTIFY].status == NV_IN_PROGRESS);

                    pDmaToMemNotifier[NV039_NOTIFIERS_BUFFER_NOTIFY].status = NV_IN_PROGRESS;

                    while (freeCount < 32)
                        freeCount = NvGetFreeCount(npDev, NV_DD_IMAGE);
                    freeCount -= 32;

                    npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.OffsetIn =
                    dwSrcOffset +
                    ((dwSrcPitch + skipSrcBytes) * (unsigned long)wSrcXY.xy16.y) +
                    ((unsigned long)wSrcXY.xy16.x);

                    npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.OffsetOut =
                    srcStrtX;

                    npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.PitchIn =
                    (dwSrcPitch + skipSrcBytes);

                    npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.PitchOut =
                    dwSrcPitch;

                    npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.LineLengthIn =
                    (unsigned long)(wSrcExt.wh16.w);

                    npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.LineCount =
                    m;

                    npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.Format =
                        1 | (1 << 8);
                    //NV_MTMF_FORMAT_INPUT_INC_1 | NV_MTMF_FORMAT_OUTPUT_INC_1;

                    npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.BufferNotify =
                    0;

                    // wait for Dma operation to finish
                    while ((volatile)pDmaToMemNotifier[NV039_NOTIFIERS_BUFFER_NOTIFY].status == NV_IN_PROGRESS);

                    if (doMirrorUpDown)
                        wSrcXY.xy16.y -= (m + skipV);
                    else
                        wSrcXY.xy16.y += (m + skipV);
                    }

                /* Convert to 12.4 format */
                wDstPoint.xy16.x = (wDestXY.xy16.x << 4);
                wDstPoint.xy16.y = (wDestXY.xy16.y << 4);

                /* convert to 16.16 */
                lastDstY = (wDestXY.xy16.y + wXYext.wh16.h) << 16;

                /* convert to 16.16 */
                curDstY = (wDestXY.xy16.y << 16);

                while (freeCount < 28)
                    freeCount = NvGetFreeCount(npDev, NV_DD_STRETCH);
                freeCount -= 28;

                npDev->subchannel[NV_DD_SPARE].SetObject =
                NV_DD_STRETCHED_IMAGE_FROM_CPU;
                ppdev->dDrawSpareSubchannelObject = NV_DD_STRETCHED_IMAGE_FROM_CPU;

                npDev->dDrawStretch.nv4StretchedImageFromCpu.ClipPoint =
                wDestXY.xy;

                npDev->dDrawStretch.nv4StretchedImageFromCpu.ClipSize =
                wXYext.wh;

                npDev->dDrawStretch.nv4StretchedImageFromCpu.SizeIn = wSrcExt.wh;

                npDev->dDrawStretch.nv4StretchedImageFromCpu.DeltaDxDu = deltaX;

                npDev->dDrawStretch.nv4StretchedImageFromCpu.DeltaDyDv = deltaY;

                npDev->dDrawStretch.nv4StretchedImageFromCpu.Point12d4 = wDstPoint.xy;

                while ((n > 0) && (curDstY < lastDstY))
                    {
                    FAST unsigned long *pSrcBits;
                    FAST unsigned long tmpPxls0, tmpPxls1, tmpPxls2;

                    if (srcInVideoMemory)
                        {
                        if (bufState == 0)
                            pSrcBits = (unsigned long *)(pScanlineBuffer + srcStrtX);
                        else
                            pSrcBits = (unsigned long *)(pScanlineBuffer +
                                                         (NV_DMA_SCANLINE_BUF_SIZE >> 1) + srcStrtX);

                        pSrcCurScan = (unsigned char *)pSrcBits;

                        if (m > 0)
                            {
                            pDmaToMemNotifier[NV039_NOTIFIERS_BUFFER_NOTIFY].status = NV_IN_PROGRESS;

                            while (freeCount < 36)
                                freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);
                            freeCount -= 36;

                            npDev->subchannel[NV_DD_SPARE].SetObject = NV_DD_VIDEO_MEM_TO_SYSTEM_MEM_FORMAT;
                            ppdev->dDrawSpareSubchannelObject = NV_DD_VIDEO_MEM_TO_SYSTEM_MEM_FORMAT;

                            npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.OffsetIn =
                            dwSrcOffset +
                            ((dwSrcPitch + skipSrcBytes) * (unsigned long)wSrcXY.xy16.y) +
                            ((unsigned long)wSrcXY.xy16.x);

                            if (bufState == 0)
                                npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.OffsetOut =
                                (NV_DMA_SCANLINE_BUF_SIZE >> 1) +
                                srcStrtX;
                            else
                                npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.OffsetOut =
                                srcStrtX;

                            npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.PitchIn =
                            (dwSrcPitch + skipSrcBytes);

                            npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.PitchOut =
                            dwSrcPitch;

                            npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.LineLengthIn =
                            (unsigned long)(wSrcExt.wh16.w);

                            npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.LineCount =
                            m;

                            npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.Format =
                                1 | (1 << 8);
                            //NV_MTMF_FORMAT_INPUT_INC_1 | NV_MTMF_FORMAT_OUTPUT_INC_1;

                            npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.BufferNotify =
                            0;

                            bufState ^= 1;

                            if (doMirrorUpDown)
                                wSrcXY.xy16.y -= (m + skipV);
                            else
                                wSrcXY.xy16.y += (m + skipV);

                            while (freeCount < 28)
                                freeCount = NvGetFreeCount(npDev, NV_DD_STRETCH);
                            freeCount -= 28;

                            npDev->subchannel[NV_DD_SPARE].SetObject =
                            NV_DD_STRETCHED_IMAGE_FROM_CPU;
                            ppdev->dDrawSpareSubchannelObject = NV_DD_STRETCHED_IMAGE_FROM_CPU;


                            npDev->dDrawStretch.nv4StretchedImageFromCpu.ClipPoint =
                            wDestXY.xy;
                            npDev->dDrawStretch.nv4StretchedImageFromCpu.ClipSize =
                            wXYext.wh;
                            npDev->dDrawStretch.nv4StretchedImageFromCpu.SizeIn =
                            wSrcExt.wh;
                            npDev->dDrawStretch.nv4StretchedImageFromCpu.DeltaDxDu =
                            deltaX;
                            npDev->dDrawStretch.nv4StretchedImageFromCpu.DeltaDyDv =
                            deltaY;
                            npDev->dDrawStretch.nv4StretchedImageFromCpu.Point12d4 =
                            wDstPoint.xy;
                            }
                        }
                    else
                        { // source in system memory
                        pSrcBits = (unsigned long *)pSrcCurScan;
                        pSrcCurScan += (nxtSrcScan + skipSrcBytes);
                        n--;
                        }


                    doNxtSrcScan:      pxlCount = (short)((dwSrcWidth + 3) & ~3);

                    while (pxlCount >= 64)
                        {

                        pxlCount -= 64;

                        while (freeCount < 64)
                            freeCount = NvGetFreeCount(npDev, NV_DD_STRETCH);
                        freeCount -= 64;

                        tmpPxls0 = pSrcBits[0];
                        tmpPxls1 = pSrcBits[1];
                        npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[0] = tmpPxls0;
                        tmpPxls2 = pSrcBits[2];
                        npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[1] = tmpPxls1;
                        tmpPxls0 = pSrcBits[3];
                        tmpPxls1 = pSrcBits[4];
                        npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[2] = tmpPxls2;
                        npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[3] = tmpPxls0;
                        tmpPxls2 = pSrcBits[5];
                        tmpPxls0 = pSrcBits[6];
                        npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[4] = tmpPxls1;
                        npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[5] = tmpPxls2;
                        tmpPxls1 = pSrcBits[7];
                        tmpPxls2 = pSrcBits[8];
                        npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[6] = tmpPxls0;
                        npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[7] = tmpPxls1;
                        tmpPxls0 = pSrcBits[9];
                        tmpPxls1 = pSrcBits[10];
                        npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[8] = tmpPxls2;
                        npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[9] = tmpPxls0;
                        tmpPxls2 = pSrcBits[11];
                        tmpPxls0 = pSrcBits[12];
                        npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[10] = tmpPxls1;
                        npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[11] = tmpPxls2;
                        tmpPxls1 = pSrcBits[13];
                        tmpPxls2 = pSrcBits[14];
                        npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[12] = tmpPxls0;
                        npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[13] = tmpPxls1;
                        tmpPxls0 = pSrcBits[15];
                        npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[14] = tmpPxls2;
                        pSrcBits += 16;
                        npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[15] = tmpPxls0;
                        }

                    while (pxlCount >= 32)
                        {

                        pxlCount -= 32;

                        while (freeCount < 32)
                            freeCount = NvGetFreeCount(npDev, NV_DD_STRETCH);
                        freeCount -= 32;

                        tmpPxls0 = pSrcBits[0];
                        tmpPxls1 = pSrcBits[1];
                        npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[0] = tmpPxls0;
                        tmpPxls2 = pSrcBits[2];
                        npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[1] = tmpPxls1;
                        tmpPxls0 = pSrcBits[3];
                        tmpPxls1 = pSrcBits[4];
                        npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[2] = tmpPxls2;
                        npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[3] = tmpPxls0;
                        tmpPxls2 = pSrcBits[5];
                        tmpPxls0 = pSrcBits[6];
                        npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[4] = tmpPxls1;
                        npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[5] = tmpPxls2;
                        tmpPxls1 = pSrcBits[7];
                        pSrcBits += 8;
                        npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[6] = tmpPxls0;
                        npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[7] = tmpPxls1;
                        }

                    while (freeCount < 32)
                        freeCount = NvGetFreeCount(npDev, NV_DD_STRETCH);
                    freeCount -= 32;

                    while (pxlCount >= 4)
                        {
                        tmpPxls0 = pSrcBits[0];
                        pxlCount -= 4;
                        npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[0] = tmpPxls0;
                        pSrcBits += 1;
                        }

                    if (srcInVideoMemory)
                        {
                        if (--m > 0)
                            {
                            pSrcCurScan += dwSrcPitch;

                            pSrcBits = (unsigned long *)pSrcCurScan;

                            goto doNxtSrcScan;
                            }
                        else
                            {
                            if (dwSrcPitch <= 800)
                                {
                                m = 16;
                                curDstY += deltaDstY;
                                }
                            else
                                {
                                m = 8;
                                curDstY += (deltaDstY >> 1);
                                }
                            /* convert 16.16 to 12.4 */
                            wDstPoint.xy16.y = (short)(curDstY >> 12);

                            // wait for DMA operation to finish
                            while ((volatile)pDmaToMemNotifier[NV076_NOTIFIERS_NOTIFY].status == NV_IN_PROGRESS);
                            }
                        }
                    }
                    if (isOverlappingVmem && lpSurfTemp)
                        {
                        NVHEAP_FREE(lpSurfTemp);
                        }
                }

            if (dwFlags & DDBLT_KEYSRCOVERRIDE)
                {
                while (freeCount < 2*4)
                    freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);
                freeCount -= 2*4;
                if (ppdev->dDrawSpareSubchannelObject != NV_DD_IMAGE_SOLID)
                    {
                    npDev->subchannel[NV_DD_SPARE].SetObject = NV_DD_IMAGE_SOLID;
                    ppdev->dDrawSpareSubchannelObject = NV_DD_IMAGE_SOLID;
                    }
                    // disable chroma key
                    npDev->dDrawTransColor.SetColor = 0;

                }
            }
        else
            {
            DPF("BLT     blt not handled by driver");
            ppdev->NVFreeCount = freeCount;
            return DDHAL_DRIVER_NOTHANDLED;
            }
        }
    else if (dwFlags & DDBLT_COLORFILL)
        {
        dwFillColor = (pbd->bltFX.dwFillColor & ppdev->physicalColorMask) | ppdev->AlphaEnableValue;

        ppdev->NVFreeCount = freeCount;
        DDRAW_SET_PRIMARY(ppdev, dwDstOffset, dwDstPitch);
        freeCount = ppdev->NVFreeCount;

        while (freeCount < 16)
            freeCount = NvGetFreeCount(npDev, NV_DD_ROP);
        freeCount -= 16;

        npDev->dDrawRop.SetRop5 = SRCCOPYINDEX;

        npDev->subchannel[NV_DD_RECT_AND_TEXT].Nv04GdiRectangleText.Color1A = dwFillColor;

        npDev->subchannel[NV_DD_RECT_AND_TEXT].Nv04GdiRectangleText.UnclippedRectangle[0].point =
        asmMergeCoords(wDestXY.xy16.y, wDestXY.xy16.x);

        npDev->subchannel[NV_DD_RECT_AND_TEXT].Nv04GdiRectangleText.UnclippedRectangle[0].size =
        asmMergeCoords(wXYext.wh16.h, wXYext.wh16.w);

        }
    else if (dwFlags & DDBLT_ZBUFFER)
        {
        /* Hardware Z buffer fills not currently supported when in 8bpp mode */
        DPF("HARDWARE Z BUFFER BLT FAILED");
        ppdev->NVFreeCount = freeCount;
        return DDHAL_DRIVER_NOTHANDLED;
        }
    else
        {
        DPF("BLT     blt not handled by driver");
        /* We don't handle any other type of BLT operation */
        ppdev->NVFreeCount = freeCount;
        return DDHAL_DRIVER_NOTHANDLED;
        }

    pbd->ddRVal = DD_OK;
    ppdev->NVFreeCount = freeCount;
    return DDHAL_DRIVER_HANDLED;

    } /* Nv4Blt8 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\ddraw\nv4\blt16.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995,1997 NVidia Corporation.  All Rights Reserved.
 *
 *  File:       Nv4Blt16.c
 *  Content:    Windows95 DirectDraw 32 bit driver
 *
 ***************************************************************************/
#include "nvprecomp.h"
#include "nvalpha.h"
#include "ddminint.h"
#include "nv32.h"

#include "nvos.h"
#include "nvntioctl.h"
#include "nvntddctl.h"
#include "nvapi.h"
#include "nvsubch.h"

#ifdef NVD3D
    VOID nvTexBLT16BPP(int, int, int, int, int, int, int, int, int, int, int, int, int);
#endif

#define NvGetFreeCount(NN, CH)\
                 (NN)->subchannel[CH].control.Free


/*
 * Nv4Blt16
 *
 * NV4 Blt function for 16bpp surfaces.
 */
DWORD __stdcall Nv4Blt16( PDD_BLTDATA pbd )
    {
    DWORD dwStatus;
    FAST Nv3ChannelPio *npDev;
    FAST USHORT freeCount;
    DWORD       dwFlags;
    DWORD       dwDstCaps;
    DWORD       dwSrcCaps;
    DWORD       dwDDFX = 0;
    DWORD       dwRop;
    NVCOORD     wXYext;
    NVCOORD     wDestXY;
    NVCOORD     wSrcXY;
    BYTE        wStretch = 0;
    BYTE        doMirrorUpDown = 0;
    BYTE        isVideo = 0;
//    BYTE        doAlpha = 0;

    DWORD       dwFillColor;
    DWORD       dwColorKey;

    DWORD       dwDstOffset;
    DWORD       dwDstPitch;
    DWORD       dwDstWidth;
    DWORD       dwDstHeight;

    DWORD       dwSrcOffset;
    DWORD       dwSrcPitch;
    DWORD       dwSrcWidth;
    DWORD       dwSrcHeight;

    PDD_SURFACE_LOCAL  srcx;
    PDD_SURFACE_LOCAL  dstx;
    PDD_SURFACE_GLOBAL  src;
    PDD_SURFACE_GLOBAL  dst;
    PDEV    *ppdev;

    dstx = pbd->lpDDDestSurface;
    dst = dstx->lpGbl;
    ppdev = (PDEV*) pbd->lpDD->dhpdev;

    /*
     * NOTES:
     *
     * Everything you need is in pdb->bltFX .
     * Look at pdb->dwFlags to determine what kind of blt you are doing,
     * DDBLT_xxxx are the flags.
     *
     * ALPHA NOTES:
     *
     * Alpha ALWAYS comes in BLTFX.   You don't need to go looking for
     * the attached surface. If DDBLT_ALPHA is specified, then either a
     * constant alpha or alpha surface has been specified. Just look for
     * DDBLT_ALPHASURFACEOVERRIDE or DDBLT_ALPHACONSTANTOVERRIDE
     *
     * Look for DDBLT_ALPHASURFACEDESTRECT to use the destination rectangle
     * for choosing the rectangle in the alpha surface.   Otherwise use the
     * source rectangle.
     *
     * Z BUFFER NOTES:
     *
     * ZBuffer ALWAYS comes in BLTFX.   You don't need to go looking for
     * the attached surface. If DDBLT_ZBUFFER is specified, then either a
     * constant z or z buffer surface has been specified for the source and
     * destination. Just look for the DDBLT_ZBUFFERDESTOVERRIDE,
     * DDBLT_ZBUFFERSRCOVERRIDE, DDBLT_ZBUFFERCONSTANTDESTOVERRIDE, or
     * DDBLT_ZBUFFERCONSTANTSRCOVERRIDE.
     *
     * COLORKEY NOTES:
     *
     * ColorKey ALWAY comes in BLTFX.   You don't have to look it up in
     * the surface.
     */

    dwFlags   = pbd->dwFlags;
    dwDstCaps = dstx->ddsCaps.dwCaps;

#ifndef NVD3D
    if (dwDstCaps & (DDSCAPS_SYSTEMMEMORY | DDSCAPS_TEXTURE | DDSCAPS_NONLOCALVIDMEM))
        return DDHAL_DRIVER_NOTHANDLED;
#else   // NVD3D
    /*
     * Check for a 16 Bpp texture blit right ways.
     */
    if ((dwDstCaps & DDSCAPS_TEXTURE) && (dwDstCaps & DDSCAPS_VIDEOMEMORY))
        {
        /*
         * Call the special D3D Texture blit code to handle this blit.
         */
        if (srcx = pbd->lpDDSrcSurface)
        {
            src  = srcx->lpGbl;
            nvTexBLT16BPP(pbd->rSrc.left,
              pbd->rSrc.top,
              pbd->rSrc.right,
              pbd->rSrc.bottom,
              src->wWidth,
              src->wHeight,
              src->fpVidMem,
              src->lPitch,
              pbd->rDest.left,
              pbd->rDest.top,
              dst->wWidth,
              dst->wHeight,
              dst->fpVidMem + (DWORD)ppdev->pjFrameBufbase);
        }
        /*
         * Return successfully.
         */
        pbd->ddRVal = DD_OK;
        return DDHAL_DRIVER_HANDLED;
        }

    /*
     * Check for any non video memory blits and reject them right away.
     */
    if (dwDstCaps & (DDSCAPS_SYSTEMMEMORY | DDSCAPS_NONLOCALVIDMEM))
        return DDHAL_DRIVER_NOTHANDLED;
#endif  // NVD3D

    if (dwFlags & DDBLT_DDFX)
        dwDDFX = pbd->bltFX.dwDDFX;

//    if (dwFlags & DDOVER_ANYALPHA) {
//        DPF("Overlay Alpha failed");
//        pbd->ddRVal = DDERR_NOOVERLAYHW;
//        return DDHAL_DRIVER_HANDLED;
//    }

//    if (dwFlags & DDBLT_ANYALPHA) {
//        DPF("Alpha requested");
//        if ((dwFlags & DDBLT_ALPHASRCCONSTOVERRIDE) == 0) {
//            pbd->ddRVal = DDERR_NOALPHAHW;
//            return DDHAL_DRIVER_HANDLED;
//        } else
//            doAlpha = 1;
//    }

    if (dwFlags & (DDBLT_KEYDEST | DDBLT_KEYDESTOVERRIDE))
        {
        DPF("Dest color key failed");
        pbd->ddRVal = DDERR_NOCOLORKEYHW;
        return DDHAL_DRIVER_HANDLED;
        }

    /*
     * get offset, width, and height for destination
     */
    dwDstOffset = dst->fpVidMem;
    dwDstPitch  = dst->lPitch;
    dwDstWidth  = pbd->rDest.right  - pbd->rDest.left;
    dwDstHeight = pbd->rDest.bottom - pbd->rDest.top;
    wXYext.wh16.w = (unsigned short)dwDstWidth;
    wXYext.wh16.h = (unsigned short)dwDstHeight;

    wDestXY.xy16.x = (short)pbd->rDest.left;
    wDestXY.xy16.y = (short)pbd->rDest.top;

    npDev = (Nv3ChannelPio *)ppdev->ddChannelPtr;

    if (npDev == NULL)
        {
        pbd->ddRVal = DDERR_SURFACELOST;
        return DDHAL_DRIVER_HANDLED;
        }

    freeCount = ppdev->NVFreeCount;

    /*
     * If async, then only work if bltter isn't busy
     * This should probably be a little more specific to each call, but
     * waiting for 32 is pretty close
     */
    if ( dwFlags & DDBLT_ASYNC )
        {
        if (freeCount < 32)
            freeCount = NvGetFreeCount(npDev, 0);

        if ( freeCount < 32 )
            {
            DPF("Asynchronous blit failed");
            pbd->ddRVal = DDERR_WASSTILLDRAWING;
            ppdev->NVFreeCount = freeCount;
            return DDHAL_DRIVER_HANDLED;
            }
        }

    if (dwFlags & DDBLT_ROP)
        {
        dwRop = pbd->bltFX.dwROP >> 16;

        if ((dwRop == BLACKNESSINDEX) || (dwRop == WHITENESSINDEX))
            {

            DDRAW_SET_PRIMARY(ppdev, dwDstOffset, dwDstPitch);

            while (freeCount < 4*4)
                freeCount = NvGetFreeCount(npDev, 0);
            freeCount -= 4*4;

            npDev->subchannel[NV_DD_ROP].Nv03ContextRop.SetRop5 = dwRop;

            npDev->subchannel[NV_DD_RECT_AND_TEXT].Nv04GdiRectangleText.Color1A =
            0;

            npDev->subchannel[NV_DD_RECT_AND_TEXT].Nv04GdiRectangleText.UnclippedRectangle[0].point =
            asmMergeCoords(wDestXY.xy16.y, wDestXY.xy16.x);

            npDev->subchannel[NV_DD_RECT_AND_TEXT].Nv04GdiRectangleText.UnclippedRectangle[0].size =
            asmMergeCoords(wXYext.wh16.h, wXYext.wh16.w);

            }
        else if ((dwRop == PATCOPYINDEX) || (dwRop == PATINVERTINDEX))
            {

            dwFillColor = (pbd->bltFX.dwFillColor & ppdev->physicalColorMask) | ppdev->AlphaEnableValue;
            DDRAW_SET_PRIMARY(ppdev, dwDstOffset, dwDstPitch);
            while (freeCount < 16)
                freeCount = NvGetFreeCount(npDev, NV_DD_ROP);
            freeCount -= 16;

            if (dwRop == PATCOPYINDEX)
                dwRop = SRCCOPYINDEX;
            else if (dwRop == PATINVERTINDEX)
                dwRop = SRCINVERTINDEX;

            npDev->dDrawRop.SetRop5 = dwRop;

            npDev->subchannel[NV_DD_RECT_AND_TEXT].Nv04GdiRectangleText.Color1A = dwFillColor;

            npDev->subchannel[NV_DD_RECT_AND_TEXT].Nv04GdiRectangleText.UnclippedRectangle[0].point =
            asmMergeCoords(wDestXY.xy16.y, wDestXY.xy16.x);

            npDev->subchannel[NV_DD_RECT_AND_TEXT].Nv04GdiRectangleText.UnclippedRectangle[0].size =
            asmMergeCoords(wXYext.wh16.h, wXYext.wh16.w);

            }
        else if ((dwRop == SRCCOPYINDEX) || (dwRop == SRCPAINTINDEX) ||
                 (dwRop == SRCANDINDEX) || (dwRop == NOTSRCCOPYINDEX) ||
                 (dwRop == SRCINVERTINDEX) || (dwRop == MERGEPAINTINDEX) ||
                 (dwRop == SRCERASEINDEX) || (dwRop == NOTSRCERASEINDEX))
            {
            srcx = pbd->lpDDSrcSurface;
            src = srcx->lpGbl;

            dwSrcCaps = srcx->ddsCaps.dwCaps;

            /* We must treat AGP source memory as system memory */
            if (dwSrcCaps & DDSCAPS_NONLOCALVIDMEM)
                {
                dwSrcCaps &= ~(DDSCAPS_VIDEOMEMORY | DDSCAPS_NONLOCALVIDMEM);
                }

            dwSrcOffset = src->fpVidMem;
            dwSrcPitch  = src->lPitch;
            dwSrcWidth  = pbd->rSrc.right  - pbd->rSrc.left;
            dwSrcHeight = pbd->rSrc.bottom - pbd->rSrc.top;
            dwColorKey  = pbd->bltFX.ddckSrcColorkey.dwColorSpaceLowValue;

            wSrcXY.xy16.x = (short)pbd->rSrc.left;
            wSrcXY.xy16.y = (short)pbd->rSrc.top;

            // if ((srcx->dwFlags & DDRAWISURF_HASPIXELFORMAT) &&
            if (src->ddpfSurface.dwFlags & DDPF_FOURCC)
                {

                if (src->ddpfSurface.dwFourCC == FOURCC_RGB0)
                    {
                    if ((src->ddpfSurface.dwRBitMask == 0x00007C00) &&
                        (src->ddpfSurface.dwGBitMask == 0x000003E0) &&
                        (src->ddpfSurface.dwBBitMask == 0x0000001F))
                        {
                        if (dwSrcCaps & DDSCAPS_SYSTEMMEMORY)
                            isVideo = 1;
                        goto srcRGB;
                        }
                    else
                        {
                        pbd->ddRVal = DDERR_UNSUPPORTEDFORMAT;
                        ppdev->NVFreeCount = freeCount;
                        return DDHAL_DRIVER_HANDLED;
                        }
                    }
                DDRAW_SET_PRIMARY(ppdev, dwDstOffset, dwDstPitch);
                while (freeCount < 4 )
                    freeCount = NvGetFreeCount(npDev, NV_DD_ROP);
                freeCount -= 4;

                npDev->dDrawRop.SetRop5 = SRCCOPYINDEX;

                switch (src->ddpfSurface.dwFourCC)
                    {
                    case FOURCC_UYVY:
                    case FOURCC_YUY2:
//                     if (dwSrcWidth & 1) {  NEC MPEG CODEC DOESN'T RESPOND TO THIS ERROR
//                           pbd->ddRVal = DDERR_INVALIDRECT;
//                           return DDHAL_DRIVER_HANDLED;
//                       }

                        if (wSrcXY.xy16.x & 1)
                            {
                            pbd->ddRVal = DDERR_INVALIDRECT;
                            ppdev->NVFreeCount = freeCount;
                            return DDHAL_DRIVER_HANDLED;
                            }

                        if (src->ddpfSurface.dwFourCC == FOURCC_UYVY)
                            {
                            isVideo = 2;
                            // Is this surface DMAable ?
                            if ((ppdev->fNvActiveFloatingContexts &
                                 NV_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY) &&
                                (ppdev->NvFloating0UYVYSurfaceMem == (ULONG) src->fpVidMem))
                                isVideo = 4;
                            else if ((ppdev->fNvActiveFloatingContexts &
                                      NV_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY) &&
                                     (ppdev->NvFloating1UYVYSurfaceMem == (ULONG) src->fpVidMem))
                                isVideo = 5;
                            }
                        else
                            { // YUY2
                            isVideo = 3;
                            // Is this surface DMAable ?
                            if ((ppdev->fNvActiveFloatingContexts &
                                 NV_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY) &&
                                (ppdev->NvFloating0YUYVSurfaceMem == (ULONG) src->fpVidMem))
                                isVideo = 6;
                            else if ((ppdev->fNvActiveFloatingContexts &
                                      NV_FLOATING1_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY) &&
                                     (ppdev->NvFloating1YUYVSurfaceMem == (ULONG) src->fpVidMem))
                                isVideo = 7;
                            }
                        goto srcRGB;
                        break;
#ifdef YV12_SUPPORT
                    case FOURCC_YV12:
                        // Size has to be always * 4, to use VU subsampling
                        if ((dwSrcWidth & 3) || (dwSrcHeight & 3))
                            {
                            pbd->ddRVal = DDERR_INVALIDRECT;
                            ppdev->NVFreeCount = freeCount;
                            return DDHAL_DRIVER_HANDLED;
                            }

//                     pbd->ddRVal = nvStretchYVU12ToDev (pbd, src->ddpfSurface.dwFourCC);
                        ppdev->NVFreeCount = freeCount;
                        return DDHAL_DRIVER_HANDLED;
                        break;
#endif
                    }
                pbd->ddRVal = DDERR_UNSUPPORTEDFORMAT;
                ppdev->NVFreeCount = freeCount;
                return DDHAL_DRIVER_HANDLED;
                }

            srcRGB:     if (dwDDFX & DDBLTFX_MIRRORUPDOWN)
                doMirrorUpDown = 1;

            if ((dwSrcWidth != dwDstWidth) || (dwSrcHeight != dwDstHeight))
                wStretch = 1;

            if (isVideo > 1) /* YUV video */
                wStretch = 1;

            if (dwFlags & DDBLT_KEYSRCOVERRIDE)
                {

                dwColorKey = pbd->bltFX.ddckSrcColorkey.dwColorSpaceLowValue;

                while (freeCount < 2*4)
                    freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);

                // load and enable chroma key
                freeCount -= 2*4;
                if (ppdev->dDrawSpareSubchannelObject != NV_DD_IMAGE_SOLID)
                    {
                    npDev->dDrawSpare.SetObject = NV_DD_IMAGE_SOLID;
                    ppdev->dDrawSpareSubchannelObject = NV_DD_IMAGE_SOLID;
                    }
                npDev->dDrawTransColor.SetColor =
                (dwColorKey & ppdev->physicalColorMask) | NV_ALPHA_1_565;

                }

            // screen to screen bitblt
            if (wStretch == 0)
                {

                if ((dwDstCaps & DDSCAPS_VIDEOMEMORY) &&
                    (dwSrcCaps & DDSCAPS_VIDEOMEMORY) &&
                    ((dwSrcCaps & DDSCAPS_TEXTURE) == 0) &&
                    (doMirrorUpDown == 0) &&
                    (isVideo == 0))
                    {
                    DDRAW_SET_PRIMARY(ppdev, dwDstOffset, dwDstPitch);
                    DDRAW_SET_SOURCE(ppdev, dwSrcOffset, dwSrcPitch);

                    while (freeCount < 4*4)
                        freeCount = NvGetFreeCount(npDev, NV_DD_ROP);
                    freeCount -= 4*4;

                    npDev->dDrawRop.SetRop5 = dwRop;

                    npDev->dDrawBlit.ControlPointIn = wSrcXY.xy;
                    npDev->dDrawBlit.ControlPointOut = wDestXY.xy;
                    npDev->dDrawBlit.Size = wXYext.wh;

                    }
                else
                    {
                    // memory to screen blt (src may be in system memory or in video memory)
                    unsigned long temp;
                    long srcScanLength;
                    long nxtSrcScan;
                    short n = wXYext.wh16.h;
                    FAST short pxlCount;
                    unsigned long srcOffset;
                    unsigned char *pSrcInitBits;

                    pSrcInitBits = (unsigned char *) src->fpVidMem;
                    if (dwSrcCaps & DDSCAPS_VIDEOMEMORY)
                        pSrcInitBits += (ULONG) ppdev->pjFrameBufbase;

                    srcScanLength = src->lPitch;

                    if (doMirrorUpDown)
                        wSrcXY.xy16.y += (short)(n - 1);

                    pSrcInitBits += (wSrcXY.xy16.y * srcScanLength);

                    srcOffset = wSrcXY.xy16.x & 1;

                    temp = ((wXYext.wh16.w + 1 + srcOffset) & 0xFFFE);

                    nxtSrcScan = (srcScanLength >> 1) - temp;

                    if (doMirrorUpDown)
                        nxtSrcScan = -(srcScanLength >> 1) - temp;

                    pSrcInitBits += ((wSrcXY.xy16.x & 0xFFFE) << 1);
                    DDRAW_SET_PRIMARY(ppdev, dwDstOffset, dwDstPitch);
                    while (freeCount < 6*4)
                        freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);
                    freeCount -= 6*4;

                    // changing canvas clip avoids manually aligning 16-bit source /
                    npDev->subchannel[NV_DD_CLIP].Nv01ContextClipRectangle.SetPoint =
                    wDestXY.xy;
                    npDev->subchannel[NV_DD_CLIP].Nv01ContextClipRectangle.SetSize =
                    wXYext.wh;
                    ppdev->DdClipResetFlag = TRUE;

                    npDev->dDrawRop.SetRop5 = dwRop;

                    npDev->dDrawImageFromCpu.Point =
                    asmMergeCoords((wDestXY.xy16.x - srcOffset), wDestXY.xy16.y);
                    npDev->dDrawImageFromCpu.SizeOut =
                    asmMergeCoords(wXYext.wh16.w + srcOffset, wXYext.wh16.h);

                    npDev->dDrawImageFromCpu.SizeIn =
                    asmMergeCoords(temp, wXYext.wh16.h);

                    {
                        FAST unsigned short *pSrcBits = (unsigned short *)pSrcInitBits;
                        FAST unsigned long tmpPxls0, tmpPxls1, tmpPxls2;

                        while (--n >= 0)
                            {
                            pxlCount = (short)temp;

                            while (pxlCount >= 16)
                                {
                                pxlCount -= 16;

                                while (freeCount < 32)
                                    freeCount = NvGetFreeCount(npDev, NV_DD_IMAGE);
                                freeCount -= 32;

                                tmpPxls0 = *(unsigned long *)&pSrcBits[0];
                                tmpPxls1 = *(unsigned long *)&pSrcBits[2];
                                npDev->dDrawImageFromCpu.Color[0] = tmpPxls0;
                                tmpPxls2 = *(unsigned long *)&pSrcBits[4];
                                npDev->dDrawImageFromCpu.Color[1] = tmpPxls1;
                                tmpPxls0 = *(unsigned long *)&pSrcBits[6];
                                tmpPxls1 = *(unsigned long *)&pSrcBits[8];
                                npDev->dDrawImageFromCpu.Color[2] = tmpPxls2;
                                npDev->dDrawImageFromCpu.Color[3] = tmpPxls0;
                                tmpPxls2 = *(unsigned long *)&pSrcBits[10];
                                tmpPxls0 = *(unsigned long *)&pSrcBits[12];
                                npDev->dDrawImageFromCpu.Color[4] = tmpPxls1;
                                npDev->dDrawImageFromCpu.Color[5] = tmpPxls2;
                                tmpPxls1 = *(unsigned long *)&pSrcBits[14];
                                npDev->dDrawImageFromCpu.Color[6] = tmpPxls0;
                                pSrcBits += 16;
                                npDev->dDrawImageFromCpu.Color[7] = tmpPxls1;
                                }

                            if (pxlCount > 0)
                                {
                                while (freeCount < 32)
                                    freeCount = NvGetFreeCount(npDev, NV_DD_IMAGE);

                                while (pxlCount >= 4)
                                    {
                                    tmpPxls0 = *(unsigned long *)&pSrcBits[0];
                                    tmpPxls1 = *(unsigned long *)&pSrcBits[2];
                                    pxlCount -= 4;
                                    freeCount -= 8;
                                    npDev->dDrawImageFromCpu.Color[0] = tmpPxls0;
                                    npDev->dDrawImageFromCpu.Color[1] = tmpPxls1;
                                    pSrcBits += 4;
                                    }

                                if (pxlCount > 0)
                                    {
                                    tmpPxls0 = *(unsigned long *)&pSrcBits[0];
                                    freeCount -= 4;
                                    pSrcBits += 2;
                                    npDev->dDrawImageFromCpu.Color[0] = tmpPxls0;
                                    }
                                }
                            pSrcBits += nxtSrcScan;
                            }
                    }

                    while (freeCount < 8)
                        freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);
                    freeCount -= 8;

                    // restore canvas clip
                    if (ppdev->DdClipResetFlag)
                        {
                        npDev->subchannel[NV_DD_CLIP].Nv01ContextClipRectangle.SetPoint =
                            0;
                        npDev->subchannel[NV_DD_CLIP].Nv01ContextClipRectangle.SetSize =
                            asmMergeCoords(ppdev->cBitsPerPel,
                                       ppdev->cyMemory);
                        ppdev->DdClipResetFlag = FALSE;
                        }
                    }
                }
            else
                {
                // stretch
                RECTL rDummy;
                BOOL isOverlappingVmem = FALSE;
                ULONG lpSurfTemp = 0;
                DWORD dwSrcBitsPP = 16;
                // if the source and destination overlap, then we must do this in 2 passes, first copy the source
                // image somewhere else, and then so the stretch from there.
                if ((dwSrcCaps & DDSCAPS_VIDEOMEMORY) && dwSrcOffset == dwDstOffset && bIntersect((RECTL *)(&pbd->rSrc), (RECTL *)(&pbd->rDest), &rDummy))
                    {
                    ULONG tmpBmpPitch = (((dwSrcWidth * (ppdev->cBitsPerPel / 8)) + ppdev->ulSurfaceAlign) & ~ppdev->ulSurfaceAlign);
                    NVHEAP_ALLOC(dwStatus,lpSurfTemp, (DWORD)dwSrcHeight * tmpBmpPitch,  TYPE_IMAGE);
                    if (dwStatus!=0)
                    {
                        bMoveAllDfbsFromOffscreenToDibs(ppdev);
                        NVHEAP_ALLOC(dwStatus, lpSurfTemp, (DWORD)dwSrcHeight * tmpBmpPitch,  TYPE_IMAGE);
                    }

                    if (dwStatus==0) {
                        isOverlappingVmem = TRUE;
                        DDRAW_SET_PRIMARY(ppdev, lpSurfTemp, tmpBmpPitch);
                        DDRAW_SET_SOURCE(ppdev, dwSrcOffset, dwSrcPitch);

                        while (freeCount < 6*4)
                            freeCount = NvGetFreeCount(npDev, 0);
                        freeCount -= 6*4;

						{
							NVCOORD     srcSize;

							srcSize.wh16.w = (unsigned short)dwSrcWidth;
							srcSize.wh16.h = (unsigned short)dwSrcHeight;

							npDev->dDrawRop.SetRop5 = SRCCOPYINDEX;
							npDev->dDrawBlit.ControlPointIn = wSrcXY.xy;
							npDev->dDrawBlit.ControlPointOut = 0;
							npDev->dDrawBlit.Size = srcSize.wh;
						}

                        dwSrcOffset = lpSurfTemp;
                        dwSrcPitch = tmpBmpPitch;
                        wSrcXY.xy = 0;
                        wSrcXY.xy16.x = 0;
                        wSrcXY.xy16.y = 0;
                    } else {
                        // FIXME: vmem heap alloc failed, must do system mem alloc and copy there
                    }
                }
                // WARNING: carefully consider each use of src->fpVidMem and src->lPitch beyond this point
                //          it could screw up overlapping stretchblits

                // stretch
                if (dwFlags & DDBLT_KEYSRCOVERRIDE)
                    { // If color key then MUST use STRETCHED IMAGE instead of SCALED IMAGE
                    NvNotification *pDmaToMemNotifier;
                    unsigned char *pScanlineBuffer;
                    long srcScanLength;
                    long nxtSrcScan;
                    long n;
                    short m;
                    FAST short pxlCount;
                    unsigned char *pSrcInitBits;
                    unsigned char *pSaveSrcBits;
                    unsigned char *pSrcCurScan;
                    long deltaX;
                    long deltaY;
                    long deltaDstY;
                    long curDstY;
                    long lastDstY;
                    long skipSrcBytes = 0;
                    NVCOORD wSrcExt;
                    NVCOORD wDstPoint;
                    unsigned long srcStrtX;
                    BYTE srcInVideoMemory = 0;
                    BYTE bufState = 0;
                    short skipV = 0;

                    pSrcInitBits = (unsigned char *) dwSrcOffset;
                    if (dwSrcCaps & DDSCAPS_VIDEOMEMORY)
                        pSrcInitBits += (ULONG) ppdev->pjFrameBufbase;

                    srcScanLength = dwSrcPitch;

                    if (dwSrcPitch <= 800)
                        m = 16;
                    else if (dwSrcPitch <= 1600)
                        m = 8;
                    else
                        m = 4;

                    DDRAW_SET_PRIMARY(ppdev, dwDstOffset, dwDstPitch);

                    while (freeCount < 4)
                        freeCount = NvGetFreeCount(npDev, NV_DD_ROP);
                    freeCount -= 4;

                    npDev->dDrawRop.SetRop5 = dwRop;

                    /* calculate deltas in 12.20 format */
                    n = (dwDstWidth << 20) / dwSrcWidth;

                    if ((n & 0xFFFFF) == 0)
                        n = 0;
                    else
                        {
                        n >>= 20;
                        n += 1;
                        }

                    deltaX = (dwDstWidth + n) << 20;
                    deltaX /= dwSrcWidth;

                    n = (dwDstHeight << 20) / dwSrcHeight;

                    if ((n & 0xFFFFF) == 0)
                        n = 0;
                    else
                        {
                        n >>= 20;
                        n += 1;
                        }

                    deltaY = (dwDstHeight + n) << 20;
                    deltaY /= dwSrcHeight;

                    deltaDstY = (dwDstHeight << 20);
                    deltaDstY /= dwSrcHeight;

                    wSrcExt.wh16.w = (unsigned short)((dwSrcWidth + 1) & ~1);
                    wSrcExt.wh16.h = (unsigned short)dwSrcHeight;

                    n = (short)dwSrcHeight;

                    if (wSrcXY.xy16.y + (ULONG) n > src->wHeight)
                        n = src->wHeight - wSrcXY.xy16.y;

                    nxtSrcScan = srcScanLength;

                    if (doMirrorUpDown)
                        {
                        wSrcXY.xy16.y += (short)(n - 1);
                        nxtSrcScan = -nxtSrcScan;
                        skipSrcBytes = -skipSrcBytes;
                        }

                    if ((dwSrcCaps & DDSCAPS_VIDEOMEMORY) &&
                        ((dwSrcCaps & DDSCAPS_TEXTURE) == 0) || isOverlappingVmem)
                        {
                        srcInVideoMemory = 1;
                        }
                    else
                        {
                        pSaveSrcBits = (unsigned char *)(pSrcInitBits +
                                                         (wSrcXY.xy16.y * srcScanLength));
                        pSaveSrcBits += (wSrcXY.xy16.x << 1);
                        pSrcCurScan = pSaveSrcBits;
                        }

                    if (srcInVideoMemory)
                        {
                        pDmaToMemNotifier = (NvNotification *)ppdev->Notifiers->DmaToMem;
                        pScanlineBuffer = (unsigned char *)ppdev->NvScanlineBufferFlat;

                        wSrcExt.wh16.w = (unsigned short)((dwSrcWidth + 1) & ~1);
                        wSrcExt.wh16.h = m;

                        srcStrtX = wSrcXY.xy16.x;

                        while (freeCount < 4)
                            freeCount = NvGetFreeCount(npDev, NV_DD_IMAGE);
                        freeCount -= 4;

                        if (ppdev->dDrawSpareSubchannelObject != NV_DD_VIDEO_MEM_TO_SYSTEM_MEM_FORMAT)
                            {
                            npDev->subchannel[NV_DD_SPARE].SetObject =
                                NV_DD_VIDEO_MEM_TO_SYSTEM_MEM_FORMAT;
                            ppdev->dDrawSpareSubchannelObject = NV_DD_VIDEO_MEM_TO_SYSTEM_MEM_FORMAT;
                            }
                                                // wait for any pending notification operation to finish
                        while ((volatile)pDmaToMemNotifier[NV039_NOTIFIERS_BUFFER_NOTIFY].status == NV_IN_PROGRESS);

                        pDmaToMemNotifier[NV039_NOTIFIERS_BUFFER_NOTIFY].status = NV_IN_PROGRESS;

                        while (freeCount < 32)
                            freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);
                        freeCount -= 32;

                        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.OffsetIn =
                        dwSrcOffset +
                        ((dwSrcPitch + skipSrcBytes) * (unsigned long)wSrcXY.xy16.y) +
                        ((unsigned long)wSrcXY.xy16.x << 1);

                        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.OffsetOut =
                        (srcStrtX << 1);

                        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.PitchIn =
                        (dwSrcPitch + skipSrcBytes);

                        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.PitchOut =
                        dwSrcPitch;

                        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.LineLengthIn =
                        (unsigned long)(wSrcExt.wh16.w << 1);

                        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.LineCount =
                        m;

                        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.Format =
                        1 | (1 << 8);
                        //NV_MTMF_FORMAT_INPUT_INC_1 | NV_MTMF_FORMAT_OUTPUT_INC_1;

                        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.BufferNotify =
                        0;

                        // wait for Dma operation to finish
                        while ((volatile)pDmaToMemNotifier[NV039_NOTIFIERS_BUFFER_NOTIFY].status == NV_IN_PROGRESS);

                        if (doMirrorUpDown)
                            wSrcXY.xy16.y -= (m + skipV);
                        else
                            wSrcXY.xy16.y += (m + skipV);
                        }

                    /* Convert to 12.4 format */
                    wDstPoint.xy16.x = (wDestXY.xy16.x << 4);
                    wDstPoint.xy16.y = (wDestXY.xy16.y << 4);

                    /* convert to 16.16 */
                    lastDstY = (wDestXY.xy16.y + wXYext.wh16.h) << 16;

                    /* convert to 16.16 */
                    curDstY = (wDestXY.xy16.y << 16);

                    while (freeCount < 7*4)
                        freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);
                    freeCount -= 7*4;

                    npDev->dDrawStretch.SetObject = NV_DD_STRETCHED_IMAGE_FROM_CPU;
                    ppdev->dDrawSpareSubchannelObject = NV_DD_STRETCHED_IMAGE_FROM_CPU;

                    npDev->dDrawStretch.Nv04StretchedImageFromCpu.ClipPoint =
                    wDestXY.xy;

                    npDev->dDrawStretch.Nv04StretchedImageFromCpu.ClipSize =
                    wXYext.wh;

                    npDev->dDrawStretch.Nv04StretchedImageFromCpu.SizeIn = wSrcExt.wh;

                    npDev->dDrawStretch.Nv04StretchedImageFromCpu.DeltaDxDu = deltaX;

                    npDev->dDrawStretch.Nv04StretchedImageFromCpu.DeltaDyDv = deltaY;

                    npDev->dDrawStretch.Nv04StretchedImageFromCpu.Point12d4 = wDstPoint.xy;

                    while ((n > 0) && (curDstY < lastDstY))
                        {
                        FAST unsigned long *pSrcBits;
                        FAST unsigned long tmpPxls0, tmpPxls1, tmpPxls2;

                        if (srcInVideoMemory)
                            {
                            if (bufState == 0)
                                pSrcBits = (unsigned long *)(pScanlineBuffer +
                                                             (srcStrtX << 1));
                            else
                                pSrcBits = (unsigned long *)(pScanlineBuffer +
                                                             (NV_DMA_SCANLINE_BUF_SIZE >> 1) +
                                                             (srcStrtX << 1));

                            pSrcCurScan = (unsigned char *)pSrcBits;

                            if (m > 0)
                                {
                                pDmaToMemNotifier[NV039_NOTIFIERS_BUFFER_NOTIFY].status = NV_IN_PROGRESS;

                                while (freeCount < 9*4)
                                    freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);
                                freeCount -= 9*4;
                                npDev->subchannel[NV_DD_SPARE].SetObject =
                                    NV_DD_VIDEO_MEM_TO_SYSTEM_MEM_FORMAT;
                                ppdev->dDrawSpareSubchannelObject = NV_DD_VIDEO_MEM_TO_SYSTEM_MEM_FORMAT;

                                npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.OffsetIn =
                                dwSrcOffset +
                                ((dwSrcPitch + skipSrcBytes) * (unsigned long)wSrcXY.xy16.y) +
                                ((unsigned long)wSrcXY.xy16.x << 1);

                                if (bufState == 0)
                                    npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.OffsetOut =
                                    (NV_DMA_SCANLINE_BUF_SIZE >> 1) +
                                    (srcStrtX << 1);
                                else
                                    npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.OffsetOut =
                                    (srcStrtX << 1);

                                npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.PitchIn =
                                (dwSrcPitch + skipSrcBytes);

                                npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.PitchOut =
                                dwSrcPitch;

                                npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.LineLengthIn =
                                (unsigned long)(wSrcExt.wh16.w << 1);

                                npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.LineCount =
                                m;

                                npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.Format =
                                    1 | (1 << 8);
                                // NV_MTMF_FORMAT_INPUT_INC_1 | NV_MTMF_FORMAT_OUTPUT_INC_1;

                                npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.BufferNotify =
                                0;

                                bufState ^= 1;

                                if (doMirrorUpDown)
                                    wSrcXY.xy16.y -= (m + skipV);
                                else
                                    wSrcXY.xy16.y += (m + skipV);

                                while (freeCount < 7*4)
                                    freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);
                                freeCount -= 7*4;

                                npDev->dDrawStretch.SetObject = NV_DD_STRETCHED_IMAGE_FROM_CPU;
                                ppdev->dDrawSpareSubchannelObject = NV_DD_STRETCHED_IMAGE_FROM_CPU;

                                npDev->dDrawStretch.Nv04StretchedImageFromCpu.ClipPoint =
                                wDestXY.xy;
                                npDev->dDrawStretch.Nv04StretchedImageFromCpu.ClipSize =
                                wXYext.wh;
                                npDev->dDrawStretch.Nv04StretchedImageFromCpu.SizeIn =
                                wSrcExt.wh;
                                npDev->dDrawStretch.Nv04StretchedImageFromCpu.DeltaDxDu =
                                deltaX;
                                npDev->dDrawStretch.Nv04StretchedImageFromCpu.DeltaDyDv =
                                deltaY;
                                npDev->dDrawStretch.Nv04StretchedImageFromCpu.Point12d4 =
                                wDstPoint.xy;
                                }
                            }
                        else
                            { // source in system memory
                            pSrcBits = (unsigned long *)pSrcCurScan;
                            pSrcCurScan += (nxtSrcScan + skipSrcBytes);
                            n--;
                            }

                        doNxtSrcScan:          pxlCount = (short)((dwSrcWidth + 1) & ~1);

                        while (pxlCount >= 32)
                            {

                            pxlCount -= 32;

                            while (freeCount < 64)
                                freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);
                            freeCount -= 64;

                            tmpPxls0 = pSrcBits[0];
                            tmpPxls1 = pSrcBits[1];
                            npDev->dDrawStretch.Nv04StretchedImageFromCpu.Color[0] = tmpPxls0;
                            tmpPxls2 = pSrcBits[2];
                            npDev->dDrawStretch.Nv04StretchedImageFromCpu.Color[1] = tmpPxls1;
                            tmpPxls0 = pSrcBits[3];
                            tmpPxls1 = pSrcBits[4];
                            npDev->dDrawStretch.Nv04StretchedImageFromCpu.Color[2] = tmpPxls2;
                            npDev->dDrawStretch.Nv04StretchedImageFromCpu.Color[3] = tmpPxls0;
                            tmpPxls2 = pSrcBits[5];
                            tmpPxls0 = pSrcBits[6];
                            npDev->dDrawStretch.Nv04StretchedImageFromCpu.Color[4] = tmpPxls1;
                            npDev->dDrawStretch.Nv04StretchedImageFromCpu.Color[5] = tmpPxls2;
                            tmpPxls1 = pSrcBits[7];
                            tmpPxls2 = pSrcBits[8];
                            npDev->dDrawStretch.Nv04StretchedImageFromCpu.Color[6] = tmpPxls0;
                            npDev->dDrawStretch.Nv04StretchedImageFromCpu.Color[7] = tmpPxls1;
                            tmpPxls0 = pSrcBits[9];
                            tmpPxls1 = pSrcBits[10];
                            npDev->dDrawStretch.Nv04StretchedImageFromCpu.Color[8] = tmpPxls2;
                            npDev->dDrawStretch.Nv04StretchedImageFromCpu.Color[9] = tmpPxls0;
                            tmpPxls2 = pSrcBits[11];
                            tmpPxls0 = pSrcBits[12];
                            npDev->dDrawStretch.Nv04StretchedImageFromCpu.Color[10] = tmpPxls1;
                            npDev->dDrawStretch.Nv04StretchedImageFromCpu.Color[11] = tmpPxls2;
                            tmpPxls1 = pSrcBits[13];
                            tmpPxls2 = pSrcBits[14];
                            npDev->dDrawStretch.Nv04StretchedImageFromCpu.Color[12] = tmpPxls0;
                            npDev->dDrawStretch.Nv04StretchedImageFromCpu.Color[13] = tmpPxls1;
                            tmpPxls0 = pSrcBits[15];
                            npDev->dDrawStretch.Nv04StretchedImageFromCpu.Color[14] = tmpPxls2;
                            pSrcBits += 16;
                            npDev->dDrawStretch.Nv04StretchedImageFromCpu.Color[15] = tmpPxls0;
                            }

                        while (pxlCount >= 16)
                            {

                            pxlCount -= 16;

                            while (freeCount < 32)
                                freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);
                            freeCount -= 32;

                            tmpPxls0 = pSrcBits[0];
                            tmpPxls1 = pSrcBits[1];
                            npDev->dDrawStretch.Nv04StretchedImageFromCpu.Color[0] = tmpPxls0;
                            tmpPxls2 = pSrcBits[2];
                            npDev->dDrawStretch.Nv04StretchedImageFromCpu.Color[1] = tmpPxls1;
                            tmpPxls0 = pSrcBits[3];
                            tmpPxls1 = pSrcBits[4];
                            npDev->dDrawStretch.Nv04StretchedImageFromCpu.Color[2] = tmpPxls2;
                            npDev->dDrawStretch.Nv04StretchedImageFromCpu.Color[3] = tmpPxls0;
                            tmpPxls2 = pSrcBits[5];
                            tmpPxls0 = pSrcBits[6];
                            npDev->dDrawStretch.Nv04StretchedImageFromCpu.Color[4] = tmpPxls1;
                            npDev->dDrawStretch.Nv04StretchedImageFromCpu.Color[5] = tmpPxls2;
                            tmpPxls1 = pSrcBits[7];
                            pSrcBits += 8;
                            npDev->dDrawStretch.Nv04StretchedImageFromCpu.Color[6] = tmpPxls0;
                            npDev->dDrawStretch.Nv04StretchedImageFromCpu.Color[7] = tmpPxls1;
                            }

                        while (freeCount < 32)
                            freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);
                        freeCount -= 32;

                        while (pxlCount >= 2)
                            {
                            tmpPxls0 = pSrcBits[0];
                            pxlCount -= 2;
                            npDev->dDrawStretch.Nv04StretchedImageFromCpu.Color[0] = tmpPxls0;
                            pSrcBits += 1;
                            }

                        if (srcInVideoMemory)
                            {
                            if (--m > 0)
                                {
                                pSrcCurScan += dwSrcPitch;

                                pSrcBits = (unsigned long *)pSrcCurScan;

                                goto doNxtSrcScan;
                                }
                            else
                                {
                                if (dwSrcPitch <= 800)
                                    {
                                    m = 16;
                                    curDstY += deltaDstY;
                                    }
                                else if (dwSrcPitch <= 1600)
                                    {
                                    m = 8;
                                    curDstY += (deltaDstY >> 1);
                                    }
                                else
                                    {
                                    m = 4;
                                    curDstY += (deltaDstY >> 2);
                                    }
                                /* convert 16.16 to 12.4 */
                                wDstPoint.xy16.y = (short)(curDstY >> 12);

                                // wait for DMA operation to finish
                                while ((volatile)pDmaToMemNotifier[NV039_NOTIFIERS_NOTIFY].status == NV_IN_PROGRESS);
                                }
                            }
                        }

                    if (srcInVideoMemory)
                        {
                        while (freeCount < 4)
                            freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);
                        freeCount -= 4;
                        if (ppdev->dDrawSpareSubchannelObject != NV_DD_VIDEO_MEM_TO_SYSTEM_MEM_FORMAT)
                            {
                            npDev->subchannel[NV_DD_SPARE].SetObject =
                                NV_DD_VIDEO_MEM_TO_SYSTEM_MEM_FORMAT;
                            ppdev->dDrawSpareSubchannelObject = NV_DD_VIDEO_MEM_TO_SYSTEM_MEM_FORMAT;
                            }
                        }

                    }
                else
                    { // OK to use SCALED IMAGE
                    NvNotification *pDmaToMemNotifier;
                    unsigned char *pScanlineBuffer;
                    unsigned char *npPixelBuf;
                    long srcScanLength;
                    long nxtSrcScan;
                    unsigned long n;
                    unsigned char *pSrcInitBits;
                    unsigned char *pSaveSrcInitBits;
                    unsigned short *pSaveSrcBits;
                    unsigned short *pSrcCurScan;
                    long srcDeltaX;
                    long srcDeltaY;
                    unsigned long dstDeltaScans;
                    unsigned long dstDeltaX;
                    unsigned long dstDeltaY;
                    long srcInitFract;
                    long srcStartFract;
                    long srcCurFract;
                    long srcDeltaFract;
                    long srcDeltaScans;
                    long srcCurDeltaScans;
                    long xStretch;
                    long yStretch;
                    long srcBufferPitch;
                    long skipSrcBytes = 0;
                    long dstStartY;
                    long dstCurY;
                    long curV;
                    long skipV = 0;
                    long m;
                    long srcFinalHeight;
                    NVCOORD wSrcPoint;
                    NVCOORD wSrcExt;
                    NVCOORD wDstPoint;
                    NVCOORD wDstExt;
                    BYTE srcInVideoMemory = 0;
                    BYTE srcTooWide = 0;
                    short curBuffer;

//                   pPusherSyncNotifier = (NvNotification *)ppdev->NvPusherSyncNotifierFlat;

                    /* Avoid using shared buffer memory until it becomes available */
//                   while ((volatile)pPusherSyncNotifier->status == NV_IN_PROGRESS);

                    pSrcInitBits = (unsigned char *) dwSrcOffset;
                    if (dwSrcCaps & DDSCAPS_VIDEOMEMORY)
                         pSrcInitBits += (ULONG) ppdev->pjFrameBufbase;

                    srcScanLength = dwSrcPitch;

                    DDRAW_SET_PRIMARY(ppdev, dwDstOffset, dwDstPitch);

                    while (freeCount < 4)
                        freeCount = NvGetFreeCount(npDev, NV_DD_ROP);
                    freeCount -= 4;

                    npDev->dDrawRop.SetRop5 = dwRop;


                    srcBufferPitch = ((dwSrcWidth << 1) + 3) & ~3L;

                    srcDeltaScans = (NV_DMA_SCANLINE_BUF_SIZE >> 1) -   /* allow for 2 extra src scanlines */
                                    (srcBufferPitch << 1); /* buffer contains 4 separate notifiers */

                    srcDeltaScans /= srcBufferPitch;

                    /* limiting source scans per DMA increases parallelism */
                    if (srcDeltaScans > 32)
                        srcDeltaScans = 32;
                    else if (srcDeltaScans > 16)
                        srcDeltaScans = 16;
                    else if (srcDeltaScans > 8)
                        srcDeltaScans = 8;
                    else if (srcDeltaScans > 4)
                        srcDeltaScans = 4;
                    else
                        srcDeltaScans = 2;

                    /* check for divide by 0 */
                    if ((dwDstWidth < 1) || (dwDstHeight < 1))
                        {
                        pbd->ddRVal = DDERR_INVALIDRECT;
                        ppdev->NVFreeCount = freeCount;
                        return DDHAL_DRIVER_HANDLED;
                        }

                    n = (dwSrcWidth << 20) / dwDstWidth;

                    if (n == 0x100000)
                        n = 0;
                    else
                        {
                        n >>= 20;
                        n += 1;
                        }

                    srcDeltaX = dwSrcWidth << 20;
                    srcDeltaX /= (dwDstWidth + n);

                    n = (dwSrcHeight << 20) / dwDstHeight;

                    if (n == 0x100000)
                        n = 0;
                    else
                        {
                        n >>= 20;
                        n += 1;
                        }

                    srcDeltaY = dwSrcHeight << 20;
                    srcDeltaY /= (dwDstHeight + n);

                    /* Algorithm can't handle a scale factor that is too large */
                    if (srcDeltaY > 0x40000000)
                        {
                        pbd->ddRVal = DDERR_INVALIDRECT;
                        ppdev->NVFreeCount = freeCount;
                        return DDHAL_DRIVER_HANDLED;
                        }

                    /* If shrinking in vertical direction then adjust to skip src scanlines */
                    if (srcDeltaY >= (srcDeltaScans << 20))
                        { /* limit Y delta range to acceptable range */
                        skipSrcBytes = srcScanLength;
                        skipV = 1;
                        while (srcDeltaY >= (srcDeltaScans << 20))
                            {
                            srcDeltaY >>= 1;
                            skipSrcBytes <<= 1;
                            skipV <<= 1;
                            }
                        skipSrcBytes -= srcScanLength;
                        skipV -= 1;
                        }

                    /* Algorithm can't handle scale factor that is too small */
                    if ((srcDeltaY & 0xFFFFFC00) == 0)
                        {
                        pbd->ddRVal = DDERR_INVALIDRECT;
                        ppdev->NVFreeCount = freeCount;
                        return DDHAL_DRIVER_HANDLED;
                        }

                    yStretch = 0x40000000 / ((srcDeltaY + 0x00000200) >> 10);

                    dstDeltaY = srcDeltaScans * yStretch;  // how many dst scanlines will srcDeltaScans scanlines generate

                    dstDeltaScans = dstDeltaY >> 20;

                    if (dstDeltaScans == 0)
                        { /* if shrinking too much then can't handle */
                        pbd->ddRVal = DDERR_INVALIDRECT;
                        ppdev->NVFreeCount = freeCount;
                        return DDHAL_DRIVER_HANDLED;
                        }

                    if (wSrcXY.xy16.y + dwSrcHeight > src->wHeight)
                        dwSrcHeight = src->wHeight - wSrcXY.xy16.y;

                    nxtSrcScan = (srcScanLength >> 1);

                    if (doMirrorUpDown)
                        {
                        wSrcXY.xy16.y += (short)(dwSrcHeight - 1);
                        srcDeltaY =- srcDeltaY;
                        nxtSrcScan = -nxtSrcScan;
                        skipSrcBytes = -skipSrcBytes;
                        }

                    pDmaToMemNotifier = (NvNotification *)ppdev->Notifiers->DmaToMem;
                    pScanlineBuffer = (unsigned char *)ppdev->NvScanlineBufferFlat;

                    srcDeltaFract = (dstDeltaScans << 20) / srcDeltaScans;

                    srcDeltaFract &= 0xFFFFF;

                    wSrcPoint.xy = 0;

                    /* Calculate initial source fractional X */
                    if ((srcDeltaX > 0x40000000) || ((srcDeltaX & 0xFFFFFC00) == 0))
                        {
                        pbd->ddRVal = DDERR_INVALIDRECT;
                        ppdev->NVFreeCount = freeCount;
                        return DDHAL_DRIVER_HANDLED;
                        }

                    /* Do this math in 16.16 precision to avoid 12. overflow */
                    dstDeltaX = ((long)wSrcXY.xy16.x << 16) / (srcDeltaX >> 4);

                    /* Do this math in 16.16 precision to avoid 12. overflow */
                    srcInitFract = dstDeltaX * (srcDeltaX >> 4);

                    /* Do this math in 16.16 precision to avoid 12. overflow */
                    while (srcInitFract >> 16 < wSrcXY.xy16.x)
                        srcInitFract += (srcDeltaX >> 4);

                    /* Convert to 12.4 format */
                    wSrcPoint.xy16.x = (short)(srcInitFract & 0xFFFF) >> 12;

                    // DMAable ?
                    if ((isVideo > 3) || ((dwSrcCaps & DDSCAPS_VIDEOMEMORY) &&
                                          ((dwSrcCaps & DDSCAPS_TEXTURE) == 0)) || isOverlappingVmem)
                        {

                        /* Calculate initial source fractional Y */
                        /* Do this math in 16.16 precision to avoid 12. overflow */
                        dstDeltaY = ((long)wSrcXY.xy16.y << 16) / (srcDeltaY  >> 4);

                        /* Do this math in 16.16 precision to avoid 12. overflow */
                        srcInitFract = dstDeltaY * (srcDeltaY >> 4);

                        /* Do this math in 16.16 precision to avoid 12. overflow */
                        while (srcInitFract >> 16 < wSrcXY.xy16.y)
                            srcInitFract += (srcDeltaY >> 4);

                        /* Convert result back to 12.20 precision */
                        srcInitFract <<= 4;

                        srcInitFract &= 0xFFFFF;

                        srcCurFract = srcInitFract;

                        if (isVideo < 4)
                            {
                            srcInVideoMemory = 1;

                            wSrcPoint.xy16.y += (short)srcCurFract >> 16;

                            if (doMirrorUpDown)
                                {
                                pSaveSrcBits = (unsigned short *)
                                               (pSrcInitBits - ppdev->pjFrameBufbase);
                                wSrcPoint.xy16.y += ((short)(dwSrcHeight - 1) << 4);
                                }
                            else
                                {
                                pSaveSrcBits = (unsigned short *)
                                               ((pSrcInitBits - ppdev->pjFrameBufbase) +
                                                (wSrcXY.xy16.y * srcScanLength));
                                }

                            }
                        else
                            { // source is in DMAable system memory

                            wSrcPoint.xy16.y += (short)srcCurFract >> 16;

                            if (doMirrorUpDown)
                                {
                                pSaveSrcBits = 0;
                                wSrcPoint.xy16.y += ((short)(dwSrcHeight - 1) << 4);
                                }
                            else
                                {
                                pSaveSrcBits = (unsigned short *)
                                               (wSrcXY.xy16.y * srcScanLength);
                                }
                            }

                        pSaveSrcBits += wSrcXY.xy16.x;

                        while (freeCount < 20)
                            freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);
                        freeCount -= 20;

                        if (isVideo < 2)
                            {
                            if (ppdev->dDrawSpareSubchannelObject != NV_DD_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY)
                                {
                                npDev->dDrawStretch.SetObject =
                                    NV_DD_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY;
                                ppdev->dDrawSpareSubchannelObject = NV_DD_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY;
                                }
                            }
                        else if (isVideo == 2)
                            {
                            if (ppdev->dDrawSpareSubchannelObject != NV_DD_SCALED_UYVY_IMAGE_FROM_VIDEO_MEMORY)
                                {
                                npDev->dDrawStretch.SetObject =
                                    NV_DD_SCALED_UYVY_IMAGE_FROM_VIDEO_MEMORY;
                                ppdev->dDrawSpareSubchannelObject =
                                    NV_DD_SCALED_UYVY_IMAGE_FROM_VIDEO_MEMORY;
                                }
                            }
                        else if (isVideo == 3)
                            {
                            if (ppdev->dDrawSpareSubchannelObject != NV_DD_SCALED_YUYV_IMAGE_FROM_VIDEO_MEMORY)
                                {
                                npDev->dDrawStretch.SetObject =
                                    NV_DD_SCALED_YUYV_IMAGE_FROM_VIDEO_MEMORY;
                                ppdev->dDrawSpareSubchannelObject =
                                    NV_DD_SCALED_YUYV_IMAGE_FROM_VIDEO_MEMORY;
                                }
                            }
                        else if (isVideo == 4)
                            {
                            if (ppdev->dDrawSpareSubchannelObject != NV_DD_FLOATING0_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY)
                                {
                                npDev->dDrawStretch.SetObject =
                                    NV_DD_FLOATING0_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
                                ppdev->dDrawSpareSubchannelObject =
                                    NV_DD_FLOATING0_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
                                }
                            }
                        else if (isVideo == 5)
                            {
                            if (ppdev->dDrawSpareSubchannelObject != NV_DD_FLOATING1_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY)
                                {
                                npDev->dDrawStretch.SetObject =
                                    NV_DD_FLOATING1_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
                                ppdev->dDrawSpareSubchannelObject =
                                    NV_DD_FLOATING1_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
                                }
                            }
                        else if (isVideo == 6)
                            {
                            if (ppdev->dDrawSpareSubchannelObject != NV_DD_FLOATING0_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY)
                                {
                                npDev->dDrawStretch.SetObject =
                                    NV_DD_FLOATING0_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
                                ppdev->dDrawSpareSubchannelObject =
                                    NV_DD_FLOATING0_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
                                }
                            }
                        else if (isVideo == 7)
                            {
                            if (ppdev->dDrawSpareSubchannelObject != NV_DD_FLOATING1_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY)
                                {
                                npDev->dDrawStretch.SetObject =
                                    NV_DD_FLOATING1_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
                                ppdev->dDrawSpareSubchannelObject =
                                    NV_DD_FLOATING1_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
                                }
                            }

                        }
                    else
                        {
                        pSaveSrcBits = (unsigned short *)(pSrcInitBits +
                                                          (wSrcXY.xy16.y * srcScanLength));
                        pSaveSrcBits += wSrcXY.xy16.x;
                        pSrcCurScan = pSaveSrcBits;

                        while (freeCount < 20)
                            freeCount = NvGetFreeCount(npDev, NV_DD_STRETCH);
                        freeCount -= 20;

                        if (isVideo == 2)
                            {
                             if (ppdev->dDrawSpareSubchannelObject != NV_DD_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY)
                                {
                                npDev->subchannel[NV_DD_STRETCH].SetObject =
                                    NV_DD_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
                                ppdev->dDrawSpareSubchannelObject = NV_DD_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
                                }
                            }
                        else if (isVideo == 3)
                            {
                            if (ppdev->dDrawSpareSubchannelObject != NV_DD_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY)
                                {
                                npDev->subchannel[NV_DD_STRETCH].SetObject =
                                    NV_DD_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
                                ppdev->dDrawSpareSubchannelObject = NV_DD_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
                                }
                            }
                        }

                    pSaveSrcInitBits = (unsigned char *)pSaveSrcBits;

                    npDev->dDrawStretch.nv4ScaledImageFromMemory.ClipPoint =
                    wDestXY.xy;

                    npDev->dDrawStretch.nv4ScaledImageFromMemory.ClipSize =
                    wXYext.wh;

                    npDev->dDrawStretch.nv4ScaledImageFromMemory.DeltaDuDx = srcDeltaX;
                    npDev->dDrawStretch.nv4ScaledImageFromMemory.DeltaDvDy = srcDeltaY;

                    wDstExt.wh = wXYext.wh;

                    /* NV3 hardware can only handle a maximum source width of 1024 */
                    if (dwSrcWidth > 1024)
                        {
                        srcTooWide = 1;
                        xStretch = 0x40000000 / (srcDeltaX >> 10);
                        dstDeltaX = (xStretch * 1024) >> 20;
                        wDstExt.wh16.w = (unsigned short)dstDeltaX;
                        srcBufferPitch = 2048;
                        }

                    // wait for any pending notification operation to finish
                    while ((volatile)pDmaToMemNotifier[NV077_NOTIFIERS_NOTIFY].status == NV_IN_PROGRESS);

                    // Let the world know we are doing DMA operations
                    ppdev->NvDmaFromMemSurfaceMem = dwSrcOffset;
                    if (dwSrcCaps & DDSCAPS_VIDEOMEMORY)
                        ppdev->NvDmaFromMemSurfaceMem += (ULONG) ppdev->pjFrameBufbase;

                    oneMorePass:       n = dwDstHeight;

                    /* Calculate initial source fractional Y */
                    /* Do this math in 16.16 precision to avoid 12. overflow */
                    dstDeltaY = ((long)wSrcXY.xy16.y << 16) / (srcDeltaY >> 4);

                    /* Do this math in 16.16 precision to avoid 12. overflow */
                    srcInitFract = dstDeltaY * (srcDeltaY >> 4);

                    /* Do this math in 16.16 precision to avoid 12. overflow */
                    while (srcInitFract >> 16 < wSrcXY.xy16.y)
                        srcInitFract += (srcDeltaY >> 4);

                    /* Convert result back to 12.20 precision */
                    srcInitFract <<= 4;

                    srcInitFract &= 0xFFFFF;

                    srcCurFract = srcInitFract;

                    curV = 0;

                    wDstPoint.xy = wDestXY.xy;

                    dstStartY = dstCurY = wDestXY.xy16.y;

                    curBuffer = 0;

                    if ((srcInVideoMemory) || (isVideo > 3))
                        { // DMAable ?

                        // wait for any pending notification operation to finish
                        while ((volatile)pDmaToMemNotifier[NV077_NOTIFIERS_NOTIFY].status == NV_IN_PROGRESS);

                        pDmaToMemNotifier[NV077_NOTIFIERS_NOTIFY].status = NV_IN_PROGRESS;

                        while (freeCount < 28)
                            freeCount = NvGetFreeCount(npDev, NV_DD_STRETCH);
                        freeCount -= 28;

                        npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageOutPoint =
                        wDstPoint.xy;
                        npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageOutSize =
                        wDstExt.wh;

                        if (dwSrcWidth < 16)
                            { // workaround for NV5 hardware bug
                            npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInSize =
                            asmMergeCoords((unsigned short) ((dwSrcPitch + 1) & ~1), dwSrcHeight);
                            }
                        else
                            {
                            npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInSize =
                            asmMergeCoords((unsigned short) ((dwSrcWidth + 1) & ~ 1), dwSrcHeight);
                            }

                        npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInFormat =
                            (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_FOH << 24) |
                            (NV077_IMAGE_IN_FORMAT_ORIGIN_CENTER << 16) |
                            dwSrcPitch;

                        npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInOffset =
                        (unsigned long)pSaveSrcBits;
                        npDev->dDrawStretch.nv4ScaledImageFromMemory.Notify =
                        0;
                        npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInPoint =
                        wSrcPoint.xy;

                        n = 0;
                        }

                    while (n >= dstDeltaScans)
                        {
                        FAST unsigned long *pSrcBits;

                        n -= dstDeltaScans;
                        srcStartFract = srcCurFract;
                        srcCurFract += srcDeltaFract;
                        if (curBuffer == 0)
                            npPixelBuf = (unsigned char *)pScanlineBuffer;
                        else
                            npPixelBuf = (unsigned char *)(pScanlineBuffer +
                                                           (NV_DMA_SCANLINE_BUF_SIZE >> 1));

                        /* Must recalculate on each pass since src scanlines may be used more than once */
                        pSrcBits = (unsigned long *)(pSaveSrcInitBits +
                                                     (curV * (nxtSrcScan << 1)));
                        pSrcCurScan = (unsigned short *)pSrcBits;

                        m = srcDeltaScans + (srcCurFract >> 20) + 1;

                        if (skipV)
                            {
                            if ((long)dwSrcHeight - curV < (m * (skipV + 1)))
                                m = ((long)dwSrcHeight - curV) / (skipV + 1);
                            }
                        else
                            {
                            if ((long)dwSrcHeight - curV < m)
                                m = (long)dwSrcHeight - curV;
                            }

                        srcCurDeltaScans = 0;

                        /* Copy and convert a block of source pixels to transfer buffer */
                        while (--m >= 0)
                            {

                            if (pSrcBits >= (unsigned long *)pSrcInitBits)
                                {
                                //                           asmCopyScan(pSrcBits, npPixelBuf, srcBufferPitch);
                                _asm
                                {
#ifdef P6
                                    mov ecx, dword ptr srcBufferPitch
                                    mov esi, dword ptr pSrcBits
                                    shr ecx, 5
                                    nxtCacheLine2: mov eax, [esi]
                                    add esi, 32
                                    dec ecx
                                    jg nxtCacheLine2
#endif /* P6 */
                                    mov ecx, dword ptr srcBufferPitch
                                    mov esi, dword ptr pSrcBits
                                    shr ecx, 2
                                    mov edi, dword ptr npPixelBuf
                                    test ecx, 1
                                    jz doQwords2
                                    mov eax, [esi]
                                    add esi, 4
                                    mov [edi], eax
                                    add edi, 4
                                    doQwords2: shr ecx, 1
                                    jz copyDone2
#ifdef MMX
                                    nxtQword2: movq mm1, qword ptr [esi]
                                    add esi, 8
                                    movq qword ptr [edi], mm1
                                    add edi, 8
                                    dec ecx
#else /* MMX */
                                    nxtQword2: mov eax, [esi]
                                    mov edx, [esi+4]
                                    add edi, 8
                                    add esi, 8
                                    dec ecx
                                    mov [edi-8], eax
                                    mov [edi-4], edx
#endif /* MMX */
                                    copyDone2: jg nxtQword2
                                }
                                }
                            npPixelBuf += srcBufferPitch;
                            pSrcCurScan += (nxtSrcScan + skipSrcBytes);
                            pSrcBits = (unsigned long *)pSrcCurScan;
                            srcCurDeltaScans++;
                            curV += skipV;
                            }

                        /* wait for Dma operation to finish */
                        while (pDmaToMemNotifier[NV077_NOTIFIERS_NOTIFY].status == NV_IN_PROGRESS);

                        pDmaToMemNotifier[NV077_NOTIFIERS_NOTIFY].status = NV_IN_PROGRESS;

                        wDstPoint.xy16.y = (short)dstCurY;
                        wDstExt.wh16.h = (unsigned short)dstDeltaScans;
                        wSrcPoint.xy16.y = (short)srcStartFract >> 16; /* convert V to 12.4 */
                        wSrcExt.wh = srcCurDeltaScans; //+ (srcCurFract >> 20) + 1;
                        wSrcExt.wh <<= 16;    /* shift V extent into place */
                        wSrcExt.wh |= (unsigned short)((dwSrcWidth + 1) & ~1);

                        while (freeCount < 28)
                            freeCount = NvGetFreeCount(npDev, NV_DD_STRETCH);
                        freeCount -= 28;

                        npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageOutPoint =
                        wDstPoint.xy;
                        npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageOutSize =
                        wDstExt.wh;
                                                // NV5 hw bug workaround
                        if (dwSrcWidth < 16)
                            {
                            npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInSize =
                                (wSrcExt.wh & 0xffff0000) | dwSrcPitch;
                            }
                        else
                            {
                            npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInSize =
                                wSrcExt.wh;
                            }

                        npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInFormat =
                            (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_FOH << 24) |
                           (NV077_IMAGE_IN_FORMAT_ORIGIN_CENTER << 16) |
                            srcBufferPitch;

                        if (curBuffer == 0)
                            npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInOffset =
                            0;
                        else
                            npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInOffset =
                            (NV_DMA_SCANLINE_BUF_SIZE >> 1);

                        npDev->dDrawStretch.nv4ScaledImageFromMemory.Notify =
                        0;
                        npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInPoint =
                        wSrcPoint.xy;

                        curBuffer ^= 1;
                        dstCurY += dstDeltaScans;

                        srcCurFract = ((dstCurY - dstStartY) * srcDeltaY) + srcInitFract;

                        curV = srcCurFract >> 20;
                        srcCurFract &= 0xFFFFF;

                        curV += (curV - 1) * skipV;
                        if (curV > (long)dwSrcHeight - 1)
                            curV = (long)dwSrcHeight - 1;
                        }

                    if (n > 0)
                        {
                        FAST unsigned long *pSrcBits;

                        srcStartFract = srcCurFract;
                        srcCurFract += srcDeltaFract;
                        if (curBuffer == 0)
                            npPixelBuf = (unsigned char *)pScanlineBuffer;
                        else
                            npPixelBuf = (unsigned char *)(pScanlineBuffer +
                                                           (NV_DMA_SCANLINE_BUF_SIZE >> 1));

                        /* Must recalculate since src scanlines may be used more than once */
                        pSrcBits = (unsigned long *)(pSaveSrcInitBits +
                                                     (curV * (nxtSrcScan << 1)));
                        pSrcCurScan = (unsigned short *)pSrcBits;

                        m = srcDeltaScans + (srcCurFract >> 20) + 1;

                        srcFinalHeight = m;

                        if (skipV)
                            {
                            if ((long)dwSrcHeight - curV < (m * (skipV + 1)))
                                srcFinalHeight = ((long)dwSrcHeight - curV) / (skipV + 1);
                            }
                        else
                            {
                            if ((long)dwSrcHeight - curV < m)
                                srcFinalHeight = (long)dwSrcHeight - curV;
                            }

                        srcCurDeltaScans = 0;

                        /* Copy and convert a block of source pixels to transfer buffer */
                        while (--m >= 0)
                            {
                            if (pSrcBits >= (unsigned long *)pSrcInitBits)
                                {
                                //                           asmCopyScan(pSrcBits, npPixelBuf, srcBufferPitch);
                                _asm
                                {
#ifdef P6
                                    mov ecx, dword ptr srcBufferPitch
                                    mov esi, dword ptr pSrcBits
                                    shr ecx, 5
                                    nxtCacheLine: mov eax, [esi]
                                    add esi, 32
                                    dec ecx
                                    jg nxtCacheLine
#endif /* P6 */
                                    mov ecx, dword ptr srcBufferPitch
                                    mov esi, dword ptr pSrcBits
                                    shr ecx, 2
                                    mov edi, dword ptr npPixelBuf
                                    test ecx, 1
                                    jz doQwords
                                    mov eax, [esi]
                                    add esi, 4
                                    mov [edi], eax
                                    add edi, 4
                                    doQwords: shr ecx, 1
                                    jz copyDone
#ifdef MMX
                                    nxtQword: movq mm1, qword ptr [esi]
                                    add esi, 8
                                    movq qword ptr [edi], mm1
                                    add edi, 8
                                    dec ecx
#else /* MMX */
                                    nxtQword: mov eax, [esi]
                                    mov edx, [esi+4]
                                    add edi, 8
                                    add esi, 8
                                    dec ecx
                                    mov [edi-8], eax
                                    mov [edi-4], edx
#endif /* MMX */
                                    copyDone: jg nxtQword
                                }
                                }
                            npPixelBuf += srcBufferPitch;
                            if (--srcFinalHeight > 0)
                                pSrcCurScan += (nxtSrcScan + skipSrcBytes);
                            pSrcBits = (unsigned long *)pSrcCurScan;
                            srcCurDeltaScans++;
                            curV += skipV;
                            }

                        /* wait for Dma operation to finish */
                        while (pDmaToMemNotifier[NV077_NOTIFIERS_NOTIFY].status == NV_IN_PROGRESS);

                        pDmaToMemNotifier[NV077_NOTIFIERS_NOTIFY].status = NV_IN_PROGRESS;

                        wDstPoint.xy16.y = (short)dstCurY;
                        wDstExt.wh16.h = (unsigned short)n;
                        wSrcPoint.xy16.y = (short)srcStartFract >> 16; /* convert V to 12.4 */
                        wSrcExt.wh = srcCurDeltaScans; //+ (srcCurFract >> 20) + 1;
                        wSrcExt.wh <<= 16;    /* shift V extent into place */
                        wSrcExt.wh |= (unsigned short)((dwSrcWidth + 1) & ~1);

                        while (freeCount < 28)
                            freeCount = NvGetFreeCount(npDev, NV_DD_STRETCH);
                        freeCount -= 28;

                        npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageOutPoint =
                        wDstPoint.xy;
                        npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageOutSize =
                        wDstExt.wh;

                        // NV5 hw bug workaround
                        if (dwSrcWidth < 16)
                            {
                            npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInSize =
                                (wSrcExt.wh & 0xffff0000) | dwSrcPitch;
                            }
                        else
                            {
                            npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInSize =
                                wSrcExt.wh;
                            }

                        npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInFormat =
                            (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_FOH << 24) |
                            (NV077_IMAGE_IN_FORMAT_ORIGIN_CENTER << 16) |
                            srcBufferPitch;

                        if (curBuffer == 0)
                            npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInOffset =
                            0;
                            //(sizeof(NvNotification) << 3); /* there are 4 notifiers in the buffer */
                        else
                            npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInOffset =
                            (NV_DMA_SCANLINE_BUF_SIZE >> 1);
                            //(sizeof(NvNotification) << 3) + (NV_DMA_SCANLINE_BUF_SIZE >> 1);

                        npDev->dDrawStretch.nv4ScaledImageFromMemory.Notify =
                        0;
                        npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInPoint =
                        wSrcPoint.xy;
                        }

                    if (srcTooWide)
                        {
                        srcTooWide = 0;
                        wDestXY.xy16.x += (short)dstDeltaX;
                        wDstExt.wh16.w = wXYext.wh16.w - wDstExt.wh16.w;
                        if ((srcInVideoMemory) || (isVideo > 3))
                            wSrcPoint.xy16.x += (1024 << 4);
                        srcBufferPitch = ((dwSrcWidth << 1) + 3) & ~3L;
                        srcBufferPitch -= 2048;
                        pSaveSrcInitBits += 2048;
                        pSaveSrcBits = (unsigned short *)pSaveSrcInitBits;
                        pSrcCurScan = pSaveSrcBits;
                        goto oneMorePass;
                        }
#ifdef  MMX
                    if (curV != 0)
                        {
                        _asm emms;
                        }
#endif /* MMX */

                    }
                    if (isOverlappingVmem && lpSurfTemp)
                        {
                        NVHEAP_FREE(lpSurfTemp);
                        }
                }

            if (dwFlags & DDBLT_KEYSRCOVERRIDE)
                {
                // disable chroma key
                while (freeCount < 2*4)
                    freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);
                freeCount -= 2*4;
                if (ppdev->dDrawSpareSubchannelObject != NV_DD_IMAGE_SOLID)
                    {
                    npDev->dDrawSpare.SetObject = NV_DD_IMAGE_SOLID;
                    ppdev->dDrawSpareSubchannelObject = NV_DD_IMAGE_SOLID;
                    }
                npDev->dDrawTransColor.SetColor = 0;
                }

            }
        else
            {
            DPF("BLT     blt not handled by driver");
            ppdev->NVFreeCount = freeCount;
            return DDHAL_DRIVER_NOTHANDLED;
            }
        }
    else if (dwFlags & DDBLT_COLORFILL)
        {
        dwFillColor = (pbd->bltFX.dwFillColor & ppdev->physicalColorMask) | ppdev->AlphaEnableValue;
        DDRAW_SET_PRIMARY(ppdev, dwDstOffset, dwDstPitch);

        while (freeCount < 16)
            freeCount = NvGetFreeCount(npDev, NV_DD_ROP);
        freeCount -= 16;

        npDev->dDrawRop.SetRop5 = SRCCOPYINDEX;

        npDev->subchannel[NV_DD_RECT_AND_TEXT].Nv04GdiRectangleText.Color1A = dwFillColor;

        npDev->subchannel[NV_DD_RECT_AND_TEXT].Nv04GdiRectangleText.UnclippedRectangle[0].point =
        asmMergeCoords(wDestXY.xy16.y, wDestXY.xy16.x);

        npDev->subchannel[NV_DD_RECT_AND_TEXT].Nv04GdiRectangleText.UnclippedRectangle[0].size =
        asmMergeCoords(wXYext.wh16.h, wXYext.wh16.w);
        }
#ifdef NVD3D
//*********************************************************************************
// BUGBUG - z clear rectangle has not been implemented.
//*********************************************************************************
    else if (dwFlags & DDBLT_DEPTHFILL)
        {
        unsigned long dwFillDepth = pbd->bltFX.dwFillDepth;

        if (!(dwDstCaps & DDSCAPS_ZBUFFER))
            {
            pbd->ddRVal = DDERR_INVALIDSURFACETYPE;
            ppdev->NVFreeCount = freeCount;
            return DDHAL_DRIVER_HANDLED;
            }
        ppdev->NVFreeCount = freeCount;
        // BUGBUG NV3_SetZBufferBase(ppdev, dwDstOffset, dwDstPitch);
        freeCount = ppdev->NVFreeCount;

        while (freeCount < 6*4)
            freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);
        freeCount -= 6*4;

        /* Temporarily replace BLIT object */
        npDev->subchannel[NV_DD_BLIT].SetObject =
        NV_DD_RENDER_SOLID_ZETA_RECTANGLE;

        npDev->subchannel[NV_DD_BLIT].nvRenderSolidRectangle.Color =
        dwFillDepth;

        npDev->subchannel[NV_DD_BLIT].nvRenderSolidRectangle.Rectangle[0].y_x =
        asmMergeCoords(wDestXY.xy16.x, wDestXY.xy16.y);

        npDev->subchannel[NV_DD_BLIT].nvRenderSolidRectangle.Rectangle[0].height_width =
        asmMergeCoords(wXYext.wh16.w, wXYext.wh16.h);

        npDev->subchannel[NV_DD_BLIT].SetObject =
        NV_DD_IMAGE_BLIT;

        npDev->subchannel[NV_DD_SPARE].SetObject =
        NV_DD_DST_IMAGE_IN_MEMORY;
        ppdev->dDrawSpareSubchannelObject = NV_DD_DST_IMAGE_IN_MEMORY;
        }
#endif // #ifdef NVD3D
    else
        {
        /* We don't handle any other type of BLT operation */
        ppdev->NVFreeCount = freeCount;
        return DDHAL_DRIVER_NOTHANDLED;
        }

    ppdev->NVFreeCount = (short)freeCount;

    pbd->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;

    } /* Nv4Blt16 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\ddraw\nv4\dd.cpp ===
// **************************************************************************
//
//       Copyright 1993-2001 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: dd.cpp
//      nVidia routines to support the DirectDraw interface on NT4
//
// **************************************************************************
//
// Environment: kernel mode only
//
//******************************************************************************
#include "nvprecomp.h"
#include "nvalpha.h"
#include "ddminint.h"
#include "nv32.h"
#include "nvcm.h"
#include "nvUtil.h"

#include "nvos.h"
#include "nvntioctl.h"
#include "nvntddctl.h"
#include "nvapi.h"
#include "nvsubch.h"

#define NvGetFreeCount(NN, CH)\
                 (NN)->subchannel[CH].control.Free

extern ULONG NV4_ChannelIsGdi(PDEV *ppdev);
extern VOID NV4_DdPioSync(PDEV *ppdev);
    
extern GLOBALDATA           DriverData;     // in ddmini16.c

static OLD_FLIPRECORD       flipPrimaryRecord;
static OLD_FLIPRECORD       flipOverlayRecord;

/*
 * IN_VBLANK should be replaced by a test to see if the hardware is currently
 * in the vertical blank
 */
#define IN_VBLANK               FALSE
#define IN_DISPLAY              TRUE

/*
 * CURRENT_VLINE should be replaced by a macro to retrieve the current
 * scanline
 */
#define CURRENT_VLINE   (ppdev->pfnGetScanline(ppdev))

// Defines we'll use in the surface's 'dwReserved1' field:

#define DD_RESERVED_DIFFERENTPIXELFORMAT    0x0001


// Worst-case possible number of FIFO entries we'll have to wait for in
// DdBlt for any operation:

#define DDBLT_FIFO_COUNT    9

// NT is kind enough to pre-calculate the 2-d surface offset as a 'hint' so
// that we don't have to do the following, which would be 6 DIVs per blt:
//
//    y += (offset / pitch)
//    x += (offset % pitch) / bytes_per_pixel

#define convertToGlobalCord(x, y, surf) \
{                                       \
    y += surf->yHint;                   \
    x += surf->xHint;                   \
}


#define MAGIC_DELAY         1000000

#define WAIT_OVERLAY_NOTIFIER(buf)                                                                  \
{   NvNotification *pFlipOverlayNotifier =    (NvNotification *)ppdev->Notifiers->FlipOverlay;      \
    ULONG i = 0;                                                                                    \
    while (pFlipOverlayNotifier[NV07A_NOTIFIERS_SET_OVERLAY(buf)].status == NV_IN_PROGRESS)         \
        if(i++ > MAGIC_DELAY) break;                                                                \
}                                                                                                   \


/*
 * Nv4UpdateFlipStatus
 *
 * checks and sees if the most recent flip has occurred
 */
unsigned long Nv4UpdateFlipStatus( PDEV *ppdev, FLATPTR fpVidMem )
    {

	ULONG ulIndex;

    /*
     * see if a flip has happened recently
     */
    if (flipPrimaryRecord.bFlipFlag &&
        ((fpVidMem == 0) || (fpVidMem == flipPrimaryRecord.fpFlipFrom)) )
        {
        if(((NvNotification *) (&(ppdev->Notifiers->FlipPrimary[NV046_NOTIFIERS_SET_IMAGE(0)*sizeof(NvNotification)])))->status == NV_IN_PROGRESS)
        {
            return DDERR_WASSTILLDRAWING;
        }
	    else
        {
    	    ppdev->CurrentVisibleSurfaceAddress = flipPrimaryRecord.fpFlipTo;
            flipPrimaryRecord.bFlipFlag = FALSE;
        	return DD_OK;
        }

        /*
         * if we aren't in the vertical blank, we can use the scanline
         * to help decide on what to do
         */
//        if(!(IN_VBLANK)) {
//            if( (CURRENT_VLINE >= flipPrimaryRecord.wFlipScanLine) ) {
//                QueryPerformanceCounter((LARGE_INTEGER*)&ttime);
//                if( (DWORD)(ttime-flipPrimaryRecord.liFlipTime) <= flipPrimaryRecord.dwFlipDuration ) {
//                    return DDERR_WASSTILLDRAWING;
//                }
//            }
//        }
        /*
         * in the vertical blank, scanline is useless
         */
//        else {
//            QueryPerformanceCounter((LARGE_INTEGER*)&ttime);
//            if( ((DWORD)(ttime-flipPrimaryRecord.liFlipTime) <= flipPrimaryRecord.dwFlipDuration) ) {
//                return DDERR_WASSTILLDRAWING;
//            }
//        }
//        flipPrimaryRecord.bFlipFlag = FALSE;
        }

    if (flipOverlayRecord.bFlipFlag &&
        ((fpVidMem == 0) ||
         (fpVidMem == flipOverlayRecord.fpFlipFrom) ||
         (fpVidMem == flipOverlayRecord.fpPreviousFlipFrom)) ) {
        NvNotification *pPioFlipOverlayNotifier =
            (NvNotification *)ppdev->Notifiers->FlipOverlay;

        if (ppdev->CurrentClass.VideoOverlay == NV04_VIDEO_OVERLAY) {

            if (fpVidMem == flipOverlayRecord.fpPreviousFlipFrom) {
                // only need for one to flush out
                if (pPioFlipOverlayNotifier[ppdev->OverlayBufferIndex + 1].status == NV_IN_PROGRESS)
                    return (DDERR_WASSTILLDRAWING);
            } else {
                // need to wait for both flips to flush out
                if ((pPioFlipOverlayNotifier[1].status == NV_IN_PROGRESS) ||
                    (pPioFlipOverlayNotifier[2].status == NV_IN_PROGRESS)) {
                    return (DDERR_WASSTILLDRAWING);
                } else {
                    flipOverlayRecord.bFlipFlag = FALSE;
                }
            }
        } else {
            if (fpVidMem == flipOverlayRecord.fpPreviousFlipFrom) {
/* The WHQL flip status test doesn't like this conservatism.  Comment out for now.
                LONGLONG timeNow;
                // only need for one to flush out, no way to really determine this on NV10,
                // but if we wait at least one CRTC refresh since it was issued, we can
                // guarantee it has been flushed through
                if ((pPioFlipOverlayNotifier[1].status == NV_IN_PROGRESS) &&
                    (pPioFlipOverlayNotifier[2].status == NV_IN_PROGRESS)) {
                    EngQueryPerformanceCounter((LONGLONG *) &timeNow);
                    if ((timeNow - flipOverlayRecord.llPreviousFlipTime) < flipPrimaryRecord.dwFlipDuration) {
                        return (DDERR_WASSTILLDRAWING);
                    }
                }
*/
            } else {
                if (fpVidMem == flipOverlayRecord.fpFlipFrom) {
                    // need to wait for both flips to flush out
                    if ((pPioFlipOverlayNotifier[1].status == NV_IN_PROGRESS) &&
                        (pPioFlipOverlayNotifier[2].status == NV_IN_PROGRESS)) {
                        return (DDERR_WASSTILLDRAWING);
                    } else {
                        flipOverlayRecord.bFlipFlag = FALSE;
                    }
                }
            }
        }
        return (DD_OK);
    }

    return DD_OK;
}

//******************************Public*Routine**********************************
//
// Function: Nv4Blt()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************
DWORD Nv4Blt(PDD_BLTDATA pbd)
    {
    HRESULT     ddrval;
    PDEV        *ppdev;
    Nv3ChannelPio   *npDev;
    USHORT  freeCount;
    ULONG   DdReturncode;
    BOOL    releaseOpenglSemaphore = FALSE;
    NvNotification *pSyncNotifier;

    ppdev = (PDEV *)pbd->lpDD->dhpdev;
    npDev = (Nv3ChannelPio *) ppdev->ddChannelPtr;

    if (npDev == NULL)
        {
        pbd->ddRVal = DDERR_SURFACELOST;
        return DDHAL_DRIVER_HANDLED;
        }

    /*
     * is a flip in progress?
     */
    ddrval = Nv4UpdateFlipStatus(ppdev, pbd->lpDDDestSurface->lpGbl->fpVidMem);
    if ( ddrval != DD_OK )
        {
        if (pbd->dwFlags & DDBLT_WAIT)
            {
            while (ddrval != DD_OK)
                ddrval = Nv4UpdateFlipStatus(ppdev, pbd->lpDDDestSurface->lpGbl->fpVidMem);
            }
        else
            {
            pbd->ddRVal = ddrval;
            return DDHAL_DRIVER_HANDLED;
            }
        }

        ENTER_DMA_PUSH_SYNC();
        NV_DD_DMA_PUSHER_SYNC();

        if (ppdev->DdClipResetFlag)
            {
            freeCount = ppdev->NVFreeCount;
            while (freeCount < 2*4)
                freeCount = NvGetFreeCount(npDev, NV_DD_CLIP);
            freeCount -= 2*4;
            npDev->subchannel[NV_DD_CLIP].Nv01ContextClipRectangle.SetPoint = 0;
            npDev->subchannel[NV_DD_CLIP].Nv01ContextClipRectangle.SetSize =
            asmMergeCoords(ppdev->cxMemory, ppdev->cyMemory);
            ppdev->DdClipResetFlag = 0;       // Clipping rectangle has been reset
            ppdev->NVFreeCount = freeCount;
            }


    if (ppdev->cBitsPerPel == 8)
        {
        DdReturncode = Nv4Blt8(pbd);
        }
    else if (ppdev->cBitsPerPel == 16)
        {
        DdReturncode = Nv4Blt16(pbd);
        }
    else if (ppdev->cBitsPerPel == 32)
        {
        DdReturncode = Nv4Blt32(pbd);
        }
    else
        {
        pbd->ddRVal = DDERR_INVALIDPIXELFORMAT;
        DdReturncode = DDHAL_DRIVER_NOTHANDLED;
        }
    ppdev->NVFreeCount = 0;
    EXIT_DMA_PUSH_SYNC(DdReturncode);
    }

//******************************Public*Routine**********************************
//
// Function: Nv4Flip()
//
//  Note that lpSurfCurr may not necessarily be valid.
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************

DWORD __stdcall Nv4Flip(PDD_FLIPDATA pfd)
    {
    FAST short freeCount;
    HRESULT     ddrval;
    PDD_SURFACE_GLOBAL   pSurfTarg_gbl;
    BOOL    releaseOpenglSemaphore = FALSE;

    PDEV *ppdev = (PDEV *) pfd->lpDD->dhpdev;
    FAST Nv3ChannelPio *npDev = (Nv3ChannelPio *)ppdev->ddChannelPtr;

    NvNotification *pFlipOverlayNotifier =
    (NvNotification *)ppdev->Notifiers->FlipOverlay;
    NvNotification *pDmaToMemNotifier =
    (NvNotification *)ppdev->Notifiers->DmaToMem;

    /*
     * NOTES:
     *
     * This callback is invoked whenever we are about to flip to from
     * one surface to another.   pfd->lpSurfCurr is the surface we were at,
     * pfd->lpSurfTarg is the one we are flipping to.
     *
     * You should point the hardware registers at the new surface, and
     * also keep track of the surface that was flipped away from, so
     * that if the user tries to lock it, you can be sure that it is done
     * being displayed
     */

    DPF( "Flip32: curr=%08lx, targ=%08lx", pfd->lpSurfCurr, pfd->lpSurfTarg );
    DPF( "        vidmem ptrs change: %08lx->%08lx",
         pfd->lpSurfCurr->lpGbl->fpVidMem,
         pfd->lpSurfTarg->lpGbl->fpVidMem );


    ddrval = Nv4UpdateFlipStatus(ppdev, 0);

    if (ddrval != DD_OK)
        {
        if (pfd->dwFlags & DDFLIP_WAIT)
            {
            while (ddrval != DD_OK)
                {
                ddrval = Nv4UpdateFlipStatus(ppdev, 0);
                }
            }
        else
            {
            pfd->ddRVal = ddrval;
            return DDHAL_DRIVER_HANDLED;
            }
        }

    if (npDev == NULL)
        {
        pfd->ddRVal = DDERR_SURFACELOST;
        return DDHAL_DRIVER_HANDLED;
        }

    if ((pfd->dwFlags & DDFLIP_WAIT) &&
        ppdev->pfnGraphicsEngineBusy(ppdev))
        {
        ppdev->NVFreeCount = 0;
        pfd->ddRVal = DDERR_WASSTILLDRAWING;
        EXIT_DMA_PUSH_SYNC(DDHAL_DRIVER_HANDLED);
        }

    ENTER_DMA_PUSH_SYNC();
    NV_DD_DMA_PUSHER_SYNC();
    NV4_DdPioSync(ppdev);

    freeCount = NvGetFreeCount(npDev, 7);

    /*
     * everything is OK, do the flip here
     */

    pSurfTarg_gbl = pfd->lpSurfTarg->lpGbl;

    /* Is this an overlay surface ? */
    if (!(pfd->lpSurfTarg->ddsCaps.dwCaps & DDSCAPS_OVERLAY))
        {
        /* No - assume it is the primary surface */

        ULONG i, ulHead;

        flipPrimaryRecord.fpFlipFrom = pfd->lpSurfCurr->lpGbl->fpVidMem;
        flipPrimaryRecord.bHaveEverCrossedVBlank = FALSE;
        flipPrimaryRecord.fpFlipTo = pSurfTarg_gbl->fpVidMem;

        flipPrimaryRecord.bFlipFlag = TRUE;

        ((NvNotification *) (&(ppdev->Notifiers->FlipPrimary[NV046_NOTIFIERS_SET_IMAGE(0)*sizeof(NvNotification)])))->status = NV_IN_PROGRESS;
    	for(i = 0; i < ppdev->ulNumberDacsActive; i++)
	    {
            NV_CREATE_OBJECT_SETUP();

            ulHead = ppdev->ulDeviceDisplay[i];

            while (freeCount < 4 * 6)
                freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);
            freeCount -= 4 * 6;


            npDev->subchannel[NV_DD_SPARE].SetObject = NV_DD_VIDEO_LUT_CURSOR_DAC+ulHead;
            ppdev->dDrawSpareSubchannelObject = NV_DD_VIDEO_LUT_CURSOR_DAC+ulHead;
            
            npDev->dDrawSpare.SetObject = NV_DD_VIDEO_LUT_CURSOR_DAC+ulHead;
            npDev->dDrawSpare.Nv04VideoLutCursorDac.SetImage[0].offset = 
                pSurfTarg_gbl->fpVidMem + i * ppdev->ulHeadDisplayOffset[ulHead];
            npDev->dDrawSpare.Nv04VideoLutCursorDac.SetImage[0].format = ppdev->lDelta | 
                NV046_SET_IMAGE_FORMAT_NOTIFY_WRITE_THEN_AWAKEN << 31;

            ppdev->ulFlipBase = pSurfTarg_gbl->fpVidMem;

        }
        // Syn. with both heads
        if(ppdev->ulNumberDacsActive > 1)
            while(((NvNotification *) (&(ppdev->Notifiers->FlipPrimary[NV046_NOTIFIERS_SET_IMAGE(0)*sizeof(NvNotification)])))->status == NV_IN_PROGRESS);

        if (IN_VBLANK)
            {
            flipPrimaryRecord.dwFlipScanLine = 0;
            flipPrimaryRecord.bWasEverInDisplay = FALSE;
            }
        else
            {
            flipPrimaryRecord.dwFlipScanLine = CURRENT_VLINE;
            flipPrimaryRecord.bWasEverInDisplay = TRUE;
            }
        }
    else if (pfd->lpSurfTarg->ddsCaps.dwCaps & DDSCAPS_OVERLAY)
        { /* overlay */
        DWORD dwOffset;
        DWORD dwPitch;
        DWORD index;

        flipOverlayRecord.liPreviousFlipTime = flipOverlayRecord.liFlipTime;
        EngQueryPerformanceCounter((LONGLONG *) &flipOverlayRecord.liFlipTime);
        flipOverlayRecord.fpPreviousFlipFrom = flipOverlayRecord.fpFlipFrom;
        flipOverlayRecord.fpFlipFrom = pfd->lpSurfCurr->lpGbl->fpVidMem;
        flipOverlayRecord.fpFlipTo = pSurfTarg_gbl->fpVidMem;
        flipOverlayRecord.bHaveEverCrossedVBlank = FALSE;

        flipOverlayRecord.bFlipFlag = TRUE;

        /* Alternate buffer indexes to keep the hardware happy */

   	    ppdev->OverlayBufferIndex ^= 1;
    	index = ppdev->OverlayBufferIndex;

        /* Make sure we flip to the correct starting offset in new overlay surface */
        dwOffset = pSurfTarg_gbl->fpVidMem;

        if ((pSurfTarg_gbl->ddpfSurface.dwFourCC == FOURCC_IF09) ||
            (pSurfTarg_gbl->ddpfSurface.dwFourCC == FOURCC_YVU9) ||
            (pSurfTarg_gbl->ddpfSurface.dwFourCC == FOURCC_IV32) ||
            (pSurfTarg_gbl->ddpfSurface.dwFourCC == FOURCC_IV31))
            {
            /* Skip over Indeo portion of surface */
            dwPitch = (DWORD)pSurfTarg_gbl->wWidth;
            dwOffset += ((dwPitch * ((DWORD)pSurfTarg_gbl->wHeight * 10L)) >> 3);
            /* Force block to be properly aligned */
            dwOffset = (dwOffset + ppdev->ulSurfaceAlign) & ~ppdev->ulSurfaceAlign;
            dwPitch = ((pSurfTarg_gbl->wWidth + 1) & 0xFFFFFFFE) << 1;
            dwPitch = (dwPitch + ppdev->ulSurfaceAlign) & ~ppdev->ulSurfaceAlign;
            }
        else if ((pSurfTarg_gbl->ddpfSurface.dwFourCC == FOURCC_YV12) ||
                 (pSurfTarg_gbl->ddpfSurface.dwFourCC == FOURCC_420i))
            {
            /* Assumes a separate overlay YUY2 surface in video memory */
            if (pSurfTarg_gbl->fpVidMem == ppdev->NvFloatingMem2MemFormatBaseAddress)
                dwOffset = ppdev->NvYUY2Surface0Mem;
            else if (pSurfTarg_gbl->fpVidMem == ppdev->NvFloatingMem2MemFormatNextAddress)
                dwOffset = ppdev->NvYUY2Surface1Mem;
            else
                dwOffset = ppdev->NvYUY2Surface2Mem;

            dwPitch = ((pSurfTarg_gbl->wWidth + 1) & 0xFFFFFFFE) << 1;
            dwPitch = (dwPitch + ppdev->ulSurfaceAlign) & ~ppdev->ulSurfaceAlign;
            }
        else
            dwPitch = (DWORD)pSurfTarg_gbl->lPitch;

        dwOffset += (ppdev->OverlaySrcY * dwPitch);
        dwOffset += (ppdev->OverlaySrcX << 1);



        while (freeCount < 10*4)
            freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);
        freeCount -= 10*4;

        if (ppdev->dDrawSpareSubchannelObject != NV_DD_VIDEO_OVERLAY)
        {
            npDev->subchannel[NV_DD_SPARE].SetObject = NV_DD_VIDEO_OVERLAY;
            ppdev->dDrawSpareSubchannelObject = NV_DD_VIDEO_OVERLAY;
        }

        npDev->dDrawSpare.SetObject = NV_DD_VIDEO_OVERLAY;

        npDev->dDrawSpare.Nv04VideoOverlay.SetOverlay[index].colorKey = ppdev->dwVideoColorKey;
        npDev->dDrawSpare.Nv04VideoOverlay.SetOverlay[index].offset =  dwOffset;
        npDev->dDrawSpare.Nv04VideoOverlay.SetOverlay[index].sizeIn = ppdev->OverlaySrcSize;
        npDev->dDrawSpare.Nv04VideoOverlay.SetOverlay[index].pointIn = 0;
        npDev->dDrawSpare.Nv04VideoOverlay.SetOverlay[index].dsDx = ppdev->dwOverlayDeltaX;
        npDev->dDrawSpare.Nv04VideoOverlay.SetOverlay[index].dtDy = ppdev->dwOverlayDeltaY;
        npDev->dDrawSpare.Nv04VideoOverlay.SetOverlay[index].pointOut = asmMergeCoords(ppdev->dwOverlayDstX, ppdev->dwOverlayDstY);
        npDev->dDrawSpare.Nv04VideoOverlay.SetOverlay[index].sizeOut = asmMergeCoords(ppdev->dwOverlayDstWidth, ppdev->dwOverlayDstHeight);
        npDev->dDrawSpare.Nv04VideoOverlay.SetOverlay[index].format = ppdev->dwOverlayFormat | dwPitch;
        ppdev->OverlaySrcOffset = dwOffset;
        }
    else
        { /* video port flips handled by FlipVideoPort32 */
        ppdev->NVFreeCount = freeCount;
        pfd->ddRVal = DDERR_INVALIDSURFACETYPE;
        EXIT_DMA_PUSH_SYNC(DDHAL_DRIVER_HANDLED);
        }

    if (pfd->dwFlags & DDFLIP_WAIT)
        {
        ddrval = Nv4UpdateFlipStatus(ppdev, 0);

        while (ddrval != DD_OK)
            ddrval = Nv4UpdateFlipStatus(ppdev, 0);
        }

    ppdev->NVFreeCount = freeCount;

    pfd->ddRVal = DD_OK;
    EXIT_DMA_PUSH_SYNC(DDHAL_DRIVER_HANDLED);

    } /* Flip32 */

//******************************Public*Routine**********************************
//
// Function: Nv4Lock()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************
DWORD Nv4Lock(
            PDD_LOCKDATA lpLockData)
    {
    HRESULT                     ddrval;
    DWORD                       dwOffset;
    DWORD                       caps;
    PDD_SURFACE_GLOBAL          psurf_gbl;
    BOOL    releaseOpenglSemaphore = FALSE;

    PDEV    *ppdev = (PDEV *) lpLockData->lpDD->dhpdev;
    FAST Nv3ChannelPio              *npDev = (Nv3ChannelPio *)ppdev->ddChannelPtr;
    NvNotification *pPioFlipOverlayNotifier = (NvNotification *)ppdev->Notifiers->FlipOverlay;

    NvNotification              *pDmaToMemNotifier =
    (NvNotification *)ppdev->Notifiers->DmaToMem;
    NvNotification              *pDmaFromMemNotifier =
    (NvNotification *)ppdev->Notifiers->DmaFromMem;
    NvNotification              *pSyncNotifier =
      (NvNotification *)ppdev->Notifiers->Sync;


    psurf_gbl = lpLockData->lpDDSurface->lpGbl;

    if (lpLockData->lpDDSurface->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
        {
        //*****************************************************************
        // For surfaces in system memory, just return the user-mode address
        //*****************************************************************
        lpLockData->lpSurfData = (VOID*) psurf_gbl->fpVidMem;
        lpLockData->ddRVal = DD_OK;

        //*****************************************************************
        // When a driver returns DD_OK and DDHAL_DRIVER_HANDLED from DdLock,
        // DirectDraw expects it to have adjusted the resulting pointer
        // to point to the upper left corner of the specified rectangle, if
        // any:
        //*****************************************************************
        if (lpLockData->bHasRect)
            {
            lpLockData->lpSurfData = (VOID*) ((BYTE*) lpLockData->lpSurfData
                                              + lpLockData->rArea.top * psurf_gbl->lPitch
                                              + lpLockData->rArea.left
                                              * (psurf_gbl->ddpfSurface.dwYUVBitCount >> 3));
            }

        return (DDHAL_DRIVER_HANDLED);
        }

    /*
     * NOTES:
     *
     * This callback is invoked whenever a surface is about to be directly
     * accessed by the user.   This is where you need to make sure that
     * a surface can be safely accessed by the user.
     *
     * If your memory cannot be accessed while in accelerator mode, you
     * should either take the card out of accelerator mode or else
     * return DDERR_SURFACEBUSY
     *
     * If someone is accessing a surface that was just flipped away from,
     * make sure that the old surface (what was the primary) has finished
     * being displayed.
     */

    caps = lpLockData->lpDDSurface->ddsCaps.dwCaps;

    if ((npDev == NULL) && (caps & DDSCAPS_VIDEOMEMORY))
        {  /* Mode switches might occur without warning */
        lpLockData->ddRVal = DDERR_SURFACELOST;
        return DDHAL_DRIVER_HANDLED;
        }

    psurf_gbl = lpLockData->lpDDSurface->lpGbl;

    /*
     * check to see if any pending physical flip has occurred
     */

    ddrval = Nv4UpdateFlipStatus(ppdev, psurf_gbl->fpVidMem);
    if ( ddrval != DD_OK )
        {
        if (lpLockData->dwFlags & DDLOCK_WAIT)
            {
            while (ddrval != DD_OK)
                {
                long countDown = 500000;  // sometimes we can loose a Flip notification
                ddrval = Nv4UpdateFlipStatus(ppdev, psurf_gbl->fpVidMem);
                if (--countDown <= 0)
                    {
                    ((NvNotification *) (&(ppdev->Notifiers->FlipPrimary[NV046_NOTIFIERS_SET_IMAGE(0)*sizeof(NvNotification)])))->status = 0;
                    pPioFlipOverlayNotifier[1].status = 0;
                    pPioFlipOverlayNotifier[2].status = 0;
                    }
                }
            }
        else
            {
            lpLockData->ddRVal = DDERR_WASSTILLDRAWING;
            return DDHAL_DRIVER_HANDLED;
            }
        }

    if (caps & (DDSCAPS_VIDEOMEMORY | DDSCAPS_PRIMARYSURFACE))
        {
        if (((caps & DDSCAPS_TEXTURE) == 0) && ((lpLockData->dwFlags & DDLOCK_READONLY) == 0))
            {

            if (!OglIsEnabled(ppdev))
                {
                //***********************************************************************
                // Ensure graphics engine has completed all processing in Ddraw
                // channel. We know the GDI channel is idle at this point.
                //***********************************************************************
                NV_DD_DMA_PUSHER_SYNC();
                NV4_DdPioSync(ppdev);
                }
            else
                {
                //************************************************************************
                // If OpenGL ICD is running, the fifo sync routine will ensure the fifo is
                // empty and the graphics engine has completed its processing.
                //*************************************************************************
                START_DMA_PUSH_SYNC();
                NV_DD_DMA_PUSHER_SYNC();
                ppdev->NVFreeCount = 0;
                END_DMA_PUSH_SYNC();
                }
            }
        else
            {
            return(DDHAL_DRIVER_NOTHANDLED);
            }
        }
    return(DDHAL_DRIVER_NOTHANDLED);
    }

//******************************Public*Routine**********************************
//
// Function: Nv4Unlock()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************

DWORD __stdcall Nv4Unlock( PDD_UNLOCKDATA lpUnlockData )
    {
    FAST Nv3ChannelPio          *npDev;
    PDD_SURFACE_GLOBAL   pSurf_gbl;
    DWORD                       caps;
    PDEV*   ppdev;

    caps = lpUnlockData->lpDDSurface->ddsCaps.dwCaps;
    ppdev = (PDEV *) lpUnlockData->lpDD->dhpdev;
    npDev = (Nv3ChannelPio *) ppdev->ddChannelPtr;

    if ((npDev == NULL) && (caps & DDSCAPS_VIDEOMEMORY))
        {  /* Mode switches might occur without warning */
        lpUnlockData->ddRVal = DDERR_SURFACELOST;
        return DDHAL_DRIVER_HANDLED;
        }

    pSurf_gbl = lpUnlockData->lpDDSurface->lpGbl;

    if (caps & DDSCAPS_OVERLAY)
        Nv4UnlockOverlay(lpUnlockData);

    lpUnlockData->ddRVal = DD_OK;

    return DDHAL_DRIVER_HANDLED;

    } /* Unlock32 */


//******************************Public*Routine**********************************
//
// Function: Nv4GetBltStatus()
//
//      Doesn't currently really care what surface is specified, just checks
//      and goes.
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************

DWORD Nv4GetBltStatus(
                    PDD_GETBLTSTATUSDATA lpGetBltStatus)

    {
    PDEV*   ppdev;
    BYTE*   pjMmBase;
    HRESULT ddRVal;
    FNGRAPHICSENGINEBUSY*  pfnGraphicsEngineBusy;
    FNFIFOISBUSY*         pfnFifoIsBusy;
    Nv3ChannelPio *npDev;

    ppdev    = (PDEV*) lpGetBltStatus->lpDD->dhpdev;

    //**************************************************************************
    // Init chip specific function pointers
    //**************************************************************************

    pfnGraphicsEngineBusy = ppdev->pfnGraphicsEngineBusy;
    pfnFifoIsBusy         = ppdev->pfnFifoIsBusy;

    ddRVal = DD_OK;
    if (lpGetBltStatus->dwFlags == DDGBS_CANBLT)
        {
        //**********************************************************************
        // DDGBS_CANBLT case: can we add a blt?
        //**********************************************************************

        ddRVal = Nv4UpdateFlipStatus(ppdev,
                                        lpGetBltStatus->lpDDSurface->lpGbl->fpVidMem);

         }

    else

        {
        //**********************************************************************
        // DDGBS_ISBLTDONE case: is a blt in progress?
        //**********************************************************************
        npDev = (Nv3ChannelPio *) ppdev->ddChannelPtr;
        NV_DD_DMA_PUSHER_SYNC();
        NV4_DdPioSync(ppdev);
        ddRVal = DD_OK;
        }

    lpGetBltStatus->ddRVal = ddRVal;
    return (DDHAL_DRIVER_HANDLED);
    }

//******************************Public*Routine**********************************
//
// Function: Nv4DestroySurface
//
// Routine Description:
//
//      Note that if DirectDraw did the allocation, DDHAL_DRIVER_NOTHANDLED
//      should be returned.
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************

DWORD __stdcall Nv4DestroySurface( PDD_DESTROYSURFACEDATA lpDestroySurface )
    {
    PDD_DIRECTDRAW_GLOBAL pdrv;
    PDD_SURFACE_LOCAL   psurf;
    PDD_SURFACE_GLOBAL  psurf_gbl;
    BOOL    releaseOpenglSemaphore = FALSE;

    DWORD                       index = 0;
    PDEV *ppdev = (PDEV *) lpDestroySurface->lpDD->dhpdev;
    Nv3ChannelPio  *npDev = (Nv3ChannelPio *)ppdev->ddChannelPtr;
    USHORT     freeCount = ppdev->NVFreeCount;
    NvNotification *pFlipOverlayNotifier = (NvNotification *)ppdev->Notifiers->FlipOverlay;

    pdrv = lpDestroySurface->lpDD;
    DPF( "in DestroySurface, lpDestroySurface->lpDD=%08lx, lpDestroySurface->lpDDSurface = %08lx",
         pdrv, lpDestroySurface->lpDDSurface );

    psurf = lpDestroySurface->lpDDSurface;
    psurf_gbl = psurf->lpGbl;

    if (psurf_gbl->fpVidMem == 0)
        {
        lpDestroySurface->ddRVal = DD_OK;
        goto DESTROY_HANDLED;
        }

    /*
       Should check if YUV surface is an active VPE surface and make sure
       to stop VPE hardware before destroying VPE surface somewhere YUV
       surface code in this function.
    */

    if ((psurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) &&
        (psurf->ddsCaps.dwCaps & (DDSCAPS_VISIBLE | DDSCAPS_FRONTBUFFER)))
        {
        //**************************************************************
        // Ensure GDI channel has completed processing.
        //**************************************************************
        ENTER_DMA_PUSH_SYNC();
        NV_DD_DMA_PUSHER_SYNC();


        freeCount = ppdev->NVFreeCount;
        ppdev->HALInfo.ddCaps.dwCurrVisibleOverlays = 0;

        WAIT_OVERLAY_NOTIFIER(0);
        WAIT_OVERLAY_NOTIFIER(1);

        while (freeCount < 3*4)
            freeCount = NvGetFreeCount(npDev, BLIT_SUBCHANNEL);
        freeCount -= 3*4;

        npDev->dDrawSpare.SetObject = NV_DD_VIDEO_OVERLAY;
        npDev->dDrawSpare.Nv04VideoOverlay.StopOverlay[0] = NV07A_STOP_OVERLAY_AS_SOON_AS_POSSIBLE;
        npDev->dDrawSpare.Nv04VideoOverlay.StopOverlay[1] = NV07A_STOP_OVERLAY_AS_SOON_AS_POSSIBLE;

        ppdev->dDrawSpareSubchannelObject = NV_DD_VIDEO_OVERLAY;

        ppdev->NVFreeCount = (short)freeCount;
        END_DMA_PUSH_SYNC();
        }

    if (
       // (psurf->dwFlags & DDRAWISURF_HASPIXELFORMAT) &&
       (psurf_gbl->ddpfSurface.dwFlags & DDPF_FOURCC) )
        {
        DPF( "  FOURCC surface" );

        switch ( psurf->lpGbl->ddpfSurface.dwFourCC )
            {
            case FOURCC_RGB0:
                if (psurf->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY)
                    {
                    if (psurf_gbl->fpVidMem > 0)
                        {
                        NVHEAP_FREE( psurf_gbl->fpVidMem);
                        psurf_gbl->fpVidMem = 0;
                        if (ppdev->DDrawVideoSurfaceCount > 0)
                            ppdev->DDrawVideoSurfaceCount--;
                        }
                    }
                else
                    {
                    lpDestroySurface->ddRVal = DD_OK;
                    return DDHAL_DRIVER_NOTHANDLED;
                    }
                lpDestroySurface->ddRVal = DD_OK;
                goto DESTROY_HANDLED;
                break;
            case FOURCC_IF09:
            case FOURCC_YVU9:
            case FOURCC_IV32:
            case FOURCC_IV31:
            case FOURCC_YUY2:
            case FOURCC_UYVY:
                if (psurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY)
                    {
                    while (index < NV_MAX_OVERLAY_SURFACES)
                        {
                        if ((DWORD)psurf == ppdev->dwOverlaySurfaceLCL[index])
                            {
                            ppdev->dwOverlaySurfaceLCL[index] = 0;
                            if (ppdev->dwOverlaySurfaces > 0)
                                ppdev->dwOverlaySurfaces--;
                            if (ppdev->dwOverlaySurfaces == 0)
                                {
                                ppdev->dwOverlayOwner = 0;
                                }
                            }
                        index++;
                        }
                    }

                if ((psurf->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) &&
                    ((psurf->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) == 0))
                    {
                    if (psurf_gbl->fpVidMem > 0)
                        {
                        NVHEAP_FREE(psurf_gbl->fpVidMem);
                        psurf_gbl->fpVidMem = 0;
                        if (ppdev->DDrawVideoSurfaceCount > 0)
                            ppdev->DDrawVideoSurfaceCount--;
                        }
                    }
                else
                    {
                    if ((ppdev->fNvActiveFloatingContexts) &&
                        ((psurf->lpGbl->ddpfSurface.dwFourCC == FOURCC_UYVY) ||
                         (psurf->lpGbl->ddpfSurface.dwFourCC == FOURCC_YUY2)))
                        {
                        if (psurf->lpGbl->ddpfSurface.dwFourCC == FOURCC_UYVY)
                            {
                            if ((ppdev->fNvActiveFloatingContexts &
                                 NV_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY) &&
                                (ppdev->NvFloating0UYVYSurfaceMem == psurf_gbl->fpVidMem))
                                {

                                if (NvFree(ppdev->hDriver, ppdev->hClient, ppdev->hDevice, NV_DD_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY) != NVOS00_STATUS_SUCCESS)
                                    {
                                    /* Mode switches might occur without warning */
                                    lpDestroySurface->ddRVal = DDERR_SURFACELOST;
                                    goto DESTROY_HANDLED;
                                    }

                                ppdev->fNvActiveFloatingContexts &=
                                ~NV_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

                                }
                            else if ((ppdev->fNvActiveFloatingContexts &
                                      NV_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY) &&
                                     (ppdev->NvFloating1UYVYSurfaceMem == psurf_gbl->fpVidMem))
                                {
                                /* Trash spare subchannel */
                                if (NvFree(ppdev->hDriver, ppdev->hClient, ppdev->hDevice, NV_DD_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY) != NVOS00_STATUS_SUCCESS)
                                    {
                                    /* Mode switches might occur without warning */
                                    lpDestroySurface->ddRVal = DDERR_SURFACELOST;
                                    goto DESTROY_HANDLED;
                                    }

                                ppdev->fNvActiveFloatingContexts &=
                                ~NV_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
                                }
                            }
                        else
                            {
                            if ((ppdev->fNvActiveFloatingContexts &
                                 NV_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY) &&
                                (ppdev->NvFloating0YUYVSurfaceMem == psurf_gbl->fpVidMem))
                                {
                                if (NvFree(ppdev->hDriver, ppdev->hClient, ppdev->hDevice, NV_DD_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY) != NVOS00_STATUS_SUCCESS)
                                    {
                                    /* Mode switches might occur without warning */
                                    lpDestroySurface->ddRVal = DDERR_SURFACELOST;
                                    goto DESTROY_HANDLED;
                                    }

                                ppdev->fNvActiveFloatingContexts &=
                                ~NV_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

                                }
                            else if ((ppdev->fNvActiveFloatingContexts &
                                      NV_FLOATING1_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY) &&
                                     (ppdev->NvFloating1YUYVSurfaceMem == psurf_gbl->fpVidMem))
                                {
                                if (NvFree(ppdev->hDriver, ppdev->hClient, ppdev->hDevice, NV_DD_FLOATING1_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY) != NVOS00_STATUS_SUCCESS)
                                    {
                                    /* Mode switches might occur without warning */
                                    lpDestroySurface->ddRVal = DDERR_SURFACELOST;
                                    goto DESTROY_HANDLED;
                                    }

                                ppdev->fNvActiveFloatingContexts &=
                                ~NV_FLOATING1_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

                                }
                            }
                        }

                    return(DDHAL_DRIVER_NOTHANDLED);
                    }
                lpDestroySurface->ddRVal = DD_OK;
                goto DESTROY_HANDLED;
                break;

            case FOURCC_YV12:
            case FOURCC_420i:
                if (psurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY)
                    {
                    while (index < NV_MAX_OVERLAY_SURFACES)
                        {
                        if ((DWORD)psurf == ppdev->dwOverlaySurfaceLCL[index])
                            {
                            ppdev->dwOverlaySurfaceLCL[index] = 0;
                            if (ppdev->dwOverlaySurfaces > 0)
                                ppdev->dwOverlaySurfaces--;
                            if (ppdev->dwOverlaySurfaces == 0)
                                {
                                ppdev->dwOverlayOwner = 0;
                                }
                            }
                        index++;
                        }
                    }

                if ((psurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) &&
                    (psurf->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY))
                    {
                    if (psurf_gbl->fpVidMem == ppdev->NvFloatingMem2MemFormatBaseAddress)
                        {

                        if (ppdev->NvYUY2Surface0Mem > 0)
                            {
                            NVHEAP_FREE(ppdev->NvYUY2Surface0Mem);
                            ppdev->NvYUY2Surface0Mem = 0;
                            if (ppdev->DDrawVideoSurfaceCount > 0)
                                ppdev->DDrawVideoSurfaceCount--;
                            }

                        if (npDev == NULL)
                            {  /* Mode switches might occur without warning */
                            lpDestroySurface->ddRVal = DDERR_SURFACELOST;
                            goto DESTROY_HANDLED;
                            }
#ifdef SYSMEM_FALLBACK
                        if ((ppdev->NvFloatingMem2MemFormatBaseAddress < (ULONG) ppdev->pjFrameBufbase) || /* If system memory */
                            (ppdev->NvFloatingMem2MemFormatBaseAddress > (ULONG) ppdev->pjFrameBufbase + 0x1000000))
                            {
                            if (NvFree(ppdev->hDriver, ppdev->hClient, ppdev->hDevice, NV_DD_FLOATING_FORMAT_CONTEXT_DMA_FROM_SYSTEM_MEMORY) != NVOS00_STATUS_SUCCESS)
                                {
                                /* Mode switches might occur without warning */
                                lpDestroySurface->ddRVal = DDERR_SURFACELOST;
                                goto DESTROY_HANDLED;
                                }
                            }
                        else
#endif // #ifdef SYSMEM_FALLBACK
                            {
                            NVHEAP_FREE(psurf_gbl->fpVidMem);
                            if (ppdev->DDrawVideoSurfaceCount > 0)
                                ppdev->DDrawVideoSurfaceCount--;
                            }

                        ppdev->NvFloatingMem2MemFormatBaseAddress = 0;
                        ppdev->NvFloatingMem2MemFormatNextAddress = 0;

                        }
                    else
                        {
                        if (psurf_gbl->fpVidMem == ppdev->NvFloatingMem2MemFormatNextAddress)
                            {
                            ppdev->NvFloatingMem2MemFormatNextAddress = 0;
                            if (ppdev->NvYUY2Surface1Mem > 0)
                                {
                                NVHEAP_FREE(ppdev->NvYUY2Surface1Mem);
                                ppdev->NvYUY2Surface1Mem = 0;
                                if (ppdev->DDrawVideoSurfaceCount > 0)
                                    ppdev->DDrawVideoSurfaceCount--;
                                }
                            }
                        else
                            {
                            if (ppdev->NvYUY2Surface2Mem > 0)
                                {
                                NVHEAP_FREE(ppdev->NvYUY2Surface2Mem);
                                ppdev->NvYUY2Surface2Mem = 0;
                                if (ppdev->DDrawVideoSurfaceCount > 0)
                                    ppdev->DDrawVideoSurfaceCount--;
                                }
                            }
                        }
                    psurf_gbl->fpVidMem = 0;
                    }
                else if (psurf->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY)
                    {
                    if (psurf_gbl->fpVidMem > 0)
                        {
                        NVHEAP_FREE(psurf_gbl->fpVidMem);
                        psurf_gbl->fpVidMem = 0;
                        if (ppdev->DDrawVideoSurfaceCount > 0)
                            ppdev->DDrawVideoSurfaceCount--;
                        }
                    }
                else
                    {
                    return(DDHAL_DRIVER_NOTHANDLED);
                    }
                lpDestroySurface->ddRVal = DD_OK;
                goto DESTROY_HANDLED;
                break;
            }
        }
    else if ((psurf->ddsCaps.dwCaps & DDSCAPS_OFFSCREENPLAIN) &&
             (psurf->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY))
        {
        if (psurf_gbl->fpVidMem > 0)
            {
            NVHEAP_FREE(psurf_gbl->fpVidMem);
            if (ppdev->DDrawVideoSurfaceCount > 0)
                ppdev->DDrawVideoSurfaceCount--;
            psurf_gbl->fpVidMem = 0;
            }
        DPF( "    Offscreen deallocated" );
        lpDestroySurface->ddRVal = DD_OK;
        goto DESTROY_HANDLED;
        }
    else if (psurf->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY)
        {
        if (psurf_gbl->fpVidMem > 0)
            {
            NVHEAP_FREE(psurf_gbl->fpVidMem);
            if (ppdev->DDrawVideoSurfaceCount > 0)
                ppdev->DDrawVideoSurfaceCount--;
            psurf_gbl->fpVidMem = 0;
            }
        else
            {
            DPF( "    Unspecified Video Memory deallocation not handled");
            return DDHAL_DRIVER_NOTHANDLED;
            }
        DPF( "    Offscreen deallocated" );
        lpDestroySurface->ddRVal = DD_OK;
        goto DESTROY_HANDLED;
        }
    else if (psurf->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
        {
        DPF( "    System memory deallocated" );
        return DDHAL_DRIVER_NOTHANDLED;
        }

    return DDHAL_DRIVER_NOTHANDLED;

DESTROY_HANDLED:
    return DDHAL_DRIVER_HANDLED;

    }

//
// From nv_ref.h - RM guys may some day give a better way to read this
//
#define NV_PBUS_PCI_NV_18                                0x00001848 /* RW-4R */
#define NV_PBUS_PCI_NV_19                                0x0000184C /* RW-4R */
#define NV_PBUS_PCI_NV_19_AGP_COMMAND_AGP_ENABLE                8:8 /* RWIVF */
#define NV_PBUS_PCI_NV_19_AGP_COMMAND_FW_ENABLE                 4:4 /* RWIVF */
#define NV_PBUS_PCI_NV_19_AGP_COMMAND_SBA_ENABLE                9:9 /* RWIVF */
#define NV_PBUS_PCI_NV_18_AGP_STATUS_FW                         4:4 /* R--VF */
#define NV_PBUS_PCI_NV_18_AGP_STATUS_SBA                        9:9 /* R--VF */

// search for a particular class in a list of classes
// return TRUE if found, FALSE if not
// (right now this is just a dumb linear search. it could be better...)

static __inline BOOL nvClassListCheck
(
    NV_CFGEX_GET_SUPPORTED_CLASSES_PARAMS params,
    DWORD dwClass
)
{
    NvU32 i=0;
    while (i < params.numClasses) {
        if (params.classBuffer[i] == dwClass) {
            return (TRUE);
        }
        i++;
    }
    return (FALSE);
}

//
// nvDeterminePerformanceStrategy
//
// detects HW and use this info together with the CPU info to figure out the best
//  performance strategy. pDriverData->dwDeviceIDNum must be initialized
//
// Note: This was copied and modified from a routine of similar name in nvProf.
//       That routine is highly non-portable.
EXTERN_C BOOL __stdcall nvDeterminePerformanceStrategy_NT4(GLOBALDATA *pDriverData, NV_SystemInfo_t *pSysInfo)
{
    DWORD dwRoot, dwDevID;
    BOOL  bOverride = FALSE;
    DWORD dwWidth;
    DWORD dwNVCLK;
    DWORD dwMCLK;
    DWORD dwGPUMemory;
    DWORD dwCpuClock;
    DWORD dwCpuType;
    DWORD dwFullspeedFW;
    DWORD dwFastWrite;
    DWORD dwBusCaps;
    DWORD dwStrapCaps;
    DWORD dwBase;
    DWORD dwBusType;
    DWORD dwPCIID;
    HANDLE hDriver;
    NV_CFGEX_GET_SUPPORTED_CLASSES_PARAMS params;
    DWORD dwSuccess;
    DWORD dwPSOr;
    DWORD dwPSAnd;
    DWORD dwPBSize;
    DWORD dwSBSize;
    DWORD dwCaps;
    DWORD res;
    union
    {
            ULONG osName;
            char devName[NV_DEVICE_NAME_LENGTH_MAX+1];
    } nameBuffer;

    pSysInfo->dwNVClasses      = 0;
    pSysInfo->dwCPUFeatureSet  = 0;
    pSysInfo->dwProcessorSpeed = 0;

    hDriver = (HANDLE) pDriverData->ppdev->hDriver;

    //
    // determine amount of memory present
    //
    // roughly the number of MB of system memory on the machine

//    pSysInfo->dwSystemMemory = (DWORD)((pDriverData->ppdev->SysMemInfo.SystemMemorySize) >> 20);
    // No way to query true amount of system memory on NT4 from disp driver (yet anyway) @mjl@
    pSysInfo->dwSystemMemory = 16;

    // round to the ceiling 8 MB
    pSysInfo->dwSystemMemory = (pSysInfo->dwSystemMemory + 7) & ~7;

    /*
     * determine installed HW
     *
     * at this point ddraw has not been initialized yet so this code is
     *  opening a RM channel for itself to do the detection and then
     *  close it.
     */

    /*
    * Under WINNT, must id the correct device in a  multimon
    * system.
    */

    nameBuffer.osName = pDriverData->ppdev->ulDeviceReference;

    dwDevID = 0xDEAD0001;

    NvOpen(hDriver);

    res = NvAllocRoot(hDriver,NV01_ROOT,&dwRoot);
    if (res != NVOS01_STATUS_SUCCESS) return FALSE;

    res = NvAllocDevice(hDriver, dwRoot, dwDevID, NV01_DEVICE_0, (BYTE*)nameBuffer.devName);
    if (res != NVOS06_STATUS_SUCCESS) return FALSE;

    // get general HW info
    NvConfigGet(hDriver, dwRoot, dwDevID, NV_CFG_DAC_INPUT_WIDTH,   &dwWidth);
    NvConfigGet(hDriver, dwRoot, dwDevID, NV_CFG_DAC_GRAPHICS_CLOCK,&dwNVCLK);
    NvConfigGet(hDriver, dwRoot, dwDevID, NV_CFG_DAC_MEMORY_CLOCK,  &dwMCLK);
    NvConfigGet(hDriver, dwRoot, dwDevID, NV_CFG_RAM_SIZE_MB,       &dwGPUMemory);
    NvConfigGet(hDriver, dwRoot, dwDevID, NV_CFG_PROCESSOR_SPEED,   &dwCpuClock);
    NvConfigGet(hDriver, dwRoot, dwDevID, NV_CFG_PROCESSOR_TYPE,    &dwCpuType);
    NvConfigGet(hDriver, dwRoot, dwDevID, NV_CFG_ADDRESS_NVADDR,    &dwBase);
    NvConfigGet(hDriver, dwRoot, dwDevID, NV_CFG_AGP_FULLSPEED_FW,  &dwFullspeedFW);
    NvConfigGet(hDriver, dwRoot, dwDevID, NV_CFG_AGP_FW_ENABLE,     &dwFastWrite);
    NvConfigGet(hDriver, dwRoot, dwDevID, NV_CFG_BUS_TYPE,          &dwBusType);
    NvConfigGet(hDriver, dwRoot, dwDevID, NV_CFG_PCI_ID,            &dwPCIID);

    // get the list of classes this HW supports

    params.numClasses  = 0;
    params.classBuffer = NULL;

    // call to get the number of supported classes
    dwSuccess = NvConfigGetEx (hDriver, dwRoot, dwDevID, NV_CFGEX_GET_SUPPORTED_CLASSES, &params, sizeof(params));
    nvAssert (dwSuccess == NVOS_CGE_STATUS_SUCCESS);

    // allocate and call again to actually get the class list itself
    params.classBuffer   = (NvU32 *)  EngAllocMem( HEAP_ZERO_MEMORY, params.numClasses * sizeof(NvU32), ALLOC_TAG);

    dwSuccess = NvConfigGetEx (hDriver, dwRoot, dwDevID, NV_CFGEX_GET_SUPPORTED_CLASSES, &params, sizeof(params));
    nvAssert (dwSuccess == NVOS_CGE_STATUS_SUCCESS);

    // parse the class list
    if (nvClassListCheck (params, 0x0055))  pSysInfo->dwNVClasses |= NVCLASS_0055_DX6TRI;
    if (nvClassListCheck (params, 0x0095))  pSysInfo->dwNVClasses |= NVCLASS_0095_DX6TRI;

    if (nvClassListCheck (params, 0x0054))  pSysInfo->dwNVClasses |= NVCLASS_0054_DX5TRI;
    if (nvClassListCheck (params, 0x0094))  pSysInfo->dwNVClasses |= NVCLASS_0094_DX5TRI;

    if (nvClassListCheck (params, 0x0056))  pSysInfo->dwNVClasses |= NVCLASS_0056_CELSIUS;
    if (nvClassListCheck (params, 0x0096))  pSysInfo->dwNVClasses |= NVCLASS_0096_CELSIUS;
    if (nvClassListCheck (params, 0x1196))  pSysInfo->dwNVClasses |= NVCLASS_1196_CELSIUS;

    if (nvClassListCheck (params, 0x0097))  pSysInfo->dwNVClasses |= NVCLASS_0097_KELVIN;

    if (nvClassListCheck (params, 0x0046))  pSysInfo->dwNVClasses |= NVCLASS_0046_DAC;
    if (nvClassListCheck (params, 0x0049))  pSysInfo->dwNVClasses |= NVCLASS_0049_DAC;
    if (nvClassListCheck (params, 0x0067))  pSysInfo->dwNVClasses |= NVCLASS_0067_DAC;
    if (nvClassListCheck (params, 0x007C))  pSysInfo->dwNVClasses |= NVCLASS_007C_DAC;

    if (nvClassListCheck (params, 0x0042))  pSysInfo->dwNVClasses |= NVCLASS_0042_CTXSURF2D;
    if (nvClassListCheck (params, 0x0062))  pSysInfo->dwNVClasses |= NVCLASS_0062_CTXSURF2D;

    if (nvClassListCheck (params, 0x0060))  pSysInfo->dwNVClasses |= NVCLASS_0060_IDXIMAGE;
    if (nvClassListCheck (params, 0x0064))  pSysInfo->dwNVClasses |= NVCLASS_0064_IDXIMAGE;

    if (nvClassListCheck (params, 0x0077))  pSysInfo->dwNVClasses |= NVCLASS_0077_SCALEDIMG;
    if (nvClassListCheck (params, 0x0063))  pSysInfo->dwNVClasses |= NVCLASS_0063_SCALEDIMG;
    if (nvClassListCheck (params, 0x0089))  pSysInfo->dwNVClasses |= NVCLASS_0089_SCALEDIMG;

    if (nvClassListCheck (params, 0x0038))  pSysInfo->dwNVClasses |= NVCLASS_0038_DVDPICT;
    if (nvClassListCheck (params, 0x0088))  pSysInfo->dwNVClasses |= NVCLASS_0088_DVDPICT;

    if (nvClassListCheck (params, 0x007A))  pSysInfo->dwNVClasses |= NVCLASS_007A_OVERLAY;

    if (nvClassListCheck (params, 0x0053))  pSysInfo->dwNVClasses |= NVCLASS_0053_CTXSURF3D;
    if (nvClassListCheck (params, 0x0093))  pSysInfo->dwNVClasses |= NVCLASS_0093_CTXSURF3D;

    if (nvClassListCheck (params, 0x004A))  pSysInfo->dwNVClasses |= NVCLASS_004A_GDIRECT;
    if (nvClassListCheck (params, 0x005E))  pSysInfo->dwNVClasses |= NVCLASS_005E_SOLIDRECT;

    if (nvClassListCheck (params, 0x0052))  pSysInfo->dwNVClasses |= NVCLASS_0052_CTXSURFSWZ;
    if (nvClassListCheck (params, 0x009E))  pSysInfo->dwNVClasses |= NVCLASS_009E_CTXSURFSWZ;

    if (nvClassListCheck (params, 0x0004))  pSysInfo->dwNVClasses |= NVCLASS_0004_TIMER;

    if (nvClassListCheck (params, 0x006C))  pSysInfo->dwNVClasses1 |= NVCLASS1_006C_CHANNELDMA;
    if (nvClassListCheck (params, 0x006E))  pSysInfo->dwNVClasses1 |= NVCLASS1_006E_CHANNELDMA;
    if (nvClassListCheck (params, 0x206E))  pSysInfo->dwNVClasses1 |= NVCLASS1_206E_CHANNELDMA;

    // free the dynamically allocated list
    EngFreeMem(params.classBuffer);

    dwNVCLK = (dwNVCLK + 500000) / 1000000;
    dwMCLK  = (dwMCLK  + 500000) / 1000000;

    // disconnect
    {
        DWORD res;
        res = NvFree (hDriver, dwRoot, NV01_NULL_OBJECT, dwRoot);
        if (res != NVOS00_STATUS_SUCCESS) return FALSE;
    }
    NvClose(hDriver);

    dwStrapCaps = *(DWORD*)(dwBase + NV_PBUS_PCI_NV_18);
    dwBusCaps   = *(DWORD*)(dwBase + NV_PBUS_PCI_NV_19);

    //
    // override
    //
#ifdef FORCE_NV10_AS_NV5
    pSysInfo->dwNVClasses &= ~(NVCLASS_0056_CELSIUS |
                                                NVCLASS_0096_CELSIUS |
                                                NVCLASS_1196_CELSIUS);
#endif

#ifdef SPOOF_KELVIN
    pSysInfo->dwNVClasses |= NVCLASS_0097_KELVIN;
#endif

    //
    // map cpu onto feature flags
    //
    pSysInfo->dwProcessorSpeed = dwCpuClock;
    if (dwCpuType & NV_CPU_FUNC_MMX)     pSysInfo->dwCPUFeatureSet |= FS_MMX;
    if (dwCpuType & NV_CPU_FUNC_SSE)     pSysInfo->dwCPUFeatureSet |= FS_KATMAI;
    if (dwCpuType & NV_CPU_FUNC_SSE2)    pSysInfo->dwCPUFeatureSet |= FS_WILLAMETTE;
    if (dwCpuType & NV_CPU_FUNC_3DNOW)   pSysInfo->dwCPUFeatureSet |= FS_3DNOW;
    if (dwCpuType & NV_CPU_FUNC_SFENCE)  pSysInfo->dwCPUFeatureSet |= FS_SFENCE;
    if ((dwCpuType & 0xff) == NV_CPU_K7) pSysInfo->dwCPUFeatureSet |= FS_ATHLON;

    if ((pSysInfo->dwCPUFeatureSet & FS_KATMAI) ||
        (pSysInfo->dwCPUFeatureSet & FS_WILLAMETTE) ||
        (pSysInfo->dwCPUFeatureSet & FS_ATHLON))
    {
        pSysInfo->dwCPUFeatureSet |= FS_PREFETCH;
    }

    // See if this is a PCI bus interface
    if (dwBusType == 1)
    {
        pSysInfo->dwCPUFeatureSet |= FS_PCIBUS;
    }

    //
    // map misc flags
    //
    // fast writes
    if (dwFastWrite && dwFullspeedFW)   pSysInfo->dwCPUFeatureSet |= FS_FULLFASTWRITE;
    if (dwFastWrite && !dwFullspeedFW)  pSysInfo->dwCPUFeatureSet |= FS_HALFFASTWRITE;
    // detect low back end bus
    if (dwWidth == 64)                  pSysInfo->dwCPUFeatureSet |= FS_64BIT;

    //
    // determine strategy...
    //
    dwPSOr  =  0;
    dwPSAnd = ~0;
    {
        BOOL bFastMachine      = pSysInfo->dwProcessorSpeed >= 390;
        BOOL bRealFastMachine  = pSysInfo->dwProcessorSpeed >= 650; //650
        BOOL bSuperFastBackEnd = dwMCLK >= 300;
        // bFastBackEnd should only be FALSE on VANTA
        BOOL bFastBackEnd      = !(pSysInfo->dwCPUFeatureSet & FS_64BIT)
                               || (dwMCLK > 200);
        BOOL bHalfFastWrites   = pSysInfo->dwCPUFeatureSet & FS_HALFFASTWRITE;
        BOOL bFullFastWrites   = pSysInfo->dwCPUFeatureSet & FS_FULLFASTWRITE;
        BOOL bHasAGP           = dwBusCaps & (1 << (0 ? NV_PBUS_PCI_NV_19_AGP_COMMAND_AGP_ENABLE));

        //
        // slow back end
        //
        if (!bFastBackEnd)
        {
            if (bFastMachine) pSysInfo->dwPerformanceStrategy = PS_CONTROL_TRAFFIC_16 |
                                                                                 PS_CONTROL_TRAFFIC_32 |
                                                                                 PS_TEXTURE_RENAME     |
                                                                                 PS_TEXTURE_PREFER_AGP;
                         else pSysInfo->dwPerformanceStrategy = PS_CONTROL_TRAFFIC_16 |
                                                                                 PS_CONTROL_TRAFFIC_32 |
                                                                                 PS_TEXTURE_USEHW;
        }
#if 0 // (NVARCH >= 0x020)
        else if (pSysInfo->dwNVClasses & NVCLASS_FAMILY_KELVIN)
        {
            // put stuff here
        }
#endif
        else if (pSysInfo->dwNVClasses & NVCLASS_FAMILY_CELSIUS)
        {
            // decide who does what
            pSysInfo->dwPerformanceStrategy = PS_TEXTURE_RENAME | PS_TEXTURE_USEHW;
            // decide where to put stuff
            switch ((bFullFastWrites   ? 4 : 0)
                  | (bHalfFastWrites   ? 2 : 0)
                  | (bSuperFastBackEnd ? 1 : 0))
            {
                case 0: // !FW, !SF   - bx, SDR
                        pSysInfo->dwPerformanceStrategy &= ~PS_PUSH_VID;
                        pSysInfo->dwPerformanceStrategy |=  PS_VB_PREFER_AGP;
                        break;
                case 1: // !FW,  SF   - bx, DDR
                        pSysInfo->dwPerformanceStrategy &= ~PS_PUSH_VID;
                        pSysInfo->dwPerformanceStrategy |=  PS_VB_PREFER_AGP;
                        break;
                case 2: //  1/2 FW, !SF   - camino, SDR
                        pSysInfo->dwPerformanceStrategy &= ~PS_PUSH_VID;
                        pSysInfo->dwPerformanceStrategy |=  PS_VB_PREFER_AGP;
                        break;
                case 3: //  1/2 FW,  SF   - camino, DDR
                        pSysInfo->dwPerformanceStrategy &= ~PS_PUSH_VID;
                        pSysInfo->dwPerformanceStrategy |=  PS_VB_PREFER_AGP;
                        break;
                case 6: //  FW, !SF   - camino, SDR
                        pSysInfo->dwPerformanceStrategy &= ~PS_PUSH_VID;
                        pSysInfo->dwPerformanceStrategy |=  PS_VB_PREFER_AGP;
                        break;
                case 7: //  FW,  SF   - camino, DDR (we have not experimentd with this one yet - be conservative)
                        pSysInfo->dwPerformanceStrategy &= ~PS_PUSH_VID;
                        pSysInfo->dwPerformanceStrategy |=  PS_VB_PREFER_AGP;
                        break;
            }

            if (pSysInfo->dwCPUFeatureSet & FS_PCIBUS)
            {
                // PCI bus interface -- don't prefer AGP!
                pSysInfo->dwPerformanceStrategy &=  ~PS_VB_PREFER_AGP;
            }

            // should we use auto-palettes?
            if (pSysInfo->dwNVClasses & NVCLASS_FAMILY_CELSIUS)
            {
                pSysInfo->dwPerformanceStrategy |= PS_AUTOPALETTE;
            }

            //camino (i.e. FW's) do 32 bit perf strategy.
            if ((pSysInfo->dwNVClasses & NVCLASS_1196_CELSIUS)
             || (pSysInfo->dwNVClasses & NVCLASS_0096_CELSIUS)) {
                pSysInfo->dwPerformanceStrategy |= PS_CONTROL_TRAFFIC_32;
                pSysInfo->dwPerformanceStrategy |= PS_CONTROL_TRAFFIC_16;
            }

            if (pSysInfo->dwNVClasses & NVCLASS_FAMILY_KELVIN)
            {
                // No CT for Kelvin
                pSysInfo->dwPerformanceStrategy &= ~(PS_CONTROL_TRAFFIC_16 | PS_CONTROL_TRAFFIC_32);
            }

            // should we do super triangles?
#ifdef SUPERTRI
           if (bRealFastMachine
              && ((pSysInfo->dwCPUFeatureSet & FS_KATMAI)
                    || (pSysInfo->dwCPUFeatureSet & FS_WILLAMETTE)
                    || (pSysInfo->dwCPUFeatureSet & FS_ATHLON)))
            {
                pSysInfo->dwPerformanceStrategy |= (PS_SUPERTRI | PS_ST_XFORMCLIP | PS_ST_MODEL);

                // TODO: Add transformation and clip code for Athlon
                if (pSysInfo->dwCPUFeatureSet & FS_ATHLON)
                    pSysInfo->dwPerformanceStrategy &= ~PS_ST_XFORMCLIP;
            }
#endif
        }
        // ben BUGBUG
        // this is ugly. we infer nv4 vs. nv5 based on the DAC object. philosophically, this is illegal.
        else if (pSysInfo->dwNVClasses & NVCLASS_0049_DAC)
        {
            if (bFastMachine) pSysInfo->dwPerformanceStrategy = PS_CONTROL_TRAFFIC_32 | PS_TEXTURE_RENAME;
                         else pSysInfo->dwPerformanceStrategy = PS_CONTROL_TRAFFIC_32 | PS_TEXTURE_USEHW;
        }
        else
        {
            if (bFastMachine) pSysInfo->dwPerformanceStrategy = PS_CONTROL_TRAFFIC_16 |
                                                                                 PS_CONTROL_TRAFFIC_32 |
                                                                                 PS_TEXTURE_RENAME     |
                                                                                 PS_TEXTURE_PREFER_AGP;
                         else pSysInfo->dwPerformanceStrategy = PS_CONTROL_TRAFFIC_16 |
                                                                                 PS_CONTROL_TRAFFIC_32 |
                                                                                 PS_TEXTURE_USEHW;
        }

#ifdef FORCE_CT
#if FORCE_CT
    pSysInfo->dwPerformanceStrategy |= PS_CONTROL_TRAFFIC_32;
    pSysInfo->dwPerformanceStrategy |= PS_CONTROL_TRAFFIC_16;
#else
    pSysInfo->dwPerformanceStrategy &= ~PS_CONTROL_TRAFFIC_32;
    pSysInfo->dwPerformanceStrategy &= ~PS_CONTROL_TRAFFIC_16;
#endif
#endif 

    }

/*
    pSysInfo->dwPerformanceStrategy = (1 ? PS_TEXTURE_RENAME     : 0)
                                 | (0 ? PS_TEXTURE_USEHW      : 0)
                                 | (1 ? PS_TEXTURE_PREFER_AGP : 0)
                                 | (1 ? PS_CONTROL_TRAFFIC_16 : 0)
                                 | (1 ? PS_CONTROL_TRAFFIC_32 : 0);
//*/

#define SIZE_VIDMEM_PUSH_BUFFER         (1.0f /  32.0f)     // of total vid mem
#define SIZE_VIDMEM_STAGE_BUFFER        (2.0f /  32.0f)     // of total vid mem

#define SIZE_SYSMEM_PUSH_BUFFER         (2.0f / 128.0f)     // of total sys mem (buffer lives in PCI or AGP)
#define SIZE_SYSMEM_STAGE_BUFFER        (4.0f / 128.0f)     // of total sys mem (buffer lives in PCI or AGP)


    if (pSysInfo->dwPerformanceStrategy & PS_PUSH_VID) // buffers in video memory
    {
        dwPBSize = (DWORD)(1024.0f * 1024.0f * dwGPUMemory * SIZE_VIDMEM_PUSH_BUFFER);
        dwSBSize = (DWORD)(1024.0f * 1024.0f * dwGPUMemory * SIZE_VIDMEM_STAGE_BUFFER);
    }
    else // buffers in AGP or PCI memory
    {
        // base AGP buffer sizes on aperture or memory size, depending on their relative sizes
        DWORD dwMem = pSysInfo->dwSystemMemory;
        dwPBSize = (DWORD)(1024.0f * 1024.0f * dwMem * SIZE_SYSMEM_PUSH_BUFFER);
    }

    dwPBSize = max(dwPBSize, 128 * 1024); // must be at least 128K

    dwPBSize = (dwPBSize + 4095) & ~4095; // 4K align

    // limit maximum size of push buffer
    dwPBSize = min(dwPBSize, 8 * 1024 * 1024); // 8MB max

    pSysInfo->dwRecommendedPushBufferSize  = dwPBSize;

#define PRINT
#if defined(DEBUG) || defined(PRINT)
    {
        static BOOL bPrintedThisBefore = FALSE;

        if (!bPrintedThisBefore)
        {
            char szString[128];

            PF (" NV: classes=%08x %d/%d RAM=%dMB bus=%d", pSysInfo->dwNVClasses,dwNVCLK,dwMCLK,dwGPUMemory,dwWidth);
            PF ("CPU: FS=%08x %dMHz", pSysInfo->dwCPUFeatureSet, pSysInfo->dwProcessorSpeed);

            {
                BOOL  bAGP   = dwBusCaps & (1 << (0 ? NV_PBUS_PCI_NV_19_AGP_COMMAND_AGP_ENABLE));
                DWORD dwRate = dwBusCaps ? (dwBusCaps & 7) : 0;
                BOOL  bSBA   = dwBusCaps & (1 << (0 ? NV_PBUS_PCI_NV_19_AGP_COMMAND_SBA_ENABLE));
                BOOL  bFW    = dwBusCaps & (1 << (0 ? NV_PBUS_PCI_NV_19_AGP_COMMAND_FW_ENABLE));

                PF (" BC: AGP=%dx, SBA=%d, HFW=%d, SSFW=%d, SFFW=%d",
                     bAGP ? dwRate : 0,
                     bSBA ? 1 : 0,
                     bFW ? 1 : 0,
                     (pSysInfo->dwCPUFeatureSet & FS_HALFFASTWRITE) ? 1 : 0,
                     (pSysInfo->dwCPUFeatureSet & FS_FULLFASTWRITE) ? 1 : 0);
            }
            {
                DWORD dwRate = dwStrapCaps ? (dwStrapCaps & 7) : 0;
                BOOL  bSBA   = dwStrapCaps & (1 << (0 ? NV_PBUS_PCI_NV_18_AGP_STATUS_SBA));
                BOOL  bFW    = dwStrapCaps & (1 << (0 ? NV_PBUS_PCI_NV_18_AGP_STATUS_FW));

                PF (" SC: AGP=%s%s%s%s, SBA=%d, FW=%d",
                     (dwRate & 4) ? "4" : "",
                     (dwRate & 2) ? "2" : "",
                     (dwRate & 1) ? "1" : "",
                     (dwRate & 7) ? "x" : "n/a",
                     bSBA ? 1 : 0,
                     bFW ? 1 : 0);
            }

            PF (" PS: %08x", pSysInfo->dwPerformanceStrategy);

            nvStrCpy (szString, "     ");
            if (pSysInfo->dwPerformanceStrategy & PS_TEXTURE_RENAME)     nvStrCat (szString, "texRn ");
            if (pSysInfo->dwPerformanceStrategy & PS_TEXTURE_USEHW)      nvStrCat (szString, "texHW ");
            if (pSysInfo->dwPerformanceStrategy & PS_TEXTURE_PREFER_AGP) nvStrCat (szString, "texAGP ");
            if (pSysInfo->dwPerformanceStrategy & PS_CONTROL_TRAFFIC_16) nvStrCat (szString, "ct16 ");
            if (pSysInfo->dwPerformanceStrategy & PS_CONTROL_TRAFFIC_32) nvStrCat (szString, "ct32 ");
            if (pSysInfo->dwPerformanceStrategy & PS_VB_RENAME)          nvStrCat (szString, "vbRn ");
            if (pSysInfo->dwPerformanceStrategy & PS_VB_PREFER_AGP)      nvStrCat (szString, "vbAGP ");
            if (pSysInfo->dwPerformanceStrategy & PS_PUSH_VID)           nvStrCat (szString, "pushVID ");
            if (pSysInfo->dwPerformanceStrategy & PS_SUPERTRI)           nvStrCat (szString, "supTri ");
            PF (szString);

            if (bOverride) {
                PF ("     * PS set from registry");
            }

            bPrintedThisBefore = TRUE;
        }
    }
#endif

    // calibrate delay loop
   //    assume cpuid capable
    __asm
    {
        push    eax
        push    ebx
        push    ecx
        push    edx
        mov eax,1

        _emit 0x0f //    __asm cpuid - not known to compiler used for NT4 build
        _emit 0xa2 

        mov [dwCaps],edx
        pop     edx
        pop     ecx
        pop     ebx
        pop     eax
    }
    if (dwCaps & 0x10) // rdtsc capable
    {
        __int64 qwStart;
        __int64 qwStop;

        nvSpin(10000);
        nvSpin(10000);

        __asm
        {
            push    eax
            push    edx

            _emit 0x0f //    __asm rdtsc - not known to compiler used for NT4 build
            _emit 0x31 

            mov DWORD PTR [qwStart + 0],eax
            mov DWORD PTR [qwStart + 4],edx

            pop     edx
            pop     eax
        }
        nvSpin(10000);
        __asm
        {
            push    eax
            push    edx

            _emit 0x0f //    __asm rdtsc - not known to compiler used for NT4 build
            _emit 0x31 

            mov DWORD PTR [qwStop + 0],eax
            mov DWORD PTR [qwStop + 4],edx

            pop     edx
            pop     eax

            // 3DMark 2000 leaves the floating point stack full of garbage
            // which causes the 3rd FILD below to fail resulting in a global.dwDelayCount of 0 and
            // ultimately causing the driver to hang
            // (perhaps they use MMX instructions)
            // clearing the MMX state here solves the problem
        }

        // this used to cause a fault on non-MMX machines.  Have to check for MMX before using
        // EMMS
        if (pSysInfo->dwCPUFeatureSet & FS_MMX)
        {
            __asm emms
        }

        // set delay to 10us
        double time = (double)(qwStop - qwStart) / 10000.0;
        time /= (double) pSysInfo->dwProcessorSpeed;
        pSysInfo->dwSpinLoopCount = (unsigned long) (10.0 / time);
    }
    else
    {
        // for non tsc machines we just assign a hard value for the delay loop
        pSysInfo->dwSpinLoopCount = pSysInfo->dwProcessorSpeed * 4;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\ddraw\nv4\init.cpp ===
//******************************************************************************
//
// Copyright (c) 1995-1996 Microsoft Corporation
//
// Module Name:
//
//     NV4INIT.C
//
// Abstract:
//
//     Initialize DX driver callbacks for NV4.
//
// Environment:
//
//     kernel mode only
//
// Notes:
//
// Revision History:
//
//
//******************************************************************************

#include "nvprecomp.h"
#include "nvalpha.h"
#include "ddminint.h"
#include "nv32.h"

#include "nvos.h"
#include "nvntioctl.h"
#include "nvntddctl.h"
#include "nvapi.h"
#include "nvsubch.h"

#include "nvVPP.h"

///////////////////////////////////////////////////////////////////////////
// Local Function Declarations
///////////////////////////////////////////////////////////////////////////
static NvU8 destroyExtendedDDPatch( PDEV *ppdev );
static NvU8 createExtendedDDPatch( PDEV *ppdev );

#define NvGetFreeCount(NN, CH)\
                 (NN)->subchannel[CH].control.Free

extern void NV4_DdPioSync(PDEV*);

VOID NvDDEnable(PDEV *ppdev)
{
    ppdev->ddCallBacks.WaitForVerticalBlank = DdWaitForVerticalBlank;
    ppdev->ddCallBacks.MapMemory            = DdMapMemory;
    ppdev->ddCallBacks.GetScanLine          = GetScanLine32;
    ppdev->ddCallBacks.dwFlags              = DDHAL_CB32_WAITFORVERTICALBLANK
                                    | DDHAL_CB32_MAPMEMORY
                                    | DDHAL_CB32_GETSCANLINE;

    ppdev->ddSurfaceCallBacks.Blt           = Nv4Blt;
    ppdev->ddSurfaceCallBacks.Flip          = Nv4Flip;
    ppdev->ddSurfaceCallBacks.Lock          = Nv4Lock;
    ppdev->ddSurfaceCallBacks.Unlock        = Nv4Unlock;
    ppdev->ddSurfaceCallBacks.GetBltStatus  = Nv4GetBltStatus;
    ppdev->ddSurfaceCallBacks.GetFlipStatus = DdGetFlipStatus;
    ppdev->ddSurfaceCallBacks.DestroySurface= Nv4DestroySurface;
    ppdev->ddSurfaceCallBacks.dwFlags       = DDHAL_SURFCB32_BLT
                                       | DDHAL_SURFCB32_FLIP
                                       | DDHAL_SURFCB32_UNLOCK
                                       | DDHAL_SURFCB32_LOCK
                                       | DDHAL_SURFCB32_GETBLTSTATUS
                                       | DDHAL_SURFCB32_GETFLIPSTATUS
                                       | DDHAL_SURFCB32_DESTROYSURFACE;

    ppdev->ddCallBacks.CreateSurface             = DdCreateSurface;
    ppdev->ddCallBacks.CanCreateSurface          = DdCanCreateSurface;
    ppdev->ddCallBacks.dwFlags                   |= DDHAL_CB32_CREATESURFACE
                                             | DDHAL_CB32_CANCREATESURFACE;

    ppdev->ddSurfaceCallBacks.SetColorKey        = DdSetColorKey;
    ppdev->ddSurfaceCallBacks.UpdateOverlay      = Nv4UpdateOverlay;
    ppdev->ddSurfaceCallBacks.SetOverlayPosition = Nv4SetOverlayPosition;
    ppdev->ddSurfaceCallBacks.dwFlags           |= DDHAL_SURFCB32_SETCOLORKEY
                                            | DDHAL_SURFCB32_UPDATEOVERLAY
                                            | DDHAL_SURFCB32_SETOVERLAYPOSITION;

    ppdev->pfnUpdateFlipStatus = Nv4UpdateFlipStatus;
}

//
// create the best NV_DD_VIDEO_LUT_CURSOR_DAC object we can
//
static NvU8 createLutCursorDacObj(PPDEV ppdev,NV_SystemInfo_t *pSysInfo)
{
	NvU32 retval;
    NV07C_ALLOCATION_PARAMETERS nv07cAllocParms;

    if (pSysInfo->dwNVClasses & NVCLASS_007C_DAC)
	{
        for (nv07cAllocParms.logicalHeadId=0; 
		     nv07cAllocParms.logicalHeadId < ppdev->pDriverData->dwHeads; 
			 nv07cAllocParms.logicalHeadId++)
		{
			retval = NvAlloc(
				ppdev->hDriver,ppdev->hClient,
				NV_VPP_CHANNEL_IID,
				NV_VPP_LUT_CURSOR_DAC_IID + nv07cAllocParms.logicalHeadId,
				NV15_VIDEO_LUT_CURSOR_DAC,
				&nv07cAllocParms);
            if (retval != NVOS21_STATUS_SUCCESS)
			{
				dbgError("alloc of class 7c should have succeeded, but did not!");
                return FALSE;
            }
        }
    }
    else if (pSysInfo->dwNVClasses & NVCLASS_0067_DAC)
	{
		retval = NvAllocObject(
			ppdev->hDriver,ppdev->hClient,
			NV_VPP_CHANNEL_IID,
			NV_VPP_LUT_CURSOR_DAC_IID,
			NV10_VIDEO_LUT_CURSOR_DAC);
        if (retval != NVOS21_STATUS_SUCCESS)
		{
			dbgError("alloc of class 67 should have succeeded, but did not!");
            return FALSE;
        }
    }
    else if (pSysInfo->dwNVClasses & NVCLASS_0049_DAC)
	{
		retval = NvAllocObject(
			ppdev->hDriver,ppdev->hClient,
			NV_VPP_CHANNEL_IID,
			NV_VPP_LUT_CURSOR_DAC_IID,
			NV05_VIDEO_LUT_CURSOR_DAC);
        if (retval != NVOS21_STATUS_SUCCESS)
		{
			dbgError("alloc of class 49 should have succeeded, but did not!");
            return FALSE;
        }
    }
    else if (pSysInfo->dwNVClasses & NVCLASS_0046_DAC)
	{
		retval = NvAllocObject(
			ppdev->hDriver,ppdev->hClient,
			NV_VPP_CHANNEL_IID,
			NV_VPP_LUT_CURSOR_DAC_IID,
			NV04_VIDEO_LUT_CURSOR_DAC);
        if (retval != NVOS21_STATUS_SUCCESS)
		{
			dbgError("alloc of class 46 should have succeeded, but did not!");
            return FALSE;
        }
    }
    else
	{
        dbgError("hardware doesn't seem to support any flavor of the VIDEO_LUT_CURSOR_DAC class!");
        return FALSE;
    }

#if 0
	    for (DWORD dwHead = 0; dwHead < pDriverData->dwHeads; dwHead ++) {
        // initialize LUT-cursor-DAC object
        nvPushData (0,dDrawSubchannelOffset(NV_DD_ROP) | 0x40000);
        nvPushData (1,NV_DD_VIDEO_LUT_CURSOR_DAC + dwHead);
        nvPushData (2,dDrawSubchannelOffset(NV_DD_ROP) + NV067_SET_CONTEXT_DMA_NOTIFIES | 0x1C0000);
        nvPushData (3,NV_DD_DMA_FLIP_PRIMARY_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
        nvPushData (4,NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);  // image a
        nvPushData (5,NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);  // image b
        nvPushData (6,NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);  // LUT a
        nvPushData (7,NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);  // LUT b
        nvPushData (8,NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);  // cursor a
        nvPushData (9,NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);  // cursor b
        nvPushData (10,dDrawSubchannelOffset(NV_DD_ROP) + NV067_SET_DAC(0) | 0x40000);
        nvPushData (11,asmMergeCoords(GET_MODE_WIDTH(), GET_MODE_HEIGHT()));
        nvPusherAdjust (12);
    }

#endif

	return TRUE;
}

//
// Try to create a 3D object (okay if we do not get one though)
//
static NvU8 create3Dobject(PPDEV ppdev, NV_SystemInfo_t *pSysInfo)
{
	NvU32 retval;
	NvU8 bHave3DClass = FALSE;

    if (pSysInfo->dwNVClasses & NVCLASS_0097_KELVIN)
    {
        retval = NvAllocObject(ppdev->hDriver,ppdev->hClient,NV_VPP_CHANNEL_IID,NV_VPP_3D_OBJECT_IID,NV20_KELVIN_PRIMITIVE);
        if (retval != NVOS05_STATUS_SUCCESS)
        {
            dbgError("Failed to get expected class: 0x0097 kelvin");
        }
        else
        {
            bHave3DClass = TRUE;
            DPF_LEVEL(NVDBG_LEVEL_INFO, "VPP using NV20 Kelvin class");
        }
    }
    else if (pSysInfo->dwNVClasses & NVCLASS_1196_CELSIUS)
    {
        retval = NvAllocObject(ppdev->hDriver,ppdev->hClient,NV_VPP_CHANNEL_IID,NV_VPP_3D_OBJECT_IID, NV11_CELSIUS_PRIMITIVE);
        if (retval != NVOS05_STATUS_SUCCESS)
        {
            dbgError("Failed to get expected class: 1196 CELSIUS");
        }
        else
        {
            bHave3DClass = TRUE;
            DPF_LEVEL(NVDBG_LEVEL_INFO, "VPP using NV11 Celsius class");
        }
    }
    else if (pSysInfo->dwNVClasses & NVCLASS_0096_CELSIUS)
    {
        retval = NvAllocObject(ppdev->hDriver,ppdev->hClient,NV_VPP_CHANNEL_IID, NV_VPP_3D_OBJECT_IID, NV15_CELSIUS_PRIMITIVE);
        if (retval != NVOS05_STATUS_SUCCESS)
        {
            dbgError("Failed to get expected class: 0096 CELSIUS");
        }
        else
        {
            bHave3DClass = TRUE;
            DPF_LEVEL(NVDBG_LEVEL_INFO, "VPP using NV15 Celsius class");
        }
    }
    else if (pSysInfo->dwNVClasses & NVCLASS_0056_CELSIUS)
    {
        retval = NvAllocObject(ppdev->hDriver,ppdev->hClient,NV_VPP_CHANNEL_IID, NV_VPP_3D_OBJECT_IID, NV10_CELSIUS_PRIMITIVE);
        if (retval != NVOS05_STATUS_SUCCESS)
        {
            dbgError("Failed to get expected class: 0056 CELSIUS");
        }
        else
        {
            bHave3DClass = TRUE;
            DPF_LEVEL(NVDBG_LEVEL_INFO, "VPP using NV10 Celsius class");
        }
    }
    else
    {
        bHave3DClass = FALSE;
        DPF_LEVEL(NVDBG_LEVEL_INFO, "No 3D super class is available.  Vpp proceeding without one.");
    }
	return bHave3DClass;
}

//**************************************************************************
// Allocate a DMA context which points to all of video memory. The limit
// must be page aligned: i.e. limit = (size in bytes of video mem rounded to the
// closest page boundary) - 1.
//
// TBD: not sure if we can share these.  They do appear to be channel independant.
//
//**************************************************************************
static NvU8 createContextDmas(PPDEV ppdev)
{
	NvU32 retval;

    retval = NvAllocContextDma(ppdev->hDriver,ppdev->hClient,
                        NV_VPP_DMA_WITHIN_VMEM_IID,
                        NV01_CONTEXT_DMA,
                        DRF_DEF(OS03, _FLAGS, _ACCESS, _READ_WRITE) |
                        DRF_DEF(OS03, _FLAGS, _COHERENCY, _UNCACHED),
                        (PVOID) VIDMEM_ADDR(ppdev->pDriverData->BaseAddress),
                        ppdev->pDriverData->TotalVRAM - 1);
    if (retval != NVOS01_STATUS_SUCCESS)
    {
        dbgError("DMA Context <within vmem>: allocation failed");
		return FALSE;
    }

    retval = NvAllocContextDma(ppdev->hDriver,ppdev->hClient,
                        NV_VPP_DMA_FROM_VMEM_IID,
                        NV01_CONTEXT_DMA,
                        DRF_DEF(OS03, _FLAGS, _ACCESS, _READ_ONLY) |
                        DRF_DEF(OS03, _FLAGS, _COHERENCY, _UNCACHED),
                        (PVOID) VIDMEM_ADDR(ppdev->pDriverData->BaseAddress),
                        ppdev->pDriverData->TotalVRAM - 1);
    if (retval != NVOS01_STATUS_SUCCESS)
    {
        dbgError("DMA Context <from vmem>: allocation failed");
		return FALSE;
    }

    retval = NvAllocContextDma(ppdev->hDriver,ppdev->hClient,
                        NV_VPP_DMA_TO_VMEM_IID,
                        NV01_CONTEXT_DMA,
                        DRF_DEF(OS03, _FLAGS, _ACCESS, _WRITE_ONLY) |
                        DRF_DEF(OS03, _FLAGS, _COHERENCY, _UNCACHED),
                        (PVOID) VIDMEM_ADDR(ppdev->pDriverData->BaseAddress),
                        ppdev->pDriverData->TotalVRAM - 1);
    if (retval != NVOS01_STATUS_SUCCESS)
    {
        dbgError("DMA Context <to vmem>: allocation failed");
		return FALSE;
    }

	// Alloc 3 notifier slots for the OVERLAY notifier
    retval = NvAllocContextDma(ppdev->hDriver,ppdev->hClient,
                        NV_VPP_OVERLAY_NOTIFIER_IID,
                        NV01_CONTEXT_DMA,
                        DRF_DEF(OS03, _FLAGS, _ACCESS, _WRITE_ONLY),
                        ppdev->pDriverData->pCommonNotifierBuffer,
                        3*sizeof(NvNotification) - 1);
    if (retval != NVOS01_STATUS_SUCCESS)
    {
        dbgError("DMA Context for overlay notifier: allocation failed");
		return FALSE;
    }

	return TRUE;
}
static NvU8 allocateCommonNotifierBuffer( PPDEV ppdev )
{
    NvU32   commonBufferSize;

    dbgTracePush("allocateCommonNotifierBuffer");

    commonBufferSize = 0
		+ 3*sizeof(NvNotification)	// for NV_VPP_OVERLAY_NOTIFIER_IID & NV_VPP_OVERLAY_IID
		- 1;

    // Allocate memory for a bunch of notifiers and the scanline buffer.
    // We must allocate the memory for this structure out of SHARED or
    // SYSTEM space -- not out of App space so don't use GlobalAlloc.

	nvAssert(ppdev->pDriverData->pCommonNotifierBuffer == NULL);

    ppdev->pDriverData->pCommonNotifierBuffer = (NvV32 *)EngAllocMem(FL_ZERO_MEMORY, commonBufferSize, ALLOC_TAG);
    if (ppdev->pDriverData->pCommonNotifierBuffer == NULL)
	{
        return FALSE;
    }
	return TRUE;
}

static NvU8 createExtendedDDPatch( PDEV *ppdev )
{
    NvU32 retval;
    NvU8  bHave3DSuperClass;
    CPushBuffer &nvPusher = ppdev->pDriverData->nvPusher;

    dbgTracePush("createExtendedDDPatch");

    nvAssert(ppdev);
    nvAssert(ppdev->pDriverData);

    // Set by VPP code, but otherwise ignored on NT4
    ppdev->pDriverData->dDrawSpareSubchannelObject = 0;
    ppdev->pDriverData->ddClipUpdate               = 0;
    ppdev->pDriverData->TwoDRenderingOccurred      = 0;
    ppdev->pDriverData->blitCalled                 = FALSE;
    ppdev->pDriverData->dwDXVAFlags                = 0;  // Not really used (though VPP sets them)
    ppdev->pDriverData->dwSharedClipChangeCount    = 0;
    ppdev->pDriverData->lpProcessInfoHead          = NULL;

    // allocate a push buffer
    nvPusher.setPdev(ppdev);
    if (!nvPusher.allocate(NV_VPP_CHANNEL_IID))
    {
        dbgError("VPP: failed to allocate push buffer");
		goto fail_extended_patch;
    }
    ppdev->vppChannelNdx = 2; // TBD: compute this as in nvEnable line 1570 @mjl@

	bHave3DSuperClass = create3Dobject(ppdev,&ppdev->pDriverData->sysInfo);

	if (!(    allocateCommonNotifierBuffer(ppdev)
		   && createLutCursorDacObj(ppdev,&ppdev->pDriverData->sysInfo)
	       && createContextDmas(ppdev)
	   ))
	{
		goto fail_extended_patch;
	}

    ppdev->pDriverData->dwMostRecent3dUser = MODULE_ID_NONE;

    if (bHave3DSuperClass)
    {
        nvPusher.setObject(NV_VPP_3D_OBJECT_SUBCH, NV_VPP_3D_OBJECT_IID);
    }
    // Now set DMA context
//    nvPusher.setObject(NV_VPP_3D_OBJECT_SUBCH, NV_VPP_3D_OBJECT_IID);
//    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        // some bare bones initialization: put the thing in its channel and set up for notifers
//        nvglSetObject (NV_DD_KELVIN, D3D_KELVIN_PRIMITIVE);
//        nvglSetNv20KelvinNotifierContextDMA (NV_DD_KELVIN, NV_DD_DMA_PUSHER_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
//    }

    if (0 && !VppEnable(
        &ppdev->pDriverData->vpp,
        ppdev,
        &ppdev->pDriverData->nvPusher,
        NV_VPP_CHANNEL_IID,
        NV_VPP_3D_OBJECT_IID,
        NV_VPP_3D_OBJECT_SUBCH,         // permanent subchannel assignment for 3d object
        &(ppdev->pDriverData->dwMostRecent3dUser),
        NV_VPP_DMA_WITHIN_VMEM_IID,     // In VideoMem DMA (all of VM)
        NV_VPP_DMA_FROM_VMEM_IID,      // From VideoMem DMA (all of VM)
        NV_VPP_DMA_TO_VMEM_IID,        // To VideoMem DMA (all of VM)
        NV_VPP_LUT_CURSOR_DAC_IID ,

        0, /* misceventnotifier (dma) -- used to be: NV_DD_DMA_COLOUR_CONTROL_EVENT_NOTIFIER */
        0, /* contextSurfaceSwizzled -- was: D3D_CONTEXT_SURFACE_SWIZZLED */
        0, //   NV_DD_CONTEXT_BETA4,
        0, //   NV_DD_SURFACES_2D,
        0, // subchannel for SURFACES_2D object
        0, // hVideoMemUtoVideoMemFormat,    // U-conversion object
        0, // hVideoMemVtoVideoMemFormat,    // V-conversion object
        0, // hVideoMemUVtoVideoMemFormat,    // UV-conversion object

        0, // NV_DD_DVD_SUBPICTURE hDvdSubpicture,
        0, // NV_DD_CONTEXT_PATTERN
        0, // NV_CONTEXT_ROP
        0, //  NV_DD_CONTEXT_COLOR_KEY,
        0, //hFloatingContextDmaInOverlayShadow NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_OVERLAY_SHADOW

        0, //(NvNotification  *)pDriverData->DMA version !pFlipPrimaryNotifier,  May be an equivalent to this - @mjl@
        0, //(NvNotification  *)pDriverData->NvDmaPusherSyncNotifierFlat,  May be an equivalent to this - @mjl@
        0, //(NvNotification  *)pDriverData->NvPioColourControlEventNotifierFlat,

        0, // D3D_CONTEXT_SURFACES_ARGB_ZS,
        0, // D3D_DX6_MULTI_TEXTURE_TRIANGLE,
        0, // NV_DD_IMAGE_BLACK_RECTANGLE -- IID

        0, // NV_DD_ROP_RECT_AND_TEXT subchannel
        0, // NV_DD_ROP subchannel
        0 /* spare sub channel */
        ))
    {
        goto fail_extended_patch;
    }

    dbgTracePop();      // Success!
    return TRUE;

fail_extended_patch:    // Failure!  

    dbgTracePop();
    destroyExtendedDDPatch(ppdev);  // Destroy any objects we may have created
    return FALSE;
}

// TBD: release all objects allocated in createExtendedDDPatch @mjl@
static NvU8 destroyExtendedDDPatch( PDEV *ppdev )
{
    NvU32 retval;
    CPushBuffer &pushBuffer = ppdev->pDriverData->nvPusher;

    // flush the push buffer before we start destroying stuff
    if (pushBuffer.isValid())
    {
        pushBuffer.flush(TRUE, CPushBuffer::FLUSH_HEAVY_POLLING);
    }

    // We may or may not have any one or more of these... so it's okay if freeing it fails
	//   (eg: if we fail part way though initial alloc)
    retval = NvFree(ppdev->hDriver,ppdev->hClient,NV_VPP_CHANNEL_IID, NV_VPP_3D_OBJECT_IID);
    retval = NvFree(ppdev->hDriver,ppdev->hClient,NV_VPP_CHANNEL_IID, NV_VPP_LUT_CURSOR_DAC_IID);
    retval = NvFree(ppdev->hDriver,ppdev->hClient,ppdev->hDevice, NV_VPP_DMA_WITHIN_VMEM_IID);
    retval = NvFree(ppdev->hDriver,ppdev->hClient,ppdev->hDevice, NV_VPP_DMA_FROM_VMEM_IID);
    retval = NvFree(ppdev->hDriver,ppdev->hClient,ppdev->hDevice, NV_VPP_DMA_TO_VMEM_IID);

    if (ppdev->pDriverData->pCommonNotifierBuffer) EngFreeMem(ppdev->pDriverData->pCommonNotifierBuffer);
    ppdev->pDriverData->pCommonNotifierBuffer = NULL;

    retval = NvFree(ppdev->hDriver,ppdev->hClient,ppdev->hDevice, NV_VPP_OVERLAY_NOTIFIER_IID);

    if (pushBuffer.isValid())
    {
        pushBuffer.free();
        pushBuffer.setPdev(NULL);
    }

    return TRUE;
}

NvU8 bCreateNVDDPatch(PDEV    *ppdev)
{
    V032    videoFmt, color0, color1;
    LONG   i;
    Nv3ChannelPio   *nv;
    NvNotification *pSyncNotifier = (NvNotification *)ppdev->Notifiers->Sync;
    ULONG   ulScaledImageClass;
    NV07A_ALLOCATION_PARAMETERS nv07aAllocParms;
    PVOID parms;
    ULONG ulHead;
    NV_CREATE_OBJECT_SETUP();

    if(!NvGetSupportedClasses(ppdev))
	{
        return FALSE;
    }

    //**********************************************************************************
    // Open a new channel for ddraw.
    //**********************************************************************************
    ppdev->hDdChannel = ppdev->hPioChannel = NV_DD_DDRAW_PIO_CHANNEL_OBJECT_HANDLE;
    if (NvAllocChannelPio(  ppdev->hDriver,
                            ppdev->hClient,
                            ppdev->hDevice,
                            ppdev->hDdChannel,
                            NV03_CHANNEL_PIO,
                            0,
                            (PVOID *) &(ppdev->ddChannelPtr),
                            0
                            ) != NVOS04_STATUS_SUCCESS)
        {
        DPF("NVDD: Cannot get NV Ddraw PIO channel");
        NvFree(ppdev->hDriver, ppdev->hClient, NV01_NULL_OBJECT, ppdev->hClient);
        NvClose(ppdev->hDriver);
        return FALSE;
        }

    //********************************************************************************
    // Ensure the 2d channel ptr is valid. We need to do this even if 2d is running in
    // DMA PUSH mode, since our waitenginebusy fcts reference the 2d channel ptr.
    //********************************************************************************
    if (ppdev->pjMmBase == NULL)
        {
        ppdev->pjMmBase = ppdev->ddChannelPtr;
        }
    nv = (Nv3ChannelPio *) ppdev->ddChannelPtr;

    //**************************************************************************
    // Allocate a DMA context which points to all of video memory. The limit
    // must be page aligned: i.e. limit = (size in bytes of video mem rounded to the
    // closest page boundary) - 1.
    //**************************************************************************

    if (NvAllocContextDma(  ppdev->hDriver,
                        ppdev->hClient,
                        NV_DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM,
                        NV01_CONTEXT_DMA,
                        NVOS03_FLAGS_ACCESS_READ_WRITE,
                        (PVOID)(ppdev->pjFrameBufbase),
                        ppdev->cbFrameBuf - 1
                        ) != NVOS03_STATUS_SUCCESS )
    {
    DPF("NVDD: Cannot allocate dma in memory context");
    return FALSE;
    }

    if (NvAllocContextDma(  ppdev->hDriver,
                            ppdev->hClient,
                            NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY,
                            NV01_CONTEXT_DMA,
                            NVOS03_FLAGS_ACCESS_WRITE_ONLY,
                            (PVOID)(ppdev->Notifiers->DmaToMem),
                            5 * sizeof(NvNotification)
                            ) != NVOS03_STATUS_SUCCESS)
        {
        DPF("NVDD: Cannot allocate notifier context");
        return FALSE;
        }

    if (NvAllocContextDma(  ppdev->hDriver,
                            ppdev->hClient,
                            DD_FIFO_SYNC_NOTIFIER,
                            NV01_CONTEXT_DMA,
                            NVOS03_FLAGS_ACCESS_WRITE_ONLY,
                            (PVOID)(ppdev->Notifiers->Sync),
                            5 * sizeof(NvNotification)
                            ) != NVOS03_STATUS_SUCCESS)
        {
        DPF("NVDD: Cannot allocate notifier context");
        return FALSE;
        }

    //**************************************************************************
    // Determine black and white colors
    //**************************************************************************

    switch (ppdev->iBitmapFormat)
    {
        case BMF_32BPP:
            color0 =    NV_ALPHA_1_32 | 0x00000000;         // BLACK
            color1 =    NV_ALPHA_1_32 | 0x00ffffff;         // WHITE
            videoFmt = NV_VFM_FORMAT_COLOR_LE_X8R8G8B8;
            break;
        case BMF_16BPP:

            if (ppdev->flGreen == 0x03e0)
                {
                //**************************************************************
                // 5:5:5 format
                //**************************************************************
                videoFmt = NV_VFM_FORMAT_COLOR_LE_X1R5G5B5_P2;
                color0 =    NV_ALPHA_1_16 | 0x00000000;     // BLACK
                color1 =    NV_ALPHA_1_16 | 0x00007fff;     // WHITE
                }
            else
                {

                //**************************************************************
                // 5:6:5 format
                //**************************************************************

                color0 =   (NV_ALPHA_1_565 | 0x00000000);       // BLACK
                color1 =   (NV_ALPHA_1_565 | 0x0000ffff);       // WHITE
                videoFmt = NV_VFM_FORMAT_COLOR_LE_R5G6B5_P2;
                }

            break;
        case BMF_8BPP:
            color0 =    NV_ALPHA_1_08 | 0x00000000;         // BLACK
            color1 =    NV_ALPHA_1_08 | 0x000000ff;         // WHITE
            videoFmt = NV_VFM_FORMAT_COLOR_LE_Y8_P4;

            //*************************************************************************
            // Setup palette for indexed color mode.
            // allocate the colormap context (from system memory)
            //*************************************************************************
            if (NvAllocContextDma(  ppdev->hDriver,
                        ppdev->hClient,
                        NV_DD_WIN_COLORMAP_CONTEXT,
                        NV01_CONTEXT_DMA,
                        NVOS03_FLAGS_ACCESS_READ_ONLY,
                        (PVOID)(ppdev->ajClutData),
                        (256 * sizeof(VIDEO_CLUTDATA)) - 1
                        ) != NVOS03_STATUS_SUCCESS)
                {
                DPF("NVDD: Cannot allocate buffer context");
                return FALSE;
                }
            break;
        default:
            return(FALSE);
    }

    //*************************************************************************
    // allocate the dma notifier context for flip surface
    //*************************************************************************
    if (NvAllocContextDma(  ppdev->hDriver,
                            ppdev->hClient,
                            NV_DD_FLIP_PRIMARY_NOTIFIER_CONTEXT_DMA_TO_MEMORY,
                            NV01_CONTEXT_DMA,
                            NVOS03_FLAGS_ACCESS_WRITE_ONLY,
                            (PVOID)(ppdev->Notifiers->FlipPrimary),
                            9 * sizeof(NvNotification)
                            ) != NVOS03_STATUS_SUCCESS)
        {
        DPF("NVDD: Cannot allocate context dma notifier for flip surface");
        return FALSE;
        }
    ((NvNotification *) (&(ppdev->Notifiers->FlipPrimary[NV046_NOTIFIERS_SET_IMAGE(0)*sizeof(NvNotification)])))->status = 0;


    //*************************************************************************
    // allocate the dma notifier context for video overlay flip
    //*************************************************************************
    if (NvAllocContextDma(  ppdev->hDriver,
                        ppdev->hClient,
                        NV_DD_FLIP_OVERLAY_NOTIFIER_CONTEXT_DMA_TO_MEMORY,
                        NV01_CONTEXT_DMA,
                        NVOS03_FLAGS_ACCESS_WRITE_ONLY,
                        (PVOID)(ppdev->Notifiers->FlipOverlay),
                        5 * sizeof(NvNotification)
                        ) != NVOS03_STATUS_SUCCESS)
        {
        DPF("NVDD: Cannot allocate notifier context");
        return FALSE;
        }
    ((NvNotification *) (ppdev->Notifiers->FlipOverlay))->status = 0;


    //***********************************************************************************
    // Allocate a buffer for scanlines.
    //***********************************************************************************
    if ((ppdev->NvDmaBufferFlat = EngAllocMem(0, 0x8000, ALLOC_TAG)) != NULL)
        {
        ppdev->NvScanlineBufferFlat = ppdev->NvDmaBufferFlat;
        if (NvAllocContextDma(  ppdev->hDriver,
                        ppdev->hClient,
                        NV_DD_CONTEXT_DMA_FROM_SYSTEM_MEMORY,
                        NV01_CONTEXT_DMA,
                        NVOS03_FLAGS_ACCESS_READ_WRITE,
                        ppdev->NvDmaBufferFlat,
                        0x8000 - 1
                        ) != NVOS03_STATUS_SUCCESS)
            return(FALSE);
        }


    //******************************************************************************************
    // Create the NV Objects. The video back end objects are identical to NV3.
    //******************************************************************************************
    NV_CREATE_OBJECT_INIT();
    NV_CREATE_OBJECT_PIO2(NV10_CONTEXT_SURFACES_2D, NV04_CONTEXT_SURFACES_2D,
                          NV_DD_PRIMARY_SURFACE);
    if (NV_CREATE_OBJECT_FAIL()) {
        return FALSE;
    } else {
        if (NV_CREATE_OBJECT_CLASS() == NV10_CONTEXT_SURFACES_2D) {
            ulScaledImageClass = NV10_SCALED_IMAGE_FROM_MEMORY;
        } else {
            ulScaledImageClass = NV04_SCALED_IMAGE_FROM_MEMORY;
        }
    }
    
    NV_CREATE_OBJECT_INIT();
    NV_CREATE_OBJECT_PIO1(ulScaledImageClass, NV_DD_FLOATING0_SCALED_Y420_IMAGE_FROM_SYSTEM_MEMORY);
    NV_CREATE_OBJECT_PIO1(ulScaledImageClass, NV_DD_FLOATING1_SCALED_Y420_IMAGE_FROM_SYSTEM_MEMORY);
    NV_CREATE_OBJECT_PIO1(NV3_CONTEXT_ROP, NV_DD_ROP5_SOLID);
    NV_CREATE_OBJECT_PIO1(NV1_IMAGE_BLACK_RECTANGLE, NV_DD_IMAGE_BLACK_RECTANGLE);
    NV_CREATE_OBJECT_PIO1(NV4_CONTEXT_PATTERN, NV_DD_IMAGE_PATTERN);
    NV_CREATE_OBJECT_PIO1(NV4_CONTEXT_COLOR_KEY, NV_DD_IMAGE_SOLID);
    NV_CREATE_OBJECT_PIO1(NV4_IMAGE_FROM_CPU, NV_DD_IMAGE_FROM_CPU);
    NV_CREATE_OBJECT_PIO1(NV4_IMAGE_BLIT, NV_DD_IMAGE_BLIT);
    NV_CREATE_OBJECT_PIO1(NV4_GDI_RECTANGLE_TEXT, NV_DD_RENDER_RECT_AND_TEXT);
    // video overlay class
    {
        NV_CREATE_OBJECT_SETUP();
        ulHead = ppdev->ulDeviceDisplay[0];
        if (ulHead > 0) {
            nv07aAllocParms.logicalHeadId = ulHead;
            parms = &nv07aAllocParms;
        } else {
            parms = NULL;
        }

        NV_CREATE_OBJECT_INIT();

        NV_CREATE_OBJECT_PARM_PIO2(parms,  NV_DD_VIDEO_OVERLAY, 
                   NV10_VIDEO_OVERLAY, NV04_VIDEO_OVERLAY);

        if (NV_CREATE_OBJECT_FAIL()) {
            return FALSE;
        } else {
            ppdev->CurrentClass.VideoOverlay = NV_CREATE_OBJECT_CLASS();
        }
    }
    
    // if 8bpp, create colormap
    NV_CREATE_OBJECT_INIT();
    if (ppdev->iBitmapFormat == BMF_8BPP) {
        NV_CREATE_OBJECT_PIO1(NV_VIDEO_COLORMAP, NV_DD_SHARED_VIDEO_COLORMAP);
        NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_VIDEO, NV_DD_P_V_SHARED_VIDEO_COLORMAP);
    }

    NV_CREATE_OBJECT_PIO1(NV3_MEMORY_TO_MEMORY_FORMAT, NV_DD_VIDEO_MEM_TO_SYSTEM_MEM_FORMAT);
    NV_CREATE_OBJECT_PIO1(NV3_MEMORY_TO_MEMORY_FORMAT, NV_DD_VIDEO_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT);
    NV_CREATE_OBJECT_PIO1(NV4_STRETCHED_IMAGE_FROM_CPU, NV_DD_STRETCHED_UV_IMAGE_FROM_CPU);
    NV_CREATE_OBJECT_PIO1(NV4_STRETCHED_IMAGE_FROM_CPU, NV_DD_STRETCHED_IMAGE_FROM_CPU);
    if (NV_CREATE_OBJECT_FAIL()) {
        return FALSE;
    }    

    //*******************************************************************************
    // Create video overlay objects.
    //*******************************************************************************
    if (ppdev->cBitsPerPel > 8) {
        NV_CREATE_OBJECT_INIT();
        NV_CREATE_OBJECT_PIO1(ulScaledImageClass, NV_DD_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY);
        NV_CREATE_OBJECT_PIO1(ulScaledImageClass, NV_DD_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY);
        NV_CREATE_OBJECT_PIO1(ulScaledImageClass, NV_DD_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY);
        NV_CREATE_OBJECT_PIO1(ulScaledImageClass, NV_DD_SCALED_UYVY_IMAGE_FROM_VIDEO_MEMORY);
        NV_CREATE_OBJECT_PIO1(ulScaledImageClass, NV_DD_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY);
        NV_CREATE_OBJECT_PIO1(ulScaledImageClass, NV_DD_SCALED_YUYV_IMAGE_FROM_VIDEO_MEMORY);
        NV_CREATE_OBJECT_PIO1(ulScaledImageClass, NV_DD_FLOATING0_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY);
        NV_CREATE_OBJECT_PIO1(ulScaledImageClass, NV_DD_FLOATING1_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY);
        NV_CREATE_OBJECT_PIO1(ulScaledImageClass, NV_DD_FLOATING0_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY);
        NV_CREATE_OBJECT_PIO1(ulScaledImageClass, NV_DD_FLOATING1_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY);
        if (NV_CREATE_OBJECT_FAIL()) {
            return FALSE;
        }    
    }


    {
    ULONG i, ulHead;
    PVOID parms;
    NV07C_ALLOCATION_PARAMETERS nv07cAllocParms;


    	for(i = 0; i < ppdev->ulNumberDacsActive; i++)
	    {
            NV_CREATE_OBJECT_SETUP();

            ulHead = ppdev->ulDeviceDisplay[i];

            if (ulHead > 0) {
                nv07cAllocParms.logicalHeadId = ulHead;
                parms = &nv07cAllocParms;
            } else {
                parms = NULL;
            }
            // NV5 will use NV04_VIDEO_LUT_CURSOR_DAC class because the method offset of NV05_VIDEO_LUT_CURSOR_DAC 
            // is different from other NV??_VIDEO_LUT_CURSOR_DAC classes.
            NV_CREATE_OBJECT_INIT();

            NV_CREATE_OBJECT_PARM_PIO3(parms,NV_DD_VIDEO_LUT_CURSOR_DAC+ulHead, 
                       NV15_VIDEO_LUT_CURSOR_DAC,NV10_VIDEO_LUT_CURSOR_DAC,
                       NV04_VIDEO_LUT_CURSOR_DAC);
            if (NV_CREATE_OBJECT_FAIL()) 
            {
                return (FALSE);
            } 
            else 
            {
                while (NvGetFreeCount(nv, 0) < 3*4);
            
                nv->subchannel[NV_DD_PRIMARY].SetObject = NV_DD_VIDEO_LUT_CURSOR_DAC+ulHead;
                nv->subchannel[NV_DD_PRIMARY].Nv04VideoLutCursorDac.SetContextDmaImage[0] = NV_DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM;
                nv->subchannel[NV_DD_PRIMARY].Nv04VideoLutCursorDac.SetContextDmaNotifies = NV_DD_FLIP_PRIMARY_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
                
            }
        }
    }

    while (NvGetFreeCount(nv, 0) < 8*4);
    nv->subchannel[NV_DD_PRIMARY].SetObject       = NV_DD_PRIMARY_SURFACE;
    nv->subchannel[NV_DD_PRIMARY].nv4ContextSurfaces2D.SetContextDmaNotifies = NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
    nv->subchannel[NV_DD_PRIMARY].nv4ContextSurfaces2D.SetContextDmaImageSource    = NV_DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM;
    nv->subchannel[NV_DD_PRIMARY].nv4ContextSurfaces2D.SetContextDmaImageDestin    = NV_DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM;

    // Determine the color format
    switch (ppdev->iBitmapFormat)
        {
        case BMF_32BPP:
            nv->subchannel[NV_DD_PRIMARY].nv4ContextSurfaces2D.SetColorFormat = NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8;
            break;
        case BMF_16BPP:
            nv->subchannel[NV_DD_PRIMARY].nv4ContextSurfaces2D.SetColorFormat =
                NV042_SET_COLOR_FORMAT_LE_R5G6B5;
            break;
        case BMF_8BPP:
            nv->subchannel[NV_DD_PRIMARY].nv4ContextSurfaces2D.SetColorFormat = NV042_SET_COLOR_FORMAT_LE_Y8;
            break;
        default:
            return(FALSE);
        }

    nv->subchannel[NV_DD_PRIMARY].nv4ContextSurfaces2D.SetPitch  =
        ppdev->lDelta << 16 | (ppdev->lDelta);
    nv->subchannel[NV_DD_PRIMARY].nv4ContextSurfaces2D.SetOffsetSource =  ppdev->ulPrimarySurfaceOffset;
    nv->subchannel[NV_DD_PRIMARY].nv4ContextSurfaces2D.SetOffsetDestin =  ppdev->ulPrimarySurfaceOffset;

    //**********************************************************************
    // Make sure to reset pitches and offsets across modesets!
    //**********************************************************************

    ppdev->DdCurrentSourceOffset = ppdev->DdCurrentDestOffset = ppdev->ulPrimarySurfaceOffset;
    ppdev->DdCurrentSourcePitch  = ppdev->DdCurrentDestPitch = ppdev->lDelta;

    //**************************************************************************
    // Setup ROP5 SOLID
    //**************************************************************************


    while (NvGetFreeCount(nv, 0) < 3*4);
    nv->subchannel[NV_DD_ROP].SetObject      = NV_DD_ROP5_SOLID;
    nv->subchannel[NV_DD_ROP].nv3ContextRop.SetContextDmaNotifies = NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
    nv->subchannel[NV_DD_ROP].nv3ContextRop.SetRop5 = 0xcccc;

    //**************************************************************************
    // Setup clip rectangle
    //**************************************************************************

    while (NvGetFreeCount(nv, 0) < 4*4);
    nv->subchannel[NV_DD_CLIP].SetObject       = NV_DD_IMAGE_BLACK_RECTANGLE;
    nv->subchannel[NV_DD_CLIP].nv1ImageBlackRectangle.SetContextDmaNotifies = DD_FIFO_SYNC_NOTIFIER;
    nv->subchannel[NV_DD_CLIP].nv1ImageBlackRectangle.SetPoint = 0;
    nv->subchannel[NV_DD_CLIP].nv1ImageBlackRectangle.SetSize  = ((0x7fff<<16) | 0x7fff);
    ppdev->DdClipResetFlag = 0;

    //**********************************************************************
    // Setup CONTEXT PATTERN
    //**********************************************************************

    while (NvGetFreeCount(nv, 0) < 10*4);
    nv->subchannel[NV_DD_PATTERN].SetObject      = NV_DD_IMAGE_PATTERN;
    nv->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetContextDmaNotifies = NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;

    // Determine the color format
    switch (ppdev->iBitmapFormat)
        {
        case BMF_32BPP:
            nv->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetColorFormat = NV044_SET_COLOR_FORMAT_LE_A8R8G8B8;
            break;
        case BMF_16BPP:
            nv->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetColorFormat = NV044_SET_COLOR_FORMAT_LE_A16R5G6B5;
            break;
        case BMF_8BPP:
            // Must be set to a legal value but hardware ignores it otherwise
            nv->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetColorFormat = NV044_SET_COLOR_FORMAT_LE_A8R8G8B8;
            break;
        default:
            return(FALSE);
        }

    nv->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetMonochromeFormat   = NV044_SET_MONOCHROME_FORMAT_CGA6_M1;
    nv->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetMonochromeShape    = NV044_SET_MONOCHROME_SHAPE_64X_1Y ;
    nv->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetPatternSelect      = NV044_SET_PATTERN_SELECT_MONOCHROME;
    nv->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetMonochromeColor0   = color0;
    nv->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetMonochromeColor1   = color1;
    nv->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetMonochromePattern0 = 0xffffffff;
    nv->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetMonochromePattern1 = 0x50505050;

    //**********************************************************************
    // Y8 default pattern values
    //**********************************************************************

    while (NvGetFreeCount(nv, 0) < 16*4);
    for (i=0;i<16;i++)
        nv->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetPatternY8[i] = 0xffffffff;

    //**********************************************************************
    // R5G6B5 default pattern values
    //**********************************************************************

    while (NvGetFreeCount(nv, 0) < 16*4);
    for (i=0;i<16;i++)
        nv->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetPatternR5G6B5[i] = 0xffffffff;

    while (NvGetFreeCount(nv, 0) < 16*4);
    for (i=16;i<32;i++)
        nv->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetPatternR5G6B5[i] = 0xffffffff;

    //**********************************************************************
    // X1R5G5B5 default pattern values
    //**********************************************************************

    while (NvGetFreeCount(nv, 0) < 16*4);
    for (i=0;i<16;i++)
        nv->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetPatternX1R5G5B5[i] = 0xffffffff;

    while (NvGetFreeCount(nv, 0) < 16*4);
    for (i=16;i<32;i++)
        nv->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetPatternX1R5G5B5[i] = 0xffffffff;

    //**********************************************************************
    // X8R8G8B8 default pattern values
    //**********************************************************************

    while (NvGetFreeCount(nv, 0) < 16*4);
    for (i=0;i<16;i++)
        nv->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetPatternX8R8G8B8[i] = 0xffffffff;

    while (NvGetFreeCount(nv, 0) < 16*4);
    for (i=16;i<32;i++)
        nv->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetPatternX8R8G8B8[i] = 0xffffffff;

    while (NvGetFreeCount(nv, 0) < 16*4);
    for (i=32;i<48;i++)
        nv->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetPatternX8R8G8B8[i] = 0xffffffff;

    while (NvGetFreeCount(nv, 0) < 16*4);
    for (i=48;i<64;i++)
        nv->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetPatternX8R8G8B8[i] = 0xffffffff;

    //**********************************************************************
    // Setup IMAGE SOLID (CONTEXT COLOR KEY for NV4)
    //**********************************************************************

    while (NvGetFreeCount(nv, 0) < 4*4);
    nv->subchannel[NV_DD_SPARE].SetObject = NV_DD_IMAGE_SOLID;
    nv->subchannel[NV_DD_SPARE].nv4ContextColorKey.SetContextDmaNotifies = NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;

    // Determine the color format
    switch (ppdev->iBitmapFormat)
        {
        case BMF_32BPP:
            nv->subchannel[NV_DD_SPARE].nv4ContextColorKey.SetColorFormat = NV057_SET_COLOR_FORMAT_LE_A8R8G8B8;
            break;
        case BMF_16BPP:
            nv->subchannel[NV_DD_SPARE].nv4ContextColorKey.SetColorFormat = NV057_SET_COLOR_FORMAT_LE_A16R5G6B5;
            break;
        case BMF_8BPP:
            // Does hardware ignore this value???
            nv->subchannel[NV_DD_SPARE].nv4ContextColorKey.SetColorFormat = NV057_SET_COLOR_FORMAT_LE_A8R8G8B8;
            break;
        default:
            return(FALSE);
        }

    nv->subchannel[NV_DD_SPARE].nv4ContextColorKey.SetColor = 0L; // Disabled

    //**********************************************************************
    // Setup Image From CPU (565 format)
    //
    // NOTE:  We CAN NOT use the COLOR_KEY (IMAGE_SOLID)
    //        if ROP_OPERATION = ROP_AND
    //**********************************************************************

    while (NvGetFreeCount(nv, 0) < 8*4);
    nv->subchannel[NV_DD_SPARE].SetObject         = NV_DD_IMAGE_FROM_CPU;
    nv->subchannel[NV_DD_SPARE].nv4ImageFromCpu.SetContextDmaNotifies = NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
    nv->subchannel[NV_DD_SPARE].nv4ImageFromCpu.SetContextClipRectangle = NV_DD_IMAGE_BLACK_RECTANGLE;
    nv->subchannel[NV_DD_SPARE].nv4ImageFromCpu.SetContextPattern     = NV_DD_IMAGE_PATTERN;
    nv->subchannel[NV_DD_SPARE].nv4ImageFromCpu.SetContextRop         = NV_DD_ROP5_SOLID;
    nv->subchannel[NV_DD_SPARE].nv4ImageFromCpu.SetContextSurface     = NV_DD_PRIMARY_SURFACE;
    nv->subchannel[NV_DD_SPARE].nv4ImageFromCpu.SetOperation          = NV061_SET_OPERATION_ROP_AND;

    // Determine the color format
    switch (ppdev->iBitmapFormat)
        {
        case BMF_32BPP:
            nv->subchannel[NV_DD_SPARE].nv4ImageFromCpu.SetColorFormat = NV061_SET_COLOR_FORMAT_LE_X8R8G8B8;
            break;
        case BMF_16BPP:
            nv->subchannel[NV_DD_SPARE].nv4ImageFromCpu.SetColorFormat = NV061_SET_COLOR_FORMAT_LE_R5G6B5;
            break;
        case BMF_8BPP:
            // Does hardware ignore this value???
            nv->subchannel[NV_DD_SPARE].nv4ImageFromCpu.SetColorFormat = NV061_SET_COLOR_FORMAT_LE_X8R8G8B8;
            break;
        default:
            return(FALSE);
        }

    //**************************************************************************
    // Setup Image Blit
    //**************************************************************************

    while (NvGetFreeCount(nv, 0) < 8*4);
    nv->subchannel[NV_DD_BLIT].SetObject                               = NV_DD_IMAGE_BLIT;
    nv->subchannel[NV_DD_BLIT].nv4ImageBlit.SetContextDmaNotifies      = NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
    nv->subchannel[NV_DD_BLIT].nv4ImageBlit.SetContextClipRectangle    = NV_DD_IMAGE_BLACK_RECTANGLE;
    nv->subchannel[NV_DD_BLIT].nv4ImageBlit.SetContextPattern          = NV_DD_IMAGE_PATTERN;
    nv->subchannel[NV_DD_BLIT].nv4ImageBlit.SetContextRop              = NV_DD_ROP5_SOLID;
    nv->subchannel[NV_DD_BLIT].nv4ImageBlit.SetContextSurfaces         = NV_DD_PRIMARY_SURFACE;
    nv->subchannel[NV_DD_BLIT].nv4ImageBlit.SetOperation               = NV05F_SET_OPERATION_ROP_AND;
    nv->subchannel[NV_DD_BLIT].nv4ImageBlit.SetContextColorKey         = NV_DD_IMAGE_SOLID;

    //**********************************************************************
    // Setup RECT and TEXT  (565 format)
    //**********************************************************************

    while (NvGetFreeCount(nv, 0) < 8*4);
    nv->subchannel[NV_DD_RECT_AND_TEXT].SetObject      = NV_DD_RENDER_RECT_AND_TEXT;
    nv->subchannel[NV_DD_RECT_AND_TEXT].nv4GdiRectangleText.SetContextDmaNotifies = NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
    nv->subchannel[NV_DD_RECT_AND_TEXT].nv4GdiRectangleText.SetContextPattern = NV_DD_IMAGE_PATTERN;
    nv->subchannel[NV_DD_RECT_AND_TEXT].nv4GdiRectangleText.SetContextRop     = NV_DD_ROP5_SOLID;
    nv->subchannel[NV_DD_RECT_AND_TEXT].nv4GdiRectangleText.SetContextSurface = NV_DD_PRIMARY_SURFACE;
    nv->subchannel[NV_DD_RECT_AND_TEXT].nv4GdiRectangleText.SetOperation      = NV04A_SET_OPERATION_ROP_AND;

    // Determine the color format
    switch (ppdev->iBitmapFormat)
        {
        case BMF_32BPP:
            nv->subchannel[NV_DD_RECT_AND_TEXT].nv4GdiRectangleText.SetColorFormat = NV04A_SET_COLOR_FORMAT_LE_X8R8G8B8;
            break;
        case BMF_16BPP:
            nv->subchannel[NV_DD_RECT_AND_TEXT].nv4GdiRectangleText.SetColorFormat = NV04A_SET_COLOR_FORMAT_LE_X16R5G6B5;
            break;
        case BMF_8BPP:
            // Does hardware ignore this value???
            nv->subchannel[NV_DD_RECT_AND_TEXT].nv4GdiRectangleText.SetColorFormat = NV04A_SET_COLOR_FORMAT_LE_X8R8G8B8;
            break;
        default:
            return(FALSE);
        }

    nv->subchannel[NV_DD_RECT_AND_TEXT].nv4GdiRectangleText.SetMonochromeFormat = NV04A_SET_MONOCHROME_FORMAT_CGA6_M1;

    // if 8bpp, create colormap
    if (ppdev->iBitmapFormat == BMF_8BPP)
        {
        while (NvGetFreeCount(nv, 0) < 9*4);
        nv->subchannel[NV_DD_SPARE].SetObject = NV_DD_SHARED_VIDEO_COLORMAP;
        nv->subchannel[NV_DD_SPARE].NvVideoColormap.SetVideoOutput =
            NV_DD_P_V_SHARED_VIDEO_COLORMAP;
        nv->subchannel[NV_DD_SPARE].NvVideoColormap.SetVideoInput =
            DD_PATCHCORD_VIDEO;
        nv->subchannel[NV_DD_SPARE].NvVideoColormap.SetContextDmaNotifies =
            NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
        nv->subchannel[NV_DD_SPARE].NvVideoColormap.SetContextDmaColormap =
            NV_DD_WIN_COLORMAP_CONTEXT;
        nv->subchannel[NV_DD_SPARE].NvVideoColormap.SetColormapStart = 0;
        nv->subchannel[NV_DD_SPARE].NvVideoColormap.Notify = 0;
        nv->subchannel[NV_DD_SPARE].NvVideoColormap.SetColormapLength =
            256 * sizeof(VIDEO_CLUTDATA);

        }

    //************************************************************************
    // Create the video memory to system memory format object.
    //************************************************************************

    while (NvGetFreeCount(nv, 0) < 4*4);
    nv->subchannel[NV_DD_SPARE].SetObject = NV_DD_VIDEO_MEM_TO_SYSTEM_MEM_FORMAT;
    nv->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.SetContextDmaNotifies =
        NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
    nv->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.SetContextDmaBufferIn =
        NV_DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM;
    nv->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.SetContextDmaBufferOut =
        NV_DD_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

    //**************************************************************************
    // create memory to memory format object used to reformat overlay surfaces
    //**************************************************************************

    while (NvGetFreeCount(nv, 0) < 4*4);
    nv->subchannel[NV_DD_SPARE].SetObject =
       NV_DD_VIDEO_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT;
    nv->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.SetContextDmaNotifies =
       NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
    nv->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.SetContextDmaBufferIn =
       NV_DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM;
    nv->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.SetContextDmaBufferOut =
       NV_DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM;

    // video overlay class
    while (NvGetFreeCount(nv, NV_DD_SPARE) < 4*4);

    nv->subchannel[NV_DD_SPARE].SetObject = NV_DD_VIDEO_OVERLAY;
    nv->subchannel[NV_DD_SPARE].Nv04VideoOverlay.SetContextDmaNotifies =
        NV_DD_FLIP_OVERLAY_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
    nv->subchannel[NV_DD_SPARE].Nv04VideoOverlay.SetContextDmaOverlay[0] =
        NV_DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM;
    nv->subchannel[NV_DD_SPARE].Nv04VideoOverlay.SetContextDmaOverlay[1] =
        NV_DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM;

    if (ppdev->cBitsPerPel > 8)
        {
        //*****************************************************************************
        // Hook up scaled image from mem objects.
        //*****************************************************************************
        while (NvGetFreeCount(nv, 0) < 5*4);

        nv->subchannel[NV_DD_SPARE].SetObject =
            NV_DD_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetContextDmaNotifies =
            NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetContextSurface =
            NV_DD_PRIMARY_SURFACE;
        if (ppdev->cBitsPerPel == 16)
            nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetColorFormat =
                NV077_SET_COLOR_FORMAT_LE_R5G6B5;
        else
            nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetColorFormat =
                NV077_SET_COLOR_FORMAT_LE_X8R8G8B8;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetContextDmaImage =
            NV_DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM;

        while (NvGetFreeCount(nv, 0) < 5*4);

        nv->subchannel[NV_DD_SPARE].SetObject =
            NV_DD_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetContextDmaNotifies =
            NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetContextSurface =
            NV_DD_PRIMARY_SURFACE;
        if (ppdev->cBitsPerPel == 16)
            nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetColorFormat =
                NV077_SET_COLOR_FORMAT_LE_R5G6B5;
        else
            nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetColorFormat =
                NV077_SET_COLOR_FORMAT_LE_X8R8G8B8;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetContextDmaImage =
            NV_DD_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

        while (NvGetFreeCount(nv, 0) < 5*4);

        nv->subchannel[NV_DD_SPARE].SetObject =
            NV_DD_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetContextDmaNotifies =
            NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;

        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetContextSurface =
            NV_DD_PRIMARY_SURFACE;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetColorFormat =
            NV077_SET_COLOR_FORMAT_LE_YB8V8YA8U8;

        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetContextDmaImage =
            NV_DD_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

        while (NvGetFreeCount(nv, 0) < 5*4);

        nv->subchannel[NV_DD_SPARE].SetObject =
            NV_DD_SCALED_UYVY_IMAGE_FROM_VIDEO_MEMORY;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetContextDmaNotifies =
            NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;

        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetContextSurface =
            NV_DD_PRIMARY_SURFACE;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetColorFormat =
            NV077_SET_COLOR_FORMAT_LE_YB8V8YA8U8;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetContextDmaImage =
            NV_DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM;

        while (NvGetFreeCount(nv, 0) < 5*4);

        nv->subchannel[NV_DD_SPARE].SetObject =
            NV_DD_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetContextDmaNotifies =
            NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;

        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetContextSurface =
            NV_DD_PRIMARY_SURFACE;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetColorFormat =
            NV077_SET_COLOR_FORMAT_LE_YB8V8YA8U8;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetContextDmaImage =
            NV_DD_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

        while (NvGetFreeCount(nv, 0) < 7*4);

        nv->subchannel[NV_DD_SPARE].SetObject =
            NV_DD_SCALED_YUYV_IMAGE_FROM_VIDEO_MEMORY;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetContextDmaNotifies =
            NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;

        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetContextSurface =
            NV_DD_PRIMARY_SURFACE;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetColorFormat =
            NV077_SET_COLOR_FORMAT_LE_YB8V8YA8U8;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetContextDmaImage =
            NV_DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetColorFormat =
            NV077_SET_COLOR_FORMAT_LE_V8YB8U8YA8;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetOperation =
            NV077_SET_OPERATION_SRCCOPY;

        while (NvGetFreeCount(nv, 0) < 5*4);

        nv->subchannel[NV_DD_SPARE].SetObject =
            NV_DD_FLOATING0_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetContextDmaNotifies =
            NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetContextSurface =
            NV_DD_PRIMARY_SURFACE;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetColorFormat =
            NV077_SET_COLOR_FORMAT_LE_YB8V8YA8U8;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetContextDmaImage =
            NV_DD_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

        while (NvGetFreeCount(nv, 0) < 5*4);

        nv->subchannel[NV_DD_SPARE].SetObject =
            NV_DD_FLOATING1_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetContextDmaNotifies =
            NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetContextSurface =
            NV_DD_PRIMARY_SURFACE;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetColorFormat =
            NV077_SET_COLOR_FORMAT_LE_YB8V8YA8U8;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetContextDmaImage =
            NV_DD_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

        while (NvGetFreeCount(nv, 0) < 5*4);

        nv->subchannel[NV_DD_SPARE].SetObject =
            NV_DD_FLOATING0_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetContextDmaNotifies =
            NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetContextSurface =
            NV_DD_PRIMARY_SURFACE;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetColorFormat =
            NV077_SET_COLOR_FORMAT_LE_V8YB8U8YA8;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetContextDmaImage =
            NV_DD_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

        while (NvGetFreeCount(nv, 0) < 5*4);

        nv->subchannel[NV_DD_SPARE].SetObject =
            NV_DD_FLOATING1_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetContextDmaNotifies =
            NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetContextSurface =
            NV_DD_PRIMARY_SURFACE;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetColorFormat =
            NV077_SET_COLOR_FORMAT_LE_V8YB8U8YA8;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetContextDmaImage =
            NV_DD_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
#if 0
    // BUGBUG I don't think YUV420 object is needed. BUGBUG
        while (NvGetFreeCount(nv, 0) < 4*4);

        nv->subchannel[NV_DD_SPARE].SetObject =
            NV_DD_FLOATING0_SCALED_Y420_IMAGE_FROM_SYSTEM_MEMORY;
        nv->subchannel[NV_DD_SPARE].nvScaledYuv420FromMemory.SetNotifyCtxDma =
            NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
        nv->subchannel[NV_DD_SPARE].nvScaledYuv420FromMemory.SetImageOutput =
            NV_DD_P_I_FLOATING0_SCALED_Y420_IMAGE_FROM_SYSTEM_MEMORY;
        nv->subchannel[NV_DD_SPARE].nvScaledYuv420FromMemory.SetImageCtxDma =
            NV_DD_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

        while (NvGetFreeCount(nv, 0) < 4*4);

        nv->subchannel[NV_DD_SPARE].SetObject =
            NV_DD_FLOATING1_SCALED_Y420_IMAGE_FROM_SYSTEM_MEMORY;
        nv->subchannel[NV_DD_SPARE].nvScaledYuv420FromMemory.SetNotifyCtxDma =
            NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
        nv->subchannel[NV_DD_SPARE].nvScaledYuv420FromMemory.SetImageOutput =
            NV_DD_P_I_FLOATING1_SCALED_Y420_IMAGE_FROM_SYSTEM_MEMORY;
        nv->subchannel[NV_DD_SPARE].nvScaledYuv420FromMemory.SetImageCtxDma =
            NV_DD_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
#endif
        }

    while (NvGetFreeCount(nv, 0) < 8*4);
    nv->subchannel[NV_DD_STRETCH].SetObject = NV_DD_STRETCHED_IMAGE_FROM_CPU;
    nv->subchannel[NV_DD_STRETCH].nv4StretchedImageFromCpu.SetContextDmaNotifies = NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
    nv->subchannel[NV_DD_STRETCH].nv4StretchedImageFromCpu.SetContextColorKey = NV_DD_IMAGE_SOLID;
    nv->subchannel[NV_DD_STRETCH].nv4StretchedImageFromCpu.SetContextPattern = NV_DD_IMAGE_PATTERN;
    nv->subchannel[NV_DD_STRETCH].nv4StretchedImageFromCpu.SetContextRop     = NV_DD_ROP5_SOLID;
    nv->subchannel[NV_DD_STRETCH].nv4StretchedImageFromCpu.SetOperation =
        NV076_SET_OPERATION_ROP_AND;
    nv->subchannel[NV_DD_STRETCH].nv4StretchedImageFromCpu.SetContextSurface =
        NV_DD_PRIMARY_SURFACE;

    switch (ppdev->cBitsPerPel)
        {
        case 8:
            /* A8Y8 color format assumed by hardware when destination surface in 8bpp mode */
            /* Must be set to a legal value but hardware ignores it otherwise */
            nv->subchannel[NV_DD_SPARE].nv4StretchedImageFromCpu.SetColorFormat =
               NV076_SET_COLOR_FORMAT_LE_X8R8G8B8;
            break;
        case 16:

            if (ppdev->flGreen == 0x03e0)
                nv->subchannel[NV_DD_STRETCH].nv4StretchedImageFromCpu.SetColorFormat =
                    NV076_SET_COLOR_FORMAT_LE_A1R5G5B5;
            else
                nv->subchannel[NV_DD_STRETCH].nv4StretchedImageFromCpu.SetColorFormat =
                    NV076_SET_COLOR_FORMAT_LE_R5G6B5;       // 5:6:5 format

            break;
        case 32:
            nv->subchannel[NV_DD_STRETCH].nv4StretchedImageFromCpu.SetColorFormat =
                NV076_SET_COLOR_FORMAT_LE_X8R8G8B8;
            break;
        }
    ppdev->dDrawSpareSubchannelObject = 0;

    while (NvGetFreeCount(nv, 0) < 8*4);
    nv->subchannel[NV_DD_STRETCH].SetObject = NV_DD_STRETCHED_UV_IMAGE_FROM_CPU;
    nv->subchannel[NV_DD_STRETCH].nv4StretchedImageFromCpu.SetContextPattern = NV_DD_IMAGE_PATTERN;
    nv->subchannel[NV_DD_STRETCH].nv4StretchedImageFromCpu.SetContextRop     = NV_DD_ROP5_SOLID;
    nv->subchannel[NV_DD_STRETCH].nv4StretchedImageFromCpu.SetOperation =
        NV076_SET_OPERATION_ROP_AND;
    nv->subchannel[NV_DD_STRETCH].nv4StretchedImageFromCpu.SetContextSurface =
        NV_DD_PRIMARY_SURFACE;
    nv->subchannel[NV_DD_STRETCH].nv4StretchedImageFromCpu.SetContextDmaNotifies = NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
    nv->subchannel[NV_DD_STRETCH].nv4StretchedImageFromCpu.SetContextColorKey = NV_DD_IMAGE_SOLID;
    /* A8Y8 color format assumed by hardware when destination surface in 8bpp mode */
    /* Must be set to a legal value but hardware ignores it otherwise */
    nv->subchannel[NV_DD_STRETCH].nv4StretchedImageFromCpu.SetColorFormat =
        NV076_SET_COLOR_FORMAT_LE_X8R8G8B8;

#ifdef MJL_USE_VPP
    if (!createExtendedDDPatch(ppdev))
    {
        return (FALSE);
    }
#endif

    //******************************************************************************************
    // End of video object creation.
    //******************************************************************************************
    ppdev->bDDChannelActive = TRUE;

    pSyncNotifier[NV04A_NOTIFIERS_NOTIFY].status = 0;

    return(TRUE);
}


NvU8 bDestroyNVDDPatch(PDEV    *ppdev)
{
    ULONG status;

    //*********************************************************************************
    // Ensure DD channel processing has completed prior to destroying objects
    // and DMA contexts.
    //*********************************************************************************
    NV4_DdPioSync(ppdev);

    //*********************************************************************************
    // Ensure all processing has completed prior to destroying objects.
    //*********************************************************************************
    ppdev->pfnWaitForChannelSwitch(ppdev);
    ppdev->pfnWaitEngineBusy(ppdev);

    //**********************************************************************************
    // Close ddraw channel.
    //**********************************************************************************
    status = NvFree(ppdev->hDriver,
                ppdev->hClient,
                ppdev->hDevice,
                ppdev->hDdChannel);

    if (status != NVOS00_STATUS_SUCCESS)
        {
        DPF("NVDD: Cannot free NV ddraw PIO channel");
        NvClose(ppdev->hDriver);
        return FALSE;
        }

    //********************************************************************************
    // If the pjMmBase ptr was alloc'd by ddraw, clear it.
    //********************************************************************************
    if (ppdev->pjMmBase == ppdev->ddChannelPtr)
        {
        ppdev->pjMmBase = NULL;
        }

    ppdev->ddChannelPtr = NULL;

    //**************************************************************************
    // Free DMA context which points to all of video memory.
    //**************************************************************************
    if (NvFree(  ppdev->hDriver,ppdev->hClient, ppdev->hDevice, NV_DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM) !=
            NVOS00_STATUS_SUCCESS )
        {
        DPF("NVDD: Cannot free dma in memory context");
        return FALSE;
        }

    //******************************************************************************
    // Free ddraw notifier context
    //******************************************************************************
    if (NvFree(  ppdev->hDriver,
                            ppdev->hClient, ppdev->hDevice, NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY) != NVOS00_STATUS_SUCCESS )
        {
        DPF("NVDD: Cannot free notifier context");
        return FALSE;
        }

    //******************************************************************************
    // Free flip notifier context
    //******************************************************************************
    if (NvFree(  ppdev->hDriver,
                            ppdev->hClient, ppdev->hDevice, NV_DD_FLIP_PRIMARY_NOTIFIER_CONTEXT_DMA_TO_MEMORY) != NVOS00_STATUS_SUCCESS )
        {
        DPF("NVDD: Cannot free notifier context");
        return FALSE;
        }

    //******************************************************************************
    // Free flip overlay notifier context
    //******************************************************************************
    if (NvFree(  ppdev->hDriver,
                            ppdev->hClient, ppdev->hDevice, NV_DD_FLIP_OVERLAY_NOTIFIER_CONTEXT_DMA_TO_MEMORY) != NVOS00_STATUS_SUCCESS )
        {
        DPF("NVDD: Cannot free notifier context");
        return FALSE;
        }

    //******************************************************************************
    // Free sync notifier context
    //******************************************************************************
    if (NvFree(  ppdev->hDriver,
                            ppdev->hClient, ppdev->hDevice, DD_FIFO_SYNC_NOTIFIER) != NVOS00_STATUS_SUCCESS )
        {
        DPF("NVDD: Cannot free notifier context");
        return FALSE;
        }



    //***********************************************************************************
    // Free scanline buffer.
    //***********************************************************************************
    if (NvFree(ppdev->hDriver, ppdev->hClient, ppdev->hDevice, NV_DD_CONTEXT_DMA_FROM_SYSTEM_MEMORY))
        DPF("NVDD: Cannot free scanline buffer context");
    EngFreeMem(ppdev->NvDmaBufferFlat);
    ppdev->NvScanlineBufferFlat = ppdev->NvDmaBufferFlat = 0;

    //***********************************************************************************
    // Free palette DMA context.
    //***********************************************************************************
    if (ppdev->cBitsPerPel == 8)
        {
        if (NvFree(ppdev->hDriver, ppdev->hClient, ppdev->hDevice, NV_DD_WIN_COLORMAP_CONTEXT))
            DPF("NVDD: Cannot free palette context");
        }

#ifdef MJL_USE_VPP
    destroyExtendedDDPatch(ppdev);
#endif

    ppdev->bDDChannelActive = FALSE;

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\ddraw\nv4\nv4subch.h ===
//******************************************************************************
//
// Copyright (c) 1992  Microsoft Corporation
//
// Module Name:
//
//     nv4subch.h
//
// Abstract:
//
//     This module contains the object subchannel definitions
//
// Environment:
//
//     Kernel mode
//
// Revision History:
//
//
//******************************************************************************

//******************************************************************************
// ddraw SubChannel assignments for objects
//******************************************************************************
#define NV_DD_ROP                      0
#define NV_DD_BLIT                     1
#define NV_DD_RECT_AND_TEXT            2
#define NV_DD_PRIMARY                  3
#define NV_DD_IMAGE                    4
#define NV_DD_PATTERN                  5
#define NV_DD_CLIP                     6
#define NV_DD_STRETCH                  7
#define NV_DD_SPARE                    7

/* Default cached objects in Windows 95 Direct Draw patch */
#define dDrawRop                       subchannel[NV_DD_ROP].nv3ContextRop
#define dDrawImageInMemory             subchannel[NV_DD_SPARE].nvImageInMemory
#define dDrawRopRectAndText            subchannel[NV_DD_RECT_AND_TEXT].nvRenderGdi0RectangleAndText
#define dDrawBlit                      subchannel[NV_DD_BLIT].nv4ImageBlit
#define dDrawImageFromCpu              subchannel[NV_DD_IMAGE].nv4ImageFromCpu
#define dDrawStretch                   subchannel[NV_DD_STRETCH]
#define dDrawTransColor                subchannel[NV_DD_SPARE].nv4ContextColorKey
#define dDrawSpare                     subchannel[NV_DD_SPARE]

#define DD_CHANNEL      1                   // DDRAW always in channel 1
#define GDI_CHANNEL     0                   // GDI always in channel 0
#define DD_CHANNEL_MASK (1 << DD_CHANNEL)   // Mask out ddraw channel

//********************************************************************
// #defines for NV4 fifo sync registers.
//********************************************************************
#define OFFSET_NV_PFIFO_BASE            0x2000
#define NV4_PFIFO_DMA                   0x2508-OFFSET_NV_PFIFO_BASE
#define NV4_PFIFO_CACHE1_PUSH1          0x3204-OFFSET_NV_PFIFO_BASE
#define NV4_PFIFO_CACHE1_DMA_PUSH       0x3220-OFFSET_NV_PFIFO_BASE
#define NV_PFIFO_CACHE1_PUSH1_MODE_DMA_BIT  0x00000100
#define CACHE1_DMA_PUSH_BUFFER_EMPTY    0x100L

//********************************************************************
// This macro is used to ensure that all DMA channel processing has
// completed prior to performing PIO writes.
//********************************************************************
#define NV_DD_DMA_PUSHER_SYNC()                                 \
{                                                               \
if (!ppdev->bDDChannelActive)                                   \
    {                                                           \
    volatile DWORD *npNvBase = (DWORD *)ppdev->PFIFORegs;       \
    volatile DWORD  regValue;                                   \
    DWORD chid;                                                 \
                                                                \
    while ((npNvBase[(NV4_PFIFO_DMA >> 2)] &                    \
            (~DD_CHANNEL_MASK)) != 0);                          \
    if ((npNvBase[NV4_PFIFO_CACHE1_PUSH1 >> 2] & NV_PFIFO_CACHE1_PUSH1_MODE_DMA_BIT) &&         \
        ((chid = (npNvBase[NV4_PFIFO_CACHE1_PUSH1 >> 2] & 0x1F)) !=      \
            (WORD)DD_CHANNEL))                                  \
        {                                                       \
            regValue = npNvBase[(NV4_PFIFO_CACHE1_DMA_PUSH >> 2)]; \
            while ((regValue & CACHE1_DMA_PUSH_BUFFER_EMPTY) == 0) { \
                regValue = npNvBase[(NV4_PFIFO_CACHE1_DMA_PUSH >> 2)]; \
            }                                                   \
            if (chid == GDI_CHANNEL)                            \
                ppdev->pfnWaitEngineBusy(ppdev);                \
        }                                                       \
        ppdev->bDDChannelActive = TRUE;                         \
        ppdev->oglLastChannel = DD_CHANNEL;                     \
    }                                                           \
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\ddraw\nv4\nvdbg_link.cpp ===
// **************************************************************************
//
//       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvDbg_link.cpp
//      a pointer to a shared file
//
// **************************************************************************

#include "..\..\..\..\common\src\nvDbg.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\ddraw\nv4\nvOverlaySurf_link.cpp ===
// **************************************************************************
//
//       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvOverlaySurf_link.cpp
//      a pointer to a shared file
//
// **************************************************************************

#define PDEV_PTR() vpp.pDriverData->ppdev

#include "..\..\..\..\common\src\nvOverlaySurf.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\ddraw\nv4\nvprecomp.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-2001 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/
#include <math.h>   // For sin/cos
#include <stddef.h>
#include <stdarg.h>
#include <limits.h>
#include <windef.h>
#include <winerror.h>
#include <wingdi.h>
#include <winbase.h>
extern "C" {
#include <winddi.h>
};
#include <ntddvdeo.h>

#include "nvTypes.h"
#include "CompileControl.h"

#include "memstruc.h"

// These constants were taken from nvDD.h.  They should come from a shared directory. @mjl@
#define NV_PRESCALE_OVERLAY_X           1
#define NV_PRESCALE_OVERLAY_Y           2
#define NV_PRESCALE_OVERLAY_FIELD       4
#define NV_ALPHA_1_032          ((U032)0xFF000000)
#if (NVARCH >= 0x04)
#define NV_ALPHA_1_016          ((U032)0xFFFF0000)
#else
#define NV_ALPHA_1_016          ((U032)0x00008000)
#endif
#define NV_ALPHA_1_008          ((U032)0x0000FF00)
#define NV_MAX_Y_CLIP                   0x00000FFF
#define NV_MAX_X_CLIP                   0x00000FFF
#define NV_PFIFO_DMA                                     0x00002508 // @mjl@ make sure we map these objects!
#define NV_PFIFO_CACHE1_PUSH1                            0x00003204
#define NV_PFIFO_CACHE1_PUSH1_MODE_DMA_BIT               0x00000100
#define NV_PFIFO_CACHE1_DMA_PUSH                         0x00003220
#define NV_PFIFO_CACHE1_DMA_PUSH_BUFFER_EMPTY_BIT        0x00000100

#include "nvPusher.h"

#include "nv32.h"

// Note: ddminint.h defines GLOBALDATA (and much else) but shared code (anything including this file)
//   will get GLOBALDATA from a different place (win9x/inc/DDMINI.H)
//
#include "ddminint.h"
#include "driver.h" // This is an NT4 specific header despite the name... - @mjl@

#include "nvDbg.h"
#include "nvUtil.h"
#include "nv4subch.h"

#define AllocIPM(size) EngAllocMem(FL_ZERO_MEMORY,size,ALLOC_TAG)
#define FreeIPM(ptr) EngFreeMem(ptr)

#define VIDMEM_ADDR(fpVidMem)    ((fpVidMem) + (ULONG) PDEV_PTR()->pjFrameBufbase)
#define AGPMEM_ADDR(fpVidMem)    ((ULONG) fpVidMem + (ULONG) PDEV_PTR()->pDriverData->GARTLinearBase)
#define VIDMEM_OFFSET(fpVidMem)  (fpVidMem)

// These came from dx95types.h which is not in the dx path being used for NT4
typedef PDD_SURFACE_LOCAL LPDDRAWI_DDRAWSURFACE_LCL;
typedef PDD_SURFACE_GLOBAL LPDDRAWI_DDRAWSURFACE_GBL;
typedef PDD_SURFACE_GLOBAL LPDDRAWI_DDRAWSURFACE_GBL;
typedef PDD_SURFACE_GLOBAL LPDDRAWI_DDRAWSURFACE_GBL;
typedef PDD_DIRECTDRAW_GLOBAL LPDDRAWI_DIRECTDRAW_GBL;

// From win9x/inc32/winnt & winbase headers
// Needed for nvVPP and nvPriv
#define STATUS_WAIT_0       ((DWORD   )0x00000000L)    
#define WAIT_OBJECT_0       ((STATUS_WAIT_0 ) + 0 )

#include "Nvcm.h" // Configuration Manager

#define NvRmConfigGetEx(hCli, hDevice, index, pParams, paramSize) \
        NvConfigGetEx(PDEV_PTR()->hDriver, hCli, hDevice, index, pParams, paramSize)
#define NvRmConfigGet(hClient, hDevice, index, pValue) \
        NvConfigGet(PDEV_PTR()->hDriver, hClient, hDevice, index, pValue)
#define NvRmAllocObject(hCli, hChan, hObj, hCls) \
        NvAllocObject(PDEV_PTR()->hDriver, hCli, hChan, hObj, hCls)
#define NvRmAlloc(hCli, hChan, hObj, hCls, parms) \
        NvAlloc(PDEV_PTR()->hDriver, hCli, hChan, hObj, hCls, parms)
#define NvRmFree(hClient, hParent, hObj) \
        NvFree(PDEV_PTR()->hDriver, hClient, hParent, hObj)
#define NvRmAllocContextDma(hClient, hDma, hClass, flags, base, limit) \
        NvAllocContextDma(PDEV_PTR()->hDriver, hClient, hDma, hClass, flags, base, limit)
#define NvRmAllocChannelDma(hClient, hDev, hChan, hClass, hErrorCtx, hDataCtx, offset, ppChan) \
        NvAllocChannelDma(PDEV_PTR()->hDriver, (hClient), hDev, (hChan), (hClass), (hErrorCtx), (hDataCtx), (offset), (ppChan))

#include "nvapi.h" // For NvConfigGetEx (and possibly other stuff)

#include "winioctl.h"
#include "nvntioctl.h"

#include "nvos.h"
#include "nvReg.h"

// This comes from DDPRIV and is needed by VPP -> resolve later -@mjl@
#define NVS2VF_SP_SUBRECT       0x00000002

#define DXVA_OVERLAY_WAS_BOBBED     0x00000010 // Yet another thing to move from ddmini.h -@mjl@

#define NV_TEXTURE_OFFSET_ALIGN            255

#define AGP_HEAP 1
#define ERR_DXALLOC_FAILED 1
FLATPTR DDHAL32_VidMemAlloc (LPDDRAWI_DIRECTDRAW_GBL pdrv, int heap, DWORD dwXDim, DWORD dwYDim);
void DDHAL32_VidMemFree (LPDDRAWI_DIRECTDRAW_GBL pdrv, int heap, FLATPTR ptr);


#define NVDBG_LEVEL_ERROR               0x80000000 // Temp -- until dbg flags are placed properly @mjl@
#define NVDBG_LEVEL_INFO                0x40000000
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\ddraw\nv4\nvpusher_link.cpp ===
// **************************************************************************
//
//       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvPusher_link.cpp
//      a pointer to a shared file
//
// **************************************************************************

#define PDEV_PTR() m_ppdev

// redefine pusher aliases to local environment (NT4)

//#define _pdwHWGet      These reference internal pusher vars and are therefore okay
//#define _pdwHWPut      
//#define _pdwHWRef
#define _pbHWBusy       (*(volatile DWORD *)(m_ppdev->pDriverData->NvBaseFlat + 0x400700))
#define _ffCache1Push1  (*(volatile DWORD *)(m_ppdev->pDriverData->NvBaseFlat + 0x003204))
#define _ffCache1Status (*(volatile DWORD *)(m_ppdev->pDriverData->NvBaseFlat + 0x003214))
#define _hasKNI         (m_ppdev->pDriverData->sysInfo.dwCPUFeatureSet & FS_KATMAI)
#define _has3DNOW       (m_ppdev->pDriverData->sysInfo.dwCPUFeatureSet & FS_3DNOW)
#define _hasSFENCE      (m_ppdev->pDriverData->sysInfo.dwCPUFeatureSet & FS_SFENCE)
#define _hasFullScreenDosOccurred (m_ppdev->pDriverData->fFullScreenDosOccurred)
#define _systemInfo (m_ppdev->pDriverData->sysInfo)
#define _dmaPusherChannelIndex (m_ppdev->vppChannelNdx)
#define _dwRootHandle (m_ppdev->pDriverData->dwRootHandle)
#define _nvBaseFlat ((volatile DWORD*)m_ppdev->pDriverData->NvBaseFlat)
#define _pCurrentChannelID ((DWORD*)(m_ppdev->pDriverData->pCurrentChannelID))
#define _pDriverData (m_ppdev->pDriverData)
#define _hDevice (m_ppdev->hDevice)

// By redefining this class to nothing, and copying these consts, we effectively rewrite some code in
// the pusher class that depends on the CSimpleSurface class which I'm not ready to port. @mjl@
#define CSimpleSurface
enum
{
    // used to specify where we want to allocate a surface (or'ed together)
    // or where it's currently allocated
    HEAP_LOCATION_MASK      = 0x0000001f,   // surface location - preserve order
    HEAP_VID                = 0x01,
    HEAP_AGP                = 0x02,
    HEAP_PCI                = 0x04,
    HEAP_SYS                = 0x08,
    HEAP_DYNSYS             = 0x18,
    HEAP_DYNSYSBIT          = 0x10,
    HEAP_ANYWHERE           = HEAP_VID | HEAP_AGP | HEAP_PCI | HEAP_SYS | HEAP_DYNSYS,
    HEAP_NOWHERE            = 0x0
};

#define HEAP_SHARED                 0x04000000UL    // put heap in shared memory

#include "..\..\..\..\common\src\nvPusher.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\ddraw\nv4\nvUtil_link.cpp ===
// **************************************************************************
//
//       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvUtil_link.cpp
//      a pointer to a shared file
//
// **************************************************************************

#include "..\..\..\..\common\src\nvUtil.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\ddraw\nv4\nvpriv_link.cpp ===
// **************************************************************************
//
//       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvPriv_link.cpp
//      a pointer to a shared file
//
// **************************************************************************
#define PDEV_PTR() pDriverData->ppdev

#include "..\..\..\..\common\src\nvPriv.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\ddraw\nv4\nvprocman_link.cpp ===
// **************************************************************************
//
//       Copyright 1993-2001 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvProcMan_link.cpp
//      a pointer to a shared file
//
// **************************************************************************

#include "..\..\..\..\common\src\nvProcMan.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\ddraw\nv4\nvVPP_link.cpp ===
// **************************************************************************
//
//       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvVPP_link.cpp
//      a pointer to a shared file
//
// **************************************************************************

// It would be best to move this head to a common header directory
// since it is in fact shared.  All we need is NV_ESC_SETGET_TWINVIEW_DATA.
#include "..\win9x\inc\escape.h"


#define PDEV_PTR() vpp.pDriverData->ppdev

#undef VPP_USE_EVENT_NOTIFIERS    // use event notifiers if this is defined, else use polling
// On NT4 the Ke*Event() routines are not available to the display driver.

#include "..\..\..\..\common\src\nvVPP.cpp"

// This function is only called to get AGP memory -- we don't have AGP on NT4, so we always fail
FLATPTR DDHAL32_VidMemAlloc (LPDDRAWI_DIRECTDRAW_GBL pdrv, int heap, DWORD dwXDim, DWORD dwYDim)
{
    nvAssert(heap == AGP_HEAP);
    return ERR_DXALLOC_FAILED;
}

void DDHAL32_VidMemFree (LPDDRAWI_DIRECTDRAW_GBL pdrv, int heap, FLATPTR ptr)
{
    nvAssert(heap == AGP_HEAP);
    nvAssert(FALSE); // Never called -- since we always fail AGP alloc
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\ddraw\nv4\nvRegTool_link.cpp ===
// **************************************************************************
//
//       Copyright 2001-2001 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvRegTool_link.cpp
//      a pointer to a shared file
//
// **************************************************************************

#include "..\..\..\..\common\src\nvRegTool.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\ddraw\nv4\vid.cpp ===
//******************************************************************************
//
// Copyright (c) 1995-1996 Microsoft Corporation
//
// Module Name:
//
//     DVIDEO.C
//
// Abstract:
//
//     Implements all the low level NV4 specific DirectVideo components for the driver.
//
// Environment:
//
//     kernel mode only
//
// Notes:
//
// Revision History:
//
//
//******************************************************************************

#include "nvprecomp.h"
#include "nvalpha.h"
#include "ddminint.h"
#include "nv32.h"

#include "nvos.h"
#include "nvntioctl.h"
#include "nvntddctl.h"
#include "nvapi.h"
#include "nvsubch.h"

#define NvGetFreeCount(NN, CH)\
                 (NN)->subchannel[CH].control.Free


#define MAGIC_DELAY         1000000

#define WAIT_OVERLAY_NOTIFIER(buf)                                                                  \
{   NvNotification *pFlipOverlayNotifier =    (NvNotification *)ppdev->Notifiers->FlipOverlay;      \
    ULONG i = 0;                                                                                    \
    while (pFlipOverlayNotifier[NV07A_NOTIFIERS_SET_OVERLAY(buf)].status == NV_IN_PROGRESS)         \
        if(i++ > MAGIC_DELAY) break;                                                                \
}                                                                                                   \
    

/******************************Public*Routine**********************************\
* DWORD Nv4UpdateOverlay
*
\******************************************************************************/

DWORD __stdcall Nv4UpdateOverlay( PDD_UPDATEOVERLAYDATA lpUOData )
    {
    long srcDeltaX;
    long srcDeltaY;                                                        
    long dwSrcOffset;
    long dwSrcWidth;
    long dwSrcHeight;
    long dwDstWidth;
    long dwDstHeight;
    long dwSrcPitch;
    ULONG   dwVideoColorKey;
    DWORD index = 0;
    DWORD dwBackBufferCount = 0;
    DWORD match = 0;
    BOOL    releaseOpenglSemaphore = FALSE;
    DWORD dwOverlayFormat;

    PDEV *ppdev = (PDEV *) lpUOData->lpDD->dhpdev;
    FAST Nv3ChannelPio  *npDev = (Nv3ChannelPio *)ppdev->ddChannelPtr;
    FAST USHORT     freeCount = ppdev->NVFreeCount;
    NvNotification *pFlipOverlayNotifier =
    (NvNotification *)ppdev->Notifiers->FlipOverlay;

    PDD_SURFACE_LOCAL  srcx = lpUOData->lpDDSrcSurface;
    PDD_SURFACE_GLOBAL  src = srcx->lpGbl;
    PDD_SURFACE_LOCAL  pOriginalSrcx = lpUOData->lpDDSrcSurface;
    PDD_SURFACE_GLOBAL  pOriginalSrc  = lpUOData->lpDDSrcSurface->lpGbl;

    if ((src->ddpfSurface.dwFourCC != FOURCC_UYVY) &&
        (src->ddpfSurface.dwFourCC != FOURCC_YUY2) &&
        (src->ddpfSurface.dwFourCC != FOURCC_YV12) &&
        (src->ddpfSurface.dwFourCC != FOURCC_420i) &&
        (src->ddpfSurface.dwFourCC != FOURCC_IF09) &&
        (src->ddpfSurface.dwFourCC != FOURCC_YVU9) &&
        (src->ddpfSurface.dwFourCC != FOURCC_IV32) &&
        (src->ddpfSurface.dwFourCC != FOURCC_IV31))
        {
        lpUOData->ddRVal = DDERR_INVALIDSURFACETYPE;
        return DDHAL_DRIVER_HANDLED;
        }

    if (!(srcx->ddsCaps.dwCaps & DDSCAPS_OVERLAY))
        {
        lpUOData->ddRVal = DDERR_NOTAOVERLAYSURFACE;
        return DDHAL_DRIVER_HANDLED;
        }

    while ((index < NV_MAX_OVERLAY_SURFACES) && (!match))
        if ((DWORD)srcx == ppdev->dwOverlaySurfaceLCL[index++])
            match = 1;

    if (!match)
        {
        lpUOData->ddRVal = DDERR_OUTOFCAPS;
        return DDHAL_DRIVER_HANDLED;
        }

    if (npDev == NULL)
        {  /* Mode switches might occur without warning */
        lpUOData->ddRVal = DDERR_SURFACELOST;
        return DDHAL_DRIVER_HANDLED;
        }

    /*
     * NOTES:
     *
     * This callback is invoked to update an overlay surface.
     * This is where the src/destination is specified, any effects, and
     * it is shown or hidden
     */

    /* Alternate buffer indexes to keep the hardware happy */
	ppdev->OverlayBufferIndex ^= 1;
    index = ppdev->OverlayBufferIndex;

    ENTER_DMA_PUSH_SYNC();
    NV_DD_DMA_PUSHER_SYNC();
    freeCount = ppdev->NVFreeCount;

    // if Overlay is enabled, disabled it before updating new size and position.
    if ((lpUOData->dwFlags & DDOVER_HIDE ) || ppdev->dwOverlayEnabled)
        {
        DPF("UPDATE OVERLAY - DDOVER_HIDE");

        WAIT_OVERLAY_NOTIFIER(0);
        WAIT_OVERLAY_NOTIFIER(1);

        while (freeCount < 3*4)
            freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);
        freeCount -= 3*4;

        npDev->dDrawSpare.SetObject = NV_DD_VIDEO_OVERLAY;
        npDev->dDrawSpare.Nv04VideoOverlay.StopOverlay[0] = NV07A_STOP_OVERLAY_AS_SOON_AS_POSSIBLE;
        npDev->dDrawSpare.Nv04VideoOverlay.StopOverlay[1] = NV07A_STOP_OVERLAY_AS_SOON_AS_POSSIBLE;

        ppdev->dDrawSpareSubchannelObject = NV_DD_VIDEO_OVERLAY;

        /* Let DDraw know how many visible overlays are active */
        ppdev->HALInfo.ddCaps.dwCurrVisibleOverlays = 0;
        ppdev->dwOverlaySrcHeight = 0;
        ppdev->dwOverlayDstHeight = 0;

        WAIT_OVERLAY_NOTIFIER(0);
        WAIT_OVERLAY_NOTIFIER(1);

        ppdev->dwOverlayEnabled = FALSE;
        }

    if (lpUOData->dwFlags & DDOVER_HIDE )
        {
            // already disabled
        }
    else
        {

        ppdev->dwOverlayEnabled = TRUE;
        DPF("UPDATE OVERLAY - DDOVER_SHOW OR MOVE/RESIZE ");
        DPF( "Source Rect = (%ld,%ld), (%ld,%ld)",
             lpUOData->rSrc.left, lpUOData->rSrc.top,
             lpUOData->rSrc.right, lpUOData->rSrc.bottom );

        DPF( "Dest Rect = (%ld,%ld), (%ld,%ld)",
             lpUOData->rDest.left, lpUOData->rDest.top,
             lpUOData->rDest.right, lpUOData->rDest.bottom );

        if ( lpUOData->dwFlags & (DDOVER_KEYSRCOVERRIDE | DDOVER_KEYSRC) )
            {
            ppdev->NVFreeCount = freeCount;
            lpUOData->ddRVal = DDERR_NOCOLORKEYHW;
            EXIT_DMA_PUSH_SYNC(DDHAL_DRIVER_HANDLED);
            }
        if ((lpUOData->rDest.left < 0) || (lpUOData->rDest.top < 0))
            {
            lpUOData->ddRVal = DDERR_INVALIDPOSITION;
            ppdev->NVFreeCount = freeCount;
            EXIT_DMA_PUSH_SYNC(DDHAL_DRIVER_HANDLED);
            }

        dwSrcWidth = lpUOData->rSrc.right - lpUOData->rSrc.left;
        dwSrcHeight = lpUOData->rSrc.bottom - lpUOData->rSrc.top;
        dwDstWidth = lpUOData->rDest.right - lpUOData->rDest.left;
        dwDstHeight = lpUOData->rDest.bottom - lpUOData->rDest.top;

        /* Remember heights so Flip32 knows what to do */
        ppdev->dwOverlaySrcHeight = dwSrcHeight;
        ppdev->dwOverlayDstHeight = dwDstHeight;

        if (dwSrcHeight > dwDstHeight)
            {
            dwSrcHeight >>= 1; /* We only support vertical shrinking and it can't be by more than .5 */
            if (dwSrcHeight > dwDstHeight)
                {
                lpUOData->ddRVal = DDERR_UNSUPPORTED;
                ppdev->NVFreeCount = freeCount;
                EXIT_DMA_PUSH_SYNC(DDHAL_DRIVER_HANDLED);
                }
            }

        /* Align to 2 pixel boundary + 1 for video scaler */
        dwDstWidth = (dwDstWidth + 2) & ~1L;
        dwDstHeight = (dwDstHeight + 2) & ~1L;

        srcDeltaX = (dwSrcWidth - 1) << 16;
        srcDeltaX /= dwDstWidth - 1;
        srcDeltaX <<= 4;
        srcDeltaY = (dwSrcHeight - 1) << 16;
        srcDeltaY /= dwDstHeight - 1;
        srcDeltaY <<= 4;

            // color key?
        if (lpUOData->dwFlags & DDOVER_KEYDESTOVERRIDE) {
            dwVideoColorKey = lpUOData->overlayFX.dckDestColorkey.dwColorSpaceLowValue;
            dwOverlayFormat = (NV07A_SET_OVERLAY_FORMAT_COLOR_KEY_MISMATCH_SHOW_IMAGE << 20);
        } else if (lpUOData->dwFlags & DDOVER_KEYDEST) {
            dwVideoColorKey = lpUOData->lpDDDestSurface->ddckCKDestOverlay.dwColorSpaceLowValue;
            dwOverlayFormat = (NV07A_SET_OVERLAY_FORMAT_COLOR_KEY_MISMATCH_SHOW_IMAGE << 20);
        } else {    // disable color key
            dwOverlayFormat = (NV07A_SET_OVERLAY_FORMAT_COLOR_KEY_MISMATCH_SHOW_OVERLAY << 20);
        }
        if (src->ddpfSurface.dwFourCC == FOURCC_UYVY) {
            dwOverlayFormat |= (NV07A_SET_OVERLAY_FORMAT_COLOR_LE_YB8CR8YA8CB8 << 16);
        } else {
            dwOverlayFormat |= (NV07A_SET_OVERLAY_FORMAT_COLOR_LE_CR8YB8CB8YA8 << 16);
        }

        while (srcx != NULL)
            {
            dwSrcOffset = src->fpVidMem;

            if ((src->ddpfSurface.dwFourCC == FOURCC_IF09) ||
                (src->ddpfSurface.dwFourCC == FOURCC_YVU9) ||
                (src->ddpfSurface.dwFourCC == FOURCC_IV32) ||
                (src->ddpfSurface.dwFourCC == FOURCC_IV31))
                {
                /* Skip over Indeo portion of surface */
                dwSrcPitch = (DWORD)src->wWidth;
                dwSrcOffset += ((dwSrcPitch * ((DWORD)src->wHeight * 10L)) >> 3);
                /* Force block to be properly aligned */
                dwSrcOffset = (dwSrcOffset + ppdev->ulSurfaceAlign) & ~ppdev->ulSurfaceAlign;
                dwSrcPitch = ((src->wWidth + 1) & 0xFFFFFFFE) << 1;
                dwSrcPitch = (dwSrcPitch + ppdev->ulSurfaceAlign) & ~ppdev->ulSurfaceAlign;
                }
            else if ((src->ddpfSurface.dwFourCC == FOURCC_YV12) ||
                     (src->ddpfSurface.dwFourCC == FOURCC_420i))
                {
                /* Assumes a separate overlay YUY2 surface in video memory */
                if (src->fpVidMem == ppdev->NvFloatingMem2MemFormatBaseAddress)
                    dwSrcOffset = ppdev->NvYUY2Surface0Mem;

                else if (src->fpVidMem == ppdev->NvFloatingMem2MemFormatNextAddress)
                    dwSrcOffset = ppdev->NvYUY2Surface1Mem;
                else
                    dwSrcOffset = ppdev->NvYUY2Surface2Mem;

                dwSrcPitch = ((src->wWidth + 1) & 0xFFFFFFFE) << 1;
                dwSrcPitch = (dwSrcPitch + ppdev->ulSurfaceAlign) & ~ppdev->ulSurfaceAlign;
                }
            else
                dwSrcPitch = (DWORD)src->lPitch;

            dwSrcOffset += (lpUOData->rSrc.top * dwSrcPitch);
            dwSrcOffset += (lpUOData->rSrc.left << 1);

            /* Let the world know what the current overlay src offset is */
            ppdev->OverlaySrcX = (short)lpUOData->rSrc.left;
            ppdev->OverlaySrcY = (short)lpUOData->rSrc.top;

            /* We shrink vertically by skipping scanlines then stretching up */
            if (ppdev->dwOverlaySrcHeight > (DWORD)dwDstHeight)
                dwSrcPitch <<= 1;

// temp defines b4 becoming a class standard
#define NV_VFM_FORMAT_CONTROL_FLIP_BY_MEDIAPORT_0 (0x04000000)
#define NV_VFM_FORMAT_CONTROL_FLIP_BY_MEDIAPORT_1 (0x02000000)

            /* Let the world know what the overlay src info is */
            ppdev->OverlaySrcOffset = dwSrcOffset;
            ppdev->OverlaySrcPitch = dwSrcPitch;
            ppdev->OverlaySrcSize = asmMergeCoords(dwSrcWidth, dwSrcHeight);

            dwOverlayFormat |= (NV07A_SET_OVERLAY_FORMAT_MATRIX_ITURBT601 << 24);
            dwOverlayFormat |= (NV07A_SET_OVERLAY_FORMAT_NOTIFY_WRITE_ONLY << 31);

            ppdev->dwVideoColorKey = dwVideoColorKey;
            ppdev->OverlaySrcOffset = dwSrcOffset;
            ppdev->OverlaySrcSize = asmMergeCoords((dwSrcWidth & ~1), (dwSrcHeight & ~1));
            ppdev->dwOverlayDeltaX = srcDeltaX;
            ppdev->dwOverlayDeltaY = srcDeltaY;
            ppdev->dwOverlayDstX = lpUOData->rDest.left;
            ppdev->dwOverlayDstY = lpUOData->rDest.top;
            ppdev->dwOverlayDstWidth = dwDstWidth;
            ppdev->dwOverlayDstHeight = dwDstHeight;
            ppdev->dwOverlayFormat = dwOverlayFormat;
            ppdev->OverlaySrcPitch = dwSrcPitch;

            dwOverlayFormat |= dwSrcPitch;

            WAIT_OVERLAY_NOTIFIER(index);

            while (freeCount < 10*4)
                freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);
            freeCount -= 10*4;

            // notifiers do not seem to be working...
            pFlipOverlayNotifier[NV07A_NOTIFIERS_SET_OVERLAY(index)].status = NV_IN_PROGRESS;

            npDev->dDrawSpare.SetObject = NV_DD_VIDEO_OVERLAY;
            npDev->dDrawSpare.Nv04VideoOverlay.SetOverlay[index].colorKey = dwVideoColorKey;
            npDev->dDrawSpare.Nv04VideoOverlay.SetOverlay[index].offset = dwSrcOffset;
            npDev->dDrawSpare.Nv04VideoOverlay.SetOverlay[index].sizeIn = asmMergeCoords((dwSrcWidth & ~1), (dwSrcHeight & ~1));
            npDev->dDrawSpare.Nv04VideoOverlay.SetOverlay[index].pointIn = 0;
            npDev->dDrawSpare.Nv04VideoOverlay.SetOverlay[index].dsDx = srcDeltaX;
            npDev->dDrawSpare.Nv04VideoOverlay.SetOverlay[index].dtDy = srcDeltaY;
            npDev->dDrawSpare.Nv04VideoOverlay.SetOverlay[index].pointOut = asmMergeCoords(lpUOData->rDest.left, lpUOData->rDest.top);
            npDev->dDrawSpare.Nv04VideoOverlay.SetOverlay[index].sizeOut = asmMergeCoords(dwDstWidth, dwDstHeight);
            npDev->dDrawSpare.Nv04VideoOverlay.SetOverlay[index].format = dwOverlayFormat;

            ppdev->dDrawSpareSubchannelObject = NV_DD_VIDEO_OVERLAY;
            

            srcx = NULL;
            src  = NULL;
            }

        ppdev->dDrawSpareSubchannelObject = 0;

        /* Let DDraw know how many visible overlays are active */
        if (ppdev->HALInfo.ddCaps.dwCurrVisibleOverlays == 0)
            {
            ppdev->HALInfo.ddCaps.dwCurrVisibleOverlays = 1;
            }
        }
    ppdev->NVFreeCount = (short)freeCount;
    lpUOData->ddRVal = DD_OK;
    EXIT_DMA_PUSH_SYNC(DDHAL_DRIVER_HANDLED);

    } /* Nv4UpdateOverlay */


/******************************Public*Routine**********************************\
* DWORD DdSetOverlayPosition
*
\******************************************************************************/
DWORD __stdcall Nv4SetOverlayPosition( PDD_SETOVERLAYPOSITIONDATA lpSOPData )
    {
    DWORD           index = 0;
    DWORD           match = 0;
    PDEV *ppdev = (PDEV *) lpSOPData->lpDD->dhpdev;
    FAST Nv3ChannelPio  *npDev = (Nv3ChannelPio *)ppdev->ddChannelPtr;
    FAST USHORT     freeCount = ppdev->NVFreeCount;
    BOOL    releaseOpenglSemaphore = FALSE;

    PDD_SURFACE_LOCAL  srcx = lpSOPData->lpDDSrcSurface;

    if (!(srcx->ddsCaps.dwCaps & DDSCAPS_OVERLAY))
        {
        lpSOPData->ddRVal = DDERR_NOTAOVERLAYSURFACE;
        return DDHAL_DRIVER_HANDLED;
        }

    if ((lpSOPData->lXPos < 0) || (lpSOPData->lYPos < 0))
        {
        lpSOPData->ddRVal = DDERR_INVALIDPOSITION;
        return DDHAL_DRIVER_HANDLED;
        }

    while ((index < NV_MAX_OVERLAY_SURFACES) && (!match))
        if ((DWORD)srcx == ppdev->dwOverlaySurfaceLCL[index++])
            match = 1;

    if (!match)
        {
        lpSOPData->ddRVal = DDERR_OUTOFCAPS;
        return DDHAL_DRIVER_HANDLED;
        }

    if (npDev == NULL)
        {  /* Mode switches might occur without warning */
        lpSOPData->ddRVal = DDERR_SURFACELOST;
        return DDHAL_DRIVER_HANDLED;
        }
        
    /* Alternate buffer indexes to keep the hardware happy */
	ppdev->OverlayBufferIndex ^= 1;
    index = ppdev->OverlayBufferIndex;

    ENTER_DMA_PUSH_SYNC();
    NV_DD_DMA_PUSHER_SYNC();
    freeCount = ppdev->NVFreeCount;

    /*
     * NOTES:
     *
     * This callback is invoked to set an overlay position
     */
    DPF( "SET OVERLAY POSITION" );
    DPF( "Overlay surface = %08lx", lpSOPData->lpDDSrcSurface );
    DPF( "(%ld,%ld)", lpSOPData->lXPos, lpSOPData->lYPos );

    while (freeCount < 2*4)
        freeCount = NvGetFreeCount(npDev, BLIT_SUBCHANNEL);
    freeCount -= 2*4;

    npDev->dDrawSpare.SetObject = NV_DD_VIDEO_OVERLAY;
    npDev->dDrawSpare.Nv04VideoOverlay.SetOverlayPointOutA = asmMergeCoords(lpSOPData->lXPos, lpSOPData->lYPos);
    ppdev->dwOverlayDstX = lpSOPData->lXPos;
    ppdev->dwOverlayDstY = lpSOPData->lYPos;

    ppdev->dDrawSpareSubchannelObject = 0;

    ppdev->NVFreeCount = (short)freeCount;

    lpSOPData->ddRVal = DD_OK;
    EXIT_DMA_PUSH_SYNC(DDHAL_DRIVER_HANDLED);

    } /* DdSetOverlayPosition */

/*
 * Nv4UnlockOverlay
 */
DWORD __stdcall Nv4UnlockOverlay( PDD_UNLOCKDATA lpUnlockData )
    {
    PDEV*   ppdev;
    FAST Nv3ChannelPio          *npDev;
    FAST USHORT                 freeCount;
    PDD_SURFACE_GLOBAL        pSurf_gbl;
    DWORD                       caps;
    DWORD                       dwSrcYOffset;
    DWORD                       dwSrcVOffset;
    DWORD                       dwSrcUOffset;
    long                        dwSrcYPitch;
    long                        dwSrcUVPitch;
    long                        dwSrcUVHeight;
    DWORD                       dwDstYOffset;
    long                        dwDstYPitch;
    unsigned char               *fpSrcYMem;
    unsigned char               *fpSrcUMem;
    unsigned char               *fpSrcVMem;
    long                        dwSrcPitch;
    long                        dwSrcWidth;
    long                        dwSrcHeight;
    BOOL    releaseOpenglSemaphore = FALSE;

    pSurf_gbl = lpUnlockData->lpDDSurface->lpGbl;
    ppdev = (PDEV *) lpUnlockData->lpDD->dhpdev;
    npDev = (Nv3ChannelPio *)ppdev->ddChannelPtr;

    caps = lpUnlockData->lpDDSurface->ddsCaps.dwCaps;


    //*************************************************************
    // Ensure GDI DMA Push channel processing has completed prior
    // to copying a large block of bitmap data into the fifo.
    //*************************************************************
    ENTER_DMA_PUSH_SYNC();
    NV_DD_DMA_PUSHER_SYNC();

    ppdev->pfnWaitEngineBusy(ppdev);

    /* If surface is IF09 format then must reformat data before
       video scaler can be used to display it */
    if ((pSurf_gbl->ddpfSurface.dwFourCC == FOURCC_IF09) ||
        (pSurf_gbl->ddpfSurface.dwFourCC == FOURCC_YVU9) ||
        (pSurf_gbl->ddpfSurface.dwFourCC == FOURCC_IV32) ||
        (pSurf_gbl->ddpfSurface.dwFourCC == FOURCC_IV31))
        {

        dwSrcYOffset = pSurf_gbl->fpVidMem;
        dwSrcYPitch = (DWORD)pSurf_gbl->wWidth;
        dwSrcYPitch = (dwSrcYPitch + 3) & ~3L;
        dwDstYOffset = dwSrcYOffset + ((dwSrcYPitch * ((DWORD)pSurf_gbl->wHeight * 10L)) >> 3);
        dwDstYOffset = (dwDstYOffset + ppdev->ulSurfaceAlign) & ~ppdev->ulSurfaceAlign;
        dwDstYPitch = ((pSurf_gbl->wWidth + 1) & 0xFFFE) << 1;
        dwDstYPitch = (dwDstYPitch + ppdev->ulSurfaceAlign) & ~ppdev->ulSurfaceAlign;

        fpSrcYMem = (unsigned char *)(ULONG)ppdev->pjFrameBufbase + pSurf_gbl->fpVidMem;
        dwSrcHeight = (DWORD)pSurf_gbl->wHeight;
        dwSrcHeight = (dwSrcHeight + 3) & ~3L;
        fpSrcVMem = fpSrcYMem + (dwSrcYPitch * dwSrcHeight);
        dwSrcHeight >>= 2;
        fpSrcUMem = fpSrcVMem + ((dwSrcYPitch >> 2) * dwSrcHeight);

        dwSrcUVHeight = (DWORD)pSurf_gbl->wHeight;
        dwSrcUVHeight = (dwSrcUVHeight + 3) & ~3L;
        dwSrcUVHeight >>= 2;

        dwSrcUVPitch = (DWORD)pSurf_gbl->wWidth;
        dwSrcUVPitch = (dwSrcUVPitch + 3) & ~3L;
        dwSrcUVPitch >>= 2;


        freeCount = ppdev->NVFreeCount;

        while (freeCount < 3*4)
            freeCount = NvGetFreeCount(npDev, NV_DD_ROP);
        freeCount -= 3*4;

        npDev->dDrawRop.SetRop5 = 0xC0; /* MERGECOPY PSa */

        /* Temporarily change destination surface color format */
        npDev->subchannel[NV_DD_PRIMARY].nv4ContextSurfaces2D.SetColorFormat =
            NV042_SET_COLOR_FORMAT_LE_Y8;

        DDRAW_SET_PRIMARY(ppdev, dwDstYOffset, dwDstYPitch);
        DDRAW_SET_SOURCE(ppdev, dwSrcYOffset, dwDstYPitch);
        while (freeCount < 16*4)
            freeCount = NvGetFreeCount(npDev, NV_DD_ROP);
        freeCount -= 16*4;

//        npDev->subchannel[NV_DD_PRIMARY].nv4ContextSurfaces2D.SetOffsetDestin = dwDstYOffset;
//        npDev->subchannel[NV_DD_PRIMARY].nv4ContextSurfaces2D.SetPitch =
//            (dwDstYPitch << 16) | dwDstYPitch;

        npDev->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetPatternSelect =
        NV044_SET_PATTERN_SELECT_MONOCHROME;

        npDev->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetMonochromeShape =
        NV044_SET_MONOCHROME_SHAPE_64X_1Y;

        npDev->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetMonochromeColor1 = 0xFFFFFFFF;

        npDev->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetMonochromeColor0 = 0;

        /* First enable only V values to be written */
        npDev->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetMonochromePattern0 =
        0x11111111;

        npDev->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetMonochromePattern1 =
        0x11111111;

        npDev->dDrawStretch.SetObject =
            NV_DD_STRETCHED_UV_IMAGE_FROM_CPU;

        npDev->dDrawStretch.nv4StretchedImageFromCpu.SizeIn =
            asmMergeCoords(dwSrcUVPitch, dwSrcUVHeight);

        npDev->dDrawStretch.nv4StretchedImageFromCpu.ClipPoint = 0;

        npDev->dDrawStretch.nv4StretchedImageFromCpu.ClipSize =
            asmMergeCoords((dwSrcYPitch << 1), (DWORD)pSurf_gbl->wHeight);

        npDev->dDrawStretch.nv4StretchedImageFromCpu.DeltaDxDu =
            8 << 20;

        npDev->dDrawStretch.nv4StretchedImageFromCpu.DeltaDyDv =
            4 << 20;

        npDev->dDrawStretch.nv4StretchedImageFromCpu.Point12d4 = 0;

        dwSrcHeight = dwSrcUVHeight;

        while (--dwSrcHeight >= 0)
            {
            FAST DWORD vPxls0;
            FAST DWORD vPxls1;

            dwSrcPitch = dwSrcUVPitch;
            
            dwSrcPitch = (dwSrcPitch + 3) & ~3;

            while (dwSrcPitch >= 16)
                {
                dwSrcPitch -= 16;

                while (freeCount < 16)
                    freeCount = NvGetFreeCount(npDev, NV_DD_STRETCH);
                freeCount -= 16;

                vPxls0 = *(unsigned long *)fpSrcVMem;
                vPxls1 = *(unsigned long *)&fpSrcVMem[4];
                npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[0] =
                vPxls0;
                vPxls0 = *(unsigned long *)&fpSrcVMem[8];
                npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[1] =
                vPxls1;
                vPxls1 = *(unsigned long *)&fpSrcVMem[12];
                npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[2] =
                vPxls0;
                fpSrcVMem += 16;
                npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[3] =
                vPxls1;
                }

            while (freeCount < 16)
                freeCount = NvGetFreeCount(npDev, NV_DD_STRETCH);

            while (dwSrcPitch >= 4)
                {
                dwSrcPitch -= 4;
                freeCount -= 4;
                vPxls0 = *(unsigned long *)fpSrcVMem;
                fpSrcVMem += 4;
                npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[0] =
                vPxls0;
                }
            }

        while (freeCount < 56)
            freeCount = NvGetFreeCount(npDev, NV_DD_PATTERN);
        freeCount -= 56;

        npDev->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetPatternSelect =
        NV044_SET_PATTERN_SELECT_MONOCHROME;

        npDev->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetMonochromeShape =
        NV044_SET_MONOCHROME_SHAPE_64X_1Y;

        npDev->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetMonochromeColor1 = 0xFFFFFFFF;

        npDev->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetMonochromeColor0 = 0;

        /* Now enable only U values to be written */
        npDev->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetMonochromePattern0 =
        0x44444444;

        npDev->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetMonochromePattern1 =
        0x44444444;

        npDev->dDrawStretch.SetObject = NV_DD_STRETCHED_UV_IMAGE_FROM_CPU;

        npDev->dDrawStretch.nv4StretchedImageFromCpu.SizeIn =
        asmMergeCoords(dwSrcUVPitch, dwSrcUVHeight);

        npDev->dDrawStretch.nv4StretchedImageFromCpu.ClipPoint = 0;

        npDev->dDrawStretch.nv4StretchedImageFromCpu.ClipSize =
        asmMergeCoords((dwSrcYPitch << 1), (DWORD)pSurf_gbl->wHeight);

        npDev->dDrawStretch.nv4StretchedImageFromCpu.DeltaDxDu = 8 << 20;

        npDev->dDrawStretch.nv4StretchedImageFromCpu.DeltaDyDv = 4 << 20;

        npDev->dDrawStretch.nv4StretchedImageFromCpu.Point12d4 = 0;
        dwSrcHeight = dwSrcUVHeight;

        while (--dwSrcHeight >= 0)
            {
            FAST DWORD uPxls0;
            FAST DWORD uPxls1;

            dwSrcPitch = dwSrcUVPitch;

            dwSrcPitch = (dwSrcPitch + 3) & ~3;
            
            while (dwSrcPitch >= 16)
                {
                dwSrcPitch -= 16;

                while (freeCount < 16)
                    freeCount = NvGetFreeCount(npDev, NV_DD_STRETCH);
                freeCount -= 16;

                uPxls0 = *(unsigned long *)fpSrcUMem;
                uPxls1 = *(unsigned long *)&fpSrcUMem[4];
                npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[0] =
                uPxls0;
                uPxls0 = *(unsigned long *)&fpSrcUMem[8];
                npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[1] =
                uPxls1;
                uPxls1 = *(unsigned long *)&fpSrcUMem[12];
                npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[2] =
                uPxls0;
                fpSrcUMem += 16;
                npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[3] =
                uPxls1;
                }

            while (freeCount < 16)
                freeCount = NvGetFreeCount(npDev, NV_DD_STRETCH);

            while (dwSrcPitch >= 4)
                {
                dwSrcPitch -= 4;
                freeCount -= 4;
                uPxls0 = *(unsigned long *)fpSrcUMem;
                fpSrcUMem += 4;
                npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[0] =
                uPxls0;
                }
            }

        while (freeCount < 54)
            freeCount = NvGetFreeCount(npDev, NV_DD_STRETCH);
        freeCount -= 54;


        /* reenable pattern object alpha */
       npDev->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetMonochromeColor0 =
            0 | ppdev->AlphaEnableValue;

        /* restore destination surface color format */
        if (ppdev->cBitsPerPel == 8)
            npDev->subchannel[NV_DD_PRIMARY].nv4ContextSurfaces2D.SetColorFormat =
                NV042_SET_COLOR_FORMAT_LE_Y8;
        else if (ppdev->cBitsPerPel == 16)
            npDev->subchannel[NV_DD_PRIMARY].nv4ContextSurfaces2D.SetColorFormat =
                NV042_SET_COLOR_FORMAT_LE_R5G6B5;
        else
            npDev->subchannel[NV_DD_PRIMARY].nv4ContextSurfaces2D.SetColorFormat =
                NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_O8R8G8B8;

        /* Update all Y values */
        npDev->subchannel[NV_DD_SPARE].SetObject =
        NV_DD_VIDEO_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT;

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.OffsetIn =
            dwSrcYOffset;

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.OffsetOut =
            dwDstYOffset;

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.PitchIn =
            dwSrcYPitch;

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.PitchOut =
            dwDstYPitch;

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.LineLengthIn =
            dwSrcYPitch;

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.LineCount =
            (DWORD)pSurf_gbl->wHeight;
            //NV_MTMF_FORMAT_INPUT_INC_1 | NV_MTMF_FORMAT_OUTPUT_INC_2;

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.Format =
            1 | (2 << 8);

        //((NvNotification *)(&(ppdev->Notifiers->DmaToMem)))[1].status = NV039_NOTIFICATION_STATUS_IN_PROGRESS;
        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.BufferNotify = NV039_NOTIFY_WRITE_ONLY;

        //while (((NvNotification *)(&ppdev->Notifiers->DmaToMem))[1].status == NV039_NOTIFICATION_STATUS_IN_PROGRESS);

        ppdev->dDrawSpareSubchannelObject = 0;
        ppdev->NVFreeCount = (short)freeCount;
        }
    else if ((pSurf_gbl->ddpfSurface.dwFourCC == FOURCC_YV12)||
             (pSurf_gbl->ddpfSurface.dwFourCC == FOURCC_420i))
        {
        /* YV12/420i surfaces also need reformated before the video scaler can display them */
        DWORD srcMemType = 0;

        freeCount = ppdev->NVFreeCount;

        /* First determine which source buffer is being used */
        dwSrcYOffset = pSurf_gbl->fpVidMem; // - ppdev->NvFloatingMem2MemFormatBaseAddress;

        dwSrcYPitch = (DWORD)pSurf_gbl->wWidth;
        dwSrcYPitch = (dwSrcYPitch + 3) & ~3L;

        dwSrcWidth = dwSrcYPitch;

        if (dwSrcYOffset == ppdev->NvFloatingMem2MemFormatBaseAddress)
            dwDstYOffset = ppdev->NvYUY2Surface0Mem;
        else if (pSurf_gbl->fpVidMem == ppdev->NvFloatingMem2MemFormatNextAddress)
            dwDstYOffset = ppdev->NvYUY2Surface1Mem;
        else
            dwDstYOffset = ppdev->NvYUY2Surface2Mem;
#ifdef SYSMEM_FALLBACK
        /* Now correct source offset if it is really in video memory */
        if ((ppdev->NvFloatingMem2MemFormatBaseAddress >= pDriverData->BaseAddress) && /* If video memory */
            (pDriverData->NvFloatingMem2MemFormatBaseAddress < pDriverData->BaseAddress + 0x1000000))
            {
            dwSrcYOffset = pSurf_gbl->fpVidMem - pDriverData->BaseAddress;
            srcMemType = DDSCAPS_LOCALVIDMEM;
            }
#endif
        srcMemType = DDSCAPS_LOCALVIDMEM;
        dwDstYPitch = ((pSurf_gbl->wWidth + 1) & 0xFFFE) << 1;
        dwDstYPitch = (dwDstYPitch + ppdev->ulSurfaceAlign) & ~ppdev->ulSurfaceAlign;

        dwSrcHeight = (DWORD)pSurf_gbl->wHeight;
        dwSrcHeight = (dwSrcHeight + 1) & ~1L;

        if (pSurf_gbl->ddpfSurface.dwFourCC == FOURCC_YV12)
            {
            dwSrcVOffset = dwSrcYOffset + (dwSrcYPitch * dwSrcHeight);
            dwSrcUOffset = dwSrcVOffset + ((dwSrcYPitch * dwSrcHeight) >> 2);

            dwSrcUVPitch = (DWORD)pSurf_gbl->wWidth;
            dwSrcUVPitch = (dwSrcUVPitch + 3) & ~3L;
            dwSrcUVPitch >>= 1;

            }
        else
            { /* FOURCC_420i */
            dwSrcVOffset = dwSrcYOffset + dwSrcYPitch;
            dwSrcYPitch += (dwSrcYPitch >> 1);
            dwSrcUOffset = dwSrcVOffset + dwSrcYPitch;

            dwSrcUVPitch = dwSrcYPitch << 1;
            }

        dwSrcUVHeight = (DWORD)pSurf_gbl->wHeight;
        dwSrcUVHeight = (dwSrcUVHeight + 1) & ~1L;
        dwSrcUVHeight >>= 1;

        while (freeCount < 72)
            freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);
        freeCount -= 72;

        if (srcMemType == 0) /* If system memory */
            npDev->subchannel[NV_DD_SPARE].SetObject =
            NV_DD_SYSTEM_MEMORY_V_TO_VIDEO_MEMORY_FORMAT;
        else
            npDev->subchannel[NV_DD_SPARE].SetObject =
            NV_DD_VIDEO_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT;

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.OffsetIn =
        dwSrcVOffset;

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.OffsetOut =
        (dwDstYOffset + 3);

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.PitchIn =
        dwSrcUVPitch;

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.PitchOut =
        (dwDstYPitch << 1);

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.LineLengthIn =
        (dwSrcWidth >> 1);

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.LineCount =
        dwSrcUVHeight;

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.Format =
        1 | (4 << 8);
        //NV_MTMF_FORMAT_INPUT_INC_1 | NV_MTMF_FORMAT_OUTPUT_INC_4;

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.BufferNotify = 0;

        if (srcMemType == 0) /* If system memory */
            npDev->subchannel[NV_DD_SPARE].SetObject =
            NV_DD_SYSTEM_MEMORY_U_TO_VIDEO_MEMORY_FORMAT;
        else
            npDev->subchannel[NV_DD_SPARE].SetObject =
            NV_DD_VIDEO_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT;

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.OffsetIn =
        dwSrcUOffset;

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.OffsetOut =
        (dwDstYOffset + 1);

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.PitchIn =
        dwSrcUVPitch;

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.PitchOut =
        (dwDstYPitch << 1);

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.LineLengthIn =
        (dwSrcWidth >> 1);

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.LineCount =
        dwSrcUVHeight;

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.Format =
        1 | (4 << 8);
        //NV_MTMF_FORMAT_INPUT_INC_1 | NV_MTMF_FORMAT_OUTPUT_INC_4;

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.BufferNotify = 0;

        while (freeCount < 72)
            freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);
        freeCount -= 72;

        if (srcMemType == 0) /* If system memory */
            npDev->subchannel[NV_DD_SPARE].SetObject =
            NV_DD_SYSTEM_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT;
        else
            npDev->subchannel[NV_DD_SPARE].SetObject =
            NV_DD_VIDEO_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT;

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.OffsetIn =
        dwSrcYOffset;

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.OffsetOut =
        dwDstYOffset;

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.PitchIn =
        dwSrcYPitch;

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.PitchOut =
        dwDstYPitch;

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.LineLengthIn =
        dwSrcWidth;

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.LineCount =
        (DWORD)pSurf_gbl->wHeight;

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.Format =
        1 | (2 << 8);
        //NV_MTMF_FORMAT_INPUT_INC_1 | NV_MTMF_FORMAT_OUTPUT_INC_2;

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.BufferNotify = 0;

        npDev->subchannel[NV_DD_SPARE].SetObject =
        NV_DD_VIDEO_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT;

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.OffsetIn =
        (dwDstYOffset + 1);

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.OffsetOut =
        (dwDstYOffset + 1 + dwDstYPitch);

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.PitchIn =
        (dwDstYPitch << 1);

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.PitchOut =
        (dwDstYPitch << 1);

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.LineLengthIn =
        (dwDstYPitch >> 1);

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.LineCount =
        (DWORD)pSurf_gbl->wHeight >> 1;

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.Format =
        (2 << 8) | 2;
        //NV_MTMF_FORMAT_INPUT_INC_2 | NV_MTMF_FORMAT_OUTPUT_INC_2;

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.BufferNotify = 0;

        ppdev->dDrawSpareSubchannelObject = 0;
        ppdev->NVFreeCount = (short)freeCount;
        }

    lpUnlockData->ddRVal = DD_OK;

    ppdev->pfnWaitEngineBusy(ppdev);
    EXIT_DMA_PUSH_SYNC(DDHAL_DRIVER_HANDLED);

    } /* Nv4UnlockOverlay */

extern "C" VOID __cdecl NvTurnOffVideoOverlay(PDEV *ppdev)
{
    FAST Nv3ChannelPio  *npDev = (Nv3ChannelPio *)ppdev->ddChannelPtr;
    FAST USHORT     freeCount = ppdev->NVFreeCount;

    WAIT_OVERLAY_NOTIFIER(0);
    WAIT_OVERLAY_NOTIFIER(1);

    while (freeCount < 3*4)
        freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);
    freeCount -= 3*4;

    npDev->dDrawSpare.SetObject = NV_DD_VIDEO_OVERLAY;
    npDev->dDrawSpare.Nv04VideoOverlay.StopOverlay[0] = NV07A_STOP_OVERLAY_AS_SOON_AS_POSSIBLE;
    npDev->dDrawSpare.Nv04VideoOverlay.StopOverlay[1] = NV07A_STOP_OVERLAY_AS_SOON_AS_POSSIBLE;

    ppdev->dDrawSpareSubchannelObject = NV_DD_VIDEO_OVERLAY;

    WAIT_OVERLAY_NOTIFIER(0);
    WAIT_OVERLAY_NOTIFIER(1);

    ppdev->NVFreeCount = (short)freeCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\bank.c ===
//******************************Module*Header***********************************
//
// Module Name: bank.c
//
// Contains all the banking code for the display driver.
//
// It's helpful not to have to implement all the DDI drawing functionality
// in a driver (who wants to write the code to support true ROP4's with
// arbitrary sized patterns?).  Fortunately, we can punt to GDI for any
// drawing we don't want to do.  And if GDI can write directly on the frame
// buffer bits, performance won't even be toooo bad.
//
// NT's GDI can draw on any standard format frame buffer.  When the entire
// frame buffer can be mapped into main memory, it's very simple to set up:
// the display driver tells GDI the frame buffer format and location, and
// GDI can then just draw directly.
//
// When only one bank of the frame buffer can be mapped into main memory
// at one time (e.g., there is a moveable 64k aperture) things are not
// nearly so easy.  For every bank spanned by a drawing operation, we have
// to set the hardware to the bank, and call back to GDI.  We tell GDI
// to draw only on the mapped-in bank by mucking with the drawing call's
// CLIPOBJ.
//
// This module contains the code for doing all banking support.
//
// This code supports 8, 16 and 32bpp colour depths, arbitrary bank
// sizes, and handles 'broken rasters' (which happens when the bank size
// is not a multiple of the scan length; some scans will end up being
// split over two separate banks).
//
// Note:  If you mess with this code and break it, you can expect to get
//        random access violations on call-backs in internal GDI routines
//        that are very hard to debug.
//
// Copyright (c) 1993-1996 Microsoft Corporation
//
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"
#include "driver.h"


//******************************************************************************
// Extern declearations
//******************************************************************************

VOID NV3ScreenToMemoryDMA(PDEV*,BYTE** ,LONG ,BYTE** ,LONG ,LONG ,LONG ,BOOL );

//******************************Public*Routine**********************************
//
// Function: vAlignedCopy
//
// Routine Description:
//
//      Copies the given portion of a bitmap, using dword alignment for the
//      screen.  Note that this routine has no notion of banking.
//
//      Updates ppjDst and ppjSrc to point to the beginning of the next scan.
//
// Arguments:
//
//      ppdev - Pointer to the physical device structure
//
// Return Value:
//
//******************************************************************************


VOID vAlignedCopy(
PDEV*   ppdev,
BYTE**  ppjDst,
LONG    lDstDelta,
BYTE**  ppjSrc,
LONG    lSrcDelta,
LONG    cjScan,
LONG    cyScan,
BOOL    bDstIsScreen)

    {
    BYTE* pjDst;
    BYTE* pjSrc;
    LONG  cjMiddle;
    LONG  culMiddle;
    LONG  cjStartPhase;
    LONG  cjEndPhase;
    LONG i;

    //**************************************************************************
    // Get source and destination pointers
    //**************************************************************************

    pjSrc = *ppjSrc;
    pjDst = *ppjDst;

    //**************************************************************************
    // If Screen is the SOURCE, then align the copy according to the SOURCE.
    // If Screen is the DEST,   then align the copy according to the DEST.
    //
    // Careful:  Phase is 0 if on a byte 0 boundary.
    //           Phase is 3 if on a byte 1 boundary.
    //           Phase is 2 if on a byte 2 boundary.
    //           Phase is 1 if on a byte 3 boundary.
    //
    // cjStartPhase is the number of bytes we need to output first, before
    // we can start outputting the rest of the bytes.
    //**************************************************************************

    // Be aware of IA64 when doing ptr arithmetic !!
    cjStartPhase = (0 - ((bDstIsScreen) ? (LONG)(ULONG_PTR)pjDst : (LONG)(ULONG_PTR)pjSrc)) & 3;

    //**************************************************************************
    // Calculate Number of bytes remaing after outputting the 'starting' phase bytes.
    // We'll later calculate the final culMiddle and cjEndPhase from cjMiddle.
    //**************************************************************************

    cjMiddle     = cjScan - cjStartPhase;

    //**************************************************************************
    // For cases where cjMiddle is positive:
    //                                                  cjEndPhase      culMiddle
    //   cjScan     cjStartPhase    cjMiddle          (cjMiddle & 3)  (cjMiddle >> 2)
    //   ------     ------------    --------          --------------  ---------------
    //      1           0              1                    1            0
    //      1           1              0                    0            0
    //      1           2             neg                   -            -
    //      1           3             neg                   -            -
    //
    //      2           0              2                    2            0
    //      2           1              1                    1            0
    //      2           2              0                    0            0
    //      2           3             neg                   -            -
    //
    //      3           0              3                    3            0
    //      3           1              2                    2            0
    //      3           2              1                    1            0
    //      3           3              0                    0            0
    //
    //      4           0              4                    0            1
    //      4           1              3                    3            0
    //      4           2              2                    2            0
    //      4           3              1                    1            0
    //
    // The following condition always holds true in the above table.
    //
    //      cjStartPhase + (culMiddle * 4) +cjEndPhase  ==  cjScan
    //
    // EXCEPT for the cases where cjMiddle < 0.  So we must special case them.
    // Here, we'll just get rid of the starting phase.  The end result is that
    // for these case, bytes will only be output in the 'cjEndPhase'.
    //
    //**************************************************************************

    if (cjMiddle < 0)
        {
        cjStartPhase = 0;
        cjMiddle     = cjScan;
        }

    //**************************************************************************
    // Update the number of bytes we need to add to get to the next scanline,
    // after copying 'cjScan' bytes.
    //**************************************************************************

    lSrcDelta -= cjScan;
    lDstDelta -= cjScan;

    //**************************************************************************
    // EndPhase will be copied in bytes.
    // MiddlePhase will always be copied in DWORDS.
    // See description up above.
    //**************************************************************************

    cjEndPhase = cjMiddle & 3;
    culMiddle  = cjMiddle >> 2;

    //**************************************************************************
    // Ensure that graphics engine is idle before touching the framebuffer.
    //**************************************************************************
    ppdev->pfnWaitEngineBusy(ppdev);
    if (bDstIsScreen)

        {
        //**********************************************************************
        // Align to the destination (implying that the source may be
        // unaligned):  Occurs when copying MEMORY to SCREEN (Dest is aligned).
        // Copy scanlines at a time.
        //**********************************************************************

        for (; cyScan > 0; cyScan--)

            {
            //******************************************************************
            // Copy Bytes at a time
            //******************************************************************

            for (i = cjStartPhase; i > 0; i--)
                {
                *pjDst++ = *pjSrc++;
                }

            //******************************************************************
            // Copy Dwords at a time
            //******************************************************************

            for (i = culMiddle; i > 0; i--)
                {
                *((ULONG*) pjDst) = *((ULONG UNALIGNED *) pjSrc);
                pjSrc += sizeof(ULONG);
                pjDst += sizeof(ULONG);
                }

            //******************************************************************
            // Copy Bytes at a time
            //******************************************************************

            for (i = cjEndPhase; i > 0; i--)
                {
                *pjDst++ = *pjSrc++;
                }

            pjSrc += lSrcDelta;
            pjDst += lDstDelta;
            }
        }

    else

        {

        //**********************************************************************
        // Align to the source (implying that the destination may be
        // unaligned):  Occurs when copying SCREEN (Source is aligned) to MEMORY.
        // Copy scanlines at a time.
        //**********************************************************************

        for (; cyScan > 0; cyScan--)

            {
            //******************************************************************
            // Copy Bytes at a time
            //******************************************************************

            for (i = cjStartPhase; i > 0; i--)
                {
                *pjDst++ = *pjSrc++;
                }

            //******************************************************************
            // Copy Dwords at a time
            //******************************************************************

            for (i = culMiddle; i > 0; i--)
                {
                *((ULONG UNALIGNED *) pjDst) = *((ULONG*) (pjSrc));
                pjSrc += sizeof(ULONG);
                pjDst += sizeof(ULONG);
                }

           //*******************************************************************
           // Copy Bytes at a time
           //*******************************************************************

            for (i = cjEndPhase; i > 0; i--)
                {
                *pjDst++ = *pjSrc++;
                }

            pjSrc += lSrcDelta;
            pjDst += lDstDelta;
            }

        }

    //**************************************************************************
    // Save the updated pointers
    //**************************************************************************

    *ppjSrc = pjSrc;
    *ppjDst = pjDst;

    }

//******************************Public*Routine**********************************
//
// Function: vPutBits
//
// Routine Description:
//
//      Copies the bits from the given surface to the screen
//      Must be pre-clipped.  (Implement Memory to Screen blit here for
//      better performance???)
//
// Arguments:
//
//       ppdev - Pointer to the physical device structure
//
// Return Value:
//
//******************************************************************************

VOID vPutBits(
PDEV*       ppdev,
DSURF*      pdsurf,
SURFOBJ*    psoSrc,
RECTL*      prclDst)            // Absolute coordinates!

    {
    RECTL   rclDraw;
    LONG    iBank;
    LONG    cjOffset;
    LONG    cyScan;
    LONG    lDstDelta;
    LONG    lSrcDelta;
    BYTE*   pjDst;
    BYTE*   pjSrc;
    LONG    cjScan;
    LONG    iNewBank;
    LONG    cjRemainder;

    //**************************************************************************
    // We need a local copy of 'rclDraw' because we'll be iteratively
    // modifying 'top' and passing the modified rectangle back into
    // bBankComputeNonPower2:
    //**************************************************************************

    rclDraw = *prclDst;

    //**************************************************************************
    // Calculate the pointer to the upper-left corner of Destination rectangle (DFB)
    //**************************************************************************

    lDstDelta = pdsurf->LinearStride;
    pjDst     = pdsurf->LinearPtr;

    //**************************************************************************
    // Calculate the pointer to the upper-left corner of Source rectangle (DIB)
    //**************************************************************************

    lSrcDelta = psoSrc->lDelta;
    pjSrc     = (BYTE*) psoSrc->pvScan0;

    //**************************************************************************
    // Calculate number of scanlines to copy (cyScan), and
    // Calculate number of bytes to copy for each scanline (cjScan)
    //**************************************************************************

    cjScan = CONVERT_TO_BYTES((rclDraw.right  - rclDraw.left), ppdev);
    cyScan = (rclDraw.bottom - rclDraw.top);

    //**************************************************************************
    // Copy bytes. DIB (Memory) is source. DFB (Framebuffer) is destination
    //**************************************************************************

    vAlignedCopy(ppdev, &pjDst, lDstDelta, &pjSrc, lSrcDelta, cjScan, cyScan,
                     TRUE);             // Screen is the destination
    return;
    }

//******************************Public*Routine**********************************
//
// Function: vGetBits
//
// Routine Description:
//
//       Copies the bits to the given surface from the screen.
//       Currently, just uses straighforward software copy.  (later use DMA?)
//       Must be pre-clipped.
//
// Arguments:
//
//       ppdev - Pointer to the physical device structure
//
// Return Value:
//
//******************************************************************************


VOID vGetBits(
PDEV*       ppdev,
DSURF*      pdsurf,
SURFOBJ*    psoDst,
RECTL*      prclDst)        // Absolute coordinates!

    {
    LONG    iBank;
    LONG    cjOffset;
    LONG    cyScan;
    LONG    lDstDelta;
    LONG    lSrcDelta;
    BYTE*   pjDst;
    BYTE*   pjSrc;
    LONG    cjScan;
    LONG    iNewBank;
    LONG    cjRemainder;
    LONG    width,height;

    //**************************************************************************
    // Get source rectangle (Offscreen DFB rectangle)
    //**************************************************************************

    width  = (prclDst->right  - prclDst->left);
    height = (prclDst->bottom - prclDst->top);

    //**************************************************************************
    // Calculate the pointer to the upper-left corner of Source rectangle (DFB)
    //**************************************************************************

    lSrcDelta = pdsurf->LinearStride;
    pjSrc     = pdsurf->LinearPtr;

    //**************************************************************************
    // Calculate the pointer to the upper-left corner of Destination rectangle (DIB)
    //**************************************************************************

    lDstDelta = psoDst->lDelta;
    pjDst     = (BYTE*) psoDst->pvScan0;

    //**************************************************************************
    // Calculate number of scanlines to copy (cyScan), and
    // Calculate number of bytes to copy for each scanline (cjScan)
    //**************************************************************************

    cjScan = CONVERT_TO_BYTES(width, ppdev);
    cyScan = height;

    //**************************************************************************
    // Copy bytes. DFB (Framebuffer) is source. DIB (memory) is destination
    //**************************************************************************

    vAlignedCopy(ppdev, &pjDst, lDstDelta, &pjSrc, lSrcDelta, cjScan, cyScan, FALSE);

    return;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\bitblt.c ===
//**************************** Module Header ***********************************
//
// Module Name: bitblt.c
//
// Contains the high-level DrvBitBlt and DrvCopyBits functions.  The low-
// level stuff lives in the 'blt??.c' files.
//
// Note: Since we've implemented device-bitmaps, any surface that GDI passes
//       to us can have 3 values for its 'iType': STYPE_BITMAP, STYPE_DEVICE
//       or STYPE_DEVBITMAP.  We filter device-bitmaps that we've stored
//       as DIBs fairly high in the code, so after we adjust its 'pptlSrc',
//       we can treat STYPE_DEVBITMAP surfaces the same as STYPE_DEVICE
//       surfaces (e.g., a blt from an off-screen device bitmap to the screen
//       gets treated as a normal screen-to-screen blt).
//
//       Unfortunately, if we've created our primary surface as a device-
//       managed surface, it has an 'iType' of STYPE_BITMAP and not
//       STYPE_DEVICE.  So throughout this code, we will determine if a
//       surface is one of ours by checking 'dhsurf' -- a NULL value means
//       that it's a GDI-created DIB, otherwise it's one of our surfaces and
//       'dhsurf' points to our DSURF structure.
//
// Copyright (c) 1992-1996 Microsoft Corporation
//
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"
#include "driver.h"
#include "nvapi.h"
#include "oglDD.h"
#include "oglOverlay.h"
#include "oglsync.h"

VOID CopyDIBBitmaps (DSURF*, BYTE*, BYTE*, ULONG, ULONG); // forward declaration

typedef enum {
    NONE=0,
    COPYBLIT,
    IMAGEFROMCPU
} ALPHA_SAVE;


extern VOID NV4DmaPushAlphaPreserve(PPDEV, BOOL, BOOL);
#if _WIN32_WINNT >= 0x0500
extern VOID NV4DmaPushSetColorKey(PPDEV, ULONG, ULONG);
extern BOOL NV4CheckAlphaBlendOK(PPDEV);
extern BOOL NV4DmaPushCopyAlphaBlt(PPDEV, LONG, RECTL*, ULONG, POINTL*, RECTL*, BLENDOBJ*);
#endif _WIN32_WINNT >= 0x0500
    
//******************************************************************************
//
//  Function:   PrepareSurfacesForPunt
//
//  Routine Description:
//
//      GDI only knows how to write to standard DIB surfaces.
//      That means, if the SOURCE or DEST is a DFB, we need to create a standard
//      DIB SurfObj in place of the device managed surface (DFB) object in order
//      to let GDI do the blit.
//
//      Essentially, there are 4 types of SURFOBJS we'll encounter.
//
//              1) System Memory SurfObj (Standard DIB)
//                  We can pass this surfobj to GDI as is.
//
//              2) DFB - exists in offscreen VRAM memory
//                  Need to create a standard DIB SurfObj to let GDI draw to this surface
//
//              3) DFB - exists in system memory
//                  Need to create a standard DIB surfObj to let GDI draw to this surface
//
//              4) Primary Surface VRAM (Standard DIB format)
//                  We can pass this surfobj to GDI as is.
//
//              CONDITION                                           SURFOBJ TYPE
//              ---------                                           ------------
//
//      (pdsurf != NULL)  &&  (pdsurf->dt == DT_DIB)         --> This is a DFB in system memory
//      (pdsurf != NULL)  &&  (pdsurf->dt == DT_SCREEN)      --> This is a DFB in offscreen VRAM memory
//
//      (pdsurf == NULL)  &&  (pvBits != ppdev->pjScreen)    --> Standard DIB
//      (pdsurf == NULL)  &&  (pvBits == ppdev->pjScreen)    --> Primary Screen Surface
//
//  Arguments:
//
//      Src, Dst SURFOBJ pointers
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID PrepareSurfacesForPunt(
    SURFOBJ*    psoSrc,
    SURFOBJ*    psoDst,
    SURFOBJ**   pTempSrcSurfObjPtr,
    SURFOBJ**   pTempDstSurfObjPtr,
    PDEV*       ppdev
)
{
    DSURF*          pdsurfDst;
    DSURF*          pdsurfSrc;
    SURFOBJ*        SrcPuntPtr;
    SURFOBJ*        DstPuntPtr;

    //**************************************************************************
    // Default to Standard DIB, and get handles to surfaces if they exist
    //**************************************************************************

    (VOID *)pdsurfSrc = NULL;
    (VOID *)pdsurfDst = NULL;

    if ((VOID *)psoSrc != NULL)
        pdsurfSrc = (DSURF*) psoSrc->dhsurf;

    if ((VOID *)psoDst != NULL)
        pdsurfDst = (DSURF*) psoDst->dhsurf;

    //**************************************************************************
    // Default to using the original, un-modified SURFOBJ's that were passed to us.
    //**************************************************************************

    *pTempSrcSurfObjPtr = psoSrc;
    *pTempDstSurfObjPtr = psoDst;

    //**************************************************************************
    // Get pointers to the 'wrapper' surfaces that we use to draw to the
    // screen surface if necessary.  These surfaces are locked.
    // (The surfaces that we pass to GDI MUST be locked).
    // See EnableOffscreenHeap for more information.
    //**************************************************************************

    SrcPuntPtr = ppdev->psoPunt;
    DstPuntPtr = ppdev->psoPunt2;

    //**************************************************************************
    // Check if source bitmap is a DFB.  If so, create a temporary surfobj
    // (mapped to the screen) that GDI can read from
    //**************************************************************************

    if (pdsurfSrc !=0 )
        {
        SrcPuntPtr->dhsurf      = 0;                    // Behave like a standard DIB
        if (pdsurfSrc->dt == DT_SCREEN)
            {
            SrcPuntPtr->sizlBitmap  = pdsurfSrc->sizl;
            SrcPuntPtr->cjBits  = pdsurfSrc->LinearStride * pdsurfSrc->sizl.cy;
            SrcPuntPtr->pvBits  = pdsurfSrc->LinearPtr;
            SrcPuntPtr->pvScan0 = pdsurfSrc->LinearPtr;
            SrcPuntPtr->lDelta  = pdsurfSrc->LinearStride;
            // adi we cannot use the ppdev->iBitmapFormat because we may have to do
            // with a surface wrapped around a DD surface by DrvDeriveSurface
            SrcPuntPtr->iBitmapFormat = psoSrc->iBitmapFormat;
            }
        else
            {
            //**********************************************************************
            // This is a DFB which is stored in main memory as a DIB
            //**********************************************************************
            SrcPuntPtr->sizlBitmap  = pdsurfSrc->pso->sizlBitmap;
            SrcPuntPtr->cjBits      = pdsurfSrc->pso->lDelta * pdsurfSrc->pso->sizlBitmap.cy;
            SrcPuntPtr->pvBits  = pdsurfSrc->pso->pvBits;
            SrcPuntPtr->pvScan0 = pdsurfSrc->pso->pvScan0;
            SrcPuntPtr->lDelta  = pdsurfSrc->pso->lDelta;
            SrcPuntPtr->iBitmapFormat = pdsurfSrc->pso->iBitmapFormat;
            }

        //**********************************************************************
        // Use the 'wrapper' surface, instead of the original DFB surfobj for GDI
        //**********************************************************************

        *pTempSrcSurfObjPtr       = SrcPuntPtr;
        }


    //**************************************************************************
    // Check if destination bitmap is a DFB.  If so, create a temporary surfobj
    // (mapped to the screen) that GDI can write on
    //**************************************************************************

    if (pdsurfDst !=0 )
        {
        DstPuntPtr->dhsurf      = 0;                    // Behave like a standard DIB
        if (pdsurfDst->dt == DT_SCREEN)
            {
            DstPuntPtr->sizlBitmap  = pdsurfDst->sizl;
            DstPuntPtr->cjBits  = pdsurfDst->LinearStride * pdsurfDst->sizl.cy;
            DstPuntPtr->pvBits  = pdsurfDst->LinearPtr;
            DstPuntPtr->pvScan0 = pdsurfDst->LinearPtr;
            DstPuntPtr->lDelta  = pdsurfDst->LinearStride;
            // adi we cannot use the ppdev->iBitmapFormat because we may have to do
            // with a surface wrapped around a DD surface by DrvDeriveSurface
            DstPuntPtr->iBitmapFormat = psoDst->iBitmapFormat;
            }
        else
            {
            //**********************************************************************
            // This is a DFB which is stored in main memory as a DIB
            //**********************************************************************
            DstPuntPtr->sizlBitmap  = pdsurfDst->pso->sizlBitmap;
            DstPuntPtr->cjBits      = pdsurfDst->pso->lDelta * pdsurfDst->pso->sizlBitmap.cy;
            DstPuntPtr->pvBits  = pdsurfDst->pso->pvBits;
            DstPuntPtr->pvScan0 = pdsurfDst->pso->pvScan0;
            DstPuntPtr->lDelta  = pdsurfDst->pso->lDelta;
            DstPuntPtr->iBitmapFormat = pdsurfDst->pso->iBitmapFormat;
            }

        //**********************************************************************
        // Use the 'wrapper' surface, instead of the original DFB surfobj for GDI
        //**********************************************************************

        *pTempDstSurfObjPtr       = DstPuntPtr;
        }
}


//******************************************************************************
//
//  Macro:   TRY_MOVE_SRC_TO_OFFSCREEN_MEM
//
//  Macro Description:
//
//      check and see if we can move system memory DFB's back into                  
//      offscreen VRAM for better performance. That is, at some point, we put a DFB 
//      in system memory. Now we determine that if this DFB is getting              
//      used a lot, put it back in offscreen VRAM so we can regain performance.     
//
//*****************************************************************************
#define TRY_MOVE_SRC_TO_OFFSCREEN_MEM(psoSrc, pdsurfSrc, pxlo, ppdev)                           \
{                                                                                               \
    if ( (pdsurfSrc != NULL) && (pdsurfSrc->dt == DT_DIB) )                                     \
        {                                                                                       \
        /***********************************************************************/               \
        /* Here we consider putting a DIB DFB back into off-screen             */               \
        /* memory.  If there's a translate, it's probably not worth            */               \
        /* moving it since we won't be able to use the hardware to do          */               \
        /* the blt (a similar argument could be made for weird rops            */               \
        /* and stuff that we'll only end up having GDI simulate, but           */               \
        /* those should happen infrequently enough that I don't care).         */               \
        /***********************************************************************/               \
        if ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL))                                     \
            {                                                                                   \
            ASSERTDD(pdsurfSrc->pso->iBitmapFormat == ppdev->iBitmapFormat, "oops");            \
                                                                                                \
            if (pdsurfSrc->iUniq == ppdev->iHeapUniq)                                           \
                {                                                                               \
                /*****************************************************************/             \
                /* Attempt to move DIB back to offscreen VRAM.                   */             \
                /* This won't necessarily succeed.                               */             \
                /*                                                               */             \
                /* NOTE: If space doesn't get freed up for a while (heapUniq     */             \
                /*       remains the same), and this call fails, then cBlt will  */             \
                /*       wrap around to 0xffffffff, meaning we won't consider    */             \
                /*       putting this DFB DIB back into offscreen VRAM for a     */             \
                /*       LONG time, until someone frees up some offscreen memory,*/             \
                /*       and causes cBlt to be reset to HEAP_COUNT_DOWN.         */             \
                /*****************************************************************/             \
                if (--pdsurfSrc->cBlt == 0)                                                     \
                    if (bMoveDibToOffscreenDfbIfRoom(ppdev, pdsurfSrc))                         \
                        {                                                                       \
                            /* Now in offscreen, ptrs OK as is so return */                     \
                            goto MoveComplete;                                                  \
                        }                                                                       \
                }                                                                               \
                else                                                                            \
                {                                                                               \
                /***************************************************************/               \
                /* Some space was freed up in off-screen memory,               */               \
                /* so reset the counter for this DFB:                          */               \
                /***************************************************************/               \
                pdsurfSrc->iUniq = ppdev->iHeapUniq;                                            \
                pdsurfSrc->cBlt  = HEAP_COUNT_DOWN;                                             \
                }                                                                               \
            }                                                                                   \
                                                                                                \
        psoSrc = pdsurfSrc->pso;                                                                \
        pdsurfSrc = (DSURF *) psoSrc->dhsurf;                                                   \
                                                                                                \
        }                                                                                       \
MoveComplete: ;                                                                                 \
}


//******************************************************************************
//
//  Function:   GenericBitBltAlpha
//
//  Routine Description:
//
//      Implements the workhorse routine of a display driver.
//      Called by DrvBitBlt and DrvAlphaBlend to do bit block transfers
//      Called by DrvCopyBits in some cases.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

BOOL GenericBitBltAlpha(
    SURFOBJ*    psoDst,
    SURFOBJ*    psoSrc,
    SURFOBJ*    psoMsk,
    CLIPOBJ*    pco,
    XLATEOBJ*   pxlo,
    RECTL*      prclDst,
    RECTL*      prclSrc,
    POINTL*     pptlSrc,
    POINTL*     pptlMsk,
    BRUSHOBJ*   pbo,
    POINTL*     pptlBrush,
    ROP4        rop4,
    BLENDOBJ*   pBlendObj,
    PDEV*       ppdev
)

    {
    DSURF*          pdsurfDst;
    DSURF*          pdsurfSrc;
    POINTL          ptlSrc;
    BYTE            jClip;
    BOOL            bMore;
    CLIPENUM        ce;
    LONG            c;
    RECTL           rcl;
    BYTE            rop3;
    FNFILL*         pfnFill;
    RBRUSH_COLOR    rbc;        // Realized brush or solid colour
    FNXFER*         pfnXfer;
    FNSCRNTOMEM*    pfnStoM;
    ULONG           iSrcBitmapFormat;
    ULONG           iDstBitmapFormat;
    ULONG           iDir;
    BOOL            bRet;
    ULONG*          CheckSurfPtr;
    ULONG*          CheckPdevPtr;
    ULONG*          ScreenBitmap;
    ULONG*          DstBits;
    ULONG*          SrcBits;
    ULONG           PatternColor;

    SURFOBJ*        SrcPuntPtr;
    SURFOBJ*        DstPuntPtr;
    SURFOBJ*        TempDstSurfObjPtr;
    SURFOBJ*        TempSrcSurfObjPtr;

    ULONG           SrcOffset;
    ULONG           DstOffset;
    ULONG           SrcStride;
    ULONG           DstStride;

    ALPHA_SAVE      alphaPreserve=NONE;

    //**************************************************************************
    // Assume successful blit
    //**************************************************************************

    bRet = TRUE;

    // Alpha only supported on Win2k
#if _WIN32_WINNT >= 0x0500

    if (pBlendObj)
        {
        // Trivially reject AlphaBlends we can't do
        if ((pxlo && pxlo->flXlate && !(pxlo->flXlate & XO_TRIVIAL) ) ||
            ((ppdev->iBitmapFormat != BMF_32BPP) && (ppdev->iBitmapFormat != BMF_16BPP)))
            {
            // Can't do translations with blends
            // Can't hw accelerate anything except 16,32 bpp desktop
            goto EngFallBack;
            }
        }    
    //**************************************************************************
    //  Fixes case where driver is called in full screen DOS during STRESS tests.
    //  In this case, GDI is allowed to call us to update DFBs that are stored in
    //  system memory, or offscreen memory. We need to wrap the surface and call
    //  EngBitBlt.
    //**************************************************************************

    if(!ppdev->bEnabled)
        goto EngFallBack;

#endif

    //**************************************************************************
    // Trivially reject calls we don't handle. We don't blt between host memory bitmaps.
    //**************************************************************************

    if (!IS_DEV_SURF(psoDst))
        {
        if (psoSrc == NULL)
            goto EngFallBack;
        else if (!IS_DEV_SURF(psoSrc))
            goto EngFallBack;
        }

    //**************************************************************************
    // This is a good place to examine offscreen memory visually for debugging.
    // purposes.  That's because there are difficulties when trying to output
    // DWORD values in the WinDbg debugger to NV hardware registers.
    // Apparently, when using WinDbg, it doesn't output dwords as dwords.
    // It seems to output them as 4 bytes. This can cause problems
    // with NV hardware since NV architecture expects all operations to be done
    // as dwords. As a result, in order to flip the buffer, we need to do it in
    // real 32-bit code, instead of manually in the debugger.
    //
    //
    //**************************************************************************

    //**************************************************************************
    // GDI will never give us a Rop4 with the bits in the high-word set
    // (so that we can check if it's actually a Rop3 via the expression
    // (rop4 >> 8) == (rop4 & 0xff)):
    //**************************************************************************

    ASSERTDD((rop4 >> 16) == 0, "Didn't expect a rop4 with high bits set");

    //**************************************************************************
    // For NV, our primary screen surface is a GDI-Managed bitmap, instead of a
    // DEVICE MANAGED surface.  This allows us to punt any call back to GDI
    // if necessary.  Therefore, pdsurfDst will be NULL when the destination
    // is the SCREEN.  pdsurfDst will be Non-NULL when the destination is a DFB.
    // As a result, we determine if the SURFOBJ is the primary surface by taking
    // a look at the 'pvBits' value.  If pvBits == ppdev->pjScreen, then the
    // surfobj is the primary surface.
    //**************************************************************************

    pdsurfDst = (DSURF*) psoDst->dhsurf;    // May be NULL since we created the
                                            // primary surface as a GDI Managed bitmap

    //**************************************************************************
    // Check to see if the dest is a device bitmap which has been moved to main
    // memory
    //**************************************************************************
    if ((pdsurfDst != NULL) && (pdsurfDst->dt == DT_DIB))
        {
        psoDst = pdsurfDst->pso;
        pdsurfDst = (DSURF *) psoDst->dhsurf;
        }

    //**************************************************************************
    // Check if this blit only involves a destination
    //**************************************************************************

    if (psoSrc == NULL)
        {
        //**********************************************************************
        // Since there is no source bitmap, the destination can be either a
        // DIB , DFB (DT_SCREEN), DFB(DT_DIB) or SCREEN surface.  Since we don't
        // handle blits to DIBs or system memory, we'll only handle blits
        // to the primary screen surface (SCREEN), or blits to DFB (DT_SCREEN).
        //
        //  1) DESTINATION = SCREEN
        //
        //        (pdsurfDst    == 0)               &&
        //        (DstBits      == ScreenBitmap)
        //
        //  2) DESTINATION = DFB (DT_SCREEN)
        //
        //        (pdsurfDst     != 0)              &&
        //        (pdsurfDst->dt == DT_SCREEN)      &&
        //        (DstBits       != ScreenBitmap)
        //
        //**********************************************************************

        //**********************************************************************
        // AlphaBlends need a source so assert if we don't have one. -paul
        //**********************************************************************
        ASSERTDD(!pBlendObj ,"AlphaBlend with no source bitmap!");

        //**********************************************************************
        // Fills are this function's "raison d'etre", so we handle them
        // as quickly as possible:
        //**********************************************************************

        //**********************************************************************
        // There will always be a destination so we don't have to check
        // for psoDst == NULL.
        //**********************************************************************

        DstBits         = (ULONG *)(psoDst->pvBits);
        ScreenBitmap    = (ULONG *)(ppdev->pjScreen);

        //**********************************************************************
        // Only handle blits to VRAM.  Send blits to system memory back to GDI.
        //**********************************************************************

        if (  ((pdsurfDst == 0) && (DstBits == ScreenBitmap))   ||
              ((pdsurfDst != 0) && (pdsurfDst->dt == DT_SCREEN))  )
            {
            //******************************************************************
            // Make sure it doesn't involve a mask (i.e., it's really a
            // Rop3):
            //******************************************************************

            rop3 = (BYTE) rop4;

            if ((BYTE) (rop4 >> 8) == rop3)

                {
                //**************************************************************
                // Since 'psoSrc' is NULL, the rop3 had better not indicate
                // that we need a source.
                //
                // Truth table for a Rop 3.           R
                //                                    O
                //                        (SD)        P
                //                  11  10  01  00    3
                //                  --------------
                //          (P) 1  | x   x   x   x    High nibble
                //              0  | x   x   x   x    Low nibble
                //
                //**************************************************************

                ASSERTDD((((rop4 >> 2) ^ (rop4)) & 0x33) == 0,
                             "Need source but GDI gave us a NULL 'psoSrc'");

                //**************************************************************
                // Default to solid fill
                //**************************************************************

                pfnFill = ppdev->pfnFillSolid;

                //**************************************************************
                // This will be a SOLID fill (No Source, No Pattern
                // unless the ROP says a pattern is required).
                // So check if Pattern is needed.  See truth table up above.
                //**************************************************************

                if(pbo == NULL)  // Black and White Rops do not need color
                    rbc.iSolidColor = (ULONG)-1;
                else
                    rbc.iSolidColor = pbo->iSolidColor;

                if ((((rop3 >> 4) ^ (rop3)) & 0xf) != 0)

                    {
                    //**********************************************************
                    // The rop says that a pattern is truly required
                    // (blackness, for instance, doesn't need one):
                    //**********************************************************

                    if (rbc.iSolidColor == -1)

                        {
                        //******************************************************
                        // Try and realize the pattern brush; by doing
                        // this call-back, GDI will eventually call us
                        // again through DrvRealizeBrush:
                        //******************************************************

                        rbc.prb = pbo->pvRbrush;
                        if (rbc.prb == NULL)

                            {
                            rbc.prb = BRUSHOBJ_pvGetRbrush(pbo);
                            if (rbc.prb == NULL)

                                {
                                //**********************************************
                                // If we couldn't realize the brush, let GDI handle
                                // the call (it may have been a non 8x8
                                // brush or something, which we can't be
                                // bothered to handle, so let GDI do the
                                // drawing):
                                //**********************************************

                                goto EngFallBack;
                                }
                            }

                        //******************************************************
                        // We've now determined that this a Pattern blit.
                        // Pattern will come from the Pattern brush.
                        //******************************************************

                        pfnFill = ppdev->pfnFillPat;

                        }

                    }


                //**************************************************************
                // Linear memory management
                // Set linear offset and stride for destination buffer
                //**************************************************************

                if (pdsurfDst != 0)
                    {
                    DstOffset = (ULONG)((BYTE *)(pdsurfDst->LinearPtr) - ppdev->pjFrameBufbase);
                    DstStride = pdsurfDst->LinearStride;
                    }

                else

                    {
                    //**********************************************************
                    // Use pitch settings of visible screen
                    //**********************************************************

                    DstOffset = ppdev->ulPrimarySurfaceOffset;
                    DstStride = ppdev->lDelta;
                    }

                ppdev->pfnSetDestBase(ppdev, DstOffset , DstStride);


                //**************************************************************
                // Solid and Pattern fills
                //**************************************************************

                //**************************************************************
                // Note that these 2 'if's are more efficient than
                // a switch statement:
                //**************************************************************

                if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))

                    {
                    //**********************************************************
                    // No clipping required
                    //**********************************************************
                    pfnFill(ppdev, 1, prclDst, rop4, rbc, pptlBrush);
                    goto All_Done;
                    }

                else if (pco->iDComplexity == DC_RECT)

                    {
                    //**********************************************************
                    // Clip to a single rectangle
                    //**********************************************************
                    if (bIntersect(prclDst, &pco->rclBounds, &rcl))
                        {
                        pfnFill(ppdev, 1, &rcl, rop4, rbc, pptlBrush);
                        }

                    goto All_Done;
                    }

                else

                    {
                    //**********************************************************
                    // Clip region must be enumerated
                    // For NV, do we need to worry about direction???
                    //**********************************************************
                    CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

                    do  {
                        bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

                        c = cIntersect(prclDst, ce.arcl, ce.c);

                        if (c != 0)
                            {
                            pfnFill(ppdev, c, ce.arcl, rop4, rbc, pptlBrush);
                            }

                        } while (bMore);
                    goto All_Done;
                    }

                } // if (BYTE) Rop4 >> 8) ...
                else
                    //*****************************************************
                    // This is a true Rop4, pass this call to GDI.
                    //*****************************************************
                    goto EngFallBack;

            }  // if (destination == VRAM)

        else

            {

            //******************************************************************
            // At this point, we know that there was no source, and that the
            // destination was a standard DIB or a DFB that was moved from
            // offscreen VRAM to system memory.  We won't handle these so just pass
            // them on to EngBitBlt
            //
            // We will also get to this point if the blit involved a MASK.
            //******************************************************************

            goto EngFallBack;
            }

        } // if (psoSrc == NULL)...

    //**************************************************************************
    // Before we handle blits which involve a source and destination,
    // check and see if we can move system memory DFB's back into
    // offscreen VRAM for better performance. That is, at some point, we put a DFB
    // in system memory. Now we determine that if this DFB is getting
    // used a lot, put it back in offscreen VRAM so we can regain performance.
    //
    // We know that at this point, psoSrc and psoDst will not be null.
    //**************************************************************************

    //**************************************************************************
    // Here we know psoSrc != NULL and psoDst should NOT be NULL !
    //**************************************************************************

    ASSERTDD(((VOID *)psoSrc != NULL), "Didn't expect a NULL source");
    ASSERTDD(((VOID *)psoDst != NULL), "Didn't expect a NULL destination");

    pdsurfDst = (DSURF*) psoDst->dhsurf;
    pdsurfSrc = (DSURF*) psoSrc->dhsurf;

    if ( (pdsurfSrc != NULL) && (pdsurfSrc->dt == DT_DIB) )

        {
        //**********************************************************************
        // Here we consider putting a DIB DFB back into off-screen
        // memory.  If there's a translate, it's probably not worth
        // moving it since we won't be able to use the hardware to do
        // the blt (a similar argument could be made for weird rops
        // and stuff that we'll only end up having GDI simulate, but
        // those should happen infrequently enough that I don't care).
        //**********************************************************************

        if ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)) {
            ASSERTDD(pdsurfSrc->pso->iBitmapFormat == ppdev->iBitmapFormat, "oops");
            //******************************************************************
            // See 'DrvCopyBits' for some more comments on how this
            // moving-it-back-into-off-screen-memory thing works:
            //******************************************************************

            if (pdsurfSrc->iUniq == ppdev->iHeapUniq) {
                //**************************************************************
                // Attempt to move DIB back to offscreen VRAM.
                // This won't necessarily succeed.
                //
                // NOTE: If space doesn't get freed up for a while (heapUniq
                //       remains the same), and this call fails, then cBlt will
                //       wrap around to 0xffffffff, meaning we won't consider
                //       putting this DFB DIB back into offscreen VRAM for a
                //       LONG time, until someone frees up some offscreen memory,
                //       and causes cBlt to be reset to HEAP_COUNT_DOWN.
                //**************************************************************

                if (--pdsurfSrc->cBlt == 0)
                    if (bMoveDibToOffscreenDfbIfRoom(ppdev, pdsurfSrc))
                              goto BltDstDevBmp;
            } else {
                
                //**************************************************************
                // Some space was freed up in off-screen memory,
                // so reset the counter for this DFB:
                //**************************************************************
                ASSERTDD(pdsurfSrc->pso->iBitmapFormat == ppdev->iBitmapFormat, "oops");

                pdsurfSrc->iUniq = ppdev->iHeapUniq;
                pdsurfSrc->cBlt  = HEAP_COUNT_DOWN;
            }

        }
        
        psoSrc = pdsurfSrc->pso;
        pdsurfSrc = (DSURF *) psoSrc->dhsurf;

    }

BltDstDevBmp:
    //**************************************************************************
    // Get pointers to the Destination and Source 'Bitmaps'
    // We'll use these to determine if the bitmap is ONSCREEN or not.
    //**************************************************************************

    DstBits = (ULONG *)(psoDst->pvBits);
    SrcBits = (ULONG *)(psoSrc->pvBits);
    ScreenBitmap = (ULONG *)(ppdev->pjScreen);

    //**************************************************************************
    // Bitmaps can be one of 4 types, resulting in 16 ways to do blits as follows
    //
    //
    // 1) DIB,  2) DFB (OFFSCREEN),  3) DFB (SYS MEMORY),   4) SCREEN
    //
    //
    //    DIB               to DIB                -> Will not handle - Punt to GDI
    //    DFB (OFFSCREEN)   to DIB                -> Will not handle - Punt to GDI
    //    DFB (SYS MEMORY)  to DIB                -> Will not handle - Punt to GDI
    // SCREEN               to DIB                -> Will not handle - Punt to GDI
    //
    //    DIB               to DFB (OFFSCREEN)    -> Handled
    //    DFB (OFFSCREEN)   to DFB (OFFSCREEN)    -> Handled (rare?)
    //    DFB (SYS MEMORY)  to DFB (OFFSCREEN)    -> Handled (rare?)
    // SCREEN               to DFB (OFFSCREEN)    -> Handled
    //
    //    DIB               to DFB (SYS MEMORY)   -> Will not handle - Punt to GDI
    //    DFB (OFFSCREEN)   to DFB (SYS MEMORY)   -> Will not handle - Punt to GDI ??
    //    DFB (SYS MEMORY)  to DFB (SYS MEMORY)   -> Will not handle - Punt to GDI ??
    // SCREEN               to DFB (SYS MEMORY)   -> Will not handle - Punt to GDI
    //
    //    DIB               to SCREEN             -> Handled
    //    DFB (OFFSCREEN)   to SCREEN             -> Handled
    //    DFB (SYS MEMORY)  to SCREEN             -> Handled
    // SCREEN               to SCREEN             -> Handled
    //
    //
    //      We'll only need to handle the following cases:  (Punt the rest to GDI)
    //      The reason we need to check against ScreenBitmap is that
    //      we've mapped the primary surface using EngCreateBitmap,
    //      so that we can let GDI draw directly to it.  Because of this,
    //      the primary surface is NOT a device managed surface, but rather
    //      a GDI-managed surface.  This means that pdsurf for the
    //      primary surface will be NULL.  So in order to determine
    //      if a surface corresponds to the primary screen surface,
    //      we simply check it's pointer against the ScreenBitmap pointer
    //
    //      Optional:  Since we started with a Dumb Frame Buffer driver using
    //                 EngCreateBitmap (primary surface is GDI-managed, not device
    //                 managed), we check if a standard DIB is the primary surface
    //                 by checking if pvBits == ScreenBitmap.  We can avoid
    //                 this by converting the primary surface to be device managed.
    //                 (EngCreateDeviceSurface). This would result in a more consistent
    //                 driver. (This is the original way it was done in the S3 driver).
    //                 However, we started with a Dumb Frame buffer driver, so
    //                 just leave it for now. It doesn't seem to make that much
    //                 of a difference except for a couple of extra 'if' statements.
    //
    //
    //      We only handle blits where the destination is VRAM, as follows:
    //
    //
    //  1) SCREEN to SCREEN             (CopyBlit)
    //
    //        pdsurfSrc == 0 && SrcBits == ScreenBitmap
    //        pdsurfDst == 0 && DstBits == ScreenBitmap
    //
    //  2) DFB (SYS MEMORY) to SCREEN   (Memory to Screen)
    //
    //        pdsurfSrc != 0 && pdsurfSrc->dt == DT_DIB     && SrcBits != ScreenBitmap;
    //        pdsurfDst == 0 && DstBits == ScreenBitmap
    //
    //  3) DFB (OFFSCREEN) to SCREEN    (CopyBlit)
    //
    //        pdsurfSrc != 0 && pdsurfSrc->dt == DT_SCREEN  &&  SrcBits != ScreenBitmap
    //        pdsurfDst == 0 && DstBits == ScreenBitmap
    //
    //  4) DIB to SCREEN                (Memory to Screen)
    //
    //        pdsurfSrc == 0 && SrcBits != ScreenBitmap;
    //        pdsurfDst == 0 && DstBits == ScreenBitmap
    //
    //  5) SCREEN to DFB (OFFSCREEN)    (CopyBlit)
    //
    //        pdsurfSrc == 0 && SrcBits == ScreenBitmap
    //        pdsurfDst != 0 && pdsurfDst->dt == DT_SCREEN  && DstBits != ScreenBitmap
    //
    //  6) DFB (SYS MEMORY) to DFB (OFFSCREEN)   (Memory to Screen)
    //
    //        pdsurfSrc != 0 && pdsurfSrc->dt == DT_DIB     && SrcBits != ScreenBitmap
    //        pdsurfDst != 0 && pdsurfDst->dt == DT_SCREEN  && DstBits != ScreenBitmap
    //
    //  7) DFB (OFFSCREEN) to DFB (OFFSCREEN)    (CopyBlit)
    //
    //        pdsurfSrc != 0 && pdsurfSrc->dt == DT_SCREEN  && SrcBits != ScreenBitmap
    //        pdsurfDst != 0 && pdsurfDst->dt == DT_SCREEN  && DstBits != ScreenBitmap
    //
    //  8) DIB to DFB (OFFSCREEN)       (Memory to Screen)
    //
    //        pdsurfSrc == 0 && SrcBits != ScreenBitmap
    //        pdsurfDst != 0 && pdsurfDst->dt == DT_SCREEN  DstBits != ScreenBitmap
    //
    //
    //      If the destination is system memory, then we send it back to GDI
    //
    //**************************************************************************

    //**************************************************************************
    // Determine the clipping type
    //**************************************************************************

    if (pco == NULL)
        jClip = DC_TRIVIAL;             // Don't have to worry about clipping
    else
        jClip = pco->iDComplexity;      // Use the CLIPOBJ-provided clipping


    //**************************************************************************
    // Check if DEST is to VRAM or SYSTEM MEMORY
    //**************************************************************************

    if ((DstBits == ScreenBitmap) ||
        ((pdsurfDst !=NULL) && (pdsurfDst->dt == DT_SCREEN)))

        {

        //**********************************************************************
        // Set linear offset and stride for destination buffer
        //**********************************************************************

        if (pdsurfDst != 0)
            {
            DstOffset = (ULONG)((BYTE *)(pdsurfDst->LinearPtr) - ppdev->pjFrameBufbase);
            DstStride = pdsurfDst->LinearStride;
            }
        else
            {
            DstOffset = ppdev->ulPrimarySurfaceOffset;
            DstStride = ppdev->lDelta;
            }

        //**********************************************************************
        // Check to see if this is an 8BPP VRAM to 8BPP VRAM with translation
        // If so, kick out the bitmap to system memory.
        //**********************************************************************
        
        if (ppdev->iBitmapFormat  == BMF_8BPP &&
            psoSrc->iBitmapFormat == BMF_8BPP &&
            pxlo != NULL                      && 
            (pxlo->flXlate & XO_TABLE)        &&
            pdsurfSrc != NULL                 && 
            (pdsurfSrc->dt == DT_SCREEN))

            {
                //
                // We can not flush the primary screen
                //
                if (psoSrc->iType != STYPE_DEVICE)
                { 
                    DISPDBG((3,"Kick out to system memory"));
                    pohMoveOffscreenDfbToDib(ppdev,pdsurfSrc->poh);
                }
            }

        //**********************************************************************
        // Set pitch and stride of destination buffer
        //**********************************************************************

        ppdev->pfnSetDestBase(ppdev, DstOffset , DstStride);

        //**********************************************************************
        // DEST is VRAM
        // Check if the ROP4 is really a ROP3
        //**********************************************************************


        if (((rop4 >> 8) & 0xff) == (rop4 & 0xff))
            {
            //******************************************************************
            // Since we've already handled the cases where the ROP4 is really
            // a ROP3 and no source is required, we can assert...
            //******************************************************************

            ASSERTDD((psoSrc != NULL) && (pptlSrc != NULL),
                   "Expected no-source case to already have been handled");

            //******************************************************************
            // Since the foreground and background ROPs are the same, we
            // don't have to worry about no stinking masks (it's a simple
            // Rop3).
            //******************************************************************

            rop3 = (BYTE) rop4;     // Make it into a Rop3 (we keep the rop4
                                    //  around in case we decide to punt)

            //******************************************************************
            // Check if a pattern is required
            //******************************************************************

            if ((rop3 >> 4) == (rop3 & 0xf))
                {
                //**************************************************************
                // The ROP3 doesn't require a pattern:
                // Check if the source is from VRAM or SYSTEM MEMORY
                //**************************************************************

                if ((SrcBits == ScreenBitmap)   ||
                    ((pdsurfSrc != NULL) && (pdsurfSrc->dt == DT_SCREEN)))

                    {
#if (_WIN32_WINNT >= 0x0500)
                    if ( ((rop3 == 0xcc) || pBlendObj) && 
                         (ppdev->iBitmapFormat == BMF_32BPP) )
                        {
                        alphaPreserve = COPYBLIT;
                        NV4DmaPushAlphaPreserve(ppdev, TRUE, FALSE); // Start=TRUE, FromCpu=FALSE
                        }
#endif // NT5
                    //**********************************************************
                    // Linear memory management
                    // Set linear offset and stride for source buffer
                    //**********************************************************

                    if (pdsurfSrc != 0)
                        {
                        SrcOffset = (ULONG)((BYTE *)(pdsurfSrc->LinearPtr) - ppdev->pjFrameBufbase);
                        SrcStride = pdsurfSrc->LinearStride;
                        }
                    else
                        {
                        SrcOffset = ppdev->ulPrimarySurfaceOffset;
                        SrcStride = ppdev->lDelta;
                        }

                    ppdev->pfnSetSourceBase(ppdev,SrcOffset,SrcStride);

                    //**********************************************************
                    // DEST is VRAM
                    // SOURCE is VRAM  (on-screen or off-screen)
                    //
                    // SCREEN TO SCREEN blt with no color translate
                    //**********************************************************

                    if ((pxlo == NULL) || (pBlendObj && !pxlo->flXlate) || (pxlo->flXlate & XO_TRIVIAL))
                        {
                        
                        if (jClip == DC_TRIVIAL)

                            {
                            //**************************************************
                            // No clipping required
                            //**************************************************
#if _WIN32_WINNT >= 0x0500
                            if (pBlendObj)
                                {
                                if (!NV4DmaPushCopyAlphaBlt(ppdev, 1, prclDst, rop4, pptlSrc, prclDst, pBlendObj))
                                    {
                                    goto EngFallBack; // Routine returned failure - must punt
                                    }
                                goto All_Done;
                                }
#endif _WIN32_WINNT >= 0x0500

                            ppdev->pfnCopyBlt(ppdev, 1, prclDst, rop4, pptlSrc, prclDst, pBlendObj);
                            goto All_Done;
                            }

                        else if (jClip == DC_RECT)

                            {
                            //**************************************************
                            // Clip to a single rectangle
                            //**************************************************

                            if (bIntersect(prclDst, &pco->rclBounds, &rcl))
                                {
#if _WIN32_WINNT >= 0x0500
                                if (pBlendObj)
                                    {
                                    if (!NV4DmaPushCopyAlphaBlt(ppdev, 1, &rcl, rop4, pptlSrc, prclDst, pBlendObj))
                                        {
                                        goto EngFallBack; // Routine returned failure - must punt
                                        }
                                    goto All_Done;
                                    }
#endif _WIN32_WINNT >= 0x0500
                                ppdev->pfnCopyBlt(ppdev, 1, &rcl, rop4, pptlSrc, prclDst, pBlendObj);
                                }

                            goto All_Done;
                            }

                        else

                            {
                            //**************************************************
                            // Clip region must be enumerated
                            //**************************************************

                            if (pptlSrc->y >= (prclDst->top))
                                {
                                if (pptlSrc->x >= (prclDst->left))
                                    iDir = CD_RIGHTDOWN;
                                else
                                    iDir = CD_LEFTDOWN;
                                }
                            else
                                {
                                if (pptlSrc->x >= (prclDst->left))
                                    iDir = CD_RIGHTUP;
                                else
                                    iDir = CD_LEFTUP;
                                }

                            CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES,
                                                 iDir, 0);

                            do  {
                                bMore = CLIPOBJ_bEnum(pco, sizeof(ce),
                                                        (ULONG*) &ce);

                                c = cIntersect(prclDst, ce.arcl, ce.c);

                                if (c != 0)
                                    {
#if _WIN32_WINNT >= 0x0500
                                    if (pBlendObj)
                                        {
                                        if (!NV4DmaPushCopyAlphaBlt(ppdev, c, ce.arcl, rop4, pptlSrc, prclDst, pBlendObj))
                                            {
                                            goto EngFallBack; // Routine returned failure - must punt
                                            }
                                        }
                                        else
                                        {
#endif _WIN32_WINNT >= 0x0500
                                        ppdev->pfnCopyBlt(ppdev, c, ce.arcl, rop4, pptlSrc, prclDst, pBlendObj);
#if _WIN32_WINNT >= 0x0500
                                        }
#endif _WIN32_WINNT >= 0x0500


                                    }

                                } while (bMore);
                             goto All_Done;

                            }

                        } // if (pxlo == NULL)...

                    } // if (psoSrc !=NULL) ....

                else

                    {

                    //**********************************************************
                    // DEST is VRAM
                    // SOURCE is SYSTEM MEMORY
                    //**********************************************************

                    iSrcBitmapFormat = psoSrc->iBitmapFormat;
                    iDstBitmapFormat = ppdev->iBitmapFormat;

                    if (iSrcBitmapFormat == BMF_1BPP)

                        {
                        //******************************************************
                        // Transfer from a 1bpp bitmap
                        //******************************************************
                        pfnXfer = ppdev->pfnXfer1bpp;
                        goto Xfer_It;
                        }

                    else if (((iSrcBitmapFormat == iDstBitmapFormat) ||
                              (pBlendObj && (iDstBitmapFormat == BMF_16BPP) && (iSrcBitmapFormat == BMF_32BPP)) )
                             &&
                             ((pxlo == NULL) || (pBlendObj && !pxlo->flXlate) || (pxlo->flXlate & XO_TRIVIAL)))
                        {

                        //******************************************************
                        // Transfer from bitmap with SAME pixel depth
                        //******************************************************

#if (_WIN32_WINNT >= 0x0500)
                        // effectively an RGB bitmap, so preserve alpha
                        if ( ((rop3 == 0xcc) || pBlendObj) && 
                             (ppdev->iBitmapFormat == BMF_32BPP) )
                            {
                            alphaPreserve = IMAGEFROMCPU;
                            NV4DmaPushAlphaPreserve(ppdev, TRUE, TRUE); // Start=TRUE, FromCpu=TRUE
                            }
#endif // NT5

                        pfnXfer = ppdev->pfnXferNative;
                        goto Xfer_It;

                        }

                    else if ((iSrcBitmapFormat == BMF_4BPP) &&
                             (iDstBitmapFormat == BMF_8BPP))

                        {
                        //******************************************************
                        // Transfer from 4bpp Source Bitmap
                        // to 8bpp Destination Bitmap
                        //******************************************************

                        pfnXfer = ppdev->pfnXfer4bpp;
                        goto Xfer_It;
                        }

                    else if (((iSrcBitmapFormat == BMF_8BPP) ||
                              (iSrcBitmapFormat == BMF_4BPP)) &&
                             ((iDstBitmapFormat == BMF_32BPP) ||
                              (iDstBitmapFormat == BMF_16BPP)) &&
                              (pxlo!=NULL) &&
                              (pxlo->flXlate & XO_TABLE))
                        {

                        //******************************************************
                        // Use hardware Indexed Image to transfer from 4bpp or 8bpp
                        // source bitmap to 16bpp or 32bpp destination bitmap
                        //******************************************************

                        pfnXfer = ppdev->pfnIndexedImage;

                        if (pfnXfer != NULL)
                            goto Xfer_It;
                        }

                    } // DEST is VRAM, SRC is SYSTEM MEMORY

                } // ...if (pattern NOT required)

            else

                {
                //**************************************************************
                // Blit is to VRAM, we have a source bitmap in system memory,
                // AND a pattern is required
                //**************************************************************

                ASSERTDD(!pBlendObj ,"No AlphaBlends with patterns");

                if (  ((pdsurfSrc != NULL) && (pdsurfSrc->dt == DT_DIB)) ||
                       (pdsurfSrc == NULL) && (SrcBits !=ScreenBitmap))
                    {

                    //**********************************************************
                    // Need to check clipping here too !!!  We'll only handle simple clipping for now...
                    //**********************************************************

                    //**********************************************************
                    // If iSolidColor == 0xffffffff and pvRbrush == NULL, that means
                    // the brush has not yet been realized.  This is our cue to call
                    // BRUSHOBJ_pvGetRBrush which will call our DrvRealizeBrush function
                    //**********************************************************

                    rbc.iSolidColor = pbo->iSolidColor;

                    //**********************************************************
                    // Prepare to use solid pattern color
                    //**********************************************************

                    PatternColor = rbc.iSolidColor;

                    if (rbc.iSolidColor == -1)

                        {
                        //******************************************************
                        // Try and realize the pattern brush; by doing
                        // this call-back, GDI will eventually call us
                        // again through DrvRealizeBrush:
                        //******************************************************

                        //******************************************************
                        // TODO:  ... Implement ROP3 Pattern,Source,Destination
                        //            blits for non-solid brushes for better
                        //            performance.  We currently don't support
                        //            Colored Brushes.  We only support
                        //            monochrome brushes right now...
                        //******************************************************

                        goto EngFallBack;

                        //******************************************************
                        // Need to test if this works...
                        //******************************************************

                        rbc.prb = pbo->pvRbrush;
                        if (rbc.prb == NULL)

                            {
                            rbc.prb = BRUSHOBJ_pvGetRbrush(pbo);
                            if (rbc.prb == NULL)

                                {
                                //**********************************************
                                // If we couldn't realize the brush, punt
                                // the call (it may have been a non 8x8
                                // brush or something, which we can't be
                                // bothered to handle, so let GDI do the
                                // drawing):
                                //**********************************************

                                goto EngFallBack;
                                }
                            }

                        }

                    //**********************************************************
                    // At this point, let's check if it's a monochrome bitmap that's being passed
                    // to us.  If so, we can do it using IMAGE_MONO_FROM_CPU.
                    //**********************************************************

                    iSrcBitmapFormat = psoSrc->iBitmapFormat;
                    if (iSrcBitmapFormat == BMF_1BPP)

                        {
                        //******************************************************
                        // Transfer from a 1bpp bitmap
                        //******************************************************

                        pfnXfer = ppdev->pfnXfer1bpp;
                        goto Xfer_It;
                        }

                    //**********************************************************
                    // Be careful!  When swithing modes with the display applet,
                    // GDI will NOT update the SrcBitmap formats to agree with the
                    // new resolution.  If you started NT at 16bpp, the source bitmap format
                    // will be 16bpp.  But if you mode switch to 8bpp, the source bitmap
                    // format will remain at 16bpp. Beware....performance tests will run
                    // better if you do NOT do mode switches!
                    //**********************************************************

                    if (iSrcBitmapFormat == ppdev->iBitmapFormat)
                        {

                        //******************************************************
                        // DEST is SCREEN
                        // SOURCE is MEMORY
                        // PATTERN is required as well
                        //******************************************************

#if _WIN32_WINNT >= 0x0500
                        if(iSrcBitmapFormat == BMF_16BPP)
                        {
                            // On WIN2K Multi-Monitors support,  the GDI passed the
                            // 15BPP format source bitmap to us.  Make additional call
                            // to check whether it is 15BPP format bitmap
                        
                            ULONG   RGBFields[3] = { 0, 1, 2};
                            ULONG   ulXret;
                        
                            ulXret = XLATEOBJ_cGetPalette(pxlo, XO_SRCBITFIELDS, 3, RGBFields);
                            
                            if(ulXret && RGBFields[1] == 0x03E0)
                            {
                                // It is 15BPP format bitmap; our driver only handle 16Bpp bitmap
                                // punt back to GDI.
                                DISPDBG((5, "XLATEOBJ_cGetPalette returned %ld and { %x, %x, %x }",
                                    ulXret, RGBFields[0], RGBFields[1], RGBFields[2]));
                            
                                goto EngFallBack;
                            
                            }
                            
                        }
#endif                        
                        rop3 = (BYTE) rop4;

                        if (jClip == DC_TRIVIAL)
                        {
                            ppdev->pfnMemToScreenPatternBlt(ppdev,
                                                          psoSrc,
                                                          pptlSrc,
                                                          prclDst,
                                                          (ULONG)rop3,
                                                          &rbc,
                                                          NULL);
                        }
                        else if (jClip == DC_RECT)
                        {
                            if (bIntersect(prclDst, &pco->rclBounds, &rcl))
                            {
                                    ppdev->pfnMemToScreenPatternBlt(ppdev,
                                                          psoSrc,
                                                          pptlSrc,
                                                          prclDst,
                                                          (ULONG)rop3,
                                                          &rbc,
                                                          &rcl);
                            }
                        }
                        else
                        {
                                //**********************************************************************
                                // Clip region must be enumerated
                                //**********************************************************************

                                CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

                                do  {
                                    bMore = CLIPOBJ_bEnum(pco, sizeof(ce),
                                        (ULONG*) &ce);

                                    c = cIntersect(prclDst, ce.arcl, ce.c);

                                    if (c != 0)
                                    {
                                        ppdev->pfnMemToScreenPatternBlt(ppdev,
                                                          psoSrc,
                                                          pptlSrc,
                                                          prclDst,
                                                          (ULONG)rop3,
                                                          &rbc,
                                                          ce.arcl);
                                    }
                                } while (bMore);
                        }

                        goto All_Done;
                        }

                    } // Make sure source is from system memory
                 
                

                else  // else (Source is from VRAM)    ( dest is to vram and we need a pattern )
                    {
                        // VRAM->VRAM + PATTERN BLITS

                        // Check if brush is needed ( StoS + Non-Solid Pat. )
    
                        if (pbo->iSolidColor == 0xFFFFFFFF )
                        {
                            //******************************************************
                            // Realize the pattern brush if it's ptr is NULL
                            //******************************************************
    
                            if (pbo->pvRbrush == NULL)
                            {
                                pbo->pvRbrush = BRUSHOBJ_pvGetRbrush(pbo);
                                if (pbo->pvRbrush == NULL)
                                {
                                    //**********************************************
                                    // If we couldn't realize the brush, let GDI handle
                                    // the call (it may have been a non 8x8
                                    // brush or something, which we can't be
                                    // bothered to handle, so let GDI do the
                                    // drawing):
                                    //**********************************************
                                    goto EngFallBack;
                                }
                            }
                        }
                        
                        //**********************************************************************
                        // Linear memory management
                        // Set linear offset and stride for source buffer
                        //**********************************************************************
            
                        if (pdsurfSrc != 0)
                            {
                            SrcOffset = (ULONG)( (BYTE *)(pdsurfSrc->LinearPtr) - ppdev->pjFrameBufbase);
                            SrcStride = pdsurfSrc->LinearStride;
                            }
                        else           
                            {
                            SrcOffset = ppdev->ulPrimarySurfaceOffset;
                            SrcStride = ppdev->lDelta;
                            }
            
                        (ppdev->pfnSetSourceBase)(ppdev,SrcOffset,SrcStride);
            
                        // pfnSetDestBase was already called at that point
            
                        if( 
                            (ppdev->pfnScreenToScreenWithPatBlt != NULL )             &&  // function exist
                            ( (pxlo==NULL) || (pxlo->flXlate & XO_TRIVIAL) )          &&  // no translation
                            ( jClip == DC_TRIVIAL )                                       // trivial clipping
                            
                          ) 
                        {
            
                            (ppdev->pfnScreenToScreenWithPatBlt)(      ppdev, 
                                                                           1, 
                                                                     prclDst, 
                                                                     pptlSrc, 
                                                                     prclDst,
                                                                         pbo,
                                                                   pptlBrush,
                                                                        rop4  );
            
                            goto All_Done;
            
            
                        }
                    
                    } // ...else (Source is from VRAM)    ( dest is to vram and we need a pattern )

                } // ...else( pattern IS required)

            } // ...if (not a Rop4)

        } // ...if (DstBits == ScreenBitmap)

    else

        {

        //**********************************************************************
        // DEST is SYSTEM MEMORY
        //**********************************************************************

        //**********************************************************************
        // Can't support AlphaBlend to system memory
        // Only supported on Win2k
        //**********************************************************************

#if _WIN32_WINNT >= 0x0500
        
        if (pBlendObj)
            {
            goto EngFallBack;
            }

#endif //_WIN32_WINNT >= 0x0500
         
            

            if ((SrcBits == ScreenBitmap) ||
                ((pdsurfSrc != NULL) && (pdsurfSrc->dt == DT_SCREEN)))
            {
                //******************************************************************
                // DEST is SYSTEM MEMORY
                // SOURCE is VRAM
                //******************************************************************
                
                // Check to see if we have trivial clipping and source copy rop...
                //
                
                if (
                     ( jClip == DC_TRIVIAL )                               &&
                     ( ( (rop4 >> 8) & 0xff  ) == (rop4 & 0xff) )          &&
                     ( (rop4 & 0xff) == 0xcc   )                                
                   )
                {
    
                    //******************************************************************
                    // Check if this is a color to monochrome bitmap conversion
                    //******************************************************************
        
                    if ( (psoDst->iBitmapFormat == BMF_1BPP)                    &&
                         (ppdev->iBitmapFormat != BMF_24BPP)                    &&
                         ( (pxlo!=NULL) && (pxlo->flXlate & XO_TO_MONO)  )
                       )
                    {
                       //**************************************************************
                       // ScreenTo1Bpp will return TRUE is successful.
                       // Otherwise, the call will be punted (this probably means
                       // the temporary buffer wasn't large enough to handle the blit)
                       //**************************************************************
        
                       if (ppdev->pfnScreenTo1BppMemBlt != NULL)
                       {
                           if ( (ppdev->pfnScreenTo1BppMemBlt)(ppdev, 1, prclDst, psoSrc, psoDst, pptlSrc, prclDst, pxlo ) == TRUE)
                               goto All_Done;
                       }
                       
                    } //... if ScreenTo1Bpp (Screen->SysMem)
    
                    //
                    // Else check to see if formats are equal...
                    //
                    else if(
                               ( psoDst->iBitmapFormat == ppdev->iBitmapFormat )     && // if
                               ( (pxlo==NULL) || (pxlo->flXlate & XO_TRIVIAL) )         // no translation
                           )
                    {
                        // Formats are equal, we don't need to do any xlate,
                        // so use the general ScreenToMemBlt
    
                        if (ppdev->pfnScreenToMemBlt != NULL )
                        {
                    
                           if ( (ppdev->pfnScreenToMemBlt)(   ppdev, 
                                                                  1, 
                                                            prclDst, 
                                                             psoSrc, 
                                                             psoDst, 
                                                            pptlSrc, 
                                                            prclDst, 
                                                               pxlo  ) == TRUE )
                               goto All_Done;
                        }
                    }
                    
                    else // else color translation is needed.
                    {
    
                        // Formats are not equal, handle 32,16 -> 4 or 8 bpp blits
                        // 
                        switch(ppdev->cjPelSize)  // All the frame buffer is the same format at this time so
                        {                         // we use cjPelSize in ppdev to see what's the dest format
                        case 4: 
                            switch(psoDst->iBitmapFormat)
                            {
                            case BMF_4BPP:
                                pfnStoM = ppdev->pfnScreenToMem32to4bppBlt;
                                break;
                      
                            case BMF_8BPP:
                                pfnStoM = ppdev->pfnScreenToMem32to8bppBlt;
                                break;
                      
                            default:
                                goto EngFallBack;
                            }
                      
                            break; // if SRC == 32 bit/pixel
                      
                        case 2:
                      
                            //goto EngFallBack; // UNTESTED !! (the code is there tough)
                      
                            switch(psoDst->iBitmapFormat)
                            {
                            case BMF_4BPP:
                      
                                pfnStoM = ppdev->pfnScreenToMem16to4bppBlt;
                                break;
                      
                            case BMF_8BPP:
                      
                                pfnStoM = ppdev->pfnScreenToMem16to8bppBlt;
                                break;
                      
                            default:
                                goto EngFallBack;
                            }
                      
                            break; // if SRC == 16 bit/pixel
                      
                        default:

                            // Source is indexed, don't need the fancy nonindexed to indexed
                            // color translate blit routines.  Translation is more
                            // simple in that case, and we could do 2 other ScreenToMem*to*
                            // (just need a slight modification in the core macros of CpuXfers,
                            //  see nv4bltc.c)  This is not added because "who sets their UI
                            // in 8bpp anyway ? "
                        case 1:
                            goto EngFallBack;
                        
                        } // ...swith( ppdev->cjPelSize ) ( type of source)
                        
                        //
                        // Now that the proper function is chosen, do the blt
                        //
                        
                        if (pfnStoM != NULL )
                        {
                    
                           if ( (pfnStoM)(   ppdev, 
                                                 1, 
                                           prclDst, 
                                            psoSrc, 
                                            psoDst, 
                                           pptlSrc, 
                                           prclDst, 
                                              pxlo  ) == TRUE )
                               goto All_Done;
                        }
                      
    
                    } // ...else color translation is needed.
                
                } // ...if (without clipping and with source copy rop)  (in ScreenToMem)
                             
                
            } // ...if (Src is screen)  (Dest is system mem)

        else
            {
            //******************************************************************
            // DEST is SYSTEM MEMORY
            // SOURCE is SYSTEM MEMORY
            //******************************************************************

            }


        }


    //**************************************************************************
    // Let GDI handle all other blits for now....
    //
    // Destination = System Memory
    // True ROP 4's com here (masks required)
    //**************************************************************************

    goto EngFallBack;


    //**************************************************************************
    // Common bitmap transfer
    //**************************************************************************

Xfer_It:


#if _WIN32_WINNT >= 0x0500
    if (pBlendObj &&
        ((pfnXfer != ppdev->pfnXferNative) || !NV4CheckAlphaBlendOK(ppdev)))
        {
        //**************************************************************************
        // Only native xfer routines can handle an alpha blend.  If we get here with 
        // anything but a native xfer we are likely blending between different depths.
        // Call hw specific routine to check if hw capable of blending in current state
        //**************************************************************************

        goto EngFallBack;
        }

#endif _WIN32_WINNT >= 0x0500

    if (jClip == DC_TRIVIAL)

        {
        //**********************************************************************
        // No clipping required
        //**********************************************************************

        pfnXfer(ppdev, 1, prclDst, rop4, psoSrc, pptlSrc, prclDst, pxlo,PatternColor,pBlendObj);

        goto All_Done;
        }

    else if (jClip == DC_RECT)

        {

        //**********************************************************************
        // Clip to a single rectangle
        //**********************************************************************
        if (bIntersect(prclDst, &pco->rclBounds, &rcl))
            pfnXfer(ppdev, 1, &rcl, rop4, psoSrc, pptlSrc, prclDst, pxlo,PatternColor,pBlendObj);

        goto All_Done;
        }

    else

        {

        //**********************************************************************
        // Clip region must be enumerated
        //**********************************************************************

        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

        do  {
            bMore = CLIPOBJ_bEnum(pco, sizeof(ce),
                                    (ULONG*) &ce);

            c = cIntersect(prclDst, ce.arcl, ce.c);

            if (c != 0)
                {
                pfnXfer(ppdev, c, ce.arcl, rop4, psoSrc,
                        pptlSrc, prclDst, pxlo,PatternColor,pBlendObj);
                }

            } while (bMore);
        goto All_Done;
        }



EngFallBack:

    //**************************************************************************
    // GDI only knows how to write to standard DIB surfaces.
    // That means, if the SOURCE or DEST is a DFB, we need to create a standard
    // DIB SurfObj in place of the device managed surface (DFB) object in order
    // to let GDI do the blit.
    //
    // Essentially, there are 4 types of SURFOBJS we'll encounter.
    //
    //      1) System Memory SurfObj (Standard DIB)
    //          We can pass this surfobj to GDI as is.
    //
    //      2) DFB - exists in offscreen VRAM memory
    //          Need to create a standard DIB SurfObj to let GDI draw to this surface
    //
    //      3) DFB - exists in system memory
    //          Need to create a standard DIB surfObj to let GDI draw to this surface
    //
    //      4) Primary Surface VRAM (Standard DIB format)
    //          We can pass this surfobj to GDI as is.
    //
    //          CONDITION                                           SURFOBJ TYPE
    //          ---------                                           ------------
    //
    // (pdsurf != NULL)  &&  (pdsurf->dt == DT_DIB)         --> This is a DFB in system memory
    // (pdsurf != NULL)  &&  (pdsurf->dt == DT_SCREEN)      --> This is a DFB in offscreen VRAM memory
    //
    // (pdsurf == NULL)  &&  (pvBits != ppdev->pjScreen)    --> Standard DIB
    // (pdsurf == NULL)  &&  (pvBits == ppdev->pjScreen)    --> Primary Screen Surface
    //**************************************************************************


    //**************************************************************************
    // Default to Standard DIB, and get handles to surfaces if they exist
    //**************************************************************************

    (VOID *)pdsurfSrc = NULL;
    (VOID *)pdsurfDst = NULL;

    if ((VOID *)psoSrc != NULL)
        pdsurfSrc = (DSURF*) psoSrc->dhsurf;

    if ((VOID *)psoDst != NULL)
        pdsurfDst = (DSURF*) psoDst->dhsurf;

    //**************************************************************************
    // Default to using the original, un-modified SURFOBJ's that were passed to us.
    //**************************************************************************

    TempSrcSurfObjPtr = psoSrc;
    TempDstSurfObjPtr = psoDst;

    //**************************************************************************
    // Get pointers to the 'wrapper' surfaces that we use to draw to the
    // screen surface if necessary.  These surfaces are locked.
    // (The surfaces that we pass to GDI MUST be locked).
    // See EnableOffscreenHeap for more information.
    //**************************************************************************

    SrcPuntPtr = ppdev->psoPunt;
    DstPuntPtr = ppdev->psoPunt2;

    //**************************************************************************
    // Check if source bitmap is a DFB.  If so, create a temporary surfobj
    // (mapped to the screen) that GDI can read from
    //**************************************************************************

    if (pdsurfSrc !=0 )
        {
        SrcPuntPtr->dhsurf      = 0;                    // Behave like a standard DIB
        if (pdsurfSrc->dt == DT_SCREEN)
            {
            SrcPuntPtr->sizlBitmap  = pdsurfSrc->sizl;
            SrcPuntPtr->cjBits  = pdsurfSrc->LinearStride * pdsurfSrc->sizl.cy;
            SrcPuntPtr->pvBits  = pdsurfSrc->LinearPtr;
            SrcPuntPtr->pvScan0 = pdsurfSrc->LinearPtr;
            SrcPuntPtr->lDelta  = pdsurfSrc->LinearStride;
            SrcPuntPtr->iBitmapFormat = ppdev->iBitmapFormat;
            }
        else
            {
            //**********************************************************************
            // This is a DFB which is stored in main memory as a DIB
            //**********************************************************************
            SrcPuntPtr->sizlBitmap  = pdsurfSrc->pso->sizlBitmap;
            SrcPuntPtr->cjBits      = pdsurfSrc->pso->lDelta * pdsurfSrc->pso->sizlBitmap.cy;
            SrcPuntPtr->pvBits  = pdsurfSrc->pso->pvBits;
            SrcPuntPtr->pvScan0 = pdsurfSrc->pso->pvScan0;
            SrcPuntPtr->lDelta  = pdsurfSrc->pso->lDelta;
            SrcPuntPtr->iBitmapFormat = pdsurfSrc->pso->iBitmapFormat;
            }

        //**********************************************************************
        // Use the 'wrapper' surface, instead of the original DFB surfobj for GDI
        //**********************************************************************

        TempSrcSurfObjPtr       = SrcPuntPtr;
        }


    //**************************************************************************
    // Check if destination bitmap is a DFB.  If so, create a temporary surfobj
    // (mapped to the screen) that GDI can write on
    //**************************************************************************

    if (pdsurfDst !=0 )
        {
        DstPuntPtr->dhsurf      = 0;                    // Behave like a standard DIB
        if (pdsurfDst->dt == DT_SCREEN)
            {
            DstPuntPtr->sizlBitmap  = pdsurfDst->sizl;
            DstPuntPtr->cjBits  = pdsurfDst->LinearStride * pdsurfDst->sizl.cy;
            DstPuntPtr->pvBits  = pdsurfDst->LinearPtr;
            DstPuntPtr->pvScan0 = pdsurfDst->LinearPtr;
            DstPuntPtr->lDelta  = pdsurfDst->LinearStride;
            DstPuntPtr->iBitmapFormat = ppdev->iBitmapFormat;
            }
        else
            {
            //**********************************************************************
            // This is a DFB which is stored in main memory as a DIB
            //**********************************************************************
            DstPuntPtr->sizlBitmap  = pdsurfDst->pso->sizlBitmap;
            DstPuntPtr->cjBits      = pdsurfDst->pso->lDelta * pdsurfDst->pso->sizlBitmap.cy;
            DstPuntPtr->pvBits  = pdsurfDst->pso->pvBits;
            DstPuntPtr->pvScan0 = pdsurfDst->pso->pvScan0;
            DstPuntPtr->lDelta  = pdsurfDst->pso->lDelta;
            DstPuntPtr->iBitmapFormat = pdsurfDst->pso->iBitmapFormat;
            }

        //**********************************************************************
        // Use the 'wrapper' surface, instead of the original DFB surfobj for GDI
        //**********************************************************************

        TempDstSurfObjPtr       = DstPuntPtr;
        }

    ppdev->pfnWaitEngineBusy(ppdev);

    //**********************************************************************
    // Only supported on Win2k
    //**********************************************************************

#if _WIN32_WINNT >= 0x0500
    
    if (pBlendObj) {
        //**********************************************************************
        // This was a call from DrvAlphaBlend so call EngAlphaBlend
        //**********************************************************************
        bRet = ppdev->pfnEngAlphaBlend(TempDstSurfObjPtr, TempSrcSurfObjPtr, pco, pxlo, prclDst,
                                       prclSrc, pBlendObj);
    } else {
        //**********************************************************************
        // This was a call from DrvBitBlt so call EngBitBlt
        //**********************************************************************
        bRet = ppdev->pfnEngBitBlt(TempDstSurfObjPtr, TempSrcSurfObjPtr, psoMsk, pco, pxlo, prclDst,
                                   pptlSrc, pptlMsk, pbo, pptlBrush, rop4);
    }

#else // NT 4.0
    
    //**********************************************************************
    // This was a call from DrvBitBlt so call EngBitBlt
    //**********************************************************************
    bRet = ppdev->pfnEngBitBlt(TempDstSurfObjPtr, TempSrcSurfObjPtr, psoMsk, pco, pxlo, prclDst,
                               pptlSrc, pptlMsk, pbo, pptlBrush, rop4);

#endif //_WIN32_WINNT >= 0x0500



All_Done:

    if (alphaPreserve != NONE)
        {
        NV4DmaPushAlphaPreserve(ppdev, FALSE, alphaPreserve==IMAGEFROMCPU); // Start=FALSE; TRUE if FromCPU
        }

    return(bRet);

    }


#if _WIN32_WINNT >= 0x0500

//******************************************************************************
//
//  Function:   TransparentBitBlt
//
//  Routine Description:
//
//      Simpler version of GenericBitBltAlpha, used only by DrvTransparentBlt
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

BOOL TransparentBitBlt(
    SURFOBJ*    psoDst,
    SURFOBJ*    psoSrc,
    CLIPOBJ*    pco,
    XLATEOBJ*   pxlo,
    RECTL*      prclDst,
    RECTL*      prclSrc,
    POINTL*     pptlSrc,
    ULONG       iTransColor,
    ULONG       Reserved,
    PDEV*       ppdev
)

    {
    DSURF*          pdsurfDst;
    DSURF*          pdsurfSrc;
    POINTL          ptlSrc;
    BYTE            jClip;
    BOOL            bMore;
    CLIPENUM        ce;
    LONG            c;
    RECTL           rcl;
    FNXFER*         pfnXfer = ppdev->pfnXferNative;
    ULONG           iDir;
    BOOL            bRet;
    ULONG*          ScreenBitmap;
    ULONG*          DstBits;
    ULONG*          SrcBits;
    
    SURFOBJ*        TempDstSurfObjPtr;
    SURFOBJ*        TempSrcSurfObjPtr;

    ULONG           SrcOffset;
    ULONG           DstOffset;
    ULONG           SrcStride;
    ULONG           DstStride;

    // Assume success
    bRet = TRUE;

    // Trivially reject TransparentBlts we can't do
    if ((pxlo && pxlo->flXlate && !(pxlo->flXlate & XO_TRIVIAL) ) ||
        ((ppdev->iBitmapFormat != BMF_32BPP) && (ppdev->iBitmapFormat != BMF_16BPP)) ||
        (psoSrc == NULL) ||
        (!ppdev->bEnabled))
        {
        // Can't do translations
        // Can't hw accelerate anything except 16,32 bpp desktop
        // Must have a source bitmap
        // ppdev must be enabled (may be disable in Stress test)
        goto EngFallBack;
        }

    // Trivially reject blts to host memory bitmaps.
    if (!IS_DEV_SURF(psoDst))
        {
        goto EngFallBack;
        }
    

    //**************************************************************************
    // For NV, our primary screen surface is a GDI-Managed bitmap, instead of a
    // DEVICE MANAGED surface.  This allows us to punt any call back to GDI
    // if necessary.  Therefore, pdsurfDst will be NULL when the destination
    // is the SCREEN.  pdsurfDst will be Non-NULL when the destination is a DFB.
    // As a result, we determine if the SURFOBJ is the primary surface by taking
    // a look at the 'pvBits' value.  If pvBits == ppdev->pjScreen, then the
    // surfobj is the primary surface.
    //**************************************************************************

    pdsurfDst = (DSURF*) psoDst->dhsurf;    // May be NULL since we created the
                                            // primary surface as a GDI Managed bitmap

    //**************************************************************************
    // Check to see if the dest is a device bitmap which has been moved to main
    // memory
    //**************************************************************************
    if ((pdsurfDst != NULL) && (pdsurfDst->dt == DT_DIB))
        {
        psoDst = pdsurfDst->pso;
        pdsurfDst = (DSURF *) psoDst->dhsurf;
        }

    //**************************************************************************
    // Here we know psoDst should NOT be NULL! (already punted if psoSrc=NULL)
    //**************************************************************************

    ASSERTDD(((VOID *)psoDst != NULL), "Didn't expect a NULL destination");

    pdsurfSrc = (DSURF*) psoSrc->dhsurf;

    TRY_MOVE_SRC_TO_OFFSCREEN_MEM(psoSrc, pdsurfSrc, pxlo, ppdev);

    //**************************************************************************
    // Get pointers to the Destination and Source 'Bitmaps'
    // We'll use these to determine if the bitmap is ONSCREEN or not.
    //**************************************************************************

    DstBits = (ULONG *)(psoDst->pvBits);
    SrcBits = (ULONG *)(psoSrc->pvBits);
    ScreenBitmap = (ULONG *)(ppdev->pjScreen);

    //**************************************************************************
    // Determine the clipping type
    //**************************************************************************

    if (pco == NULL)
        jClip = DC_TRIVIAL;             // Don't have to worry about clipping
    else
        jClip = pco->iDComplexity;      // Use the CLIPOBJ-provided clipping

    //**************************************************************************
    // Check if DEST is to VRAM or SYSTEM MEMORY
    //**************************************************************************

    if ((DstBits == ScreenBitmap) ||
        ((pdsurfDst !=NULL) && (pdsurfDst->dt == DT_SCREEN)))
        {
        //**********************************************************************
        // DEST is VRAM
        //**********************************************************************

        // Set linear offset and stride for destination buffer
        if (pdsurfDst != 0)
            {
            DstOffset = (ULONG)((BYTE *)(pdsurfDst->LinearPtr) - ppdev->pjFrameBufbase);
            DstStride = pdsurfDst->LinearStride;
            }
        else
            {
            DstOffset = ppdev->ulPrimarySurfaceOffset;
            DstStride = ppdev->lDelta;
            }

        // Set pitch and stride of destination buffer
        ppdev->pfnSetDestBase(ppdev, DstOffset , DstStride);

        // Check if the source is from VRAM or SYSTEM MEMORY
        if ((SrcBits == ScreenBitmap)   ||
            ((pdsurfSrc != NULL) && (pdsurfSrc->dt == DT_SCREEN)))
            {
            //**********************************************************
            // DEST is VRAM
            // SOURCE is VRAM  (on-screen or off-screen)
            //
            // SCREEN TO SCREEN blt with no color translate
            //**********************************************************

            //**********************************************************
            // Linear memory management
            // Set linear offset and stride for source buffer
            //**********************************************************
    
            if (pdsurfSrc != 0)
                {
                SrcOffset = (ULONG)((BYTE *)(pdsurfSrc->LinearPtr) - ppdev->pjFrameBufbase);
                SrcStride = pdsurfSrc->LinearStride;
                }
            else
                {
                SrcOffset = ppdev->ulPrimarySurfaceOffset;
                SrcStride = ppdev->lDelta;
                }
    
            ppdev->pfnSetSourceBase(ppdev,SrcOffset,SrcStride);
    
    
            NV4DmaPushSetColorKey(ppdev, ppdev->iBitmapFormat, iTransColor);

            if (jClip == DC_TRIVIAL)
                {
                //**************************************************
                // No clipping required
                //**************************************************
                ppdev->pfnCopyBlt(ppdev, 1, prclDst, 0xcccc, pptlSrc, prclDst, NULL);
                
                goto All_Done;
                }
            else if (jClip == DC_RECT)
                {
                //**************************************************
                // Clip to a single rectangle
                //**************************************************

                if (bIntersect(prclDst, &pco->rclBounds, &rcl))
                    {

                    ppdev->pfnCopyBlt(ppdev, 1, &rcl, 0xcccc, pptlSrc, prclDst, NULL);
                    
                    }

                goto All_Done;
                }
            else
                {
                //**************************************************
                // Clip region must be enumerated
                //**************************************************

                if (pptlSrc->y >= (prclDst->top))
                    {
                    if (pptlSrc->x >= (prclDst->left))
                        iDir = CD_RIGHTDOWN;
                    else
                        iDir = CD_LEFTDOWN;
                    }
                else
                    {
                    if (pptlSrc->x >= (prclDst->left))
                        iDir = CD_RIGHTUP;
                    else
                        iDir = CD_LEFTUP;
                    }

                CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES,
                                     iDir, 0);

                do  {
                    bMore = CLIPOBJ_bEnum(pco, sizeof(ce),
                                            (ULONG*) &ce);

                    c = cIntersect(prclDst, ce.arcl, ce.c);

                    if (c != 0)
                        {
                        
                        ppdev->pfnCopyBlt(ppdev, c, ce.arcl, 0xcccc, pptlSrc, prclDst, NULL);

                        }

                    } while (bMore);
                 goto All_Done;
                 }
            }
        else
            {
            //**********************************************************
            // DEST is VRAM
            // SOURCE is SYSTEM MEMORY
            //**********************************************************

            // Transfer from bitmap with SAME pixel depth, or 32bpp source w/ 16bpp dest
            if ((psoSrc->iBitmapFormat == ppdev->iBitmapFormat) ||
                (psoSrc->iBitmapFormat == BMF_32BPP) && (ppdev->iBitmapFormat == BMF_16BPP))
                {
                
                pfnXfer = ppdev->pfnXferNative;
                goto Xfer_It;

                }
            } // DEST is VRAM, SRC is SYSTEM MEMORY
        } // ...if (DstBits == ScreenBitmap)

    //**************************************************************************
    // GDI handles all other blits
    //
    // Destination = System Memory
    //**************************************************************************
    goto EngFallBack;

    //**************************************************************************
    // Common bitmap transfer
    //**************************************************************************

Xfer_It:

    NV4DmaPushSetColorKey(ppdev, psoSrc->iBitmapFormat, iTransColor);

    if (jClip == DC_TRIVIAL)
        {
        //**********************************************************************
        // No clipping required
        //**********************************************************************

        pfnXfer(ppdev, 1, prclDst, 0xcccc, psoSrc, pptlSrc, prclDst, pxlo,0,NULL);

        }
    else if (jClip == DC_RECT)
        {
        //**********************************************************************
        // Clip to a single rectangle
        //**********************************************************************
        if (bIntersect(prclDst, &pco->rclBounds, &rcl))
            pfnXfer(ppdev, 1, &rcl, 0xcccc, psoSrc, pptlSrc, prclDst, pxlo,0,NULL);
        
        }
    else
        {

        //**********************************************************************
        // Clip region must be enumerated
        //**********************************************************************

        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

        do  {
            bMore = CLIPOBJ_bEnum(pco, sizeof(ce),
                                    (ULONG*) &ce);

            c = cIntersect(prclDst, ce.arcl, ce.c);

            if (c != 0)
                {
                pfnXfer(ppdev, c, ce.arcl, 0xcccc, psoSrc, pptlSrc, prclDst, pxlo,0,NULL);
                }

            } while (bMore);
        }
    
    goto All_Done;

EngFallBack:

    PrepareSurfacesForPunt(psoSrc,psoDst,(SURFOBJ**)&TempSrcSurfObjPtr,(SURFOBJ**)&TempDstSurfObjPtr,ppdev);

    ppdev->pfnWaitEngineBusy(ppdev);
    bRet = ppdev->pfnEngTransparentBlt(TempDstSurfObjPtr,TempSrcSurfObjPtr,pco,pxlo,prclDst,prclSrc,iTransColor,Reserved); 

All_Done:

    NV4DmaPushSetColorKey(ppdev, 0, 0);
    
    return(bRet);

    }

#endif // _WIN32_WINNT >= 0x0500


//******************************************************************************
//
//  Function:   DrvBitBlt
//
//  Routine Description:
//
//      Implements Bit Block Transfers without alpha blend support -paul.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

BOOL DrvBitBlt(
    SURFOBJ*    psoDst,
    SURFOBJ*    psoSrc,
    SURFOBJ*    psoMsk,
    CLIPOBJ*    pco,
    XLATEOBJ*   pxlo,
    RECTL*      prclDst,
    POINTL*     pptlSrc,
    POINTL*     pptlMsk,
    BRUSHOBJ*   pbo,
    POINTL*     pptlBrush,
    ROP4        rop4)
{
    PDEV*           ppdev;
    
    ppdev = (PDEV*) psoDst->dhpdev;
    
    //**************************************************************************
    // ppdev may not be present in the Dst surface object
    // This can happen if the Dst surface object is a standard DIB
    //**************************************************************************

    if (ppdev == NULL || (ppdev->hdevEng != psoDst->hdev)) {

        if (psoSrc != NULL)
            ppdev = (PDEV *)psoSrc->dhpdev;
        if (ppdev == NULL || (ppdev->hdevEng != psoSrc->hdev))
            //******************************************************************
            // This blit call is either screwed up, or we got a
            // memory to memory blit (with no physical device associated).
            // Send the call back to GDI.
            //******************************************************************
                return(EngBitBlt(psoDst, psoSrc, psoMsk, pco, pxlo, prclDst,
                                pptlSrc, pptlMsk, pbo, pptlBrush, rop4));

    }

    //************************************************************************** 
    // Need to do smart sync between OpenGL and GDI depending on 
    // clip intersection.
    //**************************************************************************
    if (OglIsEnabled(ppdev)) // fast ogl check
    {
        bOglSyncIfGdiInOglWindowBlt(ppdev,psoDst,psoSrc,pco,prclDst,pptlSrc);        
    }


    return GenericBitBltAlpha(psoDst,
                              psoSrc,
                              psoMsk,
                              pco,
                              pxlo,
                              prclDst,
                              NULL,        // RECTL *prclSrc
                              pptlSrc,
                              pptlMsk,
                              pbo,
                              pptlBrush,
                              rop4,
                              NULL,         // BLENDOBJ *pBlendObj
                              ppdev
                              );

}

#if _WIN32_WINNT >= 0x0500

//******************************************************************************
//
//  Function:   DrvAlphaBlend
//
//  Routine Description:
//
//      Implements Bit Block Transfers with alpha blend support. -paul
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

BOOL DrvAlphaBlend(
    SURFOBJ  *psoDst,
    SURFOBJ  *psoSrc,
    CLIPOBJ  *pco,
    XLATEOBJ  *pxlo,
    RECTL  *prclDst,
    RECTL  *prclSrc,
    BLENDOBJ  *pBlendObj) 
{
    PDEV*           ppdev;
    POINTL          ptlSrc;
    LONG            SrcWidth;
    LONG            SrcHeight;


    //**************************************************************************
    // Either the source or the destination should have the physical device
    // associated with it. (We should never get a memory to memory blit)
    // Default to getting the PPDEV from the dst.  Otherwise, get it from source
    //**************************************************************************

    ppdev = (PDEV*) psoDst->dhpdev;
    //**************************************************************************
    // ppdev may not be present in the Dst surface object
    // This can happen if the Dst surface object is a standard DIB
    //**************************************************************************
    if (ppdev == NULL || (ppdev->hdevEng != psoDst->hdev) || (!ppdev->bEnabled)) 
        {

        if (psoSrc != NULL)
            ppdev = (PDEV *)psoSrc->dhpdev;
        if (ppdev == NULL || (ppdev->hdevEng != psoSrc->hdev) || (!ppdev->bEnabled))
            //******************************************************************
            // This blit call is either screwed up, or we got a
            // memory to memory blit (with no physical device associated).
            // Send the call back to GDI.
            //******************************************************************
            {
            return (EngAlphaBlend(psoDst,psoSrc,pco,pxlo,prclDst,prclSrc,pBlendObj)); 
            }
        }

    // NOTE: GDI does not pass the call if no per-pixel alpha and SourceConstantAlpha is 0xFF. 

    // We get called if SourceConstantAlpha == 0x00, but no visual change for this, so return ASAP
    if(!(pBlendObj->BlendFunction.SourceConstantAlpha))
        {
        return TRUE; // nothing to blend.
        }


    //************************************************************************** 
    // Need to do smart sync between OpenGL and GDI depending on 
    // clip intersection.
    //**************************************************************************
    if (OglIsEnabled(ppdev)) // fast ogl check
    {
        bOglSyncIfGdiInOglWindowStretch(ppdev,psoDst,psoSrc,pco,prclDst,prclSrc);        
    }


    //**********************************************************************
    // Source and Dest rects may be different size.
    // If they are a different size, we need to stretch/squash 'em. 
    // Currently we don't support StretchBlt, which would be the function we'd
    // feed into.
    //**********************************************************************
    SrcWidth  = prclSrc->right  - prclSrc->left;
    SrcHeight = prclSrc->bottom - prclSrc->top;

    if ((SrcWidth != prclDst->right - prclDst->left) ||
        (SrcHeight!= prclDst->bottom - prclDst->top))
        {
        // SCALED_IMAGE class will support this, when we switch to it eventually.
        ppdev->pfnWaitEngineBusy(ppdev);
        return (ppdev->pfnEngAlphaBlend(psoDst,psoSrc,pco,pxlo,prclDst,prclSrc,pBlendObj)); 
        }

    //**********************************************************************
    // Create the src point struct based on the source rect
    //**********************************************************************

    ptlSrc.x = prclSrc->left;
    ptlSrc.y = prclSrc->top;

    DISPDBG((4,"DrvAlphablend:x=%d,y=%d,w=%d,h=%d",ptlSrc.x, ptlSrc.y, SrcWidth, SrcHeight));
    return GenericBitBltAlpha(psoDst,
                              psoSrc,
                              NULL,        // SURFOBJ  *psoMsk
                              pco,
                              pxlo,
                              prclDst,
                              prclSrc,
                              &ptlSrc,
                              NULL,        // POINTL   *pptlMsk
                              NULL,        // BRUSHOBJ *pbo
                              NULL,        // POINTL   *pptlBrush
                              0,           // ROP4     rop4
                              pBlendObj,
                              ppdev
                              );

}


//******************************************************************************
//
//  Function:   DrvTransparentBlt
//
//  Routine Description:
//
//      Implements Bit Block Transfers with transparency (color key)
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

BOOL DrvTransparentBlt(
    SURFOBJ     *psoDst,
    SURFOBJ     *psoSrc,
    CLIPOBJ     *pco,
    XLATEOBJ    *pxlo,
    RECTL       *prclDst,
    RECTL       *prclSrc,
    ULONG       iTransColor,
    ULONG       Reserved) 
{
    PDEV*           ppdev;
    POINTL          ptlSrc;
    LONG            SrcWidth;
    LONG            SrcHeight;

    ppdev = (PDEV*) psoDst->dhpdev;
    
    //**************************************************************************
    // ppdev may not be present in the Dst surface object
    // This can happen if the Dst surface object is a standard DIB
    //**************************************************************************

    if (ppdev == NULL || (ppdev->hdevEng != psoDst->hdev)) {

        if (psoSrc != NULL)
            ppdev = (PDEV *)psoSrc->dhpdev;
        if (ppdev == NULL || (ppdev->hdevEng != psoSrc->hdev))
            //******************************************************************
            // This blit call is either screwed up, or we got a
            // memory to memory blit (with no physical device associated).
            // Send the call back to GDI.
            //******************************************************************
                return(EngTransparentBlt(psoDst, psoSrc, pco, pxlo, prclDst, prclSrc, iTransColor, Reserved));

    }


    //************************************************************************** 
    // Need to do smart sync between OpenGL and GDI depending on 
    // clip intersection.
    //**************************************************************************
    if (OglIsEnabled(ppdev)) // fast ogl check
    {
        bOglSyncIfGdiInOglWindowStretch(ppdev,psoDst,psoSrc,pco,prclDst,prclSrc);        
    }


    //**********************************************************************
    // Source and Dest rects may be different size.
    // If they are a different size, we need to stretch/squash 'em. 
    // Currently we don't support StretchBlt, which would be the function we'd
    // feed into.
    //**********************************************************************
    SrcWidth  = prclSrc->right  - prclSrc->left;
    SrcHeight = prclSrc->bottom - prclSrc->top;

    if ((SrcWidth != prclDst->right - prclDst->left) ||
        (SrcHeight!= prclDst->bottom - prclDst->top))
        {
        // SCALED_IMAGE class will support this, when we switch to it eventually.
        ppdev->pfnWaitEngineBusy(ppdev);
        return (ppdev->pfnEngTransparentBlt(psoDst,psoSrc,pco,pxlo,prclDst,prclSrc,iTransColor,Reserved)); 
        }

    //**********************************************************************
    // Create the src point struct based on the source rect
    //**********************************************************************

    ptlSrc.x = prclSrc->left;
    ptlSrc.y = prclSrc->top;

    DISPDBG((4,"DrvTransparentBlt:x=%d,y=%d,w=%d,h=%d",ptlSrc.x, ptlSrc.y, SrcWidth, SrcHeight));
    
    return TransparentBitBlt(psoDst,
                              psoSrc,
                              pco,
                              pxlo,
                              prclDst,
                              prclSrc,
                              &ptlSrc,
                              iTransColor,
                              Reserved,
                              ppdev
                              );
}

#endif // _WIN32_WINNT >= 0x0500

//******************************************************************************
//
//  Function:   DrvCopyBits
//
//  Routine Description:
//
//      Do fast bitmap copies.
//
//      Note that GDI will (usually) automatically adjust the blt extents to
//      adjust for any rectangular clipping, so we'll rarely see DC_RECT
//      clipping in this routine (and as such, we don't bother special casing
//      it).
//
//      I'm not sure if the performance benefit from this routine is actually
//      worth the increase in code size, since SRCCOPY BitBlts are hardly the
//      most common drawing operation we'll get.  But what the heck.
//
//      On the S3 it's faster to do straight SRCCOPY bitblt's through the
//      memory aperture than to use the data transfer register; as such, this
//      routine is the logical place to put this special case.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************


BOOL DrvCopyBits(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc)

    {
    BOOL        bMore;
    CLIPENUM    ce;
    LONG        c;
    PDEV*       ppdev;
    DSURF*      pdsurfSrc;
    DSURF*      pdsurfDst;
    RECTL       rcl;
    POINTL      ptlSrc;
    ULONG*      ScreenBitmap;
    ULONG*      DstBits;
    ULONG*      SrcBits;
    FNXFER*     pfnXfer;
    BYTE        jClip;
    ULONG       jXlo;

    ULONG       iDstBitmapFormat;
    ULONG       iSrcBitmapFormat;

    SURFOBJ*    SrcPuntPtr;
    SURFOBJ*    DstPuntPtr;
    SURFOBJ*    TempDstSurfObjPtr;
    SURFOBJ*    TempSrcSurfObjPtr;
    BOOL        bret                = FALSE;

    ULONG       bltHeight;
    ULONG       bltWidth;
    ULONG       bltDelta;
    ULONG       SrcOffset;
    ULONG       DstOffset;
    ULONG       SrcStride;
    ULONG       DstStride;

    BYTE*       SrcOffsetPtr;
    BYTE*       DstOffsetPtr;

    ALPHA_SAVE  alphaPreserve=NONE;

    //**************************************************************************
    //  Src and Dst surfaces better be valid.
    //**************************************************************************

    ASSERTDD(((VOID *)psoSrc != NULL), "Didn't expect a NULL source");
    ASSERTDD(((VOID *)psoDst != NULL), "Didn't expect a NULL destination");

    //**************************************************************************
    // Either the source or the destination should have the physical device
    // associated with it. Default to getting the PPDEV from the dst.
    // Otherwise, get it from source
    //**************************************************************************

    ppdev = (PDEV*) psoDst->dhpdev;

    //**************************************************************************
    // ppdev may not be present in the Dst surface object
    // This can happen if the Dst surface object is a standard DIB
    //**************************************************************************

    if (ppdev == NULL)
        {
        //******************************************************************
        // If the PDEV ptr is still NULL, then just kick it back to DIB engine
        //******************************************************************
        ppdev = (PDEV *)psoSrc->dhpdev;
        if (ppdev == NULL)
            //*******************************************
            // No device managed surfaces in the blit.
            //*******************************************

            return(EngCopyBits(psoDst, psoSrc, pco, pxlo, prclDst, pptlSrc));
        }


    //************************************************************************** 
    // Need to do smart sync between OpenGL and GDI depending on 
    // clip intersection.
    //**************************************************************************
    if (OglIsEnabled(ppdev)) // fast ogl check
    {
        bOglSyncIfGdiInOglWindowBlt(ppdev,psoDst,psoSrc,pco,prclDst,pptlSrc);        
    }


    //**************************************************************************
    // Get ptrs to the drivers private device surface structs.
    //**************************************************************************

    pdsurfDst = (DSURF*) psoDst->dhsurf;
    pdsurfSrc = (DSURF*) psoSrc->dhsurf;

    //**************************************************************************
    // Try Signature of ppdev....Only accept PPDEV if it matches our signature
    // (NetMeeting seems to be passing in bogus ppdev values)
    //**************************************************************************

    if (ppdev->NVSignature != NV_SIGNATURE)

        {
        //**********************************************************************
        // The ppdev from the DST did not match...try the ppdev from psosrc
        //**********************************************************************

        ppdev = (PDEV*) psoSrc->dhpdev;

        if (ppdev->NVSignature != NV_SIGNATURE)

            {
            //*******************************************************************
            // We're not able to determine the correct ppdev....just punt
            //*******************************************************************

            goto EngCopyBits_It;
            }

        }

#if _WIN32_WINNT >= 0x0500
    
    //**************************************************************************
    //  Fixes case where driver is called in full screen DOS during STRESS tests.
    //  In this case, GDI is allowed to call us to update DFBs that are stored in
    //  system memory, or offscreen memory. We need to wrap the surface and call
    //  EngBitBlt.
    //**************************************************************************

    if(!ppdev->bEnabled)
        goto EngCopyBits_It;
#endif

    //**************************************************************************
    // Trivially reject calls we don't handle. We don't do color translation or
    // clipping here, nor do we blt between host memory bitmaps.
    //**************************************************************************

    if (pco == NULL)
        jClip = DC_TRIVIAL;
    else
        jClip = pco->iDComplexity;

    if (pxlo == NULL)
        jXlo = XO_TRIVIAL;
    else
        jXlo = pxlo->flXlate;

    //**************************************************************************
    // Check to see if the dest is a device bitmap which has been moved to main
    // memory
    //**************************************************************************

    if ((pdsurfDst != NULL) && (pdsurfDst->dt == DT_DIB))
        {
        psoDst = pdsurfDst->pso;
        if ((pdsurfSrc != NULL) && (pdsurfSrc->dt == DT_DIB))
            {
            //*************************************************************
            // No Device surfaces involved in the blt - check if overlap to
            // avoid GDI bug.
            //*************************************************************
            psoSrc = pdsurfSrc->pso;
            if (pdsurfSrc == pdsurfDst)
                {
                goto CheckDibToDibOverlap;
                }
            }
        goto EngCopyBits_It;     // destination in DIB, no overlap so just punt to GDI
        }

    //**************************************************************************
    // Check and see if we can move system memory DFB's back into
    // offscreen VRAM for better performance. That is, at some point, we put a
    // DFB in system memory. Now we determine that if this DFB is getting
    // used a lot, put it back in offscreen VRAM so we can regain performance.
    //**************************************************************************

    if ( (pdsurfSrc != NULL) && (pdsurfSrc->dt == DT_DIB) )

        {
        //**********************************************************************
        // Here we consider putting a DIB DFB back into off-screen
        // memory. See 'DrvCopyBits' for some more comments on how this
        // moving-it-back-into-off-screen-memory thing works:
        //******************************************************************
        if (pdsurfSrc->iUniq == ppdev->iHeapUniq)

            {
            ASSERTDD(pdsurfSrc->pso->iBitmapFormat == ppdev->iBitmapFormat, "oops");
            //**************************************************************
            // Attempt to move DIB back to offscreen VRAM.
            // This won't necessarily succeed.
            //
            // NOTE: If space doesn't get freed up for a while (heapUniq
            //       remains the same), and this call fails, then cBlt will
            //       wrap around to 0xffffffff, meaning we won't consider
            //       putting this DFB DIB back into offscreen VRAM for a
            //       LONG time, until someone frees up some offscreen memory,
            //       and causes cBlt to be reset to HEAP_COUNT_DOWN.
            //**************************************************************

            if (--pdsurfSrc->cBlt == 0)
                if (bMoveDibToOffscreenDfbIfRoom(ppdev, pdsurfSrc))
                    goto DstDevBmp;

            }
        else
            {
            //**************************************************************
            // Some space was freed up in off-screen memory,
            // so reset the counter for this DFB:
            //**************************************************************
            ASSERTDD(pdsurfSrc->pso->iBitmapFormat == ppdev->iBitmapFormat, "oops");

            pdsurfSrc->iUniq = ppdev->iHeapUniq;
            pdsurfSrc->cBlt  = HEAP_COUNT_DOWN;
            }
        psoSrc = pdsurfSrc->pso;
        }

    //**************************************************************************
    // Get pointers to the Destination and Source 'Bitmaps'
    // We'll use these to determine if the bitmap is ONSCREEN or not.
    //**************************************************************************
DstDevBmp:
    DstBits = (ULONG *)(psoDst->pvBits);
    SrcBits = (ULONG *)(psoSrc->pvBits);
    ScreenBitmap = (ULONG *)(ppdev->pjScreen);

    //**************************************************************************
    // Bitmaps can be one of 4 types, resulting in 16 ways to do blits as follows
    //
    //
    // 1) DIB,  2) DFB (OFFSCREEN),  3) DFB (SYS MEMORY),   4) SCREEN
    //
    //
    //    DIB               to DIB                -> Will not handle - Punt to GDI
    //    DFB (OFFSCREEN)   to DIB                -> Will not handle - Punt to GDI
    //    DFB (SYS MEMORY)  to DIB                -> Will not handle - Punt to GDI
    // SCREEN               to DIB                -> Will not handle - Punt to GDI
    //
    //    DIB               to DFB (OFFSCREEN)    -> Handled
    //    DFB (OFFSCREEN)   to DFB (OFFSCREEN)    -> Handled (rare?)
    //    DFB (SYS MEMORY)  to DFB (OFFSCREEN)    -> Handled (rare?)
    // SCREEN               to DFB (OFFSCREEN)    -> Handled
    //
    //    DIB               to DFB (SYS MEMORY)   -> Will not handle - Punt to GDI
    //    DFB (OFFSCREEN)   to DFB (SYS MEMORY)   -> Will not handle - Punt to GDI ??
    //    DFB (SYS MEMORY)  to DFB (SYS MEMORY)   -> Will not handle - Punt to GDI ??
    // SCREEN               to DFB (SYS MEMORY)   -> Will not handle - Punt to GDI
    //
    //    DIB               to SCREEN             -> Handled
    //    DFB (OFFSCREEN)   to SCREEN             -> Handled
    //    DFB (SYS MEMORY)  to SCREEN             -> Handled
    // SCREEN               to SCREEN             -> Handled
    //
    //
    //      We'll only need to handle the following cases:  (Punt the rest to GDI)
    //      The reason we need to check against ScreenBitmap is that
    //      we've mapped the primary surface using EngCreateBitmap,
    //      so that we can let GDI draw directly to it.  Because of this,
    //      the primary surface is NOT a device managed surface, but rather
    //      a GDI-managed surface.  This means that pdsurf for the
    //      primary surface will be NULL.  So in order to determine
    //      if a surface corresponds to the primary screen surface,
    //      we simply check it's pointer against the ScreenBitmap pointer
    //
    //      Optional:  Since we started with a Dumb Frame Buffer driver using
    //                 EngCreateBitmap (primary surface is GDI-managed, not device
    //                 managed), we check if a standard DIB is the primary surface
    //                 by checking if pvBits == ScreenBitmap.  We can avoid
    //                 this by converting the primary surface to be device managed.
    //                 (EngCreateDeviceSurface). This would result in a more consistent
    //                 driver. (This is the original way it was done in the S3 driver).
    //                 However, we started with a Dumb Frame buffer driver, so
    //                 just leave it for now. It doesn't seem to make that much
    //                 of a difference except for a couple of extra 'if' statements.
    //
    //
    //      We only handle blits where the destination is VRAM, as follows:
    //
    //
    //  1) SCREEN to SCREEN             (CopyBlit)
    //
    //        pdsurfSrc == 0 && SrcBits == ScreenBitmap
    //        pdsurfDst == 0 && DstBits == ScreenBitmap
    //
    //  2) DFB (SYS MEMORY) to SCREEN   (Memory to Screen)
    //
    //        pdsurfSrc != 0 && pdsurfSrc->dt == DT_DIB     && SrcBits != ScreenBitmap;
    //        pdsurfDst == 0 && DstBits == ScreenBitmap
    //
    //  3) DFB (OFFSCREEN) to SCREEN    (CopyBlit)
    //
    //        pdsurfSrc != 0 && pdsurfSrc->dt == DT_SCREEN  &&  SrcBits != ScreenBitmap
    //        pdsurfDst == 0 && DstBits == ScreenBitmap
    //
    //  4) DIB to SCREEN                (Memory to Screen)
    //
    //        pdsurfSrc == 0 && SrcBits != ScreenBitmap;
    //        pdsurfDst == 0 && DstBits == ScreenBitmap
    //
    //  5) SCREEN to DFB (OFFSCREEN)    (CopyBlit)
    //
    //        pdsurfSrc == 0 && SrcBits == ScreenBitmap
    //        pdsurfDst != 0 && pdsurfDst->dt == DT_SCREEN  && DstBits != ScreenBitmap
    //
    //  6) DFB (SYS MEMORY) to DFB (OFFSCREEN)   (Memory to Screen)
    //
    //        pdsurfSrc != 0 && pdsurfSrc->dt == DT_DIB     && SrcBits != ScreenBitmap
    //        pdsurfDst != 0 && pdsurfDst->dt == DT_SCREEN  && DstBits != ScreenBitmap
    //
    //  7) DFB (OFFSCREEN) to DFB (OFFSCREEN)    (CopyBlit)
    //
    //        pdsurfSrc != 0 && pdsurfSrc->dt == DT_SCREEN  && SrcBits != ScreenBitmap
    //        pdsurfDst != 0 && pdsurfDst->dt == DT_SCREEN  && DstBits != ScreenBitmap
    //
    //  8) DIB to DFB (OFFSCREEN)       (Memory to Screen)
    //
    //        pdsurfSrc == 0 && SrcBits != ScreenBitmap
    //        pdsurfDst != 0 && pdsurfDst->dt == DT_SCREEN  DstBits != ScreenBitmap
    //
    //
    //      If the destination is system memory, then we send it back to GDI
    //
    //**************************************************************************

    //**********************************************************************
    // Check if DEST is the SCREEN or MEMORY
    //**********************************************************************
    if (IS_DEV_SURF(psoDst))

        {
        //******************************************************************
        // DEST is SCREEN
        //******************************************************************

        if (IS_DEV_SURF(psoSrc))
            {
            //**************************************************************
            // DEST is SCREEN
            // SOURCE is SCREEN
            // Handle simple SCREEN to SCREEN blit with ROP=SRCCOPY
            //**************************************************************

            if ((jClip != DC_TRIVIAL) || (jXlo != XO_TRIVIAL))
                goto DrvBlt_It;

            //**************************************************************
            // Linear memory management
            // Set linear offset and stride for source buffer
            //**************************************************************

            if (pdsurfSrc != 0)     // source is offscreen bitmap
                {
                SrcOffset = (ULONG)((BYTE *)(pdsurfSrc->LinearPtr) - ppdev->pjFrameBufbase);
                SrcStride = pdsurfSrc->LinearStride;
                }
            else
                {
                SrcOffset = ppdev->ulPrimarySurfaceOffset;
                SrcStride = ppdev->lDelta;
                }

            (ppdev->pfnSetSourceBase)(ppdev,SrcOffset,SrcStride);

            //**************************************************************
            // Set linear offset and stride for destination buffer
            //**************************************************************

            if (pdsurfDst != 0)     // dest is offscreen bitmap
                {
                DstOffset = (ULONG)((BYTE *)(pdsurfDst->LinearPtr) - ppdev->pjFrameBufbase);
                DstStride = pdsurfDst->LinearStride;
                }
            else
                {
                DstOffset = ppdev->ulPrimarySurfaceOffset;
                DstStride = ppdev->lDelta;
                }

            (ppdev->pfnSetDestBase)(ppdev, DstOffset , DstStride);

            //**************************************************************
            // Do the blit
            //**************************************************************
#if (_WIN32_WINNT >= 0x0500)
            if (ppdev->iBitmapFormat == BMF_32BPP)
                {
                // 32bpp src copy - upper 8 bits may be alpha
                // Preserve alpha since this bitmap may be the source on a future DrvAlphaBlend
                alphaPreserve = COPYBLIT;
                NV4DmaPushAlphaPreserve(ppdev, TRUE, FALSE); // Start=TRUE, FromCpu=TRUE
                }
#endif // NT5
            ppdev->pfnCopyBlt(ppdev, 1, prclDst, 0xcccc, pptlSrc, prclDst, NULL);

            bret = TRUE;
            goto Exit;
            }

        else

            {

            //**************************************************************
            // DEST is SCREEN
            // SOURCE is MEMORY
            // Handle simple MEMORY to SCREEN blit with ROP=SRCCOPY
            //**************************************************************

            //**************************************************************
            // Set linear offset and stride for destination buffers
            //**************************************************************

            if (pdsurfDst != 0)     // dest is offscreen bitmap
                {
                DstOffset = (ULONG)((BYTE *)(pdsurfDst->LinearPtr) - ppdev->pjFrameBufbase);
                DstStride = pdsurfDst->LinearStride;
                }
            else
                {
                DstOffset = ppdev->ulPrimarySurfaceOffset;
                DstStride = ppdev->lDelta;
                }

            (ppdev->pfnSetDestBase)(ppdev, DstOffset , DstStride);

            iSrcBitmapFormat = psoSrc->iBitmapFormat;
            iDstBitmapFormat = ppdev->iBitmapFormat;
            bltHeight = prclDst->bottom - prclDst->top;

            if ((jXlo & XO_TABLE)               &&
                (iSrcBitmapFormat == BMF_8BPP)  &&
                (jClip == DC_TRIVIAL)           &&
                (ppdev->DmaPushEnabled2D)       &&
                (bltHeight == 1))
                {

                if ((iDstBitmapFormat == BMF_32BPP))
                    {
                    ppdev->pfnFastXfer8to32(ppdev, prclDst, psoSrc, pptlSrc, pxlo);
                    bret = TRUE;
                    goto Exit;
                    }

                if ((iDstBitmapFormat == BMF_16BPP))
                    {
                    ppdev->pfnFastXfer8to16(ppdev, prclDst, psoSrc, pptlSrc, pxlo);
                    bret = TRUE;
                    goto Exit;
                    }

                goto DrvBlt_It;
                }

            if (((iSrcBitmapFormat == BMF_8BPP)  ||
                 (iSrcBitmapFormat == BMF_4BPP)) &&
                ((iDstBitmapFormat == BMF_32BPP) ||
                 (iDstBitmapFormat == BMF_16BPP)) &&
                 (jXlo & XO_TABLE))
                {
                //******************************************************
                // For small bitmaps, it is faster to do a manual indexed
                // image transfer.
                //******************************************************

                bltWidth = prclDst->right - prclDst->left;

                //
                // pfnIndexedImage will download 256 dwords palette and the image itself
                // 16x16 in 8bpp = 64 dwords
                // 16x16 in 4bpp = 32 dwords
                // pfnXferXtoYY will xlate in sw and put the xlated data to the pushbuffer
                // We need to count the palette overhead to make a decision
                // suggestion: if ((bltWidth * bltHeight) <= 320)
                if ((bltWidth <= 16) && (bltHeight <= 16))
                    {
                    if (iDstBitmapFormat == BMF_16BPP)
                        {
                        if (iSrcBitmapFormat == BMF_4BPP)
                            pfnXfer = ppdev->pfnXfer4to16bpp;
                        else
                            pfnXfer = ppdev->pfnXfer8to16bpp;
                        }
                    else
                        {
                        if (iSrcBitmapFormat == BMF_4BPP)
                            pfnXfer = ppdev->pfnXfer4to32bpp;
                        else
                            pfnXfer = ppdev->pfnXfer8to32bpp;
                        }
                    }
                else
                    {
                    //******************************************************
                    // Use hardware Indexed Image to transfer from 4bpp or 8bpp
                    // source bitmap to 16bpp or 32bpp destination bitmap
                    //******************************************************

                    pfnXfer = ppdev->pfnIndexedImage;
                    }

                if (pfnXfer == NULL)
                    goto DrvBlt_It;

                if (jClip == DC_TRIVIAL)
                    pfnXfer(ppdev, 1, prclDst, 0xcccc, psoSrc, pptlSrc, prclDst, pxlo, 0, NULL);
                else if (jClip == DC_RECT)
                    {
                    if (bIntersect(prclDst, &pco->rclBounds, &rcl))
                        pfnXfer(ppdev, 1, &rcl, 0xcccc, psoSrc, pptlSrc, prclDst, pxlo, 0, NULL);
                    }
                else
                    {

            //************************************************************
            // Clip region must be enumerated
            //************************************************************

                    CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

                    do  {
                        bMore = CLIPOBJ_bEnum(pco, sizeof(ce),
                                           (ULONG*) &ce);

                        c = cIntersect(prclDst, ce.arcl, ce.c);

                        if (c != 0)
                            {
                            pfnXfer(ppdev, c, ce.arcl, 0xcccc, psoSrc,
                                    pptlSrc, prclDst, pxlo, 0, NULL);
                            }

                        } while (bMore);
                    }
                }
            //**************************************************************
            // If source format == dest format, do straight mem to screen BLT.
            //**************************************************************

            else
                {
                if ((jClip != DC_TRIVIAL) ||
                    (iSrcBitmapFormat != iDstBitmapFormat) ||
                    (jXlo != XO_TRIVIAL))

                    goto DrvBlt_It;

#if (_WIN32_WINNT >= 0x0500)
                if (iDstBitmapFormat == BMF_32BPP)
                    {
                    // Preserve alpha since this bitmap may be the source on a future DrvAlphaBlend
                    alphaPreserve = IMAGEFROMCPU;
                    NV4DmaPushAlphaPreserve(ppdev, TRUE, TRUE); // Start=TRUE, FromCpu=TRUE
                    }
#endif // NT5

                (ppdev->pfnMemToScreenBlt)(ppdev, psoSrc, pptlSrc, prclDst);
                }

            bret = TRUE;
            goto Exit;

            }

        }

    else

        {

        //******************************************************************
        // DEST is MEMORY
        //******************************************************************

        if (IS_DEV_SURF(psoSrc))
            {
            //**************************************************************
            // DEST is MEMORY
            // SOURCE is SCREEN
            // Handle simple SCREEN to MEMORY blit with ROP=SRCCOPY
            //**************************************************************
            goto DrvBlt_It;
            }

        else
            {
            //**************************************************************
            // DEST is MEMORY
            // SOURCE is MEMORY
            // Should never get here since we trivially rejected this case.
            // But if we do get here, punt.
            //**************************************************************
            goto EngCopyBits_It;
            }

        }

    //**************************************************************************
    // If DrvCopyBits couldn't handle it, just send it to DrvBitBlt.
    // A DrvCopyBits is after all just a simplified DrvBitBlt:
    //**************************************************************************

DrvBlt_It:
    bret = GenericBitBltAlpha(psoDst,
                              psoSrc,
                              NULL,
                              pco,
                              pxlo,
                              prclDst,
                              NULL,        // RECTL *prclSrc
                              pptlSrc,
                              NULL,
                              NULL,
                              NULL,
                              0x0000CCCC,
                              NULL,         // BLENDOBJ *pBlendObj
                              ppdev
                              );
    goto Exit;

EngCopyBits_It:

    //**************************************************************************
    // GDI only knows how to write to standard DIB surfaces.
    // That means, if the SOURCE or DEST is a DFB, we need to create a standard
    // DIB SurfObj in place of the device managed surface (DFB) object in order
    // to let GDI do the blit.
    //
    // Essentially, there are 4 types of SURFOBJS we'll encounter.
    //
    //      1) System Memory SurfObj (Standard DIB)
    //          We can pass this surfobj to GDI as is.
    //
    //      2) DFB - exists in offscreen VRAM memory
    //          Need to create a standard DIB SurfObj to let GDI draw to this surface
    //
    //      3) DFB - exists in system memory
    //          Need to create a standard DIB surfObj to let GDI draw to this surface
    //
    //      4) Primary Surface VRAM (Standard DIB format)
    //          We can pass this surfobj to GDI as is.
    //
    //          CONDITION                                           SURFOBJ TYPE
    //          ---------                                           ------------
    //
    // (pdsurf != NULL)  &&  (pdsurf->dt == DT_DIB)         --> This is a DFB in system memory
    // (pdsurf != NULL)  &&  (pdsurf->dt == DT_SCREEN)      --> This is a DFB in offscreen VRAM memory
    //
    // (pdsurf == NULL)  &&  (pvBits != ppdev->pjScreen)    --> Standard DIB
    // (pdsurf == NULL)  &&  (pvBits == ppdev->pjScreen)    --> Primary Screen Surface
    //**************************************************************************


    //**************************************************************************
    // Default to using the original, un-modified SURFOBJ's that were passed to us.
    //**************************************************************************

    TempSrcSurfObjPtr = psoSrc;
    TempDstSurfObjPtr = psoDst;

    //**************************************************************************
    // Get pointers to the 'wrapper' surfaces that we use to draw to the
    // screen surface if necessary.  These surfaces are locked.
    // (The surfaces that we pass to GDI MUST be locked).
    // See EnableOffscreenHeap for more information.
    //**************************************************************************

    SrcPuntPtr = ppdev->psoPunt;
    DstPuntPtr = ppdev->psoPunt2;

    //**************************************************************************
    // Check if source bitmap is a DFB.  If so, create a temporary surfobj
    // (mapped to the screen) that GDI can read from
    //**************************************************************************

    if (pdsurfSrc !=0 )
        {
        SrcPuntPtr->dhsurf      = 0;                    // Behave like a standard DIB
        if (pdsurfSrc->dt == DT_SCREEN)
            {
            SrcPuntPtr->sizlBitmap  = pdsurfSrc->sizl;
            SrcPuntPtr->cjBits  = pdsurfSrc->LinearStride * pdsurfSrc->sizl.cy;
            SrcPuntPtr->pvBits  = pdsurfSrc->LinearPtr;
            SrcPuntPtr->pvScan0 = pdsurfSrc->LinearPtr;
            SrcPuntPtr->lDelta  = pdsurfSrc->LinearStride;
            SrcPuntPtr->iBitmapFormat = ppdev->iBitmapFormat;
            }
        else
            {
            //**********************************************************************
            // This is a DFB which is stored in main memory as a DIB
            //**********************************************************************
            SrcPuntPtr->sizlBitmap  = pdsurfSrc->pso->sizlBitmap;
            SrcPuntPtr->cjBits      = pdsurfSrc->pso->lDelta * pdsurfSrc->pso->sizlBitmap.cy;
            SrcPuntPtr->pvBits  = pdsurfSrc->pso->pvBits;
            SrcPuntPtr->pvScan0 = pdsurfSrc->pso->pvScan0;
            SrcPuntPtr->lDelta  = pdsurfSrc->pso->lDelta;
            SrcPuntPtr->iBitmapFormat = pdsurfSrc->pso->iBitmapFormat;
            }

        //**********************************************************************
        // Use the 'wrapper' surface, instead of the original DFB surfobj for GDI
        //**********************************************************************

        TempSrcSurfObjPtr       = SrcPuntPtr;
        }


    //**************************************************************************
    // Check if destination bitmap is a DFB.  If so, create a temporary surfobj
    // (mapped to the screen) that GDI can write on
    //**************************************************************************

    if (pdsurfDst !=0 )
        {
        DstPuntPtr->dhsurf      = 0;                    // Behave like a standard DIB
        if (pdsurfDst->dt == DT_SCREEN)
            {
            DstPuntPtr->sizlBitmap  = pdsurfDst->sizl;
            DstPuntPtr->cjBits  = pdsurfDst->LinearStride * pdsurfDst->sizl.cy;
            DstPuntPtr->pvBits  = pdsurfDst->LinearPtr;
            DstPuntPtr->pvScan0 = pdsurfDst->LinearPtr;
            DstPuntPtr->lDelta  = pdsurfDst->LinearStride;
            DstPuntPtr->iBitmapFormat = ppdev->iBitmapFormat;
            }
        else
            {
            //**********************************************************************
            // This is a DFB which is stored in main memory as a DIB
            //**********************************************************************
            DstPuntPtr->sizlBitmap  = pdsurfDst->pso->sizlBitmap;
            DstPuntPtr->cjBits      = pdsurfDst->pso->lDelta * pdsurfDst->pso->sizlBitmap.cy;
            DstPuntPtr->pvBits  = pdsurfDst->pso->pvBits;
            DstPuntPtr->pvScan0 = pdsurfDst->pso->pvScan0;
            DstPuntPtr->lDelta  = pdsurfDst->pso->lDelta;
            DstPuntPtr->iBitmapFormat = pdsurfDst->pso->iBitmapFormat;
            }

        //**********************************************************************
        // Use the 'wrapper' surface, instead of the original DFB surfobj for GDI
        //**********************************************************************

        TempDstSurfObjPtr       = DstPuntPtr;
        }
    
    //**************************************************************************
    // Let GDI do the blit, even our DFB surfobjs!
    //**************************************************************************
    ppdev->pfnWaitEngineBusy(ppdev);
    bret = (ppdev->pfnEngCopyBits(TempDstSurfObjPtr, TempSrcSurfObjPtr, pco, pxlo, prclDst, pptlSrc));
    goto Exit;

    //**************************************************************************
    //
    // There is a bug in GDI that shows up with MapView (a Japanese app). The
    // problem ends up occuring where an offscreen bitmap is punted to system
    // memory. Then the app does a copy from one part of the bitmap to the other.
    // In some cases, there is overlap and the copy to the destination stomps on
    // the source. Working around that problem here.
    //
    // On entry, pdsurfDst = psoDst->dhsurf
    //           pdsurfSrc = psoSrc->dhsurf
    //
    //**************************************************************************

CheckDibToDibOverlap:

    bltDelta = pdsurfDst->pso->lDelta;

    DstOffsetPtr = SrcOffsetPtr = pdsurfSrc->pso->pvScan0;

    SrcOffsetPtr += (((pptlSrc->x) << (ppdev->cjPelSize/2)) + (pptlSrc->y * bltDelta)) ;
    DstOffsetPtr += (((prclDst->left) << (ppdev->cjPelSize/2)) + (prclDst->top * bltDelta)) ;

    //*****************************************************************
    // Check if Src DIB offsetis before Dest DIB. If so, then we might
    // need to copy this DIB from bottom to top to take care of the
    // overlapping case.
    //*****************************************************************

    if ((SrcOffsetPtr < DstOffsetPtr) &&
        (jClip == DC_TRIVIAL) && (jXlo == XO_TRIVIAL))
        {
        ULONG       bltHeight;
        ULONG       bltWidth;
        ULONG       bitmapEnd;

        bltHeight = prclDst->bottom - prclDst->top;
        bltWidth  = (prclDst->right  - prclDst->left) << (ppdev->cjPelSize/2);
        bitmapEnd = ((bltHeight-1)*bltDelta) + bltWidth;

        //*****************************************************************
        // Check if end of Src DIB overlaps start of Dest DIB. If so, then
        // we handle this case since there is a bug in GDI.
        //*****************************************************************

        if ((SrcOffsetPtr+bitmapEnd) > DstOffsetPtr)
            {
            //*****************************************************************
            // Copy from Src DIB to Dest DIB taking care of overlapping
            //*****************************************************************
            SrcOffsetPtr += bitmapEnd;                 // point to end of src bitmap
            DstOffsetPtr += bitmapEnd;                 // point to end of dest bitmap

            CopyDIBBitmaps (pdsurfDst,
                            DstOffsetPtr,
                            SrcOffsetPtr,
                            bltHeight,
                            bltWidth);

            bret = TRUE;
            goto Exit;
            }
        }
    goto EngCopyBits_It;


Exit:

#if (NVARCH >= 0x4)
    // MSchwarzer 10/04/2000 need this extrypoint for fixes in overlaymode
    if(   (bret)                                            // CopyBit was successful
#if _WIN32_WINNT >= 0x0500
        &&(ppdev->bEnabled)                                 // see above
#endif
        &&(ppdev->bOglOverlaySurfacesCreated)               // OverlayMode is enabled
        &&(XO_TRIVIAL == jXlo )                             // no color translation
        &&(psoDst->iBitmapFormat == ppdev->iBitmapFormat)   // Dst has same format than Primary
      )
    {
        // 1st check for primary to mem/offscreen blit
        if(   (STYPE_DEVICE == psoSrc->iType)
            &&(STYPE_DEVICE != psoDst->iType)
            &&(NULL         == pco  )          // no clipping => need to check this for W2K fading !!
           )
        {
            DISPDBG((20, "PM:psoSrc: 0x%x, psoDst: 0x%x, pco: 0x%x",psoSrc,psoDst,pco));                

            // Check for intersection between source and any overlaywindow and
            // copy mainplanefront of these areas into destination bitmap
            if( bCopyIntersectingMainPlaneFrontToPSO( ppdev, psoSrc, psoDst, prclDst, pptlSrc) )
            {
                // remember Destination Bitmap for restauration purposes
                if(!bAddPointerToList( &ppdev->plSavedPopupMenus, (PULONG)psoDst ))
                {
                    if( bRemoveFirstElementFromList( &ppdev->plSavedPopupMenus ) )
                    {
                        if(!bAddPointerToList( &ppdev->plSavedPopupMenus, (PULONG)psoDst ))
                            DISPDBG((0, "too many popup windows at one time to store !"));                
                    }
                }
            }

        }
        // 2nd check if it was a restauration blit ( mem/offsreen to primary )
        else if(   (STYPE_DEVICE == psoDst->iType)
                 &&(bIsPointerInList(&ppdev->plSavedPopupMenus,(PULONG)psoSrc))
               )
        {
            DISPDBG((20, "MP:psoSrc: 0x%x, psoDst: 0x%x, pco: 0x%x",psoSrc,psoDst,pco));                

            // Restore color format before entering the merge blit. The Colorkey blit 
            // needs the right color format set for the primary surface.
            if (alphaPreserve != NONE)
            {
                NV4DmaPushAlphaPreserve(ppdev, FALSE, alphaPreserve!=COPYBLIT); // Start=FALSE; TRUE if FromCPU else FALSE
                alphaPreserve = NONE;
            }

            // we need to to a mergeblit on any parts of OverlayWindows
            // affected by this blit
            if( !bDoMergeBlitOnIntersectingRectangle(ppdev, prclDst) )
                DISPDBG((0, "bDoMergeBlitOnIntersectingRectangle failed "));                
            if(!bRemovePointerFromList( &ppdev->plSavedPopupMenus, (PULONG)psoSrc ))
               DISPDBG((0, "Could not remove popupmenue from psolist! !"));                
        }
    }
#endif// #if (NVARCH >= 0x4)

    if (alphaPreserve != NONE)
        {
        NV4DmaPushAlphaPreserve(ppdev, FALSE, alphaPreserve!=COPYBLIT); // Start=FALSE; TRUE if FromCPU else FALSE
        }


    return bret;
    }


//*****************************************************************************
//
// There is a bug in GDI that shows up with MapView (a Japanese app). The
// problem ends up occuring where an offscreen bitmap is punted to system
// memory. Then the app does a copy from one part of the bitmap to the other.
// In some cases, there is overlap and the copy to the destination stomps on
// the source. The ntoskrnl!movemem routine checks for overlapping one scanline
// at a time, but the calling code does not take care of the bitmaps overlapping
// correctly. This routine copies the bitmap when a source offset is less than
// the destination offset and takes care of the overlapping.
//
// Note: Performance is not an issue with this bug - this code will almost never
//       execute. The only way I can reproduce this is with MapView on NV3 (with
//       4M or less offscreen memory) at 800x600x32 or 1024x768x32.
//*****************************************************************************

VOID CopyDIBBitmaps (
DSURF*      pdsurf,
BYTE*       DstOffset,      // points to end of DIB bitmap
BYTE*       SrcOffset,      // points to end of DIB bitmap
ULONG       bltHeight,
ULONG       bltWidth)

    {

    LONG    i;
    LONG    cjMiddle;
    LONG    culMiddle;
    LONG    cjStartPhase;
    LONG    cjEndPhase;
    LONG    lDelta;

    lDelta    = pdsurf->pso->lDelta;

    //******************************************************************
    // Align the copy according to the DEST.
    //
    // Careful:  Phase is 0 if on a byte 0 boundary.
    //           Phase is 3 if on a byte 1 boundary.
    //           Phase is 2 if on a byte 2 boundary.
    //           Phase is 1 if on a byte 3 boundary.
    //
    // cjStartPhase is the number of bytes we need to output first, before
    // we can start outputting the rest of the bytes.
    //******************************************************************

    // We ignore upper dword since we only care about bottom 2 bits
    cjStartPhase = (ULONG)((ULONG_PTR)DstOffset & 3);

    //******************************************************************
    // Calculate Number of bytes remaing after outputting the 'starting'
    // phase bytes. We'll later calculate the final culMiddle and cjEndPhase
    // from cjMiddle.
    //**************************************************************************

    cjMiddle = bltWidth - cjStartPhase;

    //**************************************************************************
    // The following condition always holds true:
    //
    //      cjStartPhase + (culMiddle * 4) +cjEndPhase  ==  cjScan
    //
    // EXCEPT for the cases where cjMiddle < 0.  So we must special case them.
    // Here, we'll just get rid of the starting phase.  The end result is that
    // for these case, bytes will only be output in the 'cjEndPhase'.
    //
    //**************************************************************************

    if (cjMiddle < 0)
        {
        cjStartPhase = 0;
        cjMiddle     = bltWidth;
        }

    //**************************************************************************
    // Update the number of bytes we need to add to get to the next scanline,
    // after copying 'cjScan' bytes.
    //**************************************************************************

    lDelta -= bltWidth;

    //**************************************************************************
    // EndPhase will be copied in bytes.
    // MiddlePhase will always be copied in DWORDS.
    // See description up above.
    //**************************************************************************

    cjEndPhase = cjMiddle & 3;
    culMiddle  = cjMiddle >> 2;

    //**********************************************************************
    // Align to the destination (implying that the source may be
    // unaligned).
    // Copy scanlines at a time.
    //**********************************************************************

    for (; bltHeight > 0; bltHeight--)

        {
        //******************************************************************
        // Copy Bytes at a time
        //******************************************************************

        for (i = cjStartPhase; i > 0; i--)
            {
            *(--DstOffset) = *(--SrcOffset);
            }

        //******************************************************************
        // Copy Dwords at a time
        //******************************************************************

        for (i = culMiddle; i > 0; i--)
            {
            *(--((ULONG*)DstOffset)) = *(--((ULONG UNALIGNED *)SrcOffset));
            }

        //******************************************************************
        // Copy Bytes at a time
        //******************************************************************

        for (i = cjEndPhase; i > 0; i--)
            {
            *(--DstOffset) = *(--SrcOffset);
            }

        SrcOffset -= lDelta;
        DstOffset -= lDelta;
        }

    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\brush.c ===
//******************************Module*Header***********************************
//
// Module Name: Brush.c
//
// Handles all brush/pattern initialization and realization.
//
// Copyright (c) 1992-1996 Microsoft Corporation
//
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/


#include "precomp.h"
#include "driver.h"

/******************************Public*Routine**********************************\
* VOID vRealizeDitherPattern
*
* Generates an 8x8 dither pattern, in our internal realization format, for
* the colour ulRGBToDither.  Note that the high byte of ulRGBToDither does
* not need to be set to zero, because vComputeSubspaces ignores it.
\******************************************************************************/

VOID vRealizeDitherPattern(
RBRUSH*     prb,
ULONG       ulRGBToDither)
{
    ULONG           ulNumVertices;
    VERTEX_DATA     vVertexData[4];
    VERTEX_DATA*    pvVertexData;
    LONG            i;

    // Calculate what colour subspaces are involved in the dither:

    pvVertexData = vComputeSubspaces(ulRGBToDither, vVertexData);

    // Now that we have found the bounding vertices and the number of
    // pixels to dither for each vertex, we can create the dither pattern

    ulNumVertices = (ULONG)(pvVertexData - vVertexData);
                      // # of vertices with more than zero pixels in the dither

    // Do the actual dithering:

    vDitherColor(&prb->aulPattern[0], vVertexData, pvVertexData, ulNumVertices);

    // Initialize the fields we need:

    prb->ptlBrushOrg.x = LONG_MIN;
    prb->fl            = 0;

    for (i = 0; i < MAX_BOARDS; i++)
    {
        prb->apbe[i] = NULL;
    }
}

//******************************************************************************
//
//  Function:   DrvRealizeBrush()
//
//  Routine Description:
//
//     This function allows us to convert GDI brushes into an internal form
//     we can use.  It may be called directly by GDI at SelectObject time, or
//     it may be called by GDI as a result of us calling BRUSHOBJ_pvGetRbrush
//     to create a realized brush in a function like DrvBitBlt.
//
//     Note that we have no way of determining what the current Rop or brush
//     alignment are at this point.
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

BOOL DrvRealizeBrush(
BRUSHOBJ*   pbo,
SURFOBJ*    psoDst,
SURFOBJ*    psoPattern,
SURFOBJ*    psoMask,
XLATEOBJ*   pxlo,
ULONG       iHatch)

    {
    PDEV*       ppdev;
    ULONG       iPatternFormat;
    BYTE*       pjSrc;
    BYTE*       pjDst;
    LONG        lSrcDelta;
    LONG        cj;
    LONG        i;
    LONG        j;
    RBRUSH*     prb;
    ULONG*      pulXlate;
    SURFOBJ*    psoPunt;
    RECTL       rclDst;
    BOOL        b;

    ppdev = (PDEV*) psoDst->dhpdev;


    //**************************************************************************
    // We only handle brushes if we have an off-screen brush cache
    // available.  If there isn't one, we can simply fail the realization,
    // and eventually GDI will do the drawing for us (although a lot
    // slower than we could have done it):
    //
    // NOTE: Currently, BRUSH_CACHE is always disabled in Enable.c
    //       For now, we're just going to get the pattern straight from
    //       the brush structure and not cache it....eventually
    //       we'll store it in offscreen memory...but for now...we just
    //       want to get brush functionality working. (without caching)
    //**************************************************************************

    //**************************************************************************
    //    if (!(ppdev->flStatus & STAT_BRUSH_CACHE))
    //        goto ReturnFalse;
    //**************************************************************************

    //**************************************************************************
    // We have a fast path for dithers when we set GCAPS_DITHERONREALIZE:
    // For now, just return false.
    //**************************************************************************

    if (iHatch & RB_DITHERCOLOR)
        {
        //**********************************************************************
        // Implementing DITHERONREALIZE increased our score on a certain
        // unmentionable benchmark by 0.4 million 'megapixels'.  Too bad
        // this didn't work in the first version of NT.
        //**********************************************************************

        //**********************************************************************
        // NV: This case doesn't seem to buy us that much of an improvement.
        //     Leaving out for now...
        //
        //        prb = BRUSHOBJ_pvAllocRbrush(pbo,
        //               sizeof(RBRUSH) + CONVERT_TO_BYTES(TOTAL_BRUSH_SIZE, ppdev));
        //        if (prb == NULL)
        //            goto ReturnFalse;
        //
        //        vRealizeDitherPattern(prb, iHatch);
        //        goto ReturnTrue;
        //**********************************************************************

        goto ReturnFalse;

        }

    //**************************************************************************
    // We only accelerate 8x8 patterns.  Since Win3.1 and Chicago don't
    // support patterns of any other size, it's a safe bet that 99.9%
    // of the patterns we'll ever get will be 8x8:
    //**************************************************************************

    if ((psoPattern->sizlBitmap.cx != 8) ||
        (psoPattern->sizlBitmap.cy != 8))
        goto ReturnFalse;

    iPatternFormat = psoPattern->iBitmapFormat;

    //**************************************************************************
    // Allocate memory for our RBRUSH structure.  The actual
    // pattern bits are stored at the end of this structure.
    //**************************************************************************

    prb = BRUSHOBJ_pvAllocRbrush(pbo,
          sizeof(RBRUSH) + CONVERT_TO_BYTES(TOTAL_BRUSH_SIZE, ppdev));
    if (prb == NULL)
        goto ReturnFalse;

    //**************************************************************************
    // Initialize the fields we need:
    // BrushOrg.X will be initialized to the smallest value possible.
    // Flags will be init to NULL.
    //**************************************************************************

    prb->ptlBrushOrg.x = LONG_MIN;
    prb->fl            = 0;

    //**************************************************************************
    // For now, multi board functionality isn't important to us.
    // MAX_BOARDS should be 1.
    //**************************************************************************

    for (i = 0; i < MAX_BOARDS; i++)
        {
        prb->apbe[i] = NULL;
        }

    //**************************************************************************
    // Now let's take a look at the pattern bitmap.
    // Get the pitch and ptr to the pattern bitmap
    // Also get a ptr to the aulpattern array where we'll store the pattern bits.
    //**************************************************************************

    lSrcDelta = psoPattern->lDelta;
    pjSrc     = (BYTE*) psoPattern->pvScan0;
    pjDst     = (BYTE*) &prb->aulPattern[0];

    //**************************************************************************
    // Handle simple case where pattern bitmap format is same
    // as current screen bitmap format, and palette translation is not required.
    //**************************************************************************

    if ((ppdev->iBitmapFormat == iPatternFormat) &&
        ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)))
        {
        DISPDBG((2, "Realizing un-translated brush"));

        //**********************************************************************
        // The pattern is the same colour depth as the screen, and
        // there's no translation to be done:
        //**********************************************************************

        cj = CONVERT_TO_BYTES(8, ppdev);  // Every pattern is 8 pels wide

        //**********************************************************************
        // RtlCopyMemory is a RunTime library routine (Destination,Src,Length in bytes)
        //**********************************************************************

        for (i = 8; i != 0; i--)
            {
            RtlCopyMemory(pjDst, pjSrc, cj);

            pjSrc += lSrcDelta;
            pjDst += cj;
            }

        }

    //**************************************************************************
    // Don't do monochrome expansion on 24 bpp due to s3 968 feature.
    // For NV, we currently don't support 24bpp anyway.
    // All monochrome expansion will get done here.
    //**************************************************************************

    else if ((iPatternFormat == BMF_1BPP) && (ppdev->iBitmapFormat != BMF_24BPP))

        {
        DISPDBG((2, "Realizing 1bpp brush"));

        //**********************************************************************
        // We word align the monochrome bitmap so that every row starts
        // on a new word (so that we can do word writes later to transfer
        // the bitmap):
        //
        // NV: For NV, we'll just set the pattern object to be an 8x8 pattern.
        //     2 patterns registers (2 dwords) need to be set as follows:
        //                               -------------------------------------
        //          Pattern register 0  | byte 3 |  byte 2 |  byte 1 | byte 0 |
        //                               -------------------------------------
        //                               -------------------------------------
        //          Pattern register 1  | byte 7 |  byte 6 |  byte 5 | byte 4 |
        //                               -------------------------------------
        //
        //     This defines a total of 64 bits (8x8 monochrome pattern)
        //
        //**********************************************************************

        for (i = 8; i != 0; i--)
            {
            *pjDst = *pjSrc;
            pjDst ++;                           // Store NV monochrome pattern bytes
            pjSrc += lSrcDelta;                 // Usually src pattern is dword aligned
            }

        pulXlate         = pxlo->pulXlate;
        prb->fl         |= RBRUSH_2COLOR;
        prb->ulForeColor = pulXlate[1];
        prb->ulBackColor = pulXlate[0];

        }

    //**************************************************************************
    // Pattern is 4bpp, device is currently at 8bpp
    //**************************************************************************

    else if ((iPatternFormat == BMF_4BPP) && (ppdev->iBitmapFormat == BMF_8BPP))

        {
        //**********************************************************************
        // NV: This case doesn't have a signficant impact on performance
        //     so we'll skip it for now.
        //**********************************************************************

        //**********************************************************************
        //        DISPDBG((2, "Realizing 4bpp brush"));
        //
        //        //************************************************************
        //        // The screen is 8bpp and the pattern is 4bpp:
        //        //************************************************************
        //
        //        ASSERTDD((ppdev->iBitmapFormat == BMF_8BPP) &&
        //                 (iPatternFormat == BMF_4BPP),
        //                 "Messed up brush logic");
        //
        //        pulXlate = pxlo->pulXlate;
        //
        //        for (i = 8; i != 0; i--)
        //            {
        //            //********************************************************
        //            // Inner loop is repeated only 4 times because each loop
        //            // handles 2 pixels:
        //            //********************************************************
        //
        //            for (j = 4; j != 0; j--)
        //                {
        //                *pjDst++ = (BYTE) pulXlate[*pjSrc >> 4];
        //                *pjDst++ = (BYTE) pulXlate[*pjSrc & 15];
        //                pjSrc++;
        //                }
        //
        //            pjSrc += lSrcDelta - 4;
        //            }
        //
        //**********************************************************************

        goto ReturnFalse;

        }


    //**************************************************************************
    // NV: Unrecognized/ brush format.  Just punt back to GDI
    //**************************************************************************

    else

        {
        //**********************************************************************
        // We've got a brush whose format we haven't special cased.  No
        // problem, we can have GDI convert it to our device's format.
        // We simply use a temporary surface object that was created with
        // the same format as the display, and point it to our brush
        // realization:
        //**********************************************************************

        DISPDBG((5, "Realizing funky brush"));

        psoPunt          = ppdev->psoPunt3;
        psoPunt->pvBits  = pjDst;
        psoPunt->pvScan0 = pjDst;
        psoPunt->lDelta  = CONVERT_TO_BYTES(8, ppdev);

        rclDst.left      = 0;
        rclDst.top       = 0;
        rclDst.right     = 8;
        rclDst.bottom    = 8;

        ppdev->pfnWaitEngineBusy(ppdev);
        b = ppdev->pfnEngCopyBits(psoPunt, psoPattern, NULL, pxlo,
                                  &rclDst, (POINTL*) &rclDst);

        if (!b)
            {
            goto ReturnFalse;
            }

        }

//**************************************************************************
// ReturnTrue:
//**************************************************************************

    //**************************************************************************
    // NV: Skip following code for now... (we currently don't store
    //     patterns in offscreen memory
    //**************************************************************************

    //**************************************************************************
    //    if (!(ppdev->flCaps & CAPS_HW_PATTERNS))
    //    {
    //        // The last time I checked, GDI took some 500 odd instructions to
    //        // get from here back to whereever we called 'BRUSHOBJ_pvGetRbrush'.
    //        // We can at least use this time to get some overlap between the
    //        // CPU and the display hardware: we'll initialize the 72x72 off-
    //        // screen cache entry now, which will keep the accelerator busy for
    //        // a while.
    //        //
    //        // We don't do this if we have hardware patterns because:
    //        //
    //        //   a) S3 hardware patterns require that the off-screen cached
    //        //      brush be correctly aligned, and at this point we don't have
    //        //      access to the 'pptlBrush' brush origin (although we could
    //        //      have copied it into the PDEV before calling
    //        //      BRUSHOBJ_pvGetRbrush).
    //        //
    //        //   b) S3 hardware patterns require only an 8x8 copy of the
    //        //      pattern; it is not expanded to 72x72, so there isn't even
    //        //      any opportunity for CPU/accelerator processing overlap.
    //
    //        vIoSlowPatRealize(ppdev, prb, FALSE);
    //    }
    //**************************************************************************

    return(TRUE);

ReturnFalse:


    //**************************************************************************
    // NV: Failed call, let GDI handle it
    //**************************************************************************

    if (psoPattern != NULL)
        {
        DISPDBG((2, "Failed realization -- Type: %li Format: %li cx: %li cy: %li",
                    psoPattern->iType, psoPattern->iBitmapFormat,
                    psoPattern->sizlBitmap.cx, psoPattern->sizlBitmap.cy));
        }

    return(FALSE);
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\cliplist.c ===
//******************************Module*Header***********************************
// Module Name: cliplist.c
//
// management functions for CLIPLIST
//
// Copyright (c) 2000, NVIDIA, Corporation.  All rights reserved.
//
// THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
// NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
// IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
//
//******************************************************************************
#include "precomp.h"
#include "driver.h"
#include "RectUtils.h"

#include "cliplist.h"


//*************************************************************************
// bClipListAlloc
//
// allocates a CLIPLIST that can store cMax clip rects.
// All members are initilized to 0 if we don't fail.
//
// return: TRUE  - Success, cMax and array set to new values
//         FALSE - Failure, pClip isn't touched
//
// FNicklis 24.11.98: New
//*************************************************************************
BOOL bClipListAlloc(
  IN OUT CLIPLIST *pClip, // structure to fill out
  IN     LONG      cMax)  // number of rects to allocate
{
  BOOL   bRet = FALSE;
  RECTL *prcl = NULL;

  DBG_TRACE_IN(DBG_LVL_SUBENTRY, bClipListAlloc);

  ASSERTDD(bClipListCheck(pClip),"function isn't used correctly!");
  ASSERTDD(NULL==pClip->prcl,    "cliplist not empty!");
  ASSERTDD(0==pClip->cMax,       "cliplist not empty!");

  prcl = EngAllocMem(FL_ZERO_MEMORY, cMax*sizeof(RECTL), ALLOC_TAG);

  if (NULL == prcl)
  {
    // don't touch structure and exit
    DBG_ERROR("EngAllocMem failed for clip list");
    goto Exit;
  }

  // clear all members as we start a new clip list
  RtlZeroMemory(pClip, sizeof(CLIPLIST));

  pClip->cMax = cMax;
  pClip->prcl = prcl;

  bRet = TRUE;

Exit:
  DBG_TRACE_OUT(DBG_LVL_SUBENTRY, bRet);

  return (bRet);
}


//*************************************************************************
// bClipListFree
//
// Free a cliplist 
//
// return: TRUE=OK, FALSE=error.
//
// FNicklis 01.11.98: New from bFreeNegativeClipList
//*************************************************************************
BOOL bClipListFree(
  IN OUT CLIPLIST *pClip)
{
  BOOL      bRet = FALSE;

  DBG_TRACE_IN(DBG_LVL_SUBENTRY, bClipListFree);

  ASSERTDD(bClipListCheck(pClip),"function isn't used correctly!");

  // is there a cliplist to free?
  if ( (pClip->prcl != NULL) )
  {
    DISPDBG((10,"free %d rects in %d sized buffer",pClip->c,pClip->cMax));
    // all rects should have been counted too then
    // free and invalidate list
    EngFreeMem(pClip->prcl);

    // clear entire structure
    RtlZeroMemory(pClip, sizeof(CLIPLIST));
  }
  else
  {
    DISPDBG((10,"nothing to do"));
  }
  bRet = TRUE;

  DBG_TRACE_OUT(DBG_LVL_SUBENTRY, bRet);

  return (bRet);
}


#define CLIPLIST_GRANULARITY 8

//*************************************************************************
// bClipListReAlloc
//
// Realloc on clip list. Either shrink or grow a cliplist, keeping
// existing data.
//
// return: TRUE  - Success, cMax and array set to new values
//         FALSE - Failure, pClip isn't touched
//
// FNicklis 24.11.98: New
//*************************************************************************
BOOL bClipListReAlloc(
  IN OUT CLIPLIST *pClip,  // structure to fill out
  IN     LONG      cNew)   // number of rects to allocate
{
    BOOL      bRet = FALSE;
    RECTL    *prcl = NULL;
    LONG      cNewMax;
    LONG      c;
    CLIPLIST  NewClip = {0};

    ASSERTDD(bClipListCheck(pClip),"function isn't used correctly!");
    ASSERTDD(NULL!=pClip->prcl,    "cliplist empty!");
    ASSERTDD(0!=pClip->cMax,       "cliplist empty!");

    cNewMax = max(CLIPLIST_GRANULARITY, ((cNew + CLIPLIST_GRANULARITY - 1) / CLIPLIST_GRANULARITY) * CLIPLIST_GRANULARITY);

    if (cNewMax != pClip->cMax)
    {
        if (!bClipListAlloc(&NewClip, cNewMax))
          goto Exit;

        c = min(pClip->c, cNew);

        // copy current rects (if available) to new array
        if (c > 0)
        {
            RtlCopyMemory(NewClip.prcl, pClip->prcl, (c * sizeof(RECTL)) );
            NewClip.c = c;
        }

        bClipListFree(pClip);

        *pClip = NewClip;
    }
    // else nothing to do

    bRet = TRUE;

Exit:
    ASSERTDD(bClipListCheck(pClip),"clip list is now destroyed!");
    return (bRet);
}


//*************************************************************************
// bClipListCopy
//
// Copy max of cOutMax rects out of CLIPLIST to prclOut
//
// return: count of rects copied to prclOut
//
// FNicklis 01.11.98: New
//*************************************************************************
LONG lClipListCopy(
  OUT       RECTL    *prclOut,
  IN        LONG      cOutMax,
  IN  const CLIPLIST *pClip)
{
  LONG lRects = 0; // default is "nothing done"

  DBG_TRACE_IN(DBG_LVL_SUBENTRY, lClipListCopy);
  
  ASSERTDD(bClipListCheck(pClip),"function isn't used correctly!");
  ASSERTDD(cOutMax>0,               "function isn't used correctly!");
  ASSERTDD(NULL!=prclOut,           "function isn't used correctly!");
  
  if (pClip->c > 0)
  {
    ASSERTDD(NULL!=prclOut, "");

    // cannot copy more than room in output buffer!
    lRects = min(pClip->c,cOutMax);

    RtlCopyMemory(
      prclOut,              // dst
      pClip->prcl,          // src
      lRects*sizeof(RECTL));// count
  }

  // check if outputbuffer was to small
  DISPDBGCOND(lRects!=pClip->c, (1, "WARNING in lClipListCopy: cOutMax:%d for pClip->c:%d to small?",cOutMax, pClip->c));

  DBG_TRACE_OUT(DBG_LVL_SUBENTRY, lRects);
  return (lRects);
}

LONG lClipListPixelCount(CLIPLIST *pClip)
{
  LONG      lRects;

  pClip->cPixel = 0;
  for (lRects = 0; lRects <pClip->c; lRects++)
  {
    pClip->cPixel += lRclPixelCount(&pClip->prcl[lRects]);
  }
  return (pClip->cPixel);
}


BOOL bClipListCheck(
  IN  const CLIPLIST *pClip)
{
  BOOL bRet = FALSE;

  if (NULL==pClip)
    bRet = FALSE; // invalid pointer
  else
  {
    if ( (pClip->prcl!=NULL) &&          // if allocated
         (pClip->cMax   >  0) &&         // we need a max amount of rects
         (pClip->cMax   >= pClip->c) &&  // cannot store more than max
         (pClip->c      >= 0) &&         // rects should be stored, or 0 -> reason to free a buffer!
         (pClip->cPixel >= 0) )          // pixels should be counted
    {
     bRet = TRUE;
    }
    else if ( (pClip->prcl   == NULL) && // not allocated
              (pClip->cMax   == 0) &&    // max must be null
              (pClip->c      == 0) &&    // nothing stored
              (pClip->cPixel == 0) )     // no pixels
    {
     bRet = TRUE;
    }
    else
    {
      bRet = FALSE;                     // error
    }
  }
  return (bRet);
}


// End of cliplist.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\cliplist.h ===
#ifndef _CLIPLIST_H
#define _CLIPLIST_H
//******************************Module*Header***********************************
// Module Name: cliplist.h
//
// management functions for struct CLIPLIST
//
// Copyright (c) 2000, NVIDIA, Corporation.  All rights reserved.
//
// THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
// NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
// IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
//
//******************************************************************************

LONG lClipListCopy(
  OUT       RECTL    *prclOut,
  IN        LONG      cOutMax,
  IN  const struct _CLIPLIST *pClip);

BOOL bClipListAlloc(
  IN OUT struct _CLIPLIST *pClip, // structure to fill out
  IN     LONG      cMax); // number of rects to allocate

BOOL bClipListReAlloc(
  IN OUT struct _CLIPLIST *pClip,  // structure to fill out
  IN     LONG      cNewMax);  // number of rects to allocate

BOOL bClipListFree(
  IN OUT struct _CLIPLIST *pClip);

LONG lClipListPixelCount(struct _CLIPLIST *pClip);

VOID vClipListBoundsCalculate(struct _CLIPLIST *pClip);

BOOL bClipListCheck(
  IN  const struct _CLIPLIST *pClip);
#endif // _CLIPLIST_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\debug.c ===
//*****************************Module*Header************************************
//
// Module Name: debug.c
//
// Debug helper routines.
//
// Copyright (c) 1992-1996 Microsoft Corporation
//
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"
#include "driver.h"

#if DBG
    #ifndef _DEBUG_H
    #error debug.c should see debug.h, please include!
    #endif

////////////////////////////////////////////////////////////////////////////
// DEBUGGING INITIALIZATION CODE
//
// When you're bringing up your display for the first time, you can
// recompile with 'DebugLevel' set to 100.  That will cause absolutely
// all DISPDBG messages to be displayed on the kernel debugger (this
// is known as the "PrintF Approach to Debugging" and is about the only
// viable method for debugging driver initialization code).

LONG DebugLevel = 0;            // Set to '100' to debug initialization code
                                //   (the default is '0')

BOOL    g_bNvbreak = FALSE;     // By default, we don't want to assert.

////////////////////////////////////////////////////////////////////////////

LONG gcFifo = 0;                // Number of currently free FIFO entries

BOOL gbCrtcCriticalSection = FALSE;
                                // Have we acquired the CRTC register
                                //   critical section?

#define LARGE_LOOP_COUNT  10000000

////////////////////////////////////////////////////////////////////////////
// Miscellaneous Driver Debug Routines
////////////////////////////////////////////////////////////////////////////

/*****************************************************************************
 *
 *   Routine Description:
 *
 *      This function is variable-argument, level-sensitive debug print
 *      routine.
 *      If the specified debug level for the print statement is lower or equal
 *      to the current debug level, the message will be printed.
 *
 *   Arguments:
 *
 *      DebugPrintLevel - Specifies at which debugging level the string should
 *          be printed
 *
 *      DebugMessage - Variable argument ascii c string
 *
 *   Return Value:
 *
 *      None.
 *
 ***************************************************************************/

VOID
DebugPrint(
    LONG  DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    )
{
    va_list ap;

    va_start(ap, DebugMessage);

    if (DebugPrintLevel <= DebugLevel)
    {
#ifdef _WIN32_WINNT         // NT 4.x
        EngDebugPrint(STANDARD_DEBUG_PREFIX, DebugMessage, ap);
        EngDebugPrint("", "\n", ap);
#else
        char buffer[128];

        vsprintf(buffer, DebugMessage, ap);
        OutputDebugStringA(buffer);
        OutputDebugStringA("\n");
#endif                      // NT 4.x
    }

    va_end(ap);

} // DebugPrint()



/******************************Public*Routine******************************\
* VOID vAcquireCrtc()
* VOID vReleaseCrtc()
*
* Debug thunks for grabbing the CRTC register critical section.
*
\**************************************************************************/

VOID vAcquireCrtc(PDEV* ppdev)
{
    EngAcquireSemaphore(ppdev->csCrtc);

    if (gbCrtcCriticalSection)
        RIP("Had already acquired Critical Section");
    gbCrtcCriticalSection = TRUE;
}

VOID vReleaseCrtc(PDEV* ppdev)
{
    if (!gbCrtcCriticalSection)
        RIP("Hadn't yet acquired Critical Section");
    gbCrtcCriticalSection = FALSE;
    EngReleaseSemaphore(ppdev->csCrtc);
}


//*************************************************************************
// szDbg_GetDBG_NAMEINDEX
// 
// Helper function for DBG_NAMEINDEX to retrieve the string matching 
// ulIndex out of array pNameIndex. 
//
// NOTE: debug.h for more information
//*************************************************************************
char *szDbg_GetDBG_NAMEINDEX(
    IN const DBG_NAMEINDEX *pNameIndex, // pointer to array with lEntries members
    IN       LONG           lEntries,   // number of valid array elements
    IN       ULONG          ulIndex)    // index to find within array
{
    char *szRet=NULL;

    while (lEntries)
    {
        if (pNameIndex->ulIndex == ulIndex)
        { 
            // found index, return string
            szRet = pNameIndex->szName;
            break;
        }
        pNameIndex++;
        lEntries--;
    }

    if (szRet == NULL)
    {
        // entry not found, return default string
        szRet = "unknown";
    }

    return (szRet);
}


//*************************************************************************
// vDbg_PrintDBG_NAMEINDEX
// 
// General debug print for DBG_NAMEINDEX member with ulIndex, using 
// debuglevel and leading string.
//*************************************************************************
VOID vDbg_PrintDBG_NAMEINDEX(
    LONG         DebugPrintLevel,    // debug level
    const PCHAR  pcString,           // any leading string
    char        *(szFlCaps)(ULONG),  // function pointer to stringizer function
    ULONG        ulIndex)            // index to find and to which the matching name has to be printed
{
    DISPDBG((DebugPrintLevel, "%s 0x%08x %s", pcString, ulIndex, szFlCaps(ulIndex) ));
}


//*************************************************************************
// vDbg_PrintDBG_NAMEINDEXfl
// 
// Same as vDbg_PrintDBG_NAMEINDEX but interpreting fl as bitfield and 
// calling stringizer function for every bit.
//*************************************************************************
VOID vDbg_PrintDBG_NAMEINDEXfl(
  LONG DebugPrintLevel, 
  const PCHAR pcString, 
  char *(szFlCaps)(ULONG),  // function pointer to stringizer function
  FLONG fl)
{
    ULONG ul;

    DISPDBG((DebugPrintLevel, "%s: 0x%8x ->", pcString,fl));
    for (ul=0; ul<32; ul++)
    {
        ULONG ulBit = 1<<ul;
        if (fl & ulBit)
        {
            DISPDBG(( DebugPrintLevel, "  0x%8x %s", ulBit, szFlCaps(ulBit) ));
        }
    }
}


//*************************************************************************
// DrvEscape-iEsc stuff:                        
//                                                        
// szDbg_iEscGet                                        
//   return string matching the iEsc
// aDbg_iEsc                                             
//   array defining all known escapes                            
//*************************************************************************
DBG_NAMEINDEX aDbg_iEsc[] =
{
#if _WIN32_WINNT >= 0x0500
    {3076, "MCDFUNCS"},
#else
    {3076, "RXFUNCS" },
#endif
    DBG_MAKE_NAMEINDEX(QUERYESCSUPPORT          ),
    DBG_MAKE_NAMEINDEX(OPENGL_CMD               ),
    DBG_MAKE_NAMEINDEX(OPENGL_GETINFO           ),
    DBG_MAKE_NAMEINDEX(NV_OPENGL_SET_ENABLE     ),
    DBG_MAKE_NAMEINDEX(ESC_ALLOC_CONTEXT_DMA    ),
    DBG_MAKE_NAMEINDEX(ESC_FREE_CONTEXT_DMA     ),
    DBG_MAKE_NAMEINDEX(ESC_ALLOC_CHANNEL_DMA    ),
    DBG_MAKE_NAMEINDEX(ESC_FREE_CHANNEL_DMA     ),
    DBG_MAKE_NAMEINDEX(ESC_DMA_FLOW_CONTROL     ),
    DBG_MAKE_NAMEINDEX(ESC_SET_GAMMA_RAMP       ),
    DBG_MAKE_NAMEINDEX(ESC_GET_GAMMA_RAMP       ),
    DBG_MAKE_NAMEINDEX(ESC_SET_GAMMA_RAMP_MULTI ),
    DBG_MAKE_NAMEINDEX(ESC_GET_GAMMA_RAMP_MULTI ),
    DBG_MAKE_NAMEINDEX(ESC_GET_PIXEL_FORMAT     ),

    DBG_MAKE_NAMEINDEX(NV_ESC_RM_BASE                  ),
    DBG_MAKE_NAMEINDEX(NV_ESC_RM_OPEN                  ),
    DBG_MAKE_NAMEINDEX(NV_ESC_RM_CLOSE                 ),
    DBG_MAKE_NAMEINDEX(NV_ESC_RM_ALLOC_ROOT            ),
    DBG_MAKE_NAMEINDEX(NV_ESC_RM_ALLOC_DEVICE          ),
    DBG_MAKE_NAMEINDEX(NV_ESC_RM_ALLOC_CONTEXT_DMA     ),
    DBG_MAKE_NAMEINDEX(NV_ESC_RM_ALLOC_CHANNEL_PIO     ),
    DBG_MAKE_NAMEINDEX(NV_ESC_RM_ALLOC_CHANNEL_DMA     ),
    DBG_MAKE_NAMEINDEX(NV_ESC_RM_ALLOC_MEMORY          ),
    DBG_MAKE_NAMEINDEX(NV_ESC_RM_ALLOC_OBJECT          ),
    DBG_MAKE_NAMEINDEX(NV_ESC_RM_FREE                  ),
    DBG_MAKE_NAMEINDEX(NV_ESC_RM_DMA_PUSH_INFO         ),
    DBG_MAKE_NAMEINDEX(NV_ESC_RM_ALLOC                 ),
    DBG_MAKE_NAMEINDEX(NV_ESC_RM_CONFIG_VERSION        ),
    DBG_MAKE_NAMEINDEX(NV_ESC_RM_CONFIG_GET            ),
    DBG_MAKE_NAMEINDEX(NV_ESC_RM_CONFIG_SET            ),
    DBG_MAKE_NAMEINDEX(NV_ESC_RM_CONFIG_UPDATE         ),
    DBG_MAKE_NAMEINDEX(NV_ESC_RM_ARCH_HEAP             ),
    DBG_MAKE_NAMEINDEX(NV_ESC_RM_DEBUG_CONTROL         ),
    DBG_MAKE_NAMEINDEX(NV_ESC_RM_CONFIG_GET_EX         ),
    DBG_MAKE_NAMEINDEX(NV_ESC_RM_CONFIG_SET_EX         ),
    DBG_MAKE_NAMEINDEX(NV_ESC_RM_I2C_ACCESS            ),
    DBG_MAKE_NAMEINDEX(NV_ESC_RM_POWER_MANAGEMENT      ),
    DBG_MAKE_NAMEINDEX(NV_ESC_RM_INTERRUPT             ),
    DBG_MAKE_NAMEINDEX(NV_ESC_RM_OS_CONFIG_GET         ),
    DBG_MAKE_NAMEINDEX(NV_ESC_RM_OS_CONFIG_SET         ),
    DBG_MAKE_NAMEINDEX(NV_ESC_RM_OS_CONFIG_GET_EX      ),
    DBG_MAKE_NAMEINDEX(NV_ESC_RM_OS_CONFIG_SET_EX      ),
    DBG_MAKE_NAMEINDEX(NV_ESC_RM_NVWATCH               ),

    DBG_MAKE_NAMEINDEX(WNDOBJ_SETUP),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_DMA_PUSH_GO),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_ESCAPE),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_MEM_TO_SCREEN_SRCCOPY       ),
    DBG_MAKE_NAMEINDEX(ESC_NV_QUERYSET_REGISTRY_KEY              ),
    DBG_MAKE_NAMEINDEX(ESC_NV_MAP_USER	),
    DBG_MAKE_NAMEINDEX(ESC_NV_UNMAP_USER),
    DBG_MAKE_NAMEINDEX(ESC_NV_QUERY_PCI_SLOT                  ),
    DBG_MAKE_NAMEINDEX(ESC_NV_QUERY_HEAD_REFRESH_RATE         ),
    DBG_MAKE_NAMEINDEX(NV_ESC_PRIMARY_INFO),
    DBG_MAKE_NAMEINDEX(ESC_NV_DESKMGR_ZOOMBLIT),
    DBG_MAKE_NAMEINDEX(ESC_NV_WKS_APP_SUPPORT),
};

char *szDbg_iEscGet(ULONG iEsc)
{
  return (DBG_GETDBG_NAMEINDEX(aDbg_iEsc, iEsc));
}

DBG_NAMEINDEX aDbg_NV_OPENGL_ESCAPE[] =
{
    //DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_CREATE_DRAWABLE             ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_DESTROY_DRAWABLE            ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_START_STATE_CLIENT_TRACKING ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_STOP_STATE_CLIENT_TRACKING  ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_DMA_PUSH_GO_CMD             ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_MEM_TO_SCREEN_SRCCOPY       ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_SCREEN_TO_SCREEN_SRCCOPY    ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_SUPPORT_ENABLED             ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_ALLOC_SHARED_MEMORY         ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_FREE_SHARED_MEMORY          ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_GET_DISPLAY_PITCH           ),
    DBG_MAKE_NAMEINDEX(ESC_NV4_OPENGL_SWAP_BUFFERS               ),
    DBG_MAKE_NAMEINDEX(ESC_NV4_OPENGL_FLUSH                      ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_PURGE_DEVICE_BITMAP         ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_FLUSH                       ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_SWAP_BUFFERS                ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_COMMAND                     ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_CPUBLIT                     ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_INIT_STATE                  ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_ALLOC_UNIFIED_SURFACES      ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_FREE_UNIFIED_SURFACES       ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_GET_SURFACE_INFO            ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_DID_STATUS_CHANGE           ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_GET_CLIP_LIST_COUNT         ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_GET_CLIP_LIST               ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_SUPPORT                     ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_REGISTER_RM_CLIENT          ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_UNREGISTER_RM_CLIENT        ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_SET_DAC_BASE                ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_SYNC_CHANNEL                ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_SET_LAYER_PALETTE           ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_GET_LAYER_PALETTE           ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_OVERLAY_MERGEBLIT           ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_PFD_CHECK                   ),
    DBG_MAKE_NAMEINDEX(ESC_NV_OPENGL_SHARED_LIBRARY_SIZES        ),
};

char *szDbg_NV_OPENGL_ESCAPE(ULONG iEsc)
{
  return (DBG_GETDBG_NAMEINDEX(aDbg_NV_OPENGL_ESCAPE, iEsc));
}


//
// SURFOBJ stuff
//
DBG_NAMEINDEX aDbg_SURFOBJiBitmapFormat[] =
{
    DBG_MAKE_NAMEINDEX(BMF_1BPP ),
    DBG_MAKE_NAMEINDEX(BMF_4BPP ),
    DBG_MAKE_NAMEINDEX(BMF_8BPP ),
    DBG_MAKE_NAMEINDEX(BMF_16BPP),
    DBG_MAKE_NAMEINDEX(BMF_24BPP),
    DBG_MAKE_NAMEINDEX(BMF_32BPP),
    DBG_MAKE_NAMEINDEX(BMF_4RLE ),
    DBG_MAKE_NAMEINDEX(BMF_8RLE ),
#if _WIN32_WINNT >= 0x0500
    DBG_MAKE_NAMEINDEX(BMF_JPEG ),
    DBG_MAKE_NAMEINDEX(BMF_PNG  ),
#endif
};

char *szDbg_SURFOBJiBitmapFormat(ULONG iBitmapFormat)
{
  return (DBG_GETDBG_NAMEINDEX(aDbg_SURFOBJiBitmapFormat, iBitmapFormat));
}

#define STYPE_DEVBITMAP_DIB 'derf'

DBG_NAMEINDEX aDbg_SURFOBJiType[] =
{
    DBG_MAKE_NAMEINDEX(STYPE_BITMAP   ),
    DBG_MAKE_NAMEINDEX(STYPE_DEVICE   ),
    DBG_MAKE_NAMEINDEX(STYPE_DEVBITMAP),
    // the following doesn't exist!
    DBG_MAKE_NAMEINDEX(STYPE_DEVBITMAP_DIB),
};

char *szDbg_SURFOBJiType(USHORT iType)
{
  return (DBG_GETDBG_NAMEINDEX(aDbg_SURFOBJiType, (ULONG)iType));
}

char *szDbg_SURFOBJ_surf(SURFOBJ *pso)
{
    if (pso)
    {
        if(IS_DIB_DEVICEBITMAP(pso))
        {
            ASSERT(STYPE_DEVBITMAP==pso->iType);
            return(szDbg_SURFOBJiType((USHORT)STYPE_DEVBITMAP_DIB));
        }
        else
            return(szDbg_SURFOBJiType(pso->iType));
    }
    else
    {
        return "";
    }
}

//
// CLIPOBJ stuff
// 
DBG_NAMEINDEX aDbg_CLIPOBJiDComplexity[] =
{
    DBG_MAKE_NAMEINDEX(DC_TRIVIAL),
    DBG_MAKE_NAMEINDEX(DC_RECT   ),
    DBG_MAKE_NAMEINDEX(DC_COMPLEX),
};

char *szDbg_CLIPOBJiDComplexity(BYTE iDComplexity)
{
  return (DBG_GETDBG_NAMEINDEX(aDbg_CLIPOBJiDComplexity, (ULONG)iDComplexity));
}

//
// XLATEOBJ stuf
//
DBG_NAMEINDEX aDbg_XLATEOBJflXlate[] =
{
    DBG_MAKE_NAMEINDEX(XO_TRIVIAL   ),
    DBG_MAKE_NAMEINDEX(XO_TABLE     ),
    DBG_MAKE_NAMEINDEX(XO_TO_MONO   ),
#if _WIN32_WINNT >= 0x0500
    DBG_MAKE_NAMEINDEX(XO_FROM_CMYK ),
    DBG_MAKE_NAMEINDEX(XO_DEVICE_ICM),
    DBG_MAKE_NAMEINDEX(XO_HOST_ICM  ),
#endif //_WIN32_WINNT >= 0x0500
};

char *szDbg_XLATEOBJflXlate(FLONG flXlate)
{
  return (DBG_GETDBG_NAMEINDEX(aDbg_XLATEOBJflXlate, (ULONG)flXlate));
}





////////////////////////////////////////////////////////////////////////////

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\debug.h ===
#ifndef _DEBUG_H
#define _DEBUG_H
//******************************************************************************
//
// Module Name: debug.h
//
// Commonly used debugging macros.
//
// Copyright (c) 1992-1996 Microsoft Corporation
//
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

extern
VOID
DebugPrint(
    LONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    );

#if DBG

#ifndef _WIN32_WINNT     // If this is NT 3.5
#define OutputDebugString OutputDebugStringA
#define EngDebugBreak() DebugBreak()
#define EngDebugPrint(s1, s2, s3) \
    OutputDebugString(s1);  \
    OutputDebugString(s2);  \
    OutputDebugString(s3)
#endif                  // If this is NT 3.5

VOID DebugLog(LONG, CHAR*, ...);

#define DISPDBG(arg) DebugPrint arg
#define DISPDBGCOND(cond, arg) if (cond) DISPDBG(arg)
#define STATEDBG(level) DebugState(level)


// FNicklisch 28.09.2000: more comfortable Assert and debug functions
#ifdef i386
#define DBG_HW_INDEP_BREAK { __asm {int 3} }
#else
#define DBG_HW_INDEP_BREAK EngDebugBreak()
#endif

//old version #define RIP(x) { DebugPrint(0, x); EngDebugBreak(); }
#define RIP(text)                                                                                                            \
  {                                                                                                                          \
    ENG_TIME_FIELDS localTime;                                                                                               \
    EngQueryLocalTime(&localTime);                                                                                           \
    DebugPrint(0, "RIP %s in %s, %d at %02d:%02d on %02d.%02d.%04d",                                                         \
      text?text:"",__FILE__,__LINE__,localTime.usHour,localTime.usMinute,localTime.usDay,localTime.usMonth,localTime.usYear);\
    DBG_HW_INDEP_BREAK;                                                                                                      \
    DebugPrint(0, "RIP %s in %s, %d at %02d:%02d on %02d.%02d.%04d",                                                         \
      text?text:"",__FILE__,__LINE__,localTime.usHour,localTime.usMinute,localTime.usDay,localTime.usMonth,localTime.usYear);\
  }

//old version #define ASSERTDD(x, y) if (!(x)) RIP(y)
#define ASSERTDD(condition, text)                                                            \
  if (!(condition))                                                                          \
  {                                                                                          \
    DebugPrint(0, "ASSERTION \"%s\" failed: %s (%s,%d)",#condition, text,__FILE__,__LINE__); \
    DBGBREAK(); /* No more output (text) needed! */                                          \
    DebugPrint(0, "ASSERTION \"%s\" failed: %s (%s,%d)",#condition, text,__FILE__,__LINE__); \
  }

#define DBG_ERROR(a) DISPDBG((0, "ERROR, %s", a));

#define DBGBREAK()                                                                                              \
  {                                                                                                             \
    ENG_TIME_FIELDS localTime;                                                                                  \
    EngQueryLocalTime(&localTime);                                                                              \
    DebugPrint(0, "BREAK in %s, %d at %02d:%02d on %02d.%02d.%04d",                                             \
      __FILE__,__LINE__,localTime.usHour,localTime.usMinute,localTime.usDay,localTime.usMonth,localTime.usYear);\
    DBG_HW_INDEP_BREAK;                                                                                         \
    DebugPrint(0, "BREAK in %s, %d at %02d:%02d on %02d.%02d.%04d",                                             \
      __FILE__,__LINE__,localTime.usHour,localTime.usMinute,localTime.usDay,localTime.usMonth,localTime.usYear);\
  }

#undef ASSERT // remove if defined!
#define ASSERT(condition) ASSERTDD(condition,"")

#define NVDBG(x, y) \
    if(!(x)){\
        extern BOOL g_bNvbreak;\
        DebugPrint(0, y);\
        if(g_bNvbreak) {EngDebugBreak();}\
    }

//*************************************************************************
// DBG_NAMEINDEX stuff:
// 
// Little helper code that allows us to easily convert enums or defines to 
// strings.
//*************************************************************************

//
// Basic structure conatining a index and the corresponding string
//
typedef struct _DBG_NAMEINDEX
{
  ULONG ulIndex;
  char *szName;
} DBG_NAMEINDEX;

// This macro simplifies the presetting of nameindex arrays
// Example aDbg_DrvEscapeIEsc in debug.c 
#define DBG_MAKE_NAMEINDEX(id) {(ULONG)id, #id}

// returns the string matching to index using lEntries out of the array pNameIndex
char *szDbg_GetDBG_NAMEINDEX(IN const struct _DBG_NAMEINDEX *pNameIndex, IN LONG lEntries, IN ULONG ulIndex);

// define to simplify the call to szDbg_GetDBG_NAMEINDEX
// Use it withing the specific strinizer function: Example szDbg_GetDrvEscapeIEsc in debug.c
#define DBG_GETDBG_NAMEINDEX(array, ulIndex) szDbg_GetDBG_NAMEINDEX((array), sizeof(array)/sizeof((array)[0]), ulIndex)

// Use Instead of DISPDBG if a 
VOID vDbg_PrintDBG_NAMEINDEX(LONG DebugPrintLevel,const PCHAR pcString,char *(szFlCaps)(ULONG),ULONG ul);
#define DBG_PRINT_DBG_NAMEINDEX(lvl,str,pfn,ul)    vDbg_PrintDBG_NAMEINDEX(lvl,str,pfn,ul)

VOID vDbg_PrintDBG_NAMEINDEXfl(LONG DebugPrintLevel,const PCHAR pcString,char *(szFlCaps)(ULONG),FLONG fl);
#define DBG_PRINT_DBG_NAMEINDEX_FL(lvl,str,pfn,fl) vDbg_PrintDBG_NAMEINDEXfl(lvl,str,pfn,fl)

char *szDbg_iEscGet(ULONG iEsc);
char *szDbg_NV_OPENGL_ESCAPE(ULONG iEsc);
char *szDbg_SURFOBJiBitmapFormat(ULONG iBitmapFormat);
char *szDbg_SURFOBJiType(USHORT iType);
char *szDbg_SURFOBJ_surf(SURFOBJ *pso);
char *szDbg_CLIPOBJiDComplexity(BYTE iDComplexity);
char *szDbg_XLATEOBJflXlate(FLONG flXlate);

// If we are not in a debug environment, we want all of the debug
// information to be stripped out.

// Translate ELSA trace code:
#define DBG_TRACE_IN(a, b)  DISPDBG((a,"%s {", #b))
#define DBG_TRACE_OUT(a, b) DISPDBG((a,"}: 0x%x", (unsigned long)b))
#define DBG_LVL_SUBENTRY  5
#define DBG_LVL_RECT      15

#else

#define EngDebugBreak()
#define DISPDBG(arg)
#define DISPDBGCOND(cond, arg)
#define STATEDBG(level)
#define LOGDBG(arg)
#define RIP(x)
#define ASSERTDD(x, y)

#define DBG_ERROR(a)
#define DBGBREAK()
#define ASSERT(x)


#define NVDBG(x, y)

#define DBG_PRINT_DBG_NAMEINDEX(lvl,str,pfn,ul)
#define DBG_PRINT_DBG_NAMEINDEX_FL(lvl,str,pfn,fl)

#define DBG_TRACE_IN(a,b)
#define DBG_TRACE_OUT(a,b)
#endif

#endif // _DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\color.c ===
/******************************Module*Header*******************************\
* Module Name: color.c
*
* This algorithm for color dithering is patent pending and its use is
* restricted to Microsoft products and drivers for Microsoft products.
* Use in non-Microsoft products or in drivers for non-Microsoft products
* is prohibited without the expressed written consent of Microsoft Corp.
*
* The patent application is the primary reference for the operation of the
* color dithering code.
*
* Note that in the comments and variable names, "vertex" means "vertex of
* either the inner (half intensity) or outer (full intensity) color cube."
* Vertices map to colors 0-7 and 9-15 of the Windows standard (required)
* 16-color palette, where vertices 0-7 are the vertices of the inner color
* cube, and 0 plus 9-15 are the vertices of the full color cube. Vertex 8 is
* 75% gray; this could be used in the dither, but that would break apps that
* depend on the exact Windows 3.1 dithering. This code is Window 3.1
* compatible.
*
* Note that as a result of the compatibility requirement, the dither
* produced by this algorithm is the exact same dither as that produced
* by the default Windows 3.1 16 color and 256 color VGA drivers.
*
* Copyright (c) 1992-1996 Microsoft Corporation
\**************************************************************************/

/**************************************************************************
 *                                                                        *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.          *
 *                                                                        *
 **************************************************************************/

#include "precomp.h"
#include "driver.h"

/**************************************************************************\
* This function takes a value from 0 - 255 and uses it to create an
* 8x8 pile of bits in the form of a 1BPP bitmap.  It can also take an
* RGB value and make an 8x8 bitmap.  These can then be used as brushes
* to simulate color unavaible on the device.
*
* For monochrome the basic algorithm is equivalent to turning on bits
* in the 8x8 array according to the following order:
*
*  00 32 08 40 02 34 10 42
*  48 16 56 24 50 18 58 26
*  12 44 04 36 14 46 06 38
*  60 28 52 20 62 30 54 22
*  03 35 11 43 01 33 09 41
*  51 19 59 27 49 17 57 25
*  15 47 07 39 13 45 05 37
*  63 31 55 23 61 29 53 21
*
* Reference: A Survey of Techniques for the Display of Continous
*            Tone Pictures on Bilevel Displays,;
*            Jarvis, Judice, & Ninke;
*            COMPUTER GRAPHICS AND IMAGE PROCESSING 5, pp 13-40, (1976)
\**************************************************************************/

#define SWAP_RB 0x00000004
#define SWAP_GB 0x00000002
#define SWAP_RG 0x00000001

#define SWAPTHEM(a,b) (ulTemp = a, a = b, b = ulTemp)

// PATTERNSIZE is the number of pixels in a dither pattern.
#define PATTERNSIZE 64

typedef union _PAL_ULONG {
    PALETTEENTRY pal;
    ULONG ul;
} PAL_ULONG;

// Tells which row to turn a pel on in when dithering for monochrome bitmaps.
static BYTE ajByte[] = {
    0, 4, 0, 4, 2, 6, 2, 6,
    0, 4, 0, 4, 2, 6, 2, 6,
    1, 5, 1, 5, 3, 7, 3, 7,
    1, 5, 1, 5, 3, 7, 3, 7,
    0, 4, 0, 4, 2, 6, 2, 6,
    0, 4, 0, 4, 2, 6, 2, 6,
    1, 5, 1, 5, 3, 7, 3, 7,
    1, 5, 1, 5, 3, 7, 3, 7
};

// The array of monochrome bits used for monc
static BYTE ajBits[] = {
    0x80, 0x08, 0x08, 0x80, 0x20, 0x02, 0x02, 0x20,
    0x20, 0x02, 0x02, 0x20, 0x80, 0x08, 0x08, 0x80,
    0x40, 0x04, 0x04, 0x40, 0x10, 0x01, 0x01, 0x10,
    0x10, 0x01, 0x01, 0x10, 0x40, 0x04, 0x04, 0x40,
    0x40, 0x04, 0x04, 0x40, 0x10, 0x01, 0x01, 0x10,
    0x10, 0x01, 0x01, 0x10, 0x40, 0x04, 0x04, 0x40,
    0x80, 0x08, 0x08, 0x80, 0x20, 0x02, 0x02, 0x20,
    0x20, 0x02, 0x02, 0x20, 0x80, 0x08, 0x08, 0x80
};

// Translates vertices back to the original subspace. Each row is a subspace,
// as encoded in ulSymmetry, and each column is a vertex between 0 and 15.
BYTE jSwapSubSpace[8*16] = {
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
    0, 2, 1, 3, 4, 6, 5, 7, 8, 10, 9, 11, 12, 14, 13, 15,
    0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15,
    0, 4, 1, 5, 2, 6, 3, 7, 8, 12, 9, 13, 10, 14, 11, 15,
    0, 4, 2, 6, 1, 5, 3, 7, 8, 12, 10, 14, 9, 13, 11, 15,
    0, 2, 4, 6, 1, 3, 5, 7, 8, 10, 12, 14, 9, 11, 13, 15,
    0, 4, 1, 5, 2, 6, 3, 7, 8, 12, 9, 13, 10, 14, 11, 15,
    0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15,
};

// Converts a nibble value in the range 0-15 to a dword value containing the
// nibble value packed 8 times.
ULONG ulNibbleToDword[16] = {
    0x00000000,
    0x01010101,
    0x02020202,
    0x03030303,
    0x04040404,
    0x05050505,
    0x06060606,
    0xF8F8F8F8,
    0x07070707,
    0xF9F9F9F9,
    0xFAFAFAFA,
    0xFBFBFBFB,
    0xFCFCFCFC,
    0xFDFDFDFD,
    0xFEFEFEFE,
    0xFFFFFFFF
};

// Specifies where in the dither pattern colors should be placed in order
// of increasing intensity.
ULONG aulDitherOrder[] = {
  0, 36,  4, 32, 18, 54, 22, 50,
  2, 38,  6, 34, 16, 52, 20, 48,
  9, 45, 13, 41, 27, 63, 31, 59,
 11, 47, 15, 43, 25, 61, 29, 57,
  1, 37,  5, 33, 19, 55, 23, 51,
  3, 39,  7, 35, 17, 53, 21, 49,
  8, 44, 12, 40, 26, 62, 30, 58,
 10, 46, 14, 42, 24, 60, 28, 56,
};

// Array to convert to 256 color from 16 color. Maps from index that represents
// a 16-color vertex (color) to value that specifies the color index in the
// 256-color palette.
BYTE ajConvert[] =
{
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    248,
    7,
    249,
    250,
    251,
    252,
    253,
    254,
    255
};

/******************************Public*Routine******************************\
* vComputeSubspaces
*
* Calculates the subspace data associated with rgb, stores the data at
* pvVertexData, in the form of an array of VERTEX_DATA structures,
* suitable for vDitherColor. Returns a pointer to the byte after the
* last VERTEX_DATA structure.
*
* Ignores the high byte of rgb.
*
\**************************************************************************/

VERTEX_DATA* vComputeSubspaces(
ULONG           rgb,
VERTEX_DATA*    pvVertexData)
{
    ULONG   ulRedTemp, ulGreenTemp, ulBlueTemp, ulSymmetry;
    ULONG   ulRed, ulGre, ulBlu, ulTemp;
    ULONG   ulVertex0Temp, ulVertex1Temp, ulVertex2Temp, ulVertex3Temp;

    // Split the color into red, green, and blue components
    ulRedTemp   = ((PAL_ULONG *)&rgb)->pal.peRed;
    ulGreenTemp   = ((PAL_ULONG *)&rgb)->pal.peGreen;
    ulBlueTemp   = ((PAL_ULONG *)&rgb)->pal.peBlue;

    // Sort the RGB so that the point is transformed into subspace 0, and
    // keep track of the swaps in ulSymmetry so we can unravel it again
    // later.  We want r >= g >= b (subspace 0).
    ulSymmetry = 0;
    if (ulBlueTemp > ulRedTemp) {
        SWAPTHEM(ulBlueTemp,ulRedTemp);
        ulSymmetry = SWAP_RB;
    }

    if (ulBlueTemp > ulGreenTemp) {
        SWAPTHEM(ulBlueTemp,ulGreenTemp);
        ulSymmetry |= SWAP_GB;
    }

    if (ulGreenTemp > ulRedTemp) {
        SWAPTHEM(ulGreenTemp,ulRedTemp);
        ulSymmetry |= SWAP_RG;
    }

    ulSymmetry <<= 4;   // for lookup purposes

    // Scale the values from 0-255 to 0-64. Note that the scaling is not
    // symmetric at the ends; this is done to match Windows 3.1 dithering
    ulRed = (ulRedTemp + 1) >> 2;
    ulGre = (ulGreenTemp + 1) >> 2;
    ulBlu = (ulBlueTemp + 1) >> 2;

    // Compute the subsubspace within subspace 0 in which the point lies,
    // then calculate the # of pixels to dither in the colors that are the
    // four vertexes of the tetrahedron bounding the color we're emulating.
    // Only vertices with more than zero pixels are stored, and the
    // vertices are stored in order of increasing intensity, saving us the
    // need to sort them later
    if ((ulRedTemp + ulGreenTemp) > 256) {
        // Subsubspace 2 or 3
        if ((ulRedTemp + ulBlueTemp) > 256) {
            // Subsubspace 3
            // Calculate the number of pixels per vertex, still in
            // subsubspace 3, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 3 is:
            // 7, 9, 0x0B, 0x0F
            if ((ulVertex0Temp = (64 - ulRed) << 1) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
            ulVertex2Temp = ulGre - ulBlu;
            ulVertex3Temp = (ulRed - 64) + ulBlu;
            if ((ulVertex1Temp = ((PATTERNSIZE - ulVertex0Temp) -
                    ulVertex2Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
            }
            if (ulVertex2Temp != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0B];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0F];
            }
        } else {
            // Subsubspace 2
            // Calculate the number of pixels per vertex, still in
            // subsubspace 2, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 2 is:
            // 3, 7, 9, 0x0B
            ulVertex1Temp = ulBlu << 1;
            ulVertex2Temp = ulRed - ulGre;
            ulVertex3Temp = (ulRed - 32) + (ulGre - 32);
            if ((ulVertex0Temp = ((PATTERNSIZE - ulVertex1Temp) -
                        ulVertex2Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
            }
            if (ulVertex1Temp != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
            if (ulVertex2Temp != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0B];
            }
        }
    } else {
        // Subsubspace 0 or 1
        if (ulRedTemp > 128) {
            // Subsubspace 1
            // Calculate the number of pixels per vertex, still in
            // subsubspace 1, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 1 is:
            // 1, 3, 7, 9
            if ((ulVertex0Temp = ((32 - ulGre) + (32 - ulRed)) << 1) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x01];
            }
            ulVertex2Temp = ulBlu << 1;
            ulVertex3Temp = (ulRed - 32) << 1;
            if ((ulVertex1Temp = ((PATTERNSIZE - ulVertex0Temp) -
                    ulVertex2Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
            }
            if (ulVertex2Temp != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
            }
        } else {
            // Subsubspace 0
            // Calculate the number of pixels per vertex, still in
            // subsubspace 0, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 0 is:
            // 0, 1, 3, 7
            if ((ulVertex0Temp = (32 - ulRed) << 1) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x00];
            }
            if ((ulVertex1Temp = (ulRed - ulGre) << 1) != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x01];
            }
            ulVertex3Temp = ulBlu << 1;
            if ((ulVertex2Temp = ((PATTERNSIZE - ulVertex0Temp) -
                    ulVertex1Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
        }
    }

    return(pvVertexData);
}

/******************************Public*Routine******************************\
* vDitherColor
*
* Dithers the ulNumVertices vertices described by vVertexData into pulDest.
*
\**************************************************************************/

VOID vDitherColor(
ULONG*          pulDest,
VERTEX_DATA*    vVertexData,
VERTEX_DATA*    pvVertexDataEnd,
ULONG           ulNumVertices)
{
    ULONG ulTemp, ulNumPixels, ulColor;
    VERTEX_DATA *pvMaxVertex, *pvVertexData;
    ULONG  *pulDitherOrder;
    BYTE    jColor;
    BYTE   *pjDither = (BYTE *)pulDest;

    if (ulNumVertices > 2) {

        // There are 3 or 4 vertices in this dither
        if (ulNumVertices == 3) {

            // There are 3 vertices in this dither

            // Find the vertex with the most pixels, and fill the whole
            // destination bitmap with that vertex's color, which is faster
            // than dithering it
            if (vVertexData[1].ulCount >= vVertexData[2].ulCount) {
                pvMaxVertex = &vVertexData[1];
                ulTemp = vVertexData[1].ulCount;
            } else {
                pvMaxVertex = &vVertexData[2];
                ulTemp = vVertexData[2].ulCount;
            }

        } else {

            // There are 4 vertices in this dither

            // Find the vertex with the most pixels, and fill the whole
            // destination bitmap with that vertex's color, which is faster
            // than dithering it
            if (vVertexData[2].ulCount >= vVertexData[3].ulCount) {
                pvMaxVertex = &vVertexData[2];
                ulTemp = vVertexData[2].ulCount;
            } else {
                pvMaxVertex = &vVertexData[3];
                ulTemp = vVertexData[3].ulCount;
            }
        }

        if (vVertexData[1].ulCount > ulTemp) {
            pvMaxVertex = &vVertexData[1];
            ulTemp = vVertexData[1].ulCount;
        }
        if (vVertexData[0].ulCount > ulTemp) {
            pvMaxVertex = &vVertexData[0];
        }

        // Prepare a dword version of the most common vertex number (color)
        ulColor = ulNibbleToDword[pvMaxVertex->ulVertex];

        // Mark that the vertex we're about to do doesn't need to be done
        // later
        pvMaxVertex->ulVertex = 0xFF;

        // Block fill the dither pattern with the more common vertex
        *pulDest = ulColor;
        *(pulDest+1) = ulColor;
        *(pulDest+2) = ulColor;
        *(pulDest+3) = ulColor;
        *(pulDest+4) = ulColor;
        *(pulDest+5) = ulColor;
        *(pulDest+6) = ulColor;
        *(pulDest+7) = ulColor;
        *(pulDest+8) = ulColor;
        *(pulDest+9) = ulColor;
        *(pulDest+10) = ulColor;
        *(pulDest+11) = ulColor;
        *(pulDest+12) = ulColor;
        *(pulDest+13) = ulColor;
        *(pulDest+14) = ulColor;
        *(pulDest+15) = ulColor;

        // Now dither all the remaining vertices in order 0->2 or 0->3
        // (in order of increasing intensity)
        pulDitherOrder = aulDitherOrder;
        pvVertexData = vVertexData;
        do {
            if (pvVertexData->ulVertex == 0xFF) {
                // This is the max vertex, which we already did, but we
                // have to account for it in the dither order
                pulDitherOrder += pvVertexData->ulCount;
            } else {
                jColor = (BYTE) ajConvert[pvVertexData->ulVertex];
                ulNumPixels = pvVertexData->ulCount;
                switch (ulNumPixels & 3) {
                    case 3:
                        pjDither[*(pulDitherOrder+2)] = jColor;
                    case 2:
                        pjDither[*(pulDitherOrder+1)] = jColor;
                    case 1:
                        pjDither[*(pulDitherOrder+0)] = jColor;
                        pulDitherOrder += ulNumPixels & 3;
                    case 0:
                        break;
                }
                if ((ulNumPixels >>= 2) != 0) {
                    do {
                        pjDither[*pulDitherOrder] = jColor;
                        pjDither[*(pulDitherOrder+1)] = jColor;
                        pjDither[*(pulDitherOrder+2)] = jColor;
                        pjDither[*(pulDitherOrder+3)] = jColor;
                        pulDitherOrder += 4;
                    } while (--ulNumPixels);
                }
            }
        } while (++pvVertexData < pvVertexDataEnd);

    } else if (ulNumVertices == 2) {

        // There are exactly two vertices with more than zero pixels; fill
        // in the dither array as follows: block fill with vertex with more
        // points first, then dither in the other vertex
        if (vVertexData[0].ulCount >= vVertexData[1].ulCount) {
            // There are no more vertex 1 than vertex 0 pixels, so do
            // the block fill with vertex 0
            ulColor = ulNibbleToDword[vVertexData[0].ulVertex];
            // Do the dither with vertex 1
            jColor = (BYTE) ajConvert[vVertexData[1].ulVertex];
            ulNumPixels = vVertexData[1].ulCount;
            // Set where to start dithering with vertex 1 (vertex 0 is
            // lower intensity, so its pixels come first in the dither
            // order)
            pulDitherOrder = aulDitherOrder + vVertexData[0].ulCount;
        } else {
            // There are more vertex 1 pixels, so do the block fill
            // with vertex 1
            ulColor = ulNibbleToDword[vVertexData[1].ulVertex];
            // Do the dither with vertex 0
            jColor = (BYTE) ajConvert[vVertexData[0].ulVertex];
            ulNumPixels = vVertexData[0].ulCount;
            // Set where to start dithering with vertex 0 (vertex 0 is
            // lower intensity, so its pixels come first in the dither
            // order)
            pulDitherOrder = aulDitherOrder;
        }

        // Block fill the dither pattern with the more common vertex
        *pulDest = ulColor;
        *(pulDest+1) = ulColor;
        *(pulDest+2) = ulColor;
        *(pulDest+3) = ulColor;
        *(pulDest+4) = ulColor;
        *(pulDest+5) = ulColor;
        *(pulDest+6) = ulColor;
        *(pulDest+7) = ulColor;
        *(pulDest+8) = ulColor;
        *(pulDest+9) = ulColor;
        *(pulDest+10) = ulColor;
        *(pulDest+11) = ulColor;
        *(pulDest+12) = ulColor;
        *(pulDest+13) = ulColor;
        *(pulDest+14) = ulColor;
        *(pulDest+15) = ulColor;

        // Dither in the less common vertex
        switch (ulNumPixels & 3) {
            case 3:
                pjDither[*(pulDitherOrder+2)] = jColor;
            case 2:
                pjDither[*(pulDitherOrder+1)] = jColor;
            case 1:
                pjDither[*(pulDitherOrder+0)] = jColor;
                pulDitherOrder += ulNumPixels & 3;
            case 0:
                break;
        }
        if ((ulNumPixels >>= 2) != 0) {
            do {
                pjDither[*pulDitherOrder] = jColor;
                pjDither[*(pulDitherOrder+1)] = jColor;
                pjDither[*(pulDitherOrder+2)] = jColor;
                pjDither[*(pulDitherOrder+3)] = jColor;
                pulDitherOrder += 4;
            } while (--ulNumPixels);
        }

    } else {

        // There is only one vertex in this dither

        // No sorting or dithering is needed for just one color; we can
        // just generate the final DIB directly
        ulColor = ulNibbleToDword[vVertexData[0].ulVertex];
        *pulDest = ulColor;
        *(pulDest+1) = ulColor;
        *(pulDest+2) = ulColor;
        *(pulDest+3) = ulColor;
        *(pulDest+4) = ulColor;
        *(pulDest+5) = ulColor;
        *(pulDest+6) = ulColor;
        *(pulDest+7) = ulColor;
        *(pulDest+8) = ulColor;
        *(pulDest+9) = ulColor;
        *(pulDest+10) = ulColor;
        *(pulDest+11) = ulColor;
        *(pulDest+12) = ulColor;
        *(pulDest+13) = ulColor;
        *(pulDest+14) = ulColor;
        *(pulDest+15) = ulColor;
    }
}

/******************************Public*Routine******************************\
* DrvDitherColor
*
* Dithers an RGB color to an 8X8 approximation using the reserved VGA
* colours.
*
\**************************************************************************/

ULONG DrvDitherColor(
DHPDEV  dhpdev,
ULONG   iMode,
ULONG   rgb,
ULONG*  pul)
{
    ULONG   ulGrey, ulRed, ulGre, ulBlu, ulTemp;
    VERTEX_DATA vVertexData[4];
    VERTEX_DATA *pvVertexData;

    // Figure out if we need a full color dither or only a monochrome dither.

    // Note: we'll get colour dithers only at 8bpp, because that's the
    //       only colour depth at which we set GCAPS_COLOR_DITHER.

    if (iMode != DM_MONOCHROME)
    {
        // Full color dither

        // Calculate what color subspaces are involved in the dither
        pvVertexData = vComputeSubspaces(rgb, vVertexData);

        // Now that we have found the bounding vertices and the number of
        // pixels to dither for each vertex, we can create the dither pattern

        // Handle 1, 2, and 3 & 4 vertices per dither separately
        ulTemp = (ULONG)(pvVertexData - vVertexData);
                                                // # of vertices with more than
                                                //  zero pixels in the dither

        vDitherColor(pul, vVertexData, pvVertexData, ulTemp);
    }
    else
    {
        // Note: we can get monochrome dithers at any colour depth because
        //       we always set GCAPS_MONO_DITHER.

        // For monochrome we will only use the Intensity (grey level)

        RtlFillMemory((PVOID) pul, PATTERNSIZE/2, 0);  // zero the dither bits

        ulRed   = (ULONG) ((PALETTEENTRY *) &rgb)->peRed;
        ulGre = (ULONG) ((PALETTEENTRY *) &rgb)->peGreen;
        ulBlu  = (ULONG) ((PALETTEENTRY *) &rgb)->peBlue;

        // I = .30R + .59G + .11B
        // For convience the following ratios are used:
        //
        //  77/256 = 30.08%
        // 151/256 = 58.98%
        //  28/256 = 10.94%

        ulGrey  = (((ulRed * 77) + (ulGre * 151) + (ulBlu * 28)) >> 8) & 255;

        // Convert the RGBI from 0-255 to 0-64 notation.

        ulGrey = (ulGrey + 1) >> 2;

        while(ulGrey) {
            ulGrey--;
            pul[ajByte[ulGrey]] |= ((ULONG) ajBits[ulGrey]);
        }
    }

    return(DCR_DRIVER);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\ddraw.c ===
//******************************************************************************
//
// Copyright (c) 1995-1996 Microsoft Corporation
//
// Module Name:
//
//     DDRAW.C
//
// Abstract:
//
//     Implements all the DirectDraw components for the driver.
//
// Environment:
//
//     kernel mode only
//
// Notes:
//
// Revision History:
//
//     This driver was adapted from the S3 Display driver
//
//******************************************************************************

//******************************************************************************
//
// Copyright (c) 1996,1997  NVidia Corporation. All Rights Reserved
//
//******************************************************************************

#include "precomp.h"
#include "driver.h"
#include "nvPriv.h"
#include "nvReg.h"

#include "ddminint.h"

#include "nvalpha.h"
#ifdef NVD3D
    #include "dx95type.h"
    #include "nvntd3d.h"
    #include "nvProcMan.h"
    #include "ddmini.h"
#endif

#include "nvos.h"
#include "nvntioctl.h"
#include "nvntddctl.h"
#include "nvapi.h"
#include "nvsubch.h"
#include "nvcm.h"

#include "oglutils.h"

#ifdef NVD3D

#include "dx95type.h"
#define _NO_COM
#include "ddkernel.h"
#undef _NO_COM
#define NV_DD_DMA_PUSH_BUFFER_SIZE      (2*1024*1024)
                                        // This is a temporary default til we get the registry stuff going.

#ifndef _WIN64
extern DWORD __stdcall GetDriverInfo32(LPDDHAL_GETDRIVERINFODATA lpData);
#endif // D3D is not 64 bit code clean , skip for now...

// D3D Callbacks
extern DWORD __fastcall D3DClear2( LPD3DHAL_CLEAR2DATA);
extern DWORD __fastcall D3DValidateTextureStageState( LPD3DHAL_VALIDATETEXTURESTAGESTATEDATA);
extern DWORD __fastcall D3DDrawPrimitives2( LPD3DHAL_DRAWPRIMITIVES2DATA);
extern DWORD __fastcall D3DSetRenderTarget32(LPD3DHAL_SETRENDERTARGETDATA);


ULONG a = (ULONG)DDERR_UNSUPPORTED;
ULONG b = (ULONG)DDERR_GENERIC;
ULONG c = (ULONG)DDERR_OUTOFCAPS;

//extern DDHAL_DDKERNELCALLBACKS KernelCallbacks;
extern DDHAL_DDCOLORCONTROLCALLBACKS ColorControlCallbacks;
DDKERNELCAPS KernelCaps =
{
    sizeof( DDKERNELCAPS ),
    DDKERNELCAPS_SKIPFIELDS|DDKERNELCAPS_SETSTATE|
        DDKERNELCAPS_LOCK|DDKERNELCAPS_FLIPVIDEOPORT|DDKERNELCAPS_FLIPOVERLAY| \
        DDKERNELCAPS_FIELDPOLARITY,
    DDIRQ_DISPLAY_VSYNC|DDIRQ_VPORT0_VSYNC
};

DWORD WINAPI DdGetDriverInfo(struct _DD_GETDRIVERINFODATA *);
VOID nvTexDeSwizzle16BPP(int, int, int);
VOID nvTexSwizzle16BPP(int, int, int);

//*******************************************************************
// These functions initialize the driver caps and callbacks. They
// can be found in the common DX driver source.
// nvBuildDDHALInfo32   - ddDrv.cpp
//*******************************************************************
//BOOL nvBuildDDHALInfo32  (GLOBALDATA *pDriverData);

//
// One time DX6 Init/Destroy code. This is the "16 bit" ddraw init code
// from the Win9x GDI driver. Found in
// $(BUILDDIR)\main\drivers\common\nvX\src\ddmini16.c.
//
ULONG ddEnable(PDEV *lpDevice);

#else   // !NVD3D
DWORD __stdcall DriverInit_NT4(GLOBALDATA * pDriverData);
DWORD WINAPI GetDriverInfo32(struct _DD_GETDRIVERINFODATA *lpData);
#endif // #ifdef NVD3D

#ifdef NVPE
extern const DDHAL_DDVIDEOPORTCALLBACKS LPBVideoPortCallbacks;
extern const DDHAL_DDKERNELCALLBACKS KernelCallbacks;
extern const DDVIDEOPORTCAPS g_ddNVideoPortCaps;
///// H.AZAR: (02/29/2000): this function is defined in nvpkrnl.c (nvpe.lib)
#ifdef __cplusplus
extern "C" {
#endif
BOOL __stdcall NVPIsVPEEnabled(GLOBALDATA *pDriverData, DWORD hDriver);
#ifdef __cplusplus
}
#endif // __cplusplus
#endif // NVPE

/*
 * IN_VBLANK should be replaced by a test to see if the hardware is currently
 * in the vertical blank
 */
#define IN_VBLANK               FALSE
#define IN_DISPLAY              TRUE

/*
 * CURRENT_VLINE should be replaced by a macro to retrieve the current
 * scanline
 */
#define CURRENT_VLINE   (ppdev->pfnGetScanline(ppdev))

// Defines we'll use in the surface's 'dwReserved1' field:

#define DD_RESERVED_DIFFERENTPIXELFORMAT    0x0001


// Worst-case possible number of FIFO entries we'll have to wait for in
// DdBlt for any operation:

#define DDBLT_FIFO_COUNT    9

// NT is kind enough to pre-calculate the 2-d surface offset as a 'hint' so
// that we don't have to do the following, which would be 6 DIVs per blt:
//
//    y += (offset / pitch)
//    x += (offset % pitch) / bytes_per_pixel

#define convertToGlobalCord(x, y, surf) \
{                                       \
    y += surf->yHint;                   \
    x += surf->xHint;                   \
}

//******************************************************************************
// External declarations
//******************************************************************************

//******************************Public*Routine**********************************
//
// Function: DdMapMemory()
//
//      This is a new DDI call specific to Windows NT that is used to map
//      or unmap all the application modifiable portions of the frame buffer
//      into the specified process's address space.
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************

DWORD DdMapMemory(
                 PDD_MAPMEMORYDATA lpMapMemory)

    {
    PDEV*                           ppdev;
    VIDEO_SHARE_MEMORY              ShareMemory;
    VIDEO_SHARE_MEMORY_INFORMATION  ShareMemoryInformation;
    DWORD                           ReturnedDataLength;

    ppdev = (PDEV*) lpMapMemory->lpDD->dhpdev;

    if (lpMapMemory->bMap)
        {
        ShareMemory.ProcessHandle = lpMapMemory->hProcess;

        //**********************************************************************
        // 'RequestedVirtualAddress' isn't actually used for the SHARE IOCTL:
        //**********************************************************************

        ShareMemory.RequestedVirtualAddress = 0;

        //**********************************************************************
        // We map in starting at the top of the frame buffer:
        //**********************************************************************

        ShareMemory.ViewOffset = 0;

        //**********************************************************************
        // We map down to the end of the frame buffer.
        //
        // Note: There is a 64k granularity on the mapping (meaning that
        //       we have to round up to 64k).
        //
        // Note: If there is any portion of the frame buffer that must
        //       not be modified by an application, that portion of memory
        //       MUST NOT be mapped in by this call.  This would include
        //       any data that, if modified by a malicious application,
        //       would cause the driver to crash.  This could include, for
        //       example, any DSP code that is kept in off-screen memory.
        //
        // NOTE: AdapterMemorySize was adjusted in NVValidateModes
        //       to compensate for INSTANCE memory in offscreen memory.
        //       That is, Hash Table, Fifo Context, and Run Out information
        //       is stored in PRAMIN memory, which also exists in offscreen memory.
        //       We must make sure NO ONE (but the miniport) touches this offscreen memory.
        //       To make a long story short, AdapterMemorySize was adjusted by
        //       64k in NVValidateModes (The last 64k of VRAM contains Instance memory).
        //       See NVValidateModes for more comments.
        //**********************************************************************

        ShareMemory.ViewSize
        = ROUND_UP_TO_64K(ppdev->cbFrameBuf);

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_SHARE_VIDEO_MEMORY,
                               &ShareMemory,
                               sizeof(VIDEO_SHARE_MEMORY),
                               &ShareMemoryInformation,
                               sizeof(VIDEO_SHARE_MEMORY_INFORMATION),
                               &ReturnedDataLength))
            {
            DISPDBG((2, "Failed IOCTL_VIDEO_SHARE_MEMORY"));

            lpMapMemory->ddRVal = DDERR_GENERIC;
            return (DDHAL_DRIVER_HANDLED);
            }

        // Be aware of IA64 when doing ptr arithmetic !!
        // fpProcess is of type FLATPTR, VirtualAddres is PVOID
        lpMapMemory->fpProcess = (FLATPTR) ShareMemoryInformation.VirtualAddress;

#if _WIN32_WINNT < 0x0500
        // we need this to count Ddraw Clients
        NV_OglDDrawSurfaceCreated(ppdev);
#endif
        }

    else

        {
        ShareMemory.ProcessHandle           = lpMapMemory->hProcess;
        ShareMemory.ViewOffset              = 0;
        ShareMemory.ViewSize                = 0;
        ShareMemory.RequestedVirtualAddress = (VOID*) lpMapMemory->fpProcess;

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_UNSHARE_VIDEO_MEMORY,
                               &ShareMemory,
                               sizeof(VIDEO_SHARE_MEMORY),
                               NULL,
                               0,
                               &ReturnedDataLength))
            {
            RIP("Failed IOCTL_VIDEO_UNSHARE_MEMORY");
            }

#if _WIN32_WINNT < 0x0500
        // we need this to count Ddraw Clients
        NV_OglDDrawSurfaceDestroyed(ppdev);
#endif
        }

    lpMapMemory->ddRVal = DD_OK;
    return (DDHAL_DRIVER_HANDLED);
    }

#ifndef NVD3D
/*
 * GetScanLine32
 */
DWORD GetScanLine32(
                   PDD_GETSCANLINEDATA lpGetScanLine )
    {
    PDEV*   ppdev;

    ppdev = lpGetScanLine->lpDD->dhpdev;

    /*
     * If a vertical blank is in progress the scan line is in
     * indeterminant. If the scan line is indeterminant we return
     * the error code DDERR_VERTICALBLANKINPROGRESS.
     * Otherwise we return the scan line and a success code
     */
    if (ppdev->pfnVBlankIsActive(ppdev))
        {
        lpGetScanLine->ddRVal = DDERR_VERTICALBLANKINPROGRESS;
        }
    else
        {
        lpGetScanLine->dwScanLine = ppdev->pfnGetScanline(ppdev);
        lpGetScanLine->ddRVal = DD_OK;
        }
    return DDHAL_DRIVER_HANDLED;

    } /* GetScanLine32 */
#endif // #ifndef NVD3D

//******************************Public*Routine**********************************
//
// Function: DdGetFlipStatus
//
//      If the display has gone through one refresh cycle since the flip
//      occurred, we return DD_OK.  If it has not gone through one refresh
//      cycle we return DDERR_WASSTILLDRAWING to indicate that this surface
//      is still busy "drawing" the flipped page.   We also return
//      DDERR_WASSTILLDRAWING if the bltter is busy and the caller wanted
//      to know if they could flip yet.
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************

DWORD DdGetFlipStatus(
                     PDD_GETFLIPSTATUSDATA lpGetFlipStatus)

    {
    PDEV*   ppdev;
    BYTE*   pjMmBase;
    FNGRAPHICSENGINEBUSY*  pfnGraphicsEngineBusy;

    ppdev    = (PDEV*) lpGetFlipStatus->lpDD->dhpdev;

    //**************************************************************************
    // Init chip specific function pointers
    //**************************************************************************

    pfnGraphicsEngineBusy = ppdev->pfnGraphicsEngineBusy;


    //**************************************************************************
    // We don't want a flip to work until after the last flip is done,
    // so we ask for the general flip status and ignore the vmem:
    //**************************************************************************

    lpGetFlipStatus->ddRVal = ppdev->pfnUpdateFlipStatus(ppdev, 0);

    //**************************************************************************
    // Check if the bltter is busy if someone wants to know if they can
    // flip:
    //**************************************************************************

    if (lpGetFlipStatus->dwFlags == DDGFS_CANFLIP)
        {
        if ( (lpGetFlipStatus->ddRVal == DD_OK) && (pfnGraphicsEngineBusy(ppdev)) )
            {
            lpGetFlipStatus->ddRVal = DDERR_WASSTILLDRAWING;
            }
        }

    return (DDHAL_DRIVER_HANDLED);
    }

//******************************Public*Routine**********************************
//
// Function: DdWaitForVerticalBlank
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************

DWORD DdWaitForVerticalBlank(
                            PDD_WAITFORVERTICALBLANKDATA lpWaitForVerticalBlank)

    {
    PDEV*   ppdev;
    FNWAITWHILEVBLANKACTIVE*    pfnWaitWhileVBlankActive;
    FNWAITWHILEDISPLAYACTIVE*   pfnWaitWhileDisplayActive;
    FNVBLANKISACTIVE*           pfnVBlankIsActive;

    ppdev    = (PDEV*) lpWaitForVerticalBlank->lpDD->dhpdev;

    //**************************************************************************
    // Init chip specific function pointers
    //**************************************************************************

    pfnWaitWhileVBlankActive = ppdev->pfnWaitWhileVBlankActive;
    pfnWaitWhileDisplayActive = ppdev->pfnWaitWhileDisplayActive;
    pfnVBlankIsActive = ppdev->pfnVBlankIsActive;


    switch (lpWaitForVerticalBlank->dwFlags)
        {
        case DDWAITVB_I_TESTVB:

            //******************************************************************
            // If TESTVB, it's just a request for the current vertical blank
            // status:
            //******************************************************************

            if (pfnVBlankIsActive(ppdev))
                lpWaitForVerticalBlank->bIsInVB = TRUE;
            else
                lpWaitForVerticalBlank->bIsInVB = FALSE;

            lpWaitForVerticalBlank->ddRVal = DD_OK;

            return (DDHAL_DRIVER_HANDLED);

        case DDWAITVB_BLOCKBEGIN:

            //******************************************************************
            // If BLOCKBEGIN is requested, we wait until the vertical blank
            // is over, and then wait for the display period to end:
            //******************************************************************

            pfnWaitWhileVBlankActive(ppdev);
            pfnWaitWhileDisplayActive(ppdev);

            lpWaitForVerticalBlank->ddRVal = DD_OK;
            return (DDHAL_DRIVER_HANDLED);

        case DDWAITVB_BLOCKEND:

            //******************************************************************
            // If BLOCKEND is requested, we wait for the vblank interval to end:
            //******************************************************************

            pfnWaitWhileDisplayActive(ppdev);
            pfnWaitWhileVBlankActive(ppdev);

            lpWaitForVerticalBlank->ddRVal = DD_OK;
            return (DDHAL_DRIVER_HANDLED);
        }

    return (DDHAL_DRIVER_NOTHANDLED);
    }

#ifdef IS_WINNT4
//******************************Public*Routine**********************************
//
// Function: DdCanCreateSurface
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************

DWORD __stdcall DdCanCreateSurface(PDD_CANCREATESURFACEDATA lpCanCreateSurface )
    {
    DWORD               caps;
    LPDDSURFACEDESC     lpDDSurface;
    int                 i;
    PDEV *ppdev = (PDEV *) lpCanCreateSurface->lpDD->dhpdev;

    /*
     * NOTES:
     *
     * This entry point is called after parameter validation but before
     * any object creation.   You can decide here if it is possible for
     * you to create this surface.  For example, if the person is trying
     * to create an overlay, and you already have the maximum number of
     * overlays created, this is the place to fail the call.
     *
     * You also need to check if the pixel format specified can be supported.
     *
     * lpCanCreateSurface->bIsDifferentPixelFormat tells us if the pixel format of the
     * surface being created matches that of the primary surface.  It can be
     * true for Z buffer and alpha buffers, so don't just reject it out of
     * hand...
     */
    DISPDBG((2, "CanCreateSurface, lpCanCreateSurface->lpDD=%08lx", lpCanCreateSurface->lpDD ));
    DISPDBG((2, "    lpCanCreateSurface->lpDDSurfaceDesc=%08lx", lpCanCreateSurface->lpDDSurfaceDesc ));

    lpDDSurface = lpCanCreateSurface->lpDDSurfaceDesc;

    caps = lpDDSurface->ddsCaps.dwCaps;

    if (caps & (DDSCAPS_MODEX | DDSCAPS_PALETTE))
        return DDHAL_DRIVER_NOTHANDLED;

    if (ppdev->cBitsPerPel == 8)
        {
        if (caps & DDSCAPS_ALPHA)
            return DDHAL_DRIVER_NOTHANDLED;
        }

    /*
     * check pixel format.   Don't allow pixel formats that aren't
     * the same, unless we have a valid fourcc code, an overlay,
     * an alpha surface, or z buffer.
     */
    if ( lpCanCreateSurface->bIsDifferentPixelFormat )
        {
        DISPDBG((2, "    different pixel format!" ));

        if ( lpDDSurface->ddpfPixelFormat.dwFlags & DDPF_FOURCC )
            {
            if (ppdev->cBitsPerPel == 8)
                {
                /* We don't support RGB FOURCCs in 8bpp mode */
                if (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_RGB0)
                    {
                    lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                    return DDHAL_DRIVER_HANDLED;
                    }
                }

            DISPDBG((2, "    FourCC requested (%4.4hs, 0x%08lx)",
                     (LPSTR) &lpDDSurface->ddpfPixelFormat.dwFourCC,
                     lpDDSurface->ddpfPixelFormat.dwFourCC ));
            for ( i=0; i < NV_MAX_FOURCC; i++ )
                {
                if ( lpDDSurface->ddpfPixelFormat.dwFourCC == ppdev->fourCC[i] )
                    {
                    DISPDBG((2, "    FOURCC=%4.4hs", (LPSTR) &ppdev->fourCC[i] ));
                    if (caps & DDSCAPS_OVERLAY)
                        {
                        if ((lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_UYVY) &&
                            (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_YUY2) &&
                            (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_YV12) &&
//                            (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_420i) &&
                            (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_IF09) &&
                            (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_YVU9) &&
                            (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_IV32) &&
                            (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_IV31))
                            {
                            lpCanCreateSurface->ddRVal = DDERR_UNSUPPORTEDFORMAT;
                            return DDHAL_DRIVER_HANDLED;
                            }

                        if ((ppdev->cBitsPerPel == 32) &&
                            (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_IF09))
                            {
                            lpCanCreateSurface->ddRVal = DDERR_UNSUPPORTEDFORMAT;
                            return DDHAL_DRIVER_HANDLED;
                            }
                        if ((lpDDSurface->dwFlags & DDSD_BACKBUFFERCOUNT) &&
                            (lpDDSurface->dwBackBufferCount > 1) &&
                            ((lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_UYVY) ||
                             (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_YUY2)))
                            {
                            lpCanCreateSurface->ddRVal = DDERR_INVALIDPARAMS;
                            return DDHAL_DRIVER_HANDLED;
                            }
                        if (ppdev->dwOverlaySurfaces > 0)
                            {
                            lpCanCreateSurface->ddRVal = DDERR_OUTOFCAPS;
                            return DDHAL_DRIVER_HANDLED;
                            }

                        if (ppdev->bHwVidOvl == FALSE)
                            {
                            lpCanCreateSurface->ddRVal = DDERR_NOOVERLAYHW;
                            return DDHAL_DRIVER_HANDLED;
                            }
                        // NB: Unlike win2k/Dx8, we HAVE to fail based on bandwidth in canCreateSurface.  If we do it in
                        //     createSurface we cause Windows Media player to fault.  It's probably their bug, but it's
                        //     easy enough to reject in both cases.
                        if (VppGetVideoScalerBandwidthStatus(&ppdev->pDriverData->vpp, (WORD)lpDDSurface->dwWidth) == FALSE)
                            {
                            lpCanCreateSurface->ddRVal = DDERR_OUTOFCAPS;
                            return DDHAL_DRIVER_HANDLED;
                            }

                        }
                    else if (caps & (DDSCAPS_VIDEOMEMORY | DDSCAPS_OFFSCREENPLAIN))
                        {
                        /* Front end YUV support cannot reformat data so Indeo is not supported */
                        /* Currently also disallowing front end YUV420 since YUYV or UYVY
                           should do ok when not enough backend bandwidth is available */
                        if ((lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_IF09) ||
                            (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_YVU9) ||
                            (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_IV32) ||
                            (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_IV31) ||
                            (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_YV12) ||
                            (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_420i))
                            {
                            lpCanCreateSurface->ddRVal = DDERR_UNSUPPORTEDFORMAT;
                            return DDHAL_DRIVER_HANDLED;
                            }
                        /* Front end YUV support not available in 8bit indexed mode */
                        if (ppdev->cBitsPerPel == 8)
                            {
                            lpCanCreateSurface->ddRVal = DDERR_UNSUPPORTEDFORMAT;
                            return DDHAL_DRIVER_HANDLED;
                            }
                        }

                    if (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_RGB0)
                        {
                        if (((ppdev->cBitsPerPel == 16) &&
                             (lpDDSurface->ddpfPixelFormat.dwRGBBitCount != DDBD_16)) ||
                            ((ppdev->cBitsPerPel == 32) &&
                             (lpDDSurface->ddpfPixelFormat.dwRGBBitCount != DDBD_32)))
                            {
                            lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                            return DDHAL_DRIVER_HANDLED;
                            }
                        }

                    lpCanCreateSurface->ddRVal = DD_OK;
                    return DDHAL_DRIVER_HANDLED;
                    }
                }
            }
        else if ( lpDDSurface->ddpfPixelFormat.dwFlags & DDPF_RGB )
            {

            /* Don't allow 3D devices in 8bpp or 32bpp */
            if (caps & DDSCAPS_3DDEVICE)
                {
                if ((lpDDSurface->ddpfPixelFormat.dwRGBBitCount == 8) ||
                    (lpDDSurface->ddpfPixelFormat.dwRGBBitCount == 32))
                    {
                    lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                    return DDHAL_DRIVER_HANDLED;
                    }
                }

            if (caps & (DDSCAPS_TEXTURE | DDSCAPS_OFFSCREENPLAIN))
                {
                /* Don't allow textures in 8bpp or 32bpp */
                if ((ppdev->cBitsPerPel == 8) || (ppdev->cBitsPerPel == 32))
                    {
                    lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                    return DDHAL_DRIVER_NOTHANDLED;
                    }
#if 0
                if (lpDDSurface->ddpfPixelFormat.dwFlags & PALETTEINDEXED8)
                    {
                    lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                    return DDHAL_DRIVER_HANDLED;
                    }
#endif

                if (lpDDSurface->ddpfPixelFormat.dwRGBBitCount == 16)
                    {
                        // ELAU NV3 cannot handle 565 format
                        if(lpDDSurface->ddpfPixelFormat.dwGBitMask == 0x7e0)
                        {
                            lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                            return DDHAL_DRIVER_HANDLED;
                        }
                        /* accept all 16 bpp texture formats */
                        lpCanCreateSurface->ddRVal = DD_OK;
                        return DDHAL_DRIVER_HANDLED;
                    }
                }

            /* For now, support z buffers in video memory only when our primary rendering depth is 16 bpp */
            if (caps & DDSCAPS_ZBUFFER)
                {
                if ((ppdev->cBitsPerPel == 8) || (ppdev->cBitsPerPel == 32))
                    return DDHAL_DRIVER_NOTHANDLED;

                if (lpDDSurface->ddpfPixelFormat.dwRGBBitCount == 16)
                    {
                    /* accept all 16 bpp z buffer formats */
                    lpCanCreateSurface->ddRVal = DD_OK;
                    return DDHAL_DRIVER_HANDLED;
                    }
                }

            /* We don't support any other RGB surfaces not in our native format */
            lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
            return DDHAL_DRIVER_HANDLED;
            }
        else if ( lpDDSurface->ddpfPixelFormat.dwFlags & DDPF_ZBUFFER )
            {
            /* For now, support z buffers in video memory only when our primary rendering depth is 16 bpp */
            if (caps & DDSCAPS_ZBUFFER)
                {
                if ((ppdev->cBitsPerPel == 8) || (ppdev->cBitsPerPel == 32))
                    return DDHAL_DRIVER_NOTHANDLED;
                }

            DISPDBG((2, "Z BUFFER OK!" ));
            lpCanCreateSurface->ddRVal = DD_OK;
            return DDHAL_DRIVER_HANDLED;
            }

        /*
         * can't handle any other kinds of different fourcc or RGB overlays
         */
        lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
        return DDHAL_DRIVER_HANDLED;
        }

    if (caps & DDSCAPS_MODEX)
        {
        DISPDBG((2, "    Mode X requested" ));
        lpCanCreateSurface->ddRVal = DDERR_UNSUPPORTEDMODE;
        return DDHAL_DRIVER_HANDLED;
        }

    /* Don't allow 3D devices in 8bpp or 32bpp (except for primary surface access, fixes Jedi Knight) */
    if ((caps & DDSCAPS_3DDEVICE) && (!(caps & DDSCAPS_PRIMARYSURFACE)))
        {
        if ((ppdev->cBitsPerPel == 8) || (ppdev->cBitsPerPel == 32))
            {
            lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
            return DDHAL_DRIVER_HANDLED;
            }
        }

    if (caps & (DDSCAPS_FRONTBUFFER | DDSCAPS_PRIMARYSURFACE | DDSCAPS_VISIBLE))
        {
        DISPDBG((2, "    Frontbuffer requested" ));

        if (caps & DDSCAPS_OVERLAY)
            {
            lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
            return DDHAL_DRIVER_HANDLED;
            }

        if (caps & DDSCAPS_FLIP)
            {
            if (lpDDSurface->dwHeight > (unsigned long)ppdev->cyScreen)
                {
                if (lpDDSurface->dwFlags & DDSD_HEIGHT)
                    {
                    lpCanCreateSurface->ddRVal = DDERR_TOOBIGHEIGHT;
                    return DDHAL_DRIVER_HANDLED;
                    }
                else
                    {
                    lpDDSurface->dwHeight = (unsigned long)ppdev->cyScreen;
                    }

                }
            if (lpDDSurface->dwWidth > (unsigned long)ppdev->cxScreen)
                {
                if (lpDDSurface->dwFlags & DDSD_WIDTH)
                    {
                    lpCanCreateSurface->ddRVal = DDERR_TOOBIGWIDTH;
                    return DDHAL_DRIVER_HANDLED;
                    }
                else
                    {
                    lpDDSurface->dwWidth = (unsigned long)ppdev->cxScreen;
                    }
                }
            }
        lpCanCreateSurface->ddRVal = DD_OK;
        return DDHAL_DRIVER_HANDLED;

        }
    else if (caps & DDSCAPS_BACKBUFFER)
        {
        DISPDBG((2, "    Backbuffer requested" ));
        if (caps & DDSCAPS_OVERLAY)
            {
            lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
            return DDHAL_DRIVER_HANDLED;
            }

        if (caps & DDSCAPS_FLIP)
            {
            if (lpDDSurface->dwHeight > (unsigned long)ppdev->cyScreen)
                {
                if (lpDDSurface->dwFlags & DDSD_HEIGHT)
                    {
                    lpCanCreateSurface->ddRVal = DDERR_TOOBIGHEIGHT;
                    return DDHAL_DRIVER_HANDLED;
                    }
                else
                    {
                    lpDDSurface->dwHeight = (unsigned long)ppdev->cyScreen;
                    }

                }
            if (lpDDSurface->dwWidth > (unsigned long)ppdev->cyScreen)
                {
                if (lpDDSurface->dwFlags & DDSD_WIDTH)
                    {
                    lpCanCreateSurface->ddRVal = DDERR_TOOBIGWIDTH;
                    return DDHAL_DRIVER_HANDLED;
                    }
                else
                    {
                    lpDDSurface->dwWidth = (unsigned long)ppdev->cBitsPerPel;
                    }
                }
            }
        lpCanCreateSurface->ddRVal = DD_OK;
        return DDHAL_DRIVER_HANDLED;

        }
    else if (caps & DDSCAPS_TEXTURE)
        {
        /* Don't allow textures in 8bpp or 32bpp */
        if ((ppdev->cBitsPerPel == 8) || (ppdev->cBitsPerPel == 32))
            {
            lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
            return DDHAL_DRIVER_HANDLED;
            }
#ifndef NVD3D
        lpDDSurface->ddsCaps.dwCaps &= ~DDSCAPS_VIDEOMEMORY;
        lpDDSurface->ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
#endif
        lpCanCreateSurface->ddRVal = DD_OK;
        return DDHAL_DRIVER_HANDLED;

        }
    else if (caps & DDSCAPS_OFFSCREENPLAIN)
        {
        DISPDBG((2, "    Can create offscreen requested" ));

        if (caps & DDSCAPS_VIDEOMEMORY)
            {
            if (caps & DDSCAPS_OVERLAY)
                {
                lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                return DDHAL_DRIVER_HANDLED;
                }

            if (caps & DDSCAPS_FLIP)
                {
                if (lpDDSurface->dwHeight > (unsigned long)ppdev->cyScreen)
                    {
                    if (lpDDSurface->dwFlags & DDSD_HEIGHT)
                        {
                        lpCanCreateSurface->ddRVal = DDERR_TOOBIGHEIGHT;
                        return DDHAL_DRIVER_HANDLED;
                        }
                    else
                        {
                        lpDDSurface->dwHeight = (unsigned long)ppdev->cyScreen;
                        }
                    }
                if (lpDDSurface->dwWidth > (unsigned long)ppdev->cxScreen)
                    {
                    if (lpDDSurface->dwFlags & DDSD_WIDTH)
                        {
                        lpCanCreateSurface->ddRVal = DDERR_TOOBIGWIDTH;
                        return DDHAL_DRIVER_HANDLED;
                        }
                    else
                        {
                        lpDDSurface->dwWidth = (unsigned long)ppdev->cxScreen;
                        }

                    }
                }
            }
        lpCanCreateSurface->ddRVal = DD_OK;
        DISPDBG((2, "    Can create offscreen granted" ));
        return DDHAL_DRIVER_HANDLED;

        }
    else if (caps & (DDSCAPS_FLIP | DDSCAPS_VIDEOMEMORY | DDSCAPS_ZBUFFER))
        {
        DISPDBG((2, "    Can create flipping surface requested" ));

        if (caps & DDSCAPS_OVERLAY)
            {
            lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
            return DDHAL_DRIVER_HANDLED;
            }
        DISPDBG((2, "    Can create flipping surface available" ));
        lpCanCreateSurface->ddRVal = DD_OK;
        return DDHAL_DRIVER_HANDLED;

        }
    else
        if (caps & DDSCAPS_SYSTEMMEMORY)
        {
        lpCanCreateSurface->ddRVal = DD_OK;
        DISPDBG((2, "    Can create system memory requested" ));
        return DDHAL_DRIVER_HANDLED;
        }

    return DDHAL_DRIVER_NOTHANDLED;

    } /* DdCanCreateSurface */

//******************************Public*Routine**********************************
//
// Function: DdCreateSurface
//
// Routine Description:
//
//    Creates an off-screen surface.
//
//    We use the Millennium's own off-screen heap manager instead of DirectDraw's
//    so that the OpenGL MCD and DirectDraw parts can coexist -- at the time of this
//    writing NT has no support for call-backs from the driver to allocate memory,
//    which we need to do to allocate the MCD's back buffer and Z-buffer.  So
//    we simply manage all of off-screen memory ourselves.
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************
DWORD DdCreateSurface(
                     PDD_CREATESURFACEDATA lpCreateSurface)

    {
    PDEV*               ppdev;
    DD_SURFACE_LOCAL*   lpSurfaceLocal;
    DD_SURFACE_GLOBAL*  lpSurfaceGlobal;
    LPDDSURFACEDESC     lpSurfaceDesc;
    DWORD               dwByteCount;
    ULONG               lPitch;
    DWORD               dwHeight;
    NvU16               wWidth;
    LONG                wHeight;
    LONG                adjustedHeight;
    FLATPTR             fpVidMem;
    PDD_SURFACE_LOCAL   *powner;
    ULONG               dwBlockSize;
    ULONG   index;
    ULONG   memType;
    NvU32 dwStatus;
#ifdef DEBUG
    char                        fourCCStr[5];
#endif // DEBUG

    //**************************************************************************
    // Get pointer to device
    //**************************************************************************

    ppdev = (PDEV*) lpCreateSurface->lpDD->dhpdev;

    //**************************************************************************
    // On Windows NT, dwSCnt will always be 1, so there will only ever
    // be one entry in the 'lplpSList' array:
    //**************************************************************************
    powner = lpCreateSurface->lplpSList;
    lpSurfaceLocal  = lpCreateSurface->lplpSList[0];
    lpSurfaceGlobal  = lpCreateSurface->lplpSList[0]->lpGbl;
    lpSurfaceDesc   = lpCreateSurface->lpDDSurfaceDesc;

    //**************************************************************************
    // Get width and height
    //**************************************************************************

    wWidth  = (WORD)lpSurfaceGlobal->wWidth;    // wWidth is actually an unsigned long despite name
    wHeight = lpSurfaceGlobal->wHeight;

    //**************************************************************************
    // We repeat the same checks we did in 'DdCanCreateSurface' because
    // it's possible that an application doesn't call 'DdCanCreateSurface'
    // before calling 'DdCreateSurface'.
    //**************************************************************************

    ASSERTDD(lpSurfaceGlobal->ddpfSurface.dwSize == sizeof(DDPIXELFORMAT),
             "NT is supposed to guarantee that ddpfSurface.dwSize is valid");

    //**************************************************************************
    // Determine type and format of surface prior to allocation.
    //**************************************************************************

    if (
       //(lpSurfaceLocal->dwFlags & DDRAWISURF_HASPIXELFORMAT) &&
       (lpSurfaceGlobal->ddpfSurface.dwFlags & DDPF_FOURCC) )
    {
        DPF( "NVDD: FOURCC surface requested" );

        if ((lpSurfaceLocal->ddsCaps.dwCaps & DDSCAPS_OVERLAY) &&
             (VppGetVideoScalerBandwidthStatus(&ppdev->pDriverData->vpp, wWidth) == FALSE))
        {
            DPF( "NVDD: Insufficient video bandwidth, overlay creation refused.");
            lpCreateSurface->ddRVal = DDERR_OUTOFCAPS;
            goto CREATE_HANDLED;
        }

        //**************************************************************************
        // we know the FOURCC code is OK, because we validated it
        // during CanCreateSurface.   Compute a block size based
        // on the code, and allocate system memory for it.
        //**************************************************************************
        switch ( lpSurfaceLocal->lpGbl->ddpfSurface.dwFourCC )
            {
            case FOURCC_RGB0:
                lpSurfaceGlobal->ddpfSurface.dwRGBBitCount = ppdev->cBitsPerPel;
                if (ppdev->cBitsPerPel == 8)
                    {
                    lpSurfaceGlobal->ddpfSurface.dwRBitMask = 0;
                    lpSurfaceGlobal->ddpfSurface.dwGBitMask = 0;
                    lpSurfaceGlobal->ddpfSurface.dwBBitMask = 0;
                    lpSurfaceGlobal->ddpfSurface.dwFlags |= DDPF_PALETTEINDEXED8;
                    }
                else if (ppdev->cBitsPerPel == 16)
                    {
                    lpSurfaceGlobal->ddpfSurface.dwRBitMask = 0x00007C00;
                    lpSurfaceGlobal->ddpfSurface.dwGBitMask = 0x000003E0;
                    lpSurfaceGlobal->ddpfSurface.dwBBitMask = 0x0000001F;
                    }
                else if (ppdev->cBitsPerPel == 32)
                    {
                    lpSurfaceGlobal->ddpfSurface.dwRBitMask = 0x00FF0000;
                    lpSurfaceGlobal->ddpfSurface.dwGBitMask = 0x0000FF00;
                    lpSurfaceGlobal->ddpfSurface.dwBBitMask = 0x000000FF;
                    }
                lpSurfaceGlobal->ddpfSurface.dwRGBAlphaBitMask = 0;
#ifdef DEBUG
                fourCCStr[0] = (char)lpSurfaceGlobal->ddpfSurface.dwFourCC & 0xFF;
                fourCCStr[1] = (char)(lpSurfaceGlobal->ddpfSurface.dwFourCC >> 8) & 0xFF;
                fourCCStr[2] = (char)(lpSurfaceGlobal->ddpfSurface.dwFourCC >> 16) & 0xFF;
                fourCCStr[3] = (char)(lpSurfaceGlobal->ddpfSurface.dwFourCC >> 24) & 0xFF;
                fourCCStr[4] = 0;
                DPF( "FOURCC %s allocation: size=%lu bytes", &fourCCStr, dwBlockSize );
#endif // DEBUG
                lpSurfaceLocal->ddsCaps.dwCaps |= DDSCAPS_HWCODEC;

                lPitch = wWidth * (ppdev->cBitsPerPel >> 3);
                lPitch = (lPitch + ppdev->ulSurfaceAlign) & ~ppdev->ulSurfaceAlign;

                if (lpSurfaceLocal->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY)
                    {
                    NVHEAP_ALLOC(dwStatus,fpVidMem, lPitch * wHeight, TYPE_OVERLAY);
                    if (dwStatus!=0)
                    {
                        bMoveAllDfbsFromOffscreenToDibs(ppdev);
                        NVHEAP_ALLOC(dwStatus,fpVidMem, lPitch * wHeight, TYPE_OVERLAY);
                    }
                    if (dwStatus==0)
                        {
                        //**********************************************************************
                        // Flip surfaces, detected by surface requests that are the
                        // same size as the current display, have special
                        // considerations: they must live in the first four megabytes
                        // of video memory:
                        //**********************************************************************

                        lpSurfaceGlobal->yHint        = (fpVidMem / ppdev->lDelta);
                        lpSurfaceGlobal->xHint        = ((fpVidMem - (lpSurfaceGlobal->yHint * ppdev->lDelta))/ ppdev->cjPelSize) ;
                        lpSurfaceGlobal->fpVidMem     = fpVidMem;
                        lpSurfaceGlobal->lPitch       = lPitch;

                        lpSurfaceDesc->lPitch   = lPitch;
                        lpSurfaceDesc->dwFlags |= DDSD_PITCH;


                        //**********************************************************************
                        // We handled the creation entirely ourselves, so we have to
                        // set the return code and return DDHAL_DRIVER_HANDLED:
                        //**********************************************************************

                        lpCreateSurface->ddRVal = DD_OK;
                        lpSurfaceLocal->ddsCaps.dwCaps &= ~DDSCAPS_SYSTEMMEMORY;
                        lpSurfaceLocal->ddsCaps.dwCaps |= DDSCAPS_LOCALVIDMEM;
                        break;
                        }
                    }

                //**********************************************************************
                // Tell DDRAW to allocate user mem for this surface.
                //**********************************************************************
                lpSurfaceGlobal->fpVidMem = DDHAL_PLEASEALLOC_USERMEM;
                lpSurfaceGlobal->dwUserMemSize = lPitch * wHeight;
                lpSurfaceDesc->lPitch = lPitch;
                lpSurfaceDesc->dwFlags  |= DDSD_PITCH;
                lpSurfaceLocal->ddsCaps.dwCaps &= ~DDSCAPS_LOCALVIDMEM;
                lpSurfaceLocal->ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;

                return (DDHAL_DRIVER_NOTHANDLED);
                break;

            case FOURCC_IF09:
            case FOURCC_YVU9:
            case FOURCC_IV32:
            case FOURCC_IV31:

                if ((lpSurfaceLocal->ddsCaps.dwCaps & DDSCAPS_OVERLAY) &&
                    (ppdev->dwOverlaySurfaces > 0))
                    {
                    if ((ppdev->dwOverlayOwner != (DWORD)powner) ||
                        (ppdev->dwOverlaySurfaces + 1 >= NV_MAX_OVERLAY_SURFACES))
                        {
                        lpCreateSurface->ddRVal = DDERR_OUTOFCAPS;
                        goto CREATE_HANDLED;
                        }
                    }

                /* First allocate enough video memory for YUY2 overlay pixel area */
                lPitch = ((lpSurfaceGlobal->wWidth + 1) & 0xFFFFFFFE) << 1;

                lPitch = (lPitch + ppdev->ulSurfaceAlign) & ~ppdev->ulSurfaceAlign;
                /* pad with an extra scanline */
                dwBlockSize = (lPitch * (DWORD)lpSurfaceGlobal->wHeight);
                /* now allocate enough video memory for the Indeo part of the surface */
                lPitch = lpSurfaceGlobal->wWidth;
                /* allow extra room for block skip bits between Indeo portion of surface and YUY2 portion */
                dwBlockSize +=
                ((lPitch * ((DWORD)lpSurfaceGlobal->wHeight * 10L)) >> 3);
                /* Force block to be properly aligned */
                dwBlockSize =
                (dwBlockSize + ppdev->ulSurfaceAlign) & ~ppdev->ulSurfaceAlign;

                lpSurfaceGlobal->ddpfSurface.dwYUVBitCount = 9;
                lpSurfaceGlobal->ddpfSurface.dwYBitMask = 0;
                lpSurfaceGlobal->ddpfSurface.dwUBitMask = 0;
                lpSurfaceGlobal->ddpfSurface.dwVBitMask = 0;
                lpSurfaceGlobal->ddpfSurface.dwYUVAlphaBitMask = 0;
#ifdef DEBUG
                fourCCStr[0] = (char)lpSurfaceGlobal->ddpfSurface.dwFourCC & 0xFF;
                fourCCStr[1] = (char)(lpSurfaceGlobal->ddpfSurface.dwFourCC >> 8) & 0xFF;
                fourCCStr[2] = (char)(lpSurfaceGlobal->ddpfSurface.dwFourCC >> 16) & 0xFF;
                fourCCStr[3] = (char)(lpSurfaceGlobal->ddpfSurface.dwFourCC >> 24) & 0xFF;
                fourCCStr[4] = 0;
                DPF( "FOURCC %s allocation: size=%lu bytes", &fourCCStr, dwBlockSize );
#endif // DEBUG

                lpSurfaceGlobal->lPitch = lPitch;
                lpSurfaceGlobal->fpVidMem = ppdev->ulPrimarySurfaceOffset;
                lpSurfaceGlobal->dwReserved1 = 0;
                lpSurfaceLocal->ddsCaps.dwCaps |= DDSCAPS_HWCODEC;

                if (lpSurfaceLocal->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY)
                    {
                    NVHEAP_ALLOC(dwStatus,fpVidMem, dwBlockSize, TYPE_OVERLAY);
                    if (dwStatus!=0)
                    {
                        bMoveAllDfbsFromOffscreenToDibs(ppdev);
                        NVHEAP_ALLOC(dwStatus,fpVidMem, dwBlockSize, TYPE_OVERLAY);
                    }

                    if (dwStatus==0)
                        {
                        ppdev->DDrawVideoSurfaceCount++;
                        lpSurfaceGlobal->fpVidMem = fpVidMem;
                        lpSurfaceLocal->ddsCaps.dwCaps &= ~DDSCAPS_SYSTEMMEMORY;
                        lpSurfaceLocal->ddsCaps.dwCaps |= (DDSCAPS_VIDEOMEMORY | DDSCAPS_LOCALVIDMEM);

                        if (lpSurfaceLocal->ddsCaps.dwCaps & DDSCAPS_OVERLAY)
                            {
                            index = 0;
                            while ((ppdev->dwOverlaySurfaceLCL[index] != 0) &&
                                   (index < NV_MAX_OVERLAY_SURFACES))
                                index++;
                            ppdev->dwOverlaySurfaceLCL[index] = (DWORD) lpSurfaceLocal;
                            ppdev->dwOverlayOwner = (DWORD)powner;
                            ppdev->dwOverlaySurfaces++;
                            }

                        lpCreateSurface->ddRVal = DD_OK;
                        goto CREATE_HANDLED;
                        }
                    else
                        {
                        /* We can't support overlay surfaces in system memory */
                        if (lpSurfaceLocal->ddsCaps.dwCaps & DDSCAPS_OVERLAY)
                            {
                            return DDHAL_DRIVER_NOTHANDLED;
                            }
                        }
                    }

                //**********************************************************************
                // Tell DDRAW to allocate user mem for this surface.
                //**********************************************************************
                lpSurfaceGlobal->fpVidMem = DDHAL_PLEASEALLOC_USERMEM;
                lpSurfaceGlobal->dwUserMemSize = dwBlockSize;
                lpSurfaceDesc->lPitch = lPitch;
                lpSurfaceLocal->ddsCaps.dwCaps &= ~(DDSCAPS_VIDEOMEMORY | DDSCAPS_LOCALVIDMEM);
                lpSurfaceLocal->ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;

                return DDHAL_DRIVER_NOTHANDLED;
                break;

            case FOURCC_YUY2:
            case FOURCC_UYVY:

                if ((lpSurfaceLocal->ddsCaps.dwCaps & DDSCAPS_OVERLAY) &&
                    (ppdev->dwOverlaySurfaces > 0))
                    {
                    if ((ppdev->dwOverlayOwner != (DWORD)powner) ||
                        (ppdev->dwOverlaySurfaces + 1 >= NV_MAX_OVERLAY_SURFACES))
                        {
                        lpCreateSurface->ddRVal = DDERR_OUTOFCAPS;
                        goto CREATE_HANDLED;
                        }
                    }

                /* First try video memory */
                lPitch = ((lpSurfaceGlobal->wWidth + 1) & 0xFFFFFFFE) << 1;
                lPitch = (lPitch + ppdev->ulSurfaceAlign) & ~ppdev->ulSurfaceAlign;
                /* pad with an extra scanline */
                dwBlockSize = (lPitch * (DWORD)lpSurfaceGlobal->wHeight);
                lpSurfaceGlobal->ddpfSurface.dwYUVBitCount = 16;
                if (lpSurfaceGlobal->ddpfSurface.dwFourCC == FOURCC_YUY2)
                    {
                    lpSurfaceGlobal->ddpfSurface.dwYBitMask = 0x00FF00FF;
                    lpSurfaceGlobal->ddpfSurface.dwUBitMask = 0x0000FF00;
                    lpSurfaceGlobal->ddpfSurface.dwVBitMask = 0xFF000000;
                    }
                else
                    {
                    lpSurfaceGlobal->ddpfSurface.dwYBitMask = 0xFF00FF00;
                    lpSurfaceGlobal->ddpfSurface.dwUBitMask = 0x000000FF;
                    lpSurfaceGlobal->ddpfSurface.dwVBitMask = 0x00FF0000;
                    }
                lpSurfaceGlobal->ddpfSurface.dwYUVAlphaBitMask = 0;
#ifdef DEBUG
                fourCCStr[0] = (char)lpSurfaceGlobal->ddpfSurface.dwFourCC & 0xFF;
                fourCCStr[1] = (char)(lpSurfaceGlobal->ddpfSurface.dwFourCC >> 8) & 0xFF;
                fourCCStr[2] = (char)(lpSurfaceGlobal->ddpfSurface.dwFourCC >> 16) & 0xFF;
                fourCCStr[3] = (char)(lpSurfaceGlobal->ddpfSurface.dwFourCC >> 24) & 0xFF;
                fourCCStr[4] = 0;
                DPF( "FOURCC %s allocation: size=%lu bytes", &fourCCStr, dwBlockSize );
#endif // DEBUG
                lpSurfaceGlobal->lPitch = lPitch;
                lpSurfaceDesc->dwFlags |= DDSD_PITCH;
                lpSurfaceLocal->ddsCaps.dwCaps |= DDSCAPS_HWCODEC;

                NVHEAP_ALLOC(dwStatus,fpVidMem, dwBlockSize, TYPE_OVERLAY);
                if (dwStatus!=0)
                {
                    bMoveAllDfbsFromOffscreenToDibs(ppdev);
                    NVHEAP_ALLOC(dwStatus,fpVidMem, dwBlockSize, TYPE_OVERLAY);
                }


                if (dwStatus==0)
                    {
                    ppdev->DDrawVideoSurfaceCount++;
                    lpSurfaceLocal->ddsCaps.dwCaps |= (DDSCAPS_VIDEOMEMORY | DDSCAPS_LOCALVIDMEM);
                    lpSurfaceLocal->ddsCaps.dwCaps &= ~DDSCAPS_SYSTEMMEMORY;
                    lpSurfaceGlobal->fpVidMem = fpVidMem;
                    lpCreateSurface->ddRVal = DD_OK;
                    if (lpSurfaceLocal->ddsCaps.dwCaps & DDSCAPS_OVERLAY)
                        {
                        index = 0;
                        while ((ppdev->dwOverlaySurfaceLCL[index] != 0) &&
                               (index < NV_MAX_OVERLAY_SURFACES))
                            index++;
                        ppdev->dwOverlaySurfaceLCL[index] = (DWORD) lpSurfaceLocal;
                        ppdev->dwOverlayOwner = (DWORD)powner;
                        ppdev->dwOverlaySurfaces++;
                        }

                    }
                else
                    {
                    /* We can't support overlay surfaces in system memory */
                    if (lpSurfaceLocal->ddsCaps.dwCaps & DDSCAPS_OVERLAY)
                        {
                        lpCreateSurface->ddRVal = DDERR_OUTOFMEMORY;
                        goto CREATE_HANDLED;
                        }
                    //**********************************************************************
                    // Tell DDRAW to allocate user mem for this surface.
                    //**********************************************************************
                    lpSurfaceGlobal->fpVidMem = DDHAL_PLEASEALLOC_USERMEM;
                    lpSurfaceGlobal->dwUserMemSize = dwBlockSize;
                    lpSurfaceDesc->lPitch = lPitch;
                    lpSurfaceDesc->dwFlags  |= DDSD_PITCH;
                    lpSurfaceLocal->ddsCaps.dwCaps &= ~(DDSCAPS_VIDEOMEMORY | DDSCAPS_LOCALVIDMEM);
                    lpSurfaceLocal->ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;

                    return DDHAL_DRIVER_NOTHANDLED;
                    }
                goto CREATE_HANDLED;
                break;

            case FOURCC_YV12:
            case FOURCC_420i:

                if ((lpSurfaceLocal->ddsCaps.dwCaps & DDSCAPS_OVERLAY) &&
                    (ppdev->dwOverlaySurfaces > 0))
                    {
                    if ((ppdev->dwOverlayOwner != (DWORD)powner) ||
                        (ppdev->dwOverlaySurfaces + 1 >= NV_MAX_OVERLAY_SURFACES))
                        {
                        lpCreateSurface->ddRVal = DDERR_OUTOFCAPS;
                        goto CREATE_HANDLED;
                        }
                    }

                /*
                 * Always split allocation of YV12/420i overlay surfaces.
                 *   Allocate the YV12/420i portion in AGP memory on AGP systems, local video memory on PCI systems.
                 *   Fall back to system memory only if preferred allocation fails.
                 *   Allocate additional YUY2 surfaces in local video memory for the video scaler to use
                 */
                lpSurfaceGlobal->ddpfSurface.dwYUVBitCount = 12;
                lpSurfaceGlobal->ddpfSurface.dwYBitMask = 0;
                lpSurfaceGlobal->ddpfSurface.dwUBitMask = 0;
                lpSurfaceGlobal->ddpfSurface.dwVBitMask = 0;
                lpSurfaceGlobal->ddpfSurface.dwYUVAlphaBitMask = 0;

                lpSurfaceGlobal->fpVidMem = ppdev->ulPrimarySurfaceOffset;
                lpSurfaceGlobal->dwReserved1 = 0;
                lpSurfaceLocal->ddsCaps.dwCaps |= DDSCAPS_HWCODEC;

                lPitch = ((lpSurfaceGlobal->wWidth + 1) & 0xFFFFFFFE) << 1;
                lPitch = (lPitch + ppdev->ulSurfaceAlign) & ~ppdev->ulSurfaceAlign;

                adjustedHeight = (DWORD)((lpSurfaceGlobal->wHeight + 1) & ~1);

                dwBlockSize = lPitch * adjustedHeight;

                if (lpSurfaceLocal->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY)
                    {
                    NVHEAP_ALLOC(dwStatus,fpVidMem, dwBlockSize, TYPE_OVERLAY);
                    if (dwStatus!=0)
                    {
                        bMoveAllDfbsFromOffscreenToDibs(ppdev);
                        NVHEAP_ALLOC(dwStatus,fpVidMem, dwBlockSize, TYPE_OVERLAY);
                    }

                    if (dwStatus==0)
                        {
                        ppdev->DDrawVideoSurfaceCount++;
                        lpSurfaceLocal->ddsCaps.dwCaps |= DDSCAPS_LOCALVIDMEM;
                        if (ppdev->NvFloatingMem2MemFormatBaseAddress == 0)
                            ppdev->NvYUY2Surface0Mem = (DWORD)fpVidMem; /* save pointer to YUY2 overlay surface */
                        else if (ppdev->NvFloatingMem2MemFormatNextAddress == 0)
                            ppdev->NvYUY2Surface1Mem = (DWORD)fpVidMem;
                        else
                            ppdev->NvYUY2Surface2Mem = (DWORD)fpVidMem;
                        }
                    else
                        {
                        /* one or more overlay surfaces could not be allocated, clean up already allocated memory */
                        if (ppdev->NvYUY2Surface1Mem > 0)
                            {
                            NVHEAP_FREE(ppdev->NvYUY2Surface1Mem);
                            ppdev->NvYUY2Surface1Mem = 0;
                            ppdev->NvFloatingMem2MemFormatNextAddress = 0;
                            if (ppdev->DDrawVideoSurfaceCount > 0)
                                ppdev->DDrawVideoSurfaceCount--;
                            }

                        if (ppdev->NvFloatingMem2MemFormatBaseAddress != 0)
                            {
                            if (ppdev->NvYUY2Surface0Mem > 0)
                                {
                                NVHEAP_FREE(ppdev->NvYUY2Surface0Mem);
                                ppdev->NvYUY2Surface0Mem = 0;
                                if (ppdev->DDrawVideoSurfaceCount > 0)
                                    ppdev->DDrawVideoSurfaceCount--;
                                }
#ifdef SYSMEM_FALLBACK
                            if ((ppdev->NvFloatingMem2MemFormatBaseAddress < (ULONG) ppdev->pjFrameBufbase) || /* If system memory */
                                (ppdev->NvFloatingMem2MemFormatBaseAddress > (ULONG) ppdev->pjFrameBufbase + 0x1000000))
                                {
                                if (NvFree(ppdev->hDriver,
                                                     ppdev->hClient,
                                                     ppdev->hDevice,
                                                     NV_DD_FLOATING_FORMAT_CONTEXT_DMA_FROM_SYSTEM_MEMORY)
                                    != NVOS00_STATUS_SUCCESS)
                                /*
                                if (NvFreeContextDma(ppdev->hDriver,
                                                     NV_DD_FLOATING_FORMAT_CONTEXT_DMA_FROM_SYSTEM_MEMORY)
                                    != NV0003_ERROR_OK)
                                */
                                    {
                                    DISPDBG((2, "Couldn't free dma context in sys mem"));
                                    lpCreateSurface->ddRVal = DDERR_OUTOFMEMORY;
                                    goto CREATE_HANDLED;
                                    }
                                }
                            if ((ppdev->NvFloatingMem2MemFormatBaseAddress < (ULONG) ppdev->pjFrameBufbase) || /* If system memory */
                                (ppdev->NvFloatingMem2MemFormatBaseAddress > (ULONG) ppdev->pjFrameBufbase + 0x1000000))
                                {
                                // BUGBUG...
                                //GlobalUnlock((HGLOBAL)ppdev->NvFloatingMem2MemFormatMemoryHandle);
                                //GlobalFree((HGLOBAL)ppdev->NvFloatingMem2MemFormatMemoryHandle);
                                }
                            else
#endif // #ifdef SYSMEM_FALLBACK
                                {
                                NVHEAP_FREE(ppdev->NvFloatingMem2MemFormatBaseAddress);
                                if (ppdev->DDrawVideoSurfaceCount > 0)
                                    ppdev->DDrawVideoSurfaceCount--;
                                }

                            ppdev->NvFloatingMem2MemFormatBaseAddress = 0;
                            ppdev->NvFloatingMem2MemFormatNextAddress = 0;
                            }

                        ppdev->dwOverlayOwner = 0;
                        ppdev->dwOverlaySurfaces = 0;

                        /* We can't support overlay surfaces in system memory */
                        if (lpSurfaceLocal->ddsCaps.dwCaps & DDSCAPS_OVERLAY)
                            {
                            lpCreateSurface->ddRVal = DDERR_OUTOFMEMORY;
                            goto CREATE_HANDLED;
                            }
                        return(DDHAL_DRIVER_NOTHANDLED);
                        }
                    }
#ifdef DEBUG
                fourCCStr[0] = (char)lpSurfaceGlobal->ddpfSurface.dwFourCC & 0xFF;
                fourCCStr[1] = (char)(lpSurfaceGlobal->ddpfSurface.dwFourCC >> 8) & 0xFF;
                fourCCStr[2] = (char)(lpSurfaceGlobal->ddpfSurface.dwFourCC >> 16) & 0xFF;
                fourCCStr[3] = (char)(lpSurfaceGlobal->ddpfSurface.dwFourCC >> 24) & 0xFF;
                fourCCStr[4] = 0;
                DPF( "FOURCC %s allocation: size=%lu bytes", &fourCCStr, dwBlockSize );
#endif // DEBUG
                /* now allocate enough AGP memory or local video memory for the YV12 part of the surface */
                lPitch = lpSurfaceGlobal->wWidth;
                lpSurfaceGlobal->lPitch = lPitch;

                dwBlockSize = ((lPitch * (adjustedHeight * 12L)) >> 3);
                /* Force block to be properly aligned */
                lPitch = (lPitch + ppdev->ulSurfaceAlign) & ~ppdev->ulSurfaceAlign;

                if (ppdev->NvFloatingMem2MemFormatBaseAddress == 0)
                    { /* If this is the first of a complex overlay surface */

                    /*
                     * Allocate enough AGP, video, or system memory for ALL of the surfaces in the
                     * complex surface in a single block
                     */

                    if (lpCreateSurface->dwSCnt > 2)
                        dwBlockSize *= (DWORD)lpCreateSurface->dwSCnt;
                    else /* Assume that 2 of these surfaces will be created */
                        dwBlockSize <<= 1;

                    fpVidMem = 0;

                    memType = 0;

                    NVHEAP_ALLOC(dwStatus,fpVidMem, dwBlockSize, TYPE_OVERLAY);
                    if (dwStatus!=0)
                    {
                        bMoveAllDfbsFromOffscreenToDibs(ppdev);
                        NVHEAP_ALLOC(dwStatus,fpVidMem, dwBlockSize, TYPE_OVERLAY);
                    }

                    if (dwStatus==0)
                        {
                        memType = DDSCAPS_LOCALVIDMEM;
                        ppdev->DDrawVideoSurfaceCount++;
                        lpSurfaceGlobal->fpVidMem = fpVidMem;
                        ppdev->NvFloatingMem2MemFormatMemoryHandle = 0;
                        }

                    if (dwStatus!=0)
                        { /* Finally try system memory */
#ifdef SYSMEM_FALLBACK
                        lpSurfaceGlobal->fpVidMem = DDHAL_PLEASEALLOC_USERMEM;
                        lpSurfaceGlobal->dwUserMemSize = dwBlockSize;
                        lpSurfaceDesc->lPitch = lPitch;
                        lpSurfaceDesc->dwFlags  |= DDSD_PITCH;
                        lpSurfaceLocal->ddsCaps.dwCaps &= ~DDSCAPS_LOCALVIDMEM;

                        lpSurfaceLocal->ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
#endif
                        return (DDHAL_DRIVER_NOTHANDLED);
                        }

#ifdef SYSMEM_FALLBACK
                    DPF( "    System memory FOURCC surface allocation succeeded" );
                    if ((memType == DDSCAPS_NONLOCALVIDMEM) || (memType == DDSCAPS_SYSTEMMEMORY))
                        { /* If system memory */

                        if (NvAllocContextDma(ppdev->hDriver,
                                              ppdev->hClient,
                                              NV_DD_FLOATING_FORMAT_CONTEXT_DMA_FROM_SYSTEM_MEMORY,
                                              NV01_CONTEXT_DMA,
                                              NVOS03_FLAGS_ACCESS_READ_ONLY,
                                              (PVOID) lpSurfaceGlobal->fpVidMem,
                                              dwBlockSize - 1
                                              ) != NVOS03_STATUS_SUCCESS)
                        /*
                        if (NvAllocContextDma(ppdev->hDriver,
                                              NV_DD_FLOATING_FORMAT_CONTEXT_DMA_FROM_SYSTEM_MEMORY,
                                              NV_CONTEXT_DMA_FROM_MEMORY,
                                              (PVOID) lpSurfaceGlobal->fpVidMem,
                                              dwBlockSize - 1,
                                              0) != NV0002_ERROR_OK)
                        */
                            {
                            DISPDBG((2, "DdCreateSurface: cannot create dma context in sys mem"));
                            /* Can't lock down system memory, forget using this technique */
                            ppdev->NvFloatingMem2MemFormatBaseAddress = 0;
                            /* Free video memory just allocated above */
                            NVHEAP_FREE(ppdev->NvYUY2Surface0Mem);
                            if (ppdev->DDrawVideoSurfaceCount > 0)
                                ppdev->DDrawVideoSurfaceCount--;

                            /* Free AGP memory just allocated above */
                            NVHEAP_FREE(lpSurfaceGlobal->fpVidMem);
                            lpSurfaceGlobal->fpVidMem = 0;
                            lpCreateSurface->ddRVal = DDERR_OUTOFMEMORY;
                            goto CREATE_HANDLED;
                            }
                        }
#endif // #ifdef SYSMEM_FALLBACK

                    ppdev->NvFloatingMem2MemFormatBaseAddress =
                        (DWORD)lpSurfaceGlobal->fpVidMem;
                    }
                else
                    {
                    lpSurfaceGlobal->fpVidMem = ppdev->NvFloatingMem2MemFormatNextAddress =
                        ppdev->NvFloatingMem2MemFormatBaseAddress + dwBlockSize;
                    }

                if (lpSurfaceLocal->ddsCaps.dwCaps & DDSCAPS_OVERLAY)
                    {
                    index = 0;
                    while ((ppdev->dwOverlaySurfaceLCL[index] != 0) &&
                           (index < NV_MAX_OVERLAY_SURFACES))
                        index++;
                    ppdev->dwOverlaySurfaceLCL[index] = (DWORD) lpSurfaceLocal;
                    ppdev->dwOverlayOwner = (DWORD)powner;
                    ppdev->dwOverlaySurfaces++;
                    }
            }
        }
    else
        {
        //**************************************************************************
        // Allocate a space in off-screen memory, using our own heap
        // manager:
        //**************************************************************************
        lPitch = wWidth * ppdev->cjPelSize;
        lPitch = (lPitch + ppdev->ulSurfaceAlign) & ~ppdev->ulSurfaceAlign;
        if (lpSurfaceLocal->ddsCaps.dwCaps & (DDSCAPS_BACKBUFFER | DDSCAPS_FLIP))
            {
            NVHEAP_ALLOC_TILED(dwStatus,fpVidMem, lPitch, wHeight, TYPE_IMAGE);
            }
        else
            {
            NVHEAP_ALLOC(dwStatus,fpVidMem, lPitch * wHeight, TYPE_IMAGE);
            }
        if (dwStatus!=0)
        {
            bMoveAllDfbsFromOffscreenToDibs(ppdev);
            lPitch = (lPitch + ppdev->ulSurfaceAlign) & ~ppdev->ulSurfaceAlign;
            if (lpSurfaceLocal->ddsCaps.dwCaps & (DDSCAPS_BACKBUFFER | DDSCAPS_FLIP))
                {
                NVHEAP_ALLOC_TILED(dwStatus,fpVidMem, lPitch, wHeight, TYPE_IMAGE);
                }
            else
                {
                NVHEAP_ALLOC(dwStatus,fpVidMem, lPitch * wHeight, TYPE_IMAGE)
                }
        }
        if (dwStatus==0)
            {
            ppdev->DDrawVideoSurfaceCount++;

            //**********************************************************************
            // Flip surfaces, detected by surface requests that are the
            // same size as the current display, have special
            // considerations: they must live in the first four megabytes
            // of video memory:
            //**********************************************************************

            lpSurfaceGlobal->yHint        = (fpVidMem / ppdev->lDelta);
            lpSurfaceGlobal->xHint        = ((fpVidMem - (lpSurfaceGlobal->yHint * ppdev->lDelta))/ ppdev->cjPelSize) ;
            lpSurfaceGlobal->fpVidMem     = fpVidMem;
            lpSurfaceGlobal->lPitch       = lPitch;

            lpSurfaceDesc->lPitch   = lPitch;
            lpSurfaceDesc->dwFlags |= DDSD_PITCH;

            lpSurfaceLocal->ddsCaps.dwCaps &= ~DDSCAPS_SYSTEMMEMORY;
            lpSurfaceLocal->ddsCaps.dwCaps |= DDSCAPS_LOCALVIDMEM;

            //**********************************************************************
            // We handled the creation entirely ourselves, so we have to
            // set the return code and goto CREATE_HANDLED:
            //**********************************************************************

            lpCreateSurface->ddRVal = DD_OK;
            goto CREATE_HANDLED;
            }
        else
            {
            return (DDHAL_DRIVER_NOTHANDLED);
            }
        }
    //**********************************************************************
    // We handled the creation entirely ourselves, so we have to
    // set the return code and goto CREATE_HANDLED:
    //**********************************************************************
    lpCreateSurface->ddRVal = DD_OK;

CREATE_HANDLED:
    return DDHAL_DRIVER_HANDLED;

    }
#endif // IS_WINNT4

/******************************Public*Routine**********************************\
* DWORD DdSetColorKey
*
\******************************************************************************/
DWORD __stdcall DdSetColorKey(PDD_SETCOLORKEYDATA lpSetColorKey)
    {
    PDD_DIRECTDRAW_GLOBAL pdrv;
    PDD_SURFACE_LOCAL     psurf;
    PDEV                 *ppdev;

    pdrv = lpSetColorKey->lpDD;
    psurf = lpSetColorKey->lpDDSurface;
    ppdev = (PDEV *) lpSetColorKey->lpDD->dhpdev;

    DPF( "in SetSurfaceColorKey, lpSetColorKey->lpDD=%08lx, lpSetColorKey->lpDDSurface = %08lx",
         pdrv, lpSetColorKey->lpDDSurface );

    if (lpSetColorKey->dwFlags == DDCKEY_SRCBLT)
        {
        psurf->ddckCKSrcOverlay.dwColorSpaceLowValue =
        lpSetColorKey->ckNew.dwColorSpaceLowValue & ppdev->physicalColorMask;
        /* Use no mask on this one on NV3 so that our D3D driver can get all the bits when surface is 565 */
        psurf->ddckCKSrcOverlay.dwColorSpaceHighValue =
        lpSetColorKey->ckNew.dwColorSpaceHighValue & ppdev->physicalColorMask;
        }
    else if (lpSetColorKey->dwFlags == DDCKEY_DESTOVERLAY)
        {
        psurf->ddckCKDestOverlay.dwColorSpaceLowValue =
        lpSetColorKey->ckNew.dwColorSpaceLowValue & ppdev->physicalColorMask;
        psurf->ddckCKDestOverlay.dwColorSpaceHighValue =
        lpSetColorKey->ckNew.dwColorSpaceHighValue & ppdev->physicalColorMask;
        }
    else
        {
        lpSetColorKey->ddRVal = DDERR_UNSUPPORTED;
        return DDHAL_DRIVER_HANDLED;
        }


    lpSetColorKey->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
    }

#if (_WIN32_WINNT >= 0x0500) && defined(NVD3D) && !defined(_WIN64)
//WINNT 5 version, use common code to build caps. If not D3D use WINNT 4 version
//note that both have to build with NV3/NV4
BOOL DrvGetDirectDrawInfo(
                         DHPDEV          dhpdev,
                         DD_HALINFO*     pHalInfo,
                         DWORD*          pdwNumHeaps,
                         VIDEOMEMORY*    pvmList,            // Will be NULL on first call
                         DWORD*          pdwNumFourCC,
                         DWORD*          pdwFourCC)          // Will be NULL on first call
    {
    PDEV*       ppdev;
    LONGLONG    li;
    DWORD       i=0;

    ppdev = (PDEV*) dhpdev;

    //**************************************************************************
    // When enabling Direct Draw, DrvGetDirectDrawInfo will get called twice.
    //
    // The first call will have (pvmList = NULL) and (pdwFourCC = NULL)
    // During this time, the driver needs to returns the size of the memory
    // heap and the number of FourCC's that the driver supports.
    //
    // During the second call, the driver should initialize pdwNumHeaps,
    // pvmList, pdwNumFourCC, and pdwFourCC based on the values returned
    // in the first call.
    //
    //**************************************************************************

    //************************************************************************
    // BUGBUG - temp hack til we get overlay conversion stuff working.
    //************************************************************************

#ifdef YUNV_UYNV
    *pdwNumFourCC = 10;
#else // YUNV_UYNV
    *pdwNumFourCC = 8;
#endif// YUNV_UYNV

#if !defined(DX_AGP)
    *pdwNumHeaps = 0;
#else
    *pdwNumHeaps = 1;       // AGP memory heap
#endif // #if _WIN32_WINNT >= 0x0500

    //**************************************************************************
    // Verify that we enabled Direct Draw in bEnableDirectDraw
    //**************************************************************************

    if (!(ppdev->flStatus & STAT_DIRECTDRAW_CAPABLE))
    {
        return (FALSE);
    }

    if (pvmList == NULL && pdwFourCC == NULL)
    {
        return (TRUE);
    }

    buildDDHALInfo32(ppdev->pDriverData);
    *pHalInfo = ppdev->pDriverData->HALInfo;

    pHalInfo->dwSize = sizeof(*pHalInfo);

    //**************************************************************************
    // Current primary surface attributes.  Since HalInfo is zero-initialized
    // by GDI, we only have to fill in the fields which should be non-zero:
    // First fill out VideoMemoryInformation
    //**************************************************************************

    pHalInfo->vmiData.pvPrimary       = ppdev->pjScreen;
    pHalInfo->vmiData.fpPrimary       = ppdev->ulPrimarySurfaceOffset;
    pHalInfo->vmiData.dwDisplayWidth  = ppdev->cxScreen;
    pHalInfo->vmiData.dwDisplayHeight = ppdev->cyScreen;
    pHalInfo->vmiData.lDisplayPitch   = ppdev->lDelta;

    pHalInfo->vmiData.ddpfDisplay.dwSize  = sizeof(DDPIXELFORMAT);
    pHalInfo->vmiData.ddpfDisplay.dwFlags = DDPF_RGB;
    pHalInfo->vmiData.ddpfDisplay.dwRGBBitCount = ppdev->cBitsPerPel;

    if (ppdev->iBitmapFormat == BMF_8BPP)
        {
        pHalInfo->vmiData.ddpfDisplay.dwFlags |= DDPF_PALETTEINDEXED8;
        }

    pHalInfo->vmiData.ddpfDisplay.dwRBitMask = ppdev->flRed;
    pHalInfo->vmiData.ddpfDisplay.dwGBitMask = ppdev->flGreen;
    pHalInfo->vmiData.ddpfDisplay.dwBBitMask = ppdev->flBlue;

#if defined(NV4) && defined(DX_AGP)
    //**************************************************************
    // AGP support is Win2k specific.
    //**************************************************************

    {
#if (_WIN32_WINNT >= 0x0500)
        // Ask miniport if AGP should be enabled.
        // Miniport has knowledge of AGP chipsets for which we should disable AGP functionality.
        // e.g. ALi1541 chipset

        ULONG ulReturn = 0;

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_SHOULD_AGP_BE_ENABLED,
                               NULL, 0, NULL, 0, &ulReturn))
        {
            // non NO_ERROR returned
            ppdev->bAgp = FALSE;
        }
        else
        {
            // NO_ERROR returned
            ppdev->bAgp = TRUE;
        }
#else
        ULONG cbLimit = 0xfff;

        if (NvAllocMemory(ppdev->hDriver,
            ppdev->hClient,
            ppdev->hDevice,
            NV_AGP_PUSHBUF_OBJECT_HANDLE,
            NV01_MEMORY_SYSTEM,
            (DRF_DEF(OS02, _FLAGS, _LOCATION, _AGP) | DRF_DEF(OS02, _FLAGS, _COHERENCY, _WRITE_COMBINE)),
            (PVOID *)&(ppdev->AgpHeapBase),
            &cbLimit))
        {
            ppdev->bAgp = FALSE;
        }
        else
        {
            ppdev->bAgp = TRUE;
            NvFree(ppdev->hDriver, ppdev->hClient, ppdev->hDevice, NV_AGP_PUSHBUF_OBJECT_HANDLE);
        }
#endif
    }

    if (ppdev->bAgp)
    {
        // get the AGP aperture size and store in pDriverdata->regMaxAGPLimit;
        NvWin2KGetAgpLimit(ppdev, ppdev->hClient, ppdev->hDevice);

        pHalInfo->ddCaps.ddsCaps.dwCaps |= DDSCAPS_NONLOCALVIDMEM;
        pHalInfo->ddCaps.dwCaps2        |= DDCAPS2_NONLOCALVIDMEMCAPS | DDCAPS2_NONLOCALVIDMEM;
        pHalInfo->ddCaps.dwVidMemTotal   = ppdev->pDriverData->regMaxAGPLimit + 1;

        NvWin2KpvmConfig(ppdev, pvmList);

        ppdev->AgpHeap = pvmList;
        ppdev->AgpHeapAlignment.Linear.dwStartAlignment = 256;
        ppdev->AgpHeapAlignment.Linear.dwPitchAlignment = 256;
    }
    else
#endif
    {
        pHalInfo->ddCaps.dwCaps2 &= ~DDCAPS2_NONLOCALVIDMEM;
        pHalInfo->ddCaps.dwVidMemTotal = ppdev->cbFrameBuf - (ppdev->cyScreen * ppdev->lDelta);
    }
    //**************************************************************************
    // Since we do our own memory allocation, we have to set dwVidMemTotal
    // ourselves.  Note that this represents the amount of available off-
    // screen memory, not all of video memory:
    //**************************************************************************

    //**************************************************************************
    // Dword alignment must be guaranteed for off-screen surfaces:
    //**************************************************************************
    pHalInfo->vmiData.dwOffscreenAlign = ppdev->ulSurfaceAlign + 1;
    pHalInfo->vmiData.dwTextureAlign   = ppdev->ulSurfaceAlign + 1;
    pHalInfo->vmiData.dwAlphaAlign     = ppdev->ulSurfaceAlign + 1;
    pHalInfo->vmiData.dwZBufferAlign   = ppdev->ulSurfaceAlign + 1;
    pHalInfo->vmiData.dwOverlayAlign   = ppdev->ulSurfaceAlign + 1;

    pdwFourCC[i] = DefaultGlobalData.fourCC[i++] = FOURCC_UYVY;
    pdwFourCC[i] = DefaultGlobalData.fourCC[i++] = FOURCC_YUY2;
    pdwFourCC[i] = DefaultGlobalData.fourCC[i++] = FOURCC_RAW8;
#ifdef YUNV_UYNV
    pdwFourCC[i] = DefaultGlobalData.fourCC[i++] = FOURCC_YUNV;
    pdwFourCC[i] = DefaultGlobalData.fourCC[i++] = FOURCC_UYNV;
#endif
    pdwFourCC[i] = DefaultGlobalData.fourCC[i++] = FOURCC_YV12;

    pdwFourCC[i] = DefaultGlobalData.fourCC[i++] = FOURCC_YVU9;
    pdwFourCC[i] = DefaultGlobalData.fourCC[i++] = FOURCC_IV32;
    pdwFourCC[i] = DefaultGlobalData.fourCC[i++] = FOURCC_IV31;
    pdwFourCC[i] = DefaultGlobalData.fourCC[i++] = FOURCC_IF09;

    // The first call will have (pvmList = NULL) and (pdwFourCC = NULL)
    // During this time, the driver needs to returns the size of the memory
    // heap and the number of FourCC's that the driver supports.
    DISPDBG((2,"NV3:DrvEnableDirectDraw: Set D3D caps"));
#if defined(NV4)
#ifndef _WIN64
    NvWin2KD3DHALCreateDriver(pHalInfo, ppdev);
#endif // D3D is not 64 bit code clean , skip for now...

    /*
     * Force reset of D3D rendering target and z-buffer.
     */
    ppdev->pDriverData->HALInfo = *pHalInfo;

    ppdev->pDriverData->dwFullScreenDOSStatus   = 0;
    ppdev->pDriverData->dwCurrentContextHandle  = 0;
    ppdev->pDriverData->bDirtyRenderTarget      = TRUE;

    ppdev->pDriverData->vpp.dwOverlayFSOvlHeadSaved = 0xFFFFFFFF;
    ppdev->pDriverData->vpp.dwOverlayFSOvlHead = 0xFFFFFFFF;
#else
    D3DHALCreateDriver((LPD3DHAL_GLOBALDRIVERDATA *)&pHalInfo->lpD3DGlobalDriverData,
                       (LPD3DHAL_CALLBACKS *)&pHalInfo->lpD3DHALCallbacks);
    pDriverData->HALInfo = *pHalInfo;
    /*
     * Force reset of D3D rendering target and z-buffer.
     */
    pDriverData->fFullScreenDosOccurred  = 0;
    pDriverData->lpLast3DSurfaceRendered = 0;
    pDriverData->dwCurrentContextHandle  = 0;

    pDriverData->vpp.dwOverlayFSOvlHeadSaved = 0xFFFFFFFF;
    pDriverData->vpp.dwOverlayFSOvlHead = 0xFFFFFFFF;

#endif // #ifdef NV4
    return (TRUE);
    }

#else
//
// WINNT 4 version -- no Direct3D
//
BOOL DrvGetDirectDrawInfo(
                         DHPDEV          dhpdev,
                         DD_HALINFO*     pHalInfo,
                         DWORD*          pdwNumHeaps,
                         VIDEOMEMORY*    pvmList,            // Will be NULL on first call
                         DWORD*          pdwNumFourCC,
                         DWORD*          pdwFourCC)          // Will be NULL on first call
{
    PDEV*       ppdev;
    LONGLONG    li;

    ppdev = (PDEV*) dhpdev;

    //**************************************************************************
    // When enabling Direct Draw, DrvGetDirectDrawInfo will get called twice.
    //
    // The first call will have (pvmList = NULL) and (pdwFourCC = NULL)
    // During this time, the driver needs to returns the size of the memory
    // heap and the number of FourCC's that the driver supports.
    //
    // During the second call, the driver should initialize pdwNumHeaps,
    // pvmList, pdwNumFourCC, and pdwFourCC based on the values returned
    // in the first call.
    //
    //**************************************************************************
    *pdwNumFourCC = NV_MAX_FOURCC;
    *pdwNumHeaps = 0;
    if (!ppdev->bEnableIF09)
    {
        //***********************************************************************
        // Don't report support for the IF09 FOURCC. The default Indeo codec
        // shipping with NT 4 doesn't decode IF09's properly, so we need to punt them
        // to sw. NOTE: WE ASSUME IF09 IS THE LAST CODEC in the FOURCC LIST!
        //************************************************************************
        (*pdwNumFourCC)--;
    }

    //**************************************************************************
    // Verify that we enabled Direct Draw in bEnableDirectDraw
    //**************************************************************************

    if (!(ppdev->flStatus & STAT_DIRECTDRAW_CAPABLE))
        return (FALSE);

    pHalInfo->dwSize = sizeof(*pHalInfo);

    //**************************************************************************
    // Current primary surface attributes.  Since HalInfo is zero-initialized
    // by GDI, we only have to fill in the fields which should be non-zero:
    // First fill out VideoMemoryInformation
    //**************************************************************************

    pHalInfo->vmiData.pvPrimary       = ppdev->pjScreen;
    pHalInfo->vmiData.fpPrimary       = ppdev->ulPrimarySurfaceOffset;
    pHalInfo->vmiData.dwDisplayWidth  = ppdev->cxScreen;
    pHalInfo->vmiData.dwDisplayHeight = ppdev->cyScreen;
    pHalInfo->vmiData.lDisplayPitch   = ppdev->lDelta;

    pHalInfo->vmiData.ddpfDisplay.dwSize  = sizeof(DDPIXELFORMAT);
    pHalInfo->vmiData.ddpfDisplay.dwFlags = DDPF_RGB;
    pHalInfo->vmiData.ddpfDisplay.dwRGBBitCount = ppdev->cBitsPerPel;

    if (ppdev->iBitmapFormat == BMF_8BPP)
    {
        pHalInfo->vmiData.ddpfDisplay.dwFlags |= DDPF_PALETTEINDEXED8;
    }

    pHalInfo->vmiData.ddpfDisplay.dwRBitMask = ppdev->flRed;
    pHalInfo->vmiData.ddpfDisplay.dwGBitMask = ppdev->flGreen;
    pHalInfo->vmiData.ddpfDisplay.dwBBitMask = ppdev->flBlue;

    //**************************************************************************
    // Since we do our own memory allocation, we have to set dwVidMemTotal
    // ourselves.  Note that this represents the amount of available off-
    // screen memory, not all of video memory:
    //**************************************************************************

    pHalInfo->ddCaps.dwVidMemTotal = ppdev->cbFrameBuf - (ppdev->cyScreen * ppdev->lDelta);

    //**************************************************************************
    // Dword alignment must be guaranteed for off-screen surfaces:
    //**************************************************************************

    pHalInfo->vmiData.dwOffscreenAlign = ppdev->ulSurfaceAlign + 1;

    //**************************************************************************
    // Capabilities supported:
    //**************************************************************************

    pHalInfo->ddCaps.dwCaps = DDCAPS_BLT
                              | DDCAPS_BLTCOLORFILL
                              | DDCAPS_COLORKEY
                              | DDCAPS_READSCANLINE
                              | DDCAPS_BLTFOURCC
                              | DDCAPS_OVERLAY
                              | DDCAPS_OVERLAYSTRETCH
                              | DDCAPS_OVERLAYFOURCC
                              | DDCAPS_OVERLAYCANTCLIP
                              | DDCAPS_BLTDEPTHFILL;

    pHalInfo->ddCaps.dwCKeyCaps = DDCKEYCAPS_SRCBLT;

    pHalInfo->ddCaps.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN
                                      | DDSCAPS_PRIMARYSURFACE
                                      | DDSCAPS_FLIP
                                      | DDSCAPS_OVERLAY
                                      | DDSCAPS_HWCODEC;

    // Overlays need 8-byte alignment.  Note that if 24bpp overlays are
    // ever supported, this will have to change to compensate:
    pHalInfo->vmiData.dwOverlayAlign = ppdev->ulSurfaceAlign + 1;

    pHalInfo->ddCaps.dwCaps |=
          DDCAPS_OVERLAY
        | DDCAPS_OVERLAYSTRETCH
        | DDCAPS_OVERLAYFOURCC
        | DDCAPS_OVERLAYCANTCLIP;

    pHalInfo->ddCaps.dwFXCaps |= DDFXCAPS_OVERLAYSTRETCHX
                              | DDFXCAPS_OVERLAYSTRETCHY;
                                                                 // H.AZAR: (03/15/1999) overlay shrink support !
                                 //| DDFXCAPS_OVERLAYSHRINKX
                                 //| DDFXCAPS_OVERLAYSHRINKY;

    // We support only destination colour keying because that's the
    // only permutation we've had a chance to test.
    pHalInfo->ddCaps.dwCKeyCaps |= DDCKEYCAPS_DESTOVERLAY;

    if (pdwFourCC)
    {
        USHORT i = 0;
        pdwFourCC[i] = ppdev->fourCC[i++] = FOURCC_UYVY;
        pdwFourCC[i] = ppdev->fourCC[i++] = FOURCC_YUY2;
        pdwFourCC[i] = ppdev->fourCC[i++] = FOURCC_YVU9;
        pdwFourCC[i] = ppdev->fourCC[i++] = FOURCC_IV32;
        pdwFourCC[i] = ppdev->fourCC[i++] = FOURCC_IV31;
        pdwFourCC[i] = ppdev->fourCC[i++] = FOURCC_YV12;
        if (ppdev->bEnableIF09)
        {
            pdwFourCC[i] = ppdev->fourCC[i++] = FOURCC_IF09;
        }
    }
    pHalInfo->ddCaps.dwMaxVisibleOverlays = 1;
    pHalInfo->ddCaps.dwMinOverlayStretch   = ppdev->ulMinOverlayStretch;
    pHalInfo->ddCaps.dwMinLiveVideoStretch = ppdev->ulMinOverlayStretch;
    pHalInfo->ddCaps.dwMinHwCodecStretch   = ppdev->ulMinOverlayStretch;

    pHalInfo->ddCaps.dwMaxOverlayStretch   = 9999;
    pHalInfo->ddCaps.dwMaxLiveVideoStretch = 9999;
    pHalInfo->ddCaps.dwMaxHwCodecStretch   = 9999;

    pHalInfo->ddCaps.dwCaps |= DDCAPS_BLTSTRETCH;
    pHalInfo->ddCaps.dwFXCaps |= DDFXCAPS_BLTSTRETCHX
                                 | DDFXCAPS_BLTSTRETCHY;
    return (TRUE);
}
#endif

//******************************Public*Routine**********************************
//
// Function: DrvEnableDirectDraw()
//
//  This function is called by GDI to enable DirectDraw when a DirectDraw
//  program is started and DirectDraw is not already active.
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************


BOOL DrvEnableDirectDraw(
                        DHPDEV                  dhpdev,
                        DD_CALLBACKS*           pCallBacks,
                        DD_SURFACECALLBACKS*    pSurfaceCallBacks,
                        DD_PALETTECALLBACKS*    pPaletteCallBacks)

{
    PDEV* ppdev;
    ppdev = (PDEV*) dhpdev;

    //**************************************************************************
    // Perform one time initialization steps necessary every time directdraw is
    // started.
    //**************************************************************************
    if (!bAssertModeDirectDraw(ppdev, TRUE))
        return(FALSE);
    ppdev->flStatus |= STAT_DIRECTDRAW_ENABLED;
#ifndef NVD3D
    //****************************************************************************
    // DX3 - Initialize HAL fct ptrs.
    //****************************************************************************
    NvDDEnable(ppdev);
    *pCallBacks = ppdev->ddCallBacks;
    *pSurfaceCallBacks = ppdev->ddSurfaceCallBacks;
    *pPaletteCallBacks = ppdev->ddPaletteCallBacks;

#else
    //****************************************************************************
    // DX6 - Initialize HAL fct ptrs.
    //****************************************************************************
#ifndef _WIN64
    ppdev->pDriverData->DDCallbacks.dwFlags  |= DDHAL_CB32_MAPMEMORY;
    ppdev->pDriverData->DDCallbacks.MapMemory = DdMapMemory;
    *pCallBacks = ppdev->pDriverData->DDCallbacks;
    *pSurfaceCallBacks = ppdev->pDriverData->DDSurfaceCallbacks;
    *pPaletteCallBacks = ppdev->pDriverData->DDPaletteCallbacks;
#endif // #ifndef _WIN64
#endif // #ifndef NVD3D
    return (TRUE);
}

//******************************Public*Routine**********************************
//
// Function: DrvDisableDirectDraw()
//
//      This function is called by GDI when the last active DirectDraw program
//      is quit and DirectDraw will no longer be active.
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************

VOID DrvDisableDirectDraw(
                         DHPDEV      dhpdev)

    {
    PDEV* ppdev;
    ULONG  NvStatus;
    BOOL  status;
    ppdev = (PDEV*) dhpdev;
    if (!ppdev || !ppdev->bEnabled)
        {
        return;
        }

#if defined(NVD3D) && (NVARCH>= 0x04)
    vDisableDirectDraw(ppdev);
#else
    if (!bAssertModeDirectDraw(ppdev, FALSE))
        return;
#endif // NVD3D

    ppdev->flStatus &= ~STAT_DIRECTDRAW_ENABLED;

    //*****************************************************************************
    // If the 2d driver is running in DMA push mode, the channel ptr in ppdev->pjMmBase
    // must be the ddraw channel ptr, which is no longer valid.
    //*****************************************************************************
#if _WIN32_WINNT >= 0x0500
    // ifdeffed out because NT4 still references the PIO channel in many places -- slum
    if (ppdev->DmaPushEnabled2D)
        {
        ppdev->pjMmBase = NULL;
        }
#endif
    return;
    }

//******************************Public*Routine**********************************
//
// Function: bAssertModeDirectDraw
//
//      This function is called by enable.c when entering or leaving the
//      DOS full-screen character mode.
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     TRUE if successful.
//     FALSE if an error occurred.
//
//******************************************************************************


BOOL bAssertModeDirectDraw(PDEV*   ppdev, BOOL    bEnable)
{
    BOOL releaseOpenglSemaphore = FALSE;

    ENTER_DMA_PUSH_SYNC();

    if (bEnable && !ppdev->DDrawEnabledFlag)
    {
        //*************************************************************************
        // Init ddraw state data.
        //*************************************************************************
        ppdev->OverlayBufferIndex = 1;

        //*************************************************************************
        // If this is NV4, create the ddraw patch. NV3 ddraw patch is integrated
        // into the 2D patch.
        //*************************************************************************
#ifndef NVD3D
        if (!ppdev->pDriverData->dwRootHandle)
        {
            if (!DriverInit_NT4(ppdev->pDriverData))
                return(FALSE);
        }
        nvAssert(ppdev->pDriverData->dwRootHandle);

        if (!bCreateNVDDPatch(ppdev))
        {
            END_DMA_PUSH_SYNC();
            return(FALSE);
        }
#else
        //**************************************************************************
        // Initialize DX7 driver state for this device.
        //**************************************************************************
#ifndef _WIN64
#if (NVARCH >= 0x04)
        if (!ppdev->pDriverData->dwRootHandle)
            if (!DriverInit((ULONG)ppdev))
                return(FALSE);
#else
        if (ppdev->pDriverData == NULL)
        {
            pDriverData = ppdev->pDriverData =
                EngAllocMem(FL_ZERO_MEMORY, sizeof(GLOBALDATA), ALLOC_TAG);
            if (ppdev->pDriverData == NULL)
                {
                END_DMA_PUSH_SYNC();
                return(FALSE);
                }
            *(ppdev->pDriverData) = DefaultGlobalData;
            ppdev->pDriverData->dwGlobalStructSize = sizeof(GLOBALDATA);
            ppdev->pDriverData->ppdev = ppdev;
            ppdev->pDriverData->dwRootHandle = ppdev->hClient;
            ppdev->pDriverData->dwDeviceHandle = ppdev->hDevice;
            ddEnable(ppdev);
            if (!DriverInit((ULONG) ppdev))
            {
                EngFreeMem(ppdev->pDriverData);
                ppdev->pDriverData = NULL;
                END_DMA_PUSH_SYNC();
                return(FALSE);
            }
        }
#endif // D3D is not 64 bit code clean , skip for now...


        //********************************************************
        // Temp hack to use RM pitch alignment.
        //********************************************************
        ppdev->pDriverData->HALInfo.vmiData.lDisplayPitch = ppdev->lDelta;
        ppdev->pDriverData->VideoHeapTotal = ppdev->VideoHeapTotal;
        ppdev->pDriverData->VideoHeapFree = ppdev->VideoHeapFree;

#endif // #ifdef NVD3D
#endif // #ifndef _WIN64
        ppdev->DDrawEnabledFlag = TRUE;
    }
    else if (!bEnable && (ppdev->DDrawEnabledFlag))
    {
        //*************************************************************************
        // If this is NV4, destroy the ddraw patch. NV3 ddraw patch is integrated
        // into the 2D patch.
        //*************************************************************************
#ifndef NVD3D
        if (!bDestroyNVDDPatch(ppdev))
        {
            END_DMA_PUSH_SYNC();
            return(FALSE);
        }
#else   // NVD3D
        if (ppdev->pDriverData)
        {
            DWORD status;
            //************************************************
            // Force DX driver to recreate its objects.
            //************************************************
#ifndef _WIN64
            status = DestroyDriver32(ppdev->pDriverData);
#endif // D3D is not 64 bit code clean , skip for now...
        }

#endif // NVD3D
        ppdev->DDrawEnabledFlag = FALSE;
    }
    else if (bEnable && ppdev->DDrawEnabledFlag)
    {
#ifndef NVD3D
        extern VOID __cdecl NvTurnOffVideoOverlay(PDEV *ppdev);

        if(ppdev->dwOverlayEnabled == TRUE)
        {
            NvTurnOffVideoOverlay(ppdev);
        }
#endif
    }

    END_DMA_PUSH_SYNC();
    return(TRUE);
}

//******************************Public*Routine**********************************
//
// Function: bEnableDirectDraw()
//
// Routine Description:
//
//      This function is called by enable.c when the mode is first initialized,
//      right after the miniport does the mode-set.
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************

BOOL bEnableDirectDraw(PDEV*   ppdev)
{
    //**************************************************************************
    // Now init the low level direct draw functions depending on
    // what chip we're currently using.  We need to do this here,
    // (instead of later in DrvEnableDirectDraw), because GetDisplayDuration
    // uses the hardware registers.
    //**************************************************************************
//BUGBUG
#ifdef NV3
    ppdev->pfnGraphicsEngineBusy        = NV3_GraphicsEngineBusy;
    ppdev->pfnVBlankIsActive            = NV3_VBlankIsActive;
    ppdev->pfnWaitWhileVBlankActive     = NV3_WaitWhileVBlankActive;
    ppdev->pfnWaitWhileDisplayActive    = NV3_WaitWhileDisplayActive;
#else
    ppdev->pfnGraphicsEngineBusy        = NV4_GraphicsEngineBusy;
    ppdev->pfnVBlankIsActive            = NV4_VBlankIsActive;
    ppdev->pfnWaitWhileVBlankActive     = NV4_WaitWhileVBlankActive;
    ppdev->pfnWaitWhileDisplayActive    = NV4_WaitWhileDisplayActive;
#endif
    ppdev->pfnGetScanline               = NV_GetScanLineData;
    ppdev->pfnFifoIsBusy                = NV1FifoIsBusy;

#ifndef _WIN64
    //**************************************************************************
    // DirectDraw is all set to be used on this card:
    //**************************************************************************

    ppdev->flStatus |= STAT_DIRECTDRAW_CAPABLE;

    //**************************************************************************
    // Anything else we need to do here to prep NV for Direct Draw ??
    //**************************************************************************
#if (NVARCH >= 0x04)
#if IS_WINNT4
        if (!ppdev->pDriverData->dwRootHandle)
            if (!DriverInit_NT4(ppdev->pDriverData))
                return(FALSE);
#else
        if (!ppdev->pDriverData->dwRootHandle)
            if (!DriverInit((ULONG)ppdev))
                return(FALSE);
#endif
#endif

#endif // #ifndef _WIN64
    return (TRUE);
}

//******************************Public*Routine**********************************
//
// Function: vDisableDirectDraw()
//
// Routine Description:
//
//      This function is called by enable.c when the driver is shutting down.
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************
VOID vDisableDirectDraw(PDEV*   ppdev)
{
#if IS_WINNT4
//@mjl@   VppDestructor(&ppdev->pDriverData->vpp);
#endif

    if (!bAssertModeDirectDraw(ppdev, FALSE))
    {
        return;
    }

    ppdev->flStatus &= ~STAT_DIRECTDRAW_ENABLED;
}

#if _WIN32_WINNT >= 0x0500
//******************************Public*Routine**********************************
/*
 *  GetAvailDriverMemory
 *
 *  DDraw 'miscellaneous' callback returning the amount of free memory in driver's
 *  'private' heap
 */
//******************************************************************************

DWORD WINAPI GetAvailDriverMemory (PDD_GETAVAILDRIVERMEMORYDATA  pDmd)
{
    LONG    Free, Total;
    memory_t* pBlk;
    PDEV  *ppdev = pDmd->lpDD->dhpdev;

    DISPDBG((2,"NV3: GetAvailDriverMemory"));

    //**************************************************************************
    // Currently the driver only manages local vidmem
    //**************************************************************************
    if (pDmd->DDSCaps.dwCaps & DDSCAPS_LOCALVIDMEM ||
        pDmd->DDSCaps.dwCaps & DDSCAPS_VIDEOMEMORY ||
        pDmd->DDSCaps.dwCaps & DDSCAPS_PRIMARYSURFACE ||
        pDmd->DDSCaps.dwCaps & DDSCAPS_OFFSCREENPLAIN
#ifdef NVD3D
        ||
        pDmd->DDSCaps.dwCaps & DDSCAPS_TEXTURE
#endif // #ifdef NVD3D
        )
#ifndef RM_HEAPMGR
        {
        if (pDmd->DDSCaps.dwCaps &
            (DDSCAPS_VIDEOMEMORY | DDSCAPS_TEXTURE | DDSCAPS_LOCALVIDMEM))
            {
            pBlk = (memory_t *) ppdev->heap.heap_2d_ptr;
            if (!pBlk)
                {
                pDmd->ddRVal = DDERR_GENERIC;
                return(DDHAL_DRIVER_HANDLED);
                }
            Free = Total = 0;
            do
                {
                if (IS_EMPTY(pBlk))
                    Free += pBlk->blkSize;
                Total += pBlk->blkSize;
                pBlk  = pBlk->next;
                } while (pBlk != ppdev->heap.heap_2d_ptr);
            Free *= ALIGN_SIZE;
            Total *= ALIGN_SIZE;
            pDmd->dwFree = Free;
            pDmd->dwTotal = Total - (ppdev->cyScreen * ppdev->lDelta);
            }
        if (pDriverData->GARTLinearBase &&
            pDmd->DDSCaps.dwCaps &
                (DDSCAPS_VIDEOMEMORY | DDSCAPS_TEXTURE | DDSCAPS_NONLOCALVIDMEM))
            {
            pDmd->dwTotal += MAX_AGP_HEAP;
            pDmd->dwFree += MAX_AGP_HEAP;
            if (pDriverData->NvAGPDmaPusherBufferBase)
                {
                //*************************************************
                // Account for AGP push buffer.
                //*************************************************
                pDmd->dwFree -= pDriverData->NvDmaPusherBufferSize;
                }
            }
        }
#else
        {
        //********************************************************
        // Any memory currently used by GDI device bitmaps should
        // be reported as available for DX usage.
        //********************************************************
        pDmd->dwTotal = ppdev->VideoHeapTotal;
        pDmd->dwFree  = ppdev->VideoHeapFree + ppdev->cbGdiHeap;
        }
#endif // RM_HEAPMGR
        else
        {
            pDmd->dwTotal = 0;
            pDmd->dwFree  = 0;
        }

    pDmd->ddRVal = DD_OK;

    DISPDBG((2,"NV3:            Total:0x%08xd",pDmd->dwTotal));
    DISPDBG((2,"NV3:            Free :0x%08xd",pDmd->dwFree));
    return DDHAL_DRIVER_HANDLED;
}
#if !defined(DX7) || !(NVARCH >= 0x04) // DX7 driver uses GetDriverInfo32 routine in common code
//******************************Public*Routine**********************************
/*
 * GetDriverInfo32
 *
 * Initialize Extended Functionality Classes
 */
//******************************************************************************

DWORD WINAPI GetDriverInfo32(struct _DD_GETDRIVERINFODATA *lpData)
{
        DWORD dwSize = 0;
    PDEV  *ppdev = lpData->dhpdev;

    DISPDBG((2,"NV3dd: GetDriverInfo"));
    lpData->ddRVal = DDERR_CURRENTLYNOTAVAIL;

    if (IsEqualIID(&(lpData->guidInfo), &GUID_MiscellaneousCallbacks) ) {
        DD_MISCELLANEOUSCALLBACKS miscCB;
        dwSize = lpData->dwExpectedSize;

        DISPDBG((2,"NV3dd: GetDriverInfo - Process GUID_MiscellaneousCallbacks"));
        if ( sizeof(miscCB) < dwSize )
            dwSize = sizeof(miscCB);
        lpData->dwActualSize = sizeof(miscCB);
        memset(&miscCB, 0, dwSize);
        miscCB.dwSize = dwSize;

        miscCB.dwFlags = DDHAL_MISCCB32_GETAVAILDRIVERMEMORY;

        miscCB.GetAvailDriverMemory = GetAvailDriverMemory;

        memcpy(lpData->lpvData, &miscCB, dwSize );
        lpData->ddRVal = DD_OK;
    }

#ifdef NVPE
    /*
     * VPE stuff
     */

    if (IsEqualIID(&lpData->guidInfo, &GUID_VideoPortCallbacks))
    {
            dwSize = sizeof(DDHAL_DDVIDEOPORTCALLBACKS);

            lpData->dwActualSize = dwSize;
            lpData->ddRVal = DD_OK;

            memcpy(lpData->lpvData, &LPBVideoPortCallbacks, dwSize);
    }

        ///// H.AZAR (02/02/99): use structure defined in nvpe.lib
    if (IsEqualIID(&lpData->guidInfo, &GUID_VideoPortCaps))
    {
            dwSize = sizeof(DDVIDEOPORTCAPS);

            lpData->dwActualSize = dwSize;
            lpData->ddRVal = DD_OK;

            memcpy(lpData->lpvData, &g_ddNVideoPortCaps, dwSize);
    }

    if (IsEqualIID(&(lpData->guidInfo), &GUID_KernelCallbacks) )
    {
                DDHAL_DDKERNELCALLBACKS KernelCallbacks;
        DWORD dwSize = lpData->dwExpectedSize;

        if ( sizeof(KernelCallbacks) < dwSize )
            dwSize = sizeof(KernelCallbacks);
        lpData->dwActualSize = sizeof(KernelCallbacks);

        KernelCallbacks.dwSize = sizeof(DDHAL_DDKERNELCALLBACKS);
        KernelCallbacks.dwFlags = 0; //DDHAL_KERNEL_SYNCSURFACEDATA | DDHAL_KERNEL_SYNCVIDEOPORTDATA;
        KernelCallbacks.SyncSurfaceData = NULL;          // we're not doing anything on EITHER of these yet
        KernelCallbacks.SyncVideoPortData = NULL;

        memcpy(lpData->lpvData, &KernelCallbacks, dwSize );
        lpData->ddRVal = DD_OK; //DDERR_CURRENTLYNOTAVAIL;
    }

    if (IsEqualIID(&(lpData->guidInfo), &GUID_KernelCaps))
    {
        DDKERNELCAPS cpKernelCaps;
        if (lpData->dwExpectedSize != sizeof(DDKERNELCAPS))
            return DDHAL_DRIVER_HANDLED;

        lpData->dwActualSize = sizeof(DDKERNELCAPS);

        cpKernelCaps.dwSize = sizeof(DDKERNELCAPS);
        cpKernelCaps.dwCaps =   DDKERNELCAPS_SKIPFIELDS         |
                                        DDKERNELCAPS_AUTOFLIP           |
                                        DDKERNELCAPS_SETSTATE           |
                                            DDKERNELCAPS_LOCK               |
                                            //DDKERNELCAPS_FLIPVIDEOPORT      |
                                            DDKERNELCAPS_FLIPOVERLAY        |
                                            DDKERNELCAPS_CAPTURE_SYSMEM |
                                            //DDKERNELCAPS_CAPTURE_NONLOCALVIDMEM |
                                            DDKERNELCAPS_FIELDPOLARITY      ;
                                            //DDKERNELCAPS_CAPTURE_INVERTED   ;

        cpKernelCaps.dwIRQCaps = DDIRQ_VPORT0_VSYNC |
                                                           //#define DDIRQ_BUSMASTER                         0x00000002l
                               2; //DDIRQ_BUSMASTER;
                                                   //DDIRQ_DISPLAY_VSYNC |
                                                   //DDIRQ_RESERVED1     |
                                                   //DDIRQ_VPORT0_VSYNC  |    // this is the only IRQ we'll be supporting
                                                   //DDIRQ_VPORT0_LINE   |
                                                   //DDIRQ_VPORT1_VSYNC  |
                                                   //DDIRQ_VPORT1_LINE;

        memcpy(lpData->lpvData, &cpKernelCaps, sizeof(DDKERNELCAPS));
        lpData->ddRVal = DD_OK; //DDERR_CURRENTLYNOTAVAIL;
    }
#endif // NVPE

#ifdef NVD3D
    /*
     * Call D3D HAL to see if there's any GUIDs it wants to handle.
     */
    pDriverData = ppdev->pDriverData;
    D3DGetDriverInfo(lpData);
#endif // #ifdef NVD3D

    return DDHAL_DRIVER_HANDLED;

} /* GetDriverInfo32 */
#endif // !DX7
#endif // #if _WIN32_WINNT >= 0x0500

#if IS_WINNT4

/*
 * DriverInit_NT4
 *
 * this is the entry point called by DirectDraw to
 * initialize the 32-bit driver when running on NT4.
 *
 * This was converted from the version in ddraw/common/src/ddDrv.cpp and
 * the logic greatly reduced because we *know* we're on NT4 and many of the
 * optional features are not available (AGP for example).
 *
 * Note: all registry lookups have also been removed (for now)
 *
 */
DWORD __stdcall DriverInit_NT4(GLOBALDATA * pDriverData)
{
    static NvU8 bFirstTime = TRUE;

    dbgResetTraceLevel();
    dbgTracePush("DriverInit_NT4");

    nvAssert(pDriverData);
    nvAssert(pDriverData->ppdev);

    // These get erased on modesets? @mjl@
    pDriverData->dwRootHandle      = pDriverData->ppdev->hClient;
    pDriverData->NvBaseFlat        = (DWORD) pDriverData->ppdev->NvBaseAddr;

    if (bFirstTime)
    {
        pDriverData->pCommonNotifierBuffer = NULL;
        pDriverData->NvDeviceVersion   = (unsigned short) pDriverData->ppdev->dwDeviceVersion;
        pDriverData->dwDeviceHandle    = pDriverData->ppdev->hDevice;
        pDriverData->dwSurfaceAlignPad = pDriverData->ppdev->ulSurfaceAlign;
        pDriverData->BaseAddress       = 0;   // offset of frame buffer

        NvConfigGet(pDriverData->ppdev->hDriver,pDriverData->dwRootHandle, pDriverData->dwDeviceHandle,
            NV_CFG_RAM_SIZE_MB, &(pDriverData->TotalVRAM));
        pDriverData->TotalVRAM       <<= 20;    // Convert megabytes to bytes

#if (NVARCH < 0x010)
        if (pDriverData->NvDeviceVersion > NV_DEVICE_VERSION_5) {
            pDriverData->NvDeviceVersion = NV_DEVICE_VERSION_5;
        }
#endif // !NV10

        // get the number of heads (DACs) on this device
        NvConfigGet(pDriverData->ppdev->hDriver,pDriverData->dwRootHandle, pDriverData->dwDeviceHandle,
            NV_CFG_NUMBER_OF_HEADS, &pDriverData->dwHeads);

        nvDeterminePerformanceStrategy_NT4(pDriverData,&pDriverData->sysInfo);

        // Construct the VPP object (must be after nvDeterminePerformanceStrategy)
        //   There must be NO references to vpp data prior to this point
        //
        if (!VppConstructor(pDriverData->ppdev,&(pDriverData->vpp),&pDriverData->sysInfo))
        {
            VppDestructor(&(pDriverData->vpp)); // Release anything we might have allocated thus far
            dbgTracePop();
            return 0;
        }

        // TBD: move nvPusher init here? -@mjl@

//          bFirstTime = FALSE;
    }

    // Get the current registry settings from the hardware specific routine.
    // TBD: need any of these? @mjl@

    //***************************************************************
    // Shared variable for active channel id is stored in NT display
    // driver state.
    //***************************************************************

    g_adapterData[0].pDriverData = pDriverData; // add this device to the global adapter table (used by nvPriv)

    pDriverData->pCurrentChannelID       = &(pDriverData->ppdev->oglLastChannel);
    pDriverData->dwDesktopState          = 0;  // Means there is no clone or twinview mode
    pDriverData->regPBLocale             = NV_REG_SYS_PB_LOCATION_SYSTEM; // push buffer location: No AGP on NT4, force to SystemMem
//    pDriverData->dwVideoPortsAvailable   = 1;
    pDriverData->DDrawVideoSurfaceCount  = 0;
    pDriverData->dwTVTunerFlipCount      = 0;

    // Reset in case of a mode switch which unloaded the driver
    pDriverData->ppdev->HALInfo.ddCaps.dwCurrVisibleOverlays = 0;


    pDriverData->bltData.dwSystemSurfaceContextDMAIndex = 0;
    pDriverData->bltData.dwLastRop                      = 0xFFFFFFFF;
    pDriverData->bltData.dwLastColourKey                = 0xFFFFFFF0;
    pDriverData->bltData.dwLastColourFormat             = 0;
    pDriverData->bltData.dwLastCombinedPitch            = 0;
    pDriverData->bltData.dwLastSrcOffset                = 0xFFFFFFFF;
    pDriverData->bltData.dwLastDstOffset                = 0xFFFFFFFF;
    pDriverData->bltData.dwSystemBltFallback            = 0;
    pDriverData->bltData.dwLetItThrash                  = 0;


    // can't do this unless more than 4M and MMX instructions available
    if (!(pDriverData->sysInfo.dwCPUFeatureSet & FS_MMX) || (pDriverData->TotalVRAM <= 0x400000)) {
        pDriverData->vpp.regOverlayColourControlEnable = FALSE;
    }

    // Disable HQVUp on less than 16M
    if (pDriverData->TotalVRAM < 0x1000000) {
        pDriverData->vpp.regOverlayMode &= ~NV4_REG_OVL_MODE_VUPSCALE;
    }

    if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10)
    {
        // Disable HQVUp and sw colour controls on NV10
        pDriverData->vpp.regOverlayMode &= ~NV4_REG_OVL_MODE_VUPSCALE;
        pDriverData->vpp.regOverlayColourControlEnable = FALSE;
        if (pDriverData->TotalVRAM < 0x800000) {
            // Disable temporal and deinterlace filters on NV10 if less than 8M
            pDriverData->vpp.regOverlayMode &= ~NV4_REG_OVL_MODE_TFILTER;
            pDriverData->vpp.regOverlayMode &= ~NV4_REG_OVL_MODE_DFILTER;
        }
    } else {
        pDriverData->vpp.regOverlayMode &= ~NV4_REG_OVL_MODE_DFILTER;
        if (pDriverData->TotalVRAM < 0x1000000) {
            // Disable temporal filter on NV4/5 if less than 16M
            pDriverData->vpp.regOverlayMode &= ~NV4_REG_OVL_MODE_TFILTER;
        }
    }

    // Disable fullscreen mirror on non-dual head devices
    if (pDriverData->dwHeads < 2)
    {
        pDriverData->vpp.regOverlayMode2 &= ~NV4_REG_OVL_MODE2_FSDEVICEMASK;
    }
    else
    {
        dbgError("NT4 direct draw driver is seeing more than 1 head!");

        // Disable anyway!
        pDriverData->dwHeads = 1;
        pDriverData->vpp.regOverlayMode2 &= ~NV4_REG_OVL_MODE2_FSDEVICEMASK;
    }

    dbgTracePop();
    return (DWORD)pDriverData;
} // DriverInit_NT4

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\dmamacro.h ===
//******************************************************************************
//
// Module Name: DMAMACRO.H
//
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1998 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/
 
#define DECLARE_DMA_FIFO                                                \
    ULONG       nvDmaCount;                                             \
    ULONG       *nvDmaFifo                                              \
                         
                         
#define INIT_LOCAL_DMA_FIFO                                             \
    nvDmaCount = ppdev->nvDmaCount;                                     \
    nvDmaFifo = ppdev->nvDmaFifo;                                      \
    
#define NV_DMA_FIFO                 nvDmaFifo[nvDmaCount++]

#define UPDATE_PDEV_DMA_COUNT       ppdev->nvDmaCount  = nvDmaCount

#define UPDATE_LOCAL_DMA_COUNT      nvDmaCount = ppdev->nvDmaCount   


//******************************************************************************
// DMA Pusher Control DWORD macros
//******************************************************************************

#define NV_DMAPUSH_CONTROL_WORD(NUM_DWORD, SUBCH, METHOD_OFFSET)            \
            ( ((NUM_DWORD)<<18) | ((SUBCH)<<13) | (METHOD_OFFSET) )

#define NV_DMAPUSH_START(NUM_DWORD, SUBCH, METHOD_OFFSET)                   \
{\
            nvDmaFifo[nvDmaCount++] = NV_DMAPUSH_CONTROL_WORD(NUM_DWORD,    \
                                                              SUBCH,        \
                                                              METHOD_OFFSET); \
}                                                              

#define NV_DMAPUSH_SET_DEST_BASE(ppdev, Offset, Stride)                     \
{                                                                           \
    if ((Offset != ppdev->CurrentDestOffset) ||                             \
        (Stride != (LONG)ppdev->CurrentDestPitch))                          \
        {                                                                   \
        (ppdev->pfnSetDestBase)(ppdev, Offset, Stride);                     \
        }                                                                   \
}                                                              

#define NV_DMAPUSH_SET_SOURCE_BASE(ppdev, Offset, Stride)                   \
{                                                                           \
    if ((Offset != ppdev->CurrentSourceOffset) ||                           \
        (Stride != (LONG)ppdev->CurrentSourcePitch))                        \
        {                                                                   \
        (ppdev->pfnSetSourceBase)(ppdev, Offset, Stride);                   \
        }                                                                   \
}                                                              

//******************************************************************************
// DMAPUSH_WRITE1 macro 
//
// Writes a control dword followed by ONE method value
// 
// SUBCH            = subchannel for the methods placed into the push buffer
// METHOD_OFFSET    = offset to the first method in the subchannel to
//                    be filled in by the push buffer commands
// METHOD_VALUE     = Actual value sent to hardware
// 
//
//
// Example Usage of sending MULTIPLE method values:
//
//            NV_DMAPUSH_START(NUM_DWORDS, SUBCHANNEL, STARTING_OFFSET)
//            nvDmaFifo[nvDmaCount++] = METHOD_VALUE1
//            nvDmaFifo[nvDmaCount++] = METHOD_VALUE2
//            nvDmaFifo[nvDmaCount++] = METHOD_VALUE3
//            nvDmaFifo[nvDmaCount++] = METHOD_VALUE4
//            nvDmaFifo[nvDmaCount++] = METHOD_VALUE5
//            nvDmaFifo[nvDmaCount++] = METHOD_VALUE6
//            ... up to N methods
//
//******************************************************************************

#define NV_DMAPUSH_WRITE1(SUBCH, METHOD_OFFSET, METHOD_VALUE)               \
{\
            NV_DMAPUSH_START(1, SUBCH, METHOD_OFFSET);                      \
            nvDmaFifo[nvDmaCount++] = METHOD_VALUE;                         \
}


//******************************************************************************
// CREATE OBJECT macro
//
// SUBCHANNEL to be used
// CLASS type to create
// INSTANCE name
//******************************************************************************

//#define NV_CREATE_OBJECT(SUBCH,CLASS,INSTANCE)                              \
//{\
//            NV_DMAPUSH_WRITE1(SUBCH, NVFFF_SET_OBJECT, CLASS);              \
//            NV_DMAPUSH_WRITE1(SUBCH, NVFFF_CREATE, INSTANCE);               \
//}            

//******************************************************************************
// DESTROY OBJECT macro
//
// SUBCHANNEL to be used
// CLASS type to destroy
// INSTANCE name
//******************************************************************************

#define NV_DESTROY_OBJECT(SUBCH,CLASS,INSTANCE)                              \
{\
            NV_DMAPUSH_WRITE1(SUBCH, NVFFF_SET_OBJECT, CLASS);               \
            NV_DMAPUSH_WRITE1(SUBCH, NVFFF_DESTROY, INSTANCE);               \
}            


//******************************************************************************
// Used to reset the DMA buffer address back to the beginning
//******************************************************************************

#define NV4_JUMP(ADDR)                              (0x20000000 | (ADDR))


//******************************************************************************
//
// NV_DMAPUSH_CHECKFREE() macro
//
//
//         WRAP_FLAG = FALSE
//
//         ---------  0  
//        |         |    
//        |         |    
//        |         |    
//        |         |  
//        |         |  
//        |         |  
//        |  Push   |  
//        | Buffer  |  
//        |         |  <----- Get Ptr (Normally, the GET ptr will be 'less'
//        |         |    |             than the PUT ptr. It constantly tries
//        |         |    v             to catchup to the PUT ptr.
//        |         |
//        |         |  <----- Cached Put Ptr 
//        |         |    | 
//        |         |    v
//        |         |  <----- DMA Count (Where CPU writes data)  
//        |         |    
//         ---------    
//
//         Total Size of Push Buffer
//
//
//  ---------------------------------------------------------------------------
//
//
//         WRAP_FLAG = TRUE
//          
//         ---------  0  
//        |         |    
//        |         |    
//        |         |  <----- Cached Put Ptr (Where the last hardware PUT occurred)  
//        |         |    |                   (PUT ptr must not get ahead of the GET ptr)  
//        |         |    v
//        |         |  
//        |  Push   |  <----- DMA Count (Where CPU currently writes data)
//        | Buffer  |    |
//        |         |    |
//        |         |    v            
//        |         |                
//        |         |  <----- Get Ptr   
//        |         |    | 
//        |         |    v
//        |         |    
//        |         |    
//         ---------    
//
//         Total Size of Push Buffer
//
//
//  Current Setings:    DmaPushBufTotalSize = 512k
//    
//******************************************************************************

//******************************************************************************
// PADDING is needed because when we wraparound, 
// we sometimes insert 1 JUMP dword at the end (need an extra dword)
// (Specified in DWORDS)
//******************************************************************************


#define NV_DMAPUSH_CHECKFREE(DWORDS_NEEDED)               \
    {\
\
    /***************************************************************************/ \
    /* 2 scenarios:                                                            */ \
    /*      1) DMA Count Ptr is ahead of the Get Ptr.  (DmaCount >= Get Ptr)   */ \
    /*      2) Get Ptr is ahead of the DMA Count Ptr   (DmaCount < Get Ptr)    */ \
    /***************************************************************************/ \
\
    if (ppdev->nvDmaWrapFlag == FALSE)\
        {\
\
        /***********************************************************************/ \
        /* WRAP_FLAG = FALSE                                                   */ \
        /* Check if we need to wraparound.                                     */ \
        /* Convert PushBufTotalSize to DWORDS                                  */ \
        /***********************************************************************/ \
        if ( (nvDmaCount + DWORDS_NEEDED) > (ppdev->DmaPushBufCanUseSize) )       \
            {\
            /*******************************************************************/ \
            /* Make sure to update the PDEV copy of the DmaCount first!!       */ \
            /*******************************************************************/ \
            ppdev->nvDmaCount = nvDmaCount;\
\
            NV_DmaPush_Wrap(ppdev,(ULONG)(DWORDS_NEEDED));\
\
            /*******************************************************************/ \
            /* Make sure to update the LOCAL copy of the DmaCount!!            */ \
            /*******************************************************************/ \
            nvDmaCount=ppdev->nvDmaCount;\
            }\
\
        }\
\
    else\
\
        {\
        /***********************************************************************/ \
        /* Make sure to update the PDEV copy of the DmaCount first!!           */ \
        /***********************************************************************/ \
        ppdev->nvDmaCount = nvDmaCount;\
        /***********************************************************************/ \
        /* WRAP_FLAG = TRUE                                                    */ \
        /* We are currently 'wrapped around' (DMA Count < Get Ptr)             */ \
        /* Make sure DMA Count does NOT go past GET ptr                        */ \
        /***********************************************************************/ \
        NV_DmaPush_CheckWrapped(ppdev,(ULONG)(DWORDS_NEEDED));\
\
        /***********************************************************************/ \
        /* Make sure to update the LOCAL copy of the DmaCount!!                */ \
        /***********************************************************************/ \
        nvDmaCount=ppdev->nvDmaCount;\
        }\
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\drawescape.c ===
//*****************************Module*Header******************************
//
// Module Name: drawescape.c
//
// Supports the API DrvDrawEscape entry
//
// FNicklisch 14.09.00: New: added from ELSA code
//   Added this to implement the roller tool support. I use this entry because 
//   the code and the tool were already available and it was the fastest
//   way to get it running. 
//
// Copyright (c) 1999-2000, ELSA AG, Aachen (Germany)
// Copyright (c) 2000 NVidia Corporation. All Rights Reserved.
//

// import header files
#include "precomp.h"
#include "driver.h"
#include "nv32.h"

#include "dmamacro.h"
#include "nv32.h"
#include "nvsubch.h"

#ifdef IA64
    //
    // Disable the scroll interface for IA64 as we don't have the tool and
    // I don't know how dwParam in the DCICOMMAND is defined
    //
    #undef ROLLER_TOOL_SUPPORT
#else
    #include <Dciddi.h>
#endif


// export header file
#include "drawescape.h"

//*****************************************************************************
// Externs
//*****************************************************************************

extern VOID NV4_DmaPushSend(PDEV *);
extern VOID NV_DmaPush_CheckWrapped(PDEV *, ULONG );
extern VOID NV_DmaPush_Wrap(PDEV *, ULONG );

//
// 
//
static BOOL ulRollerToolEscape(PPDEV ppdev, VOID* pv);


//
// Driver Entry point
//
ULONG APIENTRY DrvDrawEscape (
    SURFOBJ *pso,
    ULONG    iEsc,
    CLIPOBJ *pco,
    RECTL   *prcl,
    ULONG    cjIn,
    PVOID    pvIn)
{
    ULONG ulRet = 0; // unsuported escape
    PPDEV ppdev = (PPDEV)pso->dhpdev;

    prcl = prcl; // unreferenced formal parameter
    pco  = pco;  // unreferenced formal parameter

    switch(iEsc)
    {
        #ifdef ROLLER_TOOL_SUPPORT
        case DCICOMMAND:
        {
            DCICMD *pDciCmd = (DCICMD*)pvIn;

            if (   (cjIn < sizeof(DCICMD)) 
                || (pDciCmd->dwVersion != DCI_VERSION) )
            {
                ulRet = (ULONG)-1; // error
                break;
            }

            switch (pDciCmd->dwCommand)
            {
            case 0xEEEE0000: // EDDESCAPE==ELSA defined service escape
                ulRet = ulRollerToolEscape(ppdev, (PVOID)pDciCmd->dwParam1);
                break;
            }
            break;
        }
        #endif // ROLLER_TOOL_SUPPORT
    }

    return ulRet;
}


#ifdef ROLLER_TOOL_SUPPORT
//
// Downstripped version of the ELSA DrawEscape support function. 
// The remaining code supports the roller tool.
//

//
// ELSA specific command group
//
#define EDDESC_SCROLL               (0xEDD00000 | 0x00000012)

//
// scrolling into offscreen (debug purposes)
//
typedef struct _EDDESC_SCROLL_DATA
{
  DWORD dwSize;             // = sizeof(struct tagSCROLL_DATA)
  DWORD dwCommand;          // = EDDESC_SCROLL
  LONG  cyLines;            // # of lines vertical panning
} EDDESC_SCROLL_DATA;


//
// ulRollerToolEscape was spawned from a more complex
// escape interface, but only the EDDESC_SCROLL is supported
// in the nVidia code.
//
static BOOL ulRollerToolEscape(PPDEV ppdev, VOID* pv)
{
    BOOL                bRet    = FALSE; // unsupported escape==default error exit
    EDDESC_SCROLL_DATA *pScroll = pv;

    if (   (NULL != pScroll)
        && (NULL != ppdev)
        && (EDDESC_SCROLL==pScroll->dwCommand)
        && (pScroll->dwSize == sizeof(EDDESC_SCROLL_DATA)) )
    {
        static LONG ActualLine = 0; // remember this as last address!

        // CSchalle 12/3/98 2:43:28 PM: want to see instance memory, too
        ULONG cbTotalRAM = (ppdev->cbFrameBuf + (4 *1024*1024 - 1)) & ~(4 *1024 *1024 - 1);
        LONG  lLastLine  = cbTotalRAM / ppdev->lDelta;
        ULONG i=0;
        ULONG ulMaxDacs;

        DECLARE_DMA_FIFO;

        INIT_LOCAL_DMA_FIFO;


        ActualLine += pScroll->cyLines;

        // stop scrolling up at top
        if (ActualLine < 0)  
            ActualLine = 0;

        // stop scrolling down at bottom - screem height
        if (ActualLine + ppdev->cyScreen > lLastLine) 
            ActualLine = lLastLine - ppdev->cyScreen;

        if (ppdev->ulDesktopMode & NV_CLONE_DESKTOP)
        {
            // In clone mode only do it for first monitor by now as
            // it seems to be more convenient for debugging

            ulMaxDacs = 1;
        }
        else
        {
            // In a multimon environment scroll all dacs
            ulMaxDacs = ppdev->ulNumberDacsActive;
        }

        //doesn't work for multiple dacs...    for (i = 0; i < ulMaxDacs; i++)
        {
            ULONG ulHead;
            ulHead = ppdev->ulDeviceDisplay[i];

            // ELSA method of setting the display start address 
            // replaced by code taken from OglRestoreDacs.

            NV_DMAPUSH_CHECKFREE( ((ULONG)(10)));
            NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NVFFF_SET_OBJECT(0) ,
                NV_VIDEO_LUT_CURSOR_DAC + ulHead);

            ASSERT(0==i); // notification fails for multiple dacs, don't know why!
            while (((NvNotification *) (&(ppdev->Notifiers->VideoLutCursorDac[NV046_NOTIFIERS_SET_IMAGE(0)* sizeof(NvNotification)])))->status == NV_IN_PROGRESS)
            {
                ;
            }

            ((NvNotification *) (&(ppdev->Notifiers->VideoLutCursorDac[NV046_NOTIFIERS_SET_IMAGE(0)*
                                   sizeof(NvNotification)])))->status = NV_IN_PROGRESS;

            NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_IMAGE_OFFSET(0), 
                ActualLine * ppdev->lDelta);
            NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_IMAGE_FORMAT(0), 
                ppdev->lDelta | NV046_SET_IMAGE_FORMAT_NOTIFY_WRITE_ONLY << 31);
        }
        // Restore to 1st DAC
        NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NVFFF_SET_OBJECT(0), NV_VIDEO_LUT_CURSOR_DAC);

        UPDATE_PDEV_DMA_COUNT;

        //******************************************************************
        // Send data on thru to the DMA push buffer
        //******************************************************************

        NV4_DmaPushSend(ppdev);

        bRet = TRUE;
    }

    return bRet;
}

// End of drawescape.c
#endif //ROLLER_TOOL_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\driver.h ===
// **************************************************************************
//
//       Copyright 1993-2001 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
#include "CompileControl.h"
#if IS_WINNT5
#include <ntddvdeo.h>
#include <dmemmgr.h>
#endif
#include "nvtypes.h"

//***************************************************************************
// Include display driver IOCTL codes (shared by all components)
//***************************************************************************
#include <dspioctl.h>

#include "nvOverlay.h"

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus


#define GDI_CHANNEL_ID 0x00000000 // NOTE: assumes GDI is on channel 0

//***************************************************************************
// Special cased ROPS (In ROP3 single byte format)
//***************************************************************************

#define NV BLACKNESS 0x00
#define NV_DSTINVERT 0x55
#define NV_PATINVERT 0x5A
#define NV_SRCAND    0x88
#define NV_DSTCOPY   0xAA
#define NV_SRCCOPY   0xCC
#define NV_SRCPAINT  0xEE
#define NV_PATCOPY   0xF0
#define NV_WHITENESS 0xFF

// !!! CAUTION CAUTION !!!  See Note!!!
#define DMAPUSH_BUFFER_SIZE 0x200000    // NOTE: If you change these values, then
#define DMAPUSH_PADDING     32          //       change the EQUs in I386/STRUCS.INC
// !!! CAUTION CAUTION !!!              //


// these #defines are used by opengl api stereo 
#define OGL_STEREO_NUMBUFFERS       2
#define OGL_STEREO_BUFFER_LEFT      0
#define OGL_STEREO_BUFFER_RIGHT     1


#define MAX_INDEXED_IMAGE_NOTIFIERS 16       // Must be a power of 2
#define INDEXED_IMAGE_LUT_BUFFER_SIZE (MAX_INDEXED_IMAGE_NOTIFIERS * 256 * 4)
                                             // Allocate LUTs for each indexed image
                                             // object. These are associated so that
                                             // the LUT is not updated causing the
                                             // image to be corrupted
#define MAX_INDEXED_IMAGE_DWORDS 1792

#define MAX_CY_MEMORY_VALUE 0x7fff           // Hardware limitation

#ifndef NVD3D_DX6 // D3D driver conflicts
#define NV_IN_PROGRESS 255
#else
//
// DX6 Only:
// Redefine HAL CALLBACK function structs so they match the "NT" way.
//
//typedef DD_CALLBACKS       DDHAL_CALLBACKS;
typedef DD_SURFACECALLBACKS    DDHAL_SURFACECALLBACKS;
typedef DD_PALETTECALLBACKS    DDHAL_PALETTECALLBACKS;
#endif // #ifdef NVD3D_DX6


//***************************************************************************
// Number of cached cursors
//***************************************************************************

#define NUM_CACHED_CURSORS 4

//////////////////////////////////////////////////////////////////////
// Put all the conditional-compile constants here.  There had better
// not be many!

// Multi-board support can be enabled by setting this to 1:

#define MULTI_BOARDS            0

#if _WIN32_WINNT < 0x0500
//#define NT4_MULTI_DEV
#else
#undef NT4_MULTI_DEV
#endif

// This is the maximum number of boards we'll support in a single
// virtual driver:

#if MULTI_BOARDS
    #define MAX_BOARDS          16
    #define IBOARD(ppdev)       ((ppdev)->iBoard)
#else
    #define MAX_BOARDS          1
    #define IBOARD(ppdev)       0
#endif

//*********************************************************************************
// Number of dacs
// SAME one also define in miniport head file(s).  Search in miniport to match it.
//*********************************************************************************
#define NV_NO_DACS                  2
#define NV_NO_CONNECTORS                  24

// Useful for visualizing the offscreen heap:

#define DEBUG_HEAP              0

// Sorts out memory allocation macros
#ifndef PDEV_PTR
#define PDEV_PTR() ppdev
#endif

//*********************************************************************
// For NT4 for both NV3 and NV4, the display and DX drivers use the
// same version of the mem allocation macros.
//
// For Win2K, the NV4 DX6 driver has its own version of the memory
// allocation macros in D3DINC.H. For NV3, the Win2K DX driver is
// currently the same DX driver used for NT4, so it uses the following
// mem allocation in both the DX and display drivers. This will change
// once NV3 Win2K DX6 support is implemented.
//*********************************************************************

#if (!defined(NVD3D_DX6)) // [ && defined(NV4)) || (defined(NV3) && (defined(DISPDRV) ||  _WIN32_WINNT < 0x0500))


#define HEAP_ALLOC_DEPTH_WIDTH_HEIGHT        1
#define HEAP_ALLOC_SIZE                      2
#define HEAP_FREE                            3
#define HEAP_PURGE                           4
#define HEAP_INFO                            5
#define HEAP_ALLOC_TILED_PITCH_HEIGHT        6
#define HEAP_DESTROY                         7
#define TYPE_IMAGE                           0
#define TYPE_DEPTH                           1
#define TYPE_TEXTURE                         2
#define TYPE_OVERLAY                         3
#define TYPE_FONT                            4
#define TYPE_CURSOR                          5
#define TYPE_DMA                             6
#define TYPE_INSTANCE                        7
#define MEM_TYPE_PRIMARY                     8
#define MEM_TYPE_IMAGE_TILED                 9
#define TYPE_DEPTH_COMPR16                   10
#define TYPE_DEPTH_COMPR32                   11

#define NVHEAP_INFO()                           \
{                                               \
    NVOS11_PARAMETERS   HeapParams;             \
    PVOID pParms = (PVOID) &HeapParams;         \
    DWORD cbReturned;                           \
    HeapParams.hRoot = ppdev->hClient;          \
    HeapParams.hObjectParent = ppdev->hDevice;  \
    HeapParams.function = HEAP_INFO;            \
    HeapParams.owner    = 'NVDD';               \
    EngDeviceIoControl(                         \
        ppdev->hDriver,                         \
        (DWORD)IOCTL_NV01_ARCH_HEAP,            \
        (&pParms),                              \
        sizeof(PVOID),                          \
        pParms,                                 \
        sizeof(NVOS11_PARAMETERS),              \
        &cbReturned                             \
    );                                          \
    ppdev->VideoHeapTotal = HeapParams.total;   \
    ppdev->VideoHeapFree = HeapParams.free;     \
}

#define NVHEAP_PURGE()                          \
{                                               \
    NVOS11_PARAMETERS HeapParams;               \
    PVOID pParms = (PVOID) &HeapParams;         \
    DWORD cbReturned;                           \
    HeapParams.hRoot = ppdev->hClient;          \
    HeapParams.hObjectParent = ppdev->hDevice;  \
    HeapParams.function = HEAP_PURGE;           \
    HeapParams.owner    = 'NVDD';               \
    EngDeviceIoControl(                         \
        ppdev->hDriver,                         \
        (DWORD)IOCTL_NV01_ARCH_HEAP,            \
        (&pParms),                              \
        sizeof(PVOID),                          \
        pParms,                                 \
        sizeof(NVOS11_PARAMETERS),              \
        &cbReturned                             \
    );                                          \
}

#define NVHEAP_DESTROY()                        \
{                                               \
    NVOS11_PARAMETERS HeapParams;               \
    PVOID pParms = (PVOID) &HeapParams;         \
    DWORD cbReturned;                           \
    HeapParams.hRoot = ppdev->hClient;          \
    HeapParams.hObjectParent = ppdev->hDevice;  \
    HeapParams.function = HEAP_DESTROY;         \
    HeapParams.owner    = 'NVDD';               \
    EngDeviceIoControl(                         \
        ppdev->hDriver,                         \
        (DWORD)IOCTL_NV01_ARCH_HEAP,            \
        (&pParms),                              \
        sizeof(PVOID),                          \
        pParms,                                 \
        sizeof(NVOS11_PARAMETERS),              \
        &cbReturned                             \
    );                                          \
}

#define NVHEAP_INIT(strt, end, heap) \
{                                    \
    PDEV_PTR()->cbGdiHeap = 0;          \
}

#define NVHEAP_CLEAR(heap)  \
{                           \
    PDEV_PTR()->cbGdiHeap = 0; \
}

#define NVHEAP_ALLOC(sts,pvm,sz,tp)                     \
{                                                       \
    NVOS11_PARAMETERS   HeapParams;                     \
    PVOID pParms = (PVOID) &HeapParams;                 \
    DWORD cbReturned;                                   \
                                                        \
    HeapParams.hRoot = PDEV_PTR()->hClient;                \
    HeapParams.hObjectParent = PDEV_PTR()->hDevice;        \
    HeapParams.function = HEAP_ALLOC_SIZE;              \
    HeapParams.owner    = 'NVDD';                       \
    HeapParams.type     = (tp);                         \
    HeapParams.size     = (sz);                         \
    EngDeviceIoControl(                                 \
        PDEV_PTR()->hDriver,                               \
        (DWORD)IOCTL_NV01_ARCH_HEAP,                    \
        (&pParms),                                      \
        sizeof(PVOID),                                  \
        pParms,                                         \
        sizeof(NVOS11_PARAMETERS),                      \
        &cbReturned                                     \
    );                                                  \
    (sts) = HeapParams.status;                          \
    (pvm) = (HeapParams.status ? 0 : HeapParams.offset);\
    if (pvm)                                            \
        {                                               \
        PDEV_PTR()->cbGdiHeap += PDEV_PTR()->VideoHeapFree -  \
            HeapParams.free;                            \
        PDEV_PTR()->VideoHeapFree = HeapParams.free;       \
        }                                               \
}

#define NVHEAP_ALLOC_TILED(sts,pvm,pch,ht,tp)           \
{                                                       \
    NVOS11_PARAMETERS HeapParams;                       \
    PVOID pParms = (PVOID) &HeapParams;                 \
    DWORD cbReturned;                                   \
    HeapParams.hRoot = PDEV_PTR()->hClient;                \
    HeapParams.hObjectParent = PDEV_PTR()->hDevice;        \
    HeapParams.function = HEAP_ALLOC_TILED_PITCH_HEIGHT;\
    HeapParams.owner    = 'NVDD';                       \
    HeapParams.type     = (tp);                         \
    HeapParams.pitch    = (pch);                        \
    HeapParams.height   = (ht);                         \
    EngDeviceIoControl(                                 \
        PDEV_PTR()->hDriver,                               \
        (DWORD)IOCTL_NV01_ARCH_HEAP,                    \
        (&pParms),                                      \
        sizeof(PVOID),                                  \
        pParms,                                         \
        sizeof(NVOS11_PARAMETERS),                      \
        &cbReturned                                     \
    );                                                  \
    (sts) = HeapParams.status;                          \
    (pvm) = HeapParams.status ? 0 : HeapParams.offset;  \
    (pch) = HeapParams.pitch;                           \
    if (pvm)                                            \
        {                                               \
        PDEV_PTR()->cbGdiHeap += PDEV_PTR()->VideoHeapFree -  \
            HeapParams.free;                            \
        PDEV_PTR()->VideoHeapFree = HeapParams.free;       \
        }                                               \
}

#define NVHEAP_FREE(pvm)                        \
{                                               \
    NVOS11_PARAMETERS HeapParams;               \
    PVOID pParms = (PVOID) &HeapParams;         \
    DWORD cbReturned;                           \
    HeapParams.hRoot = PDEV_PTR()->hClient;        \
    HeapParams.hObjectParent = PDEV_PTR()->hDevice;\
    HeapParams.function = HEAP_FREE;            \
    HeapParams.owner    = 'NVDD';               \
    HeapParams.offset   = (U032)(pvm);          \
    EngDeviceIoControl(                         \
        PDEV_PTR()->hDriver,                       \
        (DWORD)IOCTL_NV01_ARCH_HEAP,            \
        (&pParms),                              \
        sizeof(PVOID),                          \
        pParms,                                 \
        sizeof(NVOS11_PARAMETERS),              \
        &cbReturned                             \
    );                                          \
    PDEV_PTR()->cbGdiHeap -= (HeapParams.free -    \
        PDEV_PTR()->VideoHeapFree);                \
    PDEV_PTR()->VideoHeapFree = HeapParams.free;   \
}

#endif // (!defined(NVD3D_DX6)) ]

//////////////////////////////////////////////////////////////////////
// Miscellaneous shared stuff

#define DLL_NAME                L"NV_DISP"  // Name of the DLL in UNICODE
#define STANDARD_DEBUG_PREFIX   "NV: "      // All debug output is prefixed
                                            //   by this string
#define ALLOC_TAG               '  VN'      // Four byte tag used for tracking
                                            //   memory allocations (characters
                                            //   are in reverse order)

#define CLIP_LIMIT          50  // We'll be taking 800 bytes of stack space

#define DRIVER_EXTRA_SIZE   0   // Size of the DriverExtra information in the
                                //   DEVMODE structure

#define MEM_TO_MEM_BUFFER_SIZE    (0x80000)  // 512kb
 
                                  // Size in bytes of 'MEM_TO_MEM_Buffer'.  Has to
                                  //   be at least enough to store an entire
                                  //   scan line (i.e., 6400 for 1600x1200x32).

#if defined(_ALPHA_)
    #define XFER_BUFFERS    16  // Defines the maximum number of write buffers
                                //   possible on any Alpha.  Must be a power
#else                           //   of two.
    #define XFER_BUFFERS    1   // On non-alpha systems, we don't have to
                                //   worry about the chip caching our bus
#endif                          //   writes.

#define XFER_MASK           (XFER_BUFFERS - 1)

typedef struct _CLIPENUM {
    LONG    c;
    RECTL   arcl[CLIP_LIMIT];   // Space for enumerating complex clipping

} CLIPENUM;                         /* ce, pce */


// structure to handle FC_RECT4 but doesn't use so much stack space as CLIPENUM
typedef struct _ENUMRECT4 {
    LONG    c;
    RECTL   arcl[4];   // Space for enumerating FC_RECT4 clipping
} ENUMRECT4;


typedef struct _NV_VIDEO_CLUTDATA {
    UCHAR Blue;
    UCHAR Green;
    UCHAR Red;
    UCHAR Unused;
} NV_VIDEO_CLUTDATA, *PNV_VIDEO_CLUTDATA;

// BUGBUG - Hack 'o rama, these should be NvNotification structs!
typedef struct _NV_NOTIFIERS
{
    BYTE   VideoLutCursorDac[16*9];
    BYTE   Sync[16*5];
    BYTE   FlipPrimary[16*9];
    BYTE   FlipOverlay[16*5];
    BYTE   FlipVport[16*5];
    BYTE   DmaFromMem[16*5];
    BYTE   DmaToMem[16*5];
    BYTE   DmaToMemIndexedImage[16*MAX_INDEXED_IMAGE_NOTIFIERS];
    BYTE   MemToMem[16*2];
    BYTE   ScaledImage[16*5];
    BYTE   Primary2d[16*5];
    BYTE   DmaPushBufErr[16];
} NV_NOTIFIERS, *PNV_NOTIFIERS;

typedef struct _PDEV PDEV;      // Handy forward declaration

typedef struct _GLOBALDATA GLOBALDATA; // Defined in DD driver's DDMINI.H (NT5)
                                       // or Display Driver's DDMININT.H (NT4)


VOID vSetClipping(PDEV*, RECTL*);
VOID vResetClipping(PDEV*);

//////////////////////////////////////////////////////////////////////
// Text stuff

#define GLYPH_CACHE_HEIGHT  48  // Number of scans to allocate for glyph cache,
                                //   divided by pel size

#define GLYPH_CACHE_CX      64  // Maximal width of glyphs that we'll consider
                                //   caching

#define GLYPH_CACHE_CY      64  // Maximum height of glyphs that we'll consider
                                //   caching

#define MAX_GLYPH_SIZE      ((GLYPH_CACHE_CX * GLYPH_CACHE_CY + 31) / 8)
                                // Maximum amount of off-screen memory required
                                //   to cache a glyph, in bytes

#define GLYPH_ALLOC_SIZE    8100
                                // Do all cached glyph memory allocations
                                //   in 8k chunks

#define HGLYPH_SENTINEL     ((ULONG) -1)
                                // GDI will never give us a glyph with a
                                //   handle value of 0xffffffff, so we can
                                //   use this as a sentinel for the end of
                                //   our linked lists

#define GLYPH_HASH_SIZE     256

#define GLYPH_HASH_FUNC(x)  ((x) & (GLYPH_HASH_SIZE - 1))

typedef struct _CACHEDGLYPH CACHEDGLYPH;
typedef struct _CACHEDGLYPH
{
    CACHEDGLYPH*    pcgNext;    // Points to next glyph that was assigned
                                //   to the same hash table bucket
    HGLYPH          hg;         // Handles in the bucket-list are kept in
                                //   increasing order
    POINTL          ptlOrigin;  // Origin of glyph bits

    // Device specific fields below here:

    LONG            cxLessOne;  // Glyph width less one
    LONG            cyLessOne;  // Glyph height less one
    LONG            cxcyLessOne;// Packed width and height, less one
    LONG            cw;         // Number of words to be transferred
    LONG            cd;         // Number of dwords to be transferred
    ULONG           ad[1];      // Start of glyph bits
} CACHEDGLYPH;  /* cg, pcg */

typedef struct _GLYPHALLOC GLYPHALLOC;
typedef struct _GLYPHALLOC
{
    GLYPHALLOC*     pgaNext;    // Points to next glyph structure that
                                //   was allocated for this font
    CACHEDGLYPH     acg[1];     // This array is a bit misleading, because
                                //   the CACHEDGLYPH structures are actually
                                //   variable sized
} GLYPHAALLOC;  /* ga, pga */

typedef struct _CACHEDFONT CACHEDFONT;
typedef struct _CACHEDFONT
{
    CACHEDFONT*     pcfNext;    // Points to next entry in CACHEDFONT list
    CACHEDFONT*     pcfPrev;    // Points to previous entry in CACHEDFONT list
    GLYPHALLOC*     pgaChain;   // Points to start of allocated memory list
    CACHEDGLYPH*    pcgNew;     // Points to where in the current glyph
                                //   allocation structure a new glyph should
                                //   be placed
    LONG            cjAlloc;    // Bytes remaining in current glyph allocation
                                //   structure
    CACHEDGLYPH     cgSentinel; // Sentinel entry of the end of our bucket
                                //   lists, with a handle of HGLYPH_SENTINEL
    CACHEDGLYPH*    apcg[GLYPH_HASH_SIZE];
                                // Hash table for glyphs

} CACHEDFONT;   /* cf, pcf */

typedef struct _XLATECOLORS {       // Specifies foreground and background
ULONG   iBackColor;                 //   colours for faking a 1bpp XLATEOBJ
ULONG   iForeColor;
} XLATECOLORS;                          /* xlc, pxlc */


//********************************************************************
// This cursor structure MUST also match the one defined in nv.h
// (in the miniport directory)
//********************************************************************

typedef struct _TV_CURSOR_ADJUST_INFO
    {
    ULONG   MonitorType;
    ULONG   Underscan_x;
    ULONG   Underscan_y;
    ULONG   Scale_x;
    ULONG   Scale_y;
    ULONG   FilterEnable;
    ULONG   TVCursorMin;
    ULONG   TVCursorMax;
    } TV_CURSOR_ADJUST_INFO;


BOOL bEnableText(PDEV*);
VOID vDisableText(PDEV*);
VOID vAssertModeText(PDEV*, BOOL);

VOID vFastText(GLYPHPOS*, ULONG, BYTE*, ULONG, ULONG, RECTL*, RECTL*,
               FLONG, RECTL*, RECTL*);
VOID vClearMemDword(ULONG*, ULONG);

//////////////////////////////////////////////////////////////////////
// Dither stuff

// Describes a single colour tetrahedron vertex for dithering:

typedef struct _VERTEX_DATA {
    ULONG ulCount;              // Number of pixels in this vertex
    ULONG ulVertex;             // Vertex number
} VERTEX_DATA;                      /* vd, pv */

VERTEX_DATA*    vComputeSubspaces(ULONG, VERTEX_DATA*);
VOID            vDitherColor(ULONG*, VERTEX_DATA*, VERTEX_DATA*, ULONG);

//////////////////////////////////////////////////////////////////////
// Brush stuff

// 'Slow' brushes are used when we don't have hardware pattern capability,
// and we have to handle patterns using screen-to-screen blts:

#define SLOW_BRUSH_CACHE_DIM    3   // Controls the number of brushes cached
                                    //   in off-screen memory, when we don't
                                    //   have the S3 hardware pattern support.
                                    //   We allocate 3 x 3 brushes, so we can
                                    //   cache a total of 9 brushes:
#define SLOW_BRUSH_COUNT        (SLOW_BRUSH_CACHE_DIM * SLOW_BRUSH_CACHE_DIM)
#define SLOW_BRUSH_DIMENSION    64  // After alignment is taken care of,
                                    //   every off-screen brush cache entry
                                    //   will be 64 pels in both dimensions
#define SLOW_BRUSH_ALLOCATION   (SLOW_BRUSH_DIMENSION + 8)
                                    // Actually allocate 72x72 pels for each
                                    //   pattern, using the 8 extra for brush
                                    //   alignment

// 'Fast' brushes are used when we have hardware pattern capability:

#define FAST_BRUSH_COUNT        16  // Total number of non-hardware brushes
                                    //   cached off-screen
#define FAST_BRUSH_DIMENSION    8   // Every off-screen brush cache entry
                                    //   is 8 pels in both dimensions
#define FAST_BRUSH_ALLOCATION   8   // We have to align ourselves, so this is
                                    //   the dimension of each brush allocation

// Common to both implementations:

#define RBRUSH_2COLOR           1   // For RBRUSH flags

#define TOTAL_BRUSH_COUNT       max(FAST_BRUSH_COUNT, SLOW_BRUSH_COUNT)
                                    // This is the maximum number of brushes
                                    //   we can possibly have cached off-screen
#define TOTAL_BRUSH_SIZE        64  // We'll only ever handle 8x8 patterns,
                                    //   and this is the number of pels

typedef struct _BRUSHENTRY BRUSHENTRY;

// NOTE: Changes to the RBRUSH or BRUSHENTRY structures must be reflected
//       in strucs.inc!

typedef struct _RBRUSH {
    FLONG       fl;             // Type flags
    BOOL        bTransparent;   // TRUE if brush was realized for a transparent
                                //   blt (meaning colours are white and black),
                                //   FALSE if not (meaning it's already been
                                //   colour-expanded to the correct colours).
                                //   Value is undefined if the brush isn't
                                //   2 colour.
    ULONG       ulForeColor;    // Foreground colour if 1bpp
    ULONG       ulBackColor;    // Background colour if 1bpp
    POINTL      ptlBrushOrg;    // Brush origin of cached pattern.  Initial
                                //   value should be -1
    BRUSHENTRY* apbe[MAX_BOARDS];// Points to brush-entry that keeps track
                                //   of the cached off-screen brush bits
    ULONG       aulPattern[1];  // Open-ended array for keeping copy of the
      // Don't put anything     //   actual pattern bits in case the brush
      //   after here, or       //   origin changes, or someone else steals
      //   you'll be sorry!     //   our brush entry (declared as a ULONG
                                //   for proper dword alignment)

} RBRUSH;                           /* rb, prb */

typedef struct _BRUSHENTRY {
    RBRUSH*     prbVerify;      // We never dereference this pointer to
                                //   find a brush realization; it is only
                                //   ever used in a compare to verify
                                //   that for a given realized brush, our
                                //   off-screen brush entry is still valid.
    LONG        x;              // x-position of cached pattern
    LONG        y;              // y-position of cached pattern

} BRUSHENTRY;                       /* be, pbe */

typedef union _RBRUSH_COLOR {
    RBRUSH*     prb;
    ULONG       iSolidColor;
} RBRUSH_COLOR;                     /* rbc, prbc */


//////////////////////////////////////////////////////////////////////
// Stretch stuff

typedef struct _STR_BLT {
    PDEV*   ppdev;
    PBYTE   pjSrcScan;
    LONG    lDeltaSrc;
    LONG    XSrcStart;
    PBYTE   pjDstScan;
    LONG    lDeltaDst;
    LONG    XDstStart;
    LONG    XDstEnd;
    LONG    YDstStart;
    LONG    YDstCount;
    ULONG   ulXDstToSrcIntCeil;
    ULONG   ulXDstToSrcFracCeil;
    ULONG   ulYDstToSrcIntCeil;
    ULONG   ulYDstToSrcFracCeil;
    ULONG   ulXFracAccumulator;
    ULONG   ulYFracAccumulator;
} STR_BLT;

typedef VOID (*PFN_DIRSTRETCH)(STR_BLT*);

VOID vDirectStretch8Narrow(STR_BLT*);
VOID vDirectStretch8(STR_BLT*);
VOID vDirectStretch16(STR_BLT*);
VOID vDirectStretch32(STR_BLT*);

/////////////////////////////////////////////////////////////////////////
// Heap stuff

typedef struct _DSURF DSURF;
typedef struct _HEAP HEAP;
typedef struct _OH OH;

typedef struct _OH
{
    DSURF*  pdsurf;         // corresponding DSURF structure
    OH*     next;           // for 2-link list
    OH*     prev;           // for 2-link list
    OH*     nextEmpty;      // for 1-link list of empty fragments
    HEAP*   pHeap;          // pointer to heap containing this fragment
                            // not used if using RM_MMGR exclusively

    ULONG   ulSizeInBytes;  // size in bytes of fragment
    ULONG   ulOffset;       // FB offset to allocation
    ULONG   ulLinearStride; // stride in bytes (that was used to enforce alignment restrictions)
#ifdef _WIN64
    ULONG   pad;            // keep struct 64bit aligned for IA64 builds
#endif
}
OH;

typedef struct _HEAP
{
    OH      oh;             // Contains base OH struct for entire heap.

    HEAP*   pNextHeap;
    HEAP*   pPrevHeap;

    ULONG   ulSizeInBytes;  // size in bytes of this heap
    ULONG   ulOffset;       // physical offset to base of heap
}
HEAP;

typedef enum {
    DT_SCREEN,              // Surface is kept in screen memory
    DT_DIB                  // Surface is kept as a DIB
} DSURFTYPE;                    /* dt, pdt */

typedef struct _DSURF
{
    DSURFTYPE dt;           // DSURF status (whether off-screen or in a DIB)
    ULONG     pad;          // keep pointers below 64bit aligned for IA64

    SIZEL     sizl;         // Size of the original bitmap (could be smaller
                            //   than poh->sizl)
    PDEV*     ppdev;        // Need this for deleting the bitmap
    union {
        OH*         poh;    // If DT_SCREEN, points to off-screen heap node
        SURFOBJ*    pso;    // If DT_DIB, points to locked GDI surface
    };

    DSURF*    next;         // for 2-link list of DSURFs
    DSURF*    prev;         // for 2-link list of DSURFs

    // The following are used for DT_DIB only...

    ULONG     cBlt;         // Counts down the number of blts necessary at
                            //   the current uniqueness before we'll consider
                            //   putting the DIB back into off-screen memory
    ULONG     iUniq;        // Tells us whether there have been any heap
                            //   'free's since the last time we looked at
                            //   this DIB

    /* the following information is from OH structure */
    VOID*    LinearPtr;
    ULONG    LinearStride;

} DSURF;                          /* dsurf, pdsurf */

// GDI expects dword alignment for any bitmaps on which it is expected
// to draw.  Since we occasionally ask GDI to draw directly on our off-
// screen bitmaps, this means that any off-screen bitmaps must be dword
// aligned in the frame buffer.  We enforce this merely by ensuring that
// all off-screen bitmaps are four-pel aligned (we may waste a couple of
// pixels at the higher colour depths):

#define HEAP_X_ALIGNMENT    4

// Number of blts necessary before we'll consider putting a DIB DFB back
// into off-screen memory:

#define HEAP_COUNT_DOWN     6

// Flags for 'pohAllocate':

typedef enum {
    FLOH_ONLY_IF_ROOM       = 0x0001,   // Don't kick stuff out of off-
                                        //   screen memory to make room
    FLOH_MAKE_PERMANENT     = 0x0002,   // Allocate a permanent entry
    FLOH_RESERVE            = 0x0004,   // Allocate an off-screen entry,
                                        //   but let it be used by discardable
                                        //   bitmaps until it's needed
} FLOH;

// Publicly callable heap APIs:

OH*  pohAllocate(PDEV*, LONG, LONG);
void pohFree(PDEV*, OH*);

BOOL pohMoveOffscreenDfbToDib(PDEV*, OH*);
BOOL bMoveDibToOffscreenDfbIfRoom(PDEV*, DSURF*);
BOOL __fastcall bMoveAllDfbsFromOffscreenToDibs(PDEV* ppdev);

BOOL bEnableOffscreenHeap(PDEV*);
VOID vDisableOffscreenHeap(PDEV*);
BOOL bAssertModeOffscreenHeap(PDEV*, BOOL);


/////////////////////////////////////////////////////////////////////////
// Pointer stuff

#define POINTER_DATA_SIZE       40      // Number of bytes to allocate for the
                                        //   miniport down-loaded pointer code
                                        //   working space
#define HW_INVISIBLE_OFFSET     2       // Offset from 'ppdev->yPointerBuffer'
                                        //   to the invisible pointer
//#define HW_POINTER_DIMENSION    64      // Maximum dimension of default
//                                        //   (built-in) hardware pointer
#define HW_POINTER_DIMENSION    32      // Maximum dimension of default
                                        //   (built-in) hardware pointer


#define HW_POINTER_HIDE         63      // Hardware pointer start pixel
                                        //   position used to hide the pointer
//#define HW_POINTER_TOTAL_SIZE   1024    // Total size in bytes required
//                                        //   to define the hardware pointer
//                                        //   (must be a power of 2 for
//                                        //   allocating space for the shape)
#define NV1_POINTER_TOTAL_SIZE   256    // Total size in bytes required



typedef VOID (FNSHOWPOINTER)(PDEV*, BOOL);
typedef VOID (FNMOVEPOINTER)(PDEV*, LONG, LONG);
typedef ULONG (FNSETPOINTERSHAPE)(SURFOBJ *,SURFOBJ*,SURFOBJ*,XLATEOBJ*,LONG,LONG,LONG,LONG,LONG,LONG,BOOL);
typedef VOID (FNENABLEPOINTER)(PDEV*, BOOL);

BOOL bEnablePointer(PDEV*);
VOID vDisablePointer(PDEV*);
VOID vAssertModePointer(PDEV*, BOOL);

/////////////////////////////////////////////////////////////////////////
// Palette stuff

BOOL bEnablePalette(PDEV*);
VOID vDisablePalette(PDEV*);
VOID vAssertModePalette(PDEV*, BOOL);

BOOL bInitializePalette(PDEV*, DEVINFO*);
VOID vUninitializePalette(PDEV*);
ULONG nvSetGammaRamp(PDEV *ppdev, PUSHORT fpRampVals);
ULONG nvGetGammaRamp(PDEV *ppdev, PUSHORT fpRampVals);
BOOL nvSetHeadGammaRamp(PDEV *ppdev, ULONG ulHead, PUSHORT fpRampVals);
BOOL nvGetHeadGammaRamp(PDEV *ppdev, ULONG ulHead, PUSHORT fpRampVals);

#if 0 // _WIN32_WINNT >= 0x0500
BOOL    DrvIcmSetDeviceGammaRamp(DHPDEV, ULONG, LPVOID);
HBITMAP DrvDeriveSurface(DD_DIRECTDRAW_GLOBAL *, DD_SURFACE_LOCAL *);
#endif

#define MAX_CLUT_SIZE (sizeof(VIDEO_CLUT) + (sizeof(ULONG) * 256))
#define ROUND_UP_TO_64K(x)  (((ULONG)(x) + 0x10000 - 1) & ~(0x10000 - 1))

#ifndef NVD3D
/////////////////////////////////////////////////////////////////////////
// DirectDraw stuff

// There's a 64K granularity that applies to the mapping of the frame
// buffer into the application's address space:
#endif // #ifndef NVD3D

BOOL bEnableDirectDraw(PDEV*);
VOID vDisableDirectDraw(PDEV*);
BOOL bAssertModeDirectDraw(PDEV*, BOOL);

#ifdef VPE_NT
DWORD   VPE_DriverInit(PDEV*);
#endif

//////////////////////////////////////////////////////////////////////
// Low-level blt function prototypes

#if (_WIN32_WINNT < 0x0500)
#define BLENDOBJ   VOID
#endif


typedef VOID (FNSETDESTBASE)(PDEV*, ULONG, LONG);
typedef VOID (FNSETSOURCEBASE)(PDEV*, ULONG, LONG);

typedef VOID (FNFILL)(PDEV*, LONG, RECTL*, ULONG, RBRUSH_COLOR, POINTL*);
typedef VOID (FNMEMTOSCRN)(PDEV*, SURFOBJ*, POINTL*, RECTL *);
typedef BOOL (FNSCRNTO1BPPMEM)(PDEV*, LONG, RECTL *, SURFOBJ*, SURFOBJ*, POINTL*, RECTL *, XLATEOBJ *);

typedef BOOL (FNSCRNTOMEM)(PDEV*, LONG, RECTL *, SURFOBJ*, SURFOBJ*, POINTL*, RECTL *, XLATEOBJ *);
typedef VOID (FNSCRNTOSCRNPAT)(PDEV*, LONG, RECTL*, POINTL*, RECTL*, BRUSHOBJ*, POINTL*, ROP4);

typedef VOID (FNGETSCRNBITS)(PDEV* ,DSURF* ,SURFOBJ* ,RECTL* ,POINTL* );

typedef VOID (FNMEMTOSCRNPATTERN)(PDEV*, SURFOBJ*, POINTL*, RECTL *,ULONG ,RBRUSH_COLOR * , RECTL*);
typedef VOID (FNXFER)(PDEV*, LONG, RECTL*, ULONG, SURFOBJ*, POINTL*,
                      RECTL*, XLATEOBJ*,ULONG,BLENDOBJ*);
typedef VOID (FNCOPY)(PDEV*, LONG, RECTL*, ULONG, POINTL*, RECTL*, BLENDOBJ*);
typedef VOID (FNCOLORKEYBLT)(PDEV*, LONG, RECTL*, POINTL*, RECTL*, ULONG);
typedef VOID (FNFASTPATREALIZE)(PDEV*, RBRUSH*, POINTL*, BOOL);
typedef VOID (FNIMAGETRANSFER)(PDEV*, BYTE*, LONG, LONG, LONG, ULONG);
typedef BOOL (FNTEXTOUT)(SURFOBJ*, STROBJ*, FONTOBJ*, CLIPOBJ*, RECTL*,
                         BRUSHOBJ*, BRUSHOBJ*);
typedef VOID (FNLINETOTRIVIAL)(PDEV*, LONG, LONG, LONG, LONG, ULONG, MIX);
typedef VOID (FNLINETOCLIPPED)(PDEV*, LONG, LONG, LONG, LONG, ULONG, MIX, RECTL*);
typedef VOID (FNSETPALETTE)(PDEV*, ULONG, ULONG);

typedef VOID (FNWAITENGINEBUSY)(PDEV*);
typedef VOID (FNWAITCHANNELSWITCH)(PDEV*);
typedef ULONG (FNDMAPUSHGO)(PDEV*, ULONG, ULONG, ULONG, ULONG, ULONG, ULONG, ULONG);
typedef BOOL (FNSTROKEPATH)(SURFOBJ *,PATHOBJ *,CLIPOBJ *,XFORMOBJ*,BRUSHOBJ *,POINTL *,LINEATTRS *, MIX);
typedef BOOL (FNLINETO)(SURFOBJ *,CLIPOBJ *,BRUSHOBJ *,LONG,LONG,LONG,LONG,RECTL *,MIX);
typedef BOOL (FNSTRETCHCOPY)(PDEV*, ULONG, int, RECTL*, RECTL*, int, RECTL*);

typedef VOID (FastXFER)(PDEV*, RECTL*, SURFOBJ*, POINTL*, XLATEOBJ*);

typedef VOID (FNACQUIREOGLMUTEX)(PDEV*);
typedef VOID (FNRELEASEOGLMUTEX)(PDEV*);

//******************************************************************************
// NV1 Function declarations
//******************************************************************************


FNWAITENGINEBUSY    NV1_WaitWhileGraphicsEngineBusy;
FNSTROKEPATH        NV1StrokePath;
FNLINETO            NV1LineTo;

//******************************************************************************
// NV3 Function declarations
// (These functions support 16bpp in 555 format)
//******************************************************************************

FNSETDESTBASE       NV3_SetDestBase;
FNSETSOURCEBASE     NV3_SetSourceBase;
FNFILL              NV3FillPatFast;
FNFILL              NV3FillSolid;
FNMEMTOSCRN         NV3MemToScreenBlt;
FNMEMTOSCRNPATTERN  NV3MemToScreenWithPatternBlt;
FNXFER              NV3Xfer1bpp;
FNXFER              NV3Xfer4bpp;
FNXFER              NV3XferNative;
FNCOPY              NV3CopyBlt;
FNTEXTOUT           NV3TextOut;
FNSETPALETTE        NV3SetPalette;

FNWAITENGINEBUSY    NV3_WaitWhileGraphicsEngineBusy;
FNWAITCHANNELSWITCH NV3_WaitForChannelSwitch;
FNDMAPUSHGO         NV3_DmaPushGo;

FNACQUIREOGLMUTEX   NV3_AcquireOglMutex;
FNRELEASEOGLMUTEX   NV3_ReleaseOglMutex;

FNSCRNTO1BPPMEM     NV4ScreenTo1bppMemBlt;

FNSCRNTOMEM         NV4ScreenToMemBlt;
FNSCRNTOMEM         NV4ScreenToMem16to4bppBlt;
FNSCRNTOMEM         NV4ScreenToMem32to4bppBlt;
FNSCRNTOMEM         NV4ScreenToMem16to8bppBlt;
FNSCRNTOMEM         NV4ScreenToMem32to8bppBlt;
FNSCRNTOSCRNPAT     NV4ScreenToScreenWithPatBlt;

FNWAITENGINEBUSY    NV4_WaitWhileGraphicsEngineBusy;
FNWAITCHANNELSWITCH NV4_WaitForChannelSwitch;

FNACQUIREOGLMUTEX   NV4_AcquireOglMutex;
FNRELEASEOGLMUTEX   NV4_ReleaseOglMutex;
VOID NV4_EnableDither(PDEV*  ppdev, BOOLEAN DitherFlag);

//******************************************************************************
// NV4 DMA Pusher Function declarations
// (These functions support 16bpp in 565 format)
//******************************************************************************

FNSETDESTBASE       NV4_DmaPushSetDestBase;
FNSETSOURCEBASE     NV4_DmaPushSetSourceBase;
FNFILL              NV4DmaPushFillPatFast;
FNFILL              NV4DmaPushFillSolid;
FNMEMTOSCRN         NV4DmaPushMemToScreenBlt;
FNMEMTOSCRNPATTERN  NV4DmaPushMemToScreenWithPatternBlt;
FNXFER              NV4DmaPushXfer1bpp;
FNXFER              NV4DmaPushXfer4bpp;
FNXFER              NV4DmaPushXferNative;
FNCOPY              NV4DmaPushCopyBlt;
FNCOLORKEYBLT       NV4DmaPushColorKeyBlt;
FNTEXTOUT           NV4DmaPushTextOut;
FNSETPALETTE        NV4DmaPushSetPalette;

FNXFER              NV4DmaPushXfer4to16bpp;
FNXFER              NV4DmaPushXfer8to16bpp;
FNXFER              NV4DmaPushXfer4to32bpp;
FNXFER              NV4DmaPushXfer8to32bpp;
FNXFER              NV4DmaPushIndexedImage;

FastXFER            NV4DmaPushFastXfer8to32;
FastXFER            NV4DmaPushFastXfer8to16;

FNGETSCRNBITS       NV4DmaPushDMAGetScreenBits;

FNWAITENGINEBUSY    NV4_DmaPushWaitWhileGraphicsEngineBusy;
FNWAITCHANNELSWITCH NV4_DmaPushWaitForChannelSwitch;
FNSTROKEPATH        NV4DmaPushStrokePath;
FNLINETO            NV4DmaPushLineTo;
FNSTRETCHCOPY       NV4DmaPushStretchCopy;

//******************************************************************************
// NV10 DMA Pusher Function declarations
// (These functions support 16bpp in 565 format)
//******************************************************************************

FNXFER              NV4DmaPushIndexedImage;     // this function call NV10DmaPush, but include
                                                // a bugfix for bug #20000720-213841
FNXFER              NV10DmaPushIndexedImage;
FNSETDESTBASE       NV10_DmaPushSetDestBase;
FNSETSOURCEBASE     NV10_DmaPushSetSourceBase;


FNFASTPATREALIZE    vMmFastPatRealize;
FNIMAGETRANSFER     vMmImageTransferMm16;
FNIMAGETRANSFER     vMmImageTransferMm32;
FNLINETOTRIVIAL     vMmLineToTrivial;
FNLINETOCLIPPED     vMmLineToClipped;


//////////////////////////////////////////////////////////////////////
// Function pointer for Direct Draw
//////////////////////////////////////////////////////////////////////

typedef ULONG (FNGRAPHICSENGINEBUSY)(PDEV*);
typedef VOID (FNFLIPBUFFER)(PDEV*,ULONG);
typedef ULONG (FNVBLANKISACTIVE)(PDEV*);
typedef VOID (FNWAITWHILEVBLANKACTIVE)(PDEV*);
typedef VOID (FNWAITWHILEDISPLAYACTIVE)(PDEV*);
typedef ULONG (FNGETSCANLINE)(PDEV*);
typedef VOID (FNDDENABLE)(PDEV*);
typedef DWORD (FNDDUPDATEFLIPSTATUS)(PDEV*, DWORD);

typedef ULONG (FNFIFOISBUSY)(PDEV *);

FNGRAPHICSENGINEBUSY    NV3_GraphicsEngineBusy;
FNGRAPHICSENGINEBUSY    NV4_GraphicsEngineBusy;
FNFLIPBUFFER            NV3_FlipBuffer;
FNVBLANKISACTIVE        NV3_VBlankIsActive;
FNVBLANKISACTIVE        NV4_VBlankIsActive;
FNWAITWHILEVBLANKACTIVE NV3_WaitWhileVBlankActive;
FNWAITWHILEVBLANKACTIVE NV4_WaitWhileVBlankActive;
FNWAITWHILEDISPLAYACTIVE NV3_WaitWhileDisplayActive;
FNWAITWHILEDISPLAYACTIVE NV4_WaitWhileDisplayActive;
FNGETSCANLINE           NV_GetScanLineData;

FNFIFOISBUSY            NV1FifoIsBusy;

VOID vPutBits(PDEV*, DSURF *,SURFOBJ*, RECTL*);
VOID vGetBits(PDEV*, DSURF *,SURFOBJ*, RECTL*);

VOID vIoSlowPatRealize(PDEV*, RBRUSH*, BOOL);

VOID NvHwSpecific(PDEV* ppdev);
//******************************************************************************
// Capabilities flags
//
// These are private flags passed to us from the NV miniport.  They
// come from the 'DriverSpecificAttributeFlags' field of the
// 'VIDEO_MODE_INFORMATION' structure (found in 'ntddvdeo.h') passed
// to us via an 'VIDEO_QUERY_AVAIL_MODES' or 'VIDEO_QUERY_CURRENT_MODE'
// IOCTL.
//
// NOTE: These definitions must match those in the NV miniport's 'NV.h'!
//******************************************************************************

//******************************************************************************
// Do NOT use CAPS_NVX_IS_PRESENT anywhere in the display driver.  Chip
// capabilities should be based on the classes that are allocated.  See
// ppdev->CurrentClass for which classes got allocated at init time.
//******************************************************************************


typedef enum {
/*    
    CAPS_NV1_IS_PRESENT     = 0x00000010,   // NV1 Chip is present
    CAPS_NV3_IS_PRESENT     = 0x00000020,   // NV3 Chip is present
    CAPS_NV4_IS_PRESENT     = 0x00000040,   // NV4 Chip is present
    CAPS_NV5_IS_PRESENT     = 0x00000080,   // NV5 Chip is present
    CAPS_NV5VANTA_IS_PRESENT= 0x00000100,   // NV5 VANTA Chip is present
    CAPS_NV5ULTRA_IS_PRESENT= 0x00000200,   // NV5 ULTRA Chip is present
    CAPS_NV0A_IS_PRESENT    = 0x00000400,   // NV0A Chip is present
    CAPS_NV10_IS_PRESENT    = 0x00000800,   // NV10 Chip is present
 CAPS_NV5MODEL64_IS_PRESENT = 0x00001000,   // NV5 Model 64 is present
 CAPS_NV10DDR_IS_PRESENT    = 0x00002000,   // NV10 DDR Chip is present
 CAPS_NV10GL_IS_PRESENT     = 0x00004000,   // NV10 GL Chip is present
 CAPS_NV11_IS_PRESENT       = 0x00008000,   // NV11 Chip is present
 CAPS_NV11DDR_IS_PRESENT    = 0x00010000,   // NV11 DDR Chip is present
 CAPS_NV11M_IS_PRESENT      = 0x80000000,   // NV11M Chip is present
 CAPS_NV11GL_IS_PRESENT     = 0x00020000,   // NV11 GL Chip is present
 CAPS_NV15_IS_PRESENT       = 0x00040000,   // NV15 Chip is present
 CAPS_NV15DDR_IS_PRESENT    = 0x00080000,   // NV15 DDR Chip is present
 CAPS_NV15GL_IS_PRESENT     = 0x00100000,   // NV15 GL Chip is present
 CAPS_NV15BR_IS_PRESENT     = 0x00200000,   // NV15 BR Chip is present
 CAPS_NV20_IS_PRESENT       = 0x00400000,   // NV20 Chip is present
*/    
// not used    CAPS_BT485_POINTER      = 0x00400000,   // Use Brooktree 485 pointer
// not used     CAPS_TI025_POINTER      = 0x00800000,   // Use TI TVP3020/3025 pointer
// not used     CAPS_SCALE_POINTER      = 0x01000000,   // Set if the S3 hardware pointer
// not used                                             //   x position has to be scaled by
// not used                                             //   two
// not used     CAPS_SPARSE_SPACE       = 0x02000000,   // Frame buffer is mapped in sparse
// not used                                             //   space on the Alpha
// not used     CAPS_NEW_BANK_CONTROL   = 0x04000000,   // Set if 801/805/928 style banking
// not used     CAPS_NEWER_BANK_CONTROL = 0x08000000,   // Set if 864/964 style banking
// not used     CAPS_RE_REALIZE_PATTERN = 0x10000000,   // Set if we have to work around the
// not used                                             //   864/964 hardware pattern bug
// not used     CAPS_SLOW_MONO_EXPANDS  = 0x20000000,   // Set if we have to slow down
// not used                                             //   monochrome expansions
    CAPS_SW_POINTER         = 0x40000000,   // No hardware pointer; use software simulation
// Note definition above: CAPS_NV11M_IS_PRESENT      = 0x80000000,   // NV11M Chip is present


} CAPS;

#define CAPS_DAC_POINTER        (CAPS_BT485_POINTER | CAPS_TI025_POINTER)

#define CAPS_LINEAR_FRAMEBUFFER CAPS_NEW_MMIO
                                            // For now, we're linear only
                                            //   when using with 'New MM I/O'

//******************************************************************************
// Do NOT use NVX_IS_PRESENT anywhere in the display driver.  Chip
// capabilities should be based on the classes that are allocated.  See
// ppdev->CurrentClass for which classes got allocated at init time.
//******************************************************************************

/*
// The NV4_IS_PRESENT bit is also used as a compatibility flag, so to truly detect an NV4, no other bits must be set
#define IS_NV04_PRESENT(ppdev) ((ppdev->flCaps & CAPS_NV4_IS_PRESENT) && (ppdev->flCaps & ~CAPS_NV4_IS_PRESENT)==0)

#define IS_NV05_PRESENT(ppdev)  ((ppdev->flCaps & CAPS_NV5_IS_PRESENT) ||\
             (ppdev->flCaps & CAPS_NV5VANTA_IS_PRESENT) ||\
             (ppdev->flCaps & CAPS_NV5MODEL64_IS_PRESENT) ||\
             (ppdev->flCaps & CAPS_NV5ULTRA_IS_PRESENT) ||\
             (ppdev->flCaps & CAPS_NV0A_IS_PRESENT))

#define IS_NV10_PRESENT(ppdev)  ((ppdev->flCaps & CAPS_NV10_IS_PRESENT) ||\
             (ppdev->flCaps & CAPS_NV10DDR_IS_PRESENT) ||\
             (ppdev->flCaps & CAPS_NV10GL_IS_PRESENT))

#define IS_NV11_PRESENT(ppdev)  ((ppdev->flCaps & CAPS_NV11_IS_PRESENT) ||\
             (ppdev->flCaps & CAPS_NV11DDR_IS_PRESENT) ||\
             (ppdev->flCaps & CAPS_NV11M_IS_PRESENT)   ||\
             (ppdev->flCaps & CAPS_NV11GL_IS_PRESENT))

#define IS_NV15_PRESENT(ppdev)  ((ppdev->flCaps & CAPS_NV15_IS_PRESENT) ||\
             (ppdev->flCaps & CAPS_NV15DDR_IS_PRESENT) ||\
             (ppdev->flCaps & CAPS_NV15BR_IS_PRESENT)  ||\
             (ppdev->flCaps & CAPS_NV15GL_IS_PRESENT))

#define IS_NV20_PRESENT(ppdev)  ((ppdev->flCaps & CAPS_NV20_IS_PRESENT))

*/

// DENSE(ppdev) returns TRUE if the normal 'dense space' mapping of the
// frame buffer is being used.  It returns FALSE only on the Alpha when
// the frame buffer is mapped in using 'sparse space,' meaning that all
// reads and writes to and from the frame buffer must be done through the
// funky 'ioaccess.h' macros.

#if defined(_ALPHA_)
    #define DENSE(ppdev)        (!(ppdev->flCaps & CAPS_SPARSE_SPACE))
#else
    #define DENSE(ppdev)        1
#endif

////////////////////////////////////////////////////////////////////////
// Status flags

typedef enum {
    STAT_GLYPH_CACHE        = 0x0001,   // Glyph cache successfully allocated
    STAT_BRUSH_CACHE        = 0x0002,   // Brush cache successfully allocated
    STAT_DIRECTDRAW_CAPABLE = 0x0004,   // Card is DirectDraw capable
    STAT_DIRECTDRAW_ENABLED = 0x0008,   // DirectDraw is currently enabled
    STAT_STREAMS_ENABLED    = 0x0010,   // Streams are enabled for this mode
    STAT_FORMATTER_ENABLED  = 0x0020,   // Pixel formatter enabled for this mode
} STATUS;

////////////////////////////////////////////////////////////////////////
// Nvidia OpenGL client information.
// globalOpenGLData.oglClientCount will not go to 0, so it is bad to use it for ogl tests!
#define OglIsEnabled(_pdev) (0 != globalOpenGLData.oglDrawableClientCount)
#define OGL_FLIPPED() (ppdev->ulPrimarySurfaceOffset != ppdev->ulFlipBase)

#define NV_OGL_CLIENT_DRAWABLE_INFO 0x0001 // if bit ON then drawable info exists...
#define NV_OGL_CLIENT_CONTEXT_INFO  0x0002 // if bit ON then context info exits...
#define NV_OGL_CLIENT_SHARED_INFO   0x0004 // if bit ON then context info exits...
#define NV_OGL_CLIENT_WOC_DELETE    0x0008 // if bit ON then WOC_DELETE occured on window...

typedef struct _NV_OPENGL_CLIENT_INFO
    {
    DWORD                      flags;               // bits indicating allocated/free resources
    HDRVOBJ                    hDrvObj;             // driver object handle for this client
    WNDOBJ                     *pwo;                // WNDOBJ pointer for drawable node
    struct _PDEV               *ppdev;              // Pointer to current ppdev;
    DWORD                      modeSwitchCount;     // mode switch counter when hDrvObj is created
    ULONG                      processHandle;       // Process handle from client associated with globalData
    PVOID                      oglGlobalPagePtr;    // Pointer to shared memory
    PVOID                      pfifoAddress;        // Address of FIFO in client address space
    PVOID                      pbusAddress;         // Address of PBUS in client address space
    ULONG                      hClient;             // Per-process shared hClient
    PIXELFORMATDESCRIPTOR      pfd;                 // pixelformat of the client window
    BOOL                       bStereoDisabled;     // if stereo pfd: TRUE: currently disabled because unused
    BOOL                       bFlipping;           // TRUE if client is allowed to flip.
    DWORD                      dwProcessID;         // ProcessID of ICD's process
    struct _NV_OPENGL_DRAWABLE_INFO    *clientDrawableInfo; // drawable information for this client
    struct _NV_OPENGL_CONTEXT_INFO     *clientContextInfo;  // context information for this client
    } NV_OPENGL_CLIENT_INFO;

struct _NV_OPENGL_CLIENT_INFO_LIST;
typedef struct _NV_OPENGL_CLIENT_INFO_LIST
    {
        ULONG refCount;
        NV_OPENGL_CLIENT_INFO              clientInfo;
        struct _NV_OPENGL_CLIENT_INFO_LIST *next;
    } NV_OPENGL_CLIENT_INFO_LIST;

typedef struct _NV_OPENGL_CLIENT_LIST_HEAD
    {
    NV_OPENGL_CLIENT_INFO_LIST *clientList;
    } NV_OPENGL_CLIENT_LIST_HEAD;

typedef struct _NV_LAYER_PALETTE
    {
    struct _NV_LAYER_PALETTE *next;

    void         *windowHandle;
    unsigned int  entries[ICD_PALETTE_ENTRIES];
    unsigned int  crTransparent;
    } NV_LAYER_PALETTE;

typedef struct _NV_LAYER_PALETTE_LIST_HEAD
    {
    NV_LAYER_PALETTE *paletteList;
    } NV_LAYER_PALETTE_LIST_HEAD;

typedef struct _GLOBAL_OPENGL_DATA {
    NV_OPENGL_CLIENT_LIST_HEAD oglClientListHead;
    ULONG                      oglClientCount; // Count of number of OGL clients connected to display driver
    ULONG                      oglDrawableClientCount; // Count of number of OGL drawable clients
    // RBierman: addons for overlay
    NV_LAYER_PALETTE_LIST_HEAD oglLayerPaletteListHead;
    ULONG                      oglLayerPaletteClientCount; 
#ifdef NV_MAIN_MULTIMON
    struct _LINKEDLISTHEAD     *oglpdevList;
#endif
} GLOBAL_OPENGL_DATA;

extern GLOBAL_OPENGL_DATA globalOpenGLData;
extern VOID OglAcquireGlobalMutex();
extern VOID OglReleaseGlobalMutex();

typedef struct _CLASSOBJ {
    ULONG ChannelDMA;
    ULONG IndexedImageFromCPU;
    ULONG VideoLutCursorDac;
    ULONG ContextSurfaces2D;
    ULONG VideoOverlay;
    ULONG ScaledImageFromMemory;
    ULONG AlphaImageFromMemory;
} CLASSOBJ;

////////////////////////////////////////////////////////////////////////
// Misc video related defs
#define NV_MAX_BUFFERS 8

typedef struct _VIDBUFFER
{
     ULONG offset;                 /* byte offset of top-left pixel       00-  03*/
     ULONG pitch;                  /* bytes between lines                 04-  07*/
     ULONG size;                   /* height_width U16_U16 in pixels      08-  0b*/
     ULONG format;                 /* ORed NV_VFM_IMAGE_FORMAT_*          0c-  0f*/
     ULONG notify;                 /* notification style, varies w/OS     10-  13*/
} VIDBUFFER, *PVIDBUFFER;

// for ICD-Overlay purposes + DDrawApp detection
#define MAX_POINTER_LIST_ELEMENTS 50 

typedef struct _POINTER_LIST
{
    ULONG  cElements;
    PULONG apulElements[MAX_POINTER_LIST_ELEMENTS];
}POINTER_LIST, *PPOINTER_LIST;

////////////////////////////////////////////////////////////////////////
// HW workaround flags
#define NV_WORKAROUND_NV11RevB_DIRTHERING       0x00000001

// this is required for pre-win2k driver builds. on win2k, the display
// driver shares a flip record in GLOBALDATA with the d3d driver
typedef struct 
{
    FLATPTR         fpFlipFrom;             // Surface we last flipped from
    FLATPTR         fpFlipTo;               // Surface we last flipped to
    LONGLONG        liFlipTime;             // Time at which last flip
                                            //   occured
    LONGLONG        liFlipDuration;         // Precise amount of time it
                                            //   takes from vblank to vblank
    BOOL            bHaveEverCrossedVBlank; // True if we noticed that we
                                            //   switched from inactive to
                                            //   vblank
    BOOL            bWasEverInDisplay;      // True if we ever noticed that
                                            //   we were inactive
    UINT            dwFlipScanLine;
    BOOL            bFlipFlag;              // True if we think a flip is
                                            //   still pending
    DWORD           fpPreviousFlipFrom;     // Previous surface we flipped from
    LONGLONG        liPreviousFlipTime;     // Time of previous surface flip
    DWORD           dwReserved1;            // pad to 64 bits
} OLD_FLIPRECORD;

//
// cliplist structure managed through cliplist.c/h
typedef struct _CLIPLIST
{
  RECTL   rclBounds;  // visible bounding <= rclClient!
  LONG    cMax;       // allocated size for prcl
  LONG    c;          // number of rects stored in prcl
  LONG    cPixel;     // Number of total pixels inside cliplist
  RECTL  *prcl;       // array of size cMac with c valid rects
} CLIPLIST;


////////////////////////////////////////////////////////////////////////
// The Physical Device data structure

typedef struct  _PDEV
{
    // -------------------------------------------------------------------
    // NOTE: Changes between here and NOTE1 in the PDEV structure must be
    // reflected in i386\strucs.inc (assuming you're on an x86, of course)!

    ULONG       NVSignature;
    LONG        xOffset;                // Pixel offset from (0, 0) to current
    LONG        yOffset;                //   DFB located in off-screen memory
    DWORD*      pjMmBase;               // We'll use it as a ptr to our NV Channel
    volatile DWORD* GrStatusReg;        // We'll use it as a ptr to our Gr Status Reg
    volatile DWORD* FbConfig0Reg;       // We'll use it as a ptr to our Fb Config0 Reg
    volatile DWORD* FbStartAddr;        // We'll use it as a ptr to our Fb Start Addr
    volatile DWORD* DACRegs;            // We'll use it as a ptr to our Cursor registers
    volatile UCHAR* PRMCIORegs;         // NV3 PRMCIO Regs
    volatile UCHAR* PRMVIORegs;         // NV3 PRMVIO Regs
    volatile DWORD* PRAMDACRegs;        // NV3 PRAMDAC Regs
    volatile DWORD* PRAMINRegs;         // NV3 PRAMIN Regs
    volatile DWORD* PGRAPHRegs;         // NV3 PGRAPH Regs
    volatile DWORD* PFIFORegs;          // NV3 PFIFO Regs
    ULONG       FbBufferToggle;         // 0 or 1 (denotes frame buffer)
    BYTE*       pjFrameBufbase;         // pjFrameBuf base pointing to the base of frame buffer
    BYTE*       pjScreen;               // Points to base screen address
    LONG        lDelta;                 // Distance from one scan to the next.
    LONG        cjPelSize;              // 1 if 8bpp, 2 if 16bpp, 3 if 24bpp,
                                        //   4 if 32bpp
    ULONG       iBitmapFormat;          // BMF_8BPP or BMF_16BPP or BMF_32BPP
                                        //   (our current colour depth)
    LONG        iBoard;                 // Logical multi-board identifier
                                        //   (zero by default)
    ULONG       fontCacheOffset;        // Offset into font cache offscreen mem area
    ULONG       fontCacheEnabled;       // Flag to indicate whether driver will cache fonts

    CAPS        flCaps;                 // Capabilities flags
    STATUS      flStatus;               // Status flags
    BOOL        bEnabled;               // In graphics mode (not full-screen)

    HANDLE      hDriver;                // Handle to \Device\Screen
    HDEV        hdevEng;                // Engine's handle to PDEV

    LONG        cxScreen;               // Visible screen width
    LONG        cyScreen;               // Visible screen height
    LONG        cxMemory;               // Width of Video RAM
    LONG        cyMemory;               // Height of Video RAM
    LONG        cBitsPerPel;            // Bits per pel (8, 15, 16, 24 or 32)
    ULONG       cbFrameBuf;             // Size of frame buffer in bytes
    ULONG       AlphaEnableValue;       // Global alpha enable value

    ////////// DMA Pusher Functionality

    ULONG       DmaPushEnabled2D;
    ULONG       DmaPushBufTotalSize;
    ULONG       DmaPushBufCanUseSize;
    ULONG       DmaPushBufMinSize;
    ULONG       DmaPushHandle;
    ULONG      *nvDmaFifo;
    ULONG       nvDmaCount;
    ULONG      *nvDmaChannel;
    ULONG       nvDmaCachedGet;
    ULONG       nvDmaCachedPut;
    ULONG       nvDmaPreviousPut;
    ULONG       nvDmaWrapFlag;
    LONG        nvDmaCachedFreeCount;
    ULONG      *nvDmaFlushFixDwordPtr;
    ULONG       nvDmaFlushFixDummyValue;

    // -------------------------------------------------------------------
    // NOTE1: Changes up to here in the PDEV structure must be reflected in
    // i386\strucs.inc (assuming you're on an x86, of course)!

    ULONG       left;                   // left edge of display (relative to desktop)
    ULONG       top;                    // rop edge of display (relative to desktop)

    volatile DWORD* NvBaseAddr;         // Base address of NV device regs
    VOID*  NvDmaIndexedImageLut;        // pointer to indexed image LUT buffer
    ULONG  NvLastIndexedImageNotifier;

    ULONG       AliFixupIoNeeded;       // Flag to enable IO fixup for ALI
    ULONG       AliFixupIoBase;         // Mapping to unused IO register

    ULONG       ulMode;                 // Mode the mini-port driver is in.

    FLONG       flHooks;                // What we're hooking from GDI
    FLONG       flHooksDeviceBitmap;    // What we're hooking from GDI
    ULONG       ulWhite;                // 0xff if 8bpp, 0xffff if 16bpp,
                                        //   0xffffffff if 32bpp
    VOID*       pMemToMemBuffer;        // General purpose temporary buffer,
                                        //   MEM_TO_MEM_BUFFER_SIZE bytes in size
                                        //   (Remember to synchronize if you
                                        //   use this for device bitmaps or
                                        //   async pointers)
    ULONG       MemToMemBufferSize;     // Holds size of mem to mem temporary buffer
    USHORT*     apwMmXfer[XFER_BUFFERS];// Pre-computed array of unique
    ULONG*      apdMmXfer[XFER_BUFFERS];//   addresses for doing memory-mapped
                                        //   transfers without memory barriers
                                        // Note that the 868/968 chips have a
                                        //   hardware bug and can't do byte
                                        //   transfers
    HSEMAPHORE  csCrtc;                 // Used for synchronizing access to
                                        //   the CRTC register
    HSEMAPHORE  csFifo;                 // Used for synchronizing access to
                                        //   the DMA pusher or CPU pusher shared FIFO
    ULONG       numDevices;             // Number of devices OpenGL is using...
    ULONG       bSupportOgl;            // TRUE if OpenGL ICD is supported
    ULONG       bReleaseOglMutex;       // TRUE indicates driver must release the OGL mutex
    ULONG       *oglGlobalPagePtr;      // pointer to page of locked down memory used by OGL
    PVOID       origOglGlobalPagePtr;   // Pointer remembered to free oglGlobalPagePtr
    PVOID       oglGlobalPageMdl;       // MDL to locked down OGL page
    ULONG       oglGlobalPageSize;      // size in bytes of locked down OGL page
    ULONG       *oglMutexPtr;           // OGL mutex lock pointer
    ULONG       *oglModeSwitchPtr;      // OGL mode switch pointer
    ULONG       bOglSingleBackDepthSupported; // TRUE if display driver allocates single-back-depth surface
    ULONG       bOglSingleBackDepthCreated; // TRUE if display driver allocated single-back-depth surface
    ULONG       oglSyncGdi;             // Synchronize OpenGL with GDI
    ULONG       ulOpenGLinFullScreen;   // TRUE if OpenGL is rendering in FULL screen
    ULONG       hwGfxCaps;              // Graphics caps reported by the RM. 
    DWORD       oglRegUBB;              // registry val for NV_REG_OGL_SINGLE_BACKDEPTH_BUFFER
    DWORD       oglRegFlippingControl;  // registry val for NV4_REG_OGL_BUFFER_FLIPPING_CONTROL
    DWORD       oglRegWindowFlipping;   // registry val for NV_REG_OGL_WINDOW_FLIPPING
    DWORD       oglRegOverlaySupport;   // registry val for NV_REG_OGL_OVERLAY_SUPPORT
    DWORD       oglRegApiStereoSupport; // registry val for NV_REG_OGL_STEREO_SUPPORT
    DWORD       oglRegApiStereoMode;    // registry val for NV_REG_OGL_API_STEREO_MODE
    BOOL        bOglOverlayDesired;     // reflects that ogl overlay is switched on via registry
    BOOL        bOglStereoDesired;      // reflects that ogl stereo is switched on via registry
    BOOL        bOglStereoActive;       // TRUE if stereo is active now, and glasses are in any of oglRegApiStereoMode supported modes
    ULONG       ulOglActiveViews;       // number of addition active OGL_STEREO_NUMBUFFERS views for ogl 0 -> ogl not running, 1 -> monoscopic left only, 2 -> stereo left and right
    NvU32       singleFrontOffset[OGL_STEREO_NUMBUFFERS]; // offset in video memory to single-front buffer
    NvU32       singleFrontPitch[OGL_STEREO_NUMBUFFERS];  // offset in video memory to single-front buffer
    NvU32       singleBack1Offset[OGL_STEREO_NUMBUFFERS]; // offset in video memory to single-back buffer
    NvU32       singleBack1Pitch[OGL_STEREO_NUMBUFFERS];  // offset in video memory to single-back buffer
    NvU32       singleDepthOffset[OGL_STEREO_NUMBUFFERS]; // offset in video memory to single-depth buffer
    NvU32       singleDepthPitch[OGL_STEREO_NUMBUFFERS];  // offset in video memory to single-depth buffer
    ULONG       ulTempOffscreenBufferSize;  // size of temporary offscreen buffer ( lDelta long )
    ULONG       ulTempOffscreenBufferOffset;// offset of temporary offscreen buffer ( needed in ubb mode )
    ULONG       bOglOverlaySurfacesCreated; // TRUE if display driver allocated overlay surfaces
                                            //      for OpenGL
    NvU32       singleFrontMainOffset[OGL_STEREO_NUMBUFFERS];      // Offsets and pitches to main and overlay planes
    NvU32       singleFrontMainPitch[OGL_STEREO_NUMBUFFERS];       //    for opengl pseudo hardware implementation of
    NvU32       singleBack1MainOffset[OGL_STEREO_NUMBUFFERS];      //    overlay planes
    NvU32       singleBack1MainPitch[OGL_STEREO_NUMBUFFERS]; 
    NvU32       singleFrontOverlayOffset[OGL_STEREO_NUMBUFFERS];
    NvU32       singleFrontOverlayPitch[OGL_STEREO_NUMBUFFERS]; 
    NvU32       singleBack1OverlayOffset[OGL_STEREO_NUMBUFFERS];
    NvU32       singleBack1OverlayPitch[OGL_STEREO_NUMBUFFERS]; 
    POINTER_LIST plSavedPopupMenus; // MSchwarzer 10/04/2000 need this for overlay popuprestauration
    LONG        lSavedScreenBits;         // MSchwarzer 11/20/2000 need this for overlay popuprestauration
    FNACQUIREOGLMUTEX *pfnAcquireOglMutex; // function to acquire the OGL mutex
    FNRELEASEOGLMUTEX *pfnReleaseOglMutex; // function to release the OGL mutex
    CLIPLIST          OglNegativeClipList; // pointer to negative cliplist == desktop - all clients

    ////////// Low-level blt function pointers:

    FNSETDESTBASE*      pfnSetDestBase;
    FNSETSOURCEBASE*    pfnSetSourceBase;

    FNFILL*             pfnFillSolid;
    FNFILL*             pfnFillPat;
    FNXFER*             pfnXfer1bpp;
    FNXFER*             pfnXfer4bpp;
    FNXFER*             pfnXferNative;
    FNXFER*             pfnXfer8to16bpp;
    FNXFER*             pfnXfer4to16bpp;
    FNXFER*             pfnXfer8to32bpp;
    FNXFER*             pfnXfer4to32bpp;
    FastXFER*           pfnFastXfer8to32;
    FastXFER*           pfnFastXfer8to16;

    FNXFER*             pfnIndexedImage;
    FNCOPY*             pfnCopyBlt;
    FNMEMTOSCRN*        pfnMemToScreenBlt;
    FNSCRNTO1BPPMEM*    pfnScreenTo1BppMemBlt;
    FNGETSCRNBITS*      pfnGetScreenBits;
    FNFASTPATREALIZE*   pfnFastPatRealize;
    FNIMAGETRANSFER*    pfnImageTransfer;
    FNTEXTOUT*          pfnTextOut;
    FNSETPALETTE*       pfnSetPalette;
    FNLINETOTRIVIAL*    pfnLineToTrivial;
    FNLINETOCLIPPED*    pfnLineToClipped;

    
    FNSCRNTOMEM*        pfnScreenToMemBlt;        // 
                                                  //
    DWORD               globalXferOverheadFactor; // This is not a pfn, but is data
                                                  // needed by pfnScreenToMemBlt

    FNSCRNTOMEM*        pfnScreenToMem16to4bppBlt; 
    FNSCRNTOMEM*        pfnScreenToMem32to4bppBlt; 
    FNSCRNTOMEM*        pfnScreenToMem16to8bppBlt; 
    FNSCRNTOMEM*        pfnScreenToMem32to8bppBlt; 

    FNSCRNTOSCRNPAT*    pfnScreenToScreenWithPatBlt; 


    ////////// Other NV function pointers:

    FNWAITENGINEBUSY*   pfnWaitEngineBusy;
    FNWAITCHANNELSWITCH* pfnWaitForChannelSwitch;
    FNDMAPUSHGO*        pfnDmaPushGo;
    FNMEMTOSCRNPATTERN* pfnMemToScreenPatternBlt;
    FNSTROKEPATH*       pfnStrokePath;
    FNLINETO*           pfnLineTo;
    FNSTRETCHCOPY*      pfnStretchCopy;

    ////////// Eng fallback function pointers:
    
    BOOL (*pfnEngBitBlt)(SURFOBJ  *psoTrg,
                                  SURFOBJ  *psoSrc,
                                  SURFOBJ  *psoMask,
                                  CLIPOBJ  *pco,
                                  XLATEOBJ *pxlo,
                                  RECTL    *prclTrg,
                                  POINTL   *pptlSrc,
                                  POINTL   *pptlMask,
                                  BRUSHOBJ *pbo,
                                  POINTL   *pptlBrush,
                                  ROP4      rop4);
    BOOL (*pfnEngCopyBits)(SURFOBJ  *psoDest,
                                    SURFOBJ  *psoSrc,
                                    CLIPOBJ  *pco,
                                    XLATEOBJ *pxlo,
                                    RECTL    *prclDest,
                                    POINTL   *pptlSrc);
    BOOL (*pfnEngAlphaBlend)(SURFOBJ       *psoDest,
                                      SURFOBJ       *psoSrc,
                                      CLIPOBJ       *pco,
                                      XLATEOBJ      *pxlo,
                                      RECTL         *prclDest,
                                      RECTL         *prclSrc,
                                      BLENDOBJ      *pBlendObj);
    BOOL (*pfnEngTransparentBlt)(SURFOBJ       *psoDest,
                                      SURFOBJ       *psoSrc,
                                      CLIPOBJ       *pco,
                                      XLATEOBJ      *pxlo,
                                      RECTL         *prclDest,
                                      RECTL         *prclSrc,
                                      ULONG         iTransColor,
                                      ULONG         Reserved);
    BOOL (*pfnEngTextOut)(SURFOBJ  *pso,
                                   STROBJ   *pstro,
                                   FONTOBJ  *pfo,
                                   CLIPOBJ  *pco,
                                   RECTL    *prclExtra,
                                   RECTL    *prclOpaque,
                                   BRUSHOBJ *pboFore,
                                   BRUSHOBJ *pboOpaque,
                                   POINTL   *pptlOrg,
                                   MIX       mix);
    BOOL (*pfnEngLineTo)(SURFOBJ   *pso,
                                  CLIPOBJ   *pco,
                                  BRUSHOBJ  *pbo,
                                  LONG       x1,
                                  LONG       y1,
                                  LONG       x2,
                                  LONG       y2,
                                  RECTL     *prclBounds,
                                  MIX        mix);
    BOOL (*pfnEngStrokePath)(SURFOBJ   *pso,
                                      PATHOBJ   *ppo,
                                      CLIPOBJ   *pco,
                                      XFORMOBJ  *pxo,
                                      BRUSHOBJ  *pbo,
                                      POINTL    *pptlBrushOrg,
                                      LINEATTRS *plineattrs,
                                      MIX        mix);

    struct {
        LONG  NumBuffers; // number of valid offsets in MultiBufferOffsets (signed to allow better error checking)
        ULONG MultiBufferOffsets[NV_MAX_BUFFERS];
        BOOL  bEnabled;

        struct {
            // FNACQUIREOGLMUTEX *pfnAcquireOglMutex; // function to acquire the OGL mutex
            // FNRELEASEOGLMUTEX *pfnReleaseOglMutex; // function to release the OGL mutex

            ////////// Low-level blt function pointers:
            // FNSETDESTBASE*      pfnSetDestBase;
            // FNSETSOURCEBASE*    pfnSetSourceBase;

            FNFILL*             pfnFillSolid;
            FNFILL*             pfnFillPat;
            FNXFER*             pfnXfer1bpp;
            FNXFER*             pfnXfer4bpp;
            FNXFER*             pfnXferNative;
            FNXFER*             pfnXfer8to16bpp;
            FNXFER*             pfnXfer4to16bpp;
            FNXFER*             pfnXfer8to32bpp;
            FNXFER*             pfnXfer4to32bpp;
            FastXFER*           pfnFastXfer8to32;
            FastXFER*           pfnFastXfer8to16;

            FNXFER*             pfnIndexedImage;
            FNCOPY*             pfnCopyBlt;
            FNMEMTOSCRN*        pfnMemToScreenBlt;
            FNSCRNTO1BPPMEM*    pfnScreenTo1BppMemBlt;
            //FNGETSCRNBITS*      pfnGetScreenBits;
            FNFASTPATREALIZE*   pfnFastPatRealize;
            FNIMAGETRANSFER*    pfnImageTransfer;
            FNTEXTOUT*          pfnTextOut;
            FNSETPALETTE*       pfnSetPalette;
            FNLINETOTRIVIAL*    pfnLineToTrivial;
            FNLINETOCLIPPED*    pfnLineToClipped;

            // Screen to Mem Function Pointers
            FNSCRNTOMEM*        pfnScreenToMemBlt;

            //DWORD               globalXferOverheadFactor; // This is not a pfn, but is data
            //                                              // needed by pfnScreenToMemBlt
            
            FNSCRNTOMEM*        pfnScreenToMem16to4bppBlt; 
            FNSCRNTOMEM*        pfnScreenToMem32to4bppBlt; 
            FNSCRNTOMEM*        pfnScreenToMem16to8bppBlt; 
            FNSCRNTOMEM*        pfnScreenToMem32to8bppBlt; 

            FNSCRNTOSCRNPAT*    pfnScreenToScreenWithPatBlt; 


            ////////// Other NV function pointers:

            // FNWAITENGINEBUSY*   pfnWaitEngineBusy;            
            // FNWAITCHANNELSWITCH* pfnWaitForChannelSwitch;
            // FNDMAPUSHGO*        pfnDmaPushGo;
            FNMEMTOSCRNPATTERN* pfnMemToScreenPatternBlt;
            FNSTROKEPATH*       pfnStrokePath;
            FNLINETO*           pfnLineTo;
            FNSTRETCHCOPY*      pfnStretchCopy;

        } SavedProcs;
    } DoubleBuffer;


    ////////// Palette stuff:

    PALETTEENTRY* pPal;                 // The palette if palette managed
    HPALETTE    hpalDefault;            // GDI handle to the default palette.
    FLONG       flRed;                  // Red mask for 16/32bpp bitfields
    FLONG       flGreen;                // Green mask for 16/32bpp bitfields
    FLONG       flBlue;                 // Blue mask for 16/32bpp bitfields
    FLONG       physicalColorMask;      //
    ULONG       cPaletteShift;          // number of bits the 8-8-8 palette must
                                        // be shifted by to fit in the hardware
                                        // palette.

    ////////// Primary surface stuff:
    
    HSURF       hsurfScreen;            // Engine's handle to screen surface
    DSURF       dsurfScreen;            // Our private DSURF for the screen
    OH          ohScreen;               // Off-screen heap structure for the
                                        //   visible screen

    ////////// Heap stuff:

    HEAP        heap;                   // All our off-screen heap data
    ULONG       iHeapUniq;              // Incremented every time room is freed
                                        //   in the off-screen heap

    DSURF*      pdsurf;                 // head of 2-link list of all DFBs.

    SURFOBJ*    psoPunt;                // Wrapper surface for having GDI draw
                                        //   on off-screen bitmaps
    SURFOBJ*    psoPunt2;               // Another one for off-screen to off-
                                        //   screen blts
    SURFOBJ*    psoPunt3;               // Another one needed for brush conversion

    ////////// Pointer stuff:

    ULONG       MonitorType;            // Cursor adjustment values for when
    ULONG       Underscan_x;            // the driver is running through a TV set
    ULONG       Underscan_y;            //
    ULONG       Scale_x;                //
    ULONG       Scale_y;                //
    ULONG       FilterEnable;           //
    ULONG       TVCursorMin;            //
    ULONG       TVCursorMax;            //

    LONG        xPointerHot;            // xHot of current hardware pointer
    LONG        yPointerHot;            // yHot of current hardware pointer

    LONG        xPointer;               // Start x-position for the current
                                        //   S3 pointer
    LONG        yPointer;               // Start y-position for the current

    ULONG       ulCursorMemOffset[2];   // Offset into inst mem of area for ptr bmps - Double buffer.
    ULONG       ulCursorCurBufIndex;    // Double Buffer, current cursor buffer;

    ULONG       ulCachedCursorWidth;    // Last width programmed into the HW
    ULONG       ulCachedCursorFormat;   // Last format programmed into the HW
    ULONG       ulMaxHwCursorDepth;     // Max color depth of cursor (16/32)
    ULONG       ulMaxHwCursorSize;      // Max cursor width/height supported by
                                        //   current hardware
    BOOL        bSupportAlphaCursor;    // Support Alpha blended cursor

    FNSHOWPOINTER*      pfnShowPointer;
    FNMOVEPOINTER*      pfnMovePointer;
    FNSETPOINTERSHAPE*  pfnSetPointerShape;
    FNENABLEPOINTER*    pfnEnablePointer;

    ////////// Brush stuff:
    LONG        iBrushCache;            // Index for next brush to be allocated
    LONG        cBrushCache;            // Total number of brushes cached
    BRUSHENTRY  abe[TOTAL_BRUSH_COUNT]; // Keeps track of brush cache
    POINTL      ptlReRealize;           // Work area for 864/964 pattern


    BYTE        NV_CursorImageData[32*32*2]; // Max size is 32x32  *2bytes/pixel
    BYTE        NV_TVCursorImageData[32*32*2]; // Max size is 32x32  *2bytes/pixel

    ////////// Text stuff:

    SURFOBJ*    psoText;                // 1bpp surface to which we will have
                                        //   GDI draw our glyphs for us
    /////////// DirectDraw stuff:

    ULONG       DDrawEnabledFlag;       // Flag denotes if DDRAW was enabled
    ULONG       ulMinOverlayStretch;    // Minimum stretch ratio for this mode,
    DWORD       hDdChannel;             // Channel handle
    DWORD       *ddChannelPtr;          // PIO channel ptr for ddraw
    DWORD       DummyReturn;            // Scratch area used to store return from RM fcts

#ifdef NVD3D
    /////////// Direct3D stuff:
    BOOL                        bD3DInitialized;
    DWORD                       lpLast3DSurfaceRendered;
    DWORD                       dwZBufferContextAddr;
    BOOL                        TwoDRenderingOccurred;
    BOOL                        ThreeDRenderingOccurred;
    struct _def_nv_d3d_context *FirstCtxt;
#endif // NVD3D
    BOOL                        bD3DappIsRunning;

    FNGRAPHICSENGINEBUSY*       pfnGraphicsEngineBusy;
    FNVBLANKISACTIVE*           pfnVBlankIsActive;
    FNWAITWHILEVBLANKACTIVE*    pfnWaitWhileVBlankActive;
    FNWAITWHILEDISPLAYACTIVE*   pfnWaitWhileDisplayActive;
    FNGETSCANLINE*              pfnGetScanline;
    FNFIFOISBUSY*               pfnFifoIsBusy;
    FNDDUPDATEFLIPSTATUS*       pfnUpdateFlipStatus;

    ////////// OpenGL ICD stuff:
    struct _OGLSERVER          *pOglServer;    // Pointer to structure containing OpenGL Server data.
    ULONG                      oglLastChannel; // Count of number of OGL clients connected to display driver
    ULONG                      dwGlobalModeSwitchCount;// Number of mode switches since boot
    ULONG                      OglStencilSwitch;       // Registry switch for OpenGL stencil
    ULONG                      oglColor32Depth16; // TRUE if hardware supports mixed 32/16 mode rendering
    ULONG                      oglColor16Depth32; // TRUE if hardware supports mixed 16/32 mode rendering
    ULONG                      oglMultisample;    // TRUE if hardware supports multisample rendering
    ULONG                      oglDDrawSurfaceCount;
    POINTER_LIST               oglDDrawSurfaceCountList;

    ULONG       iUniqueness;            // display uniqueness for tracking
                                        // resolution changes
    OH*         pohBackBuffer;          // Our 2-d heap allocation structure
                                        //   for the back-buffer
    ULONG       ulBackBuffer;           // Byte offset in the frame buffer
                                        //   to the start of the back-buffer
    OH*         pohRed;
    OH*         pohBlue;
    OH*         pohGreen;
    ULONG       SolidTextureOffset;     // Offset to solid texture data

    /////////// NV list of supported classes
    ULONG       nvNumClasses;
    ULONG*      nvClassList;

    CLASSOBJ    CurrentClass;          

    /////////// NV Buffer Management:

    ULONG       CurrentZOffset;
    ULONG       CurrentZPitch;
    ULONG       CurrentSourceOffset;
    ULONG       CurrentSourcePitch;
    ULONG       CurrentDestOffset;
    ULONG       CurrentDestPitch;
    ULONG       CurrentDitherState;
    ULONG       CurrentDisplayOffset;

    /////////// Ddraw Buffer Management:
    ULONG       DdCurrentSourceOffset;
    ULONG       DdCurrentSourcePitch;
    ULONG       DdCurrentDestOffset;
    ULONG       DdCurrentDestPitch;
    ULONG       DdClipResetFlag;

    // Vertex Cache Stuff

    ULONG       VRotIndex0[8];
    ULONG       VRotIndex1[8];
    ULONG       VRotIndex2[8];
    ULONG       VRotMask[8];
    ULONG       VCache[16];

    ULONG       SavedCursorCheckSums[NUM_CACHED_CURSORS];
    ULONG       SavedCursorBitmaps[NUM_CACHED_CURSORS][512];
    ULONG       NextCachedCursor;


    //Texture buffers related data
    ULONG       pListDevTex;            // A pointer to the list of device textures
                                        // being handled by the physical device

    ULONG       lastRenderedTexKey;     // Contains a reference to the texture (if any)
                                        // used in the last hw primitive rendering,
                                        // this helps us to avoid corrupting the texture
                                        // while it still may be in use by the hw

    NV_VIDEO_CLUTDATA  *ajClutData;     // Local copy of palette data
    /////////// NV Brush stuff:

    DWORD       AlignedBrush[8*8];      // Enough room for an 8x8 pattern

// NVTEST
    DWORD       NVAbsoluteLimitFlag;    // Use to calculate theoretical limit
    DWORD       NVStubTest;             // Used to return without doing anything..
    DWORD       TestChannelFlag;        // Used to return without doing anything..
    DWORD*      TestChannelPtr;
    DWORD       NVClipResetFlag;
    DWORD       NVPatternResetFlag;
    USHORT      NVFreeCount;
    DWORD       NVDebugTrace;           // Used to return without doing anything..
    DWORD       NVRecordFunctionsFlag;
    DWORD       NVLocation[70];        //Record iterations thru paths

    DWORD       dwMaxClip;              // Max. Clip value: (ppdev->cyMemory)<<16) | (0x7fff)

    //*********************************************************************************
    // Direct draw support.
    //*********************************************************************************

    // TBD: these will be replaced by vpp components in GLOBALDATA eventually. -@mjl@
    //    At present, they are used in nv4vid (among others perhaps)
#define NV_MAX_OVERLAY_SURFACES 10 // replaced by NV_VPP_MAX...
    DWORD                       dwOverlayEnabled;
    DWORD                       dwOverlayFormat;
    DWORD                       dwOverlaySurfaces;
    DWORD                       dwOverlayOwner;
    DWORD                       dwOverlaySurfaceLCL[NV_MAX_OVERLAY_SURFACES];
    DWORD                       dwOverlaySrcWidth;
    DWORD                       dwOverlaySrcHeight;
    DWORD                       dwOverlayDstWidth;
    DWORD                       dwOverlayDstHeight;
    DWORD                       dwOverlayDeltaX;
    DWORD                       dwOverlayDeltaY;
    DWORD                       dwOverlayDstX;        // overlay Dst starting point
    DWORD                       dwOverlayDstY;
    DWORD                       dwVideoColorKey;
    ULONG                       OverlaySrcX;        // overlay source starting point
    ULONG                       OverlaySrcY;
    ULONG                       OverlaySrcOffset;
    ULONG                       OverlaySrcPitch;
    ULONG                       OverlaySrcSize;
    ULONG                       OverlayBufferIndex;

    DWORD                       DDrawVideoSurfaceCount;
    ULONG                       NvFloating0UYVYSurfaceMem;
    ULONG                       NvFloating1UYVYSurfaceMem;
    ULONG                       NvFloating0YUYVSurfaceMem;
    ULONG                       NvFloating1YUYVSurfaceMem;
    ULONG                       NvFloatingMem2MemFormatBaseAddress;
    ULONG                       NvYUY2Surface0Mem;
    ULONG                       NvYUY2Surface1Mem;
    ULONG                       NvFloatingMem2MemFormatMemoryHandle;
    ULONG                       NvFloatingMem2MemFormatNextAddress;
    ULONG                       NvYUY2Surface2Mem;
    ULONG                       BaseAddress;
    PVOID                       NvDmaBufferFlat;

    //
    // Directdraw callbacks
    //
    DD_CALLBACKS            ddCallBacks;
    DD_SURFACECALLBACKS     ddSurfaceCallBacks;
    DD_PALETTECALLBACKS     ddPaletteCallBacks;

    GLOBALDATA              *pDriverData; // ->Global data used by DX6 driver.

#ifdef NVD3D
    //********************************************************************************
    // NT5 Specific data.
    //********************************************************************************
    PULONG                  dmaD3DPusherNotifier;
    BOOLEAN                 bDXGblStateInitialized;
#else
    BOOLEAN                 bDDChannelActive;
#endif // #ifdef NVD3D

    //
    // Cached surface pitch and offset for ddraw surfaces. This is for NV4 only, since
    // the NV4 ddraw patch runs in a seperate channel from the GDI driver.
    //
    ULONG   ddSrcOffset;
    ULONG   ddDstOffset;
    ULONG   ddSrcPitch;
    ULONG   ddDstPitch;

#ifdef VPE_NT
    //
    // VPE stuff
    //
    ULONG       ulCaps;
#endif

    PNV_NOTIFIERS               Notifiers;
/*#if (NVARCH < 0x4)
    // BUGBUG - Hack 'o rama, these should be NvNotification structs!
    BYTE                       NvVideoLutCursorDacNotifier[16*9];
    BYTE                       NvSyncNotifierFlat[16*5];
    BYTE                       NvFlipPrimaryNotifierFlat[16*9];
    BYTE                       NvFlipOverlayNotifierFlat[16*5];
    BYTE                       NvFlipVportNotifierFlat[16*5];
    BYTE                       NvDmaToMemNotifierFlat[16*5];
    BYTE                       NvDmaFromMemNotifierFlat[16*5];
    BYTE                        NvScaledImageNotifier[16*5];
    BYTE                        NvPrimary2dNotifier[16*5];
#endif
*/  ULONG                       fourCC[10];
    ULONG                       fNvActiveFloatingContexts;
    ULONG                       CurrentVisibleSurfaceAddress;
    DD_HALINFO                  HALInfo;
//    ULONG                       ddClipUpdate;
    BOOLEAN                     bHwVidOvl;
    ULONG                       dDrawSpareSubchannelObject;
    PVOID                       NvScanlineBufferFlat;
    ULONG                       NvDmaFromMemSurfaceMem;
    ULONG                       bEnableIF09;

    // jsw: global handles for the new architecture
    ULONG                       hClient;
    ULONG                       hDevice;
    ULONG                       hDevClass;
    ULONG                       ulDeviceReference;
#ifdef VPE_NT
    ULONG                       hVPEChannel;
    void*                       pMySurfaces;
#endif
    ULONG                       vppChannelNdx;
    ULONG                       hPioChannel;
    ULONG                       hDmaChannel;
    ULONG                       hFrameBuffer;
    ULONG                       hCursor;
    ULONG                       ulSurfaceAlign;     // hw required surface alignment
    ULONG                       ulSurfaceBitAlign;  // hw required surface alignment in term of bits
    LONG                        cxSurfaceMax;       // maximum surface width in pixels (based upon the current CONTEXT_SURFACES_2D pitch constraint)


#if (_WIN32_WINNT >= 0x0500) && !defined(NV3)
    SURFACEALIGNMENT            AgpHeapAlignment;
    LPVIDEOMEMORY               AgpHeap;
    LONG                        AgpDummyPitch;
    PVOID                       AgpPushBuffer;
    PVOID                       AgpHeapBase;
    BOOLEAN                     bAgp;               // Is AGP supported on this config?

#endif // #if _WIN32_WINNT > 0x0500

    ULONG                       ulEnableDualView;   // WINXP DualView
    ULONG                       ulDualViewSecondary;

    // used by NVHEAP_ macros
    ULONG   VideoHeapTotal;
    ULONG   VideoHeapFree;
    ULONG   cbGdiHeap;

#if _WIN32_WINNT >= 0x0500
    NV_SYSMEM_INFO  SysMemInfo;
    NV_OS_VERSION_INFO OsVersionInfo;
#endif // _WIN32_WINNT >= 0x0500

#ifndef NV3
    USHORT  dwDeviceVersion;
#endif // !NV3

    ULONG ulWorkAroundHwFlag;
    
    // VIRTUAL DESKTOP SUPPORT
        // Display driver needs 1+2*NV_NO_DACS from control panel to set the multi-view
        // 1. cxScreen, cyScreen is the big Virtual Desktop to GDI
        // 2. rclDisplayDesktop is the virtual desktop for each view fram each DAC
        // 3. width and height are calculated from rclCurrentDisplay which is the resolution 
        //    for setting mode for each DAC.  rclCurrentDisplay.top and rclCurrentDisplay.left
        //    are the intial display of each view.

    ULONG   ulDesktopMode;                      // 0x0000 -> Single Monitor
    ULONG   ulDriverNotSupportPanScan;          // Driver does not support Panning and Scanning
    ULONG   ulPuntCursorToGDI;                  // Win2K only punt the cursor back to GDI
    ULONG   ulNumberDacsOnBoard;                // Number of DACs on the board
    ULONG   ulNumberDacsConnected;              // Number of DACs which have a device (CRT/DFP/TV) connected to them
    ULONG   ulNumberDacsActive;                 // Number of DACs which are currently active. For example, in the Normal
                                                // mode, this value will be 1.
    ULONG   ulPrimaryBufferIndex;               // used by ddraw flip
    ULONG   ulDacStatus[NV_NO_DACS];            // The status of each dac (onBoard/connected/Active). Defined in nvMultiMon.h.
    ULONG   ulMoveDisplayDx;                    // Move Delta X to right or left direction
    ULONG   ulMoveDisplayDy;                    // Move Delta Y to up or down direction
    ULONG   ulGDIRefreshRate;                   // Refresh rate of the current mode as requested by GDI.
    ULONG   ulRefreshRate[NV_NO_DACS];          // Refresh rate in Hz for each head.
    RECTL   rclDisplayDesktop[NV_NO_DACS];      // Boundary of desktop;
    RECTL   rclCurrentDisplay[NV_NO_DACS];      // Current display view
    ULONG   ulHeadDisplayOffset[NV_NO_DACS];    // The offset calculated from rclDisplayDesktop (top, left and ppdev->lDelta)
    ULONG   ulFlipBase;                         // Multi buffer switching for 3D rendering
    ULONG   ulDeviceDisplay[NV_NO_DACS];        // Dynamically switch device; ulDeviceDisplay[0] will be primary; head 0 or head 1
    ULONG   ulEnableDDC[NV_NO_DACS];            // Enable EDID filtering by the display driver.
    ULONG   ulTimingOverRide[NV_NO_DACS];       // DMT/GTF/AUTO Timing override
    ULONG   ulEnablePanScan[NV_NO_DACS];        // Enable the virtual desktop (pan-scan).
    ULONG   ulFreezePanScan[NV_NO_DACS];        // Freeze the pan-scan.
    ULONG   ulFreezeOriginX[NV_NO_DACS];       // The user specified upper left corner for freezing the pan-scan.
    ULONG   ulFreezeOriginY[NV_NO_DACS];       // The user specified upper left corner for freezing the pan-scan.

    ULONG   ulDeviceMask[NV_NO_DACS];             // The bit mask ID of the device. Part of the new Head API of ResMan.
    ULONG   ulAllDeviceMask;                     // The bit mask for all the output device connectors in the board.
    ULONG   ulConnectedDeviceMask;               // The bit mask for all the currently connected output devices in the system.

    ULONG   ulDeviceType[NV_NO_DACS];           // The type of device connected to the head viz., CRT, TV, FlatPanel
                                                // defined in nvcm.h
    ULONG   ulHeadDeviceOptions[NV_NO_DACS];    // A matrix of possible device options for each head. Defined in nvMultiMon.h.
                                                // This info is used mainly by the NV control panel and gets scanned in after each
                                                // modeset since this matrix can be changed by the RM after a modeset.
                                                // This is a static entity as opposed to ulDeviceType[NV_NO_DACS] which specifies
                                                // the currently selected device type for this head.
    ULONG   ulTVFormat[NV_NO_DACS];             // The TV type: defined in nvcm.h
    ULONG   ulNumPhysModes[NV_NO_DACS];         // number of EDID trimmed, FB size trimmed and PixelClockFrequency trimmed modes
    ULONG   ulNumVirtualModes[NV_NO_DACS];      // number of FB size trimmed and PixelClockFrequency trimmed modes
    MODE_ENTRY *PhysModeList[NV_NO_DACS];       // EDID trimmed, FB size trimmed and PixelClockFrequency trimmed mode list.
    MODE_ENTRY *VirtualModeList[NV_NO_DACS];    // FB size trimmed and PixelClockFrequency trimmed mode list
    
    ULONG   TwinView_State;                     // normal, multi-mon or clone mode. Defined in nvMultiMon.h
    ULONG   TwinView_Orientation;               // horizontal or vertical. Only for multimon. Defined in nvMultiMon.h

    ULONG   ulPrimarySurfaceOffset;

    BOOL    bNVInitDmaCompleted;                // Make sure DMA initialization is completed.
    ULONG   Mobile;                             // Read from the registry. 0: Desktop, 1: Dell laptop, 2: Toshiba laptop.
                                                // NOTE: Display driver should not use this registry key. This will
                                                // be deleted eventually.
    ULONG   UseHWSelectedDevice;                // BIOS devices take precedence over windows devices.
    ULONG   UseHotKeySameMode;                  // On hot key switches, keeps the same desktop mode (resolution,depth).
                                                // This needs PAN_SCAN_SELECTION_ENABLE_ALL to have been turned on.
                                                // This field is obsolete now since no OEM is using this feature curently.
    ULONG   PanScanSelection;                   // absent or 0: pan-scan in only secondary monitor of clone mode: PAN_SCAN_SELECTION_CLONE_SECONDARY_ONLY
                                                // 1: Enable pan-scan in all modes: PAN_SCAN_SELECTION_ENABLE_ALL
                                                // 2: Disable pan-scan in all modes:PAN_SCAN_SELECTION_DISABLE_ALL 
    ULONG   GDIModePruning;                     // Absent or 0: Driver always provides EDID mode pruning protection.
                                                // 1:   For desktop or laptop systems, for CRT, for the
                                                //      standard mode device and the primary device in clone mode and
                                                //      both devices in XP DualView mode, lets the GDI handle EDID 
                                                //      mode pruning via "Hide Modes" monitor checkbox.
                                                // 2:   For desktop systems only, for CRT or DFP, for the
                                                //      standard mode device and the primary device in clone mode and
                                                //      both devices in XP DualView mode, lets the GDI handle EDID 
                                                //      mode pruning via "Hide Modes" monitor checkbox.
                                                //
    ULONG   EnableModesetStopImage;             // Sony specific feature to STOP_IMAGE during modesets and 
                                                // DPMS power on.
    ULONG   ulInduceModeChangeDeviceMask;       // The device mask/masks used by the NVSVC to induce mode change.
    ULONG   ulNVSVCStatus;                      // Started, stopped or paused status of the NVSVC service.
    ULONG   ACPISystem;                         // TRUE if we are on a ACPI system (such as laptops).

    ULONG   ulDFPSupports1400x1050;             // For Toshiba. Export 1400x1050 only on the 14x10 flat panel laptops.
    ULONG   ulDrvAssertModeTRUE;                // 1 if DrvAssertMode(TRUE). 0 if DrvEnableSurface().
    ULONG   ulDefaultTVFormat;                  // The latest and correct BIOS or user specified TV format.
    ULONG   ulDefaultTVDeviceType;              // PAL or NTSC device type based on the ppdev->ulDefaultTVFormat above.
    NVTWINVIEWDATA SaveSettings[NUM_ENTRIES_SAVE_SETTINGS]; // Saved settings for each device combo.
    // VIRTUAL DESKTOP SUPPORT

    ULONG   ulSaveScreenBitsRefCounter;                // is incremented per DrvSaveScreenBits call and used as unique ID.
    struct _LINKEDLISTHEAD *pLinkedListSaveScreenBits; // linked list of data collected in DrvSaveScreenBits

#if defined(_WIN64)
    PVOID fpState;                              // EngSaveFloatingPointState ptr
    ULONG fpStateSize;                          // EngSaveFloatingPointState len
#endif
#ifdef NT4_MULTI_DEV
    struct _MDEV *pmdev;                        // NT4 multiboarddescriptor for fast onedevice access        
#endif
    ULONG ulDriverCompatibilityMode;            // The video card's acceleration level (can be dynamically set through the Display Applet)
                                                // Value Description (W2K DDK):
                                                //     0 All display driver accelerations are permitted. 
                                                //     1 DrvSetPointerShape and DrvCreateDeviceBitmap are disabled. 
                                                //     2 In addition to 1, more sophisticated display driver accelerations are disallowed, including DrvStretchBlt, DrvFillPath, DrvGradientFill, DrvLineTo, DrvAlphaBlend, and DrvTransparentBlt. 
                                                //     3 In addition to 2, all DirectDraw and Direct3D accelerations are disallowed. 
                                                //     4 In addition to 3, almost all display driver accelerations are disallowed, except for solid color fills, DrvCopyBits, DrvTextOut, and DrvStrokePath. DrvEscape is disabled. 
                                                //     5 No hardware accelerations are allowed. The driver will only be called to do bit-block transfers from a system memory surface to the screen. 
    BOOL  bIsSWPointer;                         // NOTE: is true for SW emulated pointers (different to ulPuntCursorToGDI)
} PDEV, *PPDEV;


    // This is defined in the NT5 ddk, but nt4 needs it also
#if _WIN32_WINNT < 0x0500
    // Gamma support ( single head )
    typedef struct _GAMMARAMP
    {
      WORD Red[256];
      WORD Green[256];
      WORD Blue[256];
    }  GAMMARAMP, *PGAMMARAMP;

#endif

    // Gamma support ( multi head )
   typedef struct GAMMARAMP_MULTI
   {
      WORD        wHead; 
      GAMMARAMP   grGammaRamp;
   } GAMMARAMP_MULTI, *PGAMMARAMP_MULTI;


/////////////////////////////////////////////////////////////////////////
// Double Buffer Window Flipping Support

void NV_InitDoubleBufferMode(PDEV *ppdev, LONG NumBuffers, ULONG *MultiBufferOffsets);
void NV_DisableDoubleBufferMode(PDEV *ppdev);

/////////////////////////////////////////////////////////////////////////
// nv4hw.c export prototypes:

VOID NV4_DdPioSync(PDEV *ppdev);

/////////////////////////////////////////////////////////////////////////
// Miscellaneous prototypes:

BOOL __fastcall bIntersect(RECTL*, RECTL*, RECTL*);
LONG cIntersect(RECTL*, RECTL*, LONG);
DWORD getAvailableModes(HANDLE, PVIDEO_MODE_INFORMATION*, DWORD*, DWORD*);

BOOL bInitializeModeFields(PDEV*, GDIINFO*, DEVINFO*, DEVMODEW*);
BOOL bFastFill(PDEV*, LONG, POINTFIX*, ULONG, ULONG, RBRUSH*, POINTL*, RECTL*);

BOOL bEnableHardware(PDEV*);
VOID vDisableHardware(PDEV*);
BOOL bAssertModeHardware(PDEV*, BOOL);

void __cdecl NvSetDacImageOffset(PDEV* ppdev, ULONG ulDac, ULONG ulOffset);
BOOL __cdecl NvSetDac(PDEV *ppdev, ULONG ulHead, RESOLUTION_INFO * pResolution);
void __cdecl DisableHeadCursor(PDEV *ppdev, ULONG ulHead, ULONG ulDiable);
BOOL NvInitialDac(PDEV *ppdev);
VOID NvRestoreDacs(PDEV *ppdev);
VOID NvCreateObject(PDEV *, BOOL, PVOID, NvU32, NvU32 *, NvU32 *, int, NvU32 *);
BOOL NvGetSupportedClasses(PDEV *);

BOOL AllocDmaPushBuf(PDEV *ppdev);
VOID FreeDmaPushBuf(PDEV *ppdev);

BOOL AllocMemOncePerPdev(PDEV * ppdev);
VOID FreeMemOncePerPdev(PDEV * ppdev);

BOOL NvSetupContextDma(PDEV * ppdev);
VOID NvFreeContextDma(PDEV * ppdev);

BOOL NvSetupHwObjects(PDEV * ppdev);            
BOOL NvInitHwObjects(PDEV * ppdev);

ULONG OglSupportEnabled(PDEV *ppdev);
NV_OPENGL_CLIENT_INFO *OglFindClientInfoHWnd(PDEV *ppdev, HWND hWnd);
NV_OPENGL_CLIENT_INFO_LIST *OglFindClientInfoFromHWnd(PDEV *ppdev, HWND hWnd);

#if defined(_WIN64)
ULONG DrvEscape32(SURFOBJ *pso, ULONG iEsc,
                  ULONG cjIn, VOID *pvIn,
                  ULONG cjOut, VOID *pvOut);

VOID NvCopyStructIn (VOID *ptr32, VOID *ptr64, CHAR *fmt);
VOID NvCopyStructOut(VOID *ptr32, VOID *ptr64, CHAR *fmt);
#endif

extern BYTE gajHwMixFromMix[];
extern BYTE gaRop3FromMix[];
extern ULONG gaulHwMixFromRop2[];

/////////////////////////////////////////////////////////////////////////
// The x86 C compiler insists on making a divide and modulus operation
// into two DIVs, when it can in fact be done in one.  So we use this
// macro.
//
// Note: QUOTIENT_REMAINDER implicitly takes unsigned arguments.

#if defined(_X86_)

#define QUOTIENT_REMAINDER(ulNumerator, ulDenominator, ulQuotient, ulRemainder) \
{                                                               \
    __asm mov eax, ulNumerator                                  \
    __asm sub edx, edx                                          \
    __asm div ulDenominator                                     \
    __asm mov ulQuotient, eax                                   \
    __asm mov ulRemainder, edx                                  \
}

#else

#define QUOTIENT_REMAINDER(ulNumerator, ulDenominator, ulQuotient, ulRemainder) \
{                                                               \
    ulQuotient  = (ULONG) ulNumerator / (ULONG) ulDenominator;  \
    ulRemainder = (ULONG) ulNumerator % (ULONG) ulDenominator;  \
}

#endif

/////////////////////////////////////////////////////////////////////////
// OVERLAP - Returns TRUE if the same-size lower-right exclusive
//           rectangles defined by 'pptl' and 'prcl' overlap:

#define OVERLAP(prcl, pptl)                                             \
    (((prcl)->right  > (pptl)->x)                                   &&  \
     ((prcl)->bottom > (pptl)->y)                                   &&  \
     ((prcl)->left   < ((pptl)->x + (prcl)->right - (prcl)->left))  &&  \
     ((prcl)->top    < ((pptl)->y + (prcl)->bottom - (prcl)->top)))

/////////////////////////////////////////////////////////////////////////
// SWAP - Swaps the value of two variables, using a temporary variable

#define SWAP(a, b, tmp) { (tmp) = (a); (a) = (b); (b) = (tmp); }

//////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////
// CONVERT_TO_BYTES - Converts to byte count.

#define CONVERT_TO_BYTES(x, pdev)   ( (x) * pdev->cjPelSize)

//////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////
// CONVERT_FROM_BYTES - Converts to byte count.

#define CONVERT_FROM_BYTES(x, pdev) ( (x) / pdev->cjPelSize)

/////////////////////////////////////////////////////////////////////////
// Macro to determine if SURFOBJ is on primary screen
#define IS_SCREEN(pso)           (STYPE_DEVICE == pso->iType)
// Macro to determine if SURFOBJ any kind of devicebitmap
#define IS_DEVICEBITMAP(pso)     (STYPE_DEVBITMAP == pso->iType)
// Macro to determine if SURFOBJ a devicebitmap in device memory
#define IS_DEV_DEVICEBITMAP(pso) (IS_DEVICEBITMAP(pso) && (((DSURF *)pso->dhsurf)->dt == DT_SCREEN))
// Macro to determine if SURFOBJ a devicebitmap in host memory
#define IS_DIB_DEVICEBITMAP(pso) (IS_DEVICEBITMAP(pso) && (((DSURF *)pso->dhsurf)->dt == DT_DIB))
/////////////////////////////////////////////////////////////////////////
// Macro to determine if SURFOBJ is in framebuffer (device memory)
// NT4 doesn't have BMF_NOTSYSMEM or DrvDeriveSurface
#if _WIN32_WINNT >= 0x0500
#define IS_DEV_SURF(pso)   \
        (  IS_SCREEN(pso)  \
        || IS_DEV_DEVICEBITMAP(pso) \
        || (pso->fjBitmap & BMF_NOTSYSMEM) )
#else
#define IS_DEV_SURF(pso)   \
        (  IS_SCREEN(pso)  \
        || IS_DEV_DEVICEBITMAP(pso) )
#endif

/////////////////////////////////////////////////////////////////////////
// Macros used to access NV PRM regs.

#define PRMVIO_Base ppdev->PRMVIORegs
#define PRMCIO_Base ((PBYTE) (ppdev->PRMCIORegs))


//////////////////////////////////////////////////////////////////////

// These Mul prototypes are thunks for multi-board support:

ULONG   MulGetModes(HANDLE, ULONG, DEVMODEW*);
DHPDEV  MulEnablePDEV(DEVMODEW*, PWSTR, ULONG, HSURF*, ULONG, ULONG*,
                      ULONG, DEVINFO*, HDEV, PWSTR, HANDLE);
VOID    MulCompletePDEV(DHPDEV, HDEV);
HSURF   MulEnableSurface(DHPDEV);
BOOL    MulStrokePath(SURFOBJ*, PATHOBJ*, CLIPOBJ*, XFORMOBJ*, BRUSHOBJ*,
                      POINTL*, LINEATTRS*, MIX);
BOOL    MulFillPath(SURFOBJ*, PATHOBJ*, CLIPOBJ*, BRUSHOBJ*, POINTL*,
                    MIX, FLONG);
BOOL    MulBitBlt(SURFOBJ*, SURFOBJ*, SURFOBJ*, CLIPOBJ*, XLATEOBJ*,
                  RECTL*, POINTL*, POINTL*, BRUSHOBJ*, POINTL*, ROP4);
VOID    MulDisablePDEV(DHPDEV);
VOID    MulDisableSurface(DHPDEV);
BOOL    MulAssertMode(DHPDEV, BOOL);
VOID    MulMovePointer(SURFOBJ*, LONG, LONG, RECTL*);
ULONG   MulSetPointerShape(SURFOBJ*, SURFOBJ*, SURFOBJ*, XLATEOBJ*, LONG,
                           LONG, LONG, LONG, RECTL*, FLONG);
ULONG   MulDitherColor(DHPDEV, ULONG, ULONG, ULONG*);
BOOL    MulSetPalette(DHPDEV, PALOBJ*, FLONG, ULONG, ULONG);
BOOL    MulCopyBits(SURFOBJ*, SURFOBJ*, CLIPOBJ*, XLATEOBJ*, RECTL*, POINTL*);
BOOL    MulTextOut(SURFOBJ*, STROBJ*, FONTOBJ*, CLIPOBJ*, RECTL*, RECTL*,
                   BRUSHOBJ*, BRUSHOBJ*, POINTL*, MIX);
VOID    MulDestroyFont(FONTOBJ*);
BOOL    MulPaint(SURFOBJ*, CLIPOBJ*, BRUSHOBJ*, POINTL*, MIX);
BOOL    MulRealizeBrush(BRUSHOBJ*, SURFOBJ*, SURFOBJ*, SURFOBJ*, XLATEOBJ*,
                        ULONG);
HBITMAP MulCreateDeviceBitmap(DHPDEV, SIZEL, ULONG);
VOID    MulDeleteDeviceBitmap(DHSURF);
BOOL    MulStretchBlt(SURFOBJ*, SURFOBJ*, SURFOBJ*, CLIPOBJ*, XLATEOBJ*,
                      COLORADJUSTMENT*, POINTL*, RECTL*, RECTL*, POINTL*,
                      ULONG);

// These Dbg prototypes are thunks for debugging:

ULONG   DbgGetModes(HANDLE, ULONG, DEVMODEW*);
DHPDEV  DbgEnablePDEV(DEVMODEW*, PWSTR, ULONG, HSURF*, ULONG, ULONG*,
                      ULONG, DEVINFO*, HDEV, PWSTR, HANDLE);

VOID    DbgCompletePDEV(DHPDEV, HDEV);
VOID    DbgSynchronize(DHPDEV, RECTL *);
HSURF   DbgEnableSurface(DHPDEV);
BOOL    DbgLineTo(SURFOBJ*, CLIPOBJ*, BRUSHOBJ*, LONG, LONG, LONG, LONG,
                  RECTL*, MIX);
BOOL    DbgStrokePath(SURFOBJ*, PATHOBJ*, CLIPOBJ*, XFORMOBJ*, BRUSHOBJ*,
                      POINTL*, LINEATTRS*, MIX);
BOOL    DbgFillPath(SURFOBJ*, PATHOBJ*, CLIPOBJ*, BRUSHOBJ*, POINTL*,
                    MIX, FLONG);
BOOL    DbgBitBlt(SURFOBJ*, SURFOBJ*, SURFOBJ*, CLIPOBJ*, XLATEOBJ*,
                  RECTL*, POINTL*, POINTL*, BRUSHOBJ*, POINTL*, ROP4);
BOOL    DbgAlphaBlend(SURFOBJ*, SURFOBJ*, CLIPOBJ*, XLATEOBJ*, RECTL*,
                      RECTL*, BLENDOBJ*); 
BOOL    DbgTransparentBlt(SURFOBJ*, SURFOBJ*, CLIPOBJ*, XLATEOBJ*, RECTL*, RECTL*, ULONG, ULONG);
VOID    DbgDisablePDEV(DHPDEV);
VOID    DbgDisableSurface(DHPDEV);

BOOL    DbgAssertMode(DHPDEV, BOOL);

VOID    DbgMovePointer(SURFOBJ*, LONG, LONG, RECTL*);
ULONG   DbgSetPointerShape(SURFOBJ*, SURFOBJ*, SURFOBJ*, XLATEOBJ*, LONG,
                           LONG, LONG, LONG, RECTL*, FLONG);
ULONG   DbgDitherColor(DHPDEV, ULONG, ULONG, ULONG*);
BOOL    DbgSetPalette(DHPDEV, PALOBJ*, FLONG, ULONG, ULONG);
BOOL    DbgCopyBits(SURFOBJ*, SURFOBJ*, CLIPOBJ*, XLATEOBJ*, RECTL*, POINTL*);
BOOL    DbgTextOut(SURFOBJ*, STROBJ*, FONTOBJ*, CLIPOBJ*, RECTL*, RECTL*,
                   BRUSHOBJ*, BRUSHOBJ*, POINTL*, MIX);
VOID    DbgDestroyFont(FONTOBJ*);
BOOL    DbgPaint(SURFOBJ*, CLIPOBJ*, BRUSHOBJ*, POINTL*, MIX);
BOOL    DbgRealizeBrush(BRUSHOBJ*, SURFOBJ*, SURFOBJ*, SURFOBJ*, XLATEOBJ*,
                        ULONG);
HBITMAP DbgCreateDeviceBitmap(DHPDEV, SIZEL, ULONG);
VOID    DbgDeleteDeviceBitmap(DHSURF);
BOOL    DbgStretchBlt(SURFOBJ*, SURFOBJ*, SURFOBJ*, CLIPOBJ*, XLATEOBJ*,
                      COLORADJUSTMENT*, POINTL*, RECTL*, RECTL*, POINTL*,
                      ULONG);
ULONG   DbgEscape(SURFOBJ*, ULONG, ULONG, VOID*, ULONG, VOID*);
ULONG   DbgDrawEscape (SURFOBJ*, ULONG, CLIPOBJ*, RECTL*, ULONG, VOID*);
BOOL    DbgResetPDEV(DHPDEV, DHPDEV);

VOID NV3_SetSourceBase(PDEV *,ULONG,LONG);
VOID NV3_SetDestBase(PDEV *,ULONG,LONG);

VOID NvDDEnable(PDEV *ppdev);
NvU8 bCreateNVDDPatch(PDEV *ppdev);
NvU8 bDestroyNVDDPatch(PDEV *ppdev);

BOOL    DbgGetDirectDrawInfo(DHPDEV, DD_HALINFO*, DWORD*, VIDEOMEMORY*,
                             DWORD*, DWORD*);
BOOL    DbgEnableDirectDraw(DHPDEV, DD_CALLBACKS*, DD_SURFACECALLBACKS*,
                            DD_PALETTECALLBACKS*);
VOID    DbgDisableDirectDraw(DHPDEV);

#if _WIN32_WINNT >= 0x0500
BOOL    DbgIcmSetDeviceGammaRamp(DHPDEV,ULONG,LPVOID);
HBITMAP DbgDeriveSurface(DD_DIRECTDRAW_GLOBAL *, DD_SURFACE_LOCAL *);
void    DbgDrvNotify(SURFOBJ *, ULONG, PVOID);

#endif

#if DBG
    VOID    vAcquireCrtc(PDEV*);
    VOID    vReleaseCrtc(PDEV*);

    #define ACQUIRE_CRTC_CRITICAL_SECTION(ppdev)    vAcquireCrtc(ppdev)
    #define RELEASE_CRTC_CRITICAL_SECTION(ppdev)    vReleaseCrtc(ppdev)

#else

    /////////////////////////////////////////////////////////////////////////
    // Free Build
    //
    // For a free (non-debug build), we make everything in-line.

    // Safe port access macros -- these macros automatically do memory
    // -----------------------    barriers, so you don't have to worry
    //                            about them:

    // The CRTC register critical section must be acquired before
    // touching the CRTC register (because of async pointers):


    #define ACQUIRE_CRTC_CRITICAL_SECTION(ppdev)                \
        EngAcquireSemaphore(ppdev->csCrtc);

    #define RELEASE_CRTC_CRITICAL_SECTION(ppdev)                \
    {                                                           \
        EngReleaseSemaphore(ppdev->csCrtc);                     \
    }

#endif

//
// macro to access the hwGfxCaps which is initialized with NvConfigGet(..NV_CFG_GRAPHICS_CAPS..) (look nvcm.h)
//
#define HWGFXCAPS_MAXCLIPS(ppdev)       ((ppdev->hwGfxCaps >> NV_CFG_GRAPHICS_CAPS_MAXCLIPS_SHIFT) & NV_CFG_GRAPHICS_CAPS_MAXCLIPS_MASK)
#define HWGFXCAPS_QUADRO_GENERIC(ppdev) (ppdev->hwGfxCaps & NV_CFG_GRAPHICS_CAPS_QUADRO_GENERIC)
#define HWGFXCAPS_UBB(ppdev)            (ppdev->hwGfxCaps & NV_CFG_GRAPHICS_CAPS_UBB)


/*******************************************************************************
 *
 *    Useful information for OpenGL support.  Not guaranteed to work.
 *
 *******************************************************************************/


#define     OPENGL_CMD              4352
#define     OPENGL_GETINFO          4353
#define     NV_OPENGL_SET_ENABLE    0x6988
#define     OPENGL_GETINFO_DRVNAME  0

#define     OPENGL_ICD_VER          2
#define     OPENGL_DRIVER_VER       0x10000
#define     OPENGL_KEY_NAME_NV3     L"RIVA128"
#define     OPENGL_KEY_NAME_NV4     L"RIVATNT"

#define     ESC_ALLOC_CONTEXT_DMA                   0x6989
#define     ESC_FREE_CONTEXT_DMA                    0x698A
#define     ESC_ALLOC_CHANNEL_DMA                   0x698B
#define     ESC_FREE_CHANNEL_DMA                    0x698C
#define     ESC_DMA_FLOW_CONTROL                    0x698D
#define     ESC_SET_GAMMA_RAMP                      0x698E
#define     ESC_GET_GAMMA_RAMP                      0x698F
#define     ESC_SET_GAMMA_RAMP_MULTI                0x6990
#define     ESC_GET_GAMMA_RAMP_MULTI                0x6991
#define     ESC_GET_PIXEL_FORMAT                    0x7000
#define     ESC_NV_OPENGL_DMA_PUSH_GO               0x7001

#define DDI_VER_40 0x00020000

#define NV_DMA_SCANLINE_BUF_SIZE 32768

#ifndef NVD3D_DX6 // D3D driver conflicts
//*******************************************************************************
// Macros used to access NV registers.
//*******************************************************************************
#define REG_WR32(a,d)   ppdev->NvBaseAddr[(a)/4]=(U032)(d)
#define REG_RD32(a)     ppdev->NvBaseAddr[(a)/4]
#define REG_WR08(a,d)   ((V008 *)(ppdev->NvBaseAddr))[(a)]  =(U008)(d)
#define REG_RD08(a)     ((V008 *)(ppdev->NvBaseAddr))[(a)]

#define BIT(b)                  (1<<(b))
#define DEVICE_BASE(d)          (0?d)
#define DEVICE_EXTENT(d)        (1?d) - DEVICE_BASE(d) + 1
#define DRF_SHIFT(drf)          ((0?drf) % 32)
#define DRF_MASK(drf)           (0xFFFFFFFF>>(31-((1?drf) % 32)+((0?drf) % 32)))
#define DRF_DEF(d,r,f,c)        ((NV ## d ## r ## f ## c)<<DRF_SHIFT(NV ## d ## r ## f))
#define DRF_NUM(d,r,f,n)        (((n)&DRF_MASK(NV ## d ## r ## f))<<DRF_SHIFT(NV ## d ## r ## f))
#define DRF_VAL(d,r,f,v)        (((v)>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))
#define REG_WR_DRF_NUM(d,r,f,n) REG_WR32(NV ## d ## r, DRF_NUM(d,r,f,n))
#define REG_WR_DRF_DEF(d,r,f,c) REG_WR32(NV ## d ## r, DRF_DEF(d,r,f,c))
#define FLD_WR_DRF_NUM(d,r,f,n) REG_WR32(NV##d##r,(REG_RD32(NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define FLD_WR_DRF_DEF(d,r,f,c) REG_WR32(NV##d##r,(REG_RD32(NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define REG_RD_DRF(d,r,f)       (((REG_RD32(NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))
#endif // #ifndef NVD3D_DX6

#ifdef __cplusplus
}
#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\drawescape.h ===
//*****************************Module*Header******************************
//
// Module Name: drawescape.h
//
// FNicklisch 14.09.00: New: added from ELSA code
//
// Copyright (c) 2000 NVidia Corporation. All Rights Reserved.
//
#ifndef _DRAWESCAPE_H
#define _DRAWESCAPE_H



#endif // _DRAWESCAPE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\enable.c ===
/************************** Module Header *************************************
//                                                                             *
//  Module Name: enable.c                                                      *
//                                                                             *
//  This module contains the functions that enable and disable the             *
//  driver, the pdev, and the surface.                                         *
//                                                                             *
//  Copyright (c) 1992-1996 Microsoft Corporation                              *
//                                                                             *
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"
#include "driver.h"
#include "nvcm.h"
#include "ddminint.h"
#ifdef NVD3D
    #include "dx95type.h"
    #include "nvntd3d.h"
    #include "nvProcMan.h"
    #include "ddmini.h"
#endif
#include "oglDD.h"
#include "ogloverlay.h"
#include "oglutils.h"
#include "oglstereo.h"
#include "oglflip.h"
#include "nvdoublebuf.h"
#include "pixelfmt.h"
#include "linkedlist.h"
#include "savescreenbits.h"

// To get the NV11 twinview definitions
#include "nvMultiMon.h"

extern void FreeMemoryMultiMon(PDEV *ppdev);
extern BOOLEAN   TwinViewDataOK(PPDEV ppdev, NVTWINVIEWDATA *pData);
extern VOID ReadToshibaHotKeyMode(HANDLE      hDriver, TOSHIBA_HOTKEY_MODE *pMode);
extern VOID WriteToshibaHotKeyMode(HANDLE      hDriver, TOSHIBA_HOTKEY_MODE *pMode);

// 2 next functions are utils functions in nvMultiMon.c
//
extern void GetRegValueW(HANDLE hDriver, PWSTR keyName, PVOID keyData, ULONG keyDataSize);
extern void SetRegValueW(HANDLE hDriver, PWSTR keyName, PVOID keyData, ULONG keyDataSize);


extern BOOLEAN bQueryGDIModePruning(ULONG ulTwinView_State, ULONG ulPrimaryHead, ULONG ulPrimaryDeviceMask,
        ULONG ulHead, ULONG ulDeviceMask, ULONG ulACPISystem, ULONG ulGDIModePruning);

#if DBG
extern VOID GetDebugLevelRegValue(PPDEV ppdev);
#endif

#if defined(DX7) && (NVARCH >= 0x04)

#ifndef _WIN64
extern BOOL __stdcall nvDeterminePerformanceStrategy(GLOBALDATA *pDriverData, PDEV* ppdev);
#endif // D3D is not 64 bit code clean , skip for now...

#endif // DX7

// local prototypes
#ifdef NV3
BOOL bNV3CreateStdPatches(PDEV *ppdev);
VOID vNV3DestroyStdPatches(PDEV *ppdev, BOOL CreateStdPatchFailFlag);
#endif // NV3
VOID RenderRectangle(PDEV *ppdev);

VOID vCalibrate_XferSpeeds(PDEV *ppdev);    // Calibration routine to decide xfer chunk size
                                            // when doing a vram ram to sys mem xfer -steph


// save old client on list of PDEVs using this client

//******************************************************************************
//
//  GDIINFO ggdiDefault
//
//  This contains the default GDIINFO fields that are passed back to GDI
//  during DrvEnablePDEV.
//
//  NOTE: This structure defaults to values for an 8bpp palette device.
//        Some fields are overwritten for different colour depths.
//
//******************************************************************************

GDIINFO ggdiDefault = {
    GDI_DRIVER_VERSION,
    DT_RASDISPLAY,          // ulTechnology
    0,                      // ulHorzSize (filled in later)
    0,                      // ulVertSize (filled in later)
    0,                      // ulHorzRes (filled in later)
    0,                      // ulVertRes (filled in later)
    0,                      // cBitsPixel (filled in later)
    0,                      // cPlanes (filled in later)
    20,                     // ulNumColors (palette managed)
    0,                      // flRaster (DDI reserved field)

    0,                      // ulLogPixelsX (filled in later)
    0,                      // ulLogPixelsY (filled in later)

    TC_RA_ABLE,             // flTextCaps -- If we had wanted console windows
                            //   to scroll by repainting the entire window,
                            //   instead of doing a screen-to-screen blt, we
                            //   would have set TC_SCROLLBLT (yes, the flag is
                            //   bass-ackwards).

    0,                      // ulDACRed (filled in later)
    0,                      // ulDACGreen (filled in later)
    0,                      // ulDACBlue (filled in later)

    0x0024,                 // ulAspectX
    0x0024,                 // ulAspectY
    0x0033,                 // ulAspectXY (one-to-one aspect ratio)

    1,                      // xStyleStep
    1,                      // yStyleSte;
    3,                      // denStyleStep -- Styles have a one-to-one aspect
                            //   ratio, and every 'dot' is 3 pixels long

    { 0, 0 },               // ptlPhysOffset
    { 0, 0 },               // szlPhysSize

    256,                    // ulNumPalReg

    // These fields are for halftone initialization.  The actual values are
    // a bit magic, but seem to work well on our display.

    {                       // ciDevice
       { 6700, 3300, 0 },   //      Red
       { 2100, 7100, 0 },   //      Green
       { 1400,  800, 0 },   //      Blue
       { 1750, 3950, 0 },   //      Cyan
       { 4050, 2050, 0 },   //      Magenta
       { 4400, 5200, 0 },   //      Yellow
       { 3127, 3290, 0 },   //      AlignmentWhite
       20000,               //      RedGamma
       20000,               //      GreenGamma
       20000,               //      BlueGamma
       0, 0, 0, 0, 0, 0     //      No dye correction for raster displays
    },

    0,                       // ulDevicePelsDPI (for printers only)
    PRIMARY_ORDER_CBA,       // ulPrimaryOrder
    HT_PATSIZE_4x4_M,        // ulHTPatternSize
    HT_FORMAT_8BPP,          // ulHTOutputFormat
    HT_FLAG_ADDITIVE_PRIMS,  // flHTFlags
    0,                       // ulVRefresh
    0,                       // ulPanningHorzRes
    0,                       // ulPanningVertRes
    0,                       // ulBltAlignment
};

//*********************** Public cStructure *************************************
//
//  DEVINFO gdevinfoDefault
//
//  This contains the default DEVINFO fields that are passed back to GDI
//  during DrvEnablePDEV.
//
//  NOTE: This structure defaults to values for an 8bpp palette device.
//        Some fields are overwritten for different colour depths.
//
//******************************************************************************

#define SYSTM_LOGFONT {16,7,0,0,700,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,\
                       CLIP_DEFAULT_PRECIS,DEFAULT_QUALITY,\
                       VARIABLE_PITCH | FF_DONTCARE,L"System"}
#define HELVE_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,\
                       CLIP_STROKE_PRECIS,PROOF_QUALITY,\
                       VARIABLE_PITCH | FF_DONTCARE,L"MS Sans Serif"}
#define COURI_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,\
                       CLIP_STROKE_PRECIS,PROOF_QUALITY,\
                       FIXED_PITCH | FF_DONTCARE, L"Courier"}

DEVINFO gdevinfoDefault = {
    (GCAPS_OPAQUERECT       |
    GCAPS_MONO_DITHER       |
     GCAPS_DITHERONREALIZE  |
     GCAPS_ALTERNATEFILL    |
     GCAPS_WINDINGFILL      |
     GCAPS_COLOR_DITHER     //|
     //GCAPS_ASYNCMOVE
#ifndef NVGDI
      | GCAPS_DIRECTDRAW
#endif
      ),
    SYSTM_LOGFONT,                              // lfDefaultFont
    HELVE_LOGFONT,                              // lfAnsiVarFont
    COURI_LOGFONT,                              // lfAnsiFixFont
    0,                                          // cFonts
    BMF_8BPP,                                   // iDitherFormat
    8,                                          // cxDither
    8,                                          // cyDither
    0                                           // hpalDefault (filled in later)
};

#ifdef NVD3D
//*********************************************************************
// This is the GLOBALDATA struct used to store the default settings
// for each GLOBALDATA struct created dynamically at DrvEnablePDEV
// time.
//*********************************************************************
GLOBALDATA  DefaultGlobalData;


//******************************************************************************
// This semaphore is used by the DX and GDI drivers to synchronize access to the
// DX GLOBALDATA struct.
//******************************************************************************
ENGSAFESEMAPHORE  NvSem = {(HSEMAPHORE) 0, 0L};
#endif // NVD3D

//************************* Public Structure ***********************************
//
//  FUNCTION TABLE:    DFVFN gadrvfn[]
//
//  Build the driver function table gadrvfn with function index/address
//  pairs.  This table tells GDI which DDI calls we support, and their
//  location (GDI does an indirect call through this table to call us).
//
//  Why haven't we implemented DrvSaveScreenBits?  To save code.
//
//  When the driver doesn't hook DrvSaveScreenBits, USER simulates on-
//  the-fly by creating a temporary device-format-bitmap, and explicitly
//  calling DrvCopyBits to save/restore the bits.  Since we already hook
//  DrvCreateDeviceBitmap, we'll end up using off-screen memory to store
//  the bits anyway (which would have been the main reason for implementing
//  DrvSaveScreenBits).  So we may as well save some working set.
//
//******************************************************************************

#ifdef NT4_MULTI_DEV
extern DRVFN gadrvfn[];
extern ULONG gcdrvfn;
#else //#ifdef NT4_MULTI_DEV

#if MULTI_BOARDS

//******************************************************************************
// Multi-board support has its own thunks...
//******************************************************************************

DRVFN gadrvfn[] = {
    {   INDEX_DrvEnablePDEV,            (PFN) MulEnablePDEV         },
    {   INDEX_DrvCompletePDEV,          (PFN) MulCompletePDEV       },
    {   INDEX_DrvDisablePDEV,           (PFN) MulDisablePDEV        },
    {   INDEX_DrvEnableSurface,         (PFN) MulEnableSurface      },
    {   INDEX_DrvDisableSurface,        (PFN) MulDisableSurface     },
    {   INDEX_DrvAssertMode,            (PFN) MulAssertMode         },
    {   INDEX_DrvMovePointer,           (PFN) MulMovePointer        },
    {   INDEX_DrvSetPointerShape,       (PFN) MulSetPointerShape    },
    {   INDEX_DrvDitherColor,           (PFN) MulDitherColor        },
    {   INDEX_DrvSetPalette,            (PFN) MulSetPalette         },
    {   INDEX_DrvCopyBits,              (PFN) MulCopyBits           },
    {   INDEX_DrvBitBlt,                (PFN) MulBitBlt             },
    {   INDEX_DrvTextOut,               (PFN) MulTextOut            },
    {   INDEX_DrvGetModes,              (PFN) MulGetModes           },
    {   INDEX_DrvStrokePath,            (PFN) MulStrokePath         },
//  {   INDEX_DrvFillPath,              (PFN) MulFillPath           }, not supported
    {   INDEX_DrvPaint,                 (PFN) MulPaint              },
    {   INDEX_DrvRealizeBrush,          (PFN) MulRealizeBrush       },
    {   INDEX_DrvDestroyFont,           (PFN) MulDestroyFont        },
    // Note that we don't support DrvCreateDeviceBitmap for multi-boards
    // Note that we don't support DrvDeleteDeviceBitmap for multi-boards
    // Note that we don't support DrvStretchBlt for multi-boards
    // Note that we don't support DrvLineTo for multi-boards
    // Note that we don't support DrvEscape for multi-boards
    // Note that we don't support DrvDirectDraw functions for multi-boards
};

#elif DBG && !defined(QUIET)

//******************************************************************************
// On Checked builds, thunk everything through Dbg calls...
//******************************************************************************

DRVFN gadrvfn[] = {
    {   INDEX_DrvEnablePDEV,            (PFN) DbgEnablePDEV         },
    {   INDEX_DrvCompletePDEV,          (PFN) DbgCompletePDEV       },
    {   INDEX_DrvDisablePDEV,           (PFN) DbgDisablePDEV        },
    {   INDEX_DrvEnableSurface,         (PFN) DbgEnableSurface      },
    {   INDEX_DrvDisableSurface,        (PFN) DbgDisableSurface     },
    {   INDEX_DrvAssertMode,            (PFN) DbgAssertMode         },
    {   INDEX_DrvMovePointer,           (PFN) DbgMovePointer        },
    {   INDEX_DrvSetPointerShape,       (PFN) DbgSetPointerShape    },
    {   INDEX_DrvDitherColor,           (PFN) DbgDitherColor        },
    {   INDEX_DrvSetPalette,            (PFN) DbgSetPalette         },
    {   INDEX_DrvCopyBits,              (PFN) DbgCopyBits           },
    {   INDEX_DrvBitBlt,                (PFN) DbgBitBlt             },
    {   INDEX_DrvTextOut,               (PFN) DbgTextOut            },
    {   INDEX_DrvGetModes,              (PFN) DbgGetModes           },
    {   INDEX_DrvLineTo,                (PFN) DbgLineTo             },
    {   INDEX_DrvStrokePath,            (PFN) DbgStrokePath         },
//    {   INDEX_DrvFillPath,              (PFN) DbgFillPath           }, // not suppported
    {   INDEX_DrvPaint,                 (PFN) DbgPaint              },
    {   INDEX_DrvRealizeBrush,          (PFN) DbgRealizeBrush       },
    {   INDEX_DrvCreateDeviceBitmap,    (PFN) DbgCreateDeviceBitmap },
    {   INDEX_DrvDeleteDeviceBitmap,    (PFN) DbgDeleteDeviceBitmap },
//  {   INDEX_DrvStretchBlt,            (PFN) DbgStretchBlt         }, // not implemented or hooked
    {   INDEX_DrvDestroyFont,           (PFN) DbgDestroyFont        },
#ifndef NVGDI
    {   INDEX_DrvGetDirectDrawInfo,     (PFN) DrvGetDirectDrawInfo  },
    {   INDEX_DrvEnableDirectDraw,      (PFN) DrvEnableDirectDraw   },
    {   INDEX_DrvDisableDirectDraw,     (PFN) DrvDisableDirectDraw  },
#endif
    {   INDEX_DrvSynchronize,           (PFN) DbgSynchronize        },
    {   INDEX_DrvEscape,                (PFN) DbgEscape             },
    {   INDEX_DrvDrawEscape,            (PFN) DbgDrawEscape         },
    {   INDEX_DrvResetPDEV,             (PFN) DbgResetPDEV          },
    {   INDEX_DrvDescribePixelFormat,   (PFN) DrvDescribePixelFormat},
    {   INDEX_DrvSetPixelFormat,        (PFN) DrvSetPixelFormat     },
    {   INDEX_DrvSwapBuffers,           (PFN) DrvSwapBuffers        },

    #if _WIN32_WINNT >= 0x0500
    {   INDEX_DrvIcmSetDeviceGammaRamp, (PFN) DbgIcmSetDeviceGammaRamp},
    {   INDEX_DrvDeriveSurface,         (PFN) DbgDeriveSurface},
    {   INDEX_DrvNotify,                (PFN) DbgDrvNotify},
    #ifndef NV3
    {   INDEX_DrvAlphaBlend,            (PFN) DbgAlphaBlend},           // not supported in nv3
    {   INDEX_DrvTransparentBlt,        (PFN) DbgTransparentBlt},       // not supported in nv3
    #endif
    #endif
#if (NVARCH >= 0x4)
    {   INDEX_DrvSaveScreenBits,        (PFN) DrvSaveScreenBits     },
#endif
};
#else

//******************************************************************************
// On Free builds, directly call the appropriate functions...
//******************************************************************************

DRVFN gadrvfn[] = {
    {   INDEX_DrvEnablePDEV,            (PFN) DrvEnablePDEV         },
    {   INDEX_DrvCompletePDEV,          (PFN) DrvCompletePDEV       },
    {   INDEX_DrvDisablePDEV,           (PFN) DrvDisablePDEV        },
    {   INDEX_DrvEnableSurface,         (PFN) DrvEnableSurface      },
    {   INDEX_DrvDisableSurface,        (PFN) DrvDisableSurface     },
    {   INDEX_DrvAssertMode,            (PFN) DrvAssertMode         },
    {   INDEX_DrvMovePointer,           (PFN) DrvMovePointer        },
    {   INDEX_DrvSetPointerShape,       (PFN) DrvSetPointerShape    },
    {   INDEX_DrvDitherColor,           (PFN) DrvDitherColor        },
    {   INDEX_DrvSetPalette,            (PFN) DrvSetPalette         },
    {   INDEX_DrvCopyBits,              (PFN) DrvCopyBits           },
    {   INDEX_DrvBitBlt,                (PFN) DrvBitBlt             },
    {   INDEX_DrvTextOut,               (PFN) DrvTextOut            },
    {   INDEX_DrvGetModes,              (PFN) DrvGetModes           },
    {   INDEX_DrvLineTo,                (PFN) DrvLineTo             },
    {   INDEX_DrvStrokePath,            (PFN) DrvStrokePath         },
//    {   INDEX_DrvFillPath,              (PFN) DrvFillPath           }, // not supported
    {   INDEX_DrvPaint,                 (PFN) DrvPaint              },
    {   INDEX_DrvRealizeBrush,          (PFN) DrvRealizeBrush       },
    {   INDEX_DrvCreateDeviceBitmap,    (PFN) DrvCreateDeviceBitmap },
    {   INDEX_DrvDeleteDeviceBitmap,    (PFN) DrvDeleteDeviceBitmap },
//  {   INDEX_DrvStretchBlt,            (PFN) DrvStretchBlt         }, // not implemented or hooked
    {   INDEX_DrvDestroyFont,           (PFN) DrvDestroyFont        },
#ifndef NVGDI
    {   INDEX_DrvGetDirectDrawInfo,     (PFN) DrvGetDirectDrawInfo  },
    {   INDEX_DrvEnableDirectDraw,      (PFN) DrvEnableDirectDraw   },
    {   INDEX_DrvDisableDirectDraw,     (PFN) DrvDisableDirectDraw  },
#endif
    {   INDEX_DrvSynchronize,           (PFN) DrvSynchronize        },
    {   INDEX_DrvEscape,                (PFN) DrvEscape             },
    {   INDEX_DrvDrawEscape,            (PFN) DrvDrawEscape         },
    {   INDEX_DrvResetPDEV,             (PFN) DrvResetPDEV          },
    {   INDEX_DrvDescribePixelFormat,   (PFN) DrvDescribePixelFormat},
    {   INDEX_DrvSetPixelFormat,        (PFN) DrvSetPixelFormat     },
    {   INDEX_DrvSwapBuffers,           (PFN) DrvSwapBuffers        },

    #if _WIN32_WINNT >= 0x0500
    {   INDEX_DrvIcmSetDeviceGammaRamp, (PFN) DrvIcmSetDeviceGammaRamp},
    {   INDEX_DrvDeriveSurface,         (PFN) DrvDeriveSurface},
    {   INDEX_DrvNotify,                (PFN) DrvNotify},
    #ifndef NV3
    {   INDEX_DrvAlphaBlend,            (PFN) DrvAlphaBlend},           // not supported in nv3
    {   INDEX_DrvTransparentBlt,        (PFN) DrvTransparentBlt},       // not supported in nv3
    #endif
    #endif
#if (NVARCH >= 0x4)
    {   INDEX_DrvSaveScreenBits,        (PFN) DrvSaveScreenBits     },
#endif
};
#endif

ULONG gcdrvfn = sizeof(gadrvfn) / sizeof(DRVFN);

#endif // NT4_MULTI_DEV


//******************************************************************************
//
//  Function:   GetDisplayUniqueness
//
//  Routine Description:
//
//      Returns the display uniqueness.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

ULONG GetDisplayUniqueness(PDEV *ppdev)
    {
    return ppdev->iUniqueness;
    }

//******************************************************************************
//
//  Function:   DrvResetPDEV
//
//  Routine Description:
//
//      Notifies the driver of a dynamic mode change.
//
//  Arguments:
//
//  Return Value:
//
//      TRUE : okay, now GDI is allowed to continue with the mode switch
//      FALSE: Stop with the mode switch, return to the old mode. This causes
//             GDI to open a dialog that a reboot is necessary!
//
//******************************************************************************


BOOL DrvResetPDEV(
DHPDEV dhpdevOld,
DHPDEV dhpdevNew)

    {
    PDEV* ppdevNew = (PDEV*) dhpdevNew;
    PDEV* ppdevOld = (PDEV*) dhpdevOld;
    ULONG                       i;
    NV_OPENGL_GLOBAL_DATA*      nvGlobalData;
    long                        status;
    ULONG                       ulTemp;
    HSEMAPHORE                  csFifoTemp;
    NV_OPENGL_CLIENT_INFO      *clientInfo;
    BOOL                        bRet = FALSE; // default error exit

    // Do some test for OpenGL that might cause problems
    // in the new resolution
    if (!bOglResetPDEV(ppdevOld, ppdevNew))
        goto Exit;

    ppdevNew->iUniqueness             = ppdevOld->iUniqueness + 1;
#ifdef NVD3D
    ppdevNew->bDXGblStateInitialized = ppdevOld->bDXGblStateInitialized;
#endif // NVD3D
    ppdevOld->pfnAcquireOglMutex(ppdevOld);

    ppdevNew->dwGlobalModeSwitchCount = ppdevOld->dwGlobalModeSwitchCount;

    if (HWGFXCAPS_QUADRO_GENERIC(ppdevOld))
    {
        // The reference counter must be unique as long as the system isn't rebooted
        ppdevNew->ulSaveScreenBitsRefCounter = ppdevOld->ulSaveScreenBitsRefCounter;
        bSaveScreenBitsGarbageCollection(ppdevOld, 0); // remove all elements we've collected (GDI bug)
    }

    if (ppdevOld->oglGlobalPageMdl)
        {
        // This swap is done because we can't have global memory
        // allocated within the display driver.  PDEV is local
        // to current instantiation so we swap memory old and new
        // pointers and information.
        //
        // Swap new and old OGL pointers.  The old OGL pointer
        // is in use by clients so we can't free it but we can free
        // the new one.  So, swap them and the new one will get freed
        // when the disable PDEV call is made.
        //
        ULONG *oglGlobalPagePtr;           // OGL mutex lock variable
        ULONG oglGlobalPageSize;           // OGL mutex lock size in bytes
        PVOID oglGlobalPageMdl;            // MDL to locked down mutex page
        PVOID origOglGlobalPagePtr;        // OGL Ptr for allocated memory

        // tmp = New
        oglGlobalPagePtr  = ppdevNew->oglGlobalPagePtr;
        oglGlobalPageSize = ppdevNew->oglGlobalPageSize;
        oglGlobalPageMdl  = ppdevNew->oglGlobalPageMdl;
        origOglGlobalPagePtr = ppdevNew->origOglGlobalPagePtr;

        // New = Old
        ppdevNew->oglGlobalPagePtr  = ppdevOld->oglGlobalPagePtr;
        ppdevNew->oglGlobalPageSize = ppdevOld->oglGlobalPageSize;
        ppdevNew->oglGlobalPageMdl  = ppdevOld->oglGlobalPageMdl;
        ppdevNew->origOglGlobalPagePtr = ppdevOld->origOglGlobalPagePtr;

        // old = tmp
        ppdevOld->oglGlobalPagePtr  = oglGlobalPagePtr;
        ppdevOld->oglGlobalPageSize = oglGlobalPageSize;
        ppdevOld->oglGlobalPageMdl  = oglGlobalPageMdl;
        ppdevOld->origOglGlobalPagePtr = origOglGlobalPagePtr;

        nvGlobalData = (NV_OPENGL_GLOBAL_DATA *)ppdevNew->oglGlobalPagePtr;
        if (nvGlobalData)
            {
            ppdevNew->oglMutexPtr      = &nvGlobalData->oglMutex;
            ppdevNew->oglModeSwitchPtr = &nvGlobalData->oglModeSwitch;
            }

        nvGlobalData = (NV_OPENGL_GLOBAL_DATA *)ppdevOld->oglGlobalPagePtr;
        if (nvGlobalData)
            {
            ppdevOld->oglMutexPtr      = &nvGlobalData->oglMutex;
            ppdevOld->oglModeSwitchPtr = &nvGlobalData->oglModeSwitch;
            }
        }

    OglAcquireGlobalMutex();
    if (globalOpenGLData.oglClientListHead.clientList)
        {
        globalOpenGLData.oglClientListHead.clientList->refCount++;
        }


    // Update width and height of screen in each node.
    clientInfo = NULL; // start search at top of list
    while (bOglGetNextClient(&clientInfo))
        {
        NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo;

        ASSERT(bOglHasDrawableInfo(clientInfo));

#ifdef NV_MAIN_MULTIMON
        // NOTE: We want to check the old PDEV with
        // the one inside the clientInfo, so in a 
        // Multi-Monitor situation, we don't update
        // clients with the modeset PDEV.  Since we
        // keep multiple clients per-app/per-monitor,
        // we would end up having all the clients
        // point to the same monitor.  This is bad.
        if ( clientInfo->ppdev == ppdevOld ) {
            clientInfo->ppdev  = ppdevNew;
            clientDrawableInfo = clientInfo->clientDrawableInfo;
            if (clientDrawableInfo)
                {
                clientDrawableInfo->cxScreen = ppdevNew->cxScreen;
                clientDrawableInfo->cyScreen = ppdevNew->cyScreen;
                clientDrawableInfo->cxcyChanged = 1;
                }
            }
        }
#else
        clientInfo->ppdev  = ppdevNew;
        clientDrawableInfo = clientInfo->clientDrawableInfo;
        if (clientDrawableInfo)
            {
            clientDrawableInfo->cxScreen = ppdevNew->cxScreen;
            clientDrawableInfo->cyScreen = ppdevNew->cyScreen;
            clientDrawableInfo->cxcyChanged = 1;
            }
        }
#endif


    OglReleaseGlobalMutex();

    // release mutex taken with previous ppdevOld->pfnAcquireOglMutex(ppdevOld);
    ulTemp = ppdevNew->bReleaseOglMutex;
    ppdevNew->bReleaseOglMutex = ppdevOld->bReleaseOglMutex;
    ppdevOld->bReleaseOglMutex = ulTemp;

    csFifoTemp = ppdevNew->csFifo;
    ppdevNew->csFifo = ppdevOld->csFifo;
    ppdevOld->csFifo = csFifoTemp;

    ppdevNew->bSupportOgl = ppdevOld->bSupportOgl;

    OglEnableModeSwitchUpdate(ppdevNew);

    ppdevNew->pfnReleaseOglMutex(ppdevNew);

    // we need to do this when switching back to a previously left desktopsize
    ppdevNew->oglDDrawSurfaceCount = 0;
    bClearPointerList(&ppdevNew->oglDDrawSurfaceCountList);

    // Transfer the state of the NVSVC service from the old prev to the new pdev.
    ppdevNew->ulNVSVCStatus = ppdevOld->ulNVSVCStatus;

    bRet = TRUE;
Exit:
    return(bRet);
    }


//******************************************************************************
//
//  Function:   DrvEnableDriver
//
//  Routine Description:
//
//      Enables the driver by retrieving the drivers function table and version.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

BOOL DrvEnableDriver(
ULONG          iEngineVersion,
ULONG          cj,
DRVENABLEDATA* pded)

    {
    //**************************************************************************
    // Engine Version is passed down so future drivers can support previous
    // engine versions.  A next generation driver can support both the old
    // and new engine conventions if told what version of engine it is
    // working with.  For the first version the driver does nothing with it.
    //**************************************************************************
    //**************************************************************************
    // Fill in as much as we can.
    //**************************************************************************
    if (cj >= sizeof(DRVENABLEDATA))
        pded->pdrvfn = gadrvfn;

    if (cj >= (sizeof(ULONG) * 2))
        pded->c = gcdrvfn;

    //**************************************************************************
    // DDI version this driver was targeted for is passed back to engine.
    // Future graphic's engine may break calls down to old driver format.
    //**************************************************************************

    if (cj >= sizeof(ULONG))

#if _WIN32_WINNT >= 0x0500  // Win2k or later OS
        pded->iDriverVersion = DDI_DRIVER_VERSION_NT5;
#else // NT4 build uses NT4 DDK, so use version available in NT4 DDK WINDDI.H
        pded->iDriverVersion = DDI_DRIVER_VERSION;
#endif

    //**************************************************************************
    // Save the DDI version so we can tell the miniport which version of NT is running.
    //**************************************************************************
    //iOsVersion = iEngineVersion;

#if defined(DX7) && (NVARCH >= 0x04)

    //**************************************************************************
    // Create the semaphore used to sync access to the DX GLOBALDATA
    //**************************************************************************
    EngInitializeSafeSemaphore(&NvSem);

    //**************************************************************************
    // Initialize data which is GLOBAL to the DX7 driver. This data is not
    // associated with a particular device.
    //**************************************************************************
#ifndef _WIN64
    NvWin2KInitDXGlobals();
#endif // D3D is not 64 bit code clean , skip for now...

#endif  // DX7

    OglInitLayerPalette();

#ifdef NV_MAIN_MULTIMON
    /* Initialize the global PDEV list for OpenGL. */
    OglInitPDEVList();
#endif

    return(TRUE);
    }

//******************************************************************************
//
//  Function:   DrvDisableDriver
//
//  Routine Description:
//
//      Tells the driver it is being disabled. Release any resources allocated in
//      DrvEnableDriver.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID DrvDisableDriver(VOID)
    {
#if defined(DX7) && (NVARCH >= 0x04)
    //**************************************************************************
    // Create the semaphore used to sync access to the DX GLOBALDATA
    //**************************************************************************
    EngDeleteSafeSemaphore(&NvSem);
#endif  // DX7

#ifdef NV_MAIN_MULTIMON
    /* Destroy the global PDEV list for OpenGL. */
    OglDestroyPDEVList();
#endif

    return;
    }

//******************************************************************************
//
//  Function:   DrvEnablePDEV
//
//  Routine Description:
//
//    Initializes a bunch of fields for GDI, based on the mode we've been asked
//    to do.  This is the first thing called after DrvEnableDriver, when GDI
//    wants to get some information about us.
//
//    (This function mostly returns back information; DrvEnableSurface is used
//    for initializing the hardware and driver components.)
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

DHPDEV DrvEnablePDEV(
        DEVMODEW*   pdm,            // Contains data pertaining to REQUESTED MODE
        PWSTR       pwszLogAddr,    // Logical address
        ULONG       cPat,           // Count of standard patterns
        HSURF*      phsurfPatterns, // Buffer for standard patterns
        ULONG       cjCaps,         // Size of buffer for device caps 'pdevcaps'
        ULONG*      pdevcaps,       // Buffer for device caps, also known as 'gdiinfo'
        ULONG       cjDevInfo,      // Number of bytes in device info 'pdi'
        DEVINFO*    pdi,            // Device information
        HDEV        hdev,           // HDEV, used for callbacks
        PWSTR       pwszDeviceName, // Device name
        HANDLE      hDriver)        // Kernel driver handle

{
    PDEV* ppdev;
    ULONG ReturnedDataLength;
    NV_COMMON_DEVICE_INFO CommonDeviceInfo;

    //**************************************************************************
    // Future versions of NT had better supply 'devcaps' and 'devinfo'
    // structures that are the same size or larger than the current
    // structures:
    //**************************************************************************
    if ((cjCaps < sizeof(GDIINFO)) || (cjDevInfo < sizeof(DEVINFO)))
        {
        DISPDBG((2, "DrvEnablePDEV - Buffer size too small"));
        goto ReturnFailure0;
        }

    //**************************************************************************
    // Allocate a physical device structure.  Note that we definitely
    // rely on the zero initialization:
    //**************************************************************************

    ppdev = EngAllocMem(FL_ZERO_MEMORY, sizeof(PDEV), ALLOC_TAG);
    if (ppdev == NULL)
        {
        DISPDBG((2, "DrvEnablePDEV - Failed EngAllocMem"));
        goto ReturnFailure0;
        }
    memset(ppdev, 0, sizeof(PDEV));

    ppdev->hDriver = hDriver;
#if DBG
    GetDebugLevelRegValue(ppdev);
#endif

    if (ppdev && pdm)
    {
        DISPDBG((6,"DrvEnablePDev(): ppdev: 0x%x, requesting mode: (%d, %d), %d bpp, %d HZ\n",
            ppdev,pdm->dmPelsWidth,pdm->dmPelsHeight,pdm->dmBitsPerPel,pdm->dmDisplayFrequency));
    }

    //********************************************************************
    // Store our 'Unique' signature in the PPDEV
    //********************************************************************

    ppdev->NVSignature = NV_SIGNATURE;

    //********************************************************************
    // Store global settings in the PDEV. BUGBUG: GLOBAL VARS NOT ALLOWED!!!
    //********************************************************************

    ppdev->bEnableIF09 = TRUE; //bEnableIF09;

    //**************************************************************************
    //
    // OpenGL code:
    //
    // Create OGL mutex pointer and lock down the memory page
    //
    //**************************************************************************
    CreateOglGlobalMemory(ppdev);
    ppdev->bSupportOgl = (ULONG)TRUE; // Enable OpenGL support by default

#ifdef NV_MAIN_MULTIMON
    /* Add the ppdev to the global PDEV list for OpenGL.  See oglmultimon.c */
    OglAddPDEVToList(ppdev);
#endif

#ifdef NV3
        ppdev->bOglSingleBackDepthSupported = (ULONG)FALSE; // Not available on NV3
#else        
        ppdev->bOglSingleBackDepthSupported = (ULONG)TRUE; // Enable single-back-depth surfaces
#endif // NV3

    ppdev->DoubleBuffer.bEnabled = FALSE;

    

    //**************************************************************************
    // Get the current screen mode information.  Set up device caps and
    // devinfo:
    //**************************************************************************

    if (!bInitializeModeFields(ppdev, (GDIINFO*) pdevcaps, pdi, pdm))
        {
        DISPDBG((2, "DrvEnablePDEV - Failed bInitializeModeFields"));
        goto ReturnFailure1;
        }

    //**************************************************************************
    // Save position relative to desktop (0,0 on single monitor system and
    // relative to primary display on multi-monitor system)
    //**************************************************************************
#if _WIN32_WINNT >= 0x0500
    ppdev->left = pdm->dmPosition.x;
    ppdev->top = pdm->dmPosition.y;
#else
    // ASSUME NT4 builds...
    // will be set by NT4 multiboard wrapper
    ppdev->left = 0;
    ppdev->top = 0;
#endif // NVD3D

    //**************************************************************************
    // Initialize palette information.
    //**************************************************************************

    if (!bInitializePalette(ppdev, pdi))
        {
        DISPDBG((2, "DrvEnablePDEV - Failed bInitializePalette"));
        goto ReturnFailure1;
        }

    //**************************************************************************
    // We are running a version of NT which is >= 4.0. This means we can safely
    // enable P6 write combining when mapping the framebuffer. The following IOCTL
    // sets a flag in the device state which tells the miniport to do just that.
    // This needs to be done for every physical NV device enabled by this driver.
    //**************************************************************************
    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_ENABLE_WRITE_COMBINING,
                           NULL,
                           0,
                           NULL,
                           0,
                           &ReturnedDataLength))
        {
        DISPDBG((1, "DrvEnablePDEV - IOCTL_VIDEO_ENABLE_WRITE_COMBINING failed"));
        }

    //
    // Get common device information from miniport
    //
    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_GET_COMMON_DEVICE_INFO,
                           NULL,
                           0,
                           &CommonDeviceInfo,
                           sizeof(NV_COMMON_DEVICE_INFO),
                           &ReturnedDataLength))
    {
        DISPDBG((1, "DrvEnablePDEV - VIDEO_GET_COMMON_DEVICE_INFO failed"));
        goto ReturnFailure1;
    }
    ppdev->ulDeviceReference   = CommonDeviceInfo.ulDeviceReference;
    ppdev->ulEnableDualView    = CommonDeviceInfo.ulEnableDualView;
    ppdev->ulDualViewSecondary = CommonDeviceInfo.ulDualViewSecondary;
#if _WIN32_WINNT >= 0x0500
    ppdev->OsVersionInfo       = CommonDeviceInfo.OsVersionInfo;
    ppdev->SysMemInfo          = CommonDeviceInfo.SysMemInfo;
#endif // _WIN32_WINNT >= 0x0500

    //**************************************************************************
    // Get the OGL stencil registry switch
    //**************************************************************************

    ppdev->OglStencilSwitch = FALSE;

    if (EngDeviceIoControl(
            ppdev->hDriver,
            IOCTL_VIDEO_GET_OGL_STENCIL_SWITCH,
            NULL,
            0,
            &ppdev->OglStencilSwitch,
            sizeof(DWORD),
            &ReturnedDataLength))
    {
        DISPDBG((1, "DrvEnablePDEV - VIDEO_GET_OGL_STENCIL_SWITCH failed"));
    }


    // On NT4, there is no global DriverData struct.  Here we allocate and 
        // hang it on the PDEV.
        //
#if IS_WINNT4
    if (ppdev->pDriverData == NULL)
    {
        ppdev->pDriverData = EngAllocMem(FL_ZERO_MEMORY, sizeof(GLOBALDATA), ALLOC_TAG);
        if (ppdev->pDriverData == NULL)
        {
            goto ReturnFailure1;
        }
        ppdev->pDriverData->ppdev = ppdev;
    }
#endif

#if defined(DX7) && !defined(_WIN64) && (NVARCH >=0x04)
    if (NvWin2KAllocDriverData(ppdev))
    {
        DISPDBG((1, "DrvEnablePDEV - Allocation of DX7 GLOBALDATA failed"));
        goto ReturnFailure1;
    }

    //**************************************************************************
    // Initialize fixed 'global' data which is device specific (fixed on a
    // per device basis).
    //**************************************************************************
    nvDeterminePerformanceStrategy(ppdev->pDriverData, ppdev);
    ppdev->pDriverData->NvSemRefCnt = 0;

#endif  // DX7

    //**************************************************************************
    // Initialize nvidia class list structure
    //**************************************************************************
    ppdev->nvNumClasses = 0;
    ppdev->nvClassList = NULL;

    //**************************************************************************
    // Fill in the Eng..() procs with the default GDI routines.
    // This gets overloaded with the NV_Eng.._DBLBUF() procs in nvdoublebuf.c
    // when we are in double buffer mode
    //**************************************************************************
    ppdev->pfnEngBitBlt     = EngBitBlt;
    ppdev->pfnEngCopyBits   = EngCopyBits;
    ppdev->pfnEngTextOut    = EngTextOut;
    ppdev->pfnEngLineTo     = EngLineTo;
    ppdev->pfnEngStrokePath = EngStrokePath;
#if _WIN32_WINNT >= 0x0500
    ppdev->pfnEngAlphaBlend = EngAlphaBlend;
    ppdev->pfnEngTransparentBlt = EngTransparentBlt;
#endif

    //
    // Clear the default request for NVSVC to induce a modeset. It will be set later in HandleBiosHeads()
    // if needed. Also set the default status of NVSVC as stopped.
    //
    ppdev->ulInduceModeChangeDeviceMask = 0;
    ppdev->ulNVSVCStatus = NVSVC_STATUS_STOPPED;

    return((DHPDEV) ppdev);

ReturnFailure1:
    DrvDisablePDEV((DHPDEV) ppdev);

ReturnFailure0:
    DISPDBG((1, "Failed DrvEnablePDEV"));

    return(0);
    }

//******************************************************************************
//
//  Function:   DrvDisablePDEV
//
//  Routine Description:
//
//     Release the resources allocated in DrvEnablePDEV.  If a surface has been
//     enabled DrvDisableSurface will have already been called.
//
//     Note that this function will be called when previewing modes in the
//     Display Applet, but not at system shutdown.  If you need to reset the
//     hardware at shutdown, you can do it in the miniport by providing a
//     'HwResetHw' entry point in the VIDEO_HW_INITIALIZATION_DATA structure.
//
//     Note: In an error, we may call this before DrvEnablePDEV is done.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID DrvDisablePDEV(DHPDEV dhpdev)
{
    PDEV* ppdev;

    ppdev = (PDEV*) dhpdev;

    vUninitializePalette(ppdev);

#if IS_WINNT4
    if (ppdev->pDriverData != NULL)
    {
        EngFreeMem(ppdev->pDriverData);
        ppdev->pDriverData = NULL;
    }
#endif

    //**************************************************************************
    //
    // OpenGL code:
    //
    // Destroy OGL mutex pointer and unlock down the memory page
    //
    //**************************************************************************
    DestroyOglGlobalMemory(ppdev);

#ifdef NV_MAIN_MULTIMON
    /* Remove the ppdev from the global PDEV list for OpenGL.  See oglmultimon.c */    
    OglRemovePDEVFromList(ppdev);
#endif

    // Free up any memory alloced by display driver for multimon purposes.
    FreeMemoryMultiMon(ppdev);

    EngFreeMem(ppdev);
}

//******************************************************************************
//
//  Function:   DrvCompletePDEV
//
//  Routine Description:
//
//      Store the HPDEV, the engines handle for this PDEV, in the DHPDEV.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID DrvCompletePDEV(
DHPDEV dhpdev,
HDEV   hdev)
{
    ((PDEV*) dhpdev)->hdevEng = hdev;
}

//******************************************************************************
//
//  Function:   DrvSynchronize
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID DrvSynchronize(DHPDEV dhpdev, RECTL  *prcl)
{
    PDEV*           ppdev;

    ppdev = (PDEV *)dhpdev;

    //**************************************************************************
    // Call the NV1/NV3/NV4 specific version of 'waiting while the engine is busy' routine
    //**************************************************************************

    ppdev->pfnWaitEngineBusy( ppdev );

    return;
}


#define CALIBRATION_ENABLED // enable calibration in DrvEnableSurface



//******************************************************************************
//
//  Function:   HSURF DrvEnableSurface
//
//      Creates the drawing surface, initializes the hardware, and initializes
//      driver components.  This function is called after DrvEnablePDEV, and
//      performs the final device initialization.
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

HSURF DrvEnableSurface(
DHPDEV dhpdev)
    {
    PDEV*   ppdev;
    HSURF   hsurf;
    DSURF*  pdsurf;
    BYTE*   TextureDataPtr;
    ULONG   i;
    PULONG  pulBmp;
    PULONG DMABufferStart;
    PULONG DMABufferEnd;
    PULONG VRAMStart;
    PULONG VRAMEnd;
    BOOL   UseDFBPrimary;
    ppdev = (PDEV*) dhpdev;

    // Turn off the DrvAssertMode flag.
    ppdev->ulDrvAssertModeTRUE = 0;

    //**************************************************************************
    // First enable all the subcomponents.
    //
    // Note that the order in which these 'Enable' functions are called
    // may be significant in low off-screen memory conditions, because
    // the off-screen heap manager may fail some of the later
    // allocations...
    //**************************************************************************

    //**************************************************************************
    // EnableHardware mainly does 4 things:
    //      1) Gets access to framebuffer memory
    //      2) Gets access to miscellaneous memory mapped hardware registers
    //      3) Sets the mode, then fills in the ppdev fields (AssertModeHardware)
    //      4) Init the function table (NV1 functions vs NV3 functions)
    //**************************************************************************


    if (!bEnableHardware(ppdev))
        goto ReturnFailure;

    //**************************************************************************
    // Call the NV1/NV3 specific version of 'waiting while the engine is busy' routine
    // ??? NEED TO INCLUDE THIS TO PREVENT INCONSISTENT LOCKUP ???
    //**************************************************************************

    ppdev->pfnWaitEngineBusy(ppdev);

    // test rect render patch (jsw)
    //RenderRectangle(ppdev);

    //**************************************************************************
    // EnableOffscreenHeap mainly does 3 things:
    //      1) Inits the heap to contain all of Video Memory, then..
    //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    //!!! JOEHACK the next two should be done in EnableSurface to decouple  !!!
    //!!!         offscreen mgmt & bitmap caching from primary surface init !!!
    //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    //      2) Allocates a permanent region for the visible screen
    //      3) Creates the wrapper surface objects that GDI will use,
    //         when we use GDI to draw to our offscreen DFB's.
    //**************************************************************************
    if (!bEnableOffscreenHeap(ppdev))
        goto ReturnFailure;

    //**************************************************************************
    // EnablePointer currently does nothing (just returns TRUE)
    //**************************************************************************

    if (!bEnablePointer(ppdev))
        goto ReturnFailure;

    //**************************************************************************
    // EnablePointer currently does nothing (just returns TRUE)
    // since we don't do glyph caching
    //**************************************************************************

    if (!bEnableText(ppdev))
        goto ReturnFailure;

    //**************************************************************************
    // EnableBrushCache currently does nothing (just returns TRUE)
    // since we don't do brush caching
    //**************************************************************************

    //**************************************************************************
    // Inits the 8bpp palette registers
    //**************************************************************************

    if (!bEnablePalette(ppdev))
        goto ReturnFailure;

    //**************************************************************************
    // EnableDirectDraw currently does measures vertical refresh rate
    // and sets the bit DIRECTDRAW_CAPABLE
    //**************************************************************************

    if (!bEnableDirectDraw(ppdev))
        goto ReturnFailure;

    //**************************************************************************
    // Initialize the ohScreen struct with primary screen info.  This should
    // be done before the DSURF stuct for the primary screen is initialized.
    //**************************************************************************

    ppdev->ohScreen.pdsurf         = &ppdev->dsurfScreen;
    ppdev->ohScreen.next           = NULL;
    ppdev->ohScreen.prev           = NULL;
    ppdev->ohScreen.nextEmpty      = NULL;
    ppdev->ohScreen.pHeap          = NULL;
    ppdev->ohScreen.ulSizeInBytes  = ppdev->cyScreen *
                                     ppdev->cxScreen * ppdev->cjPelSize;
    ppdev->ohScreen.ulOffset       = 0;
    ppdev->ohScreen.ulLinearStride = (ULONG)ppdev->lDelta;

    //**************************************************************************
    // Now create our private (DSURF) surface structure.
    // This DSURF structure is specifically used to denote the physical screen.
    //
    // Whenever we get a call to draw directly to the screen, we'll get
    // passed a pointer to a SURFOBJ whose 'dhpdev' field will point
    // to our PDEV structure, and whose 'dhsurf' field will point to the
    // following DSURF structure.
    //
    // Every device bitmap we create in DrvCreateDeviceBitmap will also
    // have its own unique DSURF structure allocated (but will share the
    // same PDEV).  To make our code more polymorphic for handling drawing
    // to either the screen or an off-screen bitmap, we have the same
    // structure for both.
    //
    //JOEHACK - obsolete comment???
    // NV: For NV, this is not the case.  Since we started with a Dumb Frame
    //     Buffer driver, we used EngCreateBitmap to create a surface
    //     for the visible screen, so that we could let GDI draw directly
    //     to it.  Since then, Offscreen DFB's have now been implemented, and we
    //     can now go back to using EngCreateDeviceSurface to create the surface
    //     and have the code be more consistent.  But that would require
    //     BitBlt, TextOut and other code to be reworked (DFB testing code
    //     will need to be changed as well as wrapper surface functionality,
    //     so that we can tell if a bitmap is in system memory, or in VRAM).
    //     For now, we'll just continue using EngCreateBitmap. Basically, it
    //     doesn't seem to make that much of a difference.  If we decide
    //     to switch back to having our primary surface being Device-Managed,
    //     we'll need to add back the following code.
    //
    //     The bottom line, is that we can always default back to GDI to draw
    //     to ANY of our surface objects.
    //**************************************************************************

    pdsurf = &ppdev->dsurfScreen;

    //**********************************************************************
    // DSURF structures denote whether a DFB exists in offscreen memory (DT_SCREEN)
    // or whether it's been converted to a DIB (DT_DIB) in system memory.
    // Since this DSURF structure represents the physical screen, we init
    // the DSURF fields with the physical screen attributes.
    //**********************************************************************

    pdsurf->dt           = DT_SCREEN;           // Not to be confused with a DIB
    pdsurf->sizl.cx      = ppdev->cxScreen;     // Width of screen surface
    pdsurf->sizl.cy      = ppdev->cyScreen;     // Height of screen surface
    pdsurf->ppdev        = ppdev;               // Pointer to physical device
    pdsurf->poh          = &ppdev->ohScreen;    // The screen is a surface, too
    pdsurf->LinearPtr    = ppdev->pjScreen;
    pdsurf->LinearStride = (ULONG) ppdev->lDelta;

    //**************************************************************************
    // Next, have GDI create the actual SURFOBJ.
    //
    // Our drawing surface is going to be 'device-managed', meaning that
    // GDI cannot draw on the framebuffer bits directly, and as such we
    // create the surface via EngCreateDeviceSurface.  By doing this, we ensure
    // that GDI will only ever access the bitmaps bits via the Drv calls
    // that we've HOOKed.
    //
    // If we could map the entire framebuffer linearly into main memory
    // (i.e., we didn't have to go through a 64k aperture), it would be
    // beneficial to create the surface via EngCreateBitmap, giving GDI a
    // pointer to the framebuffer bits.  When we pass a call on to GDI
    // where it can't directly read/write to the surface bits because the
    // surface is device managed, it has to create a temporary bitmap and
    // call our DrvCopyBits routine to get/set a copy of the affected bits.
    // Fer example, the OpenGL component prefers to be able to write on the
    // framebuffer bits directly.
    //
    // NOTE: For NV, we don't have this problem.  We create the surface
    //       using EngCreateBitmap.  This allows us to pass any call we want
    //       to back to GDI. (Driver can run in Dumb Framebuffer mode if desired)
    //**************************************************************************

    // Always use a STYPE_DEVICE for our primary
    hsurf = (HSURF) EngCreateDeviceSurface( (DHSURF)pdsurf,
                                            pdsurf->sizl,
                                            ppdev->iBitmapFormat );
        
    
    if (hsurf == 0)
    {
        DISPDBG((1, "DrvEnableSurface - Failed EngCreateBitmap/DeviceSurface"));
        goto ReturnFailure;
    }

    ppdev->hsurfScreen = hsurf;     // Remember it for clean-up

    //**************************************************************************
    // Now associate the surface and the PDEV.
    //
    // We have to associate the surface we just created with our physical
    // device so that GDI can get information related to the PDEV when
    // it's drawing to the surface (such as, for example, the length of
    // styles on the device when simulating styled lines).
    //**************************************************************************

    if (!EngAssociateSurface(hsurf, ppdev->hdevEng, ppdev->flHooks ))
    {
        DISPDBG((1, "DrvEnableSurface - Failed EngAssociateSurface"));
        goto ReturnFailure;
    }

    //**************************************************************************
    // DrvEnableSurface Succeeded!
    //**************************************************************************

    if (HWGFXCAPS_QUADRO_GENERIC(ppdev))
    {
        // Create the linked list used to store DrvSaveScreenBits data
        if(!bLinkedListCreate(&(ppdev->pLinkedListSaveScreenBits), LL_CLASS_SAVESCREENBITS))
        {
            //  If failed, return immediately

            goto ReturnFailure;
        }
    }

    DISPDBG((5, "Passed DrvEnableSurface"));


    //**************************************************************************
    // Call the NV1/NV3 specific version of 'waiting while the engine is busy' routine
    // ??? NEED TO INCLUDE THIS TO PREVENT INCONSISTENT LOCKUP ???
    //**************************************************************************

    ppdev->pfnWaitEngineBusy(ppdev);

    // OpenGL init
    if (!bOglServicesInit(ppdev))
    {
        DISPDBG((1, "DrvEnableSurface - Failed bOglServicesInit"));
        goto ReturnFailure;
    }

    #ifdef  CALIBRATION_ENABLED
    
    vCalibrate_XferSpeeds(ppdev);   // Just before returning from this last stage
                                    // of the installation of the driver/pdev,
                                    // calibrate to setup ppdev->globalXferOverheadFactor
    #endif


#if _WIN32_WINNT >= 0x0500
    // In W2K the video card's acceleration level can be dynamically set through the Display Applet
    // Here we read the value because we need to disable e.g. page flipping on a sw cursor
    // as long as our double pumping double pumps even on to of opengl surfaces
    if (!EngQueryDeviceAttribute(ppdev->hdevEng, QDA_ACCELERATION_LEVEL, NULL, 0, &ppdev->ulDriverCompatibilityMode, sizeof(ULONG)))
#endif
    {
        // on NT4 or if we failed we assume full acceleration
        ppdev->ulDriverCompatibilityMode = 0;
    }

    return(hsurf);

    //**************************************************************************
    // DrvEnableSurface Failed!
    //**************************************************************************

ReturnFailure:

    DrvDisableSurface((DHPDEV) ppdev);
    ppdev->bEnabled = FALSE;

    DISPDBG((0, "Failed DrvEnableSurface"));

    return(0);
    }

//******************************************************************************
//
//  Function:   DrvDisableSurface
//
//  Routine Description:
//
//     Free resources allocated by DrvEnableSurface.  Release the surface.
//
//     Note that this function will be called when previewing modes in the
//     Display Applet, but not at system shutdown.  If you need to reset the
//     hardware at shutdown, you can do it in the miniport by providing a
//     'HwResetHw' entry point in the VIDEO_HW_INITIALIZATION_DATA structure.
//
//     Note: In an error case, we may call this before DrvEnableSurface is
//           completely done.
//
//  Arguments:
//
//  Return Value:
//
//
//******************************************************************************


VOID DrvDisableSurface(
DHPDEV dhpdev)

    {
    PDEV*   ppdev;
    BOOLEAN bHwDisabled;

    ppdev = (PDEV*) dhpdev;

    //**************************************************************************
    // Note: In an error case, some of the following relies on the
    //       fact that the PDEV is zero-initialized, so fields like
    //       'hsurfScreen' will be zero unless the surface has been
    //       sucessfully initialized, and makes the assumption that
    //       EngDeleteSurface can take '0' as a parameter.
    //**************************************************************************

    //**************************************************************************
    // DisableDirectDraw -> frees up memory taken my Direct Draw)
    // DisablePalette    -> does nothing
    // DisableBrushCache -> does nothing (we don't put brushes in offscreen memory)
    // DisableText       -> does nothing (we don't do glyph caching)
    // DisablePointer    -> does nothing
    // DisableOffscreenHeap -> frees up system memory used for offscreen heap
    //                         management, as well as the wrapper 'punt' surface objects
    //JOEHACK - move punt surfobj creation/deletion from  E/Doffscreenheap to E/Dsurface and fix the comment
    // DisableBanking    -> does nothing (we don't do banking in NV)
    // DisableHardware   -> frees up memory used to map frame buffer , as well
    //                      as memory used to map miscellaneous memory mapped
    //                      register ranges
    //**************************************************************************
    if (HWGFXCAPS_QUADRO_GENERIC(ppdev))
    {
        // Free the linked list used to store DrvSaveScreenBits data
        bSaveScreenBitsGarbageCollection(ppdev, 0); // remove all elements we've collected (GDI bug)
        bLinkedListDestroy(&(ppdev->pLinkedListSaveScreenBits));
    }

    bOglServicesDisable(ppdev);

    vDisableDirectDraw(ppdev);
    vDisablePalette(ppdev);
    vDisableText(ppdev);
    vDisablePointer(ppdev);
    vDisableOffscreenHeap(ppdev);
    vDisableHardware(ppdev);
    if (ppdev->hsurfScreen != NULL)
        EngDeleteSurface(ppdev->hsurfScreen);

    }

//******************************************************************************
//
//  Function:   AssertModeEnable
//
//  Routine Description:
//
//      Called by DrvAssertMode(dhpdev, TRUE);
//
//  Arguments:
//
//  Return Value:
//
//
//******************************************************************************
BOOL AssertModeEnable(PDEV* ppdev)
{
    ULONG   ReturnedDataLength;

    //**************************************************************************
    // We are running a version of NT which is >= 4.0. This means we can safely
    // enable P6 write combining when mapping the framebuffer. The following IOCTL
    // sets a flag in the device state which tells the miniport to do just that.
    // This needs to be done for every physical NV device enabled by this driver.
    //**************************************************************************
    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_ENABLE_WRITE_COMBINING,
                           NULL,
                           0,
                           NULL,
                           0,
                           &ReturnedDataLength))
        {
        DISPDBG((1, "AssertModeEnable - IOCTL_VIDEO_ENABLE_WRITE_COMBINING failed"));
        }

    //**********************************************************************
    // Enable - Switch back to graphics mode
    //**********************************************************************

    //**********************************************************************
    // We have to enable every subcomponent in the reverse order
    // in which it was disabled:
    //**********************************************************************


    if (bAssertModeHardware(ppdev, TRUE))
    {
#if (_WIN32_WINNT >= 0x0500) && !defined(NV3)
        if (ppdev->bAgp) {
            ppdev->pDriverData->GARTPhysicalBase = ppdev->AgpHeap->lpHeap->fpGARTDev;
            ppdev->pDriverData->GARTLinearHeapOffset = ppdev->AgpHeap->lpHeap->fpGARTLin;
        }
#endif

        //******************************************************************
        // This really doesn't do anything, since BitBlt already
        // attempts to put DFB DIBs back into offscreen VRAM if possible
        //******************************************************************
        bAssertModeOffscreenHeap(ppdev, TRUE);  // We don't need to check
                                                //   return code with TRUE
        //******************************************************************
        // Init heap for direct draw if it was previously active.
        //******************************************************************
        if (ppdev->flStatus & STAT_DIRECTDRAW_ENABLED)
            if (!bAssertModeDirectDraw(ppdev, TRUE))
                return(FALSE);


        //******************************************************************
        // Re-enable the cursor
        //******************************************************************

        vAssertModePointer(ppdev, TRUE);

        if (!bOglAssertMode(ppdev, TRUE))
            return(FALSE);

        ppdev->bEnabled = TRUE;
        ppdev->dsurfScreen.LinearPtr = ppdev->pjScreen;

        return(TRUE);
    }
    return(FALSE);
}

//******************************************************************************
//
//  Function:   AssertModeDisable
//
//  Routine Description:
//
//      Called by DrvAssertMode(dhpdev, TRUE);
//
//  Arguments:
//
//  Return Value:
//
//
//******************************************************************************
BOOL AssertModeDisable(PDEV* ppdev)
{
    BOOL  bReleaseOpenGLMutex = FALSE;
    ULONG ulRet;

    //**************************************************************************
    // If OpenGL is enabled, then wait for current push buffer to complete.
    //**************************************************************************

    //  Indicate that we are currently disabled, and should not call
    //  accelerated codes.

    ppdev->bEnabled = FALSE;

    if (!bOglAssertMode(ppdev, FALSE))
        return(FALSE);


    if (OglIsEnabled(ppdev))
    {
        ppdev->pfnAcquireOglMutex(ppdev);
        ppdev->pfnWaitForChannelSwitch(ppdev);
        ppdev->NVFreeCount = 0;
        bReleaseOpenGLMutex = TRUE;
    }

    //**********************************************************************
    // Disable - Switch to full-screen mode
    //**********************************************************************
    if(ppdev->pjScreen != NULL)
    {
        ULONG ulBytesToClear,ul;

        // clear visible screen
        ulBytesToClear = ppdev->lDelta * ppdev->cyScreen;

        for(ul = 0; ul < (ulBytesToClear / sizeof(ULONG)); ul++)
        {
            ((PULONG) ppdev->pjScreen)[ul] = 0;
        }
    }


    //**********************************************************************
    // NT4 - Disable directdraw offscreen heap if enabled.
    // NT5 - Destroy DX6 objects.
    //**********************************************************************
    if (!bAssertModeDirectDraw(ppdev, FALSE))
    {
        if (bReleaseOpenGLMutex == TRUE)
        {
            ppdev->pfnReleaseOglMutex(ppdev);
        }
        // Don't return so soon; let clean up other stuff.
        //return(FALSE);
    }

    //**********************************************************************
    // AssertModePalette doesn't do anything for NV.
    // We'll just leave it as a placeholder
    //**********************************************************************

    vAssertModePalette(ppdev, FALSE);

    //**********************************************************************
    // AssertModeBrushCache doesn't do anything for NV,
    // since we don't implement brushes in offscreen vram.
    //**********************************************************************

    //**********************************************************************
    // AssertModeBrushCache doesn't do anything for NV,
    // since we don't do glyph caching.
    // We'll just leave it as a placeholder
    //**********************************************************************

    vAssertModeText(ppdev, FALSE);

    //**********************************************************************
    // Disable/hide the cursor
    //**********************************************************************

    vAssertModePointer(ppdev, FALSE);

    //**********************************************************************
    // Make sure to move offscreen DFB's to system memory
    //**********************************************************************
    if (bAssertModeOffscreenHeap(ppdev, FALSE))
    {
    //******************************************************************
    // Now do the actual mode switch to full-screen
    //******************************************************************

        if (bAssertModeHardware(ppdev, FALSE))
        {
            if (bReleaseOpenGLMutex == TRUE)
            {
                ppdev->pfnReleaseOglMutex(ppdev);
                if (ppdev->oglMutexPtr) *(ppdev->oglMutexPtr) = 0;
            }

            if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_SET_UNIQUENESS_VGA,
                               &ppdev->iUniqueness,
                               sizeof(ULONG),
                               NULL,
                               0,
                               &ulRet))
            {
                DISPDBG((1, "AssertModeDisable - Failed SET_UNIQUENESS_VGA IOCTL"));
            }


            return(TRUE);
        }
    }                                       //   return code with TRUE

    //**********************************************************************
    // Re-enable the cursor
    //**********************************************************************

    vAssertModePointer(ppdev, TRUE);

    if (bReleaseOpenGLMutex == TRUE)
    {
        ppdev->pfnReleaseOglMutex(ppdev);
        if (ppdev->oglMutexPtr) *(ppdev->oglMutexPtr) = 0;
    }

    return(FALSE);
}

//******************************************************************************
//
//  Function:   vDisableAcceleration
//
//  Routine Description:
//
//      
//
//  Arguments:
//
//  Return Value:
//
//
//******************************************************************************
VOID vDisableAcceleration(PDEV* ppdev)
{
    ULONG ulReturnedDataLength;

    // Reset the chip
    if (EngDeviceIoControl(ppdev->hDriver,
                       IOCTL_VIDEO_RESET_DEVICE,
                       NULL,
                       0,
                       NULL,
                       0,
                       &ulReturnedDataLength))
    {
        DISPDBG((1, "bAssertModeHardware - Failed reset IOCTL"));
    }

    // setup new mode by call miniport throught RmSetMode because
    // display driver has trouble to create/initialize the HW objects.
    if (EngDeviceIoControl(ppdev->hDriver,
                       IOCTL_VIDEO_SET_CURRENT_MODE,
                       &ppdev->ulMode,  // input buffer
                       sizeof(DWORD),
                       &ppdev->bHwVidOvl,
                       sizeof(BOOLEAN),
                       &ulReturnedDataLength))
    {
        DISPDBG((1, "bAssertModeHardware - Failed VIDEO_SET_CURRENT_MODE"));
    }

    // Disable all accelerations
    ppdev->bEnabled = FALSE; 
}

//******************************************************************************
//
//  Function:   DrvAssertMode
//
//  Routine Description:
//
//      This asks the device to reset itself to the mode of the pdev passed in.
//
//  Arguments:
//
//  Return Value:
//
//
//******************************************************************************
BOOL DrvAssertMode(
DHPDEV  dhpdev,
BOOL    bEnable)
{
    PDEV* ppdev;
    TOSHIBA_HOTKEY_MODE ToshibaHotKeyMode;

    ppdev = (PDEV*) dhpdev;

    if (bEnable)
    {
        // Indicate we are in DrvAssertMode(TRUE) so that we can obey the BOOT_DEVICEs for laptops.
        ppdev->ulDrvAssertModeTRUE = 1;
        // if we are already enabled, do nothing.
        if (ppdev->bEnabled)
        {
            DISPDBG((1, "DrvAssertMode(TRUE):Already enabled. Returning"));
            return(TRUE);
        }
    }
    else
    {
        // Indicate we are not in DrvAssertMode(TRUE)
        ppdev->ulDrvAssertModeTRUE = 0;
        if (!ppdev->bEnabled)
        {
            DISPDBG((1, "DrvAssertMode(FALSE): Already disabled. Returning"));
            return(TRUE);
        }
    }

#if _WIN32_WINNT >= 0x0500

    if (bEnable)
    {
        // Read in the Toshiba Hotkey mode. This is only for win2K or later.
        ToshibaHotKeyMode.ValidMode = 0;
        ReadToshibaHotKeyMode(ppdev->hDriver, &ToshibaHotKeyMode);
        if (ToshibaHotKeyMode.ValidMode == 1)
        {
            // We are here because of a hotkey switch. However, GDI is keeping the same mode so no need to
            // force GDI into the same mode.
            // Now turn off the hotkey mode.
            ToshibaHotKeyMode.ValidMode = 0;
            WriteToshibaHotKeyMode(ppdev->hDriver, &ToshibaHotKeyMode);
        }

        if(!AssertModeEnable(ppdev))
        {

            // Has trouble to assert mode
            // Let's disable them if any of them enabled


            if(!AssertModeDisable(ppdev))
            {
                //  If failed, exit immediately to avoid risk of access violation later
                //  in the code.

                // Free up any memory alloced by display driver for multimon purposes.
                FreeMemoryMultiMon(ppdev);
                return(FALSE);
            }

            // Disable acceleration
            vDisableAcceleration(ppdev);
            DISPDBG((0, "DrvAssertMode - all 2D accelerations are disable."));

        }
    }
    else
    {
        AssertModeDisable(ppdev);
        // Free up any memory alloced by display driver for multimon purposes.
        FreeMemoryMultiMon(ppdev);
    }
    // Always return TRUE to make OS kernal happy.
    return(TRUE);

#else

    if (bEnable)
    {
        if(AssertModeEnable(ppdev))
            return(TRUE);
    }
    else
    {
        if(AssertModeDisable(ppdev))
        {
            // Free up any memory alloced by display driver for multimon purposes.
            FreeMemoryMultiMon(ppdev);
            return(TRUE);
        }
    }
    DISPDBG((0, "DrvAssertMode - failed (bEnable = %d)", bEnable));
    // Free up any memory alloced by display driver for multimon purposes.
    FreeMemoryMultiMon(ppdev);
    return(FALSE);

#endif

}

//******************************************************************************
//
//  Function:   DrvGetModes
//
//  Routine Description:
//
//      Returns the list of available modes for the device.
//
//  Arguments:
//
//  Return Value:
//
//
//******************************************************************************

ULONG DrvGetModes(
HANDLE      hDriver,
ULONG       cjSize,
DEVMODEW*   pdm)

    {
    DWORD cModes;
    DWORD cbOutputSize;
    PVIDEO_MODE_INFORMATION pVideoModeInformation;
    PVIDEO_MODE_INFORMATION pVideoTemp;
    DWORD cOutputModes = cjSize / (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
    DWORD cbModeSize;
    DWORD cNumGDIModes;

    DISPDBG((6,"DrvGetModes() Enter\n"));

    //**************************************************************************
    // getAvailableModes mainly does 2 things
    //      1) Gets the TOTAL number of modes supported by the miniport
    //      2) Returns a pointer to the array of modes. The modes
    //         whose length is set to 0 are not valid for the display driver
    //**************************************************************************

    cModes = getAvailableModes(hDriver,
                            (PVIDEO_MODE_INFORMATION *) &pVideoModeInformation,
                            &cbModeSize, &cNumGDIModes);

    //**************************************************************************
    // If this fails, NT will go back to VGA
    //**************************************************************************

    if (cModes == 0 || cNumGDIModes == 0)
        {
        DISPDBG((1, "DrvGetModes failed to get mode information"));
        return(0);
        }


    //**************************************************************************
    // pdm points to the buffer where we'll store the valid modes
    // (DEVMODEW structures).  If pdm == NULL, we need to return
    // the number of bytes required to hold all the mode data.
    //**************************************************************************

    if (pdm == NULL)
        {
        cbOutputSize = cNumGDIModes * (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
        }

    else

        {
        //**********************************************************************
        // Now copy the information for the supported modes back into the
        // output buffer
        //**********************************************************************

        cbOutputSize = 0;

        pVideoTemp = pVideoModeInformation;

        do  {

            //******************************************************************
            // Now copy only the modes which this display driver supports
            //******************************************************************

            if (pVideoTemp->Length != 0)
                {

                //**************************************************************
                // Make sure we don't go past the end of the mode
                // buffer supplied to us
                //**************************************************************

                if (cOutputModes == 0)
                    {
                    break;
                    }

                //**************************************************************
                // Zero the entire structure to start off with.
                //**************************************************************

                memset(pdm, 0, sizeof(DEVMODEW));

                //**************************************************************
                // Set the name of the device to the name of the DLL.
                //**************************************************************

                DISPDBG((6, "exporting: (%d, %d) at %d bpp, %d HZ\n",
                    pVideoTemp->VisScreenWidth,pVideoTemp->VisScreenHeight,
                    pVideoTemp->BitsPerPlane,pVideoTemp->Frequency));

                memcpy(pdm->dmDeviceName, DLL_NAME, sizeof(DLL_NAME));

                pdm->dmSpecVersion      = DM_SPECVERSION;
                pdm->dmDriverVersion    = DM_SPECVERSION;
                pdm->dmSize             = sizeof(DEVMODEW);
                pdm->dmDriverExtra      = DRIVER_EXTRA_SIZE;

                pdm->dmBitsPerPel       = pVideoTemp->NumberOfPlanes *
                                          pVideoTemp->BitsPerPlane;
                pdm->dmPelsWidth        = pVideoTemp->VisScreenWidth;
                pdm->dmPelsHeight       = pVideoTemp->VisScreenHeight;
                pdm->dmDisplayFrequency = pVideoTemp->Frequency;
                pdm->dmDisplayFlags     = 0;

                pdm->dmFields           = DM_BITSPERPEL       |
                                          DM_PELSWIDTH        |
                                          DM_PELSHEIGHT       |
                                          DM_DISPLAYFREQUENCY |
                                          DM_DISPLAYFLAGS     ;

                //**************************************************************
                // Go to the next DEVMODE entry in the buffer.
                // cOutputModes represents the number of mode entries
                // left in the buffer supplied to us.
                //**************************************************************

                cOutputModes--;

                pdm = (LPDEVMODEW) ( ((BYTE *)pdm) + sizeof(DEVMODEW) +
                                                   DRIVER_EXTRA_SIZE);

                cbOutputSize += (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);

                }

            //******************************************************************
            // Check next miniport mode
            //******************************************************************

            pVideoTemp = (PVIDEO_MODE_INFORMATION)
                (((PUCHAR)pVideoTemp) + cbModeSize);


            } while (--cModes);

        }

    //**************************************************************************
    // MAKE sure to free up this memory, which was allocated in
    // getAvailableModes()
    //**************************************************************************

    EngFreeMem(pVideoModeInformation);
    DISPDBG((1,"Returning number of modes: %d\n",(cbOutputSize / (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE))));

    return(cbOutputSize);
    }

//******************************************************************************
//


//  Function:   bInitializeModeFields
//
//  Routine Description:
//
//      Initializes a bunch of fields in the pdev, devcaps (aka gdiinfo), and
//      devinfo based on the requested mode.
//
//  Arguments:
//
//  Return Value:
//
//
//******************************************************************************


BOOL bInitializeModeFields(
PDEV*     ppdev,
GDIINFO*  pgdi,
DEVINFO*  pdi,
DEVMODEW* pdm)

    {
    ULONG                   cModes;
    PVIDEO_MODE_INFORMATION pVideoBuffer;
    PVIDEO_MODE_INFORMATION pVideoModeSelected;
    PVIDEO_MODE_INFORMATION pVideoTemp;
    BOOL                    bSelectDefault;
    VIDEO_MODE_INFORMATION  VideoModeInformation;
    ULONG                   cbModeSize;
    ULONG i;
    TOSHIBA_HOTKEY_MODE     ToshibaHotKeyMode;
    DWORD cNumGDIModes;

    //**************************************************************************
    // Call the miniport to get mode information
    //**************************************************************************

    cModes = getAvailableModes(ppdev->hDriver, &pVideoBuffer, &cbModeSize, &cNumGDIModes);
    if (cModes == 0)
        goto bInitializeModeFields_ReturnFalse;

#if _WIN32_WINNT >= 0x0500
    // Read in the Toshiba Hotkey mode.
    ToshibaHotKeyMode.ValidMode = 0;
    ReadToshibaHotKeyMode(ppdev->hDriver, &ToshibaHotKeyMode);
    if (ToshibaHotKeyMode.ValidMode == 1)
    {
        // We are here because of a hotkey switch. So overwrite the 'pdm'. This will automatically percolate the desired mode
        // to 'pgdi'.
        pdm->dmPelsWidth = ToshibaHotKeyMode.Width;
        pdm->dmPelsHeight = ToshibaHotKeyMode.Height;
        pdm->dmBitsPerPel = ToshibaHotKeyMode.Depth;
        pdm->dmDisplayFrequency = ToshibaHotKeyMode.RefreshRate;

        // Now turn off the hotkey mode.
        ToshibaHotKeyMode.ValidMode = 0;
        WriteToshibaHotKeyMode(ppdev->hDriver, &ToshibaHotKeyMode);
    }

#endif _WIN32_WINNT >= 0x0500

    //****************************************************************************************
    // Now check if we were asked to force a mode: if we started this 
    // one-time-after-reboot-forced-mode sequence, but we haven't rebooted yet,
    // we just clear the flag that indicate the start of this sequence. This means
    // the user switched mode before rebooting.  Else, we do the mode overide if the
    // sequence is at the "end" (only the mode overide is missing)
    // This sequence goes like :  
    //                            hwinit()        -> ForceModeNextBoot := 1 (if we want to force this sequence)
    //                            reboot
    //                            hwinit()        -> ForceModeNextBoot := 0, ReBootedNowForceMode.ValidMode := 1
    //                                                 ( if ForceModeNextBoot == 1 )
    //
    //                            drvenablepdev() -> + ReBootedNowForceMode.ValidMode := 0
    //                                               | Overide mode
    //                                               |
    //                                               +--> this is only done if ForceModeNextBoot == 0, and 
    //                                                    ReBootedNowForceMode.ValidMode == 1
    //
    //                                               Else, if ForceModeNextBoot == 1, we halt the sequence here
    //                                               because we're assuming the user sets a mode and that
    //                                               overides our force sequence.
    //
    // SEE \nv_mini\nv.c: CheckForcedResolution()
    //
    // (The next comments are pulled from that:)
    //
    // In DrvEnablePdev(): ***!ASSUMING it is called ONLY on modeset!*** 
    //
    //
    //    1) read the ForceModeNextBoot flag: 
    //
    //                     if it is set ->        clear it ! (the user changed the mode but we haven't rebooted
    //                                            yet because otherwise, on reboot, in this very function,
    //                                            we would have cleared it);   ReBootedNowForceMode.ValidMode is 
    //                                            probably = 0, else the state is inconsistant.
    //                     else 
    //                         -> 
    //                     read the ReBootedNowForceMode.ValidMode flag:  
    //            
    //                         if it is set -> clear it and overide the GDI mode with
    //                                         ReBootedNowForceMode;
    //                         else 
    //                             -> nothing special;
    //
    //  was already induced, we already have a mode to set, from a previous call to this function)
    //
    //****************************************************************************************

    {
        ULONG           ForceModeNextBoot;

        
        ForceModeNextBoot = 0;

        GetRegValueW( ppdev->hDriver, L"ForceModeNextBoot", (PVOID) &ForceModeNextBoot, sizeof(ULONG));

        if( ForceModeNextBoot == 1)
        {
            // Force mode sequence started but we haven't rebooted and the user switch mode, so 
            // overide the sequence

            ForceModeNextBoot = 0;
            SetRegValueW( ppdev->hDriver, L"ForceModeNextBoot", (PVOID) &ForceModeNextBoot, sizeof(ULONG));
        }
        else
        {
            // Check to see if a force mode sequence needs to be completed
            
            MODE_ENTRY      ModeEntry;
        
            GetRegValueW( ppdev->hDriver, L"ReBootedNowForceMode", (PVOID) &ModeEntry, sizeof(MODE_ENTRY));

            if( ModeEntry.ValidMode == 1 )
            {
                // Clear the flag, and overide the mode asked by GDI

                ModeEntry.ValidMode = 0;
                
                // Overwrite the 'pdm' field (DEVMODEW).
                
                pdm->dmPelsWidth  = ModeEntry.Width;
                pdm->dmPelsHeight = ModeEntry.Height;
                pdm->dmBitsPerPel = ModeEntry.Depth;
                pdm->dmDisplayFrequency = ModeEntry.RefreshRate;

                SetRegValueW( ppdev->hDriver, L"ReBootedNowForceMode", (PVOID) &ModeEntry, sizeof(MODE_ENTRY));    
            
            } // ... if validmode (then we overide the mode asked by GDI with the mode in the key)

        }// ...else forcemodenextboot = 0;  (need to check for force mode sequence)
    }

    //*** ...check for a forced mode we wanted to set ****************************************


    //**************************************************************************
    // Now see if the requested mode has a match in that table.
    //**************************************************************************

    pVideoModeSelected = NULL;
    pVideoTemp = pVideoBuffer;

    if ((pdm->dmPelsWidth        == 0) &&
        (pdm->dmPelsHeight       == 0) &&
        (pdm->dmBitsPerPel       == 0) &&
        (pdm->dmDisplayFrequency == 0))
        {
        DISPDBG((1, "Default mode requested"));
        bSelectDefault = TRUE;
        }
    else
        {
        DISPDBG((1, "Requested mode..."));
        DISPDBG((1, "   Screen width  -- %li", pdm->dmPelsWidth));
        DISPDBG((1, "   Screen height -- %li", pdm->dmPelsHeight));
        DISPDBG((1, "   Bits per pel  -- %li", pdm->dmBitsPerPel));
        DISPDBG((1, "   Frequency     -- %li", pdm->dmDisplayFrequency));

        bSelectDefault = FALSE;
        }

    //**************************************************************************
    // Check the requested mode against the miniport modes until we find a match
    //**************************************************************************

    while (cModes--)
        {
        if (pVideoTemp->Length != 0)
            {
            DISPDBG((8, "   Checking against miniport mode:"));
            DISPDBG((8, "      Screen width  -- %li", pVideoTemp->VisScreenWidth));
            DISPDBG((8, "      Screen height -- %li", pVideoTemp->VisScreenHeight));
            DISPDBG((8, "      Bits per pel  -- %li", pVideoTemp->BitsPerPlane *
                                                      pVideoTemp->NumberOfPlanes));
            DISPDBG((8, "      Frequency     -- %li", pVideoTemp->Frequency));

            //******************************************************************
            // If the default mode is requested, use the first mode entry
            //******************************************************************

            if (bSelectDefault ||
                ((pVideoTemp->VisScreenWidth  == pdm->dmPelsWidth) &&
                 (pVideoTemp->VisScreenHeight == pdm->dmPelsHeight) &&
                 (pVideoTemp->BitsPerPlane *
                  pVideoTemp->NumberOfPlanes  == pdm->dmBitsPerPel) &&
                 (pVideoTemp->Frequency       == pdm->dmDisplayFrequency)))
                {
                pVideoModeSelected = pVideoTemp;
                DISPDBG((1, "...Found a mode match!"));
                break;
                }
            }


        //**********************************************************************
        // Check next miniport mode
        //**********************************************************************

        pVideoTemp = (PVIDEO_MODE_INFORMATION)
            (((PUCHAR)pVideoTemp) + cbModeSize);

        }

    //**************************************************************************
    // If no mode has been found, return an error
    //**************************************************************************

    if (pVideoModeSelected == NULL)
        {
        DISPDBG((1, "...Couldn't find a mode match!"));
        EngFreeMem(pVideoBuffer);
        goto bInitializeModeFields_ReturnFalse;
        }

    //**************************************************************************
    // We have chosen the one we want.  Save it in a stack buffer and
    // get rid of allocated memory before we forget to free it.
    //**************************************************************************

    VideoModeInformation = *pVideoModeSelected;
    EngFreeMem(pVideoBuffer);

    #if DEBUG_HEAP
        VideoModeInformation.VisScreenWidth  = 640;
        VideoModeInformation.VisScreenHeight = 480;
    #endif

    //**************************************************************************
    // Set up screen information from the mini-port:
    //**************************************************************************

    ppdev->ulMode           = VideoModeInformation.ModeIndex;
    ppdev->cxScreen         = VideoModeInformation.VisScreenWidth;
    ppdev->cyScreen         = VideoModeInformation.VisScreenHeight;
    ppdev->cBitsPerPel      = VideoModeInformation.BitsPerPlane;
    ppdev->ulGDIRefreshRate      = VideoModeInformation.Frequency;

    // For Twinview purposes
    // GDI tells us the refresh rate for the first head. nVidia panel tells us the refresh rate for the second head.
    ppdev->ulRefreshRate[0]      = VideoModeInformation.Frequency;

    DISPDBG((1, "ScreenStride: %lx", VideoModeInformation.ScreenStride));

    //**************************************************************************
    // We'll slowly add accelerations, starting with BITBLT
    //**************************************************************************
    ppdev->flHooks = (HOOK_SYNCHRONIZEACCESS |
                      HOOK_SYNCHRONIZE       |
                      HOOK_BITBLT            |
                      HOOK_COPYBITS          |
                      HOOK_TEXTOUT           |
                      HOOK_PAINT             |
                      HOOK_STROKEPATH        |
//                      HOOK_FILLPATH          |
                      HOOK_LINETO 
#if _WIN32_WINNT >= 0x0500 
#ifndef NV3
                      | HOOK_ALPHABLEND
                      | HOOK_TRANSPARENTBLT
#endif
#endif                      
                      );


    //**************************************************************
    // It's a device-managed surface; make sure we don't set
    // HOOK_SYNCHRONIZE, otherwise we may confuse GDI:
    //**************************************************************
    ppdev->flHooksDeviceBitmap = ppdev->flHooks & ~HOOK_SYNCHRONIZE;

    //**************************************************************
    // Setting the SYNCHRONIZEACCESS flag tells GDI that we
    // want all drawing to the bitmaps to be synchronized (GDI
    // is multi-threaded and by default does not synchronize
    // device bitmap drawing -- it would be a Bad Thing for us
    // to have multiple threads using the accelerator at the
    // same time):
    //**************************************************************

    ppdev->flHooksDeviceBitmap  |= HOOK_SYNCHRONIZEACCESS;


    //**************************************************************************
    // We currently don't implement the following functions
    //
    //          HOOK_STRETCHBLT         -> Not that important speed wise?
    //                                     Current version doesn't handle DFB's
    //          HOOK_FILLPATH           -> Not implemented
    //          HOOK_STROKEANDFILLPATH  -> Not implemented
    //
    //**************************************************************************

    //**************************************************************************
    // Make sure that Clipping rectangle gets reset by the first hardware function
    // By default, the clipping rectangle should include ALL of video memory
    // (including offscreen). Whenever we change it, we need to set this flag.
    // So, by setting it here, the first function we get to will reset
    // the clipping rectangle.
    //**************************************************************************

    ppdev->NVClipResetFlag=1;

    //**************************************************************************
    // Used to test successful return of functions without doing anything
    // The following variables are just used for debugging and profiling
    //**************************************************************************

    ppdev->NVAbsoluteLimitFlag      = FALSE;
    ppdev->NVStubTest               = FALSE;
    ppdev->NVRecordFunctionsFlag    = 0;
    for (i=0;i<70;i++)
        ppdev->NVLocation[i]=0;

    //**************************************************************************
    // Fill in the GDIINFO data structure with the default 8bpp values:
    // NOTE: This is a global variable/structure!  May need to
    //       change it if we implement multiple board functionality
    //**************************************************************************

    *pgdi = ggdiDefault;

    //**************************************************************************
    // Now overwrite the defaults with the relevant information returned
    // from the kernel driver:
    //**************************************************************************

    pgdi->ulHorzSize        = VideoModeInformation.XMillimeter;
    pgdi->ulVertSize        = VideoModeInformation.YMillimeter;

    pgdi->ulHorzRes         = VideoModeInformation.VisScreenWidth;
    pgdi->ulVertRes         = VideoModeInformation.VisScreenHeight;
    pgdi->ulPanningHorzRes  = VideoModeInformation.VisScreenWidth;
    pgdi->ulPanningVertRes  = VideoModeInformation.VisScreenHeight;

    pgdi->cBitsPixel        = VideoModeInformation.BitsPerPlane;
    pgdi->cPlanes           = VideoModeInformation.NumberOfPlanes;
    pgdi->ulVRefresh        = VideoModeInformation.Frequency;

    pgdi->ulDACRed          = VideoModeInformation.NumberRedBits;
    pgdi->ulDACGreen        = VideoModeInformation.NumberGreenBits;
    pgdi->ulDACBlue         = VideoModeInformation.NumberBlueBits;

    pgdi->ulLogPixelsX      = pdm->dmLogPixels;
    pgdi->ulLogPixelsY      = pdm->dmLogPixels;

    //
    // The analog clock on the lower right end of the task bar needs to be circular shaped always.
    // So adjust the millimeter size of the width or height accordingly for spanning modes.
    //
    if (HORIZONTAL_MODE(VideoModeInformation.VisScreenWidth, VideoModeInformation.VisScreenHeight))
    {
        //
        // Double the horizontal size
        //
        pgdi->ulHorzSize *= 2;

    }
    else
    if (VERTICAL_MODE(VideoModeInformation.VisScreenWidth, VideoModeInformation.VisScreenHeight))
    {
        //
        // Double the vertical size.
        //
        pgdi->ulVertSize *= 2;
    }

    //**************************************************************************
    // Fill in the devinfo structure with the default 8bpp values:
    //**************************************************************************

    *pdi = gdevinfoDefault;

    //**************************************************************************
    // Initialize the ppdev field values according to the bitdepth
    //**************************************************************************

    if (VideoModeInformation.BitsPerPlane == 8)

        {
        ppdev->cjPelSize       = 1;
        ppdev->iBitmapFormat   = BMF_8BPP;
        ppdev->ulWhite         = 0xff;
        ppdev->physicalColorMask = 0xff;

        //**********************************************************************
        // Assuming palette is orthogonal - all colors are same size.
        //**********************************************************************

        ppdev->cPaletteShift   = 8 - pgdi->ulDACRed;
        pdi->flGraphicsCaps   |= (GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);
        DISPDBG((3, "palette shift = %d\n", ppdev->cPaletteShift));
        }

    else if ((VideoModeInformation.BitsPerPlane == 16) ||
             (VideoModeInformation.BitsPerPlane == 15))
        {
        ppdev->cjPelSize       = 2;
        ppdev->iBitmapFormat   = BMF_16BPP;
        ppdev->ulWhite         = 0xffff;
        ppdev->flRed           = VideoModeInformation.RedMask;
        ppdev->flGreen         = VideoModeInformation.GreenMask;
        ppdev->flBlue          = VideoModeInformation.BlueMask;
        ppdev->physicalColorMask = ppdev->flRed | ppdev->flGreen | ppdev->flBlue;

        pgdi->ulNumColors      = (ULONG) -1;
        pgdi->ulNumPalReg      = 0;
        pgdi->ulHTOutputFormat = HT_FORMAT_16BPP;

        pdi->iDitherFormat     = BMF_16BPP;
        pdi->flGraphicsCaps   &= ~(GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);

        #if _WIN32_WINNT >= 0x0500

        //
        //  Allow system to call DrvIcmSetDeviceGammaRamp
        //

        pdi->flGraphicsCaps2 |= GCAPS2_CHANGEGAMMARAMP;
        pdi->flGraphicsCaps2 |= GCAPS2_ALPHACURSOR;

        pdi->flGraphicsCaps2 |= GCAPS2_ICD_MULTIMON;

        #endif

        }

    else

        {
        ASSERTDD(VideoModeInformation.BitsPerPlane == 32,
         "This driver supports only 8, 16, and 32bpp");

        ppdev->cjPelSize       = 4;
        ppdev->iBitmapFormat   = BMF_32BPP;
        ppdev->ulWhite         = 0xffffffff;
        ppdev->flRed           = VideoModeInformation.RedMask;
        ppdev->flGreen         = VideoModeInformation.GreenMask;
        ppdev->flBlue          = VideoModeInformation.BlueMask;
        ppdev->physicalColorMask = ppdev->flRed | ppdev->flGreen | ppdev->flBlue;

        pgdi->ulNumColors      = (ULONG) -1;
        pgdi->ulNumPalReg      = 0;
        pgdi->ulHTOutputFormat = HT_FORMAT_32BPP;

        pdi->iDitherFormat     = BMF_32BPP;
        pdi->flGraphicsCaps   &= ~(GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);

        #if _WIN32_WINNT >= 0x0500

        //
        //  Allow system to call DrvIcmSetDeviceGammaRamp
        //

        pdi->flGraphicsCaps2 |= GCAPS2_CHANGEGAMMARAMP;
        pdi->flGraphicsCaps2 |= GCAPS2_ALPHACURSOR;

        pdi->flGraphicsCaps2 |= GCAPS2_ICD_MULTIMON;

        #endif
        }

    DISPDBG((5, "Passed bInitializeModeFields"));

    return(TRUE);

bInitializeModeFields_ReturnFalse:

    DISPDBG((1, "Failed bInitializeModeFields"));

    return(FALSE);
    }

//******************************************************************************
//
//  Function:   getAvailableModes
//
//  Routine Description:
//
//     Calls the miniport to get the master list of modes in the registry.
//     Returns the number of entries in the videomode buffer 'modeInformation'.
//     0 means no modes are supported by the miniport or that an error occured.
//     The number of modes returned is the total number of modes in the master mode list
//     read from the registry and returned via 'modeInformation'.
//     The actual number of modes supported in the current
//     desktop (standard/clone/span modes and EDID based pruning) which needs to be
//     exported to the GDI via DrvgetModes() is returned in the out parameter 'pcNumGDIModes'.
//     The validated GDI modes in the 'modeINformation' list can be identified by the 'Length'
//     field being non-zero.
//
//     NOTE: the buffer must be freed up by the caller.
//
//  Arguments:
//
//  Return Value:
//
//
//
//******************************************************************************


DWORD getAvailableModes(
HANDLE                   hDriver,
PVIDEO_MODE_INFORMATION* modeInformation,       // Must be freed by caller
DWORD*                   cbModeSize,
DWORD*                   pcNumGDIModes)

{
    ULONG                   ulTemp, ulRet, ulRetSize;
    VIDEO_NUM_MODES         modes;
    PVIDEO_MODE_INFORMATION pVideoTemp;
    NVTWINVIEWDATA sData;
    ULONG   TwinView_State, TwinView_Orientation;
    ULONG   ReturnedDataLength, NumDacsOnBoard;
    GET_NUMBER_DACS   NumberDacs;
    ULONG   PrimaryHead;
    ULONG   PrimaryDeviceMask;
    ULONG   ulDeviceDisplay[NV_NO_DACS];
    ULONG TwinViewRegistryDataOK = 0;
    MODE_ENTRY RequestedMode, BestFitMode;
    ULONG MaxCommonWidth, MaxCommonHeight;
    ULONG i, j;
    ULONG PhysWidth, PhysHeight, ulHead;
    MODE_ENTRY *PhysModeList[NV_NO_DACS];
    ULONG NumPhysModes[NV_NO_DACS];
    MODE_ENTRY *SingleVirtualModeList;
    ULONG NumSingleVirtualModes;
    MODE_ENTRY *PhysModePtr;
    MODE_ENTRY *DestPtr;
    BOOLEAN bFoundPhysMode;
    ULONG MustHaveResolution;
    DWORD cNumGDIModes = 0;

    *pcNumGDIModes = 0;    
    //**************************************************************************
    // Get the number of modes supported by the mini-port
    //**************************************************************************

    if (EngDeviceIoControl(hDriver,
                           IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES,
                           NULL,
                           0,
                           &modes,
                           sizeof(VIDEO_NUM_MODES),
                           &ulTemp))
    {
        DISPDBG((1, "getAvailableModes - Failed VIDEO_QUERY_NUM_AVAIL_MODES"));
        return(0);
    }

    *cbModeSize = modes.ModeInformationLength;

    //**************************************************************************
    // Allocate the buffer for the mini-port to write the modes in.
    //**************************************************************************

    *modeInformation = EngAllocMem(FL_ZERO_MEMORY,
                                   modes.NumModes * modes.ModeInformationLength,
                                   ALLOC_TAG);

    if (*modeInformation == (PVIDEO_MODE_INFORMATION) NULL)
    {
        DISPDBG((0, "getAvailableModes - Failed EngAllocMem"));
        return 0;
    }


    //**************************************************************************
    // See if we are in clone or normal or multimon mode on a dual head system.
    // if we are on a single head system, then we always assume a normal mode.
    //**************************************************************************
    NumberDacs.ulNumberDacsOnBoard = 1;
    NumberDacs.ulNumberDacsConnected = 1;
    if (EngDeviceIoControl(hDriver,
                           IOCTL_VIDEO_GET_NUMBER_DACS,
                           NULL,
                           0,
                           &NumberDacs,
                           sizeof(NumberDacs),
                           &ReturnedDataLength))
    {
        DISPDBG((0, "getAvailableModes() - IOCTL_VIDEO_GET_NUMBER_DACS failed"));
    }
    else
    {
        DISPDBG((6, "Got NumDacsOnBoard: 0x%x, NumDacsConnected: 0x%x\n",NumberDacs.ulNumberDacsOnBoard,
                 NumberDacs.ulNumberDacsConnected ));
    }
    if (NumberDacs.ulNumberDacsOnBoard == 0 || NumberDacs.ulNumberDacsOnBoard > 2)
    {
        DISPDBG((0, "Oops! Invalid NumberDacs.ulNumberDacsOnBoard: 0x%x, assuming single headed board\n",NumberDacs.ulNumberDacsOnBoard));
        NumberDacs.ulNumberDacsOnBoard = 1;
    }
    if (NumberDacs.ulNumberDacsConnected == 0 || NumberDacs.ulNumberDacsConnected > 2)
    {
        DISPDBG((0, "Oops! Invalid NumberDacs.ulNumberDacsConnected: 0x%x, assuming single headed board\n",NumberDacs.ulNumberDacsConnected));
        NumberDacs.ulNumberDacsConnected = 1;
    }

    //
    // Assume a safe default state
    //
    TwinView_State = NVTWINVIEW_STATE_NORMAL;

    PrimaryHead = NumberDacs.ulDeviceDisplay[0];
    PrimaryDeviceMask = NumberDacs.ulDeviceMask[PrimaryHead];

    //
    // Initialize the modelist pointers to NULL
    //
    for (i=0; i < NV_NO_DACS; i++)
    {
        PhysModeList[i] = NULL;
        ulDeviceDisplay[i]= NumberDacs.ulDeviceDisplay[i];
    }
    SingleVirtualModeList = NULL;

    
    if ((NumberDacs.ulNumberDacsOnBoard == 2 && NumberDacs.ulNumberDacsConnected == 2) ||
        (NumberDacs.ulNumberDacsOnBoard == 2 && NumberDacs.ulNumberDacsConnected == 1) ||
        (NumberDacs.ulNumberDacsOnBoard == 1 && NumberDacs.ulNumberDacsConnected == 1))
    {
        
        if (EngDeviceIoControl(hDriver,
                               IOCTL_VIDEO_GET_TWINVIEW_STATE,
                               NULL,
                               0,
                               &sData,
                               sizeof(NVTWINVIEWDATA),
                               &ReturnedDataLength))
        {
            DISPDBG((3, "InitMultiMon() - IOCTL_VIDEO_GET_TWINVIEW_STATE failed"));
            TwinView_State = NVTWINVIEW_STATE_NORMAL;
        }
        else
        {
            DISPDBG((6,"Read the registry state as: 0x%x\n",sData.dwState));

            // sanity check to see if the TwinViewInfo data is valid.
            // 'NULL' is because we don't get a pointer to ppdev in DrvGetModes.
            if (sData.dwState == NVTWINVIEW_STATE_DUALVIEW)
                TwinView_State = sData.dwState;

            if (!TwinViewDataOK((PPDEV)NULL, &sData))
            {
                TwinViewRegistryDataOK = 0; 
            }
            else
            {
                TwinView_State = sData.dwState;
                TwinView_Orientation = sData.dwOrientation;
                PrimaryHead = sData.dwDeviceDisplay[0];
                PrimaryDeviceMask = sData.NVTWINVIEWUNION.nvtwdevdata[PrimaryHead].dwDeviceMask;

                for (i = 0; i < NV_NO_DACS; i++)
                    ulDeviceDisplay[i]= sData.dwDeviceDisplay[i];
                DISPDBG((6,"Read the Primary head as: 0x%x\n",PrimaryHead));
                TwinViewRegistryDataOK = 1;

                if (TwinView_State != NVTWINVIEW_STATE_NORMAL && TwinView_State != NVTWINVIEW_STATE_CLONE &&
                    TwinView_State != NVTWINVIEW_STATE_DUALVIEW && TwinView_State != NVTWINVIEW_STATE_SPAN)
                {
                    DISPDBG((0, "getAvailableModes - Invalid State read from registry: 0x%x,TwinView_State"));
                    return 0;
                }
                if (TwinView_State == NVTWINVIEW_STATE_SPAN)
                {
                    if (TwinView_Orientation != HORIZONTAL_ORIENTATION && TwinView_Orientation != VERTICAL_ORIENTATION)
                    {
                        DISPDBG((0, "getAvailableModes - Invalid Orientation read from registry: 0x%x for MULTIMON state\n",TwinView_Orientation));
                        return 0;
                    }
                }
            }
        }
    }



    //**************************************************************************
    // Ask the mini-port to fill in the available modes.
    //**************************************************************************

    if (EngDeviceIoControl(hDriver,
                           IOCTL_VIDEO_QUERY_AVAIL_MODES,
                           NULL,
                           0,
                           *modeInformation,
                           modes.NumModes * modes.ModeInformationLength,
                           &ulTemp))
    {

        DISPDBG((1, "getAvailableModes - Failed VIDEO_QUERY_AVAIL_MODES"));

        EngFreeMem(*modeInformation);
        *modeInformation = (PVIDEO_MODE_INFORMATION) NULL;

        return(0);
    }

    //**************************************************************************
    // Allocate the temporary buffers to hold the physical modelist
    // for each head and the single resolution virtual mode list.
    //**************************************************************************
    for (i = 0; i < NumberDacs.ulNumberDacsOnBoard; i++)
    {
        PhysModeList[i] = (MODE_ENTRY *)EngAllocMem(FL_ZERO_MEMORY,
                                                    modes.NumModes * sizeof(MODE_ENTRY),
                                                    ALLOC_TAG);
        if (PhysModeList[i] == (MODE_ENTRY *) NULL)
        {
            DISPDBG((0, "getAvailableModes - Failed EngAllocMem for PhysModeList: %d", i));
            goto getAvailableModesFailure;
        }
    }

    SingleVirtualModeList = (MODE_ENTRY *)EngAllocMem(FL_ZERO_MEMORY,
                                                      modes.NumModes * sizeof(MODE_ENTRY),
                                                      ALLOC_TAG);
    if (SingleVirtualModeList == (MODE_ENTRY *) NULL)
    {
        DISPDBG((0, "getAvailableModes - Failed EngAllocMem for PhysModeList1"));
        goto getAvailableModesFailure;
    }

    // Invalidate all the doubled modes from the VirtualModeList.
    NumSingleVirtualModes = 0;
    pVideoTemp = *modeInformation;
    DestPtr = SingleVirtualModeList;
    for (i=0; i<modes.NumModes; i++)
    {
        if (pVideoTemp)
        {
            if (MULTIMON_MODE(pVideoTemp->VisScreenWidth,pVideoTemp->VisScreenHeight))
            {
                // Do not copy.
                pVideoTemp++;
                continue;
            }
            // This is a single resolution virtual mode. So copy it.
            DestPtr->Width = (USHORT)pVideoTemp->VisScreenWidth;
            DestPtr->Height = (USHORT)pVideoTemp->VisScreenHeight;
            DestPtr->Depth = (USHORT)pVideoTemp->BitsPerPlane;
            DestPtr->RefreshRate = (USHORT)pVideoTemp->Frequency;
            DestPtr->ValidMode = TRUE;
            NumSingleVirtualModes++;
            DestPtr++;
            pVideoTemp++;
        }
    }

    //**************************************************************************
    // Now see which of these modes are supported by the display driver.
    // As an internal mechanism, set the length to 0 for the modes we
    // DO NOT support.
    //**************************************************************************

    ulTemp = modes.NumModes;
    pVideoTemp = *modeInformation;

    
    //**************************************************************************
    // Get the physical mode list for all the heads from miniport.
    // We already have this info in PDEV but we don't get the ppdev passed to us
    // in DrvGetModes()
    //**************************************************************************
    for (i=0; i < NumberDacs.ulNumberDacsOnBoard; i++)
    {
        HEAD_MODE_LIST_INFO VirtInfo;
        
        ulHead = ulDeviceDisplay[i];
        VirtInfo.ulHead = ulHead;

        // Use the correct default values if the registry entry is absent
        if (!TwinViewRegistryDataOK)
        {
            VirtInfo.ulDeviceMask = NumberDacs.ulDeviceMask[ulHead];
            VirtInfo.ulDeviceType = NumberDacs.ulDeviceType[ulHead];
            VirtInfo.ulTVType = NumberDacs.ulTVFormat[ulHead];
            VirtInfo.ulEnableDDC = 1;
        }
        else
        {
            VirtInfo.ulDeviceMask = sData.NVTWINVIEWUNION.nvtwdevdata[ulHead].dwDeviceMask;
            VirtInfo.ulDeviceType = sData.NVTWINVIEWUNION.nvtwdevdata[ulHead].dwDeviceType;
            VirtInfo.ulTVType = sData.NVTWINVIEWUNION.nvtwdevdata[ulHead].dwTVFormat;
            VirtInfo.ulEnableDDC = sData.NVTWINVIEWUNION.nvtwdevdata[ulHead].dwEnableDDC;
            VirtInfo.ulEnableDDC = 1;
        }
        
        VirtInfo.pVirtualModeList = SingleVirtualModeList;
        VirtInfo.ulNumVirtualModes = NumSingleVirtualModes;

        VirtInfo.pPhysicalModeList = PhysModeList[ulHead];

        // Call the IOCTL for the miniport to return the physical modes.
        ulRet = EngDeviceIoControl(hDriver,
                                   IOCTL_VIDEO_GET_HEAD_PHYSICAL_MODE_LIST,
                                   (HEAD_MODE_LIST_INFO *)&VirtInfo,
                                   sizeof(HEAD_MODE_LIST_INFO),
                                   NULL,
                                   0,
                                   &(ulRetSize));
        if (ulRet)
        {
            DISPDBG((0,"Oops! IOCTL_VIDEO_GET_HEAD_PHYSICAL_MODE_LIST failed!"));
            return(FALSE);
        }
        else
        {
            if (ulRetSize == 0)
            {
                DISPDBG((0,"Oops! Number of physical modes for head: %d is 0",i));
                return(FALSE);
            }

            NumPhysModes[ulHead] = ulRetSize/sizeof(MODE_ENTRY);

        }
    }
    

    //**************************************************************************
    // Mode is rejected if it is not one plane, or not graphics, or is not
    // one of 8, 16, 32 bits per pel.
    //**************************************************************************

    while (ulTemp--)
    {

        if ((pVideoTemp->NumberOfPlanes != 1 ) ||
            !(pVideoTemp->AttributeFlags & VIDEO_MODE_GRAPHICS) ||
            ((pVideoTemp->BitsPerPlane != 8) &&
             (pVideoTemp->BitsPerPlane != 15) &&
             (pVideoTemp->BitsPerPlane != 16) &&
             (pVideoTemp->BitsPerPlane != 24) && //24bpp
             (pVideoTemp->BitsPerPlane != 32)))
        {
            DISPDBG((2, "Rejecting miniport mode:"));
            DISPDBG((2, "   Screen width  -- %li", pVideoTemp->VisScreenWidth));
            DISPDBG((2, "   Screen height -- %li", pVideoTemp->VisScreenHeight));
            DISPDBG((2, "   Bits per pel  -- %li", pVideoTemp->BitsPerPlane *
                     pVideoTemp->NumberOfPlanes));
            DISPDBG((2, "   Frequency     -- %li", pVideoTemp->Frequency));

            pVideoTemp->Length = 0;
        }


        // export only single resolution modes for the normal or clone modes


        MustHaveResolution = 0;

        if(TwinView_State == NVTWINVIEW_STATE_SPAN && 
            pVideoTemp->VisScreenWidth != 480 && pVideoTemp->VisScreenHeight != 360 &&
            pVideoTemp->VisScreenWidth <= 640 && pVideoTemp->VisScreenHeight <= 480)
        {
            // Also export low resolution for spanning mode for DirectDraw
            MustHaveResolution = 1;
        }
        else  
        {
            // The exception is the 640x480 and 800x600 modes which NT4.0 and Win2K expects to be there always.
            // In win2k, GDI inserts 640x480 and 800x600 modes at 4bpp if the driver does not support it natively.
            // Also PC99 14.8 says that 1024x768 should always be supported.

            if ((pVideoTemp->VisScreenWidth == 640 && pVideoTemp->VisScreenHeight == 480) ||
                (pVideoTemp->VisScreenWidth == 800 && pVideoTemp->VisScreenHeight == 600) ||
                (pVideoTemp->VisScreenWidth == 1024 && pVideoTemp->VisScreenHeight == 768))
            {
            // do not skip these modes. Otherise you will see the ugly 4BPP vga modes show up in NT panel list of modes.
            MustHaveResolution = 1;
            }
        }


        if (TwinView_State == NVTWINVIEW_STATE_NORMAL || TwinView_State == NVTWINVIEW_STATE_CLONE || TwinView_State == NVTWINVIEW_STATE_DUALVIEW)
        {
            if (MULTIMON_MODE(pVideoTemp->VisScreenWidth,pVideoTemp->VisScreenHeight))
            {
                pVideoTemp->Length = 0;
            }
        }

        // export only horizontal doubled modes if the state is MULTIMON and orinetation is HORIZONTAL
        if (TwinView_State == NVTWINVIEW_STATE_SPAN && TwinView_Orientation == HORIZONTAL_ORIENTATION)
        {
            if (!(HORIZONTAL_MODE(pVideoTemp->VisScreenWidth,pVideoTemp->VisScreenHeight)))
            {
                if (!MustHaveResolution)
                {
                    pVideoTemp->Length = 0;
                }

            }
        }

        // export only vertical doubled modes if the state is MULTIMON and orinetation is VERTICAL
        if (TwinView_State == NVTWINVIEW_STATE_SPAN && TwinView_Orientation == VERTICAL_ORIENTATION)
        {
            if (!(VERTICAL_MODE(pVideoTemp->VisScreenWidth,pVideoTemp->VisScreenHeight)))
            {
                if (!MustHaveResolution)
                {
                    pVideoTemp->Length = 0;
                }
            }
        }


        


        //
        // Peter Daifuku's specs says that for Rel 6.0, we limit the desktop to 2X the smaller of the two displays.
        // i.e., no pan-scan for either heads.
        // Also, if the INF specifies PAN_SCAN_SELECTION_DISABLE_ALL such as for Gateway, we disallow pan-scan for both heads
        // in clone mode (and standard and span modes).
        //
        if ((TwinView_State == NVTWINVIEW_STATE_SPAN) ||
            (NumberDacs.PanScanSelection == PAN_SCAN_SELECTION_DISABLE_ALL && (TwinView_State == NVTWINVIEW_STATE_CLONE)))
        {
            // see if this mode has already been rejected.
            if (pVideoTemp->Length != 0)
            {
                if (TwinViewRegistryDataOK)
                {
                    PhysWidth =  pVideoTemp->VisScreenWidth;
                    PhysHeight = pVideoTemp->VisScreenHeight;

                    // Get the physical dimensions of this mode.
                    if (HORIZONTAL_MODE(pVideoTemp->VisScreenWidth, pVideoTemp->VisScreenHeight))
                    {
                        PhysWidth = pVideoTemp->VisScreenWidth / 2;
                    }
                    if (VERTICAL_MODE(pVideoTemp->VisScreenWidth, pVideoTemp->VisScreenHeight))
                    {
                        PhysHeight = pVideoTemp->VisScreenHeight / 2;
                    }

                    //
                    // Now see if this physical mode is supported by both heads. 
                    // If not, we do not support this spanning mode.
                    //
                    for (i = 0; i < NV_NO_DACS; i++)
                    {
                        ulHead = ulDeviceDisplay[i];
                        PhysModePtr = PhysModeList[ulHead];
                        bFoundPhysMode = FALSE;

                        for (j=0; j < NumPhysModes[ulHead]; j++)
                        {
                            // Do not test the refresh rate because we allow it to be different on
                            // both the heads.
                            if (PhysModePtr->Width == PhysWidth && PhysModePtr->Height == PhysHeight &&
                                PhysModePtr->Depth == pVideoTemp->BitsPerPlane &&
                                PhysModePtr->ValidMode)
                            {
                                // Found a match.
                                bFoundPhysMode = TRUE;
                                break;
                            }
                            PhysModePtr++;
                        }

                        // Special case.
                        // Toshiba wants 1400x1050 to be exported only if panel supports it
                        // natively.
                        if (NumberDacs.PanScanSelection == PAN_SCAN_SELECTION_ENABLE_ALL && 
                            PhysWidth == 1400 && PhysHeight == 1050 && 
                            NumberDacs.ulDFPSupports1400x1050 == 0)
                        {
                            // Disallow the mode.
                            pVideoTemp->Length = 0;
                            break;
                        }

                        // Special case
                        // The common modeset code does not allow two low res modes for DFP
                        // These are 480x360 and 960x720. So do not export these modes.
                        // To be more symmetrical, we will disallow these modes irrespective of the 
                        // device types and platforms.
                        if ((PhysWidth == 480 && PhysHeight == 360) ||
                            (PhysWidth == 960 && PhysHeight == 720) )
                        {
                            // Disallow the mode.
                            pVideoTemp->Length = 0;
                            break;
                        }

                        
                        if (!bFoundPhysMode)
                        {
                            // This head does not support pan-scan. So ignore this mode.
                            // On Toshiba, we allow pan-scan for spanning modes also.
                            if (NumberDacs.PanScanSelection == PAN_SCAN_SELECTION_ENABLE_ALL)
                            {
                                // Do nothing
                            }

                            else
                            {
                                // Disallow the mode.
                                pVideoTemp->Length = 0;
                            }


                            break;
                        }
                    } // for each DAC
                } // registry data is OK
            } // Mode is valid
        } // State is MULTIMON


        // In normal mode or clone mode or multimon mdoe, each and every mode exported to GDI should be supported 
        // by the primary monitor as NT/Win2K directly control the primary screen.
        if ((pVideoTemp->Length != 0) &&
            (TwinView_State == NVTWINVIEW_STATE_NORMAL ||
             TwinView_State == NVTWINVIEW_STATE_DUALVIEW ||
             TwinViewRegistryDataOK)
           ) 
        {
            PhysWidth = (unsigned short)(pVideoTemp->VisScreenWidth);
            PhysHeight = (unsigned short)(pVideoTemp->VisScreenHeight);

            //
            // Note: Peter Daifuku's requirement states as follows
            // 1. For normal mode, allow pan/scan for primary. So filter based on refresh rate only.
            //    However, it is off by default unless user explicitly turns on panning in the panel.
            // 2. For clone mode, do not allow pan/scan for primary. So we need to filter based on refresh rate,
            //    width and height.
            // 3. For multimon mode, do not allow pan/scan for primary (and secondary). 
            //    So we need to filter based on refresh rate, width and height.
            //
            if (TwinView_State == NVTWINVIEW_STATE_SPAN)
            {
                // Get the physical dimensions of this mode.
                if (HORIZONTAL_MODE(pVideoTemp->VisScreenWidth, pVideoTemp->VisScreenHeight))
                {
                    PhysWidth = pVideoTemp->VisScreenWidth / 2;
                }
                if (VERTICAL_MODE(pVideoTemp->VisScreenWidth, pVideoTemp->VisScreenHeight))
                {
                    PhysHeight = pVideoTemp->VisScreenHeight / 2;
                }
            }

            if (TwinViewRegistryDataOK)
            {
                ulHead = sData.dwDeviceDisplay[0];
            }
            else
            {
                // Determine whether to use head0 or head1.
                // If you have only one head connected on a dual head card, use the head which
                // has a valid device connected to it.
                if (NumberDacs.ulNumberDacsOnBoard == 1)
                {
                    ulHead = 0;
                }
                else if (NumberDacs.ulNumberDacsOnBoard == 2 && TwinView_State == NVTWINVIEW_STATE_NORMAL)
                {
                    if (NumberDacs.ulDeviceMask[0] == BITMASK_INVALID_DEVICE && NumberDacs.ulDeviceMask[1] != BITMASK_INVALID_DEVICE)
                    {
                        ulHead = 1;
                    }
                    if (NumberDacs.ulDeviceMask[0] != BITMASK_INVALID_DEVICE && NumberDacs.ulDeviceMask[1] == BITMASK_INVALID_DEVICE)
                    {
                        ulHead = 0;
                    }
                    if (NumberDacs.ulDeviceMask[0] == BITMASK_INVALID_DEVICE && NumberDacs.ulDeviceMask[1] == BITMASK_INVALID_DEVICE)
                    {
                        // Pathological case. Nothing is connected!
                        ulHead = 0;
                    }
                    if (NumberDacs.ulDeviceMask[0] != BITMASK_INVALID_DEVICE && NumberDacs.ulDeviceMask[1] != BITMASK_INVALID_DEVICE)
                    {
                        // A valid device is connected to both heads. Let us choose head0 as default.
                        ulHead = 0;
                    }
                }
                else if (NumberDacs.ulNumberDacsOnBoard == 2 && TwinView_State == NVTWINVIEW_STATE_DUALVIEW)
                {
                    ulHead = sData.dwDeviceDisplay[0];
                }
            }

            PhysModePtr = PhysModeList[ulHead];
            bFoundPhysMode = FALSE;

            for (j = 0; j < NumPhysModes[ulHead]; j++)
            {
                if (PhysModePtr->Width == PhysWidth && PhysModePtr->Height == PhysHeight &&
                    PhysModePtr->Depth == pVideoTemp->BitsPerPlane &&
                    PhysModePtr->RefreshRate == pVideoTemp->Frequency &&
                    PhysModePtr->ValidMode)
                {
                    // Found a match.
                    bFoundPhysMode = TRUE;
                    break;
                }
                PhysModePtr++;
            }

            if (!bFoundPhysMode)
            {
                // This head does not support pan-scan. So ignore this mode.
                // On Toshiba laptops, we allow pan-scan on standard mode and clone mode and multimon mode also.
                if ( NumberDacs.PanScanSelection == PAN_SCAN_SELECTION_ENABLE_ALL )
                {
                    // Do nothing.
                }
#if _WIN32_WINNT >= 0x500
                else
                if (bQueryGDIModePruning(TwinView_State, PrimaryHead, PrimaryDeviceMask, 
                        PrimaryHead,  PrimaryDeviceMask, NumberDacs.ACPISystem, NumberDacs.GDIModePruning))
                {
                    //
                    // We let GDI do the mode pruning for the EDID
                    //
                    // Do nothing
                }
#endif
                else
                {
                    // Do not allow this mode.
                    pVideoTemp->Length = 0;
                }
            }

            // Special case.
            // Toshiba wants 1400x1050 to be exported only if panel supports it
            // natively.
            if (NumberDacs.PanScanSelection == PAN_SCAN_SELECTION_ENABLE_ALL && 
                PhysWidth == 1400 && PhysHeight == 1050 && 
                NumberDacs.ulDFPSupports1400x1050 == 0)
            {
                // Disallow the mode.
                pVideoTemp->Length = 0;
            }

            // Special case
            // The common modeset code does not allow two low res modes for DFP
            // These are 480x360 and 960x720. So do not export these modes.
            // To be more symmetrical, we will disallow these modes irrespective of the 
            // device types and platforms.
            if ((PhysWidth == 480 && PhysHeight == 360) ||
                (PhysWidth == 960 && PhysHeight == 720) )
            {
                // Disallow the mode.
                pVideoTemp->Length = 0;
            }

        } // Normal or clone mode or multimon mode.

        //
        // If this mode was found valid for GDI for current desktop settings, increment the counter.
        //
        if (pVideoTemp->Length)
        {
            cNumGDIModes++;
        }
        


        //**********************************************************************
        // Check next mode
        //**********************************************************************

        pVideoTemp = (PVIDEO_MODE_INFORMATION)
                     (((PUCHAR)pVideoTemp) + modes.ModeInformationLength);
    }

    // Free up the temporary memory allocations.
    for (i = 0; i < NumberDacs.ulNumberDacsOnBoard; i++)
    {
        EngFreeMem(PhysModeList[i]);
    }
    EngFreeMem(SingleVirtualModeList);

    *pcNumGDIModes = cNumGDIModes;
    return(modes.NumModes);

getAvailableModesFailure:
    for (i = 0; i < NumberDacs.ulNumberDacsOnBoard; i++)
    {
        if (PhysModeList[i] != NULL)
        {
            EngFreeMem(PhysModeList[i]);
        }
    }
    if (*modeInformation != NULL) 
    {
        EngFreeMem(*modeInformation);
    }
    *pcNumGDIModes = 0;
    return 0;
}

#if (_WIN32_WINNT >= 0x0500)
//******************************************************************************
//
//  Function: DrvNotify
//
//  Routine Description: Attempts to allocate push buf from AGP memory, if
//  there is no AGP memory it falls back to allocating the push buf from
//  system memory.
//
//  Arguments:
//
//  Return Value:
//            TRUE or FALSE
//
//
//******************************************************************************
void DrvNotify(
    SURFOBJ *hsurf,
    ULONG iType,
    PVOID pvData)
    {

    if (hsurf && pvData)
        {
        PDEV* ppdev = (PDEV *)hsurf->dhpdev;

        switch(iType)
            {
            case DN_DEVICE_ORIGIN:
                {
                POINTL *devOrigin;

                devOrigin = (POINTL *)pvData;
                ppdev->left = devOrigin->x;
                ppdev->top = devOrigin->y;
                }
                break;
            default:
                break;
            }
        }

    }

#endif // #if _WIN32_WINNT >= 0x0500
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\escape.c ===
//***************************** Module Header **********************************
//
// Module Name: escape.c
//
// Escape handler for drivers and other escapes.
//
// Copyright (c) 1996 Microsoft Corporation
//
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"
#include "driver.h"

#include "excpt.h"
#include "nv32.h"
#include "nvos.h"
#include "nvntioctl.h"
//#include "nvntddctl.h"
//#include "nvosnt.h"
#include "nvsubch.h"
#include "nvapi.h"
#include "nvReg.h"
#if (NVARCH >= 0x4)
#if _WIN32_WINNT >= 0x0500
#include "nvPriv.h"
#endif
#endif

#include "wksappsupport.h"

#include "nv32.h"
#include "dmamacro.h"

#include "nvsubch.h"
#include "nvalpha.h"
#include "nvapi.h"

#include "oglDD.h"
#include "oglOverlay.h"
#include "oglsync.h"
#ifdef NV_MAIN_MULTIMON
#include "oglutils.h"
#endif
#include "pixelfmt.h"

// To get the NV11 twinview definitions
#include "escape.h"
#include "nvcm.h"
extern BOOLEAN   TwinViewDataOK(PPDEV ppdev, NVTWINVIEWDATA *pData);
extern void PrintTwinViewData (char *Msg, ULONG ulDebugLevel, NVTWINVIEWDATA *pData, PPDEV ppdev);
extern BOOLEAN bGetPhysicalVirtualModeList(PPDEV ppdev, ULONG Head, ULONG DeviceMask, ULONG DeviceType, ULONG TVFormat,
        MODE_ENTRY *PhysModeList, MODE_ENTRY *VirtModeList, ULONG *NumPhysModes, ULONG *NumVirtModes);
extern void InduceAndUpdateDeviceScanning (PPDEV ppdev);

extern void   ProcessSynchronousFlags(PPDEV ppdev, NVTWINVIEWDATA *pData);
extern VOID WriteRegistryTwinViewInfo (PPDEV ppdev, NVTWINVIEWDATA *pData);

extern VOID SetInduceRegValue(PPDEV ppdev, ULONG ulVal);
extern NVTWINVIEWDATA * pFindSaveSettings(PPDEV ppdev, QUERY_SAVE_SETTINGS * pQuery, NVTWINVIEWDATA * pTwinViewData);
extern VOID vWriteSaveSettings(PPDEV ppdev);
BOOLEAN bHandleNT4HotKey(PPDEV ppdev, GET_DEVICE_MASK_DATA_TYPE *pInfo);

#if 0 // defined in common\win9x\inc\escape.h
// - Added escapes for output device set/get
#define NV_ESC_SET_DISPLAY_DEVICE_TYPE  0x6E84
#define NV_ESC_GET_DISPLAY_DEVICE_TYPE  0x6E85
// - Added to provide the path to the driver reg area (hard coded under winnt4)
#define NV_ESC_GET_LOCAL_REGISTRY_PATH      0x6E7F
// - Added to provide id of the board and type
#define NV_ESC_IS_NVIDIA_BOARD_AND_DRIVER   0x6E80
// - Added escape to validate a mode for a device
#define NV_ESC_VALIDATE_DEVICE_MODE         0x6E83
// - From nvVer.h, the escape value for driver verification
#endif
#define NV_ESCAPE_ID                'nv'
#define NV_ESCAPE_ID_RETURN         0x3031564E  // "NV10"


#if 0
//
// Since we are including escape.h now, we don't need to define the structure here. Otherwise we get a redefinition error.
//

// - Data struct for NV_ESC_SET_DISPLAY_DEVICE_TYPE / NV_ESC_GET_DISPLAY_DEVICE_TYPE
typedef struct  tagSETGETDEVTYPE
{
    unsigned long   dwSuccessFlag;
    unsigned long   dwDeviceType;
    unsigned long   dwTvFormat;
} SETGETDEVTYPE, *PSETGETDEVTYPE;
#else
typedef SETGETDEVTYPE *PSETGETDEVTYPE;
#endif // 0



// - Data struct for NV_ESC_VALIDATE_DEVICE_MODE
typedef struct  tagVALMODEEXTR
{
    unsigned long   dwHRes;
    unsigned long   dwVRes;
    unsigned long   dwBpp;
    unsigned long   dwRefresh;
    unsigned long   dwDeviceType;
} VALMODEXTR;

// - Added function protos for support functions added
BOOL  nvSetDisplayDevice(PDEV *ppdev, PSETGETDEVTYPE pvIn);
BOOL  nvGetDisplayDevice(PDEV *ppdev, PSETGETDEVTYPE pvIn);
BOOL  __cdecl nvDoValidateDeviceModeEsc(PDEV *ppdev, VALMODEXTR *pvIn, DWORD *pvOut);
BOOL  nvGetDisplayDeviceClass(PDEV *ppdev, ULONG *deviceclass);


//
// Before calling RM IOCTL routines use csFifo mutex.  This is also
// used before kicking off push buffers.  This should remove any chance
// that a software interrupt can get into the resource manager at the
// same time as a user IOCTL on MP systems.
//
#define NVDMAPUSHMODESWITCHCOUNT 0x6986

#define CHECK_PDEV_NULL(_STR) \
    if (ppdev == NULL || pvIn == NULL || pvOut == NULL) \
        { \
        DISPDBG((0, "DrvEscape - %s NULL error!", _STR)); \
        return(FALSE); \
        }
#define CHECK_IN_OUT_SIZE(_STR, _INSIZE, _OUTSIZE) \
    if (_INSIZE != cjIn) \
        { \
        DISPDBG((0, "DrvEscape - %s input size error! needed:%d != cjIn:%d", _STR, _INSIZE, cjIn)); \
        return(FALSE); \
        } \
    if (_OUTSIZE != cjOut) \
        { \
        DISPDBG((0, "DrvEscape - %s output size error! needed:%d != cjOut:%d ", _STR, _OUTSIZE, cjOut)); \
        return(FALSE); \
        }

#define OGL_ESCAPE_FAIL_TEST(_PPDEV) ((_PPDEV)->oglMutexPtr == NULL)

static ULONG DoOpenGLEscapeCommand(PPDEV ppdev, PVOID in, PVOID out);

#ifdef NV3
// WARNING: This structure is defined in the client side.
// Don't change it without changing the OpenGL clients too.
typedef struct Nv3DmaPushInfo {
    DWORD dwChID;
    DWORD dwTlbPtBase;
    DWORD dwAddressSpace;
    DWORD get;
    DWORD put;
    DWORD localModeSwitchCount;
    DWORD hClient;
    DWORD hDevice;
} Nv3DmaPushInfo;

extern ULONG NV3_DmaPushGo(PDEV *ppdev, ULONG chID, ULONG tlbPtBase, ULONG busAddressSpace, ULONG getOffset, ULONG putOffset, ULONG hClient, ULONG hDevice);
#endif

static ULONG OglCheckForClientDll(PDEV *ppdev);

//******************************************************************************
//
//  Function:   DrvEscape(SURFOBJ *, ULONG, ULONG, VOID *, ULONG cjOut, VOID *pvOut)
//
//  Routine Description:
//
//      Driver escape entry point.  This function should return TRUE for any
//      supported escapes in response to QUERYESCSUPPORT, and FALSE for any
//      others.  All supported escapes are called from this routine.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************


ULONG DrvEscape(SURFOBJ *pso, ULONG iEsc,
                ULONG cjIn, VOID *pvIn,
                ULONG cjOut, VOID *pvOut)

    {
    ULONG   retVal;
    ULONG   oglSupported;
    ULONG   returnedDataLength;
    ULONG   cbReturned;
    PDEV    *ppdev = (PDEV *)pso->dhpdev;

#ifdef _WIN32_WINNT // >= NT 4.x

    //**************************************************************************
    //
    // On 64 bit systems, the following switch statement is for escape codes
    // that are handled identically on both 32 and 64 bit clients.
    // This primarily means the RM calls where the incoming parameter
    // structure is deliberately sized the same for both models.
    //
    // When in doubt, add new escapes to the second switch statement below.
    //
    //**************************************************************************
    switch(iEsc)
    {
    case NV_ESC_RM_OPEN:
        {
        CHECK_PDEV_NULL("NV_OPEN");
        CHECK_IN_OUT_SIZE("NV_OPEN", sizeof(DWORD), sizeof(DWORD));

        ppdev->pfnAcquireOglMutex(ppdev);
        (*(HANDLE *)pvOut) = NvOpen(ppdev->hDriver);
        ppdev->pfnReleaseOglMutex(ppdev);

        return(TRUE);
        }
        break;
    case NV_ESC_RM_CLOSE:
        {
        CHECK_PDEV_NULL("NV_CLOSE");
        CHECK_IN_OUT_SIZE("NV_CLOSE", sizeof(DWORD), sizeof(DWORD));

        ppdev->pfnAcquireOglMutex(ppdev);
        NvClose(ppdev->hDriver);
        ppdev->pfnReleaseOglMutex(ppdev);

        return(TRUE);
        }
        break;
    case NV_ESC_RM_ALLOC_ROOT:
        {
        NVOS01_PARAMETERS *inParms, *outParms;

        CHECK_PDEV_NULL("ALLOC_ROOT");
        CHECK_IN_OUT_SIZE("ALLOC_ROOT", sizeof(NVOS01_PARAMETERS), sizeof(NVOS01_PARAMETERS));

        inParms  = (NVOS01_PARAMETERS *)pvIn;
        outParms = (NVOS01_PARAMETERS *)pvOut;
        inParms->hClass  = NV01_ROOT_USER;

        ppdev->pfnAcquireOglMutex(ppdev);
        outParms->status = NvAllocRoot(ppdev->hDriver, NV01_ROOT_USER, &inParms->hObjectNew);
        ppdev->pfnReleaseOglMutex(ppdev);

        outParms->hObjectNew = inParms->hObjectNew;

        return(TRUE);
        }
        break;
    case NV_ESC_RM_ALLOC_DEVICE:
        {
        NVOS06_PARAMETERS *inParms, *outParms;
        union
        {
            ULONG osName;
            char devName[NV_DEVICE_NAME_LENGTH_MAX+1];
        } nameBuffer;

        CHECK_PDEV_NULL("ALLOC_DEVICE");
        CHECK_IN_OUT_SIZE("ALLOC_DEVICE", sizeof(NVOS06_PARAMETERS), sizeof(NVOS06_PARAMETERS));

        inParms  = (NVOS06_PARAMETERS *)pvIn;
        outParms = (NVOS06_PARAMETERS *)pvOut;

        ppdev->pfnAcquireOglMutex(ppdev);

        // escape the device class to the device reference
        nameBuffer.osName = ppdev->ulDeviceReference;

        outParms->status = NvAllocDevice(ppdev->hDriver,
                                         inParms->hObjectParent,
                                         inParms->hObjectNew,
                                         NV03_DEVICE_XX, // inParms->hClass,
                                         (unsigned char *)nameBuffer.devName);
        ppdev->pfnReleaseOglMutex(ppdev);

        return(TRUE);
        }
        break;
    case NV_ESC_RM_ALLOC_CONTEXT_DMA:
        {
        NVOS03_PARAMETERS *inParms, *outParms;

        CHECK_PDEV_NULL("ALLOC_CONTEXT_DMA");
        CHECK_IN_OUT_SIZE("ALLOC_CONTEXT_DMA", sizeof(NVOS03_PARAMETERS), sizeof(NVOS03_PARAMETERS));

        inParms  = (NVOS03_PARAMETERS *)pvIn;
        outParms = (NVOS03_PARAMETERS *)pvOut;

        ppdev->pfnAcquireOglMutex(ppdev);
        outParms->status = NvAllocContextDma(ppdev->hDriver,
                                             inParms->hObjectParent,
                                             inParms->hObjectNew,
                                             inParms->hClass,
                                             inParms->flags,
                                             (PVOID)inParms->pBase,
                                             (ULONG)inParms->limit);
        ppdev->pfnReleaseOglMutex(ppdev);

        return(TRUE);
        }
        break;
    case NV_ESC_RM_ALLOC_CHANNEL_PIO:
        {
        NVOS04_PARAMETERS *inParms, *outParms;

        CHECK_PDEV_NULL("ALLOC_CHANNEL_PIO");
        CHECK_IN_OUT_SIZE("ALLOC_CHANNEL_PIO", sizeof(NVOS04_PARAMETERS), sizeof(NVOS04_PARAMETERS));

        inParms  = (NVOS04_PARAMETERS *)pvIn;
        outParms = (NVOS04_PARAMETERS *)pvOut;

        ppdev->pfnAcquireOglMutex(ppdev);
        outParms->status = NvAllocChannelPio(ppdev->hDriver,
                                             inParms->hRoot,
                                             inParms->hObjectParent,
                                             inParms->hObjectNew,
                                             inParms->hClass,
                                             inParms->hObjectError,
                                             (PVOID)&inParms->pChannel,
                                             inParms->flags);
        ppdev->pfnReleaseOglMutex(ppdev);

        outParms->pChannel = inParms->pChannel;

        return(TRUE);
        }
        break;
    case NV_ESC_RM_ALLOC_CHANNEL_DMA:
        {
        NVOS07_PARAMETERS *inParms, *outParms;

        CHECK_PDEV_NULL("ALLOC_CHANNEL_DMA");
        CHECK_IN_OUT_SIZE("ALLOC_CHANNEL_DMA", sizeof(NVOS07_PARAMETERS), sizeof(NVOS07_PARAMETERS));

        inParms  = (NVOS07_PARAMETERS *)pvIn;
        outParms = (NVOS07_PARAMETERS *)pvOut;

        ppdev->pfnAcquireOglMutex(ppdev);
        outParms->status = NvAllocChannelDma(ppdev->hDriver,
                                             inParms->hRoot,
                                             inParms->hObjectParent,
                                             inParms->hObjectNew,
                                             inParms->hClass,
                                             inParms->hObjectError,
                                             inParms->hObjectBuffer,
                                             inParms->offset,
                                             (PVOID)&inParms->pControl);
        ppdev->pfnReleaseOglMutex(ppdev);

        outParms->pControl = inParms->pControl;

        return(TRUE);
        }
        break;
    case NV_ESC_RM_ALLOC_MEMORY:
        {
        NVOS02_PARAMETERS *inParms, *outParms;
        PVOID memory;
        ULONG limit;

        CHECK_PDEV_NULL("ALLOC_MEMORY");
        CHECK_IN_OUT_SIZE("ALLOC_MEMORY", sizeof(NVOS02_PARAMETERS), sizeof(NVOS02_PARAMETERS));

        inParms  = (NVOS02_PARAMETERS *)pvIn;
        outParms = (NVOS02_PARAMETERS *)pvOut;

        memory = (PVOID)inParms->pMemory; 
        limit = (ULONG)inParms->pLimit; 

        ppdev->pfnAcquireOglMutex(ppdev);
        outParms->status = NvAllocMemory(ppdev->hDriver,
                                         inParms->hRoot,
                                         inParms->hObjectParent,
                                         inParms->hObjectNew,
                                         inParms->hClass,
                                         inParms->flags,
                                         &memory,
                                         &limit);
        ppdev->pfnReleaseOglMutex(ppdev);

        outParms->pMemory = (NvP64)memory;
        outParms->pLimit  = (NvU64)limit;

        return(TRUE);
        }
        break;
    case NV_ESC_RM_ALLOC:
        {
        NVOS21_PARAMETERS *inParms, *outParms;

        CHECK_PDEV_NULL("ALLOC");
        CHECK_IN_OUT_SIZE("ALLOC", sizeof(NVOS21_PARAMETERS), sizeof(NVOS21_PARAMETERS));

        inParms  = (NVOS21_PARAMETERS *)pvIn;
        outParms = (NVOS21_PARAMETERS *)pvOut;

        ppdev->pfnAcquireOglMutex(ppdev);
        outParms->status = NvAlloc(ppdev->hDriver,
                                   inParms->hRoot,
                                   inParms->hObjectParent,
                                   inParms->hObjectNew,
                                   inParms->hClass,
                                   (PVOID)inParms->pAllocParms);
        ppdev->pfnReleaseOglMutex(ppdev);

        return(TRUE);
        }
        break;
    case NV_ESC_RM_ALLOC_OBJECT:
        {
        NVOS05_PARAMETERS *inParms, *outParms;

        CHECK_PDEV_NULL("ALLOC_OBJECT");
        CHECK_IN_OUT_SIZE("ALLOC_OBJECT", sizeof(NVOS05_PARAMETERS), sizeof(NVOS05_PARAMETERS));

        inParms  = (NVOS05_PARAMETERS *)pvIn;
        outParms = (NVOS05_PARAMETERS *)pvOut;

        ppdev->pfnAcquireOglMutex(ppdev);
        outParms->status = NvAllocObject(ppdev->hDriver,
                                             inParms->hRoot,
                                             inParms->hObjectParent,
                                             inParms->hObjectNew,
                                             inParms->hClass);
        ppdev->pfnReleaseOglMutex(ppdev);

        return(TRUE);
        }
        break;
    case NV_ESC_RM_ALLOC_EVENT:
        {
        NVOS10_PARAMETERS *inParms, *outParms;

        CHECK_PDEV_NULL("ALLOC_EVENT");
        CHECK_IN_OUT_SIZE("ALLOC_EVENT", sizeof(NVOS10_PARAMETERS), sizeof(NVOS10_PARAMETERS));

        inParms  = (NVOS10_PARAMETERS *)pvIn;
        outParms = (NVOS10_PARAMETERS *)pvOut;

        ppdev->pfnAcquireOglMutex(ppdev);
        outParms->status = NvAllocEvent(ppdev->hDriver,
                                            inParms->hRoot,
                                            inParms->hObjectParent,
                                            inParms->hObjectNew,
                                            inParms->hClass,
                                            inParms->index,
#ifdef _WIN64
                                            (PVOID) inParms->hEvent);
#else
                                            (ULONG) inParms->hEvent);
#endif
        ppdev->pfnReleaseOglMutex(ppdev);

        return(TRUE);
        }
        break;
    case NV_ESC_RM_FREE:
        {
        NVOS00_PARAMETERS *inParms, *outParms;

        CHECK_PDEV_NULL("NV_FREE");
        CHECK_IN_OUT_SIZE("NV_FREE", sizeof(NVOS00_PARAMETERS), sizeof(NVOS00_PARAMETERS));

        inParms  = (NVOS00_PARAMETERS *)pvIn;
        outParms = (NVOS00_PARAMETERS *)pvOut;

        ppdev->pfnAcquireOglMutex(ppdev);
        outParms->status = NvFree(ppdev->hDriver,
                                  inParms->hRoot,
                                  inParms->hObjectParent,
                                  inParms->hObjectOld);
        ppdev->pfnReleaseOglMutex(ppdev);

        return(TRUE);
        }
        break;
    case NV_ESC_RM_ARCH_HEAP:
        {
        NVOS11_PARAMETERS *inParms, *outParms;
        ULONG             lPitch;
        FLATPTR           fpVidMem;

        CHECK_PDEV_NULL("RM_ARCH_HEAP");
        CHECK_IN_OUT_SIZE("RM_ARCH_HEAP", sizeof(NVOS11_PARAMETERS), sizeof(NVOS11_PARAMETERS));

        inParms  = (NVOS11_PARAMETERS *)pvIn;
        outParms = (NVOS11_PARAMETERS *)pvOut;

        ppdev->pfnAcquireOglMutex(ppdev);

        // copy input data to set it up
        *outParms = *inParms;

#ifdef RM_HEAPMGR
        outParms->status = NvArchHeap(ppdev->hDriver, inParms);
        outParms->offset = inParms->offset;
        outParms->pitch  = inParms->pitch;
#else
        // TODO: track heap allocations and cleanup on process
        // termination in DestroyContextClientInfo.
        if (inParms->function == NVOS11_HEAP_ALLOC_SIZE)
            {
            lPitch = (ULONG)inParms->pitch;
            lPitch = (lPitch + ppdev->ulSurfaceAlign) & ~ppdev->ulSurfaceAlign;
            NVHEAP_ALLOC(fpVidMem, lPitch * inParms->height, TYPE_IMAGE);
            inParms->offset = (ULONG)fpVidMem;
            if (inParms->offset)
                {
                outParms->offset = inParms->offset;
                outParms->pitch  = inParms->pitch;
                outParms->status = NVOS11_STATUS_SUCCESS;
                }
            else
                {
                outParms->offset = inParms->offset;
                outParms->pitch  = inParms->pitch;
                outParms->status = NVOS11_STATUS_ERROR_INSUFFICIENT_RESOURCES;
                }
            }
        else
            {
            NVHEAP_FREE(inParms->offset);
            outParms->status = NVOS11_STATUS_SUCCESS;
            }
#endif

        ppdev->pfnReleaseOglMutex(ppdev);

        return(TRUE);
        }
        break;
    case NV_ESC_RM_CONFIG_VERSION:
        {
        NVOS12_PARAMETERS *inParms, *outParms;

        CHECK_PDEV_NULL("CONFIG_VERSION");
        CHECK_IN_OUT_SIZE("CONFIG_VERSION", sizeof(NVOS12_PARAMETERS), sizeof(NVOS12_PARAMETERS));

        inParms  = (NVOS12_PARAMETERS *)pvIn;
        outParms = (NVOS12_PARAMETERS *)pvOut;

        ppdev->pfnAcquireOglMutex(ppdev);
        outParms->status = NvConfigVersion (ppdev->hDriver,
                                            inParms->hClient,
                                            inParms->hDevice,
                                            &outParms->version);
        ppdev->pfnReleaseOglMutex(ppdev);

        return(TRUE);
        }
        break;
    case NV_ESC_RM_CONFIG_GET:
        {
        NVOS13_PARAMETERS *inParms, *outParms;

        CHECK_PDEV_NULL("CONFIG_GET");
        CHECK_IN_OUT_SIZE("CONFIG_GET", sizeof(NVOS13_PARAMETERS), sizeof(NVOS13_PARAMETERS));

        inParms  = (NVOS13_PARAMETERS *)pvIn;
        outParms = (NVOS13_PARAMETERS *)pvOut;

        ppdev->pfnAcquireOglMutex(ppdev);
        outParms->status = NvConfigGet (ppdev->hDriver,
                                        inParms->hClient,
                                        inParms->hDevice,
                                        inParms->index,
                                        &outParms->value);
        ppdev->pfnReleaseOglMutex(ppdev);

        return(TRUE);
        }
        break;
    case NV_ESC_RM_CONFIG_SET:
        {
        NVOS14_PARAMETERS *inParms, *outParms;

        CHECK_PDEV_NULL("CONFIG_SET");
        CHECK_IN_OUT_SIZE("CONFIG_SET", sizeof(NVOS14_PARAMETERS), sizeof(NVOS14_PARAMETERS));

        inParms  = (NVOS14_PARAMETERS *)pvIn;
        outParms = (NVOS14_PARAMETERS *)pvOut;

        ppdev->pfnAcquireOglMutex(ppdev);
        outParms->status = NvConfigSet (ppdev->hDriver,
                                        inParms->hClient,
                                        inParms->hDevice,
                                        inParms->index,
                                        inParms->newValue,
                                        &outParms->oldValue);
        ppdev->pfnReleaseOglMutex(ppdev);

        return(TRUE);
        }
        break;
    case NV_ESC_RM_CONFIG_GET_EX:
        {
        NVOS_CONFIG_GET_EX_PARAMS *inParms, *outParms;

        CHECK_PDEV_NULL("CONFIG_GET_EX");
        CHECK_IN_OUT_SIZE("CONFIG_GET_EX", sizeof(NVOS_CONFIG_GET_EX_PARAMS), sizeof(NVOS_CONFIG_GET_EX_PARAMS));

        inParms  = (NVOS_CONFIG_GET_EX_PARAMS *)pvIn;
        outParms = (NVOS_CONFIG_GET_EX_PARAMS *)pvOut;

        ppdev->pfnAcquireOglMutex(ppdev);
        outParms->status = NvConfigGetEx (ppdev->hDriver,
                                          inParms->hClient,
                                          inParms->hDevice,
                                          inParms->index,
                                          (ULONG *)inParms->paramStructPtr,
                                          inParms->paramSize);
        ppdev->pfnReleaseOglMutex(ppdev);

        return(TRUE);
        }
        break;
    case NV_ESC_RM_CONFIG_SET_EX:
        {
        NVOS_CONFIG_SET_EX_PARAMS *inParms, *outParms;

        CHECK_PDEV_NULL("CONFIG_SET_EX");
        CHECK_IN_OUT_SIZE("CONFIG_SET_EX", sizeof(NVOS_CONFIG_SET_EX_PARAMS), sizeof(NVOS_CONFIG_SET_EX_PARAMS));

        inParms  = (NVOS_CONFIG_SET_EX_PARAMS *)pvIn;
        outParms = (NVOS_CONFIG_SET_EX_PARAMS *)pvOut;

        ppdev->pfnAcquireOglMutex(ppdev);
        outParms->status = NvConfigSetEx (ppdev->hDriver,
                                          inParms->hClient,
                                          inParms->hDevice,
                                          inParms->index,
                                          (ULONG *)inParms->paramStructPtr,
                                          inParms->paramSize);
        ppdev->pfnReleaseOglMutex(ppdev);

        return(TRUE);
        }
        break;
    case NV_ESC_RM_CONFIG_UPDATE:
        {
        NVOS15_PARAMETERS *inParms, *outParms;

        CHECK_PDEV_NULL("CONFIG_UPDATE");
        CHECK_IN_OUT_SIZE("CONFIG_UPDATE", sizeof(NVOS15_PARAMETERS), sizeof(NVOS15_PARAMETERS));

        inParms  = (NVOS15_PARAMETERS *)pvIn;
        outParms = (NVOS15_PARAMETERS *)pvOut;

        ppdev->pfnAcquireOglMutex(ppdev);
        outParms->status = NvConfigUpdate (ppdev->hDriver,
                                           inParms->hClient,
                                           inParms->hDevice,
                                           inParms->flags);
        ppdev->pfnReleaseOglMutex(ppdev);

        return(TRUE);
        }
        break;
    case NV_ESC_RM_DEBUG_CONTROL:
        {
        NVOS20_PARAMETERS *parms;
        NVOS20_PARAMETERS *outParms;
        parms = (NVOS20_PARAMETERS *) pvIn;
        outParms = (NVOS20_PARAMETERS *)pvOut;

        outParms->status = NvRmDebugControl(ppdev->hDriver,
                                            parms->hRoot,
                                            parms->command,
                                            (PVOID)(parms->pArgs));
        return (ULONG)TRUE;
        }
        break;
    case ESC_NV_CONVERT_RING3_TO_RING0:
        {
        DWORD status, cbReturned;
        HANDLE* input[] = {pvIn, pvOut};

        CHECK_PDEV_NULL("NV_OPEN");
        CHECK_IN_OUT_SIZE("NV_CONVERT_RING3_TO_RING0", sizeof(HANDLE), sizeof(HANDLE));        

        if (*(HANDLE*)pvIn == NULL)
        {
            *(HANDLE*)pvOut = NULL;
            return(TRUE);
        }

        // the miniport will convert the handle
        status = EngDeviceIoControl(
            ppdev->hDriver,
            IOCTL_CONVERT_RING3_HANDLE,
            input,
            2 * sizeof(HANDLE*),
            input,
            2 * sizeof(HANDLE*),
            &cbReturned
        );

        if (status)
        {
            *(HANDLE*)pvOut = NULL;            
        }

        return(TRUE);
        }
        break;
    case QUERYESCSUPPORT:
        {
        // QUERYESCSUPPORT is sent to the driver to ask do you support
        // this pvIn points to the function code to query
        switch(*(ULONG *)pvIn)
            {
            case OPENGL_GETINFO:
                if (OGL_ESCAPE_FAIL_TEST(ppdev))
                    {
                    return((ULONG)FALSE);
                    }
#ifdef NV3
                oglSupported = (ppdev->cBitsPerPel == 16);
#else
                oglSupported = ((ppdev->cBitsPerPel == 16) ||
                                (ppdev->cBitsPerPel == 32));
#endif // NV3

#ifdef _WIN64
                oglSupported = oglSupported && (ppdev->hwGfxCaps & NV_CFG_GRAPHICS_CAPS_QUADRO_GENERIC);
#endif
                if (oglSupported)
                    return((ULONG)TRUE); // return non-zero if supported
                return((ULONG)FALSE);
            break;
            case OPENGL_CMD:
                return((ULONG)TRUE); // supported
            break;
            default:
            break;
            }
        break;
        }
    case OPENGL_GETINFO:
        {
        if (OGL_ESCAPE_FAIL_TEST(ppdev))
            {
            return((ULONG)FALSE);
            }

        if (OglSupportEnabled(ppdev) == (ULONG)FALSE)
            {
            return((ULONG)FALSE);
            }
#ifdef NV3
        oglSupported = (ppdev->cBitsPerPel == 16);
#else
        oglSupported = ((ppdev->cBitsPerPel == 16) ||
                        (ppdev->cBitsPerPel == 32));
#endif // NV3

#ifdef _WIN64
        oglSupported = oglSupported && (ppdev->hwGfxCaps & NV_CFG_GRAPHICS_CAPS_QUADRO_GENERIC); 
#endif
        if (oglSupported) {
            if (*((ULONG *)pvIn) == OPENGL_GETINFO_DRVNAME) {
#ifdef NV3
                if (wcslen(OPENGL_KEY_NAME_NV3) <= MAX_PATH) {
                    (void)wcscpy((wchar_t *)((LP_OPENGL_INFO) pvOut)->awch, OPENGL_KEY_NAME_NV3);
                    ((LP_OPENGL_INFO) pvOut)->ulVersion       = OPENGL_ICD_VER;
                    ((LP_OPENGL_INFO) pvOut)->ulDriverVersion = OPENGL_DRIVER_VER;

                    return((ULONG)TRUE);
                }
#else                
                if (wcslen(OPENGL_KEY_NAME_NV4) <= MAX_PATH) {
                    (void)wcscpy((wchar_t *)((LP_OPENGL_INFO) pvOut)->awch, OPENGL_KEY_NAME_NV4);
                    ((LP_OPENGL_INFO) pvOut)->ulVersion       = OPENGL_ICD_VER;
                    ((LP_OPENGL_INFO) pvOut)->ulDriverVersion = OPENGL_DRIVER_VER;

                    return((ULONG)TRUE);
                }
#endif            
            }
        }
        return((ULONG)FALSE);
        }
        break;
    case OPENGL_CMD:
      { 
            NV_OPENGL_COMMAND *pNvOpenGLCmd = (NV_OPENGL_COMMAND *)pvIn;
            PPDEV              ppdevTemp    = ppdev;

            if (   (NULL == pNvOpenGLCmd)
                || (cjIn < sizeof(NV_OPENGL_COMMAND)) )
            {
                DISPDBG((0, "DrvEscape - OPENGL_CMD input param error! needed:%d != cjIn:%d, pvIn:0x%p", sizeof(NV_OPENGL_COMMAND), cjIn, pNvOpenGLCmd));
                return(FALSE);
            }

#if defined(_WIN64)
            ASSERTDD(pNvOpenGLCmd->NVClientModel == NV_ESC_IS_64BIT_CLIENT || pNvOpenGLCmd->NVClientModel == NV_ESC_IS_32BIT_CLIENT, "NVClientModel not preset !!!");
#else
            ASSERTDD(pNvOpenGLCmd->NVClientModel == NV_ESC_IS_32BIT_CLIENT, "ICD Client is not matching 64 bit client on 32 bit server or NVClientModel not preset !!!");
#endif
            // this call has to be send to the right device in multimon configuration
            // we use the device origin for that purpose
#ifdef NV_MAIN_MULTIMON
            if( bOglRetrieveValidPDEVForOrigin( &ppdevTemp, pNvOpenGLCmd->devOriginLeft, pNvOpenGLCmd->devOriginTop ) )
#else
            if( NULL != ppdevTemp )
#endif
            {
                //************************************************************************** 
                // Need to do smart sync between OpenGL and GDI depending on 
                // clip intersection.
                //**************************************************************************
                bOglSyncOglIfGdiRenderedToWindow(ppdevTemp);

                return ((ULONG)DoOpenGLEscapeCommand(ppdevTemp, (PVOID)pvIn, (PVOID)pvOut));
            }
            else
            {
                ASSERT(FALSE);
                return((ULONG)FALSE);
            }
            
        }
        break;
    case WNDOBJ_SETUP:
        {
        NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo;
        NV_WNDOBJ_SETUP *pNvWndObj;
        LONG status;
#if defined(_WIN64)
        NV_WNDOBJ_SETUP    nvWndObj;
        NV_WNDOBJ_SETUP32 *pNvWndObj32;

        if (cjIn == sizeof(NV_WNDOBJ_SETUP32)) {
            pNvWndObj32 = (NV_WNDOBJ_SETUP32 *)pvIn;
            pNvWndObj = &nvWndObj;
            try
                {
                    NvCopyStructIn(pNvWndObj32, pNvWndObj, "IPPII");
                }
            except(EXCEPTION_EXECUTE_HANDLER)
                {
                status = GetExceptionCode();
                DISPDBG((1, "WNDOBJ_SETUP: exception = 0x%lx", status));
                return((ULONG)FALSE);
                }
 
        } else
#endif
        pNvWndObj = (NV_WNDOBJ_SETUP *)pvIn;

        if((pNvWndObj != NULL ) && (pNvWndObj->NVSignature == NV_SIGNATURE))
            {
            try
                {
                ppdev->numDevices = pNvWndObj->numDevices;
                OglAcquireGlobalMutex();
                clientDrawableInfo = CreateDrawableClientInfo(pso,
                    pNvWndObj->hWnd,
                    pNvWndObj->hDC,
                    &pNvWndObj->pfd);
               ((PVOID *)pvOut)[0] = clientDrawableInfo;
                OglReleaseGlobalMutex();
                }
            except(EXCEPTION_EXECUTE_HANDLER)
                {
                status = GetExceptionCode();
                DISPDBG((1, "WNDOBJ_SETUP: exception = 0x%lx", status));
                return((ULONG)FALSE);
                }
            return((ULONG)TRUE);
            }
        else
            {
            return((ULONG)FALSE);
            }
        }
        break;
   // - Added to provide the path to the driver reg area (hard coded under winnt4)
   case NV_ESC_GET_LOCAL_REGISTRY_PATH:
      {
         // - The first four spaces in the string are required to remain comp with w9x behavior
#if (_WIN32_WINNT >= 0x0500)
        UCHAR drv_path[128];
#else
        UCHAR drv_path[] = "    SYSTEM\\CurrentControlSet\\Services\\nv4\\Device0";
#endif
         if(ppdev == NULL ||
            pvOut == NULL || cjOut < sizeof(drv_path) ) { // - Remember to change this to X 2 when unicode

            DISPDBG((2, "DrvEscape - can't NV_ESC_GET_LOCAL_REGISTRY_PATH"));
            return(FALSE);
            }

#if (_WIN32_WINNT >= 0x0500)
        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_GET_REGISTRY_PATH,
                               NULL,
                               0,
                               (LPVOID) (drv_path),
                               sizeof(drv_path),
                               &returnedDataLength))
        {
            return(FALSE);
        }
        if (returnedDataLength == 0)
        {
            return(FALSE);
        }
#endif

        // - Do a simple memcpy for now, till unicode later
        {
            int i;
            for(i=0;drv_path[i]!=0 && i<127;i++)
               ((UCHAR*)pvOut)[i] = drv_path[i];
            ((UCHAR*)pvOut)[i] = 0;
        }

        return(TRUE);
      }
      break;


    default:
        break;
    }

    //**************************************************************************
    //
    // DISABLED UNTIL IMPLEMENTATION IS COMPLETE
    //
    // On 64 bit systems, call DrvEscape32() for escape codes that need
    // special handling (pointer conversion) for 32 bit clients.
    //
    //
    //**************************************************************************
    if (iEsc & NV_ESC_64_BASE)
        iEsc &= ~NV_ESC_64_BASE;
#if 0
    else
        return(DrvEscape32(pso, iEsc, cjIn, pvIn, cjOut, pvOut));
#endif

    //**************************************************************************
    //
    // The following switch statement handles the bulk of the cases where the
    // incoming parameter data differs in size from 32 and 64 bit clients.
    //
    //**************************************************************************

    switch(iEsc)
    {
    case NV_ESC_PRIMARY_INFO:
        {
        NV_PRIMARY_INFO *primaryInfoIn = (NV_PRIMARY_INFO *)pvIn;
        NV_PRIMARY_INFO *primaryInfoOut = (NV_PRIMARY_INFO *)pvOut;
        LONG status;
        unsigned int numActiveDACs, dacMask, activeDACs, d;

        try
            {
            if (primaryInfoIn && primaryInfoOut && primaryInfoIn->ulNVSignature == NV_SIGNATURE)
                {
                primaryInfoOut->ulWidth         = ppdev->cxScreen;
                primaryInfoOut->ulHeight        = ppdev->cyScreen;
                primaryInfoOut->ulDepth         = ppdev->cjPelSize << 3;
                primaryInfoOut->ulPitch         = ppdev->lDelta;
                primaryInfoOut->ulPrimaryOffset = ppdev->ulPrimarySurfaceOffset;
                primaryInfoOut->ulNumDACs       = ppdev->ulNumberDacsOnBoard;
                primaryInfoOut->ulNumActiveDACs = ppdev->ulNumberDacsActive;
                primaryInfoOut->ulPanningPtr    = NULL;
                primaryInfoOut->ulReturnCode    = TRUE;

                // Compute a bitmap of active DACs by looping over all displays
                // until we've checked them all, or found ulNumberDacsActive
                // unique DACs--whichever comes first.
                for (d = activeDACs = numActiveDACs = 0; (d < NV_NO_DACS) &&
                     (numActiveDACs < ppdev->ulNumberDacsActive); d++)
                    {
                    if (ppdev->ulDeviceDisplay[d] < NV_NO_DACS)
                        {
                        dacMask = 1 << ppdev->ulDeviceDisplay[d];
                        if (!(dacMask & activeDACs))
                            {
                            numActiveDACs++;
                            activeDACs |= dacMask;
                            }
                        }
                    }
                primaryInfoOut->ulActiveDACs = activeDACs;
                }
            else
                {
                return (ULONG)FALSE;
                }
            }
        except(EXCEPTION_EXECUTE_HANDLER)
            {
            status = GetExceptionCode();
            DISPDBG((1, "NV_ESC_PRIMARY_INFO: exception = 0x%lx", status));
            return (ULONG)FALSE;
            }
        }
        return (ULONG)TRUE;
    case NVDMAPUSHMODESWITCHCOUNT:
        {
        if (OGL_ESCAPE_FAIL_TEST(ppdev))
            {
            return((ULONG)FALSE);
            }

        if (pvOut != NULL)
            {
            ((ULONG *)pvOut)[0] = 0; // ppdev->dwGlobalModeSwitchCount;
            return((ULONG)TRUE);
            }
        return((ULONG)FALSE);
        }
        break;
    case ESC_NV_OPENGL_ESCAPE:
        {
        return((ULONG)DoOpenGLEscapeCommand(ppdev, (PVOID)pvIn, (PVOID)pvOut));
        }
        break;
    case NV_OPENGL_SET_ENABLE:
        {
        // return the current mode switch counter to the caller and
        // the shared mutex lock pointer.
        ((ULONG *)pvOut)[0] = ppdev->dwGlobalModeSwitchCount;
        return((ULONG)TRUE); // return non-zero if supported
        }
        break;
    case ESC_NV_OPENGL_DMA_PUSH_GO:
        {

            if (ppdev == NULL || pvOut == NULL || pvIn == NULL) {
                return((ULONG)FALSE);
            } else {
#ifdef NV3
                Nv3DmaPushInfo *dmaPushInfo;
                dmaPushInfo = (Nv3DmaPushInfo *)((Nv3DmaPushInfo *)pvIn);

                if ((long)dmaPushInfo->put - (long)dmaPushInfo->get <= 0) {
                    ((ULONG *)pvOut)[1] = ppdev->dwGlobalModeSwitchCount;

                    return((ULONG)FALSE);
                }

                if (ppdev->cBitsPerPel == 16 &&
                    dmaPushInfo->localModeSwitchCount == ppdev->dwGlobalModeSwitchCount)
                    {
                    // on NV3 this is a DMA push kickoff escape function
                    ((ULONG *)pvOut)[0] = (ULONG)NV3_DmaPushGo(ppdev,
                                                               dmaPushInfo->dwChID,
                                                               dmaPushInfo->dwTlbPtBase,
                                                               dmaPushInfo->dwAddressSpace,
                                                               dmaPushInfo->get,
                                                               dmaPushInfo->put,
                                                               dmaPushInfo->hClient,
                                                               dmaPushInfo->hDevice);
                }
#else                
                // on NV4 this is an engine sync escape function
                // force a channel sync when GDI gets called again for rendering
                ppdev->oglLastChannel = -1;  // FORCE IT TO SYNC...
                ppdev->NVFreeCount = 0;
                ppdev->pfnWaitForChannelSwitch(ppdev);
#endif // NV3
            
                ((ULONG *)pvOut)[1] = ppdev->dwGlobalModeSwitchCount;

                DISPDBG((2, "DrvEscape - SUCCESS!"));
                return((ULONG)TRUE);
            }
        }
        break;
    case ESC_SET_GAMMA_RAMP:
        {
        if (ppdev == NULL || pvIn == NULL || cjIn != sizeof(GAMMARAMP) )
            {
            DISPDBG((2, "DrvEscape - can't set gamma ramp"));
            return(FALSE);
            }
        nvSetGammaRamp(ppdev, (PUSHORT) pvIn);
        return(TRUE);
        }
        break;
    case ESC_GET_GAMMA_RAMP:
        {
        if (ppdev == NULL || pvOut == NULL || cjOut != sizeof(GAMMARAMP) ) 
            {
            DISPDBG((2, "DrvEscape - can't get gamma ramp"));
            return(FALSE);
            }
        nvGetGammaRamp(ppdev, (PUSHORT) pvOut);
        return(TRUE);
        }
        break;
    case ESC_SET_GAMMA_RAMP_MULTI:
        {
        if (ppdev == NULL || pvIn == NULL || cjIn != sizeof(GAMMARAMP_MULTI) )
            {
            DISPDBG((2, "DrvEscape - can't set gamma ramp multi"));
            return(FALSE);
            }
        nvSetHeadGammaRamp(ppdev, ((PGAMMARAMP_MULTI)pvIn)->wHead, (PUSHORT)&(((PGAMMARAMP_MULTI)pvIn)->grGammaRamp));
        return(TRUE);
        }
        break;
    case ESC_GET_GAMMA_RAMP_MULTI:
        {
        if (ppdev == NULL || pvOut == NULL || cjOut != sizeof(GAMMARAMP_MULTI) ||
                             pvIn == NULL  || cjIn != sizeof(GAMMARAMP_MULTI) )
            {
            DISPDBG((2, "DrvEscape - can't get gamma ramp multi"));
            return(FALSE);
            }
        nvGetHeadGammaRamp(ppdev, ((PGAMMARAMP_MULTI)pvIn)->wHead, (PUSHORT)&(((PGAMMARAMP_MULTI)pvOut)->grGammaRamp));
        return(TRUE);
        }
        break;
    case NV_ESC_RM_DMA_PUSH_INFO:
        {
        // TODO: define a structure for this call...
        ULONG *inParms, *outParms;

        CHECK_PDEV_NULL("RM_DMA_PUSH_INFO");
        CHECK_IN_OUT_SIZE("RM_DMA_PUSH_INFO", sizeof(NVOS08_PARAMETERS), sizeof(NVOS08_PARAMETERS));

        inParms  = (ULONG *)pvIn;
        outParms = (ULONG *)pvOut;

        ppdev->pfnAcquireOglMutex(ppdev);
        outParms[4] = NvGetDmaPushInfo (ppdev->hDriver,
                                        inParms[0],  // hClient
                                        inParms[1],  // hDevice
                                        inParms[2],  // hChannel
                                        inParms[3],  // a pointer to a DWORD array
                                        inParms[4]); // hDmaContext
        ppdev->pfnReleaseOglMutex(ppdev);

        return(TRUE);
        }
        break;

    case ESC_NV_QUERY_PCI_SLOT:
    {
        ULONG * pulPciSlot;

        pulPciSlot = (ULONG *) pvOut;

        if(EngDeviceIoControl(ppdev->hDriver,
                       IOCTL_VIDEO_QUERY_PCI_SLOT,
                       NULL,
                       0,
                       (LPVOID) (pulPciSlot),
                       sizeof(ULONG),
                       &returnedDataLength))
        {
            DISPDBG((2, "DrvEscape - can't get PCI number"));
            return(FALSE);
        }
        
        return(TRUE);
    }    
    break;

    case ESC_NV_QUERY_HEAD_REFRESH_RATE:
    {
        ULONG * pulHead;
        ULONG * pulRefreshRate;

        pulHead = (ULONG *) pvIn;
        pulRefreshRate = (ULONG *) pvOut;

        if( (pulHead == NULL) || (*pulHead > 1) )
        {
            DISPDBG((2, "DrvEscape - Invaild Head number"));
            return(FALSE);
        }

        if( ppdev == NULL || pulRefreshRate == NULL)
        {
            DISPDBG((2, "DrvEscape - NULL pointer for refresh rate"));
            return(FALSE);
        }

        *pulRefreshRate = ppdev->ulRefreshRate[*pulHead];

        return(TRUE);
    }    
    break;


    case ESC_NV_QUERYSET_REGISTRY_KEY:
        {
            __PNVRegKeyInfo inParms, outParms;
            WCHAR tmpStrBuf[NV_MAX_REG_KEYNAME_LEN];
            ULONG  inpStrLen, outStrLen;
            ULONG ii, returnedDataLen;
            NV_REGISTRY_STRUCT regStruct;
            NV_REGISTRY_STRUCT regStructInput, regStructOutput;
            DWORD retStatus;
            
            CHECK_PDEV_NULL("QUERYSET_REGISTRY_KEY");
            CHECK_IN_OUT_SIZE("QUERYSET_REGISTRY_KEY", sizeof(__NVRegKeyInfo), sizeof(__NVRegKeyInfo));

            inParms = (__PNVRegKeyInfo) pvIn;


            if (!inParms->keyName)
                return (FALSE);

            inpStrLen = strlen(inParms->keyName);

            if ((inpStrLen+1) > NV_MAX_REG_KEYNAME_LEN)
                return (FALSE);
            /*
            for (ii = 0; ii < inpStrLen; ii++)
                tmpStrBuf[ii] = inParms->keyName[ii];
            tmpStrBuf[ii] = 0;
            */

            EngMultiByteToUnicodeN((LPWSTR)tmpStrBuf, NV_MAX_REG_KEYNAME_LEN*sizeof(WCHAR), &outStrLen,
                                   inParms->keyName, (inpStrLen+1)*sizeof(CHAR));



            switch(inParms->type)
            {
            case NV_QUERY_REGISTRY_BINARY_KEY:
                outParms = (__PNVRegKeyInfo) pvOut;
                *outParms = *inParms;

                regStructInput.keyName = (PWSTR)tmpStrBuf;
                regStructInput.keyVal = outParms->keyVal;
                regStructInput.keyValSize = outParms->keyValMaxSize;

                retStatus = EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_QUERY_REGISTRY_BINARY_VAL,
                               (LPVOID)&regStructInput,
                               sizeof(NV_REGISTRY_STRUCT),
                               (LPVOID) (outParms->keyVal),
                               outParms->keyValMaxSize,
                               &(returnedDataLen));

                outParms->retStatus = retStatus;

                // Copy the returned registry value size into outParams
                outParms->keyValSize = returnedDataLen;
                // The KeyVal has already been copied by the miniport

                break;

            case NV_QUERY_REGISTRY_KEY:

                outParms = (__PNVRegKeyInfo) pvOut;
                *outParms = *inParms;

                retStatus = EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_QUERY_REGISTRY_VAL,
                               (LPVOID)tmpStrBuf,
                               outStrLen,
                               (LPVOID) (outParms->keyVal),
                               outParms->keyValMaxSize,
                               &(outParms->keyValSize));

                outParms->retStatus = retStatus;

                break;

            case NV_SET_REGISTRY_KEY:

                outParms = (__PNVRegKeyInfo) pvOut;
                *outParms = *inParms;

                regStruct.keyName = (PWSTR)tmpStrBuf;
                regStruct.keyVal = inParms->keyVal;
                regStruct.keyValSize = inParms->keyValSize;

                retStatus = EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_SET_REGISTRY_VALUE,
                               (LPVOID)(&regStruct),
                               sizeof(NV_REGISTRY_STRUCT),
                               (LPVOID) NULL,
                               0,
                               &returnedDataLen);

                outParms->retStatus = retStatus;

                break;

            default:
                break;
            }
            return (TRUE);
        }
        break;

    case ESC_NV_DESKMGR_ZOOMBLIT:
#ifdef _WIN32_WINNT
        {
            __NVDMEscapeParams* pParams = (__NVDMEscapeParams*) pvIn;

            // Validate parameters.
            if (!(pParams && (cjIn >= (sizeof(__NVDMEscapeParams) +
                                      (pParams->clips - 1) * sizeof(RECTL)))))
                return (ULONG) FALSE;
            // If we don't have appropriate scaled-image HW support, fail.
            if (!(ppdev->CurrentClass.ScaledImageFromMemory &&
                  ppdev->pfnStretchCopy))
                return (ULONG) FALSE;

            // If performing a blit out of system memory...
            if (pParams->flags & NVDM_ESC_BLIT_SYSMEM) {
                // Not supported at the moment.
                return (ULONG) TRUE;
            }
            // Otherwise do a vidmem-to-vidmem blit.
            return (ULONG)
                ppdev->pfnStretchCopy(ppdev,
                                      pParams->flags & NVDM_ESC_BLIT_SMOOTH,
                                      pParams->scale,
                                      &pParams->srcRect, &pParams->dstRect,
                                      pParams->clips, pParams->clipRects);
        }
#endif  //#ifdef _WIN32_WINNT
        return (ULONG) TRUE;

#if (NVARCH >= 0x4) && (_WIN32_WINNT >= 0x0500) && !defined(_WIN64)
    case NV_ESC_DDPRIV_DMABLIT:
       {
           ULONG i;
           if (cjOut >= sizeof(NVS2VERROR)) {
               ((LPNVS2VDATATYPE)pvIn)->dwDevice = ppdev->ulDeviceReference;
               *((NVS2VERROR *)pvOut) = nvMoComp(pvIn);
               return (TRUE);
           }
       }
       break;

   case NV_ESC_DDPRIV_OVERLAYCONTROL:
       {
           ULONG i;
           if (cjOut >= sizeof(NVOCERROR)) {
               ((LPNVOCDATATYPE)pvIn)->dwDevice = ppdev->ulDeviceReference;
               *((NVOCERROR *)pvOut) = nvOverlayControl(pvIn);
               return (TRUE);
           }
       }
       break;
#endif

    case NV_ESC_SETGET_TWINVIEW_DATA:
        {

            NVTWINVIEWDATA  * nvDataIn;
            NVTWINVIEWDATA  * nvDataOut;
            ULONG GetFlag;  // 1 means a "Get" kind of action and 0 means a "Set" kind of action
            ULONG i, j;

            DISPDBG((1, "Enter NV_ESC_SETGET_TWINVIEW_DATA"));

            if (ppdev == NULL || pvIn == NULL || pvOut == NULL) {
                DISPDBG((0, "DrvEscape - cant NV_ESC_SETGET_TWINVIEW_DATA: ppdev: 0x%x, pvIn: 0x%x, pvOut: 0x%x", ppdev, pvIn, pvOut));
                return(FALSE);
            }
            //
            // Need to add some defensive code in case the Control Panel doesn't match the driver. If this
            // happens, the structure size can be different and cause lots of problems, especially when doing
            // the memcpy below. Note that I'm not checking for cjIn/cjOut to be equal the NVTWINVIEWDATA
            // because there is a case during initialization where this isn't true - they are about 4 times
            // larger. Need to check with Control Panel guys, and so this is at least a first pass to make
            // sure the memcpy below won't get a page fault.
            //
            if ((cjIn < sizeof(NVTWINVIEWDATA)) || (cjOut < sizeof(NVTWINVIEWDATA)))
            {
                DISPDBG((1, "DrvEscape - NV_ESC_SETGET_TWINVIEW_DATA error: cjIn: 0x%x, cjOut: 0x%x", cjIn, cjOut));
                return(FALSE);
            }
            nvDataIn = (NVTWINVIEWDATA *)pvIn;
            nvDataOut = (NVTWINVIEWDATA *)pvOut;

            switch (nvDataIn->dwFlag) {
                case NVTWINVIEW_FLAG_GET: 
                     GetFlag = 1;
                     // Do a copy of the pvIn to pvOut.
                     // This is to handle the case where the OS zeroes out the pvOut before calling the display driver.
                     memcpy(nvDataOut, nvDataIn, sizeof(NVTWINVIEWDATA));
                     break;
                case NVTWINVIEW_FLAG_SET: 
                     GetFlag = 0;
                     break;
                default:
                     DISPDBG((0," oops! dwFlag is unknown: 0x%x\n",nvDataIn->dwFlag));
                     nvDataOut->dwSuccess = FALSE;
                     return(TRUE);
                     break;
            }
            nvDataOut->dwSuccess = TRUE;

            switch (nvDataIn->dwAction) {
                case NVTWINVIEW_ACTION_SETGET_PHYSICAL_VIRTUAL_MODE:
                    if (GetFlag)
                    {
                        SET_RECT(&nvDataOut->DeskTopRectl, 0, 0, ppdev->cxScreen, ppdev->cyScreen);
                        nvDataOut->dwState = ppdev->TwinView_State;
                        nvDataOut->dwOrientation = ppdev->TwinView_Orientation;
                        nvDataOut->dwAllDeviceMask = ppdev->ulAllDeviceMask;
                        nvDataOut->dwConnectedDeviceMask = ppdev->ulConnectedDeviceMask;
                        for (i=0; i < ppdev->ulNumberDacsOnBoard; i++) {
                            nvDataOut->dwDeviceDisplay[i] = ppdev->ulDeviceDisplay[i];
                        }
                    }
                    else
                    {
                       BOOLEAN DataOK;
                        DataOK = TwinViewDataOK(ppdev, nvDataIn);
                        if (!DataOK) 
                        {
                            DISPDBG((0,"Oops! The panel did not pass us sensible data. So return Failure\n"));
                            nvDataOut->dwSuccess = FALSE;
                            return(TRUE);
                        }
                        //
                        // Now write the TwinViewInfo structure to the registry.
                        //
                        PrintTwinViewData ("SET_PHYSICAL_VIRTUAL_MODE:Info sent by nvPanel", 1, nvDataIn, ppdev);
                        WriteRegistryTwinViewInfo(ppdev, nvDataIn);

                        // Some of the flags are synchronous. They take effect immediately.
                        // Handle the synchronous EnablePanScan flag.
                        ProcessSynchronousFlags(ppdev, nvDataIn);


                        return(TRUE);
                    }

                    for (i=0; i < ppdev->ulNumberDacsOnBoard; i++) {
                        if (GetFlag) {
                            SET_RECT(&nvDataOut->NVTWINVIEWUNION.nvtwdevdata[i].VirtualRectl,ppdev->rclDisplayDesktop[i].left,
                                ppdev->rclDisplayDesktop[i].top, ppdev->rclDisplayDesktop[i].right,ppdev->rclDisplayDesktop[i].bottom);
                            SET_RECT(&nvDataOut->NVTWINVIEWUNION.nvtwdevdata[i].PhysicalRectl,ppdev->rclCurrentDisplay[i].left,
                                ppdev->rclCurrentDisplay[i].top,ppdev->rclCurrentDisplay[i].right,ppdev->rclCurrentDisplay[i].bottom);

                            nvDataOut->NVTWINVIEWUNION.nvtwdevdata[i].dwDeviceMask = ppdev->ulDeviceMask[i];

                            nvDataOut->NVTWINVIEWUNION.nvtwdevdata[i].dwDeviceType = ppdev->ulDeviceType[i];
                            nvDataOut->NVTWINVIEWUNION.nvtwdevdata[i].dwTVFormat = ppdev->ulTVFormat[i];
                            nvDataOut->NVTWINVIEWUNION.nvtwdevdata[i].dwBpp = ppdev->cBitsPerPel; // same for both devices
                            nvDataOut->NVTWINVIEWUNION.nvtwdevdata[i].dwRefresh = ppdev->ulRefreshRate[i];
                            nvDataOut->NVTWINVIEWUNION.nvtwdevdata[i].dwNumPhysModes = ppdev->ulNumPhysModes[i];
                            nvDataOut->NVTWINVIEWUNION.nvtwdevdata[i].dwNumVirtualModes = ppdev->ulNumVirtualModes[i];

                            nvDataOut->NVTWINVIEWUNION.nvtwdevdata[i].dwTimingOverRide = ppdev->ulTimingOverRide[i];
                            nvDataOut->NVTWINVIEWUNION.nvtwdevdata[i].dwEnableDDC = ppdev->ulEnableDDC[i];
                            nvDataOut->NVTWINVIEWUNION.nvtwdevdata[i].dwEnablePanScan = ppdev->ulEnablePanScan[i];
                            nvDataOut->NVTWINVIEWUNION.nvtwdevdata[i].dwFreezePanScan = ppdev->ulFreezePanScan[i];
                            nvDataOut->NVTWINVIEWUNION.nvtwdevdata[i].dwFreezeOriginX = ppdev->ulFreezeOriginX[i];
                            nvDataOut->NVTWINVIEWUNION.nvtwdevdata[i].dwFreezeOriginY = ppdev->ulFreezeOriginY[i];

                        } else {
                            DISPDBG((0,"OOps! Logic error in display driver. Should not be here. file: %s, line: %d\n",__FILE__,__LINE__));
                        }
                    } // for
                    if (GetFlag) {
                        //
                        // Print the info we are sending back to the panel
                        //
                        PrintTwinViewData ("GET_PHYSICAL_VIRTUAL_MODE:Info returned to nvPanel", 2, nvDataOut, ppdev);
                    }
                    break;

                case NVTWINVIEW_ACTION_SETGET_PHYSICAL_VIRTUAL_MODELIST:
                    if (GetFlag) {
                        for (i=0; i < ppdev->ulNumberDacsOnBoard; i++) {
                            if (!bGetPhysicalVirtualModeList(ppdev, i, 

                                    nvDataOut->NVTWINVIEWUNION.nvtwModeListData[i].dwDeviceMask,

                                    nvDataOut->NVTWINVIEWUNION.nvtwModeListData[i].dwDeviceType,
                                    nvDataOut->NVTWINVIEWUNION.nvtwModeListData[i].dwTVFormat,
                                    nvDataOut->NVTWINVIEWUNION.nvtwModeListData[i].PhysModeEntries,
                                    nvDataOut->NVTWINVIEWUNION.nvtwModeListData[i].VirtualModeEntries,
                                    &nvDataOut->NVTWINVIEWUNION.nvtwModeListData[i].dwNumPhysModeEntries,
                                    &nvDataOut->NVTWINVIEWUNION.nvtwModeListData[i].dwNumVirtualModeEntries))
                            {
                                nvDataOut->dwSuccess = FALSE;
                                return(TRUE);
                            }
                        }
                    } 
                    else 
                    {
                        // There is no necessity for this path. The panel should never need to tell
                        // the driver to set the physmodeList for a head.
                    }
                    break;

                default: DISPDBG((0,"Invalid unsupported dwAction: 0x%x\n",nvDataIn->dwAction));
                     nvDataOut->dwSuccess = FALSE;
                     return(TRUE);
                    break;
            }
            return(TRUE);
        }


    case NV_ESC_SET_DISPLAY_DEVICE_TYPE:
        {
        if (ppdev == NULL || pvIn == NULL || cjIn != sizeof(SETGETDEVTYPE))
            {
            DISPDBG((2, "DrvEscape - cant NV_ESC_SET_DISPLAY_DEVICE_TYPE"));
            return(FALSE);
            }
        DISPDBG((2, "DrvEscape - NV_ESC_SET_DISPLAY_DEVICE_TYPE"));
        if(!nvSetDisplayDevice(ppdev, (PSETGETDEVTYPE) pvIn)) {
           return(FALSE);
        }
        return(TRUE);
        }
        break;


    case NV_ESC_GET_DISPLAY_DEVICE_TYPE:
        {
        if (ppdev == NULL || pvOut == NULL || cjOut != sizeof(SETGETDEVTYPE))
            {
            DISPDBG((2, "DrvEscape - cant NV_ESC_GET_DISPLAY_DEVICE_TYPE"));
            return(FALSE);
            }
        DISPDBG((2, "DrvEscape - NV_ESC_GET_DISPLAY_DEVICE_TYPE"));
        if(!nvGetDisplayDevice(ppdev, (PSETGETDEVTYPE) pvOut)) {
            return(FALSE);
        }
        return(TRUE);
        }
        break;

    case NV_ESC_GET_DEVICE_SCAN_DATA:
        {
        GET_DEVICE_SCAN_DATA_TYPE * pInfo;
        ULONG i;
        if (ppdev == NULL || pvOut == NULL || cjOut != sizeof(GET_DEVICE_SCAN_DATA_TYPE))
            {
            DISPDBG((0, "DrvEscape - cant NV_ESC_GET_DEVICE_SCAN_DATA"));
            return(FALSE);
            }
        DISPDBG((1, "DrvEscape - NV_ESC_GET_DEVICE_SCAN_DATA"));
        pInfo = (GET_DEVICE_SCAN_DATA_TYPE *)pvOut;
        pInfo->ulNumberDacsOnBoard = ppdev->ulNumberDacsOnBoard;
        pInfo->ulNumberDacsConnected = ppdev->ulNumberDacsConnected;
        pInfo->ulNumberDacsActive = ppdev->ulNumberDacsActive;
        for (i=0; i < ppdev->ulNumberDacsOnBoard; i++)
        {
            pInfo->ulHeadDeviceOptions[i] = ppdev->ulHeadDeviceOptions[i];
        }
        
        return(TRUE);
        }
        break;

    case NV_ESC_GET_DEVICE_MASK:
        {
        GET_DEVICE_MASK_DATA_TYPE * pInfo;
        ULONG ulPrimaryHead;
        ULONG ReturnedDataLength;
        if (ppdev == NULL || pvOut == NULL || cjOut != sizeof(GET_DEVICE_MASK_DATA_TYPE))
            {
            DISPDBG((0, "DrvEscape - cant NV_ESC_GET_DEVICE_MASK"));
            return(FALSE);
            }
        DISPDBG((1, "DrvEscape - NV_ESC_GET_DEVICE_MASK, ppdev->ulInduceModeChangeDeviceMask: 0x%x",
                 ppdev->ulInduceModeChangeDeviceMask));
        pInfo = (GET_DEVICE_MASK_DATA_TYPE *)pvOut;
        //
        // Initialize the return data.
        //
        pInfo->ulDeviceMask = 0;

        //
        // A sanity check. We enable this modeswitch only if the NVSVC has started.
        // We should not run into this situation since we would never be here unless NVSVC had responded to
        // the signal on the named event. A sanity check however should not hurt.
        //
        if (ppdev->ulNVSVCStatus != NVSVC_STATUS_STARTED)
        {
            DISPDBG((1,"Something wrong. NVSVC is not running."));
            return(TRUE);
        }


#if _WIN32_WINNT < 0x500
        //
        // See if we got here as a result of a NT4.0 hotkey switch, such as on gateway laptops.
        // I can put a further check here for ACPI system. Do this later.
        //
        if (bHandleNT4HotKey(ppdev, pInfo))
        {
            //
            // There was a hotkey pending. We processed it and now we can return.
            //
            return(TRUE);
        }
#endif

        //
        // We are not here because of a hotkey switch.
        // Ergo, this is a device switch initiated by the display driver.
        // So return the device mask to be used by the control panel.
        //
        pInfo->ulDeviceMask = ppdev->ulInduceModeChangeDeviceMask;
        DISPDBG((1, "Info being returned: ulDeviceMask: 0x%x",pInfo->ulDeviceMask));

        //
        // The ulInduceModeChangeDeviceMask has been consumed by the panel. So clear it now so that subsequent
        // modesets will not cause StopImage method to show up. Also, let miniport know too.
        // Note: it is better to do it here rather than on entry into InitMultiMon(). Reason is the hibernation
        // case where GDI callsDrvAssertMode(TRUE) twice and by the time control panel makes the GET_DEVICE_MASK
        // escape call, the second DrvAssertMode(TRUE) would have sneaked in and cleared the 
        // ulInduceModeChangeDeviceMask before the control panel had a chance to consume it.
        //
        ppdev->ulInduceModeChangeDeviceMask = 0;
        if (EngDeviceIoControl(ppdev->hDriver,
                        IOCTL_VIDEO_SET_NVSVC_MODESET_DEVMASK,
                        &ppdev->ulInduceModeChangeDeviceMask,
                        sizeof(ULONG),
                        NULL,
                        0,
                        &ReturnedDataLength))
        {
            DISPDBG((1, "InitMultiMon() - IOCTL_VIDEO_SIGNAL_MODESET_DEVMASK failed"));
        }   
        return(TRUE);
        }
        break;

    case NV_ESC_INDUCE_DEVICE_SCAN:
        {
            if (ppdev == NULL)
               {
               DISPDBG((0, "DrvEscape - cant NV_ESC_INDUCE_DEVICE_SCAN"));
               return(FALSE);
               }
            DISPDBG((1, "DrvEscape - NV_ESC_INDUCE_DEVICE_SCAN"));
            InduceAndUpdateDeviceScanning(ppdev);

            return(TRUE);
        }
        break;

    case NV_ESC_SET_NVSVC_STATUS:
        {
        ULONG ulNVSVCStatus;
        ULONG returnedDataLength;

        if (ppdev == NULL || pvIn == NULL || cjIn != sizeof(ULONG))
            {
            DISPDBG((0, "DrvEscape - cant NV_ESC_SET_NVSVC_STATUS"));
            return(FALSE);
            }
        DISPDBG((1, "DrvEscape - NV_ESC_SET_NVSVC_STATUS"));
        ulNVSVCStatus = *(ULONG *)pvIn;
        if (ulNVSVCStatus != NVSVC_STATUS_STARTED && ulNVSVCStatus != NVSVC_STATUS_STOPPED &&
            ulNVSVCStatus != NVSVC_STATUS_PAUSED)
        {
            //
            // Invalid data passed to us by NVSVC
            //
            DISPDBG((0, "DrvEscape - Invalid NVSVC_STATUS data passed in by NVSVC: 0x%x",ulNVSVCStatus));
            return(FALSE);
        }
        DISPDBG((1, "NVSVCStatus being set: 0x%x\n",ulNVSVCStatus));
        //
        // Store it in the pdev.
        //
        ppdev->ulNVSVCStatus = ulNVSVCStatus;
        //
        // Let the miniport know of this latest status also.
        //
        if(EngDeviceIoControl(ppdev->hDriver,
                       IOCTL_VIDEO_SET_NVSVC_STATUS,
                       &ulNVSVCStatus,
                       sizeof(ULONG),
                       NULL,
                       0,
                       &returnedDataLength))
        {
            DISPDBG((0, "DrvEscape - can't do SET_NVSVC_STATUS"));
            return(FALSE);
        }

        return(TRUE);
        }
        break;

    case NV_ESC_QUERY_SAVE_SETTINGS:
        {

            QUERY_SAVE_SETTINGS  * nvDataIn;
            NVTWINVIEWDATA  * nvDataOut;
            NVTWINVIEWDATA  * pFind;

            DISPDBG((1, "Enter NV_ESC_QUERY_SAVE_SETTINGS"));

            if (ppdev == NULL || pvIn == NULL || pvOut == NULL) {
                DISPDBG((0, "DrvEscape - cant NV_ESC_QUERY_SAVE_SETTINGS: ppdev: 0x%x, pvIn: 0x%x, pvOut: 0x%x", ppdev, pvIn, pvOut));
                return(FALSE);
            }
            //
            // Need to add some defensive code in case the Control Panel doesn't match the driver. 
            //
            if ((cjIn < sizeof(QUERY_SAVE_SETTINGS)) || (cjOut < sizeof(NVTWINVIEWDATA)))
            {
                DISPDBG((1, "DrvEscape - NV_ESC_QUERY_SAVE_SETTINGS error: cjIn: 0x%x, cjOut: 0x%x", cjIn, cjOut));
                return(FALSE);
            }
            nvDataIn = (QUERY_SAVE_SETTINGS *)pvIn;
            nvDataOut = (NVTWINVIEWDATA *)pvOut;
            
            DISPDBG((1, "Query: State: 0x%x, Orientation: 0x%x, mapping array:(%d, %d), deviceMask: (0x%x, 0x%x)",
                nvDataIn->ulState,nvDataIn->ulOrientation, nvDataIn->ulDeviceDisplay[0], nvDataIn->ulDeviceDisplay[1],
                nvDataIn->ulDeviceMask[0],nvDataIn->ulDeviceMask[1]));

            //
            // Find the saved settings slot for the requested device combo
            //
            pFind = pFindSaveSettings(ppdev, nvDataIn, NULL);
            if (pFind == NULL)
            {
                DISPDBG((1,"Something wrong. pFindSaveSettings() returned failure"));
                nvDataOut->dwSuccess = FALSE;
                return(TRUE);
            }
        
            //
            // We found the saved settings. Now return the data to the panel
            //
            memcpy(nvDataOut, pFind, sizeof(NVTWINVIEWDATA));
            nvDataOut->dwSuccess = TRUE;
            //
            // Print the info we are sending back to the panel
            //
            PrintTwinViewData ("QUERY_SAVE_SETTINGS:Info returned to nvPanel", 1, nvDataOut, ppdev);
            return(TRUE);
        }
        break;

    case NV_ESC_FORCE_SAVE_SETTINGS:
        {
            NVTWINVIEWDATA  * nvDataIn;
            NVTWINVIEWDATA  * pFind;

            DISPDBG((1, "Enter NV_ESC_QUERY_SAVE_SETTINGS"));

            if (ppdev == NULL || pvIn == NULL) {
                DISPDBG((0, "DrvEscape - cant NV_ESC_FORCE_SAVE_SETTINGS: ppdev: 0x%x, pvIn: 0x%x", ppdev, pvIn));
                return(FALSE);
            }
            //
            // Need to add some defensive code in case the Control Panel doesn't match the driver. 
            //
            if (cjIn < sizeof(NVTWINVIEWDATA))
            {
                DISPDBG((1, "DrvEscape - NV_ESC_FORCE_SAVE_SETTINGS error: cjIn: 0x%x", cjIn));
                return(FALSE);
            }
            nvDataIn = (NVTWINVIEWDATA *)pvIn;
            PrintTwinViewData("DataInput", 1, nvDataIn, ppdev);

            //
            // Find the saved settings slot for the requested device combo
            //
            pFind = pFindSaveSettings(ppdev, NULL, nvDataIn);
            if (pFind == NULL)
            {
                DISPDBG((1,"Something wrong. pFindSaveSettings() returned failure"));
                // How do I pass an error value back to control panel here?
                return(TRUE);
            }
        
            //
            // We found the saved settings. Now Copy the passed in data into the slot.
            //
            *pFind = *nvDataIn;

            //
            // Write the table back to the registry.
            //
            vWriteSaveSettings(ppdev);
            return(TRUE);
        }
        break;

    case NV_ESC_DISPLAY_ICON:
        {
        DISPLAY_ICON_DATA_TYPE * pInfo;
        if (ppdev == NULL || pvIn == NULL || cjIn != sizeof(DISPLAY_ICON_DATA_TYPE))
            {
            DISPDBG((0, "DrvEscape - cant NV_ESC_DISPLAY_ICON"));
            return(FALSE);
            }
        DISPDBG((1, "DrvEscape - NV_ESC_DISPLAY_ICON"));
        pInfo = (DISPLAY_ICON_DATA_TYPE *)pvIn;
        return(TRUE);
        }
        break;

    case NV_ESC_HIDE_ICON:
        {
            if (ppdev == NULL)
            {
                DISPDBG((0, "DrvEscape - cant NV_ESC_HIDE_ICON:"));
                return(FALSE);
            }
            DISPDBG((1, "DrvEscape - NV_ESC_HIDE_ICON"));
            return(TRUE);
        }
        break;

    case NV_ESC_DISABLE_HW_CURSOR:
        {
            if (ppdev == NULL || pvIn == NULL)
            {
                DISPDBG((0, "DrvEscape - Incorrect param to disable HW cursor"));
                return(FALSE);
            }
            if(*(ULONG *)pvIn == FALSE)
            {
                ppdev->flCaps &= ~CAPS_SW_POINTER;
                DISPDBG((1, "DrvEscape - enable HW cursor"));
            }
            else
            {
                ppdev->flCaps |= CAPS_SW_POINTER;
                DISPDBG((1, "DrvEscape - disable HW cursor"));
            }
            return(TRUE);
        }
        break;

   case NV_ESC_VALIDATE_DEVICE_MODE:
      {
        if (ppdev == NULL ||
            pvIn  == NULL || cjIn  != sizeof(VALMODEXTR) ||
            pvOut == NULL || cjOut != sizeof(DWORD))
            {
            DISPDBG((2, "DrvEscape - cant NV_ESC_VALIDATE_DEVICE_MODE"));
            return(FALSE);
            }
        DISPDBG((2, "DrvEscape - NV_ESC_VALIDATE_DEVICE_MODE"));

        if(!nvDoValidateDeviceModeEsc(ppdev, (VALMODEXTR *)pvIn, (DWORD *) pvOut)) {
           return(FALSE);
        }
        return(TRUE);
      }
      break;


   // - Added to provide id of the board and type
   case NV_ESC_IS_NVIDIA_BOARD_AND_DRIVER:
      {
        if (ppdev == NULL ||
            pvOut == NULL || cjOut != 2 * sizeof(DWORD)) // Two DWORDs
            {
            DISPDBG((2, "DrvEscape - cant NV_ESC_IS_NVIDIA_BOARD_AND_DRIVER"));
            return(FALSE);
            }
        DISPDBG((2, "DrvEscape - NV_ESC_IS_NVIDIA_BOARD_AND_DRIVER"));

        // - Store the ESC value back in the 1st DWORD
        ((DWORD *)pvOut)[0] = NV_ESC_IS_NVIDIA_BOARD_AND_DRIVER;

        // - Store the nvidia device class in the second DWORD
        if(!nvGetDisplayDeviceClass(ppdev, &((DWORD *)pvOut)[1])) {
           return(FALSE);
        }

        return(TRUE);
      }
      break;


#ifdef   NV_ESCAPE_ID
   // - Added to positive id of nvidia drivers
   case NV_ESCAPE_ID:
      {
        if (ppdev == NULL ||
            pvOut == NULL || cjOut != 1 * sizeof(DWORD))
            {
            DISPDBG((2, "DrvEscape - cant NV_ESCAPE_ID"));
            return(FALSE);
            }
        DISPDBG((2, "DrvEscape - NV_ESCAPE_ID"));

        // - Store the NV_ESCAPE_ID_RETURN value in the 1st DWORD
        ((DWORD *)pvOut)[0] = NV_ESCAPE_ID_RETURN;
        return(TRUE);
      }
      break;
#endif

   case NV_ESC_RM_I2C_ACCESS:
      {

         NVOS_I2C_ACCESS_PARAMS *inParms, *outParms;
         ULONG ReturnedDataLength;

         CHECK_PDEV_NULL("I2C_ACCESS");
         CHECK_IN_OUT_SIZE("I2C_ACCESS", sizeof(NVOS_I2C_ACCESS_PARAMS), sizeof(NVOS_I2C_ACCESS_PARAMS));

         inParms  = (NVOS_I2C_ACCESS_PARAMS *)pvIn;
         outParms = (NVOS_I2C_ACCESS_PARAMS *)pvOut;

         if( EngDeviceIoControl( ppdev->hDriver,
                                IOCTL_NV04_I2C_ACCESS,
                                pvIn,
                                sizeof(NVOS_I2C_ACCESS_PARAMS),
                                pvOut,
                                sizeof(NVOS_I2C_ACCESS_PARAMS),
                                &ReturnedDataLength) ) {

            // The IOCTL failed, so return fail
            return(FALSE);
         }

         // Make sure we got what we wanted, at least size wise
         if(ReturnedDataLength != sizeof(NVOS_I2C_ACCESS_PARAMS))
            return(FALSE);

         return(TRUE);
      }
      break;

      case ESC_NV_MAP_USER:
        {
        // Setup the parms
        NV_SYSMEM_SHARE_MEMORY *sysmemIn;

        CHECK_PDEV_NULL("MAP_USER");

        sysmemIn = (NV_SYSMEM_SHARE_MEMORY *)pvIn;

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_MAP_TO_USER,
                               sysmemIn,
                               sizeof(NV_SYSMEM_SHARE_MEMORY),
                               (NV_SYSMEM_SHARE_MEMORY *)pvOut,
                               sizeof(NV_SYSMEM_SHARE_MEMORY),
                               &returnedDataLength))
            {
            DISPDBG((2, "DrvEscape - can't map address"));
            return(FALSE);
            }
            // Add some clean-up registering code.

        return(TRUE);
        }
        break;

    case ESC_NV_UNMAP_USER:
        {
        NV_SYSMEM_SHARE_MEMORY sysmemShareMemoryIn, sysmemShareMemoryOut;

        CHECK_PDEV_NULL("UNMAP_PFIFO_USER");

        sysmemShareMemoryIn = *(NV_SYSMEM_SHARE_MEMORY *)pvIn;
        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_UNMAP_FROM_USER,
                               &sysmemShareMemoryIn,
                               sizeof(NV_SYSMEM_SHARE_MEMORY),
                               (PULONG) &sysmemShareMemoryOut,
                               sizeof(NV_SYSMEM_SHARE_MEMORY),
                               &returnedDataLength))
            {
            DISPDBG((2, "DrvEscape - can't unmap NV PFIFO"));
            return(FALSE);
            }
        return(TRUE);
        }
        break;

#ifdef USE_WKS_ELSA_TOOLS
    case ESC_ELSA_TOOLS:
    {
        // Only support the interface on a QUADRO piece
        if (ppdev->hwGfxCaps & NV_CFG_GRAPHICS_CAPS_QUADRO_GENERIC)
        {
            return ((ULONG)lEscapeTools(pso, cjIn, pvIn, cjOut, pvOut));
        }
        // not supported on this device -> defaults to FALSE
        break;
    }
#endif //USE_WKS_ELSA_TOOLS

    case ESC_NV_WKS_APP_SUPPORT:
    {
        return ((ULONG)lWksAppSupport(pso, cjIn, pvIn, cjOut, pvOut));
        break;
    }

    default:
        break;
    }

#endif  // >= NT 4.x
    return (ULONG)FALSE;
    }

static ULONG DoOpenGLEscapeCommand(PPDEV ppdev, PVOID pvIn, PVOID pvOut)
{
    NV_OPENGL_COMMAND *inCommand;
    ULONG             *outPtr = NULL;
    LONG              status;
    ULONG             ulRet = FALSE;

    ASSERT(ppdev);

    inCommand = (NV_OPENGL_COMMAND *)pvIn;
    try
        {
        ppdev->numDevices = inCommand->numDevices;
        }
    except(EXCEPTION_EXECUTE_HANDLER)
        {
        status = GetExceptionCode();
        DISPDBG((1, "DoOpenGLEscapeCommand: exception = 0x%lx", status));
        return(1 + (ULONG)FALSE);
        }

#if defined(_WIN64)
    if (!EngSaveFloatingPointState(ppdev->fpState, ppdev->fpStateSize))
        {
        DISPDBG((1, "EngSaveFloatingPointState failed"));
        return(1 + (ULONG)FALSE);
        }
#endif

    switch(inCommand->command)
    {
#if (NVARCH >= 0x4)
        case ESC_NV_OPENGL_COMMAND:
            // Call back to shared library to execute a command
            if (NV_OglOperation(ppdev,
                                inCommand->hWnd,
                                inCommand->hDC,
                                (__GLNVoperation*)inCommand->other)) {
                ulRet = ((ULONG)TRUE);
            } else {
                ulRet = ((ULONG)FALSE);
            }
            break;
        case ESC_NV_OPENGL_SYNC_CHANNEL:
            // force a channel sync when GDI gets called again for rendering
            ppdev->oglLastChannel = -1;  // FORCE IT TO SYNC...
            ppdev->NVFreeCount = 0;
            ppdev->pfnWaitForChannelSwitch(ppdev);
            ulRet = ((ULONG)TRUE);
            break;
        case ESC_NV_OPENGL_SHARED_LIBRARY_SIZES:
            {
            extern int sizeOfState;
            extern int sizeOfDrawablePrivate;
            int *sizes = (int *)inCommand->other;

                if (sizes[0] == sizeOfState && // __GLNVstate
                    sizes[1] == sizeOfDrawablePrivate)  // __GLdrawablePrivate
                    {
                    ulRet = ((ULONG)TRUE);
                    break;
                    }
                else
                    {
                    ulRet = ((ULONG)FALSE);
                    break;
                    }
                ulRet = ((ULONG)FALSE);
            }
            break;
        case ESC_NV_OPENGL_SUPPORT:
            if (OglSupportEnabled(ppdev) == (ULONG)TRUE)
                {
                if (inCommand->NVSignature == NV_SIGNATURE)
                    {
                    ulRet = ((ULONG)TRUE);
                    break;
                    }
                else
                    {
                    ulRet = ((ULONG)FALSE);
                    break;
                    }
                }
            ulRet = ((ULONG)FALSE);
            break;
        case ESC_NV_OPENGL_REGISTER_RM_CLIENT:
            OglAcquireGlobalMutex();
            OglRegisterRmClient(ppdev, PtrToUlong(inCommand->other));
            OglReleaseGlobalMutex();
            ulRet = ((ULONG)TRUE);
            break;
        case ESC_NV_OPENGL_UNREGISTER_RM_CLIENT:
            OglAcquireGlobalMutex();
            OglUnRegisterRmClient(ppdev, PtrToUlong(inCommand->other));
            OglReleaseGlobalMutex();
            ulRet = ((ULONG)TRUE);
            break;
        case ESC_NV_OPENGL_DESTROY_DRAWABLE:
            OglAcquireGlobalMutex();
            DestroyDrawableClientInfo(ppdev, inCommand->hWnd, inCommand->hDC, TRUE);
            OglReleaseGlobalMutex();
            ulRet = ((ULONG)TRUE);
            break;
        case ESC_NV_OPENGL_START_STATE_CLIENT_TRACKING:
            {
            OglAcquireGlobalMutex();
            ulRet = CreateContextClientInfo(ppdev, inCommand->hWnd, inCommand->hClient);
            OglReleaseGlobalMutex();
            }
            break;
        case ESC_NV_OPENGL_STOP_STATE_CLIENT_TRACKING:
            OglAcquireGlobalMutex();
            DestroyContextClientInfo(ppdev, inCommand->hClient, TRUE);
            OglReleaseGlobalMutex();
            ulRet = ((ULONG)TRUE);
            break;
        case ESC_NV_OPENGL_ALLOC_SHARED_MEMORY:
            {
            void *globalData, *pfifoAddress, *pbusAddress;

            OglAcquireGlobalMutex();
            CreateSharedClientInfo(ppdev, inCommand->hClient, inCommand->processHandle, &globalData, &pfifoAddress, &pbusAddress);
            ((PVOID *)pvOut)[0] = globalData;
            ((PVOID *)pvOut)[1] = pfifoAddress;
            ((PVOID *)pvOut)[2] = pbusAddress;
            OglReleaseGlobalMutex();
            ulRet = ((ULONG)TRUE);
            }
            break;
        case ESC_NV_OPENGL_FREE_SHARED_MEMORY:
            OglAcquireGlobalMutex();
            DestroySharedClientInfo(ppdev, inCommand->hClient, inCommand->processHandle, inCommand->globalData, TRUE);
            OglReleaseGlobalMutex();
            ulRet = ((ULONG)TRUE);
            break;
        case ESC_NV_OPENGL_GET_DISPLAY_PITCH:
            ((ULONG *)pvOut)[0] = (ULONG)ppdev->lDelta;
            break;
        case ESC_NV4_OPENGL_SWAP_BUFFERS:
            {
            __GLNVswapInfo *swapInfo = (__GLNVswapInfo *)inCommand->other;

            ppdev->pfnAcquireOglMutex(ppdev);
            ulRet = NV4_OglSwapBuffers(ppdev,
                                       inCommand->hWnd,
                                       inCommand->hDC,
                                       swapInfo->hClient,
                                       swapInfo);
            ppdev->pfnReleaseOglMutex(ppdev);
            break;
            }
        case ESC_NV_OPENGL_SWAP_BUFFERS:
            {
            __GLNVswapInfo *swapInfo = (__GLNVswapInfo *)inCommand->other;

            ppdev->pfnAcquireOglMutex(ppdev);
            ulRet = NV_OglSwapBuffers(ppdev,
                                      inCommand->hWnd,
                                      inCommand->hDC,
                                      swapInfo->hClient,
                                      swapInfo);
            ppdev->pfnReleaseOglMutex(ppdev);
            break;
            }
        case ESC_NV_OPENGL_INIT_STATE:
            {
            NV_OglInitState(ppdev, inCommand->other);
            ulRet = ((ULONG)TRUE);
            break;
            }

        case ESC_NV_OPENGL_OVERLAY_MERGEBLIT:
        {
            __GLNVoverlayMergeBlitInfo *mergeInfo = (__GLNVoverlayMergeBlitInfo *)inCommand->other;

            ppdev->pfnAcquireOglMutex(ppdev);
            ulRet = NV_OglOverlayMergeBlit(ppdev,
                                           inCommand->hWnd,
                                           inCommand->hDC,
                                           mergeInfo);
            ppdev->pfnReleaseOglMutex(ppdev);
            break;
        }

        // this is used by W2K in DrvDescribePixelFormat
        case ESC_NV_OPENGL_PFD_CHECK:
        {
            ULONG *pulPfdCheckFlags = pvOut;           
            *pulPfdCheckFlags = 0;

            ulRet = bOglPfdCheckFlags(ppdev, pulPfdCheckFlags) ? 1 : (ULONG)-1;
            break;
        }
#endif // (NVARCH >= 0x4)
        case ESC_NV_OPENGL_PURGE_DEVICE_BITMAP:
            {
            ((ULONG *)pvOut)[0] = (ULONG)0; // means nothing got punted
            if (ppdev->cbGdiHeap)   // contains #bytes allocated by GDI
                {
                bMoveAllDfbsFromOffscreenToDibs(ppdev);
                ((ULONG *)pvOut)[0] = (ULONG)1; // means something got punted
                }
            ulRet = (ULONG) TRUE;
            break;
            }
        case ESC_NV4_OPENGL_FLUSH:
            {
            __GLNVflushInfo *flushInfo = (__GLNVflushInfo *)inCommand->other;

            ppdev->pfnAcquireOglMutex(ppdev);
            ulRet = NV4_OglFlushClipped(ppdev,
                                        inCommand->hWnd,
                                        inCommand->hDC,
                                        flushInfo->hClient,
                                        flushInfo);
            ppdev->pfnReleaseOglMutex(ppdev);
            break;
            }
        case ESC_NV_OPENGL_FLUSH:
            {
#if (NVARCH >= 0x4)
            __GLNVflushInfo *flushInfo = (__GLNVflushInfo *)inCommand->other;
#endif // (NVARCH >= 0x4)

            ulRet = (ULONG) FALSE;

#if (NVARCH >= 0x4)
            ppdev->pfnAcquireOglMutex(ppdev);
            ulRet = NV_OglFlushClipped(ppdev,
                                       inCommand->hWnd,
                                       inCommand->hDC,
                                       flushInfo->hClient,
                                       flushInfo);
            ppdev->pfnReleaseOglMutex(ppdev);
#endif // (NVARCH >= 0x4)
            break;
            }
        case ESC_NV_OPENGL_DMA_PUSH_GO_CMD:
            {
                if (ppdev == NULL || pvOut == NULL || pvIn == NULL) {
                    ulRet = ((ULONG)FALSE);
                    break;
                } else {
#ifdef NV3
                    Nv3DmaPushInfo *dmaPushInfo;
                    dmaPushInfo = (Nv3DmaPushInfo *)((Nv3DmaPushInfo *)pvIn);

                    if ((long)dmaPushInfo->put - (long)dmaPushInfo->get <= 0) {
                        ((ULONG *)pvOut)[1] = ppdev->dwGlobalModeSwitchCount;

                        ulRet = ((ULONG)FALSE);
                        break;
                    }

                    if (ppdev->cBitsPerPel == 16 &&
                        dmaPushInfo->localModeSwitchCount == ppdev->dwGlobalModeSwitchCount)
                        {
                        // on NV3 this is a DMA push kickoff escape function
                        ((ULONG *)pvOut)[0] = (ULONG)NV3_DmaPushGo(ppdev,
                            dmaPushInfo->dwChID,
                            dmaPushInfo->dwTlbPtBase,
                            dmaPushInfo->dwAddressSpace,
                            dmaPushInfo->get,
                            dmaPushInfo->put,
                            dmaPushInfo->hClient,
                            dmaPushInfo->hDevice);
                    }
#else                    
                    // on NV4 this is an engine sync escape function
                    // force a channel sync when GDI gets called again for rendering
                    ppdev->oglLastChannel = -1;  // FORCE IT TO SYNC...
                    ppdev->NVFreeCount = 0;
                    ppdev->pfnWaitForChannelSwitch(ppdev);
#endif // NV3
                }
                ((ULONG *)pvOut)[1] = ppdev->dwGlobalModeSwitchCount;

                DISPDBG((2, "DrvEscape - SUCCESS!"));
            }
            ulRet = ((ULONG)TRUE);
            break;
        case ESC_NV_OPENGL_SCREEN_TO_SCREEN_SRCCOPY:
            {
            ulRet = ((ULONG)FALSE);
            }
            break;
        case ESC_NV_OPENGL_SUPPORT_ENABLED:
            {
            // This is a toggle...
            if (ppdev->bSupportOgl == (ULONG)TRUE)
                ppdev->bSupportOgl = (ULONG)FALSE;
            else
                ppdev->bSupportOgl = (ULONG)TRUE;
            ((ULONG *)pvOut)[0] = ppdev->bSupportOgl; // return current value
            ulRet = ((ULONG)TRUE);
            }
            break;
        case ESC_NV_OPENGL_SET_DAC_BASE:
            ppdev->pfnAcquireOglMutex(ppdev);

            NvRestoreDacs(ppdev);

            ppdev->pfnReleaseOglMutex(ppdev);

            ulRet = ((ULONG)TRUE);
            break;
        case ESC_NV_OPENGL_CPUBLIT:
            {
                __GLNvCpuBltData * oglNvCpuBlitData;

                oglNvCpuBlitData = (__GLNvCpuBltData *)inCommand->other;

                ppdev->pfnAcquireOglMutex(ppdev);
                ulRet = OglCpuBlit(ppdev, oglNvCpuBlitData);

                ppdev->pfnReleaseOglMutex(ppdev);
            }
            break;
        case ESC_NV_OPENGL_ALLOC_UNIFIED_SURFACES:
            if (!OglAllocUnifiedSurfaces(ppdev, inCommand->other))
            {
                DISPDBG((0, "ERROR in DrvEscape: ESC_NV_OPENGL_ALLOC_UNIFIED_SURFACES-OglAllocUnifiedSurfaces failed!"));
            }
            ulRet = (ppdev->bOglSingleBackDepthSupported &&
                     ppdev->bOglSingleBackDepthCreated);
            break;
        case ESC_NV_OPENGL_FREE_UNIFIED_SURFACES:
            OglFreeUnifiedSurfaces(ppdev);
            ulRet = (ppdev->bOglSingleBackDepthSupported &&
                     !ppdev->bOglSingleBackDepthCreated);
            break;
        case ESC_NV_OPENGL_GET_SURFACE_INFO:
            {
                NvU32 fbInfo;
                outPtr = (ULONG *)pvOut;
                
                fbInfo = OglGetUnifiedSurfaceInfo(ppdev, inCommand->other);
                try
                {
                    *outPtr = (ULONG)fbInfo;
                }
                except(EXCEPTION_EXECUTE_HANDLER)
                {
                    status = GetExceptionCode();
                    DISPDBG((1, "ESC_NV_OPENGL_GET_SURFACE_INFO: ppdev: exception = 0x%lx", status));
                }
                if (fbInfo) {
                    ulRet = ((ULONG)TRUE);
                } else {
                    ulRet = ((ULONG)FALSE);
                }
                break;
            }
        case ESC_NV_OPENGL_DID_STATUS_CHANGE:
            outPtr = (ULONG *)pvOut;
            try
                {
                NV_OPENGL_CLIENT_INFO      *clientInfo = NULL;
                NV_OPENGL_CLIENT_INFO_LIST *clientList = NULL;

                clientList = OglFindClientInfoFromHWndHDC(ppdev, inCommand->hWnd, inCommand->hDC);
                if (clientList)
                    {
                    clientInfo = &clientList->clientInfo;
                    }
                if (clientInfo)
                    {
                    NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo;

                        clientDrawableInfo = clientInfo->clientDrawableInfo;
                        if (clientDrawableInfo->clipChangedCount != PtrToUlong(inCommand->other))

                        {
                        *outPtr = 1;
                        }
                    else
                        {
                        *outPtr = 0;
                        }
                    }
                else
                    {
                    *outPtr = -1; // client not found
                    }
                }
            except(EXCEPTION_EXECUTE_HANDLER)
                {
                status = GetExceptionCode();
                DISPDBG((1, "ESC_NV_OPENGL_DID_STATUS_CHANGE: ppdev: exception = 0x%lx", status));
                }
            ulRet = ((ULONG)TRUE);
            break;
        case ESC_NV_OPENGL_GET_CLIP_LIST_COUNT:
            outPtr = (ULONG *)pvOut;
            try
                {
                NV_OPENGL_CLIENT_INFO      *clientInfo = NULL;
                NV_OPENGL_CLIENT_INFO_LIST *clientList = NULL;

                clientList = OglFindClientInfoFromHWndHDC(ppdev, inCommand->hWnd, inCommand->hDC);
                if (clientList)
                    {
                    clientInfo = &clientList->clientInfo;
                    }
                if (clientInfo)
                    {
                    NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo;

                    clientDrawableInfo = clientInfo->clientDrawableInfo;
                    *outPtr = clientDrawableInfo->numClipRects;
                    }
                else
                    {
                    *outPtr = -1; // client not found
                    }
                }
            except(EXCEPTION_EXECUTE_HANDLER)
                {
                status = GetExceptionCode();
                DISPDBG((1, "ESC_NV_OPENGL_GET_CLIP_LIST_COUNT: ppdev: exception = 0x%lx", status));
                }
            ulRet = ((ULONG)TRUE);
            break;
        case ESC_NV_OPENGL_GET_CLIP_LIST:
            outPtr = (ULONG *)pvOut;
            try
                {
                NV_OPENGL_CLIENT_INFO_LIST *clientList = NULL;

                clientList = OglFindClientInfoFromHWndHDC(ppdev, inCommand->hWnd, inCommand->hDC);
                if (clientList)
                    {
                    NV_OPENGL_CLIP_LIST_DATA *nvClipList;
                    NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo;
                    int       i, rgnDataSize;
                    LPRGNDATA rgnData = NULL;
                    RECTL     *rectList = NULL, *rect = NULL;
                    static RECTL nullRect = { 0,0,0,0 };

                    clientDrawableInfo = clientList->clientInfo.clientDrawableInfo;
                    nvClipList = (NV_OPENGL_CLIP_LIST_DATA *)inCommand->other;

                    rect        = (RECTL *)nvClipList->rect; // bounds rectangle
                    rgnDataSize = sizeof(RGNDATAHEADER) + (clientDrawableInfo->numClipRects * sizeof(RECT));
                    rgnData     = (LPRGNDATA)nvClipList->rgnData;

                    if (rgnDataSize > nvClipList->rgnDataSize)
                        {
                        *outPtr = rgnDataSize;  // Insufficient space--return space needed.
                        }
                    else
                        {
                        rgnDataSize           = nvClipList->rgnDataSize;
                        rgnData->rdh.dwSize   = sizeof(RGNDATAHEADER);
                        rgnData->rdh.iType    = RDH_RECTANGLES;
                        rgnData->rdh.nCount   = clientDrawableInfo->numClipRects;
                        rgnData->rdh.nRgnSize = rgnDataSize;

                        rgnData->rdh.rcBound = clientDrawableInfo->rect;
                        rectList = (RECTL *)&rgnData->rdh.rcBound;
                        if (rectList->left >= rectList->right || rectList->top >= rectList->bottom)
                            {
                            // NULL clip list
                            rgnData->rdh.nCount = 0;
                            *rectList = nullRect; // rgnData->rdh.rcBound set to NULL rectangle
                            }

                        rectList = (RECTL *)&rgnData->Buffer;
                        if ((int)rgnData->rdh.nCount <= 0)
                            {
                            rectList[0] = nullRect;
                            }
                        else
                            {
                            for (i = 0; i < (int)rgnData->rdh.nCount; i++)
                                {
                                rectList[i] = clientDrawableInfo->copyWindowRect[i];
                                if (rectList[i].left >= rectList[i].right ||
                                    rectList[i].top >= rectList[i].bottom)
                                    {
                                    rectList[i] = nullRect;
                                    }
                                }
                            }

                        nvClipList->clipChangedCount = clientDrawableInfo->clipChangedCount;
                        *outPtr = 1;
                        }
                    }
                else
                    {
                    *outPtr = -1; // client not found
                    }
                }
            except(EXCEPTION_EXECUTE_HANDLER)
                {
                status = GetExceptionCode();
                DISPDBG((1, "ESC_NV_OPENGL_GET_CLIP_LIST: ppdev: exception = 0x%lx", status));
                }
            ulRet = ((ULONG)TRUE);
            break;

        case ESC_NV_OPENGL_SET_LAYER_PALETTE:
            ulRet = OglSetLayerPalette(inCommand->other);
            break;

        case ESC_NV_OPENGL_GET_LAYER_PALETTE:
            ulRet = OglGetLayerPalette(inCommand->other);
            break;

        default:
            ulRet = ((ULONG)FALSE);
            break;
    }

#if defined(_WIN64)
    EngRestoreFloatingPointState(ppdev->fpState);
#endif

    // Offset the return value by +1 so that the ESC_NV_OPENGL_ESCAPE escape handler
    // always returns >0, so a zero return from ExtEscape() will indicate a "hard"
    // GDI error.
    return(ulRet + 1);
}


//*************************************************************************
// OglSupportEnabled
// 
// returns TRUE if hw accelerated OpenGL is supported and allowed.
//*************************************************************************
ULONG OglSupportEnabled(PDEV *ppdev)
{
    if (   (ppdev->bSupportOgl == (ULONG)TRUE)         // sw enable/disable
        && (NULL != ppdev->pOglServer)                 // need ogl server data
        && OglCheckForClientDll(ppdev) == (ULONG)TRUE) // need ICD dll
        {
        return((ULONG)TRUE);
        }
    return((ULONG)FALSE);
}

/*
 * This function checks to see if the OpenGL driver is on
 * the system.  If it is then we can return TRUE.  If is
 * isn't then we return FALSE.  This code was added for NT5
 * because Microsoft reported a bug that we claimed to run
 * OpenGL but the client side DLL didn't exist.  But
 * Microsoft wouldn't let us ship the DLL.  This code became
 * old when Microsoft decided to let NVidia ship the OpenGL
 * client side DLL.
 */
static ULONG OglCheckForClientDll(PDEV *ppdev)
{
#if 0
    return((ULONG)TRUE);
#else
    unsigned char oglDllName[MAX_PATH + 1];
    HANDLE        oglDllHandle;

#ifdef NV3
    (void)wcscpy((wchar_t *)oglDllName, OGL_CLIENT_DLL_NAME_NV3);
#else    
    (void)wcscpy((wchar_t *)oglDllName, OGL_CLIENT_DLL_NAME_NV4);
#endif // NV3
    
    oglDllHandle = EngLoadModule((unsigned short *)&oglDllName[0]);
    if (oglDllHandle)
        {
        EngFreeModule(oglDllHandle);
        DISPDBG((2, "OglCheckForClientDll - SUCCESS!"));
        return((ULONG)TRUE);
        }
    DISPDBG((0, "OglCheckForClientDll - FAILED!"));
    return((ULONG)FALSE);
#endif
}

/******************************************************************************
 * This function does a generic CPU blit.
 * It is currently used in buffer region extension.
 * It can be optimized later by figuring out whether the blit was
 * from Mem To Screen OR Screen To Mem OR Mem To Mem.
 ******************************************************************************/
ULONG
OglCpuBlit(PDEV *ppdev, __GLNvCpuBltData *oglNVCpuBltData)
{
    BYTE *src, *dst;
    ULONG  srcStep, dstStep;
    ULONG  height, width;

    if (oglNVCpuBltData->useClipList == 0L)
    {
        src = (BYTE *)(oglNVCpuBltData->pSrcBase)
            + (oglNVCpuBltData->dwSrcTop * oglNVCpuBltData->dwSrcByteWidth)
            + (oglNVCpuBltData->dwSrcLeft * oglNVCpuBltData->dwSrcElementSize);
        dst = (BYTE *)(oglNVCpuBltData->pDstBase)
            + (oglNVCpuBltData->dwDstTop * oglNVCpuBltData->dwDstByteWidth)
            + (oglNVCpuBltData->dwDstLeft * oglNVCpuBltData->dwDstElementSize);

        srcStep = oglNVCpuBltData->dwSrcByteWidth;
        dstStep = oglNVCpuBltData->dwDstByteWidth;

        height = oglNVCpuBltData->dwHeight;
        width = oglNVCpuBltData->dwWidth * oglNVCpuBltData->dwDstElementSize;

        while (height--) {
            memcpy(dst, src, width);
            src += srcStep;
            dst += dstStep;
        }
    }
    else
    {
        /* Intersect rectangle
           (oglNVCpuBltData->dwSrcTop,
            oglNVCpuBltData->dwDstLeft,
            oglNVCpuBltData->dwSrcTop+oglNVCpuBltData->dwHeight,
            oglNVCpuBltData->dwSrcLeft+oglNVCpuBltData->dwWidth)
            with clip list using CombineRectList
            and blit each rectangle separately.
         */
    }
    oglNVCpuBltData->retStatus = TRUE;
    return ((ULONG)TRUE);
}



BOOL  nvSetDisplayDevice(PDEV *ppdev, PSETGETDEVTYPE pvIn)
{

   ULONG ReturnedDataLength;

   // - Attempt to perform the IOCTL to SET the display device
   if (
       EngDeviceIoControl(
            ppdev->hDriver,
            IOCTL_VIDEO_SET_DISPLAY_DEVICE,
            pvIn,
            sizeof(SETGETDEVTYPE),
            NULL,
            0,
            &ReturnedDataLength
      )
   ) {

      // - That call burned, so return fail
      return(FALSE);
   }

   return(TRUE);

}

BOOL  nvGetDisplayDevice(PDEV *ppdev, PSETGETDEVTYPE pvIn)
{

   ULONG ReturnedDataLength;

   // - Attempt to perform the IOCTL to GET the display device
   if (
       EngDeviceIoControl(
            ppdev->hDriver,
            IOCTL_VIDEO_GET_DISPLAY_DEVICE,
            NULL,
            0,
            pvIn,
            sizeof(SETGETDEVTYPE),
            &ReturnedDataLength
      )
   ) {

      // - That call burned, so return fail
      return(FALSE);
   }

   // - Make sure we got what we wanted, at least size wise
   if(ReturnedDataLength != sizeof(SETGETDEVTYPE))
      return(FALSE);

   return(TRUE);

}


BOOL __cdecl nvDoValidateDeviceModeEsc(PDEV *ppdev, VALMODEXTR *pvIn, DWORD *pvOut)
{

   ULONG ReturnedDataLength;

   // Assume that the mode is not valid just to be safe
   *(DWORD *)pvOut = FALSE;

   // - Attempt to perform the IOCTL to validate the device display mode
   if (
       EngDeviceIoControl(
            ppdev->hDriver,
            IOCTL_VALIDATE_DEVICE_MODE,
            pvIn,
            sizeof(VALMODEXTR),
            pvOut,
            sizeof(DWORD),
            &ReturnedDataLength
      )
   ) {

      DISPDBG((1, "DrvEscape - nvDoValidateDeviceModeEsc FAILED"));
      // - That call burned, so return fail
      return(FALSE);
   }

   // - Make sure we got what we wanted, at least size wise
   if(ReturnedDataLength != sizeof(DWORD))
      return(FALSE);

   DISPDBG((1, "DrvEscape - nvDoValidateDeviceModeEsc PASSED"));

   return(TRUE);

}


BOOL  nvGetDisplayDeviceClass(PDEV *ppdev, ULONG *deviceclass)
{

   ULONG ReturnedDataLength;

   // - Attempt to perform the IOCTL to GET the display device
   if (
       EngDeviceIoControl(
            ppdev->hDriver,
            IOCTL_VIDEO_IS_NVIDIA_BOARD_AND_DRIVER,
            NULL,
            0,
            deviceclass,
            sizeof(ULONG),
            &ReturnedDataLength
      )
   ) {

      // - That call burned, so return fail
      return(FALSE);
   }

   // - Make sure we got what we wanted, at least size wise
   if(ReturnedDataLength != sizeof(ULONG))
      return(FALSE);

   return(TRUE);

}

//
// Handles the hotkeys under NT4.0 for laptops.
// Return Value: FALSE if there was no hotkey pending. TRUE if a hotkey was pending.
// Modifies the 'ulDeviceMask' field with the hotkey device mask if a hotkey was pending. 
// 
//
BOOLEAN bHandleNT4HotKey(PPDEV ppdev, GET_DEVICE_MASK_DATA_TYPE *pInfo)
{
        NV_CFGEX_GET_HOTKEY_EVENT_PARAMS nvHotKeyEvent, nvTmp;
        ULONG ulDeviceMask;
        ULONG i, status;
        UCHAR statusByte;

        //
        // See if a NT4.0 style hotkey request is pending.
        //
        nvHotKeyEvent.status = 0;
        nvHotKeyEvent.event =  0;
        if (NvConfigGetEx (ppdev->hDriver, ppdev->hClient, ppdev->hDevice,
                 NV_CFGEX_GET_HOTKEY_EVENT, &nvHotKeyEvent, sizeof(NV_CFGEX_GET_HOTKEY_EVENT_PARAMS))) 
        {
            DISPDBG((1, "bHandleNT4HotKey() - Cannot get HOTKEY_EVENT from RM. What to do??"));
            return(FALSE);
        }
        
        //
        // check to see if a hotkey event is really pending
        //
        if (nvHotKeyEvent.event == NV_HOTKEY_EVENT_DISPLAY_ENABLE)
        {
            //
            // Atleast one HK event is there. Extract the device mask.
            //
            ulDeviceMask = 0;
            status = nvHotKeyEvent.status;
            DISPDBG((1,"special device word from RM to be parsed: 0x%x",nvHotKeyEvent.status));
            for (i=0; i < 2; i++)
            {   
                statusByte = (UCHAR)((status >> (i * 8)) & 0xff);
                switch (statusByte)
                {
                case NV_HOTKEY_STATUS_DISPLAY_ENABLE_LCD:
                    ulDeviceMask |= BITMASK_DFP0;
                    break;
                case NV_HOTKEY_STATUS_DISPLAY_ENABLE_CRT:
                    ulDeviceMask |= BITMASK_CRT0;
                    break;
                case NV_HOTKEY_STATUS_DISPLAY_ENABLE_TV:
                    ulDeviceMask |= BITMASK_TV0;
                    break;
                }
            }
            DISPDBG((1, "ulDeviceMask constructed: 0x%x",ulDeviceMask));
            pInfo->ulDeviceMask = ulDeviceMask;
            
            //
            // We now need to drain the event queue of the RM of any other 
            // HKs. This can happen if the user presses Fn+F5 faster than the driver can process.
            // Just as a safety measure, do it only say 50 times before bailing out.
            //
            nvTmp.event = NV_HOTKEY_EVENT_DISPLAY_ENABLE;
            i = 0;
            while (nvTmp.event != NV_HOTKEY_EVENT_NONE_PENDING && i < 50)
            {
                if (NvConfigGetEx (ppdev->hDriver, ppdev->hClient, ppdev->hDevice,
                 NV_CFGEX_GET_HOTKEY_EVENT, &nvTmp, sizeof(NV_CFGEX_GET_HOTKEY_EVENT_PARAMS))) 
                {
                    DISPDBG((1, "bHandleNT4HotKey() - Cannot get tmp HOTKEY_EVENT from RM. What to do??"));
                    break;
                }
                i++;
            }
            DISPDBG((1,"bHandleNT4HotKey(): Successful hotkey event processed")); 
            return(TRUE);
        }
        else
        {
            //
            // Either hotkey is not supported or is not pending.
            //
            DISPDBG((1,"bHandleNT4HotKey(): no hotkey event pending: 0x%x", nvHotKeyEvent.event)); 
            return(FALSE);
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\fillpath.c ===
//******************************Module*Header***********************************
//
//  Module Name: fillpath.c
//
//  Contains the DrvFillPath routine.
//
//  Copyright (c) 1992-1996 Microsoft Corporation
//
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"
#include "driver.h"
#include "oglsync.h"
/******************************Public*Routine******************************\
* DrvFillPath
*
* Fill the specified path with the specified brush and ROP.  This routine
* detects single convex polygons, and will call to separate faster convex
* polygon code for those cases.  This routine also detects polygons that
* are really rectangles, and handles those separately as well.
*
* Note: Multiple polygons in a path cannot be treated as being disjoint;
*       the fill must consider all the points in the path.  That is, if the
*       path contains multiple polygons, you cannot simply draw one polygon
*       after the other (unless they don't overlap).
*
* Note: This function is optional, but is recommended for good performance.
*       To get GDI to call this function, not only do you have to
*       HOOK_FILLPATH, you have to set GCAPS_ALTERNATEFILL and/or
*       GCAPS_WINDINGFILL.
*
\**************************************************************************/

BOOL DrvFillPath(
SURFOBJ*    pso,
PATHOBJ*    ppo,
CLIPOBJ*    pco,
BRUSHOBJ*   pbo,
POINTL*     pptlBrush,
MIX         mix,
FLONG       flOptions)
{
    //**************************************************************************
    // NV: Not implemented.
    //**************************************************************************
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\lines.c ===
//******************************************************************************
//
// Module Name: Lines.c
//
// Contains most of the required GDI line support.  Supports drawing
// lines in short 'strips' when clipping is complex or coordinates
// are too large to be drawn by the line hardware.
//
// Copyright (c) 1990-1996 Microsoft Corporation
//
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"
#include "driver.h"
#include "oglsync.h"

//*****************************************************************************
//
//  Function:   DrvStrokePath
//
//  Routine Description:
//
//              Strokes the path.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//*****************************************************************************

BOOL DrvStrokePath(
    SURFOBJ*   pso,
    PATHOBJ*   ppo,
    CLIPOBJ*   pco,
    XFORMOBJ*  pxo,
    BRUSHOBJ*  pbo,
    POINTL*    pptlBrush,
    LINEATTRS* pla,
    MIX        mix)


    {
    PDEV*   ppdev;
    DSURF*  pdsurfDst;
    ULONG   DstOffset;
    ULONG   DstStride;
    BOOL    result;
    SURFOBJ*    PuntPtr;
    ULONG       *DstBits;
    ULONG       *ScreenBitmap;


    //**************************************************************************
    // Get ptr to physical device.  We should never get a null surface object
    //**************************************************************************

    ppdev = (PDEV*) pso->dhpdev;

    //**************************************************************************
    // Set linear offset and stride for destination buffers
    //**************************************************************************

    pdsurfDst = (DSURF*) pso->dhsurf;    // May be NULL since we created the


    //**************************************************************************
    //  Fixes case where driver is called in full screen DOS during STRESS tests.
    //  In this case, GDI is allowed to call us to update DFBs that are stored in
    //  system memory. 
    //**************************************************************************

    if(!ppdev->bEnabled)
        {
        goto ENG_STROKE_PATH_IT;        
        }


    //************************************************************************** 
    // Need to do smart sync between OpenGL and GDI depending on 
    // clip intersection.
    //**************************************************************************
    if (OglIsEnabled(ppdev)) // fast ogl check
    {
        bOglSyncIfGdiInOglWindowPath(ppdev,pso,ppo,pco);
    }

    
    if (  (pdsurfDst != 0) && (pdsurfDst->dt == DT_SCREEN)  )
        {
        DstOffset = (ULONG)((BYTE *)(pdsurfDst->LinearPtr) - ppdev->pjFrameBufbase);
        DstStride = pdsurfDst->LinearStride;
        }

    else
        {
        DstOffset = ppdev->ulPrimarySurfaceOffset;
        DstStride = ppdev->lDelta;
        }

    //**************************************************************************
    // Check if this is a device managed surface
    //**************************************************************************

    if (pdsurfDst !=0)
    {

        //**********************************************************************
        // Pass the surface off to GDI if it's a device bitmap that we've
        // converted to a DIB:
        //**********************************************************************

        if (pdsurfDst->dt == DT_DIB)
        {
            //******************************************************************
            // NOTE: We use pdsurf->pso, NOT just pso, because this is
            //       a DFB that exists in system memory.
            //******************************************************************
            ppdev->pfnWaitEngineBusy(ppdev);
            return(ppdev->pfnEngStrokePath(pdsurfDst->pso, ppo, pco, pxo, pbo, pptlBrush,
                                           pla, mix));
        }
    }

    //**************************************************************************
    // Only handle line drawing to VRAM.  Send lines to system memory back to GDI.
    //**************************************************************************

    DstBits         = (ULONG *)(pso->pvBits);
    ScreenBitmap    = (ULONG *)(ppdev->pjScreen);
    if ((pdsurfDst == 0) && (DstBits != ScreenBitmap)) 
    {
        goto ENG_STROKE_PATH_IT;
    }

    (ppdev->pfnSetDestBase)(ppdev,DstOffset , DstStride);

    //*************************************************************************
    // Call the chip specific version of DrvStrokePath
    //*************************************************************************

    result =  (ppdev->pfnStrokePath)(pso,ppo,pco,pxo,pbo,pptlBrush,pla,mix)  ;

    return(result);

ENG_STROKE_PATH_IT:

//**************************************************************************
    // This 'punt' surface object is used only if we need to use GDI to
    // draw to an offscreen DFB.  Since the primary surface is already
    // a GDI-managed surface, we can kick back any line drawn to the screen.
    //**************************************************************************

    PuntPtr = pso;

    //**************************************************************************
    // Check if destination bitmap is a DFB.  If so, create a temporary surfobj
    // (mapped to the screen) that GDI can write on
    //**************************************************************************
    
    if (pdsurfDst !=0 )
        {
        PuntPtr         = ppdev->psoPunt;
        PuntPtr->dhsurf = 0;                    // Behave like a standard DIB
        
        if (pdsurfDst->dt == DT_SCREEN)
            {
            //*************************************************************
            // Set linear offset and stride for source and destination buffers
            //*************************************************************
            PuntPtr->sizlBitmap  = pdsurfDst->sizl;
            PuntPtr->cjBits  = pdsurfDst->LinearStride * pdsurfDst->sizl.cy;
            PuntPtr->pvBits  = pdsurfDst->LinearPtr;
            PuntPtr->pvScan0 = pdsurfDst->LinearPtr;
            PuntPtr->lDelta  = pdsurfDst->LinearStride;
            PuntPtr->iBitmapFormat = ppdev->iBitmapFormat;
            }
        else
            {
            //*************************************************************
            // This is a DFB which is stored in main memory as a DIB
            //*************************************************************
            PuntPtr->sizlBitmap  = pdsurfDst->pso->sizlBitmap;
            PuntPtr->cjBits      = pdsurfDst->pso->lDelta * pdsurfDst->pso->sizlBitmap.cy;
            PuntPtr->pvBits  = pdsurfDst->pso->pvBits;
            PuntPtr->pvScan0 = pdsurfDst->pso->pvScan0;
            PuntPtr->lDelta  = pdsurfDst->pso->lDelta;
            PuntPtr->iBitmapFormat = pdsurfDst->pso->iBitmapFormat;
            }
        }
    ppdev->pfnWaitEngineBusy(ppdev);
    return(ppdev->pfnEngStrokePath(PuntPtr, ppo, pco, pxo, pbo, pptlBrush, pla, mix));

    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\escape32.c ===
//***************************** Module Header **********************************
//
// Module Name: escape.c
//
// Escape handler for the 64 bit driver for 32 bit clients
//
// Copyright (c) 1996 Microsoft Corporation
//
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 2000 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"

#if defined(_WIN64)

#include "driver.h"
#include "nvReg.h"
#include "oglDD.h"
#include "pixelfmt.h"

//******************************************************************************
//
//  Function:   DrvEscape32(SURFOBJ *, ULONG, ULONG, VOID *, ULONG cjOut, VOID *pvOut)
//
//  Routine Description:
//
//      Driver escape entry point.  This function should return TRUE for any
//      supported escapes in response to QUERYESCSUPPORT, and FALSE for any
//      others.  All supported escapes are called from this routine.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

static ULONG DoOpenGLEscapeCommand32(PPDEV ppdev, PVOID in, PVOID out);

ULONG DrvEscape32(SURFOBJ *pso, ULONG iEsc,
                  ULONG cjIn, VOID *pvIn,
                  ULONG cjOut, VOID *pvOut)

{
    PDEV    *ppdev = (PDEV *)pso->dhpdev;

    switch(iEsc)
    {
    case NV_ESC_PRIMARY_INFO:
        {
        NV_PRIMARY_INFO32 *primaryInfoIn = (NV_PRIMARY_INFO32 *)pvIn;
        NV_PRIMARY_INFO32 *primaryInfoOut = (NV_PRIMARY_INFO32 *)pvOut;
        LONG status;
        unsigned int numActiveDACs, dacMask, activeDACs, d;

        try
            {
            if (primaryInfoIn && primaryInfoOut && primaryInfoIn->ulNVSignature == NV_SIGNATURE)
                {
                primaryInfoOut->ulWidth         = ppdev->cxScreen;
                primaryInfoOut->ulHeight        = ppdev->cyScreen;
                primaryInfoOut->ulDepth         = ppdev->cjPelSize << 3;
                primaryInfoOut->ulPitch         = ppdev->lDelta;
                primaryInfoOut->ulPrimaryOffset = ppdev->ulPrimarySurfaceOffset;
                primaryInfoOut->ulNumDACs       = ppdev->ulNumberDacsOnBoard;
                primaryInfoOut->ulNumActiveDACs = ppdev->ulNumberDacsActive;
                primaryInfoOut->ulPanningPtr    = NULL;
                primaryInfoOut->ulReturnCode    = TRUE;

                // Compute a bitmap of active DACs by looping over all displays
                // until we've checked them all, or found ulNumberDacsActive
                // unique DACs--whichever comes first.
                for (d = activeDACs = numActiveDACs = 0; (d < NV_NO_DACS) &&
                     (numActiveDACs < ppdev->ulNumberDacsActive); d++)
                    {
                    if (ppdev->ulDeviceDisplay[d] < NV_NO_DACS)
                        {
                        dacMask = 1 << ppdev->ulDeviceDisplay[d];
                        if (!(dacMask & activeDACs))
                            {
                            numActiveDACs++;
                            activeDACs |= dacMask;
                            }
                        }
                    }
                primaryInfoOut->ulActiveDACs = activeDACs;
                }
            else
                {
                return (ULONG)FALSE;
                }
            }
        except(EXCEPTION_EXECUTE_HANDLER)
            {
            status = GetExceptionCode();
            DISPDBG((1, "NV_ESC_PRIMARY_INFO: exception = 0x%lx", status));
            return (ULONG)FALSE;
            }
        }
        return (ULONG)TRUE;
        break;
    case ESC_NV_OPENGL_ESCAPE:
        {
        return((ULONG)DoOpenGLEscapeCommand32(ppdev, (PVOID)pvIn, (PVOID)pvOut));
        }
        break;
    case ESC_NV_QUERYSET_REGISTRY_KEY:
        {
            __PNVRegKeyInfo32 inParms, outParms;
            WCHAR tmpStrBuf[NV_MAX_REG_KEYNAME_LEN];
            ULONG  inpStrLen, outStrLen;
            ULONG ii, returnedDataLen;
            NV_REGISTRY_STRUCT regStruct;
            NV_REGISTRY_STRUCT regStructInput, regStructOutput;
            DWORD retStatus;
            

            inParms = (__PNVRegKeyInfo32) pvIn;


            if (!inParms->keyName)
                return (FALSE);

            inpStrLen = strlen(inParms->keyName);

            if ((inpStrLen+1) > NV_MAX_REG_KEYNAME_LEN)
                return (FALSE);
            /*
            for (ii = 0; ii < inpStrLen; ii++)
                tmpStrBuf[ii] = inParms->keyName[ii];
            tmpStrBuf[ii] = 0;
            */

            EngMultiByteToUnicodeN((LPWSTR)tmpStrBuf, NV_MAX_REG_KEYNAME_LEN*sizeof(WCHAR), &outStrLen,
                                   inParms->keyName, (inpStrLen+1)*sizeof(CHAR));



            switch(inParms->type)
            {
            case NV_QUERY_REGISTRY_BINARY_KEY:
                outParms = (__PNVRegKeyInfo32) pvOut;
                *outParms = *inParms;

                regStructInput.keyName = (PWSTR)tmpStrBuf;
                regStructInput.keyVal = outParms->keyVal;
                regStructInput.keyValSize = outParms->keyValMaxSize;

                retStatus = EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_QUERY_REGISTRY_BINARY_VAL,
                               (LPVOID)&regStructInput,
                               sizeof(NV_REGISTRY_STRUCT),
                               (LPVOID) (&regStructOutput),
                               sizeof(NV_REGISTRY_STRUCT),
                               &(returnedDataLen));

                outParms = (__PNVRegKeyInfo32) pvOut;

                outParms->retStatus = retStatus;

                // Copy the returned registry value size into outParams
                outParms->keyValSize = regStructOutput.keyValSize;
                // The KeyVal has already been copied by the miniport

                break;

            case NV_QUERY_REGISTRY_KEY:

                outParms = (__PNVRegKeyInfo32) pvOut;
                *outParms = *inParms;

                retStatus = EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_QUERY_REGISTRY_VAL,
                               (LPVOID)tmpStrBuf,
                               outStrLen,
                               (LPVOID) (outParms->keyVal),
                               outParms->keyValMaxSize,
                               &(outParms->keyValSize));

                outParms->retStatus = retStatus;

                break;

            case NV_SET_REGISTRY_KEY:

                outParms = (__PNVRegKeyInfo32) pvOut;
                *outParms = *inParms;

                regStruct.keyName = (PWSTR)tmpStrBuf;
                regStruct.keyVal = inParms->keyVal;
                regStruct.keyValSize = inParms->keyValSize;

                retStatus = EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_SET_REGISTRY_VALUE,
                               (LPVOID)(&regStruct),
                               sizeof(NV_REGISTRY_STRUCT),
                               (LPVOID) NULL,
                               0,
                               &returnedDataLen);

                outParms->retStatus = retStatus;

                break;

            default:
                break;
            }
            return (TRUE);
        }
        break;
    default:
        break;
    }

    return (ULONG)FALSE;
}

static ULONG DoOpenGLEscapeCommand32(PPDEV ppdev, PVOID pvIn, PVOID pvOut)
{
    NV_OPENGL_COMMAND32 *inCommand;
    LONG                status;
    ULONG               ulRet = FALSE;

    ASSERT(ppdev);

    inCommand = (NV_OPENGL_COMMAND32 *)pvIn;
    try
        {
        ppdev->numDevices = inCommand->numDevices;
        }
    except(EXCEPTION_EXECUTE_HANDLER)
        {
        status = GetExceptionCode();
        DISPDBG((1, "DoOpenGLEscapeCommand32: exception = 0x%lx", status));
        return(1 + (ULONG)FALSE);
        }
    switch(inCommand->command)
    {
    case ESC_NV_OPENGL_SHARED_LIBRARY_SIZES:
        ulRet = ((ULONG)TRUE);
        break;
    case ESC_NV_OPENGL_SUPPORT:
        if (OglSupportEnabled(ppdev) == (ULONG)TRUE)
        {
            if (inCommand->NVSignature == NV_SIGNATURE)
            {
                ulRet = ((ULONG)TRUE);
                break;
            }
            else
            {
                ulRet = ((ULONG)FALSE);
                break;
            }
         }
         ulRet = ((ULONG)FALSE);
         break;
    case ESC_NV_OPENGL_REGISTER_RM_CLIENT:
        OglAcquireGlobalMutex();
        OglRegisterRmClient(ppdev, (ULONG)(inCommand->other));
        OglReleaseGlobalMutex();
        ulRet = ((ULONG)TRUE);
        break;
    case ESC_NV_OPENGL_UNREGISTER_RM_CLIENT:
        OglAcquireGlobalMutex();
        OglUnRegisterRmClient(ppdev, (ULONG)(inCommand->other));
        OglReleaseGlobalMutex();
        ulRet = ((ULONG)TRUE);
        break;
    case ESC_NV_OPENGL_DESTROY_DRAWABLE:
        OglAcquireGlobalMutex();
        DestroyDrawableClientInfo(ppdev, inCommand->hWnd, inCommand->hDC, TRUE);
        OglReleaseGlobalMutex();
        ulRet = ((ULONG)TRUE);
        break;
    case ESC_NV_OPENGL_START_STATE_CLIENT_TRACKING:
        OglAcquireGlobalMutex();
        ulRet = CreateContextClientInfo(ppdev, inCommand->hWnd, inCommand->hClient);
        OglReleaseGlobalMutex();
        break;
    case ESC_NV_OPENGL_STOP_STATE_CLIENT_TRACKING:
        OglAcquireGlobalMutex();
        DestroyContextClientInfo(ppdev, inCommand->hClient, TRUE);
        OglReleaseGlobalMutex();
        ulRet = ((ULONG)TRUE);
        break;
    case ESC_NV_OPENGL_ALLOC_SHARED_MEMORY:
         {
            void *globalData, *pfifoAddress, *pbusAddress;
            void * __ptr32 * outPtr = (void * __ptr32 *)pvOut;

            OglAcquireGlobalMutex();
            CreateSharedClientInfo(ppdev, inCommand->hClient, inCommand->processHandle, &globalData, &pfifoAddress, &pbusAddress);
            outPtr[0] = (void * __ptr32)globalData;
            outPtr[1] = (void * __ptr32)pfifoAddress;
            outPtr[2] = (void * __ptr32)pbusAddress;
            OglReleaseGlobalMutex();
            ulRet = ((ULONG)TRUE);
        }
        break;
    case ESC_NV_OPENGL_FREE_SHARED_MEMORY:
        OglAcquireGlobalMutex();
        DestroySharedClientInfo(ppdev, inCommand->hClient, inCommand->processHandle, inCommand->globalData, TRUE);
        OglReleaseGlobalMutex();
        ulRet = ((ULONG)TRUE);
        break;
    case ESC_NV_OPENGL_INIT_STATE:
        ppdev->oglSyncGdi       = 0;
        ulRet = ((ULONG)TRUE);
        break;
    // this is used by W2K in DrvDescribePixelFormat
    case ESC_NV_OPENGL_PFD_CHECK:
    {
        ULONG *pulPfdCheckFlags = pvOut;           
        *pulPfdCheckFlags = 0;

        ulRet = bOglPfdCheckFlags(ppdev, pulPfdCheckFlags) ? 1 : (ULONG)-1;
        break;
    }
     case ESC_NV_OPENGL_PURGE_DEVICE_BITMAP:
        ((ULONG *)pvOut)[0] = (ULONG)0; // means nothing got punted
        if (ppdev->cbGdiHeap)   // contains #bytes allocated by GDI
        {
            bMoveAllDfbsFromOffscreenToDibs(ppdev);
            ((ULONG *)pvOut)[0] = (ULONG)1; // means something got punted
        }
        ulRet = (ULONG) TRUE;
        break;
     case ESC_NV_OPENGL_FLUSH:
        {
            __GLNVflushInfo flushInfo;
            __GLNVcmdInfo cmdInfo;

            NvCopyStructIn(inCommand->other, &flushInfo, "IPPIP[IIII]IIIIi");
            NvCopyStructIn(flushInfo.cmdInfo, &cmdInfo, "PIIPPIIICIIIIIIIIIII");
            flushInfo.cmdInfo = &cmdInfo;

            ppdev->pfnAcquireOglMutex(ppdev);
            ulRet = NV_OglFlushClipped(ppdev,
                                       inCommand->hWnd,
                                       inCommand->hDC,
                                       flushInfo.hClient,
                                       &flushInfo);
            ppdev->pfnReleaseOglMutex(ppdev);
            NvCopyStructOut(inCommand->other, &flushInfo, "ippip[iiii]iiiiI");
        }
        break;
    case ESC_NV_OPENGL_ALLOC_UNIFIED_SURFACES:
        OglAllocUnifiedSurfaces(ppdev, inCommand->other);
        ulRet = (ppdev->bOglSingleBackDepthSupported &&
                 ppdev->bOglSingleBackDepthCreated);
        break;
    case ESC_NV_OPENGL_FREE_UNIFIED_SURFACES:
        OglFreeUnifiedSurfaces(ppdev);
        ulRet = (ppdev->bOglSingleBackDepthSupported &&
                 !ppdev->bOglSingleBackDepthCreated);
        break;
    case ESC_NV_OPENGL_GET_SURFACE_INFO:
        {
            NvU32 fbInfo;
            ULONG *outPtr = (ULONG *)pvOut;
                
            fbInfo = OglGetUnifiedSurfaceInfo(ppdev, inCommand->other);
            try
            {
                *outPtr = (ULONG)fbInfo;
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                status = GetExceptionCode();
                DISPDBG((1, "ESC_NV_OPENGL_GET_SURFACE_INFO: ppdev: exception = 0x%lx", status));
            }
            if (fbInfo)
            {
                ulRet = ((ULONG)TRUE);
            }
            else
            {
                ulRet = ((ULONG)FALSE);
            }
        }
        break;
    case ESC_NV_OPENGL_GET_CLIP_LIST_COUNT:
        {
            ULONG *outPtr = (ULONG *)pvOut;
            try
            {
                NV_OPENGL_CLIENT_INFO      *clientInfo = NULL;
                NV_OPENGL_CLIENT_INFO_LIST *clientList = NULL;

                clientList = OglFindClientInfoFromHWndHDC(ppdev, inCommand->hWnd, inCommand->hDC);
                if (clientList)
                {
                    clientInfo = &clientList->clientInfo;
                }
                if (clientInfo)
                {
                    NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo;

                    clientDrawableInfo = clientInfo->clientDrawableInfo;
                    *outPtr = clientDrawableInfo->numClipRects;
                }
                else
                {
                    *outPtr = -1; // client not found
                }
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                status = GetExceptionCode();
                DISPDBG((1, "ESC_NV_OPENGL_GET_CLIP_LIST_COUNT: ppdev: exception = 0x%lx", status));
                }
            ulRet = ((ULONG)TRUE);
        }
        break;
    case ESC_NV_OPENGL_GET_CLIP_LIST:
        {
            ULONG *outPtr = (ULONG *)pvOut;
            try
            {
                NV_OPENGL_CLIENT_INFO_LIST *clientList = NULL;

                clientList = OglFindClientInfoFromHWndHDC(ppdev, inCommand->hWnd, inCommand->hDC);
                if (clientList)
                {
                    NV_OPENGL_CLIP_LIST_DATA32 *nvClipList;
                    NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo;
                    int       i, rgnDataSize;
                    LPRGNDATA rgnData = NULL;
                    RECTL     *rectList = NULL, *rect = NULL;
                    static RECTL nullRect = { 0,0,0,0 };

                    clientDrawableInfo = clientList->clientInfo.clientDrawableInfo;
                    nvClipList = (NV_OPENGL_CLIP_LIST_DATA32 *)inCommand->other;

                    rect        = (RECTL *)nvClipList->rect; // bounds rectangle
                    rgnDataSize = sizeof(RGNDATAHEADER) + (clientDrawableInfo->numClipRects * sizeof(RECT));
                    rgnData     = (LPRGNDATA)nvClipList->rgnData;

                    if (rgnDataSize > nvClipList->rgnDataSize)
                    {
                        *outPtr = rgnDataSize;  // Insufficient space--return space needed.
                    }
                    else
                    {
                        rgnDataSize           = nvClipList->rgnDataSize;
                        rgnData->rdh.dwSize   = sizeof(RGNDATAHEADER);
                        rgnData->rdh.iType    = RDH_RECTANGLES;
                        rgnData->rdh.nCount   = clientDrawableInfo->numClipRects;
                        rgnData->rdh.nRgnSize = rgnDataSize;

                        rgnData->rdh.rcBound = clientDrawableInfo->rect;
                        rectList = (RECTL *)&rgnData->rdh.rcBound;
                        if (rectList->left >= rectList->right ||
                            rectList->top  >= rectList->bottom)
                       {
                            // NULL clip list
                            rgnData->rdh.nCount = 0;
                            *rectList = nullRect; // rgnData->rdh.rcBound set to NULL rectangle
                       }

                        rectList = (RECTL *)&rgnData->Buffer;
                        if ((int)rgnData->rdh.nCount <= 0)
                        {
                            rectList[0] = nullRect;
                        }
                        else
                        {
                            for (i = 0; i < (int)rgnData->rdh.nCount; i++)
                            {
                                rectList[i] = clientDrawableInfo->copyWindowRect[i];
                                if (rectList[i].left >= rectList[i].right ||
                                    rectList[i].top  >= rectList[i].bottom)
                                {
                                    rectList[i] = nullRect;
                                }
                            }
                        }

                        nvClipList->clipChangedCount = clientDrawableInfo->clipChangedCount;
                        *outPtr = 1;
                    }
                }
                else
                {
                    *outPtr = -1; // client not found
                }
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                status = GetExceptionCode();
                DISPDBG((1, "ESC_NV_OPENGL_GET_CLIP_LIST: ppdev: exception = 0x%lx", status));
            }
            ulRet = ((ULONG)TRUE);
        }
        break;
    default:
        ulRet = ((ULONG)FALSE);
        break;
    }

    return(ulRet + 1);
    // Offset the return value by +1 so that the ESC_NV_OPENGL_ESCAPE escape
    // handler always returns >0, so a zero return from ExtEscape() will
    // indicate a "hard" GDI error.
}

VOID NvCopyStructIn(VOID *ptr32, VOID *ptr64, CHAR *fmt)
{
    char f;

    while ((f = *fmt++) != '\0') {
        switch(f) {
        case 'c':
            ((char *)ptr32)++;
            ((char *)ptr64)++;
            break;
        case 'C':
            *((char *)ptr64)++ = *((char *)ptr32)++;
            break;
        case 's':
            ptr32 = (void *)(((uintptr_t)ptr32 + 0x1) & ~0x1);
            ptr64 = (void *)(((uintptr_t)ptr64 + 0x1) & ~0x1);
            ((short *)ptr32)++;
            ((short *)ptr64)++;
            break;
        case 'S':
            ptr32 = (void *)(((uintptr_t)ptr32 + 0x1) & ~0x1);
            ptr64 = (void *)(((uintptr_t)ptr64 + 0x1) & ~0x1);
            *((short *)ptr64)++ = *((short *)ptr32)++;
            break;
        case 'i':
            ptr32 = (void *)(((uintptr_t)ptr32 + 0x3) & ~0x3);
            ptr64 = (void *)(((uintptr_t)ptr64 + 0x3) & ~0x3);
            ((int *)ptr32)++;
            ((int *)ptr64)++;
            break;
        case 'I':
            ptr32 = (void *)(((uintptr_t)ptr32 + 0x3) & ~0x3);
            ptr64 = (void *)(((uintptr_t)ptr64 + 0x3) & ~0x3);
            *((int *)ptr64)++ = *((int *)ptr32)++;
            break;
        case 'p':
            ptr32 = (void *)(((uintptr_t)ptr32 + 0x3) & ~0x3);
            ptr64 = (void *)(((uintptr_t)ptr64 + 0x7) & ~0x7);
            ((void * __ptr32 *)ptr32)++;
            ((void **)ptr64)++;
            break;
        case 'P':
            ptr32 = (void *)(((uintptr_t)ptr32 + 0x3) & ~0x3);
            ptr64 = (void *)(((uintptr_t)ptr64 + 0x7) & ~0x7);
            *((void **)ptr64)++ = *((void * __ptr32 *)ptr32)++;
            break;
        case '{':
        case '}':
            break;
        }
    }
}

VOID NvCopyStructOut(VOID *ptr32, VOID *ptr64, CHAR *fmt)
{
    char f;

    while ((f = *fmt++) != '\0') {
        switch(f) {
        case 'c':
            ((char *)ptr32)++;
            ((char *)ptr64)++;
            break;
        case 'C':
            *((char *)ptr32)++ = *((char *)ptr64)++;
            break;
        case 's':
            ptr32 = (void *)(((uintptr_t)ptr32 + 0x1) & ~0x1);
            ptr64 = (void *)(((uintptr_t)ptr64 + 0x1) & ~0x1);
            ((short *)ptr32)++;
            ((short *)ptr64)++;
            break;
        case 'S':
            ptr32 = (void *)(((uintptr_t)ptr32 + 0x1) & ~0x1);
            ptr64 = (void *)(((uintptr_t)ptr64 + 0x1) & ~0x1);
            *((short *)ptr32)++ = *((short *)ptr64)++;
            break;
        case 'i':
            ptr32 = (void *)(((uintptr_t)ptr32 + 0x3) & ~0x3);
            ptr64 = (void *)(((uintptr_t)ptr64 + 0x3) & ~0x3);
            ((int *)ptr32)++;
            ((int *)ptr64)++;
            break;
        case 'I':
            ptr32 = (void *)(((uintptr_t)ptr32 + 0x3) & ~0x3);
            ptr64 = (void *)(((uintptr_t)ptr64 + 0x3) & ~0x3);
            *((int *)ptr32)++ = *((int *)ptr64)++;
            break;
        case 'p':
            ptr32 = (void *)(((uintptr_t)ptr32 + 0x3) & ~0x3);
            ptr64 = (void *)(((uintptr_t)ptr64 + 0x7) & ~0x7);
            ((void **)ptr64)++;
            ((void * __ptr32 *)ptr32)++;
            break;
        case 'P':
            ptr32 = (void *)(((uintptr_t)ptr32 + 0x3) & ~0x3);
            ptr64 = (void *)(((uintptr_t)ptr64 + 0x7) & ~0x7);
            *((void * __ptr32 *)ptr32)++ = (void * __ptr32)*((void **)ptr64)++;
            break;
        case '{':
        case '}':
            break;
        }
    }
}
#endif // defined(_WIN64)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\lineto.c ===
//*****************************Module*Header************************************
// 
// Module Name: Lineto.c
// 
// DrvLineTo for NV driver
// 
// Copyright (c) 1995-1996 Microsoft Corporation
// 
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"
#include "driver.h"
#include "oglsync.h"

//*****************************************************************************
//  
//  Function:   DrvLineTo
//  
//  Routine Description:
//  
//          Draws a single solid integer-only cosmetic line.
//
//  Arguments:
//  
//  Return Value:
//  
//      None.
//  
//*****************************************************************************


BOOL DrvLineTo(
SURFOBJ*    pso,
CLIPOBJ*    pco,
BRUSHOBJ*   pbo,
LONG        x1,
LONG        y1,
LONG        x2,
LONG        y2,
RECTL*      prclBounds,
MIX         mix)

    {
    PDEV*   ppdev;
    DSURF*  pdsurfDst;
    ULONG   DstOffset;
    ULONG   DstStride;
    BOOL    result;
    SURFOBJ*    PuntPtr;

    //**************************************************************************
    // Get ptr to physical device.  We should never get a null surface object
    //**************************************************************************

    ppdev = (PDEV*) pso->dhpdev;

    //**************************************************************************
    // Set linear offset and stride for source and destination buffers
    //**************************************************************************

    pdsurfDst = (DSURF*) pso->dhsurf;    // May be NULL since we created the

#if _WIN32_WINNT >= 0x0500

    //**************************************************************************
    //  Fixes case where driver is called in full screen DOS during STRESS tests.
    //  In this case, GDI is allowed to call us to update DFBs that are stored in
    //  system memory. 
    //**************************************************************************

        if(!ppdev->bEnabled)
            goto DRV_LINE_TO_IT;
#endif

    //************************************************************************** 
    // Need to do smart sync between OpenGL and GDI depending on 
    // clip intersection.
    //**************************************************************************
    if (OglIsEnabled(ppdev)) // fast ogl check
    {
        bOglSyncIfGdiInOglWindowRect(ppdev,pso,prclBounds,pco);
    }

    
    if (  (pdsurfDst != 0) && (pdsurfDst->dt == DT_SCREEN)  )
        {
        DstOffset = (ULONG)((BYTE *)(pdsurfDst->LinearPtr) - ppdev->pjFrameBufbase);
        DstStride = pdsurfDst->LinearStride;
        }
    else
        { 
        DstOffset = ppdev->ulPrimarySurfaceOffset;
        DstStride = ppdev->lDelta;
        }
    
    (ppdev->pfnSetDestBase)(ppdev,DstOffset , DstStride);


    //*************************************************************************
    // Call the chip specific version of DrvLineTo
    //*************************************************************************

    result =  (ppdev->pfnLineTo)(pso,pco,pbo,x1,y1,x2,y2,prclBounds,mix)  ;

    return(result);

#if _WIN32_WINNT >= 0x0500

DRV_LINE_TO_IT:

    //**************************************************************************
    // This 'punt' surface object is used only if we need to use GDI to
    // draw to an offscreen DFB.  Since the primary surface is already
    // a GDI-managed surface, we can kick back any line drawn to the screen.
    //**************************************************************************

    PuntPtr = pso;

    //**************************************************************************
    // Check if destination bitmap is a DFB.  If so, create a temporary surfobj
    // (mapped to the screen) that GDI can write on
    //**************************************************************************
    
    if (pdsurfDst !=0 )
        {
        PuntPtr         = ppdev->psoPunt;
        PuntPtr->dhsurf = 0;                    // Behave like a standard DIB
        
        if (pdsurfDst->dt == DT_SCREEN)
            {
            //*************************************************************
            // Set linear offset and stride for source and destination buffers
            //*************************************************************
            PuntPtr->sizlBitmap  = pdsurfDst->sizl;
            PuntPtr->cjBits  = pdsurfDst->LinearStride * pdsurfDst->sizl.cy;
            PuntPtr->pvBits  = pdsurfDst->LinearPtr;
            PuntPtr->pvScan0 = pdsurfDst->LinearPtr;
            PuntPtr->lDelta  = pdsurfDst->LinearStride;
            PuntPtr->iBitmapFormat = ppdev->iBitmapFormat;
            }
        else
            {
            //*************************************************************
            // This is a DFB which is stored in main memory as a DIB
            //*************************************************************
            PuntPtr->sizlBitmap     = pdsurfDst->pso->sizlBitmap;
            PuntPtr->cjBits         = pdsurfDst->pso->lDelta * pdsurfDst->pso->sizlBitmap.cy;
            PuntPtr->pvBits         = pdsurfDst->pso->pvBits;
            PuntPtr->pvScan0        = pdsurfDst->pso->pvScan0;
            PuntPtr->lDelta         = pdsurfDst->pso->lDelta;
            PuntPtr->iBitmapFormat  = pdsurfDst->pso->iBitmapFormat;
            }
        }
    ppdev->pfnWaitEngineBusy(ppdev);    
    return(ppdev->pfnEngLineTo(PuntPtr, pco, pbo, x1, y1, x2, y2, prclBounds, mix));
#endif

    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\lines.h ===
/******************************Module*Header***********************************\
* Module Name: lines.h
*
* Line drawing constants and structures.
*
* NOTE: This file mirrors LINES.INC.  Changes here must be reflected in
* the .inc file!
*
* Copyright (c) 1992-1996 Microsoft Corporation
\******************************************************************************/

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

typedef struct _PDEV PDEV;      // Handy forward declaration

// We have to be careful that we don't overflow any registers when using
// the hardware to draw lines (as opposed to going through the strips
// routines, which will never overflow).  We accomplish this by simply
// checking the bounds of the path; if it is so large that any of the
// hardware terms may overflow, we punt the entire path to the strips
// code (should be pretty rare).

// The clipping hardware coordinates are limited to 16-bit unsigned values:

#define MIN_INTEGER_BOUND (0)
#define MAX_INTEGER_BOUND (65535)

// We have special strip routines when all strips have at most this many
// pixels:

#define MAX_SHORT_STROKE_LENGTH 15

// # of strip drawers in every group:

#define NUM_STRIP_DRAW_DIRECTIONS 4

// # of strip drawers for doing either solid lines or styled lines:

#define NUM_STRIP_DRAW_STYLES 8

typedef LONG STYLEPOS;

#define STYLE_MAX_COUNT     16
#define STYLE_MAX_VALUE     0x3fffL
#define RUN_MAX             20
#define STRIP_MAX           100
#define STYLE_DENSITY       3

// Flip and round flags:

#define FL_H_ROUND_DOWN         0x00000080L     // .... .... 1... ....
#define FL_V_ROUND_DOWN         0x00008000L     // 1... .... .... ....

#define FL_FLIP_D               0x00000005L     // .... .... .... .1.1
#define FL_FLIP_V               0x00000008L     // .... .... .... 1...
#define FL_FLIP_SLOPE_ONE       0x00000010L     // .... .... ...1 ....
#define FL_FLIP_HALF            0x00000002L     // .... .... .... ..1.
#define FL_FLIP_H               0x00000200L     // .... ..1. .... ....

#define FL_ROUND_MASK           0x0000001CL     // .... .... ...1 11..
#define FL_ROUND_SHIFT          2

#define FL_RECTLCLIP_MASK       0x0000000CL     // .... .... .... 11..
#define FL_RECTLCLIP_SHIFT      2

#define FL_STRIP_MASK           0x00000003L     // .... .... .... ..11
#define FL_STRIP_SHIFT          0

#define FL_SIMPLE_CLIP          0x00000020      // .... .... ..1. ....
#define FL_COMPLEX_CLIP         0x00000040      // .... .... .1.. ....
#define FL_CLIP                (FL_SIMPLE_CLIP | FL_COMPLEX_CLIP)

#define FL_STYLED               0x00000400L     // .... .1.. .... ....
#define FL_ALTERNATESTYLED      0x00001000L     // ...1 .... .... ....

#define FL_STYLE_MASK           0x00000400L
#define FL_STYLE_SHIFT          10

#define FL_LAST_PEL_INCLUSIVE   0x00002000L     // ..1. .... .... ....

// Miscellaneous DDA defines:

#define LROUND(x, flRoundDown) (((x) + F/2 - ((flRoundDown) > 0)) >> 4)
#define F                     16
#define FLOG2                 4
#define LFLOOR(x)             ((x) >> 4)
#define FXFRAC(x)             ((x) & (F - 1))

////////////////////////////////////////////////////////////////////////////
// NOTE: The following structures must exactly match those declared in
//       lines.inc!

typedef struct _STRIP {
    LONG   cStrips;               // # of strips in array
    LONG   flFlips;               // Indicates if line goes up or down
    POINTL ptlStart;             // first point
    LONG   alStrips[STRIP_MAX];   // Array of strips
} STRIP;

typedef struct _LINESTATE {
    STYLEPOS*       pspStart;       // Pointer to start of style array
    STYLEPOS*       pspEnd;         // Pointer to end of style array
    STYLEPOS*       psp;            // Pointer to current style entry

    STYLEPOS        spRemaining;    // To go in current style
    STYLEPOS        spTotal;        // Sum of style array
    STYLEPOS        spTotal2;       // Twice sum of style array
    STYLEPOS        spNext;         // Style state at start of next line
    STYLEPOS        spComplex;      // Style state at start of complex clip line

    STYLEPOS*       aspRtoL;        // Style array in right-to-left order
    STYLEPOS*       aspLtoR;        // Style array in left-to-right order

    ULONG           ulStyleMask;    // Are we working on a gap in the style?
                                    // 0xff if yes, 0x0 if not
    ULONG           xyDensity;      // Density of style
    ULONG           cStyle;         // Size of style array

    ULONG           ulStyleMaskLtoR;// Original style mask, left-to-right order
    ULONG           ulStyleMaskRtoL;// Original style mask, right-to-left order

    BOOL            ulStartMask;    // Determines if first element in style
                                    // array is for a gap or a dash

} LINESTATE;                        /* ls */

// Strip drawer prototype:

typedef VOID (*PFNSTRIP)(PDEV*, STRIP*, LINESTATE*);
extern PFNSTRIP gapfnStrip[];

// Strip drawers:

VOID vssSolidHorizontal(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vrlSolidHorizontal(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);

VOID vssSolidVertical(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vrlSolidVertical(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);

VOID vssSolidDiagonalHorizontal(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vrlSolidDiagonalHorizontal(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);

VOID vssSolidDiagonalVertical(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vrlSolidDiagonalVertical(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);

VOID vStripStyledHorizontal(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vStripStyledVertical(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);

// External calls:

BOOL bLines(PDEV*, POINTFIX*, POINTFIX*, RUN* prun, ULONG,
            LINESTATE*, RECTL*, PFNSTRIP*, FLONG);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\linkedlist.c ===
//******************************Module*Header***********************************
// Module Name: linkedlist.c
//
// Manage a linked list containing any data
//
// Copyright (c) 2000, NVIDIA, Corporation.  All rights reserved.
//
// THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
// NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
// IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
//
// Usage:
// 
// 1. Define new class type in LL_CLASS_ID enum (or use LL_CLASS_ANY_CLASS).
// 2. Call bLinkedListCreate to initialize the linked list
// 3. Add items to linked list using bLinkedListAddElement
// 4. Work with the items
// 5. Remove items from linked list using bLinkedListRemoveElement
// 6. Destroy linked list with a bLinkedListDestroy call
//
// You need unique identifier (which of course can be a pointer) and optional
// data you want to store. The identifier is used to reference the data.
//
// Example:
//
// VOID vLinkedListTest(VOID)
// {
//     // NOTE: we don't need the definition of the structure for a pointer!
//     struct _LINKEDLISTHEAD *pHead;
// 
//     // create linked list head
//     pHead = NULL;
//     if (bLinkedListCreate(&pHead, LL_CLASS_MYCLASS))
//     {
//         ULONG ul;
//         PVOID pData=&ul;
// 
//         // Add elements to linked list
//         for (ul=0; ul<10; ul++)
//         {
//             if (!bLinkedListAddElement(pHead, LL_CLASS_MYCLASS, ul, pData, 0))
//                 errorhandling();
//         }
// 
//         // Work with data (e.g. get element with id 5)
//         if (bLinkedListGetElement(pHead,LL_CLASS_MYCLASS, 5, &pData))
//         {
//             ASSERT(NULL==pHead);
//             //work with pData
//         }
//         else 
//             errorhandling();
// 
//         // Remove elements from linked list
//         for (ul=0; ul<10; ul++)
//         {
//             if (!bLinkedListRemoveElement(pHead,LL_CLASS_MYCLASS,ul))
//                 errorhandling();
//         }
// 
//         // destroy linked list head linked list should be empty!
//         bLinkedListDestroy(&pHead);
//         ASSERT(NULL==pHead);
//     }
// }
//
//
//
//******************************************************************************

// import
#include "precomp.h"
#include "driver.h"

// export
#include "linkedlist.h"

//*************************************************************************
// LINKEDLIST
// 
// structure defines one double linked node containing data of type ClassID
// with unique identifier ulIdent.
//*************************************************************************
typedef struct _LINKEDLIST
{
    LL_CLASS_ID         ClassID;            // Type of data 
    ULONG_PTR           ulIdent;            // unique identifier for data (can be pointer)
    PVOID               pData;              // poiter to any kind of data
    struct _LINKEDLIST *pPrev;              // previous element in linked list or NULL if there is none
    struct _LINKEDLIST *pNext;              // next element in linked list or NULL if there is none
    ULONG               ulAllocatedSize;    // 0 if pData is allocated outside, != 0 if allocated in this module
    ULONG               ulReferenceCount;   // number of references to this node
} LINKEDLIST;


//*************************************************************************
// LINKEDLISTHEAD
// 
// head to double linked list of any data. If ClassID is set to 
// LL_CLASS_ANY_CLASS the linked list can store any class. If it is set to
// something else out of the enum LL_CLASS_ID it can only store this type.
//*************************************************************************
typedef struct _LINKEDLISTHEAD
{
    ULONG        ulMagic;         // must be set to LL_MAGIC to identify a valid head
    LL_CLASS_ID  ClassID;         // specifies type of data
    LINKEDLIST  *pFirst;          // points to first element in list
    LINKEDLIST  *pLast;           // points to last element in list
    LINKEDLIST  *pCurrent;        // used internaly to handle first/get
    ULONG        ulNumberOfNodes; // total number of nodes in linked list
} LINKEDLISTHEAD;

#define LL_MAGIC    'derf'        // magic value to check validity of linked list header


//******************************************************************************
//
// Internal functions
//

//*************************************************************************
// bLLValidList
// 
// returns TRUE if the linked list to which pAnchor is pointing is a valid 
// linked list. Returns FALSE if it is invalid or corrupted.
//
// NOTE: As we access the pointers, we will crash if they are invalid!
//*************************************************************************
BOOL bLLValidList(
    IN LINKEDLISTHEAD *pAnchor)
{
    LINKEDLIST *pNode         = NULL;
    LINKEDLIST *pNodeLast     = NULL;
    ULONG       ulCount       = 0;
    BOOL        bFoundCurrent = FALSE;
    BOOL        bRet          = FALSE;

    //
    // Check pAnchor and base members
    //

    if (NULL==pAnchor)
    {
        DISPDBG((0, "ERROR in linked list: pAnchor==NULL"));
        goto Exit;
    }

    if (LL_MAGIC != pAnchor->ulMagic)
    {
        DISPDBG((0, "ERROR in linked list: pAnchor invalid ulMagic"));
        goto Exit;
    }

    if (LL_CLASS_INVALID == pAnchor->ClassID)
    {
        DISPDBG((0, "ERROR in linked list: pAnchor invalid ClassID"));
        goto Exit;
    }


    //
    // Test simple conditions with pFirst and pLast depending on number of stored nodes
    //

    if (   (0 == pAnchor->ulNumberOfNodes)
        && ( (NULL != pAnchor->pFirst) || (NULL != pAnchor->pLast) || (NULL != pAnchor->pCurrent)  ) )
    {
        DISPDBG((0, "ERROR in linked list: 0 nodes but pointers!= NULL (pLast:0x%p, pFirst:0x%p, pCurrent:0x%p)", pAnchor->pFirst, pAnchor->pLast, pAnchor->pCurrent));
        goto Exit;
    }

    if (   (1 == pAnchor->ulNumberOfNodes)
        && (pAnchor->pFirst != pAnchor->pLast) )
    {
        DISPDBG((0, "ERROR in linked list: 1 node but first!=last (pLast:0x%p, pFirst:0x%p)", pAnchor->pFirst, pAnchor->pLast));
        goto Exit;
    }

    if (   (0 != pAnchor->ulNumberOfNodes)
        && (   (pAnchor->pFirst == NULL) 
            || (pAnchor->pLast  == NULL) 
           ) )
    {
        DISPDBG((0, "ERROR in linked list: %d nodes and first and last invalid (pLast:0x%p, pFirst:0x%p)", pAnchor->ulNumberOfNodes, pAnchor->pFirst, pAnchor->pLast));
        goto Exit;
    }

    if (   (pAnchor->ulNumberOfNodes > 1)
        && (pAnchor->pFirst == pAnchor->pLast) )
    {
        DISPDBG((0, "ERROR in linked list: %d nodes but first and last invalid (pLast:0x%p, pFirst:0x%p)", pAnchor->ulNumberOfNodes, pAnchor->pFirst, pAnchor->pLast));
        goto Exit;
    }

    if (   (NULL != pAnchor->pFirst)
        && (NULL != pAnchor->pFirst->pPrev) )
    {
        DISPDBG((0, "ERROR in linked list: first element not pointing to NULL"));
        goto Exit;
    }

    if (   (NULL != pAnchor->pLast)
        && (NULL != pAnchor->pLast->pNext) )
    {
        DISPDBG((0, "ERROR in linked list: last element not pointing to NULL"));
        goto Exit;
    }

    //
    // Walk through list and check linkage
    //

    if (NULL==pAnchor->pCurrent)
        bFoundCurrent = TRUE;
    else
        bFoundCurrent = FALSE;

    for (pNode = pAnchor->pFirst, ulCount = 0, pNodeLast = NULL; 
         (NULL != pNode) && (ulCount < pAnchor->ulNumberOfNodes+5); 
         pNodeLast = pNode, pNode = pNode->pNext)
    {
        if (pNode->pPrev != pNodeLast)
        {
            DISPDBG((0, "ERROR in linked list: wrong prev linkage node %d: 0x%p==pNode->pPrev != pNodeLast==0x%p", ulCount,pNode->pPrev,pNodeLast));
            goto Exit;
        }

        if (   (pAnchor->ClassID != LL_CLASS_ANY_CLASS)
            && (pAnchor->ClassID != pNode->ClassID) )
        {
            DISPDBG((0, "ERROR in linked list: node 0x%p has wrong ClassID: 0x%x (0x%x expected)", pNode, pNode->ClassID,pAnchor->ClassID));
            goto Exit;
        }

        if (   (pNode->ulAllocatedSize != 0)
            && (NULL==pNode->pData) )
        {
            DISPDBG((0, "ERROR in linked list: node 0x%p pData NULL although %d bytes allocated", pNode, pNode->ulAllocatedSize));
            goto Exit;
        }

        if (pAnchor->pCurrent==pNode)
            bFoundCurrent=TRUE;
        ulCount++;
    }

    if (NULL != pNode)
    {
        DISPDBG((0, "ERROR in linked list: didn't find end of list after %d nodes with expected pAnchor->ulNumberOfNodes=%d", ulCount,pAnchor->ulNumberOfNodes));
        goto Exit;
    }

    if (ulCount != pAnchor->ulNumberOfNodes)
    {
        DISPDBG((0, "ERROR in linked list: pAnchor->ulNumberOfNodes=%d not valid (found %d nodes)",pAnchor->ulNumberOfNodes, ulCount));
        goto Exit;
    }

    if (pNodeLast!=pAnchor->pLast)
    {
        DISPDBG((0, "ERROR in linked list: pAnchor->pLast==0x%p instead of 0x%p", pAnchor->pLast,pNodeLast));
        goto Exit;
    }

    if (!bFoundCurrent)
    {
        DISPDBG((0, "ERROR in linked list: pAnchor->pCurrent:0x%p not found",pAnchor->pCurrent));
        goto Exit;
    }

    // couldn't find an error
    bRet = TRUE;
Exit:
    return (bRet);
}


//*************************************************************************
// bLLFindNode
// 
// find node with class ClassID and identifier ulIdent and return node. 
// returns TRUE if node was found; *ppNode is valid; 
// returns FALSE if node wasn't found, *ppNode invalid (not touched)
//*************************************************************************
BOOL bLLFindNode(
    IN  LINKEDLISTHEAD *pAnchor, // root of linked list 
    IN  LL_CLASS_ID     ClassID, // class if data to look for
    IN  ULONG_PTR       ulIdent, // unique identifier of node to finde
    OUT LINKEDLIST    **ppNode)  // contains found node if return is TRUE
{
    LINKEDLIST *pNode   = NULL;
    BOOL        bRet    = FALSE;

    ASSERT(bLLValidList(pAnchor));
    ASSERT(LL_CLASS_INVALID != ClassID);

    if (   (NULL != pAnchor)
        && (   (pAnchor->ClassID == ClassID)                // either specified ClassID
            || (pAnchor->ClassID == LL_CLASS_ANY_CLASS) ) ) // or list can store any class
    {
        // run through linked list
        pNode = pAnchor->pFirst;
        while (pNode)
        {
            if (   (pNode->ulIdent == ulIdent)
                && (pNode->ClassID == ClassID) )
            {                
                // found node
                *ppNode = pNode;
                bRet    = TRUE;
                break;
            }
            pNode = pNode->pNext;
        }
    }

    return (bRet);
}


//******************************************************************************
//
// Exported functions
//

//*************************************************************************
// bLinkedListCreate
// 
// must be called to create and initialize a linked list. A linked list
// can either store any data types (classes) if LL_CLASS_ANY_CLASS is 
// given or only one type.
// returns TRUE if a linked list was created and *ppAnchor contains a 
// valid head.
// returns FALSE if it failed.
//*************************************************************************
BOOL bLinkedListCreate(
    OUT LINKEDLISTHEAD **ppAnchor, // root of linked list 
    IN  LL_CLASS_ID      ClassID)  // class of linked list to create (or 
{
    LINKEDLISTHEAD *pAnchor = NULL;
    BOOL            bRet    = FALSE;

    ASSERT(NULL != ppAnchor);
    ASSERT(NULL == *ppAnchor);
    ASSERT(LL_CLASS_INVALID!=ClassID);

    pAnchor = EngAllocMem(FL_ZERO_MEMORY, sizeof(LINKEDLISTHEAD), ALLOC_TAG);

    if (NULL != pAnchor)
    {
        // initialize head
        pAnchor->ulMagic = LL_MAGIC;
        pAnchor->ClassID = ClassID;

        *ppAnchor = pAnchor;
        ASSERT(bLLValidList(*ppAnchor));
        bRet = TRUE;
    }

    return bRet;
}


//*************************************************************************
// bLinkedListDestroy
// 
// free and destroy a linked list given by ppAnchor. 
// NOTE this function doesn't free nodes!
// returns TRUE if a linked list was destroyed and *ppAnchor is invalidated
// returns FALSE if it failed.
//*************************************************************************
BOOL bLinkedListDestroy(
    IN OUT LINKEDLISTHEAD **ppAnchor)
{
    LINKEDLISTHEAD *pAnchor = NULL;
    BOOL            bRet    = FALSE;

    ASSERT(bLLValidList(*ppAnchor));

    if (NULL != ppAnchor)
    {
        ASSERT(0 == (*ppAnchor)->ulNumberOfNodes);

        (*ppAnchor)->ulMagic = 0;

        EngFreeMem(*ppAnchor);
        *ppAnchor = NULL;
        bRet = TRUE;
    }

    return bRet;
}


//*************************************************************************
// bLinkedListAddElement
// 
// adds an element with the unique identifier ulIdent and the data pData 
// to the linked list. 
//
// NOTE: ulAllocSize is reserved for a future extension, where this would
//       specify additonal memory to allocate and internaly set pData.
//       Currently there is no mehtod to return the allocated pointer.
//
// Returns TRUE if succeeded, use ulIdent and ClassID to access later.
// Returns FALSE if failed.
//*************************************************************************
BOOL bLinkedListAddElement(
    IN LINKEDLISTHEAD *pAnchor,     // root of linked list 
    IN LL_CLASS_ID     ClassID,     // type of this date (must be valid for this linked list)
    IN ULONG_PTR       ulIdent,     // unique identifier of data (can be a pointer)
    IN PVOID           pData,       // pointer to data to store in the node, can be NULL!
    IN ULONG           ulAllocSize) // unused for now! must be 0!
{
    LINKEDLIST *pNode   = NULL;
    BOOL        bRet    = FALSE;

    ASSERT(bLLValidList(pAnchor));
    ASSERT(LL_CLASS_INVALID != ClassID);
    ASSERT(0==ulAllocSize);

    if (   (NULL != pAnchor)
        && (   (pAnchor->ClassID == ClassID)
            || (pAnchor->ClassID == LL_CLASS_ANY_CLASS) ) )
    {
        //
        // Create new node at top of linked list
        //

        pNode = EngAllocMem(FL_ZERO_MEMORY, sizeof(LINKEDLIST)+ulAllocSize, ALLOC_TAG);

        if (NULL != pNode)
        {
            // Add at top of linked list
            pNode->pNext   = pAnchor->pFirst;
            pNode->pPrev   = NULL;

            // let next element point back to us
            if (NULL != pNode->pNext)
                pNode->pNext->pPrev = pNode;

            // replace anchor entries.
            pAnchor->pFirst = pNode;

            if (NULL == pAnchor->pLast)
                pAnchor->pLast = pNode;

            pAnchor->ulNumberOfNodes++;

            // Insert Data to node

            pNode->ClassID = ClassID;
            pNode->ulIdent = ulIdent;
            if (ulAllocSize)
            {
                // cannot allocate if pData already is assigned
                ASSERT(NULL == pData);

                pNode->ulAllocatedSize = ulAllocSize;
                pNode->pData           = (PVOID)(pNode+1); // data starts behind node struct
            }
            else
            {
                // remember data
                pNode->pData   = pData;
            }
            pNode->ulReferenceCount = 0;
            bRet = TRUE;
        }
    }

    ASSERT(bLLValidList(pAnchor));
    ASSERT(bRet);

    return bRet;
}


//*************************************************************************
// bLinkedListRemoveElement
// 
// remove element with unique identifier ulIdent of type ClassID from 
// linked list.
//
// Returns TRUE if succeeded.
// Returns FALSE if failed.
//*************************************************************************
BOOL bLinkedListRemoveElement(
    IN LINKEDLISTHEAD *pAnchor,     // root of linked list 
    IN LL_CLASS_ID     ClassID,     // type of this date (must be valid for this linked list)
    IN ULONG_PTR       ulIdent)     // unique identifier of data (can be a pointer)
{
    LINKEDLIST *pNode   = NULL;
    BOOL        bRet    = FALSE;

    ASSERT(bLLValidList(pAnchor));
    ASSERT(LL_CLASS_INVALID!=ClassID);
    
    if (bLLFindNode(pAnchor, ClassID, ulIdent, &pNode))
    {
        ASSERT(NULL!=pNode);

        // Unlink from linked list
        if (NULL != pNode->pNext)
            pNode->pNext->pPrev = pNode->pPrev;

        if (NULL != pNode->pPrev)
            pNode->pPrev->pNext = pNode->pNext;

        // Unlink from anchor
        if (pAnchor->pFirst == pNode)
        {
            ASSERT(NULL==pNode->pPrev);
            pAnchor->pFirst = pNode->pNext;
        }

        if (pAnchor->pLast == pNode)
        {
            ASSERT(NULL==pNode->pNext);
            pAnchor->pLast = pNode->pPrev;
        }

        if (pAnchor->pCurrent == pNode)
        {
            pAnchor->pCurrent = pNode->pPrev;
        }

        //
        // Nothing should point to pNode anymore
        // 

        EngFreeMem(pNode);

        ASSERT(pAnchor->ulNumberOfNodes!=0);
        pAnchor->ulNumberOfNodes--;

        bRet = TRUE;
    }

    ASSERT(bLLValidList(pAnchor));
    ASSERT(bRet);

    return bRet;
}


//*************************************************************************
// bLinkedListGetElement
// 
// find and return data element of node with unique identifier ulIdent of 
// type ClassID. 
//
// Returns TRUE if element was found (and returns data if ppData != NULL). 
// Returns FALSE if element wasn't found. ppData isn't touched.
//*************************************************************************
BOOL bLinkedListGetElement(
    IN  LINKEDLISTHEAD *pAnchor,     // root of linked list 
    IN  LL_CLASS_ID     ClassID,     // type of this date (must be valid for this linked list)
    IN  ULONG_PTR       ulIdent,     // unique identifier of data (can be a pointer)
    OUT PVOID          *ppData)      // pointer to data returned if bRet==TRUE, ppData can be NULL
{
    LINKEDLIST *pNode   = NULL;
    BOOL        bRet    = FALSE;

    ASSERT(bLLValidList(pAnchor));
    ASSERT(LL_CLASS_INVALID!=ClassID);
    
    if (bLLFindNode(pAnchor, ClassID, ulIdent, &pNode))
    {
        // node found
        if (NULL != ppData)
        {
            // if data returned increase reference counter
            pNode->ulReferenceCount++;
            *ppData = pNode->pData;
        }
        bRet = TRUE;
    }

    return bRet;
}

//*************************************************************************
// bLinkedListGetFirstElement
// bLinkedListGetNextElement
// 
// used to enumerate a linked list from top to bottom. It returns the 
// unique identifier and data of first element with type ClassID 
// within linked list. This is the initializer for a get first/next
// enumeration loop
//
// NOTE: a single or both out params can be NULL if the data isn't needed.
// NOTE 2: Use bLinkedListGetNextElement to enumerate the list after it has
//         been resetted with this bLinkedListGetFirstElement.
//
// Returns TRUE and OUT data if succeed. 
// Returns FALSE if failed or list empty, OUT data not touched
//*************************************************************************
BOOL bLinkedListGetFirstElement(
    IN  LINKEDLISTHEAD *pAnchor,     // root of linked list 
    IN  LL_CLASS_ID     ClassID,     // type of this date (must be valid for this linked list)
    OUT ULONG_PTR      *pulIdent,    // contains unique identifier of data if pulIdent != NULL
    OUT PVOID          *ppData)      // contains pointer to data if ppData != NULL
{
    LINKEDLIST *pNode   = NULL;
    BOOL        bRet    = FALSE;

    ASSERT(bLLValidList(pAnchor));
    ASSERT(LL_CLASS_INVALID!=ClassID);

    // Initialize pCurrent with top of linked list
    pAnchor->pCurrent = pAnchor->pFirst;

    bRet = bLinkedListGetNextElement(pAnchor,ClassID, pulIdent, ppData); 

    return bRet;
}

// see above
BOOL bLinkedListGetNextElement(
    IN  LINKEDLISTHEAD *pAnchor,     // root of linked list 
    IN  LL_CLASS_ID     ClassID,     // type of this date (must be valid for this linked list)
    OUT ULONG_PTR      *pulIdent,    // contains unique identifier of data if pulIdent != NULL
    OUT PVOID          *ppData)      // contains pointer to data if ppData != NULL
{
    LINKEDLIST *pNode   = NULL;
    BOOL        bRet    = FALSE;

    ASSERT(bLLValidList(pAnchor));
    ASSERT(LL_CLASS_INVALID!=ClassID);
    
    // start at last positon
    pNode = pAnchor->pCurrent;

    // find next element matching the type
    while (   (NULL != pNode)
           && (ClassID != pNode->ClassID)
           && (ClassID != LL_CLASS_ANY_CLASS) )
    {
        pNode = pNode->pNext;
    }

    if (NULL != pNode)
    {
        // found node
        if (pulIdent)
            *pulIdent = pNode->ulIdent;
        if (ppData)
            *ppData = pNode->pData;

        // if data returned increase reference counter
        if (pulIdent || ppData)
            pNode->ulReferenceCount++;

        // initialize current with next element (as this one already is returned)
        pAnchor->pCurrent = pNode->pNext;
        bRet = TRUE;
    }
    else
    {
        // cannot continue
        pAnchor->pCurrent = NULL;
    }

    return bRet;
}


//*************************************************************************
// bLinkedListGetLastElement
// bLinkedListGetPrevElement
// 
// same as bLinkedListGetFirstElement and bLinkedListGetNextElement runing
// from bottom to top.
//
// Returns TRUE and OUT data if succeed. 
// Returns FALSE if failed or list empty, OUT data not touched
//*************************************************************************
BOOL bLinkedListGetLastElement(
    IN  LINKEDLISTHEAD *pAnchor,     // root of linked list 
    IN  LL_CLASS_ID     ClassID,     // type of this date (must be valid for this linked list)
    OUT ULONG_PTR      *pulIdent,    // contains unique identifier of data if pulIdent != NULL
    OUT PVOID          *ppData)      // contains pointer to data if ppData != NULL
{
    LINKEDLIST *pNode   = NULL;
    BOOL        bRet    = FALSE;

    ASSERT(bLLValidList(pAnchor));
    ASSERT(LL_CLASS_INVALID!=ClassID);

    // Initialize pCurrent with top of linked list
    pAnchor->pCurrent = pAnchor->pLast;

    bRet = bLinkedListGetPrevElement(pAnchor,ClassID, pulIdent, ppData); 

    return bRet;
}

// see above
BOOL bLinkedListGetPrevElement(
    IN  LINKEDLISTHEAD *pAnchor,     // root of linked list 
    IN  LL_CLASS_ID     ClassID,     // type of this date (must be valid for this linked list)
    OUT ULONG_PTR      *pulIdent,    // contains unique identifier of data if pulIdent != NULL
    OUT PVOID          *ppData)      // contains pointer to data if ppData != NULL
{
    LINKEDLIST *pNode   = NULL;
    BOOL        bRet    = FALSE;

    ASSERT(bLLValidList(pAnchor));
    ASSERT(LL_CLASS_INVALID!=ClassID);

    // start at bottom of linked list
    pNode = pAnchor->pCurrent;

    // find previous element matching the type
    while (   (NULL != pNode)
           && (   (ClassID != pNode->ClassID)
               && (ClassID != LL_CLASS_ANY_CLASS) ) )
    {
        pNode = pNode->pPrev;
    }

    if (NULL != pNode)
    {
        // found node
        if (pulIdent)
            *pulIdent = pNode->ulIdent;
        if (ppData)
            *ppData = pNode->pData;

        // if data returned increase reference counter
        if (pulIdent || ppData)
            pNode->ulReferenceCount++;
        pAnchor->pCurrent = pNode->pPrev;
        bRet = TRUE;
    }
    else
    {
        pAnchor->pCurrent = NULL;
    }

    return bRet;
}


//*************************************************************************
// bLinkedListGetNewestElement
// 
// returns the data of the newset element in the linked list of given type.
//
// Returns TRUE and OUT data if succeed. 
// Returns FALSE if failed or list empty, OUT data not touched
//*************************************************************************
BOOL bLinkedListGetNewestElement(
    IN  LINKEDLISTHEAD *pAnchor,     // root of linked list 
    IN  LL_CLASS_ID     ClassID,     // type of this date (must be valid for this linked list)
    OUT ULONG_PTR      *pulIdent,    // contains unique identifier of data if pulIdent != NULL
    OUT PVOID          *ppData)      // contains pointer to data if ppData != NULL
{
    ASSERT(bLLValidList(pAnchor));
    return(bLinkedListGetFirstElement(pAnchor, ClassID, pulIdent, ppData)); 
}


//*************************************************************************
// bLinkedListGetOldestElement
// 
// returns the data of the oldest element in the linked list of given type.
//
// Returns TRUE and OUT data if succeed. 
// Returns FALSE if failed or list empty, OUT data not touched
//*************************************************************************
BOOL bLinkedListGetOldestElement(
    IN  LINKEDLISTHEAD *pAnchor,     // root of linked list 
    IN  LL_CLASS_ID     ClassID,     // type of this date (must be valid for this linked list)
    OUT ULONG_PTR      *pulIdent,    // contains unique identifier of data if pulIdent != NULL
    OUT PVOID          *ppData)      // contains pointer to data if ppData != NULL
{
    ASSERT(bLLValidList(pAnchor));
    return(bLinkedListGetLastElement(pAnchor, ClassID, pulIdent, ppData)); 
}


//*************************************************************************
// ulLinkedListGetCountOfElements
// 
// returns number of node stored in linked list that have type ClassID.
//*************************************************************************
ULONG ulLinkedListGetCountOfElements(
    LINKEDLISTHEAD *pAnchor,  // root of linked list 
    LL_CLASS_ID     ClassID)  // type of this date (must be valid for this linked list)
{
    BOOL  bFound;
    ULONG ulRet  = 0;

    ASSERT(bLLValidList(pAnchor));
    ASSERT(LL_CLASS_INVALID!=ClassID);

    if (   (ClassID == pAnchor->ClassID)
        && (ClassID != LL_CLASS_ANY_CLASS) )
    {
        // Only one class is stored, return all linked nodes
        ulRet = pAnchor->ulNumberOfNodes;
    }
    else if (ClassID == LL_CLASS_ANY_CLASS)
    {
        // type doesn't matter, return all nodes
        ulRet = pAnchor->ulNumberOfNodes;
    }
    else
    {
        // Only count members of class ClassID
        // need to enumerate and find nodes.
        if (bLinkedListGetFirstElement(pAnchor, ClassID, NULL, NULL))
        {
            ulRet++;

            while (bLinkedListGetNextElement(pAnchor, ClassID, NULL, NULL))
            {
                ulRet++;
            }
        }
    }

    ASSERT(ulRet <= pAnchor->ulNumberOfNodes);
    
    return ulRet;
}

// End of linkedlist.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\heap.c ===
//******************************Module*Header***********************************
//
// Module Name: heap.c
//
// Contains offscreen heap manager and create/delete device bitmap functions.
//
// Copyright (c) 1993-1996 Microsoft Corporation
//
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"
#include "driver.h"

#ifdef NVD3D
    #include "dx95type.h"
    #include "nvntd3d.h"
//    #include "nvProcMan.h"
    #include "ddmini.h"
#endif

// Define USE_RM_MMGR RM to use RM heap manager only
//#define USE_RM_MMGR     1

#ifndef USE_RM_MMGR // [
#define MIN_HEAP_SIZE       ( 128 * 1024)
#define FIRST_HEAP_SIZE_16  ( 512 * 1024)
#define FIRST_HEAP_SIZE_32  (1024 * 1024)

void FreeHeap(PDEV* ppdev, HEAP* pHeap);
HEAP* GetHeap(PDEV* ppdev, ULONG ulMinAlloc);

OH* heap_alloc(ULONG blksToAlloc, HEAP* pHeap);
BOOL heap_free(OH* pBlk);
BOOL heap_init(ULONG memBegin, ULONG memSize, HEAP* pHeap);
void heap_clear(HEAP* pHeap);
#endif // !USE_RM_MMGR ]

#ifdef FONT_CACHE // [
// Font cache definitions
//
// NOTE: If values are changed, must update NV4TEXT.ASM
//
#define MAX_FONTS       16
#define MAX_GLYPHS      256
#define GLYPH_PITCH     128
#define FONT_CACHE_SIZE MAX_FONTS*MAX_GLYPHS*GLYPH_PITCH
//
// End of font cache definitions
#endif // FONT_CACHE ]

// macro to clear the given poh with color
// FN: Disabled until someone needs it
#if 0//DBG
#define DBG_CLEARPOH(ppdev, poh, color)                                                                   \
{                                                                                                         \
    RECTL rclTrg = {0};                                                                                   \
    RBRUSH_COLOR rbc = {0};                                                                               \
    ppdev->pfnSetDestBase(ppdev, (ULONG)((BYTE *)(poh->LinearPtr) - ppdev->pjScreen), poh->LinearStride); \
    rbc.iSolidColor = color;                                                                              \
    rclTrg.right    = poh->cx;                                                                            \
    rclTrg.bottom   = poh->cy;                                                                            \
    ppdev->pfnFillSolid(ppdev, 1, &rclTrg, 0xF0F0, rbc, NULL);                                            \
}
#else
#define DBG_CLEARPOH(ppdev, poh, color)
#endif


//******************************Public*Routine**********************************
//
// Function: pohFree()
//
//      Frees an off-screen heap allocation.  The free space will be combined
//      with any adjacent free spaces to avoid segmentation of the heap.
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//     poh   - Pointer to the offscreen memory allocation to free
//
// Return Value:
//
//     None.
//
//******************************************************************************

void pohFree
(
    PDEV*   ppdev,
    OH*     poh
)
{
    if (poh == NULL)
        return;

#ifdef USE_RM_MMGR // [

    //**********************************************************************
    // We now support linear memory management
    //**********************************************************************

    //                       green
    DBG_CLEARPOH(ppdev, poh, 0xff00);
    NVHEAP_FREE(poh->ulOffset);

    //**********************************************************************
    // Remove this node from the allocation list.
    //**********************************************************************

    poh->next->prev = poh->prev;
    poh->prev->next = poh->next;

    //**************************************************************************
    // Free the struct space
    //**************************************************************************

    EngFreeMem(poh);

#else // USE_RM_MMGR ][
    {
        // poh is freed by heap_free so we need to get the heap pointer
        // before calling heap_free
        HEAP* pHeap = poh->pHeap;

        /*
        ** If there is alloc/free hysteresis here, then we have to return heap
        ** space in the following functions:
        **     bAssertModeOffscreenHeap()
        **     bMoveAllOffscreenDfbsToDibs()
        **     vDisableOffscreenHeap()
        */
        if (heap_free(poh) == 1)    // retval 1 means heap is empty
        {
            FreeHeap(ppdev, pHeap);
        }
    }
#endif // USE_RM_MMGR ]

    //**********************************************************************
    // Update the uniqueness to show that space has been freed, so that
    // we may decide to see if some DIBs can be moved back into off-screen
    // memory:
    //**********************************************************************

    ppdev->iHeapUniq++;
}


//******************************Public*Routine**********************************
//
// Function:   OH* pohAllocate
//
// Routine Description:
//
//      Allocates a piece in off-screen memory.
//
// Arguments:
//
//
// Return Value:
//
//        Ptr to OH structure representing offscreen memory
//
//******************************************************************************

OH* pohAllocate
(
    PDEV*   ppdev,
    LONG    cxThis,         // Width of rectangle to be allocated
    LONG    cyThis          // Height of rectangle to be allocated
)
{
    OH*     pohThis;    // Points to found available rectangle we'll use
    OH*     pohRoot;

    ULONG   LinearStride;
    ULONG   ulSizeInBytes;
    ULONG   ulAllocated;
    NvU32   dwStatus;

    //**************************************************************************
    // Align to appropriate boundary.
    //**************************************************************************

    LinearStride  = cxThis * ppdev->cjPelSize;
    LinearStride += ppdev->ulSurfaceAlign;
    LinearStride &= ~ppdev->ulSurfaceAlign;
    ulSizeInBytes = LinearStride * cyThis;

    //**************************************************************************
    // Request offscreen memory from linear memory manager
    //**************************************************************************

#ifdef USE_RM_MMGR // [

    NVHEAP_ALLOC(dwStatus, ulAllocated, ulSizeInBytes, TYPE_IMAGE);

    if (dwStatus != 0)
        return NULL;

    if ((pohThis = EngAllocMem(0, sizeof(OH), ALLOC_TAG)) == NULL)
    {
        NVHEAP_FREE(ulAllocated);
        return NULL;
    }

    //**************************************************************************
    // Fill in the OH structure for this allocation.
    //**************************************************************************

    pohThis->pdsurf         = NULL; // The caller owns and sets this field:
//  pohThis->next           = filled in below
//  pohThis->prev           = filled in below
    pohThis->nextEmpty      = NULL; // not used if RM doing all alloc/free
    pohThis->pHeap          = &ppdev->heap; // not used if RM doing all alloc/free
    pohThis->ulSizeInBytes  = ulSizeInBytes;
    pohThis->ulOffset       = ulAllocated;
    pohThis->ulLinearStride = LinearStride;

    //**************************************************************************
    // Now insert this new node at the head of the OH list:
    //**************************************************************************

    pohRoot = &ppdev->heap.oh;

    pohThis->next = pohRoot->next;
    pohThis->prev = pohRoot;

    pohRoot->next->prev = pohThis;
    pohRoot->next = pohThis;

#else // USE_RM_MMGR ][

    {
        HEAP* pHeap = &ppdev->heap;

        /*
        ** Try to allocate space from one of the heaps.
        */
        do
        {
            pohThis = heap_alloc(ulSizeInBytes, pHeap);
        }
        while ((pohThis == NULL) && ((pHeap = pHeap->pNextHeap) != NULL));

        /*
        ** If we couldn't allocate space allocate another heap and try again.
        */
        if (pohThis == NULL)
        {
            if ((pHeap = GetHeap(ppdev, ulSizeInBytes)) == NULL)
                return NULL;

            /*
            ** This should always succeed if the GetHeap above worked.
            */
            pohThis = heap_alloc(ulSizeInBytes, pHeap);

            /*
            ** This check should not be necessary but is here to be safe in
            ** case GetHeap() is changed to not allocate at least the min
            ** heap space requested in the above GetHeap call.
            */
            if (pohThis == NULL)
            {
                FreeHeap(ppdev, pHeap);
                return NULL;
            }
        }

        /*
        ** The linear memory manager does not have LinearStride so fill it in.
        */
        pohThis->ulLinearStride = LinearStride;


        //                           yellow
        DBG_CLEARPOH(ppdev, pohThis, 0xffff00);

    }
#endif // USE_RM_MMGR ]

    DISPDBG((7, "   Allocated (%li x %li) at offset %li",
                cxThis, cyThis, pohThis->ulOffset));

    return pohThis;
}


//******************************Public*Routine**********************************
//
// Function: BOOL bMoveDibToOffscreenDfbIfRoom
//
// Routine Description:
//
//      Converts the DIB DFB to an off-screen DFB, if there's room for it in
//      off-screen memory.
//
// Arguments:
//
//      ppdev - Pointer to the physical device structure
//
// Return Value:
//
//      FALSE if there wasn't room, TRUE if successfully moved.
//
//******************************************************************************


BOOL bMoveDibToOffscreenDfbIfRoom(
PDEV*   ppdev,
DSURF*  pdsurf)

    {
    OH*         poh;
    SURFOBJ*    pso;
    RECTL       rclDst;
    HSURF       hsurf;

    ASSERTDD(pdsurf->dt == DT_DIB,
             "Can't move a bitmap off-screen when it's already off-screen");

    //**************************************************************************
    // If we're in full-screen mode, or ddraw is currently loaded,
    // we can't move anything to off-screen memory:
    //**************************************************************************

    if (!ppdev->bEnabled || (ppdev->flStatus & STAT_DIRECTDRAW_ENABLED))
        return(FALSE);

    //**************************************************************************
    // Allocate an offscreen region
    //**************************************************************************

    poh = pohAllocate(ppdev, pdsurf->sizl.cx, pdsurf->sizl.cy);
    if (poh == NULL)
        {
        //**********************************************************************
        // There wasn't any free room.
        //**********************************************************************

        return(FALSE);
        }

    //**************************************************************************
    // 'pdsurf->sizl' is the actual bitmap dimension, not 'poh->cx' or
    // 'poh->cy'.
    //**************************************************************************

    rclDst.left   = 0;
    rclDst.top    = 0;
    rclDst.right  = pdsurf->sizl.cx;
    rclDst.bottom = pdsurf->sizl.cy;

    pdsurf->LinearPtr    = ppdev->pjFrameBufbase + poh->ulOffset;
    pdsurf->LinearStride = poh->ulLinearStride;

    vPutBits(ppdev,pdsurf, pdsurf->pso, &rclDst);

    //**************************************************************************
    // Update the data structures to reflect the new off-screen node:
    //**************************************************************************

    pso           = pdsurf->pso;
    pdsurf->dt    = DT_SCREEN;
    pdsurf->poh   = poh;
    poh->pdsurf   = pdsurf;

    //**************************************************************************
    // Now free the DIB.  Get the hsurf from the SURFOBJ before we unlock
    // it (it's not legal to dereference psoDib when it's unlocked):
    //**************************************************************************

    hsurf = pso->hsurf;
    EngUnlockSurface(pso);
    EngDeleteSurface(hsurf);

    return(TRUE);
    }

//******************************Public*Routine**********************************
//
// Function: BOOL pohMoveOffscreenDfbToDib
//
// Routine Description:
//
//       Converts the DFB from being off-screen to being a DIB.
//
//       Note: The caller does NOT have to call 'pohFree' on 'poh' after making
//             this call.
//
// Arguments:
//
//       ppdev - Pointer to the physical device structure
//
// Return Value:
//
//       NULL if the function failed (due to a memory allocation).
//       Otherwise, it returns a pointer to the coalesced off-screen heap
//       node that has been made available for subsequent allocations
//       (useful when trying to free enough memory to make a new
//       allocation).
//
//******************************************************************************

BOOL pohMoveOffscreenDfbToDib
(
    PDEV*       ppdev,
    OH*         poh
)
{
    DSURF*      pdsurf;
    HBITMAP     hbmDib;
    SURFOBJ*    pso;
    RECTL       rclDst;

    if ((pdsurf = poh->pdsurf) == NULL)
        return TRUE;

    DISPDBG((2, "Throwing out %li x %li at offset %li!",
                 pdsurf->sizl.cx, pdsurf->sizl.cy, poh->ulOffset));

    ASSERTDD(pdsurf->dt != DT_DIB,
            "Can't make a DIB into even more of a DIB");

    //**************************************************************************
    // Create the Bitmap for NT GDI to use
    //**************************************************************************

    hbmDib = EngCreateBitmap(pdsurf->sizl, 0, ppdev->iBitmapFormat, BMF_TOPDOWN, NULL);

    if (hbmDib)
        {

        //**********************************************************************
        // Specify flhooks = 0
        //**********************************************************************

        if (EngAssociateSurface((HSURF) hbmDib, ppdev->hdevEng, 0))
            {
            pso = EngLockSurface((HSURF) hbmDib);
            if (pso != NULL)
                {
                rclDst.left   = 0;
                rclDst.top    = 0;
                rclDst.right  = pdsurf->sizl.cx;
                rclDst.bottom = pdsurf->sizl.cy;

                vGetBits(ppdev, pdsurf, pso, &rclDst);

                //**************************************************************
                // sizel field  is already set. Does not need to be modified.
                // Does ppdev field need to be set to NULL here ???
                // No, not really. This is still a DFB and as such is associated
                // with our Device.  A DFB implies that the surface is in a
                // DEVICE format. But for NV, we're just using the standard DIB
                // format.  Essentially, we can just leave the ppdev field alone.
                // Besides, this DFB may get put back in offscreen memory and
                // at that point we may need the ppdev again.
                //**************************************************************

                pdsurf->dt    = DT_DIB;
                pdsurf->pso   = pso;

                //**************************************************************
                // Don't even bother checking to see if this DIB should
                // be put back into off-screen memory until the next
                // heap 'free' occurs:
                //**************************************************************

                pdsurf->iUniq = ppdev->iHeapUniq;
                pdsurf->cBlt  = 0;

                //**************************************************************
                // Remove this node from the off-screen DFB list, and free
                // it.  'pohFree' will never return NULL:
                //**************************************************************

                pohFree(ppdev, poh);
                return TRUE;
                }
            else
                {
                DISPDBG((0,"ERROR in pohMoveOffscreenDfbToDib: EngLockSurface failed on poh:0x%p with 0x%p!",poh,hbmDib));
                }
            }
        else
            {
            DISPDBG((0,"ERROR in pohMoveOffscreenDfbToDib: EngAssociateSurface failed on poh:0x%p with 0x%p!",poh,hbmDib));
            }

        //**********************************************************************
        // Fail case:
        //**********************************************************************

        EngDeleteSurface((HSURF) hbmDib);
        }
    else
        {
        DISPDBG((0,"ERROR in pohMoveOffscreenDfbToDib: EngCreateBitmap failed on poh:0x%p (%d x %d)!",poh,pdsurf->sizl.cx,pdsurf->sizl.cy));
        }
    return FALSE;
}


//******************************Public*Routine**********************************
//
// Function: bMoveAllDfbsFromOffscreenToDibs
//
// Routine Description:
//
//      This function is used when we're about to enter full-screen mode, which
//      would wipe all our off-screen bitmaps.  GDI can ask us to draw on
//      device bitmaps even when we're in full-screen mode, and we do NOT have
//      the option of stalling the call until we switch out of full-screen.
//      We have no choice but to move all the off-screen DFBs to DIBs.
//
// Arguments:
//
//      ppdev - Pointer to the physical device structure
//
// Return Value:
//
//      Returns TRUE if all DSURFs have been successfully moved.
//
//******************************************************************************

BOOL __fastcall bMoveAllDfbsFromOffscreenToDibs(PDEV* ppdev)
{
    DSURF*  pdsurf;
    BOOL    bRet = TRUE;    // Assume success

    pdsurf = ppdev->pdsurf;

    while (pdsurf)
    {
        if (pdsurf->dt == DT_SCREEN)
        {
            //JOEHACK - why would we keep trying if this fails???
            if (!pohMoveOffscreenDfbToDib(ppdev, pdsurf->poh))
                bRet = FALSE;
        }

        pdsurf = pdsurf->next;
    }

#if defined(USE_RM_MMGR) && defined(OLD_WAY) // [
    {
        OH*     poh;
        OH*     pohNext;

        //**************************************************************************
        // Make sure that heap was already initialized in EnableOffscreenHeap.
        //**************************************************************************

        poh = ppdev->heap.oh.next;

        if (poh == NULL)
            return TRUE;

        while (poh != &ppdev->heap.oh)
        {
            pohNext = poh->next;

            //JOEHACK - why would we keep trying if this fails???
            if (!pohMoveOffscreenDfbToDib(ppdev, poh))
                bRet = FALSE;

            poh = pohNext;
        }
    }
#endif // defined(USE_RM_MMGR) && defined(OLD_WAY) ]

    return bRet;
}


//******************************Public*Routine**********************************
//
// Function:    DrvCreateDeviceBitmap
//
// Routine Description:
//
//   Function called by GDI to create a device-format-bitmap (DFB).  We will
//   always try to allocate the bitmap in off-screen; if we can't, we simply
//   fail the call and GDI will create and manage the bitmap itself.
//
//   Note: We do not have to zero the bitmap bits.  GDI will automatically
//         call us via DrvBitBlt to zero the bits (which is a security
//         consideration).
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

HBITMAP DrvCreateDeviceBitmap(
DHPDEV  dhpdev,
SIZEL   sizl,
ULONG   iFormat)

    {
    PDEV*   ppdev;
    OH*     poh;
    DSURF*  pdsurf;
    HBITMAP hbmDevice;

    ppdev = (PDEV*) dhpdev;

    //**************************************************************************
    // If we're in full-screen mode, we hardly have any off-screen memory
    // in which to allocate a DFB.  LATER: We could still allocate an
    // OH node and put the bitmap on the DIB DFB list for later promotion.
    //**************************************************************************

    if (!ppdev->bEnabled)
        return(0);

    //**************************************************************************
    // We only support device bitmaps that are the same colour depth
    // as our display.
    //
    // Actually, those are the only kind GDI will ever call us with,
    // but we may as well check.  Note that this implies you'll never
    // get a crack at 1bpp bitmaps.
    //**************************************************************************

    if (iFormat != ppdev->iBitmapFormat)
        return(0);

    //**************************************************************************
    // Do NOT support device bitmaps when OpenGL or ddraw is enabled !
    // OpenGL MCD and ddraw currently expect to manage all of offscreen memory.
    //**************************************************************************

    //**************************************************************************
    // We don't want anything 8x8 or smaller -- they're typically brush
    // patterns which we don't particularly want to stash in off-screen
    // memory:
    //
    // (Some of the screen savers like 'Dangerous Creatures' have very wide
    // offscreen bmaps).  CorelDream3D and RayDream use very TALL bitmaps (0x20 x 0x4400).
    // So we also need to limit the height of the offscreen bitmaps too.
    //**************************************************************************

    if ( ((sizl.cx <= 8) && (sizl.cy <= 8)) ||
         ((sizl.cx == 0x30) && (sizl.cy == 0x0E)) || // gains ~2% on 32bpp WB99BG
          (sizl.cx > ppdev->cxScreen * 2) ||
          (sizl.cy > ppdev->cyScreen * 2) ||
          (sizl.cx > ppdev->cxSurfaceMax) || // don't exceed h/w limits
          (sizl.cy > MAX_CY_MEMORY_VALUE)    // don't exceed h/w limits
       )
    {
        return 0;
    }


//******************************************************************************
//
//  Remove this code since it hurts OGL performance when running with GDI.
//
//    if (OglIsEnabled(ppdev))
//        return(0);
//
//******************************************************************************

    //**************************************************************************
    // When OpenGL is rendering in FULL screen mode,
    // don't create any offscreen bitmap so that display driver will not perform
    // any render in GDI channel in order to avoid the channel switch from OpenGL.
    //**************************************************************************
    if(globalOpenGLData.oglDrawableClientCount)
        if(ppdev->ulOpenGLinFullScreen)
            return(0);

#if defined(NVD3D)
    if (ppdev->pDriverData && ppdev->pDriverData->DDrawVideoSurfaceCount)
#else
    if (ppdev->DDrawVideoSurfaceCount)
#endif // !NVD3D
        {
        return(0);
        }

    poh = pohAllocate(ppdev, sizl.cx, sizl.cy);

    if (poh != NULL)
        {
        pdsurf = EngAllocMem(FL_ZERO_MEMORY, sizeof(DSURF), ALLOC_TAG);
        if (pdsurf != NULL)
            {
            hbmDevice = EngCreateDeviceBitmap((DHSURF) pdsurf, sizl, iFormat);
            if (hbmDevice != NULL)
                {

                if (EngAssociateSurface((HSURF) hbmDevice, ppdev->hdevEng,
                                        ppdev->flHooksDeviceBitmap))
                    {
                    pdsurf->dt           = DT_SCREEN;
                    pdsurf->sizl         = sizl;
                    pdsurf->ppdev        = ppdev;
                    poh->pdsurf          = pdsurf;
                    pdsurf->poh          = poh;
                    pdsurf->LinearPtr    = ppdev->pjFrameBufbase + poh->ulOffset;
                    pdsurf->LinearStride = poh->ulLinearStride;

                    /*
                    ** Add this pdsurf to the head of our pdsurf list.
                    */
                    pdsurf->prev = NULL;
                    pdsurf->next = ppdev->pdsurf;
                    if (ppdev->pdsurf)
                        ppdev->pdsurf->prev = pdsurf;
                    ppdev->pdsurf = pdsurf;

                    return(hbmDevice);
                    }
                else
                    {
                    DISPDBG((0, "ERROR in DrvCreateDeviceBitmap: EngAssociateSurface on hbmDevice:0x%p", hbmDevice));
                    }

                EngDeleteSurface((HSURF) hbmDevice);
                }
            else
                {
                DISPDBG((0, "ERROR in DrvCreateDeviceBitmap: EngCreateDeviceBitmap failed on pdsurf:0x%p", pdsurf));
                }
            EngFreeMem(pdsurf);
            }
        else
            {
            DISPDBG((0, "ERROR in DrvCreateDeviceBitmap: EngAllocMem failed to alloc %d bytes", sizeof(DSURF)));
            }

        pohFree(ppdev, poh);
        }

    return(0);
    }

//******************************Public*Routine**********************************
//
// Function: DrvDeleteDeviceBitmap
//
// Routine Description:
//
//      Deletes a DFB.
//
//      Since we implement DrvDeriveSurface on W2k, there are two cases to
//      handle here.  One case is the classic case where this DFB to delete
//      was created by an eariler successful call to DrvCreateDeviceBitmap.
//      The other case is where this DFB to delete was created by an eariler
//      successful call to DrvDeriveSurface.  In the latter case, there will
//      never be a non-NULL poh because the offscreen memory had already been
//      allocated by DirectDraw when DrvDeriveSurface was called.
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID DrvDeleteDeviceBitmap
(
    DHSURF      dhsurf
)
{
    DSURF*      pdsurf;
    PDEV*       ppdev;
    SURFOBJ*    psoDib;
    HSURF       hsurfDib;

    pdsurf = (DSURF *)dhsurf;
    ppdev  = pdsurf->ppdev;

    if (pdsurf->dt == DT_SCREEN)
    {
        // If this DFB was created by DrvDeriveSurface, poh will be NULL.
        if (pdsurf->poh)
            pohFree(ppdev, pdsurf->poh);

        // Comment from DDK500\src\video\displays\3dlabs\driver\heap.c:
        // Note: we don't need to call EngDeleteSurface(psurf->hsurf) to delete
        // the HBITMAP we created in DrvCreateDeviceBitmap() or DrvDeriveSurface()
        // because GDI will take care of this when it call DrvDeleteDeviceBitmap
        //

    }
    else
    {
        ASSERTDD(pdsurf->dt == DT_DIB, "Expected DIB type");

        //**********************************************************************
        // Get the hsurf from the SURFOBJ before we unlock it (it's not
        // legal to dereference psoDib when it's unlocked):
        //**********************************************************************

        psoDib = pdsurf->pso;
        hsurfDib = psoDib->hsurf;
        EngUnlockSurface(psoDib);
        EngDeleteSurface(hsurfDib);
    }

    /*
    ** Remove this dsurf from our ppdev->pdsurf list.  DrvDeriveSurface dsurfs
    ** will never be in the ppdev->pdsurf list but DrvDeriveSurface dsurfs
    ** always have (NULL==next==prev) so these DrvDeriveSurface dsurfs don't
    ** cause anything to happen below.
    **
    ** Note that (NULL==next==prev) cannot be used to detect a DrvDeriveSurface
    ** created dsurf because this will also be true for a DrvCreateDeviceBitmap
    ** dsurf when there is only one in a PDEV.
    **
    ** Also note that since DrvDeriveSurface dsurfs always have a NULL prev
    ** pointer we must check that the dsurf being deleted is indeed the head
    ** of the ppdev->pdsurf before unlinking the old head.
    */
    if (pdsurf->next)
        pdsurf->next->prev = pdsurf->prev;

    if (pdsurf->prev)
        pdsurf->prev->next = pdsurf->next;
    else if (ppdev->pdsurf == pdsurf)
        ppdev->pdsurf = pdsurf->next;   // new head of list

    EngFreeMem(pdsurf);
}

//******************************Public*Routine**********************************
//
// Function: bAssertModeOffscreenHeap
//
// Routine Description:
//
//   This function is called whenever we switch in or out of full-screen
//   mode.  We have to convert all the off-screen bitmaps to DIBs when
//   we switch to full-screen (because we may be asked to draw on them even
//   when in full-screen, and the mode switch would probably nuke the video
//   memory contents anyway).
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     True if successful.
//
//******************************************************************************

BOOL bAssertModeOffscreenHeap
(
    PDEV*   ppdev,
    BOOL    bEnable
)
{
    if (!bEnable)
        return bMoveAllDfbsFromOffscreenToDibs(ppdev);

    return TRUE;
}

//******************************Public*Routine**********************************
//
// Function: vDisableOffscreenHeap
//
// Routine Description:
//
//     Frees any resources allocated by the off-screen heap.
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************

VOID vDisableOffscreenHeap
(
    PDEV*   ppdev
)
{
    SURFOBJ*    psoPunt;
    HSURF       hsurf;

    psoPunt = ppdev->psoPunt;
    if (psoPunt != NULL)
        {
        hsurf = psoPunt->hsurf;
        EngUnlockSurface(psoPunt);
        EngDeleteSurface(hsurf);
        }

    psoPunt = ppdev->psoPunt2;
    if (psoPunt != NULL)
        {
        hsurf = psoPunt->hsurf;
        EngUnlockSurface(psoPunt);
        EngDeleteSurface(hsurf);
        }

    psoPunt = ppdev->psoPunt3;
    if (psoPunt != NULL)
        {
        hsurf = psoPunt->hsurf;
        EngUnlockSurface(psoPunt);
        EngDeleteSurface(hsurf);
        }

#ifndef USE_RM_MMGR // [
    //**************************************************************************
    // Free heap space allocated from from RM.
    //**************************************************************************
    {
        HEAP* pHeap = &ppdev->heap;

        // This should never have to free any heap space unless we are using
        // hysteresis in the alloc/free heap algorithm.  That is if we are
        // freeing heaps as they become empty instead of deferring that work,
        // this function should never be called with any offscreen currently
        // in use.

        /*
        ** Start with the last heap in list.
        */
        while (pHeap->pNextHeap)
            pHeap = pHeap->pNextHeap;

        /*
        ** Return heap space back to RM in reverse order of allocation.
        */
        do
        {
            /*
            ** This check is required because the first heap struct is part of
            ** PDEV instead of being allocated so the only way we know that it
            ** is empty (no space allocated for the heap) is to check its size.
            */
            if (pHeap->ulSizeInBytes)
                FreeHeap(ppdev, pHeap);
        }
        while ((pHeap = pHeap->pPrevHeap) != NULL);
    }
#endif // !USE_RM_MMGR ]

    //**********************************************************************
    // Destroy the offscreen heap.
    //**********************************************************************

    NVHEAP_CLEAR(NULL);
}


//******************************Public*Routine**********************************
//
// Function: bEnableOffscreenHeap
//
// Routine Description:
//
//      Initializes the off-screen heap using all available video memory,
//      accounting for the portion taken by the visible screen.
//
//      Input: ppdev->cxScreen
//             ppdev->cyScreen
//             ppdev->cxMemory
//             ppdev->cyMemory
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************

BOOL bEnableOffscreenHeap
(
    PDEV*       ppdev
)
{
    SIZEL       sizl;
    HSURF       hsurf;
    ULONG       xSize;

    //**************************************************************************
    // Initialize offscreen heap manager
    //**************************************************************************
    NVHEAP_INIT(0, ppdev->cbFrameBuf - 1, NULL);

    //**************************************************************************
    // cxMemory is Width of Video Memory (in pixels, not bytes)
    // cyMemory is Height of All of Video Memory (in scanlines)
    //
    //      cx/cyMemory encompasses all of video memory, which includes
    //      any additional 'right-hand' side memory, which may be present if
    //      the Width of the screen != pitch/stride of mode.
    //
    // NOTE:  NV Instance memory exists at the end of offscreen memory.
    //        This has already been compensated for by the miniport.
    //        The Miniport reduces the available amount of offscreen memory
    //        before it returns it to the display driver.  See NVValidateModes
    //        for more information.
    //**************************************************************************

    DISPDBG((1, "Screen: %li x %li  Memory: %li x %li",
        ppdev->cxScreen, ppdev->cyScreen, ppdev->cxMemory, ppdev->cyMemory));

    ASSERTDD((ppdev->cxScreen <= ppdev->cxMemory) &&
             (ppdev->cyScreen <= ppdev->cyMemory),
             "Memory must not have smaller dimensions than visible screen!");

#ifdef USE_RM_MMGR // [
    //**************************************************************************
    // Init the heap.oh structure links.
    //**************************************************************************

    ppdev->heap.oh.pdsurf         = NULL;
    ppdev->heap.oh.next           = &ppdev->heap.oh;
    ppdev->heap.oh.prev           = &ppdev->heap.oh;
    ppdev->heap.oh.nextEmpty      = NULL;
    ppdev->heap.oh.pHeap          = &ppdev->heap;
    ppdev->heap.oh.ulSizeInBytes  = 0;
    ppdev->heap.oh.ulOffset       = 0;
    ppdev->heap.oh.ulLinearStride = 0;
#endif // USE_RM_MMGR ]

    //**************************************************************************
    // Allocate a 'punt' SURFOBJ we'll use when the device-bitmap is in
    // off-screen memory, but we want GDI to draw to it directly as an
    // engine-managed surface:
    //**************************************************************************

    sizl.cx = ppdev->cxMemory;
    sizl.cy = ppdev->cyMemory;

    //**************************************************************************
    // We don't want to hook any drawing functions for the punt surfaces, since
    // they are only there to allow GDI to perform drawing operations which we
    // don't support in hardware. We do need to ask GDI to call us prior to drawing,
    // to ensure the hw graphics engine is idle, since these surfaces represent bitmaps
    // stored in graphics memory.
    //**************************************************************************

    hsurf = (HSURF) EngCreateBitmap(sizl,
                                    0xbadf00d,
                                    ppdev->iBitmapFormat,
                                    BMF_TOPDOWN,
                                    (VOID*) 0xbadf00d);

    if ((hsurf == 0)                                     ||
        (!EngAssociateSurface(hsurf, ppdev->hdevEng, 0)) ||
        (!(ppdev->psoPunt = EngLockSurface(hsurf))))
        {
        DISPDBG((2, "Failed punt surface creation"));

        EngDeleteSurface(hsurf);
        goto ReturnFalse;
        }

    //**************************************************************************
    // We need another for doing DrvBitBlt and DrvCopyBits when both
    // surfaces are off-screen bitmaps:
    //**************************************************************************

    hsurf = (HSURF) EngCreateBitmap(sizl,
                                    0xbadf00d,
                                    ppdev->iBitmapFormat,
                                    BMF_TOPDOWN,
                                    (VOID*) 0xbadf00d);

    //**************************************************************************
    // These 'punt' services are necessary for when we use GDI to
    // draw on a 'Device' format bitmap.  Instead of passing the SURFOBJ
    // with the Device Surface in it, we use these temporary wrapper surfaces.
    //**************************************************************************

    if ((hsurf == 0)                                     ||
        (!EngAssociateSurface(hsurf, ppdev->hdevEng, 0)) ||
        (!(ppdev->psoPunt2 = EngLockSurface(hsurf))))
        {
        DISPDBG((2, "Failed punt surface creation"));

        EngDeleteSurface(hsurf);
        goto ReturnFalse;
        }


    //**************************************************************************
    // We need another punt surface for translating multi-colored brushes
    //**************************************************************************

    hsurf = (HSURF) EngCreateBitmap(sizl,
                                    ppdev->lDelta,
                                    ppdev->iBitmapFormat,
                                    BMF_TOPDOWN,
                                    ppdev->pjFrameBufbase);

    //**************************************************************************
    // These 'punt' services are necessary for when we use GDI to
    // draw on a 'Device' format bitmap.  Instead of passing the SURFOBJ
    // with the Device Surface in it, we use these temporary wrapper surfaces.
    //**************************************************************************

    if ((hsurf == 0)                                     ||
        (!EngAssociateSurface(hsurf, ppdev->hdevEng, 0)) ||
        (!(ppdev->psoPunt3 = EngLockSurface(hsurf))))
        {
        DISPDBG((2, "Failed punt surface creation"));

        EngDeleteSurface(hsurf);
        goto ReturnFalse;
        }

    //**************************************************************************
    // Point the punt surface back to the ppdev
    //**************************************************************************
    ppdev->psoPunt->dhpdev = (DHPDEV) ppdev;
    ppdev->psoPunt2->dhpdev = (DHPDEV) ppdev;
    ppdev->psoPunt3->dhpdev = (DHPDEV) ppdev;


    DISPDBG((5, "Passed bEnableOffscreenHeap"));

#ifdef FONT_CACHE // [
    /*
    ** JOEHACK
    ** If we go back to glyph caching we should create and Enable, Disable and
    ** AssertMode GlyphCache() funtions and call them as appropiate from Enable
    ** and Disable Surface and AssertMode().
    */
#ifndef NV3
    //**************************************************************************
    // Check if screen rectangle allocation succeeded
    //**************************************************************************

    if (poh != NULL) {

    //**************************************************************************
    // Reserve the font cache area in offscreen memory.
    //**************************************************************************

        if (ppdev->fontCacheEnabled) {
            xSize = ppdev->cxScreen;
            poh = pohAllocate  (ppdev,
                                xSize/ppdev->cjPelSize,
                                (FONT_CACHE_SIZE+xSize-1)/xSize,
                                FLOH_MAKE_PERMANENT);
            if (poh == NULL)
                ppdev->fontCacheEnabled = FALSE;
            else {
                ppdev->fontCacheOffset = (ULONG)((BYTE *)poh->LinearPtr - ppdev->pjFrameBufbase);
            }

        }
    }
#endif // NV3
#endif // FONT_CACHE ]

    return(TRUE);

ReturnFalse:

    DISPDBG((2, "Failed bEnableOffscreenHeap"));

    return(FALSE);
}


#if _WIN32_WINNT >= 0x0500 // [
/*****************************************************************************\
*  HBITMAP DrvDeriveSurface
*
*   This function derives and creates a GDI surface from
*   specified DirectDraw surface.
*
*   Parameters:
*   pDirectDraw     Points to a DD_DIRECTDRAW_GLOBAL structure that
*                   describes the DirectDraw obect.
*   pSurface        Points to a DD_SURFACE_LOCAL structure that
*                   describes DirectDraw surface around which to wrap
*                   a GDI surface.
*
*   Return Value:
*   DrvDeriveSurface returns a handle to the created GDI surface
*   upon succeed. It returns NULL if the call fails or
*   if if the river cannot accelerate GDI drawing to
*   the specified DirectDraw surface.
*
*   Comments:
*   DrvDeriveSurface allows the driver to create a GDI surface around a
*   DirectDraw video memory or AGP surface object in order to allow
*   acceleration of GDI drawing to the surface. If the driver does not
*   hook this call, all drawing to DirectDRaw surfaces is done in software
*   using DIB engine.
*   GDI calls DrvDeriveSurface with RGB surfaces only.
*   The driver should call DrvCreateDeviceBitmap to create a GDI surface
*   of the same size and format as that of the DirectDraw surface. Space
*   for the actual pixels need not be allocated since it already exists.
*
*   Note:
*
\*****************************************************************************/

HBITMAP DrvDeriveSurface(
    DD_DIRECTDRAW_GLOBAL    *pDirectDraw,
    DD_SURFACE_LOCAL        *pSurface
)
{
    PPDEV               ppdev   = (PPDEV)pDirectDraw->dhpdev;
    SIZEL               sizel;
    HBITMAP             hbmDevice;
    DSURF               *pdsurf;
    DD_SURFACE_GLOBAL   *pSurfaceGlobal = pSurface->lpGbl;

    //  Conditions that can't create GDI surface on DirectDraw surface.

    if(pSurface->ddsCaps.dwCaps & (DDSCAPS_NONLOCALVIDMEM | DDSCAPS_TEXTURE))
    {
        //  Currently, we don't support create GDI surface over AGP
        //  memory, or textures (swizzled).

        return(0);
    }

    pdsurf  = (DSURF *)EngAllocMem(
        FL_ZERO_MEMORY, sizeof(DSURF), ALLOC_TAG);

    if(pdsurf != NULL)
    {
        sizel.cx    = pSurfaceGlobal->wWidth;
        sizel.cy    = pSurfaceGlobal->wHeight;

        hbmDevice   = EngCreateDeviceBitmap(
            (DHSURF)ppdev, sizel, ppdev->iBitmapFormat);

        if(hbmDevice != NULL)
        {
            //  HOOK_SYNCHRONIZE must always be hooked when we
            //  give GDI a pointer to the bitmap bits. (flHook
            //  already has this bit set.)

            if(EngModifySurface(
                (HSURF)hbmDevice, ppdev->hdevEng, ppdev->flHooks,
                MS_NOTSYSTEMMEMORY, (DHSURF)pdsurf,
                ppdev->pjFrameBufbase + pSurfaceGlobal->fpVidMem,
                pSurfaceGlobal->lPitch, NULL))
            {
                pdsurf->dt  = DT_SCREEN;
                pdsurf->sizl= sizel;
                pdsurf->ppdev= ppdev;
                pdsurf->LinearPtr   = ppdev->pjFrameBufbase + pSurfaceGlobal->fpVidMem;
                pdsurf->LinearStride= pSurfaceGlobal->lPitch;

                return(hbmDevice);
            }

            //  Delete the surface handle if failed.

            EngDeleteSurface((HSURF)hbmDevice);
        }

        //  Can't create handle to the bitmap, free allocated resources.

        EngFreeMem(pdsurf);
    }

    //  We can't allocate memory for the device surface object, we must
    //  return failure.

    return(0);
}
#endif // _WIN32_WINNT >= 0x0500 ]

#ifndef USE_RM_MMGR // [
//******************************Public*Routine**********************************
//
// Function:   void FreeHeap
//
// Routine Description:
//
//     Calls RM to free a heap.
//
// Arguments:
//
//     pointer to current PDEV
//     poniter to heap to free
//
// Return Value:
//
//******************************************************************************

void FreeHeap
(
    PDEV*   ppdev,
    HEAP*   pHeap
)
{
    /*
    ** Free structs used to manage this heap space.
    */
    heap_clear(pHeap);

    /*
    ** Call RM to return this heap space to its pool.
    */
    NVHEAP_FREE(pHeap->ulOffset);

    /*
    ** If this is not the root heap unlink it and free the heap struct.
    */
    if (pHeap != &ppdev->heap)
    {
        if (pHeap->pNextHeap)
            pHeap->pNextHeap->pPrevHeap = pHeap->pPrevHeap;

        if (pHeap->pPrevHeap)
            pHeap->pPrevHeap->pNextHeap = pHeap->pNextHeap;

        EngFreeMem(pHeap);
    }
    else // this is the root heap so just mark it as empty
    {
        pHeap->ulSizeInBytes = 0;
        pHeap->ulOffset      = 0;
    }
}

//******************************Public*Routine**********************************
//
// Function:   HEAP* GetHeap
//
// Routine Description:
//
//     Calls RM to allocates another heap.
//
// Arguments:
//
//     pointer to current PDEV
//     size in bytes of minimum allocation requested
//
// Return Value:
//
//     Ptr to HEAP structure (success) or NULL
//
//******************************************************************************

HEAP* GetHeap
(
    PDEV*   ppdev,
    ULONG   ulMinAlloc
)
{
    ULONG   ulAllocated = 0;
    ULONG   ulAllocSize;
    HEAP*   pNewHeap;
    HEAP*   pHeap;
    NvU32   dwStatus;

    /*
    ** Don't allocate heap space smaller than MIN_HEAP_SIZE
    */
    if (ulMinAlloc < MIN_HEAP_SIZE)
        ulMinAlloc = MIN_HEAP_SIZE;

    /*
    ** First heap will contain the persistent DFBS allocated right after a mode
    ** switch and some extra space so we won't usually have to allocate a big
    ** chunk.  If we do allocate a big chunk, it will be after Windows has
    ** already allocated its persistent DFBs so that allocation shouldn't last
    ** long.
    **
    ** We allocate TYPE_CURSOR from them RM because it will high-justify these
    ** allocations.  We do this so that when we free one of these chunks to
    ** make room for Dx/Ogl the freed space should be adjacent the current
    ** free memory since Dx/Ogl allocations are low-justified.  This leaves a
    ** single large free block to work with instead of 2 smaller free blocks.
    */

    if (ppdev->heap.ulSizeInBytes == 0)
    {
        if (ppdev->cjPelSize == 4)
            ulAllocSize = FIRST_HEAP_SIZE_32;
        else
            ulAllocSize = FIRST_HEAP_SIZE_16;  // same for 8bpp
    }
    else
    {
        // RoundUp(2 * screensize, 2^n)
        ulAllocSize = 4 * MIN_HEAP_SIZE;
        while (ulAllocSize < (ULONG)(2 * ppdev->cyScreen * ppdev->cxScreen * ppdev->cjPelSize))
        {
            ulAllocSize *= 2;
        }
    }

    /*
    ** Allocate a heap chunk from the RM memmgr.  Start with a base size and
    ** if that fails, try to allocate something half that size.
    */
    do
    {
        NVHEAP_ALLOC(dwStatus, ulAllocated, ulAllocSize, TYPE_CURSOR);
    }
    while ((dwStatus!=0) && (ulAllocSize /= 2) >= ulMinAlloc);

    if (dwStatus!=0)
    {
        DISPDBG((0, "GetHeap failed to initialize heap. Last try: %d byte", ulAllocSize));
        return NULL;
    }

    /*
    ** This is kind of a hack but rather than changing the USE_RM_MMGR case
    ** which handles only a single heap, here we deal with the mess associated
    ** with the first heap struct allocated within ppdev and subsequent heap
    ** structs being allocated.
    */

    if (ppdev->heap.ulSizeInBytes == 0)
    {
        memset(&ppdev->heap, 0, sizeof(ppdev->heap));

        pNewHeap = &ppdev->heap;
    }
    else
    {
        /*
        ** Running out of system memory sould be a rare event compared to running
        ** out of offscreen memory so we allocate the space for the heap structure
        ** after we know we have the offscreen space.
        */
        pNewHeap = EngAllocMem(FL_ZERO_MEMORY, sizeof(HEAP), ALLOC_TAG);
        if (pNewHeap == NULL)
        {
            NVHEAP_FREE(ulAllocated);
            return NULL;
        }

        /*
        ** Walk to last heap in list.
        */
        pHeap = &ppdev->heap;
        while (pHeap->pNextHeap)
            pHeap = pHeap->pNextHeap;

        pHeap->pNextHeap = pNewHeap;
        pNewHeap->pPrevHeap = pHeap;
    }

    /*
    ** Initialize size info for this heap.
    */
    pNewHeap->ulSizeInBytes = ulAllocSize;
    pNewHeap->ulOffset      = ulAllocated;

    /*
    ** Initialize memory manager structs for this heap.
    */
    if (heap_init(ulAllocated, pNewHeap->ulSizeInBytes, pNewHeap) == 0)
    {
        FreeHeap(ppdev, pNewHeap);
        return NULL;
    }

    return pNewHeap;
}

/*
** This linear heap manager is massaged from the one that was previously in
** this file.  It has been changed to use OH structs and the OH struct was
** changed to incorporate the memory management components in the memory_t
** structure that the original version used.
*/

// Don't use the memstruc.h versions of these macros.
#undef EMPTY
#undef IS_EMPTY
#undef SET_EMPTY
#undef SET_BUSY
#define EMPTY           0x1
#define IS_EMPTY(pBlk)  ((ULONG_PTR)(pBlk)->prev &  EMPTY)
#define SET_EMPTY(pBlk) ((pBlk)->prev = (OH *)((ULONG_PTR)(pBlk)->prev |  EMPTY))
#define SET_BUSY(pBlk)  ((pBlk)->prev = (OH *)((ULONG_PTR)(pBlk)->prev & ~EMPTY))

//----------------------------------------------------------------------------
//
//  Function:   heap_alloc
//
//  Routine Description:
//
//      Allocates a block of memory and cleans up the heap
//
//  Arguments:
//
//  Return Value:
//
//----------------------------------------------------------------------------
OH* heap_alloc
(
    ULONG   ulBytesToAlloc,
    HEAP*   pHeap
)
{
    OH*     pBlk;
    OH*     pPrevEmpty;
    OH*     pNextEmpty;
    ULONG   ulBytesAvail;

    /*
    ** Check for a valid initialized heap.
    */
    if ((pHeap == NULL) || (pHeap->ulSizeInBytes == 0))
        return NULL;

    //**************************************************************************
    // Scan through the free list for a block large enough
    //
    // pHeap->oh.next  (Initial look at heap)
    //        |                                               -------
    //        |  ------- nextEmpty --------   --- nextEmpty--| EMPTY |
    //        | |                          | |                -------
    //        v |                          v |
    //       1st Blk      2nd Blk       3rd Blk       Last Blk
    //       ----          ----          ----          ----
    //      |    |  --->  |    |  --->  |    |  --->  |    | ---
    //      |    |  <---  |    |  <---  |    |  <---  |    |    |
    //       ----          ----          ----          ----     |
    //         ^                                                |
    //         |                                                |
    //          ------------------------------------------------
    //
    //      EMPTY          BUSY          EMPTY         BUSY
    //
    //     No Space       Contains      Contains       Contains
    //     Available         no          video           no
    //                      data         memory         data
    //
    //  ------------------------------------------------------------------------
    // First time heap_alloc is called:
    //
    //                                  pBlk
    //                                     |
    //                                     v
    //       1st Blk      2nd Blk       3rd Blk       Last Blk
    //       ----          ----          ----          ----
    //      |    |  --->  |    |  --->  |    |  --->  |    | ---
    //      |    |  <---  |    |  <---  |    |  <---  |    |    |
    //       ----          ----          ----          ----     |
    //         ^                                                |
    //         |                                                |
    //          ------------------------------------------------
    //**************************************************************************

    pBlk = pHeap->oh.next;   // points to 1st block in heap

    do
    {
        pPrevEmpty = pBlk ;

        pBlk = pBlk->nextEmpty;

        if (pBlk == (void *)EMPTY)
            return 0;

        ulBytesAvail = pBlk->ulSizeInBytes;
    }
    while (ulBytesAvail < ulBytesToAlloc);

    //**************************************************************************
    // At this point, pBlk points to an entry which contains enough memory
    // to satisfy the allocation request.
    //
    // Note: We search thru the 'EMPTY' (UNUSED) entries, not the 'BUSY' (USED) entries
    //**************************************************************************

    if (ulBytesAvail == ulBytesToAlloc)
    {
        //**********************************************************************
        // We're giving the caller the whole thing
        // So all we need to do is set pNextEmpty
        //**********************************************************************
        pNextEmpty = pBlk->nextEmpty;
    }
    else
    {
        //**********************************************************************
        // Create a new 'EMPTY' entry which will hold the currently unused
        // portion of memory (EMPTY essentially means UNUSED in this
        // heap manager). pBlk will hold the currently allocated portion of memory
        //**********************************************************************

        pNextEmpty = EngAllocMem(FL_ZERO_MEMORY, sizeof(OH), ALLOC_TAG);

        //  if pNextEmpty is NULL ptr, we can't do anything but fail the call.

        if(pNextEmpty == NULL)
            return 0;

//      pNextEmpty->pdsurf        = we don't have this information
        pNextEmpty->next          = pBlk->next;
        pNextEmpty->prev          = pBlk;
        pNextEmpty->nextEmpty     = pBlk->nextEmpty;
        pNextEmpty->pHeap         = pHeap;
        pNextEmpty->ulSizeInBytes = ulBytesAvail - ulBytesToAlloc;
        pNextEmpty->ulOffset      = pBlk->ulOffset + ulBytesToAlloc;
//      pNextEmpty->ulLinearStride= we don't have this information

        SET_EMPTY(pNextEmpty);

        //**********************************************************************
        // Now patch its neighbors
        //**********************************************************************

        pBlk->next = pNextEmpty;
        pNextEmpty->next->prev = pNextEmpty;
    }

    pPrevEmpty->nextEmpty = pNextEmpty;

    //**************************************************************************
    // Mark as BUSY (BUSY essentially means USED in this heap manager)
    //**************************************************************************

    pBlk->ulSizeInBytes = ulBytesToAlloc;

    SET_BUSY(pBlk);

    //**************************************************************************
    //
    // pHeap->oh.next  (UPDATED HEAP)
    //        |                                                           -------
    //        |  ------- nextEmpty --------------------   --- nextEmpty--| EMPTY |
    //        | |                       pBlk           | |                -------
    //        v |                                      v |
    //       1st Blk      2nd Blk        NEW           NEW         Last Blk
    //       ----          ----         ----          ----          ----
    //      |    |  --->  |    |  ---> |    |  --->  |    |  --->  |    | ---
    //      |    |  <---  |    |  <--- |    |  <---  |    |  <---  |    |    |
    //       ----          ----         ----          ----          ----     |
    //         ^                                                             |
    //         |                                                             |
    //          -------------------------------------------------------------
    //
    //                                  NEW           NEW
    //      EMPTY          BUSY         BUSY         EMPTY          BUSY
    //
    //     No Space       Contains    Contains      Contains        Contains
    //     Available         no       current         all             no
    //                      data      requested     of video         data
    //                                 video         memory
    //                                 memory
    //
    //                  |<---------------------->|
    //                   This is where new nodes
    //                          get added
    //**************************************************************************

    return pBlk;
}

//----------------------------------------------------------------------------
//
//  Function:   heap_free
//
//  Routine Description:
//
//      Frees up a block of memory and cleans up the heap
//
//  Arguments:
//
//  Return Value:
//      0 - heap is not empty
//      1 - heap is empty
//
//----------------------------------------------------------------------------
BOOL heap_free
(
    OH*     pBlk
)
{
    HEAP*   pHeap = pBlk->pHeap;

    OH*     pChk;
    OH*     pNext;
    OH*     pNextEmpty;
    OH*     freeCurrent;
    OH*     freeAhead;

    //**************************************************************************
    // Check and see if we can coalesce memory blocks
    //
    //
    //              Previous Block    Block to     Next Block
    //                                be freed
    //
    //                   |              |               |
    //                   |              |               |
    //                   v              v               v
    //
    //               EMPTY/BUSY?       BUSY         EMPTY/BUSY?
    //
    //**************************************************************************

    pNext = pBlk->next;
    if (IS_EMPTY(pNext))
    {
        //**********************************************************************
        // Coalesce forward , next block is EMPTY
        //**********************************************************************

        freeAhead   = pNext;
        pNextEmpty  = pNext->nextEmpty;
        pNext       = pNext->next;

        //**********************************************************************
        // Current State of Variables:
        //
        //                            Block to     Next Block
        //                            be freed
        //
        //                            (pBlk)
        //                              |               |
        //                              |               |  ----- pNextEmpty -->
        //                              v               v |
        //                                                |
        //                             BUSY  ------>  EMPTY ---- pNext ------->
        //                                  freeAhead
        //
        //                          |<---------------------->|
        //                             These two blocks will
        //                             be merged below
        //
        //          pBlk        = current block
        //          freeAhead   = points to the block that will be deleted
        //          pNextEmpty  = points to the new NextEmpty block
        //          pNext       = points to the new Next block
        //**********************************************************************

    }
    else
    {
        //**********************************************************************
        // Coalesce forward , next block is BUSY
        //**********************************************************************

        pNextEmpty = 0 ;
        freeAhead = (OH *)0;

        //**********************************************************************
        // Current State of Variables:
        //
        //                            Block to     Next Block
        //                            be freed
        //
        //                            (pBlk)
        //                              |               |
        //                              |               |
        //                              v               v       pNextEmpty = 0
        //                                                      freeAhead  = 0
        //                             BUSY  ------>  BUSY
        //                                    pNext
        //
        //
        //                            The above two blocks
        //                            will NOT be merged
        //
        //          pBlk        = current block
        //          freeAhead   = 0 (means we will NOT delete/merge a block)
        //          pNextEmpty  = 0 (means we will need to obtain the pNextEmpty
        //                           block from the PREVIOUS Empty block)
        //          pNext       = unchanged, already points to the next block
        //**********************************************************************

    }

    //**************************************************************************
    // Now check and see if we can coalesce previous memory blocks
    //**************************************************************************

    if (IS_EMPTY(pBlk->prev))
    {
        //**********************************************************************
        // Coalesce backward, previous block is EMPTY
        //**********************************************************************

        freeCurrent     = pBlk;
        pBlk            = pBlk->prev;
        pNext->prev     = pBlk;
        if (pNextEmpty)
            pBlk->nextEmpty = pNextEmpty;

        //**********************************************************************
        // Current State of Variables:
        //
        //          Previous Block    Block to
        //                            be freed
        //
        //               |              |
        //               |              |
        //               v              v       --> pNextEmpty (already set up above)
        //                                      --> pNext (already set up above)
        //             EMPTY <------  BUSY
        //
        //               ^ |            ^
        //               | |            |
        //             pBlk|        freeCurrent
        //                 |
        //                  ------------------------> pNextEmpty
        //
        //          |<------------------------>|
        //              The above two blocks
        //                WILL be merged
        //
        //          pBlk            = updated to the new 'current' block
        //
        //          freeCurrent     = points to block that will be deleted
        //          pNext->prev     = updated to be linked to its new previous block
        //          pBlk->nextEmpty = updated to point to next empty block
        //                            (unless the pNextEmpty block is to be obtained
        //                             from the previous empty block, then
        //                             this field is left UNMODIFIED, because
        //                             it ALREADY points to the next empty block)
        //          pBlk->next      = is initialized after this if statement because
        //                            it doesn't depend on this if statement
        //**********************************************************************

    }
    else
    {
        //**********************************************************************
        // Coalesce backward, previous block is BUSY
        //**********************************************************************

        SET_EMPTY( pBlk ) ;
        freeCurrent = (OH *)0;

        //**********************************************************************
        // Search this heap for the previous empty block
        //**********************************************************************

        for (pChk = pHeap->oh.next;
                (pChk->nextEmpty != (OH *)EMPTY) && (pChk->nextEmpty->ulOffset < pBlk->ulOffset);
                pChk = pChk->nextEmpty)
        {
            ;
        }

        //**********************************************************************
        // If we already have a pNextEmpty block, then we know that we just need to
        // update the pNext->prev block to point back to this current block, because
        // it pNext->prev currently points to the block which will be deleted.
        //
        // However, if pNextEmpty == 0, then pNext->prev is already setup correctly.
        //
        // The following if statement would be easier to understand in the following
        // format:
        //
        //  if (pNextEmpty)
        //      pNext->prev = pBlk;
        //
        //  if (!pNextEmpty)
        //      pNextEmpty = pChk->nextEmpty
        //
        //**********************************************************************

        if (pNextEmpty)
            pNext->prev = pBlk;
        else
            pNextEmpty = pChk->nextEmpty ;

        //**********************************************************************
        // pNextEmpty has now been correctly determined.
        // Insert the block in the EMPTY list and fixup the pointers.
        //**********************************************************************

        pBlk->nextEmpty = pNextEmpty ;
        pChk->nextEmpty = pBlk ;

        //**********************************************************************
        // Current State of Variables:
        //
        //              Previous Block    Block to
        //                                be freed
        //
        //                   |              |
        //                   |              |
        //                   v              v     --> pNextEmpty (already set up above)
        //                                        --> pNext (already set up above)
        //                 BUSY           BUSY
        //                                ^ ^
        //      Previous                  | |
        //       Empty <------------------   -- pBlk
        //       Block
        //
        //
        //       pBlk            = current block
        //       freeCurrent     = 0 (means that we will NOT delete a block)
        //       pNext->prev     = updated to be linked to its new previous block
        //                         (if necessary)
        //       pBlk->nextEmpty = updated to point to the next empty block.
        //       pChk->nextEmpty = previous next empty block is also correctly updated
        //       pBlk->next      = is initialized after this if statement because
        //                         it doesn't depend on this if statement
        //**********************************************************************
    }


    //**************************************************************************
    // freeAhead is NONZERO if we merged 2 empty blocks into 1
    // freeCurrent is also NONZERO if we merged 2 empty blocks into 1
    //**************************************************************************

    if (freeCurrent)
        EngFreeMem(freeCurrent);

    if (freeAhead)
        EngFreeMem(freeAhead);

    //**************************************************************************
    // Update the next block link.
    // Also, update the size of the current block, due to freeing up one block.
    //**************************************************************************

    pBlk->next = pNext;
    pBlk->ulSizeInBytes = pNext->ulOffset - pBlk->ulOffset;

    return pBlk->ulSizeInBytes == pHeap->ulSizeInBytes;
}

//----------------------------------------------------------------------------
//
//  Function:   heap_init
//
//  Routine Description:
//
//      Initializes the linear heap manager for OpenGL
//
//  Arguments:
//
//  Return Value:
//      0 - failed
//      1 - success
//
//----------------------------------------------------------------------------
BOOL heap_init
(
    ULONG   memBegin,
    ULONG   memSize,
    HEAP*   pHeap
)
{
    OH*     pFirstBlk;
    OH*     pSecondBlk;
    OH*     pThirdBlk;
    OH*     pLastBlk;
    OH*     pNextBlk;
    OH*     pBlk;

    //**************************************************************************
    // We initialize the memory system, by setting up three special
    // blocks and a fourth block containing all of free memory.
    // The first block is "EMPTY", but has no "spaceAvailable".
    // The second block is "BUSY", but uses no space.
    // The last block is "BUSY" and also contains no memory.
    // Finally, the third block contains the rest of memory!
    //
    // pHeap->oh.next
    //        |                                               -----------
    //        |  ------- nextEmpty --------   --- nextEmpty--| 0 + EMPTY |
    //        | |                          | |                -----------
    //        v |                          v |
    //       1st Blk      2nd Blk       3rd Blk       Last Blk
    //       ----          ----          ----          ----
    //      |    |  --->  |    |  --->  |    |  --->  |    | ---
    //      |    |  <---  |    |  <---  |    |  <---  |    |    |
    //       ----          ----          ----          ----     |
    //         ^                                                |
    //         |                                                |
    //          ------------------------------------------------
    //
    //      EMPTY          BUSY          EMPTY         BUSY
    //
    //     No Space       Contains      Contains       Contains
    //     Available         no           all            no
    //                      data        of video        data
    //                                   memory
    //
    //**************************************************************************

    if ((pFirstBlk = EngAllocMem(FL_ZERO_MEMORY, 4*sizeof(OH), ALLOC_TAG)) == NULL)
    {
        pHeap->oh.next = NULL;
        return 0;
    }

    pHeap->oh.next = pFirstBlk;
    pSecondBlk = pFirstBlk + 1;
    pThirdBlk = pSecondBlk + 1;
    pLastBlk = pThirdBlk + 1;

    //**************************************************************************
    // FirstBlk is "EMPTY" but has no space available
    //**************************************************************************

    pFirstBlk->prev          = pLastBlk;
    pFirstBlk->next          = pSecondBlk;
    pFirstBlk->nextEmpty     = pThirdBlk;
    pFirstBlk->pHeap         = pHeap;
    pFirstBlk->ulSizeInBytes = 0;
    pFirstBlk->ulOffset      = memBegin;
    SET_EMPTY(pFirstBlk);

    //**************************************************************************
    // Second is "BUSY", but contains no data
    //**************************************************************************

    pSecondBlk->prev          = pFirstBlk;
    pSecondBlk->next          = pThirdBlk;
    pSecondBlk->nextEmpty     = NULL;
    pSecondBlk->pHeap         = pHeap;
    pSecondBlk->ulSizeInBytes = 0;
    pSecondBlk->ulOffset      = memBegin;
    SET_BUSY(pSecondBlk);

    //**************************************************************************
    // ThirdBlk is "EMPTY" and contains all of memory!
    //**************************************************************************

    pThirdBlk->prev          = pSecondBlk;
    pThirdBlk->next          = pLastBlk ;
    pThirdBlk->nextEmpty     = (OH *)EMPTY;
    pThirdBlk->pHeap         = pHeap;
    pThirdBlk->ulSizeInBytes = memSize;
    pThirdBlk->ulOffset      = memBegin;
    SET_EMPTY(pThirdBlk);

    //**************************************************************************
    // LastBlk is "BUSY", but contains no data
    // LastBlk starts 1 past end of available memory
    //**************************************************************************

    pLastBlk->prev          = pThirdBlk;
    pLastBlk->next          = pFirstBlk;
    pLastBlk->nextEmpty     = NULL;
    pLastBlk->pHeap         = pHeap;
    pLastBlk->ulSizeInBytes = 0;
    pLastBlk->ulOffset      = memBegin + memSize;
    SET_BUSY(pLastBlk);

    return 1;
}


//----------------------------------------------------------------------------
//
//  Function:   heap_clear
//
//  Routine Description:
//
//      Frees up the 4 base blocks used to manage a a heap
//
//  Arguments:
//
//  Return Value:
//
//----------------------------------------------------------------------------
void heap_clear
(
    HEAP*   pHeap
)
{
    /*
    ** Note that this is NOT an assert case.  If GetHeap successfully allocates
    ** a new heap but heap_init() fails (presumeably because the allocation of
    ** the oh struct space failed) then GetHeap will call FreeHeap which calls
    ** heap_clear() and pHeap->oh.next will definitely be NULL in that case.
    */
    if (pHeap && pHeap->oh.next)
    {
        EngFreeMem(pHeap->oh.next);
        pHeap->oh.next = NULL;
    }
}
#endif // !USE_RM_MMGR ]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\linkedlist.h ===
#ifndef _LINKEDLIST_H
#define _LINKEDLIST_H
//******************************Module*Header***********************************
// Module Name: linkedlist.h
//
// Manage a linked list containing any data
//
// Copyright (c) 2000, NVIDIA, Corporation.  All rights reserved.
//
// THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
// NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
// IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
//
//******************************************************************************

typedef enum _LL_CLASS_ID
{
    LL_CLASS_INVALID = 0,   // invalid type, do not use!
    LL_CLASS_ANY_CLASS,     // only allowed in call to bLinkedListCreate
    LL_CLASS_SAVESCREENBITS,
#ifdef NV_MAIN_MULTIMON
    LL_CLASS_OGLPDEV,
#endif
    // add more classes here
} LL_CLASS_ID;

BOOL bLinkedListCreate          (IN OUT struct _LINKEDLISTHEAD **ppAnchor, IN LL_CLASS_ID ClassID);
BOOL bLinkedListDestroy         (IN OUT struct _LINKEDLISTHEAD **ppAnchor);
BOOL bLinkedListAddElement      (IN struct _LINKEDLISTHEAD *pAnchor, IN LL_CLASS_ID ClassID, IN  ULONG_PTR   ulIdent, PVOID pData, ULONG ulAllocSize);
BOOL bLinkedListRemoveElement   (IN struct _LINKEDLISTHEAD *pAnchor, IN LL_CLASS_ID ClassID, IN  ULONG_PTR   ulIdent);
BOOL bLinkedListGetElement      (IN struct _LINKEDLISTHEAD *pAnchor, IN LL_CLASS_ID ClassID, IN  ULONG_PTR   ulIdent, OUT PVOID *ppData);
BOOL bLinkedListGetFirstElement (IN struct _LINKEDLISTHEAD *pAnchor, IN LL_CLASS_ID ClassID, OUT ULONG_PTR *pulIdent, OUT PVOID *ppData);
BOOL bLinkedListGetNextElement  (IN struct _LINKEDLISTHEAD *pAnchor, IN LL_CLASS_ID ClassID, OUT ULONG_PTR *pulIdent, OUT PVOID *ppData);
BOOL bLinkedListGetLastElement  (IN struct _LINKEDLISTHEAD *pAnchor, IN LL_CLASS_ID ClassID, OUT ULONG_PTR *pulIdent, OUT PVOID *ppData);
BOOL bLinkedListGetPrevElement  (IN struct _LINKEDLISTHEAD *pAnchor, IN LL_CLASS_ID ClassID, OUT ULONG_PTR *pulIdent, OUT PVOID *ppData);
BOOL bLinkedListGetNewestElement(IN struct _LINKEDLISTHEAD *pAnchor, IN LL_CLASS_ID ClassID, OUT ULONG_PTR *pulIdent, OUT PVOID *ppData);
BOOL bLinkedListGetOldestElement(IN struct _LINKEDLISTHEAD *pAnchor, IN LL_CLASS_ID ClassID, OUT ULONG_PTR *pulIdent, OUT PVOID *ppData);
ULONG ulLinkedListGetCountOfElements(IN struct _LINKEDLISTHEAD *pAnchor, IN LL_CLASS_ID ClassID);

#endif // _LINKEDLIST_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\misc.c ===
//******************************Module*Header******************************\
//
// Module Name: misc.c
//
// Miscellaneous common routines.
//
// Copyright (c) 1992-1995 Microsoft Corporation
//
//*************************************************************************/

/**************************************************************************
 *                                                                        *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.          *
 *                                                                        *
 **************************************************************************/

#include "precomp.h"

/******************************Public*Routine******************************\
* BOOL bIntersect
*
* If 'prcl1' and 'prcl2' intersect, has a return value of TRUE and returns
* the intersection in 'prclResult'.  If they don't intersect, has a return
* value of FALSE, and 'prclResult' is undefined.
*
\**************************************************************************/

BOOL __fastcall bIntersect(
RECTL*  prcl1,
RECTL*  prcl2,
RECTL*  prclResult)
{
    prclResult->left  = max(prcl1->left,  prcl2->left);
    prclResult->right = min(prcl1->right, prcl2->right);

    if (prclResult->left < prclResult->right)
    {
        prclResult->top    = max(prcl1->top,    prcl2->top);
        prclResult->bottom = min(prcl1->bottom, prcl2->bottom);

        if (prclResult->top < prclResult->bottom)
        {
            return(TRUE);
        }
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* LONG cIntersect
*
* This routine takes a list of rectangles from 'prclIn' and clips them
* in-place to the rectangle 'prclClip'.  The input rectangles don't
* have to intersect 'prclClip'; the return value will reflect the
* number of input rectangles that did intersect, and the intersecting
* rectangles will be densely packed.
*
\**************************************************************************/

LONG cIntersect(
RECTL*  prclClip,
RECTL*  prclIn,         // List of rectangles
LONG    c)              // Can be zero
{
    LONG    cIntersections;
    RECTL*  prclOut;

    cIntersections = 0;
    prclOut        = prclIn;

    for (; c != 0; prclIn++, c--)
    {
        prclOut->left  = max(prclIn->left,  prclClip->left);
        prclOut->right = min(prclIn->right, prclClip->right);

        if (prclOut->left < prclOut->right)
        {
            prclOut->top    = max(prclIn->top,    prclClip->top);
            prclOut->bottom = min(prclIn->bottom, prclClip->bottom);

            if (prclOut->top < prclOut->bottom)
            {
                prclOut++;
                cIntersections++;
            }
        }
    }

    return(cIntersections);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\machdep.h ===
//******************************************************************************
//
// Module Name: machdep.h
//
// Macros to hide Win32/Win64 machine dependent code.
//
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1998 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/


#ifdef _WIN64

#define	NV_BREAKPOINT()                                                     \
{                                                                           \
    __break(0x80016);                                                       \
}

#define NV_EXCHANGE(lock, key)                                              \
{                                                                           \
    key = _InterlockedExchange(lock, key);                                  \
}

#else // _WIN32

#define	NV_BREAKPOINT()                                                     \
{                                                                           \
    __asm int 3                                                             \
}

#define NV_EXCHANGE(lock, key)                                              \
{                                                                           \
    __asm mov  ebx, key                                                     \
    __asm mov  eax, (lock)                                                  \
    __asm xchg [eax], ebx                                                   \
    __asm mov  key, ebx                                                     \
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\multi.c ===
/******************************Module*Header*******************************\
* Module Name: multi.c
*
* Supports multiple display boards as a single virtual desktop.
*
* This is implemented by presenting to GDI a single large virtual
* display and adding a layer between GDI and the driver's Drv functions.
* For the most part, the rest of the driver outside of multi.c doesn't
* have to change much, subject to the requirements below.
*
* This implementation requires that each board have the same virtual
* resolution and colour depth (e.g., all be running 1024x768x256), and
* that the boards be arranged in a rectangular configuration.
*
* Each board has its own PDEV, and completely manages its surface
* independently, down to glyph and bitmap caching.  The Mul
* routine intercepts the DDI call, and for each board dispatches
* a Drv call with the appropriate PDEV and clip object modifications.
*
* The following support in the main driver is required:
*
* 1) The driver should be able to handle a per-surface offset.  For
*    example, if two 1024x768 displays are pasted side-by-side, the
*    right board will get drawing operations in the range (1024, 768) -
*    (2048, 768).  The driver has a (-1024, 0) surface offset to convert
*    the actual drawing on the right board to the expected (0, 0) -
*    (1024, 768).
*
*    The current driver already uses this notion to support device-format
*    bitmaps drawn in off-screen memory.
*
*    Another option would be to handle the surface offsets in this layer,
*    but then all parameters including clip objects, paths and glyph
*    enumerations would have to be adjusted here as well.
*
* 2) The main driver must be able to share realized pattern information
*    between board instances.  That is, with the current DDI specification
*    GDI entirely handles brush memory allocation via pvAllocRBrush,
*    and the driver doesn't get notified when the brush is destroyed, so
*    the driver has to keep all information about the brush for all the
*    boards in the one brush realization.  This isn't too onerous.
*
* Problems:
*
* 1) DrvSetPointerShape requires that support be consistent between all
*    board instances -- for example, one board instance cannot accept
*    a h/w cursor and the other fail it, because GDI doesn't know it would
*    have to simulate on one area of the screen and not the other.
*
* 2) CompatibleBitmaps would have to be shared between board instances.
*    This becomes a problem when the bitmaps are kept by the driver in off-
*    screen memory.
*
* Status:
*
*    This code is officially untested.  However, I know of no outstanding
*    bugs -- everything seems to just work.
*
*    Note that I haven't addressed any initialization issues; to adapt this
*    code, you will need to solve some of those problems (such as proper
*    miniport support, and a nice method for the user to control the board
*    configurations and geometry).
*
* Disclaimer:
*
*    This code is provided as sample code only.  It is not intended to
*    represent Microsoft's endorsed solution for multiple screen support.
*
* Copyright (c) 1993-1996 Microsoft Corporation
\**************************************************************************/

/***************************************************************************
 *                                                                         *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.           *
 *                                                                         *
 ***************************************************************************/

#include "precomp.h"

#if MULTI_BOARDS

// We change the active board to the home board after every drawing
// operation.  We do this only because the Metheus BIOS does not reset
// the active board on a soft-reset, and so the initial POST text
// would come up on whatever happened to be the last board drawn to.

#define GO_HOME(pmdev)       vSelectBoard(pmdev, pmdev->pmbHome)
#define GO_BOARD(pmdev, pmb) vSelectBoard(pmdev, pmb)

struct _MULTI_BOARD;

typedef struct _MULTI_BOARD MULTI_BOARD;    /* mb */

struct _MULTI_BOARD
{
    LONG            iHwBoard;       // Hardware board number
    LONG            iBoard;         // Sequentially allocated board number
    RECTL           rcl;            // Board's coordinates
    MULTI_BOARD*    pmbNext;        // For traversing the entire list of boards
    MULTI_BOARD*    pmbLeft;        // For traversing by direction
    MULTI_BOARD*    pmbUp;
    MULTI_BOARD*    pmbRight;
    MULTI_BOARD*    pmbDown;

    PDEV*           ppdev;          // Pointer to the board's PDEV
    SURFOBJ*        pso;            // Surface representing the board
    HSURF           hsurf;          // Handle to surface
};                                          /* mb, pmb */

typedef struct _MDEV
{
    MULTI_BOARD*    pmb;            // Where to start enumerating
    MULTI_BOARD*    pmbHome;        // Board used for full-screen
    MULTI_BOARD*    pmbUpperLeft;   // Board in upper-left corner
    MULTI_BOARD*    pmbUpperRight;
    MULTI_BOARD*    pmbLowerLeft;
    MULTI_BOARD*    pmbLowerRight;
    LONG            cxBoards;       // Number of boards per row
    LONG            cyBoards;       // Number of boards per column
    LONG            cBoards;        // Total number of boards

    MULTI_BOARD*    pmbPointer;     // Board where cursor is currently visible
    MULTI_BOARD*    pmbCurrent;     // Currently selected board (needed for
                                    //   DrvRealizeBrush)
    HDEV            hdev;           // Handle that GDI knows us by
    HSURF           hsurf;          // Handle to our virtual surface
    CLIPOBJ*        pco;            // A temporary CLIPOBJ that we can modify
    ULONG           iBitmapFormat;  // Current colour depth
    FLONG           flHooks;        // Those functions that the main driver
                                    //   is hooking

} MDEV;                                     /* mdev, pmdev */

typedef struct _PVCONSUMER
{
    PVOID       pvConsumer;
} PVCONSUMER;

typedef struct _FONT_CONSUMER
{
    LONG        cConsumers;         // Total number of boards
    PVCONSUMER  apvc[MAX_BOARDS];   // Array of structures cConsumers in length
} FONT_CONSUMER;                            /* fc, pfc */

typedef struct _BITBLTDATA
{
    RECTL       rclBounds;
    MDEV*       pmdev;

    SURFOBJ*    psoDst;
    SURFOBJ*    psoSrc;
    SURFOBJ*    psoMask;
    CLIPOBJ*    pco;
    XLATEOBJ*   pxlo;
    RECTL*      prclDst;
    POINTL*     pptlSrc;
    POINTL*     pptlMask;
    BRUSHOBJ*   pbo;
    POINTL*     pptlBrush;
    ROP4        rop4;
} BITBLTDATA;                               /* bb, pbb */

/******************************Public*Routine******************************\
* bFindBoard
*
* Returns in ppmb a pointer to the board containing the upper-left
* corner of prcl.
*
* Returns TRUE if prcl is entirely containing on one board; FALSE if
* prcl spans multiple boards.
*
\**************************************************************************/

BOOL bFindBoard(MDEV* pmdev, RECTL* prcl, MULTI_BOARD** ppmb)
{
    MULTI_BOARD* pmb;

    pmb = pmdev->pmbUpperLeft;

    // It should never happen that GDI will give us a call whose bounds
    // don't intersect the virtual screen.  But so that we don't crash
    // should it ever happen, we'll return an intersection with the first
    // board -- we can assume GDI at least said the clipping was non-
    // trivial, in which case that board's display routine will realize
    // nothing had to be done:

    *ppmb = pmb;

    // First find the row:

    while (prcl->top >= pmb->rcl.bottom)
    {
        pmb = pmb->pmbDown;
        if (pmb == NULL)
            return(FALSE);      // This is a case where the bounds doesn't
                                //  intercept the virtual screen
    }

    // Now find the column:

    while (prcl->left >= pmb->rcl.right)
    {
        pmb = pmb->pmbRight;
        if (pmb == NULL)
            return(FALSE);      // This is a case where the bounds doesn't
                                //  intercept the virtual screen
    }

    // So we found the first board:

    *ppmb = pmb;

    return(prcl->right  <= pmb->rcl.right &&
           prcl->bottom <= pmb->rcl.bottom);
}

/******************************Public*Routine******************************\
* bNextBoard
*
* Returns in ppmb a pointer to the next board after intersecting prcl, going
* left-to-right then top-to-bottom.
*
* Returns TRUE if all boards intersecting prcl have been enumerated; FALSE
* if there are more boards.
*
\**************************************************************************/

BOOL bNextBoard(RECTL* prcl, MULTI_BOARD** ppmb)
{
    MULTI_BOARD* pmb;

    pmb = *ppmb;

    // We'll do all the boards in a row first, remembering that the
    // bounds rectangle can extend past the end of our virtual screen:

    if ((prcl->right > pmb->rcl.right) && (pmb->pmbRight != NULL))
    {
        *ppmb = pmb->pmbRight;
        return(TRUE);
    }

    // Go to next row if need be, starting at the rcl.left:

    if ((prcl->bottom > pmb->rcl.bottom) && (pmb->pmbDown != NULL))
    {
        pmb = pmb->pmbDown;
        while ((prcl->left < pmb->rcl.left) && (pmb->pmbLeft != NULL))
        {
            pmb = pmb->pmbLeft;
        }
        *ppmb = pmb;
        return(TRUE);
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* vIntersect
*
* Returns in prclOut the intersection of rectangles prcl1 and prcl2.
*
\**************************************************************************/

VOID vIntersect(RECTL* prcl1, RECTL* prcl2, RECTL* prclOut)
{
    prclOut->left   = max(prcl1->left,   prcl2->left);
    prclOut->top    = max(prcl1->top,    prcl2->top);
    prclOut->right  = min(prcl1->right,  prcl2->right);
    prclOut->bottom = min(prcl1->bottom, prcl2->bottom);
}

/******************************Public*Routine******************************\
* bVeryTemporaryInitializationCode
*
\**************************************************************************/

BOOL bVeryTemporaryInitializationCode(MDEV* pmdev)
{
    MULTI_BOARD* pmb1 = NULL;
    MULTI_BOARD* pmb2 = NULL;

    pmb1 = EngAllocMem(FL_ZERO_MEMORY, sizeof(MULTI_BOARD), ALLOC_TAG);
    pmb2 = EngAllocMem(FL_ZERO_MEMORY, sizeof(MULTI_BOARD), ALLOC_TAG);

    if ((pmb1 == NULL) || (pmb2 == NULL))
    {
        EngFreeMem(pmb1);
        EngFreeMem(pmb2);
        return(FALSE);
    }

    // Only this initialization part is hard-coded to have two monitors,
    // side-by-side.

    // Board one:

    pmb1->iHwBoard         = 0;
    pmb1->iBoard           = 0;
    pmb1->pmbNext          = pmb2;
    pmb1->pmbRight         = pmb2;

    pmdev->pmb             = pmb1;
    pmdev->pmbUpperLeft    = pmb1;
    pmdev->pmbLowerLeft    = pmb1;
    pmdev->pmbHome         = pmb1;

    // Board two:

    pmb2->iHwBoard         = 1;
    pmb2->iBoard           = 1;
    pmb2->pmbLeft          = pmb1;

    pmdev->pmbUpperRight   = pmb2;
    pmdev->pmbLowerRight   = pmb2;

    pmdev->cxBoards        = 2;
    pmdev->cyBoards        = 1;
    pmdev->cBoards         = 2;

    // Assume that the currently active board is the 'home' board:

    pmdev->pmbCurrent      = pmdev->pmbHome;

    return(TRUE);
}

/******************************Public*Routine******************************\
* vSelectBoard
*
* Selects board pmb for drawing.  We can have only one Metheus board active
* at any time, so we have to disable the old board before enabling the new.
*
* Obviously, your hardware implementation may not require this entire
* function.  For example, you probably won't have to do this if you can
* have each board's accelerator registers mapped into separate address
* spaces.  NOTE: You'll still have to set pmdev->pmbCurrent, however,
* for DrvRealizeBrush to work!
*
\**************************************************************************/

VOID vSelectBoard(MDEV* pmdev, MULTI_BOARD* pmb)
{
    LONG iOldHwBoard;

    ASSERTDD(pmdev->pmbCurrent != NULL, "Can't have NULL pmbCurrent");
    pmdev->pmbCurrent = pmb;                             // Remember new board
}

/******************************Public*Routine******************************\
* bBoardCopy
*
* Given the BitBlt parameters in pbb, bitblt's the part of the rectangle
* on the pmbSrc board that must bitblt'ed to the pmbDst board.  Bails
* out quickly if nothing actually has to be copied.
*
* Will do a screen-to-screen blt if pmbSrc and pmbDst are the same board;
* otherwise it uses the psoTmp bitmap as temporary storage for transferring
* between the two boards.
*
* NOTE: If your hardware allows you to have all the frame buffers mapped
*       into memory simultaneously, you can avoid the 'psoTmp' bitmap
*       allocation and extra copy!
*
\**************************************************************************/

BOOL bBoardCopy(
BITBLTDATA*  pbb,
SURFOBJ*     psoTmp,
MULTI_BOARD* pmbDst,
MULTI_BOARD* pmbSrc)
{
    BOOL     b;
    RECTL    rclDst;
    LONG     dx;
    LONG     dy;
    RECTL    rclTmp;
    POINTL   ptlSrc;

    // If there's really no source board, we're guaranteed not to
    // have to copy anything from it:

    if (pmbSrc == NULL)
        return(TRUE);

    dx = pbb->prclDst->left - pbb->pptlSrc->x;
    dy = pbb->prclDst->top  - pbb->pptlSrc->y;

    // Pretend we're going to copy the entire source board's screen.
    // rclDst would be the destination rectangle:

    rclDst.left   = pmbSrc->rcl.left   + dx;
    rclDst.right  = pmbSrc->rcl.right  + dx;
    rclDst.top    = pmbSrc->rcl.top    + dy;
    rclDst.bottom = pmbSrc->rcl.bottom + dy;

    // We really want to copy only the part that overlaps the
    // destination board's screen:

    vIntersect(&pmbDst->rcl, &rclDst, &rclDst);

    // Plus we really only want to copy anything to what is contained
    // in the original destination rectangle:

    vIntersect(&pbb->rclBounds, &rclDst, &rclDst);

    // rclDst is now the destination rectangle for our call.  We'll
    // need a temporary bitmap for copying, so compute its extents:

    rclTmp.left   = 0;
    rclTmp.top    = 0;
    rclTmp.right  = rclDst.right  - rclDst.left;
    rclTmp.bottom = rclDst.bottom - rclDst.top;

    // If it's empty, we're outta here:

    if ((rclTmp.right <= 0) || (rclTmp.bottom <= 0))
        return(TRUE);

    if (pmbDst == pmbSrc)
    {
        // If the source and destination are the same board, we don't
        // need a temporary bitmap:

        psoTmp = pmbSrc->pso;
        ptlSrc = *pbb->pptlSrc;
    }
    else
    {
        ASSERTDD(psoTmp != NULL, "Need non-null bitmap");
        ASSERTDD(psoTmp->sizlBitmap.cx >= rclTmp.right, "Bitmap too small in x");
        ASSERTDD(psoTmp->sizlBitmap.cy >= rclTmp.bottom, "Bitmap too small in y");

        // Figure out the upper-left source corner corresponding to our
        // upper-left destination corner:

        ptlSrc.x = rclDst.left - dx;
        ptlSrc.y = rclDst.top  - dy;

        // Copy the rectangle from the source to the temporary bitmap:

        GO_BOARD(pbb->pmdev, pmbSrc);
        b = DrvCopyBits(psoTmp, pmbSrc->pso, NULL, NULL, &rclTmp, &ptlSrc);

        // Then get ready to do the copy from the temporary bitmap to
        // the destination:

        ptlSrc.x = pbb->prclDst->left - rclDst.left;
        ptlSrc.y = pbb->prclDst->top  - rclDst.top;
    }

    pbb->pco->rclBounds = rclDst;
    GO_BOARD(pbb->pmdev, pmbDst);
    b &= DrvBitBlt(pmbDst->pso, psoTmp, pbb->psoMask, pbb->pco, pbb->pxlo,
                   pbb->prclDst, &ptlSrc, pbb->pptlMask, pbb->pbo,
                   pbb->pptlBrush, pbb->rop4);

    return(b);
}

/******************************Public*Routine******************************\
* bBitBltBetweenBoards
*
* Handles screen-to-screen blts across multiple boards.
*
\**************************************************************************/

BOOL bBitBltBetweenBoards(
SURFOBJ*     psoDst,
SURFOBJ*     psoSrc,
SURFOBJ*     psoMask,
CLIPOBJ*     pco,
XLATEOBJ*    pxlo,
RECTL*       prclDst,
POINTL*      pptlSrc,
POINTL*      pptlMask,
BRUSHOBJ*    pbo,
POINTL*      pptlBrush,
ROP4         rop4,
RECTL*       prclUnion,     // Rectangular union of source and destination
MULTI_BOARD* pmbUnion)      // Board containing upper-left corner of prclUnion
{
    BOOL         b = TRUE;
    BITBLTDATA   bb;
    RECTL        rclOriginalBounds;
    SIZEL        sizlBoard;
    SIZEL        sizlDst;
    SIZEL        sizl;
    MULTI_BOARD* pmbSrc;
    MULTI_BOARD* pmbDst;
    LONG         dx;
    LONG         dy;
    RECTL        rclStart;

    SURFOBJ*     pso0 = NULL;   // Initialize these first off in case we
    SURFOBJ*     pso1 = NULL;   //   early-out
    SURFOBJ*     pso2 = NULL;
    SURFOBJ*     pso3 = NULL;
    HSURF        hsurf0 = 0;
    HSURF        hsurf1 = 0;

    bb.pmdev     = (MDEV*) psoDst->dhpdev;
    bb.psoDst    = psoDst;
    bb.psoSrc    = psoSrc;
    bb.psoMask   = psoMask;
    bb.pxlo      = pxlo;
    bb.prclDst   = prclDst;
    bb.pptlSrc   = pptlSrc;
    bb.pptlMask  = pptlMask;
    bb.pbo       = pbo;
    bb.pptlBrush = pptlBrush;
    bb.rop4      = rop4;
    bb.pco       = pco;
    if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
        bb.pco = bb.pmdev->pco;

    vIntersect(&bb.pco->rclBounds, prclDst, &bb.rclBounds);
    rclOriginalBounds = bb.pco->rclBounds;

    sizlDst.cx = bb.rclBounds.right - bb.rclBounds.left;
    sizlDst.cy = bb.rclBounds.bottom - bb.rclBounds.top;

    // This really should never happen, but we'll be paranoid:

    if ((sizlDst.cx <= 0) || (sizlDst.cy <= 0))
        return(TRUE);

    // Compute delta from source to destination:

    dx = prclDst->left - pptlSrc->x;
    dy = prclDst->top  - pptlSrc->y;

    // Figure out the size of a board:

    sizlBoard.cx = bb.pmdev->pmbUpperLeft->rcl.right;
    sizlBoard.cy = bb.pmdev->pmbUpperLeft->rcl.bottom;

    // We use temporary bitmaps as intermediaries for copying from one
    // board to another.  Note that it is much more efficient to allocate
    // on the fly, rather than keeping a dedicated bitmap around that
    // would have to be swapped in and out.

    // When the destination is close to the source, we can accomplish
    // most of the blt using screen-to-screen copies, and will need
    // only two small temporary bitmaps to temporarily hold the bits
    // that must be transferred from one board to another:

    if ((abs(dx) < (sizlBoard.cx >> 1)) && (abs(dy) < (sizlBoard.cy >> 1)))
    {
        // Create a temporary bitmap for the horizontal delta only if
        // the blt actually spans boards in the x-direction:

        if ((dx != 0) && (prclUnion->right > pmbUnion->rcl.right))
        {
            sizl.cx = min(sizlDst.cx, abs(dx));
            sizl.cy = min(sizlDst.cy, sizlBoard.cy - abs(dy));

            hsurf0 = (HSURF) EngCreateBitmap(sizl, 0, bb.pmdev->iBitmapFormat,
                                             0, NULL);
            pso1 = EngLockSurface(hsurf0);
            if (pso1 == NULL)
                return(FALSE);

            // Can use same temporary bitmap for section '3':

            pso3 = pso1;
        }

        // Similarly for the vertical delta:

        if ((dy != 0) && (prclUnion->bottom > pmbUnion->rcl.bottom))
        {
            sizl.cx = min(sizlDst.cx, sizlBoard.cx - abs(dx));
            sizl.cy = min(sizlDst.cy, abs(dy));

            hsurf1 = (HSURF) EngCreateBitmap(sizl, 0, bb.pmdev->iBitmapFormat,
                                             0, NULL);
            pso2 = EngLockSurface(hsurf1);
            if (pso2 == NULL)
            {
                b = FALSE;
                goto OuttaHere;
            }
        }
    }
    else
    {
        // Make the bitmap the size of a board, or the size of the
        // destination rectangle, which ever is smaller:

        sizl.cx = min(sizlDst.cx, sizlBoard.cx);
        sizl.cy = min(sizlDst.cy, sizlBoard.cy);

        hsurf0 = (HSURF) EngCreateBitmap(sizl, 0, bb.pmdev->iBitmapFormat,
                                         0, NULL);
        pso0 = EngLockSurface(hsurf0);
        if (pso0 == NULL)
            return(FALSE);

        pso1 = pso0;
        pso2 = pso0;
        pso3 = pso0;
    }

    if ((dx <= 0) && (dy <= 0))
    {
        // Move the rectangle up and to the left:

        // Find the board containing the upper-left corner of the destination:

        pmbDst = bb.pmdev->pmbUpperLeft;
        while (pmbDst->rcl.right <= bb.rclBounds.left)
            pmbDst = pmbDst->pmbRight;
        while (pmbDst->rcl.bottom <= bb.rclBounds.top)
            pmbDst = pmbDst->pmbDown;

        // Find the upper-left of the four source boards' rectangles which
        // can potentially overlap our destination board's rectangle:

        rclStart.left = pmbDst->rcl.left - dx;
        rclStart.top  = pmbDst->rcl.top  - dy;

        pmbSrc = pmbDst;
        while (pmbSrc->rcl.right <= rclStart.left)
            pmbSrc = pmbSrc->pmbRight;
        while (pmbSrc->rcl.bottom <= rclStart.top)
            pmbSrc = pmbSrc->pmbDown;

        while (TRUE)
        {
            b &= bBoardCopy(&bb, pso0, pmbDst, pmbSrc);
            b &= bBoardCopy(&bb, pso1, pmbDst, pmbSrc->pmbRight);
            b &= bBoardCopy(&bb, pso2, pmbDst, pmbSrc->pmbDown);
            if (pmbSrc->pmbDown != NULL)
                b &= bBoardCopy(&bb, pso3, pmbDst, pmbSrc->pmbDown->pmbRight);

            if (pmbDst->rcl.right < bb.rclBounds.right)
            {
                // Move right in the row of boards:

                pmbDst = pmbDst->pmbRight;
                pmbSrc = pmbSrc->pmbRight;
            }
            else
            {
                // We may be all done:

                if (pmbDst->rcl.bottom >= bb.rclBounds.bottom)
                    break;

                // Nope, have to go down to left side of next lower row:

                while (pmbDst->rcl.left > bb.rclBounds.left)
                {
                    pmbDst = pmbDst->pmbLeft;
                    pmbSrc = pmbSrc->pmbLeft;
                }

                pmbDst = pmbDst->pmbDown;
                pmbSrc = pmbSrc->pmbDown;
            }
        }
    }
    else if ((dx >= 0) && (dy >= 0))
    {
        // Move the rectangle down and to the right:

        // Find the board containing the lower-right corner of the destination:

        pmbDst = bb.pmdev->pmbLowerRight;
        while (pmbDst->rcl.left >= bb.rclBounds.right)
            pmbDst = pmbDst->pmbLeft;
        while (pmbDst->rcl.top >= bb.rclBounds.bottom)
            pmbDst = pmbDst->pmbUp;

        // Find the lower-right of the four source boards' rectangles which
        // can potentially overlap our destination board's rectangle:

        rclStart.right = pmbDst->rcl.right - dx;
        rclStart.bottom = pmbDst->rcl.bottom - dy;

        pmbSrc = pmbDst;
        while (pmbSrc->rcl.left >= rclStart.right)
            pmbSrc = pmbSrc->pmbLeft;
        while (pmbSrc->rcl.top >= rclStart.bottom)
            pmbSrc = pmbSrc->pmbUp;

        while (TRUE)
        {
            b &= bBoardCopy(&bb, pso0, pmbDst, pmbSrc);
            b &= bBoardCopy(&bb, pso1, pmbDst, pmbSrc->pmbLeft);
            b &= bBoardCopy(&bb, pso2, pmbDst, pmbSrc->pmbUp);
            if (pmbSrc->pmbUp != NULL)
                b &= bBoardCopy(&bb, pso3, pmbDst, pmbSrc->pmbUp->pmbLeft);

            if (pmbDst->rcl.left > bb.rclBounds.left)
            {
                // Move left in the row of boards:

                pmbDst = pmbDst->pmbLeft;
                pmbSrc = pmbSrc->pmbLeft;
            }
            else
            {
                // We may be all done:

                if (pmbDst->rcl.top <= bb.rclBounds.top)
                    break;

                // Nope, have to go up to right side of next upper row:

                while (pmbDst->rcl.right < bb.rclBounds.right)
                {
                    pmbDst = pmbDst->pmbRight;
                    pmbSrc = pmbSrc->pmbRight;
                }

                pmbDst = pmbDst->pmbUp;
                pmbSrc = pmbSrc->pmbUp;
            }
        }
    }
    else if ((dx >= 0) && (dy <= 0))
    {
        // Move the rectangle up and to the right:

        // Find the board containing the upper-right corner of the destination:

        pmbDst = bb.pmdev->pmbUpperRight;
        while (pmbDst->rcl.left >= bb.rclBounds.right)
            pmbDst = pmbDst->pmbLeft;
        while (pmbDst->rcl.bottom <= bb.rclBounds.top)
            pmbDst = pmbDst->pmbDown;

        // Find the upper-right of the four source boards' rectangles which
        // can potentially overlap our destination board's rectangle:

        rclStart.right = pmbDst->rcl.right - dx;
        rclStart.top   = pmbDst->rcl.top   - dy;

        pmbSrc = pmbDst;
        while (pmbSrc->rcl.left >= rclStart.right)
            pmbSrc = pmbSrc->pmbLeft;
        while (pmbSrc->rcl.bottom <= rclStart.top)
            pmbSrc = pmbSrc->pmbDown;

        while (TRUE)
        {
            b &= bBoardCopy(&bb, pso0, pmbDst, pmbSrc);
            b &= bBoardCopy(&bb, pso1, pmbDst, pmbSrc->pmbLeft);
            b &= bBoardCopy(&bb, pso2, pmbDst, pmbSrc->pmbDown);
            if (pmbSrc->pmbDown != NULL)
                b &= bBoardCopy(&bb, pso3, pmbDst, pmbSrc->pmbDown->pmbLeft);

            if (pmbDst->rcl.left > bb.rclBounds.left)
            {
                // Move left in the row of boards:

                pmbDst = pmbDst->pmbLeft;
                pmbSrc = pmbSrc->pmbLeft;
            }
            else
            {
                // We may be all done:

                if (pmbDst->rcl.bottom >= bb.rclBounds.bottom)
                    break;

                // Nope, have to go down to right side of next lower row:

                while (pmbDst->rcl.right < bb.rclBounds.right)
                {
                    pmbDst = pmbDst->pmbRight;
                    pmbSrc = pmbSrc->pmbRight;
                }

                pmbDst = pmbDst->pmbDown;
                pmbSrc = pmbSrc->pmbDown;
            }
        }
    }
    else
    {
        // Move the rectangle down and to the left:

        // Find the board containing the lower-left corner of the destination:

        pmbDst = bb.pmdev->pmbLowerLeft;
        while (pmbDst->rcl.right <= bb.rclBounds.left)
            pmbDst = pmbDst->pmbRight;
        while (pmbDst->rcl.top >= bb.rclBounds.bottom)
            pmbDst = pmbDst->pmbUp;

        // Find the lower-left of the four source boards' rectangles which
        // can potentially overlap our destination board's rectangle:

        rclStart.left   = pmbDst->rcl.left   - dx;
        rclStart.bottom = pmbDst->rcl.bottom - dy;

        pmbSrc = pmbDst;
        while (pmbSrc->rcl.right <= rclStart.left)
            pmbSrc = pmbSrc->pmbRight;
        while (pmbSrc->rcl.top >= rclStart.bottom)
            pmbSrc = pmbSrc->pmbUp;

        while (TRUE)
        {
            b &= bBoardCopy(&bb, pso0, pmbDst, pmbSrc);
            b &= bBoardCopy(&bb, pso1, pmbDst, pmbSrc->pmbRight);
            b &= bBoardCopy(&bb, pso2, pmbDst, pmbSrc->pmbUp);
            if (pmbSrc->pmbUp != NULL)
                b &= bBoardCopy(&bb, pso3, pmbDst, pmbSrc->pmbUp->pmbRight);

            if (pmbDst->rcl.right < bb.rclBounds.right)
            {
                // Move right in the row of boards:

                pmbDst = pmbDst->pmbRight;
                pmbSrc = pmbSrc->pmbRight;
            }
            else
            {
                // We may be all done:

                if (pmbDst->rcl.top <= bb.rclBounds.top)
                    break;

                // Nope, have to up down to left side of next upper row:

                while (pmbDst->rcl.left > bb.rclBounds.left)
                {
                    pmbDst = pmbDst->pmbLeft;
                    pmbSrc = pmbSrc->pmbLeft;
                }

                pmbDst = pmbDst->pmbUp;
                pmbSrc = pmbSrc->pmbUp;
            }
        }
    }

    GO_HOME(bb.pmdev);
    bb.pco->rclBounds = rclOriginalBounds;

OuttaHere:

    // In one case, pso0 == pso1 == pso2 == pso3, and we don't want to
    // unlock the same surface twice:

    if (pso1 != pso2)
        EngUnlockSurface(pso1);

    EngUnlockSurface(pso2);
    EngDeleteSurface(hsurf0);
    EngDeleteSurface(hsurf1);

    return(b);
}

/******************************Public*Routine******************************\
* MulGetModes
*
\**************************************************************************/

ULONG MulGetModes(
HANDLE    hDriver,
ULONG     cjSize,
DEVMODEW* pdm)
{
    ULONG ulRet;

    DISPDBG((5, ">> MulGetModes"));
    ulRet = DrvGetModes(hDriver, cjSize, pdm);
    DISPDBG((6, "<< MulGetModes"));

    return(ulRet);
}

/******************************Public*Routine******************************\
* MulEnablePDEV
*
\**************************************************************************/

DHPDEV MulEnablePDEV(
DEVMODEW* pDevmode,
PWSTR     pwszLogAddress,
ULONG     cPatterns,
HSURF*    ahsurfPatterns,
ULONG     cjGdiInfo,
ULONG*    pGdiInfo,
ULONG     cjDevInfo,
DEVINFO*  pDevInfo,
HDEV      hdev,
PWSTR     pwszDeviceName,
HANDLE    hDriver)
{
    MDEV*        pmdev;                // Multi-board PDEV
    PDEV*        ppdev;                // Per-board PDEV
    MULTI_BOARD* pmb;
    LONG         cx;
    LONG         cy;

    // Note that we depend on the zero initialization:

    DISPDBG((5, ">> MulEnablePDEV"));

    pmdev = EngAllocMem(FL_ZERO_MEMORY, sizeof(MDEV), ALLOC_TAG);
    if (pmdev == NULL)
        goto ReturnFailure0;

    if (!bVeryTemporaryInitializationCode(pmdev))
        goto ReturnFailure1;

    // For every board, we'll create our own PDEV and surface:

    for (pmb = pmdev->pmb; pmb != NULL; pmb = pmb->pmbNext)
    {
        // Initialize each board and create a surface to go with it:

        ppdev = (PDEV*) DrvEnablePDEV(pDevmode,     pwszLogAddress,
                                      cPatterns,    ahsurfPatterns,
                                      cjGdiInfo,    pGdiInfo,
                                      cjDevInfo,    pDevInfo,
                                      hdev,         pwszDeviceName,
                                      hDriver);
        if (ppdev == NULL)
            goto ReturnFailure1;

        pmb->ppdev = ppdev;
    }

    // Choose a board, any board:

    pmb = pmdev->pmbLowerLeft;

    // Get a copy of what functions we're supposed to hook, sans
    // HOOK_STRETCHBLT because I can't be bothered to write its
    // MulStretchBlt function:

    pmdev->flHooks       = pmb->ppdev->flHooks & ~HOOK_STRETCHBLT;
    pmdev->iBitmapFormat = pmb->ppdev->iBitmapFormat;

    // As part of our hard-coded initialization hack, we will simply
    // take whatever resolution was requested via the Control Panel
    // and create a two board virtual desktop, where the screens are
    // side-by-side.
    //
    // The DrvEnablePDEV function for any board has already figured
    // out what the requested mode was:

    cx = ((GDIINFO*) pGdiInfo)->ulHorzRes;
    cy = ((GDIINFO*) pGdiInfo)->ulVertRes;

    // Set up bounds for left board:

    pmb->rcl.left       = 0;
    pmb->rcl.top        = 0;
    pmb->rcl.right      = cx;
    pmb->rcl.bottom     = cy;

    // Set up bounds for right board:

    pmb = pmb->pmbRight;

    pmb->rcl.left       = cx;
    pmb->rcl.top        = 0;
    pmb->rcl.right      = 2 * cx;
    pmb->rcl.bottom     = cy;

    // Adjust the stuff we return back to GDI to reflect the fact that
    // we now have a double-wide display:

    ((GDIINFO*) pGdiInfo)->ulPanningHorzRes  *= 2;
    ((GDIINFO*) pGdiInfo)->ulHorzSize        *= 2;

    // With the Metheus board, since only one board can be mapped in
    // at one time, we cannot allow asynchronous pointers:

    pDevInfo->flGraphicsCaps &= ~(GCAPS_ASYNCMOVE | GCAPS_ASYNCCHANGE);
    DISPDBG((6, "<< MulEnablePDEV: Line: %d", __LINE__));

    return((DHPDEV) pmdev);

ReturnFailure1:
    MulDisablePDEV((DHPDEV) pmdev);

ReturnFailure0:
    DISPDBG((2, "Failed MulEnablePDEV"));
    DISPDBG((6, "<< MulEnablePDEV: Line: %d", __LINE__));

    return(0);
}

/******************************Public*Routine******************************\
* MulCompletePDEV
*
\**************************************************************************/

VOID MulCompletePDEV(
DHPDEV dhpdev,
HDEV   hdev)
{
    MDEV*         pmdev;
    MULTI_BOARD*  pmb;

    DISPDBG((5, ">> MulCompletePDEV"));
    pmdev = (MDEV*) dhpdev;
    pmdev->hdev = hdev;

    for (pmb = pmdev->pmb; pmb != NULL; pmb = pmb->pmbNext)
    {
        GO_BOARD(pmdev, pmb);
        DrvCompletePDEV((DHPDEV) pmb->ppdev, hdev);
    }
    DISPDBG((6, "<< MulCompletePDEV"));
}

/******************************Public*Routine******************************\
* MulEnableSurface
*
\**************************************************************************/

HSURF MulEnableSurface(DHPDEV dhpdev)
{
    MDEV*         pmdev;
    MULTI_BOARD*  pmb;
    SIZEL         sizlVirtual;
    HSURF         hsurfBoard;               // Gnarly, dude!
    SURFOBJ*      psoBoard;
    DSURF*        pdsurfBoard;
    HSURF         hsurfVirtual;
    CLIPOBJ*      pco;

    DISPDBG((5, ">> MulEnableSurface"));
    pmdev = (MDEV*) dhpdev;
    for (pmb = pmdev->pmb; pmb != NULL; pmb = pmb->pmbNext)
    {
        GO_BOARD(pmdev, pmb);

        hsurfBoard = DrvEnableSurface((DHPDEV) pmb->ppdev);
        if (hsurfBoard == 0)
            goto ReturnFailure;

        pmb->hsurf = hsurfBoard;

        // Every time we draw on a particular board, we'll refer to it
        // using this surface:

        psoBoard = EngLockSurface(hsurfBoard);
        if (psoBoard == NULL)
            goto ReturnFailure;

        pmb->pso = psoBoard;

        // There are a few things in the board's data instances that we
        // have to modify:

        pdsurfBoard = (DSURF*) psoBoard->dhsurf;

        pmb->ppdev->iBoard  =  pmb->iBoard;

        // This is sort of a hack.  Whenever we pass a call on to a board's
        // Drv function using 'pmb->pso', it has to be able to retrieve
        // it's own PDEV pointer from 'dhpdev':

        pmb->pso->dhpdev = (DHPDEV) pmb->ppdev;
    }

    // Now create the surface which the engine will use to refer to our
    // entire multi-board virtual screen:

    sizlVirtual.cx = pmdev->pmbLowerRight->rcl.right;
    sizlVirtual.cy = pmdev->pmbLowerRight->rcl.bottom;

    hsurfVirtual = EngCreateDeviceSurface((DHSURF) pmdev, sizlVirtual,
                                          pmdev->iBitmapFormat);
    if (hsurfVirtual == 0)
        goto ReturnFailure;

    pmdev->hsurf = hsurfVirtual;

    if (!EngAssociateSurface(hsurfVirtual, pmdev->hdev, pmdev->flHooks))
        goto ReturnFailure;

    // Create a temporary clip object that we can use when a drawing
    // operation spans multiple boards:

    pco = EngCreateClip();
    if (pco == NULL)
        goto ReturnFailure;

    pmdev->pco = pco;

    pmdev->pco->iDComplexity      = DC_RECT;
    pmdev->pco->iMode             = TC_RECTANGLES;
    pmdev->pco->rclBounds.left    = 0;
    pmdev->pco->rclBounds.top     = 0;
    pmdev->pco->rclBounds.right   = pmdev->pmbLowerRight->rcl.right;
    pmdev->pco->rclBounds.bottom  = pmdev->pmbLowerRight->rcl.bottom;

    DISPDBG((6, "<< MulDisableSurface: Line: %d", __LINE__));
    return(hsurfVirtual);

ReturnFailure:
    MulDisableSurface((DHPDEV) pmdev);

    DISPDBG((2, "Failed MulEnableSurface"));
    DISPDBG((6, "<< MulDisableSurface: Line: %d", __LINE__));
    return(0);
}

/******************************Public*Routine******************************\
* MulStrokePath
*
\**************************************************************************/

BOOL MulStrokePath(
SURFOBJ*   pso,
PATHOBJ*   ppo,
CLIPOBJ*   pco,
XFORMOBJ*  pxo,
BRUSHOBJ*  pbo,
POINTL*    pptlBrush,
LINEATTRS* pla,
MIX        mix)
{
    RECTFX       rcfxBounds;
    RECTL        rclBounds;
    MDEV*        pmdev;
    RECTL        rclOriginalBounds;
    MULTI_BOARD* pmb;
    BOOL         b;
    FLOAT_LONG   elStyleState;
    DISPDBG((5, ">> MulStrokePath"));

    // Get the path bounds and make it lower-right exclusive:

    PATHOBJ_vGetBounds(ppo, &rcfxBounds);

    rclBounds.left   = (rcfxBounds.xLeft   >> 4);
    rclBounds.top    = (rcfxBounds.yTop    >> 4);
    rclBounds.right  = (rcfxBounds.xRight  >> 4) + 2;
    rclBounds.bottom = (rcfxBounds.yBottom >> 4) + 2;

    pmdev = (MDEV*) pso->dhpdev;
    if (bFindBoard(pmdev, &rclBounds, &pmb))
    {
        GO_BOARD(pmdev, pmb);
        b = DrvStrokePath(pmb->pso, ppo, pco, pxo, pbo, pptlBrush, pla, mix);
    }
    else
    {
        if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
        {
            // If the CLIPOBJ doesn't have at least DC_RECT complexity,
            // substitute one that does:

            pco = pmdev->pco;
        }

        rclOriginalBounds = pco->rclBounds;
        elStyleState = pla->elStyleState;

        b = TRUE;
        do {
            // For each board, make sure the style state gets reset and
            // the path enumeration gets restarted:

            pla->elStyleState = elStyleState;
            PATHOBJ_vEnumStart(ppo);

            if (bIntersect(&rclOriginalBounds, &pmb->rcl, &pco->rclBounds))
            {
                GO_BOARD(pmdev, pmb);
                b &= DrvStrokePath(pmb->pso, ppo, pco, pxo, pbo, pptlBrush, pla,
                                   mix);
            }

        } while (bNextBoard(&rclBounds, &pmb));

        // Restore the original clip bounds:

        pco->rclBounds = rclOriginalBounds;
    }

    GO_HOME(pmdev);

    DISPDBG((6, "<< MulStrokePath: Line: %d", __LINE__));
    return(b);
}

/******************************Public*Routine******************************\
* MulFillPath
*
\**************************************************************************/

BOOL MulFillPath(
SURFOBJ*  pso,
PATHOBJ*  ppo,
CLIPOBJ*  pco,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
MIX       mix,
FLONG     flOptions)
{
    RECTFX       rcfxBounds;
    RECTL        rclBounds;
    MDEV*        pmdev;
    RECTL        rclOriginalBounds;
    MULTI_BOARD* pmb;
    BOOL         b;
    DISPDBG((5, ">> MulFillPath"));

    // Get the path bounds and make it lower-right exclusive:

    PATHOBJ_vGetBounds(ppo, &rcfxBounds);

    rclBounds.left   = (rcfxBounds.xLeft   >> 4);
    rclBounds.top    = (rcfxBounds.yTop    >> 4);
    rclBounds.right  = (rcfxBounds.xRight  >> 4) + 2;
    rclBounds.bottom = (rcfxBounds.yBottom >> 4) + 2;

    pmdev = (MDEV*) pso->dhpdev;
    if (bFindBoard(pmdev, &rclBounds, &pmb))
    {
        GO_BOARD(pmdev, pmb);
        b = DrvFillPath(pmb->pso, ppo, pco, pbo, pptlBrush, mix, flOptions);
    }
    else
    {
        if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
        {
            // If the CLIPOBJ doesn't have at least DC_RECT complexity,
            // substitute one that does:

            pco = pmdev->pco;
        }

        rclOriginalBounds = pco->rclBounds;

        b = TRUE;
        do {
            // Make sure we restart the path enumeration if need be:

            PATHOBJ_vEnumStart(ppo);
            if (bIntersect(&rclOriginalBounds, &pmb->rcl, &pco->rclBounds))
            {
                GO_BOARD(pmdev, pmb);
                b &= DrvFillPath(pmb->pso, ppo, pco, pbo, pptlBrush, mix,
                                 flOptions);
            }

        } while (bNextBoard(&rclBounds, &pmb));

        // Restore the original clip bounds:

        pco->rclBounds = rclOriginalBounds;
    }

    GO_HOME(pmdev);
    DISPDBG((6, "<< MulFillPath: Line: %d, ret: 0x%x", __LINE__, b));
    return(b);
}

/******************************Public*Routine******************************\
* MulBitBlt
*
\**************************************************************************/

BOOL MulBitBlt(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
SURFOBJ*  psoMask,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc,
POINTL*   pptlMask,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
ROP4      rop4)
{
    BOOL         bFromScreen;
    BOOL         bToScreen;
    MDEV*        pmdev;
    MULTI_BOARD* pmb;
    RECTL        rclOriginalBounds;
    BOOL         b;
    RECTL        rclBounds;
    LONG         xOffset;
    LONG         yOffset;
    RECTL        rclDstBounds;
    RECTL        rclDst;

    DISPDBG((5, ">> MulBitBlt"));

    bFromScreen = ((psoSrc != NULL) && (psoSrc->iType == STYPE_DEVICE));
    bToScreen   = ((psoDst != NULL) && (psoDst->iType == STYPE_DEVICE));

    // We copy the prclDst rectangle here because sometimes GDI will
    // simply point prclDst to the same rectangle in pco->rclBounds,
    // and we'll be mucking with pco->rclBounds...

    rclDst = *prclDst;

    if (bToScreen && bFromScreen)
    {
        ///////////////////////////////////////////////////////////////
        // Screen-to-screen
        ///////////////////////////////////////////////////////////////

        pmdev = (MDEV*) psoDst->dhpdev;

        // rclBounds is the union of the source and destination rectangles:

        rclBounds.left   = min(rclDst.left, pptlSrc->x);
        rclBounds.top    = min(rclDst.top,  pptlSrc->y);
        rclBounds.right  = max(rclDst.right,
                               pptlSrc->x + (rclDst.right - rclDst.left));
        rclBounds.bottom = max(rclDst.bottom,
                               pptlSrc->y + (rclDst.bottom - rclDst.top));

        if (bFindBoard(pmdev, &rclBounds, &pmb))
        {
            GO_BOARD(pmdev, pmb);
            b = DrvBitBlt(pmb->pso, pmb->pso, psoMask, pco, pxlo, &rclDst,
                          pptlSrc, pptlMask, pbo, pptlBrush, rop4);
        }
        else
        {
            DISPDBG((6, "<< MulBitBlt: Line: %d", __LINE__));
            return(bBitBltBetweenBoards(psoDst, psoSrc, psoMask, pco, pxlo,
                                        &rclDst, pptlSrc, pptlMask, pbo,
                                        pptlBrush, rop4, &rclBounds, pmb));

        }
    }
    else if (bToScreen)
    {
        ///////////////////////////////////////////////////////////////
        // To-screen
        ///////////////////////////////////////////////////////////////

        pmdev = (MDEV*) psoDst->dhpdev;
        if (bFindBoard(pmdev, &rclDst, &pmb))
        {
            GO_BOARD(pmdev, pmb);
            b = DrvBitBlt(pmb->pso, psoSrc, psoMask, pco, pxlo, &rclDst,
                          pptlSrc, pptlMask, pbo, pptlBrush, rop4);
        }
        else
        {
            if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
            {
                // If the CLIPOBJ doesn't have at least DC_RECT complexity,
                // substitute one that does:

                pco = pmdev->pco;
            }

            rclOriginalBounds = pco->rclBounds;

            b = TRUE;
            do {
                if (bIntersect(&rclOriginalBounds, &pmb->rcl, &pco->rclBounds))
                {
                    GO_BOARD(pmdev, pmb);
                    b &= DrvBitBlt(pmb->pso, psoSrc, psoMask, pco, pxlo, &rclDst,
                                   pptlSrc, pptlMask, pbo, pptlBrush, rop4);
                }

            } while (bNextBoard(&rclDst, &pmb));

            // Restore the original clip bounds:

            pco->rclBounds = rclOriginalBounds;
        }
    }
    else
    {
        ///////////////////////////////////////////////////////////////
        // From-screen
        ///////////////////////////////////////////////////////////////

        pmdev = (MDEV*) psoSrc->dhpdev;

        // rclBounds is the source rectangle:

        rclBounds.left   = pptlSrc->x;
        rclBounds.top    = pptlSrc->y;
        rclBounds.right  = pptlSrc->x + (rclDst.right - rclDst.left);
        rclBounds.bottom = pptlSrc->y + (rclDst.bottom - rclDst.top);

        if (bFindBoard(pmdev, &rclBounds, &pmb))
        {
            GO_BOARD(pmdev, pmb);
            b = DrvBitBlt(psoDst, pmb->pso, psoMask, pco, pxlo, &rclDst,
                          pptlSrc, pptlMask, pbo, pptlBrush, rop4);
        }
        else
        {
            if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
            {
                // If the CLIPOBJ doesn't have at least DC_RECT complexity,
                // substitute one that does:

                pco = pmdev->pco;
            }

            rclOriginalBounds = pco->rclBounds;

            // Offset to transform from source rectangle to destination
            // rectangle:

            xOffset = rclDst.left - pptlSrc->x;
            yOffset = rclDst.top  - pptlSrc->y;

            b = TRUE;
            do {
                // Since the screen is the source, but the clip bounds applies
                // to the destination, we have to convert our board clipping
                // information to destination coordinates:

                rclDstBounds.left   = pmb->rcl.left   + xOffset;
                rclDstBounds.right  = pmb->rcl.right  + xOffset;
                rclDstBounds.top    = pmb->rcl.top    + yOffset;
                rclDstBounds.bottom = pmb->rcl.bottom + yOffset;

                if (bIntersect(&rclOriginalBounds, &rclDstBounds, &pco->rclBounds))
                {
                    GO_BOARD(pmdev, pmb);
                    b &= DrvBitBlt(psoDst, pmb->pso, psoMask, pco, pxlo, &rclDst,
                                   pptlSrc, pptlMask, pbo, pptlBrush, rop4);
                }

            } while (bNextBoard(&rclBounds, &pmb));

            // Restore the original clip bounds:

            pco->rclBounds = rclOriginalBounds;
        }
    }

    GO_HOME(pmdev);

    DISPDBG((6, "<< MulBitBlt: Line: %d, ret: 0x%x", __LINE__, b));
    return(b);
}

/******************************Public*Routine******************************\
* MulDisablePDEV
*
* Note: May be called before MulEnablePDEV successfully completed!
*
\**************************************************************************/

VOID MulDisablePDEV(DHPDEV dhpdev)
{
    MULTI_BOARD* pmb;
    MDEV*        pmdev;

    DISPDBG((5, ">> MulDisablePDEV"));
    pmdev = (MDEV*) dhpdev;

    for (pmb = pmdev->pmb; pmb != NULL; pmb = pmb->pmbNext)
    {
        if (pmb->ppdev != NULL)
        {
            GO_BOARD(pmdev, pmb);
            DrvDisablePDEV((DHPDEV) pmb->ppdev);
        }
    }

    GO_HOME(pmdev);

    for (pmb = pmdev->pmb; pmb != NULL; pmb = pmb->pmbNext)
    {
        EngFreeMem(pmb);         // Undo 'bVeryTemporaryInitializationCode'
    }                           //   allocation

    EngFreeMem(pmdev);
    DISPDBG((6, "<< MulDisablePDEV: Line: %d", __LINE__));

}

/******************************Public*Routine******************************\
* MulDisableSurface
*
* Note: May be called before MulEnableSurface successfully completed!
*
\**************************************************************************/

VOID MulDisableSurface(DHPDEV dhpdev)
{
    MULTI_BOARD* pmb;
    MDEV*        pmdev;

    DISPDBG((5, ">> MulDisableSurface"));
    pmdev = (MDEV*) dhpdev;

    if (pmdev->pco != NULL)
        EngDeleteClip(pmdev->pco);

    EngDeleteSurface(pmdev->hsurf);

    for (pmb = pmdev->pmb; pmb != NULL; pmb = pmb->pmbNext)
    {
        GO_BOARD(pmdev, pmb);

        EngUnlockSurface(pmb->pso);

        DrvDisableSurface((DHPDEV) pmb->ppdev);
    }

    GO_HOME(pmdev);
    DISPDBG((6, "<< MulDisableSurface: Line: %d", __LINE__));
}

/******************************Public*Routine******************************\
* MulAssertMode
*
\**************************************************************************/

BOOL MulAssertMode(
DHPDEV dhpdev,
BOOL   bEnable)
{
    MDEV*         pmdev;
    MULTI_BOARD*  pmb;

    DISPDBG((5, ">> MulAssertMode"));
    pmdev = (MDEV*) dhpdev;

    if (!bEnable)
    {
        // When switching to full-screen mode, PatBlt blackness over
        // all the inactive screens (otherwise it looks goofy when
        // the desktop is frozen on the inactive screens and the user
        // can't do anything with it):

        for (pmb = pmdev->pmb; pmb != NULL; pmb = pmb->pmbNext)
        {
            if (pmb != pmdev->pmbHome)
            {
                GO_BOARD(pmdev, pmb);
                DrvBitBlt(pmb->pso, NULL, NULL, NULL, NULL, &pmb->rcl, NULL,
                          NULL, NULL, NULL, 0);
            }
        }
    }

    // We use the 'home' board for full-screen switching:

    GO_BOARD(pmdev, pmdev->pmbHome);
    DrvAssertMode((DHPDEV) pmdev->pmbHome->ppdev, bEnable);

    DISPDBG((6, "<< MulAssertMode: Line: %d", __LINE__));
    return TRUE;
}

/******************************Public*Routine******************************\
* MulMovePointer
*
\**************************************************************************/

VOID MulMovePointer(
SURFOBJ* pso,
LONG     x,
LONG     y,
RECTL*   prcl)
{
    MDEV*        pmdev;
    MULTI_BOARD* pmbPointer;
    RECTL        rclPointer;

    DISPDBG((5, ">> MulMovePointer"));
    pmdev     = (MDEV*) pso->dhpdev;
    pmbPointer = pmdev->pmbPointer;

    if (pmbPointer != NULL)
    {
        // The most common case is when the pointer is moved to a spot
        // on the same board:

        if ((x >= pmbPointer->rcl.left)  &&
            (x <  pmbPointer->rcl.right) &&
            (y >= pmbPointer->rcl.top)   &&
            (y <  pmbPointer->rcl.bottom))
        {
            GO_BOARD(pmdev, pmbPointer);
            DrvMovePointer(pmbPointer->pso, x, y, prcl);
            GO_HOME(pmdev);

            DISPDBG((6, "<< MulMovePointer: Line: %d", __LINE__));
            return;
        }

        // Tell the old board to erase its cursor:

        GO_BOARD(pmdev, pmbPointer);
        DrvMovePointer(pmbPointer->pso, -1, -1, NULL);
    }

    if (x == -1)
    {
        pmdev->pmbPointer = NULL;
        GO_HOME(pmdev);
        DISPDBG((6, "<< MulMovePointer: Line: %d", __LINE__));
        return;
    }

    // Find the new board and tell it to draw its new cursor:

    rclPointer.left   = x;
    rclPointer.right  = x;
    rclPointer.top    = y;
    rclPointer.bottom = y;

    bFindBoard(pmdev, &rclPointer, &pmbPointer);

    GO_BOARD(pmdev, pmbPointer);
    DrvMovePointer(pmbPointer->pso, x, y, prcl);

    pmdev->pmbPointer = pmbPointer;

    GO_HOME(pmdev);
    DISPDBG((6, "<< MulMovePointer: Line: %d", __LINE__));
}

/******************************Public*Routine******************************\
* MulSetPointerShape
*
\**************************************************************************/

ULONG MulSetPointerShape(
SURFOBJ*  pso,
SURFOBJ*  psoMask,
SURFOBJ*  psoColor,
XLATEOBJ* pxlo,
LONG      xHot,
LONG      yHot,
LONG      x,
LONG      y,
RECTL*    prcl,
FLONG     fl)
{
    MULTI_BOARD* pmb;
    MDEV*        pmdev;
    ULONG        ulRetPrevious = (ULONG) -1;
    ULONG        ulRet;
    RECTL        rclPointer;
    MULTI_BOARD* pmbPointer;             // Board on which cursor is visible

    DISPDBG((5, ">> MulSetPointerShape"));
    DISPDBG((0, "BUGBUG Software Cursor only for MULTI_BOARDS for now"));
    DISPDBG((6, "<< MulSetPointerShape: Line: %d", __LINE__));
	return(SPS_DECLINE);

    pmdev = (MDEV*) pso->dhpdev;

    // Find out which board that the cursor is visible on, if any:

    pmbPointer = NULL;
    if (x != -1)
    {
        rclPointer.left   = x;
        rclPointer.right  = x;
        rclPointer.top    = y;
        rclPointer.bottom = y;

        bFindBoard(pmdev, &rclPointer, &pmbPointer);
    }
    pmdev->pmbPointer = pmbPointer;

    // LATER: Fix the case for when some boards may fail the call, and others
    //        won't.

    for (pmb = pmdev->pmb; pmb != NULL; pmb = pmb->pmbNext)
    {
        // We notify all boards of the new cursor shape, but only the board
        // on which the cursor is visible is told to draw it:

        GO_BOARD(pmdev, pmb);

        if (pmb == pmbPointer)
        {
            ulRet = DrvSetPointerShape(pmb->pso, psoMask, psoColor, pxlo,
                                       xHot, yHot, x, y, prcl, fl);
        }
        else
        {
            ulRet = DrvSetPointerShape(pmb->pso, psoMask, psoColor, pxlo,
                                       xHot, yHot, -1, y, NULL, fl);
        }

        if ((ulRetPrevious != (ULONG) -1) && (ulRetPrevious != ulRet))
        {
            RIP("MulSetPointerShape not all DrvSetPointerShapes same\n");
        }

        ulRetPrevious = ulRet;
    }

    GO_HOME(pmdev);

    DISPDBG((6, "<< MulSetPointerShape: Line: %d, ret: 0x%x", __LINE__, ulRetPrevious));
    return(ulRetPrevious);
}

/******************************Public*Routine******************************\
* MulDitherColor
*
\**************************************************************************/

ULONG MulDitherColor(
DHPDEV dhpdev,
ULONG  iMode,
ULONG  rgb,
ULONG* pul)
{
    PDEV* ppdev;
    ULONG ulRet;

    DISPDBG((5, ">> MulDitherColor"));
    // Let the first board's driver do the dithering:

    ppdev = ((MDEV*) dhpdev)->pmb->ppdev;
    ulRet = DrvDitherColor((DHPDEV) ppdev, iMode, rgb, pul);

    DISPDBG((6, "<< MulDitherColor: Line: %d, ret: 0x%x", __LINE__, ulRet));
    return(ulRet);
}

/******************************Public*Routine******************************\
* MulSetPalette
*
\**************************************************************************/

BOOL MulSetPalette(
DHPDEV  dhpdev,
PALOBJ* ppalo,
FLONG   fl,
ULONG   iStart,
ULONG   cColors)
{
    MULTI_BOARD* pmb;
    MDEV*        pmdev;
    BOOL         bRet = TRUE;

    DISPDBG((5, ">> MulSetPalette"));
    // Notify all boards of the palette change:

    pmdev = (MDEV*) dhpdev;
    for (pmb = pmdev->pmb; pmb != NULL; pmb = pmb->pmbNext)
    {
        GO_BOARD(pmdev, pmb);
        bRet &= DrvSetPalette((DHPDEV) pmb->ppdev, ppalo, fl, iStart, cColors);
    }

    GO_HOME(pmdev);
    DISPDBG((6, "<< MulSetPalette: Line: %d, ret: 0x%x", __LINE__, bRet));
    return(bRet);
}

/******************************Public*Routine******************************\
* MulCopyBits
*
\**************************************************************************/

BOOL MulCopyBits(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc)
{
    BOOL         bFromScreen;
    BOOL         bToScreen;
    MDEV*        pmdev;
    MULTI_BOARD* pmb;
    RECTL        rclOriginalBounds;
    BOOL         b;
    RECTL        rclBounds;
    RECTL        rclDst;

    DISPDBG((5, ">> MulCopyBits"));
    bFromScreen = ((psoSrc != NULL) && (psoSrc->iType == STYPE_DEVICE));
    bToScreen   = ((psoDst != NULL) && (psoDst->iType == STYPE_DEVICE));

    // We copy the prclDst rectangle here because sometimes GDI will
    // simply point prclDst to the same rectangle in pco->rclBounds,
    // and we'll be mucking with pco->rclBounds...

    rclDst = *prclDst;

    if (bToScreen && bFromScreen)
    {
        ///////////////////////////////////////////////////////////////
        // Screen-to-screen
        ///////////////////////////////////////////////////////////////

        pmdev = (MDEV*) psoDst->dhpdev;

        // rclBounds is the union of the source and destination rectangles:

        rclBounds.left   = min(rclDst.left, pptlSrc->x);
        rclBounds.top    = min(rclDst.top,  pptlSrc->y);
        rclBounds.right  = max(rclDst.right,
                               pptlSrc->x + (rclDst.right - rclDst.left));
        rclBounds.bottom = max(rclDst.bottom,
                               pptlSrc->y + (rclDst.bottom - rclDst.top));

        if (bFindBoard(pmdev, &rclBounds, &pmb))
        {
            GO_BOARD(pmdev, pmb);
            b = DrvCopyBits(pmb->pso, pmb->pso, pco, pxlo, &rclDst, pptlSrc);
        }
        else
        {
            DISPDBG((6, "<< MulCopyBits: Line: %d", __LINE__));
            return(bBitBltBetweenBoards(psoDst, psoSrc, NULL, pco, pxlo,
                                        &rclDst, pptlSrc, NULL, NULL,
                                        NULL, 0x0000cccc, &rclBounds, pmb));
        }
    }
    else if (bToScreen)
    {
        ///////////////////////////////////////////////////////////////
        // To-screen
        ///////////////////////////////////////////////////////////////

        pmdev = (MDEV*) psoDst->dhpdev;
        if (bFindBoard(pmdev, &rclDst, &pmb))
        {
            GO_BOARD(pmdev, pmb);
            b = DrvCopyBits(pmb->pso, psoSrc, pco, pxlo, &rclDst, pptlSrc);
        }
        else
        {
            if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
            {
                // If the CLIPOBJ doesn't have at least DC_RECT complexity,
                // substitute one that does:

                pco = pmdev->pco;
            }

            rclOriginalBounds = pco->rclBounds;

            b = TRUE;
            do {
                if (bIntersect(&rclOriginalBounds, &pmb->rcl, &pco->rclBounds))
                {
                    GO_BOARD(pmdev, pmb);
                    b &= DrvCopyBits(pmb->pso, psoSrc, pco, pxlo, &rclDst,
                                     pptlSrc);
                }

            } while (bNextBoard(&rclDst, &pmb));

            // Restore the original clip bounds:

            pco->rclBounds = rclOriginalBounds;
        }
    }
    else
    {
        ///////////////////////////////////////////////////////////////
        // From-screen
        ///////////////////////////////////////////////////////////////

        // This rarely happens, so save some code space:

        return(MulBitBlt(psoDst, psoSrc, NULL, pco, pxlo, prclDst,
                              pptlSrc, NULL, NULL, NULL, 0x0000cccc));
    }

    GO_HOME(pmdev);
    DISPDBG((6, "<< MulCopyBits: Line: %d, ret: 0x%x", __LINE__, b));
    return(b);
}

/******************************Public*Routine******************************\
* MulTextOut
*
\**************************************************************************/

BOOL MulTextOut(
SURFOBJ*  pso,
STROBJ*   pstro,
FONTOBJ*  pfo,
CLIPOBJ*  pco,
RECTL*    prclExtra,
RECTL*    prclOpaque,
BRUSHOBJ* pboFore,
BRUSHOBJ* pboOpaque,
POINTL*   pptlOrg,
MIX       mix)
{
    MDEV*          pmdev;
    MULTI_BOARD*   pmb;
    RECTL          rclOriginalBounds;
    BYTE           fjOriginalOptions;
    BOOL           b;
    RECTL*         prclBounds;
    FONT_CONSUMER* pfcArray;

    DISPDBG((5, ">> MulTextOut"));
    pmdev = (MDEV*) pso->dhpdev;

    // In keeping with our philosophy for multiple board support, we handle
    // multiple consumers of the same font at this level.  We do this by
    // monitoring pfo->pvConsumer, and the first time a board sets the
    // field, we take control of pfo->pvConsumer.  We use it to allocate
    // a pvConsumer array where we can keep track of every board's
    // individual pvConsumer.

    pfcArray = pfo->pvConsumer;

    prclBounds = (prclOpaque != NULL) ? prclOpaque : &pstro->rclBkGround;

    bFindBoard(pmdev, prclBounds, &pmb);

    if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
    {
        // If the CLIPOBJ doesn't have at least DC_RECT complexity,
        // substitute one that does:

        pco = pmdev->pco;
    }

    rclOriginalBounds = pco->rclBounds;
    fjOriginalOptions = pco->fjOptions;

    // OR in the OC_BANK_CLIP flag to let GDI know that we may be calling
    // EngTextOut multiple times with the same parameters (EngTextOut
    // is destructive in that it modifies that parameters passed to it,
    // unless this bit is set):

    pco->fjOptions |= OC_BANK_CLIP;

    b = TRUE;
    do {
        if (pfcArray != NULL)
            pfo->pvConsumer = pfcArray->apvc[pmb->iBoard].pvConsumer;

        // Make sure we restart the glyph enumeration if need be:

        STROBJ_vEnumStart(pstro);
        if (bIntersect(&rclOriginalBounds, &pmb->rcl, &pco->rclBounds))
        {
            GO_BOARD(pmdev, pmb);
            b &= DrvTextOut(pmb->pso, pstro, pfo, pco, prclExtra, prclOpaque,
                            pboFore, pboOpaque, pptlOrg, mix);
        }

        if (pfcArray != NULL)
        {
            // Copy the pvConsumer, in case the last DrvTextOut changed
            // it:

            pfcArray->apvc[pmb->iBoard].pvConsumer = pfo->pvConsumer;
        }
        else
        {
            if (pfo->pvConsumer != NULL)
            {
                // The board allocated a new consumer, so create our array
                // to keep track of consumers for every board:

                pfcArray = EngAllocMem(FL_ZERO_MEMORY, sizeof(FONT_CONSUMER),
                                       ALLOC_TAG);
                if (pfcArray == NULL)
                    DrvDestroyFont(pfo);
                else
                {
                    pfcArray->cConsumers = pmdev->cBoards;
                    pfcArray->apvc[pmb->iBoard].pvConsumer = pfo->pvConsumer;

                }
            }
        }
    } while (bNextBoard(prclBounds, &pmb));

    // Restore the original clip bounds:

    pco->rclBounds = rclOriginalBounds;
    pco->fjOptions = fjOriginalOptions;

    // Make sure we restore/set the font's pvConsumer:

    pfo->pvConsumer = pfcArray;

    GO_HOME(pmdev);

    DISPDBG((6, "<< MulTextOut: Line: %d, b", __LINE__, b));
    return(b);
}

/******************************Public*Routine******************************\
* MulDestroyFont
*
\**************************************************************************/

VOID MulDestroyFont(FONTOBJ *pfo)
{
    FONT_CONSUMER* pfcArray;
    LONG           i;
    PVOID          pvConsumer;

    DISPDBG((5, ">> MulDestroyFont"));
    if (pfo->pvConsumer != NULL)
    {
        pfcArray = pfo->pvConsumer;
        for (i = 0; i < pfcArray->cConsumers; i++)
        {
            pvConsumer = pfcArray->apvc[i].pvConsumer;
            if (pvConsumer != NULL)
            {
                pfo->pvConsumer = pvConsumer;
                DrvDestroyFont(pfo);
            }
        }

        EngFreeMem(pfcArray);
        pfo->pvConsumer = NULL;
    }
    DISPDBG((6, "<< MulDestroyFont: Line: %d", __LINE__));
}

/******************************Public*Routine******************************\
* MulPaint
*
\**************************************************************************/

BOOL MulPaint(
SURFOBJ*  pso,
CLIPOBJ*  pco,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
MIX       mix)
{
    MDEV*        pmdev;
    RECTL        rclOriginalBounds;
    MULTI_BOARD* pmb;
    BOOL         b;

    DISPDBG((5, ">> MulPaint"));
    pmdev = (MDEV*) pso->dhpdev;
    if (bFindBoard(pmdev, &pco->rclBounds, &pmb))
    {
        GO_BOARD(pmdev, pmb);
        b = DrvPaint(pmb->pso, pco, pbo, pptlBrush, mix);
    }
    else
    {
        rclOriginalBounds = pco->rclBounds;

        b = TRUE;
        do {
            if (bIntersect(&rclOriginalBounds, &pmb->rcl, &pco->rclBounds))
            {
                GO_BOARD(pmdev, pmb);
                b &= DrvPaint(pmb->pso, pco, pbo, pptlBrush, mix);
            }

        } while (bNextBoard(&rclOriginalBounds, &pmb));

        // Restore the original clip bounds:

        pco->rclBounds = rclOriginalBounds;
    }

    GO_HOME(pmdev);

    DISPDBG((6, "<< MulPaint: Line: %d", __LINE__));
    return(b);
}

/******************************Public*Routine******************************\
* MulRealizeBrush
*
\**************************************************************************/

BOOL MulRealizeBrush(
BRUSHOBJ* pbo,
SURFOBJ*  psoTarget,
SURFOBJ*  psoPattern,
SURFOBJ*  psoMask,
XLATEOBJ* pxlo,
ULONG     iHatch)
{
    MDEV*        pmdev;
    BOOL         b;

    DISPDBG((5, ">> MulRealizeBrush"));
    pmdev = (MDEV*) psoTarget->dhpdev;

    // DrvRealizeBrush is only ever calling from within a Drv function.
    // 'psoTarget' points to our multi-board surface, but we have to point
    // it to the surface of the board for which the DrvBitBlt call was made.

    b = DrvRealizeBrush(pbo, pmdev->pmbCurrent->pso, psoPattern, psoMask,
                        pxlo, iHatch);

    DISPDBG((6, "<< MulRealizeBrush: Line: %d", __LINE__));
    return(b);
}

#endif // MULTI_BOARDS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nt4muldirectdraw.c ===
//************************** Module Header *************************************
//                                                                             *
//  Module Name: nt4MulDirectDraw.c                                                   *
//                                                                             *
//  This module contains the functions that belong to the multi device wrapper *
//                                                                             *
//   Copyright (C) 2000 NVidia Corporation. All Rights Reserved.               *
//                                                                             *
//******************************************************************************

#include "precomp.h"
#include "driver.h"

#include "nt4multidev.h"

#ifdef NT4_MULTI_DEV

//******************************************************************************
//
//  MulEnableDirectDraw
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
BOOL MulEnableDirectDraw(DHPDEV dhpdev, DD_CALLBACKS*  pCallBacks,
							DD_SURFACECALLBACKS*    pSurfaceCallBacks, DD_PALETTECALLBACKS*    pPaletteCallBacks)
{
    PPDEV  ppdev = (PPDEV)dhpdev;
    BOOL   bRet  = FALSE;

    DISPDBG((100, "MulEnableDirectDraw >>>"));

    ASSERT(ppdev);

    if( !ppdev->pmdev )
    {
        bRet = DrvEnableDirectDraw(dhpdev, pCallBacks, pSurfaceCallBacks, pPaletteCallBacks);
    }
    else
    {
        DISPDBG((1,"MulEnableDirectDraw: multiboards directDraw not implemented !"));
    }

    DISPDBG((100, "<<< MulEnableDirectDraw"));
	return bRet;
}


//******************************************************************************
//
//  MulGetDirectDrawInfo
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
BOOL MulGetDirectDrawInfo(DHPDEV dhpdev, DD_HALINFO* pHalInfo, DWORD* lpdwNumHeaps,
						  VIDEOMEMORY* pvmList, DWORD* lpdwNumFourCC, DWORD* lpdwFourCC)
{
    PPDEV  ppdev = (PPDEV)dhpdev;
    BOOL   bRet  = FALSE;

    DISPDBG((100, "MulGetDirectDrawInfo >>>"));

    ASSERT(ppdev);

    if( !ppdev->pmdev )
    {
        bRet = DrvGetDirectDrawInfo(dhpdev, pHalInfo, lpdwNumHeaps, pvmList, lpdwNumFourCC, lpdwFourCC);
    }
    else
    {
        DISPDBG((1,"MulGetDirectDrawInfo: multiboards directDraw not implemented !"));
    }

    DISPDBG((100, "<<< MulGetDirectDrawInfo - %d", bRet));
	return bRet;
}


//******************************************************************************
//
//  MulGetDirectDrawInfo
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
VOID MulDisableDirectDraw(DHPDEV dhpdev)
{
    PPDEV  ppdev = (PPDEV)dhpdev;

    DISPDBG((100, "MulDisableDirectDraw >>>"));

    ASSERT(ppdev);

    if( !ppdev->pmdev )
    {
        DrvDisableDirectDraw(dhpdev);
    }
    else
    {
        DISPDBG((1,"MulDisableDirectDraw: multiboards directDraw not implemented !"));
    }

    DISPDBG((100, "<<< MulDisableDirectDraw"));
	return ;
}

#endif // NT4_MULTI_DEV
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nt4mulescape.c ===
//************************** Module Header *************************************
//                                                                             *
//  Module Name: nt4MulEscape.c                                                   *
//                                                                             *
//  This module contains the functions that belong to the multi device wrapper *
//                                                                             *
//   Copyright (C) 2000 NVidia Corporation. All Rights Reserved.               *
//                                                                             *
//******************************************************************************


#include "precomp.h"
#include "driver.h"
#include "RectUtils.h"
#include "nv32.h"       // needed for NV01_DEVICE_0 #define
#include "nt4multidev.h"

#ifdef NT4_MULTI_DEV

BOOL bFindDeviceRMRoot( PBOARDDESC pbdDevices, ULONG ulRoot )
{
    BOOL  bRet = FALSE;
    ULONG ul   = 0;

    ASSERT( NULL != pbdDevices );
    ASSERT( 0 != ulRoot ); // 0 means not initialized !

    for( ul = 0; ul < MAX_MULTIDEV; ul ++ )
    {
        if( pbdDevices[ul].ulRoot == ulRoot )
        {
            bRet = TRUE;
            break;
        }
    }

    return bRet;
}


//******************************************************************************
//
//  MulEscape
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
ULONG MulEscape(SURFOBJ*    pso, ULONG       iEsc, ULONG       cjIn,
                VOID*       pvIn, ULONG       cjOut, VOID*       pvOut)
{
    PPDEV ppdev = NULL;
    ULONG ulRet = 0;

    DISPDBG((100, "MulEscape >>>"));

    ppdev = (PPDEV)pso->dhpdev; 

    ASSERT(ppdev);

    if( !ppdev->pmdev )
    {
        ulRet = DrvEscape(pso, iEsc, cjIn, pvIn, cjOut, pvOut);
    }
    else
    {

        PMDEV   pmdev = ppdev->pmdev;  
        ULONG   ulDev;

        // check for all ESCAPES related to the multimon stuff first
        switch(iEsc)
        {
            case ESC_NV_OPENGL_ESCAPE:
            {
                NV_OPENGL_COMMAND *inCommand;

                inCommand = (NV_OPENGL_COMMAND *)pvIn;

                switch(inCommand->command)
                {
                    case ESC_NV_OPENGL_NT4_GET_NUMBER_OF_MONITORS:
                        ((ULONG *)pvOut)[0] = pmdev->ulNumDevicesActive;
                        ulRet = (ULONG)TRUE + 1;
                        break;
                    case ESC_NV_OPENGL_NT4_GET_DEVICE_HANDLE:
                        ASSERT(inCommand->devID < MAX_MULTIDEV);
                        ((ULONG *)pvOut)[0] = (ULONG)pmdev->abdDevices[inCommand->devID].hDriver;
                        ulRet = (ULONG)TRUE + 1;
                        break;
                    case ESC_NV_OPENGL_NT4_GET_DEVICE_RECT:
                    {
                        RECTL *prcl;
                        prcl = (RECTL *)pvOut;
                        ASSERT(inCommand->devID < MAX_MULTIDEV);
                        *prcl = pmdev->abdDevices[inCommand->devID].rclBoard;
                        ulRet = (ULONG)TRUE + 1;
                        break;
                    }
                    case ESC_NV_OPENGL_NT4_GDI_LOCK:
                    {
                        // this call is used from ICD softwarefunctions to check if their drawable
                        // is accessible => check against modeswitches etc.
                        if(  ( ((PDEV*)(pmdev->abdDevices[inCommand->devID].pso->dhpdev))->bEnabled )
                           &&( !(((PDEV*)(pmdev->abdDevices[inCommand->devID].pso->dhpdev))->dwGlobalModeSwitchCount & 0x1) )
                          )
                        {
                            ulRet = (ULONG)TRUE + 1;
                        }
                        else
                        {
                            // here we tell ICD that Escape reached server side, but did not succeed;
                            ulRet = (ULONG)TRUE;
                        }
                        break;
                    }
                    default:
                        // all other ESCAPES ( only ESC_NV_OPENGL_ESCAPE so far ) should
                        // have DevID filled out to reach the desired device
                        // otherwise they go to device 0
                        ASSERT(inCommand->devID < MAX_MULTIDEV);
                        ASSERT(pmdev->abdDevices[inCommand->devID].pso);
                        ulRet = DrvEscape(pmdev->abdDevices[inCommand->devID].pso, iEsc, cjIn, pvIn, cjOut, pvOut);
                        break;
                }
                break;
            }

            // this is one of the few calls we have to redirect to the right device
            // devicenumber is  given as inCommand->hClass - NV01_DEVICE_0
            case NV_ESC_RM_ALLOC_DEVICE:
            {
                NVOS06_PARAMETERS *inParms;

                ASSERT( cjIn == sizeof(NVOS06_PARAMETERS) );
                inParms  = (NVOS06_PARAMETERS *)pvIn;

                ulDev = inParms->hClass - NV01_DEVICE_0;
                ASSERT(ulDev < MAX_MULTIDEV);

                // remember ParentObject ( created by alloc_root ) to redirect rm-calls
                // only take 1st one, others are not used elsawhere
                if( 0 == pmdev->abdDevices[ulDev].ulRoot )
                {
                    pmdev->abdDevices[ulDev].ulRoot = inParms->hObjectParent;
                }

                DISPDBG((95, "Redirecting NV_ESC_RM_ALLOC_DEVICE to device No: %d ( hRoot: 0x%x )",ulDev,inParms->hObjectParent));

                ASSERT(pmdev->abdDevices[ulDev].pso);
                ulRet = DrvEscape(pmdev->abdDevices[ulDev].pso, iEsc, cjIn, pvIn, cjOut, pvOut);

                break;
            }
            case ESC_NV_QUERYSET_REGISTRY_KEY: 
            {
                __PNVRegKeyInfo inParms, outParms;

                inParms = (__PNVRegKeyInfo) pvIn;

                ulDev = inParms->devID;

                // this is a hot fox for tools which do not 
                if( ulDev >= pmdev->ulNumDevicesActive )
                {
                    //ASSERT(ulDev < MAX_MULTIDEV);
                    ulDev = 0;
                }

                DISPDBG((0, "Redirecting ESC_NV_QUERYSET_REGISTRY_KEY to device No: %d ",ulDev));

                ASSERT(pmdev->abdDevices[ulDev].pso);
                ulRet = DrvEscape(pmdev->abdDevices[ulDev].pso, iEsc, cjIn, pvIn, cjOut, pvOut);
                break;
            }

            case WNDOBJ_SETUP:
            {
                NV_WNDOBJ_SETUP *pNvWndObj;
                ULONG            ulDev;

                pNvWndObj  = (NV_WNDOBJ_SETUP *)pvIn;

                ulDev = pNvWndObj->devID;
                DISPDBG((0, "WNDOBJ_SETUP called with ulDev: 0x%x )",pNvWndObj->devID));

                ASSERT(pmdev->abdDevices[ulDev].pso);
                ulRet = DrvEscape(pmdev->abdDevices[ulDev].pso, iEsc, cjIn, pvIn, cjOut, pvOut);
                break;
            }


            case NV_ESC_RM_ARCH_HEAP:
            {
                NVOS11_PARAMETERS *inParms;
                ULONG              ulDev;

                inParms  = (NVOS11_PARAMETERS *)pvIn;
                DISPDBG((0, "NV_ESC_RM_ARCH_HEAP called with hRoot: 0x%x )",inParms->hRoot));

                if( bFindDeviceRMRoot( pmdev->abdDevices, inParms->hRoot ) )
                {
                    // found matching device !
                    DISPDBG((0, "Redirecting NV_ESC_RM_ARCH_HEAP to device No: %d  ( hClass: 0x%x )",ulDev,inParms->hRoot));
//                    ulRet = DrvEscape(pmdev->abdDevices[0].pso, iEsc, cjIn, pvIn, cjOut, pvOut);
//                    break;
                }
                // check for client to redirect it to the right client
    
//                break;
            }

            default:
                ulRet = DrvEscape(pmdev->abdDevices[0].pso, iEsc, cjIn, pvIn, cjOut, pvOut);
                break;
        }
    }

    DISPDBG((100, "<<< MulEscape"));
    return ulRet;
}


//******************************************************************************
//
//  MulDrawEscape
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
ULONG MulDrawEscape(SURFOBJ *pso, ULONG    iEsc, CLIPOBJ *pco,
                    RECTL   *prcl, ULONG    cjIn, PVOID    pvIn)
{
    PPDEV ppdev = NULL;
    ULONG ulRet = 0;

    DISPDBG((100, "MulDrawEscape >>>"));

    ppdev = (PPDEV)pso->dhpdev; 

    ASSERT(ppdev);

    if( !ppdev->pmdev )
    {
        ulRet = DrvDrawEscape(pso, iEsc, pco, prcl, cjIn, pvIn);
    }
    else
    {
        PMDEV   pmdev = ppdev->pmdev;  
        ULONG   ulDev;

        for( ulDev=0; ulDev < pmdev->ulNumDevicesActive; ulDev++ )
        {
            ASSERT(pmdev->abdDevices[ulDev].pso);
            ulRet = DrvDrawEscape(pmdev->abdDevices[ulDev].pso, iEsc, pco, prcl, cjIn, pvIn);
            if( -1 == (LONG)ulRet )
                break;
        }
    }

    DISPDBG((100, "<<< MulDrawEscape"));
    return ulRet;
}


//******************************************************************************
//
//  MulSwapBuffers
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
BOOL APIENTRY MulSwapBuffers(SURFOBJ *psoDst, WNDOBJ *pwo)
{
    PPDEV ppdev = NULL;
    BOOL  bRet  = FALSE;

    DISPDBG((100, "MulSwapBuffers >>>"));

    ppdev = (PPDEV)psoDst->dhpdev; 

    ASSERT(ppdev);

    if( !ppdev->pmdev )
    {
        bRet = DrvSwapBuffers(psoDst, pwo);
    }
    else
    {
        PMDEV   pmdev = ppdev->pmdev;  
        ULONG   ulDev;

        // this is a special case !! because of the PWO
        for (ulDev = 0; ulDev < pmdev->ulNumDevicesActive; ulDev++)
        {
            ASSERT(pmdev->abdDevices[ulDev].pso);
            bRet = DrvSwapBuffers(pmdev->abdDevices[ulDev].pso, pwo);
        }
    }

    DISPDBG((100, "<<< MulSwapBuffers - %d", bRet));
    return bRet;
}


//******************************************************************************
//
//  bPixelFormatMatch
//
//  NT4 multiboard helper function which checks if 2 given pixelformats
//  do exactly match
//
//  return value FALSE: pixelformats do not match
//               TRUE:  pixelformats do exactly match
//
//******************************************************************************
BOOL bPixelFormatMatch( PIXELFORMATDESCRIPTOR* ppfd1,  PIXELFORMATDESCRIPTOR* ppfd2 )
{
    BOOL bRet = FALSE;
    
    if(   (ppfd1->nSize           == ppfd2->nSize) 
        &&(ppfd1->nVersion        == ppfd2->nVersion)
        &&(ppfd1->dwFlags         == ppfd2->dwFlags)
        &&(ppfd1->iPixelType      == ppfd2->iPixelType)
        &&(ppfd1->cColorBits      == ppfd2->cColorBits)
        &&(ppfd1->cRedBits        == ppfd2->cRedBits)
        &&(ppfd1->cRedShift       == ppfd2->cRedShift)
        &&(ppfd1->cGreenBits      == ppfd2->cGreenBits)
        &&(ppfd1->cGreenShift     == ppfd2->cGreenShift)
        &&(ppfd1->cBlueBits       == ppfd2->cBlueBits)
        &&(ppfd1->cBlueShift      == ppfd2->cBlueShift)
        &&(ppfd1->cAlphaBits      == ppfd2->cAlphaBits)
        &&(ppfd1->cAlphaShift     == ppfd2->cAlphaShift)
        &&(ppfd1->cAccumBits      == ppfd2->cAccumBits)
        &&(ppfd1->cAccumRedBits   == ppfd2->cAccumRedBits)
        &&(ppfd1->cAccumGreenBits == ppfd2->cAccumGreenBits)
        &&(ppfd1->cAccumBlueBits  == ppfd2->cAccumBlueBits)
        &&(ppfd1->cAccumAlphaBits == ppfd2->cAccumAlphaBits)
        &&(ppfd1->cDepthBits      == ppfd2->cDepthBits)
        &&(ppfd1->cStencilBits    == ppfd2->cStencilBits)
        &&(ppfd1->cAuxBuffers     == ppfd2->cAuxBuffers)
        &&(ppfd1->iLayerType      == ppfd2->iLayerType)
        &&(ppfd1->bReserved       == ppfd2->bReserved)
        &&(ppfd1->dwLayerMask     == ppfd2->dwLayerMask)
        &&(ppfd1->dwVisibleMask   == ppfd2->dwVisibleMask)
        &&(ppfd1->dwDamageMask    == ppfd2->dwDamageMask)
       )
       bRet = TRUE;

    return bRet;
}


//******************************************************************************
//
//  lReallocateMulPixelFormats
//
//  NT4 multiboard wrapper function which calculates a pixelformat list which 
//  contains only matching pixelformats of ALL enabled devices. This list is
//  stored in pmdev
//
//  return value is the number of matching pixelformats
//
//******************************************************************************
LONG lReallocateMulPixelFormats( PMDEV pmdev )
{
    PMUL_PIXELFORMAT         pmpfdFirstDevice;
    LONG                     lNumPixelFormatsFirstDevice;
    PIXELFORMATDESCRIPTOR    pfdTemp;
    LONG                     lNumPixelFormatsTemp;
    LONG                     lRet = 0;
    LONG                     l;
    lRet = 0;

    ASSERT(pmdev);
    ASSERT(pmdev->ulNumDevicesActive > 1);  // function is only designed for more than 1 device

    // we have to reallocate and fill a pixelformatlist 
    if( 0 != pmdev->PixelFormatList.iNumberOfPixelFormats )
    {
        ASSERT(pmdev->PixelFormatList.pPixelFormats);
        EngFreeMem(pmdev->PixelFormatList.pPixelFormats);
        pmdev->PixelFormatList.iNumberOfPixelFormats = 0;
    }

    lNumPixelFormatsFirstDevice = DrvDescribePixelFormat(pmdev->abdDevices[0].dhpdev, 1, 0, NULL);

    if( lNumPixelFormatsFirstDevice > 0 )
    {
        pmpfdFirstDevice = (PMUL_PIXELFORMAT)EngAllocMem(FL_ZERO_MEMORY, 
            (lNumPixelFormatsFirstDevice + 1)* sizeof(MUL_PIXELFORMAT), ALLOC_TAG); 
        if(pmpfdFirstDevice)
        {
            ULONG ulDev;

            lRet = lNumPixelFormatsFirstDevice;

            // get all pixelformats from 1st device
            for(l=1; l<=lNumPixelFormatsFirstDevice; l++)
            {
                LONG ll;
                ll = DrvDescribePixelFormat(pmdev->abdDevices[0].dhpdev, l
                        , sizeof(PIXELFORMATDESCRIPTOR), &(pmpfdFirstDevice[l].pfd));
                // remember number of pixelformat for device 0
                pmpfdFirstDevice[l].iPixelFormat[0]=l;
            }

            // now loop over all other devices and reset pixelformats in 1st device's list which does not match
            for(ulDev=1;ulDev<pmdev->ulNumDevicesActive;ulDev++)
            {
                LONG ll;
                lNumPixelFormatsTemp = DrvDescribePixelFormat(pmdev->abdDevices[ulDev].dhpdev, 1, 0, NULL);
                
                for(l=1; l <= lNumPixelFormatsFirstDevice; l++)
                {
                    if( 0 != pmpfdFirstDevice[l].pfd.nSize )
                    {
                        ll = DrvDescribePixelFormat(pmdev->abdDevices[ulDev].dhpdev, l, sizeof(PIXELFORMATDESCRIPTOR), &pfdTemp);
                        if( !bPixelFormatMatch(&(pmpfdFirstDevice[l].pfd),&pfdTemp ) )
                        {
                            // mark pixelformat as not valid
                            pmpfdFirstDevice[l].pfd.nSize = 0;
                            lRet--;
                            ASSERT(lRet>=0);
                        }
                        else
                        {
                            // found a matching pixelformat => remember number for device ulDev
                            pmpfdFirstDevice[l].iPixelFormat[ulDev]=l;
                        }
                    }
                }
            }
        
            // here we have a list of valid pixelformats ( lRet is the number of it ) 
            // and indices for each device which points to it 
            // now copy valid pixelformats into pmdev
            pmdev->PixelFormatList.iNumberOfPixelFormats = 0;
            pmdev->PixelFormatList.pPixelFormats 
                = (PMUL_PIXELFORMAT)EngAllocMem(FL_ZERO_MEMORY, lRet * sizeof(MUL_PIXELFORMAT), ALLOC_TAG);
            ASSERT(pmdev->PixelFormatList.pPixelFormats);
            for( l=1;l <= lNumPixelFormatsFirstDevice;l++)
            {
                if( 0 != pmpfdFirstDevice[l].pfd.nSize )
                {
                    // copy pixelformat and indices into pmdev
                    pmdev->PixelFormatList.pPixelFormats[pmdev->PixelFormatList.iNumberOfPixelFormats] = pmpfdFirstDevice[l];
                    // remember copied number
                    pmdev->PixelFormatList.iNumberOfPixelFormats++;  
                    ASSERT(lRet>=pmdev->PixelFormatList.iNumberOfPixelFormats);
                }
            }

            EngFreeMem(pmpfdFirstDevice);
        }
    }

    return lRet;
}


//******************************************************************************
//
//  MulSetPixelFormat
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
BOOL APIENTRY MulSetPixelFormat(
    SURFOBJ *pso,
    LONG    iPixelFormat,
    HWND    hWnd)
{
    PPDEV ppdev = NULL;
    BOOL  bRet  = FALSE;

    DISPDBG((100, "MulSetPixelFormat >>>"));

    ppdev = (PPDEV)pso->dhpdev; 

    ASSERT(ppdev);

    if( !ppdev->pmdev )
    {
        bRet = DrvSetPixelFormat(pso, iPixelFormat, hWnd);
    }
    else
    {
        PMDEV   pmdev = ppdev->pmdev;  
        ULONG   ulDev;
        LONG    lPixelFormatDevice;

        ASSERT(NULL!=pmdev->PixelFormatList.pPixelFormats);

        for (ulDev = 0; ulDev < pmdev->ulNumDevicesActive; ulDev++)
        {
            // get matching pixelformat of device
            lPixelFormatDevice = pmdev->PixelFormatList.pPixelFormats[iPixelFormat].iPixelFormat[ulDev];

            bRet =  DrvSetPixelFormat(pmdev->abdDevices[ulDev].pso, lPixelFormatDevice, hWnd);
            if( !bRet )
            {
                ASSERT(FALSE);
                break;
            }
        }
    }

    DISPDBG((100, "<<< MulSetPixelFormat"));
    return bRet;
}


//******************************************************************************
//
//  MulDescribePixelFormat
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
LONG APIENTRY MulDescribePixelFormat(
    DHPDEV                  dhpdev,
    LONG                    iPixelFormat,
    ULONG                   cjpfd,
    PIXELFORMATDESCRIPTOR   *ppfd)
{
    LONG  lRet  = 0;
    PPDEV ppdev = (PPDEV)dhpdev;

    DISPDBG((100, "MulDescribePixelFormat >>>"));

    ASSERT(ppdev);

    if( !ppdev->pmdev )
    {
        lRet = DrvDescribePixelFormat(dhpdev, iPixelFormat, cjpfd, ppfd);
    }
    else
    {
        PMDEV   pmdev = ppdev->pmdev;  

        //we do a match here to export only pixelformats which exist on ALL devices !
        // app does query us for a pixelformatlist
        if( NULL == ppfd )
        {
            lRet = lReallocateMulPixelFormats(pmdev);
        }
        else
        {
            ASSERT(NULL!=pmdev->PixelFormatList.pPixelFormats);

            lRet = pmdev->PixelFormatList.iNumberOfPixelFormats;
            if( cjpfd >= sizeof(PIXELFORMATDESCRIPTOR) )
                // our multimon pixelformatlist is zero based !!
                (*ppfd) = pmdev->PixelFormatList.pPixelFormats[iPixelFormat-1].pfd;
        }
    }

    DISPDBG((100, "<<< MulDescribePixelFormat"));
    return lRet;
}

#endif // NT4_MULTI_DEV
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nt4muldrawfunc.c ===
//************************** Module Header *************************************
//                                                                             *
//  Module Name: nt4MulDrawFunc.c                                                   *
//                                                                             *
//  This module contains the functions that belong to the multi device wrapper *
//                                                                             *
//   Copyright (C) 2000 NVidia Corporation. All Rights Reserved.               *
//                                                                             *
//******************************************************************************


#include "precomp.h"
#include "driver.h"
#include "RectUtils.h"

#include "nt4multidev.h"

#ifdef NT4_MULTI_DEV

//******************************************************************************
//
//  MulRealizeBrush
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
BOOL MulRealizeBrush(BRUSHOBJ* pbo, SURFOBJ*  psoTarget,
                    SURFOBJ*  psoPattern,   SURFOBJ*  psoMask,
                    XLATEOBJ* pxlo, ULONG     iHatch)
{
    PPDEV ppdev = (PPDEV)psoTarget->dhpdev; 
    BOOL  bRet  = FALSE;

    DISPDBG((100, "MulRealizeBrush >>>"));

    ASSERT(ppdev);

    if( !ppdev->pmdev )
    {
        bRet = DrvRealizeBrush(pbo, psoTarget, psoPattern, psoMask, pxlo, iHatch);
    }
    else
    {
        PMDEV   pmdev = ppdev->pmdev;  
        ULONG   ulDev;

        for (ulDev = 0; ulDev < pmdev->ulNumDevicesActive; ulDev++)
        {
            ASSERT(pmdev->abdDevices[ulDev].pso);
            bRet = DrvRealizeBrush(pbo, pmdev->abdDevices[ulDev].pso, psoPattern,   psoMask, pxlo,  iHatch);
        }
    }

    DISPDBG((100, "<<< MulRealizeBrush"));
    return bRet;
}


//******************************************************************************
//
//  MulSaveScreenBits
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//  For now we don't have implemented SaveScreenBits for Multimon case
//  We may need to do it if quadbuffered stereo and opengl overlay are
//  needed in multimon case.
//  That means to return an array of all collected ulRets and to take ths array
//  as input parameter for the restore cases
//
//******************************************************************************
ULONG_PTR APIENTRY MulSaveScreenBits(
    SURFOBJ   *pso,
    ULONG      iMode,
    ULONG_PTR  ident,
    RECTL     *prcl )
{
    PPDEV      ppdev = (PPDEV)pso->dhpdev; 
    ULONG_PTR  ulRet = FALSE;

    DISPDBG((100, "MulSaveScreenBits >>>"));

    ASSERT(ppdev);

    if( !ppdev->pmdev )
    {
        ulRet = DrvSaveScreenBits(pso, iMode, ident, prcl);
    }
#if 0 // not implemented yet
    else
    {
        switch(iMode) 
        {
        case SS_SAVE:
            // create array to contain all ulRets, call all DrvSaveScreenBits and return array
            break;
        case SS_RESTORE:
            // free array ( which is given by ident )
            break;
        case SS_FREE:
            // free array ( which is given by ident )
            break;
        default:
            ASSERT(FALSE);
            break;
        }
    }
#endif// #if 0

    DISPDBG((100, "<<< MulSaveScreenBits"));
    return ulRet;
}


//******************************************************************************
//
//  MulPaint
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
BOOL MulPaint(  SURFOBJ*  pso,
                CLIPOBJ*  pco,
                BRUSHOBJ* pbo,
                POINTL*   pptlBrushOrg,
                MIX       mix)
{
    PPDEV ppdev = (PPDEV)pso->dhpdev; 
    BOOL  bRet  = FALSE;

    DISPDBG((100, "MulPaint >>>"));

    ASSERT(ppdev);

    if( !ppdev->pmdev )
    {
        bRet = DrvPaint(pso, pco, pbo, pptlBrushOrg, mix);
    }
    else
    {
        PMDEV       pmdev = ppdev->pmdev;  
        ULONG       ulDev;

        for (ulDev = 0; ulDev < pmdev->ulNumDevicesActive; ulDev++)
        {
            BOARDDESC *pBoardDesc;
            ASSERT(pmdev->abdDevices[ulDev].pso);
            ASSERT(pco);

            // adjust clipobject for each single board and pass it to the coresponding board
            pBoardDesc = &pmdev->abdDevices[ulDev];

            if (DC_COMPLEX == pco->iDComplexity)
            {
                BOOL        bMoreClip;
                CLIPENUM    ce;
                LONG        l;

                CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

                do  
                {
                    bMoreClip = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);
                    for (l = 0; l < ce.c; l++)
                    {
                        if (bRclIntersect(&pBoardDesc->pco->rclBounds, &ce.arcl[l], &pBoardDesc->rclBoard))
                        {
                            vRclSubOffset(&pBoardDesc->pco->rclBounds,
                                          &pBoardDesc->pco->rclBounds,
                                          pBoardDesc->rclBoard.left, 
                                          pBoardDesc->rclBoard.top);
                            pBoardDesc->pco->iDComplexity = DC_RECT;
                            bRet = DrvPaint( pBoardDesc->pso, pBoardDesc->pco, pbo, pptlBrushOrg, mix);
                            ASSERT(bRet);
                        }
                    }
                }
                while (bMoreClip);
            }
            else
            {
                if (bRclIntersect(&pBoardDesc->pco->rclBounds, &pco->rclBounds, &pBoardDesc->rclBoard))
                {
                    vRclSubOffset(&pBoardDesc->pco->rclBounds,
                                  &pBoardDesc->pco->rclBounds,
                                  pBoardDesc->rclBoard.left, 
                                  pBoardDesc->rclBoard.top);
                    pBoardDesc->pco->iDComplexity = DC_RECT;
                    bRet = DrvPaint( pBoardDesc->pso, pBoardDesc->pco, pbo, pptlBrushOrg, mix);
                    ASSERT(bRet);
                }
            }
        }//for (ulDev = 0; ulDev < pmdev->ulNumDevicesActive; ulDev++)
    }

    DISPDBG((100, "<<< MulPaint"));
    return bRet;
}


//******************************************************************************
//
//  bTranslateBitBltParams
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
BOOL _inline bTranslateBitBltParams(IN  RECTL           *prclDstBoard,
                                    IN  RECTL           *prclSrcBoard,
                                    IN  ROP4            rop4,
                                    IN  RECTL           *prclClip,
                                    IN  RECTL           *prclDst,
                                    IN  POINTL          *pptlSrc,
                                    IN  POINTL          *pptlMask,
                                    IN  POINTL          *pptlBrush,
                                    OUT BLT_PARAM       *pBltParam)
{
    BOOL bRet = FALSE;
    SIZEL   sizSrcMinusDst;
    SIZEL   sizMaskMinusDst;
    RECTL   rclSrc;
    RECTL   rclMask;

    ASSERT(pBltParam);
    ASSERT(prclClip);
    ASSERT(prclDst);

    pBltParam->rclClip  = *prclClip;
    pBltParam->prclClip = &pBltParam->rclClip;

    pBltParam->rclDst   = *prclDst;
    pBltParam->prclDst  = &pBltParam->rclDst;

    pBltParam->pptlSrc  = pptlSrc;
    if (pptlSrc)
    {
        pBltParam->ptlSrc = *pptlSrc;
        pBltParam->pptlSrc = &pBltParam->ptlSrc;
    }

    pBltParam->pptlMask = pptlMask;
    if (pptlMask)
    {
        pBltParam->ptlMask = *pptlMask;
        pBltParam->pptlMask = &pBltParam->ptlMask;
    }

    pBltParam->pptlBrush= pptlBrush;
    if (pptlBrush)
    {
        pBltParam->ptlBrush = *pptlBrush;
        pBltParam->pptlBrush = &pBltParam->ptlBrush;
    }

    if (pptlMask)
    {
        sizMaskMinusDst.cx = pptlMask->x  - prclDst->left;
        sizMaskMinusDst.cy = pptlMask->y  - prclDst->top;
    }

    if (pptlSrc)
    {
        ASSERT(prclSrcBoard);

        sizSrcMinusDst.cx = pptlSrc->x  - prclDst->left;
        sizSrcMinusDst.cy = pptlSrc->y  - prclDst->top;

        if (bRclIntersect(&pBltParam->rclClip, prclClip, prclDstBoard))
        {
            if (bRclIntersect(&pBltParam->rclDst, prclDst, &pBltParam->rclClip))
            {
                pBltParam->ptlSrc.x = pBltParam->rclDst.left + sizSrcMinusDst.cx;
                pBltParam->ptlSrc.y = pBltParam->rclDst.top  + sizSrcMinusDst.cy;
                rclSrc.left         = pBltParam->ptlSrc.x;
                rclSrc.top          = pBltParam->ptlSrc.y;
                rclSrc.right        = pBltParam->ptlSrc.x + pBltParam->rclDst.right - pBltParam->rclDst.left;
                rclSrc.bottom       = pBltParam->ptlSrc.y + pBltParam->rclDst.bottom - pBltParam->rclDst.top;

                if (bRclIntersect(&rclSrc, &rclSrc, prclSrcBoard))
                {
                    vRclSubOffset(&pBltParam->rclDst, &rclSrc, sizSrcMinusDst.cx, sizSrcMinusDst.cy); 

                    vRclSubOffset(&pBltParam->rclClip, &pBltParam->rclClip, prclDstBoard->left, prclDstBoard->top); 
                    vRclSubOffset(&pBltParam->rclDst, &pBltParam->rclDst, prclDstBoard->left, prclDstBoard->top); 
                    vRclSubOffset(&rclSrc, &rclSrc, prclSrcBoard->left, prclSrcBoard->top); 
                    pBltParam->ptlSrc.x = rclSrc.left;
                    pBltParam->ptlSrc.y = rclSrc.top;

                    if (pptlMask)
                    {
                        pBltParam->ptlMask.x = pBltParam->rclDst.left + prclDstBoard->left + sizMaskMinusDst.cx;
                        pBltParam->ptlMask.y = pBltParam->rclDst.top + prclDstBoard->top + sizMaskMinusDst.cy;
                    }
                    if (pptlBrush)
                    {
                        pBltParam->ptlBrush.x = pptlBrush->x - prclDstBoard->left;
                        pBltParam->ptlBrush.y = pptlBrush->y - prclDstBoard->top;
                    }
                    bRet = TRUE;
                }
            }
        }

    }
    else
    {
        if (bRclIntersect(&pBltParam->rclClip, prclClip, prclDstBoard))
        {
            if (bRclIntersect(&pBltParam->rclDst, prclDst, &pBltParam->rclClip))
            {
                vRclSubOffset(&pBltParam->rclClip, &pBltParam->rclClip, prclDstBoard->left, prclDstBoard->top); 
                vRclSubOffset(&pBltParam->rclDst, &pBltParam->rclDst, prclDstBoard->left, prclDstBoard->top); 

                if (pptlMask)
                {
                    pBltParam->ptlMask.x = pBltParam->rclDst.left + prclDstBoard->left + sizMaskMinusDst.cx;
                    pBltParam->ptlMask.y = pBltParam->rclDst.top + prclDstBoard->top + sizMaskMinusDst.cy;
                }

                if (pptlBrush)
                {
                    pBltParam->ptlBrush.x = pptlBrush->x - prclDstBoard->left;
                    pBltParam->ptlBrush.y = pptlBrush->y - prclDstBoard->top;
                }
                bRet = TRUE;
            }
        }


    }



    return bRet;
}

//******************************************************************************
//
//  vPatchGlyphs
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
void vPatchGlyphs(GLYPHPOS*  pgp, ULONG cGlyphs, LONG xOffset, LONG yOffset)
{
    ULONG ul;
    ASSERT(pgp);

    if (xOffset != 0 || yOffset != 0)
    {
        for (ul = 0; ul < cGlyphs; ul++)
        {
            pgp[ul].ptl.x += xOffset;
            pgp[ul].ptl.y += yOffset;
        }
    }
}


//******************************************************************************
//
//  MulTextOut
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
BOOL MulTextOut(SURFOBJ*  pso, STROBJ*   pstro, FONTOBJ*  pfo,
                CLIPOBJ*  pco, RECTL*    prclExtra, RECTL*    prclOpaque,
                BRUSHOBJ* pboFore, BRUSHOBJ* pboOpaque, POINTL*   pptlOrg, MIX mix)
{
    PPDEV ppdev = (PPDEV)pso->dhpdev; 
    BOOL  bRet  = FALSE;

    DISPDBG((100, "MulTextOut >>>"));

    ASSERT(ppdev);

    if( !ppdev->pmdev )
    {
        bRet = DrvTextOut(pso, pstro, pfo, pco, prclExtra, prclOpaque, pboFore, pboOpaque, pptlOrg, mix);
    }
    else
    {
        ULONG       cDevices;
        BOOL        bMore;
        BOOL        bMoreClip;
        ENUMDEV16   enumDev16;    
        ULONG       ulDevID;
        DEVOBJ      DevObj;
        BOARDDESC  *pBoardDesc;
        RECTL       rclClip;
        CLIPENUM    ce;
        LONG        l;
        POINTL     *pptlBoardOrg;
        POINTL      ptlOrg;
        RECTL       rclBoard;
        SURFOBJ    *psoBoard;
        RECTL       rclOpaque;
        RECTL      *prclBoardOpaque;
        STROBJ      SaveStrO;
        GLYPHPOS   *pgpOriginal;
        ULONG       cGlyphOriginal;
        BOOL        bMoreGlyphs;
        ULONG       ulGlyph;
        ULONG       iDComplexity;
        BOOL        bIntersectString;
        BOOL        bIntersectOpaque;

#if DBG
        DWORD dwLvl = 100;
        DISPDBG((dwLvl, "pco    :0x%x", pco));
        DISPDBG((dwLvl, "rclBkGd: (%d, %d) - (%d, %d)", pstro->rclBkGround.left, pstro->rclBkGround.top, pstro->rclBkGround.right, pstro->rclBkGround.bottom));
        if (prclOpaque)
            DISPDBG((dwLvl, "rclOpaque: (%d, %d) - (%d, %d)", prclOpaque->left, prclOpaque->top, prclOpaque->right, prclOpaque->bottom));
        if (prclExtra)
            DISPDBG((dwLvl, "rclExtra: (%d, %d) - (%d, %d)", prclExtra->left, prclExtra->top, prclExtra->right, prclExtra->bottom));
        if (pboFore)
            DISPDBG((dwLvl, "Fore Color: 0x%x", pboFore->iSolidColor));
        if (pboOpaque)
            DISPDBG((dwLvl, "Opaque Color: 0x%x", pboOpaque->iSolidColor));
#endif

        cDevices = DEVOBJ_cEnumStart(&DevObj, pso, NULL, TRUE, CD_ANY);
        if (cDevices)
        {
            do 
            {
                bMore = DEVOBJ_bEnum(&DevObj, &enumDev16);
                for (ulDevID = 0; ulDevID < enumDev16.c; ulDevID++)
                {
                    pBoardDesc = enumDev16.apbdDevices[ulDevID];
                    psoBoard = psoGetBoardRectAndSync( IN pso, IN pBoardDesc, IN NULL, OUT &rclBoard);

                    prclBoardOpaque = prclOpaque;
                    if (prclOpaque)
                    {
                        if (bRclIntersect(&rclOpaque, prclOpaque, &rclBoard))
                        {
                            vRclSubOffset(&rclOpaque, &rclOpaque, rclBoard.left, rclBoard.top);                            
                            prclBoardOpaque = &rclOpaque;
                        }

                    }

                    pptlBoardOrg = pptlOrg;
                    if (pptlBoardOrg)
                    {
                        ptlOrg.x = pptlOrg->x - rclBoard.left;
                        ptlOrg.y = pptlOrg->y - rclBoard.top;
                        pptlBoardOrg = &ptlOrg;
                    }


                    iDComplexity = NULL == pco ? DC_TRIVIAL : pco->iDComplexity;

                    if (DC_TRIVIAL == iDComplexity || DC_RECT == iDComplexity)
                    {
                        if (DC_RECT == iDComplexity)
                        {
                            if (!bRclIntersect(&pBoardDesc->pco->rclBounds, &pco->rclBounds, &rclBoard))
                                continue;
                        }
                        else
                        {
                            pBoardDesc->pco->rclBounds        = rclBoard;    
                        }

                        // string is completely outside of clip or board rect, so go haead next board
                        bIntersectOpaque = prclOpaque ? bRclIntersect(NULL, &pBoardDesc->pco->rclBounds, prclOpaque) : FALSE;
                        bIntersectString = bRclIntersect(NULL, &pBoardDesc->pco->rclBounds, &pstro->rclBkGround);

                        if (!bIntersectString && !bIntersectOpaque)
                            continue;

                        vRclSubOffset(&pBoardDesc->pco->rclBounds, &pBoardDesc->pco->rclBounds, rclBoard.left, rclBoard.top);

                        if (!pstro->pgp)
                            STROBJ_vEnumStart(pstro);

                        do {
                            SaveStrO   = *pstro;

                            if (pstro->pgp)
                            {
                                bMoreGlyphs     = FALSE;
                                pgpOriginal     = pstro->pgp;
                                cGlyphOriginal  = pstro->cGlyphs;
                            }
                            else
                            {
                                bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyphOriginal, &pgpOriginal);
                            }

                            vPatchGlyphs(pgpOriginal, cGlyphOriginal, -rclBoard.left, -rclBoard.top);

                            pstro->pgp      = pgpOriginal;
                            pstro->cGlyphs  = cGlyphOriginal;

                            vRclSubOffset(&pstro->rclBkGround, &pstro->rclBkGround, rclBoard.left, rclBoard.top);

                            bRet = DrvTextOut(psoBoard, pstro, pfo, pBoardDesc->pco, prclExtra, prclBoardOpaque, pboFore, pboOpaque, pptlBoardOrg, mix);

                            vPatchGlyphs(pgpOriginal, cGlyphOriginal, rclBoard.left, rclBoard.top);

                            *pstro = SaveStrO;
                        }
                        while (bMoreGlyphs);
                    }
                    else
                    {
                        if (!bRclIntersect(&pBoardDesc->pco->rclBounds, &pco->rclBounds, &pBoardDesc->rclBoard))
                            continue;

                        // string is completely outside of clip or board rect, so go haead next board
                        bIntersectOpaque = prclOpaque ? bRclIntersect(NULL, &pBoardDesc->pco->rclBounds, prclOpaque) : FALSE;
                        bIntersectString = bRclIntersect(NULL, &pBoardDesc->pco->rclBounds, &pstro->rclBkGround);

                        if (!bIntersectString && !bIntersectOpaque)
                            continue;

                        if (!pstro->pgp)
                            STROBJ_vEnumStart(pstro);

                        do {
                            SaveStrO   = *pstro;
                            if (pstro->pgp)
                            {
                                bMoreGlyphs     = FALSE;
                                pgpOriginal     = pstro->pgp;
                                cGlyphOriginal  = pstro->cGlyphs;
                            }
                            else
                            {
                                bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyphOriginal, &pgpOriginal);
                            }

                            vRclSubOffset(&pstro->rclBkGround, &pstro->rclBkGround, rclBoard.left, rclBoard.top);

                            vPatchGlyphs(pgpOriginal, cGlyphOriginal, -rclBoard.left, -rclBoard.top);

                            pstro->pgp      = pgpOriginal;
                            pstro->cGlyphs  = cGlyphOriginal;

                            CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

                            do  
                            {
                                bMoreClip = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);
                                for (l = 0; l < ce.c; l++)
                                {
                                    if (bRclIntersect(&pBoardDesc->pco->rclBounds, &ce.arcl[l], &pBoardDesc->rclBoard))
                                    {
                                        vRclSubOffset(&pBoardDesc->pco->rclBounds, &pBoardDesc->pco->rclBounds, pBoardDesc->rclBoard.left, pBoardDesc->rclBoard.top);

                                        bRet = DrvTextOut(psoBoard, pstro, pfo, pBoardDesc->pco, prclExtra, prclBoardOpaque, pboFore, pboOpaque, pptlBoardOrg, mix);
                                    }
                                }
                            }
                            while (bMoreClip);

                            vPatchGlyphs(pgpOriginal, cGlyphOriginal, rclBoard.left, rclBoard.top);

                            *pstro = SaveStrO;
                        }
                        while (bMoreGlyphs);
                    }
                }
            }
            while (bMore && bRet);
        }
    }
    
    DISPDBG((100,"<<< MulTextOut %d", bRet));
    return bRet;
}


//******************************************************************************
//
//  ulGetBlitDirection
//
//  NT4 multiboard helper function which calculates the direction of a blit
//  to get the right clip enumeration
//
//******************************************************************************
ULONG ulGetBlitDirection( POINTL* pptlSrc, RECTL* prclDst)
{
    ULONG ulDir = CD_ANY;

    ASSERT(prclDst);

    if (pptlSrc)
    {
        if (prclDst->left < pptlSrc->x)
        {
            if (prclDst->top < pptlSrc->y)
            {
                ulDir = CD_RIGHTDOWN;
            }
            else if (prclDst->top == pptlSrc->y)
            {
                ulDir = CD_RIGHTDOWN;
            }
            else
            {
                ulDir = CD_RIGHTUP;
            }
        }
        else if (prclDst->left == pptlSrc->x)
        {
            if (prclDst->top < pptlSrc->y)
            {
                ulDir = CD_RIGHTDOWN;
            }
            else if (prclDst->top == pptlSrc->y)
            {
                ulDir = CD_ANY;
            }
            else
            {
                ulDir = CD_RIGHTUP;
            }
        }
        else
        {
            if (prclDst->top < pptlSrc->y)
            {
                ulDir = CD_LEFTDOWN;
            }
            else if (prclDst->top == pptlSrc->y)
            {
                ulDir = CD_LEFTDOWN;
            }
            else
            {
                ulDir = CD_LEFTUP;
            }
        }
    }

    return ulDir;
}


//******************************************************************************
//
//  MulBitBlt
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
BOOL MulBitBlt(SURFOBJ*  psoDst, SURFOBJ*  psoSrc, SURFOBJ*  psoMask,
                CLIPOBJ*  pco, XLATEOBJ* pxlo, RECTL*    prclDst,
                POINTL*   pptlSrc, POINTL*   pptlMask, BRUSHOBJ* pbo,
                POINTL*   pptlBrush, ROP4      rop4)
{
    BOOL  bRet  = FALSE;
    PPDEV ppdev = NULL;

    DISPDBG((100, "MulBitBlt >>>"));

    if(psoDst)
        ppdev = (PPDEV)psoDst->dhpdev; 
    if(!ppdev)
    {
        ASSERT(psoSrc);
        ppdev = (PPDEV)psoSrc->dhpdev; 
    }

    ASSERT(ppdev);

    if( !ppdev->pmdev )
    {
         bRet = DrvBitBlt(psoDst, psoSrc, psoMask, pco, pxlo, prclDst, pptlSrc, pptlMask, pbo, pptlBrush, rop4);
    }
    else
    {
        ULONG   ulDev;
        BOOL    bNeedToEnumTrg;
        BOOL    bNeedToEnumSrc;
        ULONG   cDstDevices;
        ULONG   cSrcDevices;
        BOOL    bDstMore;
        BOOL    bSrcMore;
        ENUMDEV16 enumDstDev16; 
        ENUMDEV16 enumSrcDev16; 
        ULONG   ulDstDevID;
        ULONG   ulSrcDevID;
        DEVOBJ  DstDevObj;
        DEVOBJ  SrcDevObj;
        BOARDDESC *pDstBoardDesc;
        BOARDDESC *pSrcBoardDesc;
        RECTL   rclDst;
        POINTL  ptlSrc;
        POINTL  ptlMask;
        POINTL  ptlBrush;
        BOOL    bMoreClip;
        LONG    l;
        CLIPENUM    ce;
        RECTL       rclDstBoard;
        RECTL       rclSrcBoard;
        BLT_PARAM   BltParam;
        ULONG       ulDir;

#if DBG
        DWORD dwLvl = 10;

        DISPDBG((dwLvl, "MulBitBlt >>>"));
        DISPDBG((dwLvl, "prclDst:0x%x", prclDst));
        DISPDBG((dwLvl, "pco    :0x%x", pco));
        DISPDBG((dwLvl, "rclDst: (%d, %d) - (%d, %d)", prclDst->left, prclDst->top, prclDst->right, prclDst->bottom));
        if (pbo)
            DISPDBG((dwLvl, "Color: 0x%x", pbo->iSolidColor));
#endif

        bNeedToEnumTrg = bNeedToEnumerate(psoDst);
        bNeedToEnumSrc = bNeedToEnumerate(psoSrc);

        if (bNeedToEnumTrg || bNeedToEnumSrc)
        {
            ulDir = ulGetBlitDirection(pptlSrc,prclDst);

            rclDst  = *prclDst;
            prclDst = &rclDst;

            if (pptlSrc)
            {
                ptlSrc  = *pptlSrc;
                pptlSrc = &ptlSrc;
            }

            if (pptlMask)
            {
                ptlMask  = *pptlMask;
                pptlMask = &ptlMask;
            }
            if (pptlBrush)
            {
                ptlBrush  = *pptlBrush;
                pptlBrush = &ptlBrush;
            }

            cDstDevices = DEVOBJ_cEnumStart(&DstDevObj, psoDst, NULL, TRUE, ulDir);
            if (cDstDevices)
            {
                bDstMore = TRUE;
                bRet  = TRUE;
                while (bDstMore && bRet)
                {
                    bDstMore = DEVOBJ_bEnum(&DstDevObj, &enumDstDev16);
                    for (ulDstDevID = 0; ulDstDevID < enumDstDev16.c; ulDstDevID++)
                    {
                        pDstBoardDesc = enumDstDev16.apbdDevices[ulDstDevID]; // maybe NULL on Memory bitmaps
                        BltParam.psoDst = psoGetBoardRectAndSync( IN psoDst, IN pDstBoardDesc, IN NULL, OUT &rclDstBoard);

                        cSrcDevices = DEVOBJ_cEnumStart(&SrcDevObj, psoSrc, NULL, TRUE, ulDir);
                        do
                        {
                            bSrcMore    = DEVOBJ_bEnum(&SrcDevObj, &enumSrcDev16);

                            for (ulSrcDevID = 0; ulSrcDevID < enumSrcDev16.c; ulSrcDevID++)
                            {
                                pSrcBoardDesc = enumSrcDev16.apbdDevices[ulSrcDevID];       // maybe NULL on Memory bitmaps

                                BltParam.psoSrc = psoGetBoardRectAndSync( IN psoSrc, IN pSrcBoardDesc, IN pDstBoardDesc, OUT &rclSrcBoard);
                                if (!BltParam.psoSrc)
                                    rclSrcBoard = rclDstBoard;

                                bRet = TRUE;
                                if (NULL == pco || DC_TRIVIAL == pco->iDComplexity)
                                {
                                    if (bTranslateBitBltParams( IN &rclDstBoard,
                                                                IN &rclSrcBoard,
                                                                rop4,
                                                                &rclDstBoard,  // as rclClip
                                                                prclDst, pptlSrc, pptlMask, pptlBrush, &BltParam))
                                        bRet = DrvBitBlt(BltParam.psoDst, BltParam.psoSrc, psoMask, NULL, pxlo, 
                                                        BltParam.prclDst, BltParam.pptlSrc, BltParam.pptlMask, pbo, BltParam.pptlBrush, rop4);
                                }
                                else if (DC_RECT == pco->iDComplexity)
                                {
                                    pDstBoardDesc->pco->rclBounds = pco->rclBounds;

                                    if (bTranslateBitBltParams( IN &rclDstBoard,
                                                                IN &rclSrcBoard,
                                                                rop4,
                                                                &pDstBoardDesc->pco->rclBounds,  // as rclClip
                                                                prclDst, pptlSrc, pptlMask, pptlBrush, &BltParam))
                                        bRet = DrvBitBlt(BltParam.psoDst, BltParam.psoSrc, psoMask, NULL, pxlo, 
                                                        BltParam.prclDst, BltParam.pptlSrc, BltParam.pptlMask, pbo, BltParam.pptlBrush, rop4);

                                }
                                else
                                {
                                    CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, ulDir, 0);
                                    do  
                                    {
                                        bMoreClip = CLIPOBJ_bEnum(pco, sizeof(CLIPENUM), (ULONG*) &ce);
                                        for (l = 0; l < ce.c; l++)
                                        {
                                            if (bTranslateBitBltParams( IN &rclDstBoard,
                                                                        IN &rclSrcBoard,
                                                                        rop4,
                                                                        &ce.arcl[l],  // as rclClip
                                                                        prclDst, pptlSrc, pptlMask, pptlBrush, &BltParam))
                                            bRet = DrvBitBlt(BltParam.psoDst, BltParam.psoSrc, psoMask, NULL, pxlo, 
                                                            BltParam.prclDst, BltParam.pptlSrc, BltParam.pptlMask, pbo, BltParam.pptlBrush, rop4);
                                        }
                                    }
                                    while (bMoreClip);
                                }
                            }
                        }
                        while (bSrcMore);
                    }
                }

            }
        }
        else
        {
            ASSERT(FALSE);
            bRet = EngBitBlt(psoDst, psoSrc, psoMask, pco, pxlo, prclDst, pptlSrc, pptlMask, pbo, pptlBrush, rop4);
        }
    }

    ASSERT(bRet);

    DISPDBG((100, "<<< MulBitBlt - %d", bRet));

    return bRet;
}


//******************************************************************************
//
//  MulCopyBits
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
BOOL MulCopyBits(SURFOBJ*  psoDst, SURFOBJ*  psoSrc, CLIPOBJ*  pco,
                XLATEOBJ* pxlo, RECTL*    prclDst, POINTL*   pptlSrc)
{
    BOOL  bRet  = FALSE;
    PPDEV ppdev = NULL;

    DISPDBG((100, "MulCopyBits >>>"));

    if(psoDst)
        ppdev = (PPDEV)psoDst->dhpdev; 
    if(!ppdev)
    {
        ASSERT(psoSrc);
        ppdev = (PPDEV)psoSrc->dhpdev; 
    }

    ASSERT(ppdev);

    if( !ppdev->pmdev )
    {
        bRet = DrvCopyBits(psoDst, psoSrc, pco, pxlo, prclDst, pptlSrc);
    }
    else
    {

        PMDEV   pmdev = ppdev->pmdev;  
        ULONG   ulDev;
        BOOL    bNeedToEnumTrg;
        BOOL    bNeedToEnumSrc;
        ULONG   cDstDevices;
        ULONG   cSrcDevices;
        BOOL    bDstMore;
        BOOL    bSrcMore;
        ENUMDEV16 enumDstDev16; 
        ENUMDEV16 enumSrcDev16; 
        ULONG   ulDstDevID;
        ULONG   ulSrcDevID;
        DEVOBJ  DstDevObj;
        DEVOBJ  SrcDevObj;
        BOARDDESC *pDstBoardDesc;
        BOARDDESC *pSrcBoardDesc;
        RECTL   rclDst;
        POINTL  ptlSrc;
        BOOL    bMoreClip;
        LONG    l;
        CLIPENUM    ce;
        RECTL       rclDstBoard;
        RECTL       rclSrcBoard;
        BLT_PARAM   BltParam;
        ULONG       ulDir;

#if DBG
        DWORD dwLvl = 10;
        DISPDBG((dwLvl, "MulCopyBits >>>"));
        DISPDBG((dwLvl, "prclDst:0x%x", prclDst));
        DISPDBG((dwLvl, "pco    :0x%x", pco));
        DISPDBG((dwLvl, "rclDst: (%d, %d) - (%d, %d)", prclDst->left, prclDst->top, prclDst->right, prclDst->bottom));
#endif

        bNeedToEnumTrg = bNeedToEnumerate(psoDst);
        bNeedToEnumSrc = bNeedToEnumerate(psoSrc);

        if (bNeedToEnumTrg || bNeedToEnumSrc)
        {
            ulDir = ulGetBlitDirection(pptlSrc,prclDst);

            rclDst  = *prclDst;
            prclDst = &rclDst;

            if (pptlSrc)
            {
                ptlSrc  = *pptlSrc;
                pptlSrc = &ptlSrc;
            }

            cDstDevices = DEVOBJ_cEnumStart(&DstDevObj, psoDst, NULL, TRUE, ulDir);
            if (cDstDevices)
            {
                bDstMore = TRUE;
                bRet  = TRUE;
                while (bDstMore && bRet)
                {
                    bDstMore = DEVOBJ_bEnum(&DstDevObj, &enumDstDev16);
                    for (ulDstDevID = 0; ulDstDevID < enumDstDev16.c; ulDstDevID++)
                    {
                        pDstBoardDesc = enumDstDev16.apbdDevices[ulDstDevID]; // maybe NULL on Memory bitmaps
                        BltParam.psoDst = psoGetBoardRectAndSync( IN psoDst, IN pDstBoardDesc, IN NULL, OUT &rclDstBoard);

                        cSrcDevices = DEVOBJ_cEnumStart(&SrcDevObj, psoSrc, NULL, TRUE, ulDir);
                        do
                        {
                            bSrcMore    = DEVOBJ_bEnum(&SrcDevObj, &enumSrcDev16);

                            for (ulSrcDevID = 0; ulSrcDevID < enumSrcDev16.c; ulSrcDevID++)
                            {
                                pSrcBoardDesc = enumSrcDev16.apbdDevices[ulSrcDevID];       // maybe NULL on Memory bitmaps

                                BltParam.psoSrc = psoGetBoardRectAndSync( IN psoSrc, IN pSrcBoardDesc, IN pDstBoardDesc, OUT &rclSrcBoard);
                                if (!BltParam.psoSrc)
                                    rclSrcBoard = rclDstBoard;

                                bRet = TRUE;
                                if (NULL == pco || DC_TRIVIAL == pco->iDComplexity)
                                {
                                    if (bTranslateBitBltParams( IN &rclDstBoard,
                                                                IN &rclSrcBoard,
                                                                0xcccc,
                                                                &rclDstBoard,  // as rclClip
                                                                prclDst, pptlSrc, NULL, NULL, &BltParam))

                                        bRet = DrvCopyBits(BltParam.psoDst, BltParam.psoSrc, NULL, pxlo, BltParam.prclDst, BltParam.pptlSrc);
                                }
                                else if (DC_RECT == pco->iDComplexity)
                                {
                                    pDstBoardDesc->pco->rclBounds = pco->rclBounds;

                                    if (bTranslateBitBltParams( IN &rclDstBoard,
                                                                IN &rclSrcBoard,
                                                                0xcccc,
                                                                &pDstBoardDesc->pco->rclBounds,  // as rclClip
                                                                prclDst, pptlSrc, NULL, NULL, &BltParam))
                                        bRet = DrvCopyBits(BltParam.psoDst, BltParam.psoSrc, NULL, pxlo, BltParam.prclDst, BltParam.pptlSrc);

                                }
                                else
                                {
                                    CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, ulDir, 0);
                                    do  
                                    {
                                        bMoreClip = CLIPOBJ_bEnum(pco, sizeof(CLIPENUM), (ULONG*) &ce);
                                        for (l = 0; l < ce.c; l++)
                                        {
                                            if (bTranslateBitBltParams( IN &rclDstBoard,
                                                                        IN &rclSrcBoard,
                                                                        0xcccc,
                                                                        &ce.arcl[l],  // as rclClip
                                                                        prclDst, pptlSrc, NULL, NULL, &BltParam))
                                                bRet = DrvCopyBits(BltParam.psoDst, BltParam.psoSrc, NULL, pxlo, BltParam.prclDst, BltParam.pptlSrc);
                                        }
                                    }
                                    while (bMoreClip);
                                }
                            }
                        }
                        while (bSrcMore);
                    }
                }

            }
        }
        else
        {
            ASSERT(FALSE);
            bRet = DrvCopyBits(psoDst, psoSrc, pco, pxlo, prclDst, pptlSrc);
        }
    }

    ASSERT(bRet);

    DISPDBG((100, "<<< MulCopyBits - %d", bRet));
    return bRet;
}


//******************************************************************************
//
//  MulStretchBlt
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
BOOL MulStretchBlt( SURFOBJ*            psoDst,
                    SURFOBJ*            psoSrc,
                    SURFOBJ*            psoMask,
                    CLIPOBJ*            pco,
                    XLATEOBJ*           pxlo,
                    COLORADJUSTMENT*    pca,
                    POINTL*             pptlHTOrg,
                    RECTL*              prclDst,
                    RECTL*              prclSrc,
                    POINTL*             pptlMask,
                    ULONG               iMode)
{
    BOOL  bRet  = FALSE;
    PPDEV ppdev = NULL;

    DISPDBG((100, "MulStretchBlt >>>"));

    if(psoDst)
        ppdev = (PPDEV)psoDst->dhpdev; 
    if(!ppdev)
    {
        ASSERT(psoSrc);
        ppdev = (PPDEV)psoSrc->dhpdev; 
    }

    ASSERT(ppdev);

    if( !ppdev->pmdev )
    {
        bRet = DrvStretchBlt(psoDst, psoSrc, psoMask, pco, pxlo, pca, pptlHTOrg, prclDst, prclSrc, pptlMask, iMode);
    }
    else
    {

        PMDEV   pmdev = ppdev->pmdev;  
        ULONG   ulDev;

        // have to implement this if needed
        ASSERT( FALSE );
    }
    DISPDBG((100, "<<< MulStretchBlt"));
    return TRUE;
}


#endif // NT4_MULTI_DEV
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nt4multidev.c ===
//************************** Module Header *************************************
//                                                                             
//  Module Name: nt4multidev.c                                                 
//                                                                             
//  This module contains the functions that belong to the multi device wrapper 
//
//
//  NT4 MultiBoard functionality description:
//
// Supports multiple display boards as a single virtual desktop.
//
// This is implemented by presenting to GDI a single large virtual
// display and adding a layer between GDI and the driver's Drv functions.
// For  most part, the rest of the driver outside of multidev wrapper 
// doesn't have to change much, subject to the requirements below.
//
// This implementation requires that each board have the same colour depth,
// the resolution may vary but all of the the boards have to be arranged 
// in a rectangular configuration.
//
// Each board has its own PDEV, and completely manages its surface
// independently.
//
//   Copyright (C) 2000 NVidia Corporation. All Rights Reserved.               
//                                                                             
//*****************************************************************************
#include "precomp.h"
#include "driver.h"
#include "RectUtils.h"

#include "nt4multidev.h"

#ifdef NT4_MULTI_DEV


// this is the functiontable we export in NT4-case to be able to support NT4 multimon
DRVFN gadrvfn[] = {
    {   INDEX_DrvEnablePDEV,            (PFN) MulEnablePDEV         },
    {   INDEX_DrvCompletePDEV,          (PFN) MulCompletePDEV       },
    {   INDEX_DrvDisablePDEV,           (PFN) MulDisablePDEV        },
    {   INDEX_DrvEnableSurface,         (PFN) MulEnableSurface      },
    {   INDEX_DrvDisableSurface,        (PFN) MulDisableSurface     },
    {   INDEX_DrvAssertMode,            (PFN) MulAssertMode         },
    {   INDEX_DrvMovePointer,           (PFN) MulMovePointer        },
    {   INDEX_DrvSetPointerShape,       (PFN) MulSetPointerShape    },
    {   INDEX_DrvDitherColor,           (PFN) DrvDitherColor        },  // can be redirected to 1st board
    {   INDEX_DrvSetPalette,            (PFN) MulSetPalette         },
    {   INDEX_DrvCopyBits,              (PFN) MulCopyBits           },
    {   INDEX_DrvBitBlt,                (PFN) MulBitBlt             },
    {   INDEX_DrvTextOut,               (PFN) MulTextOut            },
    {   INDEX_DrvGetModes,              (PFN) MulGetModes           },
    {   INDEX_DrvLineTo,                (PFN) MulLineTo             },
    {   INDEX_DrvStrokePath,            (PFN) MulStrokePath         },
    {   INDEX_DrvFillPath,              (PFN) MulFillPath           },  // not supported
    {   INDEX_DrvPaint,                 (PFN) MulPaint              },
    {   INDEX_DrvRealizeBrush,          (PFN) MulRealizeBrush       },
    {   INDEX_DrvCreateDeviceBitmap,    (PFN) MulCreateDeviceBitmap },
    {   INDEX_DrvDeleteDeviceBitmap,    (PFN) MulDeleteDeviceBitmap },
//  {   INDEX_DrvStretchBlt,            (PFN) MulStretchBlt         },  // not implemented or hooked
    {   INDEX_DrvDestroyFont,           (PFN) DrvDestroyFont        },  // if we need to implement, we 
#ifndef NVGDI                                                           //need to change FONTOBJ->pvconsumer
    {   INDEX_DrvGetDirectDrawInfo,     (PFN) MulGetDirectDrawInfo  },
    {   INDEX_DrvEnableDirectDraw,      (PFN) MulEnableDirectDraw   },
    {   INDEX_DrvDisableDirectDraw,     (PFN) MulDisableDirectDraw  },
#endif
    {   INDEX_DrvSynchronize,           (PFN) MulSynchronize        },
    {   INDEX_DrvEscape,                (PFN) MulEscape             },
    {   INDEX_DrvDrawEscape,            (PFN) MulDrawEscape         },
    {   INDEX_DrvResetPDEV,             (PFN) MulResetPDEV          },
    {   INDEX_DrvDescribePixelFormat,   (PFN) MulDescribePixelFormat},
    {   INDEX_DrvSetPixelFormat,        (PFN) MulSetPixelFormat     },
    {   INDEX_DrvSwapBuffers,           (PFN) MulSwapBuffers        },
#if (NVARCH >= 0x4)
    {   INDEX_DrvSaveScreenBits,        (PFN) MulSaveScreenBits     },
#endif
};
ULONG gcdrvfn = sizeof(gadrvfn) / sizeof(DRVFN);





BOOL bSwapCompareCallback(RECTL *prcl1, RECTL *prcl2, ULONG	iDir)
{
    BOOL bSwap = FALSE;

    ASSERT(prcl1);
    ASSERT(prcl2);

    switch (iDir)
    {
    case CD_RIGHTDOWN:
        if (prcl1->top > prcl2->top)
        {
            bSwap = TRUE;
        }
        else if (prcl1->top == prcl2->top)
        {
            if (prcl1->left > prcl2->left)
            {
                bSwap = TRUE;
            }
        }
        break;
    case CD_LEFTDOWN:
        if (prcl1->top > prcl2->top)
        {
            bSwap = TRUE;
        }
        else if (prcl1->top == prcl2->top)
        {
            if (prcl1->left < prcl2->left)
            {
                bSwap = TRUE;
            }
        }
        break;
    case CD_RIGHTUP:
        if (prcl1->top < prcl2->top)
        {
            bSwap = TRUE;
        }
        else if (prcl1->top == prcl2->top)
        {
            if (prcl1->left > prcl2->left)
            {
                bSwap = TRUE;
            }
        }
        break;
    case CD_LEFTUP:
        if (prcl1->top < prcl2->top)
        {
            bSwap = TRUE;
        }
        else if (prcl1->top == prcl2->top)
        {
            if (prcl1->left < prcl2->left)
            {
                bSwap = TRUE;
            }
        }
        break;
    case CD_ANY:
    default:
        bSwap = FALSE;
    }
    return bSwap;
}


// some helper funtions
ULONG DEVOBJ_cEnumStart(IN PDEVOBJ  pdo,
                        IN SURFOBJ  *pso,
                        IN RECTL    *prclBounds, // dont care if bAll = TRUE
                        IN BOOL     bAll,       // TRUE: enumerates all, FALSE enumerates only dev clipped against prclbounds
                        IN ULONG    iDir)  // CD_ANY...
{
    PMDEV   pmdev;
    ULONG   ul;
    ULONG   ulRet;
    ULONG   ulOuter;
    ULONG   ulInner;

    pdo->pso = pso;

    if (bNeedToEnumerate(pso))
    {
        pmdev               = ((PPDEV)pso->dhpdev)->pmdev;

        pdo->pmdev          = pmdev;
        pdo->enumStart      = 0;

        // copy to pointer array
        for (ul = 0; ul < pmdev->ulNumDevicesActive; ul++)
        {
            pdo->apbdDevices[ul] = &pdo->pmdev->abdDevices[ul];
            pdo->enumStart++;
        }

        if (pmdev->ulNumDevicesActive > 1)
        {
            for (ulOuter = 0; ulOuter < (pmdev->ulNumDevicesActive - 1); ulOuter++)
            {
                for (ulInner = ulOuter + 1; ulInner < pmdev->ulNumDevicesActive; ulInner++)
                {
                    if (bSwapCompareCallback(&pdo->apbdDevices[ulOuter]->rclBoard, &pdo->apbdDevices[ulInner]->rclBoard, iDir))
                    {
                        PBOARDDESC pScratch;
                        pScratch = pdo->apbdDevices[ulOuter];
                        pdo->apbdDevices[ulOuter] = pdo->apbdDevices[ulInner];
                        pdo->apbdDevices[ulInner] = pScratch;
                    }
                }
            }
        }

        pdo->cDevices = pmdev->ulNumDevicesActive;
        ulRet = pmdev->ulNumDevicesActive;
    }
    else
    {
        pdo->pmdev      = NULL;
        pdo->cDevices   = 1; 
        ulRet           = 1;
    }

    return (ulRet);
}

BOOL DEVOBJ_bEnum(IN PDEVOBJ    pdo,
                  IN ENUMDEV16  *pEnumDev16)
{
    ULONG ul;
    BOOL    bRet;

    ASSERT(pdo);
    ASSERT(pEnumDev16);

    pEnumDev16->c = pdo->cDevices;

    if (pdo->pmdev)
    {
        for (ul = 0; ul < pEnumDev16->c; ul++)
        {
            pEnumDev16->apbdDevices[ul] = pdo->apbdDevices[ul];
            pdo->enumStart++;
        }
        bRet = pdo->enumStart < pdo->pmdev->ulNumDevicesActive ? TRUE : FALSE;
    }
    else
    {
        ASSERT(pEnumDev16->c == 1);
        pEnumDev16->apbdDevices[0] = NULL;
        pdo->enumStart++;
        bRet = FALSE;
    }
    return bRet;
}
                        



// the wrapper functions


//******************************************************************************
//
//  bGetNumberOfDevices
//
//  NT4 multiboard helper function to get number of initialized (nVidia graphics )
//  devices from miniport
//
//  returns TRUE  if call to miniport succeded
//          FALSE if call to miniport did fail
//
//******************************************************************************
BOOL bGetNumberOfDevices( HANDLE hDriver, ULONG_PTR* pulNumberOfDevices )
{
    BOOL                        bRet = FALSE;
    QUERY_NUM_OF_DEVICE_OBJECTS NumOfDevObj;
    ULONG                       ulReturnedDataLength;

    ASSERT(pulNumberOfDevices);
    ASSERT(hDriver);

    NumOfDevObj.hDriver     = hDriver;

    // call minipoirt to get adresses of all initialized device handles
    if(  ( EngDeviceIoControl(hDriver,
                              IOCTL_VIDEO_QUERY_NUM_OF_DEVICE_OBJECTS,
                              &NumOfDevObj,
                              sizeof(QUERY_NUM_OF_DEVICE_OBJECTS),
                              &NumOfDevObj,
                              sizeof(QUERY_NUM_OF_DEVICE_OBJECTS),
                              &ulReturnedDataLength ) )
       ||( ulReturnedDataLength != sizeof(QUERY_NUM_OF_DEVICE_OBJECTS) )
      ) 
    {
        DISPDBG((0, "bGetNumberOfDevices - IOCTL_VIDEO_QUERY_NUM_OF_DEVICE_OBJECTS failed"));
        pulNumberOfDevices = 0;
    }
    else
    {
        DISPDBG((95, "bGetNumberOfDevices - IOCTL_VIDEO_QUERY_NUM_OF_DEVICE_OBJECTS found %d device objects", NumOfDevObj.ulNumDevObj));
        *pulNumberOfDevices  = NumOfDevObj.ulNumDevObj;
        bRet                 = TRUE;
    }

    return bRet;
}


//******************************************************************************
//
//  bGetDeviceObjects
//
//  NT4 multiboard helper function to get handles to initialized (nVidia graphics )
//  devices from miniport
//
//  returns TRUE  if call to miniport succeded
//          FALSE if call to miniport did fail
//
//******************************************************************************
BOOL bGetDeviceObjects( HANDLE hDriver, HANDLE ahDriver[MAX_MULTIDEV])
{
    BOOL  bRet     = FALSE;
    ULONG ulDevNum = 0;

    ASSERT(ahDriver);
    ASSERT(hDriver);

    // preset hDriverarray to zero
    RtlZeroMemory(ahDriver,sizeof(HANDLE)*MAX_MULTIDEV);

    // does miniport support multibple devices and do we have one or more ?
    if(   (bGetNumberOfDevices(hDriver,&ulDevNum))
        &&(ulDevNum > 0 )
       )
    {
        GET_DEVICE_OBJECTS  *pGetDevObj;
        ULONG                ulSizeOfGetDeviceObjects; 
        ULONG                ulReturnedDataLength;
        
        // allocate right size for miniport access
        ulSizeOfGetDeviceObjects = sizeof(GET_DEVICE_OBJECTS) + (ulDevNum - 1) * sizeof (HANDLE);
        pGetDevObj = (GET_DEVICE_OBJECTS *)EngAllocMem(FL_ZERO_MEMORY, ulSizeOfGetDeviceObjects, ALLOC_TAG); ;
        if (pGetDevObj)
        {
            pGetDevObj->hDriver     = hDriver;
            pGetDevObj->ulNumDevObj = ulDevNum;

            // ask miniport for hDriver of all nvidia graphic devices in system
            if (EngDeviceIoControl(hDriver,
                                   IOCTL_VIDEO_GET_DEVICE_OBJECTS,
                                   pGetDevObj,
                                   ulSizeOfGetDeviceObjects,
                                   pGetDevObj,
                                   ulSizeOfGetDeviceObjects,
                                   &ulReturnedDataLength) || ulReturnedDataLength != ulSizeOfGetDeviceObjects)
            {
                DISPDBG((0, "bGetDeviceObjects - IOCTL_VIDEO_GET_DEVICE_OBJECTS failed"));
            }
            else
            {
                ULONG ulDev;
                DISPDBG((95, "bGetDeviceObjects - hDriver 0x%x found %d devices", hDriver,ulDevNum));
                for (ulDev = 0; ulDev < ulDevNum; ulDev++)
                {
                    ahDriver[ulDev] = pGetDevObj->ahDriver[ulDev];
                    DISPDBG((95, "bGetDeviceObjects - no %d: hDriver: 0x%x",ulDev,ahDriver[ulDev]));
                }
                bRet = TRUE;
            }

            EngFreeMem(pGetDevObj);
        }
    }

    return bRet;
}


//******************************************************************************
//
//  bIsMultiMonMode
//
//  NT4 multiboard helper function check whether given mode is a multimon mode
//  or not
//
//  returns TRUE  if given mode is a multi device
//          FALSE if given mode is no multi device mode
//
//******************************************************************************
BOOL bIsMultiMonMode( HANDLE hDriver, DEVMODEW* pdm)
{
    BOOL    bRet = FALSE;
    ULONG   ulSingleDevWidth;  // width  of each single device    
    ULONG   ulSingleDevHeight; // height of each single device    
    ULONG   ulModeDescription; // width << 16 | height to be able to do a switch

    ASSERT(pdm);
    ASSERT(hDriver);
    // we may have to find another mechanism to check wether we need a
    // multimon resolution or not

    // try to calculate an aspect ration for desired mode and check
    // wheter it is an multimon mode or not
    ulSingleDevWidth  = pdm->dmPelsWidth;
    ulSingleDevHeight = pdm->dmPelsHeight;

    if (ulSingleDevWidth && ulSingleDevHeight)
    {
        ulModeDescription = (ulSingleDevWidth << 16) | ulSingleDevHeight;
        
        switch( ulModeDescription )
        {
        case 0x08000300: // 2048 *  768
        case 0x04000600: // 1024 * 1536
        case 0x08000400: // 2048 * 1536
            bRet = TRUE;
            break;
        default:
            break;
        }
    }
    else
    {
        ASSERT(FALSE);
    }

    return bRet;
}


//******************************************************************************
//
//  bGetSingleDeviceRect
//
//  NT4 multiboard helper function calcualtes the rect of the given device
//
//  returns TRUE  if rect could be calculated
//          FALSE if rect not could be calculated
//
//******************************************************************************
BOOL bGetSingleDeviceRect( HANDLE hDriver, DEVMODEW* pdm, ULONG ulDev, RECTL* prclDevice )
{
    BOOL bRet = FALSE;

    ASSERT(pdm);
    ASSERT(hDriver);
    ASSERT(prclDevice);
    ASSERT(ulDev < MAX_MULTIDEV);

    if(bIsMultiMonMode(hDriver,pdm))
    {
        // for now just track 1 mode: 800 * 300
        switch( (pdm->dmPelsWidth << 16) | pdm->dmPelsHeight)
        {
        case 0x08000300:
        case 0x0B000300:
        case 0x10000300:
            prclDevice->left   =  ulDev     * 0x400;
            prclDevice->right  = (ulDev + 1)* 0x400;
            prclDevice->top    = 0;
            prclDevice->bottom = 0x300;
            bRet = TRUE;
            break;
        case 0x04000600:
            prclDevice->left   = 0;
            prclDevice->right  = 0x400;
            prclDevice->top    =  ulDev     * 0x300;
            prclDevice->bottom = (ulDev + 1)* 0x300;
            bRet = TRUE;
            break;
        default:
            break;
        }
    }

    return bRet;
}

//******************************************************************************
//
//  MulEnablePDEV
//
//  NT4 multiboard wrapper function which tries to initialize the desired
//  number of single devices and sets up the multiboard environment
// otherwise it only calls the singleboard DrvEnablePDEV
//
//******************************************************************************
DHPDEV MulEnablePDEV(DEVMODEW* pdm, PWSTR pwszLogAddr, ULONG  cPat, HSURF* phsurfPatterns, 
                     ULONG cjCaps, ULONG* pdevcaps, ULONG cjDevInfo, DEVINFO* pdi,            
                     HDEV  hdev, PWSTR pwszDeviceName, HANDLE hDriver)        
{
    PMDEV   pmdev = NULL;                   // ppdev for multidevice case
    HANDLE  ahDriver[MAX_MULTIDEV];         // device handles from MulEnableDriver
    ULONG   ulNumDev = 0;
    DHPDEV  dhpdevRet = NULL;

    DISPDBG((100, "MulEnablePDEV >>>"));

    ASSERT(pdm);
    ASSERT(hDriver);

    // do we should run in multimon-mode ?
    if(   (bIsMultiMonMode(hDriver,pdm))
        &&(bGetNumberOfDevices( hDriver, &ulNumDev ))
        &&(ulNumDev > 1) // caution: don't remove this check here !
        &&(bGetDeviceObjects(hDriver,ahDriver)) // get hDriver of devices
       )
    {
        // here we know there are ulDev (more than 1) nvidia graphic devices activated and
        // we have objecthandles for them
        pmdev = (PMDEV)EngAllocMem(FL_ZERO_MEMORY, sizeof(MDEV), ALLOC_TAG); 
        if (pmdev)
        {
            ULONG   ulDev = 0;

            // do some multiboard initialisation
            pmdev->dwUniq               = PMDEV_UNIQ;
            pmdev->hdev                 = hdev;
            pmdev->hDriver              = hDriver;
            pmdev->rclDesktop.left      = 0;
            pmdev->rclDesktop.top       = 0;
    //      pmdev->rclDesktop.right     = max (pdm->dmPanningWidth, pdm->dmPelsWidth);
    //      pmdev->rclDesktop.bottom    = max (pdm->dmPanningHeight, pdm->dmPelsHeight);
            pmdev->rclDesktop.right     = pdm->dmPelsWidth;
            pmdev->rclDesktop.bottom    = pdm->dmPelsHeight;
            pmdev->DevMode              = *pdm;
            pmdev->ulNumDevicesActive   = ulNumDev;

            for(ulDev = 0; ulDev < ulNumDev; ulDev++)
            {
                // try to get device rectangle for current mode and device
                if( bGetSingleDeviceRect(hDriver, pdm, ulDev, &pmdev->abdDevices[ulDev].rclBoard) )
                {
                    ASSERT(ahDriver[ulDev]);
                    // fill up necessary board related information
                    pmdev->abdDevices[ulDev].bIsActive              = TRUE;
                    pmdev->abdDevices[ulDev].hDriver                = ahDriver[ulDev];
                    pmdev->abdDevices[ulDev].DevMode                = pmdev->DevMode;
                    pmdev->abdDevices[ulDev].DevMode.dmPelsWidth    = lRclWidth(&pmdev->abdDevices[ulDev].rclBoard);
                    pmdev->abdDevices[ulDev].DevMode.dmPelsHeight   = lRclHeight(&pmdev->abdDevices[ulDev].rclBoard);
                    pmdev->abdDevices[ulDev].pcoBoard               = EngCreateClip();
                    pmdev->abdDevices[ulDev].pcoBoard->iDComplexity = DC_RECT;
                    pmdev->abdDevices[ulDev].pcoBoard->rclBounds    = pmdev->abdDevices[ulDev].rclBoard;
                    pmdev->abdDevices[ulDev].pco                    = EngCreateClip();
                    pmdev->abdDevices[ulDev].pco->iDComplexity      = DC_RECT;
                    pmdev->abdDevices[ulDev].pco->rclBounds         = pmdev->abdDevices[ulDev].rclBoard;
                    pmdev->abdDevices[ulDev].rclSavedBounds         = rclEmpty;
                    pmdev->abdDevices[ulDev].pso                    = NULL;
                    pmdev->abdDevices[ulDev].psoBitmap              = NULL;
                    pmdev->abdDevices[ulDev].cjCaps                 = cjCaps;
                    pmdev->abdDevices[ulDev].cjDevInfo              = cjDevInfo;

                    pmdev->abdDevices[ulDev].pdevcaps = (ULONG *)EngAllocMem(FL_ZERO_MEMORY, pmdev->abdDevices[ulDev].cjCaps, ALLOC_TAG); 
                    if( !pmdev->abdDevices[ulDev].pdevcaps )
                    {
                        ASSERT(pmdev->abdDevices[ulDev].pdevcaps);
                        DISPDBG((0,"MulEnablePDEV: Could not allocate memory for pmdev->abdDevices[%d].pdevcaps",ulDev));
                        break;
                    }
                    pmdev->abdDevices[ulDev].pdi = (DEVINFO *)EngAllocMem(FL_ZERO_MEMORY, pmdev->abdDevices[ulDev].cjDevInfo, ALLOC_TAG); 
                    if( !pmdev->abdDevices[ulDev].pdi )
                    {
                        ASSERT(pmdev->abdDevices[ulDev].pdi);
                        DISPDBG((0,"MulEnablePDEV: Could not allocate memory for pmdev->abdDevices[%d].pdi",ulDev));
                        break;
                    }
                    // here we call the single board driver to allocate a normal singleboard ppdev
                    pmdev->abdDevices[ulDev].dhpdev = DrvEnablePDEV(&pmdev->abdDevices[ulDev].DevMode,
                                                                    NULL, 
                                                                    0, 
                                                                    NULL, 
                                                                    pmdev->abdDevices[ulDev].cjCaps, 
                                                                    pmdev->abdDevices[ulDev].pdevcaps, 
                                                                    pmdev->abdDevices[ulDev].cjDevInfo, 
                                                                    pmdev->abdDevices[ulDev].pdi,
                                                                    pmdev->hdev, 
                                                                    pwszDeviceName, 
                                                                    pmdev->abdDevices[ulDev].hDriver);
                    if( !pmdev->abdDevices[ulDev].dhpdev )
                    {
                        ASSERT(pmdev->abdDevices[ulDev].dhpdev);
                        DISPDBG((0,"MulEnablePDEV: DrvEnablePDEV for device %d failed !",ulDev));
                        break;
                    }
                        // let board know it's boundaries for ICD clip purposes
                    ((PDEV*)(pmdev->abdDevices[ulDev].dhpdev))->left  = pmdev->abdDevices[ulDev].rclBoard.left;
                    ((PDEV*)(pmdev->abdDevices[ulDev].dhpdev))->top   = pmdev->abdDevices[ulDev].rclBoard.top;
                    ((PDEV*)(pmdev->abdDevices[ulDev].dhpdev))->pmdev = pmdev; // remember pmdev in each ppdev
                }
                else
                {
                    DISPDBG((0,"MulEnablePDEV: Could not get rect for device %d !",ulDev));
                    break;
                }
            }
            // here we have to check if something went wrong 
            // on error case release all previously allocated pdevs
            // this is the error case because previous loop runs util ulDev == ulNumDev if no error case
            if(ulDev < ulNumDev )
            {
                for(;ulDev>MAX_MULTIDEV;ulDev-- )
                {
                    if( !pmdev->abdDevices[ulDev].pdevcaps )
                        EngFreeMem(pmdev->abdDevices[ulDev].pdevcaps);
                    if( !pmdev->abdDevices[ulDev].pdi )
                        EngFreeMem(pmdev->abdDevices[ulDev].pdi);
                    if( !pmdev->abdDevices[ulDev].dhpdev )
                        EngFreeMem(pmdev->abdDevices[ulDev].dhpdev);
                }
                EngFreeMem(pmdev);

                DISPDBG((0,"MulEnablePDEV failed !"));
            }
            else
            {
                // everything succeded, now adapt devcaps and return
                RtlCopyMemory(pdi, pmdev->abdDevices[0].pdi, cjDevInfo);
                RtlCopyMemory(pdevcaps, pmdev->abdDevices[0].pdevcaps, cjCaps);
                ((GDIINFO *)pdevcaps)->ulHorzRes        = pmdev->rclDesktop.right - pmdev->rclDesktop.left;
                ((GDIINFO *)pdevcaps)->ulVertRes        = pmdev->rclDesktop.bottom - pmdev->rclDesktop.top;
                ((GDIINFO *)pdevcaps)->ulPanningHorzRes = pmdev->rclDesktop.right - pmdev->rclDesktop.left;
                ((GDIINFO *)pdevcaps)->ulPanningVertRes = pmdev->rclDesktop.bottom - pmdev->rclDesktop.top;
                ((GDIINFO *)pdevcaps)->ulHorzSize       = pmdev->rclDesktop.right - pmdev->rclDesktop.left;
                ((GDIINFO *)pdevcaps)->ulVertSize       = pmdev->rclDesktop.bottom - pmdev->rclDesktop.top;

                // returning the ppdev ot 1st device => we can catch our pmdev out of this !
                dhpdevRet = pmdev->abdDevices[0].dhpdev;
            }
        }
        else
            DISPDBG((0,"MulEnablePDEV: could not allocated Memory for multiple ppdev !!"));

        DISPDBG((95, "MulEnablePDEV: enabled multi device handling"));
    }
    else
    {
        // single board resolution is desired / available => just call singleboard driver with
        // incoming values
        dhpdevRet = DrvEnablePDEV(pdm,pwszLogAddr,cPat,phsurfPatterns, 
                                  cjCaps,pdevcaps,cjDevInfo,pdi,            
                                  hdev,pwszDeviceName,hDriver);
    }

    DISPDBG((100, "<<< MulEnablePDEV"));
    return dhpdevRet;
}


//******************************************************************************
//
//  MulDisablePDEV
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
VOID MulDisablePDEV(DHPDEV  dhpdev)
{
    PPDEV   ppdev = (PPDEV)dhpdev;

    DISPDBG((100, "MulDisablePDEV >>>"));

    ASSERT(ppdev);

    if( !ppdev->pmdev )
    {
        DrvDisablePDEV(dhpdev);
    }
    else
    {
        PMDEV   pmdev = ppdev->pmdev;  
        ULONG   ulDev;

        // call DrvDisablePDEV for each single device
        for (ulDev = 0; ulDev < pmdev->ulNumDevicesActive; ulDev++)
        {
            ASSERT(pmdev->abdDevices[ulDev].dhpdev);
            DrvDisablePDEV(pmdev->abdDevices[ulDev].dhpdev);
            pmdev->abdDevices[ulDev].dhpdev     = NULL;

            EngFreeMem(pmdev->abdDevices[ulDev].pdi);
            pmdev->abdDevices[ulDev].pdi        = NULL;
            pmdev->abdDevices[ulDev].cjDevInfo  = 0;

            EngFreeMem(pmdev->abdDevices[ulDev].pdevcaps);
            pmdev->abdDevices[ulDev].pdevcaps   = NULL;
            pmdev->abdDevices[ulDev].cjCaps     = 0;

            EngDeleteClip(pmdev->abdDevices[ulDev].pco);
            pmdev->abdDevices[ulDev].pco        = NULL;

            EngDeleteClip(pmdev->abdDevices[ulDev].pcoBoard);
            pmdev->abdDevices[ulDev].pcoBoard   = NULL;
        }

        EngFreeMem(pmdev);
        pmdev = NULL;
    }

    DISPDBG((100, "<<< MulDisablePDEV"));
    return;
}

//******************************************************************************
//
//  MulCompletePDEV
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
VOID MulCompletePDEV(DHPDEV dhpdev, HDEV hdev)
{
    PPDEV   ppdev = (PPDEV)dhpdev;

    DISPDBG((100, "MulCompletePDEV >>>"));

    ASSERT(ppdev);

    if( !ppdev->pmdev )
    {
        DrvCompletePDEV(dhpdev,hdev);
    }
    else
    {
        PMDEV   pmdev = ppdev->pmdev;  
        ULONG   ulDev;

        for (ulDev = 0; ulDev < pmdev->ulNumDevicesActive; ulDev++)
        {
            ASSERT(pmdev->abdDevices[ulDev].dhpdev);
            DrvCompletePDEV(pmdev->abdDevices[ulDev].dhpdev, hdev);
        }
    }

    DISPDBG((100, "<<< MulCompletePDEV"));
    return;
}


//******************************************************************************
//
//  MulResetPDEV
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
BOOL MulResetPDEV(DHPDEV dhpdevOld, DHPDEV dhpdevNew)
{
    PPDEV   ppdevOld = (PPDEV)dhpdevOld;
    PPDEV   ppdevNew = (PPDEV)dhpdevNew;
    BOOL    bRet     = FALSE;

    DISPDBG((100, "MulResetPDEV >>>"));

    ASSERT(ppdevOld);
    ASSERT(ppdevNew);

    
    if( !ppdevNew->pmdev && !ppdevOld->pmdev )
    {
        // both modes are singleboard ones ?
        bRet = DrvResetPDEV(dhpdevOld, dhpdevNew);
    }
    // switch from multiboard to singleboard resolution
    else if( !ppdevNew->pmdev && ppdevOld->pmdev ) 
    {
        // we only allow mode switches when no icd app is running
        if(0==globalOpenGLData.oglDrawableClientCount)
        {
            bRet = DrvResetPDEV(dhpdevOld, dhpdevNew);
        }
    }
    // switch from singleboard to multiboard resolution
    else if(  ppdevNew->pmdev && !ppdevOld->pmdev ) 
    {
        // we only allow mode switches when no icd app is running
        if(0==globalOpenGLData.oglDrawableClientCount)
        {
            PMDEV   pmdevNew = ppdevNew->pmdev;
            ULONG   ulDev;

            for (ulDev = 0; ulDev < pmdevNew->ulNumDevicesActive; ulDev++)
            {
                bRet = DrvResetPDEV(dhpdevOld, pmdevNew->abdDevices[ulDev].dhpdev);
                if(!bRet)
                    goto Exit;
            }
        }
    }
    // switch from one singleboard to another multiboard resolution
    else
    {
        // we only allow mode switches when no icd app is running
        if(0==globalOpenGLData.oglDrawableClientCount)
        {
            PMDEV   pmdevNew = ppdevNew->pmdev;
            ULONG   ulDev;

            ASSERT(ppdevNew->pmdev);
            ASSERT(ppdevOld->pmdev);
            for (ulDev = 0; ulDev < pmdevNew->ulNumDevicesActive; ulDev++)
            {
                bRet = DrvResetPDEV(dhpdevOld, pmdevNew->abdDevices[ulDev].dhpdev);
                if(!bRet)
                    goto Exit;
            }
        }
    }

Exit:
    DISPDBG((100, "<<< MulResetPDEV"));

    return bRet;
}


//******************************************************************************
//
//  MulSynchronize
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
VOID MulSynchronize(DHPDEV dhpdev, RECTL  *prcl)
{
    PPDEV   ppdev = (PPDEV)dhpdev;

    DISPDBG((100, "MulSynchronize >>>"));

    ASSERT(ppdev);

    if( !ppdev->pmdev )
    {
        DrvSynchronize(dhpdev, prcl);
    }
    else
    {
        PMDEV   pmdev = ppdev->pmdev;
        ULONG   ulDev;

        for (ulDev = 0; ulDev < pmdev->ulNumDevicesActive; ulDev++)
        {
            DrvSynchronize(pmdev->abdDevices[ulDev].dhpdev, prcl);
        }
    }

    DISPDBG((100, "<<< MulSynchronize"));
    return;
}


//******************************************************************************
//
//  MulEnableSurface
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
HSURF MulEnableSurface(DHPDEV dhpdev)
{
    PPDEV   ppdev       = (PPDEV)dhpdev;
    HSURF   hSurfRet    = NULL;

    DISPDBG((100, "MulEnableSurface >>>"));

    ASSERT(ppdev);

    if( !ppdev->pmdev )
    {
        hSurfRet = DrvEnableSurface(dhpdev);
    }
    else
    {
        PMDEV   pmdev = ppdev->pmdev;  
        ULONG   ulDev;
        SIZEL   sizl;
        LONG    lWidth;
        ULONG   iFormat;
        PVOID   pvBits;
        SURFOBJ *pso;
        BOOL    bEAS;

        for (ulDev = 0; ulDev < pmdev->ulNumDevicesActive; ulDev++)
        {
            ppdev                          = (PPDEV)pmdev->abdDevices[ulDev].dhpdev;
            pmdev->abdDevices[ulDev].hsurf = DrvEnableSurface(pmdev->abdDevices[ulDev].dhpdev);

            if( 0 == pmdev->abdDevices[ulDev].hsurf )
            {
                ASSERT(FALSE);
                goto MulExit;
            }

            //  Note: EngAssociateSurface is also responsible for giving the dhpdev to the pso of hsurf
            bEAS                                    = EngAssociateSurface(pmdev->abdDevices[ulDev].hsurf, pmdev->hdev, 0);
            pmdev->abdDevices[ulDev].pso            = EngLockSurface(pmdev->abdDevices[ulDev].hsurf);
            // NOTE: this must be after EngAssociateSurface
            pmdev->abdDevices[ulDev].pso->dhpdev    = pmdev->abdDevices[ulDev].dhpdev;
            pmdev->abdDevices[ulDev].dhsurf         = pmdev->abdDevices[ulDev].pso->dhsurf;

            if (pmdev->abdDevices[ulDev].pso->dhsurf != (DHSURF)&ppdev->dsurfScreen)
            {
                pmdev->abdDevices[ulDev].pso->dhsurf = (DHSURF)&ppdev->dsurfScreen;
            }

            sizl.cx                                 = ppdev->cxScreen;
            sizl.cy                                 = ppdev->cyScreen;
            lWidth                                  = ppdev->lDelta;
            iFormat                                 = ppdev->iBitmapFormat;
            pvBits                                  = ppdev->pjScreen;
            pmdev->abdDevices[ulDev].hsurfBitmap    = EngCreateBitmap(sizl, lWidth, iFormat, BMF_TOPDOWN, pvBits);
            pmdev->abdDevices[ulDev].psoBitmap      = EngLockSurface(pmdev->abdDevices[ulDev].hsurfBitmap);

        }

        pmdev->flHooks = pmdev->abdDevices[0].ppdev->flHooks;

        sizl.cx        = pmdev->rclDesktop.right - pmdev->rclDesktop.left;
        sizl.cy        = pmdev->rclDesktop.bottom - pmdev->rclDesktop.top;
        iFormat;       // still is initialized from the loop
        lWidth         = ((sizl.cx  * (iFormat - BMF_4BPP)) + 3) & 0xFFFFFFFC;
        pvBits;        // still has a non NULL value, dont care which for now

        // create a hsurf for pmdev, but associate with ppdev[0] to be able to do
        // single board shortcut
        pmdev->hsurf   = EngCreateDeviceSurface(pmdev->abdDevices[ulDev].dhpdev, sizl, iFormat);

        if (!EngAssociateSurface(pmdev->hsurf, pmdev->hdev, pmdev->flHooks))
        {
            EngDeleteSurface(pmdev->hsurf);
            pmdev->hsurf = NULL;

            // cleanup has to be done here !
            ASSERT( FALSE);
            goto MulExit;
        }

        pmdev->pco                  = EngCreateClip();
        pmdev->pco->iMode           = TC_RECTANGLES;
        pmdev->pco->iDComplexity    = DC_RECT;
        pmdev->pco->rclBounds       = pmdev->rclDesktop;

        hSurfRet = pmdev->hsurf;

MulExit:
        if( !hSurfRet )
        {
            // cleanup necessary !
            for(; ulDev >= 0; ulDev-- )
            {
                EngUnlockSurface(pmdev->abdDevices[ulDev].psoBitmap);
                pmdev->abdDevices[ulDev].psoBitmap      = NULL;

                EngDeleteSurface(pmdev->abdDevices[ulDev].hsurfBitmap);
                pmdev->abdDevices[ulDev].hsurfBitmap = NULL;

                EngUnlockSurface(pmdev->abdDevices[ulDev].pso);
                pmdev->abdDevices[ulDev].pso = NULL;
                DrvDisableSurface(pmdev->abdDevices[ulDev].dhpdev);
            }
        }
    }

    DISPDBG((100, "<<< MulEnableSurface"));
    return hSurfRet;
}


//******************************************************************************
//
//  MulDisableSurface
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
VOID MulDisableSurface(DHPDEV dhpdev)
{
    PPDEV ppdev = (PPDEV)dhpdev;

    DISPDBG((100, "MulDisableSurface >>>"));

    ASSERT(ppdev);

    if( !ppdev->pmdev )
    {
        DrvDisableSurface(dhpdev);
    }
    else
    {
        PMDEV   pmdev = ppdev->pmdev;  
        ULONG   ulDev;

        for (ulDev = 0; ulDev < pmdev->ulNumDevicesActive; ulDev++)
        {
            EngUnlockSurface(pmdev->abdDevices[ulDev].psoBitmap);
            pmdev->abdDevices[ulDev].psoBitmap      = NULL;

            EngDeleteSurface(pmdev->abdDevices[ulDev].hsurfBitmap);
            pmdev->abdDevices[ulDev].hsurfBitmap = NULL;

            EngUnlockSurface(pmdev->abdDevices[ulDev].pso);
            pmdev->abdDevices[ulDev].pso = NULL;
            DrvDisableSurface(pmdev->abdDevices[ulDev].dhpdev);
        }

        EngDeleteClip(pmdev->pco);
        pmdev->pco  = NULL;

        EngUnlockSurface(pmdev->pso);
        pmdev->pso = NULL;
        EngDeleteSurface(pmdev->hsurf);
        pmdev->hsurf = NULL;
    }

    DISPDBG((100, "<<< MulDisableSurface"));
    return;
}


//******************************************************************************
//
//  MulAssertMode
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
BOOL MulAssertMode(DHPDEV  dhpdev,BOOL    bEnable)
{
    PPDEV ppdev = (PPDEV)dhpdev;
    BOOL  bRet  = FALSE;

    DISPDBG((100, "MulAssertMode >>>"));

    ASSERT(ppdev);

    if( !ppdev->pmdev )
    {
        bRet = DrvAssertMode(dhpdev,bEnable);
    }
    else
    {
        PMDEV   pmdev = ppdev->pmdev;  
        ULONG   ulDev;

        for (ulDev = 0; ulDev < pmdev->ulNumDevicesActive; ulDev++)
        {
            // we should not fail here !!!
            bRet = DrvAssertMode(pmdev->abdDevices[ulDev].dhpdev, bEnable);
            ASSERT(bRet);
            if( !bRet  && (0 == ulDev) )
                goto Exit;
        }
    }

Exit:

    DISPDBG((100, "<<< MulAssertMode"));
    return bRet;
}


//******************************************************************************
//
//  MulGetModes
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
ULONG MulGetModes(HANDLE hDriver, ULONG cjSize, DEVMODEW*   pdm)
{
    ULONG   ulDev;
    ULONG   ulRet = 0;
    ULONG   ulNumDev = 0;
    HANDLE  ahDriver[MAX_MULTIDEV];

    ASSERT(hDriver);

    DISPDBG((100, "MulGetModes >>>"));

    // should we run in multimon-mode ?
    if( (bGetNumberOfDevices( hDriver, &ulNumDev ))
        &&(ulNumDev > 1) // caution: don't remove this check here !
        &&(bGetDeviceObjects(hDriver,ahDriver)) // get hDriver of devices
       )
    {
        DEVMODEW *apdm[MAX_MULTIDEV];
        DEVMODEW *pdmDriver;
        DEVMODEW *pdmAppend;
        ULONG     aulSize[MAX_MULTIDEV];
        BOOL      bMatch;
        BOOL      bAllocated = FALSE;

        DISPDBG((95, "MulGetModes - found %d device objects", ulNumDev));

        RtlZeroMemory(apdm, sizeof(apdm));
        RtlZeroMemory(aulSize, sizeof(aulSize));

        // get modes from all devices
        for (ulDev = 0; ulDev < ulNumDev; ulDev++)
        {
            // check needed size for modelist
            aulSize[ulDev] = DrvGetModes(ahDriver[ulDev], 0, NULL);
            if (0 != aulSize[ulDev])
            {
                // alloc memory for modelist
                apdm[ulDev] = EngAllocMem(0, aulSize[ulDev], ALLOC_TAG);
                if (NULL != apdm[ulDev])
                {
                    // copy drivers modelist into allocated space
                    aulSize[ulDev] = DrvGetModes(ahDriver[ulDev], aulSize[ulDev], apdm[ulDev]);
                    if (0 != aulSize[ulDev])
                    {   
                        bAllocated = TRUE;
                    }
                }
            }
            if(!bAllocated)
            {
                DISPDBG((0,"MulGetModes: could not allocate modelist correctly"));
                break;
            }
        }

        // everything worked fine => try to calculate modes to export
        if( bAllocated )
        {
            // system only wants to know how much space is needed for modelist
            if (NULL == pdm)
            {
                ulRet = DrvGetModes(hDriver, cjSize, pdm);

                for (pdmDriver = apdm[0]; (BYTE *)pdmDriver < ((BYTE *)apdm[0] + aulSize[0]); pdmDriver++)
                {
                    bMatch = TRUE;
                    for (ulDev = 0; ulDev < ulNumDev; ulDev++)
                    {
                        bMatch = bMatch && bFindMatchingDevMode(pdmDriver, apdm[ulDev], aulSize[ulDev]);
                    }
                    if (bMatch)
                    {
                        ulRet += sizeof(DEVMODEW);
                    }
                }
            }
            else
            {
                // fill out given list with possible modes
                ulRet = DrvGetModes(hDriver, cjSize, pdm);

                if (ulRet <= (cjSize - sizeof(DEVMODEW)))
                {
                    for (pdmDriver = apdm[0]; (BYTE *)pdmDriver < ((BYTE *)apdm[0] + aulSize[0]); pdmDriver++)
                    {
                        bMatch = TRUE;
                        for (ulDev = 0; ulDev < ulNumDev; ulDev++)
                        {
                            bMatch = bMatch && bFindMatchingDevMode(pdmDriver, apdm[ulDev], aulSize[ulDev]);
                        }
                        if (bMatch)
                        {
                            pdmAppend = (DEVMODEW *)((BYTE *)pdm + ulRet);
                            RtlCopyMemory(pdmAppend, pdmDriver, sizeof(DEVMODEW));
                            pdmAppend->dmPelsWidth *= ulNumDev;

                            ulRet += sizeof(DEVMODEW);
                            break;
                        }
                        if ((ulRet + sizeof(DEVMODEW)) > cjSize)
                            break;
                    }
                }
            }
        }

        // clean up allocated space
        for (ulDev = 0; ulDev < ulNumDev; ulDev++)
        {
            if (apdm[ulDev])
            {
                EngFreeMem(apdm[ulDev]);
                apdm[ulDev] = NULL;
            }
        }
    }
    else
    {
        // normal single board case:
        ulRet = DrvGetModes(hDriver,cjSize,pdm);
    }

    DISPDBG((100, "<<< MulGetModes"));
    return ulRet;
}


//******************************************************************************
//
//  MulSetPalette
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
BOOL MulSetPalette(DHPDEV  dhpdev,PALOBJ* ppalo,FLONG   fl, ULONG   iStart, ULONG   cColors)
{
    PPDEV ppdev = (PPDEV)dhpdev;
    BOOL  bRet  = FALSE;

    DISPDBG((100, "MulSetPalette >>>"));

    ASSERT(ppdev);

    if( !ppdev->pmdev )
    {
        bRet = DrvSetPalette(dhpdev,ppalo, fl, iStart, cColors);
    }
    else
    {
        PMDEV   pmdev = ppdev->pmdev;  
        ULONG   ulDev;

        for (ulDev = 0; ulDev < pmdev->ulNumDevicesActive; ulDev++)
        {
            bRet = DrvSetPalette( pmdev->abdDevices[ulDev].dhpdev, ppalo, fl, iStart, cColors);                 
        }
    }

    DISPDBG((100, "<<< MulSetPalette"));
    return bRet;
}


//******************************************************************************
//
//  MulDitherColor
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
ULONG MulDitherColor(DHPDEV dhpdev,ULONG  iMode,ULONG  rgb,ULONG* pul)
{
    ULONG ulRet = 0;

    DISPDBG((100, "MulDitherColor >>>"));

    // nothing to do here, because we only need to call 1 driver to do 
    // calculate us a color => don't hang in MulDitherColor 
    ulRet = DrvDitherColor(dhpdev,iMode, rgb, pul);

    DISPDBG((100, "<<< MulDitherColor"));
    return ulRet;
}


//******************************************************************************
//
//  MulSetPointerShape
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
ULONG MulSetPointerShape(SURFOBJ*  pso, SURFOBJ*  psoMask, SURFOBJ*  psoColor,
                         XLATEOBJ* pxlo, LONG xHot, LONG yHot, LONG x, LONG y,
                         RECTL* prcl, FLONG fl)
{
    PPDEV ppdev = (PPDEV)pso->dhpdev; 
    ULONG ulRet = FALSE;

    DISPDBG((100, "MulSetPointerShape >>>"));

    ASSERT(ppdev);

    if( !ppdev->pmdev )
    {
        ulRet = DrvSetPointerShape(pso, psoMask, psoColor, pxlo, xHot, yHot, x, y, prcl, fl);
    }
    else
    {
        PMDEV   pmdev = ppdev->pmdev;  
        ULONG   ulDev;
        LONG    lx, ly;
        RECTL   rcl;
        RECTL   *prclPointerBounds;

        ASSERT(pmdev->dwUniq == PMDEV_UNIQ);

        prclPointerBounds = prcl;
        if (prcl)
        {
            prclPointerBounds = &rcl;
        }

        for (ulDev = 0; ulDev < pmdev->ulNumDevicesActive; ulDev++)
        {
            lx = x - pmdev->abdDevices[ulDev].rclBoard.left;
            ly = y - pmdev->abdDevices[ulDev].rclBoard.top;

            if ( x < (pmdev->abdDevices[ulDev].rclBoard.left - 32)
             ||  x > (pmdev->abdDevices[ulDev].rclBoard.right + 32)
             ||  y < (pmdev->abdDevices[ulDev].rclBoard.top - 32)
             ||  y > (pmdev->abdDevices[ulDev].rclBoard.bottom + 32))
            {
                lx = -1;  // turns off this cursor
            }

            if (prcl)
            {
                vRclSubOffset(&rcl, prcl, pmdev->abdDevices[ulDev].rclBoard.left, pmdev->abdDevices[ulDev].rclBoard.top);
                prclPointerBounds = &rcl;
            }

            ASSERT(pmdev->abdDevices[ulDev].pso);
            ulRet = DrvSetPointerShape(pmdev->abdDevices[ulDev].pso, psoMask, psoColor, pxlo, xHot, yHot, lx, ly, prclPointerBounds, fl);
        }
    }

    DISPDBG((100, "<<< MulSetPointerShape"));
    return ulRet;
}


//******************************************************************************
//
//  MulMovePointer
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
VOID MulMovePointer(SURFOBJ *pso,LONG x,LONG y,RECTL *prcl)
{
    PPDEV ppdev = (PPDEV)pso->dhpdev; 
    ULONG ulRet = FALSE;

    DISPDBG((100, "MulMovePointer >>>"));

    ASSERT(ppdev);

    if( !ppdev->pmdev )
    {
        DrvMovePointer(pso, x, y, prcl);
    }
    else
    {
        PMDEV   pmdev = ppdev->pmdev;  
        ULONG   ulDev;
        LONG    lx, ly;
        RECTL   rcl;
        RECTL   *prclPointerBounds;

        ASSERT(pmdev->dwUniq == PMDEV_UNIQ);

        prclPointerBounds = prcl;
        if (prcl)
        {
            prclPointerBounds = &rcl;
        }

        for (ulDev = 0; ulDev < pmdev->ulNumDevicesActive; ulDev++)
        {
            lx = x - pmdev->abdDevices[ulDev].rclBoard.left;
            ly = y - pmdev->abdDevices[ulDev].rclBoard.top;

            if ( x < (pmdev->abdDevices[ulDev].rclBoard.left - 32)
             ||  x > (pmdev->abdDevices[ulDev].rclBoard.right + 32)
             ||  y < (pmdev->abdDevices[ulDev].rclBoard.top - 32)
             ||  y > (pmdev->abdDevices[ulDev].rclBoard.bottom + 32))
            {
                lx = -1;  // turns off this cursor
            }

            if (prcl)
            {
                vRclSubOffset(&rcl, prcl, pmdev->abdDevices[ulDev].rclBoard.left, pmdev->abdDevices[ulDev].rclBoard.top);
                prclPointerBounds = &rcl;
            }

            ASSERT(pmdev->abdDevices[ulDev].pso);
            DrvMovePointer( pmdev->abdDevices[ulDev].pso, lx, ly, prclPointerBounds);
        }
    }

    DISPDBG((100, "<<< MulMovePointer"));
    return ;
}


//******************************************************************************
//
//  MulCreateDeviceBitmap
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
HBITMAP MulCreateDeviceBitmap(DHPDEV dhpdev, SIZEL sizl, ULONG iFormat)
{
    PPDEV   ppdev = (PPDEV)dhpdev;
    HBITMAP hRet  = (HBITMAP) 0;

    DISPDBG((100, "MulCreateDeviceBitmap >>>"));

    ASSERT(ppdev);

    // we do not support CreateDeviceBitMap in MultiBoard case !
    if( !ppdev->pmdev )
    {
        hRet = DrvCreateDeviceBitmap(dhpdev,sizl,iFormat);
    }

    DISPDBG((100, "<<< MulCreateDeviceBitmap"));

    return hRet;
}


//******************************************************************************
//
//  MulDeleteDeviceBitmap
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
VOID MulDeleteDeviceBitmap(DHSURF dhsurf)
{
    PPDEV   ppdev;
   
    ASSERT(dhsurf);

    DISPDBG((100, "MulDeleteDeviceBitmap >>>"));

    ppdev  = ((DSURF *)dhsurf)->ppdev;

    ASSERT(ppdev);

    
    if( !ppdev->pmdev )
    {
        DrvDeleteDeviceBitmap(dhsurf);
    }
    else
    {
        // we do not support DeleteDeviceBitmap in MultiBoard case !
        // => we should never be called for DrvDeleteDeviceBitmap
        ASSERT(FALSE);
    }


    DISPDBG((100, "<<< MulDeleteDeviceBitmap"));

    return;
}


#endif // NT4_MULTI_DEV
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nt4multidev.h ===
#ifndef _INCLUDE_NT4MULTIDEV
#define _INCLUDE_NT4MULTIDEV

#ifdef NT4_MULTI_DEV

#define MAX_MULTIDEV 16

#define PMDEV_UNIQ 'MDEV'
 
typedef struct _MUL_PIXELFORMAT
{
    PIXELFORMATDESCRIPTOR  pfd;
    LONG                   iPixelFormat[MAX_MULTIDEV] ;
}MUL_PIXELFORMAT,*PMUL_PIXELFORMAT;

typedef struct _MUL_PIXELFORMAT_LIST
{
    PMUL_PIXELFORMAT pPixelFormats;
    LONG             iNumberOfPixelFormats;
}MUL_PIXELFORMAT_LIST,*PMUL_PIXELFORMAT_LIST;

typedef struct _BOARDDESC
{
    BOOL            bIsActive;
    HANDLE          hDriver;
    RECTL           rclBoard;
    DEVMODEW        DevMode;
    union
    {
    DHPDEV          dhpdev;
    struct _PDEV   *ppdev;
    };
    union
    {
    DHSURF          dhsurf;
    struct _DSURF  *pdsurf;
    };
    CLIPOBJ        *pcoBoard;
    CLIPOBJ        *pco;
    RECTL           rclSavedBounds;
    ULONG           cjCaps;
    union
    {
    ULONG          *pdevcaps;
    GDIINFO        *pGdiInfo;
    };
    ULONG           cjDevInfo;
    DEVINFO        *pdi;
    HSURF           hsurf;
    SURFOBJ        *pso;
    HSURF           hsurfBitmap;
    SURFOBJ        *psoBitmap;
    // openGl stuff
    ULONG           ulRoot;
}
BOARDDESC, *PBOARDDESC;


typedef struct _MDEV
{
    DWORD                   dwUniq;
    HDEV                    hdev;
    HANDLE                  hDriver;
    RECTL                   rclDesktop;
    DEVMODEW                DevMode;
    HSURF                   hsurf;
    SURFOBJ                *pso;
    CLIPOBJ                *pco;
    FLONG                   flHooks;
    ULONG                   ulNumDevicesActive;
    ULONG                   ulNumDevicesInSystem;
    BOARDDESC               abdDevices[MAX_MULTIDEV];
    MUL_PIXELFORMAT_LIST    PixelFormatList;
}
MDEV, *PMDEV;


typedef struct _ENUMDEV 
{
  ULONG c;
  PBOARDDESC apbdDevices[1];
} ENUMDEV;

typedef struct _ENUMDEV16 
{
  ULONG c;
  PBOARDDESC apbdDevices[16];
} ENUMDEV16;

typedef struct _DEVOBJ
{
    PMDEV       pmdev;
    SURFOBJ     *pso;
    PBOARDDESC  apbdDevices[MAX_MULTIDEV];
    ULONG       enumStart;
    ULONG       cDevices;
}
DEVOBJ, *PDEVOBJ;



BOOL _inline bMatchingDevModes(DEVMODEW*   pdm1, DEVMODEW*   pdm2)
{
    BOOL bRet = FALSE;

    ASSERT(pdm1);
    ASSERT(pdm2);

    if (pdm1->dmBitsPerPel == pdm2->dmBitsPerPel
    &&  pdm1->dmPelsWidth == pdm2->dmPelsWidth
    &&  pdm1->dmPelsHeight == pdm2->dmPelsHeight
    &&  pdm1->dmDisplayFrequency == pdm2->dmDisplayFrequency
    &&  pdm1->dmPanningWidth == pdm2->dmPanningWidth
    &&  pdm1->dmPanningHeight == pdm2->dmPanningHeight
    )
        bRet = TRUE;
    return bRet;
}

BOOL _inline bFindMatchingDevMode(IN DEVMODEW*   pdmReference,
                                  IN DEVMODEW*   pdmArray,
                                  IN ULONG       ulSize)
{
    BOOL bRet = FALSE;
    DEVMODEW    *pdm;
    ASSERT(pdmReference);
    ASSERT(pdmArray);

#if 1
    if (pdmReference->dmPelsWidth < 1024 ||
        pdmReference->dmPelsHeight < 768 ||
        pdmReference->dmBitsPerPel != 32 ||
        pdmReference->dmDisplayFrequency != 75)
    return FALSE;
#endif  

    for (pdm = pdmArray; (BYTE *)pdm < ((BYTE *)pdmArray + ulSize); pdm++)
    {
        if (bMatchingDevModes(pdmReference, pdm))
        {
            bRet = TRUE;
            break;
        }

    }
    return bRet;
}


//*********************************************************
//
//  pmdevGetFromPso
//
//  gives back a pmdev if contained in pso
//  pso can be NULL or any type of SURFOBJ
//
//********************************************************
PMDEV _inline pmdevGetFromPso(SURFOBJ *pso)
{
    if(   (NULL != pso)
        &&(NULL != pso->dhpdev)
        &&(NULL != ((PPDEV)pso->dhpdev)->pmdev)
       )
    {
        ASSERT(((PPDEV)pso->dhpdev)->pmdev->dwUniq == PMDEV_UNIQ);
        return ((PPDEV)pso->dhpdev)->pmdev;
    }
    else
    {
        return NULL;
    }
}


//*********************************************************
//
//  bNeedToEnumerate
//
//  checks if pso is the multidev- primary surface
//
//********************************************************
BOOL _inline bNeedToEnumerate(SURFOBJ *pso)
{
    BOOL    bRet = FALSE;

    if(  (NULL != pmdevGetFromPso(pso))
       &&(STYPE_DEVICE == pso->iType)
      )
        bRet = TRUE;

    return bRet;
}

//*********************************************************
//
//  psoGetDevicePSO
//
//  get singleboard primary of ulDevID
//
//********************************************************
SURFOBJ _inline *psoGetDevicePSO(SURFOBJ *pso, ULONG ulDevID)
{

    if (bNeedToEnumerate(pso))
    {
        PMDEV pmdev = pmdevGetFromPso(pso);  

        ASSERT(NULL != pmdev );
        ASSERT(ulDevID < MAX_MULTIDEV);

        pso = pmdev->abdDevices[ulDevID].pso;
    }

    return pso;
}

SURFOBJ _inline *psoGetBoardRectAndSync( IN SURFOBJ      *pso,
                                         IN BOARDDESC    *pBoardDesc,
                                         IN BOARDDESC    *pOtherBoardDesc,  // needed to decide if we export the bitmap surface
                                         OUT RECTL       *prclBoard)
{
    ASSERT(prclBoard);


    if (pso)
    {
        if (bNeedToEnumerate(pso))
        {
            ASSERT(pBoardDesc);

            if (pOtherBoardDesc)
            {
                pso = pBoardDesc->psoBitmap;
                DrvSynchronize(pBoardDesc->dhpdev, NULL);   // this indicates that we'll use this surface as the source for dev to dev blits -> sync
            }
            else
            {
                pso = pBoardDesc->pso;
            }
            *prclBoard = pBoardDesc->rclBoard;

        }
        else
        {
            prclBoard->left   = 0;
            prclBoard->top    = 0;
            prclBoard->right  = pso->sizlBitmap.cx;
            prclBoard->bottom = pso->sizlBitmap.cy;
        }
    }
    return pso;
}

ULONG DEVOBJ_cEnumStart(IN PDEVOBJ  pdo,
                        IN SURFOBJ  *pso,
                        IN RECTL    *prclBounds, // dont care if bAll = TRUE
                        IN BOOL     bAll,       // TRUE: enumerates all, FALSE enumerates only dev clipped against prclbounds
                        IN ULONG    iDir);  // CD_ANY...

BOOL DEVOBJ_bEnum(IN PDEVOBJ    pdo,
                  IN ENUMDEV16  *pEnumDev16);



typedef struct _BLT_PARAM
{
    SURFOBJ *psoDst;
    SURFOBJ *psoSrc;
    RECTL   rclClip;
    RECTL   *prclClip;
    RECTL   rclDst;
    RECTL   *prclDst;
    POINTL  ptlSrc;
    POINTL  *pptlSrc;
    POINTL  ptlMask;
    POINTL  *pptlMask;
    POINTL  ptlBrush;
    POINTL  *pptlBrush;
}
BLT_PARAM;


BOOL APIENTRY MulResetPDEV(DHPDEV dhpdevOld, DHPDEV dhpdevNew);

DHPDEV APIENTRY MulEnablePDEV(DEVMODEW* pdm, PWSTR pwszLogAddr, ULONG  cPat, HSURF* phsurfPatterns, 
                    ULONG cjCaps, ULONG* pdevcaps, ULONG cjDevInfo, DEVINFO* pdi,            
                    HDEV  hdev, PWSTR pwszDeviceName, HANDLE hDriver);

VOID APIENTRY MulDisablePDEV(DHPDEV  dhpdev);

VOID APIENTRY MulCompletePDEV(DHPDEV dhpdev,HDEV   hdev);

VOID APIENTRY MulSynchronize(DHPDEV dhpdev, RECTL  *prcl);

HSURF APIENTRY MulEnableSurface(DHPDEV dhpdev);

VOID APIENTRY MulDisableSurface(DHPDEV dhpdev);

BOOL APIENTRY MulAssertMode(DHPDEV  dhpdev,BOOL    bEnable);

ULONG APIENTRY MulGetModes(HANDLE hDriver, ULONG cjSize, DEVMODEW*   pdm);

BOOL APIENTRY MulEnableDirectDraw(DHPDEV dhpdev, DD_CALLBACKS*  pCallBacks,
                            DD_SURFACECALLBACKS*    pSurfaceCallBacks, DD_PALETTECALLBACKS*    pPaletteCallBacks);

BOOL APIENTRY MulGetDirectDrawInfo(DHPDEV dhpdev, DD_HALINFO* pHalInfo, DWORD* lpdwNumHeaps,
                          VIDEOMEMORY* pvmList, DWORD* lpdwNumFourCC, DWORD* lpdwFourCC);

VOID APIENTRY MulDisableDirectDraw(DHPDEV      dhpdev);

ULONG APIENTRY MulEscape(SURFOBJ*    pso, ULONG       iEsc, ULONG       cjIn,
                VOID*       pvIn, ULONG       cjOut, VOID*       pvOut);

ULONG APIENTRY MulDrawEscape(SURFOBJ *pso, ULONG    iEsc, CLIPOBJ *pco,
                    RECTL   *prcl, ULONG    cjIn, PVOID    pvIn);

VOID APIENTRY MulDestroyFont(FONTOBJ *pfo);

BOOL APIENTRY MulStretchBlt(
SURFOBJ*            psoDst,
SURFOBJ*            psoSrc,
SURFOBJ*            psoMask,
CLIPOBJ*            pco,
XLATEOBJ*           pxlo,
COLORADJUSTMENT*    pca,
POINTL*             pptlHTOrg,
RECTL*              prclDst,
RECTL*              prclSrc,
POINTL*             pptlMask,
ULONG               iMode);

HBITMAP APIENTRY MulCreateDeviceBitmap(DHPDEV dhpdev, SIZEL sizl, ULONG iFormat);

VOID APIENTRY MulDeleteDeviceBitmap(DHSURF dhsurf);

BOOL APIENTRY MulRealizeBrush(
BRUSHOBJ* pbo,
SURFOBJ*  psoTarget,
SURFOBJ*  psoPattern,
SURFOBJ*  psoMask,
XLATEOBJ* pxlo,
ULONG     iHatch);

BOOL APIENTRY MulPaint(
SURFOBJ*  pso,
CLIPOBJ*  pco,
BRUSHOBJ* pbo,
POINTL*   pptlBrushOrg,
MIX       mix);

BOOL APIENTRY MulFillPath(
SURFOBJ*  pso,
PATHOBJ*  ppo,
CLIPOBJ*  pco,
BRUSHOBJ* pbo,
POINTL*   pptlBrushOrg,
MIX       mix,
FLONG     flOptions);

BOOL APIENTRY MulStrokePath(
SURFOBJ*   pso,
PATHOBJ*   ppo,
CLIPOBJ*   pco,
XFORMOBJ*  pxo,
BRUSHOBJ*  pbo,
POINTL*    pptlBrushOrg,
LINEATTRS* plineattrs,
MIX        mix);

BOOL APIENTRY MulLineTo(
SURFOBJ*    pso,
CLIPOBJ*    pco,
BRUSHOBJ*   pbo,
LONG        x1,
LONG        y1,
LONG        x2,
LONG        y2,
RECTL*      prclBounds,
MIX         mix);

BOOL APIENTRY MulTextOut(
SURFOBJ*  pso,
STROBJ*   pstro,
FONTOBJ*  pfo,
CLIPOBJ*  pco,
RECTL*    prclExtra,
RECTL*    prclOpaque,
BRUSHOBJ* pboFore,
BRUSHOBJ* pboOpaque,
POINTL*   pptlOrg,
MIX       mix);

BOOL APIENTRY MulBitBlt(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
SURFOBJ*  psoMask,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc,
POINTL*   pptlMask,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
ROP4      rop4);

BOOL APIENTRY MulCopyBits(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc);

BOOL APIENTRY MulSetPalette(
DHPDEV  dhpdev,
PALOBJ* ppalo,
FLONG   fl,
ULONG   iStart,
ULONG   cColors);

ULONG APIENTRY MulDitherColor(
DHPDEV dhpdev,
ULONG  iMode,
ULONG  rgb,
ULONG* pul);

ULONG APIENTRY MulSetPointerShape(
SURFOBJ*  pso,
SURFOBJ*  psoMask,
SURFOBJ*  psoColor,
XLATEOBJ* pxlo,
LONG      xHot,
LONG      yHot,
LONG      x,
LONG      y,
RECTL*    prcl,
FLONG     fl);

VOID APIENTRY MulMovePointer(SURFOBJ *pso,LONG x,LONG y,RECTL *prcl);

BOOL APIENTRY MulSwapBuffers(SURFOBJ *psoDst, WNDOBJ *pwo);

BOOL APIENTRY MulSetPixelFormat(
    SURFOBJ *pso,
    LONG    iPixelFormat,
    HWND    hWnd);


LONG APIENTRY MulDescribePixelFormat(
    DHPDEV                  dhpdev,
    LONG                    iPixelFormat,
    ULONG                   cjpfd,
    PIXELFORMATDESCRIPTOR   *ppfd);

ULONG_PTR APIENTRY MulSaveScreenBits(
    SURFOBJ   *pso,
    ULONG      iMode,
    ULONG_PTR  ident,
    RECTL     *prcl );


#endif // NT4_MULTI_DEV

#endif //_INCLUDE_NT4MULTIDEV
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nt4mulstrokepath.c ===
//************************** Module Header *************************************
//                                                                             *
//  Module Name: MulStrokePath.c                                                   *
//                                                                             *
//  This module contains the functions that belong to the multi device wrapper *
//                                                                             *
//   Copyright (C) 2000 NVidia Corporation. All Rights Reserved.               *
//                                                                             *
//******************************************************************************


#include "precomp.h"
#include "driver.h"
#include "RectUtils.h"

#include "nt4multidev.h"

#ifdef NT4_MULTI_DEV


typedef VOID (*PFUNCSTRIP)(SURFOBJ*, BRUSHOBJ*, MIX, STRIP*, LINESTATE*);

/******************************Public*Routine******************************\
* VOID vrlSolidHorizontal
*
* Draws left-to-right x-major near-horizontal lines using radial lines.
*
\**************************************************************************/

VOID SolidHorizontal(SURFOBJ     *pso,
                        BRUSHOBJ    *pbo,
                        MIX         mix,
                        STRIP*      pStrip,
                        LINESTATE*  pLineState)
{
    LONG    i, cStrips;
    PLONG   pStrips;
    LONG    yInc;
    LONG    x, y, x2;
    BOOL    bRet;
    RECTL   rclBounds;


    cStrips = pStrip->cStrips;

    x = pStrip->ptlStart.x;
    y = pStrip->ptlStart.y;

    // Setup the drawing direction and the skip direction.

    yInc = pStrip->flFlips & FL_FLIP_V ? -1 : 1;

    // Output the short stroke commands.

    pStrips = pStrip->alStrips;

    for (i = 0; i < cStrips; i++)
    {
        x2 = x + *pStrips;

        rclBounds.left = min(x, x2);
        rclBounds.top = y;
        rclBounds.right = max(x, x2);
        rclBounds.bottom = y + 1;
        bRet = MulLineTo(pso, NULL, pbo, x, y, x2, y, &rclBounds, mix);
        ASSERT(bRet);

        x += *pStrips++;
        y += yInc;
    }

    pStrip->ptlStart.x = x;
    pStrip->ptlStart.y = y;
}

/******************************Public*Routine******************************\
* VOID vrlSolidVertical
*
* Draws left-to-right y-major near-vertical lines using radial lines.
*
\**************************************************************************/

VOID SolidVertical(SURFOBJ     *pso,
                        BRUSHOBJ    *pbo,
                        MIX         mix,
                        STRIP*      pStrip,
                        LINESTATE*  pLineState)
{
    LONG    cStrips;
    USHORT  Cmd;
    LONG    i, x, y, y2;
    PLONG   pStrips;
    BOOL    bRet;
    RECTL   rclBounds;

    cStrips = pStrip->cStrips;
    pStrips = pStrip->alStrips;

    x = pStrip->ptlStart.x;
    y = pStrip->ptlStart.y;

    if (!(pStrip->flFlips & FL_FLIP_V))
    {
        for (i = 0; i < cStrips; i++)
        {
            y2 = y + *pStrips; 
            rclBounds.left = x;
            rclBounds.top = min(y, y2);
            rclBounds.right = x + 1;
            rclBounds.bottom = max(y, y2);
            bRet = MulLineTo(pso, NULL, pbo, x, y, x, y2, &rclBounds, mix);
            ASSERT(bRet);

            y += *pStrips++;
            x++;
        }

    }
    else
    {
        for (i = 0; i < cStrips; i++)
        {
            y2 = y - *pStrips; 
            rclBounds.left = x;
            rclBounds.top = min(y, y2);
            rclBounds.right = x + 1;
            rclBounds.bottom = max(y, y2);
            bRet = MulLineTo(pso, NULL, pbo, x, y, x, y2, &rclBounds, mix);
            ASSERT(bRet);

            y -= *pStrips++;
            x++;
        }
    }

    pStrip->ptlStart.x = x;
    pStrip->ptlStart.y = y;

}

/******************************Public*Routine******************************\
* VOID vrlSolidDiagonalHorizontal
*
* Draws left-to-right x-major near-diagonal lines using radial lines.
*
\**************************************************************************/

VOID SolidDiagonalHorizontal(SURFOBJ     *pso,
                                BRUSHOBJ    *pbo,
                                MIX         mix,
                                STRIP*      pStrip,
                                LINESTATE*  pLineState)
{
    LONG    cStrips;
    USHORT  Cmd;
    LONG    i, x, y, x2, y2;
    PLONG   pStrips;
    BOOL    bRet;
    RECTL   rclBounds;

    cStrips = pStrip->cStrips;
    pStrips = pStrip->alStrips;

    x = pStrip->ptlStart.x;
    y = pStrip->ptlStart.y;

    if (!(pStrip->flFlips & FL_FLIP_V))
    {

        for (i = 0; i < cStrips; i++)
        {
            x2 = x + *pStrips;
            y2 = y + *pStrips;
            rclBounds.left = min(x, x2);
            rclBounds.top = min(y, y2);
            rclBounds.right = max(x, x2);
            rclBounds.bottom = max(y, y2);
            bRet = MulLineTo(pso, NULL, pbo, x, y, x2, y2, &rclBounds, mix);
            ASSERT(bRet);

            y += *pStrips - 1;
            x += *pStrips++;
        }

    }
    else
    {
        for (i = 0; i < cStrips; i++)
        {
            x2 = x + *pStrips;
            y2 = y - *pStrips;
            rclBounds.left = min(x, x2);
            rclBounds.top = min(y, y2);
            rclBounds.right = max(x, x2);
            rclBounds.bottom = max(y, y2);
            bRet = MulLineTo(pso, NULL, pbo, x, y, x2, y2, &rclBounds, mix);
            ASSERT(bRet);

            y -= *pStrips - 1;
            x += *pStrips++;
        }
    }

    pStrip->ptlStart.x = x;
    pStrip->ptlStart.y = y;

}

/******************************Public*Routine******************************\
* VOID vrlSolidDiagonalVertical
*
* Draws left-to-right y-major near-diagonal lines using radial lines.
*
\**************************************************************************/

VOID SolidDiagonalVertical(SURFOBJ     *pso,
                                BRUSHOBJ    *pbo,
                                MIX         mix,
                                STRIP*      pStrip,
                                LINESTATE*  pLineState)
{
    LONG    cStrips;
    USHORT  Cmd;
    LONG    i, x, y, x2, y2;
    PLONG   pStrips;
    BOOL    bRet;
    RECTL   rclBounds;

    cStrips = pStrip->cStrips;
    pStrips = pStrip->alStrips;

    x = pStrip->ptlStart.x;
    y = pStrip->ptlStart.y;

    if (!(pStrip->flFlips & FL_FLIP_V))
    {
        for (i = 0; i < cStrips; i++)
        {
            x2 = x + *pStrips;
            y2 = y + *pStrips;
            rclBounds.left = min(x, x2);
            rclBounds.top = min(y, y2);
            rclBounds.right = max(x, x2);
            rclBounds.bottom = max(y, y2);
            bRet = MulLineTo(pso, NULL, pbo, x, y, x2, y2, &rclBounds, mix);
            ASSERT(bRet);

            y += *pStrips;
            x += *pStrips++ - 1;
        }

    }
    else
    {
        for (i = 0; i < cStrips; i++)
        {
            x2 = x + *pStrips;
            y2 = y - *pStrips;
            rclBounds.left = min(x, x2);
            rclBounds.top = min(y, y2);
            rclBounds.right = max(x, x2);
            rclBounds.bottom = max(y, y2);
            bRet = MulLineTo(pso, NULL, pbo, x, y, x2, y2, &rclBounds, mix);
            ASSERT(bRet);

            y -= *pStrips;
            x += *pStrips++ - 1;
        }
    }


    pStrip->ptlStart.x = x;
    pStrip->ptlStart.y = y;
}

/******************************Public*Routine******************************\
* VOID vStripStyledHorizontal
*
* Takes the list of strips that define the pixels that would be lit for
* a solid line, and breaks them into styling chunks according to the
* styling information that is passed in.
*
* This particular routine handles x-major lines that run left-to-right,
* and are comprised of horizontal strips.  It draws the dashes using
* short-stroke vectors.
*
* The performance of this routine could be improved significantly if
* anyone cared enough about styled lines improve it.
*
\**************************************************************************/

VOID StripStyledHorizontal(SURFOBJ     *pso,
                            BRUSHOBJ    *pbo,
                            MIX         mix,
                            STRIP*      pstrip,
                            LINESTATE*  pls)
{
    LONG    x, x1, x2;
    LONG    y;
    LONG    dy;
    LONG*   plStrip;
    LONG    cStrips;
    LONG    cStyle;
    LONG    cStrip;
    LONG    cThis;
    ULONG   bIsGap;
    BOOL    bRet;
    RECTL   rclBounds;


    if (pstrip->flFlips & FL_FLIP_V)
    {
        // The minor direction of the line is 90 degrees, and the major
        // direction is 0 (it's a left-to-right x-major line going up):

        dy      = -1;
    }
    else
    {
        // The minor direction of the line is 270 degrees, and the major
        // direction is 0 (it's a left-to-right x-major line going down):

        dy      = 1;
    }

    cStrips = pstrip->cStrips;      // Total number of strips we'll do
    plStrip = pstrip->alStrips;     // Points to current strip
    x       = pstrip->ptlStart.x;   // x position of start of first strip
    y       = pstrip->ptlStart.y;   // y position of start of first strip

    // Warm up the hardware so that it will know we'll be outputing
    // short-stroke vectors, and so that it will have the current position
    // correctly set if we're starting in the middle of a 'dash':

    x1 = x;
//    y1 = y; 

    cStrip = *plStrip;              // Number of pels in first strip

    cStyle = pls->spRemaining;      // Number of pels in first 'gap' or 'dash'
    bIsGap = pls->ulStyleMask;      // Tells whether in a 'gap' or a 'dash'

    // ulStyleMask is non-zero if we're in the middle of a 'gap',
    // and zero if we're in the middle of a 'dash':

    if (bIsGap)
        goto SkipAGap;
    else
        goto OutputADash;

PrepareToSkipAGap:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip:

    if (cStrip != 0)
        goto SkipAGap;

    // Here, we're in the middle of a 'gap' where we don't have to
    // display anything.  We simply cycle through all the strips
    // we can, keeping track of the current position, until we run
    // out of 'gap':

    while (TRUE)
    {
        // Each time we loop, we move to a new scan and need a new strip:

        y += dy;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    SkipAGap:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        x += cThis;

        if (cStyle == 0)
            goto PrepareToOutputADash;
    }

PrepareToOutputADash:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // We're gonna need the current position to be correct when we
    // start outputing short-stroke vectors:

    x1 = x;

    // If 'cStrip' is zero, we also need a new strip.

    if (cStrip != 0)
    {
        // There's more to be done in the current strip, so set 'y'
        // to be the current scan:

//        y1 = y;
        goto OutputADash;
    }

    // Set 'y' to be the scan we're about to move to, because we've
    // finished with the current strip:

//    y1 = y + dy;

    while (TRUE)
    {
        // Each time we loop, we move to a new scan and need a new strip:

        y += dy;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    OutputADash:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        x += cThis;

        x2 = x;

        rclBounds.left = min(x1, x2);
        rclBounds.top = y;
        rclBounds.right = max(x1, x2);
        rclBounds.bottom = y + 1;
        bRet = MulLineTo(pso, NULL, pbo, x1, y, x2, y, &rclBounds, mix);
        ASSERT(bRet);

        x1 = x2;  // set current x1

        if (cStyle == 0)
            goto PrepareToSkipAGap;
    }

AllDone:

    // Update our state variables so that the next line can continue
    // where we left off:

    pls->spRemaining   = cStyle;
    pls->ulStyleMask   = bIsGap;
    pstrip->ptlStart.x = x;
    pstrip->ptlStart.y = y;
}

/******************************Public*Routine******************************\
* VOID vStripStyledVertical
*
* Takes the list of strips that define the pixels that would be lit for
* a solid line, and breaks them into styling chunks according to the
* styling information that is passed in.
*
* This particular routine handles y-major lines that run left-to-right,
* and are comprised of vertical strips.  It draws the dashes using
* short-stroke vectors.
*
* The performance of this routine could be improved significantly if
* anyone cared enough about styled lines improve it.
*
\**************************************************************************/

VOID StripStyledVertical(SURFOBJ     *pso,
                            BRUSHOBJ    *pbo,
                            MIX         mix,
                            STRIP*      pstrip,
                            LINESTATE*  pls)
{
    LONG    x, x1;
    LONG    y, y1, y2;
    LONG    dy;
    LONG*   plStrip;
    LONG    cStrips;
    LONG    cStyle;
    LONG    cStrip;
    LONG    cThis;
    ULONG   bIsGap;
    BOOL    bRet;
    RECTL   rclBounds;

    if (pstrip->flFlips & FL_FLIP_V)
    {
        // The minor direction of the line is 0 degrees, and the major
        // direction is 90 (it's a left-to-right y-major line going up):
        dy        = -1;
    }
    else
    {
        // The minor direction of the line is 0 degrees, and the major
        // direction is 270 (it's a left-to-right y-major line going down):
        dy        = 1;
    }

    cStrips = pstrip->cStrips;      // Total number of strips we'll do
    plStrip = pstrip->alStrips;     // Points to current strip
    x       = pstrip->ptlStart.x;   // x position of start of first strip
    y       = pstrip->ptlStart.y;   // y position of start of first strip

    // Warm up the hardware so that it will know we'll be outputing
    // short-stroke vectors, and so that it will have the current position
    // correctly set if we're starting in the middle of a 'dash':

    x1 = x;
    y1 = y;


    cStrip = *plStrip;              // Number of pels in first strip

    cStyle = pls->spRemaining;      // Number of pels in first 'gap' or 'dash'
    bIsGap = pls->ulStyleMask;      // Tells whether in a 'gap' or a 'dash'

    // ulStyleMask is non-zero if we're in the middle of a 'gap',
    // and zero if we're in the middle of a 'dash':

    if (bIsGap)
        goto SkipAGap;
    else
        goto OutputADash;

PrepareToSkipAGap:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip:

    if (cStrip != 0)
        goto SkipAGap;

    // Here, we're in the middle of a 'gap' where we don't have to
    // display anything.  We simply cycle through all the strips
    // we can, keeping track of the current position, until we run
    // out of 'gap':

    while (TRUE)
    {
        // Each time we loop, we move to a new column and need a new strip:

        x++;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    SkipAGap:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        y += (dy > 0) ? cThis : -cThis;

        if (cStyle == 0)
            goto PrepareToOutputADash;
    }

PrepareToOutputADash:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // We're gonna need the current position to be correct when we
    // start outputing short-stroke vectors:

    y1 = y;

    // If 'cStrip' is zero, we also need a new strip.

    if (cStrip != 0)
    {
        // There's more to be done in the current strip, so set 'x'
        // to be the current column:

        x1 = x;
        goto OutputADash;
    }

    // Set 'x' to be the column we're about to move to, because we've
    // finished with the current strip:

    x1 = x + 1;

    while (TRUE)
    {
        // Each time we loop, we move to a new column and need a new strip:

        x++;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    OutputADash:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        y += (dy > 0) ? cThis : -cThis;

        y2 = y;

        rclBounds.left = x;
        rclBounds.top = min(y1, y2);
        rclBounds.right = x + 1;
        rclBounds.bottom = max(y1, y2);
        bRet = MulLineTo(pso, NULL, pbo, x, y1, x, y2, &rclBounds, mix);
        ASSERT(bRet);

        y1 = y2;   // set current y1

        if (cStyle == 0)
            goto PrepareToSkipAGap;
    }

AllDone:

    // Update our state variables so that the next line can continue
    // where we left off:

    pls->spRemaining   = cStyle;
    pls->ulStyleMask   = bIsGap;
    pstrip->ptlStart.x = x;
    pstrip->ptlStart.y = y;
}


/*******************************Public*Table*******************************\
* gapfnStrip
*
* Look-up table for DrvStrokePath to find which strip routines to call.
*
\**************************************************************************/

VOID (*gapfuncStrip[])(SURFOBJ*, BRUSHOBJ*, MIX, STRIP*, LINESTATE*) = {
    SolidHorizontal,
    SolidVertical,
    SolidDiagonalHorizontal,
    SolidDiagonalVertical,

// Should be NUM_STRIP_DRAW_DIRECTIONS = 4 strip drawers in every group

    SolidHorizontal,
    SolidVertical,
    SolidDiagonalHorizontal,
    SolidDiagonalVertical,

// Should be NUM_STRIP_DRAW_STYLES = 8 strip drawers in total for doing
// solid lines, and the same number for non-solid lines:

    StripStyledHorizontal,
    StripStyledVertical,
    StripStyledVertical,       // Diagonal goes here
    StripStyledVertical,       // Diagonal goes here

    StripStyledHorizontal,
    StripStyledVertical,
    StripStyledVertical,       // Diagonal goes here
    StripStyledVertical,       // Diagonal goes here
};




///////////////////////////////////////////////////////////////////////

// We have to be careful of arithmetic overflow in a number of places.
// Fortunately, the compiler is guaranteed to natively support 64-bit
// signed LONGLONGs and 64-bit unsigned DWORDLONGs.
//
// UUInt32x32To64(a, b) is a macro defined in 'winnt.h' that multiplies
//      two 32-bit ULONGs to produce a 64-bit DWORDLONG result.
//
// UInt64By32To32 is our own macro to divide a 64-bit DWORDLONG by
//      a 32-bit ULONG to produce a 32-bit ULONG result.
//
// UInt64Mod32To32 is our own macro to modulus a 64-bit DWORDLONG by
//      a 32-bit ULONG to produce a 32-bit ULONG result.
//
// 64 bit divides are usually very expensive.  Since it's very rare
// that we'll get lines where the upper 32 bits of the 64 bit result
// are used, we can almost always use 32-bit ULONG divides.  We still
// must correctly handle the larger cases:

#define UInt64Div32To32(a, b)                   \
    ((((DWORDLONG)(a)) > ULONG_MAX)          ?  \
        (ULONG)((DWORDLONG)(a) / (ULONG)(b)) :  \
        (ULONG)((ULONG)(a) / (ULONG)(b)))

#define UInt64Mod32To32(a, b)                   \
    ((((DWORDLONG)(a)) > ULONG_MAX)          ?  \
        (ULONG)((DWORDLONG)(a) % (ULONG)(b)) :  \
        (ULONG)((ULONG)(a) % (ULONG)(b)))

#define SWAPL(x,y,t)        {t = x; x = y; y = t;}

FLONG gaflRound[] = {
    FL_H_ROUND_DOWN | FL_V_ROUND_DOWN, // no flips
    FL_H_ROUND_DOWN | FL_V_ROUND_DOWN, // FL_FLIP_D
    FL_H_ROUND_DOWN,                   // FL_FLIP_V
    FL_V_ROUND_DOWN,                   // FL_FLIP_V | FL_FLIP_D
    FL_V_ROUND_DOWN,                   // FL_FLIP_SLOPE_ONE
    0xbaadf00d,                        // FL_FLIP_SLOPE_ONE | FL_FLIP_D
    FL_H_ROUND_DOWN,                   // FL_FLIP_SLOPE_ONE | FL_FLIP_V
    0xbaadf00d                         // FL_FLIP_SLOPE_ONE | FL_FLIP_V | FL_FLIP_D
};

BOOL bHardwareLine(SURFOBJ*, BRUSHOBJ*, MIX, POINTFIX*, POINTFIX*);

/******************************Public*Routine******************************\
* BOOL bMulLines(ppdev, pptfxFirst, pptfxBuf, cptfx, pls,
*                   prclClip, apfn[], flStart)
*
* Computes the DDA for the line and gets ready to draw it.  Puts the
* pixel data into an array of strips, and calls a strip routine to
* do the actual drawing.
*
* Doing NT Lines Right
* --------------------
*
* In NT, all lines are given to the device driver in fractional
* coordinates, in a 28.4 fixed point format.  The lower 4 bits are
* fractional for sub-pixel positioning.
*
* Note that you CANNOT! just round the coordinates to integers
* and pass the results to your favorite integer Bresenham routine!!
* (Unless, of course, you have such a high resolution device that
* nobody will notice -- not likely for a display device.)  The
* fractions give a more accurate rendering of the line -- this is
* important for things like our Bezier curves, which would have 'kinks'
* if the points in its polyline approximation were rounded to integers.
*
* Unfortunately, for fractional lines there is more setup work to do
* a DDA than for integer lines.  However, the main loop is exactly
* the same (and can be done entirely with 32 bit math).
*
* If You've Got Hardware That Does Bresenham
* ------------------------------------------
*
* A lot of hardware limits DDA error terms to 'n' bits.  With fractional
* coordinates, 4 bits are given to the fractional part, letting
* you draw in hardware only those lines that lie entirely in a 2^(n-4)
* by 2^(n-4) pixel space.
*
* And you still have to correctly draw those lines with coordinates
* outside that space!  Remember that the screen is only a viewport
* onto a 28.4 by 28.4 space -- if any part of the line is visible
* you MUST render it precisely, regardless of where the end points lie.
* So even if you do it in software, somewhere you'll have to have a
* 32 bit DDA routine.
*
* Our Implementation
* ------------------
*
* We employ a run length slice algorithm: our DDA calculates the
* number of pixels that are in each row (or 'strip') of pixels.
*
* We've separated the running of the DDA and the drawing of pixels:
* we run the DDA for several iterations and store the results in
* a 'strip' buffer (which are the lengths of consecutive pixel rows of
* the line), then we crank up a 'strip drawer' that will draw all the
* strips in the buffer.
*
* We also employ a 'half-flip' to reduce the number of strip
* iterations we need to do in the DDA and strip drawing loops: when a
* (normalized) line's slope is more than 1/2, we do a final flip
* about the line y = (1/2)x.  So now, instead of each strip being
* consecutive horizontal or vertical pixel rows, each strip is composed
* of those pixels aligned in 45 degree rows.  So a line like (0, 0) to
* (128, 128) would generate only one strip.
*
* We also always draw only left-to-right.
*
* Styled lines may have arbitrary style patterns.  We specially
* optimize the default patterns (and call them 'masked' styles).
*
* The DDA Derivation
* ------------------
*
* Here is how I like to think of the DDA calculation.
*
* We employ Knuth's "diamond rule": rendering a one-pixel-wide line
* can be thought of as dragging a one-pixel-wide by one-pixel-high
* diamond along the true line.  Pixel centers lie on the integer
* coordinates, and so we light any pixel whose center gets covered
* by the "drag" region (John D. Hobby, Journal of the Association
* for Computing Machinery, Vol. 36, No. 2, April 1989, pp. 209-229).
*
* We must define which pixel gets lit when the true line falls
* exactly half-way between two pixels.  In this case, we follow
* the rule: when two pels are equidistant, the upper or left pel
* is illuminated, unless the slope is exactly one, in which case
* the upper or right pel is illuminated.  (So we make the edges
* of the diamond exclusive, except for the top and left vertices,
* which are inclusive, unless we have slope one.)
*
* This metric decides what pixels should be on any line BEFORE it is
* flipped around for our calculation.  Having a consistent metric
* this way will let our lines blend nicely with our curves.  The
* metric also dictates that we will never have one pixel turned on
* directly above another that's turned on.  We will also never have
* a gap; i.e., there will be exactly one pixel turned on for each
* column between the start and end points.  All that remains to be
* done is to decide how many pixels should be turned on for each row.
*
* So lines we draw will consist of varying numbers of pixels on
* successive rows, for example:
*
*       ******
*             *****
*                  ******
*                        *****
*
* We'll call each set of pixels on a row a "strip".
*
* (Please remember that our coordinate space has the origin as the
* upper left pixel on the screen; postive y is down and positive x
* is right.)
*
* Device coordinates are specified as fixed point 28.4 numbers,
* where the first 28 bits are the integer coordinate, and the last
* 4 bits are the fraction.  So coordinates may be thought of as
* having the form (x, y) = (M/F, N/F) where F is the constant scaling
* factor F = 2^4 = 16, and M and N are 32 bit integers.
*
* Consider the line from (M0/F, N0/F) to (M1/F, N1/F) which runs
* left-to-right and whose slope is in the first octant, and let
* dM = M1 - M0 and dN = N1 - N0.  Then dM >= 0, dN >= 0 and dM >= dN.
*
* Since the slope of the line is less than 1, the edges of the
* drag region are created by the top and bottom vertices of the
* diamond.  At any given pixel row y of the line, we light those
* pixels whose centers are between the left and right edges.
*
* Let mL(n) denote the line representing the left edge of the drag
* region.  On pixel row j, the column of the first pixel to be
* lit is
*
*       iL(j) = ceiling( mL(j * F) / F)
*
* Since the line's slope is less than one:
*
*       iL(j) = ceiling( mL([j + 1/2] F) / F )
*
* Recall the formula for our line:
*
*       n(m) = (dN / dM) (m - M0) + N0
*
*       m(n) = (dM / dN) (n - N0) + M0
*
* Since the line's slope is less than one, the line representing
* the left edge of the drag region is the original line offset
* by 1/2 pixel in the y direction:
*
*       mL(n) = (dM / dN) (n - F/2 - N0) + M0
*
* From this we can figure out the column of the first pixel that
* will be lit on row j, being careful of rounding (if the left
* edge lands exactly on an integer point, the pixel at that
* point is not lit because of our rounding convention):
*
*       iL(j) = floor( mL(j F) / F ) + 1
*
*             = floor( ((dM / dN) (j F - F/2 - N0) + M0) / F ) + 1
*
*             = floor( F dM j - F/2 dM - N0 dM + dN M0) / F dN ) + 1
*
*                      F dM j - [ dM (N0 + F/2) - dN M0 ]
*             = floor( ---------------------------------- ) + 1
*                                   F dN
*
*                      dM j - [ dM (N0 + F/2) - dN M0 ] / F
*             = floor( ------------------------------------ ) + 1       (1)
*                                     dN
*
*             = floor( (dM j + alpha) / dN ) + 1
*
* where
*
*       alpha = - [ dM (N0 + F/2) - dN M0 ] / F
*
* We use equation (1) to calculate the DDA: there are iL(j+1) - iL(j)
* pixels in row j.  Because we are always calculating iL(j) for
* integer quantities of j, we note that the only fractional term
* is constant, and so we can 'throw away' the fractional bits of
* alpha:
*
*       beta = floor( - [ dM (N0 + F/2) - dN M0 ] / F )                 (2)
*
* so
*
*       iL(j) = floor( (dM j + beta) / dN ) + 1                         (3)
*
* for integers j.
*
* Note if iR(j) is the line's rightmost pixel on row j, that
* iR(j) = iL(j + 1) - 1.
*
* Similarly, rewriting equation (1) as a function of column i,
* we can determine, given column i, on which pixel row j is the line
* lit:
*
*                       dN i + [ dM (N0 + F/2) - dN M0 ] / F
*       j(i) = ceiling( ------------------------------------ ) - 1
*                                       dM
*
* Floors are easier to compute, so we can rewrite this:
*
*                     dN i + [ dM (N0 + F/2) - dN M0 ] / F + dM - 1/F
*       j(i) = floor( ----------------------------------------------- ) - 1
*                                       dM
*
*                     dN i + [ dM (N0 + F/2) - dN M0 ] / F + dM - 1/F - dM
*            = floor( ---------------------------------------------------- )
*                                       dM
*
*                     dN i + [ dM (N0 + F/2) - dN M0 - 1 ] / F
*            = floor( ---------------------------------------- )
*                                       dM
*
* We can once again wave our hands and throw away the fractional bits
* of the remainder term:
*
*       j(i) = floor( (dN i + gamma) / dM )                             (4)
*
* where
*
*       gamma = floor( [ dM (N0 + F/2) - dN M0 - 1 ] / F )              (5)
*
* We now note that
*
*       beta = -gamma - 1 = ~gamma                                      (6)
*
* To draw the pixels of the line, we could evaluate (3) on every scan
* line to determine where the strip starts.  Of course, we don't want
* to do that because that would involve a multiply and divide for every
* scan.  So we do everything incrementally.
*
* We would like to easily compute c , the number of pixels on scan j:
*                                  j
*
*    c  = iL(j + 1) - iL(j)
*     j
*
*       = floor((dM (j + 1) + beta) / dN) - floor((dM j + beta) / dN)   (7)
*
* This may be rewritten as
*
*    c  = floor(i    + r    / dN) - floor(i  + r  / dN)                 (8)
*     j          j+1    j+1                j    j
*
* where i , i    are integers and r  < dN, r    < dN.
*        j   j+1                   j        j+1
*
* Rewriting (7) again:
*
*    c  = floor(i  + r  / dN + dM / dN) - floor(i  + r  / dN)
*     j          j    j                          j    j
*
*
*       = floor((r  + dM) / dN) - floor(r  / dN)
*                 j                      j
*
* This may be rewritten as
*
*    c  = dI + floor((r  + dR) / dN) - floor(r  / dN)
*     j                j                      j
*
* where dI + dR / dN = dM / dN, dI is an integer and dR < dN.
*
* r  is the remainder (or "error") term in the DDA loop: r  / dN
*  j                                                      j
* is the exact fraction of a pixel at which the strip ends.  To go
* on to the next scan and compute c    we need to know r   .
*                                  j+1                  j+1
*
* So in the main loop of the DDA:
*
*    c  = dI + floor((r  + dR) / dN) and r    = (r  + dR) % dN
*     j                j                  j+1     j
*
* and we know r  < dN, r    < dN, and dR < dN.
*              j        j+1
*
* We have derived the DDA only for lines in the first octant; to
* handle other octants we do the common trick of flipping the line
* to the first octant by first making the line left-to-right by
* exchanging the end-points, then flipping about the lines y = 0 and
* y = x, as necessary.  We must record the transformation so we can
* undo them later.
*
* We must also be careful of how the flips affect our rounding.  If
* to get the line to the first octant we flipped about x = 0, we now
* have to be careful to round a y value of 1/2 up instead of down as
* we would for a line originally in the first octant (recall that
* "In the case where two pels are equidistant, the upper or left
* pel is illuminated...").
*
* To account for this rounding when running the DDA, we shift the line
* (or not) in the y direction by the smallest amount possible.  That
* takes care of rounding for the DDA, but we still have to be careful
* about the rounding when determining the first and last pixels to be
* lit in the line.
*
* Determining The First And Last Pixels In The Line
* -------------------------------------------------
*
* Fractional coordinates also make it harder to determine which pixels
* will be the first and last ones in the line.  We've already taken
* the fractional coordinates into account in calculating the DDA, but
* the DDA cannot tell us which are the end pixels because it is quite
* happy to calculate pixels on the line from minus infinity to positive
* infinity.
*
* The diamond rule determines the start and end pixels.  (Recall that
* the sides are exclusive except for the left and top vertices.)
* This convention can be thought of in another way: there are diamonds
* around the pixels, and wherever the true line crosses a diamond,
* that pel is illuminated.
*
* Consider a line where we've done the flips to the first octant, and the
* floor of the start coordinates is the origin:
*
*        +-----------------------> +x
*        |
*        | 0                     1
*        |     0123456789abcdef
*        |
*        |   0 00000000?1111111
*        |   1 00000000 1111111
*        |   2 0000000   111111
*        |   3 000000     11111
*        |   4 00000    ** 1111
*        |   5 0000       ****1
*        |   6 000           1***
*        |   7 00             1  ****
*        |   8 ?                     ***
*        |   9 22             3         ****
*        |   a 222           33             ***
*        |   b 2222         333                ****
*        |   c 22222       3333                    **
*        |   d 222222     33333
*        |   e 2222222   333333
*        |   f 22222222 3333333
*        |
*        | 2                     3
*        v
*        +y
*
* If the start of the line lands on the diamond around pixel 0 (shown by
* the '0' region here), pixel 0 is the first pel in the line.  The same
* is true for the other pels.
*
* A little more work has to be done if the line starts in the
* 'nether-land' between the diamonds (as illustrated by the '*' line):
* the first pel lit is the first diamond crossed by the line (pixel 1 in
* our example).  This calculation is determined by the DDA or slope of
* the line.
*
* If the line starts exactly half way between two adjacent pixels
* (denoted here by the '?' spots), the first pixel is determined by our
* round-down convention (and is dependent on the flips done to
* normalize the line).
*
* Last Pel Exclusive
* ------------------
*
* To eliminate repeatedly lit pels between continuous connected lines,
* we employ a last-pel exclusive convention: if the line ends exactly on
* the diamond around a pel, that pel is not lit.  (This eliminates the
* checks we had in the old code to see if we were re-lighting pels.)
*
* The Half Flip
* -------------
*
* To make our run length algorithm more efficient, we employ a "half
* flip".  If after normalizing to the first octant, the slope is more
* than 1/2, we subtract the y coordinate from the x coordinate.  This
* has the effect of reflecting the coordinates through the line of slope
* 1/2.  Note that the diagonal gets mapped into the x-axis after a half
* flip.
*
* How Many Bits Do We Need, Anyway?
* ---------------------------------
*
* Note that if the line is visible on your screen, you must light up
* exactly the correct pixels, no matter where in the 28.4 x 28.4 device
* space the end points of the line lie (meaning you must handle 32 bit
* DDAs, you can certainly have optimized cases for lesser DDAs).
*
* We move the origin to (floor(M0 / F), floor(N0 / F)), so when we
* calculate gamma from (5), we know that 0 <= M0, N0 < F.  And we
* are in the first octant, so dM >= dN.  Then we know that gamma can
* be in the range [(-1/2)dM, (3/2)dM].  The DDI guarantees us that
* valid lines will have dM and dN values at most 31 bits (unsigned)
* of significance.  So gamma requires 33 bits of significance (we store
* this as a 64 bit number for convenience).
*
* When running through the DDA loop, r  + dR can have a value in the
*                                     j
* range 0 <= r  < 2 dN; thus the result must be a 32 bit unsigned value.
*             j
*
* Testing Lines
* -------------
*
* To be NT compliant, a display driver must exactly adhere to GIQ,
* which means that for any given line, the driver must light exactly
* the same pels as does GDI.  This can be tested using the Guiman tool
* provided elsewhere in the DDK, and 'ZTest', which draws random lines
* on the screen and to a bitmap, and compares the results.
*
* If You've Got Line Hardware
* ---------------------------
*
* If your hardware already adheres to GIQ, you're all set.  Otherwise
* you'll want to look at the sample code and read the following:
*
* 1) You'll want to special case integer-only lines, since they require
*    less processing time and are more common (CAD programs will probably
*    only ever give integer lines).  GDI does not provide a flag saying
*    that all lines in a path are integer lines; consequently, you will
*    have to explicitly check every line.
*
* 2) You are required to correctly draw any line in the 28.4 device
*    space that intersects the viewport.  If you have less than 32 bits
*    of significance in the hardware for the Bresenham terms, extremely
*    long lines would overflow the hardware.  For such (rare) cases, you
*    can fall back to strip-drawing code (or if your display is a frame
*    buffer, fall back to the engine).
*
* 3) If you can explicitly set the Bresenham terms in your hardware, you
*    can draw non-integer lines using the hardware.  If your hardware has
*    'n' bits of precision, you can draw GIQ lines that are up to 2^(n-5)
*    pels long (4 bits are required for the fractional part, and one bit is
*    used as a sign bit).  Note that integer lines don't require the 4
*    fractional bits, so if you special case them as in 1), you can do
*    integer lines that are up to 2^(n - 1) pels long.  See the
*    'bHardwareLine' routine for an example.
*
\**************************************************************************/

BOOL bMulLines( SURFOBJ     *pso,
                BRUSHOBJ    *pbo,
                MIX         mix,
                POINTFIX*  pptfxFirst,  // Start of first line
                POINTFIX*  pptfxBuf,    // Pointer to buffer of all remaining lines
                RUN*       prun,        // Pointer to runs if doing complex clipping
                ULONG      cptfx,       // Number of points in pptfxBuf or number of runs
                                        // in prun
                LINESTATE* pls,         // Colour and style info
                RECTL*     prclClip,    // Pointer to clip rectangle if doing simple clipping
                PFUNCSTRIP apfn[],      // Array of strip functions
                FLONG      flStart)     // Flags for each line, which is a combination of:
                            //      FL_SIMPLE_CLIP
                            //      FL_COMPLEX_CLIP
                            //      FL_STYLED
                            //      FL_LAST_PEL_INCLUSIVE
                            //        - Should be set only for all integer lines,
                            //          and can't be used with FL_COMPLEX_CLIP
{
    ULONG     M0;
    ULONG     dM;
    ULONG     N0;
    ULONG     dN;
    ULONG     dN_Original;
    FLONG     fl;
    LONG      x;
    LONG      y;

    LONGLONG  llBeta;
    LONGLONG  llGamma;
    LONGLONG  dl;
    LONGLONG  ll;

    ULONG     ulDelta;

    ULONG     x0;
    ULONG     y0;
    ULONG     x1;
    ULONG     cStylePels;    // Major length of line in pixels for styling
    ULONG     xStart;
    POINTL    ptlStart;
    STRIP     strip;
    PFUNCSTRIP pfn;
    LONG      cPels;
    LONG*     plStrip;
    LONG*     plStripEnd;
    LONG      cStripsInNextRun;
    BOOL        bRet;
    RECTL   rclBounds;

    POINTFIX* pptfxBufEnd = pptfxBuf + cptfx; // Last point in path record
    STYLEPOS  spThis;                         // Style pos for this line

    do {

/***********************************************************************\
* Start the DDA calculations.                                           *
\***********************************************************************/

        M0 = (LONG) pptfxFirst->x;
        dM = (LONG) pptfxBuf->x;

        N0 = (LONG) pptfxFirst->y;
        dN = (LONG) pptfxBuf->y;

        fl = flStart;

    // Check for non-clipped, non-styled integer endpoint lines:

        if ((fl & (FL_CLIP | FL_STYLED)) == 0)
        {
            // Special-case integer end-point lines:

            if (((M0 | dM | N0 | dN) & (F - 1)) == 0)
            {
                // -1 for 'iSolidColor' denotes that the currently set
                // colour and mix should be kept:

                rclBounds.left = min((M0 >> 4), (dM >> 4));
                rclBounds.top = min((N0 >> 4), (dN >> 4));
                rclBounds.right = max((M0 >> 4), (dM >> 4));
                rclBounds.bottom = max((N0 >> 4), (dN >> 4));
                bRet = MulLineTo(pso, NULL, pbo, 
                                 (M0 >> 4) + 0, //ppdev->xOffset,
                                 (N0 >> 4) + 0, //ppdev->yOffset,
                                 (dM >> 4) + 0, //ppdev->xOffset,
                                 (dN >> 4) + 0, //ppdev->yOffset,
                                 &rclBounds, mix);
                ASSERT(bRet);

                goto Next_Line;
            }

            // Check for fractional endpoint lines that are small enough
            // to use the hardware DDA:

            ASSERT(FALSE);
            if (bHardwareLine(pso, pbo, mix, pptfxFirst, pptfxBuf))
                goto Next_Line;
        }
    
        if ((LONG) M0 > (LONG) dM)
        {
        // Ensure that we run left-to-right:

            register ULONG ulTmp;
            SWAPL(M0, dM, ulTmp);
            SWAPL(N0, dN, ulTmp);
            fl |= FL_FLIP_H;
        }

    // Compute the delta dx.  The DDI says we can never have a valid delta
    // with a magnitued more than 2^31 - 1, but GDI never actually checks
    // its transforms.  So we have to check for this case to avoid overflow:

        dM -= M0;
        if ((LONG) dM < 0)
        {
            goto Next_Line;
        }

        if ((LONG) dN < (LONG) N0)
        {
        // Line runs from bottom to top, so flip across y = 0:

            N0 = -(LONG) N0;
            dN = -(LONG) dN;
            fl |= FL_FLIP_V;
        }

        dN -= N0;

        if ((LONG) dN < 0)
        {
            goto Next_Line;
        }

    // We now have a line running left-to-right, top-to-bottom from (M0, N0)
    // to (M0 + dM, N0 + dN):

        if (dN >= dM)
        {
            if (dN == dM)
            {
            // Have to special case slopes of one:

                fl |= FL_FLIP_SLOPE_ONE;
            }
            else
            {
            // Since line has slope greater than 1, flip across x = y:

                register ULONG ulTmp;
                SWAPL(dM, dN, ulTmp);
                SWAPL(M0, N0, ulTmp);
                fl |= FL_FLIP_D;
            }
        }

        fl |= gaflRound[(fl & FL_ROUND_MASK) >> FL_ROUND_SHIFT];

        x = LFLOOR((LONG) M0);
        y = LFLOOR((LONG) N0);

        M0 = FXFRAC(M0);
        N0 = FXFRAC(N0);

    // Calculate the remainder term [ dM * (N0 + F/2) - M0 * dN ]:

        llGamma = UInt32x32To64(dM, N0 + F/2) - UInt32x32To64(M0, dN);
        if (fl & FL_V_ROUND_DOWN)   // Adjust so y = 1/2 rounds down
        {
            llGamma--;
        }

        llGamma >>= FLOG2;
        llBeta = ~llGamma;

/***********************************************************************\
* Figure out which pixels are at the ends of the line.                  *
\***********************************************************************/

    // The toughest part of GIQ is determining the start and end pels.
    //
    // Our approach here is to calculate x0 and x1 (the inclusive start
    // and end columns of the line respectively, relative to our normalized
    // origin).  Then x1 - x0 + 1 is the number of pels in the line.  The
    // start point is easily calculated by plugging x0 into our line equation
    // (which takes care of whether y = 1/2 rounds up or down in value)
    // getting y0, and then undoing the normalizing flips to get back
    // into device space.
    //
    // We look at the fractional parts of the coordinates of the start and
    // end points, and call them (M0, N0) and (M1, N1) respectively, where
    // 0 <= M0, N0, M1, N1 < 16.  We plot (M0, N0) on the following grid
    // to determine x0:
    //
    //   +-----------------------> +x
    //   |
    //   | 0                     1
    //   |     0123456789abcdef
    //   |
    //   |   0 ........?xxxxxxx
    //   |   1 ..........xxxxxx
    //   |   2 ...........xxxxx
    //   |   3 ............xxxx
    //   |   4 .............xxx
    //   |   5 ..............xx
    //   |   6 ...............x
    //   |   7 ................
    //   |   8 ................
    //   |   9 ......**........
    //   |   a ........****...x
    //   |   b ............****
    //   |   c .............xxx****
    //   |   d ............xxxx    ****
    //   |   e ...........xxxxx        ****
    //   |   f ..........xxxxxx
    //   |
    //   | 2                     3
    //   v
    //
    //   +y
    //
    // This grid accounts for the appropriate rounding of GIQ and last-pel
    // exclusion.  If (M0, N0) lands on an 'x', x0 = 2.  If (M0, N0) lands
    // on a '.', x0 = 1.  If (M0, N0) lands on a '?', x0 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // For the end point, if (M1, N1) lands on an 'x', x1 =
    // floor((M0 + dM) / 16) + 1.  If (M1, N1) lands on a '.', x1 =
    // floor((M0 + dM)).  If (M1, N1) lands on a '?', x1 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // Lines of exactly slope one require a special case for both the start
    // and end.  For example, if the line ends such that (M1, N1) is (9, 1),
    // the line has gone exactly through (8, 0) -- which may be considered
    // to be part of 'x' because of rounding!  So slopes of exactly slope
    // one going through (8, 0) must also be considered as belonging in 'x'.
    //
    // For lines that go left-to-right, we have the following grid:
    //
    //   +-----------------------> +x
    //   |
    //   | 0                     1
    //   |     0123456789abcdef
    //   |
    //   |   0 xxxxxxxx?.......
    //   |   1 xxxxxxx.........
    //   |   2 xxxxxx..........
    //   |   3 xxxxx...........
    //   |   4 xxxx............
    //   |   5 xxx.............
    //   |   6 xx..............
    //   |   7 x...............
    //   |   8 x...............
    //   |   9 x.....**........
    //   |   a xx......****....
    //   |   b xxx.........****
    //   |   c xxxx............****
    //   |   d xxxxx...........    ****
    //   |   e xxxxxx..........        ****
    //   |   f xxxxxxx.........
    //   |
    //   | 2                     3
    //   v
    //
    //   +y
    //
    // This grid accounts for the appropriate rounding of GIQ and last-pel
    // exclusion.  If (M0, N0) lands on an 'x', x0 = 0.  If (M0, N0) lands
    // on a '.', x0 = 1.  If (M0, N0) lands on a '?', x0 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // For the end point, if (M1, N1) lands on an 'x', x1 =
    // floor((M0 + dM) / 16) - 1.  If (M1, N1) lands on a '.', x1 =
    // floor((M0 + dM)).  If (M1, N1) lands on a '?', x1 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // Lines of exactly slope one must be handled similarly to the right-to-
    // left case.

        {

        // Calculate x0, x1

            ULONG N1 = FXFRAC(N0 + dN);
        ULONG M1 = FXFRAC(M0 + dM);

        x1 = LFLOOR(M0 + dM);

            if (fl & FL_LAST_PEL_INCLUSIVE)
            {
            // It sure is easy to compute the first pel when lines have only
            // integer coordinates and are last-pel inclusive:

                x0 = 0;
                y0 = 0;

            // Last-pel inclusive lines that are exactly one pixel long
            // have a 'delta-x' and 'delta-y' equal to zero.  The problem is
            // that our clip code assumes that 'delta-x' is always non-zero
            // (since it never happens with last-pel exclusive lines).  As
            // an inelegant solution, we simply modify 'delta-x' in this
            // case -- because the line is exactly one pixel long, changing
            // the slope will obviously have no effect on rasterization.

                if (x1 == 0)
                {
                    dM      = 1;
                    llGamma = 0;
                    llBeta  = ~llGamma;
                }
            }
            else
            {
                if (fl & FL_FLIP_H)
                {
                // ---------------------------------------------------------------
                // Line runs right-to-left:  <----

                // Compute x1:

                    if (N1 == 0)
                    {
                        if (LROUND(M1, fl & FL_H_ROUND_DOWN))
                        {
                            x1++;
                        }
                    }
                    else if (abs((LONG) (N1 - F/2)) + M1 > F)
                    {
                        x1++;
                    }

                    if ((fl & (FL_FLIP_SLOPE_ONE | FL_H_ROUND_DOWN))
                           == (FL_FLIP_SLOPE_ONE))
                    {
                    // Have to special-case diagonal lines going through our
                    // the point exactly equidistant between two horizontal
                    // pixels, if we're supposed to round x=1/2 down:

                        if ((N1 > 0) && (M1 == N1 + 8))
                            x1++;

                    // Don't you love special cases?  Is this a rhetorical question?

                        if ((N0 > 0) && (M0 == N0 + 8))
                        {
                            x0      = 2;
                            ulDelta = dN;
                            goto right_to_left_compute_y0;
                        }
                    }

                // Compute x0:

                    x0      = 1;
                    ulDelta = 0;
                    if (N0 == 0)
                    {
                        if (LROUND(M0, fl & FL_H_ROUND_DOWN))
                        {
                            x0      = 2;
                            ulDelta = dN;
                        }
                    }
                    else if (abs((LONG) (N0 - F/2)) + M0 > F)
                    {
                        x0      = 2;
                        ulDelta = dN;
                    }


                // Compute y0:

                right_to_left_compute_y0:

                    y0 = 0;
                    ll = llGamma + (LONGLONG) ulDelta;

                    if (ll >= (LONGLONG) (2 * dM - dN))
                        y0 = 2;
                    else if (ll >= (LONGLONG) (dM - dN))
                        y0 = 1;
                }
                else
                {
                // ---------------------------------------------------------------
                // Line runs left-to-right:  ---->

                // Compute x1:

                    if (!(fl & FL_LAST_PEL_INCLUSIVE))
                        x1--;

                    if (M1 > 0)
                    {
                        if (N1 == 0)
                        {
                            if (LROUND(M1, fl & FL_H_ROUND_DOWN))
                                x1++;
                        }
                        else if (abs((LONG) (N1 - F/2)) <= (LONG) M1)
                        {
                            x1++;
                        }
                    }

                    if ((fl & (FL_FLIP_SLOPE_ONE | FL_H_ROUND_DOWN))
                           == (FL_FLIP_SLOPE_ONE | FL_H_ROUND_DOWN))
                    {
                    // Have to special-case diagonal lines going through our
                    // the point exactly equidistant between two horizontal
                    // pixels, if we're supposed to round x=1/2 down:

                        if ((M1 > 0) && (N1 == M1 + 8))
                            x1--;

                        if ((M0 > 0) && (N0 == M0 + 8))
                        {
                            x0 = 0;
                            goto left_to_right_compute_y0;
                        }
                    }

                // Compute x0:

                    x0 = 0;
                    if (M0 > 0)
                    {
                        if (N0 == 0)
                        {
                            if (LROUND(M0, fl & FL_H_ROUND_DOWN))
                                x0 = 1;
                        }
                        else if (abs((LONG) (N0 - F/2)) <= (LONG) M0)
                        {
                            x0 = 1;
                        }
                    }

                // Compute y0:

                left_to_right_compute_y0:

                    y0 = 0;
                    if (llGamma >= (LONGLONG) (dM - (dN & (-(LONG) x0))))
                    {
                        y0 = 1;
                    }
                }
            }
        }

        cStylePels = x1 - x0 + 1;
        if ((LONG) cStylePels <= 0)
            goto Next_Line;

        xStart = x0;

/***********************************************************************\
* Complex clipping.                                                     *
\***********************************************************************/

        if (fl & FL_COMPLEX_CLIP)
        {
            dN_Original = dN;

        Continue_Complex_Clipping:

            if (fl & FL_FLIP_H)
            {
            // Line runs right-to-left <-----

                x0 = xStart + cStylePels - prun->iStop - 1;
                x1 = xStart + cStylePels - prun->iStart - 1;
            }
            else
            {
            // Line runs left-to-right ----->

                x0 = xStart + prun->iStart;
                x1 = xStart + prun->iStop;
            }

            prun++;

        // Reset some variables we'll nuke a little later:

            dN          = dN_Original;
            pls->spNext = pls->spComplex;

        // No overflow since large integer math is used.  Both values
        // will be positive:

            dl = UInt32x32To64(x0, dN) + llGamma;

        // y0 = dl / dM:

            y0 = UInt64Div32To32(dl, dM);

            ASSERTDD((LONG) y0 >= 0, "y0 weird: Goofed up end pel calc?");
        }

/***********************************************************************\
* Simple rectangular clipping.                                          *
\***********************************************************************/

        if (fl & FL_SIMPLE_CLIP)
        {
            ULONG y1;
            LONG  xRight;
            LONG  xLeft;
            LONG  yBottom;
            LONG  yTop;

        // Note that y0 and y1 are actually the lower and upper bounds,
        // respectively, of the y coordinates of the line (the line may
        // have actually shrunk due to first/last pel clipping).
        //
        // Also note that x0, y0 are not necessarily zero.

            RECTL* prcl = &prclClip[(fl & FL_RECTLCLIP_MASK) >>
                                    FL_RECTLCLIP_SHIFT];

        // Normalize to the same point we've normalized for the DDA
        // calculations:

            xRight  = prcl->right  - x;
            xLeft   = prcl->left   - x;
            yBottom = prcl->bottom - y;
            yTop    = prcl->top    - y;

            if (yBottom <= (LONG) y0 ||
                xRight  <= (LONG) x0 ||
                xLeft   >  (LONG) x1)
            {
            Totally_Clipped:

                if (fl & FL_STYLED)
                {
                    pls->spNext += cStylePels;
                    if (pls->spNext >= pls->spTotal2)
                        pls->spNext %= pls->spTotal2;
                }

                goto Next_Line;
            }

            if ((LONG) x1 >= xRight)
                x1 = xRight - 1;

        // We have to know the correct y1, which we haven't bothered to
        // calculate up until now.  This multiply and divide is quite
        // expensive; we could replace it with code similar to that which
        // we used for computing y0.
        //
        // The reason why we need the actual value, and not an upper
        // bounds guess like y1 = LFLOOR(dM) + 2 is that we have to be
        // careful when calculating x(y) that y0 <= y <= y1, otherwise
        // we can overflow on the divide (which, needless to say, is very
        // bad).

            dl = UInt32x32To64(x1, dN) + llGamma;

        // y1 = dl / dM:

            y1 = UInt64Div32To32(dl, dM);

            if (yTop > (LONG) y1)
                goto Totally_Clipped;

            if (yBottom <= (LONG) y1)
            {
                y1 = yBottom;
                dl = UInt32x32To64(y1, dM) + llBeta;

            // x1 = dl / dN:

                x1 = UInt64Div32To32(dl, dN);
            }

        // At this point, we've taken care of calculating the intercepts
        // with the right and bottom edges.  Now we work on the left and
        // top edges:

            if (xLeft > (LONG) x0)
            {
                x0 = xLeft;
                dl = UInt32x32To64(x0, dN) + llGamma;

            // y0 = dl / dM;

                y0 = UInt64Div32To32(dl, dM);

                if (yBottom <= (LONG) y0)
                    goto Totally_Clipped;
            }

            if (yTop > (LONG) y0)
            {
                y0 = yTop;
                dl = UInt32x32To64(y0, dM) + llBeta;

            // x0 = dl / dN + 1;

                x0 = UInt64Div32To32(dl, dN) + 1;

                if (xRight <= (LONG) x0)
                    goto Totally_Clipped;
            }

            ASSERTDD(x0 <= x1, "Improper rectangle clip");
        }

/***********************************************************************\
* Done clipping.  Unflip if necessary.                                 *
\***********************************************************************/

        ptlStart.x = x + x0;
        ptlStart.y = y + y0;

        if (fl & FL_FLIP_D)
        {
            register LONG lTmp;
            SWAPL(ptlStart.x, ptlStart.y, lTmp);
        }


        if (fl & FL_FLIP_V)
        {
            ptlStart.y = -ptlStart.y;
        }

        cPels = x1 - x0 + 1;

/***********************************************************************\
* Style calculations.                                                   *
\***********************************************************************/

        if (fl & FL_STYLED)
        {
            STYLEPOS sp;

            spThis       = pls->spNext;
            pls->spNext += cStylePels;

            {
                if (pls->spNext >= pls->spTotal2)
                    pls->spNext %= pls->spTotal2;

                if (fl & FL_FLIP_H)
                    sp = pls->spNext - x0 + xStart;
                else
                    sp = spThis + x0 - xStart;

                ASSERTDD(fl & FL_STYLED, "Oops");

            // Normalize our target style position:

                if ((sp < 0) || (sp >= pls->spTotal2))
                {
                    sp %= pls->spTotal2;

                // The modulus of a negative number is not well-defined
                // in C -- if it's negative we'll adjust it so that it's
                // back in the range [0, spTotal2):

                    if (sp < 0)
                        sp += pls->spTotal2;
                }

            // Since we always draw the line left-to-right, but styling is
            // always done in the direction of the original line, we have
            // to figure out where we are in the style array for the left
            // edge of this line.

                if (fl & FL_FLIP_H)
                {
                // Line originally ran right-to-left:

                    sp = -sp;
                    if (sp < 0)
                        sp += pls->spTotal2;

                    pls->ulStyleMask = ~pls->ulStartMask;
                    pls->pspStart    = &pls->aspRtoL[0];
                    pls->pspEnd      = &pls->aspRtoL[pls->cStyle - 1];
                }
                else
                {
                // Line originally ran left-to-right:

                    pls->ulStyleMask = pls->ulStartMask;
                    pls->pspStart    = &pls->aspLtoR[0];
                    pls->pspEnd      = &pls->aspLtoR[pls->cStyle - 1];
                }

                if (sp >= pls->spTotal)
                {
                    sp -= pls->spTotal;
                    if (pls->cStyle & 1)
                        pls->ulStyleMask = ~pls->ulStyleMask;
                }

                pls->psp = pls->pspStart;
                while (sp >= *pls->psp)
                    sp -= *pls->psp++;

                ASSERTDD(pls->psp <= pls->pspEnd,
                        "Flew off into NeverNeverLand");

                pls->spRemaining = *pls->psp - sp;
                if ((pls->psp - pls->pspStart) & 1)
                    pls->ulStyleMask = ~pls->ulStyleMask;
            }
        }

        plStrip    = &strip.alStrips[0];
        plStripEnd = &strip.alStrips[STRIP_MAX];    // Is exclusive
        cStripsInNextRun   = 0x7fffffff;

    strip.ptlStart = ptlStart;

        if (2 * dN > dM &&
            !(fl & FL_STYLED))
        {
        // Do a half flip!  Remember that we may doing this on the
        // same line multiple times for complex clipping (meaning the
        // affected variables should be reset for every clip run):

            fl |= FL_FLIP_HALF;

            llBeta  = llGamma - (LONGLONG) ((LONG) dM);
            dN = dM - dN;
            y0 = x0 - y0;       // Note this may overflow, but that's okay
        }

    // Now, run the DDA starting at (ptlStart.x, ptlStart.y)!

        strip.flFlips = fl;
        pfn           = apfn[(fl & FL_STRIP_MASK) >> FL_STRIP_SHIFT];

    // Now calculate the DDA variables needed to figure out how many pixels
    // go in the very first strip:

        {
            register LONG  i;
            register ULONG dI;
            register ULONG dR;
                     ULONG r;

            if (dN == 0)
                i = 0x7fffffff;
            else
            {
                dl = UInt32x32To64(y0 + 1, dM) + llBeta;

                ASSERTDD(dl >= 0, "Oops!");

            // i = (dl / dN) - x0 + 1;
            // r = (dl % dN);

                i = UInt64Div32To32(dl, dN);
                r = UInt64Mod32To32(dl, dN);
                i = i - x0 + 1;

                dI = dM / dN;
                dR = dM % dN;               // 0 <= dR < dN

                ASSERTDD(dI > 0, "Weird dI");
            }

            ASSERTDD(i > 0 && i <= 0x7fffffff, "Weird initial strip length");
            ASSERTDD(cPels > 0, "Zero pel line");

/***********************************************************************\
* Run the DDA!                                                          *
\***********************************************************************/

            while(TRUE)
            {
                cPels -= i;
                if (cPels <= 0)
                    break;

                *plStrip++ = i;

                if (plStrip == plStripEnd)
                {
                    strip.cStrips = plStrip - &strip.alStrips[0];
                    (*pfn)(pso, pbo, mix, &strip, pls);
                    plStrip = &strip.alStrips[0];
                }

                i = dI;
                r += dR;

                if (r >= dN)
                {
                    r -= dN;
                    i++;
                }
            }

            *plStrip++ = cPels + i;

            strip.cStrips = plStrip - &strip.alStrips[0];
            (*pfn)(pso, pbo, mix, &strip, pls);


        }

    Next_Line:

        if (fl & FL_COMPLEX_CLIP)
        {
            cptfx--;
            if (cptfx != 0)
                goto Continue_Complex_Clipping;

            break;
        }
        else
        {
            pptfxFirst = pptfxBuf;
            pptfxBuf++;
        }

    } while (pptfxBuf < pptfxBufEnd);

    return(TRUE);

}

//////////////////////////////////////////////////////////////////////////
// General defines for bHardwareLine

#define HW_FLIP_D           0x0001L     // Diagonal flip
#define HW_FLIP_V           0x0002L     // Vertical flip
#define HW_FLIP_H           0x0004L     // Horizontal flip
#define HW_FLIP_SLOPE_ONE   0x0008L     // Normalized line has exactly slope one
#define HW_FLIP_MASK        (HW_FLIP_D | HW_FLIP_V | HW_FLIP_H)

#define HW_X_ROUND_DOWN     0x0100L     // x = 1/2 rounds down in value
#define HW_Y_ROUND_DOWN     0x0200L     // y = 1/2 rounds down in value

LONG gaiDir[] = { 0, 1, 7, 6, 3, 2, 4, 5 };

FLONG gaflHardwareRound[] = {
    HW_X_ROUND_DOWN | HW_Y_ROUND_DOWN,  //           |        |        |
    HW_X_ROUND_DOWN | HW_Y_ROUND_DOWN,  //           |        |        | FLIP_D
    HW_X_ROUND_DOWN,                    //           |        | FLIP_V |
    HW_Y_ROUND_DOWN,                    //           |        | FLIP_V | FLIP_D
    HW_Y_ROUND_DOWN,                    //           | FLIP_H |        |
    HW_X_ROUND_DOWN,                    //           | FLIP_H |        | FLIP_D
    0,                                  //           | FLIP_H | FLIP_V |
    0,                                  //           | FLIP_H | FLIP_V | FLIP_D
    HW_Y_ROUND_DOWN,                    // SLOPE_ONE |        |        |
    0xffffffff,                         // SLOPE_ONE |        |        | FLIP_D
    HW_X_ROUND_DOWN,                    // SLOPE_ONE |        | FLIP_V |
    0xffffffff,                         // SLOPE_ONE |        | FLIP_V | FLIP_D
    HW_Y_ROUND_DOWN,                    // SLOPE_ONE | FLIP_H |        |
    0xffffffff,                         // SLOPE_ONE | FLIP_H |        | FLIP_D
    HW_X_ROUND_DOWN,                    // SLOPE_ONE | FLIP_H | FLIP_V |
    0xffffffff                          // SLOPE_ONE | FLIP_H | FLIP_V | FLIP_D
};


/******************************Public*Routine******************************\
* BOOL bHardwareLine(ppdev, pptfxStart, pptfxEnd)
*
* This routine is useful for folks who have line drawing hardware where
* they can explicitly set the Bresenham terms -- they can use this routine
* to draw fractional coordinate GIQ lines with the hardware.
*
* Fractional coordinate lines require an extra 4 bits of precision in the
* Bresenham terms.  For example, if your hardware has 13 bits of precision
* for the terms, you can only draw GIQ lines up to 255 pels long using this
* routine.
*
* Input:
*   pptfxStart  - Points to GIQ coordinate of start of line
*   pptfxEnd    - Points to GIQ coordinate of end of line
*   NUM_DDA_BITS- The number of bits of precision your hardware can support.
*
* Output:
*   returns     - TRUE if the line was drawn.
*                 FALSE if the line is too long, and the strips code must be
*                 used.
*
* DDALINE:
*   iDir        - Direction of the line, as an octant numbered as follows:
*
*                    \ 5 | 6 /
*                     \  |  /
*                    4 \ | / 7
*                       \ /
*                   -----+-----
*                       /|\
*                    3 / | \ 0
*                     /  |  \
*                    / 2 | 1 \
*
*   ptlStart    - Start pixel of line.
*   cPels       - # of pels in line.  *NOTE* You must check if this is <= 0!
*   dMajor      - Major axis delta.
*   dMinor      - Minor axis delta.
*   lErrorTerm  - Error term.
*
* What you do with the last 3 terms may be a little tricky.  They are
* actually the terms for the formula of the normalized line
*
*                     dMinor * x + (lErrorTerm + dMajor)
*       y(x) = floor( ---------------------------------- )
*                                  dMajor
*
* where y(x) is the y coordinate of the pixel to be lit as a function of
* the x-coordinate.
*
* Every time the line advances one in the major direction 'x', dMinor
* gets added to the current error term.  If the resulting value is >= 0,
* we know we have to move one pixel in the minor direction 'y', and
* dMajor must be subtracted from the current error term.
*
* If you're trying to figure out what this means for your hardware, you can
* think of the DDALINE terms as having been computed equivalently as
* follows:
*
*     dMinor     = 2 * (minor axis delta)
*     dMajor     = 2 * (major axis delta)
*     lErrorTerm = - (major axis delta) - fixup
*
* That is, if your documentation tells you that for integer lines, a
* register is supposed to be initialized with the value
* '2 * (minor axis delta)', you'll actually use dMinor.
*
* Example: Setting up the 8514
*
*     AXSTPSIGN is supposed to be the axial step constant register, defined
*     as 2 * (minor axis delta).  You set:
*
*           AXSTPSIGN = dMinor
*
*     DGSTPSIGN is supposed to be the diagonal step constant register,
*     defined as 2 * (minor axis delta) - 2 * (major axis delta).  You set:
*
*           DGSTPSIGN = dMinor - dMajor
*
*     ERR_TERM is supposed to be the adjusted error term, defined as
*     2 * (minor axis delta) - (major axis delta) - fixup.  You set:
*
*           ERR_TERM = lErrorTerm + dMinor
*
* Implementation:
*
*     You'll want to special case integer lines before calling this routine
*     (since they're very common, take less time to the computation of line
*     terms, and can handle longer lines than this routine because 4 bits
*     aren't being given to the fraction).
*
*     If a GIQ line is too long to be handled by this routine, you can just
*     use the slower strip routines for that line.  Note that you cannot
*     just fail the call -- you must be able to accurately draw any line
*     in the 28.4 device space when it intersects the viewport.
*
* Testing:
*
*     Use Guiman, or some other test that draws random fractional coordinate
*     lines and compares them to what GDI itself draws to a bitmap.
*
\**************************************************************************/

BOOL bHardwareLine(SURFOBJ     *pso,
                    BRUSHOBJ    *pbo,
                    MIX         mix,                              
                    POINTFIX* pptfxStart,       // Start of line
                    POINTFIX* pptfxEnd)         // End of line
{
    return FALSE;
}


// Style array for alternate style (alternates one pixel on, one pixel off):

STYLEPOS gaspAlternateStyle[] = { 1 };


/******************************Public*Routine******************************\
* BOOL MulStrokePath(pso, ppo, pco, pxo, pbo, pptlBrush, pla, mix)
*
* Strokes the path.
*
\**************************************************************************/
BOOL MulStrokePath(
    SURFOBJ*   pso,
    PATHOBJ*   ppo,
    CLIPOBJ*   pco,
    XFORMOBJ*  pxo,
    BRUSHOBJ*  pbo,
    POINTL*    pptlBrush,
    LINEATTRS* pla,
    MIX        mix)
{
    BOOL  bRet  = FALSE;
    PPDEV ppdev = NULL;

    DISPDBG((100, "MulStrokePath >>>"));

    ppdev = (PPDEV)pso->dhpdev; 

    ASSERT(ppdev);

    if( !ppdev->pmdev )
    {
        bRet = DrvStrokePath(pso, ppo, pco, pxo, pbo, pptlBrush,pla,mix);
    }
    else
    {
        PMDEV   pmdev = ppdev->pmdev;  
        ULONG   ulDevID;
        STYLEPOS  aspLtoR[STYLE_MAX_COUNT];
        STYLEPOS  aspRtoL[STYLE_MAX_COUNT];
        LINESTATE ls;
        PFUNCSTRIP* apfn;
        FLONG     fl;
        RECTL     arclClip[4];                  // For rectangular clipping
        RECTL*    prclClip;

#if DBG
        DWORD dwLvl = 10;
        DISPDBG((dwLvl, "pco    :0x%x", pco));
        if (pco)
            DISPDBG((dwLvl, "rclBounds: (%d, %d) - (%d, %d)", pco->rclBounds.left, pco->rclBounds.top, pco->rclBounds.right, pco->rclBounds.bottom));
        if (pbo)
            DISPDBG((dwLvl, "Color: 0x%x", pbo->iSolidColor));
#endif
        ASSERTDD(((mix >> 8) & 0xff) == (mix & 0xff),
                 "GDI gave us an improper mix");

        // Pass the surface off to GDI if it's a device bitmap that we've
        // converted to a DIB:

        if (!bNeedToEnumerate(pso))
        {
            // fast path for single board or bitmaps
            bRet = EngStrokePath( pso, ppo, pco, pxo, pbo, pptlBrush, pla, mix);
            goto Exit;
        }

        prclClip = NULL;
        fl       = 0;

        // Look after styling initialization:

        if (pla->fl & LA_ALTERNATE)
        {
            ls.cStyle      = 1;
            ls.spTotal     = 1;
            ls.spTotal2    = 2;
            ls.spRemaining = 1;
            ls.aspRtoL     = &gaspAlternateStyle[0];
            ls.aspLtoR     = &gaspAlternateStyle[0];
            ls.spNext      = HIWORD(pla->elStyleState.l);
            ls.xyDensity   = 1;
            fl            |= FL_STYLED;
            ls.ulStartMask = 0L;
        }
        else if (pla->pstyle != (FLOAT_LONG*) NULL)
        {
            PFLOAT_LONG pstyle;
            STYLEPOS*   pspDown;
            STYLEPOS*   pspUp;

            pstyle = &pla->pstyle[pla->cstyle];

            ls.xyDensity = STYLE_DENSITY;
            ls.spTotal   = 0;
            while (pstyle-- > pla->pstyle)
            {
                ls.spTotal += pstyle->l;
            }
            ls.spTotal *= STYLE_DENSITY;
            ls.spTotal2 = 2 * ls.spTotal;

            // Compute starting style position (this is guaranteed not to overflow):

            ls.spNext = HIWORD(pla->elStyleState.l) * STYLE_DENSITY +
                        LOWORD(pla->elStyleState.l);

            fl        |= FL_STYLED;
            ls.cStyle  = pla->cstyle;
            ls.aspRtoL = aspRtoL;
            ls.aspLtoR = aspLtoR;

            if (pla->fl & LA_STARTGAP)
                ls.ulStartMask = 0xffffffffL;
            else
                ls.ulStartMask = 0L;

            pstyle  = pla->pstyle;
            pspDown = &ls.aspRtoL[ls.cStyle - 1];
            pspUp   = &ls.aspLtoR[0];

            while (pspDown >= &ls.aspRtoL[0])
            {
                *pspDown = pstyle->l * STYLE_DENSITY;
                *pspUp   = *pspDown;

                pspUp++;
                pspDown--;
                pstyle++;
            }
        }

        if (pco->iDComplexity == DC_RECT)
        {
            fl |= FL_SIMPLE_CLIP;

            arclClip[0]        =  pco->rclBounds;

            // FL_FLIP_D:

            arclClip[1].top    =  pco->rclBounds.left;
            arclClip[1].left   =  pco->rclBounds.top;
            arclClip[1].bottom =  pco->rclBounds.right;
            arclClip[1].right  =  pco->rclBounds.bottom;

            // FL_FLIP_V:

            arclClip[2].top    = -pco->rclBounds.bottom + 1;
            arclClip[2].left   =  pco->rclBounds.left;
            arclClip[2].bottom = -pco->rclBounds.top + 1;
            arclClip[2].right  =  pco->rclBounds.right;

            // FL_FLIP_V | FL_FLIP_D:

            arclClip[3].top    =  pco->rclBounds.left;
            arclClip[3].left   = -pco->rclBounds.bottom + 1;
            arclClip[3].bottom =  pco->rclBounds.right;
            arclClip[3].right  = -pco->rclBounds.top + 1;

            prclClip = arclClip;
        }

        apfn = &gapfuncStrip[NUM_STRIP_DRAW_STYLES *
                                ((fl & FL_STYLE_MASK) >> FL_STYLE_SHIFT)];

        // Set up to enumerate the path:

        if (pco->iDComplexity != DC_COMPLEX)
        {
            PATHDATA  pd;
            BOOL      bMore;
            ULONG     cptfx;
            POINTFIX  ptfxStartFigure;
            POINTFIX  ptfxLast;
            POINTFIX* pptfxFirst;
            POINTFIX* pptfxBuf;


            pd.flags = 0;

            do {
                bMore = PATHOBJ_bEnum(ppo, &pd);

                cptfx = pd.count;
                if (cptfx == 0)
                    break;

                if (pd.flags & PD_BEGINSUBPATH)
                {
                    ptfxStartFigure  = *pd.pptfx;
                    pptfxFirst       = pd.pptfx;
                    pptfxBuf         = pd.pptfx + 1;
                    cptfx--;
                }
                else
                {
                    pptfxFirst       = &ptfxLast;
                    pptfxBuf         = pd.pptfx;
                }

                if (pd.flags & PD_RESETSTYLE)
                    ls.spNext = 0;

                if (cptfx > 0)
                {
                    if (!bMulLines(pso, pbo, mix,
                                pptfxFirst,
                                pptfxBuf,
                                (RUN*) NULL,
                                cptfx,
                                &ls,
                                prclClip,
                                apfn,
                                fl))
                    {
                        bRet = FALSE;
                        goto Exit;
                    }
                }

                ptfxLast = pd.pptfx[pd.count - 1];

                if (pd.flags & PD_CLOSEFIGURE)
                {
                    if (!bMulLines(pso, pbo, mix,
                                &ptfxLast,
                                &ptfxStartFigure,
                                (RUN*) NULL,
                                1,
                                &ls,
                                prclClip,
                                apfn,
                                fl))
                    {
                        bRet = FALSE;
                        goto Exit;
                    }
                }
            } while (bMore);

            if (fl & FL_STYLED)
            {
            // Save the style state:

                ULONG ulHigh;
                ULONG ulLow;

            // Masked styles don't normalize the style state.  It's a good
            // thing to do, so let's do it now:

                if ((ULONG) ls.spNext >= (ULONG) ls.spTotal2)
                    ls.spNext = (ULONG) ls.spNext % (ULONG) ls.spTotal2;

                ulHigh = ls.spNext / ls.xyDensity;
                ulLow  = ls.spNext % ls.xyDensity;

                pla->elStyleState.l = MAKELONG(ulLow, ulHigh);
            }
        }
        else
        {
        // Local state for path enumeration:

            BOOL bMore;
            union {
                BYTE     aj[offsetof(CLIPLINE, arun) + RUN_MAX * sizeof(RUN)];
                CLIPLINE cl;
            } cl;

            fl |= FL_COMPLEX_CLIP;

        // We use the clip object when non-simple clipping is involved:

            PATHOBJ_vEnumStartClipLines(ppo, pco, pso, pla);

            do {
                bMore = PATHOBJ_bEnumClipLines(ppo, sizeof(cl), &cl.cl);
                if (cl.cl.c != 0)
                {
                    if (fl & FL_STYLED)
                    {
                        ls.spComplex = HIWORD(cl.cl.lStyleState) * ls.xyDensity
                                     + LOWORD(cl.cl.lStyleState);
                    }
                    if (!bMulLines(pso, pbo, mix,
                                &cl.cl.ptfxA,
                                &cl.cl.ptfxB,
                                &cl.cl.arun[0],
                                cl.cl.c,
                                &ls,
                                (RECTL*) NULL,
                                apfn,
                                fl))
                    {
                        bRet = FALSE;
                        goto Exit;
                    }
                }
            } while (bMore);
        }

        bRet = TRUE;
    }

Exit:
    DISPDBG((100, "<<< MulStrokePath"));

    return(bRet);
}


//******************************************************************************
//
//  MulLineTo
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
BOOL MulLineTo(SURFOBJ*    pso,
                CLIPOBJ*    pco,
                BRUSHOBJ*   pbo,
                LONG        x1,
                LONG        y1,
                LONG        x2,
                LONG        y2,
                RECTL*      prclBounds,
                MIX         mix)
{
    BOOL  bRet  = FALSE;
    PPDEV ppdev = NULL;

    DISPDBG((100, "MulLineTo >>>"));

    ppdev = (PPDEV)pso->dhpdev; 

    ASSERT(ppdev);

    if( !ppdev->pmdev )
    {
        bRet = DrvLineTo(pso, pco, pbo, x1, y1, x2, y2, prclBounds, mix);
    }
    else
    {
        PMDEV   pmdev = ppdev->pmdev;  
        ULONG   ulDevID;
        LONG    lTransX1, lTransY1;
        LONG    lTransX2, lTransY2;
        ENUMDEV16 enumDev16;    
        BOARDDESC *pBoardDesc;
        ULONG   cDevices;
        DEVOBJ  DevObj;
        SURFOBJ *psoBoard;
        RECTL   rclBoard;
        RECTL   rclBounds;
        RECTL   *prclScratchBounds;
        CLIPENUM ce;
        LONG    l;
        BOOL    bMore;
        BOOL    bMoreClip;

#if DBG
        DWORD dwLvl = 10;
#endif

        DISPDBG((dwLvl, "MulLineTo >>>"));

        if (!bNeedToEnumerate(pso))
        {
            // fast path for bitmaps
            bRet = EngLineTo(pso, pco, pbo, x1, y1, x2, y2, prclBounds, mix);
        }
        else
        {
    
            prclScratchBounds = prclBounds;
            if (prclBounds)
            {
                rclBounds           = *prclBounds;
                prclScratchBounds   = &rclBounds;
            }

            if (pmdev)
            {
                cDevices = DEVOBJ_cEnumStart(&DevObj, pso, NULL, TRUE, CD_ANY);
                if (cDevices)
                {
                    do 
                    {
                        bMore = DEVOBJ_bEnum(&DevObj, &enumDev16);
                        for (ulDevID = 0; ulDevID < enumDev16.c; ulDevID++)
                        {
                            pBoardDesc = enumDev16.apbdDevices[ulDevID];
                            psoBoard = psoGetBoardRectAndSync( IN pso, IN pBoardDesc, IN NULL, OUT &rclBoard);
                
                            lTransX1 = x1 - rclBoard.left;
                            lTransX2 = x2 - rclBoard.left;

                            lTransY1 = y1 - rclBoard.top;
                            lTransY2 = y2 - rclBoard.top;

                            if (prclBounds)
                            {
                                vRclSubOffset(&rclBounds, prclBounds, rclBoard.left, rclBoard.top);
                            }

                            if (NULL == pco || DC_TRIVIAL == pco->iDComplexity)
                            {
                                pBoardDesc->pco->rclBounds = rclBoard;    
                                vRclSubOffset(&pBoardDesc->pco->rclBounds, &pBoardDesc->pco->rclBounds, rclBoard.left, rclBoard.top);

                                if (lTransX1 >= pBoardDesc->pco->rclBounds.left && lTransX1 < pBoardDesc->pco->rclBounds.right &&
                                    lTransY1 >= pBoardDesc->pco->rclBounds.top  && lTransY1 < pBoardDesc->pco->rclBounds.bottom &&
                                    lTransX2 >= pBoardDesc->pco->rclBounds.left && lTransX2 < pBoardDesc->pco->rclBounds.right &&
                                    lTransY2 >= pBoardDesc->pco->rclBounds.top  && lTransY2 < pBoardDesc->pco->rclBounds.bottom)
                                {
                                    pBoardDesc->pco->iDComplexity = DC_TRIVIAL;
                                }
                                bRet = DrvLineTo(psoBoard, pBoardDesc->pco, pbo, lTransX1, lTransY1, lTransX2, lTransY2, prclScratchBounds, mix);
                                pBoardDesc->pco->iDComplexity = DC_RECT;
                            }
                            else if (DC_RECT == pco->iDComplexity)
                            {
                                if (!bRclIntersect(&pBoardDesc->pco->rclBounds, &pco->rclBounds, &rclBoard))
                                    continue;
                                vRclSubOffset(&pBoardDesc->pco->rclBounds, &pBoardDesc->pco->rclBounds, rclBoard.left, rclBoard.top);

                                if (lTransX1 >= pBoardDesc->pco->rclBounds.left && lTransX1 < pBoardDesc->pco->rclBounds.right &&
                                    lTransY1 >= pBoardDesc->pco->rclBounds.top  && lTransY1 < pBoardDesc->pco->rclBounds.bottom &&
                                    lTransX2 >= pBoardDesc->pco->rclBounds.left && lTransX2 < pBoardDesc->pco->rclBounds.right &&
                                    lTransY2 >= pBoardDesc->pco->rclBounds.top  && lTransY2 < pBoardDesc->pco->rclBounds.bottom)
                                {
                                    pBoardDesc->pco->iDComplexity = DC_TRIVIAL;
                                }
                                bRet = DrvLineTo(psoBoard, pBoardDesc->pco, pbo, lTransX1, lTransY1, lTransX2, lTransY2, prclScratchBounds, mix);
                                pBoardDesc->pco->iDComplexity = DC_RECT;
                            }
                            else
                            {

                                CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

                                do  
                                {
                                    bMoreClip = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);
                                    for (l = 0; l < ce.c; l++)
                                    {
                                        if (bRclIntersect(&pBoardDesc->pco->rclBounds, &ce.arcl[l], &rclBoard))
                                        {
                                            vRclSubOffset(&pBoardDesc->pco->rclBounds, &pBoardDesc->pco->rclBounds, rclBoard.left, rclBoard.top);

                                            bRet = DrvLineTo(psoBoard, pBoardDesc->pco, pbo, lTransX1, lTransY1, lTransX2, lTransY2, prclScratchBounds, mix);
                                        }
                                    }
                                }
                                while (bMoreClip);
                            }
                        }
                    }
                    while (bMore && bRet);
                }
            }
        }
    }

    DISPDBG((100, "<<< MulLineTo"));
    return bRet;
}


//******************************************************************************
//
//  MulFillPath
//
//  NT4 multiboard wrapper function which redirects all calls to singeboard
//  functions of all devices
//
//******************************************************************************
BOOL MulFillPath( SURFOBJ*  pso,
                  PATHOBJ*  ppo,
                  CLIPOBJ*  pco,
                  BRUSHOBJ* pbo,
                  POINTL*   pptlBrushOrg,
                  MIX       mix,
                  FLONG     flOptions)
{
    BOOL  bRet  = FALSE;
    PPDEV ppdev = NULL;

    DISPDBG((100, "MulFillPath >>>"));

    ppdev = (PPDEV)pso->dhpdev; 

    ASSERT(ppdev);

    if( !ppdev->pmdev )
    {
        bRet = DrvFillPath(pso, ppo, pco, pbo, pptlBrushOrg, mix, flOptions);
    }
    else
    {
        // not implemented so far
        ASSERT(FALSE);
    }

    DISPDBG((100, "<<< MulFillPath"));
    return bRet;
}


#endif // NT4_MULTI_DEV
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nv1lines.c ===
//******************************************************************************
//
// Module Name: NV1LINES.C
//
// Contains most of the required GDI line support.  Supports drawing
// lines in short 'strips' when clipping is complex or coordinates
// are too large to be drawn by the line hardware.
//
// Copyright (c) 1990-1996 Microsoft Corporation
//
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/


#include "precomp.h"
#include "nv1_32.h"
#include "driver.h"
#include "nv1c_ref.h"
#include "nvsubch.h"
#include "nvalpha.h"


//*****************************************************************************
//
//  Function:   NV1StrokePath
//
//  Routine Description:
//
//              Strokes the path.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//*****************************************************************************

BOOL NV1StrokePath(
    SURFOBJ*   pso,
    PATHOBJ*   ppo,
    CLIPOBJ*   pco,
    XFORMOBJ*  pxo,
    BRUSHOBJ*  pbo,
    POINTL*    pptlBrush,
    LINEATTRS* pla,
    MIX        mix)

    {
    PDEV*       ppdev;
    DSURF*      pdsurf;
    RECTL       arclClip[4];                  // For rectangular clipping

    SURFOBJ*    TempDstSurfObjPtr;
    SURFOBJ*    PuntPtr;

    NvChannel   *nv;
    USHORT      FreeCount;
    BOOL        bMore;
    ULONG       VertexCount;
    POINTFIX    *CurrentVertexPtr;
    POINTFIX    *FirstVertexPtr;
    POINTFIX    *NextVertexPtr;
    POINTFIX    LastVertex;
    LONG        x0,y0;
    LONG        x1,y1;
    ULONG       width,height;
    ULONG       AlphaEnableValue;
    PATHDATA    pd;
    ULONG       temp;
    ULONG       LineVisibleFlag;
    ULONG       *DstBits;
    ULONG       *ScreenBitmap;
    ULONG       Rop3;
    ULONG       i;
    LONG        curX, curY;
    BYTE        jClip;


    ASSERTDD(((mix >> 8) & 0xff) == (mix & 0xff),
             "GDI gave us an improper mix");

    //**************************************************************************
    // Get ptr to physical device.  We should never get a null surface object
    //**************************************************************************

    ppdev = (PDEV*) pso->dhpdev;

    //**************************************************************************
    // Get the FreeCount
    //**************************************************************************

    FreeCount = ppdev->NVFreeCount;

    //**************************************************************************
    // Default to the original surface object passed in to us
    //**************************************************************************

    TempDstSurfObjPtr = pso;

    //**************************************************************************
    // This 'punt' surface object is used only if we need to use GDI to
    // draw to an offscreen DFB.  Since the primary surface is already
    // a GDI-managed surface, we can kick back any line drawn to the screen.
    //**************************************************************************

    PuntPtr = ppdev->psoPunt;

    //**************************************************************************
    // Check if this is a device managed surface
    //**************************************************************************

    pdsurf = (DSURF*) pso->dhsurf;
   
    if (pdsurf !=0)
        {

        //**********************************************************************
        // Pass the surface off to GDI if it's a device bitmap that we've
        // converted to a DIB:
        //**********************************************************************

        if (pdsurf->dt == DT_DIB)
            {
            //******************************************************************
            // NOTE: We use pdsurf->pso, NOT just pso, because this is
            //       a DFB that exists in system memory.
            //******************************************************************

            ppdev->pfnWaitEngineBusy(ppdev);
            return(EngStrokePath(pdsurf->pso, ppo, pco, pxo, pbo, pptlBrush,
                             pla, mix));
            }
        }

    //**************************************************************************
    // Only handle line drawing to VRAM.  Send lines to system memory back to GDI.
    //**************************************************************************

    DstBits         = (ULONG *)(pso->pvBits);
    ScreenBitmap    = (ULONG *)(ppdev->pjScreen);

    if ((pdsurf == 0) && (DstBits != ScreenBitmap))
        goto GDI_StrokePathIt;

    //**************************************************************************
    // Only SIMPLE, STRAIGHT lines implemented, the rest go thru GDI
    //
    // If we get to this point, the line is to be drawn onscreen
    // We'll currently use NV hardware to ONLY draw straight integer lines.
    // (Because #1) The line object is not yet implemented, just the solid
    //              rectangle object, so we'll use that to draw only straight lines
    //          #2) Currently don't have time to verify the lines are drawn
    //              exactly correct.  We'll just handle the extremely simple
    //              lines, and let GDI worry about the rest.
    //**************************************************************************

    //**************************************************************************
    // Init the pointer to NV hardware
    //**************************************************************************

    nv = (NvChannel *)ppdev->pjMmBase;

    //**************************************************************************
    // ONLY handle solid single pixel wide lines
    // Line Style is solid if pstyle array ptr is NULL
    //**************************************************************************

    if (pco == NULL)
        jClip = DC_TRIVIAL;
    else
        jClip = pco->iDComplexity;

    if ((pla->pstyle == (FLOAT_LONG*) NULL) && !(pla->fl & (LA_GEOMETRIC | LA_ALTERNATE)))
        {

        //**********************************************************************
        // ONLY handle non-clipped lines or single rectangle clipped lines
        //**********************************************************************

        if ((jClip == DC_TRIVIAL) || (jClip == DC_RECT))
            {
            //******************************************************************
            // If this is a mix which uses the destination, then we cannot punt to GDI
            // in the middle of a path enumeration since GDI will draw the same lines
            // which we have already drawn. So we MUST prescan the list of lines in the
            // path to ensure that none of the vertices in the path have a fractional
            // component, and that ALL of the lines are either horiz or vert. For now
            // we'll just check for a SRCCOPY mix.
            //******************************************************************
            if ((mix & 0xf) != R2_COPYPEN)
                {
                PATHOBJ_vEnumStart(ppo);
                do
                    {
                    pd.flags = 0;
                    bMore = PATHOBJ_bEnum(ppo, &pd);
                    curX = pd.pptfx[0].x >> 4;
                    curY = pd.pptfx[0].y >> 4;

                    for (i = 0; i < pd.count; i++)
                        {
                        if ((((pd.pptfx[i].x | pd.pptfx[i].y) & 0xf) != 0) ||
                            !((pd.pptfx[i].x >> 4) == curX || (pd.pptfx[i].y >> 4) == curY))
                            goto GDI_StrokePathIt;
                        else
                            {
                            curX = pd.pptfx[i].x >> 4;
                            curY = pd.pptfx[i].y >> 4;
                            }

                        }
                    } while (bMore);
                }

            //******************************************************************
            // First, copy the clipping rectangle if it's present
            //******************************************************************

            if (jClip == DC_RECT)
                {
                arclClip[0] = pco->rclBounds;
                }

            //******************************************************************
            // Check free count and prepare rectangle engine
            //******************************************************************

            while (FreeCount < 2*4)
                FreeCount = nv->subchannel[RECTANGLE_SUBCHANNEL].control.free ;
            FreeCount -=2*4;

            //******************************************************************
            // Convert mix to a Rop3 value.
            //******************************************************************
            Rop3 = (mix & 0x0f) - 1;
            Rop3 |= (Rop3 << 4);

            nv->subchannel[ROP_SOLID_SUBCHANNEL].ropSolid.SetRop = Rop3;
            nv->subchannel[RECTANGLE_SUBCHANNEL].renderSolidRectangle.Color = pbo->iSolidColor;

            //**************************************************************************
            // Reset clipping rectangle to full screen extents if necessary
            // Resetting the clipping rectangle causes delays so we want to do it
            // as little as possible!
            //**************************************************************************
            if (ppdev->NVClipResetFlag)
                {
                while (FreeCount < 2*4)
                    FreeCount = nv->subchannel[CLIP_SUBCHANNEL].control.free;
                FreeCount -= 2*4;

                nv->subchannel[CLIP_SUBCHANNEL].imageBlackRectangle.SetRectangle.y_x = ((0 << 16) | 0 );
                nv->subchannel[CLIP_SUBCHANNEL].imageBlackRectangle.SetRectangle.height_width = (((ppdev->cyMemory)<<16) | (ppdev->cxMemory));

                ppdev->NVClipResetFlag=0;       // Clipping rectangle has been reset
                }

            PATHOBJ_vEnumStart(ppo);
            do  {

                pd.flags = 0;

                //**************************************************************
                // Get the current group of lines
                //**************************************************************

                bMore = PATHOBJ_bEnum(ppo, &pd);

                //**************************************************************
                // Get number of vertices in this record.
                //**************************************************************

                VertexCount = pd.count;

                //**************************************************************
                // Check to see if we need to 'reset' the starting vertex
                //**************************************************************

                if (pd.flags & PD_BEGINSUBPATH)
                    {
                    //**********************************************************
                    // Get ptr to coordinates of the first vertex
                    //**********************************************************

                    CurrentVertexPtr    = pd.pptfx;
                    NextVertexPtr       = pd.pptfx+1;
                    FirstVertexPtr      = pd.pptfx;
                    }

                else

                    {
                    //**********************************************************
                    // Get coordinates of first vertex.
                    // Since we didn't get a BEGIN_SUBPATH notification,
                    // use the last vertex from the last line record
                    // as the first vertex.
                    //**********************************************************

                    CurrentVertexPtr    = &LastVertex;
                    NextVertexPtr       = pd.pptfx;
                    FirstVertexPtr      = &LastVertex;
                    }

                //**************************************************************
                // If we DIDN'T get a BEGIN_SUBPATH notification,
                // do we need to increment VertexCount???
                // We'll be using LastVertex, which isn't part of the
                // current list of lines???
                //**************************************************************

//           VertexCount++;

                //**************************************************************
                // Exit if there aren't at least 2 vertices
                //**************************************************************

                if (VertexCount < 2)
                    goto NV_LinesAreDone;

                //**************************************************************
                // Copy the last vertex in this record
                //**************************************************************

                LastVertex = pd.pptfx[pd.count - 1];

                //**************************************************************
                // Need a minimum of 2 vertices per line
                //**************************************************************

                do  {
                    //**********************************************************
                    // Check each line and see if it's an integer and straight
                    // Get the first PATHDATA record
                    //**********************************************************

                    x0 = CurrentVertexPtr->x;
                    y0 = CurrentVertexPtr->y;

                    x1 = NextVertexPtr->x;
                    y1 = NextVertexPtr->y;

                    //**********************************************************
                    // Send to GDI if we get a non-integer line
                    //**********************************************************

                    if (((x0 | y0 | x1 | y1) & 0xf) != 0)
                        goto GDI_StrokePathIt;

                    //**********************************************************
                    // Get rid of fixed fractional component
                    //**********************************************************

                    x0 >>=4;
                    y0 >>=4;
                    x1 >>=4;
                    y1 >>=4;

                    //**********************************************************
                    // Default to always drawing the line
                    //**********************************************************

                    LineVisibleFlag = TRUE;

                    //**********************************************************
                    // Only draw line if it's horizontal or vertical
                    //**********************************************************

                    if (x0==x1)

                        {
                        //******************************************************
                        // We're dealing with a VERTICAL line
                        // Make sure to calculate a positive height and
                        // swap the coordinates if necessary
                        //******************************************************

                        width=1;
                        if (y0 > y1)
                            {
                            temp=y0;
                            y0=y1+1;
                            y1=temp+1;
                            }

                        //******************************************************
                        // Vertical Line Clipping:
                        // At this point, we have the following variables to
                        // work with:       x,y,  and  width,height
                        //
                        // Now we can do single rectangle clipping very easily
                        //******************************************************

                        if (jClip == DC_RECT)
                            {

                            //**************************************************
                            // Check if is line is visible or completely clipped
                            //**************************************************

                            if ((x0 < arclClip[0].left) || (x0 >= arclClip[0].right) ||
                                (y1 <= arclClip[0].top) || (y0 >= arclClip[0].bottom))
                                LineVisibleFlag = FALSE;
                            else
                                {
                                //**********************************************
                                // If line is visible, check if it needs to be clipped
                                // If it is clipped , then update the height.
                                //**********************************************

                                if (y1 > arclClip[0].bottom)
                                    y1 = arclClip[0].bottom;

                                if (y0 < arclClip[0].top)
                                    y0 = arclClip[0].top;
                                }
                            }
                        height = y1 - y0;
                        }

                   else if (y0==y1)

                        {
                        //******************************************************
                        // We're dealing with a HORIZONTAL line
                        // Make sure to calculate a positive width and
                        // swap the coordinates if necessary
                        //******************************************************

                        height=1;
                        if (x0 > x1)
                            {
                            temp=x0;
                            x0=x1+1;
                            x1=temp+1;
                            }

                        //******************************************************
                        // Horizontal Line Clipping:
                        // At this point, we have the following variables to
                        // work with:       x,y,  and  width,height
                        //
                        // Now we can do single rectangle clipping very easily
                        //******************************************************

                        if (jClip == DC_RECT)
                            {

                            //**************************************************
                            // Check if is line is visible or completely clipped
                            //**************************************************

                            if ((y0 < arclClip[0].top) || (y0 >= arclClip[0].bottom) ||
                                (x1 <= arclClip[0].left) || (x0 >= arclClip[0].right))
                                LineVisibleFlag = FALSE;
                            else
                                {
                                //**********************************************
                                // If line is visible, check if it needs to be clipped
                                // If it is clipped , then update the width.
                                //**********************************************

                                if (x1 > arclClip[0].right)
                                    x1 = arclClip[0].right;

                                if (x0 < arclClip[0].left)
                                    x0 = arclClip[0].left;

                                }
                            }
                        width = x1 - x0;
                        }

                    else

                        {
                        //******************************************************
                        // This group of lines contains a NON straight line.
                        // Just punt it back to GDI
                        //******************************************************
                        goto GDI_StrokePathIt;

                        }

                    //**********************************************************
                    // Time to output a straight line if visible
                    //**********************************************************

                    if (LineVisibleFlag == TRUE)
                        {
                        DISPDBG((6,"x,y: %lx %lx h,w: %lx %lx", x0, y0, height, width));
                        while (FreeCount < 2*4)
                            FreeCount = nv->subchannel[RECTANGLE_SUBCHANNEL].control.free ;
                        FreeCount -=2*4;

                        nv->subchannel[RECTANGLE_SUBCHANNEL].renderSolidRectangle.Rectangle[0].y_x = ( (y0<<16) | (x0 & 0xffff) );
                        nv->subchannel[RECTANGLE_SUBCHANNEL].renderSolidRectangle.Rectangle[0].height_width = ( (height << 16) | (width & 0xffff) );

                        //******************************************************
                        // Advance to next line (must have at least 2 vertices)
                        //******************************************************
                        }


                    VertexCount--;

                    CurrentVertexPtr = NextVertexPtr;
                    NextVertexPtr++;

                    } while (VertexCount >= 2);

                //**************************************************************
                // Draw closing line if specified and if it's straight
                //**************************************************************

                if (pd.flags & PD_CLOSEFIGURE)
                    {

                    x0 = LastVertex.x;
                    y0 = LastVertex.y;

                    x1 = FirstVertexPtr->x;
                    y1 = FirstVertexPtr->y;

                    //**********************************************************
                    // Send to GDI if we get a non-integer line
                    //**********************************************************

                    if (((x0 | y0 | x1 | y1) & 0xf) != 0)
                        goto GDI_StrokePathIt;

                    //**********************************************************
                    // Get rid of fixed fractional component
                    //**********************************************************

                    x0 >>=4;
                    y0 >>=4;
                    x1 >>=4;
                    y1 >>=4;

                    //**********************************************************
                    // Default to always drawing the closing line
                    //**********************************************************

                    LineVisibleFlag = TRUE;

                    //**********************************************************
                    // Make sure line is straight!
                    //**********************************************************

                    if (x0==x1)

                        {
                        //******************************************************
                        // We're dealing with a VERTICAL line
                        // Make sure to calculate a positive height and
                        // swap the coordinates if necessary
                        //******************************************************

                        width=1;
                        if (y0 > y1)
                            {
                            temp=y0;
                            y0=y1+1;
                            y1=temp+1;
                            }

                        //******************************************************
                        // Vertical Line Clipping:
                        // At this point, we have the following variables to
                        // work with:       x,y,  and  width,height
                        //
                        // Now we can do single rectangle clipping very easily
                        //******************************************************

                        if (jClip == DC_RECT)
                            {

                            //**************************************************
                            // Check if is line is visible or completely clipped
                            //**************************************************

                            if ((x0 < arclClip[0].left) || (x0 >= arclClip[0].right) ||
                                (y1 <= arclClip[0].top) || (y0 >= arclClip[0].bottom))
                                LineVisibleFlag = FALSE;
                            else
                                {
                                //**********************************************
                                // If line is visible, check if it needs to be clipped
                                // If it is clipped , then update the height.
                                //**********************************************

                                if (y0 < arclClip[0].top)
                                    y0 = arclClip[0].top;

                                if (y1 > arclClip[0].bottom)
                                    y1 = arclClip[0].bottom;
                                }
                            }
                        height = y1 - y0;
                        }

                   else if (y0==y1)

                        {
                        //******************************************************
                        // We're dealing with a HORIZONTAL line
                        // Make sure to calculate a positive width and
                        // swap the coordinates if necessary
                        //******************************************************

                        height=1;
                        if (x0 > x1)
                            {
                            temp=x0;
                            x0=x1+1;
                            x1=temp+1;
                            }

                        //******************************************************
                        // Horizontal Line Clipping:
                        // At this point, we have the following variables to
                        // work with:       x,y,  and  width,height
                        //
                        // Now we can do single rectangle clipping very easily
                        //******************************************************

                        if (jClip == DC_RECT)
                            {

                            //**************************************************
                            // Check if is line is visible or completely clipped
                            //**************************************************

                            if ((y0 < arclClip[0].top) || (y0 >= arclClip[0].bottom) ||
                                (x1 <= arclClip[0].left) || (x0 >= arclClip[0].right))
                                LineVisibleFlag = FALSE;
                            else
                                {
                                //**********************************************
                                // If line is visible, check if it needs to be clipped
                                // If it is clipped , then update the width.
                                //**********************************************

                                if (x0 < arclClip[0].left)
                                    x0 = arclClip[0].left;

                                if (x1 > arclClip[0].right)
                                    x1 = arclClip[0].right;
                                }
                            }
                        width = x1 - x0;
                        }


                    else

                        {
                        //******************************************************
                        // This group of lines contains a NON straight line.
                        // Just punt it back to GDI
                        //******************************************************
                        goto GDI_StrokePathIt;

                        }


                    //**********************************************************
                    // Time to output a straight line if visible
                    //**********************************************************

                    if (LineVisibleFlag == TRUE)
                        {
                        DISPDBG((6,"x,y: %lx %lx h,w: %lx %lx", x0, y0, height, width));
                        while (FreeCount < 2*4)
                            FreeCount = nv->subchannel[RECTANGLE_SUBCHANNEL].control.free ;
                        FreeCount -=2*4;
                        nv->subchannel[RECTANGLE_SUBCHANNEL].renderSolidRectangle.Rectangle[0].y_x = ( (y0<<16) | (x0 & 0xffff) );
                        nv->subchannel[RECTANGLE_SUBCHANNEL].renderSolidRectangle.Rectangle[0].height_width = ( (height << 16) | (width & 0xffff) );
                        }

                    }

                } while (bMore) ;

NV_LinesAreDone:
            //******************************************************************
            // Update global free count
            //******************************************************************

            ppdev->NVFreeCount = FreeCount;

            return(TRUE);

            } // Only handle non-clipped lines or lines clipped to a single rectangle


        } // Only handle solid-lines


    //**************************************************************************
    // Send all other lines thru GDI
    //**************************************************************************

GDI_StrokePathIt:

    if (pdsurf !=0)

        {

        //******************************************************************
        // This is an offscreen DFB (DT_SCREEN).  Let GDI draw the line
        // using the wrapper 'punt' surface object
        //******************************************************************

        PuntPtr->dhsurf = 0;               // Behave like a standard DIB
        PuntPtr->sizlBitmap = pdsurf->sizl;

        //******************************************************************
        // Set linear offset and stride for source and destination buffers
        //******************************************************************

        PuntPtr->cjBits  = pdsurf->LinearStride * pdsurf->sizl.cy;
        PuntPtr->pvBits  = pdsurf->LinearPtr;
        PuntPtr->pvScan0 = pdsurf->LinearPtr;
        PuntPtr->lDelta  = pdsurf->LinearStride;

        PuntPtr->iBitmapFormat = ppdev->iBitmapFormat;

        TempDstSurfObjPtr = PuntPtr;

        }

    //**************************************************************************
    // Update global free count
    //**************************************************************************

    ppdev->NVFreeCount = FreeCount;

    ppdev->pfnWaitEngineBusy(ppdev);
    return(EngStrokePath(TempDstSurfObjPtr, ppo, pco, pxo, pbo, pptlBrush,
                             pla, mix));


    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nv1linto.c ===
//*****************************Module*Header************************************
//
// Module Name: NV1LINTO.C
//
// DrvLineTo for S3 driver
//
// Copyright (c) 1995-1996 Microsoft Corporation
//
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"
#include "driver.h"

#include "nv1_32.h"
#include "nv1c_ref.h"
#include "nvsubch.h"
#include "nvalpha.h"


//*****************************************************************************
//
//  Function:   NV1LineTo
//
//  Routine Description:
//
//          Draws a single solid integer-only cosmetic line.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//*****************************************************************************


BOOL NV1LineTo(
SURFOBJ*    pso,
CLIPOBJ*    pco,
BRUSHOBJ*   pbo,
LONG        x1,
LONG        y1,
LONG        x2,
LONG        y2,
RECTL*      prclBounds,
MIX         mix)

    {
    PDEV*   ppdev;
    DSURF*  pdsurf;
    LONG    xOffset;
    LONG    yOffset;
    BOOL    bRet;

    SURFOBJ*    TempDstSurfObjPtr;
    SURFOBJ*    PuntPtr;

    NvChannel   *nv;
    USHORT      FreeCount;
    BOOL        bMore;
    ULONG       VertexCount;
    POINTFIX    *CurrentVertexPtr;
    POINTFIX    *FirstVertexPtr;
    POINTFIX    *NextVertexPtr;
    POINTFIX    LastVertex;
    ULONG       width,height;
    ULONG       AlphaEnableValue;
    ULONG       PixelDepth;
    PATHDATA    pd;
    ULONG       temp;
    ULONG       LineVisibleFlag;
    ULONG       *DstBits;
    ULONG       *ScreenBitmap;
    ULONG       Rop3;
    ULONG SrcOffset;
    ULONG DstOffset;
    ULONG SrcStride;
    ULONG DstStride;

    ASSERTDD(((mix >> 8) & 0xff) == (mix & 0xff),
             "GDI gave us an improper mix");

    //**************************************************************************
    // Get ptr to physical device.  We should never get a null surface object
    //**************************************************************************

    ppdev = (PDEV*) pso->dhpdev;

    //**************************************************************************
    // Init FreeCount and prepare rectangle engine
    //**************************************************************************

    FreeCount = ppdev->NVFreeCount;
    
    //**************************************************************************
    // Default to the original surface object passed in to us
    //**************************************************************************

    TempDstSurfObjPtr = pso;

    //**************************************************************************
    // This 'punt' surface object is used only if we need to use GDI to
    // draw to an offscreen DFB.  Since the primary surface is already
    // a GDI-managed surface, we can kick back any line drawn to the screen.
    //**************************************************************************

    PuntPtr = ppdev->psoPunt;

    //**************************************************************************
    // Pass the surface off to GDI if it's a device bitmap that we've
    // converted to a DIB:
    //**************************************************************************

    pdsurf = (DSURF*) pso->dhsurf;
    if (pdsurf !=0)
        {

        //**********************************************************************
        // Pass the surface off to GDI if it's a device bitmap that we've
        // converted to a DIB:
        //**********************************************************************

        if (pdsurf->dt == DT_DIB)
            {
            //******************************************************************
            // NOTE: We use pdsurf->pso, NOT just pso, because this is
            //       a DFB that exists in system memory.
            //******************************************************************
            ppdev->pfnWaitEngineBusy(ppdev);
            return(EngLineTo(pdsurf->pso, pco, pbo, x1, y1, x2, y2, prclBounds, mix));

            }

        else
            {

            //******************************************************************
            //  Offset values must be zero now, for linear memory management !!!
            //******************************************************************

            ppdev->xOffset = 0;
            ppdev->yOffset = 0;

            }

        }
    else
        {
        //**************************************************************************
        // Reset the 'offscreen' offsets to zero just to be safe
        //**************************************************************************
        ppdev->xOffset = 0;
        ppdev->yOffset = 0;
        }


    //*************************************************************************
    // Only handle line drawing to VRAM.  Send lines drawn
    // to system memory back to GDI.
    //*************************************************************************

    DstBits         = (ULONG *)(pso->pvBits);
    ScreenBitmap    = (ULONG *)(ppdev->pjScreen);

    if ((pdsurf == 0) && (DstBits != ScreenBitmap))
        goto GDI_EngLineToIt;


    //**************************************************************************
    // Only SIMPLE, STRAIGHT lines implemented, the rest go thru GDI
    //
    // If we get to this point, the line is to be drawn onscreen
    // We'll currently use NV hardware to ONLY draw straight integer lines.
    // (Because #1) The line object is not yet implemented, just the solid
    //              rectangle object, so we'll use that to draw only straight lines
    //          #2) Currently don't have time to verify the lines are drawn
    //              exactly correct.  We'll just handle the extremely simple
    //              lines, and let GDI worry about the rest.
    //**************************************************************************

    //**************************************************************************
    // Init the pointer to NV hardware
    //**************************************************************************

    nv = (NvChannel *)ppdev->pjMmBase;

    //**************************************************************************
    // Restore clip rect
    //**************************************************************************
    if (ppdev->NVClipResetFlag)
        {
        while(FreeCount < 2*4)
            FreeCount = nv->subchannel[CLIP_SUBCHANNEL].control.free;
        FreeCount -= 2*4;

        nv->subchannel[CLIP_SUBCHANNEL].imageBlackRectangle.SetRectangle.y_x = ((0 << 16) | 0 );
        nv->subchannel[CLIP_SUBCHANNEL].imageBlackRectangle.SetRectangle.height_width = (((ppdev->cyMemory)<<16) | (ppdev->cxMemory));

        ppdev->NVClipResetFlag=0;       // Clipping rectangle has been reset
        }


    //**************************************************************************
    // ONLY handle non-clipped lines or single rectangle clipped lines
    //**************************************************************************

    if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL) )
        {

        //**********************************************************************
        // Get pixel depth for the current mode.
        // Then determine the ALPHA_CHANNEL enable value
        //**********************************************************************

        PixelDepth = ppdev->cBitsPerPel;

        AlphaEnableValue = ppdev->AlphaEnableValue;

        while (FreeCount < 2*4)
            FreeCount = nv->subchannel[RECTANGLE_SUBCHANNEL].control.free ;
        FreeCount -=2*4;

        //******************************************************************
        // Convert mix to a Rop3 value.
        //******************************************************************
        Rop3 = (mix & 0xf) - 1;
        Rop3 |= (Rop3 << 4);

        nv->subchannel[ROP_SOLID_SUBCHANNEL].ropSolid.SetRop = Rop3 ;
        nv->subchannel[RECTANGLE_SUBCHANNEL].renderSolidRectangle.Color = pbo->iSolidColor | AlphaEnableValue;


        //**********************************************************************
        // Only draw line if it's horizontal or vertical
        // Init default values for width and height
        //**********************************************************************

        width=1;
        height=1;

        if (x1==x2)

            {
            //******************************************************************
            // We're dealing with a VERTICAL line
            // Make sure to calculate a positive height and
            // swap the coordinates if necessary
            //******************************************************************

            if (y1 < y2)
                height=y2-y1;
            else if (y1 > y2)
                {
                height=y1-y2;
                y1=y2+1;
                }
            }

        else if (y1==y2)

            {
            //******************************************************************
            // We're dealing with a HORIZONTAL line
            // Make sure to calculate a positive width and
            // swap the coordinates if necessary
            //******************************************************************

            if (x1 < x2)
                width=x2-x1;
            else if (x1 > x2)
                {
                width=x1-x2;
                x1=x2+1;
                }
            }
        else

            {
            //******************************************************************
            // This group of lines contains a NON straight line.
            // Just punt it back to GDI
            //******************************************************************

            //******************************************************************
            // Update global free count
            //******************************************************************

            ppdev->NVFreeCount = FreeCount;

            goto GDI_EngLineToIt;

            }

        //**********************************************************************
        // Use hardware to draw the line
        //**********************************************************************

        while (FreeCount < 2*4)
            FreeCount = nv->subchannel[RECTANGLE_SUBCHANNEL].control.free ;
        FreeCount -=2*4;

        nv->subchannel[RECTANGLE_SUBCHANNEL].renderSolidRectangle.Rectangle[0].y_x = ( ((y1 + ppdev->yOffset)<<16) | ((x1 + ppdev->xOffset) & 0xffff) );
        nv->subchannel[RECTANGLE_SUBCHANNEL].renderSolidRectangle.Rectangle[0].height_width = ( (height << 16) | width );

        //**********************************************************************
        // Update global free count
        //**********************************************************************

        ppdev->NVFreeCount = FreeCount;

        return(TRUE);
        }


    else if (pco->iDComplexity == DC_RECT)

        {
        //**********************************************************************
        // This code is fairly re-dundant, but to squeeze as much performance
        // as possible, we separate it into 2 cases (non-clipped and single-clipped)
        //**********************************************************************
        //**********************************************************************
        // Get pixel depth for the current mode.
        // Then determine the ALPHA_CHANNEL enable value
        //**********************************************************************

        PixelDepth = ppdev->cBitsPerPel;

        AlphaEnableValue = ppdev->AlphaEnableValue;

        while (FreeCount < 2*4)
            FreeCount = nv->subchannel[RECTANGLE_SUBCHANNEL].control.free ;
        FreeCount -=2*4;

        //******************************************************************
        // Convert mix to a Rop3 value.
        //******************************************************************
        Rop3 = (mix & 0xf) - 1;
        Rop3 |= (Rop3 << 4);

        nv->subchannel[ROP_SOLID_SUBCHANNEL].ropSolid.SetRop = Rop3 ;
        nv->subchannel[RECTANGLE_SUBCHANNEL].renderSolidRectangle.Color = pbo->iSolidColor | AlphaEnableValue;

        //**********************************************************************
        // Default drawing the line
        //**********************************************************************

        LineVisibleFlag = TRUE;

        //**********************************************************************
        // Only draw line if it's horizontal or vertical
        // Init default values for width and height
        //**********************************************************************

        width=1;
        height=1;

        if (x1==x2)

            {
            //******************************************************************
            // We're dealing with a VERTICAL line
            // Make sure to calculate a positive height and
            // swap the coordinates if necessary
            //******************************************************************

            if (y1 < y2)
                height=y2-y1;
            else if (y1 > y2)
                {
                height=y1-y2;
                temp=y1;
                y1=y2+1;
                y2=temp;
                }


            //******************************************************************
            // Check if is line is visible or completely clipped
            //******************************************************************

            if ((x1 < pco->rclBounds.left) || (x1 > pco->rclBounds.right))
                LineVisibleFlag = FALSE;
            else if ((y2 < pco->rclBounds.top) || (y1 > pco->rclBounds.bottom))
                LineVisibleFlag = FALSE;
            else
                {
                //**************************************************************
                // If line is visible, check if it needs to be clipped
                // If it is clipped , then update the height.
                //**************************************************************

                if (y2 > pco->rclBounds.bottom)
                    y2 = pco->rclBounds.bottom;

                if (y1 < pco->rclBounds.top)
                    y1 = pco->rclBounds.top;

                height = y2 - y1;


                }
            }

        else if (y1==y2)

            {
            //******************************************************************
            // We're dealing with a HORIZONTAL line
            // Make sure to calculate a positive width and
            // swap the coordinates if necessary
            //******************************************************************

            if (x1 < x2)
                width=x2-x1;
            else if (x1 > x2)
                {
                width=x1-x2;
                temp=x1;
                x1=x2+1;
                x2=temp;
                }


            //******************************************************************
            // Check if is line is visible or completely clipped
            //******************************************************************

            if ((y1 < pco->rclBounds.top) || (y1 > pco->rclBounds.bottom))
                LineVisibleFlag = FALSE;
            else if ((x2 < pco->rclBounds.left) || (x1 > pco->rclBounds.right))
                LineVisibleFlag = FALSE;
            else
                {
                //**************************************************************
                // If line is visible, check if it needs to be clipped
                // If it is clipped , then update the width.
                //**************************************************************

                if (x2 > pco->rclBounds.right)
                    x2 = pco->rclBounds.right;

                if (x1 < pco->rclBounds.left)
                    x1 = pco->rclBounds.left;

                width = x2 - x1;

                }
            }

        else

            {
            //******************************************************************
            // This group of lines contains a NON straight line.
            // Just punt it back to GDI
            //******************************************************************

            //******************************************************************
            // Update global free count
            //******************************************************************

            ppdev->NVFreeCount = FreeCount;

            goto GDI_EngLineToIt;

            }

        //**********************************************************************
        // Use hardware to draw the line
        //**********************************************************************

        if (LineVisibleFlag == TRUE)
            {
            while (FreeCount < 2*4)
                FreeCount = nv->subchannel[RECTANGLE_SUBCHANNEL].control.free ;
            FreeCount -=2*4;

            nv->subchannel[RECTANGLE_SUBCHANNEL].renderSolidRectangle.Rectangle[0].y_x = ( ((y1+ppdev->yOffset)<<16) | ((x1 + ppdev->xOffset) & 0xffff) );
            nv->subchannel[RECTANGLE_SUBCHANNEL].renderSolidRectangle.Rectangle[0].height_width = ( (height << 16) | width );
            }

        //**********************************************************************
        // Update global free count
        //**********************************************************************

        ppdev->NVFreeCount = FreeCount;

        return(TRUE);
        }


    //**************************************************************************
    // Send all other lines thru GDI
    //**************************************************************************

GDI_EngLineToIt:

    //**************************************************************************
    // Check if destination bitmap is a DFB.  If so, create a temporary surfobj
    // (mapped to the screen) that GDI can write on
    //**************************************************************************
    if (pdsurf !=0 )
        {
             PuntPtr->dhsurf      = 0;                    // Behave like a standard DIB
             if (pdsurf->dt == DT_SCREEN)
                 {
                 PuntPtr->sizlBitmap  = pdsurf->sizl;

                 //*************************************************************
                 // Set linear offset and stride for source and destination buffers
                 //*************************************************************

                 PuntPtr->cjBits  = pdsurf->LinearStride * pdsurf->sizl.cy;
                 PuntPtr->pvBits  = pdsurf->LinearPtr;
                 PuntPtr->pvScan0 = pdsurf->LinearPtr;
                 PuntPtr->lDelta  = pdsurf->LinearStride;

                 PuntPtr->iBitmapFormat = ppdev->iBitmapFormat;

                 }
             else
                 {
                 //*************************************************************
                 // This is a DFB which is stored in main memory as a DIB
                 //*************************************************************
                 PuntPtr->sizlBitmap  = pdsurf->pso->sizlBitmap;
                 PuntPtr->cjBits      = pdsurf->pso->lDelta * pdsurf->pso->sizlBitmap.cy;
                 PuntPtr->pvBits  = pdsurf->pso->pvBits;
                 PuntPtr->pvScan0 = pdsurf->pso->pvScan0;
                 PuntPtr->lDelta  = pdsurf->pso->lDelta;
                 PuntPtr->iBitmapFormat = pdsurf->pso->iBitmapFormat;
                 }

        //**********************************************************************
        // Use the 'wrapper' surface, instead of the original DFB surfobj for GDI
        //**********************************************************************

        TempDstSurfObjPtr       = PuntPtr;
        }


    ppdev->pfnWaitEngineBusy(ppdev);
    return(EngLineTo(TempDstSurfObjPtr, pco, pbo, x1, y1, x2, y2, prclBounds, mix));

    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nv1ddrw.c ===
//******************************************************************************
//
// Module Name:
//
//     NV1.C
//
// Abstract:
//
//     Implements all NV1 specific routines
//
// Environment:
//
//     kernel mode only
//
// Notes:
//
// Revision History:
//
//     This driver was adapted from the S3 Display driver
//
//******************************************************************************

//******************************************************************************
//
// Copyright (c) 1996,1997  NVidia Corporation. All Rights Reserved
//
//******************************************************************************

#include "precomp.h"
#include "driver.h"
#include "nv32.h"

    #include "ddminint.h"
#ifdef NVD3D
    #include "dx95type.h"
    #include "nvntd3d.h"
    #include "ddmini.h"
#endif
#include "nv1c_ref.h"

#include "nvsubch.h"
#include "nvalpha.h"
// Temporary fix for Compile error...ask!
#define NvGetFreeCount(NN, CH)\
                 (NN)->subchannel[CH].control.Free


//******************************Public*Routine**********************************
//
// Function: NV1FifoIsBusy
//
// Routine Description:
//
//             This function has been pulled out of DDBLT so that
//             we can single step thru DDBLT.  The problem is that
//             WinDbg tries to display the values of local variables
//             when tracing through functions.  However, READING from
//             the NV User Channel (*nv) will cause the system to lock
//             and is not allowed.  So to make debugging easier, this
//             code has been separated.  We can put it back in later for
//             better performance.
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************

ULONG NV1FifoIsBusy(PDEV *ppdev)

    {
    Nv3ChannelPio           *nv;
    USHORT              FreeCount;

    nv  = (Nv3ChannelPio*) ppdev->pjMmBase;

    //**************************************************************************
    // Get current Free Count.  If the FIFO is absolutely full, and we
    // can't send another command, then return TRUE.
    //**************************************************************************

    FreeCount = NvGetFreeCount(nv, BLIT_SUBCHANNEL);

    if (FreeCount >= NV_GUARANTEED_FIFO_SIZE)
        return(TRUE);
    else
        return(FALSE);

    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nv1ptr.c ===
//******************************Module*Header***********************************
//
// Module Name: pointer.c
//
// This module contains the hardware pointer support for the display
// driver.  This supports both the built-in S3 hardware pointer and
// some common DAC hardware pointers.
//
// Copyright (c) 1992-1996 Microsoft Corporation
//
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"

#include "sgs_dac.h"


#define OFFSET_SGS_DAC_UPORT_WRITE_PAL_ADDR    0
#define OFFSET_SGS_DAC_UPORT_COLOR             1
#define OFFSET_SGS_DAC_UPORT_PIXEL_MASK        2
#define OFFSET_SGS_DAC_UPORT_READ_PAL_ADDR     3
#define OFFSET_SGS_DAC_UPORT_INDEX_LO          4
#define OFFSET_SGS_DAC_UPORT_INDEX_HI          5
#define OFFSET_SGS_DAC_UPORT_INDEX_DATA        6
#define OFFSET_SGS_DAC_UPORT_GAMEPORT          7


//******************************************************************************
//
//  Function:   NV1EnablePointer
//
//  Routine Description:
//
//      Get the hardware ready to use the Brooktree 485 hardware pointer.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NV1EnablePointer(
PDEV*               ppdev,
BOOL    bEnable
)
    {
    // Nothing to do, already initialized in miniport
    }


//******************************************************************************
//
//  Function:   NV1MovePointer
//
//  Routine Description:
//
//      Move the NV1 hardware pointer.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NV1MovePointer(
PDEV*   ppdev,
LONG    x,
LONG    y)

    {
    LONG    dx;
    LONG    dy;

    volatile ULONG *DACRegs;
    volatile ULONG *SGS_DAC_Index_Lo;
    volatile ULONG *SGS_DAC_Index_Hi;
    volatile ULONG *SGS_DAC_Index_Data;
    ULONG OutData;

    //**************************************************************************
    // Adjustment for cursor Hot spot
    //**************************************************************************

    x -= ppdev->xPointerHot;
    y -= ppdev->yPointerHot;

    //**************************************************************************
    // Get pointer to important SGS Dac cursor registers
    //**************************************************************************

    DACRegs = ppdev->DACRegs;

    SGS_DAC_Index_Lo = (volatile ULONG *)(DACRegs+OFFSET_SGS_DAC_UPORT_INDEX_LO);
    SGS_DAC_Index_Hi = (volatile ULONG *)(DACRegs+OFFSET_SGS_DAC_UPORT_INDEX_HI);
    SGS_DAC_Index_Data = (volatile ULONG *)(DACRegs+OFFSET_SGS_DAC_UPORT_INDEX_DATA);

    //**************************************************************************
    // Set cursor position X coordinate
    //**************************************************************************

    OutData=(SGS_DAC_CURSOR_POS_X_LO & 0xff);
    *SGS_DAC_Index_Lo = OutData;

    OutData=((SGS_DAC_CURSOR_POS_X_LO>>8) & 0xff);
    *SGS_DAC_Index_Hi = OutData;

    OutData=x;
    *SGS_DAC_Index_Data= OutData;
    *SGS_DAC_Index_Data= OutData>>8;

    //**************************************************************************
    // Set cursor position Y coordinate
    //**************************************************************************

    OutData=(SGS_DAC_CURSOR_POS_Y_LO & 0xff);
    *SGS_DAC_Index_Lo = OutData;

    OutData=((SGS_DAC_CURSOR_POS_Y_LO>>8) & 0xff);
    *SGS_DAC_Index_Hi = OutData;

    OutData=y;
    *SGS_DAC_Index_Data= OutData;
    *SGS_DAC_Index_Data= OutData>>8;

    return;

    }

//******************************************************************************
//
//  Function:   NV1ShowPointer
//
//  Routine Description:
//
//      Show or hide the NV1 hardware pointer.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NV1ShowPointer(
PDEV*   ppdev,
BOOL    bShow)      // If TRUE, show the pointer.  If FALSE, hide the pointer.

    {
    LONG    x;
    LONG    y;


    if (bShow)
        {
        //**********************************************************************
        // Make the hardware pointer visible:
        //**********************************************************************

        x  = ppdev->xPointer;
        y  = ppdev->yPointer;
        }

    else

        {
        //**********************************************************************
        // Move the hardware pointer off-screen so that it doesn't flash
        // in the old position when we finally turn it back on:
        //**********************************************************************

        x  = ppdev->cxScreen + 64;
        y  = ppdev->cyScreen + 64;
        }

    //*************************************************************************
    // Enable/Disable cursor by moving to new position
    //*************************************************************************

    NV1MovePointer(ppdev,x,y);
    }


//******************************************************************************
//
//  Function:   NV1SetPointerShape
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NV1SetPointerShape(
SURFOBJ*    pso,
LONG        x,              // Relative coordinates
LONG        y,              // Relative coordinates
LONG        xHot,
LONG        yHot,
BYTE*       pjShape)

    {
    PDEV*   ppdev;
    ULONG*  pulSrc;
    ULONG*  pulDst;
    LONG    i;

    volatile ULONG *DACRegs;
    volatile ULONG *SGS_DAC_Index_Lo;
    volatile ULONG *SGS_DAC_Index_Hi;
    volatile ULONG *SGS_DAC_Index_Data;
    ULONG OutData;
    BYTE*   pbImage;

    ppdev    = (PDEV*) pso->dhpdev;

    DACRegs = ppdev->DACRegs;

    SGS_DAC_Index_Lo = (volatile ULONG *)(DACRegs+OFFSET_SGS_DAC_UPORT_INDEX_LO);
    SGS_DAC_Index_Hi = (volatile ULONG *)(DACRegs+OFFSET_SGS_DAC_UPORT_INDEX_HI);
    SGS_DAC_Index_Data = (volatile ULONG *)(DACRegs+OFFSET_SGS_DAC_UPORT_INDEX_DATA);

    //**************************************************************************
    // Set SGS cursor image plane 1 (AND MASK plane)
    //**************************************************************************

    OutData=(SGS_DAC_CURSOR_PLANE_1_WRITE_0 & 0xff);
    *SGS_DAC_Index_Lo = OutData;

    OutData=((SGS_DAC_CURSOR_PLANE_1_WRITE_0>>8) & 0xff);
    *SGS_DAC_Index_Hi = OutData;

    pbImage = pjShape;
    for (i=0;i<128;i++)
        *SGS_DAC_Index_Data= *pbImage++;

    //**************************************************************************
    // Set SGS cursor image plane 0 (XOR MASK plane)
    //**************************************************************************

    OutData=(SGS_DAC_CURSOR_PLANE_0_WRITE_0 & 0xff);
    *SGS_DAC_Index_Lo = OutData;

    OutData=((SGS_DAC_CURSOR_PLANE_0_WRITE_0>>8) & 0xff);
    *SGS_DAC_Index_Hi = OutData;

    for (i=0;i<128;i++)
        *SGS_DAC_Index_Data= *pbImage++;

    //**************************************************************************
    // 1. Hide the current pointer.
    //**************************************************************************

    //**************************************************************************
    // 2. Wait until the vertical retrace is done.
    // --
    //
    // If we don't wait for vertical retrace here, the S3 sometimes ignores
    // the setting of the new pointer position:
    //**************************************************************************

    //**************************************************************************
    // 3. Set the new pointer position.
    // --
    //**************************************************************************

    //**************************************************************************
    // 4. Download the new pointer shape.
    //**************************************************************************

    ppdev->xPointerHot = xHot;
    ppdev->yPointerHot = yHot;

    NV1MovePointer(ppdev, x, y);


    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nv3enabl.c ===
/************************** Module Header *************************************
//                                                                             *
//  Module Name: nv3enabl.c                                                    *
//                                                                             *
//  This module contains the functions that enable and disable the             *
//  driver, the pdev, and the surface.                                         *
//                                                                             *
//  Copyright (c) 1992-1996 Microsoft Corporation                              *
//                                                                             *
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"

#ifdef NV3
#include "excpt.h"
#include "oldnv332.h"
#define NV32_INCLUDED // Prevents re-inclusion of real nv32 header
#include "driver.h"
#include "nv1c_ref.h"
#include "nvalpha.h"
#include "nvsubch.h"

#include "nvos.h"
#include "nvntioctl.h"
#include "nvntddctl.h"
#include "nvapi.h"

#include "ddminint.h"
#include "dmamacro.h"
#include "nvcm.h"

//******************************************************************************
// Local prototypes
//******************************************************************************

BOOL bNV3CreateStdPatches(PDEV *ppdev);
VOID vNV3DestroyStdPatches(PDEV *ppdev, BOOL CreateStdPatchFailFlag);


//******************************************************************************
//
//  Function: bNV3CreateStdPatches
//
//  Routine Description:
//      Program the following patch:
//
//
//              ROP 5 SOLID   PATTERN     BLACK RECTANGLE     IMAGE SOLID
//                  |           |           |                   |
//                  \--|  |-----/           |                   |
//                     |  |                 |                   |
//                     V  V                 V                   V
//                   -----------       -------------       ----------
//      IMAGE       |           |     |             |     |          |
//      FROM   ---->|   IMAGE   |---->|    IMAGE    |---->|  IMAGE   |----\       (patch for subchannel 0)
//      CPU         |  ROP AND  |     |   STENCIL   |     | COLORKEY |    |
//                  |           |     |             |     |          |    |
//                   -----------       -------------       ----------     |
//                     |  |  ^              |                   |         |
//                     V  V  |              V                   V         |
//                   -----------       -------------       ----------     |
//                  |           |     |             |     |          |    |
//      IMAGE  ---->|   IMAGE   |---->|    IMAGE    |---->|  IMAGE   |--\ |       (patch for subchannel 1)
//      BLIT        |  ROP AND  |     |   STENCIL   |     | COLORKEY |  | |
//       ^          |           |     |             |     |          |  | |
//       |           -----------       -------------       ----------   | \-->
//   /---/             |  |  ^              |                   |       \---->IMAGE TO----> VIDEO
//   |                 V  V  |              V                   V       /----> VIDEO        SINK
//   |               -----------       -------------       ----------   | /--> |
//   |              |           |     |             |     |          |  | |    |
//   |  IMAGE  ---->|   IMAGE   |---->|    IMAGE    |---->|  IMAGE   |--/ |    |  (patch for subchannel 2)
//   |  MONO        |  ROP AND  |     |   STENCIL   |     | COLORKEY |    |    |
//   |              |           |     |             |     |          |    |    |
//   |               -----------       -------------       ----------     |    |
//   |                 |  |  ^              |                   |         |    |
//   |                 V  V  |              V                   V         |    |
//   |               -----------       -------------       ----------     |    |
//   |  RENDER      |           |     |             |     |          |    |    |
//   |  SOLID  ---->|   IMAGE   |---->|    IMAGE    |---->|  IMAGE   |----/    |  (patch for subchannel 3)
//   |  RECTANGLE   |  ROP AND  |     |   STENCIL   |     | COLORKEY |         |
//   |              |           |     |             |     |          |         |
//   |               -----------       -------------       ----------          |
//   |                       ^                                                 |
//   |                       |                                                 |
//   |                       |                                                 |
//   \-------------------------------------------------------------------------/
//
//
//  Arguments:
//      A pointer to the physical device
//
//  Return Value:
//      TRUE if successful
//      FALSE if unseccessful
//
//
//******************************************************************************

BOOL bNV3CreateStdPatches(
    PDEV *ppdev
)
{
    V032 colorFmtUnpack, colorFmtAlpha, colorFmtPack, videoFmt;
    ULONG color0, color1;
    Nv3ChannelPio *nv;
    U032 class;
    NV_CREATE_OBJECT_SETUP();

    if(!NvGetSupportedClasses(ppdev)){
        return FALSE;
    }


    //**************************************************************************
    // Get a channel from the NV device
    //**************************************************************************

    ppdev->hPioChannel = DD_PIO_CHANNEL_OBJECT_HANDLE;
    if (NvAllocChannelPio(  ppdev->hDriver,
                            ppdev->hClient,
                            ppdev->hDevice,
                            ppdev->hPioChannel,
                            NV03_CHANNEL_PIO,
                            0,
                            (PVOID)&nv,
                            0
                            ) != NVOS04_STATUS_SUCCESS)
        {
        DISPDBG((1, "NVDD: Cannot get NV PIO channel"));
        goto bNV3CreateStdPatches_ReturnFalse;
        }

    //**************************************************************************
    // Save channel ptr in state struct.
    //**************************************************************************
    ppdev->pjMmBase = (ULONG *)nv;

    //**************************************************************************
    // For NV3, ddraw and 2d driver use the same channel.
    //**************************************************************************
    (Nv3ChannelPio*) ppdev->ddChannelPtr = (Nv3ChannelPio *) ppdev->pjMmBase;

    //**************************************************************************
    // Invalidate cached freecount in case this routine exits with an error
    //**************************************************************************
    ppdev->NVFreeCount = 0;

    DISPDBG((1, "DD setting up standard patches..."));

    // determine default packed and unpacked color formats from frame buffer depth
    switch (ppdev->iBitmapFormat)
    {
        case BMF_32BPP:
            colorFmtUnpack = NV_COLOR_FORMAT_LE_X8R8G8B8;
            colorFmtAlpha = NV_COLOR_FORMAT_LE_A8R8G8B8;
            colorFmtPack = colorFmtUnpack;
            videoFmt = NV_VFM_FORMAT_COLOR_LE_X8R8G8B8;
            color0 =    NV_ALPHA_1_32 | 0x00000000;         // BLACK
            color1 =    NV_ALPHA_1_32 | 0x00ffffff;         // WHITE
            break;
        case BMF_16BPP:
            colorFmtUnpack = NV_COLOR_FORMAT_LE_X17R5G5B5;
            colorFmtAlpha = NV_COLOR_FORMAT_LE_X16A1R5G5B5;
            colorFmtPack = NV_COLOR_FORMAT_LE_X1R5G5B5_P2;
            videoFmt = NV_VFM_FORMAT_COLOR_LE_X1R5G5B5_P2;
            color0 =    NV_ALPHA_1_16 | 0x00000000;         // BLACK
            color1 =    NV_ALPHA_1_16 | 0x00007fff;         // WHITE
            break;
        case BMF_8BPP:
            colorFmtUnpack = NV_COLOR_FORMAT_LE_X24Y8;
            colorFmtAlpha = NV_COLOR_FORMAT_LE_X16A8Y8;
            colorFmtPack = NV_COLOR_FORMAT_LE_Y8_P4;
            videoFmt = NV_VFM_FORMAT_COLOR_LE_Y8_P4;
            color0 =    NV_ALPHA_1_08 | 0x00000000;         // BLACK
            color1 =    NV_ALPHA_1_08 | 0x000000ff;         // WHITE
            break;

        default:
            return(FALSE);
    }

    //**************************************************************************
    // Allocate a DMA context which points to all of video memory. The limit
    // must be page aligned: i.e. limit = (size in bytes of video mem rounded to the
    // closest page boundary) - 1.
    //**************************************************************************
    if (NvAllocContextDma(  ppdev->hDriver,
                            ppdev->hClient,
                            DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM,
                            NV01_CONTEXT_DMA,
                            NVOS03_FLAGS_ACCESS_READ_WRITE,
                            (PVOID)(ppdev->pjFrameBufbase),
                            ppdev->cbFrameBuf
                            ) != NVOS03_STATUS_SUCCESS )
        {
        DISPDBG((1, "NVDD: Cannot allocate dma in memory context"));
        goto bNV3CreateStdPatches_ReturnFalse;
        }

    //**************************************************************************
    // Allocate a DMA context to "sync" the fifo on ddraw lock calls.
    //**************************************************************************
    ((NvNotification *) ppdev->Notifiers->Sync)->status = 0;
    if (NvAllocContextDma(  ppdev->hDriver,
                            ppdev->hClient,
                            DD_FIFO_SYNC_NOTIFIER,
                            NV01_CONTEXT_DMA,
                            NVOS03_FLAGS_ACCESS_WRITE_ONLY,
                            (PVOID)(ppdev->Notifiers->Sync),
                            sizeof(NvNotification) - 1
                            ) != NVOS03_STATUS_SUCCESS)
        {
        DISPDBG((1, "NVDD: Cannot allocate fifo sync notifer"));
        goto bNV3CreateStdPatches_ReturnFalse;
        }
    //*************************************************************************
    // allocate the dma notifier context for flip surface
    //*************************************************************************
    if (NvAllocContextDma(  ppdev->hDriver,
                            ppdev->hClient,
                            NV_DD_FLIP_PRIMARY_NOTIFIER_CONTEXT_DMA_TO_MEMORY,
                            NV01_CONTEXT_DMA,
                            NVOS03_FLAGS_ACCESS_WRITE_ONLY,
                            (PVOID)(ppdev->Notifiers->FlipPrimary),
                            sizeof(NvNotification) - 1
                            ) != NVOS03_STATUS_SUCCESS)
        {
        DISPDBG((1, "NVDD: Cannot allocate context dma notifier for flip surface"));
        goto bNV3CreateStdPatches_ReturnFalse;
        }

    ((NvNotification *) (ppdev->Notifiers->FlipPrimary))->status = 0;

    //*************************************************************************
    // allocate the dma notifier context for video overlay flip
    //*************************************************************************
    if (NvAllocContextDma(  ppdev->hDriver,
                            ppdev->hClient,
                            NV_DD_FLIP_OVERLAY_NOTIFIER_CONTEXT_DMA_TO_MEMORY,
                            NV01_CONTEXT_DMA,
                            NVOS03_FLAGS_ACCESS_WRITE_ONLY,
                            (PVOID)(ppdev->Notifiers->FlipOverlay),
                            sizeof(NvNotification) - 1
                            ) != NVOS03_STATUS_SUCCESS)
        {
        DISPDBG((1, "NVDD: Cannot allocate notifier context"));
        goto bNV3CreateStdPatches_ReturnFalse;
        }

    ((NvNotification *) (ppdev->Notifiers->FlipOverlay))->status = 0;
    //*************************************************************************
    // Setup palette for indexed color mode.
    // allocate the colormap context (from system memory)
    //*************************************************************************
    if (NvAllocContextDma(  ppdev->hDriver,
                            ppdev->hClient,
                            NV_WIN_COLORMAP_CONTEXT,
                            NV01_CONTEXT_DMA,
                            NVOS03_FLAGS_ACCESS_READ_ONLY,
                            (PVOID)(ppdev->ajClutData),
                            (256 * sizeof(VIDEO_CLUTDATA)) - 1
                            ) != NVOS03_STATUS_SUCCESS)
        {
        DISPDBG((1, "NVDD: Cannot allocate buffer context"));
        goto bNV3CreateStdPatches_ReturnFalse;
        }

    //*************************************************************************
    // allocate the dma notifier context (from system memory)
    //*************************************************************************
    ((NvNotification *) (ppdev->Notifiers->DmaFromMem))->status = 0;

    if (NvAllocContextDma(  ppdev->hDriver,
                            ppdev->hClient,
                            NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY,
                            NV01_CONTEXT_DMA,
                            NVOS03_FLAGS_ACCESS_WRITE_ONLY,
                            (PVOID) ppdev->Notifiers->DmaFromMem,
                            sizeof(NvNotification) - 1
                            ) != NVOS03_STATUS_SUCCESS)
        {
        DISPDBG((1, "NVDD: Cannot allocate notifier context"));
        goto bNV3CreateStdPatches_ReturnFalse;
        }

    //***********************************************************************************
    // Allocate a buffer for scanlines.
    //***********************************************************************************
    if ((ppdev->NvDmaBufferFlat = EngAllocMem(0, 0x8000, ALLOC_TAG)) != NULL)
        {
        ppdev->NvScanlineBufferFlat = ppdev->NvDmaBufferFlat;
        if (NvAllocContextDma(  ppdev->hDriver,
                                ppdev->hClient,
                                NV_DD_CONTEXT_DMA_FROM_SYSTEM_MEMORY,
                                NV01_CONTEXT_DMA,
                                NVOS03_FLAGS_ACCESS_READ_WRITE,
                                (PVOID) ppdev->NvDmaBufferFlat,
                                0x8000 - 1
                                ) != NVOS03_STATUS_SUCCESS)

        goto bNV3CreateStdPatches_ReturnFalse;
        }

    //************************************************************************
    // Allocate Notifier contexts.
    //************************************************************************
    ((NvNotification *) ppdev->Notifiers->DmaToMem)->status = 0;

    if (NvAllocContextDma(  ppdev->hDriver,
                            ppdev->hClient,
                            NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY,
                            NV01_CONTEXT_DMA,
                            NVOS03_FLAGS_ACCESS_WRITE_ONLY,
                            (PVOID)(ppdev->Notifiers->DmaToMem),
                            sizeof(NvNotification) - 1
                            ) != NVOS03_STATUS_SUCCESS)
        {
        DISPDBG((1, "NVDD: Cannot allocate notifier context"));
        goto bNV3CreateStdPatches_ReturnFalse;
        }

    NV_CREATE_OBJECT_INIT();

    NV_CREATE_OBJECT_PIO1(NV_VIDEO_COLORMAP, DD_COLORMAP);

    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_VIDEO, DD_PATCHCORD_COLORMAP);

    // create ROP ANDs
    NV_CREATE_OBJECT_PIO1(NV_IMAGE_ROP_AND, DD_IMAGE_ROP_AND0);
    NV_CREATE_OBJECT_PIO1(NV_IMAGE_ROP_AND, DD_IMAGE_ROP_AND1);
    NV_CREATE_OBJECT_PIO1(NV_IMAGE_ROP_AND, DD_IMAGE_ROP_AND2);
    NV_CREATE_OBJECT_PIO1(NV_IMAGE_ROP_AND, DD_IMAGE_ROP_AND3);
    NV_CREATE_OBJECT_PIO1(NV_IMAGE_ROP_AND, DD_IMAGE_ROP_AND4);
    NV_CREATE_OBJECT_PIO1(NV_IMAGE_ROP_AND, DD_IMAGE_ROP_AND5);
    NV_CREATE_OBJECT_PIO1(NV_IMAGE_ROP_AND, DD_IMAGE_ROP_AND6);

    // create Image Stencils
    NV_CREATE_OBJECT_PIO1(NV_IMAGE_STENCIL, DD_IMAGE_STENCIL0);
    NV_CREATE_OBJECT_PIO1(NV_IMAGE_STENCIL, DD_IMAGE_STENCIL1);
    NV_CREATE_OBJECT_PIO1(NV_IMAGE_STENCIL, DD_IMAGE_STENCIL2);
    NV_CREATE_OBJECT_PIO1(NV_IMAGE_STENCIL, DD_IMAGE_STENCIL3);
    NV_CREATE_OBJECT_PIO1(NV_IMAGE_STENCIL, DD_IMAGE_STENCIL4);
    NV_CREATE_OBJECT_PIO1(NV_IMAGE_STENCIL, DD_IMAGE_STENCIL5);
    NV_CREATE_OBJECT_PIO1(NV_IMAGE_STENCIL, DD_IMAGE_STENCIL6);

    // create Image Color Keys
    NV_CREATE_OBJECT_PIO1(NV_IMAGE_COLOR_KEY, DD_IMAGE_COLOR_KEY0);
    NV_CREATE_OBJECT_PIO1(NV_IMAGE_COLOR_KEY, DD_IMAGE_COLOR_KEY1);
    NV_CREATE_OBJECT_PIO1(NV_IMAGE_COLOR_KEY, DD_IMAGE_COLOR_KEY2);
    NV_CREATE_OBJECT_PIO1(NV_IMAGE_COLOR_KEY, DD_IMAGE_COLOR_KEY3);
    NV_CREATE_OBJECT_PIO1(NV_IMAGE_COLOR_KEY, DD_IMAGE_COLOR_KEY4);
    NV_CREATE_OBJECT_PIO1(NV_IMAGE_COLOR_KEY, DD_IMAGE_COLOR_KEY5);
    NV_CREATE_OBJECT_PIO1(NV_IMAGE_COLOR_KEY, DD_IMAGE_COLOR_KEY6);
    if (NV_CREATE_OBJECT_FAIL())
        return FALSE;


    NV_CREATE_OBJECT_INIT();
    // create Video Color Keys
    NV_CREATE_OBJECT_PIO1(NV_VIDEO_COLOR_KEY, NV_DD_VIDEO_COLOR_KEY);

    // create Image In Memory
    NV_CREATE_OBJECT_PIO1(NV_IMAGE_IN_MEMORY, DD_PRIMARY_IMAGE_IN_MEMORY);
    NV_CREATE_OBJECT_PIO1(NV_IMAGE_IN_MEMORY, DD_SRC_IMAGE_IN_MEMORY);

    // create Video from Memory
    NV_CREATE_OBJECT_PIO1(NV_VIDEO_FROM_MEMORY, DD_PRIMARY_VIDEO_FROM_MEMORY);
    NV_CREATE_OBJECT_PIO1(NV_VIDEO_FROM_MEMORY, NV_DD_YUV422_VIDEO_FROM_MEMORY);

    // create Video Sink
    NV_CREATE_OBJECT_PIO1(NV_VIDEO_SINK, DD_VIDEO_SINK);
    if (NV_CREATE_OBJECT_FAIL())
        return FALSE;

    NV_CREATE_OBJECT_INIT();
    // create Image Patchcords
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, DD_PATCHCORD_IMAGE_FROM_CPU);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, DD_PATCHCORD_IMAGE_BLIT);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, DD_PATCHCORD_IMAGE_RECT_AND_TEXT);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, DD_PATCHCORD_IMAGE_SOLID_RECT);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, DD_PATCHCORD_IMAGE_PATTERN);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, DD_PATCHCORD_IMAGE_BLACK_RECT);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, DD_PATCHCORD_IMAGE_SOLID);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, DD_PATCHCORD_IMAGE_ROP_AND0);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, DD_PATCHCORD_IMAGE_ROP_AND1);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, DD_PATCHCORD_IMAGE_ROP_AND2);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, DD_PATCHCORD_IMAGE_ROP_AND3);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, DD_PATCHCORD_IMAGE_ROP_AND4);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, DD_PATCHCORD_IMAGE_ROP_AND5);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, DD_PATCHCORD_IMAGE_ROP_AND6);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, DD_PATCHCORD_IMAGE_STENCIL0);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, DD_PATCHCORD_IMAGE_STENCIL1);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, DD_PATCHCORD_IMAGE_STENCIL2);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, DD_PATCHCORD_IMAGE_STENCIL3);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, DD_PATCHCORD_IMAGE_STENCIL4);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, DD_PATCHCORD_IMAGE_STENCIL5);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, DD_PATCHCORD_IMAGE_STENCIL6);
    if (NV_CREATE_OBJECT_FAIL())
        return FALSE;

    NV_CREATE_OBJECT_INIT();
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, DD_PATCHCORD_IMAGE0);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, DD_PATCHCORD_IMAGE1);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, DD_PATCHCORD_IMAGE2);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, DD_PATCHCORD_IMAGE3);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, DD_PATCHCORD_IMAGE4);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, DD_PATCHCORD_IMAGE5);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, DD_PATCHCORD_IMAGE6);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, DD_PATCHCORD_IMAGE_FEEDBACK);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, DD_PATCHCORD_SRC_FEEDBACK);

    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, NV_DD_P_I_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, NV_DD_P_I_STRETCHED_IMAGE_FROM_CPU);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, NV_DD_P_I_STRETCHED_UV_IMAGE_FROM_CPU);
    if (NV_CREATE_OBJECT_FAIL())
        return FALSE;

    NV_CREATE_OBJECT_INIT();
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, NV_DD_P_I_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, NV_DD_P_I_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, NV_DD_P_I_SCALED_UYVY_IMAGE_FROM_VIDEO_MEMORY);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, NV_DD_P_I_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, NV_DD_P_I_SCALED_YUYV_IMAGE_FROM_VIDEO_MEMORY);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, NV_DD_P_I_FLOATING0_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, NV_DD_P_I_FLOATING1_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, NV_DD_P_I_FLOATING0_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, NV_DD_P_I_FLOATING1_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, NV_DD_P_I_FLOATING0_SCALED_Y420_IMAGE_FROM_SYSTEM_MEMORY);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_IMAGE, NV_DD_P_I_FLOATING1_SCALED_Y420_IMAGE_FROM_SYSTEM_MEMORY);

    NV_CREATE_OBJECT_PIO1(NV_SCALED_YUV420_FROM_MEMORY, NV_DD_FLOATING0_SCALED_Y420_IMAGE_FROM_SYSTEM_MEMORY);
    NV_CREATE_OBJECT_PIO1(NV_SCALED_YUV420_FROM_MEMORY, NV_DD_FLOATING1_SCALED_Y420_IMAGE_FROM_SYSTEM_MEMORY);


    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_VIDEO, DD_PATCHCORD_VIDEO);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_VIDEO, NV_DD_P_V_VIDEO_COLOR_KEY);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_VIDEO, NV_DD_P_V_YUV422_VIDEO_FROM_MEMORY);
    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_VIDEO, NV_DD_P_V_VIDEO_SCALER);

    NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_ROP, DD_PATCHCORD_ROP5_SOLID);
    if (NV_CREATE_OBJECT_FAIL())
        return FALSE;

    NV_CREATE_OBJECT_INIT();
    // create video scaler
    NV_CREATE_OBJECT_PIO1(NV_VIDEO_SCALER, NV_DD_VIDEO_SCALER);
    NV_CREATE_OBJECT_PIO1(NV_IMAGE_FROM_CPU, DD_IMAGE_FROM_CPU);
    NV_CREATE_OBJECT_PIO1(NV_IMAGE_BLIT, DD_IMAGE_BLIT);
    NV_CREATE_OBJECT_PIO1(NV_RENDER_GDI0_RECTANGLE_AND_TEXT, DD_RENDER_RECT_AND_TEXT);
    NV_CREATE_OBJECT_PIO1(NV_RENDER_SOLID_RECTANGLE, DD_RENDER_SOLID_RECTANGLE);
    NV_CREATE_OBJECT_PIO1(NV_ROP5_SOLID, DD_ROP5_SOLID);
    NV_CREATE_OBJECT_PIO1(NV_IMAGE_PATTERN, DD_IMAGE_PATTERN);
    NV_CREATE_OBJECT_PIO1(NV_IMAGE_BLACK_RECTANGLE, DD_IMAGE_BLACK_RECTANGLE);
    NV_CREATE_OBJECT_PIO1(NV_IMAGE_SOLID, DD_IMAGE_SOLID);
    NV_CREATE_OBJECT_PIO1(NV_MEMORY_TO_MEMORY_FORMAT, NV_DD_VIDEO_MEM_TO_SYSTEM_MEM_FORMAT);
    NV_CREATE_OBJECT_PIO1(NV_MEMORY_TO_MEMORY_FORMAT, NV_DD_VIDEO_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT);
    NV_CREATE_OBJECT_PIO1(NV_STRETCHED_IMAGE_FROM_CPU, NV_DD_STRETCHED_UV_IMAGE_FROM_CPU);
    NV_CREATE_OBJECT_PIO1(NV_STRETCHED_IMAGE_FROM_CPU, NV_DD_STRETCHED_IMAGE_FROM_CPU);
    if (ppdev->cBitsPerPel > 8)
        {
        NV_CREATE_OBJECT_PIO1(NV_SCALED_IMAGE_FROM_MEMORY, NV_DD_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY);
        NV_CREATE_OBJECT_PIO1(NV_SCALED_IMAGE_FROM_MEMORY, NV_DD_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY);
        NV_CREATE_OBJECT_PIO1(NV_SCALED_IMAGE_FROM_MEMORY, NV_DD_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY);
        NV_CREATE_OBJECT_PIO1(NV_SCALED_IMAGE_FROM_MEMORY, NV_DD_SCALED_UYVY_IMAGE_FROM_VIDEO_MEMORY);
        NV_CREATE_OBJECT_PIO1(NV_SCALED_IMAGE_FROM_MEMORY, NV_DD_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY);
        NV_CREATE_OBJECT_PIO1(NV_SCALED_IMAGE_FROM_MEMORY, NV_DD_SCALED_YUYV_IMAGE_FROM_VIDEO_MEMORY);
        NV_CREATE_OBJECT_PIO1(NV_SCALED_IMAGE_FROM_MEMORY, NV_DD_FLOATING0_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY);
        NV_CREATE_OBJECT_PIO1(NV_SCALED_IMAGE_FROM_MEMORY, NV_DD_FLOATING1_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY);
        NV_CREATE_OBJECT_PIO1(NV_SCALED_IMAGE_FROM_MEMORY, NV_DD_FLOATING0_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY);
        NV_CREATE_OBJECT_PIO1(NV_SCALED_IMAGE_FROM_MEMORY, NV_DD_FLOATING1_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY);
        }
    if (NV_CREATE_OBJECT_FAIL())
        return FALSE;

    // setup patch 0
    while (NvGetFreeCount(nv, 0) < 14*4);
    nv->subchannel[BLIT_SUBCHANNEL].SetObject = DD_IMAGE_ROP_AND0;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetImageInput[0] =
        DD_PATCHCORD_IMAGE_FEEDBACK;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetImageInput[1] =
        DD_PATCHCORD_IMAGE_FROM_CPU;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetImageInput[2] =
        DD_PATCHCORD_IMAGE_PATTERN;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetRopInput = DD_PATCHCORD_ROP5_SOLID;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetImageOutput
        = DD_PATCHCORD_IMAGE_ROP_AND0;
    nv->subchannel[BLIT_SUBCHANNEL].SetObject = DD_IMAGE_STENCIL0;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageStencil.SetImageInput[0] =
        DD_PATCHCORD_IMAGE_ROP_AND0;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageStencil.SetImageInput[1] =
        DD_PATCHCORD_IMAGE_BLACK_RECT;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageStencil.SetImageOutput =
        DD_PATCHCORD_IMAGE_STENCIL0;
    nv->subchannel[BLIT_SUBCHANNEL].SetObject =
        DD_IMAGE_COLOR_KEY0;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageColorKey.SetImageInput[0] =
        DD_PATCHCORD_IMAGE_SOLID;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageColorKey.SetImageInput[1] =
        DD_PATCHCORD_IMAGE_STENCIL0;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageColorKey.SetImageOutput =
        DD_PATCHCORD_IMAGE0;

    // setup patch 1
    while (NvGetFreeCount(nv, 0) < 14*4);

    nv->subchannel[BLIT_SUBCHANNEL].SetObject =
        DD_IMAGE_ROP_AND1;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetImageInput[0] =
        DD_PATCHCORD_IMAGE_FEEDBACK;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetImageInput[1] =
        DD_PATCHCORD_IMAGE_BLIT;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetImageInput[2] =
        DD_PATCHCORD_IMAGE_PATTERN;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetRopInput =
        DD_PATCHCORD_ROP5_SOLID;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetImageOutput =
        DD_PATCHCORD_IMAGE_ROP_AND1;
    nv->subchannel[BLIT_SUBCHANNEL].SetObject =
        DD_IMAGE_STENCIL1;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageStencil.SetImageInput[0] =
        DD_PATCHCORD_IMAGE_ROP_AND1;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageStencil.SetImageInput[1] =
        DD_PATCHCORD_IMAGE_BLACK_RECT;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageStencil.SetImageOutput =
        DD_PATCHCORD_IMAGE_STENCIL1;
    nv->subchannel[BLIT_SUBCHANNEL].SetObject =
        DD_IMAGE_COLOR_KEY1;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageColorKey.SetImageInput[0] =
        DD_PATCHCORD_IMAGE_SOLID;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageColorKey.SetImageInput[1] =
        DD_PATCHCORD_IMAGE_STENCIL1;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageColorKey.SetImageOutput =
        DD_PATCHCORD_IMAGE1;

    // setup patch 2
    while (NvGetFreeCount(nv, 0) < 14*4);

    nv->subchannel[BLIT_SUBCHANNEL].SetObject =
        DD_IMAGE_ROP_AND2;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetImageInput[0] =
        DD_PATCHCORD_IMAGE_FEEDBACK;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetImageInput[1] =
            DD_PATCHCORD_IMAGE_RECT_AND_TEXT;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetImageInput[2] =
        DD_PATCHCORD_IMAGE_PATTERN;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetRopInput =
        DD_PATCHCORD_ROP5_SOLID;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetImageOutput =
        DD_PATCHCORD_IMAGE_ROP_AND2;
    nv->subchannel[BLIT_SUBCHANNEL].SetObject = DD_IMAGE_STENCIL2;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageStencil.SetImageInput[0] =
        DD_PATCHCORD_IMAGE_ROP_AND2;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageStencil.SetImageInput[1] =
        DD_PATCHCORD_IMAGE_BLACK_RECT;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageStencil.SetImageOutput =
        DD_PATCHCORD_IMAGE_STENCIL2;
    nv->subchannel[BLIT_SUBCHANNEL].SetObject = DD_IMAGE_COLOR_KEY2;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageColorKey.SetImageInput[0] =
        DD_PATCHCORD_IMAGE_SOLID;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageColorKey.SetImageInput[1] =
        DD_PATCHCORD_IMAGE_STENCIL2;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageColorKey.SetImageOutput =
        DD_PATCHCORD_IMAGE2;

    // setup patch 3
    while (NvGetFreeCount(nv, 0) < 14*4);

    nv->subchannel[BLIT_SUBCHANNEL].SetObject = DD_IMAGE_ROP_AND3;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetImageInput[0] =
        DD_PATCHCORD_IMAGE_FEEDBACK;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetImageInput[1] =
        DD_PATCHCORD_IMAGE_SOLID_RECT;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetImageInput[2] =
        DD_PATCHCORD_IMAGE_PATTERN;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetRopInput =
        DD_PATCHCORD_ROP5_SOLID;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetImageOutput =
        DD_PATCHCORD_IMAGE_ROP_AND3;
    nv->subchannel[BLIT_SUBCHANNEL].SetObject = DD_IMAGE_STENCIL3;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageStencil.SetImageInput[0] =
        DD_PATCHCORD_IMAGE_ROP_AND3;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageStencil.SetImageInput[1] =
        DD_PATCHCORD_IMAGE_BLACK_RECT;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageStencil.SetImageOutput =
        DD_PATCHCORD_IMAGE_STENCIL3;
    nv->subchannel[BLIT_SUBCHANNEL].SetObject = DD_IMAGE_COLOR_KEY3;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageColorKey.SetImageInput[0] =
        DD_PATCHCORD_IMAGE_SOLID;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageColorKey.SetImageInput[1] =
        DD_PATCHCORD_IMAGE_STENCIL3;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageColorKey.SetImageOutput =
        DD_PATCHCORD_IMAGE3;

    // setup patch 4
    while (NvGetFreeCount(nv, 0) < 14*4);

    nv->subchannel[BLIT_SUBCHANNEL].SetObject = DD_IMAGE_ROP_AND4;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetImageInput[0] =
        DD_PATCHCORD_IMAGE_FEEDBACK;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetImageInput[1] =
        NV_DD_P_I_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetImageInput[2] =
        DD_PATCHCORD_IMAGE_PATTERN;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetRopInput =
        DD_PATCHCORD_ROP5_SOLID;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetImageOutput =
        DD_PATCHCORD_IMAGE_ROP_AND4;
    nv->subchannel[BLIT_SUBCHANNEL].SetObject = DD_IMAGE_STENCIL4;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageStencil.SetImageInput[0] =
        DD_PATCHCORD_IMAGE_ROP_AND4;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageStencil.SetImageInput[1] =
        DD_PATCHCORD_IMAGE_BLACK_RECT;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageStencil.SetImageOutput =
        DD_PATCHCORD_IMAGE_STENCIL4;
    nv->subchannel[BLIT_SUBCHANNEL].SetObject = DD_IMAGE_COLOR_KEY4;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageColorKey.SetImageInput[0] =
        DD_PATCHCORD_IMAGE_SOLID;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageColorKey.SetImageInput[1] =
        DD_PATCHCORD_IMAGE_STENCIL4;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageColorKey.SetImageOutput =
        DD_PATCHCORD_IMAGE4;

    // setup patch 5
    while (NvGetFreeCount(nv, 0) < 14*4);
    nv->subchannel[BLIT_SUBCHANNEL].SetObject = DD_IMAGE_ROP_AND5;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetImageInput[0] =
        DD_PATCHCORD_IMAGE_FEEDBACK;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetImageInput[1] =
        NV_DD_P_I_STRETCHED_IMAGE_FROM_CPU;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetImageInput[2] =
        DD_PATCHCORD_IMAGE_PATTERN;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetRopInput = DD_PATCHCORD_ROP5_SOLID;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetImageOutput
        = DD_PATCHCORD_IMAGE_ROP_AND5;
    nv->subchannel[BLIT_SUBCHANNEL].SetObject = DD_IMAGE_STENCIL5;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageStencil.SetImageInput[0] =
        DD_PATCHCORD_IMAGE_ROP_AND5;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageStencil.SetImageInput[1] =
        DD_PATCHCORD_IMAGE_BLACK_RECT;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageStencil.SetImageOutput =
        DD_PATCHCORD_IMAGE_STENCIL5;
    nv->subchannel[BLIT_SUBCHANNEL].SetObject =
        DD_IMAGE_COLOR_KEY5;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageColorKey.SetImageInput[0] =
        DD_PATCHCORD_IMAGE_SOLID;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageColorKey.SetImageInput[1] =
        DD_PATCHCORD_IMAGE_STENCIL5;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageColorKey.SetImageOutput =
        DD_PATCHCORD_IMAGE5;

    // setup patch 6
    while (NvGetFreeCount(nv, 0) < 14*4);
    nv->subchannel[BLIT_SUBCHANNEL].SetObject = DD_IMAGE_ROP_AND6;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetImageInput[0] =
        DD_PATCHCORD_IMAGE_FEEDBACK;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetImageInput[1] =
        NV_DD_P_I_STRETCHED_UV_IMAGE_FROM_CPU;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetImageInput[2] =
        DD_PATCHCORD_IMAGE_PATTERN;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetRopInput = DD_PATCHCORD_ROP5_SOLID;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageRopAnd.SetImageOutput
        = DD_PATCHCORD_IMAGE_ROP_AND6;

    // setup patch back end
    while (NvGetFreeCount(nv, 0) < 25*4);

    nv->subchannel[BLIT_SUBCHANNEL].SetObject = DD_PRIMARY_IMAGE_IN_MEMORY;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageInMemory.SetImageInput[0] =
        DD_PATCHCORD_IMAGE0;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageInMemory.SetImageInput[1] =
        DD_PATCHCORD_IMAGE1;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageInMemory.SetImageInput[2] =
        DD_PATCHCORD_IMAGE2;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageInMemory.SetImageInput[3] =
        DD_PATCHCORD_IMAGE3;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageInMemory.SetImageInput[4] =
        DD_PATCHCORD_IMAGE4;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageInMemory.SetImageInput[5] =
        DD_PATCHCORD_IMAGE5;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageInMemory.SetImageInput[6] =
        DD_PATCHCORD_IMAGE6;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageInMemory.SetImageInput[7] =
        NV_DD_P_I_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageInMemory.SetImageInput[8] =
        NV_DD_P_I_SCALED_UYVY_IMAGE_FROM_VIDEO_MEMORY;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageInMemory.SetImageInput[9] =
        NV_DD_P_I_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageInMemory.SetImageInput[10] =
        NV_DD_P_I_SCALED_YUYV_IMAGE_FROM_VIDEO_MEMORY;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageInMemory.SetImageInput[11] =
        NV_DD_P_I_FLOATING0_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageInMemory.SetImageInput[12] =
        NV_DD_P_I_FLOATING1_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageInMemory.SetImageInput[13] =
        NV_DD_P_I_FLOATING0_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageInMemory.SetImageInput[14] =
        NV_DD_P_I_FLOATING1_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageInMemory.SetImageInput[15] =
        NV_DD_P_I_FLOATING0_SCALED_Y420_IMAGE_FROM_SYSTEM_MEMORY;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageInMemory.SetImageInput[16] =
        NV_DD_P_I_FLOATING1_SCALED_Y420_IMAGE_FROM_SYSTEM_MEMORY;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageInMemory.SetImageInput[17] =
        NV_DD_P_I_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageInMemory.SetImageInput[18] =
        DD_PATCHCORD_IMAGE_ROP_AND6;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageInMemory.SetImageOutput =
        DD_PATCHCORD_IMAGE_FEEDBACK;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageInMemory.SetColorFormat =
            colorFmtPack;

    nv->subchannel[BLIT_SUBCHANNEL].nvImageInMemory.SetImagePitch = ppdev->lDelta;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageInMemory.SetImageOffset = ppdev->ulPrimarySurfaceOffset;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageInMemory.SetImageCtxDma =
        DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM;

    //***************************************************************************
    // Setup src image in memory for device bitmaps.
    //***************************************************************************
    while (NvGetFreeCount(nv, 0) < 6*4);

    nv->subchannel[BLIT_SUBCHANNEL].SetObject = DD_SRC_IMAGE_IN_MEMORY;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageInMemory.SetImageOutput =
        DD_PATCHCORD_SRC_FEEDBACK;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageInMemory.SetColorFormat =
            colorFmtPack;

    nv->subchannel[BLIT_SUBCHANNEL].nvImageInMemory.SetImagePitch = ppdev->lDelta;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageInMemory.SetImageOffset = ppdev->ulPrimarySurfaceOffset;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageInMemory.SetImageCtxDma =
        DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM;

    // setup Video from memory object
    while (NvGetFreeCount(nv, 0) < 14*4);

    nv->subchannel[BLIT_SUBCHANNEL].SetObject = DD_PRIMARY_VIDEO_FROM_MEMORY;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoFromMemory.SetVideoOutput =
        DD_PATCHCORD_VIDEO;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoFromMemory.ImageScan[0].offset = ppdev->ulPrimarySurfaceOffset;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoFromMemory.ImageScan[0].pitch =
        ppdev->lDelta;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoFromMemory.ImageScan[0].size =
        (ppdev->cyScreen << 16) | (ppdev->cxScreen & 0xffff);
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoFromMemory.ImageScan[0].format =
        videoFmt;

    //**************************************************************************
    //
    // POSSIBLE PROBLEM ??  Or just a typo that was missed?
    //
    //        -> The following line used to be  ....nv4VideoFromMemory.ImageScan[0].notify.
    //           Now that this code has been separated out from ENABLE.C,
    //           this line has been changed to  ....nvVideoFromMemory.ImageScan[0].notify.
    //           in order for it to compile.   Essentially, the old obsolete
    //           nv3 classes are still being used in this file.
    //
    //           I don't know why .nv4VideoFromMemory was being used here,
    //           instead of nvVideoFromMemory.  First of all, nv4VideoFromMemory
    //           doesn't exist in the OLDNV332.H file.  And second, the structure
    //           OFFSETS for 'nvVideoFromMemory' vs nv4VideoFromMemory are DIFFERENT!
    //
    //           Bottom line: This looks like a typo that's been here forever.
    //                        It's now been changed, and should now be 'correct'.
    //                        However, since there's never been a problem with this before,
    //                        it's good to be aware of this change.   
    //
    //**************************************************************************

// REMOVED...causes lockup..ask!
//    nv->subchannel[BLIT_SUBCHANNEL].nvVideoFromMemory.ImageScan[0].notify = 0;

    nv->subchannel[BLIT_SUBCHANNEL].nvVideoFromMemory.ImageScan[1].offset = ppdev->ulPrimarySurfaceOffset;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoFromMemory.ImageScan[1].pitch =
        ppdev->lDelta;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoFromMemory.ImageScan[1].size =
        (ppdev->cyScreen << 16) | (ppdev->cxScreen & 0xffff);
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoFromMemory.ImageScan[1].format =
        videoFmt;

    //**************************************************************************
    //
    // POSSIBLE PROBLEM ??  Or just a typo that was missed?
    //
    //        -> The following line used to be  ....nv4VideoFromMemory.ImageScan[0].notify.
    //           Now that this code has been separated out from ENABLE.C,
    //           this line has been changed to  ....nvVideoFromMemory.ImageScan[0].notify.
    //           in order for it to compile.   Essentially, the old obsolete
    //           nv3 classes are still being used in this file.
    //
    //           I don't know why .nv4VideoFromMemory was being used here,
    //           instead of nvVideoFromMemory.  First of all, nv4VideoFromMemory
    //           doesn't exist in the OLDNV332.H file.  And second, the structure
    //           OFFSETS for 'nvVideoFromMemory' vs nv4VideoFromMemory were DIFFERENT!
    //
    //           Bottom line: This looks like a typo that's been here forever.
    //                        It's now been changed, and should now be 'correct'.
    //                        However, since there's never been a problem with this before,
    //                        it's good to be aware of this change.   
    //
    //**************************************************************************


// REMOVED...causes lockup..ask!
//    nv->subchannel[BLIT_SUBCHANNEL].nvVideoFromMemory.ImageScan[1].notify = 0;

    nv->subchannel[BLIT_SUBCHANNEL].nvVideoFromMemory.SetImageNotifyCtxDma[0] =
        NV_DD_FLIP_PRIMARY_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoFromMemory.SetImageNotifyCtxDma[1] =
        NV_DD_FLIP_PRIMARY_NOTIFIER_CONTEXT_DMA_TO_MEMORY;

    // setup Image From CPU in subchannel 0
    while (NvGetFreeCount(nv, 0) < 3*4);

    nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].SetObject = DD_IMAGE_FROM_CPU;
    nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nvImageFromCpu.SetImageOutput =
        DD_PATCHCORD_IMAGE_FROM_CPU;
    nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nvImageFromCpu.SetColorFormat =
        colorFmtPack;

    // setup Image BLIT in subchannel 1
    while (NvGetFreeCount(nv, 0) < 3*4);

    nv->subchannel[BLIT_SUBCHANNEL].SetObject = DD_IMAGE_BLIT;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageBlit.SetImageOutput =
        DD_PATCHCORD_IMAGE_BLIT;
    nv->subchannel[BLIT_SUBCHANNEL].nvImageBlit.SetImageInput =
        DD_PATCHCORD_SRC_FEEDBACK;

    // setup RECT and TEXT in subchannel 2
    while (NvGetFreeCount(nv, 0) < 6*4);

    nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].SetObject =
        DD_RENDER_RECT_AND_TEXT;
    nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nvRenderGdi0RectangleAndText.SetImageOutput =
        DD_PATCHCORD_IMAGE_RECT_AND_TEXT;
    nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nvRenderGdi0RectangleAndText.SetColorFormat =
        colorFmtAlpha;
    nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nvRenderGdi0RectangleAndText.SetMonochromeFormat =
        NV_MONO_CGA6_M1_P32;
    nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nvRenderGdi0RectangleAndText.SetNotifyCtxDma =
        DD_FIFO_SYNC_NOTIFIER;



    // setup Render Solid Rectangle in subchannel 3
    while (NvGetFreeCount(nv, 0) < 3*4);

    nv->subchannel[RECTANGLE_SUBCHANNEL].SetObject = DD_RENDER_SOLID_RECTANGLE;
    nv->subchannel[RECTANGLE_SUBCHANNEL].nvRenderSolidRectangle.SetImageOutput = DD_PATCHCORD_IMAGE_SOLID_RECT;
    nv->subchannel[RECTANGLE_SUBCHANNEL].nvRenderSolidRectangle.SetColorFormat = colorFmtUnpack;

    // setup ROP5 Solid in subchannel 4
    while (NvGetFreeCount(nv, 0) < 3*4);

    nv->subchannel[ROP_SOLID_SUBCHANNEL].SetObject = DD_ROP5_SOLID;
    nv->subchannel[ROP_SOLID_SUBCHANNEL].nvRop5Solid.SetRopOutput =
        DD_PATCHCORD_ROP5_SOLID;
    nv->subchannel[ROP_SOLID_SUBCHANNEL].nvRop5Solid.SetRop5 = 0xcc;

    // setup Image Pattern in subchannel 5
    while (NvGetFreeCount(nv, 0) < 9*4);

    nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].SetObject = DD_IMAGE_PATTERN;
    nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].nvImagePattern.SetImageOutput =
        DD_PATCHCORD_IMAGE_PATTERN;
    nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].nvImagePattern.SetColorFormat =
        colorFmtAlpha;
    nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].nvImagePattern.SetMonochromeFormat =
        NV_MONO_CGA6_M1_P32;
    nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].nvImagePattern.SetPatternShape =
        NV_PATTERN_SHAPE_64X1;
    nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].nvImagePattern.SetColor0 =
        color0;
    nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].nvImagePattern.SetColor1 =
        color1;
    nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].nvImagePattern.SetPattern.monochrome[0] =
        0xffffffff;
    nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].nvImagePattern.SetPattern.monochrome[1] =
        0x50505050;

    // setup Image Rectangle Black in subchannel 6
    while (NvGetFreeCount(nv, 0) < 4*4);

    nv->subchannel[CLIP_SUBCHANNEL].SetObject = DD_IMAGE_BLACK_RECTANGLE;
    nv->subchannel[CLIP_SUBCHANNEL].nvImageBlackRectangle.SetImageOutput =
        DD_PATCHCORD_IMAGE_BLACK_RECT;
    nv->subchannel[CLIP_SUBCHANNEL].nvImageBlackRectangle.SetRectangle.y_x = 0;
    nv->subchannel[CLIP_SUBCHANNEL].nvImageBlackRectangle.SetRectangle.height_width =
        ((0x7fff<<16) | 0x7fff);

    // setup Image Solid in subchannel 7
    while (NvGetFreeCount(nv, 0) < 4*4);

    nv->subchannel[DD_SPARE].SetObject = DD_IMAGE_SOLID;
    nv->subchannel[DD_SPARE].nvImageSolid.SetColorFormat = colorFmtAlpha;
    nv->subchannel[DD_SPARE].nvImageSolid.SetImageOutput =
        DD_PATCHCORD_IMAGE_SOLID;
    nv->subchannel[DD_SPARE].nvImageSolid.SetColor = 0L;  //Disable color keying
    ppdev->dDrawSpareSubchannelObject = DD_IMAGE_SOLID;

    while (NvGetFreeCount(nv, 0) < 9*4);

    nv->subchannel[BLIT_SUBCHANNEL].SetObject = DD_COLORMAP;

    nv->subchannel[BLIT_SUBCHANNEL].nvVideoColorMap.SetVideoInput =
        DD_PATCHCORD_VIDEO;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoColorMap.SetVideoOutput =
        DD_PATCHCORD_COLORMAP;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoColorMap.SetNotifyCtxDma =
        NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;

    nv->subchannel[BLIT_SUBCHANNEL].nvVideoColorMap.SetColormapCtxDma =
        NV_WIN_COLORMAP_CONTEXT;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoColorMap.SetColormapFormat =
        NV_COLORMAP_X8R8G8B8;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoColorMap.SetColormapStart = 0;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoColorMap.SetNotify = 0;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoColorMap.SetColormapLength =
        256 * sizeof(VIDEO_CLUTDATA);
    while (((NvNotification *) (ppdev->Notifiers->DmaToMem))->status == NV_STATUS_IN_PROGRESS);

    while (NvGetFreeCount(nv, 0) < 2*4);

    nv->subchannel[BLIT_SUBCHANNEL].SetObject = DD_VIDEO_SINK;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoSink.SetVideoInput[0] =
        NV_DD_P_V_VIDEO_COLOR_KEY;

    //************************************************************************
    // Create the video memory to system memory format object.
    //************************************************************************
    while (NvGetFreeCount(nv, 0) < 5*4);
    nv->subchannel[BLIT_SUBCHANNEL].SetObject = NV_DD_VIDEO_MEM_TO_SYSTEM_MEM_FORMAT;
    nv->subchannel[BLIT_SUBCHANNEL].nvMemoryToMemoryFormat.SetNotifyCtxDma =
        NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
    nv->subchannel[BLIT_SUBCHANNEL].nvMemoryToMemoryFormat.SetBufferInCtxDma =
        DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM;
    nv->subchannel[BLIT_SUBCHANNEL].nvMemoryToMemoryFormat.SetBufferOutCtxDma =
        NV_DD_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
    nv->subchannel[BLIT_SUBCHANNEL].nvMemoryToMemoryFormat.SetBufferNotifyCtxDma =
        NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;

    //**************************************************************************
    // create memory to memory format object used to reformat overlay surfaces
    //**************************************************************************
    while (NvGetFreeCount(nv, 0) < 5*4);
    nv->subchannel[BLIT_SUBCHANNEL].SetObject =
       NV_DD_VIDEO_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT;
    nv->subchannel[BLIT_SUBCHANNEL].nvMemoryToMemoryFormat.SetNotifyCtxDma =
       NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
    nv->subchannel[BLIT_SUBCHANNEL].nvMemoryToMemoryFormat.SetBufferInCtxDma =
       DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM;
    nv->subchannel[BLIT_SUBCHANNEL].nvMemoryToMemoryFormat.SetBufferOutCtxDma =
       DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM;
    nv->subchannel[BLIT_SUBCHANNEL].nvMemoryToMemoryFormat.SetBufferNotifyCtxDma =
       NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;

    //*******************************************************************************
    // Create objects needed for video overlay.
    //*******************************************************************************
    while (NvGetFreeCount(nv, BLIT_SUBCHANNEL) < 15*4);

    nv->subchannel[BLIT_SUBCHANNEL].SetObject = NV_DD_VIDEO_COLOR_KEY;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoColorKey.SetVideoOutput =
        NV_DD_P_V_VIDEO_COLOR_KEY;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoColorKey.SetVideoInput[0] =
        DD_PATCHCORD_VIDEO;

    if (ppdev->cBitsPerPel == 8)
        nv->subchannel[BLIT_SUBCHANNEL].nvVideoColorKey.SetVideoInput[1] =
            DD_PATCHCORD_COLORMAP;
    else
        nv->subchannel[BLIT_SUBCHANNEL].nvVideoColorKey.SetVideoInput[1] =
            DD_PATCHCORD_VIDEO;

    nv->subchannel[BLIT_SUBCHANNEL].nvVideoColorKey.SetVideoInput[2] =
        NV_DD_P_V_VIDEO_SCALER;

    if (ppdev->cBitsPerPel == 8)
        nv->subchannel[BLIT_SUBCHANNEL].nvVideoColorKey.SetColorFormat =
            NV_COLOR_FORMAT_LE_X16A8Y8;
    else if (ppdev->cBitsPerPel == 16)
        nv->subchannel[BLIT_SUBCHANNEL].nvVideoColorKey.SetColorFormat =
            NV_COLOR_FORMAT_LE_X16A1R5G5B5;
    else
        nv->subchannel[BLIT_SUBCHANNEL].nvVideoColorKey.SetColorFormat =
            NV_COLOR_FORMAT_LE_A8R8G8B8;


    nv->subchannel[BLIT_SUBCHANNEL].nvVideoColorKey.SetColorKey = 0;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoColorKey.SetPoint = 0;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoColorKey.SetSize = 0;

    nv->subchannel[BLIT_SUBCHANNEL].SetObject = NV_DD_VIDEO_SCALER;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoScaler.SetVideoOutput =
       NV_DD_P_V_VIDEO_SCALER;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoScaler.SetVideoInput =
       NV_DD_P_V_YUV422_VIDEO_FROM_MEMORY;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoScaler.SetDeltaDuDx = 0x100000;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoScaler.SetDeltaDvDy = 0x100000;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoScaler.SetPoint = 0;


    while (NvGetFreeCount(nv, BLIT_SUBCHANNEL) < 17*4);

    nv->subchannel[BLIT_SUBCHANNEL].SetObject = NV_DD_YUV422_VIDEO_FROM_MEMORY;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoFromMemory.SetVideoOutput =
        NV_DD_P_V_YUV422_VIDEO_FROM_MEMORY;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoFromMemory.SetImageCtxDma[0] =
        DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoFromMemory.SetImageCtxDma[1] =
        DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoFromMemory.SetImageNotifyCtxDma[0] =
        NV_DD_FLIP_OVERLAY_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoFromMemory.SetImageNotifyCtxDma[1] =
        NV_DD_FLIP_OVERLAY_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoFromMemory.ImageScan[0].offset = 0;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoFromMemory.ImageScan[0].pitch = 0;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoFromMemory.ImageScan[0].size = 0;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoFromMemory.ImageScan[0].format =
        NV_VFM_FORMAT_COLOR_LE_Y8V8Y8U8;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoFromMemory.ImageScan[0].notify = 0;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoFromMemory.ImageScan[1].offset = 0;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoFromMemory.ImageScan[1].pitch = 0;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoFromMemory.ImageScan[1].size = 0;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoFromMemory.ImageScan[1].format =
        NV_VFM_FORMAT_COLOR_LE_Y8V8Y8U8;
    nv->subchannel[BLIT_SUBCHANNEL].nvVideoFromMemory.ImageScan[1].notify = 0;

    if (ppdev->cBitsPerPel > 8)
        {
        //*****************************************************************************
        // Hook up scaled image from mem objects.
        //*****************************************************************************
        while (NvGetFreeCount(nv, 0) < 5*4);

        nv->subchannel[BLIT_SUBCHANNEL].SetObject =
            NV_DD_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetNotifyCtxDma =
            NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetImageOutput =
            NV_DD_P_I_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY;
        if (ppdev->cBitsPerPel == 16)
            nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetColorFormat =
                NV_COLOR_FORMAT_LE_X1R5G5B5_P2;
        else
            nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetColorFormat =
                NV_COLOR_FORMAT_LE_X8R8G8B8;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetImageCtxDma =
            DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM;

        while (NvGetFreeCount(nv, 0) < 5*4);

        nv->subchannel[BLIT_SUBCHANNEL].SetObject =
            NV_DD_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetNotifyCtxDma =
            NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetImageOutput =
            NV_DD_P_I_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY;
        if (ppdev->cBitsPerPel == 16)
            nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetColorFormat =
                NV_COLOR_FORMAT_LE_X1R5G5B5_P2;
        else
            nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetColorFormat =
                NV_COLOR_FORMAT_LE_X8R8G8B8;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetImageCtxDma =
            NV_DD_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

        while (NvGetFreeCount(nv, 0) < 5*4);

        nv->subchannel[BLIT_SUBCHANNEL].SetObject =
            NV_DD_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetNotifyCtxDma =
            NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetImageOutput =
            NV_DD_P_I_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetColorFormat =
            NV_COLOR_FORMAT_LE_Y8V8Y8U8;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetImageCtxDma =
            NV_DD_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

        while (NvGetFreeCount(nv, 0) < 5*4);

        nv->subchannel[BLIT_SUBCHANNEL].SetObject =
            NV_DD_SCALED_UYVY_IMAGE_FROM_VIDEO_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetNotifyCtxDma =
            NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetImageOutput =
            NV_DD_P_I_SCALED_UYVY_IMAGE_FROM_VIDEO_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetColorFormat =
            NV_COLOR_FORMAT_LE_Y8V8Y8U8;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetImageCtxDma =
            DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM;

        while (NvGetFreeCount(nv, 0) < 5*4);

        nv->subchannel[BLIT_SUBCHANNEL].SetObject =
            NV_DD_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetNotifyCtxDma =
            NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetImageOutput =
            NV_DD_P_I_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetColorFormat =
            NV_COLOR_FORMAT_LE_V8Y8U8Y8;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetImageCtxDma =
            NV_DD_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

        while (NvGetFreeCount(nv, 0) < 5*4);

        nv->subchannel[BLIT_SUBCHANNEL].SetObject =
            NV_DD_SCALED_YUYV_IMAGE_FROM_VIDEO_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetNotifyCtxDma =
            NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetImageOutput =
            NV_DD_P_I_SCALED_YUYV_IMAGE_FROM_VIDEO_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetColorFormat =
            NV_COLOR_FORMAT_LE_V8Y8U8Y8;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetImageCtxDma =
            DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM;

        while (NvGetFreeCount(nv, 0) < 5*4);

        nv->subchannel[BLIT_SUBCHANNEL].SetObject =
            NV_DD_FLOATING0_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetNotifyCtxDma =
            NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetImageOutput =
            NV_DD_P_I_FLOATING0_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetColorFormat =
            NV_COLOR_FORMAT_LE_Y8V8Y8U8;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetImageCtxDma =
            NV_DD_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

        while (NvGetFreeCount(nv, 0) < 5*4);

        nv->subchannel[BLIT_SUBCHANNEL].SetObject =
            NV_DD_FLOATING1_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetNotifyCtxDma =
            NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetImageOutput =
            NV_DD_P_I_FLOATING1_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetColorFormat =
            NV_COLOR_FORMAT_LE_Y8V8Y8U8;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetImageCtxDma =
            NV_DD_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

        while (NvGetFreeCount(nv, 0) < 5*4);

        nv->subchannel[BLIT_SUBCHANNEL].SetObject =
            NV_DD_FLOATING0_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetNotifyCtxDma =
            NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetImageOutput =
            NV_DD_P_I_FLOATING0_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetColorFormat =
            NV_COLOR_FORMAT_LE_V8Y8U8Y8;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetImageCtxDma =
            NV_DD_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

        while (NvGetFreeCount(nv, 0) < 5*4);

        nv->subchannel[BLIT_SUBCHANNEL].SetObject =
            NV_DD_FLOATING1_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetNotifyCtxDma =
            NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetImageOutput =
            NV_DD_P_I_FLOATING1_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetColorFormat =
            NV_COLOR_FORMAT_LE_V8Y8U8Y8;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledImageFromMemory.SetImageCtxDma =
            NV_DD_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

        while (NvGetFreeCount(nv, 0) < 4*4);

        nv->subchannel[BLIT_SUBCHANNEL].SetObject =
            NV_DD_FLOATING0_SCALED_Y420_IMAGE_FROM_SYSTEM_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledYuv420FromMemory.SetNotifyCtxDma =
            NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledYuv420FromMemory.SetImageOutput =
            NV_DD_P_I_FLOATING0_SCALED_Y420_IMAGE_FROM_SYSTEM_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledYuv420FromMemory.SetImageCtxDma =
            NV_DD_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

        while (NvGetFreeCount(nv, 0) < 4*4);

        nv->subchannel[BLIT_SUBCHANNEL].SetObject =
            NV_DD_FLOATING1_SCALED_Y420_IMAGE_FROM_SYSTEM_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledYuv420FromMemory.SetNotifyCtxDma =
            NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledYuv420FromMemory.SetImageOutput =
            NV_DD_P_I_FLOATING1_SCALED_Y420_IMAGE_FROM_SYSTEM_MEMORY;
        nv->subchannel[BLIT_SUBCHANNEL].nvScaledYuv420FromMemory.SetImageCtxDma =
            NV_DD_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
        }

    while (NvGetFreeCount(nv, 0) < 3*4);
    nv->subchannel[DD_STRETCH].SetObject =
        NV_DD_STRETCHED_IMAGE_FROM_CPU;
    nv->subchannel[DD_STRETCH].nvStretchedImageFromCpu.SetImageOutput =
        NV_DD_P_I_STRETCHED_IMAGE_FROM_CPU;
    nv->subchannel[DD_STRETCH].nvStretchedImageFromCpu.SetColorFormat =
        colorFmtPack;
    ppdev->dDrawSpareSubchannelObject = NV_DD_STRETCHED_IMAGE_FROM_CPU;

    while (NvGetFreeCount(nv, 0) < 3*4);
    nv->subchannel[BLIT_SUBCHANNEL].SetObject = NV_DD_STRETCHED_UV_IMAGE_FROM_CPU;
    nv->subchannel[BLIT_SUBCHANNEL].nvStretchedImageFromCpu.SetImageOutput =
        NV_DD_P_I_STRETCHED_UV_IMAGE_FROM_CPU;
    nv->subchannel[BLIT_SUBCHANNEL].nvStretchedImageFromCpu.SetColorFormat =
        NV_COLOR_FORMAT_LE_Y8_P4;

    while (NvGetFreeCount(nv, 0) < 4);
    nv->subchannel[BLIT_SUBCHANNEL].SetObject = DD_IMAGE_BLIT;

    //******************************************************************************
    // Cache the freecount
    //******************************************************************************
    ppdev->NVFreeCount = NvGetFreeCount(nv, 0);

    return TRUE;




bNV3CreateStdPatches_ReturnFalse:

    //**************************************************************************
    // Remove ALL DMA contexts that we previously allocated!
    //**************************************************************************

    vNV3DestroyStdPatches(ppdev,TRUE);
    return(FALSE);


}

VOID vNV3DestroyStdPatches(
    PDEV *ppdev,
    BOOL  CreateStdPatchFailedFlag
)
{
    // get the FIFO pointer from the physical device descriptor
    Nv3ChannelPio *nv = (Nv3ChannelPio *)ppdev->pjMmBase;
    ULONG                   status;

    DISPDBG((1, "DD destroying standard patches..."));

    //******************************************************************************
    // Ensure all hw processing has completed prior to destroying objects.
    // WaitEngineBusy function is NOT yet initialized if we just came from
    // a bNV3CreateStdPatches call, which failed.   So skip it.
    //******************************************************************************

    if (CreateStdPatchFailedFlag != TRUE)
        ppdev->pfnWaitEngineBusy(ppdev);

    //******************************************************************************
    // Invalidate cached freecount
    //******************************************************************************
    ppdev->NVFreeCount = 0;

    //**************************************************************************
    // Relinquish -> user channel
    //**************************************************************************
    if (ppdev->pjMmBase != NULL)
        {

        status = NvFree(ppdev->hDriver,
                        ppdev->hClient,
                        ppdev->hDevice,
                        ppdev->hPioChannel);

        if (status != NVOS00_STATUS_SUCCESS)
            {
            DISPDBG((1, "Failed bAssertModeHardware"));
            return;
            }

        ASSERTDD(status == NVOS00_STATUS_SUCCESS,
                 "bAssertModeHardware: Failed to free NV user channel.");

        ppdev->pjMmBase = NULL;
        ppdev->ddChannelPtr = NULL;
        }


    //**********************************************************************
    // Destroy the notifier context (from system memory)
    //**********************************************************************

    if (NvFree(ppdev->hDriver, ppdev->hClient, ppdev->hDevice, NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY) != NVOS00_STATUS_SUCCESS)
        {
        DISPDBG((1, "NVDD: Cannot free notifier context"));
        }

    //**********************************************************************
    // Destroy the colormap context (from system memory)
    //**********************************************************************

    if (NvFree(ppdev->hDriver, ppdev->hClient, ppdev->hDevice, NV_WIN_COLORMAP_CONTEXT) != NVOS00_STATUS_SUCCESS)
        {
        DISPDBG((1, "NVDD: Cannot free buffer context"));
        }

    //*************************************************************************
    // Destroy video flip notifier.
    //*************************************************************************
        if (NvFree(ppdev->hDriver,
            ppdev->hClient,
            ppdev->hDevice,
            NV_DD_FLIP_PRIMARY_NOTIFIER_CONTEXT_DMA_TO_MEMORY) != NVOS00_STATUS_SUCCESS)
            {
            DISPDBG((1, "NVDD: Cannot free buffer context"));
            }

    //*************************************************************************
    // Destroy overlay flip notifier.
    //*************************************************************************
        if (NvFree(ppdev->hDriver,
            ppdev->hClient,
            ppdev->hDevice,
            NV_DD_FLIP_OVERLAY_NOTIFIER_CONTEXT_DMA_TO_MEMORY) != NVOS00_STATUS_SUCCESS)
            {
            DISPDBG((1, "NVDD: Cannot overlay notifier"));
            }

    //*************************************************************************
    // Destroy CONTEXT_DMA_IN_MEMORY object used to reference video memory.
    //*************************************************************************
    if (NvFree(ppdev->hDriver, ppdev->hClient, ppdev->hDevice, DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM) != NVOS00_STATUS_SUCCESS)
            {
            DISPDBG((1, "NVDD: Cannot video mem context"));
            }

    //*************************************************************************
    // Destroy FIFO sync notifier.
    //*************************************************************************
    if (NvFree(ppdev->hDriver, ppdev->hClient, ppdev->hDevice, DD_FIFO_SYNC_NOTIFIER) != NVOS00_STATUS_SUCCESS)
            {
            DISPDBG((1, "NVDD: Cannot free fifo sync notifier"));
            }

    //**********************************************************************************
    // Destroy DMA context for 2D/DDraw DMA Buffer.
    //**********************************************************************************
    if (NvFree(ppdev->hDriver,
                ppdev->hClient,
                ppdev->hDevice,
                NV_DD_CONTEXT_DMA_FROM_SYSTEM_MEMORY) != NVOS00_STATUS_SUCCESS)
        {
        DISPDBG((1, "DisableOGLPatch: Cannot free 2D DMA buffer context"));
        }

    //**********************************************************************************
    // Destroy DMA notifier context for 2D/DDraw DMA Buffer.
    //**********************************************************************************
    if (ppdev->NvDmaBufferFlat)
        {
        if (NvFree(ppdev->hDriver,
                    ppdev->hClient,
                    ppdev->hDevice,
                    NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY) != NVOS00_STATUS_SUCCESS)
            {
            DISPDBG((1, "DisableOGLPatch: Cannot free 2D DMA buffer context"));
            }
        EngFreeMem((PVOID) ppdev->NvDmaBufferFlat);
        }

    ppdev->NvDmaBufferFlat = ppdev->NvScanlineBufferFlat = 0;

    return;
}
#endif // NV3
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nv3linto.c ===
//*****************************Module*Header************************************
// 
// Module Name: NV3LINTO.C
// 
// DrvLineTo for S3 driver
// 
// Copyright (c) 1995-1996 Microsoft Corporation
// 
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"

#include "oldnv332.h"

#include "nvsubch.h"
#include "nvalpha.h"

//******************************************************************************
// NV:   Currently, we'll be using the NV1 lineto functions for NV3 since
//       they're compatible.  We can add the NV3 specific versions later...
//******************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nv3bltc.c ===
//******************************Module*Header***********************************
//
// Module Name: NV3BLTC.C
//
// Copyright (c) 1992-1996 Microsoft Corporation
//
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"

#ifdef NV3
#include "oldnv332.h"

#include "nvsubch.h"
#define NV32_INCLUDED // Prevents re-inclusion of real nv32 header
#include "driver.h"

#ifdef _WIN32_WINNT     // If is >= NT 4.x

//******************************************************************************
// Externs
//******************************************************************************

ULONG nvBrushToSrcRopTable[64] = {
0x00000000, 0x00000011, 0x00000022, 0x00000033,
0x00000000, 0x00000011, 0x00000022, 0x00000033,
0x00000000, 0x00000011, 0x00000022, 0x00000033,
0x00000000, 0x00000011, 0x00000022, 0x00000033,
0x00000044, 0x00000055, 0x00000066, 0x00000077,
0x00000044, 0x00000055, 0x00000066, 0x00000077,
0x00000044, 0x00000055, 0x00000066, 0x00000077,
0x00000044, 0x00000055, 0x00000066, 0x00000077,
0x00000088, 0x00000099, 0x000000AA, 0x000000BB,
0x00000088, 0x00000099, 0x000000AA, 0x000000BB,
0x00000088, 0x00000099, 0x000000AA, 0x000000BB,
0x00000088, 0x00000099, 0x000000AA, 0x000000BB,
0x000000CC, 0x000000DD, 0x000000EE, 0x000000FF,
0x000000CC, 0x000000DD, 0x000000EE, 0x000000FF,
0x000000CC, 0x000000DD, 0x000000EE, 0x000000FF,
0x000000CC, 0x000000DD, 0x000000EE, 0x000000FF
};

#ifdef _X86_

//******************************************************************************
// X86 Assembly routine to xfer host bitmap->screen
//******************************************************************************

void NV1_Transfer_MemToScreen_Data(ULONG, USHORT *, ULONG, ULONG *,LONG, Nv3ChannelPio *);

#endif

//******************************************************************************
// Macros used by FillPatFast (optimization)
//******************************************************************************


#define BUILD_PIXEL_GROUP(GROUP_WIDTH,BLIT_SIZE,NUM_BLITS) \
{\
if (RemainingPixels>=(GROUP_WIDTH))\
    {\
    for (i=0; i<(NUM_BLITS) ;i++)\
        {\
        while (FreeCount < 3*4)\
            FreeCount = nv->subchannel[BLIT_SUBCHANNEL].control.Free;\
        FreeCount -= 3*4;\
\
        nv->subchannel[BLIT_SUBCHANNEL].nv1ImageBlit.ControlPointIn = ( (CurrentYdst << 16) | (xdst & 0xffff) );\
        nv->subchannel[BLIT_SUBCHANNEL].nv1ImageBlit.ControlPointOut = ( ( (CurrentYdst ) << 16) | ((CurrentXdst ) & 0xffff) );\
        nv->subchannel[BLIT_SUBCHANNEL].nv1ImageBlit.Size = ( (1 << 16) | (BLIT_SIZE) );\
\
        RemainingPixels -= (BLIT_SIZE);\
        CurrentXdst     += (BLIT_SIZE);\
        }\
    }\
}


#define COPY_PIXEL_GROUP(GROUP_WIDTH,NUM_BLITS) \
{\
if (RemainingPixels>= (GROUP_WIDTH) )\
    {\
    NumberOfBlits = (NUM_BLITS);\
\
    for (i=0; i< (NumberOfBlits) ;i++)\
        {\
        while (FreeCount < 3*4)\
            FreeCount = nv->subchannel[BLIT_SUBCHANNEL].control.Free;\
        FreeCount -= 3*4;\
\
        nv->subchannel[BLIT_SUBCHANNEL].nv1ImageBlit.ControlPointIn = ( (CurrentYdst << 16) | (xdst & 0xffff) );\
        nv->subchannel[BLIT_SUBCHANNEL].nv1ImageBlit.ControlPointOut = ( ( (CurrentYdst ) << 16) | ((CurrentXdst ) & 0xffff) );\
        nv->subchannel[BLIT_SUBCHANNEL].nv1ImageBlit.Size = ( (1 << 16) | (GROUP_WIDTH) );\
\
        RemainingPixels -= (GROUP_WIDTH);\
        CurrentXdst     += (GROUP_WIDTH);\
        }\
    }\
}


#define BUILD_PIXEL_BLOCK(GROUP_HEIGHT,GROUP_WIDTH,BLIT_HEIGHT,NUM_BLITS) \
{\
if (RemainingScanlines>=(GROUP_HEIGHT))\
    {\
    for (i=0; i<(NUM_BLITS) ;i++)\
        {\
        while (FreeCount < 3*4)\
            FreeCount = nv->subchannel[BLIT_SUBCHANNEL].control.Free;\
        FreeCount -= 3*4;\
\
        nv->subchannel[BLIT_SUBCHANNEL].nv1ImageBlit.ControlPointIn = ( (ydst << 16) | ((CurrentXdst) & 0xffff) );\
        nv->subchannel[BLIT_SUBCHANNEL].nv1ImageBlit.ControlPointOut = ( ( (CurrentYdst ) << 16) | ((CurrentXdst ) & 0xffff) );\
        nv->subchannel[BLIT_SUBCHANNEL].nv1ImageBlit.Size = ( ((BLIT_HEIGHT) << 16) | (GROUP_WIDTH) );\
\
        RemainingScanlines -= (BLIT_HEIGHT);\
        CurrentYdst        += (BLIT_HEIGHT);\
        }\
    }\
}


#define COPY_PIXEL_BLOCK(GROUP_HEIGHT,GROUP_WIDTH,NUM_BLITS) \
{\
if (RemainingScanlines>= (GROUP_HEIGHT) )\
    {\
    NumberOfBlits = (NUM_BLITS);\
\
    for (i=0; i< (NumberOfBlits) ;i++)\
        {\
        while (FreeCount < 3*4)\
            FreeCount = nv->subchannel[BLIT_SUBCHANNEL].control.Free;\
        FreeCount -= 3*4;\
\
        nv->subchannel[BLIT_SUBCHANNEL].nv1ImageBlit.ControlPointIn = ( (ydst << 16) | ((CurrentXdst) & 0xffff) );\
        nv->subchannel[BLIT_SUBCHANNEL].nv1ImageBlit.ControlPointOut = ( ( (CurrentYdst ) << 16) | ((CurrentXdst ) & 0xffff) );\
        nv->subchannel[BLIT_SUBCHANNEL].nv1ImageBlit.Size = ( ((GROUP_HEIGHT) << 16) | (GROUP_WIDTH) );\
\
        RemainingScanlines -= (GROUP_HEIGHT);\
        CurrentYdst        += (GROUP_HEIGHT);\
        }\
    }\
}


//******************************************************************************
//
//  Function:   NV3FillSolid
//
//  Routine Description:
//
//      Fills a list of rectangles with a solid colour.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NV3FillSolid(              // Type FNFILL
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of rectangles to be filled, in relative
                                //   coordinates
ULONG           rop4,           // rop4
RBRUSH_COLOR    rbc,            // Drawing colour is rbc.iSolidColor
POINTL*         pptlBrush)      // Not used

    {
    Nv3ChannelPio  *nv  = (Nv3ChannelPio *)ppdev->pjMmBase;

    ULONG   ulHwForeMix;
    ULONG  width,height;
    USHORT FreeCount;
    ULONG Rop3;
    ULONG temp;
    ULONG AlphaEnableValue;
    ULONG PixelDepth;

    //**************************************************************************
    // Safety checks
    //**************************************************************************

    ASSERTDD(c > 0, "Can't handle zero rectangles");

    //**************************************************************************
    // Get pixel depth for the current mode.
    // Then determine the ALPHA_CHANNEL enable value
    //**************************************************************************

    AlphaEnableValue = ppdev->AlphaEnableValue;

// ???
///    ulHwForeMix = gaulHwMixFromRop2[(rop4 >> 2) & 0xf];

    //**************************************************************************
    // Equation to convert to Rop4 to Rop3 (We don't get patterns here)
    //
    // Rop4:
    //                 Truth table for a Rop 3.
    //                 ------------------------
    //                                    R
    //                                    O
    //                        (SD)        P
    //                  11  10  01  00    3
    //                  --------------
    //          (P) 1  |         x   x    High nibble    Example Value = 0xf0
    //              0  | x   x            Low nibble
    //
    //
    // After rop4 >> 2:
    //
    //                 Truth table for a Rop 3.
    //                 ------------------------
    //                                    R
    //                                    O
    //                        (SD)        P
    //                  11  10  01  00    3
    //                  --------------
    //          (P) 1  |                  High nibble    Value = 0x3c
    //              0  | x   x   x   x    Low nibble
    //
    //
    // After (rop4 >> 2 ) & 0xf:
    //
    //                                                   Value = 0x0c
    //
    // Final Rop3 equivalent value of a Rop2 value = 0xcc
    //
    //         This value does not depend on the Pattern
    //**************************************************************************

    temp = ((rop4 >> 2) & 0xf);         // Get bottom nibble
    Rop3 = temp | (temp << 4);        // Duplicate in top nibble

    //**************************************************************************
    // Init cached free count
    //**************************************************************************

    FreeCount = ppdev->NVFreeCount;

    while (FreeCount < 1*4)
        FreeCount = nv->subchannel[ROP_SOLID_SUBCHANNEL].control.Free;
    FreeCount -= 1*4;

    nv->subchannel[ROP_SOLID_SUBCHANNEL].nv3ContextRop.SetRop5 = Rop3 ;

    //**************************************************************************
    // Reset clipping rectangle to full screen extents if necessary
    // Resetting the clipping rectangle causes delays so we want to do it
    // as little as possible!
    //**************************************************************************

    if (ppdev->NVClipResetFlag)
        {
        while (FreeCount < 2*4)
           FreeCount = nv->subchannel[CLIP_SUBCHANNEL].control.Free;
        FreeCount -= 2*4;

        nv->subchannel[CLIP_SUBCHANNEL].nv1ImageBlackRectangle.SetPoint = ((0 << 16) | 0 );
        nv->subchannel[CLIP_SUBCHANNEL].nv1ImageBlackRectangle.SetSize = (( (ppdev->cyMemory)<<16) | (0x7fff));

        ppdev->NVClipResetFlag=0;       // Clipping rectangle has been reset
        }

    while(TRUE)
        {

        //**********************************************************************
        // GDI passes the lower right and bottom coordinate as EXCLUSIVE.
        // That is, the lower right coordinate is NOT included
        // For NV, the width/height actually means the number of pixels drawn.
        // So, adjusting by 1 pixel is NOT necessary when calculating width and height.
        //**********************************************************************

        width = prcl->right - prcl->left;
        height = prcl->bottom - prcl->top;

        //**********************************************************************
        // Wait for FIFO to be ready, then draw
        // We know that this is a straight SOLID FILL with no pattern
        //***********************************************************************

        while (FreeCount < 3*4)
            FreeCount = nv->subchannel[RECTANGLE_SUBCHANNEL].control.Free ;
        FreeCount -=3*4;

        nv->subchannel[RECTANGLE_SUBCHANNEL].nv1RenderSolidRectangle.Color = (AlphaEnableValue | rbc.iSolidColor);
        nv->subchannel[RECTANGLE_SUBCHANNEL].nv1RenderSolidRectangle.Rectangle[0].point = (( (prcl->top) << 16) | ( (prcl->left) & 0xffff));
        nv->subchannel[RECTANGLE_SUBCHANNEL].nv1RenderSolidRectangle.Rectangle[0].size = ( (height << 16) | width );

        if (--c == 0)
            {
            //******************************************************************
            // Update global free count
            //******************************************************************
            ppdev->NVFreeCount = FreeCount;

            return;
            }

        prcl++;
        }

    }


//******************************************************************************
//
//  Function:   NV3FillPatFast
//
//  Routine Description:
//
//      This routine uses the NV Image_Mono_From_CPU and Image_From_CPU
//      object clases to draw a patterned list of rectangles.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************


VOID NV3FillPatFast(            // Type FNFILL
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of rectangles to be filled, in relative
                                //   coordinates
ULONG           rop4,           // rop4
RBRUSH_COLOR    rbc,            // rbc.prb points to brush realization structure
POINTL*         pptlBrush)      // Pattern alignment

    {
    BOOL        bTransparent;
    ULONG       ulHwForeMix;
    BRUSHENTRY* pbe;        // Pointer to brush entry data, which is used
                            //   for keeping track of the location and status
                            //   of the pattern bits cached in off-screen
                            //   memory

    Nv3ChannelPio  *nv  = (Nv3ChannelPio *)ppdev->pjMmBase;
    ULONG Color0;
    ULONG Color1;
    ULONG AlphaEnableValue;
    ULONG PixelDepth;
    ULONG width;
    ULONG height;
    USHORT FreeCount;
    ULONG rop3;
    LONG  xShift;
    LONG  yShift;
    ULONG BytesPerDstScan;
    ULONG DwordsPerDstScan;
    ULONG SizeInWidth;
    LONG BytesPerSrcScan;
    BYTE*  SrcBits;
    BYTE*  DstBits;
    ULONG *ScanPtr;
    ULONG TempPixelData1;
    ULONG TempPixelData2;
    RBRUSH* prb;
    ULONG PatternYCount;
    ULONG *NextScan;
    ULONG *EndOfScanPtr;
    LONG ScanInc;
    ULONG DwordCount;
    ULONG yscan;
    ULONG xdst,ydst;
    LONG  cjLeft;
    LONG  cjRight;
    ULONG   i;

    ULONG CurrentXdst;
    ULONG CurrentYdst;
    ULONG RemainingPixels;
    ULONG SrcOffset;
    ULONG SrcStride;
    ULONG NumberOfBlits;
    ULONG RemainingScanlines;

    //**************************************************************************
    // Safety checks
    //**************************************************************************

    ASSERTDD(c > 0, "Can't handle zero rectangles");

    //**************************************************************************
    // TODO: Do I need to do anything special for transparent cases?
    //**************************************************************************
    rop3 = (ULONG)((BYTE) (rop4 & 0xff));
    bTransparent = (((rop4 >> 8) & 0xff) != rop3);

    //**************************************************************************
    // Get pointer to brush entry
    //**************************************************************************

    prb = rbc.prb;
    pbe = rbc.prb->apbe[IBOARD(ppdev)];

    //**************************************************************************
    // Need to add if statement if brush pattern hasn't changed
    // For now, just always re-calculate brush pattern
    // Performance boost of how much?
    //**************************************************************************

    //**************************************************************************
    // Init FreeCount variable
    //**************************************************************************

    FreeCount = ppdev->NVFreeCount;

    //**************************************************************************
    // Get pixel depth for the current mode.
    // Then determine the ALPHA_CHANNEL enable value
    //**************************************************************************

    PixelDepth = ppdev->cBitsPerPel;

    AlphaEnableValue = ppdev->AlphaEnableValue;

    //**************************************************************************
    // Restore clip rect
    //**************************************************************************
    if (ppdev->NVClipResetFlag)
        {
        while(FreeCount < 2*4)
            FreeCount = nv->subchannel[CLIP_SUBCHANNEL].control.Free;
        FreeCount -= 2*4;

        nv->subchannel[CLIP_SUBCHANNEL].nv1ImageBlackRectangle.SetPoint = ((0 << 16) | 0 );
        nv->subchannel[CLIP_SUBCHANNEL].nv1ImageBlackRectangle.SetSize = (((ppdev->cyMemory)<<16) | (0x7fff));

        ppdev->NVClipResetFlag=0;       // Clipping rectangle has been reset
        }


    //**************************************************************************
    // I considered doing the colour expansion for 1bpp brushes in
    // software, but by letting the hardware do it, we don't have
    // to do as many OUTs to transfer the pattern.
    //**************************************************************************

    if (prb->fl & RBRUSH_2COLOR)
        {

        //**********************************************************************
        // Because we handle only 8x8 brushes, it is easy to compute the
        // number of pels by which we have to rotate the brush pattern
        // right and down.  Note that if we were to handle arbitrary sized
        // patterns, this calculation would require a modulus operation.
        //
        // The brush is aligned in absolute coordinates, so we have to add
        // in the surface offset:
        //
        // NV: We DON'T need to manually account for the position of the pattern
        //     on the screen, like we do for the Memory to Screen blits for
        //     multi-color patterns (below).
        //**********************************************************************

        //**********************************************************************
        // Rotate pattern 'xShift' pels right
        // Rotate pattern 'yShift' pels down
        //**********************************************************************

        xShift = pptlBrush->x & 7;
        yShift = pptlBrush->y & 7;

        //**********************************************************************
        // Shift Mono pattern bits appropriately (vertically)
        // First we'll align it properly by copying it to a temporary buffer:
        //**********************************************************************

        SrcBits = (BYTE*) &prb->aulPattern[0];          // Copy from brush buffer
        DstBits = (BYTE*) &ppdev->AlignedBrush[0];      // Copy to our aligned buffer

        DstBits += yShift;                              // Starting yShift rows
        i = 8 - yShift;                                 //  down for 8 - yShift rows

        //**********************************************************************
        // Now copy the pattern , row by row (byte by byte) and
        // align it vertically and horizontally at the same time
        //**********************************************************************

        do  {
            *DstBits = ((*SrcBits >> xShift) | (*SrcBits << (8-xShift)));
            DstBits ++;
            SrcBits ++;

            } while (--i != 0);

        //**********************************************************************
        // Now copy the 'top' part
        //**********************************************************************

        DstBits -=8;                    // Move back to beginning of destination

        for (; yShift != 0; yShift--)
            {
            *DstBits = ((*SrcBits >> xShift) | (*SrcBits << (8-xShift)));
            DstBits ++;
            SrcBits ++;
            }

        //**********************************************************************
        // Init foreground and background color
        //**********************************************************************

        Color1 = rbc.prb->ulForeColor | (AlphaEnableValue); // Background color
        Color0 = rbc.prb->ulBackColor | (AlphaEnableValue); // Foreground color

        while (FreeCount < 6*4)
            FreeCount = nv->subchannel[RECTANGLE_SUBCHANNEL].control.Free;
        FreeCount -= 6*4;

        nv->subchannel[ROP_SOLID_SUBCHANNEL].nv3ContextRop.SetRop5 = rop3 ;

        nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].nv1ImagePattern.SetMonochromeShape = NV018_SET_MONOCHROME_SHAPE_8X_8Y;
        nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].nv1ImagePattern.SetMonochromeColor0 = Color0;
        nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].nv1ImagePattern.SetMonochromeColor1 = Color1;
        nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].nv1ImagePattern.SetMonochromePattern0 = ppdev->AlignedBrush[0];
        nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].nv1ImagePattern.SetMonochromePattern1 = ppdev->AlignedBrush[1];


        do {
            //******************************************************************
            // Get width and height of the destination rectangle
            //******************************************************************

            width = prcl->right - prcl->left;
            height= prcl->bottom - prcl->top;

            //******************************************************************
            // Wait for FIFO to be ready, then draw
            //******************************************************************

            while (FreeCount < 3*4)
                FreeCount = nv->subchannel[RECTANGLE_SUBCHANNEL].control.Free;
            FreeCount -= 3*4;

            nv->subchannel[RECTANGLE_SUBCHANNEL].nv1RenderSolidRectangle.Color = rbc.prb->ulForeColor | AlphaEnableValue;
            nv->subchannel[RECTANGLE_SUBCHANNEL].nv1RenderSolidRectangle.Rectangle[0].point = ((prcl->top << 16) | ((prcl->left) & 0xffff));
            nv->subchannel[RECTANGLE_SUBCHANNEL].nv1RenderSolidRectangle.Rectangle[0].size = ( (height << 16) | width );


            prcl++;

            } while (--c != 0);

        //**********************************************************************
        // Notify the rest of the driver that we changed the pattern
        //**********************************************************************

        ppdev->NVPatternResetFlag=1;

        }


    else

        {

        //**********************************************************************
        // Loop thru all the clipping rectangles
        //**********************************************************************

        do  {

            //******************************************************************
            // Handle multi-color patterns.  For now, we just use the
            // ImageFromCpu class (memory to screen blit).
            //******************************************************************

            //******************************************************************
            // Because we handle only 8x8 brushes, it is easy to compute the
            // number of pels by which we have to rotate the brush pattern
            // right and down.  Note that if we were to handle arbitrary sized
            // patterns, this calculation would require a modulus operation.
            //
            // The brush is aligned in absolute coordinates, so we have to add
            // in the surface offset:
            //
            // NV: Since we are using Memory to Screen blits, we need to manually
            //     account for the position of the pattern on screen. So, not only
            //     do we need to factor in pptrlBrush.x/y, but also prcl->left/top;
            //     We don't care what the alignment is offscreen, because offscreen
            //     position is NOT the final destination/position.
            //******************************************************************

            xShift = pptlBrush->x - prcl->left;
            yShift = pptlBrush->y - prcl->top;

            //******************************************************************
            // Rotate pattern 'xShift' pels right
            // Rotate pattern 'yShift' pels down
            //******************************************************************

            xShift &= 7;
            yShift &= 7;

            //******************************************************************
            // We're going to do a straight of the Xbpp 8x8 pattern to the screen.
            // First we'll align it properly by copying it to a temporary buffer:
            //******************************************************************

            cjLeft  = CONVERT_TO_BYTES(xShift, ppdev);      // Number of bytes pattern
                                                            //   is shifted to the right
            cjRight = CONVERT_TO_BYTES(8, ppdev) - cjLeft;  // Number of bytes pattern
                                                            // is shifted to the left

            SrcBits = (BYTE*) &prb->aulPattern[0];          // Copy from brush buffer
            DstBits = (BYTE*) &ppdev->AlignedBrush[0];      // Copy to our aligned buffer

            DstBits += yShift * CONVERT_TO_BYTES(8, ppdev); // Starting yShift rows
            i = 8 - yShift;                                 //  down for 8 - yShift rows

            //******************************************************************
            // Now copy the pattern and align it, in 2 steps.
            // The 'left' part, and 'right' part (as well as the 'bottom' and 'top')
            // We'll start copying the 'bottom' part first.
            //******************************************************************

            do  {
                RtlCopyMemory(DstBits + cjLeft, SrcBits, cjRight);
                RtlCopyMemory(DstBits, SrcBits + cjRight, cjLeft);

                DstBits += cjLeft + cjRight;
                SrcBits += cjLeft + cjRight;

                } while (--i != 0);

            //******************************************************************
            // Now copy the 'top' part
            //******************************************************************

            DstBits = (BYTE*) &ppdev->AlignedBrush[0];      // Move to the beginning of destination

            for (; yShift != 0; yShift--)
                {
                RtlCopyMemory(DstBits + cjLeft, SrcBits, cjRight);
                RtlCopyMemory(DstBits, SrcBits + cjRight, cjLeft);

                DstBits += cjLeft + cjRight;
                SrcBits += cjLeft + cjRight;
                }

            //******************************************************************
            // Get width and height of the destination rectangle
            //******************************************************************

            width = prcl->right - prcl->left;
            height= prcl->bottom - prcl->top;

            //******************************************************************
            // Top left coordinate of destination on destination surface
            //******************************************************************

            xdst = prcl->left;
            ydst = prcl->top;

            //******************************************************************
            // Prepare to do an IMAGE_FROM_CPU blit
            //******************************************************************

            while (FreeCount < 4*4)
               FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
            FreeCount -=4*4;

            //******************************************************************
            // rop3 is a pat rop. Since we don't have color patterns in hw, we
            // treat pattern as source and thus convert to the corresponding source
            // rop. e.g. - convert PATCOPY->SRCCOPY, PATINVERT->SRCINVERT.
            //******************************************************************
            nv->subchannel[ROP_SOLID_SUBCHANNEL].nv3ContextRop.SetRop5 =
                nvBrushToSrcRopTable[rop3 >> 2];
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Point =  ( ((ydst) <<16) | ((xdst) & 0xffff) );
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.SizeOut = ( (height <<16) | width );

            //******************************************************************
            // Specifying 1 more pixel (in 16bpp) for SizeIn causes the NV engine to
            // ignore/clip the extra pixel that we send it, so that it won't
            // get included as part of the next scanline. Since we always
            // send DWords at a time, we may actually send more data to the NV
            // engine than is necessary.  So clip it by specifying a larger SizeIn
            // That is, we always send DWORDS at a time for each scanline.
            // For 8bpp, we may specify up to 3 additional pixels (which get ignored)
            //******************************************************************

            if (PixelDepth == 8)
                SizeInWidth = ((width + 3) & 0xfffc);
            else if (PixelDepth == 16)
                SizeInWidth = ((width + 1) & 0xfffe);
            else
                SizeInWidth = width;

            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.SizeIn = ( (height <<16) | (SizeInWidth) );

            //******************************************************************
            // Calculate number of dwords to output for scanline
            // This is the actual amount of data that the NV engine expects per scanline.
            // SizeInWidth is guaranteed to be a multiple of 2 (for 16bpp) and
            // a multiple of 4 (for 32bpp).  So we'll always be outputting DWORDS.
            // (No leftover words or bytes, they get clipped)
            //******************************************************************

            BytesPerDstScan = SizeInWidth * PixelDepth/8;
            DwordsPerDstScan = BytesPerDstScan / 4 ;

            //******************************************************************
            // Ptr to pattern data
            //******************************************************************

            SrcBits = (BYTE*) &ppdev->AlignedBrush[0];      // Move to the beginning of destination

            //******************************************************************
            // Get ptr to start of SRC
            //******************************************************************

            NextScan = (ULONG *)(SrcBits);

            //******************************************************************
            // We only ever support 8x8 patterns
            //******************************************************************

            BytesPerSrcScan = 8 * ppdev->cjPelSize;

            //******************************************************************
            // Amount to increment for each scanline (in dwords)
            //******************************************************************

            ScanInc = (BytesPerSrcScan+3) >> 2;      // Number of dwords to increment


            //******************************************************************
            // Output one scan at a time
            //******************************************************************

            PatternYCount = 0;

            //******************************************************************
            // 8bpp
            //******************************************************************

            if (ppdev->cjPelSize == 1)  // 8bpp

                {
                for (yscan=0;yscan < height; yscan++)
                    {
                    DwordCount  = DwordsPerDstScan;
                    ScanPtr     = NextScan;
                    EndOfScanPtr= NextScan + (2 * ppdev->cjPelSize);

                    //**********************************************************
                    // 4 Dwords at a time
                    //**********************************************************

                    while (DwordCount >= 4 )
                        {
                        while (FreeCount < 4*4)
                            FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
                        FreeCount -= 4*4;

                        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[0] = ScanPtr[0];
                        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[1] = ScanPtr[1];

                        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[2] = ScanPtr[0];
                        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[3] = ScanPtr[1];

                        DwordCount-=4;
                        }

                    //**********************************************************
                    // 1 Dword at a time
                    //**********************************************************

                    while (DwordCount > 0 )
                        {
                        while (FreeCount < 1*4)
                            FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
                        FreeCount -= 1*4;

                        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[0] = ScanPtr[0];

                        ScanPtr ++;                  // Advance 1 dwords

                        DwordCount--;

                        //******************************************************
                        // See if we've gone past 8 pixels worth (in dwords)
                        // We only handle 8x8 patterns
                        //******************************************************

                        if (ScanPtr >= EndOfScanPtr)
                            ScanPtr = NextScan;     // Reset back to beginning
                        }


                    //**********************************************************
                    // Advance to next pattern scanline
                    //**********************************************************

                    NextScan+=ScanInc;

                    //**********************************************************
                    // Check if we need to wraparound back to beginning of pattern
                    // If so, reset pattern pointer back to the beginning
                    //**********************************************************

                    PatternYCount++;
                    if (PatternYCount>=8)
                        {
                        NextScan = (ULONG *)SrcBits;
                        PatternYCount=0;
                        }

                    }

                }

            else

                {

                //**************************************************************
                // 16bpp or 32bpp -> Use Fast optimized blit version
                //**************************************************************

                //**************************************************************
                // Use Screen to Screen blits to speed up pattern copy
                // 2 main cases:
                //    Wide blits (greater than/equal 32 pixels wide)
                //    Narrow blits (less than 32 pixels wide),
                //**************************************************************

                if ( (rop3==0xf0) || (rop3==0xcc) )

                    {
                    //**********************************************************
                    // We'll be using image blit, so we need to
                    // set linear stride and offset for the source!
                    // Make sure to set it the same as the destination
                    // (Offscreen bitmap or Onscreen)
                    //**********************************************************

                    SrcOffset = ppdev->CurrentDestOffset;
                    SrcStride = ppdev->CurrentDestPitch;
                    (ppdev->pfnSetSourceBase)(ppdev,SrcOffset,SrcStride);


                    //**********************************************************
                    // Copy the pattern on screen, then use imageblit
                    // to copy the rest of it (faster than imagefromcpu)
                    //**********************************************************

                    yscan=0;
                    RemainingScanlines=height;

                    //**********************************************************
                    // rop3 is a pat rop. Since we don't have color patterns in hw, we
                    // treat pattern as source and thus convert to the corresponding source
                    // rop. e.g. - convert PATCOPY->SRCCOPY, PATINVERT->SRCINVERT.
                    //**********************************************************

                    while (FreeCount < 1*4)
                       FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
                    FreeCount -=1*4;

                    nv->subchannel[ROP_SOLID_SUBCHANNEL].nv3ContextRop.SetRop5 =
                        nvBrushToSrcRopTable[rop3 >> 2];

                    //**********************************************************
                    // Do the first 8 scanlines of this pattern blit
                    //**********************************************************

                    while ( (yscan < 8) && (yscan < height))
                        {

                        //******************************************************
                        // Get remaining number of pixels to do on this scanline
                        // Also get start of current pattern scanline
                        //******************************************************

                        RemainingPixels = width;
                        ScanPtr         = NextScan;

                        //******************************************************
                        // Get blit destination coordinate
                        //******************************************************

                        CurrentXdst = xdst;
                        CurrentYdst = ydst+yscan;

                        //******************************************************
                        // Speed up WIDE blits
                        //******************************************************

                        if ( width >=32 )
                            {
                            //**************************************************
                            // Prepare to do an IMAGE_FROM_CPU blit
                            // We'll be using it to copy the first 8 pixels
                            //**************************************************

                            while (FreeCount < 3*4)
                               FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
                            FreeCount -=3*4;

                            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Point   = ( ((CurrentYdst) <<16) | ((xdst) & 0xffff) );
                            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.SizeOut = ( (1 <<16) | 8 );
                            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.SizeIn  = ( (1 <<16) | 8 );

                            //**************************************************
                            // Copy first 8 pixels using ImageFromCpu (we only handle 8x8 brushes)
                            //**************************************************


                            if (ppdev->cjPelSize == 2)  // 16bpp
                                {
                                while (FreeCount < 4*4)
                                    FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
                                FreeCount -= 4*4;

                                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[0] = ScanPtr[0];
                                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[1] = ScanPtr[1];

                                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[2] = ScanPtr[2];
                                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[3] = ScanPtr[3];

                                CurrentXdst         += 8;
                                RemainingPixels     -= 8;
                                }
                            else
                                {                       // 32bpp
                                while (FreeCount < 8*4)
                                    FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
                                FreeCount -= 8*4;

                                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[0] = ScanPtr[0];
                                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[1] = ScanPtr[1];

                                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[2] = ScanPtr[2];
                                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[3] = ScanPtr[3];

                                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[4] = ScanPtr[4];
                                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[5] = ScanPtr[5];

                                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[6] = ScanPtr[6];
                                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[7] = ScanPtr[7];

                                CurrentXdst         += 8;
                                RemainingPixels     -= 8;
                                }


                            //**************************************************
                            // Set Rop to srccopy
                            //**************************************************

                            while (FreeCount < 1*4)
                                FreeCount = nv->subchannel[BLIT_SUBCHANNEL].control.Free;
                            FreeCount -= 1*4;

                            nv->subchannel[ROP_SOLID_SUBCHANNEL].nv3ContextRop.SetRop5 = 0xcccc ;

                            //**************************************************
                            // We've already blitted the first 8 pixels
                            // We only need to blit 24 more pixels to create
                            // the 32 pixel group.  ( 8 pixels * 3 times = 24)
                            //**************************************************

                            BUILD_PIXEL_GROUP(24,8,3);

                            //**************************************************
                            // 32pixel group is now available
                            // See if we can create the 128 pixel group
                            //**************************************************

                            BUILD_PIXEL_GROUP(128,32,4);

                            //**************************************************
                            // More than 128 pixels remaining? (7 -> Divide by 128)
                            // If so, we can blit it all at once
                            //**************************************************

                            COPY_PIXEL_GROUP(128, RemainingPixels>>7);

                            //**************************************************
                            // More than 32 pixels remaining? (5 -> Divide by 32)
                            // If so, we can blit it all at once
                            //**************************************************

                            COPY_PIXEL_GROUP(32, RemainingPixels>>5);

                            //**************************************************
                            // More than 8 pixels remaining? (3 -> Divide by 8)
                            // If so, we can blit it all at once
                            //**************************************************

                            COPY_PIXEL_GROUP(8, RemainingPixels>>3);

                            //**************************************************
                            // Check for remaining pixels
                            //**************************************************

                            if (RemainingPixels)
                                {
                                //**********************************************
                                // Copy  remaining pixels
                                //**********************************************

                                while (FreeCount < 3*4)
                                    FreeCount = nv->subchannel[BLIT_SUBCHANNEL].control.Free;
                                FreeCount -= 3*4;

                                nv->subchannel[BLIT_SUBCHANNEL].nv1ImageBlit.ControlPointIn = ( (CurrentYdst << 16) | (xdst & 0xffff) );
                                nv->subchannel[BLIT_SUBCHANNEL].nv1ImageBlit.ControlPointOut = ( ( (CurrentYdst ) << 16) | ((CurrentXdst ) & 0xffff) );
                                nv->subchannel[BLIT_SUBCHANNEL].nv1ImageBlit.Size = ( (1 << 16) | (RemainingPixels) );
                                }
                            }


                        else

                            {

                            //**************************************************
                            // Speed up TALL blits (less than 32 pixels wide)
                            //**************************************************

                            while (FreeCount < 3*4)
                               FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
                            FreeCount -=3*4;


                            //**************************************************
                            // Make sure to adjust the SizeInWidth appropriately
                            //**************************************************

                            if (PixelDepth == 16)
                                SizeInWidth = ((width + 1) & 0xfffe);
                            else  // Pixel Depth == 32
                                SizeInWidth = width;

                            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Point   = ( ((CurrentYdst) <<16) | ((xdst) & 0xffff) );
                            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.SizeOut = ( (1 <<16) | (width) );
                            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.SizeIn  = ( (1 <<16) | (SizeInWidth) );

                            //**************************************************
                            // Copy pixels using ImageFromCpu
                            // CAREFUL: !! FreeCount can NOT go past 128-4 bytes !!
                            //             (Maximum width here is 31)
                            //**************************************************


                            if (ppdev->cjPelSize == 2)  // 16bpp
                                {
                                while (FreeCount < (USHORT)(SizeInWidth>>1)*4)
                                    FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
                                FreeCount -= (USHORT)(SizeInWidth>>1)*4;

                                for (i=0;i<(SizeInWidth>>1);i++)
                                    nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[i] = ScanPtr[(i & 0x3)];
                                }
                            else
                                {                       // 32bpp
                                while (FreeCount < (USHORT)width*4)
                                    FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
                                FreeCount -= (USHORT)width*4;

                                for (i=0;i<width;i++)
                                    nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[i] = ScanPtr[(i & 0x7)];
                                }

                            }


                        //******************************************************
                        // Advance to next pattern scanline
                        //******************************************************

                        NextScan+=ScanInc;

                        //******************************************************
                        // Check if we need to wraparound back to beginning of pattern
                        // If so, reset pattern pointer back to the beginning
                        //******************************************************

                        PatternYCount++;
                        if (PatternYCount>=8)
                            {
                            NextScan = (ULONG *)SrcBits;
                            PatternYCount=0;
                            }

                        //******************************************************
                        // Advance to next scanline
                        //******************************************************

                        yscan++;
                        RemainingScanlines--;
                        }


                    //**********************************************************
                    // Only need to reset the ROP if this is the tall case
                    //**********************************************************

                    if ( width < 32 )
                        {
                        //******************************************************
                        // Set Rop to srccopy
                        //******************************************************

                        while (FreeCount < 1*4)
                            FreeCount = nv->subchannel[BLIT_SUBCHANNEL].control.Free;
                        FreeCount -= 1*4;

                        nv->subchannel[ROP_SOLID_SUBCHANNEL].nv3ContextRop.SetRop5 = 0xcccc ;
                        }

                    //**********************************************************
                    // If there are more then 8 scanlines, use imageblit to
                    // blit the rest
                    //**********************************************************

                    if (RemainingScanlines)

                        {
                        //******************************************************
                        // Update CurrentX and CurrentY
                        //******************************************************

                        CurrentXdst = xdst;
                        CurrentYdst = ydst+yscan;

                        //******************************************************
                        // We've already blitted the first 8 scanlines.
                        // We only need to blit 24 more scanlines to create
                        // the 32 pixel block.  ( 8 pixels * 3 times = 24)
                        //******************************************************

                        BUILD_PIXEL_BLOCK(24,width,8,3);

                        //******************************************************
                        // 32pixel group is now available
                        // See if we can create the 128 pixel block
                        //******************************************************

                        BUILD_PIXEL_BLOCK(128,width,32,4);

                        //******************************************************
                        // More than 128 scanlines remaining? (7 -> Divide by 128)
                        // If so, we can blit it all at once
                        //******************************************************

                        COPY_PIXEL_BLOCK(128, width, RemainingScanlines>>7);

                        //******************************************************
                        // More than 32 scanlines remaining? (5 -> Divide by 32)
                        // If so, we can blit it all at once
                        //******************************************************

                        COPY_PIXEL_BLOCK(32, width, RemainingScanlines>>5);

                        //******************************************************
                        // More than 8 scanlines remaining? (3 -> Divide by 8)
                        // If so, we can blit it all at once
                        //******************************************************

                        COPY_PIXEL_BLOCK(8, width, RemainingScanlines>>3);

                        //******************************************************
                        // Check for remaining scanlines
                        //******************************************************

                        if (RemainingScanlines)
                            {
                            //**************************************************
                            // Copy remaining Scanlines
                            //**************************************************

                            while (FreeCount < 3*4)
                                FreeCount = nv->subchannel[BLIT_SUBCHANNEL].control.Free;
                            FreeCount -= 3*4;

                            nv->subchannel[BLIT_SUBCHANNEL].nv1ImageBlit.ControlPointIn = ( (ydst << 16) | ((CurrentXdst) & 0xffff) );
                            nv->subchannel[BLIT_SUBCHANNEL].nv1ImageBlit.ControlPointOut = ( ( (CurrentYdst ) << 16) | ((CurrentXdst ) & 0xffff) );
                            nv->subchannel[BLIT_SUBCHANNEL].nv1ImageBlit.Size = ( ((RemainingScanlines) << 16) | (width) );
                            }


                        }


                    }


                else


                    {

                    //**********************************************************
                    // 16bpp or 32bpp -> Use slower ImageFromCpu version
                    //**********************************************************

                    for (yscan=0;yscan < height; yscan++)
                        {

                        //******************************************************
                        // Init values per each pattern scanline
                        // 8bpp  -> 8 pixels * 1 dword/4 pixels = 2 dwords per pattern scanline
                        // 16bpp -> 8 pixels * 1 dword/2 pixels = 4 dwords per pattern scanline
                        // 32bpp -> 8 pixels * 1 dword/1 pixel  = 8 dwords per pattern scanline
                        //    or just multiply 2 * Bytes Per Pixel for the same result
                        //******************************************************

                        DwordCount  = DwordsPerDstScan;
                        ScanPtr     = NextScan;
                        EndOfScanPtr= NextScan + (2 * ppdev->cjPelSize);

                        //******************************************************
                        // 8x8 color pattern
                        // We can only send 4 dwords at a time for 16bpp
                        // But we can blast out 8 dwords at a time for 32bpp
                        // (16bpp-> 2 pixels per dword, 32bpp -> 1 pixel per dword)
                        //******************************************************

                        if (ppdev->cjPelSize == 4)
                            {
                            //**************************************************
                            // 8 Dwords at a time (Valid for 32bpp mode ONLY!!)
                            //**************************************************

                            while (DwordCount >= 8 )
                                {
                                while (FreeCount < 8*4)
                                    FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
                                FreeCount -= 8*4;

                                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[0] = ScanPtr[0];
                                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[1] = ScanPtr[1];

                                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[2] = ScanPtr[2];
                                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[3] = ScanPtr[3];

                                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[4] = ScanPtr[4];
                                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[5] = ScanPtr[5];

                                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[6] = ScanPtr[6];
                                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[7] = ScanPtr[7];

                                DwordCount-=8;
                                }
                            }


                        //******************************************************
                        // 4 Dwords at a time
                        //******************************************************

                        while (DwordCount >= 4 )
                            {
                            while (FreeCount < 4*4)
                                FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
                            FreeCount -= 4*4;

                            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[0] = ScanPtr[0];
                            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[1] = ScanPtr[1];

                            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[2] = ScanPtr[2];
                            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[3] = ScanPtr[3];

                            DwordCount-=4;
                            }

                        //******************************************************
                        // Output any remaining dwords...
                        // Need to unroll and make more efficient !!!
                        //******************************************************

                        while (DwordCount > 0 )
                            {

                            while (FreeCount < 1*4)
                                FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
                            FreeCount -= 1*4;

                            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[0] = ScanPtr[0];

                            ScanPtr ++;                  // Advance 1 dwords

                            DwordCount--;

                            //**************************************************
                            // See if we've gone past 8 pixels worth (in dwords)
                            // We only handle 8x8 patterns
                            //**************************************************

                            if (ScanPtr >= EndOfScanPtr)
                                ScanPtr = NextScan;     // Reset back to beginning
                            }

                        //******************************************************
                        // Advance to next pattern scanline
                        //******************************************************

                        NextScan+=ScanInc;

                        //******************************************************
                        // Check if we need to wraparound back to beginning of pattern
                        // If so, reset pattern pointer back to the beginning
                        //******************************************************

                        PatternYCount++;
                        if (PatternYCount>=8)
                            {
                            NextScan = (ULONG *)SrcBits;
                            PatternYCount=0;
                            }

                        } // for yscan...


                    }  // slow image from cpu ...


                }  // 32bpp


            //******************************************************************
            // Onto the next clipping rectangle
            //******************************************************************

            prcl++;

            } while (--c != 0);

        } // Multi-color pattern

    //**************************************************************************
    // Update the global free count
    //**************************************************************************

    ppdev->NVFreeCount = FreeCount;

    } // End of FillPattern routine



//******************************************************************************
//
//  Function:   NV3MonoScanlineImageTransfer
//
//  Routine Description:
//
//       Low-level routine for transferring a bitmap image via RENDER_GDI0_RECT_AND_TEXT
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NV3MonoScanlineImageTransfer(
PDEV*   ppdev,
BYTE*   pjSrc,              // Source pointer
ULONG   NumDwordsPerScan,
USHORT* FreeCountPtr)


    {
    Nv3ChannelPio  *nv  = (Nv3ChannelPio *)ppdev->pjMmBase;
    USHORT FreeCount;
    ULONG MonoPixelData1;
    ULONG MonoPixelData2;
    ULONG *SrcDataPtr;

    //**************************************************************************
    // Init FreeCount variable
    //**************************************************************************

    FreeCount=(*FreeCountPtr);

    //**************************************************************************
    // Get Dword Ptr to Src Data
    //**************************************************************************

    SrcDataPtr = (DWORD *)pjSrc;

    //**************************************************************************
    // Handle groups of 16 dwords at a time
    //**************************************************************************

    while (NumDwordsPerScan>= 16)
        {

        while (FreeCount < 16*4)
           FreeCount = nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].control.Free;
        FreeCount -= 16*4;

        MonoPixelData1 = SrcDataPtr[0];
        MonoPixelData2 = SrcDataPtr[1];
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.MonochromeColor01E[0] = MonoPixelData1;
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.MonochromeColor01E[1] = MonoPixelData2;

        MonoPixelData1 = SrcDataPtr[2];
        MonoPixelData2 = SrcDataPtr[3];
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.MonochromeColor01E[2] = MonoPixelData1;
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.MonochromeColor01E[3] = MonoPixelData2;

        MonoPixelData1 = SrcDataPtr[4];
        MonoPixelData2 = SrcDataPtr[5];
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.MonochromeColor01E[4] = MonoPixelData1;
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.MonochromeColor01E[5] = MonoPixelData2;

        MonoPixelData1 = SrcDataPtr[6];
        MonoPixelData2 = SrcDataPtr[7];
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.MonochromeColor01E[6] = MonoPixelData1;
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.MonochromeColor01E[7] = MonoPixelData2;

        MonoPixelData1 = SrcDataPtr[8];
        MonoPixelData2 = SrcDataPtr[9];
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.MonochromeColor01E[8] = MonoPixelData1;
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.MonochromeColor01E[9] = MonoPixelData2;

        MonoPixelData1 = SrcDataPtr[10];
        MonoPixelData2 = SrcDataPtr[11];
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.MonochromeColor01E[10] = MonoPixelData1;
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.MonochromeColor01E[11] = MonoPixelData2;

        MonoPixelData1 = SrcDataPtr[12];
        MonoPixelData2 = SrcDataPtr[13];
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.MonochromeColor01E[12] = MonoPixelData1;
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.MonochromeColor01E[13] = MonoPixelData2;

        MonoPixelData1 = SrcDataPtr[14];
        MonoPixelData2 = SrcDataPtr[15];
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.MonochromeColor01E[14] = MonoPixelData1;
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.MonochromeColor01E[15] = MonoPixelData2;

        NumDwordsPerScan-=16;
        SrcDataPtr += 16;

        }

    //**************************************************************************
    // Handle groups of 8 dwords at a time
    //**************************************************************************

    while (NumDwordsPerScan>= 8)
        {

        while (FreeCount < 8*4)
           FreeCount = nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].control.Free;
        FreeCount -= 8*4;

        MonoPixelData1 = SrcDataPtr[0];
        MonoPixelData2 = SrcDataPtr[1];
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.MonochromeColor01E[0] = MonoPixelData1;
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.MonochromeColor01E[1] = MonoPixelData2;

        MonoPixelData1 = SrcDataPtr[2];
        MonoPixelData2 = SrcDataPtr[3];
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.MonochromeColor01E[2] = MonoPixelData1;
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.MonochromeColor01E[3] = MonoPixelData2;

        MonoPixelData1 = SrcDataPtr[4];
        MonoPixelData2 = SrcDataPtr[5];
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.MonochromeColor01E[4] = MonoPixelData1;
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.MonochromeColor01E[5] = MonoPixelData2;

        MonoPixelData1 = SrcDataPtr[6];
        MonoPixelData2 = SrcDataPtr[7];
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.MonochromeColor01E[6] = MonoPixelData1;
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.MonochromeColor01E[7] = MonoPixelData2;

        NumDwordsPerScan -=8;
        SrcDataPtr += 8;

        }

    //**************************************************************************
    // Handle groups of 4 dwords at a time
    //**************************************************************************

    while (NumDwordsPerScan>= 4)
        {

        while (FreeCount < 4*4)
           FreeCount = nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].control.Free;
        FreeCount -= 4*4;

        MonoPixelData1 = SrcDataPtr[0];
        MonoPixelData2 = SrcDataPtr[1];
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.MonochromeColor01E[0] = MonoPixelData1;
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.MonochromeColor01E[1] = MonoPixelData2;

        MonoPixelData1 = SrcDataPtr[2];
        MonoPixelData2 = SrcDataPtr[3];
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.MonochromeColor01E[2] = MonoPixelData1;
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.MonochromeColor01E[3] = MonoPixelData2;

        NumDwordsPerScan-=4;
        SrcDataPtr += 4;

        }

    //**************************************************************************
    // Handle any remaining dwords
    //**************************************************************************

    while (NumDwordsPerScan > 0)
        {
        while (FreeCount < 4)
            FreeCount = nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].control.Free;
        FreeCount -= 4;

        MonoPixelData1 = SrcDataPtr[0];
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.MonochromeColor01E[0] = MonoPixelData1;

        NumDwordsPerScan--;

        SrcDataPtr ++;
        }

    //**************************************************************************
    // Update cached FreeCount variable
    //**************************************************************************

    *FreeCountPtr = FreeCount;
    }





//******************************************************************************
//
//  Function:   NV3Xfer1bpp
//
//  Routine Description:
//
//     This routine colour expands a monochrome bitmap, possibly with different
//     Rop2's for the foreground and background.  It will be called in the
//     following cases:
//
//     1) To colour-expand the monochrome text buffer for the vFastText routine.
//     2) To blt a 1bpp source with a simple Rop2 between the source and
//        destination.
//  x  3) To blt a true Rop3 when the source is a 1bpp bitmap that expands to
//        white and black, and the pattern is a solid colour.
//     4) To handle a true Rop4 that works out to be two Rop2's between the
//        pattern and destination.
//
//     Needless to say, making this routine fast can leverage a lot of
//     performance.
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NV3Xfer1bpp(       // Type FNXFER
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // List of destination rectangles, in relative
                        //   coordinates
ROP4        rop4,       // rop4
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo,
ULONG       PatternColor,     // Solid Color of pattern
BLENDOBJ*   pBlendObj)

    {
    ULONG   ulHwForeMix;
    ULONG   ulHwBackMix;
    LONG    dxSrc;
    LONG    dySrc;
    LONG    cx;
    LONG    cy;
    LONG    lSrcDelta;
    BYTE*   pjSrcScan0;
    BYTE*   pjSrc;
    LONG    cjSrc;
    LONG    xLeft;
    LONG    yTop;
    LONG    xBias;

    Nv3ChannelPio  *nv  = (Nv3ChannelPio *)ppdev->pjMmBase;
    ULONG Color0;
    ULONG Color1;
    ULONG AlphaEnableValue;
    ULONG NumBytesPerScan;
    ULONG NumDwordsPerScan;
    ULONG OffsetOfLastDword;
    ULONG LastDword;
    ULONG PixelDepth;
    ULONG width;
    ULONG height;
    USHORT FreeCount;
    ULONG SizeInWidth;
    ULONG rop3;
    ULONG ClipLeft;
    ULONG ClipTop;
    ULONG ClipWidth;
    ULONG ClipHeight;
    RECTL DstRect;

    //**************************************************************************
    // Make sure following conditions are true before continuing on
    //**************************************************************************

    ASSERTDD(pBlendObj == NULL, "Can't handle Alpha Blends");
    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(pptlSrc != NULL && psoSrc != NULL, "Can't have NULL sources");
    ASSERTDD(((((rop4 & 0xff00) >> 8) == (rop4 & 0xff)) || (rop4 == 0xaacc)),
             "Expect weird rops only when opaquing");

    //**************************************************************************
    // Get pixel depth for the current mode.
    // Then determine the ALPHA_CHANNEL enable value
    //**************************************************************************

    AlphaEnableValue = ppdev->AlphaEnableValue;

    //**************************************************************************
    // Init foreground and background color
    //**************************************************************************

    Color0 = pxlo->pulXlate[0] | (AlphaEnableValue); // Background color
    Color1 = pxlo->pulXlate[1] | (AlphaEnableValue); // Foreground color

    //**************************************************************************
    // Find the pitch and starting location of the source mono (pattern) bitmap
    //
    // NOTE:  Normally, we'd need to check if this source SURFOBJ was a
    //        standard DIB or a DFB that was moved to system memory.
    //        However, since we don't store 1bpp SURFOBJs in offscreen memory
    //        (see drvCreateDeviceBitmap), we know that the this source SURFOBJ
    //        is just a plain standard DIB. (i.e.  we don't need to get the
    //        'lDelta' and 'pvScan0' values from psoSrc->dhsurf->pso->lDelta
    //        and psoSrc->dhsurf->pso->pvScan0.
    //
    //**************************************************************************

    lSrcDelta  = psoSrc->lDelta;
    pjSrcScan0 = psoSrc->pvScan0;

    //**************************************************************************
    // Safety check  ...check and see if source bitmap is dword aligned
    // This is a requirement....bitmap should never start on non-dword alignment..
    // Otherwise, that will invalidate some assumptions made...we currently
    // always read dword multiples...at dword alignments...if source bitmap
    // doesn't start on a dword boundary, then we might not be able to get
    // the first dword of data on a dword boundary ...Send back to DIBengine?
    //**************************************************************************

    ASSERTDD(!((ULONG_PTR) pjSrcScan0 & 0x3), "Unaligned source bitmap");

    //**********************************************************************
    // Init FreeCount variable
    //**********************************************************************

    FreeCount = ppdev->NVFreeCount;

    //**********************************************************************
    // Adjust dest rect in case it is in offscreen memory
    //**********************************************************************

    DstRect.top = prclDst->top;
    DstRect.left = prclDst->left;
    DstRect.right = prclDst->right;
    DstRect.bottom = prclDst->bottom;

    do  {
        //**********************************************************************
        //
        //  First, we need to determine the XBIAS required (where the starting bit
        //  of the monochrome source bitmap is located).  XBIAS is affected
        //  by 3 values as follows:
        //
        //          1) pptlSrc->x    ( value x1 shown below )
        //
        //                  This is simply the bit at which we want to
        //                  start in the monochrome pattern bitmap
        //
        //          2) prclDst->x    ( value x2 shown below )
        //
        //                  Location of the original unclipped destination rectangle
        //
        //          3) prcl->x       ( value x3 shown below)
        //
        //                  Current clip rectangle with coordinates relative
        //                  to prclDst
        //
        //  Screen Origin
        //  +--------------------------------------------------------------->
        //  |
        //  |
        //  |           x2 = prclDst->left
        //  |           +-----------------------------------------------
        //  |           |                             ^                 |-Original
        //  |           |                             | dySrc           |  Unclipped
        //  |           |                             |                 |   Destination
        //  |           |         x3 = prcl->left     v                 |    Rectangle
        //  |           |         +------------       -                 |
        //  |           |         |            |                        |
        //  |           |<-dxSrc->|            |                        |
        //  |           |         |            |                        |
        //  |           |         |            |-Current                |
        //  |           |         |            |  Clip                  |
        //  |           |          ------------    Rectangle            |
        //  |           |                                               |
        //  |           |                                               |
        //  |           |                                               |
        //  |            -----------------------------------------------
        //  |
        //  v
        //
        //            Source MonoChrome Bitmap
        //          +--------+--------+--------+------->
        //          |00011001|00010010|00010011|
        //          |00011001|00010010|00010011|
        //          |00011001|00010010|00010011|
        //          |00011001|00010010|00010011|
        //          |           ^
        //          v           |
        //                      |
        //                      |
        //          |-- x1 ---->|
        //
        //**********************************************************************

        //**********************************************************************
        //
        // Once we determine the starting bit in the monochrome bitmap,
        // we can calculate the XBIAS value.  The left portion of the 1st source
        // dword that we will read will end up getting clipped by hardware.
        // This will allow us to NOT have to align subsequent source data.
        //
        //    xbias =  ( x1 + (x3 - x2) ) & 0x1f
        //
        //    xbias =  ( x1 + (dxSrc)   ) & 0x1f  ( starting bit position in dword)
        //                                                 from 0 - 31
        //
        //           --------------------------
        //          |00011001|00010010|00010011|  1st dword of source data
        //           --------------------------
        //          |               |          |
        //          |<--- xbias --->|          |
        //          |               |   This   |
        //          | This region is| region is|
        //          |   clipped     |  drawn   |
        //          v               v          v
        //
        //**********************************************************************

        //**********************************************************************
        // Set initial destination coordinates of blit
        //**********************************************************************

        yTop  = prcl->top;
        xLeft = prcl->left;

        //**********************************************************************
        // Init dimensions of clip rectangle.
        //**********************************************************************

        ClipTop = prcl->top;
        ClipLeft = prcl->left;

        ClipHeight = prcl->bottom - prcl->top;
        ClipWidth = prcl->right - prcl->left;

        //**********************************************************************
        // Find starting bit location of pattern.  We really only care about
        // the dword alignment (bottom 5 bits) of this value.
        //**********************************************************************

        dxSrc = prcl->left - DstRect.left;
        dySrc = prcl->top  - DstRect.top;

        //**********************************************************************
        // Determine the bias of the bitmap
        //**********************************************************************

        xBias = ( (pptlSrc->x + dxSrc) & 0x1f);     // Value from 0 thru 31
        if (xBias != 0)
            {
            //******************************************************************
            // NV: Set the hardware clip rectangle so we don't have to
            //     manually align the pattern bitmap.  Then make sure
            //     to adjust the starting point of the blit to account
            //     for this xbias.
            //
            // We should probably remove the  if (xBias !=0) statement
            // since it's not necessary.
            //******************************************************************

            xLeft -= xBias;
            }

        //**********************************************************************
        // Get width and height of the destination rectangle
        // Then calculate the DWORDS we'll send to the NV engine
        // (we always output DWORDS at a time), and the number of bytes per scan
        // SizeInWidth will always be a multiple of 32 pixels (1 dword's worth)
        //
        // Remember, xLeft has now been adjusted to account for the XBias value
        //**********************************************************************

        width = prcl->right - xLeft;
        height= prcl->bottom - yTop;

        //**********************************************************************
        // Get values required by NV hardware engine
        //**********************************************************************

        SizeInWidth = (width + 31) & 0xffe0;    // Always a multiple of 32 pixels
        NumBytesPerScan = SizeInWidth >> 3;     // Divide mono pixels by 8 to get bytes


        //**********************************************************************
        // MUST set the pattern appropriately!
        //**********************************************************************

        while (FreeCount < 5*4)
           FreeCount = nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].control.Free;
        FreeCount -= 5*4;

        nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].nv1ImagePattern.SetMonochromeShape = NV018_SET_MONOCHROME_SHAPE_64X_1Y;
        nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].nv1ImagePattern.SetMonochromeColor0 = ( PatternColor | AlphaEnableValue );
        nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].nv1ImagePattern.SetMonochromeColor1 = ( PatternColor | AlphaEnableValue );
        nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].nv1ImagePattern.SetMonochromePattern0 = 0xffffffff;
        nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].nv1ImagePattern.SetMonochromePattern1 = 0xffffffff;


        //**********************************************************************
        // Get Rop3 value from Rop4
        //**********************************************************************

        rop3 = (ULONG)((BYTE)rop4);

        while (FreeCount < 1*4)
            FreeCount = nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].control.Free;
        FreeCount -= 1*4;

        nv->subchannel[ROP_SOLID_SUBCHANNEL].nv3ContextRop.SetRop5 = rop3;

        //**********************************************************************
        // Prep the monster class text object (rendergdi0RectAndText)
        //**********************************************************************

        while (FreeCount < 7*4)
            FreeCount = nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].control.Free;
        FreeCount -= 7*4;

        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.ClipPoint0E = ((ClipTop << 16) | (ClipLeft & 0xffff) );
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.ClipPoint1E = (((ClipTop+ClipHeight)<<16) | (ClipLeft+ClipWidth));

        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.Color0E = Color0;
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.Color1E = Color1;

        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.SizeInE = ( (height <<16) | SizeInWidth );
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.SizeOutE = ( (height <<16) | width );
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.PointE =  ( (yTop <<16) | (xLeft & 0xffff) );

        //**********************************************************************
        // Get starting byte address of source pattern bitmap
        // Once we have the starting byte address, we can get the starting dword address
        //
        // ?: Is it possible that pptlSrc->y + dySrc will go past
        //    end of Source Bitmap??
        //**********************************************************************

        pjSrc = pjSrcScan0 + (pptlSrc->y + dySrc) * lSrcDelta
                           + ((pptlSrc->x + dxSrc) >> 3);

        (ULONG_PTR)pjSrc &= ~0x3;

        //**********************************************************************
        // Get values pertinent for each scanline
        //**********************************************************************

        NumDwordsPerScan = SizeInWidth / 32;
        OffsetOfLastDword = NumDwordsPerScan << 2;

        //**********************************************************************
        //
        // For performance, we have 2 main objectives as follows:
        //
        //   a) When reading src data, we'd like it to be dword aligned
        //   b) When outputting data, we'd like to output dwords as much as possible
        //
        // With that in mind, we accomplish objective (a) by calculating an
        // xbias value and reading the dword that the first byte of source data
        // is contained in.  That is, we'll grab the first dword of source data
        // and clip the left part of it using the hardware clip rectangle.
        // As a result, any subsequent reads of src data will not require
        // alignment.
        //
        // Example:
        //          Src data begins here --+
        //          at this bit            |
        //                                 v
        //           -----------------------------------
        //          |        |        |        |        |   1st dword of src data
        //           -----------------------------------
        //            byte 0    byte1    byte2    byte3
        //
        //          |<------ xbias ------->|
        //                                 |
        //                                 |<-- used -->|
        //                                 |    data
        //          |<- hardware clipped ->|
        //
        //
        // Objective (b) is accomplished by examining how many dwords we
        // need to output.  The key here is to make sure we don't read past
        // the end of the source bitmap. If the number of bytes we need to
        // output is a dword multiple, then we don't need to worry about it.
        // However, if it's not, we need to check the last couple of bytes
        // and not read past the end of the src data. Otherwise, we'll
        // generate a protection fault. This is done simply by using
        // a switch statement that handles 0,1,2, or 3 remaining bytes of src data.
        //
        //          Switch (Number Of src bytes left)
        //              0:  We are dword aligned already
        //              1:  Just read 1 more byte
        //              2:  Just read 2 more bytes
        //              3:  just read 3 more bytes
        //
        //**********************************************************************


        //**********************************************************************
        // Get src data, depending on how many bytes we will output
        // TO DO:  Since we now read the starting dword of the source bitmap
        //         (instead of the starting byte), isn't it true that
        //         we don't need to worry about straggling bytes going past
        //         end of bitmap...i.e. bitmaps are always allocated as
        //         multiples of dwords?  VERIFY!
        //
        //**********************************************************************


        switch (NumBytesPerScan & 3)
            {

            //******************************************************************
            // Output dwords at a time, then output last 3 bytes of data (in last dword)
            //******************************************************************

            case 3:
                do  {
                    if (NumDwordsPerScan > 0)
                        NV3MonoScanlineImageTransfer(ppdev, pjSrc, NumDwordsPerScan,&FreeCount);

                    //**********************************************************
                    // Store bytes in reverse order (not necessary for NV?)
                    //**********************************************************

                    LastDword = (ULONG) (*(pjSrc + OffsetOfLastDword))  |
                            (*(pjSrc + OffsetOfLastDword + 1) << 8) |
                            (*(pjSrc + OffsetOfLastDword + 2) << 16);

                    NV3MonoScanlineImageTransfer(ppdev, (BYTE *)&LastDword, 1,&FreeCount);
                    pjSrc += lSrcDelta;

                    } while (--height != 0);
                break;

            //******************************************************************
            // Output dwords at a time, then output last 2 bytes of data (in last dword)
            //******************************************************************

            case 2:
                do  {
                    if (NumDwordsPerScan > 0)
                        NV3MonoScanlineImageTransfer(ppdev, pjSrc, NumDwordsPerScan,&FreeCount);

                    //**********************************************************
                    // Store bytes in reverse order (not necessary for NV?)
                    //**********************************************************

                    LastDword = (ULONG) (*(pjSrc + OffsetOfLastDword))  |
                            (*(pjSrc + OffsetOfLastDword + 1) << 8);

                    NV3MonoScanlineImageTransfer(ppdev, (BYTE *)&LastDword, 1,&FreeCount);
                    pjSrc += lSrcDelta;

                    } while (--height != 0);
                break;

            //******************************************************************
            // Output dwords at a time, then output last byte of data (in last dword)
            //******************************************************************

            case 1:
                do  {
                    if (NumDwordsPerScan > 0)
                        NV3MonoScanlineImageTransfer(ppdev, pjSrc, NumDwordsPerScan,&FreeCount);

                    //**********************************************************
                    // Store bytes in reverse order (not necessary for NV?)
                    //**********************************************************

                    LastDword = (ULONG) (*(pjSrc + OffsetOfLastDword));

                    NV3MonoScanlineImageTransfer(ppdev, (BYTE *)&LastDword, 1,&FreeCount);
                    pjSrc += lSrcDelta;

                    } while (--height != 0);
                break;

            //******************************************************************
            // The amount of data we will send is already a multiple of 4.
            // We will blast out all data in dwords
            //******************************************************************

            case 0:
                do  {
                    NV3MonoScanlineImageTransfer(ppdev, pjSrc,NumDwordsPerScan,&FreeCount);
                    pjSrc += lSrcDelta;

                    } while (--height != 0);
                break;

            } // Switch (NumBytesPerScan)

        prcl++;
        } while (--c != 0); // Next Clipping rectangle


    //**************************************************************************
    // Update global free count
    //**************************************************************************

    ppdev->NVFreeCount = FreeCount;

    }


//******************************************************************************
//
//  Function:   NV3_Send_Data
//
//  Routine Description:
//
//       Low-level routine for transferring a bitmap image via IMAGE_MONO_FROM_CPU
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NV3_Send_Data(
PDEV*   ppdev,
ULONG*  SrcDataPtr,              // Source pointer
ULONG   PixelCount,
USHORT* FreeCountPtr)


    {
    Nv3ChannelPio  *nv  = (Nv3ChannelPio *)ppdev->pjMmBase;
    USHORT FreeCount;
    ULONG TempPixelData1;
    ULONG TempPixelData2;
    ULONG DwordCount;

    DwordCount = (PixelCount+3)/4;

    //**************************************************************************
    // Read FreeCount for the first time
    //**************************************************************************

    FreeCount = *FreeCountPtr;

    //**************************************************************************
    // Output next group of 16 dwords
    //**************************************************************************

    while (DwordCount >= 16)
        {
        DwordCount -=16;

        while (FreeCount < 16*4)
            FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
        FreeCount -=16*4;

        TempPixelData1 = SrcDataPtr[0];
        TempPixelData2 = SrcDataPtr[1];
        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[0] =  TempPixelData1;
        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[1] =  TempPixelData2;
        TempPixelData1 = SrcDataPtr[2];
        TempPixelData2 = SrcDataPtr[3];
        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[2] =  TempPixelData1;
        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[3] =  TempPixelData2;
        TempPixelData1 = SrcDataPtr[4];
        TempPixelData2 = SrcDataPtr[5];
        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[4] =  TempPixelData1;
        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[5] =  TempPixelData2;
        TempPixelData1 = SrcDataPtr[6];
        TempPixelData2 = SrcDataPtr[7];
        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[6] =  TempPixelData1;
        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[7] =  TempPixelData2;
        TempPixelData1 = SrcDataPtr[8];
        TempPixelData2 = SrcDataPtr[9];
        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[8] =  TempPixelData1;
        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[9] =  TempPixelData2;
        TempPixelData1 = SrcDataPtr[10];
        TempPixelData2 = SrcDataPtr[11];
        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[10] =  TempPixelData1;
        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[11] =  TempPixelData2;
        TempPixelData1 = SrcDataPtr[12];
        TempPixelData2 = SrcDataPtr[13];
        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[12] =  TempPixelData1;
        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[13] =  TempPixelData2;
        TempPixelData1 = SrcDataPtr[14];
        TempPixelData2 = SrcDataPtr[15];
        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[14] =  TempPixelData1;
        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[15] =  TempPixelData2;

        SrcDataPtr +=16;           // Advance 16 dwords
        }

    //**************************************************************************
    // Output next group of 4 dwords
    //**************************************************************************

    while (DwordCount >= 4)
        {
        DwordCount -=4;

        while (FreeCount < 4*4)
            FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
        FreeCount -=4*4;

        TempPixelData1 = SrcDataPtr[0];
        TempPixelData2 = SrcDataPtr[1];
        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[0] =  TempPixelData1;
        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[1] =  TempPixelData2;
        TempPixelData1 = SrcDataPtr[2];
        TempPixelData2 = SrcDataPtr[3];
        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[2] =  TempPixelData1;
        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[3] =  TempPixelData2;

        SrcDataPtr +=4;            // Advance 4 dwords

        }


    //**************************************************************************
    // Output any remaining dwords
    //**************************************************************************

    while (DwordCount >0 )
        {
        DwordCount--;

        while (FreeCount < 4)
            FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
        FreeCount -= 4;

        TempPixelData1 = SrcDataPtr[0];
        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[0] =  TempPixelData1;

        SrcDataPtr ++;             // Advance 1 dword

        }
    *FreeCountPtr = FreeCount;
    }


//******************************************************************************
//
//  Function:   NV3Xfer4bpp
//
//  Routine Description:
//
//      Does a 4bpp transfer from a bitmap to the screen.
//
//      NOTE: The screen must be 8bpp for this function to be called!
//
//      The reason we implement this is that a lot of resources are kept as 4bpp,
//      and used to initialize DFBs, some of which we of course keep off-screen.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************


//******************************************************************************
// XLATE_BUFFER_SIZE defines the size of the stack-based buffer we use
// for doing the translate.  Note that in general stack buffers should
// be kept as small as possible.  The OS guarantees us only 8k for stack
// from GDI down to the display driver in low memory situations; if we
// ask for more, we'll access violate.  Note also that at any time the
// stack buffer cannot be larger than a page (4k) -- otherwise we may
// miss touching the 'guard page' and access violate then too.
//
// NV_HALF_BUFFER_SIZE -> NV fifo can hold up to 32 DWORDS (128 bytes)
//                        Here, we output the data when we've reach half of that
//******************************************************************************

#define XLATE_BUFFER_SIZE 256
#define NV_HALF_FIFO_SIZE 16*4

VOID NV3Xfer4bpp(     // Type FNXFER
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // Array of relative coordinates destination rectangles
ROP4        rop4,       // rop4
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo,
ULONG PatternColor,       // Not used
BLENDOBJ*   pBlendObj)

    {
    LONG    dx;
    LONG    dy;
    LONG    cx;
    LONG    cy;
    LONG    lSrcDelta;
    BYTE*   pjSrcScan0;
    BYTE*   pjSrc;
    LONG    cjSrc;

    Nv3ChannelPio   *nv = (Nv3ChannelPio *)ppdev->pjMmBase;
    ULONG depth;
    LONG BytesPerSrcScan;
    ULONG Rop3;
    ULONG temp;
    ULONG xsrc,ysrc;
    ULONG xdst,ydst;
    BYTE *NextScan;
    ULONG yscan;
    ULONG WordCount;
    BYTE *ScanPtr;
    LONG ScanInc;
    USHORT FreeCount;
    ULONG OnePixel;
    BYTE *DstBits;
    ULONG SizeInWidth;
    ULONG WordsPerDstScan;
    ULONG clip_x,clip_y;
    ULONG clip_width,clip_height;
    BYTE TempPixelData[XLATE_BUFFER_SIZE];
    DSURF*          pdsurfSrc;
    ULONG*  pulXlate;
    BYTE  PixelDataByte;
    ULONG PixelDataDword;
    ULONG   LoopCount;
    ULONG PixelCount;
    ULONG i;
    ULONG DwordCheck;

    ASSERTDD(((rop4 & 0xff00) >> 8) == (rop4 & 0xff),
             "Expect only a rop2");

    //**********************************************************************
    // Get ready to translate the 4bpp colors
    //**********************************************************************

    ASSERTDD(pxlo != NULL, "Xfer4BPP, NULL XLATEOBJ");
    pulXlate  =  pxlo->pulXlate;

    //**************************************************************************
    // Get pointer to start of source bitmap
    // Need to be careful about this!  This function gets called
    // when copying a system memory bitmap to VRAM.  However, the SOURCE
    // surfobj can be a standard DIB or it can be a DFB that's been moved
    // from offscreen VRAM to system memory.  If this is the case, then
    // we need to make sure and get the source ptr from the correct place.
    //**************************************************************************

    pdsurfSrc = (DSURF*) psoSrc->dhsurf;

    //**************************************************************************
    // If this is a DFB which has been moved to system memory (DT_DIB),
    // then get the source ptr from pdsurfSrc->pso->pvScan0.
    // Otherwise, just get it from psoSrc->pvScan0 (standard DIB)
    //**************************************************************************

    if (pdsurfSrc != NULL)
        pjSrcScan0 = pdsurfSrc->pso->pvScan0;
    else
        pjSrcScan0 = psoSrc->pvScan0;

    //**************************************************************************
    // Verify that src bitmap is DWORD aligned.  As far as I can tell, this
    // appears to always be the case.
    //**************************************************************************
    ASSERTDD(!((ULONG_PTR) pjSrcScan0 & 0x3),
        "Unaligned source bitmap");// ACK!....src bitmap is not dword aligned !!!

    //**************************************************************************
    // Get Rop3 value
    //**************************************************************************

    Rop3 = (rop4 & 0xff);               // Get bottom byte

    //**************************************************************************
    // Current pixel depth
    //**************************************************************************

    depth = ppdev->cBitsPerPel;

    //**************************************************************************
    // Get Number of bytes to advance to next scanline in SOURCE
    // CAREFUL: If this is a DFB which has been moved to system memory (DT_DIB),
    // then get the 'ldelta' value from pdsurfSrc->pso->lDelta.  Source DFB
    // will NEVER come from offscreen VRAM (DT_SCREEN) so we don't have to even
    // check for dt == DT_DIB.  Otherwise, if we're dealing with a standard
    // system memory DIB, just get 'lDelta' from psoSrc->lDelta.
    //**************************************************************************

    if (pdsurfSrc != NULL)
        BytesPerSrcScan = pdsurfSrc->pso->lDelta;
    else
        BytesPerSrcScan = psoSrc->lDelta;

    //**************************************************************************
    // Verify that src bitmap pitch is a multiple of 4 (for dwords)
    //**************************************************************************
    ASSERTDD(!((ULONG) BytesPerSrcScan & 0x3),
        "Pitch is not dword aligned"); // ACK!....pitch is not dword aligned !!!

    //**************************************************************************
    // Amount to increment for each scanline
    //**************************************************************************

    ScanInc = BytesPerSrcScan ;      // Number of bytes to increment

    //**************************************************************************
    // Read FreeCount for the first time
    //**************************************************************************

    FreeCount = ppdev->NVFreeCount;

   //***************************************************************************
   // Reset clipping rectangle to full screen extents if necessary
   // Resetting the clipping rectangle causes delays so we want to do it
   // as little as possible!
   //***************************************************************************

   if (ppdev->NVClipResetFlag)
       {
       while (FreeCount < 2*4)
          FreeCount = nv->subchannel[CLIP_SUBCHANNEL].control.Free;
       FreeCount -= 2*4;

       nv->subchannel[CLIP_SUBCHANNEL].nv1ImageBlackRectangle.SetPoint = ((0 << 16) | 0 );
       nv->subchannel[CLIP_SUBCHANNEL].nv1ImageBlackRectangle.SetSize = (((ppdev->cyMemory)<<16) | (0x7fff));

       ppdev->NVClipResetFlag=0;       // Clipping rectangle has been reset
       }

    //**************************************************************************
    // Blit for each clipping rectangle
    //**************************************************************************

    while(TRUE)
        {

        //**********************************************************************
        // Top left coordinate of source bitmap on source surface
        //**********************************************************************

        xsrc = pptlSrc->x + prcl->left - prclDst->left;
        ysrc = pptlSrc->y + prcl->top  - prclDst->top;

        //**********************************************************************
        // Get ptr to start of SRC (Remember, there are 2 pixels per byte!)
        //**********************************************************************

        NextScan = (&(pjSrcScan0[(xsrc>>1) + ysrc*BytesPerSrcScan]));

        //**********************************************************************
        // Top left coordinate of destination on destination surface
        //**********************************************************************

        clip_x = prcl->left;
        clip_y = prcl->top;

        //**********************************************************************
        // GDI passes the lower right and bottom coordinate as EXCLUSIVE.
        // That is, the lower right coordinate is NOT included
        // For NV, the width/height actually means the number of
        // pixels drawn.  So, adjusting by 1 pixel is NOT necessary
        // when calculating width and height.
        //**********************************************************************

        clip_width = prcl->right - prcl->left;
        clip_height = prcl->bottom - prcl->top;

        while (FreeCount < 4*4)
            FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
        FreeCount -=4*4;

        //**********************************************************************
        // Setup NV Blit parameters for CPU to SCREEN blit
        //**********************************************************************

        nv->subchannel[ROP_SOLID_SUBCHANNEL].nv3ContextRop.SetRop5 = Rop3 ;
        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Point =  ( ( (clip_y) <<16) | ((clip_x) & 0xffff) );
        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.SizeOut = ( (clip_height <<16) | clip_width );

        //**********************************************************************
        // Specifying 1 more pixel (in 16bpp) for SizeIn causes the NV engine to
        // ignore/clip the extra pixel that we send it, so that it won't
        // get included as part of the next scanline. Since we always
        // send DWords at a time, we may actually send more data to the NV
        // engine than is necessary.  So clip it by specifying a larger SizeIn
        // That is, we always send DWORDS at a time for each scanline.
        // For 8bpp, we may specify up to 3 additional pixels (which get ignored)
        //**********************************************************************

        if (depth == 8)
            SizeInWidth = ((clip_width + 3) & 0xfffc);
        else if (depth == 16)
            SizeInWidth = ((clip_width + 1) & 0xfffe);
        else
            SizeInWidth = clip_width;

        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.SizeIn = ( (clip_height <<16) | (SizeInWidth) );

        //******************************************************************
        //
        // 4bpp Source Bitmap:
        //
        // nibble| hi lo | hi  lo| hi lo | hi lo | hi  lo|
        //        -----------------------------------------------
        //       | Byte0 | Byte1 | Byte2 | Byte3 | Byte4 | etc..
        //        -----------------------------------------------
        // Pixels  0  1    2  3     4  5    6  7    8  9
        //
        // Pixels are displayed on screen as UPPER NYBBLE, then LOWER NYBBLE
        //
        // We must be careful not to read past end of 4bpp bitmap
        // We do this by breaking up the operation into 2 cases:
        //
        // If the starting pixel is ODD, then we need to read
        // the LOWER nybble of the source byte first, and proceed from there.
        // If the starting pixel is EVEN, then we need to read
        // the UPPER nybble of the source byte first, and proceed from there.
        //
        //******************************************************************

        //**********************************************************************
        // Output one scan at a time
        //**********************************************************************

        if ( xsrc & 1)
            {
            for (yscan=0;yscan < clip_height; yscan++)
                {
                ScanPtr = NextScan;
                PixelCount=0;
                //**************************************************************
                // For each byte, we read 2 pixels.  We will count by bytes.
                // Since we started on an ODD pixel, we read the LOWER
                // nibble of the current source byte FIRST, then we
                // read the UPPER nibble
                //**************************************************************

                LoopCount= clip_width>>1 ;      // Odd pel handled separately

                //**************************************************************
                // Get the current 2 pixels of data
                //**************************************************************

                PixelDataByte = *ScanPtr;

                while (LoopCount-- > 0)
                    {
                    TempPixelData[PixelCount++] = (BYTE) pulXlate[PixelDataByte & 0xf];
                    ScanPtr++;

                    PixelDataByte =*ScanPtr ;
                    TempPixelData[PixelCount++] = (BYTE) pulXlate[PixelDataByte >> 4];

                    //**********************************************************
                    // Check if we need to flush the data and
                    // send it to NV hardware
                    //**********************************************************

                    if (PixelCount >= NV_HALF_FIFO_SIZE)
                        {
                        NV3_Send_Data(ppdev,(ULONG *)TempPixelData,PixelCount,&FreeCount);
                        PixelCount=0;
                        }
                    }

                //**************************************************************
                // Check for any straggling pixel leftover
                //**************************************************************

                if (clip_width & 1)
                    TempPixelData[PixelCount++] = (BYTE) pulXlate[PixelDataByte & 0xf];

                //**************************************************************
                // Flush any remaining pixel data
                //**************************************************************

                if (PixelCount!=0)
                    NV3_Send_Data(ppdev,(ULONG *)TempPixelData,PixelCount,&FreeCount);

                NextScan+=ScanInc;
                }
            }
        else
            {
            for (yscan=0;yscan < clip_height; yscan++)
                {
                ScanPtr = NextScan;
                PixelCount=0;
                //**************************************************************
                // Pixels are displayed on screen as UPPER NYBBLE, then LOWER NYBBLE
                //**************************************************************

                LoopCount = (clip_width + 1) >> 1;  // Each loop handles 2 pels

                do  {
                    //**********************************************************
                    // See if we can speed things up a bit by reading DWORDS
                    //**********************************************************

                    if (LoopCount>=4)               // 8 pels or more to go?
                        {
                        PixelDataDword = *((DWORD *)ScanPtr);
                        TempPixelData[PixelCount++] = (BYTE) pulXlate[(PixelDataDword >> 4) & 0xf];
                        TempPixelData[PixelCount++] = (BYTE) pulXlate[(PixelDataDword     ) & 0xf];
                        TempPixelData[PixelCount++] = (BYTE) pulXlate[(PixelDataDword >>12) & 0xf];
                        TempPixelData[PixelCount++] = (BYTE) pulXlate[(PixelDataDword >> 8) & 0xf];
                        TempPixelData[PixelCount++] = (BYTE) pulXlate[(PixelDataDword >>20) & 0xf];
                        TempPixelData[PixelCount++] = (BYTE) pulXlate[(PixelDataDword >>16) & 0xf];
                        TempPixelData[PixelCount++] = (BYTE) pulXlate[(PixelDataDword >>28) & 0xf];
                        TempPixelData[PixelCount++] = (BYTE) pulXlate[(PixelDataDword >>24) & 0xf];

                        ScanPtr+=4;                 // Advance by 8 source pels

                        LoopCount-=4;               // 4 groups of 2 pels = 8 pels
                        }

                    else
                        {
                        PixelDataByte = *ScanPtr;

                        TempPixelData[PixelCount++] = (BYTE) pulXlate[PixelDataByte >> 4];
                        TempPixelData[PixelCount++] = (BYTE) pulXlate[PixelDataByte & 0xf];

                        ScanPtr++;                  // Advance by 2 source pels

                        LoopCount--;                // 1 group of 2 pels = 2 pels
                        }

                    //**********************************************************
                    // Check if we need to flush the data and
                    // send it to NV hardware
                    //**********************************************************

                    if (PixelCount >= NV_HALF_FIFO_SIZE)
                        {
                        NV3_Send_Data(ppdev,(ULONG *)TempPixelData,PixelCount,&FreeCount);
                        PixelCount=0;
                        }

                    } while (LoopCount != 0);

                //**************************************************************
                // Flush any remaining pixel data
                //**************************************************************

                if (PixelCount!=0)
                    NV3_Send_Data(ppdev,(ULONG *)TempPixelData,PixelCount,&FreeCount);


                NextScan+=ScanInc;
                }
            }

        if (--c == 0)
            {
            //******************************************************************
            // Update global free count
            //******************************************************************
            ppdev->NVFreeCount = FreeCount;

            return;
            }

        prcl++;

        } // while (TRUE)...

    }



//******************************************************************************
//
//  Function:   NV3XferNative
//
//      Transfers a bitmap that is the same colour depth as the display to
//      the screen via the data transfer register, with no translation.
//
//  Routine Description:
//
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************


VOID NV3XferNative(     // Type FNXFER
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // Array of relative coordinates destination rectangles
ROP4        rop4,       // rop4
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo,
ULONG PatternColor,       // Not used
BLENDOBJ*   pBlendObj)
{
    LONG    dx;
    LONG    dy;
    LONG    cx;
    LONG    cy;
    LONG    lSrcDelta;
    BYTE*   SrcBits;
    BYTE*   pjSrc;
    LONG    cjSrc;

    Nv3ChannelPio   *nv = (Nv3ChannelPio *)ppdev->pjMmBase;
    ULONG depth;
    LONG BytesPerSrcScan;
    ULONG Rop3;
    ULONG temp;
    ULONG xsrc,ysrc;
    ULONG *NextScan;
    ULONG BytesPerDstScan;
    ULONG DwordsPerDstScan;
    ULONG yscan;
    ULONG WordCount;
    ULONG *ScanPtr;
    LONG ScanInc;
    USHORT FreeCount;
    ULONG OnePixel;
    BYTE *DstBits;
    ULONG SizeInWidth;
    ULONG WordsPerDstScan;
    ULONG clip_x,clip_y;
    ULONG clip_width,clip_height;
    ULONG TempPixelData1;
    ULONG TempPixelData2;
    DSURF*          pdsurfSrc;
    ULONG   ByteCount;
    ULONG   i;

    //**************************************************************************
    // Safety checks
    //**************************************************************************

    ASSERTDD(pBlendObj == NULL, "Can't handle Alpha Blends");
    ASSERTDD((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL) ||
             ((pxlo->flXlate == 0x10) && (OglIsEnabled(ppdev))),
            "Can handle trivial xlate only");
    ASSERTDD(psoSrc->iBitmapFormat == ppdev->iBitmapFormat,
            "Source must be same colour depth as screen");
    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(((rop4 & 0xff00) >> 8) == (rop4 & 0xff),
             "Expect only a rop2");

    //**************************************************************************
    // Get pointer to start of source bitmap
    // Need to be careful about this!  This function gets called
    // when copying a system memory bitmap to VRAM.  However, the SOURCE
    // surfobj can be a standard DIB or it can be a DFB that's been moved
    // from offscreen VRAM to system memory.  If this is the case, then
    // we need to make sure and get the source ptr from the correct place.
    //**************************************************************************

    pdsurfSrc = (DSURF*) psoSrc->dhsurf;

    //**************************************************************************
    // If this is a DFB which has been moved to system memory (DT_DIB),
    // then get the source ptr from pdsurfSrc->pso->pvScan0.
    // Otherwise, just get it from psoSrc->pvScan0 (standard DIB)
    //**************************************************************************

    //**************************************************************************
    // Get Number of bytes to advance to next scanline in SOURCE
    // CAREFUL: If this is a DFB which has been moved to system memory (DT_DIB),
    // then get the 'ldelta' value from pdsurfSrc->pso->lDelta.  Source DFB
    // will NEVER come from offscreen VRAM (DT_SCREEN) so we don't have to even
    // check for dt == DT_DIB.  Otherwise, if we're dealing with a standard
    // system memory DIB, just get 'lDelta' from psoSrc->lDelta.
    //**************************************************************************

    if (pdsurfSrc != NULL)
        {
        SrcBits         = pdsurfSrc->pso->pvScan0;
        BytesPerSrcScan = pdsurfSrc->pso->lDelta;
        }
    else
        {
        SrcBits         = psoSrc->pvScan0;
        BytesPerSrcScan = psoSrc->lDelta;
        }

    //**************************************************************************
    // Verify that src bitmap is DWORD aligned.  As far as I can tell, this
    // appears to always be the case.
    //**************************************************************************

    ASSERTDD(!((ULONG_PTR) SrcBits & 0x3),
        "Src address is not dword aligned"); // ACK!..src addr is not dword aligned !!!

    //**************************************************************************
    // Verify that src bitmap pitch is a multiple of 4 (for dwords)
    //**************************************************************************

    ASSERTDD(!((ULONG_PTR) BytesPerSrcScan & 0x3),
        "Pitch is not dword aligned"); // ACK!....pitch is not dword aligned !!!

    //**************************************************************************
    // Current pixel depth
    //**************************************************************************

    depth = ppdev->cBitsPerPel;

    //**************************************************************************
    // Read FreeCount for the first time
    //**************************************************************************

    FreeCount = ppdev->NVFreeCount;

    //**************************************************************************
    // Reset clipping rectangle to full screen extents if necessary
    // Resetting the clipping rectangle causes delays so we want to do it
    // as little as possible!
    //**************************************************************************

    if (ppdev->NVClipResetFlag)
        {
        while (FreeCount < 2*4)
            FreeCount = nv->subchannel[CLIP_SUBCHANNEL].control.Free;
        FreeCount -= 2*4;

        nv->subchannel[CLIP_SUBCHANNEL].nv1ImageBlackRectangle.SetPoint = ((0 << 16) | 0 );
        nv->subchannel[CLIP_SUBCHANNEL].nv1ImageBlackRectangle.SetSize = (((ppdev->cyMemory)<<16) | (0x7fff));

        ppdev->NVClipResetFlag=0;       // Clipping rectangle has been reset
        }

    //**************************************************************************
    // Setup NV Blit parameters for CPU (MEMORY to SCREEN) blit
    //**************************************************************************

    Rop3 = (rop4 & 0xff);               // Get bottom byte

    //**************************************************************************
    // Enumerate the clipping regions
    //**************************************************************************

    while(TRUE)
        {
        //**********************************************************************
        // Top left coordinate of destination on destination surface
        //**********************************************************************

        clip_x = prcl->left;
        clip_y = prcl->top;

        //**********************************************************************
        // GDI passes the lower right and bottom coordinate as EXCLUSIVE.
        // That is, the lower right coordinate is NOT included
        // For NV, the width/height actually means the number of
        // pixels drawn.  So, adjusting by 1 pixel is NOT necessary
        // when calculating width and height.
        //**********************************************************************

        if (prclDst->right - prclDst->left < prcl->right - prcl->left)
        {
            clip_width = prclDst->right - prclDst->left;
        }
        else
        {
            clip_width = prcl->right - prcl->left;
        }
        if (prclDst->bottom - prclDst->top < prcl->bottom - prcl->top)
        {
            clip_height = prclDst->bottom - prclDst->top;
        }
        else
        {
            clip_height = prcl->bottom - prcl->top;
        }

        //**********************************************************************
        // Top left coordinate of source bitmap on source surface
        //**********************************************************************

        xsrc = pptlSrc->x + prcl->left - prclDst->left;
        ysrc = pptlSrc->y + prcl->top - prclDst->top;

        //**********************************************************************
        // Initialize the ImageFromCpu object
        //**********************************************************************

        while (FreeCount < 4*4)
            FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
        FreeCount -=4*4;

        nv->subchannel[ROP_SOLID_SUBCHANNEL].nv3ContextRop.SetRop5 = Rop3 ;
        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Point =  ( ( (clip_y) <<16) | ((clip_x) & 0xffff) );
        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.SizeOut = ( (clip_height <<16) | clip_width );

        //**********************************************************************
        // Specifying 1 more pixel (in 16bpp) for SizeIn causes the NV engine to
        // ignore/clip the extra pixel that we send it, so that it won't
        // get included as part of the next scanline. Since we always
        // send DWords at a time, we may actually send more data to the NV
        // engine than is necessary.  So clip it by specifying a larger SizeIn
        // That is, we always send DWORDS at a time for each scanline.
        // For 8bpp, we may specify up to 3 additional pixels (which get ignored)
        //**********************************************************************

        if (depth == 8)
            SizeInWidth = ((clip_width + 3) & 0xfffc);
        else if (depth == 16)
            SizeInWidth = ((clip_width + 1) & 0xfffe);
        else
            SizeInWidth = clip_width;

        nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.SizeIn = ( (clip_height <<16) | SizeInWidth );

        //**********************************************************************
        // Calculate number of dwords to output for scanline
        // This is the actual amount of data that the NV engine expects per scanline.
        // SizeInWidth is guaranteed to be a multiple of 2 (for 16bpp) and
        // a multiple of 4 (for 32bpp).  So we'll always be outputting DWORDS.
        // (No leftover words or bytes, they get clipped)
        //**********************************************************************

        BytesPerDstScan = clip_width * depth/8;
        DwordsPerDstScan = BytesPerDstScan / 4 + ((BytesPerDstScan % 4) ? 1 : 0);
        //**********************************************************************
        // Get ptr to start of SRC
        //**********************************************************************

        NextScan = (ULONG *)(&(SrcBits[(xsrc*depth/8) + ysrc*BytesPerSrcScan]));

        //**********************************************************************
        // Amount to increment for each scanline
        //**********************************************************************

        ScanInc = (BytesPerSrcScan+3) >> 2;      // Number of dwords to increment

#ifdef _X86_
        //**********************************************************************
        // Use assembly to output as fast as possible
        // We can still use the NV1 assembly routine, since we're still
        // using the NV1 version of the imagefromcpu class.
        //**********************************************************************

        NV1_Transfer_MemToScreen_Data(BytesPerDstScan,&FreeCount,clip_height,NextScan,ScanInc,nv);

#else

        //**********************************************************************
        // Output one scan at a time
        //**********************************************************************

        for (yscan=0;yscan < clip_height; yscan++)
            {
            ByteCount=BytesPerDstScan;
            ScanPtr = NextScan;

            //******************************************************************
            // Output next group of 16 dwords
            //******************************************************************

            while (ByteCount >= 16 * sizeof(ULONG))
                {
                ByteCount -= (16 * sizeof(ULONG));

                while (FreeCount < 16*4)
                    FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
                FreeCount -=16*4;

                TempPixelData1 = ScanPtr[0];
                TempPixelData2 = ScanPtr[1];
                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[0] =  TempPixelData1;
                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[1] =  TempPixelData2;
                TempPixelData1 = ScanPtr[2];
                TempPixelData2 = ScanPtr[3];
                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[2] =  TempPixelData1;
                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[3] =  TempPixelData2;
                TempPixelData1 = ScanPtr[4];
                TempPixelData2 = ScanPtr[5];
                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[4] =  TempPixelData1;
                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[5] =  TempPixelData2;
                TempPixelData1 = ScanPtr[6];
                TempPixelData2 = ScanPtr[7];
                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[6] =  TempPixelData1;
                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[7] =  TempPixelData2;
                TempPixelData1 = ScanPtr[8];
                TempPixelData2 = ScanPtr[9];
                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[8] =  TempPixelData1;
                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[9] =  TempPixelData2;
                TempPixelData1 = ScanPtr[10];
                TempPixelData2 = ScanPtr[11];
                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[10] =  TempPixelData1;
                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[11] =  TempPixelData2;
                TempPixelData1 = ScanPtr[12];
                TempPixelData2 = ScanPtr[13];
                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[12] =  TempPixelData1;
                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[13] =  TempPixelData2;
                TempPixelData1 = ScanPtr[14];
                TempPixelData2 = ScanPtr[15];
                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[14] =  TempPixelData1;
                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[15] =  TempPixelData2;

                ScanPtr +=16;           // Advance 16 dwords
                }

            //******************************************************************
            // Output next group of 4 dwords
            //******************************************************************

            while (ByteCount >= 4 * sizeof(ULONG))
                {
                ByteCount -= (4 * sizeof(ULONG));

                while (FreeCount < 4*4)
                    FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
                FreeCount -=4*4;

                TempPixelData1 = ScanPtr[0];
                TempPixelData2 = ScanPtr[1];
                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[0] =  TempPixelData1;
                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[1] =  TempPixelData2;
                TempPixelData1 = ScanPtr[2];
                TempPixelData2 = ScanPtr[3];
                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[2] =  TempPixelData1;
                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[3] =  TempPixelData2;

                ScanPtr +=4;            // Advance 4 dwords

                }


            //******************************************************************
            // Output any remaining dwords
            //******************************************************************

            while (ByteCount >= sizeof(ULONG) )
                {
                ByteCount -= sizeof(ULONG);

                while (FreeCount < 4)
                    FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
                FreeCount -= 4;

                TempPixelData1 = ScanPtr[0];
                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[0] =  TempPixelData1;

                ScanPtr ++;             // Advance 1 dword

                }



            //
            // Pad src scanline.
            //
            if (ByteCount)
            {
                TempPixelData1 = 0;
                for (i = 0; i < ByteCount; i++)
                {
                    TempPixelData1 |= ((PBYTE) (ScanPtr))[i] << (8 * i);
                }

                while (FreeCount < 4)
                    FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
                FreeCount -= 4;

                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[0] =  TempPixelData1;
            }

            NextScan+=ScanInc;
            }


#endif


        if (--c == 0)
            {
            //******************************************************************
            // Update global free count
            //******************************************************************
            ppdev->NVFreeCount = FreeCount;

            return;
            }

        prcl++;

        } // while (TRUE)...

    }


//******************************************************************************
//
//  Function:   NV3MemToScreenBlit
//
//  Routine Description:
//
//      Does a memory-to-screen blt
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NV3MemToScreenBlt(
PDEV*   ppdev,
SURFOBJ* psoSrc,
POINTL* pptlSrc,
RECTL*  prclDst)

    {
    LONG    dx;
    LONG    dy;     // Add delta to destination to get source
    LONG    cx;
    LONG    cy;     // Size of current rectangle - 1

    Nv3ChannelPio   *nv = (Nv3ChannelPio *)ppdev->pjMmBase;

    ULONG width,height;
    ULONG xscan,yscan;
    ULONG xsrc,ysrc;
    ULONG xdst,ydst;
    ULONG depth;
    LONG BytesPerSrcScan;
    ULONG ByteCount;
    ULONG SizeInWidth;
    ULONG BytesPerDstScan;
    ULONG DwordsPerDstScan;
    ULONG WordsPerDstScan;
    ULONG WordCount;
    WORD OnePixel;
    ULONG PixelData;
    ULONG TempPixelData1;
    ULONG TempPixelData2;
    ULONG *ScanPtr;
    ULONG *NextScan;
    LONG ScanInc;
    USHORT FreeCount;
    BYTE* SrcBits;
    DSURF* pdsurfSrc;

    //**************************************************************************
    // This function is exactly the same as XferNative, except
    // that 1) Rop = SRCCOPY always
    //      2) No clipping is done here
    //      3) No color translation
    //**************************************************************************

    //**************************************************************************
    // Get pointer to start of source bitmap
    // Need to be careful about this!  This function gets called
    // when copying a system memory bitmap to VRAM.  However, the SOURCE
    // surfobj can be a standard DIB or it can be a DFB that's been moved
    // from offscreen VRAM to system memory.  If this is the case, then
    // we need to make sure and get the source ptr from the correct place.
    //**************************************************************************

    pdsurfSrc = (DSURF*) psoSrc->dhsurf;

    //**************************************************************************
    // If this is a DFB which has been moved to system memory (DT_DIB),
    // then get the source ptr from pdsurfSrc->pso->pvScan0.
    // Otherwise, just get it from psoSrc->pvScan0 (standard DIB)
    //**************************************************************************

    //**************************************************************************
    // Get Number of bytes to advance to next scanline in SOURCE
    // CAREFUL: If this is a DFB which has been moved to system memory (DT_DIB),
    // then get the 'ldelta' value from pdsurfSrc->pso->lDelta.  Source DFB
    // will NEVER come from offscreen VRAM (DT_SCREEN) so we don't have to even
    // check for dt == DT_DIB.  Otherwise, if we're dealing with a standard
    // system memory DIB, just get 'lDelta' from psoSrc->lDelta.
    //**************************************************************************

    if (pdsurfSrc != NULL)
        {
        SrcBits         = pdsurfSrc->pso->pvScan0;
        BytesPerSrcScan = pdsurfSrc->pso->lDelta;
        }
    else
        {
        SrcBits         = psoSrc->pvScan0;
        BytesPerSrcScan = psoSrc->lDelta;
        }

    //**************************************************************************
    // Verify that src bitmap is DWORD aligned.  As far as I can tell, this
    // appears to always be the case.
    //**************************************************************************

    ASSERTDD(!((ULONG_PTR) SrcBits & 0x3),
        "Src address is not dword aligned"); // ACK!..src addr is not dword aligned !!!

    //**************************************************************************
    // Verify that src bitmap pitch is a multiple of 4 (for dwords)
    //**************************************************************************

    ASSERTDD(!((ULONG_PTR) BytesPerSrcScan & 0x3),
        "Pitch is not dword aligned"); // ACK!....pitch is not dword aligned !!!

    //**************************************************************************
    // GDI passes the lower right and bottom coordinate as EXCLUSIVE.
    // That is, the lower right coordinate is NOT included
    // For NV, the width/height actually means the number of
    // pixels drawn.  So, adjusting by 1 pixel is NOT necessary
    // when calculating width and height.
    //**************************************************************************

    width = prclDst->right - prclDst->left;
    height = prclDst->bottom - prclDst->top;

    //**************************************************************************
    // Top left coordinate of destination on destination surface
    //**************************************************************************

    xdst = prclDst->left;
    ydst = prclDst->top;

    //**************************************************************************
    // Top left coordinate of source bitmap on source surface
    //**************************************************************************

    xsrc = pptlSrc->x;
    ysrc = pptlSrc->y;

    //**************************************************************************
    // Current pixel depth
    //**************************************************************************

    depth = ppdev->cBitsPerPel;

    //**************************************************************************
    // Read FreeCount for the first time
    //**************************************************************************

    FreeCount = ppdev->NVFreeCount;

   //***************************************************************************
   // Reset clipping rectangle to full screen extents if necessary
   // Resetting the clipping rectangle causes delays so we want to do it
   // as little as possible!
   //***************************************************************************

   if (ppdev->NVClipResetFlag)
       {
       while (FreeCount < 2*4)
          FreeCount = nv->subchannel[CLIP_SUBCHANNEL].control.Free;
       FreeCount -= 2*4;

       nv->subchannel[CLIP_SUBCHANNEL].nv1ImageBlackRectangle.SetPoint = ((0 << 16) | 0 );
       nv->subchannel[CLIP_SUBCHANNEL].nv1ImageBlackRectangle.SetSize = (((ppdev->cyMemory)<<16) | (0x7fff));

       ppdev->NVClipResetFlag=0;       // Clipping rectangle has been reset
       }

   //***************************************************************************
   // Initialize the ImageFromCpu object
   //***************************************************************************

    while (FreeCount < 4*4)
       FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
    FreeCount -=4*4;

    nv->subchannel[ROP_SOLID_SUBCHANNEL].nv3ContextRop.SetRop5 = NV_SRCCOPY ;
    nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Point =  ( ((ydst) <<16) | ((xdst) & 0xffff) );
    nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.SizeOut = ( (height <<16) | width );

    //**************************************************************************
    // Specifying 1 more pixel (in 16bpp) for SizeIn causes the NV engine to
    // ignore/clip the extra pixel that we send it, so that it won't
    // get included as part of the next scanline. Since we always
    // send DWords at a time, we may actually send more data to the NV
    // engine than is necessary.  So clip it by specifying a larger SizeIn
    // That is, we always send DWORDS at a time for each scanline.
    // For 8bpp, we may specify up to 3 additional pixels (which get ignored)
    //**************************************************************************

    if (depth == 8)
        SizeInWidth = ((width + 3) & 0xfffc);
    else if (depth == 16)
        SizeInWidth = ((width + 1) & 0xfffe);
    else
        SizeInWidth = width;

    nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.SizeIn = ( (height <<16) | (SizeInWidth) );

    //**************************************************************************
    // Calculate number of dwords to output for scanline.
    //**************************************************************************
    BytesPerDstScan = width * depth/8;
    DwordsPerDstScan = BytesPerDstScan / 4 + ((BytesPerDstScan % 4) ? 1 : 0);

    //**************************************************************************
    // Get ptr to start of SRC
    //**************************************************************************

    NextScan = (ULONG *)(&(SrcBits[(xsrc*depth/8) + (ysrc*BytesPerSrcScan)]));

    //**************************************************************************
    // Amount to increment for each scanline
    //**************************************************************************

        ScanInc = (BytesPerSrcScan+3) >> 2;
        
#ifdef _X86_
    //**************************************************************************
    // Use assembly to output as fast as possible
    // We can still use the NV3 assembly routine, since we're still
    // using the NV3 version of the imagefromcpu class
    //**************************************************************************

    NV1_Transfer_MemToScreen_Data(BytesPerDstScan,&FreeCount,height,NextScan,ScanInc,nv);

#else
    //**************************************************************************
    // The following C code is the exact equivalent of
    // NV1_Transfer_MemToScreen_Data in assembly.
    //**************************************************************************

   //************************************************************************
   // Output one scan at a time
   //************************************************************************

   for (yscan=0;yscan < height; yscan++)
        {
        ByteCount = BytesPerDstScan;

        ScanPtr = NextScan;

        //********************************************************************
        // Output next group of 16 dwords
        //********************************************************************

        while (ByteCount >= (16 * sizeof(ULONG)))
            {
            ByteCount -= (16 * sizeof(ULONG));

            while (FreeCount < 16*4)
                FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
            FreeCount -=16*4;

            TempPixelData1 = ScanPtr[0];
            TempPixelData2 = ScanPtr[1];
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[0] =  TempPixelData1;
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[1] =  TempPixelData2;
            TempPixelData1 = ScanPtr[2];
            TempPixelData2 = ScanPtr[3];
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[2] =  TempPixelData1;
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[3] =  TempPixelData2;
            TempPixelData1 = ScanPtr[4];
            TempPixelData2 = ScanPtr[5];
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[4] =  TempPixelData1;
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[5] =  TempPixelData2;
            TempPixelData1 = ScanPtr[6];
            TempPixelData2 = ScanPtr[7];
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[6] =  TempPixelData1;
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[7] =  TempPixelData2;
            TempPixelData1 = ScanPtr[8];
            TempPixelData2 = ScanPtr[9];
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[8] =  TempPixelData1;
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[9] =  TempPixelData2;
            TempPixelData1 = ScanPtr[10];
            TempPixelData2 = ScanPtr[11];
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[10] =  TempPixelData1;
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[11] =  TempPixelData2;
            TempPixelData1 = ScanPtr[12];
            TempPixelData2 = ScanPtr[13];
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[12] =  TempPixelData1;
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[13] =  TempPixelData2;
            TempPixelData1 = ScanPtr[14];
            TempPixelData2 = ScanPtr[15];
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[14] =  TempPixelData1;
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[15] =  TempPixelData2;

            ScanPtr +=16;           // Advance 16 dwords
            }

        //********************************************************************
        // Output next group of 4 dwords
        //********************************************************************

        while (ByteCount >= (4 * sizeof(ULONG)))
            {
            ByteCount -= (4 * sizeof(ULONG));

            while (FreeCount < 4*4)
                FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
            FreeCount -=4*4;

            TempPixelData1 = ScanPtr[0];
            TempPixelData2 = ScanPtr[1];
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[0] =  TempPixelData1;
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[1] =  TempPixelData2;
            TempPixelData1 = ScanPtr[2];
            TempPixelData2 = ScanPtr[3];
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[2] =  TempPixelData1;
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[3] =  TempPixelData2;

            ScanPtr +=4;            // Advance 4 dwords

            }

        //********************************************************************
        // Output any remaining dwords
        //********************************************************************

        while (ByteCount >= sizeof(ULONG))
            {
            ByteCount -= sizeof(ULONG);

            while (FreeCount < 4)
                FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
            FreeCount -= 4;

            TempPixelData1 = ScanPtr[0];
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[0] =  TempPixelData1;

            ScanPtr ++;             // Advance 1 dword

            }

        //********************************************************************
        // Pad src scanline.
        //********************************************************************
        if (ByteCount)
            {
            ULONG   i;
            TempPixelData1 = 0;
            for (i = 0; i < ByteCount; i++)
                {
                TempPixelData1 |= ((PBYTE) (ScanPtr))[i] << (8 * i);
                }

            while (FreeCount < 4)
                FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
            FreeCount -= 4;

            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[0] =  TempPixelData1;
            }


        NextScan+=ScanInc;

        }
#endif  // _X86_

    //**************************************************************************
    // Update global free count
    //**************************************************************************

    ppdev->NVFreeCount = FreeCount;



    }

//******************************************************************************
//
//  Function:   NV3MemToScreenWithPatternBlt()
//
//  Routine Description:
//
//              Does a memory-to-screen with pattern blt
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************


VOID NV3MemToScreenWithPatternBlt(
PDEV*   ppdev,
SURFOBJ* psoSrc,
POINTL* pptlSrc,
RECTL*  prclDst,
ULONG rop3,
RBRUSH_COLOR   *rbc,
RECTL*  prclClip
)


    {
    LONG    dx;
    LONG    dy;     // Add delta to destination to get source
    LONG    cx;
    LONG    cy;     // Size of current rectangle - 1

    Nv3ChannelPio   *nv = (Nv3ChannelPio *)ppdev->pjMmBase;

    ULONG width,height;
    ULONG xscan,yscan;
    ULONG xsrc,ysrc;
    ULONG xdst,ydst;
    ULONG depth;
    LONG BytesPerSrcScan;
    ULONG ByteCount;
    ULONG SizeInWidth;
    ULONG BytesPerDstScan;
    ULONG DwordsPerDstScan;
    ULONG WordsPerDstScan;
    ULONG WordCount;
    WORD OnePixel;
    ULONG PixelData;
    ULONG TempPixelData1;
    ULONG TempPixelData2;
    ULONG *ScanPtr;
    ULONG *NextScan;
    LONG ScanInc;
    USHORT FreeCount;
    BYTE* SrcBits;
    DSURF* pdsurfSrc;
    ULONG   i;
    ULONG PixelDepth;
    ULONG AlphaEnableValue;

    //**************************************************************************
    // Get pointer to start of source bitmap
    // Need to be careful about this!  This function gets called
    // when copying a system memory bitmap to VRAM.  However, the SOURCE
    // surfobj can be a standard DIB or it can be a DFB that's been moved
    // from offscreen VRAM to system memory.  If this is the case, then
    // we need to make sure and get the source ptr from the correct place.
    //**************************************************************************

    pdsurfSrc = (DSURF*) psoSrc->dhsurf;

    //**************************************************************************
    // If this is a DFB which has been moved to system memory (DT_DIB),
    // then get the source ptr from pdsurfSrc->pso->pvScan0.
    // Otherwise, just get it from psoSrc->pvScan0 (standard DIB)
    //**************************************************************************

    //**************************************************************************
    // Get Number of bytes to advance to next scanline in SOURCE
    // CAREFUL: If this is a DFB which has been moved to system memory (DT_DIB),
    // then get the 'ldelta' value from pdsurfSrc->pso->lDelta.  Source DFB
    // will NEVER come from offscreen VRAM (DT_SCREEN) so we don't have to even
    // check for dt == DT_DIB.  Otherwise, if we're dealing with a standard
    // system memory DIB, just get 'lDelta' from psoSrc->lDelta.
    //**************************************************************************

    if (pdsurfSrc != NULL)
        {
        SrcBits         = pdsurfSrc->pso->pvScan0;
        BytesPerSrcScan = pdsurfSrc->pso->lDelta;
        }
    else
        {
        SrcBits         = psoSrc->pvScan0;
        BytesPerSrcScan = psoSrc->lDelta;
        }

    //**************************************************************************
    // Verify that src bitmap is DWORD aligned.  As far as I can tell, this
    // appears to always be the case.
    //**************************************************************************

    ASSERTDD(!((ULONG_PTR) SrcBits & 0x3),
        "Src address is not dword aligned"); // ACK!..src addr is not dword aligned !!!

    //**************************************************************************
    // Verify that src bitmap pitch is a multiple of 4 (for dwords)
    //**************************************************************************

    ASSERTDD(!((ULONG) BytesPerSrcScan & 0x3),
        "Pitch is not dword aligned"); // ACK!....pitch is not dword aligned !!!

    //**************************************************************************
    // Get pixel depth for the current mode.
    // Then determine the ALPHA_CHANNEL enable value
    //**************************************************************************

    AlphaEnableValue = ppdev->AlphaEnableValue;

    //**************************************************************************
    // GDI passes the lower right and bottom coordinate as EXCLUSIVE.
    // That is, the lower right coordinate is NOT included
    // For NV, the width/height actually means the number of
    // pixels drawn.  So, adjusting by 1 pixel is NOT necessary
    // when calculating width and height.
    //**************************************************************************

    width = prclDst->right - prclDst->left;
    height = prclDst->bottom - prclDst->top;

    //**************************************************************************
    // Top left coordinate of source bitmap on source surface
    //**************************************************************************

    xsrc = pptlSrc->x;
    ysrc = pptlSrc->y;

    //**************************************************************************
    // Top left coordinate of destination on destination surface
    //**************************************************************************

    xdst = prclDst->left;
    ydst = prclDst->top;

    //**************************************************************************
    // Current pixel depth
    //**************************************************************************

    depth = ppdev->cBitsPerPel;

    //**************************************************************************
    // Read FreeCount for the first time
    //**************************************************************************

    FreeCount = ppdev->NVFreeCount;

   //***************************************************************************
   // Reset clipping rectangle to full screen extents if necessary
   // Resetting the clipping rectangle causes delays so we want to do it
   // as little as possible!
   //***************************************************************************

    if((prclClip == NULL) && (ppdev->NVClipResetFlag))
    {
       while (FreeCount < 2*4)
          FreeCount = nv->subchannel[CLIP_SUBCHANNEL].control.Free;
       FreeCount -= 2*4;

       nv->subchannel[CLIP_SUBCHANNEL].nv1ImageBlackRectangle.SetPoint = ((0 << 16) | 0 );
       nv->subchannel[CLIP_SUBCHANNEL].nv1ImageBlackRectangle.SetSize = (((ppdev->cyMemory)<<16) | (0x7fff));

       ppdev->NVClipResetFlag=0;       // Clipping rectangle has been reset
    }
    else if(prclClip != NULL)
    {

       while (FreeCount < 2*4)
          FreeCount = nv->subchannel[CLIP_SUBCHANNEL].control.Free;
       FreeCount -= 2*4;

       nv->subchannel[CLIP_SUBCHANNEL].nv1ImageBlackRectangle.SetPoint = ((prclClip->top << 16) | prclClip->left );
       nv->subchannel[CLIP_SUBCHANNEL].nv1ImageBlackRectangle.SetSize = (((prclClip->bottom - prclClip->top) << 16) 
                    | (prclClip->right - prclClip->left) ); 

       ppdev->NVClipResetFlag=1;       // Clipping rectangle has been reset
    }

    //**************************************************************************
    // Wait for FIFO, then set pattern registers
    //**************************************************************************

    while (FreeCount < 5*4)
       FreeCount = nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].control.Free;
    FreeCount -=5*4;

    nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].nv1ImagePattern.SetMonochromeShape = NV018_SET_MONOCHROME_SHAPE_64X_1Y ;
    nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].nv1ImagePattern.SetMonochromeColor0 = (ULONG)(rbc->iSolidColor | AlphaEnableValue);
    nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].nv1ImagePattern.SetMonochromeColor1 = (ULONG)(rbc->iSolidColor | AlphaEnableValue);
    nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].nv1ImagePattern.SetMonochromePattern0 = 0xffffffff;
    nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].nv1ImagePattern.SetMonochromePattern1 = 0xffffffff;

    //**************************************************************************
    // Wait for FIFO, then set IMAGE_FROM_CPU registers
    //**************************************************************************

    while (FreeCount < 4*4)
       FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
    FreeCount -=4*4;

    nv->subchannel[ROP_SOLID_SUBCHANNEL].nv3ContextRop.SetRop5 = rop3 ;
    nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Point =  ( ((ydst) <<16) | ((xdst) & 0xffff) );
    nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.SizeOut = ( (height <<16) | width );

    //**************************************************************************
    // Specifying 1 more pixel (example: in 16bpp) for SizeIn causes the NV engine to
    // ignore/clip the extra pixel that we send it, so that it won't
    // get included as part of the next scanline. Since we always
    // send DWords at a time, we may actually send more data to the NV
    // engine than is necessary.  So clip it by specifying a larger SizeIn
    // That is, we always send DWORDS at a time for each scanline.
    // For 8bpp, we may specify up to 3 additional pixels (which get ignored)
    // SizeIn is specified in pixels.
    //**************************************************************************

    if (depth == 8)
        SizeInWidth = ((width + 3) & 0xfffc);       // We always send 4 pixels at a time
    else if (depth == 16)
        SizeInWidth = ((width + 1) & 0xfffe);       // We always send 2 pixels at a time
    else
        SizeInWidth = width;                        // We always send 1 pixel at a time

    nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.SizeIn = ( (height <<16) | (SizeInWidth) );

    //**************************************************************************
    // Calculate number of dwords to output per scanline
    // This is the actual amount of data that the NV engine expects per scanline.
    // SizeInWidth is guaranteed to be a multiple of 2 (for 16bpp) and
    // a multiple of 4 (for 8bpp).  So we'll always be outputting DWORDS.
    // (No leftover words or bytes, they get clipped)
    //**************************************************************************

    BytesPerDstScan = width * depth/8;
    DwordsPerDstScan = BytesPerDstScan / 4 + ((BytesPerDstScan % 4) ? 1 : 0);

    //**************************************************************************
    // Get ptr to start of SRC
    //**************************************************************************

    NextScan = (ULONG *)(&(SrcBits[(xsrc*depth/8) + (ysrc*BytesPerSrcScan)]));

    //**************************************************************************
    // Amount to increment for each scanline
    //**************************************************************************

    ScanInc = (BytesPerSrcScan+3) >> 2;      // Number of dwords to increment

    //**************************************************************************
    // Output one scan at a time
    //**************************************************************************

    for (yscan=0;yscan < height; yscan++)
        {
        ByteCount=BytesPerDstScan;

        ScanPtr = NextScan;

        //**********************************************************************
        // Output next group of 16 dwords
        //**********************************************************************

        while (ByteCount >= 16 * sizeof(ULONG))
            {
            ByteCount -= (16 * sizeof(ULONG));

            while (FreeCount < 16*4)
                FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
            FreeCount -=16*4;

            TempPixelData1 = ScanPtr[0];
            TempPixelData2 = ScanPtr[1];
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[0] =  TempPixelData1;
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[1] =  TempPixelData2;
            TempPixelData1 = ScanPtr[2];
            TempPixelData2 = ScanPtr[3];
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[2] =  TempPixelData1;
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[3] =  TempPixelData2;
            TempPixelData1 = ScanPtr[4];
            TempPixelData2 = ScanPtr[5];
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[4] =  TempPixelData1;
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[5] =  TempPixelData2;
            TempPixelData1 = ScanPtr[6];
            TempPixelData2 = ScanPtr[7];
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[6] =  TempPixelData1;
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[7] =  TempPixelData2;
            TempPixelData1 = ScanPtr[8];
            TempPixelData2 = ScanPtr[9];
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[8] =  TempPixelData1;
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[9] =  TempPixelData2;
            TempPixelData1 = ScanPtr[10];
            TempPixelData2 = ScanPtr[11];
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[10] =  TempPixelData1;
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[11] =  TempPixelData2;
            TempPixelData1 = ScanPtr[12];
            TempPixelData2 = ScanPtr[13];
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[12] =  TempPixelData1;
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[13] =  TempPixelData2;
            TempPixelData1 = ScanPtr[14];
            TempPixelData2 = ScanPtr[15];
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[14] =  TempPixelData1;
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[15] =  TempPixelData2;

            ScanPtr +=16;           // Advance 16 dwords
            }

        //**********************************************************************
        // Output next group of 4 dwords
        //**********************************************************************

        while (ByteCount >= 4 * sizeof(ULONG))
            {
            ByteCount -= (4 * sizeof(ULONG));
            while (FreeCount < 4*4)
                FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
            FreeCount -=4*4;

            TempPixelData1 = ScanPtr[0];
            TempPixelData2 = ScanPtr[1];
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[0] =  TempPixelData1;
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[1] =  TempPixelData2;
            TempPixelData1 = ScanPtr[2];
            TempPixelData2 = ScanPtr[3];
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[2] =  TempPixelData1;
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[3] =  TempPixelData2;

            ScanPtr +=4;            // Advance 4 dwords

            }

        //**********************************************************************
        // Output any remaining dwords
        //**********************************************************************

        while (ByteCount >= sizeof(ULONG) )
            {
            ByteCount -= sizeof(ULONG);

            while (FreeCount < 4)
                FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
            FreeCount -= 4;

            TempPixelData1 = ScanPtr[0];
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[0] =  TempPixelData1;

            ScanPtr ++;             // Advance 1 dword

            }
            //
            // Pad src scanline.
            //
            if (ByteCount)
            {
                TempPixelData1 = 0;
                for (i = 0; i < ByteCount; i++)
                {
                    TempPixelData1 |= ((PBYTE) (ScanPtr))[i] << (8 * i);
                }

                while (FreeCount < 4)
                    FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.Free;
                FreeCount -= 4;

                nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].nv1ImageFromCpu.Color[0] =  TempPixelData1;
            }


        NextScan+=ScanInc;

        }

    //**************************************************************************
    // Notify the rest of the driver that we changed the pattern
    //**************************************************************************

    ppdev->NVPatternResetFlag=1;

    //**************************************************************************
    // Update global free count
    //**************************************************************************

    ppdev->NVFreeCount = FreeCount;


    }



//******************************************************************************
//
//  Function:   NV3CopyBlit
//
//  Routine Description:
//
//      Does a screen-to-screen blt of a list of rectangles.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NV3CopyBlt(    // Type FNCOPY
    PDEV*   ppdev,
LONG    c,          // Can't be zero
RECTL*  prcl,       // Array of relative coordinates destination rectangles
ULONG   rop4,       // rop4
POINTL* pptlSrc,    // Original unclipped source point
RECTL*  prclDst,    // Original unclipped destination rectangle
BLENDOBJ*   pBlendObj)
    {
    LONG    dx;
    LONG    dy;     // Add delta to destination to get source
    LONG    cx;
    LONG    cy;     // Size of current rectangle - 1

    Nv3ChannelPio  *nv  = (Nv3ChannelPio*) ppdev->pjMmBase;

    ULONG width,height;
    ULONG xsrc,ysrc;
    ULONG xdst,ydst;
    USHORT FreeCount;
    ULONG Rop3;

    //**************************************************************************
    // Safety checks
    //**************************************************************************

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(((rop4 & 0xff00) >> 8) == (rop4 & 0xff),
             "Expect only a rop2");

    //**************************************************************************
    // Initialize the cached free count
    //**************************************************************************

    FreeCount = ppdev->NVFreeCount;

    //**************************************************************************
    // Reset clipping rectangle to full screen extents if necessary
    // Resetting the clipping rectangle causes delays so we want to do it
    // as little as possible!
    //**************************************************************************

    if (ppdev->NVClipResetFlag)
        {
        while (FreeCount < 2*4)
            FreeCount = nv->subchannel[CLIP_SUBCHANNEL].control.Free;
        FreeCount -= 2*4;

        nv->subchannel[CLIP_SUBCHANNEL].nv1ImageBlackRectangle.SetPoint = ((0 << 16) | 0 );
        nv->subchannel[CLIP_SUBCHANNEL].nv1ImageBlackRectangle.SetSize = (((ppdev->cyMemory)<<16) | (0x7fff));

        ppdev->NVClipResetFlag=0;       // Clipping rectangle has been reset
        }

    Rop3 = (rop4 & 0xff);

    //**************************************************************************
    // Do a copy blit for each clip rectangle
    //**************************************************************************

    do  {

        //**********************************************************************
        // GDI passes the lower right and bottom coordinate as EXCLUSIVE.
        // That is, the lower right coordinate is NOT included
        // For NV, the width/height actually means the number of
        // pixels drawn.  So, adjusting by 1 pixel is NOT necessary
        // when calculating width and height.
        //**********************************************************************

        width = prcl->right - prcl->left;
        height = prcl->bottom - prcl->top;

        dx = prcl->left - prclDst->left;    // prcl is always within prcldst???
        dy = prcl->top  - prclDst->top;     // prcl is always within prcldst???

        xsrc = pptlSrc->x + dx;
        ysrc = pptlSrc->y + dy;

        xdst = prcl->left;
        ydst = prcl->top;

        //**********************************************************************
        // Wait for FIFO to be ready, then draw
        //**********************************************************************

        while (FreeCount < 4*4)
            FreeCount = nv->subchannel[BLIT_SUBCHANNEL].control.Free;
        FreeCount -= 4*4;

        nv->subchannel[ROP_SOLID_SUBCHANNEL].nv3ContextRop.SetRop5 = Rop3 ;

        nv->subchannel[BLIT_SUBCHANNEL].nv1ImageBlit.ControlPointIn = ( (ysrc << 16) | (xsrc & 0xffff) );
        nv->subchannel[BLIT_SUBCHANNEL].nv1ImageBlit.ControlPointOut = ( ( (ydst) << 16) | ((xdst) & 0xffff) );
        nv->subchannel[BLIT_SUBCHANNEL].nv1ImageBlit.Size = ( (height << 16) | width );

        prcl++;

        } while (--c != 0);

    //**************************************************************************
    // Update global free count
    //**************************************************************************

    ppdev->NVFreeCount = FreeCount;

    }

#endif _WIN32_WINNT     // If is >= NT 4.x
#endif // NV3
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nv3ptr.c ===
//******************************Module*Header***********************************
//
// Module Name: NV3PTR.C
//
// This module contains the hardware pointer support for the display
// driver.
//
// Copyright (c) 1992-1996 Microsoft Corporation
//
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *  Copyright (C) 1997 - 2000 NVidia Corporation. All Rights Reserved.         *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"

#include "nvsubch.h"
#include "oldnv332.h"
#define NV32_INCLUDED // Prevents re-inclusion of real nv32 header
#include "driver.h"
#include "nvos.h"
#include "nvntioctl.h"
#include "nvntddctl.h"
#include "nvapi.h"

#ifdef NV3

#define OFFSET_PRMCIO_CRX__COLOR_REG                        0x3d4
#define OFFSET_PRMCIO_CR__COLOR_REG                         0x3d5
#define OFFSET_PRMVIO_SRX_REG                               0x3c4
#define OFFSET_PRMVIO_SR_LOCK_REG                           0x3c5
#define OFFSET_PRMVIO_MISC_READ_REG                         0x3cc
#define OFFSET_PRAMDAC_CU_START_POS_REG                     0x0
#define NV_PRMVIO_SR_LOCK_INDEX                             6

#define NV_SR_UNLOCK_VALUE                                  0x00000057
#define NV_SR_LOCK_VALUE                                    0x00000099

#define NV_CIO_CRE_HCUR_ADDR0_INDEX                 0x00000030
#define NV_CIO_CRE_HCUR_ADDR1_INDEX                 0x00000031

extern ULONG NV3CursorChecksum(BYTE *);
extern VOID  NV3LoadCursorData(BYTE *,BYTE *);
extern VOID  NV3Load16x16CursorData(BYTE *,BYTE *);

//******************************************************************************
//
//  Function:   NV3_SetHwCursor
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************
VOID NV3_SetHwCursor(
PDEV*   ppdev,
LONG    x,
LONG    y,
LONG    xHot,
LONG    yHot,
BYTE *  pjShape
)
{
    ULONG RowCount, ColumnCount;
    volatile ULONG *PRAMDACRegs;
    volatile ULONG*  CursorImageDataPtr;
    ULONG * pImage;
    
    //**************************************************************************
    // Get HotSpot
    //**************************************************************************

    ppdev->xPointerHot = xHot;
    ppdev->yPointerHot = yHot;

    //**************************************************************************
    // Init access to cursor registers
    //**************************************************************************
    PRAMDACRegs = ppdev->PRAMDACRegs;

    //**************************************************************************
    // Load a test pattern into cursor image area (2k worth of data) (32x32 16bpp)
    //**************************************************************************

    CursorImageDataPtr = ppdev->PRAMINRegs;

    //**************************************************************************
    // Each cursor color bitmap takes up 2k.  However, to fix up noise which
    // occurs when we load cursor shapes, we also allocate the subsequent 2k
    // in cursor memory, and clear it.  So essentially, each cursor
    // image takes up 4k. The 1st 2k is the cursor image, and the
    // following 2k is zero'd out (made transparent)
    //**************************************************************************

    ((PUCHAR)(CursorImageDataPtr)) += NUM_CACHED_CURSORS * 2048 * 2;

    pImage =(ULONG *)pjShape;

    for (RowCount=0;RowCount < 32;RowCount++)
        for (ColumnCount=0; ColumnCount < 16 ; ColumnCount ++)
            {
            //******************************************************************
            // ColumnCount goes from 0 thru 16 because we'll be outputting
            // DWORDS at a time (instead of words)
            // Remember, RowCount and DwordCount are multiplied by 4 after
            // C Compilation, because CursorImageDataPtr is a pointer to Dwords
            // Disable Transparency (0x80008000) and specify GREEN as
            // a test pattern for the color cursor
            //******************************************************************

            *(CursorImageDataPtr + RowCount*16 + ColumnCount) =  *pImage;
            pImage++;
            }

    //**************************************************************************
    // Update cursor position
    //**************************************************************************
    ppdev->pfnMovePointer(ppdev, x, y);

}

//******************************************************************************
//
//  Function:   NV3_TVCopyCursorData
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NV3_TVCopyCursorData(
BYTE    *srcptr,
BYTE    *dstptr)

    {
    LONG   LineCount;
    LONG   RowCount;

    //**************************************************************************
    // Just copy the cursor bitmap as is (it's already been prepped for hardware)
    //**************************************************************************

    for (LineCount=0; LineCount <32 ;LineCount++)
        {
        for (RowCount=0;RowCount<64;RowCount+=4)
            {
            *(ULONG *)(dstptr + LineCount*64 + RowCount) =
                        *(ULONG *)(srcptr + LineCount*64 + RowCount);
            }
        }

    }

//******************************************************************************
//
//  Function:   NV3_TVClipCursorData
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************



VOID NV3_TVClipCursorData(
BYTE *dstptr,
LONG ypos,
LONG height
)

    {
    LONG   LineCount;
    LONG   RowCount;
    LONG   dy;

    //**************************************************************************
    // Get bottom of cursor and figure out # of pixels past the end
    //**************************************************************************

    dy = ypos + 32;                         // Bottom of cursor
//    dy -= 476;                              // # of pixels past end
      dy -= (height);                         // # of pixels past end

    //**************************************************************************
    // Only clip cursor if it's going past the end of the screen
    //**************************************************************************

    if (dy>0)
        {
        //**********************************************************************
        // Clear out portion of cursor AFTER tv scanline 478
        //**********************************************************************

        for (LineCount=31;(LineCount > (31-dy)) && (LineCount>=0) ;LineCount--)
            {
            for (RowCount=0;RowCount<64;RowCount+=4)
                {
                *(ULONG *)(dstptr + LineCount*64 + RowCount) =  0x00000000;
                }
            }
        }

    }



//******************************************************************************
//
//  Function:   NV3EnablePointer
//
//  Routine Description:
//
//      Get the hardware ready to use the Brooktree 485 hardware pointer.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NV3EnablePointer(
PDEV*               ppdev,
BOOL    bEnable
)
{
    ULONG status;

    if (bEnable)
    {
        //**********************************************************************
        // Init access to cursor registers
        //**********************************************************************
        UCHAR lock;
        volatile UCHAR *PRMVIO_SRX_Reg;
        volatile UCHAR *PRMVIO_SR_LOCK_Reg;
        volatile UCHAR *PRMVIORegs = ppdev->PRMVIORegs;
        volatile ULONG*  CursorImageDataPtr;
        ULONG i;

        //**********************************************************************
        // Each cursor color bitmap takes up 2k.  However, to fix up noise which
        // occurs when we load cursor shapes, we also allocate the subsequent 2k
        // in cursor memory, and clear it.  So essentially, each cursor
        // image takes up 4k. The 1st 2k is the cursor image, and the
        // following 2k is zero'd out (made transparent)
        //
        // Here, we allocate memory for the cached monochrome cursors,
        // and the color cursor.
        //**********************************************************************

        ppdev->ulCursorMemOffset = (NUM_CACHED_CURSORS*2 + 2) * 2048;

        ppdev->hCursor = DD_CURSOR_OBJECT_HANDLE;
        status = NvAllocMemory( ppdev->hDriver,
                                ppdev->hClient,
                                ppdev->hDevice,
                                ppdev->hCursor,
                                NV01_MEMORY_LOCAL_PRIVILEGED,
                                0,
                                (PVOID)&ppdev->PRAMINRegs,
                                &ppdev->ulCursorMemOffset);

        if (status != NVOS02_STATUS_SUCCESS)
        /* jsw...
        status = NvAllocMemory( ppdev->hDriver,
                                "cursor",
                                (PVOID)&ppdev->PRAMINRegs,
                                &ppdev->ulCursorMemOffset);

        if (status != NV000E_ERROR_OK)
        ...jsw */
            {
            DISPDBG((2, "NV3EnablePointer: Cannot allocate cursor memory"));
            ppdev->flCaps |= CAPS_SW_POINTER;
            return;
            }

        PRMVIO_SRX_Reg = (volatile UCHAR *)(PRMVIORegs+OFFSET_PRMVIO_SRX_REG);
        PRMVIO_SR_LOCK_Reg = (volatile UCHAR *)(PRMVIORegs+OFFSET_PRMVIO_SR_LOCK_REG);

        PRMVIO_SRX_Reg = (volatile UCHAR *)(PRMVIORegs+OFFSET_PRMVIO_SRX_REG);

        *PRMVIO_SRX_Reg = NV_PRMVIO_SR_LOCK_INDEX;
        *PRMVIO_SR_LOCK_Reg = NV_SR_UNLOCK_VALUE;

        //**********************************************************************
        // Unlock CRTC extended regs
        //
        // NV_PRMVIO_SRX            = Sequencer Index Register (3c4)
        // NV_PRMVIO_SR_LOCK        = Data is written/ readm from register (3c5)
        // NV_PRMVIO_SR_LOCK_INDEX  = This indexed register (5) locks/unlocks
        //                            all extended registers.  When written with
        //                            value of 57, all extended registers are UNLOCKED.
        //                            Otherwise, all extended registers are LOCKED.
        //
        //                            When value = 0, extended register are in a locked state
        //                            When value = 1, extended registers are in an unlocked state
        //
        //**********************************************************************

        //**********************************************************************
        // Make sure to clear out cursor memory first. Otherwise,
        // we may see some noise when switching cursor shapes.
        //**********************************************************************

        CursorImageDataPtr = ppdev->PRAMINRegs;

        //**********************************************************************
        // Clear out cursor memory for all of the cached cursors and 1 color cursor.
        // Divide by 4 because we output dwords (4 bytes at a time)
        //**********************************************************************

        for (i=0;i < (((NUM_CACHED_CURSORS+1)*4096)>>2) ;i++)
            *(CursorImageDataPtr + i ) = 0x00000000;

        //**********************************************************************
        // Hide the pointer, since no cursor shape has been defined yet
        //**********************************************************************

        ppdev->pfnShowPointer(ppdev,FALSE);

    }
    else
    {
        //**********************************************************************
        // Hide the pointer.
        //**********************************************************************
        if (!(ppdev->flCaps & CAPS_SW_POINTER))
        {
            
            if(ppdev->ulCursorMemOffset)
            {
                ppdev->pfnShowPointer(ppdev, bEnable);
                status = NvFree( ppdev->hDriver,
                             ppdev->hClient,
                             ppdev->hDevice,
                             ppdev->hCursor);
                ASSERTDD(status == NVOS00_STATUS_SUCCESS,
                /*
                status = NvFreeMemory( ppdev->hDriver,
                                   (PVOID)ppdev->PRAMINRegs);
                ASSERTDD(status == NV000E_ERROR_OK,
                */
                    "Nv3EnablePointer: Cannot free cursor memory");
                ppdev->ulCursorMemOffset = 0;
            }
        }
    }
}


//******************************************************************************
//
//  Function:   NV3MovePointer
//
//  Routine Description:
//
//      Move the NV3 hardware pointer.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NV3MovePointer(
PDEV*   ppdev,
LONG    x,
LONG    y)

    {
    LONG    dx;
    LONG    dy;
    volatile ULONG *PRAMDACRegs;
    volatile ULONG *PRAMDAC_CU_START_POS_Reg;
    BYTE *CursorImageDataPtr;
    BYTE *pjDstScan;
    BYTE *pjSrcScan;

    if (x != -1)
    {
    //**************************************************************************
    // Get pointer to RAMDAC register
    //**************************************************************************

    PRAMDACRegs = ppdev->PRAMDACRegs;
    PRAMDAC_CU_START_POS_Reg = (volatile ULONG *)(PRAMDACRegs+OFFSET_PRAMDAC_CU_START_POS_REG);

    //**************************************************************************
    // Adjustment for cursor Hot spot
    //**************************************************************************

    x -= ppdev->xPointerHot;
    y -= ppdev->yPointerHot;


    //**********************************************************************
    // On modes below 400 lines, scanline doubling is used.
    // We need to multiply cursor y position by 2
    //**********************************************************************

    if (ppdev->cyScreen < 400)
        y <<=1;

    //**************************************************************************
    // If TV is enabled, adjust the cursor position (monitor type is nonzero)
    //**************************************************************************

    if (ppdev->MonitorType)
        {
        x += ppdev->TVCursorMin;

        //**********************************************************************
        // If TV is enabled AND filtering is NOT enabled (i.e. 8bpp), we need to 'clip'
        // the cursor in cursor memory. Otherwise, smearing will occur at the bottom.
        // In order to do this, we won't implement cursor caching for this case.
        //**********************************************************************

        if (!(ppdev->FilterEnable))
            {
            //******************************************************************
            // First take the current cursor bitmap (which is already
            // formatted for our hardware) and store it in a temporary buffer.
            //******************************************************************

            pjSrcScan = &ppdev->NV_CursorImageData[0];
            pjDstScan = &ppdev->NV_TVCursorImageData[0];

            NV3_TVCopyCursorData(pjSrcScan,pjDstScan);

            //******************************************************************
            // Clip the cursor manually so that smearing doesn't occur with TV
            //******************************************************************

            NV3_TVClipCursorData(pjDstScan , y, ppdev->cyScreen );

            //******************************************************************
            // Each cursor color bitmap takes up 2k.  However, to fix up noise which
            // occurs when we load cursor shapes, we also allocate the subsequent 2k
            // in cursor memory, and clear it.  So essentially, each cursor
            // image takes up 4k. The 1st 2k is the cursor image, and the
            // following 2k is zero'd out (made transparent)
            //******************************************************************

            CursorImageDataPtr = (BYTE *)ppdev->PRAMINRegs;
            CursorImageDataPtr += NUM_CACHED_CURSORS * 2048 * 2;

            //******************************************************************
            // Update PRAMIN with the updated/clipped cursor image
            //******************************************************************

            NV3_TVCopyCursorData(pjDstScan,CursorImageDataPtr);

            }

        //**********************************************************************
        // If filtering is enabled, we also need to scale the position as well!!
        //**********************************************************************

        if (ppdev->FilterEnable)
            {
            x <<=20;
            x /= ppdev->Scale_x;
            y <<=20;
            y /= ppdev->Scale_y;
            }


        }

    //**************************************************************************
    // Set hardware cursor position
    //**************************************************************************

    *PRAMDAC_CU_START_POS_Reg = ((x & 0xffff) | (y << 16) );

    return;
    }

    }

//******************************************************************************
//
//  Function:   NV3SetPointerShape
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

ULONG NV3SetPointerShape(
SURFOBJ*    pso,
SURFOBJ*    psoMsk,
SURFOBJ*    psoColor,
XLATEOBJ*   pxlo,
LONG        x,              // Relative coordinates
LONG        y,              // Relative coordinates
LONG        xHot,
LONG        yHot,
LONG        cx,
LONG        cy,
BOOL        AlphaBlendedCursor
)

    {
    PDEV*   ppdev;
    
    BYTE    CurrentValue;
    BYTE    mono;
    BYTE    ajBuf[NV1_POINTER_TOTAL_SIZE];
    
    BYTE*   pjSrcScan;
    BYTE*   pjDstScan;
    BYTE*   pbSrc;
    BYTE*   pbDst;

    LONG    i,j,k;    
    LONG    lSrcDelta;
    LONG    lDstDelta;
    LONG    CachedCursorIndex;
    
    ULONG   Checksum;
    ULONG   CursorAddress;
    ULONG   test, mask;
    ULONG   color;
    
    volatile UCHAR *PRMCIO_CRX_COLOR_Reg;
    volatile UCHAR *PRMCIO_CR_COLOR_Reg;
    volatile UCHAR *PRMVIO_SRX_Reg;
    volatile UCHAR *PRMVIO_SR_LOCK_Reg;

    //**************************************************************************
    // Get pointer to pdev
    //**************************************************************************

    ppdev    = (PDEV*) pso->dhpdev;


    //**************************************************************************
    // Handle Win2k Alpha blended cursors (ONLY if OpenGL is enabled)
    // Normally, we wouldn't attempt to handle alpha blended cursors because
    // our hardware doesn't support alpha blended cursors.
    // Unfortunately, when OpenGL is enabled, the alpha blended software cursor
    // is not visible on top of an OpenGL app.  So we're forced to 'handle' 
    // this case with our opaque hardware cursor, so that we can see the cursor.
    //
    // 2 side effects:
    //      1) Hardware only supports 32x32 cursors (up to NV5)
    //         So Alpha Blended cursors which width > 32 and height > 32
    //         may get clipped abruptly.
    //
    //      2) We ignore the alpha blended component of the bitmap
    //          and just make it transparent.
    //**************************************************************************

    if ( AlphaBlendedCursor ) 
        {

        if (globalOpenGLData.oglDrawableClientCount
#if (_WIN32_WINNT >= 0x0500) && !defined(NV3) && !defined(_WIN64)
            || ppdev->pDriverData->dwOverlaySurfaces
#endif      
        )
            {
            //******************************************************************
            // For alpha blended cursors when OpenGL is enabled,
            // we convert it to a hardware mono cursor.  NV4/NV5 only support
            // 32x32 hardware cursors, so if alpha blended cursors come thru
            // with cx>32 or cy>32, they'll get clipped
            //******************************************************************

            if (cx > 32 )
                cx = 32;
                
            if (cy > 32 )
                cy = 32;            
            }
            
        else
                    
            {
            //******************************************************************
            // Punt all Alpha blended cursors, except when OpenGL is enabled
            //******************************************************************

            return(SPS_DECLINE);
            
            }
                                
        }
        
    //**************************************************************************
    // Only handle 32x32 and 16x16 mono cursors. Send the rest thru DrvCopyBits
    //**************************************************************************

    else if ( !(((cx == 16) && (cy == 16) && (psoColor==NULL))  ||   
           ((cx == 32) && (cy == 32))) )
        {
        //
        // Can't handle this ptr in hw.
        //
        return(SPS_DECLINE);
        }


    
    //**************************************************************************
    // Check whether we'll be drawing a MONOCHROME or COLOR cursor
    //**************************************************************************
    if (psoColor == NULL)

        {

        //**********************************************************************
        // Translate to black and white format for DAC
        // Expand 32 x 32 x 1  (monochrome source ) to 32 x 32 x 16 CursorColorImage
        //
        // We're going to take the requested pointer AND masks and XOR
        // masks and combine them into our work buffer,
        //
        // We currently ONLY allow 32x32 cursors !!!
        //
        //              Monochrome Source
        //              -----------------
        //
        //         Byte0   Byte1   Byte2   Byte3
        //  0    |       |       |       |       |
        //  1    |       |       |       |       |         (monochrome source)
        //  2    |       |       |       |       |     Total of 128 bytes per plane
        //  3    |       |       |       |       |
        //                      etc..
        //
        //  31   |       |       |       |       |
        //
        //
        //
        //              Color Destination
        //              -----------------
        //
        //         Word0   Word1   ....    Word31
        //  0    |       |       |       |       |
        //  1    |       |       |       |       |         (color destination)
        //  2    |       |       |       |       |      Total 32*32*2 bytes
        //  3    |       |       |       |       |
        //                      etc..
        //
        //  31   |       |       |       |       |
        //
        //
        //**********************************************************************

        pjSrcScan    = psoMsk->pvScan0;
        lSrcDelta    = psoMsk->lDelta;

        if(lSrcDelta != 4)
        {

            // The cursor bitmap is neither TOP-DOWN nor Contiguous.

            pbDst = ajBuf;

            // XOR MASK, AND MASK
            for (i = 2*cy; i != 0; i--)
            {
                pbSrc = pjSrcScan;

                for (j = 4; j != 0; j--)
                {
                    *pbDst = *pbSrc;
                    pbDst++;
                    pbSrc++;
                }

                pjSrcScan += lSrcDelta;
            }
            pjSrcScan = ajBuf;

        }

        pjDstScan    = &ppdev->NV_CursorImageData[0]; // Start with first AND plane
        lDstDelta    = 4;                             // Each scan is 4 bytes (see above)


        //**********************************************************************
        // If TV is enabled AND filtering is NOT enabled (i.e 8bpp), we need to 'clip'
        // the cursor in cursor memory. Otherwise, smearing will occur.
        // In order to do this, we won't implement cursor caching for this case.
        //
        // Also special case 16x16 monochrome cursors!  
        // (Occurs when running SoftImage with OGL).
        // If it's a 16x16 cursor, then don't bother doing cached cursor.
        //**********************************************************************

        if (   ( (ppdev->MonitorType) && (!(ppdev->FilterEnable)))   ||
                 (cx == 16)     )
            {              
            //******************************************************************
            // First take the cursor from GDI and format it for our hardware
            // We'll store it in a temporary buffer first
            //******************************************************************

            pjDstScan = &ppdev->NV_CursorImageData[0];

            //******************************************************************
            // Cursor load is same for NV3 and NV4
            //******************************************************************

            if (cx == 16)
                NV3Load16x16CursorData(pjSrcScan, pjDstScan);
            else
                NV3LoadCursorData(pjSrcScan, pjDstScan);

            //******************************************************************
            // Don't forget to tell hardware where the cursor resides in PRAMIN memory
            //******************************************************************

            PRMCIO_CRX_COLOR_Reg = (volatile CHAR *)ppdev->PRMCIORegs;
            PRMCIO_CRX_COLOR_Reg += OFFSET_PRMCIO_CRX__COLOR_REG;

            PRMCIO_CR_COLOR_Reg = (volatile CHAR *)ppdev->PRMCIORegs;
            PRMCIO_CR_COLOR_Reg += OFFSET_PRMCIO_CR__COLOR_REG;

            //******************************************************************
            // Each cursor color bitmap takes up 2k.  However, to fix up noise which
            // occurs when we load cursor shapes, we also allocate the subsequent 2k
            // in cursor memory, and clear it.  So essentially, each cursor
            // image takes up 4k. The 1st 2k is the cursor image, and the
            // following 2k is zero'd out (made transparent)
            //******************************************************************

            CursorAddress = ppdev->ulCursorMemOffset + NUM_CACHED_CURSORS * 2048 * 2;

            *PRMCIO_CRX_COLOR_Reg = (NV_CIO_CRE_HCUR_ADDR0_INDEX & 0x3f);
            *PRMCIO_CR_COLOR_Reg  = (volatile UCHAR)(CursorAddress >> 16);

            *PRMCIO_CRX_COLOR_Reg = (NV_CIO_CRE_HCUR_ADDR1_INDEX & 0x3f);
            *PRMCIO_CR_COLOR_Reg  = (volatile UCHAR)( (((CursorAddress >> 11) & 0x1f) << 3) | 1);

            //******************************************************************
            // Blast the cursor image data into hardware
            //******************************************************************

            NV3_SetHwCursor(ppdev, x,y, xHot, yHot, pjDstScan);

            return(SPS_ACCEPT_NOEXCLUDE);

            }


#ifdef _X86_
        //**********************************************************************
        // Use assembly to load cursor data as quickly as possible
        // To improve performance, we'll store the data DIRECTLY
        // to PRAMIN memory, update the position, and return as quickly
        // as possible. (We store cursor data at PRAMIN + 14k
        //**********************************************************************

        pjDstScan = (BYTE *) ((ULONG)(ppdev->PRAMINRegs));

        //**********************************************************************
        // Quickly scan the image and get a unique checksum
        // Cursor checksum is same for NV3 and NV4
        //**********************************************************************

        Checksum = NV3CursorChecksum(pjSrcScan);

        //**********************************************************************
        // Check and see if we've already loaded the image in a buffer
        //**********************************************************************

        CachedCursorIndex = -1;

        //**********************************************************************
        // But first check and see if we couldn't distinguish the image
        // If we encounter the flag value, then reload the image.
        // Otherwise, look for the checksum in the cache.
        //**********************************************************************

        if (Checksum != 0x12345678)
            {
            for (i=0;i<NUM_CACHED_CURSORS;i++)
                if (ppdev->SavedCursorCheckSums[i] == Checksum)
                    CachedCursorIndex=i;
            }


        if (CachedCursorIndex !=-1)

            {
            //******************************************************************
            // Load the cached image directly
            //******************************************************************

            //******************************************************************
            // The 2k bitmap of the cursor (32x32 16bpp) must be located in
            // INSTANCE memory on a 2k boundary.  That is, it must lie on a 2k
            // boundary, so only 12 bits are programmable
            //
            // NV3: ------------------------------------------------------------
            //
            //      NV_CIO_CRE_HCUR_ADDR0_INDEX
            //
            //          Bits [6:0]  -> Bits [22:16] of cursor address in instance memory
            //
            //      NV_CIO_CRE_HCUR_ADDR1_INDEX
            //
            //          Bits [7:3]  -> Bits [15:11] of cursor image address in instance memory
            //          Bit  [2]    -> Undefined?
            //          Bit  [1]    -> Turns on scan doubling
            //          Bit  [0]    -> Enable/Disables cursor
            //
            //      Cursor address [10:0] is zero, due to the 2k alignment requirement
            //
            //******************************************************************

            PRMCIO_CRX_COLOR_Reg = (volatile CHAR *)ppdev->PRMCIORegs;
            PRMCIO_CRX_COLOR_Reg += OFFSET_PRMCIO_CRX__COLOR_REG;

            PRMCIO_CR_COLOR_Reg = (volatile CHAR *)ppdev->PRMCIORegs;
            PRMCIO_CR_COLOR_Reg += OFFSET_PRMCIO_CR__COLOR_REG;

            //******************************************************************
            // Bit definitions for cursor address are different for NV3 vs NV4
            //******************************************************************
            
            //**************************************************************
            // Need to ALWAYS unlock the CRTC registers here, because
            // on NEC systems, when Power Saving is enabled and the
            // system goes into power down mode, the CRTC registers
            // are locked when power comes back on.  Need to do this 
            // otherwise the cursor caching functionality won't work 
            // (hardware addressing won't work)
            //**************************************************************

            PRMVIO_SRX_Reg = (volatile CHAR *)ppdev->PRMVIORegs;
            PRMVIO_SRX_Reg += OFFSET_PRMVIO_SRX_REG;

            PRMVIO_SR_LOCK_Reg = (volatile CHAR *)ppdev->PRMVIORegs;
            PRMVIO_SR_LOCK_Reg += OFFSET_PRMVIO_SR_LOCK_REG;

            *PRMVIO_SRX_Reg = 6;    // Unlock register
            *PRMVIO_SR_LOCK_Reg = NV_SR_UNLOCK_VALUE;

            //**************************************************************
            // Each cursor color bitmap takes up 2k.  However, to fix up noise which 
            // occurs when we load cursor shapes, we also allocate the subsequent 2k
            // in cursor memory, and clear it.  So essentially, each cursor
            // image takes up 4k. The 1st 2k is the cursor image, and the
            // following 2k is zero'd out (made transparent)
            //**************************************************************

            CursorAddress =  ppdev->ulCursorMemOffset + CachedCursorIndex * 2048 * 2;

            *PRMCIO_CRX_COLOR_Reg = (NV_CIO_CRE_HCUR_ADDR0_INDEX & 0x3f);
            *PRMCIO_CR_COLOR_Reg  = (volatile UCHAR)(CursorAddress >> 16);

            *PRMCIO_CRX_COLOR_Reg = (NV_CIO_CRE_HCUR_ADDR1_INDEX & 0x3f);
            *PRMCIO_CR_COLOR_Reg  = (volatile UCHAR)( (((CursorAddress >> 11) & 0x1f) << 3) | 1);
                
            }

        else

            {
            //******************************************************************
            // Save the calculated checksum value for the cursor bitmap
            //******************************************************************

            ppdev->SavedCursorCheckSums[ppdev->NextCachedCursor] = Checksum;

            //******************************************************************
            // Each cursor color bitmap takes up 2k.  However, to fix up noise which 
            // occurs when we load cursor shapes, we also allocate the subsequent 2k
            // in cursor memory, and clear it.  So essentially, each cursor
            // image takes up 4k. The 1st 2k is the cursor image, and the
            // following 2k is zero'd out (made transparent)
            //******************************************************************

            CursorAddress = ppdev->NextCachedCursor * 2048 * 2;

            pjDstScan = (BYTE *) ((ULONG)(ppdev->PRAMINRegs));

            NV3LoadCursorData(pjSrcScan,(BYTE *)((ULONG)pjDstScan+(ULONG)(CursorAddress)));
            NV3LoadCursorData(pjSrcScan,(BYTE *) (&(ppdev->SavedCursorBitmaps[ppdev->NextCachedCursor][0])));

            //******************************************************************
            // Tell hardware where the cursor resides in PRAMIN memory
            //******************************************************************

            PRMCIO_CRX_COLOR_Reg = (volatile CHAR *)ppdev->PRMCIORegs;
            PRMCIO_CRX_COLOR_Reg += OFFSET_PRMCIO_CRX__COLOR_REG;

            PRMCIO_CR_COLOR_Reg = (volatile CHAR *)ppdev->PRMCIORegs;
            PRMCIO_CR_COLOR_Reg += OFFSET_PRMCIO_CR__COLOR_REG;

            //******************************************************************
            // Bit definitions (for cursor address)
            //******************************************************************

            *PRMCIO_CRX_COLOR_Reg = (NV_CIO_CRE_HCUR_ADDR0_INDEX & 0x3f);
            *PRMCIO_CR_COLOR_Reg  = (volatile UCHAR)((CursorAddress + ppdev->ulCursorMemOffset) >> 16);

            *PRMCIO_CRX_COLOR_Reg = (NV_CIO_CRE_HCUR_ADDR1_INDEX & 0x3f);
            *PRMCIO_CR_COLOR_Reg  = (volatile UCHAR)( ((((CursorAddress + ppdev->ulCursorMemOffset) >> 11) & 0x1f) << 3) | 1);
            
            //******************************************************************
            // Reset the next cached cursor entry (round robin)
            //******************************************************************

            ppdev->NextCachedCursor++;
            if (ppdev->NextCachedCursor >= NUM_CACHED_CURSORS)
                ppdev->NextCachedCursor=0;
            }


        //**********************************************************************
        // Get HotSpot
        //**********************************************************************
        ppdev->xPointerHot = xHot;
        ppdev->yPointerHot = yHot;

        ppdev->pfnMovePointer(ppdev, x, y);
        return(SPS_ACCEPT_NOEXCLUDE);

#else

        for (i = 0; i < 32; i++)                      // 32 pixels vertically
            for (j = 0; j < 4; j++)                   // 4 bytes accross (32 pixels)
                {
                //**************************************************************
                // Read 1 byte (8 pixels) and write 8 words
                // XOR mask is 128 bytes from the beginning of source buffer
                //**************************************************************
#define COLOR_OFFSET    (32*4)

                mask = pjSrcScan[i*4 + j];                  // Get a Mask byte (8 pixels)
                mono = pjSrcScan[COLOR_OFFSET+ i*4 + j];    // Get a Mono byte (8 pixels)

                //**************************************************************
                // Now combine the masks according to the AND-XOR Microsoft convention
                //
                //  ('mask' value)      ('mono' value)
                //  AND mask value      XOR mask value      Result on screen
                //  --------------      --------------      ----------------
                //          0               0               Black
                //          0               1               White
                //          1               0               Transparent, pixel unchanged
                //          1               1               Inverts the pixel color
                //
                // We'll parse the pixels from right to left in source
                // (Bit 0 is leftmost in mono image).  This will cause
                // us to bit flip the cursor image and draw it correctly
                //**************************************************************

                test = 0x80;
                for (k = 0; k < 8; k++, test >>= 1)
                    {
                    if (test & mono)        // Test this bit
                        color = 0x7fff;     // White
                    else
                        color = 0;          // Black

                    if (!(test & mask))
                        color |= 0x8000;    // Not transparent

                    //**********************************************************
                    // Store 16 bits for NV cursor image data
                    //**********************************************************

                    *((WORD *)(pjDstScan+ i*32*2 + j*8*2 + k*2)) = (USHORT) color;
                    }
                }


#endif


        }   // Draw monochrome cursor (psoColor == NULL)

    else

        {

        WORD    red;
        WORD    green;
        WORD    blue;
        WORD    alpha;
        ULONG   iSrcBitDepth;
        LONG    lPitch;
        BYTE*   pjSrcColor;
        BYTE*   pjSrcColorMask;
        PALETTEENTRY pXlatePal[256];
        PPALETTEENTRY pPal;
    
        
        //**********************************************************************
        // Color cursor ( or alpha blended cursor)
        // Calc width of each scan in the color cursor bitmap. Assume the
        // bitmap has the same color format as the display device.
        //
        // The first 32*4 bytes is the AND mask.
        // The next 32 * 32 * bytes/pixel is the cursor image.
        // Translate the image into 1-5-5-5 format for the DAC
        // The AND mask value goes into the upper bit
        // The pixel image gets reduced to 5 bits each color and goes in the lower 15 bits
        // 8 bpp  - 8 bit index into palette.           pixel = 1 byte
        // 16 bpp - 1 bit X, 5 bit R, 5 bit G, 5 bit B. pixel = 2 bytes
        // 32 bit - 8 bit R, 8 bit G, 8 bit B           pixel = 3 bytes unpacked (+unused byte).
        //**********************************************************************

        //**********************************************************************
        // Determine if this is a device bitmap or GDI managed bitmap.
        // Note that the cursor bitmap may be any legal bit depth: it
        // does not necessarily match the current video mode. That's ok
        // since we have to convert it to 16BPP for our color cursor
        // hw.
        //**********************************************************************

        if (psoColor->dhsurf != NULL)
            {
            //******************************************************************
            // Device managed bitmap
            //******************************************************************
            if (((DSURF *) psoColor->dhsurf)->dt == DT_SCREEN)
                {
                //**************************************************************
                // Ptr surface is in offscreen device memory, need to wait for
                // fifo empty and graphics engine idle prior to copying the
                // pointer bitmap.
                //**************************************************************
                pjSrcColor      = (PBYTE) (((DSURF *) psoColor->dhsurf)->LinearPtr);
                lPitch          = (((DSURF *) psoColor->dhsurf))->LinearStride;
                iSrcBitDepth =  (((DSURF *) psoColor->dhsurf)->ppdev)->iBitmapFormat;
                ppdev->pfnWaitEngineBusy(ppdev);
                }
            else // (pdsurfSrc->dt == DT_DIB)
                {
                //**************************************************************
                // Device managed DFB in host memory, stored as DIB.
                // Don't bother moving DIB to offscreen memory since whe don't
                // use the graphics engine to draw or translate it.
                //**************************************************************
                psoColor = ((DSURF *) psoColor->dhsurf)->pso;
                lPitch =  psoColor->lDelta;
                iSrcBitDepth = psoColor->iBitmapFormat;
                pjSrcColor = (PBYTE) psoColor->pvScan0;
                }

            }
        else if (psoColor->pvScan0 != NULL)
            {
            //******************************************************************
            // GDI managed host memory bitmap
            //******************************************************************
            pjSrcColor      = (PBYTE) psoColor->pvScan0;
            lPitch          = psoColor->lDelta;
            iSrcBitDepth =  psoColor->iBitmapFormat;
            }
        else
            {
            //******************************************************************
            // If ptr bmp is neither DFB nor DIB, it's likely an error occurred.
            //******************************************************************
            return(SPS_DECLINE);
            }

        //**********************************************************************
        // Can't use ptr without address of the bitmap
        //**********************************************************************

        if (pjSrcColor == NULL)
            {
            return(SPS_DECLINE);
            }

        //**********************************************************************
        // psoMsk is NULL when using an Alpha Blended cursor
        //**********************************************************************

        if (!(AlphaBlendedCursor)) 
            {
            pjSrcColorMask  = psoMsk->pvScan0;
            lSrcDelta       = psoMsk->lDelta;
            }
            
        pjDstScan       = &ppdev->NV_CursorImageData[0];

        switch (iSrcBitDepth)
            {
            //******************************************************************
            // We gotta look up the color from the palette to convert to RGB
            //******************************************************************

            case BMF_8BPP:
                //**************************************************************
                // We gotta look up the color from the palette to
                // convert to RGB. Try to get info from the XLATEOBJ
                // first.
                //**************************************************************
                pPal = ppdev->pPal;     // Default to using pal from PDEV
                if (pxlo != NULL)
                    {
                        if (XLATEOBJ_cGetPalette(pxlo, XO_SRCPALETTE, 256, NULL) == 256)
                        {
                        //******************************************************
                        // Get the RGB palette.
                        //******************************************************
                        if (XLATEOBJ_cGetPalette(pxlo, XO_SRCPALETTE, 256, (PULONG) pXlatePal) != 256)
                            pPal = pXlatePal;
                        }
                    }
                for (i = 0; i < 32; i++)
                    {
                    mask = *(PULONG) (pjSrcColorMask + i*lSrcDelta);     // Get 8 AND bits
                    test = 0x00000080;
                    for (k = 0; k < 32; k++, test >>=1)
                        {
                        if (!(k & 7))
                            test = 0x00000080 << k;
                        color = *((PBYTE) (pjSrcColor + i*lPitch + k)); // Get 15 bits of color
                        blue =  pPal[color].peBlue;
                        green = pPal[color].peGreen;
                        red =  pPal[color].peRed;
                        color = ((red & 0xf8) << 7) | ((green & 0xf8) << 2) | ((blue & 0xf8) >> 3);
                        if (!(test & mask))
                            color |= 0x8000;              // Not transparent

                        //******************************************************
                        // Store 16 bits for NV cursor image data
                        //******************************************************
                        *((PUSHORT)(pjDstScan+ i*32*2 + k*2)) = (USHORT) color;
                        }
                    }
                break;

            //******************************************************************
            // Screen is currently in 16bpp mode
            //******************************************************************

            case BMF_16BPP:
                for (i = 0; i < 32; i++)
                   {
                   mask = *(PULONG) (pjSrcColorMask + i*lSrcDelta);     // Get 8 AND bits
                   test = 0x00000080;
                   for (k = 0; k < 32; k++, test >>=1)
                       {
                       if (!(k & 7))
                           test = 0x00000080 << k;

                       if (ppdev->flGreen == 0x03e0)
                            {
                            //**************************************************
                            // For 555: We can use the source color as is
                            //          since the color cursor is always 555
                            //**************************************************
                            color = *((PUSHORT) (pjSrcColor + i*lPitch + k*2)); // Get 15 bits of color
                            }
                       else
                            {
                            //**************************************************
                            // For 565: Convert from 565 bitmap format to 555
                            //          since the color cursor is always 555
                            //**************************************************
                            color = *((PUSHORT) (pjSrcColor + i*lPitch + k*2)); // Get 16 bits of color
                            red   = (WORD)(color & 0xf800); // 5 bits
                            green = (WORD)(color & 0x07c0); // Just take top 5 of 6 bits !
                            blue  = (WORD)(color & 0x001f); // 5 bits
                            color = (  (red >> 1 ) | (green >> 1 ) | (blue) );
                                                            
                            }

                       if (!(test & mask))
                             color |= 0x8000;                // Not transparent

                       //******************************************************
                       // Store 16 bits for NV cursor image data
                       //******************************************************
                       *((WORD *)(pjDstScan+ i*32*2 + k*2)) = (USHORT) color;
                       }
                   }

                break;

            //******************************************************************
            // Screen is currently in 32bpp mode
            //******************************************************************

            case BMF_32BPP:
                if (AlphaBlendedCursor)
                    {
                    // 32bpp color cursor                     
                    for (i = 0; i < cy; i++)
                        {
                        for (k = 0; k < (LONG)cx; k++)
                            {
                            blue =  *(pjSrcColor + i*lPitch + k*4 + 0);
                            green = *(pjSrcColor + i*lPitch + k*4 + 1);
                            red =   *(pjSrcColor + i*lPitch + k*4 + 2);
                            alpha = *(pjSrcColor + i*lPitch + k*4 + 3);
                            color = ((red & 0xf8) << 7) | ((green & 0xf8) << 2) | ((blue & 0xf8) >> 3);

                            if (alpha == 0xff)
                                color |= 0x8000;                // Not transparent

                            //**************************************************
                            // Store 16 bits for NV cursor image data
                            //**************************************************
                            *((PUSHORT)(pjDstScan+ i*32*2 + k*2)) = (USHORT) color;
                            }


                        //******************************************************
                        // If alpha blended cursor width < 32, then fill out
                        // rest of pixels with transparent color
                        //******************************************************

                        for (;k < 32; k++)
                            {
                            blue =  0x0;
                            green = 0x0;
                            red =   0x0;
                            alpha = 0x0;
                            color = ((red & 0xf8) << 7) | ((green & 0xf8) << 2) | ((blue & 0xf8) >> 3);

                            if (alpha == 0xff)
                                color |= 0x8000;                // Not transparent

                            //**************************************************
                            // Store 16 bits for NV cursor image data
                            //**************************************************
                            *((PUSHORT)(pjDstScan+ i*32*2 + k*2)) = (USHORT) color;
                            }


                        }


                    //**********************************************************
                    // If alpha blended cursor height < 32, then fill out
                    // remaining scanlines with transparent color
                    //**********************************************************

                    for (; i < 32; i++)
                        {
                        for (k = 0; k < 32; k++)
                            {
                            blue =  0x0;
                            green = 0x0;
                            red =   0x0;
                            alpha = 0x0;
                            color = ((red & 0xf8) << 7) | ((green & 0xf8) << 2) | ((blue & 0xf8) >> 3);

                            if (alpha == 0xff)
                                color |= 0x8000;                // Not transparent

                            //******************************************************
                            // Store 16 bits for NV cursor image data
                            //******************************************************
                            *((PUSHORT)(pjDstScan+ i*32*2 + k*2)) = (USHORT) color;
                            }

                        }

                    }
                    
                else
                
                    {
                    // 32bpp color cursor                     
                    for (i = 0; i < 32; i++)
                        {
                        mask = *(PULONG) (pjSrcColorMask + i*lSrcDelta);     // Get 8 AND bitsif (!(k & 7))
                        test = 0x00000080;
                        for (k = 0; k < 32; k++, test >>=1)
                            {
                            if (!(k & 7))
                                test = 0x00000080 << k;
    
                            blue =  *(pjSrcColor + i*lPitch + k*4 + 0);
                            green = *(pjSrcColor + i*lPitch + k*4 + 1);
                            red =   *(pjSrcColor + i*lPitch + k*4 + 2);
                            color = ((red & 0xf8) << 7) | ((green & 0xf8) << 2) | ((blue & 0xf8) >> 3);
                            if (!(test & mask))
                                color |= 0x8000;                // Not transparent
    
                            //******************************************************
                            // Store 16 bits for NV cursor image data
                            //******************************************************
                            *((PUSHORT)(pjDstScan+ i*32*2 + k*2)) = (USHORT) color;
                            }
                        }
                    }
                    

                break;

             default:
                //**************************************************************
                // Can't handle any other bit depths
                //**************************************************************
                return(SPS_DECLINE);

            }   // Switch
            //******************************************************************
            // Tell hardware where the cursor resides in PRAMIN memory
            //******************************************************************

            PRMCIO_CRX_COLOR_Reg = (volatile CHAR *)ppdev->PRMCIORegs;
            PRMCIO_CRX_COLOR_Reg += OFFSET_PRMCIO_CRX__COLOR_REG;

            PRMCIO_CR_COLOR_Reg = (volatile CHAR *)ppdev->PRMCIORegs;
            PRMCIO_CR_COLOR_Reg += OFFSET_PRMCIO_CR__COLOR_REG;

            //******************************************************************
            // Each cursor color bitmap takes up 2k.  However, to fix up noise which
            // occurs when we load cursor shapes, we also allocate the subsequent 2k
            // in cursor memory, and clear it.  So essentially, each cursor
            // image takes up 4k. The 1st 2k is the cursor image, and the
            // following 2k is zero'd out (made transparent)
            //******************************************************************

            CursorAddress = ppdev->ulCursorMemOffset + NUM_CACHED_CURSORS * 2048 * 2;

            //******************************************************************
            // Bit definitions (for cursor address)
            //******************************************************************
            *PRMCIO_CRX_COLOR_Reg = (NV_CIO_CRE_HCUR_ADDR0_INDEX & 0x3f);
            *PRMCIO_CR_COLOR_Reg  = (volatile UCHAR)(CursorAddress >> 16);

            *PRMCIO_CRX_COLOR_Reg = (NV_CIO_CRE_HCUR_ADDR1_INDEX & 0x3f);
            *PRMCIO_CR_COLOR_Reg  = (volatile UCHAR)( (((CursorAddress >> 11) & 0x1f) << 3) | 1);

        } // psoColor != NULL

    //**************************************************************************
    // Set the buffer for NV1 monochrome hardware or NV3 hardware color cursor
    //**************************************************************************

    pjDstScan = &ppdev->NV_CursorImageData[0];

    //**************************************************************************
    // Blast the cursor image data into hardware
    //**************************************************************************
    NV3_SetHwCursor(ppdev, x,y, xHot, yHot, pjDstScan);

    //**************************************************************************
    // Since it's a hardware pointer, GDI doesn't have to worry about
    // overwriting the pointer on drawing operations (meaning that it
    // doesn't have to exclude the pointer), so we return 'NOEXCLUDE'.
    // Since we're returning 'NOEXCLUDE', we also don't have to update
    // the 'prcl' that GDI passed us.
    //**************************************************************************

    return(SPS_ACCEPT_NOEXCLUDE);

    }

#ifdef _WIN64
//*****************************************************************************
//
// Function: NV3LoadCursorData()
//
// Routine Description:
//
//   C version for IA64 only.
//
// Arguments:
//
// Return Value:
//
//     None.
//
//*****************************************************************************

DWORD MonoTable[4] = { 0x00000000, 0x7fff0000, 0x00007fff, 0x7fff7fff };
DWORD AndTable[4]  = { 0x80008000, 0x00008000, 0x80000000, 0x00000000 };

VOID NV3LoadCursorData(
BYTE*   pjSrcScan,
BYTE*   pjDstScan
)
    {
    UCHAR*    AndMaskPtr;
    UCHAR*     MonoMaskPtr;
    ULONG*     DstPtr;
    UCHAR      AndMask;
    UCHAR      MonoMask;
    LONG       i, j, k;

    AndMaskPtr = (UCHAR *)pjSrcScan;
    MonoMaskPtr = (UCHAR *)(pjSrcScan + 128);
    DstPtr = (ULONG *)pjDstScan;

   //***************************************************************************
   // Iterate through 32 rows of data
   //***************************************************************************
    for (i = 0; i < 32; i++)
        {
        //**********************************************************************
        // Load 16bpp pels - uses tables to convert ones to 0x7fff and zeros to
        // 0x0000.  Also uses table to add transparency bit from AND mask.
        // Zero in AND mask converts to 0x8000, ones to 0x0000.
        //
        // Create two pels at a time with 4 entry tables, above.  If pjDstScan
        // will also be quad word aligned, a future optimization might be
        // creating 4 pels at a time with 16 entry tables.
        //**********************************************************************
        

        for (j = 0; j < 4; j++)
            {
            AndMask = *AndMaskPtr++;
            MonoMask = *MonoMaskPtr++;
            for (k = 0; k < 4; k++)
                {
                *DstPtr++ = AndTable[(AndMask >> 6) & 0x3] |
                            MonoTable[(MonoMask >> 6) & 0x3];
                AndMask <<= 2;
                MonoMask <<= 2;
                }
            }
        }
    }

//************************************************************