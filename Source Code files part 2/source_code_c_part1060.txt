 the mount point or guid volume name is not optional
            if (drive_string.QueryChAt(1) == (WCHAR)':' || path.IsGuidVolName()) {
                position = drive_string.Strchr(L' ');
                if (position != INVALID_CHNUM) {
                    // split up the string into drive string and label string
                    if (!label_string.Initialize(&drive_string, position))
                        return 1;
                    drive_string.DeleteChAt(position, TO_END);
                    // get rid of spaces at the beginning
                    while (label_string.QueryChAt(0) == (WCHAR)' ')
                        label_string.DeleteChAt(0);
                }
            } else {
                if (!label_string.Initialize(&drive_string) ||
                    !drive_string.Initialize(L"."))
                    return 1;
            }
        } else {
            // treat like 'label [<driveletter>:][...label...]
            // note that the drive letter is optional
            if (drive_string.QueryChAt(1) == (WCHAR)':') {
                if (!label_string.Initialize(&drive_string, 2))
                    return 1;
                drive_string.DeleteChAt(2, TO_END);
                // get rid of spaces at the beginning
                while (label_string.QueryChAt(0) == (WCHAR)' ')
                    label_string.DeleteChAt(0);
            } else if (path.IsGuidVolName()) {
                position = drive_string.Strchr(L' ');
                if (position != INVALID_CHNUM) {
                    // split up the string into drive string and label string
                    if (!label_string.Initialize(&drive_string, position))
                        return 1;
                    drive_string.DeleteChAt(position, TO_END);
                    // get rid of spaces at the beginning
                    while (label_string.QueryChAt(0) == (WCHAR)' ')
                        label_string.DeleteChAt(0);
                }
            } else {
                if (!label_string.Initialize(&drive_string) ||
                    !SYSTEM::QueryCurrentDosDriveName(&drive_string)) {
                    return 1;
                }
            }
        }
    } else {
        if (mp_arg.IsValueSet()) {
            if (!drive_string.Initialize(L"."))
                return 1;
        } else {
            if (!SYSTEM::QueryCurrentDosDriveName(&drive_string)) {
                return 1;
            }
        }
    }

    if (!path.Initialize(&drive_string))
        return 1;

    rst = path.AnalyzePath(&drive_string,
                           &fullpath,
                           &drive_path_string);

    switch (rst) {
        case PATH_OK:
        case PATH_COULD_BE_FLOPPY:
            if (drive_path_string.QueryChCount() != 0) {
                msg.Set(MSG_FMT_INVALID_DRIVE_SPEC);
                msg.Display();
                return 1;
            }
            if (path.IsGuidVolName()) {
                if (!DisplayDriveName.Initialize(&drive_string))
                    return 1;
            } else {
                if (!DisplayDriveName.Initialize(fullpath.GetPathString()))
                    return 1;
            }
            if (fullpath.GetPathString()->QueryChCount() == 2 &&
                fullpath.GetPathString()->QueryChAt(1) == (WCHAR)':') {
                if (!drive_string.Initialize(fullpath.GetPathString()))
                    return 1;
            }
            break;

        case PATH_OUT_OF_MEMORY:
            DebugPrint("Out of memory.\n");
            return 1;

        case PATH_NO_MOUNT_POINT_FOR_VOLUME_NAME_PATH:
            msg.Set(MSG_LBL_NO_MOUNT_POINT_FOR_GUID_VOLNAME_PATH);
            msg.Display();
            return 1;

        default:
            msg.Set(MSG_LBL_INVALID_DRIVE_SPEC);
            msg.Display();
            return 1;
    }

    if (label_string.QueryChCount() == 0) {

        if (!GetLabelInput(&DisplayDriveName,
                           &drive_string, &label_exists,
                           &label_string, &msg)) {
            return 1;
        }
    }

    if (!label_string.QueryChCount()) {
        if (label_exists) {
            msg.Set(MSG_LBL_DELETE_LABEL);
            msg.Display("");
            if (!msg.IsYesResponse(FALSE)) {
                return 0;
            }
        } else {
            return 0;
        }
    }

    return SetLabel(&drive_string, &label_string, &msg) ? 0 : 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ifsutil\src\volume.cxx ===
/*++

Copyright (c) 1990-2001 Microsoft Corporation

Module Name:

    volume.cxx

Abstract:

    Provides volume methods.

Author:

    Mark Shavlik (marks) 13-Feb-90
    Norbert P. Kusters (norbertk) 22-Feb-91

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _IFSUTIL_MEMBER_

#include "ulib.hxx"
#include "ifsutil.hxx"

#include "error.hxx"
#include "volume.hxx"
#include "supera.hxx"
#include "hmem.hxx"
#include "message.hxx"
#include "rtmsg.h"
#include "autoreg.hxx"
#include "ifsentry.hxx"

#if !defined(_AUTOCHECK_)
#include "path.hxx"
#endif

extern "C" {
#ifndef _AUTOCHECK_
    #include <stdio.h>
#else
    #include "ntos.h"
#endif // _AUTOCHECK_
    #include "bootreg.h"
}

DEFINE_EXPORTED_CONSTRUCTOR( VOL_LIODPDRV, LOG_IO_DP_DRIVE, IFSUTIL_EXPORT );

VOID
VOL_LIODPDRV::Construct (
    )
/*++

Routine Description:

    Constructor for VOL_LIODPDRV.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _sa = NULL;
}

IFSUTIL_EXPORT
VOL_LIODPDRV::~VOL_LIODPDRV(
    )
/*++

Routine Description:

    Destructor for VOL_LIODPDRV.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


VOID
VOL_LIODPDRV::Destroy(
    )
/*++

Routine Description:

    This routine returns a VOL_LIODPDRV to its initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _sa = NULL;
}


IFSUTIL_EXPORT
FORMAT_ERROR_CODE
VOL_LIODPDRV::Initialize(
    IN      PCWSTRING   NtDriveName,
    IN      PSUPERAREA  SuperArea,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     ExclusiveWrite,
    IN      BOOLEAN     FormatMedia,
    IN      MEDIA_TYPE  MediaType,
    IN      USHORT      FormatType
    )
/*++

Routine Description:

    This routine initializes a VOL_LIODPDRV to a valid state.

Arguments:

    NtDriveName     - Supplies the drive path for the volume.
    SuperArea       - Supplies the superarea for the volume.
    Message         - Supplies an outlet for messages.
    ExclusiveWrite  - Supplies whether or not the drive should be
                        opened for exclusive write.
    FormatMedia     - Supplies whether or not to format the media.
    MediaType       - Supplies the type of media to format to.
    FormatType      - Supplies the file system type in the event of a format

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    CONST               MaxSectorsInVerify = 512;

    BIG_INT             chunk;
    BIG_INT             amount_to_verify;
    BIG_INT             i;
    BIG_INT             sectors;
    ULONG               percent;

    FORMAT_ERROR_CODE   errcode;
#if !defined(RUN_ON_NT4)
    NTSTATUS            es_status;
    EXECUTION_STATE     prev_state, dummy_state;
#endif
    USHORT              format_type;

    Destroy();

    DebugAssert(NtDriveName);
    DebugAssert(SuperArea);

#if defined(FE_SB) && defined(_X86_)
    if (IsPC98_N() && MediaType) {
        format_type = DP_DRIVE::ANY;
    } else {
        format_type = QueryFormatType();
    }
#else
    {
        format_type = DP_DRIVE::NONE;   // does not matter so set it to anything will do
    }
#endif

    if (!LOG_IO_DP_DRIVE::Initialize(NtDriveName, Message, ExclusiveWrite, format_type)) {
        return GeneralError;
    }

    if (!_bad_sectors.Initialize()) {
        return GeneralError;
    }

    _sa = SuperArea;

    if (FormatMedia && !IsWriteable()) {
        Message->Set(MSG_FMT_WRITE_PROTECTED_MEDIA);
        Message->Display();
        return GeneralError;
    }

    if (QueryMediaType() == Unknown && MediaType == Unknown) {
        Message ? Message->DisplayMsg(MSG_DISK_NOT_FORMATTED) : 1;
        return GeneralError;
    }

    if (!FormatMedia &&
        (QueryMediaType() == Unknown ||
        (MediaType != Unknown && MediaType != QueryMediaType()))) {
        Message ? Message->DisplayMsg(MSG_CANT_QUICKFMT) : 1;
        if (Message ? Message->IsYesResponse(FALSE) : FALSE) {
            FormatMedia = TRUE;
        } else {
            return GeneralError;
        }
    }

    if (QueryMediaType() != Unknown && QuerySectors() == 0) {
        if (Message) {
            Message->DisplayMsg(MSG_FMT_INVALID_SECTOR_COUNT);
        } else {
            DebugPrint("Sectors is 0");
        }
        return GeneralError;
    }

    if (FormatMedia) {
        if (!Lock()) {
            return LockError;
        }

        //
        //  We make a weird exception here for the Compaq 120MB floppy,
        //  because it wants to be formatted as if it were a hard disk.
        //

        if (IsFloppy() &&
            (MediaType != F3_120M_512 &&
             MediaType != F3_200Mb_512 &&
             MediaType != F3_240M_512)) {

            BOOLEAN     rst;

#if !defined(RUN_ON_NT4)
            es_status = NtSetThreadExecutionState(ES_CONTINUOUS|
                                                  ES_DISPLAY_REQUIRED|
                                                  ES_SYSTEM_REQUIRED,
                                                  &prev_state);

            if (!NT_SUCCESS(es_status)) {
                DebugPrintTrace(("IFSUTIL: Unable to set thread execution state (%x)\n", es_status));
            }
#endif

            rst = FormatVerifyFloppy(MediaType, &_bad_sectors, Message);

#if !defined(RUN_ON_NT4)
            if (NT_SUCCESS(es_status)) {
                es_status = NtSetThreadExecutionState(prev_state, &dummy_state);
                if (!NT_SUCCESS(es_status)) {
                    DebugPrintTrace(("IFSUTIL: Unable to reset thread execution state (%x)\n", es_status));
                }
            }
#endif

            if (!rst)
                return GeneralError;

        } else {

            sectors = QuerySectors();
            chunk = min( sectors/20 + 1, MaxSectorsInVerify );

            percent = 0;
            if (Message && !Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent)) {
                return GeneralError;
            }

#if !defined(RUN_ON_NT4)
            es_status = NtSetThreadExecutionState(ES_CONTINUOUS|
                                                  ES_DISPLAY_REQUIRED|
                                                  ES_SYSTEM_REQUIRED,
                                                  &prev_state);

            if (!NT_SUCCESS(es_status)) {
                DebugPrintTrace(("IFSUTIL: Unable to set thread execution state (%x)\n", es_status));
            }
#endif


            if (IsSonyMS() && IsSonyMSFmtCmdCapable()) {

                errcode = FormatSonyG2MS(Message, sectors);

            } else {

                errcode = NoError;

                for (i = 0; i < sectors; i += chunk) {

                    if ((i.GetLowPart() & 0x3ff) == 0) {
                        if (!Message->DisplayMsg(MSG_HIDDEN_STATUS, NORMAL_MESSAGE, 0)) {
                            errcode = GeneralError;
                            break;
                        }
                    }

                    if (i*100/sectors > percent) {
                        percent = ((i*100)/sectors).GetLowPart();
                        if (Message && !Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent)) {
                            errcode = GeneralError;
                            break;
                        }
                    }

                    amount_to_verify = min(chunk, sectors - i);

                    if (!Verify(i, amount_to_verify, &_bad_sectors)) {
                        if (Message) {
                            Message->DisplayMsg( (QueryLastNtStatus() == STATUS_NO_MEDIA_IN_DEVICE) ?
                                                    MSG_FORMAT_NO_MEDIA_IN_DRIVE :
                                                    MSG_CHK_NO_MEMORY );
                        }
                        errcode = GeneralError;
                        break;
                    }
                }
            }


#if !defined(RUN_ON_NT4)
            if (NT_SUCCESS(es_status)) {
                es_status = NtSetThreadExecutionState(prev_state, &dummy_state);
                if (!NT_SUCCESS(es_status)) {
                    DebugPrintTrace(("IFSUTIL: Unable to reset thread execution state (%x)\n", es_status));
                }
            }
#endif

            if (errcode != NoError)
                return errcode;

            if (Message && !Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", 100)) {
                return GeneralError;
            }
        }
    }

    return NoError;
}

IFSUTIL_EXPORT
BOOLEAN
VOL_LIODPDRV::Initialize(
    IN      PCWSTRING   NtDriveName,
    IN      PCWSTRING   HostFileName,
    IN      PSUPERAREA  SuperArea,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     ExclusiveWrite
    )
/*++

Routine Description:

    This routine initializes a VOL_LIODPDRV for a hosted
    volume, i.e. one that is implemented as a file on
    another volume.

Arguments:

    NtDriveName     - Supplies the drive path for the volume.
    HostFileName    - Supplies the drive name for the host file.
    SuperArea       - Supplies the superarea for the volume.
    Message         - Supplies an outlet for messages.
    ExclusiveWrite  - Supplies whether or not the drive should be
                        opened for exclusive write.

Return Value:

    TRUE upon successful completion.

--*/
{
    Destroy();

    DebugAssert(HostFileName);
    DebugAssert(SuperArea);

    if (!LOG_IO_DP_DRIVE::Initialize(NtDriveName,
                                     HostFileName,
                                     Message,
                                     ExclusiveWrite)) {

        return FALSE;
    }

    if (!_bad_sectors.Initialize()) {
        return FALSE;
    }

    _sa = SuperArea;

    return TRUE;
}


IFSUTIL_EXPORT
FORMAT_ERROR_CODE
VOL_LIODPDRV::Format(
    IN      PCWSTRING   Label,
    IN OUT  PMESSAGE    Message,
    IN      ULONG       Flags,
    IN      ULONG       ClusterSize,
    IN      ULONG       VirtualSectors
    )
/*++

Routine Description:

    This routine formats a volume.

Arguments:

    Label   - Supplies an optional label for the volume.
    Message - Supplies an outlet for messages.
    flags   - Supplies flags to control behavior of format
    ClusterSize
            - supplies the cluster size for the volume.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    MESSAGE msg;

    if (!Message) {
        Message = &msg;
    }

    if (!_sa) {
        return GeneralError;
    }

    if (!IsWriteable()) {
        Message->Set(MSG_FMT_WRITE_PROTECTED_MEDIA);
        Message->Display();
        return GeneralError;
    }

    if (IsSystemPartition()) {
        Message->Set(MSG_FMT_SYSTEM_PARTITION_NOT_ALLOWED);
        Message->Display();
        return GeneralError;
    }

    if (!Lock()) {
        return LockError;
    }

    if (_sa->Create(&_bad_sectors,
                    Message, Label,
                    Flags,
                    ClusterSize,
                    VirtualSectors)) {

        if (!DismountAndUnlock()) {
            DebugPrintTrace(("IFSUTIL: Failed in DismountAndUnlock\n"));
            return GeneralError;
        } else {

            PWSTRING    pLabel;
            DSTRING     label;
            NTSTATUS    status;

            pLabel = NULL;
            while (!NT_SUCCESS(status = _sa->FormatNotification(pLabel))) {
                if (status == STATUS_INVALID_VOLUME_LABEL) {

                    Message->Set(MSG_INVALID_LABEL_CHARACTERS);
                    Message->Display();

                    Message->Set(MSG_VOLUME_LABEL_PROMPT);
                    Message->Display();
                    Message->QueryStringInput(&label);

                    pLabel = &label;
                } else {
                    return GeneralError;
                }
            }
            return NoError;
        }
    } else
        return GeneralError;
}

IFSUTIL_EXPORT
BOOLEAN
VOL_LIODPDRV::SetVolumeLabelAndPrintFormatReport(
    IN      PCWSTRING   Label,
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This routine finishes up formatting by setting the volume label and
    prints format report.

Arguments:

    Label   - Supplies an optional label for the volume.
    Message - Supplies an outlet for messages.

Note:

    If volume label is incorrect, there will be a chance for the volume
    to become unavailable and further setting of label will fail.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    MESSAGE     msg;
    PWSTRING    pLabel;
    DSTRING     label;
    NTSTATUS    status;

    FILE_FS_VOLUME_INFORMATION      fs_vol_info;
    PFILE_FS_VOLUME_INFORMATION     pfs_vol_info;

    FILE_FS_SIZE_INFORMATION        fs_size_info;
    PFILE_FS_SIZE_INFORMATION       pfs_size_info;

    if (!Message) {
        Message = &msg;
    }

    if (!_sa) {
        return FALSE;
    }

    if (Label && Label->QueryChCount()) {
        pLabel = (PWSTRING)Label;
    } else {
        Message->Set(MSG_VOLUME_LABEL_PROMPT);
        Message->Display();
        Message->QueryStringInput(&label);
        pLabel = &label;
    }

    if (!DismountAndUnlock()) {
        DebugPrintTrace(("IFSUTIL: Failed in DismountAndUnlock\n"));
        return FALSE;
    } else {

        pfs_vol_info = &fs_vol_info;
        pfs_size_info = &fs_size_info;

        while (!NT_SUCCESS(status = _sa->FormatNotification(pLabel,
                                                            pfs_size_info,
                                                            pfs_vol_info))) {
            pfs_size_info = NULL;
            pfs_vol_info = NULL;

            if (status == STATUS_INVALID_VOLUME_LABEL) {

                Message->Set(MSG_INVALID_LABEL_CHARACTERS);
                Message->Display();

                Message->Set(MSG_VOLUME_LABEL_PROMPT);
                Message->Display();
                Message->QueryStringInput(&label);

                pLabel = &label;
            } else {
                Message->Set(MSG_FORMAT_FAILED);
                Message->Display();
                return FALSE;
            }
        }
    }

    if (NT_SUCCESS(status)) {

        Message->Set(MSG_FORMAT_COMPLETE);
        Message->Display();

        _sa->PrintFormatReport(Message,
                               &fs_size_info,
                               &fs_vol_info);
    }

    return TRUE;
}

#if !defined(RUN_ON_NT4)
IFSUTIL_EXPORT
VOID
RestoreThreadExecutionState(
    IN      NTSTATUS        PrevStatus,
    IN      EXECUTION_STATE PrevState
    )
/*++

Routine Description:

    This routine restores the previous execution state of the thread.
    It's intended to be used as the __except expression.

Arguments:

    PrevStatus          - Supplies the status of the previous call to
                          NtSetThreadExecutionState
    PrevState           - Supplies the execution state to restore to

Return Value:

    None

--*/
{
    EXECUTION_STATE     dummy_state;

    if (NT_SUCCESS(PrevStatus)) {
        PrevStatus = NtSetThreadExecutionState(PrevState, &dummy_state);
        if (!NT_SUCCESS(PrevStatus)) {
            DebugPrintTrace(("IFSUTIL: Unable to reset thread execution state (%x)\n", PrevStatus));
        }
    }
}
#endif

IFSUTIL_EXPORT
BOOLEAN
VOL_LIODPDRV::ChkDsk(
    IN      FIX_LEVEL   FixLevel,
    IN OUT  PMESSAGE    Message,
    IN      ULONG       Flags,
    IN      ULONG       DesiredLogFileSize,
    IN      USHORT      Algorithm,
    OUT     PULONG      ExitStatus,
    IN      PCWSTRING   DriveLetter
    )
/*++

Routine Description:

    This routine checks the integrity of the file system on the volume.
    If there are any problems, this routine will attempt to fix them
    to the degree specified in 'FixLevel'.

Arguments:

    FixLevel            - Supplies the level to which the volume should be fixed.
    Message             - Supplies an outlet for messages.
    Flags               - Supplies the flags that controls the behavior of chkdsk
                          (see ulib\inc\ifsentry.hxx for details)
    DesiredLogFileSize  - Tells what logfile size the user wants.
    ExitStatus          - Returns and indication of how the chkdsk went.
    DriveLetter         - For autochk, tells which drive letter we're checking.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    MESSAGE             msg;
    ULONG               exit_status;
#if !defined(RUN_ON_NT4)
    NTSTATUS            es_status;
    EXECUTION_STATE     prev_state;
#endif
    BOOLEAN             rst;

    if (!Message) {
        Message = &msg;
    }

    if (NULL == ExitStatus) {
        ExitStatus = &exit_status;
    }

    if (!_sa) {
        return FALSE;
    }

    if (FixLevel != CheckOnly && !IsWriteable()) {
        Message->DisplayMsg(MSG_CHK_WRITE_PROTECTED);
        *ExitStatus = CHKDSK_EXIT_COULD_NOT_CHK;
        return FALSE;
    }

#if !defined(RUN_ON_NT4)
    es_status = NtSetThreadExecutionState(ES_CONTINUOUS|
                                          ES_DISPLAY_REQUIRED|
                                          ES_SYSTEM_REQUIRED,
                                          &prev_state);

    if (!NT_SUCCESS(es_status)) {
        DebugPrintTrace(("IFSUTIL: Unable to set thread execution state (%x)\n", es_status));
    }

    __try {
#endif
        rst = _sa->VerifyAndFix(FixLevel,
                                Message,
                                Flags,
                                DesiredLogFileSize,
                                Algorithm,
                                ExitStatus,
                                DriveLetter);

        RestoreThreadExecutionState(es_status, prev_state);
#if !defined(RUN_ON_NT4)
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        RestoreThreadExecutionState(es_status, prev_state);
        if (FixLevel == CheckOnly) {
            Message->DisplayMsg(MSG_CHK_NTFS_ERRORS_FOUND);
        } else {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY); // unknown error
        }
        *ExitStatus = CHKDSK_EXIT_ERRS_NOT_FIXED;
        rst = FALSE;
    }

#endif

    return rst;

}


IFSUTIL_EXPORT
BOOLEAN
VOL_LIODPDRV::Recover(
    IN      PCWSTRING   FullPathFileName,
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This routine searches the named file for bad allocation units.
    It removes these allocation units from the file and marks them
    as bad in the file system.

Arguments:

    FullPathFileName    - Supplies the name of the file to recover.
    Message             - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    MESSAGE msg;

    if (!Message) {
        Message = &msg;
    }

    if (!_sa) {
        return FALSE;
    }

    return _sa->RecoverFile(FullPathFileName, Message);
}


IFSUTIL_EXPORT
BOOLEAN
VOL_LIODPDRV::ForceAutochk(
    IN  BOOLEAN     Fix,
    IN  ULONG       Options,
    IN  ULONG       LogFileSize,
    IN  USHORT      Algorithm,
    IN  PCWSTRING   Name
    )
/*++

Routine Description:

    This method schedules Autochk to be run at next boot.  If the client
    has not requested bad sector detection or logfile resizing, this
    scheduling is done simply by marking the volume dirty.  If bad sector
    detection or logfile resizing has been requested, the appropriate entry
    is put into the registry to force autochk to run.

Arguments:

    Fix             -- Supplies if chkdsk /f is being implied.
    Options         -- Supplies flags
                          CHKDSK_RECOVER
                          CHKDSK_RESIZE_LOGFILE
                          CHKDSK_SKIP_INDEX_SCAN
                          CHKDSK_SKIP_CYCLE_SCAN
                          CHKDSK_ALGORITHM_SPECIFIED
    LogFileSize     -- If CHKDSK_RESIZE_LOGFILE, tells the desired size in bytes.
    Algorithm       -- If CHKDSK_ALGORITHM_SPECIFIED, tells the desired chunk size.
    Name            -- Supplies the volume's NT name.

Return Value:

    TRUE upon successful completion.

--*/
{
#ifndef _AUTOCHECK_

    DSTRING             CommandLine;
    DSTRING             dos_drive_name;
    DSTRING             volume_name;
    DSTRING             nt_drive_name;
    DSTRING             drive_path_string;
    PATH                fullpath;
    PATH                dos_path;
    PCWSTRING           name;
    PATH_ANALYZE_CODE   rst;

    if (!CommandLine.Initialize( "autocheck autochk " )) {
        return FALSE;
    }

    //
    // Let's schedule an explicit autochk.
    //

    //
    // Remove any previous entry of Name from the registry
    //

    if (!AUTOREG::DeleteEntry(&CommandLine, Name))
        return FALSE;

    //
    // Get the alternate name of the drive and remove any previous entry
    // for it from the registry
    //
    if (!IFS_SYSTEM::NtDriveNameToDosDriveName(Name, &dos_drive_name) ||
        !dos_path.Initialize(&dos_drive_name))
        return FALSE;

    rst = dos_path.AnalyzePath(&volume_name,
                               &fullpath,
                               &drive_path_string);

    switch (rst) {
        case PATH_OK:
            DebugAssert(drive_path_string.QueryChCount() == 0);

            if (dos_path.GetPathString()->Stricmp(&volume_name) != 0) {
                // use volume_name as the alternate name
                name = &volume_name;
            } else {
                // try to use fullpath as the alternate name
                name = fullpath.GetPathString();

                if (name->QueryChCount() != 2)
                    break;  // alternate name not drive letter so done
            }

            if (!IFS_SYSTEM::DosDriveNameToNtDriveName(name, &nt_drive_name))
                return FALSE;

            if (!AUTOREG::DeleteEntry(&CommandLine, &nt_drive_name))
                return FALSE;

            break;

        default:
            return FALSE;
    }

    if (Options & CHKDSK_RECOVER) {

        DSTRING R_Option;

        if (!R_Option.Initialize( "/r " ) ||
            !CommandLine.Strcat( &R_Option )) {

            return FALSE;
        }
    }

    if (Options & CHKDSK_SKIP_INDEX_SCAN) {

        DSTRING I_Option;

        if (!I_Option.Initialize( "/i " ) ||
            !CommandLine.Strcat( &I_Option )) {

            return FALSE;
        }
    }

    if (Options & CHKDSK_SKIP_CYCLE_SCAN) {

        DSTRING C_Option;

        if (!C_Option.Initialize( "/c " ) ||
            !CommandLine.Strcat( &C_Option )) {

            return FALSE;
        }
    }

    if (Options & CHKDSK_RESIZE_LOGFILE) {

        DSTRING L_Option;
        CHAR buf[20];

        sprintf(buf, "/l:%d ", LogFileSize / 1024);

        if (!L_Option.Initialize( buf ) ||
            !CommandLine.Strcat( &L_Option )) {

            return FALSE;
        }
    }

    if (Options & CHKDSK_ALGORITHM_SPECIFIED) {

        DSTRING I_Option;
        CHAR buf[20];

        sprintf(buf, "/i:%d ", Algorithm);

        if (!I_Option.Initialize( buf ) ||
            !CommandLine.Strcat( &I_Option )) {

            return FALSE;
        }
    }

    //
    // if /f specified but it's not because of /r, /i, /i:chunks, or /c, then
    // specify /p as well.  The options /r, /i, /i:chunks, or /c implies /p
    // for autochk.
    //
    if (Fix &&
        !(Options & (CHKDSK_RECOVER |
                     CHKDSK_ALGORITHM_SPECIFIED |
                     CHKDSK_SKIP_INDEX_SCAN |
                     CHKDSK_SKIP_CYCLE_SCAN))) {
        DSTRING P_Option;

        if (!P_Option.Initialize( "/p " ) ||
            !CommandLine.Strcat( &P_Option )) {

            return FALSE;
        }
    }

    return CommandLine.Strcat( Name ) &&
           AUTOREG::PushEntry( &CommandLine );
#else

    return FALSE;

#endif // _AUTOCHECK_
}

IFSUTIL_EXPORT
BOOLEAN
VOL_LIODPDRV::QueryAutochkTimeOut(
    OUT PULONG      TimeOut
    )
/*++

Routine Description:

    This routine returns the count down time before autochk
    resumes.

Arguments:

    TimeOut     -- Supplies the location to store the timeout value.

Return Value:

    TRUE if successful.

--*/
{
    return QueryTimeOutValue(TimeOut);
}

IFSUTIL_EXPORT
BOOLEAN
VOL_LIODPDRV::SetAutochkTimeOut(
    IN  ULONG      TimeOut
    )
/*++

Routine Description:

    This routine sets the count down time before autochk
    resumes.

Arguments:

    TimeOut     -- Supplies the count down time in seconds

Return Value:

    TRUE if successful.

--*/
{
    return SetTimeOutValue(TimeOut);
}



FORMAT_ERROR_CODE
VOL_LIODPDRV::FormatSonyG2MS(
    IN OUT PMESSAGE     Message,
    IN     BIG_INT      Sectors
    )
/*++

Routine Description:

    This routine formats a Sony Generation 2 or later Memory Stick.

Arguments:

    Message         - Supplies an outlet for messages.
    Sectors         - Supplies the number of sectors to formamt.

Return Value:

    NoError         - Success
    GeneralError    - Failure

--*/
{
    FORMAT_ERROR_CODE   errcode = NoError;

#if !defined(_AUTOCHECK_)
    if (SendSonyMSFormatCmd()) {

        SENSE_DATA      sd;
        LARGE_INTEGER   timeout = { -20000000, -1 };        // 2 seconds
        ULONG           elapsed_time = 0;
        CONST ULONG     max_elapsed_time = 100/((timeout/-10000000).GetLowPart());  // 100 seconds
        ULONG           percent = 0;
        ULONG           new_percent = 0;
        ULONG           new_percent2;
        ULONG           estimated_time;


#if DBG==1
        UCHAR           SENSE_KEY[100];
        UCHAR           ADSENSE[100];
        UCHAR           ADSENSEQ[100];
#endif

        if (IsSonyMSProgressIndicatorCapable()) {

            do {

                NtDelayExecution(FALSE, &timeout);
                elapsed_time++;

                if (!SendSonyMSRequestSenseCmd(&sd)) {
                    // error in sending Request Sense command
                    if (Message) {
                        Message->DisplayMsg(MSG_FMT_CANNOT_TALK_TO_DEVICE);
                    }
                    errcode = GeneralError;
                    break;
                }

#if DBG==1
                SENSE_KEY[elapsed_time] = sd.SenseKey;
                ADSENSE[elapsed_time] = sd.AdditionalSenseCode;
                ADSENSEQ[elapsed_time] = sd.AdditionalSenseCodeQualifier;
#endif

                // Check to see if media is present

                if (sd.SenseKey == SCSI_SENSE_NOT_READY &&
                    sd.AdditionalSenseCode == SCSI_ADSENSE_NO_MEDIA_IN_DEVICE &&
                    sd.AdditionalSenseCodeQualifier == SCSI_SENSEQ_CAUSE_NOT_REPORTABLE) {
                    // media not present error
                    if (Message) {
                        Message->DisplayMsg(MSG_FORMAT_NO_MEDIA_IN_DRIVE);
                    }
                    errcode = GeneralError;
                    break;
                }

                if (sd.SenseKey == SCSI_SENSE_NOT_READY ||
                    sd.SenseKey == SCSI_SENSE_NO_SENSE ||
                    (sd.SenseKey == SCSI_SENSE_UNIT_ATTENTION &&
                     sd.AdditionalSenseCode == SCSI_ADSENSE_MEDIUM_CHANGED &&
                     sd.AdditionalSenseCodeQualifier == SCSI_SENSEQ_CAUSE_NOT_REPORTABLE)) {
                    if (sd.SenseKeySpecific[0] & SENSE_DATA_SKSV_BIT) {
                        new_percent = ((sd.SenseKeySpecific[1] << 8) +
                                       sd.SenseKeySpecific[2])*100 / 65536;
                    }
                } else {
                    // unexpected SenseKey
                    DebugPrintTrace(("IFSUTIL: Unexpected sense key %x/%x/%x\n",
                                     sd.SenseKey,
                                     sd.AdditionalSenseCode,
                                     sd.AdditionalSenseCodeQualifier));
                    if (Message) {
                        Message->DisplayMsg(MSG_FORMAT_FAILED);
                    }
                    errcode = GeneralError;
                    break;
                }

                new_percent2 = (elapsed_time * 100) / (max_elapsed_time + 1);
                if (new_percent < new_percent2) {
                    // make sure the progress bar is moving
                    new_percent = new_percent2;
                }
                if (new_percent > percent) {
                    percent = new_percent;
                    if (Message && !Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent)) {
                        errcode = GeneralError;
                        break;
                    }
                } else {
                    if (Message && !Message->DisplayMsg(MSG_HIDDEN_STATUS, NORMAL_MESSAGE, 0)) {
                        errcode = GeneralError;
                        break;
                    }
                }

            } while (sd.SenseKey != SCSI_SENSE_NO_SENSE &&
                     elapsed_time <= max_elapsed_time);

        } else {

            // estimated time for memory stick to format
            estimated_time = ((Sectors*QuerySectorSize()/1024/1024).GetLowPart()*27+530)/100/
                             (timeout/-10000000).GetLowPart();

            do {
                NtDelayExecution(FALSE, &timeout);
                elapsed_time++;

                if (!SendSonyMSTestUnitReadyCmd(&sd)) {
                    // error in sending Test Unit Ready command
                    if (Message) {
                        Message->DisplayMsg(MSG_FMT_CANNOT_TALK_TO_DEVICE);
                    }
                    errcode = GeneralError;
                    break;
                }

#if DBG==1
                SENSE_KEY[elapsed_time] = sd.SenseKey;
                ADSENSE[elapsed_time] = sd.AdditionalSenseCode;
                ADSENSEQ[elapsed_time] = sd.AdditionalSenseCodeQualifier;
#endif

                // During formatting, SenseKey should be NOT READY
                // When done with format, SenseKey should be UNIT ATTENTION or NO SENSE
                // For Gen 2 reader, it emits a MEDIUM ERROR before UNIT ATTENTION/NO SENSE

                if (!(sd.SenseKey == SCSI_SENSE_NOT_READY ||
                      sd.SenseKey == SCSI_SENSE_NO_SENSE ||
                      (sd.SenseKey == SCSI_SENSE_UNIT_ATTENTION &&
                       sd.AdditionalSenseCode == SCSI_ADSENSE_MEDIUM_CHANGED &&
                       sd.AdditionalSenseCodeQualifier == SCSI_SENSEQ_CAUSE_NOT_REPORTABLE) ||
                      (sd.SenseKey == SCSI_SENSE_MEDIUM_ERROR &&
                       sd.AdditionalSenseCode == SCSI_ADSENSE_INVALID_MEDIA &&
                       sd.AdditionalSenseCodeQualifier == SCSI_SENSEQ_UNKNOWN_FORMAT))) {
                    // unexpected SenseKey
                    DebugPrintTrace(("IFSUTIL: Unexpected sense key %x/%x/%x\n",
                                     sd.SenseKey,
                                     sd.AdditionalSenseCode,
                                     sd.AdditionalSenseCodeQualifier));
                    if (Message) {
                        Message->DisplayMsg(MSG_FORMAT_FAILED);
                    }
                    errcode = GeneralError;
                    break;
                }

                if (elapsed_time <= estimated_time) {
                    new_percent = (elapsed_time * 70 / estimated_time); // 0-70%
                } else {
                    // if it exceeded the estimate time, then spread the remaining time
                    // over the last 30 percent.
                    new_percent = 70 + (elapsed_time-estimated_time)*30 /
                                       (max_elapsed_time - estimated_time + 1); // 70-100%
                }

                if (new_percent > percent) {
                    percent = new_percent;
                    if (Message && !Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent)) {
                        errcode = GeneralError;
                        break;
                    }
                } else {
                    if (Message && !Message->DisplayMsg(MSG_HIDDEN_STATUS, NORMAL_MESSAGE, 0)) {
                        errcode = GeneralError;
                        break;
                    }
                }
            } while (sd.SenseKey != SCSI_SENSE_NO_SENSE &&
                     elapsed_time <= max_elapsed_time);
        }

        if (elapsed_time > max_elapsed_time) {
            if (Message) {
                Message->DisplayMsg(MSG_FMT_TIMEOUT);
            }
            errcode = GeneralError;
        }

    } else {
        if (Message) {
            Message->DisplayMsg(MSG_FMT_CANNOT_TALK_TO_DEVICE);
        }
        errcode = GeneralError;
    }
#endif
    return errcode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\mode\cons.cxx ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

	Con

Abstract:

	Takes care of request involving the console ( CON: )

Author:

	Ramon Juan San Andres (ramonsa) 26-Jun-1991

Notes:

	This module issues direct calls to USER, because having ULIB doing
	so causes programs to crash.

Revision History:

--*/


#include "mode.hxx"
#include "cons.hxx"
#include "keyboard.hxx"
#include "path.hxx"
#include "screen.hxx"
#include "stream.hxx"
#include "system.hxx"

//
//	Local prototypes
//
BOOLEAN
ConStatus(
	IN	PREQUEST_HEADER	Request,
	IN	BOOLEAN 		JustCodePage
	);

BOOLEAN
ConCodePage(
	IN	PREQUEST_HEADER	Request
	);

BOOLEAN
ConSetRowCol(
	IN	PREQUEST_HEADER	Request
	);

BOOLEAN
ConSetTypematic(
	IN	PREQUEST_HEADER	Request
	);




BOOLEAN
ConHandler(
	IN	PREQUEST_HEADER	Request
	)

/*++

Routine Description:

	Handles console requests

Arguments:

	Request -	Supplies pointer to request

Return Value:

    None.

Notes:

--*/

{

	BOOLEAN Served = TRUE;	//	TRUE if request served OK.

	DebugPtrAssert( Request );
	DebugAssert( Request->DeviceType == DEVICE_TYPE_CON );

	//
	//	So the device is valid. Now serve the request
	//
	switch( Request->RequestType ) {

	case REQUEST_TYPE_STATUS:

		//
		//	Display state of CON device
		//
		Served = ConStatus( Request, FALSE );
		break;

	case REQUEST_TYPE_CODEPAGE_PREPARE:
	case REQUEST_TYPE_CODEPAGE_SELECT:
	case REQUEST_TYPE_CODEPAGE_REFRESH:

		//
		//	Handle Codepage requests
		//
		Served = ConCodePage( Request );
		break;

	case REQUEST_TYPE_CODEPAGE_STATUS:

		//
		//	Display codepage status
		//
		Served = ConStatus( Request, TRUE );
		break;

	case REQUEST_TYPE_CON_SET_ROWCOL:

		//
		//	Set rows & columns
		//
		Served = ConSetRowCol( Request );
		break;

	case REQUEST_TYPE_CON_SET_TYPEMATIC:

		//
		//	Set typematic rate
		//
		Served = ConSetTypematic( Request );
		break;

	default:

        DisplayMessageAndExit( MODE_ERROR_INVALID_PARAMETER,
							   NULL,
							   (ULONG)EXIT_ERROR );

	}

	return Served;


}

BOOLEAN
ConStatus(
	IN	PREQUEST_HEADER	Request,
	IN	BOOLEAN 		JustCodePage
	)

/*++

Routine Description:

	Displays status of a console

Arguments:

	Request 	-	Supplies pointer to request
	JustCodePage-	Supplies a flag which if TRUE means that only
					the codepage status should be displayed.

Return Value:

	BOOLEAN -	TRUE if status displayed successfully,
				FALSE otherwise

Notes:

--*/

{

	SCREEN		Screen;

	PATH		ConPath;

	USHORT		Rows;
	USHORT		Cols;

	ULONG		Delay = 0;
	ULONG		Speed = 0;

    DSTRING     CodepageName;

	ULONG		Language;
	ULONG		Country;
	ULONG		Codepage;

    DSTRING     CodepageString;
	PSTR		S1, S2;


    if ( !ConPath.Initialize( (LPWSTR)L"CON" ) ) {
		DisplayMessageAndExit( MODE_ERROR_NO_MEMORY, NULL, (ULONG)EXIT_ERROR );
	}

	//
	//	Write the Header
	//
	WriteStatusHeader( &ConPath );

   if ( !Screen.Initialize() ) {
      DisplayMessageAndExit( MODE_ERROR_NO_MEMORY, NULL, (ULONG)EXIT_ERROR );
   }

	if ( !JustCodePage ) {

		//
		//	Display non-codepage information
		//

		Screen.QueryScreenSize( &Rows, &Cols );

		Message->Set( MODE_MESSAGE_STATUS_LINES );
		Message->Display( "%d", Rows );

		Message->Set( MODE_MESSAGE_STATUS_COLS );
		Message->Display( "%d", Cols	);

		if (!SystemParametersInfo( SPI_GETKEYBOARDSPEED, 0, (PVOID)&Speed, 0 )) {
			ExitWithError( GetLastError() );
		}
		Message->Set( MODE_MESSAGE_STATUS_RATE );
		Message->Display( "%d", Speed );

		if (!SystemParametersInfo( SPI_GETKEYBOARDDELAY, 0, (PVOID)&Delay, 0 )) {
			ExitWithError( GetLastError() );
		}

		Message->Set( MODE_MESSAGE_STATUS_DELAY );
		Message->Display( "%d", Delay );


    }

    Message->Set( MODE_MESSAGE_STATUS_CODEPAGE );
    Message->Display( "%d", Screen.QueryCodePage( ) );

	Get_Standard_Output_Stream()->WriteChar( '\r' );
	Get_Standard_Output_Stream()->WriteChar( '\n' );

	return TRUE;
}

BOOLEAN
ConCodePage(
	IN	PREQUEST_HEADER	Request
	)

/*++

Routine Description:

	Handles Codepage requests for the console

Arguments:

	Request 	-	Supplies pointer to request

Return Value:

	BOOLEAN -	TRUE if request handled successfully,
				FALSE otherwise

Notes:

--*/

{
    SCREEN                              Screen;
    PREQUEST_DATA_CON_CODEPAGE_SELECT   Data;


    //
    //  We only process Codepage Select requests, all other requests
    //  are No-Ops. Note that the Codepage Status request is not
    //  processed here.
    //
    if ( Request->RequestType == REQUEST_TYPE_CODEPAGE_SELECT ) {

        Data = (PREQUEST_DATA_CON_CODEPAGE_SELECT)&(((PCON_REQUEST)Request)->
                        Data.CpSelect);

        if ( !Screen.Initialize() ) {
            DisplayMessageAndExit( MODE_ERROR_NO_MEMORY, NULL, (ULONG)EXIT_ERROR );
        }

        if ( !Screen.SetCodePage( Data->Codepage ) ||
             !Screen.SetOutputCodePage( Data->Codepage) ) {
            DisplayMessageAndExit( MODE_ERROR_INVALID_CODEPAGE, NULL, (ULONG)EXIT_ERROR );
        }

#ifdef FE_SB
        LANGID LangId;

        switch (GetConsoleOutputCP()) {
        case 932:
            LangId = MAKELANGID( LANG_JAPANESE, SUBLANG_DEFAULT );
            break;
        case 949:
            LangId = MAKELANGID( LANG_KOREAN, SUBLANG_KOREAN );
            break;
        case 936:
            LangId = MAKELANGID( LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED );
            break;
        case 950:
            LangId = MAKELANGID( LANG_CHINESE, SUBLANG_CHINESE_TRADITIONAL );
            break;
        default:
            LangId = PRIMARYLANGID(LANGIDFROMLCID( GetUserDefaultLCID() ));
            if (LangId == LANG_JAPANESE ||
                LangId == LANG_KOREAN   ||
                LangId == LANG_CHINESE    ) {
                LangId = MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US );
            }
            else {
                LangId = MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT );
            }
            break;
        }

        SetThreadLocale( MAKELCID(LangId, SORT_DEFAULT) );
#endif

        ConStatus( Request, FALSE );

    } else {

        DisplayMessageAndExit( MODE_MESSAGE_NOT_NEEDED, NULL, EXIT_SUCCESS );
    }

	return TRUE;
}

BOOLEAN
ConSetRowCol(
	IN	PREQUEST_HEADER	Request
	)

/*++

Routine Description:

	Sets number of rows and columns in the console window.


Arguments:

	Request 	-	Supplies pointer to request

Return Value:

	BOOLEAN -	TRUE if Number of Rows & Columns set successfully,
				FALSE otherwise

Notes:

--*/

{

	PREQUEST_DATA_CON_ROWCOL	Data;

	SCREEN			Screen;

	USHORT			Rows;
    USHORT          Cols;
    BOOLEAN         IsFullScreen;


	DebugPtrAssert( Request);

	Data = (PREQUEST_DATA_CON_ROWCOL)&(((PCON_REQUEST)Request)->Data.RowCol);

    if ( !Screen.Initialize() ) {
        DisplayMessageAndExit( MODE_ERROR_NO_MEMORY, NULL, (ULONG)EXIT_ERROR );
    }

	if ( !Data->SetCol || !Data->SetLines ) {

		//
		//	Since we don't have both values, take the current ones.
		//
		Screen.QueryScreenSize( &Rows, &Cols );
	}

	//
	//	Set the number of rows and columns
	//
	if ( Data->SetCol ) {

		Cols = (USHORT)Data->Col;

	}

	if ( Data->SetLines ) {

		Rows = (USHORT)Data->Lines;

	}

    if ( !Screen.ChangeScreenSize( Rows, Cols, &IsFullScreen ) ) {

		//
		//	Cannot change the screen size
        //
        if ( IsFullScreen ) {
            DisplayMessageAndExit( MODE_ERROR_FULL_SCREEN, NULL, (ULONG)EXIT_ERROR );
        } else {
            DisplayMessageAndExit( MODE_ERROR_INVALID_SCREEN_SIZE, NULL, (ULONG)EXIT_ERROR );
        }
	}

	return TRUE;
}

BOOLEAN
ConSetTypematic(
	IN	PREQUEST_HEADER	Request
	)

/*++

Routine Description:

	Sets thje typematic rate

Arguments:

	DevicePath	-	Supplies pointer to path of device
	Request 	-	Supplies pointer to request

Return Value:

	BOOLEAN -	TRUE if typematic rate set successfully,
				FALSE otherwise

Notes:

--*/

{
	PREQUEST_DATA_CON_TYPEMATIC		Data;

	DebugPtrAssert( Request);


	Data = (PREQUEST_DATA_CON_TYPEMATIC)&(((PCON_REQUEST)Request)->Data.Typematic);

	if ( Data->SetRate ) {
		if (!SystemParametersInfo( SPI_SETKEYBOARDSPEED, (UINT)Data->Rate, NULL, SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE )) {
			DisplayMessageAndExit( MODE_ERROR_INVALID_RATE, NULL, (ULONG)EXIT_ERROR);
		}
	}
	if ( Data->SetDelay ) {
		if (!SystemParametersInfo( SPI_SETKEYBOARDDELAY, (UINT)Data->Delay, NULL, SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE )) {
			DisplayMessageAndExit( MODE_ERROR_INVALID_DELAY, NULL, (ULONG)EXIT_ERROR);
		}
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\mode\common.cxx ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

	Common

Abstract:

	Takes care of request which are common to all devices.

	Also contains any function which is common to two or more devices.

Author:

	Ramon Juan San Andres (ramonsa) 26-Jun-1991

Revision History:

--*/

#define _NTAPI_ULIB_

#include "mode.hxx"
#include "common.hxx"
#include "com.hxx"
#include "array.hxx"
#include "arrayit.hxx"
#include "stream.hxx"
#include "system.hxx"
#include "redir.hxx"
#include "registry.hxx"
#include "regvalue.hxx"



BOOLEAN
CommonHandler(
	IN	PREQUEST_HEADER	Request
	)

/*++

Routine Description:

	Calls all the device handlers with the supplied request.

Arguments:

	Request -	Supplies pointer to request

Return Value:

    None.

Notes:

--*/

{

    ULONG                   Device;         //  Current device
    REDIR_STATUS            Status;
    PPATH                   DevicePath;
    REGISTRY                Registry;
    DSTRING                 ParentName;
    DSTRING                 KeyName;
    ARRAY                   ValueArray;
    PARRAY_ITERATOR         Iterator;
    ULONG                   ErrorCode;
    PCBYTE                  Data;
    DSTRING                 PortName;
    DSTRING                 QualifiedName;
    PREGISTRY_VALUE_ENTRY   Value;


	DebugPtrAssert( Request );
	DebugAssert( Request->DeviceType == DEVICE_TYPE_ALL );

	//
	//	If this is not a null request, then we pass this request to all
	//	device handlers. Note that this means that a device handler must
	//	NOT modify the request, otherwise the next device handler would
	//	get a corrupted request.
	//
	if ( Request->RequestType != REQUEST_TYPE_NULL ) {

        //
        //  LPT devices
        //
		for ( Device = 1; Device <= LAST_LPT; Device++ ) {

            if ( IsAValidLptDevice( DEVICE_TYPE_LPT, Device, &DevicePath ) ||
                 REDIR::IsRedirected( &Status, DevicePath )
               ) {

			    Request->DeviceType   = DEVICE_TYPE_LPT;
			    Request->DeviceNumber = Device;

			    //
			    //	Have it serviced
			    //
			    DeviceHandler[ DEVICE_TYPE_LPT ]( Request );
                DELETE( DevicePath );
            }
        }


        //
        //  COM devices
        //
        if ( ParentName.Initialize( "" )            &&
             KeyName.Initialize( COMM_KEY_NAME )    &&
             ValueArray.Initialize()                &&
             Registry.Initialize()                  &&
             Registry.QueryValues(
                        PREDEFINED_KEY_LOCAL_MACHINE,
                        &ParentName,
                        &KeyName,
                        &ValueArray,
                        &ErrorCode
                        ) ) {

            if ( Iterator = (PARRAY_ITERATOR)ValueArray.QueryIterator() ) {

                while ( Value = (PREGISTRY_VALUE_ENTRY)(Iterator->GetNext() ) ) {

                    if ( Value->GetData( &Data ) ) {

                        if ( PortName.Initialize( (PWSTR)Data )     &&
                             QualifiedName.Initialize( L"\\\\.\\" ) &&
                             QualifiedName.Strcat( &PortName ) ) {

                            if ( SYSTEM::QueryFileType( &QualifiedName ) == CharFile ) {

                                Request->DeviceType = DEVICE_TYPE_COM;
                                Request->DeviceName = &PortName;

                                DeviceHandler[ DEVICE_TYPE_COM ]( Request );

                            }
                        }
                    }
                }

                DELETE( Iterator );
            }
        }

        //
        //  CON device
        //
        Request->DeviceType     = DEVICE_TYPE_CON;
        Request->DeviceNumber   = 1;
        DeviceHandler[ DEVICE_TYPE_CON ]( Request );

	}

	return TRUE;
}

BOOLEAN
IsAValidDevice (
    IN  DEVICE_TTYPE     DeviceType,
	IN	ULONG			DeviceNumber,
	OUT	PPATH			*DevicePathPointer
	)

/*++

Routine Description:

	Determines if a certain device exists and optionally creates a path
	for the device.

Arguments:

	DeviceType		-	Supplies the type of device
	DeviceNumber	-	Supplies the device number
	DeviceName		-	Supplies a pointer to a pointer to the path for
						the device.

Return Value:

	BOOLEAN -	TRUE if the device exists,
				FALSE otherwise.

Notes:

--*/

{
    DSTRING     DeviceName;
    DSTRING     QualifiedDeviceName;
    DSTRING     Number;
	CHNUM		Index;
	FILE_TYPE	DriveType;
	PPATH		DevicePath;


	//
	//	Determine what device we're working with.
	//
	switch ( DeviceType ) {

	case DEVICE_TYPE_COM:
		DeviceName.Initialize("COM#");
		break;

	case DEVICE_TYPE_LPT:
		DeviceName.Initialize("LPT#");
		break;

	case DEVICE_TYPE_CON:
		DeviceName.Initialize("CON");
		break;

	default:
		DebugAssert( FALSE );

	}

	//
	//	All devices (except the console) have a device number
	//
	if ( DeviceType != DEVICE_TYPE_CON ) {

		//
		//	Get the device number in string form
		//
		Number.Initialize( DeviceNumber );

		//
		//	Now substitute the matchnumber character with the number
		//
		Index = DeviceName.Strchr( '#'	);
		DebugAssert( Index != INVALID_CHNUM );

        DeviceName.Replace( Index, 1, &Number );

	}

	//
	//	We have the device name, gets its type.
    //
    QualifiedDeviceName.Initialize( "\\\\.\\" );
    QualifiedDeviceName.Strcat( &DeviceName );

    DriveType = SYSTEM::QueryFileType( &QualifiedDeviceName );

	//
	//	If the caller wants a path, make it.
	//
	if ( DevicePathPointer ) {

		DevicePath = NEW PATH;
		DebugPtrAssert( DevicePath );

		if ( DevicePath ) {

			DevicePath->Initialize( &DeviceName );

		}

		*DevicePathPointer = DevicePath;
	}

	//
	//	Now return whether the device is valid or not
	//
	return DriveType == CharFile;

}

BOOLEAN
WriteStatusHeader (
	IN	PCPATH		DevicePath
	)

/*++

Routine Description:

	Write the header for a status block.

Arguments:

	DevicePath	-	Supplies the device path

Return Value:

	BOOLEAN -	TRUE if header written
				FALSE otherwise.

Notes:

--*/

{

	PWSTRING	Header;
	CHNUM		Index;

	Header	=	QueryMessageString( MODE_MESSAGE_STATUS );

	if ( !Header ) {

		DisplayMessageAndExit( MODE_ERROR_NO_MEMORY, NULL, (ULONG)EXIT_ERROR );

	}

	//
	//	Replace the match-all character in the header with the device
	//	path.
	//
	Index = Header->Strchr( '*' );
	DebugAssert( Index != INVALID_CHNUM );

    Header->Replace( Index, 1, DevicePath->GetPathString() );

	//
	//	Display the header
	//
	Get_Standard_Output_Stream()->WriteChar( '\r' );
	Get_Standard_Output_Stream()->WriteChar( '\n' );
	Get_Standard_Output_Stream()->WriteString( Header );
	Get_Standard_Output_Stream()->WriteChar( '\r' );
	Get_Standard_Output_Stream()->WriteChar( '\n' );

	//
	//	Underline it
    //
    for (Index = 0; Index < Header->QueryChCount(); Index++) {
        Header->SetChAt( '-', Index );
    }
	Get_Standard_Output_Stream()->WriteString( Header );
	Get_Standard_Output_Stream()->WriteChar( '\r' );
	Get_Standard_Output_Stream()->WriteChar( '\n' );

	DELETE( Header );

	return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\mode\mode.cxx ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

        Mode

Abstract:

        Mode utility

Author:

        Ramon Juan San Andres (ramonsa) 26-Jun-1991

Revision History:

--*/


#include "mode.hxx"
#include "system.hxx"



//
//      Message stream
//
PSTREAM_MESSAGE Message;


//
//      DeviceHandler is an array of pointers to the different device
//      handlers.
//
DEVICE_HANDLER  DeviceHandler[ NUMBER_OF_DEVICE_TYPES ] = {

                LptHandler,
                ComHandler,
                ConHandler,
                CommonHandler

        };




VOID
InitializeMode (
        );

VOID
DeallocateResources (
        );


PSTREAM
Get_Standard_Input_Stream();

PSTREAM
Get_Standard_Output_Stream();

PSTREAM
Get_Standard_Error_Stream();







VOID __cdecl
main (
        )

/*++

Routine Description:

        Main function of the Mode utility

Arguments:

    None.

Return Value:

    None.

Notes:

--*/

{
        PREQUEST_HEADER Request;

        //
        //      Initialize whatever is necessary
        //
        InitializeMode();

        //
        //      Verify the OS version
        //
        if ( !SYSTEM::IsCorrectVersion() ) {

                DisplayMessageAndExit( MODE_ERROR_INCORRECT_OS_VERSION,
                                                           NULL,
                                                           (ULONG)EXIT_ERROR );
        }

        //
        //      Obtain a request from the command line. Note that the
        //      first field of the request is the device type.
        //
        Request = GetRequest();
        DebugPtrAssert( Request );
        DebugAssert( Request->DeviceType <= DEVICE_TYPE_ALL );

        //
        //      Let the device handler for the specified type take care of the
        //      request.
        //
        DebugPtrAssert( DeviceHandler[ Request->DeviceType ] );
        DeviceHandler[ Request->DeviceType ]( Request );

        //
        //      Deallocate resources
        //
        FREE( Request );
        DeallocateResources();

        //
        //      We're done
        //
        ExitMode( EXIT_SUCCESS );

}

VOID
InitializeMode (
        )

/*++

Routine Description:

        Allocates resources and initializes Mode structures

Arguments:

    None.

Return Value:

    None.

Notes:

--*/

{
        if ( //
         // Construct and initialize a STREAM_MESSAGE.
                 //
         !(Message = NEW STREAM_MESSAGE ) ||
         !Get_Standard_Output_Stream() ||
                 !Message->Initialize( Get_Standard_Output_Stream(),
                                                          Get_Standard_Input_Stream() )
           ) {

                //
                //      We don't have Message, so we cannot display the error
                //      text.
                //
                exit( EXIT_ERROR );
        }

        //
        //      Allocate resources which are private to each type of device
        //
        ComAllocateStuff();

}

VOID
DeallocateResources (
        )

/*++

Routine Description:

        Deallocates resources allocated in InitializeMode

Arguments:

    None.

Return Value:

    None.

Notes:

--*/

{

        DELETE( Message );
        ComDeAllocateStuff();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\mode\redir.cxx ===
#define _NTAPI_ULIB_

#include "ulib.hxx"
#include "path.hxx"
#include "wstring.hxx"
#include "redir.hxx"


//
//  The string below represents the path used to determine whether or not
//  an LPT device is redirected to a COM device.
//  Due to performance, this path should always be defined in upper case.
//

#define LPT_REDIRECTION_PATH    (LPWSTR)L"\\??\\COM"




BOOLEAN
REDIR::Redirect (
    IN PCPATH   Device,
    IN PCPATH   Destination
    )

/*++

Routine Description:

    Redirects a device.  The device is redirected by creating a symbolic link
    to the destination device. If this is the first redirection of the device,
    the original symbolic link is saved in the registry under a volatile key
    so that it can be recovered latter on.

    Note that redirection requires sufficient privileges to create symbolic
    links and to create entries in the registry under SAVE_ROOT.

Arguments:

    Device      -   Supplies the device to be redirected.

    Destination -   Supplies the device to be redirected to

Return Value:

    BOOLEAN -   TRUE if the device was successfully redirected.
                FALSE otherwise.

--*/

{
    BOOLEAN         Redirected  = FALSE;
    PCWSTRING       DeviceName;
    PCWSTRING       DestinationName;


    DebugPtrAssert( Device );
    DebugPtrAssert( Destination );

    if( ( Device != NULL ) &&
        ( Destination != NULL ) &&
        ( ( DeviceName = Device->GetPathString() ) != NULL ) &&
        ( ( DestinationName = Destination->GetPathString() ) != NULL )
      ) {

        Redirected = DefineDosDevice( 0,
                                      DeviceName->GetWSTR(),
                                      DestinationName->GetWSTR() ) ? TRUE : FALSE;

#if DBG
        if( !Redirected ) {
            DebugPrint( "MODE: DefineDosDevice() failed" );
            DebugPrintTrace(( "MODE: DefineDosDevice() failed, Device = %ls, Destination = %ls, Error = %d \n",
                       DeviceName->GetWSTR(),
                       DestinationName->GetWSTR(),
                       GetLastError() ));
        }
#endif

    }
    return Redirected;
}




BOOLEAN
REDIR::IsRedirected (
    OUT PREDIR_STATUS   Status,
    IN  PCPATH          Device,
    IN  PCPATH          Destination
    )

/*++

Routine Description:

    Determines if a device is being redirected to a specific device.

Arguments:

    Status      -   Supplies pointer to redirection status. Only set in
                    if the return value of this method is FALSE

    Device      -   Supplies the device about which we want to find out if
                    it is redirected or not.

    Destination -   Supplies a pointer to a destination device.

Return Value:

    TRUE if the device is redirected to the destination
    FALSE otherwise

--*/

{
    BOOLEAN         Redirected  = FALSE;
    PCWSTRING       DeviceName;
    PCWSTRING       DestinationName;
    DSTRING         DstRedir;
    FSTRING         LptRedirectionPath;
    DSTRING         TmpString;
    WCHAR           buf[ 2*(MAX_PATH + 1) ];
    PWSTR           pwstrTarget;

    DebugPtrAssert( Device );

    *Status = REDIR_STATUS_ERROR;

    if (NULL == (DeviceName = Device->GetPathString())) {
        return FALSE;
    }

    if (!QueryDosDevice(DeviceName->GetWSTR(),
                       buf,
                       sizeof(buf) / sizeof(WCHAR))) {

        //  The device probably doesn't exist

        return FALSE;
    }

    *Status = REDIR_STATUS_NONEXISTENT;

    pwstrTarget = buf;

    //  Find out if the LPT device is redirected to the destination.

    DstRedir.Initialize(pwstrTarget);

    return INVALID_CHNUM != DstRedir.Strstr(Destination->GetPathString());
}

BOOLEAN
REDIR::IsRedirected (
    OUT PREDIR_STATUS   Status,
    IN  PCPATH          Device
    )

/*++

Routine Description:

    Determines if a device is being redirected to any device.

Arguments:

    Status      -   Supplies pointer to redirection status. Only set in
                    if the return value of this method is FALSE

    Device      -   Supplies the device about which we want to find out if
                    it is redirected or not.

Return Value:

    TRUE if redirected, FALSE otherwise.

--*/

{
    BOOLEAN         Redirected  = FALSE;
    PCWSTRING       DeviceName;
    PCWSTRING       DestinationName;
    DSTRING         DstRedir;
    FSTRING         LptRedirectionPath;
    DSTRING         TmpString;
    WCHAR           Buffer[ 2*(MAX_PATH + 1) ];
    PWSTR           Pointer;
    PPATH           Destination = NULL;

    DebugPtrAssert( Device );

    *Status = REDIR_STATUS_ERROR;

    if( ( Device != NULL ) &&
        ( ( DeviceName = Device->GetPathString() ) != NULL ) ) {

        if( QueryDosDevice( DeviceName->GetWSTR(),
                            Buffer,
                            sizeof( Buffer ) / sizeof( WCHAR ) ) == 0 ) {
            //
            //  The device probably doesn't exist
            //

            return( FALSE );
        }


        //
        // At this point we know that the device exists.
        // Assume that the device is not redirected.
        //

        *Status = REDIR_STATUS_NONEXISTENT;

        Pointer = Buffer;

        LptRedirectionPath.Initialize( LPT_REDIRECTION_PATH );

        //
        //  Find out if the LPT device is redirected to a COM device
        //

        while( ( *Pointer != ( WCHAR )'\0' ) &&
               DstRedir.Initialize( Pointer ) &&
               ( DstRedir.Strupr() != NULL ) &&
               !Redirected ) {

            if( DstRedir.Strstr( &LptRedirectionPath ) != INVALID_CHNUM ) {
                //
                // The LPT device is redirected to a COM device
                //
                if( Destination != NULL ) {
                    if( ( ( DestinationName = Destination->GetPathString() ) != NULL ) &&
                        ( DstRedir.Strstr( DestinationName ) != INVALID_CHNUM ) ) {
                        Redirected = TRUE;
                    }
                } else {
                    Redirected = TRUE;
                }
            }
            Pointer +=  DstRedir.QueryChCount() + 1;
        }
    }

    return Redirected;
}




BOOLEAN
REDIR::EndRedirection (
    IN PCPATH   Device
    )

/*++

Routine Description:

    Ends the redirection of a device

Arguments:

    Device      -   Supplies the device


Return Value:


    TRUE if the device's redirection has ended.
    FALSE otherwise


--*/

{
    BOOLEAN         Done        = FALSE;
    PCWSTRING       DeviceName;
    REDIR_STATUS    Status;



    DebugPtrAssert( Device );

    if( IsRedirected( &Status, Device ) ) {
        if( ( Device != NULL ) &&
            ( ( DeviceName = Device->GetPathString() ) != NULL ) ) {

            Done = DefineDosDevice( DDD_REMOVE_DEFINITION /* | DDD_RAW_TARGET_PATH */,
                                    DeviceName->GetWSTR(),
                                    NULL ) ? TRUE : FALSE;

#if DBG
            if( !Done ) {
                DebugPrint( "MODE: DefineDosDevice() failed" );
                DebugPrintTrace(( "MODE: DefineDosDevice() failed, Device = %ls, Destination = %ls, Error = %d \n",
                           DeviceName->GetWSTR(),
                           LPT_REDIRECTION_PATH,
                           GetLastError() ));
            }
#endif
        }
    }
    return Done;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\mode\lpt.cxx ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    Lpt

Abstract:

    Takes care of request involving an LPT device

Author:

    Ramon Juan San Andres (ramonsa) 26-Jun-1991

Revision History:

--*/


#define _NTAPI_ULIB_

#include "mode.hxx"
#include "lpt.hxx"
#include "file.hxx"
#include "path.hxx"
#include "stream.hxx"
#include "redir.hxx"
#include "registry.hxx"
#include "regvalue.hxx"
#include "array.hxx"
#include "arrayit.hxx"

//
//  When an LPT port is set, mode only sends it an EPSON/IBM sequence.
//  The following macros define the EPSON sequences used.
//
#define     CODE_ESCAPE     0x27
#define     CODE_COLS_80    0x18
#define     CODE_COLS_132   0x15
#define     CODE_LINES_6    '2'
#define     CODE_LINES_8    '0'

#undef      LAST_COM
#define     LAST_COM        4


//
//  Local prototypes
//
BOOLEAN
LptStatus(
    IN  PCPATH          DevicePath,
    IN  PREQUEST_HEADER Request
    );

BOOLEAN
LptCodePage(
    IN  PCPATH          DevicePath,
    IN  PREQUEST_HEADER Request
    );

BOOLEAN
LptSetup(
    IN  PCPATH          DevicePath,
    IN  PREQUEST_HEADER Request
    );

BOOLEAN
LptRedirect(
    IN  PCPATH          DevicePath,
    IN  PREQUEST_HEADER Request
    );

BOOLEAN
LptEndRedir(
    IN  PCPATH          DevicePath,
    IN  PREQUEST_HEADER Request
    );

PPATH
GetRedirection(
    IN  PCPATH          DevicePath,
    OUT PREDIR_STATUS   RedirStatus
    );



BOOLEAN
IsAValidLptDevice (
    IN  DEVICE_TTYPE    DeviceType,
    IN  ULONG           DeviceNumber,
    OUT PPATH           *DevicePathPointer
    )

/*++

Routine Description:

    Determines if a certain comm device exists and optionally
    creates a path for it.

Arguments:

    DeviceType      -   Supplies the type of device
    DeviceNumber    -   Supplies the device number
    DeviceName      -   Supplies a pointer to a pointer to the path for
                        the device.

Return Value:

    BOOLEAN -   TRUE if the device exists,
                FALSE otherwise.

Notes:

--*/

{
    DSTRING                 DeviceName;
    DSTRING                 AlternateName;
    DSTRING                 Number;
    BOOLEAN                 Valid = FALSE;
    REGISTRY                Registry;
    DSTRING                 ParentName;
    DSTRING                 KeyName;
    ARRAY                   ValueArray;
    PARRAY_ITERATOR         Iterator;
    ULONG                   ErrorCode;
    PCBYTE                  Data;
    DSTRING                 PortName;
    PREGISTRY_VALUE_ENTRY   Value;


    UNREFERENCED_PARAMETER( DeviceType );


    if ( DeviceName.Initialize( (LPWSTR)L"LPT" )&&
         Number.Initialize( DeviceNumber )      &&
         DeviceName.Strcat( &Number )           &&
         AlternateName.Initialize( (LPWSTR)L"\\DosDevices\\" ) &&
         AlternateName.Strcat( &DeviceName )    &&
         ParentName.Initialize( "" )            &&
         KeyName.Initialize( LPT_KEY_NAME )     &&
         ValueArray.Initialize()                &&
         Registry.Initialize()
       ) {


        //
        //  Get the names of all the serial ports
        //
        if ( Registry.QueryValues(
                        PREDEFINED_KEY_LOCAL_MACHINE,
                        &ParentName,
                        &KeyName,
                        &ValueArray,
                        &ErrorCode
                        ) ) {

            //
            //  See if the given name matches any of the serial ports
            //
            if ( Iterator = (PARRAY_ITERATOR)ValueArray.QueryIterator() ) {

                while ( Value = (PREGISTRY_VALUE_ENTRY)(Iterator->GetNext() ) ) {

                    if ( Value->GetData( &Data ) ) {

                        if ( PortName.Initialize( (PWSTR)Data ) ) {

                            if ( !DeviceName.Stricmp( &PortName ) ||
                                 !AlternateName.Stricmp( &PortName ) ) {

                                Valid = TRUE;

                                break;
                            }
                        }
                    }
                }

                DELETE( Iterator );
            }
        }

        if ( DevicePathPointer ) {

            if (!(*DevicePathPointer = NEW PATH)) {
                DisplayMessageAndExit( MODE_ERROR_NO_MEMORY,
                                       NULL,
                                       (ULONG)EXIT_ERROR );
                return FALSE;   // help lint
            }
            (*DevicePathPointer)->Initialize( &DeviceName );
        }

    }

    return Valid;
}






BOOLEAN
LptHandler(
    IN  PREQUEST_HEADER Request
    )

/*++

Routine Description:

    Handles LPT requests

Arguments:

    Request -   Supplies pointer to request

Return Value:

    None.

Notes:

--*/

{
    PPATH           DevicePath;     //  Name of Device
    BOOLEAN         Served = TRUE;  //  TRUE if request served OK.
    REDIR_STATUS    Status;

    DebugPtrAssert( Request );
    DebugAssert( Request->DeviceType == DEVICE_TYPE_LPT );

    //
    //  Make sure that the device exists, and at the same time get its
    //  name ( For calling APIs ).
    //
    if ( Request->DeviceName ) {

        if (!(DevicePath = NEW PATH)) {
            DisplayMessageAndExit( MODE_ERROR_NO_MEMORY,
                                   NULL,
                                   (ULONG)EXIT_ERROR );
            return FALSE;   // help lint
        }

        DevicePath->Initialize( Request->DeviceName );

    } else if ( (!IsAValidLptDevice( Request->DeviceType, Request->DeviceNumber, &DevicePath ) &&
                 Request->RequestType != REQUEST_TYPE_LPT_REDIRECT &&
                 !REDIR::IsRedirected( &Status, DevicePath )) ||
                Request->DeviceNumber > LAST_LPT ) {
        DisplayMessageAndExit( MODE_ERROR_INVALID_DEVICE_NAME,
                               DevicePath->GetPathString(),
                               (ULONG)EXIT_ERROR );
    }

    //
    //  So the device is valid. Now serve the request
    //
    switch( Request->RequestType ) {


    case REQUEST_TYPE_STATUS:

        //
        //  Display State of device
        //
        Served = LptStatus( DevicePath, Request );
        break;

    case REQUEST_TYPE_CODEPAGE_PREPARE:
    case REQUEST_TYPE_CODEPAGE_SELECT:
    case REQUEST_TYPE_CODEPAGE_REFRESH:
    case REQUEST_TYPE_CODEPAGE_STATUS:

        //
        //  Codepage request
        //
        Served = LptCodePage( DevicePath, Request );
        break;

    case REQUEST_TYPE_LPT_SETUP:

        //
        //  Printer setup
        //
        Served = LptSetup( DevicePath, Request );
        break;

    case REQUEST_TYPE_LPT_REDIRECT:

        //
        //  Redirect LPT to COM
        //
        Served = LptRedirect( DevicePath, Request );
        break;

    case REQUEST_TYPE_LPT_ENDREDIR:

        //
        //  End redirection of LPT
        //
        Served = LptEndRedir( DevicePath, Request );
        break;

    default:

        DisplayMessageAndExit( MODE_ERROR_INVALID_PARAMETER,
                               NULL,
                               (ULONG)EXIT_ERROR );

    }

    DELETE( DevicePath );

    return Served;

}

BOOLEAN
LptStatus(
    IN  PCPATH          DevicePath,
    IN  PREQUEST_HEADER Request
    )

/*++

Routine Description:

    Displays status if an LPT device

Arguments:

    DevicePath  -   Supplies pointer to path of device
    Request     -   Supplies pointer to request

Return Value:

    BOOLEAN -   TRUE if status displayed successfully,
                FALSE otherwise

Notes:

--*/

{

    UNREFERENCED_PARAMETER( DevicePath );
    UNREFERENCED_PARAMETER( Request );

    PPATH           RedirPath = NULL;
    REDIR_STATUS    RedirStatus;

    RedirPath = GetRedirection( DevicePath, &RedirStatus );

    if ( !RedirPath && (RedirStatus != REDIR_STATUS_NONEXISTENT) ) {
        //
        //  We cannot find out the status of the redirection.
        //  This is almost certainly due to lack of privileges.
        //  We won't display the LPT status
        //
        return TRUE;
    }

    //
    //  Write the Header
    //
    WriteStatusHeader( DevicePath );


    if ( !RedirPath ) {

        DisplayMessage( MODE_MESSAGE_STATUS_NOT_REROUTED, NULL );

    } else {

        DisplayMessage( MODE_MESSAGE_STATUS_REROUTED, RedirPath->GetPathString() );

        DELETE( RedirPath );
    }

    Get_Standard_Output_Stream()->WriteChar( '\r' );
    Get_Standard_Output_Stream()->WriteChar( '\n' );

    return TRUE;
}

BOOLEAN
LptCodePage(
    IN  PCPATH          DevicePath,
    IN  PREQUEST_HEADER Request
    )

/*++

Routine Description:

    Handles Codepage requests for LPT device

Arguments:

    DevicePath  -   Supplies pointer to path of device
    Request     -   Supplies pointer to request

Return Value:

    BOOLEAN -   TRUE if request handled successfully,
                FALSE otherwise

Notes:

--*/

{

    UNREFERENCED_PARAMETER( DevicePath );
    UNREFERENCED_PARAMETER( Request );

    DisplayMessage( MODE_ERROR_CODEPAGE_OPERATION_NOT_SUPPORTED, NULL );

    return TRUE;
}

BOOLEAN
LptSetup(
    IN  PCPATH          DevicePath,
    IN  PREQUEST_HEADER Request
    )

/*++

Routine Description:

    Sets LPT state

Arguments:

    DevicePath  -   Supplies pointer to path of device
    Request     -   Supplies pointer to request

Return Value:

    BOOLEAN -   TRUE if state set successfully,
                FALSE otherwise

Notes:

--*/

{

    PREQUEST_DATA_LPT_SETUP Data;
    PFSN_FILE               Lpt;
    PFILE_STREAM            LptStream;



    Data = (PREQUEST_DATA_LPT_SETUP)&(((PLPT_REQUEST)Request)->Data.Setup);

    if  (  ( Data->SetCol && (Data->Col != 132) && ( Data->Col != 80 ) ) ||
           ( Data->SetLines && (Data->Lines != 6) && (Data->Lines != 8) ) ) {

        //
        //  Invalid number of lines or columns
        //
        DisplayMessageAndExit( MODE_ERROR_LPT_CANNOT_SET, NULL, (ULONG)EXIT_ERROR );

    }


    Lpt = SYSTEM::QueryFile( DevicePath );
    DebugPtrAssert( Lpt );

    if ( Lpt ) {
        LptStream = Lpt->QueryStream( WRITE_ACCESS );
        DebugPtrAssert( LptStream );
    }

    if ( !Lpt || !LptStream ) {
        DisplayMessageAndExit( MODE_ERROR_NO_MEMORY, NULL, (ULONG)EXIT_ERROR );
    }

    if ( Data->SetCol ) {

        //
        //  Set number of columns. The sequence consists of one byte.
        //
        LptStream->WriteByte( (Data->Col == 80) ? CODE_COLS_80 : CODE_COLS_132 );
    }

    if ( Data->SetLines ) {

        //
        //  Set line spacing. The sequence consists of one escape byte
        //  followed by one CODE_LINES_6 or CODE_LINES 8 byte.
        //
        LptStream->WriteByte( CODE_ESCAPE );
        LptStream->WriteByte( (Data->Lines == 6) ? CODE_LINES_6 : CODE_LINES_8 );

    }

    DELETE( LptStream );
    DELETE( Lpt );

    return TRUE;
}

BOOLEAN
LptRedirect(
    IN  PCPATH          DevicePath,
    IN  PREQUEST_HEADER Request
    )

/*++

Routine Description:

    Redirects LPT to a COMM port.

Arguments:

    DevicePath  -   Supplies pointer to path of device
    Request     -   Supplies pointer to request

Return Value:

    BOOLEAN -   TRUE if LPT redirected,
                FALSE otherwise

Notes:

--*/

{

    PREQUEST_DATA_LPT_REDIRECT  Data;
    PPATH                       RedirPath;

    Data = (PREQUEST_DATA_LPT_REDIRECT)&(((PLPT_REQUEST)Request)->Data.Redirect);

    //
    //  Verify that the serial device specified is valid
    //
    if ( !IsAValidDevice( Data->DeviceType, Data->DeviceNumber, &RedirPath )) {

        DisplayMessageAndExit( MODE_ERROR_INVALID_DEVICE_NAME,
                               RedirPath->GetPathString(),
                               (ULONG)EXIT_ERROR );

    }

    if ( !REDIR::Redirect( DevicePath, RedirPath ) ) {

        DisplayMessageAndExit( MODE_ERROR_LPT_CANNOT_REROUTE, RedirPath->GetPathString(), (ULONG)EXIT_ERROR );

    }

    //
    //  Display the status as confirmation
    //
    LptStatus( DevicePath, Request );

    DELETE( RedirPath );

    return TRUE;
}


BOOLEAN
LptEndRedir (
    IN  PCPATH          DevicePath,
    IN  PREQUEST_HEADER Request
    )

/*++

Routine Description:

    Ends the redirection of an LPT port

Arguments:

    DevicePath  -   Supplies pointer to path of device
    Request     -   Supplies pointer to request

Return Value:

    BOOLEAN -   TRUE

Notes:

--*/

{

    REDIR_STATUS    Status;

    //
    //  If the LPT is being redirected, end the redirection
    //
    if ( REDIR::IsRedirected( &Status, DevicePath ) ) {

        if ( !REDIR::EndRedirection( DevicePath )) {

            DisplayMessageAndExit( MODE_ERROR_LPT_CANNOT_ENDREROUTE, NULL, (ULONG)EXIT_ERROR );
        }
    }

    //
    //  Display status
    //
    LptStatus( DevicePath, Request );

    return TRUE;

}

PPATH
GetRedirection(
    IN  PCPATH          DevicePath,
    OUT PREDIR_STATUS   RedirStatus
    )

/*++

Routine Description:

    Determines to what device is the LPT redirected to

Arguments:

    DevicePath  -   Supplies pointer to path of device

    RedirStatus -   Supplies pointer to redirection status

Return Value:

    PPATH   -   Pointer to the redirected device

--*/

{

    ULONG   DeviceNumber    =   1;
    PPATH   DestPath        =   NULL;
    BOOLEAN ValidDevice     =   TRUE;

    if ( REDIR::IsRedirected( RedirStatus, DevicePath ) ) {

        for ( DeviceNumber = 1; DeviceNumber <= LAST_COM; DeviceNumber++ ) {

            IsAValidDevice( DEVICE_TYPE_COM, DeviceNumber, &DestPath );

            if ( REDIR::IsRedirected( RedirStatus, DevicePath, DestPath )) {

                break;

            }

            DELETE( DestPath );
            DestPath = NULL;

        }
    }

    return DestPath;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\mode\sources.inc ===
!IF 0

Copyright (c) 1989-2001 Microsoft Corporation

Module Name:

    sources.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

TARGETNAME=mode
TARGETPATH=obj
TARGETEXT=com
TARGETTYPE=PROGRAM

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\argument.cxx    \
        ..\common.cxx      \
        ..\com.cxx         \
        ..\cons.cxx        \
        ..\lpt.cxx         \
        ..\redir.cxx       \
        ..\support.cxx     \
        ..\mode.cxx        \
        ..\mode.rc

INCLUDES=..\.;..\..\ulib\inc;..\..\ureg\inc;$(DDK_INC_PATH)

!IF "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "ntsd"
!IFDEF NOMEMLEAK
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DUNICODE=1
!ELSE
!IFDEF STACK_TRACE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DSTACK_TRACE -DUNICODE=1
!ELSE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DUNICODE=1
!ENDIF
!ENDIF
!ELSE    # NTDEBUG
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=0 -DUNICODE=1
!ENDIF   # NTDEBUG

UMLIBS=..\..\ulib\src\$(ALT_PROJECT)\$(O)\ulib.lib \
       ..\..\ureg\src\$(ALT_PROJECT)\$(O)\ureg.lib \
       $(SDK_LIB_PATH)\user32.lib \
       $(SDK_LIB_PATH)\ntdll.lib

USE_MSVCRT=1

UMTYPE=console

W32_SB=1
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\more\argument.cxx ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    Argument

Abstract:

    Argument processing for the "MORE" pager

Author:

    Ramon Juan San Andres (ramonsa) 24-Apr-1990

Notes:

    The arguments accepted  by the more pager are:

    Extended mode switch.-  This allows all other options. Without this
                            switch, no other options are allowed.

    Help switch.-           Displays usage.

    ClearScreen switch.-    Clears the screen before displaying each page.

    SqueezeBlank switch.-   Squeezes consecutive blank lines into a single
                            line.

    ExpandFormFeed switch.- FormFeeds are expanded to fill the rest of
                            the screen.

    Start at line.-         Paging starts at the specified line of the
                            first file.

    Tab expansion.-         Expand tabs to this number of blanks

    File list.-             List of files to page.


    The more pager obtains its arguments from two sources:

    1.- An environment variable ( "MORE" )
    2.- The command line.

    The environment variable may specify any options, except a file
    list.

Revision History:


--*/


#include "ulib.hxx"
#include "arg.hxx"
#include "arrayit.hxx"
#include "rtmsg.h"
#include "path.hxx"
#include "smsg.hxx"
#include "system.hxx"
#include "more.hxx"

#define ENABLE_EXTENSIONS_VALUE  L"EnableExtensions"
#define COMMAND_PROCESSOR_KEY    L"Software\\Microsoft\\Command Processor"

//
//  Static variables
//
//
PFLAG_ARGUMENT      ExtendedModeArgument;
PFLAG_ARGUMENT      ClearScreenArgument;
PFLAG_ARGUMENT      ExpandFormFeedArgument;
PFLAG_ARGUMENT      SqueezeBlanksArgument;
PFLAG_ARGUMENT      Help1Argument;
PFLAG_ARGUMENT      Help2Argument;
PLONG_ARGUMENT      StartAtLineArgument;
PLONG_ARGUMENT      TabExpArgument;



VOID
MORE::SetArguments(
    )

/*++

Routine Description:

    Obtains the arguments for the "more" pager.

Arguments:

    None.

Return Value:

    None.

Notes:

--*/

{
    FLAG_ARGUMENT       LocalExtendedModeArgument;
    FLAG_ARGUMENT       LocalClearScreenArgument;
    FLAG_ARGUMENT       LocalExpandFormFeedArgument;
    FLAG_ARGUMENT       LocalSqueezeBlanksArgument;
    FLAG_ARGUMENT       LocalHelp1Argument;
    FLAG_ARGUMENT       LocalHelp2Argument;
    LONG_ARGUMENT       LocalStartAtLineArgument;
    LONG_ARGUMENT       LocalTabExpArgument;

    ExtendedModeArgument     = &LocalExtendedModeArgument;
    ClearScreenArgument      = &LocalClearScreenArgument;
    ExpandFormFeedArgument   = &LocalExpandFormFeedArgument;
    SqueezeBlanksArgument    = &LocalSqueezeBlanksArgument;
    Help1Argument            = &LocalHelp1Argument;
    Help2Argument            = &LocalHelp2Argument;
    StartAtLineArgument      = &LocalStartAtLineArgument;
    TabExpArgument           = &LocalTabExpArgument;

    //
    //  Get arguments from the environment variable
    //
    GetArgumentsMore();

    //
    //  Get the arguments from the command line.
    //
    GetArgumentsCmd();

    //
    // Determine if there is a need to enable command extension
    //
    GetRegistryInfo();

    //
    //  Verify the arguments
    //
    CheckArgumentConsistency();

}

VOID
MORE::GetArgumentsMore(
    )

/*++

Routine Description:

    Obtains the arguments from the "More" environment variable.

Arguments:

    None.

Return Value:

    None.

Notes:

--*/

{

    ARRAY               ArgArray;
    PWSTRING            MoreVariableName;
    PWSTRING            MoreVariableValue;

    //
    //  Get the name of the MORE environment variable and the argument
    //
    if ( (MoreVariableName  = QueryMessageString( MORE_ENVIRONMENT_VARIABLE_NAME )) == NULL ) {

        Fatal();
    }

    //
    //  Get the value of the MORE environment variable.
    //
    MoreVariableValue = SYSTEM::QueryEnvironmentVariable( MoreVariableName );

    if ( MoreVariableValue != NULL ) {

        //
        //  Now prepare for parsing
        //
        if ( //
             // Initialize tha arguments
             //
             !(ArgArray.Initialize( 7, 7 ))                 ||
             !(ExtendedModeArgument->Initialize( "/E" ))    ||
             !(ClearScreenArgument->Initialize( "/C" ))     ||
             !(ExpandFormFeedArgument->Initialize( "/P" ))  ||
             !(SqueezeBlanksArgument->Initialize( "/S" ))   ||
             !(Help1Argument->Initialize( "/?" ))           ||
             !(Help2Argument->Initialize( "/H" ))           ||
             !(StartAtLineArgument->Initialize( "+*" ))     ||
             !(TabExpArgument->Initialize( "/t*" ))         ||
             //
             // Put the arguments in the argument array
             //
             !(ArgArray.Put( ExtendedModeArgument ))        ||
             !(ArgArray.Put( ClearScreenArgument ))         ||
             !(ArgArray.Put( ExpandFormFeedArgument ))      ||
             !(ArgArray.Put( SqueezeBlanksArgument ))       ||
             !(ArgArray.Put( Help1Argument ))               ||
             !(ArgArray.Put( Help2Argument ))               ||
             !(ArgArray.Put( StartAtLineArgument ))         ||
             !(ArgArray.Put( TabExpArgument ))
             ) {

            Fatal();
        }

        //
        //  Parse the arguments
        //
        ParseArguments( MoreVariableValue, &ArgArray );

        //
        //  Set the global structures
        //
        _ExtendedModeSwitch     =   ExtendedModeArgument->QueryFlag();
        _ClearScreenSwitch      =   ClearScreenArgument->QueryFlag();
        _ExpandFormFeedSwitch   =   ExpandFormFeedArgument->QueryFlag();
        _SqueezeBlanksSwitch    =   SqueezeBlanksArgument->QueryFlag();
        _HelpSwitch             =   (BOOLEAN)(Help1Argument->QueryFlag() || Help2Argument->QueryFlag());
        if ( StartAtLineArgument->IsValueSet() ) {
            _StartAtLine = StartAtLineArgument->QueryLong();
        }
        if ( TabExpArgument->IsValueSet() ) {
            _TabExp = TabExpArgument->QueryLong();
        }

        //
        //  Clean up
        //
        DELETE( MoreVariableValue );
    }

    DELETE( MoreVariableName );

}

VOID
MORE::GetArgumentsCmd(
    )

/*++

Routine Description:

    Obtains the arguments from the Command line

Arguments:

    None.

Return Value:

    None

Notes:

--*/

{

    ARRAY               ArgArray;
    DSTRING             CmdLine;
    PATH_ARGUMENT       ProgramNameArgument;

    //
    //  Prepare for parsing
    //
    if (//
        //  Initialize the arguments
        //
        !(CmdLine.Initialize( GetCommandLine() ))                       ||
        !(ArgArray.Initialize( 9, 9 ))                                  ||
        !(ProgramNameArgument.Initialize( "*" ))                        ||
        !(ExtendedModeArgument->Initialize( "/E" ))                     ||
        !(ClearScreenArgument->Initialize( "/C" ))                      ||
        !(ExpandFormFeedArgument->Initialize( "/P" ))                   ||
        !(SqueezeBlanksArgument->Initialize( "/S" ))                    ||
        !(Help1Argument->Initialize( "/?" ))                            ||
        !(Help2Argument->Initialize( "/H" ))                            ||
        !(StartAtLineArgument->Initialize( "+*" ))                      ||
        !(TabExpArgument->Initialize( "/t*" ))                          ||
         ((_FilesArgument = NEW MULTIPLE_PATH_ARGUMENT) == NULL)        ||
        !(_FilesArgument->Initialize( "*", TRUE, TRUE ))                ||

        //
        //  Put the arguments in the argument array
        //
        !(ArgArray.Put( &ProgramNameArgument ))                         ||
        !(ArgArray.Put( ExtendedModeArgument ))                         ||
        !(ArgArray.Put( ClearScreenArgument ))                          ||
        !(ArgArray.Put( ExpandFormFeedArgument ))                       ||
        !(ArgArray.Put( SqueezeBlanksArgument ))                        ||
        !(ArgArray.Put( Help1Argument ))                                ||
        !(ArgArray.Put( Help2Argument ))                                ||
        !(ArgArray.Put( StartAtLineArgument ))                          ||
        !(ArgArray.Put( TabExpArgument ))                               ||
        !(ArgArray.Put( _FilesArgument )) ) {

        Fatal();
    }

    //
    //  Parse the arguments
    //
    ParseArguments( &CmdLine, &ArgArray );

    //
    //  Set the global structures
    //
    _ExtendedModeSwitch     |=  ExtendedModeArgument->QueryFlag();
    _ClearScreenSwitch      |=  ClearScreenArgument->QueryFlag();
    _ExpandFormFeedSwitch   |=  ExpandFormFeedArgument->QueryFlag();
    _SqueezeBlanksSwitch    |=  SqueezeBlanksArgument->QueryFlag();
    _HelpSwitch             |=  Help1Argument->QueryFlag() || Help2Argument->QueryFlag();

    if ( StartAtLineArgument->IsValueSet() ) {
        _StartAtLine = StartAtLineArgument->QueryLong();
    }
    if ( TabExpArgument->IsValueSet() ) {
        _TabExp = TabExpArgument->QueryLong();
    }

}

VOID
MORE::ParseArguments(
    IN  PWSTRING    CmdLine,
    OUT PARRAY      ArgArray
    )

/*++

Routine Description:

    Parses a group of arguments

Arguments:

    CmdLine     -   Supplies pointer to a command line to parse
    ArgArray    -   Supplies pointer to array of arguments

Return Value:

    none

Notes:

--*/

{
    ARGUMENT_LEXEMIZER  ArgLex;
    ARRAY               LexArray;
    PWSTRING            InvalidParameter;

    //
    //  Initialize lexeme array and the lexemizer.
    //
    if ( !(LexArray.Initialize( 8, 8 ))                                                   ||
         !(ArgLex.Initialize( &LexArray )) ) {

        Fatal();

    }

    //
    //  Set our parsing preferences
    //
    ArgLex.PutMultipleSwitch( "/ECPSH?" );
    ArgLex.PutSwitches( "/" );
    ArgLex.PutSeparators( " /\t" );
    ArgLex.SetCaseSensitive( FALSE );
    ArgLex.PutStartQuotes( "\"" );
    ArgLex.PutEndQuotes( "\"" );

    //
    //  Parse the arguments
    //
    if ( !(ArgLex.PrepareToParse( CmdLine ))) {

        Fatal(  EXIT_ERROR, MORE_ERROR_GENERAL, "" );

    }

    if ( !ArgLex.DoParsing( ArgArray ) ) {

        _Message.Set(MSG_INVALID_PARAMETER);
        _Message.Display("%W", InvalidParameter = ArgLex.QueryInvalidArgument() );
        DELETE(InvalidParameter);
        ExitProcess( 0 );
    }

    LexArray.DeleteAllMembers( );


}

VOID
MORE::CheckArgumentConsistency (
    )

/*++

Routine Description:

    Checks the consistency of the arguments

Arguments:

    none

Return Value:

    none

Notes:

--*/

{

    BOOLEAN     ExtendedSwitches;

    if ( _HelpSwitch ) {

        //
        //  Help wanted
        //
        Usage();
    }

    ExtendedSwitches =  (BOOLEAN)( _ClearScreenSwitch                           ||
                                   _ExpandFormFeedSwitch                        ||
                                   _SqueezeBlanksSwitch                         ||
                                   TabExpArgument->IsValueSet()                 ||
                                   ( _StartAtLine > (LONG)0 )                   ||
                                   _FilesArgument->WildCardExpansionFailed()    ||
                                   ( _FilesArgument->QueryPathCount() > (ULONG)0));

    //
    //  If the "extended" flag was not specified, then no other argument
    //  is allowed.
    //
    if ( !_ExtendedModeSwitch   &&
         ExtendedSwitches ) {

        Fatal( EXIT_ERROR, MORE_ERROR_TOO_MANY_ARGUMENTS, "" );

    }

    //
    //  Error out if invalid file specified
    //
    if ( _FilesArgument->WildCardExpansionFailed() ) {
        Fatal(  EXIT_ERROR, MORE_ERROR_CANNOT_ACCESS, "%W", _FilesArgument->GetLexemeThatFailed() );
    }

}

VOID
MORE::GetRegistryInfo(
    )
{
    ULONG   valueType;
    DWORD   value;
    ULONG   valueLength = sizeof(value);
    HKEY    key;
    LONG    status;


    if (_ExtendedModeSwitch)
        return;

    status = RegOpenKeyEx(HKEY_CURRENT_USER,
                          COMMAND_PROCESSOR_KEY,
                          0,
                          KEY_READ,
                          &key);

    if (status != ERROR_SUCCESS) {
        return;
    }

    status = RegQueryValueEx(key,
                             ENABLE_EXTENSIONS_VALUE,
                             NULL,
                             &valueType,
                             (LPBYTE)&value,
                             &valueLength);

    if (status != ERROR_SUCCESS ||
        valueType != REG_DWORD ||
        valueLength != sizeof(DWORD)) {
        return;
    }
    _ExtendedModeSwitch = (BOOLEAN)value;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\more\sources.inc ===
!IF 0

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    sources.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

TARGETNAME=more
TARGETPATH=obj
TARGETEXT=com
TARGETTYPE=PROGRAM
USE_MSVCRT=1

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\argument.cxx    \
        ..\pager.cxx       \
        ..\more.cxx        \
        ..\more.rc

INCLUDES=..\.;..\..\ulib\inc

!IF "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "ntsd"
!IFDEF NOMEMLEAK
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DUNICODE=1
!ELSE
!IFDEF STACK_TRACE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DSTACK_TRACE -DUNICODE=1
!ELSE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DUNICODE=1
!ENDIF
!ENDIF
!ELSE    # NTDEBUG
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=0 -DUNICODE=1
!ENDIF   # NTDEBUG

TARGETLIBS= \
    $(SDK_LIB_PATH)\setargv.obj  \
    ..\..\ulib\src\$(ALT_PROJECT)\$(O)\ulib.lib \
    $(SDK_LIB_PATH)\ntdll.lib

UMTYPE=console

W32_SB=1
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\mode\support.cxx ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

	Support

Abstract:

	Miscelaneous support functions for the XCopy directory copy
	utility.  All functions that are not involved directly in the
	copy process go here.

Author:

	Ramon Juan San Andres (ramonsa) 02-May-1991

Revision History:

--*/



#include "mode.hxx"
//#include "ulib.hxx"
#include "system.hxx"
//#include "mode.hxx"





VOID
DisplayMessage (
	IN	MSGID				MsgId,
    IN  PCWSTRING           String
	)

/*++

Routine Description:

	Displays a message, with an optional parameter

Arguments:

	MsgId		-	Supplies the Id of the message to display.
	String		-	Supplies a string parameter for the message.

Return Value:

    None.

Notes:

--*/

{


	if (MsgId != 0) {
		Message->Set( MsgId );

		if ( String == NULL ) {
			//
			//	The message has no parameters
			//
			Message->Display( "" );

		} else {

			//
			//	Display it.
			//
			Message->Display( "%W", String );
		}
	}

}


VOID
DisplayMessageAndExit (
	IN	MSGID				MsgId,
    IN  PCWSTRING           String,
	IN	ULONG				ExitCode
	)

/*++

Routine Description:

	Displays a message and exits the program with the supplied error code.
	We support a maximum of one string parameter for the message.

Arguments:

	MsgId		-	Supplies the Id of the message to display.
	String		-	Supplies a string parameter for the message.
	ExitCode	-	Supplies the exit code with which to exit.

Return Value:

    None.

Notes:

--*/

{

	DisplayMessage( MsgId, String );

	ExitMode( ExitCode );

}

PWSTRING
QueryMessageString (
	IN MSGID	MsgId
	)
/*++

Routine Description:

	Obtains a string object initialized to the contents of some message

Arguments:

	MsgId	-	Supplies ID of the message

Return Value:

	PWSTRING	-	Pointer to initialized string object

Notes:

--*/

{

	PWSTRING	String;

    if ( ((String = NEW DSTRING) == NULL )  ||
		 !(SYSTEM::QueryResourceString( String, MsgId, "" )) ) {

		DisplayMessageAndExit( MODE_ERROR_NO_MEMORY, NULL, (ULONG)EXIT_ERROR );
	}

	return String;

}

VOID
ExitWithError(
	IN	DWORD		ErrorCode
	)

/*++

Routine Description:

	Displays a message based on a WIN32 error code, and exits.

Arguments:

	ErrorCode	-	Supplies Windows error code

Return Value:

	none

--*/

{
	Message->Set( MODE_ERROR_EXTENDED );
	Message->Display( "%d", ErrorCode );
	ExitMode( (ULONG)EXIT_ERROR );
}

VOID
ExitMode(
	IN	DWORD	ExitCode
	)

/*++

Routine Description:

	Exits the program

Arguments:

	ExitCode	-	Supplies the exit code

Return Value:

	none

--*/

{
	exit( (int)ExitCode );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\mountvol\mountvol.c ===
#include <windows.h>
#include <stdio.h>
#include <msg.h>

HANDLE  OutputFile;
BOOL    IsConsoleOutput;

void
DisplayIt(
    IN  PWSTR   Message
    )

{
    DWORD   bytes, len;
    PSTR    message;

    if (IsConsoleOutput) {
        WriteConsole(OutputFile, Message, wcslen(Message),
                     &bytes, NULL);
    } else {
        len = wcslen(Message);
        message = LocalAlloc(0, (len + 1)*sizeof(WCHAR));
        if (!message) {
            return;
        }
        CharToOem(Message, message);
        WriteFile(OutputFile, message, strlen(message), &bytes, NULL);
        LocalFree(message);
    }
}

void  
PrintMessage(
    DWORD messageID, 
    ...
    )
{
    unsigned short messagebuffer[4096];
    va_list ap;

    va_start(ap, messageID);

    FormatMessage(FORMAT_MESSAGE_FROM_HMODULE, NULL, messageID, 0,
                  messagebuffer, 4095, &ap);

    DisplayIt(messagebuffer);

    va_end(ap);

}  // PrintMessage

void
PrintTargetForName(
    IN  PWSTR   VolumeName
    )

{
    BOOL    b;
    DWORD   len;
    WCHAR   messageBuffer[MAX_PATH];
    PWSTR   volumePaths, p;

    PrintMessage(MOUNTVOL_VOLUME_NAME, VolumeName);

    b = GetVolumePathNamesForVolumeName(VolumeName, NULL, 0, &len);
    if (!b && GetLastError() != ERROR_MORE_DATA) {
        FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, GetLastError(), 0,
                      messageBuffer, MAX_PATH, NULL);
        DisplayIt(messageBuffer);
        return;
    }

    volumePaths = LocalAlloc(0, len*sizeof(WCHAR));
    if (!volumePaths) {
        FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL,
                      ERROR_NOT_ENOUGH_MEMORY, 0, messageBuffer, MAX_PATH,
                      NULL);
        DisplayIt(messageBuffer);
        return;
    }

    b = GetVolumePathNamesForVolumeName(VolumeName, volumePaths, len, NULL);
    if (!b) {
        LocalFree(volumePaths);
        FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, GetLastError(), 0,
                      messageBuffer, MAX_PATH, NULL);
        DisplayIt(messageBuffer);
        return;
    }

    if (!volumePaths[0]) {
        PrintMessage(MOUNTVOL_NO_MOUNT_POINTS);
        LocalFree(volumePaths);
        return;
    }

    p = volumePaths;
    for (;;) {
        PrintMessage(MOUNTVOL_MOUNT_POINT, p);

        while (*p++);

        if (!*p) {
            break;
        }
    }

    LocalFree(volumePaths);

    PrintMessage(MOUNTVOL_NEWLINE);
}

BOOL
GetSystemPartitionFromRegistry(
    IN OUT  PWCHAR  SystemPartition
    )

{
    LONG    r;
    HKEY    key;
    DWORD   bytes;

    r = RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"SYSTEM\\Setup", 0, KEY_QUERY_VALUE,
                     &key);
    if (r) {
        SetLastError(r);
        return FALSE;
    }

    bytes = MAX_PATH*sizeof(WCHAR);
    r = RegQueryValueEx(key, L"SystemPartition", NULL, NULL,
                        (LPBYTE) SystemPartition, &bytes);
    RegCloseKey(key);
    if (r) {
        SetLastError(r);
        return FALSE;
    }

    return TRUE;
}

void
PrintMappedESP(
    )

{
    WCHAR   systemPartition[MAX_PATH];
    UCHAR   c;
    WCHAR   dosDevice[10], dosTarget[MAX_PATH];

    if (!GetSystemPartitionFromRegistry(systemPartition)) {
        return;
    }

    dosDevice[1] = ':';
    dosDevice[2] = 0;

    for (c = 'A'; c <= 'Z'; c++) {
        dosDevice[0] = c;
        if (!QueryDosDevice(dosDevice, dosTarget, MAX_PATH)) {
            continue;
        }
        if (lstrcmp(dosTarget, systemPartition)) {
            continue;
        }
        dosDevice[2] = '\\';
        dosDevice[3] = 0;
        PrintMessage(MOUNTVOL_EFI, dosDevice);
        break;
    }
}

void
PrintVolumeList(
    )

{
    HANDLE  h;
    WCHAR   volumeName[MAX_PATH];
    WCHAR   messageBuffer[MAX_PATH];
    BOOL    b;

    h = FindFirstVolume(volumeName, MAX_PATH);
    if (h == INVALID_HANDLE_VALUE) {
        FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, GetLastError(),
                      0, messageBuffer, MAX_PATH, NULL);
        DisplayIt(messageBuffer);
        return;
    }

    for (;;) {

        PrintTargetForName(volumeName);

        b = FindNextVolume(h, volumeName, MAX_PATH);
        if (!b) {
            break;
        }
    }

    FindVolumeClose(h);

#if defined(_M_IA64)
    PrintMappedESP();
#endif
}

BOOL
SetSystemPartitionDriveLetter(
    IN  PWCHAR  DirName
    )

/*++

Routine Description:

    This routine will set the given drive letter to the system partition.

Arguments:

    DirName - Supplies the drive letter directory name.

Return Value:

    BOOL

--*/

{
    WCHAR   systemPartition[MAX_PATH];

    if (!GetSystemPartitionFromRegistry(systemPartition)) {
        return FALSE;
    }

    DirName[wcslen(DirName) - 1] = 0;
    if (!DefineDosDevice(DDD_RAW_TARGET_PATH, DirName, systemPartition)) {
        return FALSE;
    }

    return TRUE;
}

int __cdecl
main(
    int argc,
    char** argv
    )

{
    DWORD   mode;
    WCHAR   dirName[MAX_PATH];
    WCHAR   volumeName[MAX_PATH];
    DWORD   dirLen, volumeLen;
    BOOLEAN deletePoint, listPoint, systemPartition;
    BOOL    b;
    WCHAR   messageBuffer[MAX_PATH];

    SetErrorMode(SEM_FAILCRITICALERRORS);

    OutputFile = GetStdHandle(STD_OUTPUT_HANDLE);
    IsConsoleOutput = GetConsoleMode(OutputFile, &mode);

    if (argc != 3) {
        PrintMessage(MOUNTVOL_USAGE1);
#if defined(_M_IA64)
        PrintMessage(MOUNTVOL_USAGE1_IA64);
#endif
        PrintMessage(MOUNTVOL_USAGE2);
#if defined(_M_IA64)
        PrintMessage(MOUNTVOL_USAGE2_IA64);
#endif
        PrintMessage(MOUNTVOL_START_OF_LIST);
        PrintVolumeList();
        return 0;
    }

    SetErrorMode(SEM_FAILCRITICALERRORS);

    swprintf(dirName, L"%hs", argv[1]);
    swprintf(volumeName, L"%hs", argv[2]);

    dirLen = wcslen(dirName);
    volumeLen = wcslen(volumeName);

    if (argv[2][0] == '/' && argv[2][1] != 0 && argv[2][2] == 0) {
        if (argv[2][1] == 'd' || argv[2][1] == 'D') {
            deletePoint = TRUE;
            listPoint = FALSE;
            systemPartition = FALSE;
        } else if (argv[2][1] == 'l' || argv[2][1] == 'L') {
            deletePoint = FALSE;
            listPoint = TRUE;
            systemPartition = FALSE;
        } else if (argv[2][1] == 's' ||  argv[2][1] == 'S') {
            deletePoint = FALSE;
            listPoint = FALSE;
            systemPartition = TRUE;
        } else {
            deletePoint = FALSE;
            listPoint = FALSE;
            systemPartition = FALSE;
        }
    } else {
        deletePoint = FALSE;
        listPoint = FALSE;
        systemPartition = FALSE;
    }

    if (dirName[dirLen - 1] != '\\') {
        wcscat(dirName, L"\\");
        dirLen++;
    }

    if (volumeName[volumeLen - 1] != '\\') {
        wcscat(volumeName, L"\\");
        volumeLen++;
    }

    if (deletePoint) {
        b = DeleteVolumeMountPoint(dirName);
        if (!b && GetLastError() == ERROR_INVALID_PARAMETER) {
            dirName[dirLen - 1] = 0;
            b = DefineDosDevice(DDD_REMOVE_DEFINITION, dirName, NULL);
        }
    } else if (listPoint) {
        b = GetVolumeNameForVolumeMountPoint(dirName, volumeName, MAX_PATH);
        if (b) {
            PrintMessage(MOUNTVOL_VOLUME_NAME, volumeName);
        }
    } else if (systemPartition) {
        b = SetSystemPartitionDriveLetter(dirName);
    } else {
        if (dirName[1] == ':' && dirName[2] == '\\' && !dirName[3]) {

            dirName[2] = 0;
            b = QueryDosDevice(dirName, messageBuffer, MAX_PATH);
            if (b) {
                FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL,
                              ERROR_DIR_NOT_EMPTY, 0, messageBuffer, MAX_PATH,
                              NULL);
                DisplayIt(messageBuffer);
                return 1;
            }
            dirName[2] = '\\';
        }

        b = SetVolumeMountPoint(dirName, volumeName);
    }

    if (!b) {
        FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, GetLastError(), 0,
                      messageBuffer, MAX_PATH, NULL);
        DisplayIt(messageBuffer);
        return 1;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\arg.cxx ===
#include "pch.cxx"  
#include "..\..\ulib\src\arg.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\achkmsg.cxx ===
#include "pch.cxx"  
#include "..\..\ulib\src\achkmsg.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\more\pager.cxx ===
/*++

Copyright (c) 1990-2000 Microsoft Corporation

Module Name:

    PAGER

Abstract:

    This module contains the implementations for the PAGER class

Author:

    Ramon Juan San Andres (RamonSA) 15-Apr-1990

Notes:


--*/

#include "ulib.hxx"
#include "filestrm.hxx"
#include "wstring.hxx"
#include "bstring.hxx"
#include "screen.hxx"
#include "stream.hxx"
#include "more.hxx"
#include "pager.hxx"

//
//  What constitutes a "blank" character (spaces and tabs)
//
#define BLANKCHARACTERS         (LPWSTR)L" \t"
#define TAB_ASCII               (CHAR)'\t'



DEFINE_CONSTRUCTOR( PAGER,  OBJECT );

VOID
PAGER::Construct (
    )
{
    UNREFERENCED_PARAMETER( this );
}

PAGER::~PAGER (
    )
{

    DELETE( _String );
    DELETE( _BString );
    DELETE( _Blanks );
    DELETE( _BlankLine );

}

BOOLEAN
PAGER::Initialize (
    IN  PSTREAM     Stream,
    IN  PPROGRAM    Program
    )
/*++

Routine Description:

    Phase 2 of construction for a pager object. It initializes its
    internal data.

Arguments:

    Stream      -   Supplies the stream to be paged
    Program     -   Supplies pointer to the program doing the paging.

Return Value:

    TRUE  - If initialized correctly
    FALSE - If something when wrong. (check error stack)

--*/

{

    USHORT  ScreenRows, RowsInPage;
    CHNUM   i;

    _Stream             =   Stream;
    _CurrentLineNumber  =   0;
    _StandardOutput     =   Program->GetStandardOutput();
    _Screen             =   SCREEN::Cast( _StandardOutput );
    _Position           =   INVALID_CHNUM;

    //
    //  Get the page dimensions
    //
    if (_Screen) {
        _Screen->QueryScreenSize( &ScreenRows, &_ColumnsInScreen, &RowsInPage, &_ColumnsInPage );
        _RowsInPage = RowsInPage;
        _ColumnsInPage = _ColumnsInScreen;
    } else {

        // If we don't have a screen then we should treat the page
        // as infinitely long since we have no need to prompt.

        _RowsInPage    = (ULONG) -1;
        _ColumnsInPage = (USHORT) -1;
    }

    if (!(_String = NEW DSTRING) ||
        !(_BString = NEW BDSTRING) ||
        !(_Blanks = NEW DSTRING) ||
        !(_BlankLine = NEW DSTRING) ||
        !_String->Initialize() ||
        !_BString->Initialize() ||
        !_Blanks->Initialize(BLANKCHARACTERS) ||
        !_BlankLine->Resize(_Screen ? _ColumnsInPage : 0)) {

        return FALSE;
    }

    for (i = 0; i < _BlankLine->QueryChCount(); i++) {
        _BlankLine->SetChAt(' ', i);
    }

    return TRUE;
}

BOOLEAN
PAGER::DisplayPage (
    IN  ULONG   LinesInPage,
    IN  BOOLEAN ClearScreen,
    IN  BOOLEAN SqueezeBlankLines,
    IN  BOOLEAN ExpandFormFeed,
    IN  ULONG   TabExp
    )

/*++

Routine Description:

    Displays a page of the screen

Arguments:

    LinesInPage         -   Supplies the desired number of lines in the page
    ClearScreen         -   Supplies a flag, which if TRUE means that we
                            want to clear the screen before displaying the
                            page
    SqueezeBlankLines   -   Supplies squeeze flag
    ExpandFormFeed      -   Supplies formfeed expansion flag

Return Value:

    TRUE - If page displayed
    FALSE otherwise

--*/

{
    ULONG   LinesLeft       = LinesInPage;
    BOOLEAN IgnoreBlankLine = FALSE;
    CHNUM   Length;
    CHNUM   FormFeedAt;


    if ( TabExp > (ULONG)( _ColumnsInPage - 1 ) ) {
        TabExp = _ColumnsInPage - 1 ;
    }

    //
    //  Clear the screen if instructed to do so
    //
    if ( ClearScreen && _Screen) {
#ifdef FE_SB  // v-junm - 08/18/93
// Also reset attributes.
        _Screen->EraseScreenAndResetAttribute();
#else
        _Screen->EraseScreen();
#endif
        _Screen->MoveCursorTo( 0, 0 );
    } else {
        //
        //  Make sure that we start at the beginning of a line
        //
        ClearLine();
    }

    //
    //  Display up to LinesLeft lines
    //

    while ( LinesLeft > 0 &&
           (ThereIsMoreToPage() || _Position != INVALID_CHNUM) ) {

        //
        //  Get next string from input
        //
        if (!ReadNextString( TabExp )) {
            return FALSE;
        }

#ifdef FE_SB  // v-junm - 08/18/93
// Now QueryChCount returns the correct number of unicode chars.  An additional
// API, QueryByteCount was added.
        Length = _String->QueryByteCount() - _Position;
#else
        Length = _String->QueryChCount() - _Position;
#endif

        if ( SqueezeBlankLines ) {

            if ( _String->Strspn( _Blanks, _Position ) == INVALID_CHNUM ) {

                //
                //  This is a blank line. We must sqeeze
                //
                if ( IgnoreBlankLine ) {
                    //
                    //  We ignore the line
                    //
                    _Position = INVALID_CHNUM;
                    continue;

                } else {
                    //
                    //  We will print a blank line and  ignore the following
                    //  blank lines.
                    //
                    DisplayBlankLine( 1 );
                    _Position = INVALID_CHNUM;
                    IgnoreBlankLine = TRUE;
                    continue;
                }
            } else if (IgnoreBlankLine) {
                LinesLeft--;
                IgnoreBlankLine = FALSE;
                continue;
            }
        }


        if ( ExpandFormFeed ) {
            //
            //  Look for form feed within line
            //
            if ((FormFeedAt = _String->Strchr( FORMFEED,_Position )) != INVALID_CHNUM) {
                if ( FormFeedAt == _Position ) {
                    //
                    //  First character is a form feed.
                    //
                    //  We will skip the formfeed character, and the
                    //  rest of the screen will be blanked.
                    //
                    if ( SqueezeBlankLines ) {
                        if (!IgnoreBlankLine) {
                            DisplayBlankLine( 1 );
                            LinesLeft--;
                            IgnoreBlankLine = TRUE;
                        }
                    } else {
                        DisplayBlankLine( LinesLeft );
                        LinesLeft = 0;
                    }
                    _Position++;
                    continue;
                }

                Length = FormFeedAt - _Position;
            }
        }


        //
        //  If the line is too long, we must split it
        //
        if (Length > (CHNUM)_ColumnsInPage) {
            Length = (CHNUM)_ColumnsInPage;
        }

        //
        //  Display the string
        //
        DisplayString( _String, &_Position, Length );
        IgnoreBlankLine = FALSE;

        LinesLeft--;
    }

    return TRUE;
}

VOID
PAGER::ClearLine (
    )

/*++

Routine Description:

    Clears a line

Arguments:

    none

Return Value:

    none

--*/

{
    USHORT  ScreenRows, ScreenCols;
    USHORT  WindowRows, WindowCols;
    CHNUM   i;

    if (_Screen) {

        _Screen->QueryScreenSize( &ScreenRows,
                                  &ScreenCols,
                                  &WindowRows,
                                  &WindowCols );
        //
        //  If the number of columns has changed, re-initialize the
        //  blank line.
        //
        if ( ScreenCols != _ColumnsInPage ) {
            _BlankLine->Resize(ScreenCols);
            for (i = 0; i < ScreenCols; i++) {
                _BlankLine->SetChAt(' ', i);
            }
        }
        _RowsInPage     = WindowRows;
        _ColumnsInPage  = ScreenCols;

        _StandardOutput->WriteChar( (WCHAR)CARRIAGERETURN );
        _StandardOutput->WriteString( _BlankLine, 0, _ColumnsInPage-1 );
        _StandardOutput->WriteChar( (WCHAR)CARRIAGERETURN );
    }
}

VOID
PAGER::DisplayBlankLine (
    IN ULONG    Lines,
    IN BOOLEAN  NewLine
    )

/*++

Routine Description:

    Displays a number of blank lines

Arguments:

    Lines   -   Supplies the number of blank lines to display
    NewLine -   Supplies the newline flag

Return Value:

    none

--*/

{
    CHNUM   Position;

    while ( Lines-- ) {

        Position = 0;

        DisplayString( _BlankLine, &Position, _ColumnsInPage-1, (Lines > 0) ? TRUE : NewLine);

    }
}

VOID
PAGER::DisplayString (
    IN  PWSTRING String,
    OUT PCHNUM   Position,
    IN  CHNUM    Length,
    IN  BOOLEAN  NewLine
    )

/*++

Routine Description:

    Displays a chunk of the current string

Arguments:

    Length  -   Supplies the length of the string to display
    NewLine -   Supplies the newline flag

Return Value:

    none

--*/

{
#ifdef FE_SB  // v-junm - 04/19/93

    CHNUM           UnicodeCharNum,     // # of unicode characters to display
                    TempByteCount,      // to minimize calls to QueryByteCount
                    index;              // loop counter
    PSTR            STRBuffer;          // ASCIIZ converted string pointer
    static  CHNUM   OldPos;             // Keeps old position in # of Unicode
    BOOL            DBCSFlag = FALSE;   // Flag for ending leadbyte

    TempByteCount = String->QueryByteCount();
    Length = min( Length, TempByteCount );

    // If the length of the string to display is shorter than
    // the width of the screen, we do not have to do any DBCS
    // checking.  Just print it out.  (Can be skipped for CP437)
    //

    if ( TempByteCount > _ColumnsInPage )  {

        //
        // Initialize # of unicode characters to #
        // of ASCII chars to display.
        //

        UnicodeCharNum = Length;

        //
        // Get the string as a ASCIIZ text.
        //

        STRBuffer = String->QuerySTR();

        if ( STRBuffer != NULL )  {

            //
            // Start changing the UnicodeCharNum from the actual
            // number of bytes to the actual number of characters.
            //

            for( index = 0; index < Length; index++ ) {
                if ( IsLeadByte( *(STRBuffer + index + _Position) ) ) {
                    index++;
                    UnicodeCharNum--;
                    DBCSFlag = TRUE;
                }
                else
                    DBCSFlag = FALSE;
            }
            DELETE( STRBuffer );
        }

        //
        // If the following conditions are true, then there
        // is a Leadbyte at the end of the screen that needs
        // to be displayed on the next line with it's tail byte.
        //

        if ( DBCSFlag == TRUE &&                // String ends with DBCS.
             index == (Length - 1) &&           // Only Leadbyte.
             Length == (CHNUM)_ColumnsInPage    // More rows to display.
            )  {
            Length--;
            UnicodeCharNum--;
        }

    }
    else
//fix kksuzuka: #195
//Overflow pagecolumns when writing 0D0A.
//UnicodeCharNum = String->QueryChCount();
        UnicodeCharNum = min( Length, String->QueryChCount() );

    //
    // When the string does not fit on one line and needs to be truncated,
    // OldPos keeps the position where the string was truncated in Unicode
    // location.
    //


    //
    // If true, set to beginning of string.
    //

    if ( *Position == 0 )
        OldPos = 0;

    _StandardOutput->WriteString( String, OldPos, UnicodeCharNum );

    //
    // Set to last+1 char displayed in unicode character numbers.
    //

    OldPos += UnicodeCharNum;

    //
    //  Update our position within the string
    //

    *Position += Length;

    //
    // Check if all the characters have been written.
    //

    if ( TempByteCount && (TempByteCount == *Position) &&
         !(TempByteCount % _ColumnsInPage) )  {

        //
        // Characters have been written, but there is a LF/CR
        // character at the that needs to be display that has
        // not been displayed.  (At _ColumnsInPage+1 location)
        //

        *Position = INVALID_CHNUM;
//        _StandardOutput->WriteChar( (WCHAR)CARRIAGERETURN );
//        _StandardOutput->WriteChar( (WCHAR)LINEFEED );

    }
    else if ( *Position >= TempByteCount )
        *Position = INVALID_CHNUM;

    if ( ((*Position != INVALID_CHNUM) || NewLine) &&
         ( Length < _ColumnsInScreen || !_Screen ) ) {

        _StandardOutput->WriteChar( (WCHAR)CARRIAGERETURN );
        _StandardOutput->WriteChar( (WCHAR)LINEFEED );
    }

#else // FE_SB

    Length = min( Length, String->QueryChCount() );

    _StandardOutput->WriteString( String, *Position, Length );

    //
    //  Update our position within the string
    //
    *Position += Length;

    if (*Position >= _String->QueryChCount()) {
        *Position = INVALID_CHNUM;
    }

    if ( ((*Position != INVALID_CHNUM) || NewLine) &&
         ( Length < _ColumnsInScreen || !_Screen ) ) {
        _StandardOutput->WriteChar( (WCHAR)CARRIAGERETURN );
        _StandardOutput->WriteChar( (WCHAR)LINEFEED );
    }

#endif
}


ULONGLONG
PAGER::QueryCurrentByte (
    )

/*++

Routine Description:

    Queries the current Byte number

Arguments:

    none

Return Value:

    The current byte number

--*/

{

    PFILE_STREAM    pFileStream;
    ULONGLONG       PointerPosition ;

    if ((pFileStream = FILE_STREAM::Cast(_Stream)) == NULL )  {

        return 0;

    } else {

        pFileStream->QueryPointerPosition( &PointerPosition );

        return PointerPosition;
    }
}

USHORT
PAGER::QueryLinesPerPage (
    )

/*++

Routine Description:

    Queries the number of lines per page of output

Arguments:

    none

Return Value:

    The number of lines (rows) in a page

--*/

{
    USHORT  ScreenRows, ScreenCols;
    USHORT  WindowRows, WindowCols;
    CHNUM   i;

    //
    //  If Paging to screen, get the current size of the window
    //
    if (_Screen) {

        _Screen->QueryScreenSize( &ScreenRows,
                                  &ScreenCols,
                                  &WindowRows,
                                  &WindowCols );
        //
        //  If the number of columns has changed, re-initialize the
        //  blank line.
        //
        if ( WindowCols != _ColumnsInPage ) {
            _BlankLine->Resize(ScreenCols);
            for (i = 0; i < ScreenCols; i++) {
                _BlankLine->SetChAt(' ', i);
            }
        }
        _RowsInPage     = WindowRows;
        _ColumnsInPage  = ScreenCols;
    }

    return (USHORT)_RowsInPage;
}

BOOLEAN
PAGER::ReadNextString (
    IN  ULONG   TabExp
    )

/*++

Routine Description:

    Reads in the next string from the input stream.

Arguments:

    TabExp  -   Supplies the number of blank characters per tab

Return Value:

    TRUE - If string read in
    FALSE otherwise

--*/

{

    if (_Position == INVALID_CHNUM ) {

        CHNUM   Idx;

        //
        //  We have to read a new string from the input stream.
        //
        if (!_Stream->ReadLine( _String )) {
            return FALSE;
        }

        _CurrentLineNumber++;
        _Position = 0;

        //
        //  Expand tabs
        //
        Idx = 0;

        //
        // Get the string as a ASCIIZ text.
        //
        PSTR   szBuffer;          // ASCIIZ converted string pointer

        szBuffer = _String->QuerySTR();
        if (szBuffer != NULL) {
            _BString->Initialize(szBuffer);
            DELETE( szBuffer );

            while ( (Idx < _BString->QueryChCount()) &&
                   ((Idx = _BString->Strchr( TAB_ASCII, Idx )) != INVALID_CHNUM) ) {

                if (TabExp) {
                    _BString->ReplaceWithChars(
                                      Idx,              // AtPosition
                                      1,                // AtLength
                                      ' ',              // Replacement char
                                      TabExp - Idx%TabExp   // FromLength
                                     );
                } else {
                    _BString->ReplaceWithChars(
                                      Idx,              // AtPosition
                                      1,                // AtLength
                                      ' ',              // Replacement char
                                      0                 // FromLength
                                     );
                }

                //
                // MJB:  If we're eliminating tabs we don't want to advance the
                // index; removing the previous tab has pulled the next character
                // in *to* the index, so it's already where we want it.  Advancing
                // regardless can cause every other adjacent tab not to be
                // elminiated.
                //

                if (TabExp > 0) {
                    Idx = _BString->NextChar(Idx);
                }
            }

            szBuffer = _BString->QuerySTR();
            if (szBuffer != NULL) {
                _String->Initialize(szBuffer);
                DELETE( szBuffer );
            }

        }

    }

    return TRUE;

}

BOOLEAN
PAGER::SkipLines (
    IN  ULONG   LinesToSkip,
    IN  ULONG   TabExp
    )

/*++

Routine Description:

    Skips certain number of lines

Arguments:

    LinesToSkip -   Supplies the number of lines to skip
    TabExp      -   Supplies number of spaces per tab

Return Value:

    TRUE - If lines skipped
    FALSE otherwise

--*/

{

    if ( TabExp > (ULONG)( _ColumnsInPage - 1 ) ) {
        TabExp = _ColumnsInPage - 1;
    }

    while ( LinesToSkip--  && ThereIsMoreToPage() ) {

        if (!ReadNextString( TabExp )) {
            return FALSE;
        }

        _Position = INVALID_CHNUM;

    }

    return TRUE;

}

#ifdef FE_SB // v-junm - 09/24/93

BOOLEAN
PAGER::IsLeadByte(
    IN  BYTE   c
    )

/*++

Routine Description:

    Checks to see if c is a leadbyte of a DBCS character.

Arguments:

    c - character to check to see if leadbyte.

Return Value:

    TRUE - leadbyte of DBCS character.
    FALSE otherwise

--*/

{
    CPINFO          cp;
    static UINT     outputcp = GetConsoleOutputCP();
    int             i;

    if ( GetCPInfo( outputcp, &cp ) )  {

        //
        // Code page info has been aquired.  From code page info,
        // the leadbyte range can be determined.
        //

        for( i = 0; cp.LeadByte[i] && cp.LeadByte[i+1]; i += 2 )  {

            //
            // There are leadbytes.  Check to see if c falls in
            // current leadbyte range.
            //

            if ( c >= cp.LeadByte[i] && c <= cp.LeadByte[i+1] )
                return( TRUE );

        }

        return( FALSE );
    }
    else  {

        //
        // This will not produce correct results if
        // 'ConsoleOutputCP != SystemCP && DBCS System'
        // Just making system conversion the default
        // when GetCPInfo doesn't work.
        //

        return( IsDBCSLeadByte( c ) != FALSE );
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\array.cxx ===
#include "pch.cxx"  
#include "..\..\ulib\src\array.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\more\more.cxx ===
/*++

Copyright (c) 1990-2000 Microsoft Corporation

Module Name:

        More.cxx

Abstract:

        "More" pager

Author:

        Ramon Juan San Andres (ramonsa) 11-Apr-1990

Revision History:

--*/


#include "ulib.hxx"
#include "arg.hxx"
#include "arrayit.hxx"
#include "file.hxx"
#include "filestrm.hxx"
#include "keyboard.hxx"
#include "rtmsg.h"
#include "pager.hxx"
#include "path.hxx"
#include "smsg.hxx"
#include "system.hxx"
#include "more.hxx"

#define DEFAULT_TABEXP  8

#define         NULL_CHARACTER                  ((CHAR)'\0')
#define         CTRLC_CHARACTER                 ((CHAR)0x03)



VOID __cdecl
main (
        )

/*++

Routine Description:

        Main function of the more pager.

Arguments:

    None.

Return Value:

    None.

Notes:

--*/


{

    // Initialize stuff
    //
    DEFINE_CLASS_DESCRIPTOR( MORE );

    //
    // Now do the paging
    //
    {
        MORE More;

        //
        // Initialize the MORE object.
        //
        if( More.Initialize() ) {

            //
            // Do the paging
            //
            More.DoPaging();
        }
    }
}

DEFINE_CONSTRUCTOR( MORE,       PROGRAM );



BOOLEAN
MORE::Initialize (
        )

/*++

Routine Description:

        Initializes the MORE object

Arguments:

    None.

Return Value:

    None.

Notes:

--*/

{
        //
        //      Initialize program object
        //
        if( !PROGRAM::Initialize( MORE_MESSAGE_USAGE, MORE_ERROR_NO_MEMORY,  EXIT_ERROR ) ) {

            return FALSE;
        }

        //
        //      Initialize whatever needs initialization
        //
        InitializeThings();

        //
        //      Do the argument parsing
        //
        SetArguments();

        return TRUE;

}

VOID
MORE::Construct (
    )
/*++

Routine Description:

        Construct a MORE object

Arguments:

    None.

Return Value:

    None.

Notes:

--*/

{
    _Keyboard = NULL;

    _FilesArgument = NULL;
    _LineDelimiters = NULL;
    _Percent = NULL;
    _Line = NULL;
    _Help = NULL;
    _DisplayLinesOption = NULL;
    _SkipLinesOption = NULL;
    _NextFileOption = NULL;
    _ShowLineNumberOption = NULL;
    _QuitOption = NULL;
    _Help1Option = NULL;
    _Help2Option = NULL;
}

MORE::~MORE (
        )

/*++

Routine Description:

        Destructs a MORE object

Arguments:

    None.

Return Value:

    None.

Notes:

--*/

{
        //
        //      Deallocate the global structures previously allocated
        //
        DeallocateThings();

        //
        //      Exit without error
        //
        exit( EXIT_NORMAL );

}

VOID
MORE::InitializeThings (
        )

/*++

Routine Description:

        Initializes the global variables that need initialization

Arguments:

    None.

Return Value:

    None.

Notes:

--*/

{

    if ( //
         // Initialize the library
         //
         !(_Keyboard = NEW KEYBOARD)


       ) {

                exit( EXIT_ERROR );

         }

    // MORE translates from MBCS to Unicode according to the
    // current console codepage.
    //
    WSTRING::SetConsoleConversions();

    if ( //
         // Pager stuff
         //
         !DEFINE_CLASS_DESCRIPTOR( PAGER )          ||
         //
         // Misc. Strings
         //
         ((_LineDelimiters = NEW DSTRING) == NULL ) ||
         !_LineDelimiters->Initialize( "\r\n" )     ||
         ((_Percent = NEW DSTRING) == NULL )        ||
         ((_Line    = NEW DSTRING) == NULL )        ||
         ((_OtherPrompt = NEW DSTRING) == NULL )
        ) {

                Fatal();

        }

        //
        //      Get the strings containing valid user options
        //
        if ( (( _Help                            = QueryMessageString( MORE_HELP )) ==  NULL )                                  ||
                 (( _DisplayLinesOption  = QueryMessageString( MORE_OPTION_DISPLAYLINES )) == NULL )    ||
                 (( _SkipLinesOption     = QueryMessageString( MORE_OPTION_SKIPLINES )) == NULL )               ||
                 (( _NextFileOption              = QueryMessageString( MORE_OPTION_NEXTFILE )) == NULL )                ||
                 (( _ShowLineNumberOption = QueryMessageString( MORE_OPTION_SHOWLINENUMBER )) == NULL ) ||
                 (( _QuitOption                  = QueryMessageString( MORE_OPTION_QUIT )) == NULL )                    ||
                 (( _Help1Option                 = QueryMessageString( MORE_OPTION_HELP1 )) == NULL )                   ||
                 (( _Help2Option                 = QueryMessageString( MORE_OPTION_HELP2 )) == NULL ) ) {

                Fatal();
        }

        _Keyboard->Initialize();
        _Quit                                   =       FALSE;
        _ExtendedModeSwitch     =       FALSE;
        _ClearScreenSwitch              =       FALSE;
        _ExpandFormFeedSwitch   =       FALSE;
        _SqueezeBlanksSwitch    =       FALSE;
        _HelpSwitch                     =       FALSE;
        _StartAtLine                    =       0;
        _TabExp                         =       DEFAULT_TABEXP;
        _FilesArgument                  =       NULL;

}

VOID
MORE::DeallocateThings (
        )

/*++

Routine Description:

        Deallocates the global variables that need deallocation

Arguments:

    None.

Return Value:

    None.

Notes:

--*/

{

        DELETE( _Keyboard );

        DELETE( _FilesArgument );
        DELETE( _LineDelimiters );
        DELETE( _Percent );
        DELETE( _Line );
        DELETE( _Help );

        //
        //      Delete the strings containing valid user options
        //
        DELETE( _DisplayLinesOption );
        DELETE( _SkipLinesOption );
        DELETE( _NextFileOption );
        DELETE( _ShowLineNumberOption );
        DELETE( _QuitOption );
        DELETE( _Help1Option );
        DELETE( _Help2Option );

}

VOID
MORE::DoPaging (
        )

/*++

Routine Description:

        Does the paging.

Arguments:

    None.

Return Value:

    None.

Notes:

--*/

{
    PPATH        Path;
    PITERATOR    Iterator;
    BOOLEAN      IsFirstFile = TRUE;
    ULONG        FilesLeft;
    PFSN_FILE    FsnFile;
    PFILE_STREAM FileStream;

    FilesLeft = _FilesArgument->QueryPathCount();

    if ( FilesLeft > 0 ) {

        //
        //  We have a list of files, we will page each one in turn
        //
        //  Get an iterator for going thru the file list
        //
        if ((Iterator = _FilesArgument->GetPathArray()->QueryIterator()) == NULL ) {

            Fatal();
        }

        Path = (PPATH)Iterator->GetNext();

        //
        //  Iterate thru all the files in the array
        //
        while ( Path && !_Quit) {

            //
            //  Get a new stream out of the file name
            //
            if ((FsnFile = SYSTEM::QueryFile( Path )) == NULL ||
                (FileStream = FsnFile->QueryStream( READ_ACCESS )) == NULL ) {
                Fatal(  EXIT_ERROR, MORE_ERROR_CANNOT_ACCESS, "%W", Path->GetPathString() );
            }

            PageStream( FileStream,
                        FsnFile,
                        IsFirstFile ? _StartAtLine : 0, --FilesLeft );

            DELETE( FileStream );
            DELETE( FsnFile );

            Path        = (PPATH)Iterator->GetNext();
            IsFirstFile = FALSE;
        }

        DELETE( Iterator );

    } else {

        //
        //  The user did'nt specify a file list, so we will page
        //  standard input.
        //
        PageStream( GetStandardInput(),
                    NULL,
                    _StartAtLine,
                    0 );
    }
}

VOID
MORE::PageStream (
        IN PSTREAM              Stream,
        IN PFSN_FILE    FsnFile,
        IN ULONG                FirstLineToDisplay,
        IN ULONG                FilesLeft
        )

/*++

Routine Description:

        Pages a stream

Arguments:

        Stream                          -       Supplies pointer to stream
        FsnFile                         -       Supplies pointer to file object
        FirstLineToDisplay      -       Supplies first line to display
        FilesLeft                       -       Files remaining to be displayed

Return Value:

    None.

Notes:

--*/

{

        PAGER   Pager;
        ULONG   LinesToDisplay;
        BOOLEAN ClearScreen;
        BOOLEAN StayInFile;

        //
        //      Initialize the pager
        //
        if (!Pager.Initialize( Stream,  this)) {

                Fatal();

        }

        //
        //      Skip to the first line to be displayed
        //
        if ( FirstLineToDisplay > 0 ) {
                Pager.SkipLines( FirstLineToDisplay, _TabExp );
        }

        LinesToDisplay  = Pager.QueryLinesPerPage() - 1;
        ClearScreen     = _ClearScreenSwitch;
        StayInFile              = TRUE;

        while (StayInFile && Pager.ThereIsMoreToPage() && !_Quit) {

            // If QueryLinesPerPage() returns 0 then undo the -1 operation.

            if (LinesToDisplay == (ULONG) -1) {
                LinesToDisplay = 0;
            }

                //
                //      Display a group of lines
                //
                Pager.DisplayPage( LinesToDisplay,
                                   ClearScreen,
                                   _SqueezeBlanksSwitch,
                                   _ExpandFormFeedSwitch,
                                   _TabExp );

                //
                //      If not at end of stream, we wait for an option
                //
                if (Pager.ThereIsMoreToPage() || (FilesLeft > 0)) {

                        StayInFile = DoOption( FsnFile, &Pager, &LinesToDisplay, &ClearScreen );
                }
        }
}

BOOLEAN
MORE::DoOption (
        IN      PFSN_FILE       FsnFile,
        IN      PPAGER          Pager,
        OUT PULONG              LinesInPage,
        OUT PBOOLEAN    ClearScreen
        )

/*++

Routine Description:

        Gets an option from the user

Arguments:

        FsnFile                 -       Supplies pointer to file object
        Pager                   -       Supplies pointer to pager
        LinesInpage             -       Supplies pointer to lines to display in next page
        ClearScreen             -       Supplies pointer to Clearscreen flag.

Return Value:

        TRUE  if paging should continue for this file,
        FALSE otherwise

--*/

{

    WCHAR       Char;
    DSTRING     String;
    BOOLEAN     ShowLineNumber = FALSE;
    BOOLEAN     ShowHelp       = FALSE;
    LONG        Number;


        String.Initialize( " " );

        while ( TRUE ) {

                //
                //      Display prompt
                //
                Prompt( FsnFile, Pager, ShowLineNumber, ShowHelp, 0 );

                ShowHelp                = FALSE;
                ShowLineNumber  = FALSE;

                //
                //      Get option from the user
                //
                _Keyboard->DisableLineMode();
                _Keyboard->ReadChar( &Char );
                _Keyboard->EnableLineMode();
                String.SetChAt(Char, 0);
                String.Strupr();
                Pager->ClearLine();

                //
                //      If Ctl-C, get out
                //
                if ( Char == CTRLC_CHARACTER ) {

                        _Keyboard->EnableLineMode();
                        GenerateConsoleCtrlEvent( CTRL_C_EVENT, 0 );
                        _Quit = TRUE;
                        return FALSE;
                }


                //
                //      If not in extended mode, any key just advances one page
                //
                if ( !_ExtendedModeSwitch ) {
                *LinesInPage  = Pager->QueryLinesPerPage() - 1;
                        return TRUE;
                }


                //
                //      Now take the proper action
                //
                if ( String.QueryChAt(0) == (WCHAR)CARRIAGERETURN ) {

                        //
                        //      Display next line of the file
                        //
                        *LinesInPage  = 1;
                        *ClearScreen  = FALSE;
                        return TRUE;

                } else if ( String.QueryChAt(0) == (WCHAR)' ' ) {

                        //
                        //      Display next page
                        //
            *ClearScreen = _ClearScreenSwitch;
                *LinesInPage  = Pager->QueryLinesPerPage() - 1;
                        return TRUE;

                } else if ( String.Stricmp(_DisplayLinesOption) == 0 ) {

                        //
                        //      Display a certain number of lines. Get the number of lines
                        //      to display
                        //
                        Prompt( FsnFile, Pager, ShowLineNumber, ShowHelp, MORE_LINEPROMPT );


                        *LinesInPage = ReadNumber();

            //if ( ReadLine( _Keyboard, &String ) &&
            //   String.QueryNumber((PLONG)LinesInPage) ) {
            //
            //   (*LinesInPage)--;
            //
            //} else {
            //  *LinesInPage  = 0;
            //}

                        Pager->ClearLine();

                        *ClearScreen  = FALSE;
                        return TRUE;

                } else if ( String.Stricmp(_SkipLinesOption) == 0 ) {

                        //
                        //      Skip a certain number of lines and then display a page.
                        //
                        Prompt( FsnFile, Pager, ShowLineNumber, ShowHelp, MORE_LINEPROMPT );

                        Number = ReadNumber( );
                        if ( Number ) {
                            Pager->SkipLines( Number, _TabExp );
                        }

                        Pager->ClearLine();

                        *LinesInPage  = Pager->QueryLinesPerPage() - 1;
                        return TRUE;

                } else if ( String.Stricmp(_NextFileOption) == 0 ) {

                        //
                        //      Stop paging this file
                        //
                        return FALSE;

                } else if ( String.Stricmp(_QuitOption) == 0 ) {

                        //
                        //      Quit the program
                        //
                        _Quit = TRUE;
                        return FALSE;

                } else if ( String.Stricmp(_ShowLineNumberOption) ==    0) {

                        //
                        //      Prompt again, showing the line number within the file
                        //
                        ShowLineNumber = TRUE;

                } else if ( ( String.Stricmp(_Help1Option) == 0) ||
                                        ( String.Stricmp(_Help2Option) == 0)) {

                        //
                        //      Prompt again, showing a message line
                        //
                        ShowHelp = TRUE;

                }

        }

}

VOID
MORE::Prompt (
        IN      PFSN_FILE       FsnFile,
        IN      PPAGER          Pager,
        IN      BOOLEAN         ShowLineNumber,
        IN      BOOLEAN         ShowHelp,
        IN      MSGID           OtherMsgId
        )

/*++

Routine Description:

        Displays prompt. The prompt consists of a "base" prompt (e.g.
        "-- More --" plus various optional strings:

                - Percentage of the file displayed so far.
                - Line number within the file
                - Help
                - Other (e.g prompt for a number )


Arguments:

        FsnFile                 -       Supplies pointer to file object
        Pager                   -       Supplies pointer to pager
        ShowLineNumber  -       Supplies flag which if TRUE causes the current
                                                line numnber to be displayed
        HelpMsg                 -       Supplies flag which if TRUE causes a brief help
                                                to be displayed

        OtherMsg                -       Supplies MsgId of any other string to be displayed

Return Value:

        none

--*/

{

        CHAR    NullBuffer = NULL_CHARACTER;
        PVOID   PercentMsg;
        PVOID   LineMsg;
        PVOID   HelpMsg;
        PVOID   OtherMsg;

        //
        //      Obtain all the strings that form part of the prompt
        //
        if ( FsnFile != NULL ) {
                SYSTEM::QueryResourceString( _Percent, MORE_PERCENT, "%d", (Pager->QueryCurrentByte() * 100) / FsnFile->QuerySize());
                _Percent->QuerySTR( 0, TO_END, (PSTR)_StringBuffer0, STRING_BUFFER_SIZE);
                PercentMsg = (PVOID)_StringBuffer0;
        } else {
                PercentMsg = (PVOID)&NullBuffer;
        }

        if (ShowLineNumber) {
                SYSTEM::QueryResourceString( _Line, MORE_LINE, "%d", Pager->QueryCurrentLine());
                _Line->QuerySTR( 0, TO_END, (PSTR)_StringBuffer1, STRING_BUFFER_SIZE);
                LineMsg = (PVOID)_StringBuffer1;
        } else {
                LineMsg = (PVOID)&NullBuffer;
        }

        if (ShowHelp) {
                _Help->QuerySTR(0, TO_END, (PSTR)_StringBuffer2, STRING_BUFFER_SIZE);
                HelpMsg = (PVOID)_StringBuffer2;
        } else {
                HelpMsg = (PVOID)&NullBuffer;
        }

        if (OtherMsgId != 0) {
                SYSTEM::QueryResourceString( _OtherPrompt, OtherMsgId, "" );
                _OtherPrompt->QuerySTR(0, TO_END, (PSTR)_StringBuffer3, STRING_BUFFER_SIZE);
                OtherMsg = (PVOID)_StringBuffer3;
        } else {
                OtherMsg = (PVOID)&NullBuffer;
        }

        //
        //      Now display the prompt
        //
        DisplayMessage( MORE_PROMPT, NORMAL_MESSAGE, "%s%s%s%s", PercentMsg, LineMsg, HelpMsg, OtherMsg );
}

PWSTRING
MORE::QueryMessageString (
        IN MSGID        MsgId
        )
/*++

Routine Description:

        Obtains a string object initialized to the contents of some message

Arguments:

        MsgId   -       Supplies ID of the message

Return Value:

        Pointer to initialized string object

Notes:

--*/

{

        PWSTRING        String;

    if ( ((String = NEW DSTRING) == NULL )  ||
         !(SYSTEM::QueryResourceString( String, MsgId, "" )) ) {

                DELETE( String );
                String = NULL;
        }

        return String;

}

ULONG
MORE::ReadNumber (
        )
/*++

Routine Description:

        Reads a number from the keyboard.

Arguments:

        None

Return Value:

        Number read

Notes:

--*/

{
    DSTRING     NumberString;
    DSTRING     CharString;
    PSTREAM     StandardOut;
    ULONG       Number = 0;
    LONG        LongNumber;
    WCHAR       Char;
    BOOLEAN     Done = FALSE;
    ULONG       DigitCount = 0;

        StandardOut = GetStandardOutput();

        NumberString.Initialize( "" );
        CharString.Initialize( " " );

        while ( !Done ) {

                _Keyboard->DisableLineMode();
                _Keyboard->ReadChar( &Char );
                _Keyboard->EnableLineMode();

                switch ( Char ) {

                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                        CharString.SetChAt( Char, 0 );
                        NumberString.Strcat( &CharString );
                        StandardOut->WriteChar( Char );
                        DigitCount++;
                        break;

                case '\b':
                        if ( DigitCount > 0 ) {
                                NumberString.Truncate( NumberString.QueryChCount() - 1 );
                                StandardOut->WriteChar( Char );
                                StandardOut->WriteChar( ' ' );
                                StandardOut->WriteChar( Char );
                                DigitCount--;
                        }
                        break;


                case '\r':
                case '\n':
                        Done = TRUE;
                        break;

        case CTRLC_CHARACTER:
            _Quit = TRUE;
            Done  = TRUE;
            break;

                default:
            break;


                }
        }

        if ( NumberString.QueryChCount() > 0 ) {

        if ( NumberString.QueryNumber( &LongNumber ) ) {

                        Number = (ULONG)LongNumber;
                }
        }

        return Number;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\arrayit.cxx ===
#include "pch.cxx"  
#include "..\..\ulib\src\arrayit.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\attrdef.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\attrdef.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\attrib.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\attrib.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\attrlist.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\attrlist.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\autoreg.cxx ===
#include "pch.cxx"  
#include "..\..\ifsutil\src\autoreg.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\attrcol.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\attrcol.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\autoentr.cxx ===
#include "pch.cxx"  
#include "..\..\ifsutil\src\autoentr.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\badfile.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\badfile.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\attrrec.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\attrrec.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\basesys.cxx ===
#include "pch.cxx"  
#include "..\..\ulib\src\basesys.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\bitfrs.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\bitfrs.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\bootfile.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\bootfile.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\bigint.cxx ===
#include "pch.cxx"  
#include "..\..\ifsutil\src\bigint.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\bitvect.cxx ===
#include "pch.cxx"  
#include "..\..\ulib\src\bitvect.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\bootreg.c ===
#include "..\..\ifsutil\src\bootreg.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\cannedsd.cxx ===
#include "pch.cxx"  
#include "..\..\ifsutil\src\cannedsd.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\cache.cxx ===
#include "pch.cxx"  
#include "..\..\ifsutil\src\cache.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\clasdesc.cxx ===
#include "pch.cxx"  
#include "..\..\ulib\src\clasdesc.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\boothack.cxx ===
#include <pch.cxx>
#include "ulib.hxx"

PCCLASS_DESCRIPTOR BSTRING_cd;
PCCLASS_DESCRIPTOR BDSTRING_cd;
PCCLASS_DESCRIPTOR BUFFER_STREAM_cd;
PCCLASS_DESCRIPTOR BYTE_STREAM_cd;
PCCLASS_DESCRIPTOR CHKDSK_MESSAGE_cd;
PCCLASS_DESCRIPTOR COMM_DEVICE_cd;
PCCLASS_DESCRIPTOR FILE_STREAM_cd;
PCCLASS_DESCRIPTOR FSNODE_cd;
PCCLASS_DESCRIPTOR FSN_DIRECTORY_cd;
PCCLASS_DESCRIPTOR FSN_FILE_cd;
PCCLASS_DESCRIPTOR FSN_FILTER_cd;
PCCLASS_DESCRIPTOR KEYBOARD_cd;
PCCLASS_DESCRIPTOR MULTIPLE_PATH_ARGUMENT_cd;
PCCLASS_DESCRIPTOR PATH_ARGUMENT_cd;
PCCLASS_DESCRIPTOR PATH_cd;
PCCLASS_DESCRIPTOR PIPE_cd;
PCCLASS_DESCRIPTOR PIPE_STREAM_cd;
PCCLASS_DESCRIPTOR PRINT_STREAM_cd;
PCCLASS_DESCRIPTOR PROGRAM_cd;
PCCLASS_DESCRIPTOR SCREEN_cd;
PCCLASS_DESCRIPTOR STREAM_MESSAGE_cd;
PCCLASS_DESCRIPTOR STREAM_cd;
PCCLASS_DESCRIPTOR STRING_ARRAY_cd;
PCCLASS_DESCRIPTOR TIMEINFO_ARGUMENT_cd;
PCCLASS_DESCRIPTOR TIMEINFO_cd;
PCCLASS_DESCRIPTOR REST_OF_LINE_ARGUMENT_cd;

//
// Hack because the code to fetch message text in ulib is
// there's 10 layers of stuff to get to the single
// simple thing I want.
//
BOOLEAN
SimpleFetchMessageTextInOemCharSet(
    IN  ULONG  MessageId,
    OUT CHAR  *Text,
    IN  ULONG  BufferLen
    )
{
    NTSTATUS Status;
    PMESSAGE_RESOURCE_ENTRY MessageEntry;
    ULONG l,x;
    WCHAR buffer[500];
    WCHAR *text;

    Status = RtlFindMessage(
                NtCurrentPeb()->ImageBaseAddress,
                11, //RT_MESSAGETABLE,
                0,
                MessageId,
                &MessageEntry
                );

    if(!NT_SUCCESS(Status)) {
        return(FALSE);
    }

    if(MessageEntry->Flags & MESSAGE_RESOURCE_UNICODE) {
        //
        // Need simple Unicode to OEM conversion.
        //
        text = (WCHAR *)MessageEntry->Text;

    } else {
        //
        // Need ANSI to OEM conversion, which doesn't exist.
        // Thus we convert ANSI to Unicode first.
        //
        Status = RtlMultiByteToUnicodeN(
                    buffer,
                    sizeof(buffer),
                    &l,
                    (char *)MessageEntry->Text,
                    strlen((const char *)MessageEntry->Text) + 1
                    );

        if(!NT_SUCCESS(Status)) {
            return(FALSE);
        }

        text = buffer;
    }

    //
    // Unicode to OEM, leaving the result in the caller's buffer.
    //
    Status = RtlUnicodeToOemN(
                Text,
                BufferLen,
                &l,
                text,
                (wcslen(text)+1) * sizeof(WCHAR)
                );

    //
    // Strip out %0 and anything past it.
    // Note that l includes the terminating nul and there's no need
    // to include it in the scan.
    // Also note that this is not strictly correct for DBCS case but
    // it should be good enough.
    //
    for(x=0; x<(l-2); x++) {
        if((Text[x] == '%') && (Text[x+1] == '0')) {
            Text[x] = 0;
            break;
        }
    }


    return((BOOLEAN)NT_SUCCESS(Status));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\clusrun.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\clusrun.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\cluster.cxx ===
#include "pch.cxx"  
#include "..\..\ufat\src\cluster.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\cmem.cxx ===
#include "pch.cxx"  
#include "..\..\ulib\src\cmem.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\convfat.cxx ===
#include "pch.cxx"  
#include "..\..\cufat\src\convfat.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\contain.cxx ===
#include "pch.cxx"  
#include "..\..\ulib\src\contain.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\cufat.cxx ===
#include "pch.cxx"  
#include "..\..\cufat\src\cufat.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\dcache.cxx ===
#include "pch.cxx"  
#include "..\..\ifsutil\src\dcache.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\easet.cxx ===
#include "pch.cxx"  
#include "..\..\ufat\src\easet.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\eaheader.cxx ===
#include "pch.cxx"  
#include "..\..\ufat\src\eaheader.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\digraph.cxx ===
#include "pch.cxx"  
#include "..\..\ifsutil\src\digraph.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\drive.cxx ===
#include "pch.cxx"  
#include "..\..\ifsutil\src\drive.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\downgrad.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\downgrad.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\extents.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\extents.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\fat.cxx ===
#include "pch.cxx"  
#include "..\..\ufat\src\fat.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\fatdent.cxx ===
#include "pch.cxx"  
#include "..\..\ufat\src\fatdent.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\fatvol.cxx ===
#include "pch.cxx"  
#include "..\..\ufat\src\fatvol.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\fatsachk.cxx ===
#include "pch.cxx"  
#include "..\..\ufat\src\fatsachk.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\fatsa.cxx ===
#include "pch.cxx"  
#include "..\..\ufat\src\fatsa.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\fatsacnv.cxx ===
#include "pch.cxx"  
#include "..\..\ufat\src\fatsacnv.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\filedir.cxx ===
#include "pch.cxx"  
#include "..\..\ufat\src\filedir.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\fatdir.cxx ===
#include "pch.cxx"  
#include "..\..\ufat\src\fatdir.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\fatntfs.cxx ===
#include "pch.cxx"  
#include "..\..\cufat\src\fatntfs.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\hackwc.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\hackwc.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\format.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\format.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\hmem.cxx ===
#include "pch.cxx"  
#include "..\..\ulib\src\hmem.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\ifsutil.cxx ===
#include "pch.cxx"  
#include "..\..\ifsutil\src\ifsutil.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\frsstruc.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\frsstruc.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\ifssys.cxx ===
#include "pch.cxx"  
#include "..\..\ifsutil\src\ifssys.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\frs.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\frs.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\hashindx.cxx ===
#include "pch.cxx"  
#include "..\..\ufat\src\hashindx.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\indxroot.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\indxroot.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\indxtree.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\indxtree.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\largemcb.c ===
#include "..\..\untfs\src\largemcb.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\list.cxx ===
#include "pch.cxx"  
#include "..\..\ulib\src\list.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\indxbuff.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\indxbuff.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\intstack.cxx ===
#include "pch.cxx"  
#include "..\..\ifsutil\src\intstack.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\indxchk.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\indxchk.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\iterator.cxx ===
#include "pch.cxx"  
#include "..\..\ulib\src\iterator.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\membmgr.cxx ===
#include "pch.cxx"  
#include "..\..\ulib\src\membmgr.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\mem.cxx ===
#include "pch.cxx"  
#include "..\..\ulib\src\mem.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\listit.cxx ===
#include "pch.cxx"  
#include "..\..\ulib\src\listit.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\logfile.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\logfile.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\machine.cxx ===
#include "pch.cxx"  
#include "..\..\ulib\src\machine.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\membmgr2.cxx ===
#include "pch.cxx"
#include "..\..\ulib\src\membmgr2.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\message.cxx ===
#include "pch.cxx"  
#include "..\..\ulib\src\message.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\makefile.inc ===
rtmsg.mc : ..\..\..\ulib\src\rtmsg.mc
    copy $? $@

#rtmsg.rc: msg00001.bin
#
#rtmsg.h msg00001.bin: rtmsg.mc
#    mc -v -h .\ rtmsg.mc

#
#   From ULIB
#

..\achkmsg.cxx : ..\..\..\ulib\src\achkmsg.cxx

..\array.cxx : ..\..\..\ulib\src\array.cxx

..\arrayit.cxx : ..\..\..\ulib\src\arrayit.cxx

..\basesys.cxx : ..\..\..\ulib\src\basesys.cxx

..\bitvect.cxx : ..\..\..\ulib\src\bitvect.cxx

..\contain.cxx : ..\..\..\ulib\src\contain.cxx

..\clasdesc.cxx : ..\..\..\ulib\src\clasdesc.cxx

..\cmem.cxx : ..\..\..\ulib\src\cmem.cxx

..\hmem.cxx : ..\..\..\ulib\src\hmem.cxx

..\iterator.cxx : ..\..\..\ulib\src\iterator.cxx

..\list.cxx : ..\..\..\ulib\src\list.cxx

..\listit.cxx : ..\..\..\ulib\src\listit.cxx

..\machine.cxx : ..\..\..\ulib\src\machine.cxx

..\mem.cxx : ..\..\..\ulib\src\mem.cxx

..\membmgr.cxx : ..\..\..\ulib\src\membmgr.cxx

..\membmgr2.cxx : ..\..\..\ulib\src\membmgr2.cxx

..\message.cxx : ..\..\..\ulib\src\message.cxx

..\newdel.cxx : ..\..\..\ulib\src\newdel.cxx

..\object.cxx : ..\..\..\ulib\src\object.cxx

..\prnthack.cxx : ..\..\..\ulib\src\prnthack.cxx

..\seqcnt.cxx : ..\..\..\ulib\src\seqcnt.cxx

..\sortcnt.cxx : ..\..\..\ulib\src\sortcnt.cxx

..\sortlist.cxx : ..\..\..\ulib\src\sortlist.cxx

..\sortlit.cxx : ..\..\..\ulib\src\sortlit.cxx

..\spackmsg.cxx : ..\..\..\ulib\src\spackmsg.cxx

..\tmackmsg.cxx : ..\..\..\ulib\src\tmackmsg.cxx

..\ulib.cxx : ..\..\..\ulib\src\ulib.cxx

..\wstring.cxx : ..\..\..\ulib\src\wstring.cxx

..\arg.cxx : ..\..\..\ulib\src\arg.cxx



#
#   From IFSUTIL
#
..\bigint.cxx : ..\..\..\ifsutil\src\bigint.cxx

..\cache.cxx : ..\..\..\ifsutil\src\cache.cxx

..\cannedsd.cxx : ..\..\..\ifsutil\src\cannedsd.cxx

..\digraph.cxx : ..\..\..\ifsutil\src\digraph.cxx

..\drive.cxx : ..\..\..\ifsutil\src\drive.cxx

..\ifssys.cxx : ..\..\..\ifsutil\src\ifssys.cxx

..\ifsutil.cxx : ..\..\..\ifsutil\src\ifsutil.cxx

..\intstack.cxx : ..\..\..\ifsutil\src\intstack.cxx

..\mpmap.cxx : ..\..\..\ifsutil\src\mpmap.cxx

..\numset.cxx : ..\..\..\ifsutil\src\numset.cxx

..\secrun.cxx : ..\..\..\ifsutil\src\secrun.cxx

..\spaset.cxx : ..\..\..\ifsutil\src\spaset.cxx

..\supera.cxx : ..\..\..\ifsutil\src\supera.cxx

..\volume.cxx : ..\..\..\ifsutil\src\volume.cxx

..\autoentr.cxx : ..\..\..\ifsutil\src\autoentr.cxx

..\autoreg.cxx : ..\..\..\ifsutil\src\autoreg.cxx

..\bootreg.c : ..\..\..\ifsutil\src\bootreg.c

..\dcache.cxx : ..\..\..\ifsutil\src\dcache.cxx

..\rcache.cxx : ..\..\..\ifsutil\src\rcache.cxx

..\rwcache.cxx : ..\..\..\ifsutil\src\rwcache.cxx

..\tlink.cxx : ..\..\..\ifsutil\src\tlink.cxx

#
#   From UFAT
#
..\cluster.cxx : ..\..\..\ufat\src\cluster.cxx

..\eaheader.cxx : ..\..\..\ufat\src\eaheader.cxx

..\easet.cxx : ..\..\..\ufat\src\easet.cxx

..\fat.cxx : ..\..\..\ufat\src\fat.cxx

..\fatdent.cxx : ..\..\..\ufat\src\fatdent.cxx

..\fatdir.cxx : ..\..\..\ufat\src\fatdir.cxx

..\fatsa.cxx : ..\..\..\ufat\src\fatsa.cxx

..\rfatsa.cxx : ..\..\..\ufat\src\rfatsa.cxx

..\fatsachk.cxx : ..\..\..\ufat\src\fatsachk.cxx

..\fatsacnv.cxx : ..\..\..\ufat\src\fatsacnv.cxx

..\fatvol.cxx : ..\..\..\ufat\src\fatvol.cxx

..\filedir.cxx : ..\..\..\ufat\src\filedir.cxx

..\hashindx.cxx : ..\..\..\ufat\src\hashindx.cxx

..\reloclus.cxx : ..\..\..\ufat\src\reloclus.cxx

..\rootdir.cxx : ..\..\..\ufat\src\rootdir.cxx

..\ufat.cxx : ..\..\..\ufat\src\ufat.cxx



#
#   From UNTFS
#
..\attrcol.cxx : ..\..\..\untfs\src\attrcol.cxx

..\attrdef.cxx : ..\..\..\untfs\src\attrdef.cxx

..\attrib.cxx : ..\..\..\untfs\src\attrib.cxx

..\attrlist.cxx : ..\..\..\untfs\src\attrlist.cxx

..\attrrec.cxx : ..\..\..\untfs\src\attrrec.cxx

..\badfile.cxx : ..\..\..\untfs\src\badfile.cxx

..\bitfrs.cxx : ..\..\..\untfs\src\bitfrs.cxx

..\bootfile.cxx : ..\..\..\untfs\src\bootfile.cxx

..\clusrun.cxx : ..\..\..\untfs\src\clusrun.cxx

..\downgrad.cxx : ..\..\..\untfs\src\downgrad.cxx

..\extents.cxx : ..\..\..\untfs\src\extents.cxx

..\format.cxx : ..\..\..\untfs\src\format.cxx

..\frs.cxx : ..\..\..\untfs\src\frs.cxx

..\frsstruc.cxx : ..\..\..\untfs\src\frsstruc.cxx

..\hackwc.cxx : ..\..\..\untfs\src\hackwc.cxx

..\indxbuff.cxx : ..\..\..\untfs\src\indxbuff.cxx

..\indxchk.cxx : ..\..\..\untfs\src\indxchk.cxx

..\indxroot.cxx : ..\..\..\untfs\src\indxroot.cxx

..\indxtree.cxx : ..\..\..\untfs\src\indxtree.cxx

..\largemcb.c : ..\..\..\untfs\src\largemcb.c

..\logfile.cxx : ..\..\..\untfs\src\logfile.cxx

..\mft.cxx : ..\..\..\untfs\src\mft.cxx

..\mftfile.cxx : ..\..\..\untfs\src\mftfile.cxx

..\mftinfo.cxx : ..\..\..\untfs\src\mftinfo.cxx

..\mftref.cxx : ..\..\..\untfs\src\mftref.cxx

..\ntfsbit.cxx : ..\..\..\untfs\src\ntfsbit.cxx

..\ntfschk.cxx : ..\..\..\untfs\src\ntfschk.cxx

..\ntfssa.cxx : ..\..\..\untfs\src\ntfssa.cxx

..\ntfsvol.cxx : ..\..\..\untfs\src\ntfsvol.cxx

..\rafile.cxx : ..\..\..\untfs\src\rafile.cxx

..\rasd.cxx : ..\..\..\untfs\src\rasd.cxx

..\sdchk.cxx : ..\..\..\untfs\src\sdchk.cxx

..\untfs.cxx : ..\..\..\untfs\src\untfs.cxx

..\upcase.cxx : ..\..\..\untfs\src\upcase.cxx

..\upfile.cxx : ..\..\..\untfs\src\upfile.cxx

..\usnjrnl.cxx : ..\..\..\untfs\src\usnjrnl.cxx

#
#   From CUFAT
#
..\convfat.cxx : ..\..\..\cufat\src\convfat.cxx

..\cufat.cxx : ..\..\..\cufat\src\cufat.cxx

..\fatntfs.cxx : ..\..\..\cufat\src\fatntfs.cxx
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\mpmap.cxx ===
#include "pch.cxx"  
#include "..\..\ifsutil\src\mpmap.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\mftfile.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\mftfile.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\mftinfo.cxx ===
#include "pch.cxx"
#include "..\..\untfs\src\mftinfo.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\mftref.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\mftref.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\ntfsbit.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\ntfsbit.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\mft.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\mft.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\newdel.cxx ===
#include "pch.cxx"  
#include "..\..\ulib\src\newdel.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\ntfschk.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\ntfschk.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\ntfsvol.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\ntfsvol.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\object.cxx ===
#include "pch.cxx"  
#include "..\..\ulib\src\object.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\ntfssa.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\ntfssa.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\numset.cxx ===
#include "pch.cxx"  
#include "..\..\ifsutil\src\numset.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\prnthack.cxx ===
#include "pch.cxx"  
#include "..\..\ulib\src\prnthack.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\rafile.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\rafile.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\pch.cxx ===
/*++

Copyright (c) 1994-2000 Microsoft Corporation

Module Name:

    pch.cxx

Abstract:

    This module implements pre-compiled headers for ntlib.

Author:

    Matthew Bradburn (mattbr)  26-Apr-1994

--*/

//
// ULIB headers.
//

#include "ulib.hxx"
#if defined(FE_SB) && defined(_X86_)
#include "machine.hxx"
#endif
#include "smsg.hxx"
#include "cmem.hxx"
#include "basesys.hxx"
#include "buffer.hxx"
#include "contain.hxx"
#include "hmem.hxx"
#include "achkmsg.hxx"
#include "error.hxx"
#include "ifsentry.hxx"
#include "ifsserv.hxx"
#include "iterator.hxx"
#include "list.hxx"
#include "listit.hxx"
#include "mem.hxx"
#include "membmgr.hxx"
#include "membmgr2.hxx"
#include "program.hxx"
#include "rtmsg.h"
#include "seqcnt.hxx"
#include "sortcnt.hxx"
#include "sortlist.hxx"
#include "sortlit.hxx"
#include "string.hxx"
#include "stringar.hxx"
#include "substrng.hxx"
#include "ulibcl.hxx"
#include "object.hxx"
#include "clasdesc.hxx"


//
// IFSUTIL headers.
//

#include "autoentr.hxx"
#include "autoreg.hxx"
#include "bigint.hxx"
#include "bpb.hxx"
#include "cache.hxx"
#include "cannedsd.hxx"
#include "dcache.hxx"
#include "digraph.hxx"
#include "drive.hxx"
#include "ifssys.hxx"
#include "intstack.hxx"
#include "mldcopy.hxx"
#include "numset.hxx"
#include "rcache.hxx"
#include "rwcache.hxx"
#include "secrun.hxx"
#include "supera.hxx"
#include "volume.hxx"

//
// UFAT headers.
//

#include "cluster.hxx"
#include "eaheader.hxx"
#include "easet.hxx"
#include "fat.hxx"
#include "fatdir.hxx"
#include "fatsa.hxx"
#include "fatdent.hxx"
#include "fatvol.hxx"
#include "filedir.hxx"
#include "reloclus.hxx"
#include "rfatsa.hxx"
#include "rootdir.hxx"
#include "hashindx.hxx"

//
// UNTFS headers.
//

#include "untfs.hxx"
#include "attrcol.hxx"
#include "attrdef.hxx"
#include "attrib.hxx"
#include "attrlist.hxx"
#include "attrrec.hxx"
#include "badfile.hxx"
#include "bitfrs.hxx"
#include "bootfile.hxx"
#include "clusrun.hxx"
#include "extents.hxx"
#include "frs.hxx"
#include "frsstruc.hxx"
#include "hackwc.hxx"
#include "indxbuff.hxx"
#include "indxroot.hxx"
#include "indxtree.hxx"
#include "logfile.hxx"
#include "mft.hxx"
#include "mftfile.hxx"
#include "mftinfo.hxx"
#include "mftref.hxx"
#include "ntfsbit.hxx"
#include "ntfssa.hxx"
#include "ntfsvol.hxx"
#include "upcase.hxx"
#include "upfile.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\rasd.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\rasd.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\rcache.cxx ===
#include "pch.cxx"  
#include "..\..\ifsutil\src\rcache.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\rfatsa.cxx ===
#include "pch.cxx"  
#include "..\..\ufat\src\rfatsa.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\reloclus.cxx ===
#include "pch.cxx"  
#include "..\..\ufat\src\reloclus.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\sdchk.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\sdchk.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\rwcache.cxx ===
#include "pch.cxx"  
#include "..\..\ifsutil\src\rwcache.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\secrun.cxx ===
#include "pch.cxx"  
#include "..\..\ifsutil\src\secrun.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\rootdir.cxx ===
#include "pch.cxx"  
#include "..\..\ufat\src\rootdir.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\seqcnt.cxx ===
#include "pch.cxx"  
#include "..\..\ulib\src\seqcnt.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\sortcnt.cxx ===
#include "pch.cxx"  
#include "..\..\ulib\src\sortcnt.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\sortlist.cxx ===
#include "pch.cxx"  
#include "..\..\ulib\src\sortlist.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\spaset.cxx ===
#include "pch.cxx"  
#include "..\..\ifsutil\src\spaset.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\spackmsg.cxx ===
#include "pch.cxx"  
#include "..\..\ulib\src\spackmsg.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\smsdtect.cxx ===
#include "pch.cxx"
#include "..\..\ifsutil\src\smsdtect.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\sortlit.cxx ===
#include "pch.cxx"  
#include "..\..\ulib\src\sortlit.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\sources.inc ===
!IF 0

Copyright (c) 1989-2001 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in $(BASEDIR)\bak\bin\sources.tpl

!ENDIF

NT_UP=0

TARGETNAME=ntlib
TARGETPATH=obj
TARGETTYPE=LIBRARY

PRECOMPILED_INCLUDE= ..\pch.cxx

SOURCES= \
    rtmsg.mc \
    ..\achkmsg.cxx     \
    ..\arg.cxx         \
    ..\array.cxx       \
    ..\arrayit.cxx     \
    ..\attrcol.cxx     \
    ..\attrdef.cxx     \
    ..\attrib.cxx      \
    ..\attrlist.cxx    \
    ..\attrrec.cxx     \
    ..\autoentr.cxx    \
    ..\autoreg.cxx     \
    ..\badfile.cxx     \
    ..\basesys.cxx     \
    ..\bigint.cxx      \
    ..\bitfrs.cxx      \
    ..\bitvect.cxx     \
    ..\bootfile.cxx    \
    ..\boothack.cxx \
    ..\bootreg.c       \
    ..\cache.cxx       \
    ..\cannedsd.cxx    \
    ..\clasdesc.cxx    \
    ..\clusrun.cxx     \
    ..\cluster.cxx     \
    ..\cmem.cxx        \
    ..\contain.cxx     \
    ..\convfat.cxx     \
    ..\cufat.cxx       \
    ..\digraph.cxx     \
    ..\dcache.cxx      \
    ..\downgrad.cxx    \
    ..\drive.cxx       \
    ..\eaheader.cxx    \
    ..\easet.cxx       \
    ..\extents.cxx     \
    ..\fat.cxx         \
    ..\fatdent.cxx     \
    ..\fatdir.cxx      \
    ..\fatntfs.cxx     \
    ..\fatsa.cxx       \
    ..\fatsachk.cxx    \
    ..\fatsacnv.cxx    \
    ..\fatvol.cxx      \
    ..\filedir.cxx     \
    ..\format.cxx      \
    ..\frs.cxx         \
    ..\frsstruc.cxx    \
    ..\hackwc.cxx      \
    ..\hashindx.cxx    \
    ..\hmem.cxx        \
    ..\ifssys.cxx      \
    ..\ifsutil.cxx     \
    ..\indxbuff.cxx    \
    ..\indxchk.cxx     \
    ..\indxroot.cxx    \
    ..\indxtree.cxx    \
    ..\intstack.cxx    \
    ..\iterator.cxx    \
    ..\largemcb.c      \
    ..\list.cxx        \
    ..\listit.cxx      \
    ..\logfile.cxx     \
    ..\machine.cxx     \
    ..\mem.cxx         \
    ..\membmgr.cxx     \
    ..\membmgr2.cxx    \
    ..\message.cxx     \
    ..\mpmap.cxx       \
    ..\mft.cxx         \
    ..\mftfile.cxx     \
    ..\mftinfo.cxx     \
    ..\mftref.cxx      \
    ..\newdel.cxx      \
    ..\ntfsbit.cxx     \
    ..\ntfschk.cxx     \
    ..\ntfssa.cxx      \
    ..\ntfsvol.cxx     \
    ..\numset.cxx      \
    ..\object.cxx      \
    ..\rafile.cxx      \
    ..\rasd.cxx        \
    ..\rcache.cxx      \
    ..\reloclus.cxx    \
    ..\rfatsa.cxx      \
    ..\rootdir.cxx     \
    ..\rwcache.cxx     \
    ..\sdchk.cxx       \
    ..\secrun.cxx      \
    ..\seqcnt.cxx      \
    ..\smsdtect.cxx    \
    ..\sortcnt.cxx     \
    ..\sortlist.cxx    \
    ..\sortlit.cxx     \
    ..\spackmsg.cxx    \
    ..\spaset.cxx      \
    ..\supera.cxx      \
    ..\tlink.cxx       \
    ..\tmackmsg.cxx    \
    ..\ufat.cxx        \
    ..\ulib.cxx        \
    ..\untfs.cxx       \
    ..\upfile.cxx      \
    ..\upcase.cxx      \
    ..\usnjrnl.cxx     \
    ..\volume.cxx      \
    ..\wstring.cxx

INCLUDES=..;\
    $(PROJECT_ROOT)\fs\utils\ulib\inc;\
    $(PROJECT_ROOT)\fs\utils\ifsutil\inc;\
    $(PROJECT_ROOT)\fs\utils\ufat\inc;\
    $(PROJECT_ROOT)\fs\utils\untfs\inc;\
    $(PROJECT_ROOT)\fs\utils\cufat\inc;\
    $(PROJECT_ROOT)\ntos\inc;\
    $(ADMIN_INC_PATH);

C_DEFINES=-DCONDITION_HANDLING=1 -D_AUTOCHECK_ -D_AUTOCONV_ -DUNICODE=1 -D_NTDRIVER_
NTTARGETFILES=

#
# This allow W2K utils to run under NT4 for temporary use.  Not intend for release.
#
!IF defined(UTILS_RUN_ON_NT4)
C_DEFINES=$(C_DEFINES) /DRUN_ON_NT4
!ENDIF

W32_SB=1
SOURCES_USED=..\sources.inc
USE_NTDLL=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\supera.cxx ===
#include "pch.cxx"  
#include "..\..\ifsutil\src\supera.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\tlink.cxx ===
#include "pch.cxx"  
#include "..\..\ifsutil\src\tlink.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\ufat.cxx ===
#include "pch.cxx"  
#include "..\..\ufat\src\ufat.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\tmackmsg.cxx ===
#include "pch.cxx"  
#include "..\..\ulib\src\tmackmsg.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\upcase.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\upcase.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\usa\makefile.inc ===
#
# DO NOT EDIT THIS FILE!!!  Edit .\sources. if you want to add a new source
# file to this component.  This file merely indirects to the real make file
# that is shared by all the components of NT OS/2
#
!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\untfs.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\untfs.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\upfile.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\upfile.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\usnjrnl.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\usnjrnl.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\ulib.cxx ===
#include "pch.cxx"  
#include "..\..\ulib\src\ulib.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\volume.cxx ===
#include "pch.cxx"  
#include "..\..\ifsutil\src\volume.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ntlib\src\wstring.cxx ===
#include "pch.cxx"  
#include "..\..\ulib\src\wstring.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\openfiles\disconnect.h ===
// ****************************************************************************
// 
//  Copyright (c)  Microsoft Corporation
//  
//  Module Name:
//
//        Disconnect.h  
//  
//  Abstract:
//  
//        macros and function prototypes of Disconnect.cpp
//  
//  Author:
//  
//       Akhil Gokhale (akhil.gokhale@wipro.com) 1-Nov-2000
//  
//  Revision History:
//  
//       Akhil Gokhale (akhil.gokhale@wipro.com) 1-Nov-2000 : Created It.
//  
// ****************************************************************************

#ifndef _DISCONNECT_H
#define _DISCONNECT_H
#include "openfiles.h"
#ifdef __cplusplus
extern "C" {
#endif

#define ID_HELP_START                IDS_HELP_LINE1
#define ID_HELP_END                    IDS_HELP_LINE36

// error messages
#define ERROR_USERNAME_BUT_NOMACHINE    GetResString(\
                                            IDS_ERROR_USERNAME_BUT_NOMACHINE)

#define ERROR_PASSWORD_BUT_NOUSERNAME    GetResString(\
                                            IDS_ERROR_PASSWORD_BUT_NOUSERNAME )


#define FAILURE                        GetResString(IDS_FAILURE)
#define SUCCESS                        GetResString(IDS_SUCCESS)
#define DISCONNECTED_SUCCESSFULLY   GetResString(IDS_SUCCESS_DISCONNECT)
#define DISCONNECT_UNSUCCESSFUL      GetResString(IDS_ERROR_DISCONNECT)
#define WILD_CARD                    _T("*")

#define READ_MODE                    GetResString(IDS_READ)
#define WRITE_MODE                    GetResString(IDS_WRITE)
#define READ_WRITE_MODE                GetResString(IDS_READ_SLASH_WRITE)
#define WRITE_READ_MODE                GetResString(IDS_WRITE_SLASH_READ)
#define PIPE_STRING                 L"\\PIPE\\srvsvc"
#define DOT_EOL                     GetResString(IDS_DOT_EOL)


BOOL DisconnectOpenFile( PTCHAR pszServer, 
                         PTCHAR pszID, 
                         PTCHAR pszAccessedby, 
                         PTCHAR pszOpenmode, 
                         PTCHAR pszOpenFile );
BOOL IsNamedPipePath(LPWSTR pszwFilePath);
BOOL IsSpecifiedID(LPTSTR pszId,DWORD dwId);
BOOL IsSpecifiedAccessedBy(LPTSTR pszAccessedby, LPWSTR pszwAccessedby);
BOOL IsSpecifiedOpenmode(LPTSTR pszOpenmode, DWORD  dwOpenmode);
BOOL IsSpecifiedOpenfile(LPTSTR pszOpenfile, LPWSTR pszwOpenfile);

#ifdef __cplusplus
}
#endif

#endif    // _DISCONNECT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\openfiles\openfiles.h ===
// ****************************************************************************
// 
//  Copyright (c)  Microsoft Corporation
//  
//  Module Name:
//
//        OpenFiles.h  
//  
//  Abstract:
//  
//        macros and function prototypes of OpenFiles.cpp
//  
//  Author:
//  
//       Akhil Gokhale (akhil.gokhale@wipro.com) 1-Nov-2000
//  
//  Revision History:
//  
//       Akhil Gokhale (akhil.gokhale@wipro.com) 1-Nov-2000 : Created It.
//  
// ****************************************************************************

#ifndef _OPENFILES_H
#define _OPENFILES_H
#include "pch.h"
#include "resource.h"
#include "chstring.h"
#define FORMAT_OPTIONS GetResString(IDS_FORMAT_OPTIONS)

// command line options and their indexes in the array
#define MAX_OPTIONS                 5
#define MAX_QUERY_OPTIONS        7 
#define MAX_DISCONNECT_OPTIONS   8   
#define MAX_LOCAL_OPTIONS        1

// options allowed ( no need to localize )
#define OPTION_DISCONNECT    _T("disconnect")
#define OPTION_QUERY        _T("query")
#define OPTION_USAGE        _T( "?" )
#define OPTION_SERVER        _T( "s" )
#define OPTION_USERNAME        _T( "u" )
#define OPTION_PASSWORD        _T( "p" )
#define OPTION_ID            _T( "id")
#define OPTION_ACCESSEDBY    _T( "a" )
#define OPTION_OPENMODE        _T( "o" )
#define OPTION_OPENFILE        _T( "op" )
#define OPTION_FORMAT        _T("fo")
#define OPTION_NOHEADER        _T("nh")
#define OPTION_VERBOSE        _T("v")
#define OPTION_LOCAL        _T("local") 



#define DOUBLE_SLASH                _T("\\\\")
#define SINGLE_SLASH                _T("\\")
#define SINGLE_DOT                  _T(".")
#define DOT_DOT                      L".."
#define BLANK_LINE                    L"\n"


// option indexes MAIN
#define OI_DISCONNECT                0
#define OI_QUERY                    1
#define OI_USAGE                    2
#define OI_LOCAL                    3
#define OI_DEFAULT                  4

// Option Indexes QUERY
#define OI_Q_QUERY                  0
#define OI_Q_SERVER_NAME            1
#define OI_Q_USER_NAME              2
#define OI_Q_PASSWORD               3
#define OI_Q_FORMAT                 4
#define OI_Q_NO_HEADER              5
#define OI_Q_VERBOSE                6

// Option Indexes DISCONNECT
#define OI_D_DISCONNECT             0
#define OI_D_SERVER_NAME            1
#define OI_D_USER_NAME              2
#define OI_D_PASSWORD               3
#define OI_D_ID                     4
#define OI_D_ACCESSED_BY            5
#define OI_D_OPEN_MODE              6
#define OI_D_OPEN_FILE              7

// Option Indexes for LOCAL
#define OI_O_LOCAL                  0

// Option Index for showresult for locally open files
// LOF means Localy Open Files
#define LOF_ID                      0
#define LOF_TYPE                    1
#define LOF_ACCESSED_BY             2
#define LOF_PROCESS_NAME            3
#define LOF_OPEN_FILENAME           4


// No of columns in locally open file
#define NO_OF_COL_LOCAL_OPENFILE    5 

// Column width for local open file showresult
#define COL_L_ID                       5
#define COL_L_TYPE                     10
#define COL_L_ACCESSED_BY              15
#define COL_L_PROCESS_NAME             20
#define COL_L_OPEN_FILENAME            50

BOOL DoLocalOpenFiles(DWORD dwFormat,BOOL bShowNoHeader,BOOL bVerbose,LPCTSTR pszLocalValue);
BOOL GetProcessOwner(LPTSTR pszUserName,DWORD hFile);

#define MAC_DLL_FILE_NAME           L"\\SFMAPI.DLL"

#define MIN_MEMORY_REQUIRED         256
// Macro definitions 
#define SAFEDELETE(pObj) \
    if (pObj) \
    {   \
        delete[] pObj; \
        pObj = NULL; \
    }

#define SAFEIRELEASE(pIObj) \
    if (pIObj)  \
    {\
        pIObj->Release();   \
        pIObj = NULL;\
    }

// SAFEBSTRFREE
#define SAFEBSTRFREE(bstrVal) \
    if (bstrVal) \
    {   \
        SysFreeString(bstrVal); \
        bstrVal = NULL; \
    }
#define SAFERELDYNARRAY(pArray)\
        if(pArray!=NULL)\
        {\
            DestroyDynamicArray(&pArray);\
            pArray = NULL;\
        }

#define FREE_LIBRARY(hModule)\
        if(hModule!=NULL)\
        {\
            ::FreeLibrary (hModule);\
            hModule = NULL;\
        }            

// Following are Windows Undocumented defines and structures
//////////////////////////////////////////////////////////////////
// START UNDOCUMETED FEATURES
//////////////////////////////////////////////////////////////////

#define AFP_OPEN_MODE_NONE                0x00000000
#define AFP_OPEN_MODE_READ                0x00000001
#define AFP_OPEN_MODE_WRITE                0x00000002

// Fork type of an open file
#define    AFP_FORK_DATA                    0x00000000
#define    AFP_FORK_RESOURCE                0x00000001

typedef struct _AFP_FILE_INFO
{
    DWORD    afpfile_id;                    // Id of the open file fork
    DWORD    afpfile_open_mode;            // Mode in which file is opened
    DWORD    afpfile_num_locks;            // Number of locks on the file
    DWORD    afpfile_fork_type;            // Fork type
    LPWSTR    afpfile_username;            // File opened by this user. max UNLEN
    LPWSTR    afpfile_path;                // Absolute canonical path to the file

} AFP_FILE_INFO, *PAFP_FILE_INFO;
// Used as RPC binding handle to server
typedef ULONG_PTR    AFP_SERVER_HANDLE;
typedef ULONG_PTR    *PAFP_SERVER_HANDLE;

/////////////////////////////////////////////////////////////////////////////
// END UNDOCUMETED FEATURES
/////////////////////////////////////////////////////////////////////////////

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\openfiles\openfiles.cpp ===
/******************************************************************************
Copyright (c)  Microsoft Corporation

Module Name:

    OpenFiles.cpp

Abstract:

    Enables an administrator to disconnect/query open files ina given system.

  Author:
  
 	  Akhil Gokhale (akhil.gokhale@wipro.com) 1-Nov-2000
  
 Revision History:
  
 	  Akhil Gokhale (akhil.gokhale@wipro.com) 1-Nov-2000 : Created It.

******************************************************************************/
#include "pch.h"
#include "OpenFiles.h"
#include "Disconnect.h"
#include "Query.h"
#include <limits.h>
#include "resource.h"

#define EXIT_ENV_SUCCESS 1
#define EXIT_ENV_FAILURE 0


#define SUBKEY _T("HARDWARE\\DESCRIPTION\\SYSTEM\\CENTRALPROCESSOR\\0")
#define ERROR_RETREIVE_REGISTRY	4
#define TOKEN_BACKSLASH4  _T("\\\\")
#define IDENTIFIER_VALUE  _T("Identifier")

#define SAFEFREE(pVal) \
if(pVal != NULL) \
{ \
	free(pVal); \
	pVal = NULL ;\
}


#define X86_MACHINE _T("x86")

#define SYSTEM_64_BIT 2
#define SYSTEM_32_BIT 3

BOOL g_bIs32BitEnv = TRUE ;

// Fuction protorypes. These functions will be used only in current file.
DWORD GetCPUInfo(LPTSTR szComputerName);
DWORD CheckSystemType(LPTSTR szServer);
DWORD CheckSystemType64(LPTSTR szServer);
BOOL ProcessQuery(DWORD argc,LPCTSTR argv[],LONG lMemorySize);

BOOL ProcessDisconnect(DWORD argc,LPCTSTR argv[],LONG lMemorySize);

BOOL ProcessLocal(DWORD argc,LPCTSTR  argv[]);

BOOL ProcessOptions( DWORD argc,LPCTSTR argv[],PBOOL pbDisconnect, 
                     PBOOL pbQuery,PBOOL pbUsage, 
					 PBOOL pbResetFlag,
                     LONG  lMemorySize);

BOOL ProcessOptions( DWORD argc, LPCTSTR argv[],PBOOL pbQuery,LPTSTR pszServer, 
                     LPTSTR pszUserName,LPTSTR pszPassword,LPTSTR pszFormat,
                     PBOOL pbShowNoHeader,PBOOL   pbVerbose,PBOOL pbNeedPassword);

BOOL ProcessOptions( DWORD argc, LPCTSTR argv[], PBOOL pbDisconnect,
                     LPTSTR pszServer,LPTSTR pszUserName,LPTSTR pszPassword,
                     LPTSTR pszID,LPTSTR pszAccessedby,LPTSTR pszOpenmode,
                     LPTSTR pszOpenFile,PBOOL pbNeedPassword);
BOOL
ProcessOptions( DWORD argc,
                LPCTSTR argv[],
                LPTSTR  pszLocalvalue);
                     
VOID Usage();

VOID DisconnectUsage();

VOID QueryUsage();
VOID LocalUsage();
/*-----------------------------------------------------------------------------

Routine Description:

Main routine that calls the disconnect and query options

Arguments:

    [in]    argc  - Number of command line arguments
    [in]    argv  - Array containing command line arguments

Returned Value:

DWORD       - 0 for success exit
            - 1 for failure exit
-----------------------------------------------------------------------------*/
DWORD _cdecl
_tmain( DWORD argc, LPCTSTR argv[] )
{
  BOOL bCleanExit = FALSE;
  try{
   // local variables to this function
    BOOL bResult = TRUE;
    BOOL bNeedPassword = FALSE;
    // variables to hold the values specified at the command prompt
    BOOL bUsage = FALSE;// -? ( help )
    BOOL bDisconnect = FALSE;// -disconnect
    //query command line options
    BOOL bQuery = FALSE;// -query
	BOOL bRestFlag = FALSE;
    LONG lMemorySize =0; // Memory needed for allocation.
	DWORD dwRetVal = 0;
   
#ifndef _WIN64
		dwRetVal = CheckSystemType( NULL_STRING);
		if(dwRetVal!=EXIT_SUCCESS )	
		{
			return EXIT_FAILURE;
		}
#endif
   
    // Followin is a guess to allocate the memory for variables used 
    // in many function. Guess is to allocate memory equals to Lenghth of 
    // maximum command line argumant. 
	for(UINT i = 1;i<argc;i++)
	{
        if(lMemorySize < lstrlen(argv[i]))
             lMemorySize = lstrlen(argv[i]);
	}
    
	// Check for minimum memory required. If above logic gets memory size 
	// less than MIN_MEMORY_REQUIRED, then make this to MIN_MEMORY_REQUIRED.
	
	lMemorySize = ((lMemorySize<MIN_MEMORY_REQUIRED)?
                    MIN_MEMORY_REQUIRED:
                    lMemorySize);
    
    // if no command line argument is given than -query option
    // is takan by default.
    if(argc == 1)
    {
        if(IsWin2KOrLater()==FALSE)
		{
			ShowMessage(stderr,GetResString(IDS_INVALID_OS));
			bCleanExit = FALSE;
		}
		else
		{
			bCleanExit =  DoQuery(NULL_STRING,FALSE,NULL_STRING,FALSE);
		}
    }
    else
    {

       // process and validate the command line options
        bResult = ProcessOptions( argc, 
                                  argv, 
                                  &bDisconnect, 
                                  &bQuery, 
                                  &bUsage,
                                  &bRestFlag,
                                  lMemorySize);
        if(bResult == TRUE)
        {
            if(bUsage == TRUE)// check if -? is given as parameter
            {
                if(bQuery == TRUE)//check if -create is also given
               {
                    QueryUsage();// show usage for -create option
                    bCleanExit = TRUE;
               }
               else if (bDisconnect==TRUE)//check if -disconnect is also given
               {
                    DisconnectUsage();//Show usage for -disconnect option
                    bCleanExit = TRUE;
               }
               else if (bRestFlag==TRUE)//check if -disconnect is also given
               {
                    LocalUsage();//Show usage for -local option
                    bCleanExit = TRUE;
               }
               else
               {
                    Usage();//as no -create Or -disconnect given, show main
                            // usage.
                    bCleanExit = TRUE;
               }
            }
            else
            {
                if(bRestFlag == TRUE)
				{

                    bCleanExit = ProcessLocal(argc,argv);
					
                    bCleanExit = TRUE;
				}
				else if(bQuery == TRUE)
                {
                   // Process command line parameter specific to -query and 
                    bCleanExit = ProcessQuery(argc,
                                              argv,
                                              lMemorySize);
                }
                else if(bDisconnect==TRUE)
                {
                   // Process command line parameter specific to -disconnect
                    bCleanExit = ProcessDisconnect(argc,
                                                   argv,
                                                   lMemorySize);
                }
                else
                {
		            CHString szTemp;
                    ShowMessage( stderr, GetResString(IDS_ID_SHOW_ERROR) );
                    szTemp =   argv[0];
                    szTemp.MakeUpper();
                    szTemp.Format(GetResString(IDS_INVALID_SYNTAX),szTemp);
                    
                    ShowMessage( stderr,(LPCWSTR)szTemp);
                    bCleanExit = FALSE;
                }
            }
        }
        else
        {
			if(g_bIs32BitEnv == TRUE)
			{
            // invalid syntax
            ShowMessage( stderr,GetReason());
			}
            // return from the function
            bCleanExit =  FALSE;
        }

    }
  }
  catch(CHeap_Exception cheapException)
    {
       // catching the CHStrig related memory exceptions...
       SetLastError(ERROR_NOT_ENOUGH_MEMORY);
       DISPLAY_MESSAGE(stderr,GetResString(IDS_ID_SHOW_ERROR));
       DISPLAY_MESSAGE(stderr,GetReason());
       bCleanExit =  FALSE;
    }

   // Release global memory if any allocated through common functionality
	ReleaseGlobals();
   return bCleanExit?EXIT_SUCCESS:EXIT_FAILURE;
}//_tmain
/*-----------------------------------------------------------------------------

Routine Description:
 This function will perform Local related tasks.

Arguments:

    [in]    argc            - Number of command line arguments
    [in]    argv            - Array containing command line arguments
Returned Value:

BOOL        --True if it succeeds
            --False if it fails.
-----------------------------------------------------------------------------*/

BOOL 
ProcessLocal( DWORD argc,LPCTSTR argv[])
{
    BOOL bResult = FALSE; // Variable to store function return value
    LPTSTR pszLocalValue      = new TCHAR[MAX_USERNAME_LENGTH];// MAX_USERNAME_LENGTH
                                                            // just taken for its length 
    if(pszLocalValue == NULL)
    {
        // Some variable not having enough memory
        // Show Error----
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        DISPLAY_MESSAGE(stderr,GetResString(IDS_ID_SHOW_ERROR));
        //Release allocated memory safely
        ShowLastError(stderr);
        return FALSE;
    }
    // Initialize currently allocated arrays.
    memset(pszLocalValue,0,(MAX_USERNAME_LENGTH)*sizeof(TCHAR));

    bResult = ProcessOptions( argc,argv,pszLocalValue);
    if(bResult == FALSE)
    {
        // invalid syntax
	    ShowMessage( stderr,GetReason() );
        //Release allocated memory safely
        SAFEDELETE(pszLocalValue);
        // return from the function
        return FALSE;
    }
    bResult = DoLocalOpenFiles(0,FALSE,FALSE,pszLocalValue); // Only last argument is of interst
    SAFEDELETE(pszLocalValue);
    return bResult;
}
/*-----------------------------------------------------------------------------

Routine Description:
 This function will perform query related tasks.

Arguments:

    [in]    argc            - Number of command line arguments
    [in]    argv            - Array containing command line arguments
    [in]    lMemorySize     - Maximum amount of memory to be allocated.
Returned Value:

BOOL        --True if it succeeds
            --False if it fails.
-----------------------------------------------------------------------------*/

BOOL 
ProcessQuery( DWORD argc, 
              LPCTSTR argv[],
              LONG lMemorySize
              )
{
    BOOL bResult = FALSE; // Variable to store function return value
    BOOL bCloseConnection = FALSE; //Check whether connection to be
                                   // closed or not
    CHString szChString;          // Temp. variable
	DWORD dwRetVal = 0;
    // options.
    BOOL   bQuery         = FALSE; // -query query
    BOOL   bShowNoHeader  = FALSE;// -nh (noheader)
	BOOL   bVerbose       = FALSE;// -v (verbose)  
    BOOL   bNeedPassword  = FALSE;// need password or not 
    LPTSTR pszServer      = new TCHAR[lMemorySize+1];// -s ( server name)
    LPTSTR pszUserName    = new TCHAR[lMemorySize+1];// -u ( user name)
    LPTSTR pszPassword    = new TCHAR[lMemorySize+1];// -p ( password)
    LPTSTR pszFormat      = new TCHAR[lMemorySize+1];// -format
    LPTSTR pszServerName  = new TCHAR[lMemorySize+1];// server name used for 
                                                   // EstablishConnection 
                                                   // Function. 
    LPTSTR pszServerNameHeadPosition = NULL;
    LPTSTR pszServerHeadPosition     = NULL;
    // Check if memory allocated to all variables properly
    if((pszServer     == NULL)||
       (pszUserName   == NULL)||
       (pszPassword   == NULL)||
       (pszFormat     == NULL)||
       (pszServerName == NULL)
       )  
    {
        // Some variable not having enough memory
        // Show Error----
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        DISPLAY_MESSAGE(stderr,GetResString(IDS_ID_SHOW_ERROR));
        //Release allocated memory safely
        ShowLastError(stderr);
        SAFEDELETE(pszServer);
        SAFEDELETE(pszUserName);
        SAFEDELETE(pszPassword);
        SAFEDELETE(pszFormat);
        SAFEDELETE(pszServerName);
        return FALSE;
    }
    pszServerNameHeadPosition = pszServerName;//store Head position Address
                                              // to successfully delete 
                                              // allocated memory block
    pszServerHeadPosition = pszServer;
    // Initialize currently allocated arrays.
    memset(pszServer,0,(lMemorySize+1)*sizeof(TCHAR));
    memset(pszUserName,0,(lMemorySize+1)*sizeof(TCHAR));
    memset(pszPassword,0,(lMemorySize+1)*sizeof(TCHAR));
    memset(pszFormat,0,(lMemorySize+1)*sizeof(TCHAR));
    memset(pszServerName,0,(lMemorySize+1)*sizeof(TCHAR));

    bResult = ProcessOptions(  argc, 
                               argv, 
                               &bQuery, 
                               pszServer, 
                               pszUserName,
                               pszPassword,
                               pszFormat,
                               &bShowNoHeader,
							   &bVerbose,
                               &bNeedPassword);
    if ( bResult == FALSE )
    {
        // invalid syntax
		ShowMessage( stderr,GetReason() );
        //Release allocated memory safely
        SAFEDELETE(pszServerHeadPosition);
        SAFEDELETE(pszUserName);
        SAFEDELETE(pszPassword);
        SAFEDELETE(pszFormat);
        SAFEDELETE(pszServerNameHeadPosition);
        // return from the function
        return FALSE;
    }
    szChString = pszServer;
    if((lstrcmpi(szChString.Left(2),DOUBLE_SLASH)==0)&&(szChString.GetLength()>2))
    {
    	szChString = szChString.Mid( 2,szChString.GetLength()) ;
    }
	if(lstrcmpi(szChString.Left(1),SINGLE_SLASH)!=0)
	{
		lstrcpy(pszServer,(LPCWSTR)szChString);
	}
    lstrcpy(pszServerName,pszServer);

    // Try to connect to remote server. Function checks for local machine
    // so here no checking is done.
	if(IsLocalSystem(pszServerName)==TRUE)
	{
	   if(lstrlen(pszUserName)>0)
	   {
			DISPLAY_MESSAGE(stdout,GetResString(IDS_LOCAL_SYSTEM));
	   }

	}
    else
    {
		if(EstablishConnection( pszServerName, 
                                pszUserName, 
                                lMemorySize,
                                pszPassword, 
                                lMemorySize,
                                bNeedPassword )==FALSE)
        {
			// Connection to remote system failed , Show corresponding error
            // and exit from function.
            ShowMessage( stderr,GetResString(IDS_ID_SHOW_ERROR) );
            if(lstrlen(GetReason())==0)
            {
                DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_CREDENTIALS));
            }
            else
            {
                DISPLAY_MESSAGE( stderr,GetReason() );
            }
            //Release allocated memory safely
            SAFEDELETE(pszServerHeadPosition);
            SAFEDELETE(pszUserName);
            SAFEDELETE(pszPassword);
            SAFEDELETE(pszFormat);
            SAFEDELETE(pszServerNameHeadPosition);
            return FALSE;
        }
		// determine whether this connection needs to disconnected later or not
		// though the connection is successfull, some conflict might have occured
		switch( GetLastError() )
		{
		case I_NO_CLOSE_CONNECTION:
			bCloseConnection = FALSE;
			break;
		case E_LOCAL_CREDENTIALS:
		case ERROR_SESSION_CREDENTIAL_CONFLICT:
			{
				//
				// some error occured ... but can be ignored
				// connection need not be disconnected
				bCloseConnection= FALSE;
				// show the warning message
				DISPLAY_MESSAGE(stdout,GetResString(IDS_ID_SHOW_WARNING));
				DISPLAY_MESSAGE(stdout,GetReason());
				break;
			}
		default:
			bCloseConnection = TRUE;
		}
    }
    bResult = DoQuery(pszServer, 
					  bShowNoHeader,
					  pszFormat,
					  bVerbose);
    // Close the network connection which is previously opened by
    // EstablishConnection
    if(bCloseConnection==TRUE)
    {
        CloseConnection(pszServerName);
    }
    SAFEDELETE(pszServerHeadPosition);
    SAFEDELETE(pszUserName);
    SAFEDELETE(pszPassword);
    SAFEDELETE(pszFormat);
    SAFEDELETE(pszServerNameHeadPosition);
    return bResult;
}
/*-----------------------------------------------------------------------------
Routine Description:
 This function will perform Disconnect related tasks.

Arguments:

    [in]    argc            - Number of command line arguments
    [in]    argv            - Array containing command line arguments
    [in]    lMemorySize     - Maximum amount of memory to be allocated.
    [in]    pbNeedPassword  - To check whether the password is required
                              or not.
Returned Value:

BOOL        --True if it succeeds
            --False if it fails.
-----------------------------------------------------------------------------*/
BOOL
ProcessDisconnect(DWORD argc,LPCTSTR argv[],LONG lMemorySize)
{
    BOOL bResult = FALSE; // Variable to store function return value
	DWORD dwRetVal = 0;
    BOOL bCloseConnection = FALSE; //Check whether connection to be
                                   // closed or not
    BOOL bNeedPassword    = FALSE; // Ask for password or not.                                   
    CHString szChString;          // Temp. variable

    // options.
    BOOL   bQuery         = FALSE; // -query query
    BOOL   bShowNoHeader  = FALSE;// -nh (noheader)
    LPTSTR pszServer      = new TCHAR[lMemorySize+1];// -s ( server name)
    LPTSTR pszUserName    = new TCHAR[lMemorySize+1];// -u ( user name)
    LPTSTR pszPassword    = new TCHAR[lMemorySize+1];// -p ( password)
    LPTSTR pszServerName  = new TCHAR[lMemorySize+1];// server name used for 
                                                   // EstablishConnection 
                                                   // Function. 
    LPTSTR pszServerNameHeadPosition = NULL;
    LPTSTR pszServerHeadPosition = NULL;

    LPTSTR pszID          = new TCHAR[lMemorySize+1];// -I ( id )
    LPTSTR pszAccessedby  = new TCHAR[lMemorySize+1];//-a(accessedby)
    LPTSTR pszOpenmode    = new TCHAR[lMemorySize+1];// -o ( openmode)
    LPTSTR pszOpenFile    = new TCHAR[lMemorySize+1];// -op( openfile)

    // Check if memory allocated to all variables properly
    if((pszServer      == NULL)||
       (pszUserName    == NULL)||
       (pszPassword    == NULL)||
       (pszServerName  == NULL)|| 
       (pszID          == NULL)|| 
       (pszAccessedby  == NULL)|| 
       (pszOpenmode    == NULL)|| 
       (pszOpenFile    == NULL)
       )  
    {
        // Some variable not having enough memory
        // Show Error----
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        DISPLAY_MESSAGE(stderr,GetResString(IDS_ID_SHOW_ERROR));
        //Release allocated memory safely
        ShowLastError(stderr);
        SAFEDELETE(pszServer);
        SAFEDELETE(pszUserName);
        SAFEDELETE(pszPassword);
        SAFEDELETE(pszServerName);
        SAFEDELETE(pszID);
        SAFEDELETE(pszAccessedby);
        SAFEDELETE(pszOpenmode);
        SAFEDELETE(pszOpenFile);
        return FALSE;
    }
    pszServerNameHeadPosition = pszServerName;//store Head position Address
                                              // to successfully delete 
                                              // allocated memory block
    pszServerHeadPosition = pszServer;
    // Initialize currently allocated arrays.
    memset(pszServer,0,(lMemorySize+1)*sizeof(TCHAR));
    memset(pszUserName,0,(lMemorySize+1)*sizeof(TCHAR));
    memset(pszPassword,0,(lMemorySize+1)*sizeof(TCHAR));
    memset(pszServerName,0,(lMemorySize+1)*sizeof(TCHAR));
    memset(pszID,0,(lMemorySize)*sizeof(TCHAR));
    memset(pszAccessedby,0,(lMemorySize+1)*sizeof(TCHAR));
    memset(pszOpenmode,0,(lMemorySize+1)*sizeof(TCHAR));
    memset(pszOpenFile,0,(lMemorySize+1)*sizeof(TCHAR));


    bResult = ProcessOptions(  argc, 
                               argv, 
                               &bQuery, 
                               pszServer, 
                               pszUserName,
                               pszPassword,
                               pszID,
                               pszAccessedby,
                               pszOpenmode,
                               pszOpenFile,
                               &bNeedPassword);
    if ( bResult == FALSE )
    {
        // invalid syntax
        ShowMessage( stderr,GetReason() );
        //Release allocated memory safely
        SAFEDELETE(pszServerHeadPosition);
        SAFEDELETE(pszUserName);
        SAFEDELETE(pszPassword);
        SAFEDELETE(pszServerNameHeadPosition);
        SAFEDELETE(pszID);
        SAFEDELETE(pszAccessedby);
        SAFEDELETE(pszOpenmode);
        SAFEDELETE(pszOpenFile);
        // return from the function
        return FALSE;
    }
    
    szChString = pszServer;
    if((lstrcmpi(szChString.Left(2),DOUBLE_SLASH)==0)&&(szChString.GetLength()>2))
    {
        szChString = szChString.Mid( 2,szChString.GetLength()) ;
    }
	if(lstrcmpi(szChString.Left(2),SINGLE_SLASH)!=0)
	{
		lstrcpy(pszServer,(LPCWSTR)szChString);
	}
    lstrcpy(pszServerName,pszServer);

	if(IsLocalSystem(pszServerName)==TRUE)
	{
#ifndef _WIN64
		dwRetVal = CheckSystemType( NULL_STRING);
		if(dwRetVal!=EXIT_SUCCESS )	
		{
			return EXIT_FAILURE;
		}
#else
		dwRetVal = CheckSystemType64( NULL_STRING);
		if(dwRetVal!=EXIT_SUCCESS )	
		{
			return EXIT_FAILURE;
		}

#endif //Comment 2

	   if(lstrlen(pszUserName)>0)
	   {
			DISPLAY_MESSAGE(stdout,GetResString(IDS_LOCAL_SYSTEM));
	   }

	}
    else
    {
        if(EstablishConnection( pszServerName, 
                                pszUserName, 
                                lMemorySize,
                                pszPassword, 
                                lMemorySize, 
                                bNeedPassword )==FALSE)
        {
            // Connection to remote system failed , Show corresponding error
            // and exit from function.
            ShowMessage( stderr, 
                         GetResString(IDS_ID_SHOW_ERROR) );
            if(lstrlen(GetReason())==0)
            {
                DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_CREDENTIALS));
            }
            else
            {
                DISPLAY_MESSAGE( stderr,GetReason() );
            }
            //Release allocated memory safely
            SAFEDELETE(pszServerHeadPosition);
            SAFEDELETE(pszUserName);
            SAFEDELETE(pszPassword);
            SAFEDELETE(pszServerNameHeadPosition);
            SAFEDELETE(pszID);
            SAFEDELETE(pszAccessedby);
            SAFEDELETE(pszOpenmode);
            SAFEDELETE(pszOpenFile);
            return FALSE;
        }
   		// determine whether this connection needs to disconnected later or not
		// though the connection is successfull, some conflict might have occured
		switch( GetLastError() )
		{
		case I_NO_CLOSE_CONNECTION:
			bCloseConnection = FALSE;
			break;

		case E_LOCAL_CREDENTIALS:
		case ERROR_SESSION_CREDENTIAL_CONFLICT:
			{
				//
				// some error occured ... but can be ignored

				// connection need not be disconnected
				bCloseConnection= FALSE;

				// show the warning message
				DISPLAY_MESSAGE(stdout,GetResString(IDS_ID_SHOW_WARNING));
				DISPLAY_MESSAGE(stdout,GetReason());
				break;
			}
		default:
			bCloseConnection = TRUE;

		}

    }
   // Do Disconnect open files.....
    bResult = DisconnectOpenFile(pszServer, 
                       pszID, 
                       pszAccessedby, 
                       pszOpenmode, 
                       pszOpenFile );
    // Close the network connection which is previously opened by
    // EstablishConnection
    if(bCloseConnection==TRUE)
    {
		CloseConnection(pszServerName);
    }
    // Free memory which is previously allocated.
    SAFEDELETE(pszServerHeadPosition);
    SAFEDELETE(pszUserName);
    SAFEDELETE(pszPassword);
    SAFEDELETE(pszServerNameHeadPosition);
    SAFEDELETE(pszID);
    SAFEDELETE(pszAccessedby);
    SAFEDELETE(pszOpenmode);
    SAFEDELETE(pszOpenFile);
    return bResult;
}
/*-----------------------------------------------------------------------------

Routine Description:

  This function takes command line argument and checks for correct syntax and 
  if the syntax is ok, it returns the values in different variables. variables
  [out] will contain respective values.
  

Arguments:

    [in]    argc            - Number of command line arguments
    [in]    argv            - Array containing command line arguments
    [out]   pszLocalValue     - contains the values for -local option

Returned Value:

BOOL        --True if it succeeds
            --False if it fails.
-----------------------------------------------------------------------------*/
BOOL
ProcessOptions( DWORD argc,
                LPCTSTR argv[],
                LPTSTR pszLocalValue)
{
    TCMDPARSER cmdOptions[ MAX_LOCAL_OPTIONS ];//Variable to store command line
	CHString szTempString;
    TCHAR szTemp[MAX_RES_STRING*2]; 
    szTempString = GetResString(IDS_UTILITY_NAME);
    wsprintf(szTemp,GetResString(IDS_INVALID_SYNTAX),(LPCWSTR)szTempString);


    // -local
    cmdOptions[ OI_O_LOCAL ].dwCount = 1;
    cmdOptions[ OI_O_LOCAL ].dwActuals = 0;
    cmdOptions[ OI_O_LOCAL ].dwFlags = CP_MAIN_OPTION|CP_VALUE_OPTIONAL|CP_MODE_VALUES| CP_TYPE_TEXT;
    cmdOptions[ OI_O_LOCAL ].pValue = pszLocalValue;
    cmdOptions[ OI_O_LOCAL ].pFunction = NULL;
    cmdOptions[ OI_O_LOCAL ].pFunctionData = NULL;
    lstrcpy( cmdOptions[ OI_O_LOCAL ].szValues, GetResString(IDS_LOCAL_OPTION) );
    lstrcpy( cmdOptions[ OI_O_LOCAL ].szOption, OPTION_LOCAL );

    //
    // do the command line parsing
    if ( DoParseParam( argc,argv,MAX_LOCAL_OPTIONS,cmdOptions ) == FALSE )
    {
        ShowMessage(stderr,GetResString(IDS_ID_SHOW_ERROR));
        return FALSE;       // invalid syntax
    }
    if(lstrlen(pszLocalValue) == 0)
    {
        lstrcpy(pszLocalValue,L"SHOW_STATUS"); // this string does not require localization
                            // as it is storing value other than ON/OFF
    }
    return TRUE;
}


/*-----------------------------------------------------------------------------

Routine Description:

  This function takes command line argument and checks for correct syntax and 
  if the syntax is ok, it returns the values in different variables. variables
  [out] will contain respective values.
  

Arguments:

    [in]    argc            - Number of command line arguments
    [in]    argv            - Array containing command line arguments
    [out]   pbDisconnect    - Discoonect option string
    [out]   pbQuery         - Query option string
    [out]   pbUsage         - The usage option
    [out]   pbNeedPassword  - To check whether the password is required
                              or not.
    [in]    lMemorySize     - Maximum amount of memory to be allocated.

Returned Value:

BOOL        --True if it succeeds
            --False if it fails.
-----------------------------------------------------------------------------*/
BOOL
ProcessOptions( DWORD argc,
                LPCTSTR argv[],
                PBOOL pbDisconnect, 
                PBOOL pbQuery,
                PBOOL pbUsage,
				PBOOL pbResetFlag,
                LONG  lMemorySize)
{

	DWORD dwRetVal = 0;
    // local variables
    TCMDPARSER cmdOptions[ MAX_OPTIONS ];//Variable to store command line
                                        // options.
	LPTSTR pszTempServer   = new TCHAR[lMemorySize+1];
	LPTSTR pszTempUser     = new TCHAR[lMemorySize+1];
	LPTSTR pszTempPassword = new TCHAR[lMemorySize+1];
    TARRAY arrTemp         = NULL;
    


	CHString szTempString;
    TCHAR szTemp[MAX_RES_STRING*2]; 
    szTempString = GetResString(IDS_UTILITY_NAME);
    wsprintf(szTemp,GetResString(IDS_INVALID_SYNTAX),(LPCWSTR)szTempString);



    // Allocates memory
    arrTemp = CreateDynamicArray();
    BOOL   bTemp  = FALSE;          // Temp. Variable
    //
    if((pszTempUser    == NULL)||
	   (pszTempPassword== NULL)||
	   (pszTempServer  == NULL)||
       (arrTemp      == NULL))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        DISPLAY_MESSAGE(stderr,GetResString(IDS_ID_SHOW_ERROR));
        ShowLastError(stderr);
		SAFEDELETE(pszTempUser);
		SAFEDELETE(pszTempPassword);
		SAFEDELETE(pszTempServer);
        DestroyDynamicArray(&arrTemp);
        return FALSE;
    }
    // prepare the command options
    // -disconnect option for help
    cmdOptions[ OI_DISCONNECT ].dwCount = 1;
    cmdOptions[ OI_DISCONNECT ].dwActuals = 0;
    cmdOptions[ OI_DISCONNECT ].dwFlags = 0;
    cmdOptions[ OI_DISCONNECT ].pValue = pbDisconnect;
    cmdOptions[ OI_DISCONNECT ].pFunction = NULL;
    cmdOptions[ OI_DISCONNECT ].pFunctionData = NULL;
    lstrcpy( cmdOptions[ OI_DISCONNECT ].szValues, NULL_STRING );
    lstrcpy( cmdOptions[ OI_DISCONNECT ].szOption, OPTION_DISCONNECT );

    // -query option for help
    cmdOptions[ OI_QUERY ].dwCount = 1;
    cmdOptions[ OI_QUERY ].dwActuals = 0;
    cmdOptions[ OI_QUERY ].dwFlags = 0;
    cmdOptions[ OI_QUERY ].pValue = pbQuery;
    cmdOptions[ OI_QUERY ].pFunction = NULL;
    cmdOptions[ OI_QUERY ].pFunctionData = NULL;
    lstrcpy( cmdOptions[ OI_QUERY ].szValues, NULL_STRING );
    lstrcpy( cmdOptions[ OI_QUERY ].szOption, OPTION_QUERY );

    // -? option for help
    cmdOptions[ OI_USAGE ].dwCount = 1;
    cmdOptions[ OI_USAGE ].dwActuals = 0;
    cmdOptions[ OI_USAGE ].dwFlags = CP_USAGE;
    cmdOptions[ OI_USAGE ].pValue = pbUsage;
    cmdOptions[ OI_USAGE ].pFunction = NULL;
    cmdOptions[ OI_USAGE ].pFunctionData = NULL;
    lstrcpy( cmdOptions[ OI_USAGE ].szValues, NULL_STRING );
    lstrcpy( cmdOptions[ OI_USAGE ].szOption, OPTION_USAGE );
    
    // -local 
    cmdOptions[ OI_LOCAL ].dwCount = 1;
    cmdOptions[ OI_LOCAL ].dwActuals = 0;
    cmdOptions[ OI_LOCAL ].dwFlags = 0;
    cmdOptions[ OI_LOCAL ].pValue = pbResetFlag;
    cmdOptions[ OI_LOCAL ].pFunction = NULL;
    cmdOptions[ OI_LOCAL ].pFunctionData = NULL;
    lstrcpy( cmdOptions[ OI_LOCAL ].szValues, NULL_STRING );
    lstrcpy( cmdOptions[ OI_LOCAL ].szOption, OPTION_LOCAL );
    

  //  default ..
  // Although there is no default option for this utility... 
  // At this moment all the switches other than specified above will be 
  // treated as default parameter for Main DoParceParam. 
  // Exact parcing depending on optins (-query or -disconnect) will be done 
  // at that respective places.
    lstrcpy(cmdOptions[ OI_DEFAULT ].szOption,NULL_STRING);
    cmdOptions[ OI_DEFAULT ].dwFlags = CP_TYPE_TEXT | CP_MODE_ARRAY|CP_DEFAULT;
    cmdOptions[ OI_DEFAULT ].dwCount = 0;
    cmdOptions[ OI_DEFAULT ].dwActuals = 0;
    cmdOptions[ OI_DEFAULT ].pValue    = &arrTemp;
    lstrcpy(cmdOptions[ OI_DEFAULT ].szValues,NULL_STRING);
    cmdOptions[ OI_DEFAULT ].pFunction = NULL;
    cmdOptions[ OI_DEFAULT ].pFunctionData = NULL;

    //
    // do the command line parsing
    if ( DoParseParam( argc,argv,MAX_OPTIONS,cmdOptions ) == FALSE )
    {
        ShowMessage(stderr,GetResString(IDS_ID_SHOW_ERROR));
		SAFEDELETE(pszTempUser);
		SAFEDELETE(pszTempPassword);
		SAFEDELETE(pszTempServer);
        DestroyDynamicArray(&arrTemp);
        return FALSE;       // invalid syntax
    }
    DestroyDynamicArray(&arrTemp);//Release memory as variable no longer needed
    arrTemp = NULL;

    // Check if all of following is true is an error
    if((*pbUsage==TRUE)&&argc>3)
    {
         ShowMessage( stderr, GetResString(IDS_ID_SHOW_ERROR) );
         SetReason(szTemp);
         return FALSE;
    }
    // -query ,-disconnect and -local options cannot come together
    if(((*pbQuery)+(*pbDisconnect)+(*pbResetFlag))>1)
    {
        ShowMessage( stderr, GetResString(IDS_ID_SHOW_ERROR) );
        SetReason(szTemp);
        SAFEDELETE(pszTempUser);
        SAFEDELETE(pszTempPassword);
        SAFEDELETE(pszTempServer);
        return FALSE;
    }
    else if((argc == 2)&&(*pbUsage == TRUE))
    {
       // if -? alone given its a valid conmmand line
        SAFEDELETE(pszTempUser);
        SAFEDELETE(pszTempPassword);
        SAFEDELETE(pszTempServer);
        return TRUE;
    }
    if((argc>2)&& (*pbQuery==FALSE)&&(*pbDisconnect==FALSE)&&(*pbResetFlag==FALSE))  
    {
        // If command line argument is equals or greater than 2 atleast one 
        // of -query OR -local OR -disconnect should be present in it.
        // (for "-?" previous condition already takes care)
        // This to prevent from following type of command line argument:
        // OpnFiles.exe -nh ... Which is a invalid syntax.
        ShowMessage( stderr, GetResString(IDS_ID_SHOW_ERROR) );
        SetReason(szTemp);
        SAFEDELETE(pszTempUser);
        SAFEDELETE(pszTempPassword);
        SAFEDELETE(pszTempServer);
        return FALSE;
    }
	SAFEDELETE(pszTempUser);
	SAFEDELETE(pszTempPassword);
	SAFEDELETE(pszTempServer);
    return TRUE;
}//ProcesOptions
/*-----------------------------------------------------------------------------

Routine Description:

  This function takes command line argument and checks for correct syntax and 
  if the syntax is ok, it returns the values in different variables. variables
  [out] will contain respective values. This Functin specifically checks 
  command line parameters requered for QUERY option.
  

Arguments:

    [in]    argc            - Number of command line arguments
    [in]    argv            - Array containing command line arguments
    [out]   pbQuery         - query option string
    [out]   pszServer       - remote server name
    [out]   pszUserName     - username for the remote system
    [out]   pszPassword     - password for the remote system for the 
                              username
    [out]   pszFormat       - format checking
    [out]   pbShowNoHeader  - show header
	[out]   pbVerbose       - show verbose 

Returned Value:

BOOL        --True if it succeeds
            --False if it fails.
-----------------------------------------------------------------------------*/

BOOL 
ProcessOptions( DWORD argc,
                LPCTSTR argv[],
                PBOOL pbQuery,
                LPTSTR pszServer, 
                LPTSTR pszUserName,
                LPTSTR pszPassword,
                LPTSTR pszFormat,
                PBOOL  pbShowNoHeader,
                PBOOL  pbVerbose,
                PBOOL  pbNeedPassword)
{
   // Check in/out parameters...
   if((pszServer == NULL)||(pszUserName==NULL)||(pszPassword==NULL)||
      (pszFormat == NULL))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        DISPLAY_MESSAGE(stderr,GetResString(IDS_ID_SHOW_ERROR));
        return FALSE;       // Memory ERROR
    }
    
    
    
    TCMDPARSER cmdOptions[ MAX_QUERY_OPTIONS ];//Variable to store command line
    CHString szTempString;
    TCHAR szTemp[MAX_RES_STRING*2]; 
    TCHAR szTypeHelpMsg[MAX_RES_STRING]; 

	DWORD dwRetVal = 0;

    szTempString = GetResString(IDS_UTILITY_NAME);
    wsprintf(szTemp,GetResString(IDS_INVALID_SYNTAX),(LPCWSTR)szTempString);
    wsprintf(szTypeHelpMsg,GetResString(IDS_TYPE_Q_HELP),(LPCWSTR)szTempString);
 

    //
    // prepare the command options

    // -query option for help
    cmdOptions[ OI_Q_QUERY ].dwCount = 1;
    cmdOptions[ OI_Q_QUERY ].dwActuals = 0;
    cmdOptions[ OI_Q_QUERY ].dwFlags = CP_MAIN_OPTION ;
    cmdOptions[ OI_Q_QUERY ].pValue = pbQuery;
    cmdOptions[ OI_Q_QUERY ].pFunction = NULL;
    cmdOptions[ OI_Q_QUERY ].pFunctionData = NULL;
    lstrcpy( cmdOptions[ OI_Q_QUERY ].szValues, NULL_STRING );
    lstrcpy( cmdOptions[ OI_Q_QUERY ].szOption, OPTION_QUERY );

    // -s  option remote system name
    cmdOptions[ OI_Q_SERVER_NAME ].dwCount = 1;
    cmdOptions[ OI_Q_SERVER_NAME ].dwActuals = 0;
    cmdOptions[ OI_Q_SERVER_NAME ].dwFlags = CP_TYPE_TEXT | CP_VALUE_MANDATORY;
    cmdOptions[ OI_Q_SERVER_NAME ].pValue = pszServer;
    cmdOptions[ OI_Q_SERVER_NAME ].pFunction = NULL;
    cmdOptions[ OI_Q_SERVER_NAME ].pFunctionData = NULL;
    lstrcpy( cmdOptions[ OI_Q_SERVER_NAME ].szValues, NULL_STRING );
    lstrcpy( cmdOptions[ OI_Q_SERVER_NAME ].szOption, OPTION_SERVER );

    // -u  option user name for the specified system
    cmdOptions[ OI_Q_USER_NAME ].dwCount = 1;
    cmdOptions[ OI_Q_USER_NAME ].dwActuals = 0;
    cmdOptions[ OI_Q_USER_NAME ].dwFlags = CP_TYPE_TEXT | CP_VALUE_MANDATORY;
    cmdOptions[ OI_Q_USER_NAME ].pValue = pszUserName;
    cmdOptions[ OI_Q_USER_NAME ].pFunction = NULL;
    cmdOptions[ OI_Q_USER_NAME ].pFunctionData = NULL;
    lstrcpy( cmdOptions[ OI_Q_USER_NAME ].szValues, NULL_STRING );
    lstrcpy( cmdOptions[ OI_Q_USER_NAME ].szOption, OPTION_USERNAME );

    // -p option password for the given username
    cmdOptions[ OI_Q_PASSWORD ].dwCount = 1;
    cmdOptions[ OI_Q_PASSWORD ].dwActuals = 0;
    cmdOptions[ OI_Q_PASSWORD ].dwFlags = CP_TYPE_TEXT | CP_VALUE_OPTIONAL;
    cmdOptions[ OI_Q_PASSWORD ].pValue = pszPassword;
    cmdOptions[ OI_Q_PASSWORD ].pFunction = NULL;
    cmdOptions[ 3 ].pFunctionData = NULL;
    lstrcpy( cmdOptions[ OI_Q_PASSWORD ].szValues, NULL_STRING );
    lstrcpy( cmdOptions[ OI_Q_PASSWORD ].szOption, OPTION_PASSWORD );


	// -fo  (format)
    lstrcpy(cmdOptions[ OI_Q_FORMAT ].szOption,OPTION_FORMAT);
    cmdOptions[ OI_Q_FORMAT ].dwFlags = CP_TYPE_TEXT|CP_VALUE_MANDATORY
                                     |CP_MODE_VALUES;
    cmdOptions[ OI_Q_FORMAT ].dwCount = 1;
    cmdOptions[ OI_Q_FORMAT ].dwActuals = 0;
    cmdOptions[ OI_Q_FORMAT ].pValue    = pszFormat;
    lstrcpy(cmdOptions[ OI_Q_FORMAT ].szValues,FORMAT_OPTIONS);
    cmdOptions[ OI_Q_FORMAT ].pFunction = NULL;
    cmdOptions[ OI_Q_FORMAT ].pFunctionData = NULL;

    //-nh  (noheader)
    lstrcpy(cmdOptions[ OI_Q_NO_HEADER ].szOption,OPTION_NOHEADER);
    cmdOptions[ OI_Q_NO_HEADER ].dwFlags = 0;
    cmdOptions[ OI_Q_NO_HEADER ].dwCount = 1;
    cmdOptions[ OI_Q_NO_HEADER ].dwActuals = 0;
    cmdOptions[ OI_Q_NO_HEADER ].pValue    = pbShowNoHeader;
    lstrcpy(cmdOptions[ OI_Q_NO_HEADER ].szValues,NULL_STRING);
    cmdOptions[ OI_Q_NO_HEADER ].pFunction = NULL;
    cmdOptions[ OI_Q_NO_HEADER ].pFunctionData = NULL;

    //-v verbose
    lstrcpy(cmdOptions[ OI_Q_VERBOSE ].szOption,OPTION_VERBOSE);
    cmdOptions[ OI_Q_VERBOSE ].dwFlags = 0;
    cmdOptions[ OI_Q_VERBOSE ].dwCount = 1;
    cmdOptions[ OI_Q_VERBOSE ].dwActuals = 0;
    cmdOptions[ OI_Q_VERBOSE ].pValue    = pbVerbose;
    lstrcpy(cmdOptions[ OI_Q_VERBOSE].szValues,NULL_STRING);
    cmdOptions[ OI_Q_VERBOSE ].pFunction = NULL;
    cmdOptions[ OI_Q_VERBOSE ].pFunctionData = NULL;

	// init the password with '*'
	if ( pszPassword != NULL )
		lstrcpy( pszPassword, _T( "*" ) );

    //
    // do the command line parsing
    if ( DoParseParam( argc,argv,MAX_QUERY_OPTIONS,cmdOptions ) == FALSE )
    {
        ShowMessage(stderr,GetResString(IDS_ID_SHOW_ERROR));
        return FALSE;       // invalid syntax
    }

     // -n is allowed only with -fo TABLE (which is also default)
     // and CSV
     if((*pbShowNoHeader == TRUE) &&
         ((lstrcmpi(pszFormat,GetResString(IDS_LIST))==0)))
     {
         lstrcpy(szTemp,GetResString(IDS_HEADER_NOT_ALLOWED));
         lstrcat(szTemp,szTypeHelpMsg);
         SetReason(szTemp);
         return FALSE;
     }

	// "-p" should not be specified without "-u"
    if ( cmdOptions[ OI_Q_USER_NAME ].dwActuals == 0 &&
         cmdOptions[ OI_Q_PASSWORD ].dwActuals != 0 )
    {
        // invalid syntax
        lstrcpy(szTemp,ERROR_PASSWORD_BUT_NOUSERNAME );
        lstrcat(szTemp,szTypeHelpMsg);
        SetReason(szTemp);
        return FALSE;           // indicate failure
    }

     if(*pbQuery==FALSE)
	 {
        ShowMessage( stderr, GetResString(IDS_ID_SHOW_ERROR) );
        SetReason(szTemp);
        return FALSE;
	 }
    // "-u" should not be specified without "-s"
    if ( cmdOptions[ OI_Q_SERVER_NAME ].dwActuals == 0 &&
         cmdOptions[ OI_Q_USER_NAME ].dwActuals != 0 )
    {
        // invalid syntax
        lstrcpy(szTemp,ERROR_USERNAME_BUT_NOMACHINE);
        lstrcat(szTemp,szTypeHelpMsg);
        SetReason(szTemp);
        return FALSE;			// indicate failure
    }
    
    
    szTempString = pszServer;
    szTempString.TrimRight();
    lstrcpy(pszServer,(LPCWSTR)szTempString);
    // server name with 0 length is invalid.
    if((cmdOptions[ OI_Q_SERVER_NAME ].dwActuals != 0) &&
        (lstrlen(pszServer)==0))
    {
        lstrcpy(szTemp,GetResString(IDS_SERVER_EMPTY));
        lstrcat(szTemp,szTypeHelpMsg);
        SetReason(szTemp);
        return FALSE;
    }
    // server name with 0 length is invalid.
    szTempString = pszUserName;
    szTempString.TrimRight();
    lstrcpy(pszUserName,(LPCWSTR)szTempString);

    if((cmdOptions[ OI_Q_USER_NAME ].dwActuals != 0) &&
        (lstrlen(pszUserName)==0))
    {
        lstrcpy(szTemp,GetResString(IDS_USERNAME_EMPTY));
        lstrcat(szTemp,szTypeHelpMsg);
        SetReason(szTemp);
        return FALSE;
    }
    // user given -p option and not given password 
    // so it is needed to prompt for password.
	if ( cmdOptions[ OI_Q_PASSWORD ].dwActuals != 0 && 
		 pszPassword != NULL && lstrcmp( pszPassword, _T( "*" ) ) == 0 )
	{
		// user wants the utility to prompt for the password before trying to connect
		*pbNeedPassword = TRUE;
	}
	else if ( cmdOptions[ OI_Q_PASSWORD ].dwActuals == 0 && 
	        ( cmdOptions[ OI_Q_SERVER_NAME ].dwActuals != 0 || cmdOptions[ OI_Q_USER_NAME ].dwActuals != 0 ) )
	{
		// -s, -u is specified without password ...
		// utility needs to try to connect first and if it fails then prompt for the password
		*pbNeedPassword = TRUE;
		if ( pszPassword != NULL )
		{
			lstrcpy( pszPassword, _T( "" ) );
		}
	}

    return TRUE;  
}
/*-----------------------------------------------------------------------------

Routine Description:

  This function takes command line argument and checks for correct syntax and 
  if the syntax is ok, it returns the values in different variables. variables
  [out] will contain respective values. This Functin specifically checks 
  command line parameters requered for DISCONNECT option.
  

Arguments:

    [in]    argc            - Number of command line arguments
    [in]    argv            - Array containing command line arguments
    [out]   pbDisconnect    - discoonect option string
    [out]   pszServer       - remote server name
    [out]   pszUserName     - username for the remote system
    [out]   pszPassword     - password for the remote system for the 
                              username
    [out]   pszID           - Open file ids
    [out]   pszAccessedby   - Name of  user name who access the file
    [out]   pszOpenmode     - accessed mode (read/Write)
    [out]   pszOpenFile     - Open file name

Returned Value:

BOOL        --True if it succeeds
            --False if it fails.
-----------------------------------------------------------------------------*/

BOOL 
ProcessOptions( DWORD argc, 
                LPCTSTR argv[], 
                PBOOL pbDisconnect,
                LPTSTR pszServer, 
                LPTSTR pszUserName,
                LPTSTR pszPassword,
                LPTSTR pszID, 
                LPTSTR pszAccessedby,
                LPTSTR pszOpenmode,
                LPTSTR pszOpenFile,
                PBOOL pbNeedPassword)
                     
{
   // Check in/out parameters...
   if((pszServer == NULL)||(pszUserName==NULL)||(pszPassword==NULL)||
      (pszID == NULL)||(pszAccessedby==NULL)|| (pszAccessedby == NULL)|| 
       (pszOpenmode == NULL)||(pszOpenFile==NULL))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        DISPLAY_MESSAGE(stderr,GetResString(IDS_ID_SHOW_ERROR));
        return FALSE;       // Memory ERROR
    }

    TCMDPARSER cmdOptions[ MAX_DISCONNECT_OPTIONS ];//Variable to store command line
    CHString szTempString;
    TCHAR szTemp[MAX_RES_STRING*2]; 
    TCHAR szTypeHelpMsg[MAX_RES_STRING]; 

    DWORD dwRetVal = 0;

    szTempString = GetResString(IDS_UTILITY_NAME);
    wsprintf(szTemp,GetResString(IDS_INVALID_SYNTAX),(LPCWSTR)szTempString);
    wsprintf(szTypeHelpMsg,GetResString(IDS_TYPE_D_HELP),(LPCWSTR)szTempString);
    //
    // prepare the command options
    // -disconnect option for help
    cmdOptions[ OI_D_DISCONNECT ].dwCount = 1;
    cmdOptions[ OI_D_DISCONNECT ].dwActuals = 0;
    cmdOptions[ OI_D_DISCONNECT ].dwFlags = CP_MAIN_OPTION ;
    cmdOptions[ OI_D_DISCONNECT ].pValue = pbDisconnect;
    cmdOptions[ OI_D_DISCONNECT ].pFunction = NULL;
    cmdOptions[ OI_D_DISCONNECT ].pFunctionData = NULL;
    lstrcpy( cmdOptions[ OI_D_DISCONNECT ].szValues, NULL_STRING );
    lstrcpy( cmdOptions[ OI_D_DISCONNECT ].szOption, OPTION_DISCONNECT );

    // -s  option remote system name
    cmdOptions[ OI_D_SERVER_NAME ].dwCount = 1;
    cmdOptions[ OI_D_SERVER_NAME ].dwActuals = 0;
    cmdOptions[ OI_D_SERVER_NAME ].dwFlags = CP_TYPE_TEXT | CP_VALUE_MANDATORY;
    cmdOptions[ OI_D_SERVER_NAME ].pValue = pszServer;
    cmdOptions[ OI_D_SERVER_NAME ].pFunction = NULL;
    cmdOptions[ OI_D_SERVER_NAME ].pFunctionData = NULL;
    lstrcpy( cmdOptions[ OI_D_SERVER_NAME ].szValues, NULL_STRING );
    lstrcpy( cmdOptions[ OI_D_SERVER_NAME ].szOption, OPTION_SERVER );

    // -u  option user name for the specified system
    cmdOptions[ OI_D_USER_NAME ].dwCount = 1;
    cmdOptions[ OI_D_USER_NAME ].dwActuals = 0;
    cmdOptions[ OI_D_USER_NAME ].dwFlags = CP_TYPE_TEXT | CP_VALUE_MANDATORY;
    cmdOptions[ OI_D_USER_NAME ].pValue = pszUserName;
    cmdOptions[ OI_D_USER_NAME ].pFunction = NULL;
    cmdOptions[ OI_D_USER_NAME ].pFunctionData = NULL;
    lstrcpy( cmdOptions[ OI_D_USER_NAME ].szValues, NULL_STRING );
    lstrcpy( cmdOptions[ OI_D_USER_NAME ].szOption, OPTION_USERNAME );

    // -p option password for the given username
    cmdOptions[ OI_D_PASSWORD ].dwCount = 1;
    cmdOptions[ OI_D_PASSWORD ].dwActuals = 0;
    cmdOptions[ OI_D_PASSWORD ].dwFlags = CP_TYPE_TEXT | CP_VALUE_OPTIONAL;
    cmdOptions[ OI_D_PASSWORD ].pValue = pszPassword;
    cmdOptions[ OI_D_PASSWORD ].pFunction = NULL;
    cmdOptions[ OI_D_PASSWORD ].pFunctionData = NULL;
    lstrcpy( cmdOptions[ OI_D_PASSWORD ].szValues, NULL_STRING );
    lstrcpy( cmdOptions[ OI_D_PASSWORD ].szOption, OPTION_PASSWORD );

    // -id  Values
    cmdOptions[ OI_D_ID ].dwCount = 1;
    cmdOptions[ OI_D_ID ].dwActuals = 0;
    cmdOptions[ OI_D_ID ].dwFlags = CP_TYPE_TEXT | CP_VALUE_MANDATORY;
    cmdOptions[ OI_D_ID ].pValue = pszID;
    cmdOptions[ OI_D_ID ].pFunction = NULL;
    cmdOptions[ OI_D_ID ].pFunctionData = NULL;
    lstrcpy( cmdOptions[ OI_D_ID ].szValues, NULL_STRING );
    lstrcpy( cmdOptions[ OI_D_ID ].szOption, OPTION_ID );

    // -a (accessed by)
    cmdOptions[ OI_D_ACCESSED_BY ].dwCount = 1;
    cmdOptions[ OI_D_ACCESSED_BY ].dwActuals = 0;
    cmdOptions[ OI_D_ACCESSED_BY ].dwFlags = CP_TYPE_TEXT | CP_VALUE_MANDATORY;;
    cmdOptions[ OI_D_ACCESSED_BY ].pValue = pszAccessedby;
    cmdOptions[ OI_D_ACCESSED_BY].pFunction = NULL;
    cmdOptions[ OI_D_ACCESSED_BY ].pFunctionData = NULL;
    lstrcpy( cmdOptions[ OI_D_ACCESSED_BY ].szValues, NULL_STRING );
    lstrcpy( cmdOptions[ OI_D_ACCESSED_BY ].szOption, OPTION_ACCESSEDBY );

	// -o (openmode)
	cmdOptions[ OI_D_OPEN_MODE ].dwCount = 1;
	cmdOptions[ OI_D_OPEN_MODE].dwActuals = 0;
	cmdOptions[ OI_D_OPEN_MODE ].dwFlags =  CP_VALUE_MANDATORY | CP_MODE_VALUES|
                               CP_TYPE_TEXT;
	cmdOptions[ OI_D_OPEN_MODE ].pValue = pszOpenmode;
	cmdOptions[ OI_D_OPEN_MODE ].pFunction = NULL;
	cmdOptions[ OI_D_OPEN_MODE ].pFunctionData = NULL;
	lstrcpy(cmdOptions[ OI_D_OPEN_MODE ].szValues,GetResString(IDS_OPENMODE_OPTION));
	lstrcpy(cmdOptions[ OI_D_OPEN_MODE ].szOption, OPTION_OPENMODE );

	// -op (openfile)
	cmdOptions[ OI_D_OPEN_FILE ].dwCount = 1;
	cmdOptions[ OI_D_OPEN_FILE ].dwActuals = 0;
	cmdOptions[ OI_D_OPEN_FILE ].dwFlags = CP_TYPE_TEXT | CP_VALUE_MANDATORY;;
	cmdOptions[ OI_D_OPEN_FILE ].pValue = pszOpenFile;
	cmdOptions[ OI_D_OPEN_FILE ].pFunction = NULL;
	cmdOptions[ OI_D_OPEN_FILE ].pFunctionData = NULL;
	lstrcpy( cmdOptions[ OI_D_OPEN_FILE ].szValues, NULL_STRING );
	lstrcpy( cmdOptions[ OI_D_OPEN_FILE ].szOption, OPTION_OPENFILE );

	// init the passsword variable with '*'
	if ( pszPassword != NULL )
		lstrcpy( pszPassword, _T( "*" ) );

    //
    // do the command line parsing
    if ( DoParseParam( argc,argv,MAX_DISCONNECT_OPTIONS ,cmdOptions ) == FALSE )
    {
        ShowMessage(stderr,GetResString(IDS_ID_SHOW_ERROR));
        return FALSE;       // invalid syntax
    }
	 if(*pbDisconnect==FALSE)
	 {
		ShowMessage( stderr, GetResString(IDS_ID_SHOW_ERROR) );
		SetReason(szTemp);
		return FALSE;
	 }
	// At least one of -id OR -a OR -o is required.
     if((cmdOptions[ OI_D_ID ].dwActuals==0)&&
        (cmdOptions[ OI_D_ACCESSED_BY ].dwActuals==0)&&
        (cmdOptions[ OI_D_OPEN_MODE ].dwActuals==0)
        )
     {
        lstrcpy(szTemp,GetResString(IDS_NO_ID_ACC_OF));
        lstrcat(szTemp,szTypeHelpMsg);
        SetReason(szTemp);
        return FALSE;
     }

	 // "-u" should not be specified without "-s"
    if ( cmdOptions[ OI_D_SERVER_NAME ].dwActuals == 0 &&
         cmdOptions[ OI_D_USER_NAME ].dwActuals != 0 )
    {
        // invalid syntax
        lstrcpy(szTemp,ERROR_USERNAME_BUT_NOMACHINE);
        lstrcat(szTemp,szTypeHelpMsg);
        SetReason(szTemp);
        return FALSE;			// indicate failure
    }
    // "-p" should not be specified without "-u"
    if ( cmdOptions[ OI_D_USER_NAME ].dwActuals == 0 &&
         cmdOptions[ OI_D_PASSWORD ].dwActuals != 0 )
    {
        // invalid syntax
        lstrcpy(szTemp,ERROR_PASSWORD_BUT_NOUSERNAME );
        lstrcat(szTemp,szTypeHelpMsg);
        SetReason(szTemp);
        return FALSE;           // indicate failure
    }
  

    szTempString = pszServer;
    szTempString.TrimRight();
    lstrcpy(pszServer,(LPCWSTR)szTempString);
    // server name with 0 length is invalid.
    if((cmdOptions[ OI_D_SERVER_NAME ].dwActuals != 0) &&
        (lstrlen(pszServer)==0))
    {
        lstrcpy(szTemp,GetResString(IDS_SERVER_EMPTY));
        lstrcat(szTemp,szTypeHelpMsg);
        SetReason(szTemp);
        return FALSE;
    }
    // server name with 0 length is invalid.
    szTempString = pszUserName;
    szTempString.TrimRight();
    lstrcpy(pszUserName,(LPCWSTR)szTempString);

    if((cmdOptions[ OI_D_USER_NAME ].dwActuals != 0) &&
        (lstrlen(pszUserName)==0))
    {
        lstrcpy(szTemp,GetResString(IDS_USERNAME_EMPTY));
        lstrcat(szTemp,szTypeHelpMsg);
        SetReason(szTemp);
        return FALSE;
    }
    // user given -p option and not given password 
    // so it is needed to prompt for password.
	if ( cmdOptions[ OI_D_PASSWORD ].dwActuals != 0 && 
		 pszPassword != NULL && lstrcmp( pszPassword, _T( "*" ) ) == 0 )
	{
		// user wants the utility to prompt for the password before trying to connect
		*pbNeedPassword = TRUE;
	}
	else if ( cmdOptions[ OI_D_PASSWORD ].dwActuals == 0 && 
	        ( cmdOptions[ OI_D_SERVER_NAME ].dwActuals != 0 || cmdOptions[ OI_D_USER_NAME ].dwActuals != 0 ) )
	{
		// -s, -u is specified without password ...
		// utility needs to try to connect first and if it fails then prompt for the password
		*pbNeedPassword = TRUE;
		if ( pszPassword != NULL )
		{
			lstrcpy( pszPassword, _T( "" ) );
		}
	}

     // Check if Accessed by is not given as and empty string
     // or a string having only spaces....
    szTempString = pszAccessedby;
    szTempString.TrimRight();
    lstrcpy(pszAccessedby,(LPCWSTR)szTempString);
    if((cmdOptions[ OI_D_ACCESSED_BY ].dwActuals != 0) &&
       (lstrlen(pszAccessedby) == 0))  
    {
        lstrcpy(szTemp,GetResString(IDS_ACCESSBY_EMPTY));
        lstrcat(szTemp,szTypeHelpMsg);
        SetReason(szTemp);
        return FALSE;
    }

     // Check if Open File is not given as and empty string
     // or a string having only spaces....
    szTempString = pszOpenFile;
    szTempString.TrimRight();
    lstrcpy(pszOpenFile,(LPCWSTR)szTempString);
    if((cmdOptions[ OI_D_OPEN_FILE ].dwActuals != 0) &&
       (lstrlen(pszOpenFile) == 0))  
    {
        lstrcpy(szTemp,GetResString(IDS_OPEN_FILE_EMPTY));
        lstrcat(szTemp,szTypeHelpMsg);
        SetReason(szTemp);
        return FALSE;
    }
     
   // Check if -id option is given and if it is numeric ,
   // also if it is numeric then check its range
     if((IsNumeric((LPCTSTR)pszID,10,TRUE)==TRUE)&&
        (cmdOptions[ OI_D_ID ].dwActuals==1))
     {
         if((AsLong((LPCTSTR)pszID,10)>UINT_MAX) || 
            (AsLong((LPCTSTR)pszID,10)<1))
         {
             // Message shown on screen will be...
             // ERROR: Invlid ID.
            lstrcpy(szTemp,GetResString(IDS_ERROR_ID));
            lstrcat(szTemp,szTypeHelpMsg);
            SetReason(szTemp);
             return FALSE;
         }

     }
     // check user given "*" or any junk string....
     if(!((lstrcmp((LPCTSTR)pszID,ASTERIX)==0)||
          (IsNumeric((LPCTSTR)pszID,10,TRUE)==TRUE))
          &&(lstrlen((LPCTSTR)pszID)!=0))
     {
             // Message shown on screen will be...
             // ERROR: Invlid ID.
            lstrcpy(szTemp,GetResString(IDS_ERROR_ID));
            lstrcat(szTemp,szTypeHelpMsg);
            SetReason(szTemp);
            return FALSE;
     }
    return TRUE;  
}
/*-----------------------------------------------------------------------------

Routine Description:

Displays how to use -disconnect option

Arguments:

    None

Returned Value:

None
-----------------------------------------------------------------------------*/
VOID
DisconnectUsage()
{
    // local variables
    DWORD dw = 0;

    // start displaying the usage
    for( dw = IDS_HELP_LINE1; dw <= IDS_HELP_LINE_END; dw++ )
        ShowMessage( stdout, GetResString( dw ) );
}//DisconnectUsage
/*-----------------------------------------------------------------------------

Routine Description:

Displays how to use -query option

Arguments:

    None

Returned Value:

None
-----------------------------------------------------------------------------*/
VOID
QueryUsage()
{
    // local variables
    DWORD dw = 0;

    // start displaying the usage
    for( dw = IDS_HELP_QUERY1; dw <= IDS_HELP_QUERY_END; dw++ )
        ShowMessage( stdout, GetResString( dw ) );
}//query Usage
/*-----------------------------------------------------------------------------

Routine Description:

    Displays how to use this Utility

Arguments:

    None

Returned Value:

None
-----------------------------------------------------------------------------*/
VOID
Usage()
{
    // local variables
    DWORD dw = 0;

    // start displaying the usage
    for( dw = IDS_HELP_MAIN1; dw <= IDS_HELP_MAIN_END; dw++ )
        ShowMessage( stdout, GetResString( dw ) );

}//Usage
/*-----------------------------------------------------------------------------

Routine Description:

    Displays how to use -local option

Arguments:

    None

Returned Value:

None
-----------------------------------------------------------------------------*/
VOID
LocalUsage()
{
    // local variables
    DWORD dw = 0;

    // start displaying the usage
    for( dw = IDS_HELP_LOCAL1; dw <= IDS_HELP_LOCAL_END; dw++ )
        ShowMessage( stdout, GetResString( dw ) );

}//-local

/*-----------------------------------------------------------------------------

Routine Description:


Arguments:


Returned Value:

None
-----------------------------------------------------------------------------*/

DWORD CheckSystemType(LPTSTR szServer)
{
	
	DWORD dwSystemType = 0 ;
#ifndef _WIN64
	//display the error message if  the target system is a 64 bit system or if error occured in 
	 //retreiving the information
	 dwSystemType = GetCPUInfo(szServer);
	if(dwSystemType == ERROR_RETREIVE_REGISTRY)
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_SYSTEM_INFO));
		return (EXIT_FAILURE);
	
	}
	if(dwSystemType == SYSTEM_64_BIT)
	{
		if(lstrlen(szServer)== 0 )
		{
			DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_VERSION_MISMATCH));
		}
		else
		{
			DISPLAY_MESSAGE(stderr,GetResString(IDS_REMOTE_NOT_SUPPORTED));
		}
		return (EXIT_FAILURE);

	}

#endif

		return EXIT_SUCCESS ;
}



// ***************************************************************************
//   Name							: GetCPUInfo
//   Routine Description			: determines if the computer is 32 bit system or 64 bit 
//   Arguments						: 
//		[ in ] szComputerName	: System name
//   Return Type					: BOOL
//		TRUE  :   if the system is a  32 bit system
//		FALSE :   if the system is a  64 bit system 		
// ***************************************************************************

DWORD GetCPUInfo(LPTSTR szComputerName)
{
  HKEY     hKey1 = 0;

  HKEY     hRemoteKey = 0;
  TCHAR    szCurrentPath[MAX_STRING_LENGTH + 1] = NULL_STRING;
  TCHAR    szPath[MAX_STRING_LENGTH + 1] = SUBKEY ; 
  

  DWORD    dwValueSize = MAX_STRING_LENGTH + 1;
  DWORD    dwRetCode = ERROR_SUCCESS;
  DWORD    dwError = 0;
  TCHAR szTmpCompName[MAX_STRING_LENGTH+1] = NULL_STRING;
  
   TCHAR szTemp[MAX_RES_STRING+1] = NULL_STRING ;
   DWORD len = lstrlen(szTemp);
   TCHAR szVal[MAX_RES_STRING+1] = NULL_STRING ;
   DWORD dwLength = MAX_STRING_LENGTH ;
   LPTSTR szReturnValue = NULL ;
   DWORD dwCode =  0 ;
   szReturnValue = ( LPTSTR ) malloc( dwLength*sizeof( TCHAR ) );
   if(szReturnValue == NULL)
   {
		return ERROR_RETREIVE_REGISTRY ;
   }

   if(lstrlen(szComputerName)!= 0 )
	{
	lstrcpy(szTmpCompName,TOKEN_BACKSLASH4);
	lstrcat(szTmpCompName,szComputerName);
  }
  else
  {
	lstrcpy(szTmpCompName,szComputerName);
  }
  
  // Get Remote computer local machine key
  dwError = RegConnectRegistry(szTmpCompName,HKEY_LOCAL_MACHINE,&hRemoteKey);
  if (dwError == ERROR_SUCCESS)
  {
     dwError = RegOpenKeyEx(hRemoteKey,szPath,0,KEY_READ,&hKey1);
     if (dwError == ERROR_SUCCESS)
     {
		dwRetCode = RegQueryValueEx(hKey1, IDENTIFIER_VALUE, NULL, NULL,(LPBYTE) szReturnValue, &dwValueSize);
		
		if (dwRetCode == ERROR_MORE_DATA)
		{
				szReturnValue 	 = ( LPTSTR ) realloc( szReturnValue 	, dwValueSize * sizeof( TCHAR ) );
				dwRetCode = RegQueryValueEx(hKey1, IDENTIFIER_VALUE, NULL, NULL,(LPBYTE) szReturnValue, &dwValueSize);
		}
		if(dwRetCode != ERROR_SUCCESS)
		{
			RegCloseKey(hKey1);			
			RegCloseKey(hRemoteKey);
			return ERROR_RETREIVE_REGISTRY ;
		}
	 }
	 else
	 {
		RegCloseKey(hRemoteKey);
		return ERROR_RETREIVE_REGISTRY ;

	 }
    
    RegCloseKey(hKey1);
  }
  else
  {
	  RegCloseKey(hRemoteKey);
	  return ERROR_RETREIVE_REGISTRY ;
  }
 
  RegCloseKey(hRemoteKey);
 
  lstrcpy(szVal,X86_MACHINE);

  //check if the specified system contains the words x86 (belongs to the 32 )
  // set the flag to true if the specified system is 64 bit .
	
  if( !_tcsstr(szReturnValue,szVal))
	  {
		dwCode = SYSTEM_64_BIT ;
	  }
	 else
	  {
		dwCode =  SYSTEM_32_BIT ;
	  }

	
  SAFEFREE(szReturnValue);
  return dwCode ;

}//GetCPUInfo



/*-----------------------------------------------------------------------------

Routine Description:


Arguments:


Returned Value:

None
-----------------------------------------------------------------------------*/

DWORD CheckSystemType64(LPTSTR szServer)
{
	
	DWORD dwSystemType = 0 ;
#ifdef _WIN64
	//display the error message if  the target system is a 64 bit system or if error occured in 
	 //retreiving the information
	 dwSystemType = GetCPUInfo(szServer);
	if(dwSystemType == ERROR_RETREIVE_REGISTRY)
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_SYSTEM_INFO));
		return (EXIT_FAILURE);
	
	}
	if(dwSystemType == SYSTEM_32_BIT)
	{
		if(lstrlen(szServer)== 0 )
		{
			DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_VERSION_MISMATCH1));
		}
		else
		{
			DISPLAY_MESSAGE(stderr,GetResString(IDS_REMOTE_NOT_SUPPORTED1));
		}
		return (EXIT_FAILURE);

	}

#endif

		return EXIT_SUCCESS ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\openfiles\disconnect.cpp ===
/******************************************************************************
Copyright (c) Microsoft Corporation

Module Name:

    Disconnect.cpp

Abstract:

    Disconnects one or more open files

Author:
  
     Akhil Gokhale (akhil.gokhale@wipro.com) 1-Nov-2000
  
Revision History:
  
       Akhil Gokhale (akhil.gokhale@wipro.com) 1-Nov-2000 : Created It.

******************************************************************************/
//include headers
#include "pch.h"
#include "Disconnect.h"

/*-----------------------------------------------------------------------------
Routine Description:

Disconnects one or more openfiles
     
Arguments: 

    [in]    pszServer      - remote server name
    [in]    pszID          - Open file ids
    [in]    pszAccessedby  - Name of  user name who access the file
    [in]    pszOpenmode    - accessed mode 
    [in]    pszOpenFile    - Open file name  

Returned Value:

            - TRUE for success exit
            - FALSE for failure exit
-----------------------------------------------------------------------------*/
BOOL
DisconnectOpenFile( PTCHAR pszServer,
                    PTCHAR pszID, 
                    PTCHAR pszAccessedby, 
                    PTCHAR pszOpenmode, 
                    PTCHAR pszOpenFile )
{
    // local variables to this function
    BOOL bResult = FALSE;// Stores fuctions return value status.

    DWORD dwEntriesRead = 0;// Receives the count of elements actually 
                            // enumerated by "NetFileEnum" function
    DWORD dwTotalEntries = 0;//Receives the total number of entries that could 
                             //have been enumerated from the current 
                             //resume position by "NetFileEnum" function
    DWORD dwResumeHandle = 0;//Contains a resume handle which is used to 
                             //continue an existing file search. 
                             //The handle should be zero on the first call and 
                             //left unchanged for subsequent calls. 
                             //If resume_handle is NULL, 
                             //then no resume handle is stored. This variable
                             // used in calling "NetFileEnum" function.
    LPFILE_INFO_3 pFileInfo3_1 = NULL; //LPFILE_INFO_3  structure contains the 
                                       //identification number and other 
                                       //pertinent information about files, 
                                       //devices, and pipes.

    DWORD dwError = 0;//Contains return value for "NetFileEnum" function
    NET_API_STATUS nStatus = 0;// Stores return value for NetFileClose functin

    TCHAR szResult[(MAX_RES_STRING*2) + 1] = NULL_STRING;
       
    AFP_FILE_INFO* pFileInfo = NULL;
    DWORD hEnumHandle = 0;
    HRESULT hr = S_OK;
    NET_API_STATUS retval = NERR_Success;
    AFP_SERVER_HANDLE ulSFMServerConnection = 0;
    TCHAR   szDllPath[MAX_PATH+1] = NULL_STRING;// buffer for Windows directory
    
    
    HMODULE hModule = 0;          // To store retval for LoadLibrary
  
      
    DWORD         dwConnectionId            = 0;

    typedef DWORD (*AFPCONNECTIONCLOSEPROC) (AFP_SERVER_HANDLE,DWORD); // Function pointer
    typedef DWORD (*CONNECTPROC) (LPWSTR,PAFP_SERVER_HANDLE);// Function pointer
    typedef  DWORD (*FILEENUMPROC)(AFP_SERVER_HANDLE,LPBYTE*,DWORD,LPDWORD,LPDWORD,LPDWORD);

    AFPCONNECTIONCLOSEPROC AfpAdminFileClose = NULL;  
    CONNECTPROC  AfpAdminConnect = NULL; 
    FILEENUMPROC AfpAdminFileEnum = NULL;// Function Pointer
    

    //varibles to store whether the given credentials are matching with the 
    //got credentials.

    BOOL    bId = FALSE;
    BOOL    bAccessedBy = FALSE;
    BOOL    bOpenmode   = FALSE;
    BOOL    bOpenfile   = FALSE;
    BOOL    bIfatleast  = FALSE;
    do
    {
        // Get the block of files
        dwError = NetFileEnum( pszServer, 
                               NULL, 
                               NULL, 
                               3, 
                               (LPBYTE *)&pFileInfo3_1, 
                               MAX_PREFERRED_LENGTH,
                               &dwEntriesRead,
                               &dwTotalEntries, 
                               (PDWORD_PTR)&dwResumeHandle );
        if(dwError == ERROR_ACCESS_DENIED)
        {
            SetLastError(ERROR_ACCESS_DENIED);
            DISPLAY_MESSAGE(stderr,GetResString(IDS_ID_SHOW_ERROR));
            ShowLastError(stderr);
            return FALSE;

        }
        if( dwError == NERR_Success || dwError == ERROR_MORE_DATA )
        {
            for ( DWORD dwFile = 0; 
                  dwFile < dwEntriesRead;
                  dwFile++, pFileInfo3_1++ )
            {
                //Check whether the got open file is file or names pipe.
                // If named pipe leave it. As this utility do not 
                // disconnect Named pipe
                if ( IsNamedPipePath(pFileInfo3_1->fi3_pathname ) )
                {
                    continue;
                }
                else//Not a named pipe. is a file
                {   
                    bId = IsSpecifiedID(pszID,pFileInfo3_1->fi3_id); 
                    bAccessedBy = IsSpecifiedAccessedBy(pszAccessedby, 
                                                   pFileInfo3_1->fi3_username);
                    bOpenmode = IsSpecifiedOpenmode(pszOpenmode,
                                                pFileInfo3_1->fi3_permissions);
                    bOpenfile = IsSpecifiedOpenfile(pszOpenFile,
                                                pFileInfo3_1->fi3_pathname);
                    // Proceed for dicconecting the open file only if 
                    // all previous fuction returns true. This insures that
                    // user preference is taken care.

                    if( bId && 
                        bAccessedBy && 
                        bOpenmode && 
                        bOpenfile)
                    {
                        bIfatleast = TRUE;
                        memset( szResult, 0, (((MAX_RES_STRING*2) + 1) *
                                sizeof( TCHAR )) );
                        //The NetFileClose function forces a resource to close.
                        nStatus = NetFileClose(pszServer, 
                                               pFileInfo3_1->fi3_id);
                        if(nStatus == NERR_Success)
                        {
                            // Create the output message string as File
                            // is successfully deleted.
                            // Output string will be :
                            // SUCCESS: Connection to openfile "filename"
                            // has been terminated.
                            bResult = TRUE;
                            FORMAT_STRING(szResult,DISCONNECTED_SUCCESSFULLY,pFileInfo3_1->fi3_pathname);
                            DISPLAY_MESSAGE(stdout, szResult);
                        }
                        else
                        {
                           // As unable to disconnect the openfile make  
                           // output message as 
                           // ERROR: could not dissconnect "filename".
                            bResult = FALSE;
                            FORMAT_STRING(szResult,DISCONNECT_UNSUCCESSFUL,pFileInfo3_1->fi3_pathname);
                            DISPLAY_MESSAGE(stderr, szResult);
                        }
                        // Display output result as previously constructed.
                    }//If bId...
                }//else part of is named pipe
             }
        }
   } while ( dwError == ERROR_MORE_DATA );
    // Free the block
    if( pFileInfo3_1 !=NULL)
    {
    NetApiBufferFree( pFileInfo3_1 ); 
    pFileInfo3_1 = NULL;
    }


   // Now disconnect files for MAC OS

    do
    {
        // DLL required is stored always in \windows\system32 directory....        
        // so get windows directory first.
        if(GetSystemDirectory(szDllPath, MAX_PATH)!= 0)
        {
            lstrcat(szDllPath,MAC_DLL_FILE_NAME); 
            hModule = ::LoadLibrary (szDllPath);

            if(hModule==NULL)
            {
                DISPLAY_MESSAGE(stderr,GetResString(IDS_ID_SHOW_ERROR));
                ShowLastError(stderr); // Shows the error string set by API function.
                return FALSE;

            }
        }
        else
        {
                DISPLAY_MESSAGE(stderr,GetResString(IDS_ID_SHOW_ERROR));
                ShowLastError(stderr); // Shows the error string set by API function.
                return FALSE;
        }
       
        AfpAdminConnect = (CONNECTPROC)::GetProcAddress (hModule,"AfpAdminConnect");
        AfpAdminFileClose = (AFPCONNECTIONCLOSEPROC)::GetProcAddress (hModule,"AfpAdminFileClose");
        AfpAdminFileEnum = (FILEENUMPROC)::GetProcAddress (hModule,"AfpAdminFileEnum");

        // Check if  all function pointer successfully taken from DLL
        // if not show error message and exit
        if((AfpAdminFileClose== NULL)||
           (AfpAdminConnect  == NULL)||
           (AfpAdminFileEnum == NULL))

        {
            DISPLAY_MESSAGE(stderr,GetResString(IDS_ID_SHOW_ERROR));
            ShowLastError(stderr); // Shows the error string set by API function.
            FREE_LIBRARY(hModule);
            return FALSE;
        }
        
        // Connection ID is requered for AfpAdminFileEnum function so 
        // connect to server to get connect id...
        DWORD retval_connect =  AfpAdminConnect(const_cast<LPWSTR>(pszServer),
                                &ulSFMServerConnection );
        if(retval_connect!=0)
        {
            DISPLAY_MESSAGE(stderr,GetResString(IDS_ID_SHOW_ERROR));
            ShowLastError(stderr); // Shows the error string set by API function.
            FREE_LIBRARY(hModule);
             return FALSE;
        }

      dwError =     AfpAdminFileEnum( ulSFMServerConnection,
                                      (PBYTE*)&pFileInfo,
                                      (DWORD)-1L,
                                      &dwEntriesRead,
                                      &dwTotalEntries,
                                      &hEnumHandle );
        if(dwError == ERROR_ACCESS_DENIED)
        {
            SetLastError(ERROR_ACCESS_DENIED);
            DISPLAY_MESSAGE(stderr,GetResString(IDS_ID_SHOW_ERROR));
            ShowLastError(stderr);
            FREE_LIBRARY(hModule);
            return FALSE;
        }
        if( dwError == NERR_Success || dwError == ERROR_MORE_DATA )
        {
            for ( DWORD dwFile = 0; 
                  dwFile < dwEntriesRead;
                  dwFile++, pFileInfo++ )
            {
                //Check whether the got open file is file or names pipe.
                // If named pipe leave it. As this utility do not 
                // disconnect Named pipe
                if ( IsNamedPipePath(pFileInfo->afpfile_path ) )
                {
                    continue;
                }
                else//Not a named pipe. is a file
                {   
                    bId = IsSpecifiedID(pszID,pFileInfo->afpfile_id ); 
                    bAccessedBy = IsSpecifiedAccessedBy(pszAccessedby, 
                                                   pFileInfo->afpfile_username );
                    bOpenmode = IsSpecifiedOpenmode(pszOpenmode,
                                                pFileInfo->afpfile_open_mode);
                    bOpenfile = IsSpecifiedOpenfile(pszOpenFile,
                                                pFileInfo->afpfile_path);
                    // Proceed for dicconecting the open file only if 
                    // all previous fuction returns true. This insures that
                    // user preference is taken care.

                    if( bId && 
                        bAccessedBy && 
                        bOpenmode && 
                        bOpenfile)
                    {
                        bIfatleast = TRUE;
                        memset( szResult, 0, (((MAX_RES_STRING*2) + 1) *
                                sizeof( TCHAR )) );



                        nStatus = AfpAdminFileClose(ulSFMServerConnection, 
                                                  pFileInfo->afpfile_id);
                        if(nStatus == NERR_Success)
                        {
                            // Create the output message string as File
                            // is successfully deleted.
                            // Output string will be :
                            // SUCCESS: Connection to openfile "filename"
                            // has been terminated.
                            bResult = TRUE;
                            //lstrcpy(szTemp,DISCONNECTED_SUCCESSFULLY);
                            //lstrcat(szResult,pFileInfo3_1->fi3_pathname);
                            //lstrcat(szResult,HAS_BEEN_TERMINATED);
                            
                            FORMAT_STRING(szResult,DISCONNECTED_SUCCESSFULLY,pFileInfo->afpfile_path);
                            DISPLAY_MESSAGE(stdout, szResult);

                            bResult = TRUE;
                        }
                        else
                        {
                           // As unable to disconnect the openfile make  
                           // output message as 
                           // ERROR: could not dissconnect "filename".
                            bResult = FALSE;
                            FORMAT_STRING(szResult,DISCONNECT_UNSUCCESSFUL,pFileInfo3_1->fi3_pathname);
                            DISPLAY_MESSAGE(stderr, szResult);
                        }
                    }//If bId...
                }//else part of is named pipe
             }
        }
   } while ( dwError == ERROR_MORE_DATA );

    if(bIfatleast == FALSE)// As not a single open file disconnected
                          // show Info. message as 
                          // INFO: No. open files found.
    {
        ShowMessage(stdout,GetResString(IDS_NO_D_OPENFILES));
    }

    // Free the block
    if( pFileInfo !=NULL)
    {
    NetApiBufferFree( pFileInfo); 
    pFileInfo = NULL;
    }

    FREE_LIBRARY(hModule);
    return TRUE;
}
/*-----------------------------------------------------------------------------

Routine Description:

Tests whether the given file path is namedpipe path or a file path

Arguments:

    [in] pszwFilePath    -- Null terminated string specifying the path name

Returned Value:

TRUE    - if it is a named pipe path
FALSE   - if it is a file path
-----------------------------------------------------------------------------*/
BOOL 
IsNamedPipePath(LPWSTR pszwFilePath)
{
    LPWSTR pwszSubString = NULL;
    pwszSubString = wcsstr(pszwFilePath, PIPE_STRING);//Search PIPE_STRING
    // If PIPE_STRING found then return TRUE else FALSE.
    if( pwszSubString == NULL)
    {
        return FALSE;
    }
   return TRUE;
}//IsNamedPipePath
/*-----------------------------------------------------------------------------

Routine Description:

Tests whether the user specified open file id is equivalent to the api 
returned id.

Arguments:

    [in]    pszId   -Null terminated string specifying the user 
                     specified fil ID 
    [in]    dwId    -current file ID.

Returned Value:

TRUE    - if pszId is * or equal to dwId
FALSE   - otherwise
-----------------------------------------------------------------------------*/
BOOL 
IsSpecifiedID(LPTSTR pszId, DWORD dwId)
{
   // Check if WILD card is given OR no id is given OR given id and 
   // id returned by api is similar. In any of the case return TRUE.
    
    if((lstrcmp(pszId, WILD_CARD) == 0) || 
       (lstrlen(pszId) == 0)||
       ((DWORD)(_ttol(pszId)) == dwId))
    {
        return TRUE;
    }
    return FALSE;
}//IsSpecifiedID
/*-----------------------------------------------------------------------------

Routine Description:

Tests whether the user specified accessed open file username is equivalent to 
the api returned username.

Arguments:

    [in]    pszAccessedby   - Null terminated string specifying the 
                              accessedby username
    [in]    pszwAccessedby  - Null terminated string specifying the api 
                              returned username.

Returned Value:

TRUE  - if pszAccessedby is * or equal to pszwAccessedby
FALSE - Otherwise
-----------------------------------------------------------------------------*/
BOOL 
IsSpecifiedAccessedBy(LPTSTR pszAccessedby, LPWSTR pszwAccessedby)
{
   // Check if WILD card is given OR non - existance of username  OR given 
   // username and  username returned by api is similar. In any of the case 
   // return TRUE.

    if((lstrcmp(pszAccessedby, WILD_CARD) == 0) || 
        (lstrlen(pszAccessedby) == 0)           ||
        (lstrcmpi(pszAccessedby,pszwAccessedby)==0))
    {
        return TRUE;
    }
    return FALSE;
}//IsSpecifiedAccessedBy
/*-----------------------------------------------------------------------------

Routine Description:

Tests whether the user specified open mode is equivalent to the api returned 
openmode

Arguments:

   [in] pszOpenmode - Null terminated string specifying the openmode
   [in] dwOpenmode  - The api returned open mode.

Returned Value:

TRUE  - if pszOpenmode is * or equal to dwOpenmode
FALSE - otherwise
-----------------------------------------------------------------------------*/
BOOL 
IsSpecifiedOpenmode(LPTSTR pszOpenmode, DWORD  dwOpenmode)
{
    
    // Check for WILD card if given OR if no open mode given . In both case 
    // return TRUE.
    if((lstrcmp(pszOpenmode, WILD_CARD) == 0) || 
       (lstrlen(pszOpenmode) == 0))
    {
        return TRUE;
    }
    // Check if READ mode is given as String . 
    if(CompareString(LOCALE_SYSTEM_DEFAULT,
                     NORM_IGNORECASE,
                     pszOpenmode,
                     -1,
                     READ_MODE,
                     -1)== CSTR_EQUAL)
    {
        // check  that only READ mode only with dwOpenmode variable which is
        // returned by api.
        if((PERM_FILE_READ == (dwOpenmode & PERM_FILE_READ)) && 
                       (PERM_FILE_WRITE != (dwOpenmode & PERM_FILE_WRITE)))
        {
            return TRUE;
        }
    }
    // Check if write mode is given.
    else if(CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE,
                         pszOpenmode,-1,WRITE_MODE,-1) == CSTR_EQUAL)
    {
        // check  that only WRITE mode only with dwOpenmode variable which is
        // returned by api.

        if((PERM_FILE_WRITE == (dwOpenmode & PERM_FILE_WRITE)) && 
            (PERM_FILE_READ != (dwOpenmode & PERM_FILE_READ)))
        {
            return TRUE;
        }
    }
    else if(CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE,
                        pszOpenmode,-1,READ_WRITE_MODE,-1) == CSTR_EQUAL)
    {
        if((PERM_FILE_READ == (dwOpenmode & PERM_FILE_READ)) && 
                       (PERM_FILE_WRITE == (dwOpenmode & PERM_FILE_WRITE)))
        {
            return TRUE;
        }
    }
    else if(CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE,
                        pszOpenmode,-1,WRITE_READ_MODE,-1) == CSTR_EQUAL)
    {
        if((PERM_FILE_WRITE == (dwOpenmode & PERM_FILE_WRITE)) && 
            (PERM_FILE_READ == (dwOpenmode & PERM_FILE_READ)))
        {
            return TRUE;
        }
    }

    // Given string does not matches with predefined Strings..
    // return FALSE.
    return FALSE;
}
/*-----------------------------------------------------------------------------

Routine Description:

Tests whether the user specified open file is equalant to the api returned 
open file.

Arguments:

    [in] pszOpenfile    - Null terminated string specifying the open 
                          file
    [in] pszwOpenfile   - Null terminated string specifying the api 
                          returned open file.

Returned Value:

TRUE    - if pszOpenfile is * or equal to pszwOpenfile
FALSE   - otherwise
-----------------------------------------------------------------------------*/
BOOL 
IsSpecifiedOpenfile(LPTSTR pszOpenfile, LPWSTR pszwOpenfile)
{
    // Check for WILD card if given OR no open file specified OR
    // open file given by user matches with open file returned by api. 
    // In all cases return TRUE.
    if((lstrcmp(pszOpenfile, WILD_CARD) == 0)||
       (lstrlen(pszOpenfile) == 0)           ||
       (lstrcmpi(pszwOpenfile,pszOpenfile)==0))
    {
        return TRUE;
    }
    return FALSE;
}//IsSpecifiedOpenfile
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\openfiles\processowner.cpp ===
/******************************************************************************

  Copyright (C) Microsoft Corporation

  Module Name:
      ProcessOwner.CPP 

  Abstract: 
       This module deals with Query functionality of OpenFiles.exe 
       NT command line utility.

  Author:
  
       Akhil Gokhale (akhil.gokhale@wipro.com) 25-APRIL-2000
  
 Revision History:
  
       Akhil Gokhale (akhil.gokhale@wipro.com) 25-APRIL-2000 : Created It.


*****************************************************************************/
#include "pch.h"
#include "OpenFiles.h"


#define SAFE_CLOSE_HANDLE(hHandle) \
        if(hHandle!=NULL) \
        {\
           CloseHandle(hHandle);\
           hHandle = NULL;\
        }\
        1
#define SAFE_FREE_GLOBAL_ALLOC(block) \
           if(block!=NULL)\
           {\
                delete block;\
                block = NULL;\
           }\
           1
#define SAFE_FREE_ARRAY(arr) \
         if(arr != NULL)\
         {\
             delete [] arr;\
             arr = NULL;\
         }\
         1 
/*****************************************************************************
Routine Description:


Arguments:


  result.

Return Value: 
   
******************************************************************************/
BOOL GetProcessOwner(LPTSTR pszUserName,DWORD hFile)
{

DWORD dwRtnCode = 0;
PSID pSidOwner;
BOOL bRtnBool = TRUE;
LPTSTR DomainName = NULL,AcctName = NULL;
DWORD dwAcctName = 1, dwDomainName = 1;
SID_NAME_USE eUse = SidTypeUnknown;
PSECURITY_DESCRIPTOR pSD=0;
HANDLE  hHandle = GetCurrentProcess();
HANDLE  hDynHandle = NULL;
HANDLE  hDynToken = NULL;
LUID luidValue;
BOOL bResult = FALSE;
HANDLE hToken = NULL;
TOKEN_PRIVILEGES tkp;


    bResult = OpenProcessToken(GetCurrentProcess(),TOKEN_ADJUST_PRIVILEGES|TOKEN_QUERY,&hToken);
    if(bResult == FALSE)

    {
        return FALSE;
    }

    bResult = LookupPrivilegeValue(NULL,SE_SECURITY_NAME,&luidValue );
    if(bResult == FALSE)
    {
        SAFE_CLOSE_HANDLE(hToken);
        return FALSE;
    }

    // Prepare the token privilege structure 
    tkp.PrivilegeCount = 0;
    tkp.Privileges[0].Luid = luidValue;
    tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED|SE_PRIVILEGE_USED_FOR_ACCESS;

    // Now enable the debug privileges in token

    bResult = AdjustTokenPrivileges(hToken,FALSE,&tkp,sizeof(TOKEN_PRIVILEGES),(PTOKEN_PRIVILEGES)NULL,
                                    (PDWORD)NULL);
    if(bResult == FALSE)
    {
        SAFE_CLOSE_HANDLE(hToken);
        return FALSE;
    }




hDynHandle = OpenProcess(PROCESS_QUERY_INFORMATION,FALSE,hFile);; // Here you can give any valid process ids..
      
if(hDynHandle == NULL)
{

    return FALSE;

}
bResult = OpenProcessToken(hDynHandle,TOKEN_QUERY,&hDynToken);

if(bResult == FALSE)
{
    
    SAFE_CLOSE_HANDLE(hDynHandle);
    return FALSE;
}
    TOKEN_USER * pUser = NULL;    
    DWORD cb = 0;     
    // determine size of the buffer needed to receive all information    
    if (!GetTokenInformation(hToken, TokenUser, NULL, 0, &cb))    
    {    
        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
        {
            SAFE_CLOSE_HANDLE(hDynHandle);
            SAFE_CLOSE_HANDLE(hDynToken);
        
            return FALSE;    
        }
    }        

    pUser = (TOKEN_USER *)_alloca(cb);
    if(pUser==NULL)  
    {
        SAFE_CLOSE_HANDLE(hDynHandle);
        SAFE_CLOSE_HANDLE(hDynToken);
        return FALSE;
    }

    if (!GetTokenInformation(hDynToken, TokenUser, pUser, cb, &cb))    
    {
        SAFE_CLOSE_HANDLE(hDynHandle);
        SAFE_CLOSE_HANDLE(hDynToken);
        return FALSE;     
     }


    PSID pSid =  pUser->User.Sid;
// Allocate memory for the SID structure.
    pSidOwner = new SID;
// Allocate memory for the security descriptor structure.
pSD = new SECURITY_DESCRIPTOR;
if(pSidOwner==NULL ||pSD == NULL)
{
    SAFE_CLOSE_HANDLE(hDynHandle);
    SAFE_CLOSE_HANDLE(hDynToken);
    SAFE_FREE_GLOBAL_ALLOC(pSD);
    SAFE_FREE_GLOBAL_ALLOC(pSidOwner);
   return FALSE;
}

// First call to LookupAccountSid to get the buffer sizes.
bRtnBool = LookupAccountSid(
                  NULL,           // local computer
                  pUser->User.Sid,
                  NULL, // AcctName
                  (LPDWORD)&dwAcctName,
                  NULL, // DomainName
                  (LPDWORD)&dwDomainName,
                  &eUse);

AcctName = new TCHAR[dwAcctName+1];
DomainName = new TCHAR[dwDomainName+1];

if(AcctName==NULL || DomainName==NULL)
{

    SAFE_FREE_ARRAY(AcctName);
    SAFE_FREE_ARRAY(DomainName);
    return FALSE;
}

    // Second call to LookupAccountSid to get the account name.
    bRtnBool = LookupAccountSid(
          NULL,                          // name of local or remote computer
          pUser->User.Sid,                     // security identifier
          AcctName,                      // account name buffer
          (LPDWORD)&dwAcctName,          // size of account name buffer 
          DomainName,                    // domain name
          (LPDWORD)&dwDomainName,        // size of domain name buffer
          &eUse);                        // SID type

    SAFE_CLOSE_HANDLE(hDynHandle);
    SAFE_CLOSE_HANDLE(hDynToken);
    
    SAFE_FREE_GLOBAL_ALLOC(pSD);
    SAFE_FREE_GLOBAL_ALLOC(pSidOwner);

    // Check GetLastError for LookupAccountSid error condition.
    if (bRtnBool == FALSE) 
    {
        SAFE_FREE_ARRAY(AcctName);
        SAFE_FREE_ARRAY(DomainName);
        return FALSE;

    } else  
    {
            if(lstrcmpi(DomainName,_T("NT AUTHORITY"))==0)
            {
                SAFE_FREE_ARRAY(AcctName);
                SAFE_FREE_ARRAY(DomainName);
                return FALSE;
            }
            else
            {
                lstrcpy(pszUserName,AcctName);
                SAFE_FREE_ARRAY(AcctName);
                SAFE_FREE_ARRAY(DomainName);
                return TRUE;
            }
    }

    SAFE_FREE_ARRAY(AcctName);
    SAFE_FREE_ARRAY(DomainName);
    SAFE_CLOSE_HANDLE(hDynHandle);
    SAFE_CLOSE_HANDLE(hDynToken);
    SAFE_FREE_GLOBAL_ALLOC(pSD);
    SAFE_FREE_GLOBAL_ALLOC(pSidOwner);
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\openfiles\pch.h ===
// ***************************************************************************
// 
//  Copyright (c)  Microsoft Corporation
//  
//  Module Name:
// 
//        pch.h 
//  
//  Abstract:
//  
//         pre-compiled header declaration
//        files that has to be pre-compiled into .pch file
//  
//  
//  Author:
//  
//       Akhil Gokhale (akhil.gokhale@wipro.com) 1-Nov-2000
//  
//  Revision History:
//  
//       Akhil Gokhale (akhil.gokhale@wipro.com) 1-Nov-2000 : Created It.
// ****************************************************************************

#ifndef __PCH_H
#define __PCH_H



#pragma once        // include header file only once

extern "C"
{
    #include <assert.h>
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include <ctype.h>
    #include <memory.h>
    #include <ntos.h>
    #include <ntioapi.h>
    #include <nturtl.h>
    #include <TCHAR.h> 
    #include <windows.h>
    #include <dbghelp.h>
    #include <Winbase.h>
    #include <lm.h>
    #include <Lmserver.h>
    #include <winerror.h>
}


//
// public C header files
//
#include <tchar.h>
#include <crtdbg.h>
#include <comdef.h>
#include <winsock2.h>
//
// private Common header files
//
#include "cmdline.h"

#endif    // __PCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\openfiles\handle.cpp ===
/******************************************************************************

  Copyright (C) Microsoft Corporation

  Module Name:
      Handle.CPP 

  Abstract: 
       This module deals with Query functionality of OpenFiles.exe 
       NT command line utility. This module will specifically query open files
       for local system.

  Author:
  
       Akhil Gokhale (akhil.gokhale@wipro.com) 25-APRIL-2000
  
 Revision History:
  
       Akhil Gokhale (akhil.gokhale@wipro.com) 25-APRIL-2000 : Created It.


*****************************************************************************/
#include "pch.h"
#include "OpenFiles.h"
#define MAX_POSSIBLE_DRIVES 26 // maximum possible drives are A,B....Y,Z
#define RTL_NEW( p ) RtlAllocateHeap( RtlProcessHeap(), HEAP_ZERO_MEMORY, sizeof( *p ) )
#define RTL_FREE(p) \
	if(p!=NULL)\
	{\
	RtlFreeHeap( RtlProcessHeap(), 0, p);\
	p = NULL;\
	}\
	1

#define MAX_TYPE_NAMES 128
struct DriveTypeInfo
{
	TCHAR szDrive[4];
	UINT  uiDriveType;
	BOOL  bDrivePresent;
};

BOOLEAN fAnonymousToo;
HANDLE ProcessId;
WCHAR TypeName[ MAX_TYPE_NAMES ];
WCHAR SearchName[ 512 ];
CHAR OutputFileName[ MAX_PATH ];
HANDLE OutputFile;
HKEY hKey;
CONSOLE_SCREEN_BUFFER_INFO screenBufferInfo;
HANDLE hStdHandle;

typedef struct _PROCESS_INFO 
{
    LIST_ENTRY Entry;
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    PSYSTEM_THREAD_INFORMATION ThreadInfo[ 1 ];
} PROCESS_INFO, *PPROCESS_INFO;

LIST_ENTRY ProcessListHead;

PSYSTEM_OBJECTTYPE_INFORMATION ObjectInformation;
PSYSTEM_HANDLE_INFORMATION_EX HandleInformation;
PSYSTEM_PROCESS_INFORMATION ProcessInformation;

typedef struct _TYPE_COUNT 
{
	UNICODE_STRING  TypeName ;
	ULONG           HandleCount ;
} TYPE_COUNT, * PTYPE_COUNT ;


TYPE_COUNT TypeCounts[ MAX_TYPE_NAMES + 1 ] ;

UNICODE_STRING UnknownTypeIndex;

// Local function decleration
PRTL_DEBUG_INFORMATION RtlQuerySystemDebugInformation(void);
BOOLEAN LoadSystemModules(PRTL_DEBUG_INFORMATION Buffer);
BOOLEAN LoadSystemObjects(PRTL_DEBUG_INFORMATION Buffer);
BOOLEAN LoadSystemHandles(PRTL_DEBUG_INFORMATION Buffer);
BOOLEAN LoadSystemProcesses(PRTL_DEBUG_INFORMATION Buffer);
PSYSTEM_PROCESS_INFORMATION FindProcessInfoForCid(IN HANDLE UniqueProcessId);

VOID DumpHandles( DWORD dwFormat,BOOL bShowNoHeader,BOOL bVerbose);
BOOL GetCompleteFileName(LPCTSTR pszSourceFile,LPTSTR pszFinalPath,struct DriveTypeInfo *pdrvInfo,DWORD dwTotalDrives,LPCTSTR pszCurrentDirectory,LPCTSTR pszSystemDirectory,PBOOL pAppendToCache) ;
void FormatFileName(LPTSTR pFileName,DWORD dwFormat,LONG dwColWidth);
void PrintProgressMsg(HANDLE hOutput,LPCWSTR pwszMsg,const CONSOLE_SCREEN_BUFFER_INFO& csbi);
/*****************************************************************************
Routine Description:
   This function will change an ansi string to UNICODE string

Arguments:
    [in]    Source          : Source string
    [out]   Destination     : Destination string 
    [in]    NumberOfChars   : No of character in source string
Return Value: 
   BOOL       TRUE : Successfully conversion
              FALSE: Unsuccessful   
******************************************************************************/

BOOLEAN
AnsiToUnicode(
    LPCSTR Source,
    PWSTR Destination,
    ULONG NumberOfChars
    )
{
    if (NumberOfChars == 0) 
	{
		NumberOfChars = strlen( Source );
	}
    if (MultiByteToWideChar( CP_ACP,
                             MB_PRECOMPOSED,
                             Source,
                             NumberOfChars,
                             Destination,
                             NumberOfChars
                           ) != (LONG)NumberOfChars) 
	{
        SetLastError( ERROR_NO_UNICODE_TRANSLATION );
        return FALSE;
	}
    else 
	{
        Destination[ NumberOfChars ] = UNICODE_NULL;
        return TRUE;
	}
}

/*****************************************************************************
Routine Description:
  Functin gets system registry key.

Arguments:
   none 

Return Value: 
  DWORD  : Registry key value   
******************************************************************************/

DWORD
GetSystemRegistryFlags( VOID )
{
    DWORD cbKey;
    DWORD GFlags;
    DWORD type;

    if (RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                      _T("SYSTEM\\CurrentControlSet\\Control\\Session Manager"),
                      0,
                      KEY_READ | KEY_WRITE,
                      &hKey
                    ) != ERROR_SUCCESS) 
	{
        return 0;
	}

    cbKey = sizeof( GFlags );
    if (RegQueryValueEx( hKey,
                         _T("GlobalFlag"),
                         0,
                         &type,
                         (LPBYTE)&GFlags,
                         &cbKey
                       ) != ERROR_SUCCESS ||type != REG_DWORD) 
	{
        RegCloseKey( hKey );
        return 0;
	}
    return GFlags;
}
/*****************************************************************************
Routine Description:
   Sets system registry Global Flag with given value.

Arguments:
     [in]     GFlags :  Key value

Return Value: 
    BOOLEAN   TRUE: success
              FALSE: FAIL   
******************************************************************************/

BOOLEAN
SetSystemRegistryFlags(
    DWORD GFlags
    )
{
    if (RegSetValueEx( hKey,
                       _T("GlobalFlag"),
                       0,
                       REG_DWORD,
                       (LPBYTE)&GFlags,
                       sizeof( GFlags )
                     ) != ERROR_SUCCESS) 
	{
        RegCloseKey( hKey );
        return FALSE;
	}
    return TRUE;
}

/*****************************************************************************
Routine Description:
   This function will show all locally opened open files.
Arguments:
   [in]  dwFormat      : Format value for output e.g LIST, CSV or TABLE
   [in]  bShowNoHeader : Whether to show header or not.
   [in]  bVerbose      : Verbose ouput or not.
   [in]  bDisableObjectTypeList : To disable object type list;
Return Value: 
   BOOL 
******************************************************************************/
BOOL DoLocalOpenFiles(DWORD dwFormat,BOOL bShowNoHeader,BOOL bVerbose,LPCTSTR pszLocalValue)
{
    char *s;
    NTSTATUS Status;
    PRTL_DEBUG_INFORMATION p;
	DWORD dwRegistryFlags = 0;
	dwRegistryFlags = GetSystemRegistryFlags();
	if(lstrcmpi(pszLocalValue,GetResString(IDS_LOCAL_OFF)) == 0) // disabling the object typelist 
	{
		dwRegistryFlags &= ~FLG_MAINTAIN_OBJECT_TYPELIST;  		
        if (!(NtCurrentPeb()->NtGlobalFlag & FLG_MAINTAIN_OBJECT_TYPELIST))
        {
            ShowMessage(stderr,GetResString(IDS_LOCAL_FLG_ALREADY_RESET));
        }
        else
        {
		    SetSystemRegistryFlags(dwRegistryFlags);
            ShowMessage(stderr,GetResString(IDS_LOCAL_FLG_RESET));
        }
		RegCloseKey( hKey );
		return TRUE;
	}
    else if(lstrcmpi(pszLocalValue,GetResString(IDS_LOCAL_ON)) == 0)
    {
		if (!(NtCurrentPeb()->NtGlobalFlag & FLG_MAINTAIN_OBJECT_TYPELIST))
        {
			// SUNIL: Enabling the OS to maintain the objects list flag
			//        The user help text calls this global flag 'maintain objects list' 
			//        and enables it with "/local" switch.
            SetSystemRegistryFlags( dwRegistryFlags  | FLG_MAINTAIN_OBJECT_TYPELIST );
            ShowMessage(stderr,GetResString(IDS_LOCAL_FLG_SET));
        }
        else
        {
            ShowMessage(stderr,GetResString(IDS_LOCAL_FLG_ALREADY_SET));
        }
        RegCloseKey( hKey );
        return TRUE;
    }
    else if(lstrcmpi(pszLocalValue,L"SHOW_STATUS") == 0)
    {
        dwRegistryFlags &= ~FLG_MAINTAIN_OBJECT_TYPELIST;  		
        if (!(NtCurrentPeb()->NtGlobalFlag & FLG_MAINTAIN_OBJECT_TYPELIST))
        {
            ShowMessage(stderr,GetResString(IDS_LOCAL_FLG_ALREADY_RESET));
        }
        else
        {
		    ShowMessage(stderr,GetResString(IDS_LOCAL_FLG_ALREADY_SET));
        }
		RegCloseKey( hKey );
        return TRUE;
    }
    else // just check for FLG_MAINTAIN_OBJECT_TYPELIST
    {
        if (!(NtCurrentPeb()->NtGlobalFlag & FLG_MAINTAIN_OBJECT_TYPELIST))
	    {
		    RegCloseKey( hKey );
		    ShowMessage(stderr,GetResString(IDS_LOCAL_NEEDS_TO_SET));
            return TRUE;
	    }
    }
    // Not required Reg. key so close it 
    RegCloseKey( hKey );
    hStdHandle = GetStdHandle(STD_ERROR_HANDLE);
    if(hStdHandle!=NULL)
    {
        GetConsoleScreenBufferInfo(hStdHandle,&screenBufferInfo);
    }
    PrintProgressMsg(hStdHandle,GetResString(IDS_WAIT),screenBufferInfo);
    
    OutputFileName[0]='\0';
    OutputFile = INVALID_HANDLE_VALUE;
    ProcessId = NULL;
    fAnonymousToo = FALSE;
       
   AnsiToUnicode(
    "File",
    TypeName,
    4
    );
    p = RtlQuerySystemDebugInformation();
    if (p == NULL) 
	{
        return FALSE;
    }

    Status = STATUS_SUCCESS;
    if (NT_SUCCESS( Status )) 
	{
        DumpHandles(dwFormat,bShowNoHeader,bVerbose);
	}

    if (OutputFile != INVALID_HANDLE_VALUE)
	{
        CloseHandle( OutputFile );
	}
    RtlDestroyQueryDebugBuffer( p );
    return TRUE;
}


/*****************************************************************************
Routine Description:
    Query system for System object, System handles and system process

Arguments:
   none

  result.

Return Value: 
    PRTL_DEBUG_INFORMATION 
******************************************************************************/

PRTL_DEBUG_INFORMATION
RtlQuerySystemDebugInformation( void)
{
    PRTL_DEBUG_INFORMATION Buffer;

    Buffer = (PRTL_DEBUG_INFORMATION)RTL_NEW( Buffer );
    if (Buffer == NULL) 
	{
		RTL_FREE(Buffer);
        return NULL;
	}
    if (!LoadSystemObjects( Buffer )) 
	{
		RTL_FREE(Buffer);
        return NULL;
	}

    if (!LoadSystemHandles( Buffer )) 
	{
		RTL_FREE(Buffer);
        return NULL;
	}

    if (!LoadSystemProcesses( Buffer )) 
	{
		RTL_FREE(Buffer);
        return NULL;
	}
    return Buffer;
}

/*****************************************************************************
Routine Description:
     This routine will reserves or commits a region of pages in the virtual .
   address space of given size.
Arguments:
      [in] Lenght : Size of memory required

  result.

Return Value: 
   PVOID 
******************************************************************************/

PVOID
BufferAlloc(
    IN OUT SIZE_T *Length
    )
{
    PVOID Buffer;
    MEMORY_BASIC_INFORMATION MemoryInformation;

    Buffer = VirtualAlloc( NULL,
                           *Length,
                           MEM_COMMIT,
                           PAGE_READWRITE
                         );
    
    if(Buffer == NULL)
	{
		return NULL;
	}

    if (Buffer != NULL && VirtualQuery( Buffer, &MemoryInformation, sizeof( MemoryInformation ) ) ) 
	{
        *Length = MemoryInformation.RegionSize;
	}
    return Buffer;
}
/*****************************************************************************
Routine Description:
    This routine will free buffer.

Arguments:
    [in] Buffer   : Buffer which is to be freed.

Return Value: 
    none

******************************************************************************/

VOID
BufferFree(
    IN PVOID Buffer
    )
{
    VirtualFree (Buffer,0, MEM_DECOMMIT) ;
	return;
}

/*****************************************************************************
Routine Description:
   Loads the system objects

Arguments:
   [out] Buffer:  returns system objects
  
Return Value: 
   
******************************************************************************/

BOOLEAN
LoadSystemObjects(
    PRTL_DEBUG_INFORMATION Buffer
    )
{
    NTSTATUS Status;
    SYSTEM_OBJECTTYPE_INFORMATION ObjectInfoBuffer;
    SIZE_T RequiredLength, NewLength=0;
    ULONG i;
    PSYSTEM_OBJECTTYPE_INFORMATION TypeInfo;
    DWORD length;

    ObjectInformation = &ObjectInfoBuffer;
    RequiredLength = sizeof( *ObjectInformation );
    while (TRUE) 
	{
        Status = NtQuerySystemInformation( SystemObjectInformation,
                                           ObjectInformation,
                                           (ULONG)RequiredLength,
                                           (ULONG *)&NewLength
                                         );
        if (Status == STATUS_INFO_LENGTH_MISMATCH && NewLength > RequiredLength) 
		{
            if (ObjectInformation != &ObjectInfoBuffer) 
			{
                BufferFree (ObjectInformation);
            }
            RequiredLength = NewLength + 4096;
            ObjectInformation = (PSYSTEM_OBJECTTYPE_INFORMATION)BufferAlloc (&RequiredLength);
            if (ObjectInformation == NULL) 
			{
                return FALSE;
			}
		}
        else if (!NT_SUCCESS( Status )) 
		{
            if (ObjectInformation != &ObjectInfoBuffer) 
			{
                
                BufferFree (ObjectInformation);
            }
            return FALSE;
		}
        else 
		{
			    break;
		}
        
	}
    TypeInfo = ObjectInformation;
    while (TRUE) 
	{
		if (TypeInfo->TypeIndex < MAX_TYPE_NAMES) 
		{
            TypeCounts[ TypeInfo->TypeIndex ].TypeName = TypeInfo->TypeName;
		}

        if (TypeInfo->NextEntryOffset == 0) {
            break;
            }

        TypeInfo = (PSYSTEM_OBJECTTYPE_INFORMATION)
            ((PCHAR)ObjectInformation + TypeInfo->NextEntryOffset);
        }

    RtlInitUnicodeString( &UnknownTypeIndex, L"UnknownTypeIdx" );
    for (i=0; i<=MAX_TYPE_NAMES; i++) 
	{
        if (TypeCounts[ i ].TypeName.Length == 0 ) 
		{
            TypeCounts[ i ].TypeName = UnknownTypeIndex;
		}
	}

    return TRUE;
}

/*****************************************************************************
Routine Description:
   Loads the system handles

Arguments:
   [out] Buffer:  returns system handles

Return Value: 
 BOOLEAN
   
******************************************************************************/

BOOLEAN
LoadSystemHandles(
    PRTL_DEBUG_INFORMATION Buffer
    )
{
    NTSTATUS Status;
    SYSTEM_HANDLE_INFORMATION_EX HandleInfoBuffer;
    SIZE_T RequiredLength, NewLength=0;
    PSYSTEM_OBJECTTYPE_INFORMATION TypeInfo;
    PSYSTEM_OBJECT_INFORMATION ObjectInfo;

    HandleInformation = &HandleInfoBuffer;
    RequiredLength = sizeof( *HandleInformation );
    while (TRUE) 
    {
        Status = NtQuerySystemInformation( SystemExtendedHandleInformation,
                                           HandleInformation,
                                           (ULONG)RequiredLength,
                                           (ULONG *)&NewLength
                                         );

        if (Status == STATUS_INFO_LENGTH_MISMATCH && NewLength > RequiredLength) 
        {
            if (HandleInformation != &HandleInfoBuffer) 
            {
                BufferFree (HandleInformation);
            }

            RequiredLength = NewLength + 4096; // slop, since we may trigger more handle creations.
            HandleInformation = (PSYSTEM_HANDLE_INFORMATION_EX)BufferAlloc( &RequiredLength );
            if (HandleInformation == NULL) 
            {
                return FALSE;
            }
        }
        else if (!NT_SUCCESS( Status )) 
        {
            if (HandleInformation != &HandleInfoBuffer) 
            {
                BufferFree (HandleInformation);
            }
            return FALSE;
        }
        else 
        {
            break;
        }
    }

    TypeInfo = ObjectInformation;
    while (TRUE) 
    {
        ObjectInfo = (PSYSTEM_OBJECT_INFORMATION)
            ((PCHAR)TypeInfo->TypeName.Buffer + TypeInfo->TypeName.MaximumLength);
        while (TRUE) 
        {
            if (ObjectInfo->HandleCount != 0) 
            {
                PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX HandleEntry;
                ULONG HandleNumber;

                HandleEntry = &HandleInformation->Handles[ 0 ];
                HandleNumber = 0;
                while (HandleNumber++ < HandleInformation->NumberOfHandles) 
                {
                    if (!(HandleEntry->HandleAttributes & 0x80) &&
                        HandleEntry->Object == ObjectInfo->Object) 
                    {
                        HandleEntry->Object = ObjectInfo;
                        HandleEntry->HandleAttributes |= 0x80;
                    }
                    HandleEntry++;
                }
            }

            if (ObjectInfo->NextEntryOffset == 0) 
            {
                break;
            }

            ObjectInfo = (PSYSTEM_OBJECT_INFORMATION)
                ((PCHAR)ObjectInformation + ObjectInfo->NextEntryOffset);
        }

        if (TypeInfo->NextEntryOffset == 0) 
        {
            break;
        }

        TypeInfo = (PSYSTEM_OBJECTTYPE_INFORMATION)
            ((PCHAR)ObjectInformation + TypeInfo->NextEntryOffset);
        
    }
    return TRUE;
}
/*****************************************************************************
Routine Description:
     Loads the system process .

Arguments:
    [out] Buffer:   returns sysem process

Return Value: 
   BOOLEAN
******************************************************************************/


BOOLEAN
LoadSystemProcesses(
    PRTL_DEBUG_INFORMATION Buffer
    )
{
    NTSTATUS Status;
    SIZE_T RequiredLength;
    ULONG i, TotalOffset;
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    PSYSTEM_THREAD_INFORMATION ThreadInfo;
    PPROCESS_INFO ProcessEntry;
    CHAR NameBuffer[ MAX_PATH ];
    ANSI_STRING AnsiString;

    //
    //  Always initialize the list head, so that a failed
    //  NtQuerySystemInformation call won't cause an AV later on.
    //
    InitializeListHead( &ProcessListHead );

    RequiredLength = 64 * 1024;
    ProcessInformation = (PSYSTEM_PROCESS_INFORMATION)BufferAlloc( &RequiredLength );
    if (ProcessInformation == NULL) 
    {
        return FALSE;
    }

    while (TRUE) 
    {
        Status = NtQuerySystemInformation( SystemProcessInformation,
                                           ProcessInformation,
                                           (ULONG)RequiredLength,
                                           NULL
                                         );
        if (Status == STATUS_INFO_LENGTH_MISMATCH) 
        {
            if (!VirtualFree( ProcessInformation,
                              RequiredLength,
                              MEM_DECOMMIT
                            )) 
            {
                return FALSE;
            }

            if (RequiredLength * 2 < RequiredLength) 
            {
                //  Very rare loop case, but I want to handle it anyways
                return FALSE;
            }
            RequiredLength = RequiredLength * 2;
            ProcessInformation = (PSYSTEM_PROCESS_INFORMATION)BufferAlloc( &RequiredLength );
            if (ProcessInformation == NULL) 
            {
                return FALSE;
            }
        }
        else if (!NT_SUCCESS( Status )) 
        {
            return FALSE;
        }
        else 
        {
            break;
        }
    }

    ProcessInfo = ProcessInformation;
    TotalOffset = 0;
    while (TRUE) 
    {
        if (ProcessInfo->ImageName.Buffer == NULL) 
        {
            sprintf( NameBuffer, "System Process (%p)", ProcessInfo->UniqueProcessId );
        }
        else 
        {
            sprintf( NameBuffer, "%wZ",
                     &ProcessInfo->ImageName);
        }
        RtlInitAnsiString( &AnsiString, NameBuffer );
        RtlAnsiStringToUnicodeString( &ProcessInfo->ImageName, &AnsiString, TRUE );

        ProcessEntry =(PPROCESS_INFO) RtlAllocateHeap( RtlProcessHeap(),
                                        HEAP_ZERO_MEMORY,
                                        sizeof( *ProcessEntry ) +
                                            (sizeof( ThreadInfo ) * ProcessInfo->NumberOfThreads));
        if (ProcessEntry == NULL) 
        {
            return FALSE;
        }

        InitializeListHead( &ProcessEntry->Entry );
        ProcessEntry->ProcessInfo = ProcessInfo;
        ThreadInfo = (PSYSTEM_THREAD_INFORMATION)(ProcessInfo + 1);
        for (i = 0; i < ProcessInfo->NumberOfThreads; i++) 
        {
            ProcessEntry->ThreadInfo[ i ] = ThreadInfo++;
        }

        InsertTailList( &ProcessListHead, &ProcessEntry->Entry );

        if (ProcessInfo->NextEntryOffset == 0) 
        {
            break;
        }

        TotalOffset += ProcessInfo->NextEntryOffset;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)
            ((PCHAR)ProcessInformation + TotalOffset);
    }
    return TRUE;
}
/*****************************************************************************
Routine Description:
      This routine will get Process information.
Arguments:
    [in] UniqueProcessId = Process ID.

Return Value: 
   PSYSTEM_PROCESS_INFORMATION, Structure which hold information about process
******************************************************************************/

PSYSTEM_PROCESS_INFORMATION
FindProcessInfoForCid(
    IN HANDLE UniqueProcessId
    )
{
    PLIST_ENTRY Next, Head;
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    PPROCESS_INFO ProcessEntry;
    CHAR NameBuffer[ 64 ];
    ANSI_STRING AnsiString;

    Head = &ProcessListHead;
    Next = Head->Flink;
    while (Next != Head) 
    {
        ProcessEntry = CONTAINING_RECORD( Next,
                                          PROCESS_INFO,
                                          Entry
                                        );

        ProcessInfo = ProcessEntry->ProcessInfo;
        if (ProcessInfo->UniqueProcessId == UniqueProcessId) 
        {
            return ProcessInfo;
        }

        Next = Next->Flink;
    }

    ProcessEntry =(PPROCESS_INFO) RtlAllocateHeap( RtlProcessHeap(),
                                    HEAP_ZERO_MEMORY,
                                    sizeof( *ProcessEntry ) +
                                        sizeof( *ProcessInfo )
                                  );
    if (ProcessEntry == NULL) 
    {
        return NULL;
    }
    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)(ProcessEntry+1);

    ProcessEntry->ProcessInfo = ProcessInfo;
    sprintf( NameBuffer, "Unknown Process");
    RtlInitAnsiString( &AnsiString, NameBuffer );
    RtlAnsiStringToUnicodeString( (PUNICODE_STRING)&ProcessInfo->ImageName, &AnsiString, TRUE );
    ProcessInfo->UniqueProcessId = UniqueProcessId;

    InitializeListHead( &ProcessEntry->Entry );
    InsertTailList( &ProcessListHead, &ProcessEntry->Entry );
    return ProcessInfo;
}

/*****************************************************************************
Routine Description:
    This function will show result.

Arguments:
   [in]  dwFormat      : Format value for output e.g LIST, CSV or TABLE
   [in]  bShowNoHeader : Whether to show header or not.
   [in]  bVerbose      : Verbose ouput or not.

Return Value: 
    void
   
******************************************************************************/

VOID
DumpHandles( DWORD dwFormat,BOOL bShowNoHeader,BOOL bVerbose)
{
    HANDLE PreviousUniqueProcessId;
    PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX HandleEntry;
    ULONG HandleNumber;
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    PSYSTEM_OBJECT_INFORMATION ObjectInfo;
    PUNICODE_STRING ObjectTypeName;
    WCHAR ObjectName[ MAX_RES_STRING ];
    PVOID Object;
    CHAR OutputLine[ MAX_RES_STRING];
    CHString szFileType;
    PWSTR s;
    ULONG n;
    DWORD dwRow = 0; // no of rows
	DWORD dwAvailableLogivalDrives = 0; // Stores avalable logical drives info.
	TCHAR szWorkingDirectory[MAX_PATH+1] = NULL_STRING; // stores working directory.
	TCHAR szSystemDirectory[MAX_PATH+1]  = NULL_STRING; // Stores the System (Active OS) directory
	struct DriveTypeInfo drvInfo[MAX_POSSIBLE_DRIVES];
	DWORD dwNoOfAvailableDrives = 0; // Stores no. of available drives
	TCHAR cDriveLater = 65; // "A" is First available driveDrive
    DWORD dwDriveMaskPattern = 1; // "A" is First available driveDrive
	                             // so mask pattern is 
	                             // 0xFFF1
	// variable used for _splitpath function...
	TCHAR szDrive[_MAX_DRIVE] = NULL_STRING;
	TCHAR szDir[_MAX_DIR]= NULL_STRING;
	TCHAR szFname[_MAX_FNAME]= NULL_STRING;
	TCHAR szExt[_MAX_EXT]= NULL_STRING;

    TCHAR szTemp[MAX_RES_STRING*2]=NULL_STRING;
	TCHAR szCompleteFileName[MAX_PATH] = NULL_STRING;
    DWORD dwHandle = 0;
    BOOL  bAtLeastOne = FALSE;
	DWORD dwIndx = 0; // variable used for indexing
	
    TCHAR szFileSystemNameBuffer[MAX_PATH+1] = NULL_STRING;
    TCHAR szVolName[MAX_PATH+1] = NULL_STRING;
    DWORD dwVolumeSerialNumber = 0;
    DWORD dwSerialNumber = 0;
    DWORD dwFileSystemFlags = 0;
    DWORD dwMaximumCompenentLength = 0;
    BOOL  bReturn = FALSE;
    DWORD dwNoOfElements = 0;

    DWORD dwIteration = 0;
    BY_HANDLE_FILE_INFORMATION byHandleFileInfo;
    DWORD dwFileAttributes;

    BOOL   bAppendToCache = FALSE;
    //Some column required to hide in non verbose mode query
    DWORD  dwMask = bVerbose?SR_TYPE_STRING:SR_HIDECOLUMN|SR_TYPE_STRING;

    TCOLUMNS pMainCols[]=
    {
        {NULL_STRING,COL_L_ID,SR_TYPE_STRING,NULL_STRING,NULL,NULL},
        {NULL_STRING,COL_L_TYPE,SR_HIDECOLUMN,NULL_STRING,NULL,NULL}, 
        {NULL_STRING,COL_L_ACCESSED_BY,dwMask,NULL_STRING,NULL,NULL},
        {NULL_STRING,COL_L_PROCESS_NAME,SR_TYPE_STRING,NULL_STRING,NULL,NULL},
        {NULL_STRING,COL_L_OPEN_FILENAME,SR_TYPE_STRING|(SR_NO_TRUNCATION&~(SR_WORDWRAP)),NULL_STRING,NULL,NULL}
    };
    
    LPTSTR  pszAccessedby = new TCHAR[MAX_RES_STRING*2];
    if(pszAccessedby==NULL)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        DISPLAY_MESSAGE(stderr,GetResString(IDS_ID_SHOW_ERROR));
        ShowLastError(stderr);
        return;
    }
    
    TARRAY pColData  = CreateDynamicArray();//array to stores 
                                            //result          
    if((pColData == NULL))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        DISPLAY_MESSAGE(stderr,GetResString(IDS_ID_SHOW_ERROR));
        ShowLastError(stderr);
        SAFEDELETE(pszAccessedby);
        return;
    }

    TARRAY pCacheData  = CreateDynamicArray();//array to stores 
    
    if(pCacheData == NULL)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        DISPLAY_MESSAGE(stderr,GetResString(IDS_ID_SHOW_ERROR));
        ShowLastError(stderr);
        SAFERELDYNARRAY(pColData);
		SAFERELDYNARRAY(pCacheData);
        SAFEDELETE(pszAccessedby);
        return;
    }
    
    lstrcpy(pMainCols[LOF_ID].szColumn,GetResString(IDS_STRING_ID));
    lstrcpy(pMainCols[LOF_TYPE].szColumn,GetResString(IDS_FILE_TYPE));
    lstrcpy(pMainCols[LOF_ACCESSED_BY].szColumn,GetResString(IDS_STRING_ACCESSED_BY) );
    lstrcpy(pMainCols[LOF_PROCESS_NAME].szColumn,GetResString(IDS_STRING_PROCESS_NAME));
    lstrcpy(pMainCols[LOF_OPEN_FILENAME].szColumn,GetResString(IDS_STRING_OPEN_FILE) );
    
	dwAvailableLogivalDrives = GetLogicalDrives(); // Get logical drives.
	// Store current working direcory.
	_wgetcwd(szWorkingDirectory,MAX_PATH);

	// Get System Active (OS) directory
	if(GetSystemDirectory(szSystemDirectory,MAX_PATH)==NULL)
    {
		DISPLAY_MESSAGE(stderr,GetResString(IDS_ID_SHOW_ERROR));
		ShowLastError(stderr); // Shows the error string set by API function.
        SAFERELDYNARRAY(pColData);
		SAFERELDYNARRAY(pCacheData);
        SAFEDELETE(pszAccessedby);
		return ;
    }
    
	// Check each drive and set its info.
	for(dwIndx=0;dwIndx<MAX_POSSIBLE_DRIVES;dwIndx++,cDriveLater++)
	{
		// dwAvailableLogivalDrives contains drive information in bit wise
		// 0000 0000 0000 0000 0000 01101  means A C and D drives are 
		// logical drives. 
		if(dwAvailableLogivalDrives & dwDriveMaskPattern)
		{
			// means we catch a drive latter.
			// copy drive latter (line c:\ or a: for example).
			wsprintf(drvInfo[dwNoOfAvailableDrives].szDrive,_T("%c:"),cDriveLater);
            // Check type of the drive .
            drvInfo[dwNoOfAvailableDrives].uiDriveType = GetDriveType(drvInfo[dwNoOfAvailableDrives].szDrive);
			// Check if drive is ready or not.
            wsprintf(szTemp,_T("%s\\"),drvInfo[dwNoOfAvailableDrives].szDrive);
   		    bReturn = GetVolumeInformation((LPCWSTR)szTemp,
				                           szVolName, 
					                       MAX_PATH,
				                           &dwVolumeSerialNumber,
										   &dwMaximumCompenentLength,
										   &dwFileSystemFlags,
										   szFileSystemNameBuffer,
		    							   MAX_PATH); 
		   drvInfo[dwNoOfAvailableDrives].bDrivePresent = bReturn;
		   dwNoOfAvailableDrives++;
		}
        dwDriveMaskPattern = dwDriveMaskPattern << 1; // Left shift 1 
	}
    HandleEntry = &HandleInformation->Handles[ 0 ];
    HandleNumber = 0;
    PreviousUniqueProcessId = INVALID_HANDLE_VALUE;
    for (HandleNumber = 0;HandleNumber < HandleInformation->NumberOfHandles;HandleNumber++, HandleEntry++) 
	{
            if (PreviousUniqueProcessId != (HANDLE)HandleEntry->UniqueProcessId) 
			{
                PreviousUniqueProcessId = (HANDLE)HandleEntry->UniqueProcessId;
                ProcessInfo = FindProcessInfoForCid( PreviousUniqueProcessId );
                
			}

            ObjectName[ 0 ] = UNICODE_NULL;
            if (HandleEntry->HandleAttributes & 0x80)
            {
                ObjectInfo = (PSYSTEM_OBJECT_INFORMATION)HandleEntry->Object;
                Object = ObjectInfo->Object;
                if (ObjectInfo->NameInfo.Name.Length != 0 &&
                    *(ObjectInfo->NameInfo.Name.Buffer) == UNICODE_NULL) 
                {
                    ObjectInfo->NameInfo.Name.Length = 0;
                    
                }
                n = ObjectInfo->NameInfo.Name.Length / sizeof( WCHAR );
                if(ObjectInfo->NameInfo.Name.Buffer != NULL)
                {
                    wcsncpy( ObjectName,
                             ObjectInfo->NameInfo.Name.Buffer,
                             n
                           );
                    ObjectName[ n ] = UNICODE_NULL;
                }
                else
                {
                      ObjectName[ 0 ] = UNICODE_NULL;
                }
            }
            else 
            {
                ObjectInfo = NULL;
                Object = HandleEntry->Object;
            }

            if (ProcessId != 0 && ProcessInfo->UniqueProcessId != ProcessId) 
            {
                continue;
            }

            ObjectTypeName = &TypeCounts[ HandleEntry->ObjectTypeIndex < MAX_TYPE_NAMES ?
                                                HandleEntry->ObjectTypeIndex : MAX_TYPE_NAMES ].TypeName ;

            TypeCounts[ HandleEntry->ObjectTypeIndex < MAX_TYPE_NAMES ?
                            HandleEntry->ObjectTypeIndex : MAX_TYPE_NAMES ].HandleCount++ ;

            if (TypeName[0]) 
            {
                if (_wcsicmp( TypeName, ObjectTypeName->Buffer )) 
                {
                    continue;
                }
            }

            if (!*ObjectName) 
            {
                if (!fAnonymousToo) 
                {
                    continue;
                }
            }
            else if (SearchName[0]) 
            {
                if (!wcsstr( ObjectName, SearchName )) 
                {
                    s = ObjectName;
                    n = wcslen( SearchName );
                    while (*s) 
                    {
                        if (!_wcsnicmp( s, SearchName, n )) 
                        {
                            break;
                        }
                        s += 1;
                    }
                    if (!*s) 
                    {
                        continue;
                    }
                }
            }
			dwHandle = PtrToUlong( ProcessInfo->UniqueProcessId ); //HandleEntry->HandleValue;

			// SUNIL: Blocking the display of files that were opened by system accounts ( NT AUTHORITY )
			// if( bVerbose == TRUE )
			// {
				if ( GetProcessOwner( pszAccessedby, dwHandle ) == FALSE )
					continue;// As user is "SYSTEM" related....
			// }
            
			// Get File name ..
			wsprintf(szTemp,_T("%ws"),*ObjectName ? ObjectName : L"");
            // Search this file in cache, if it is there skip this file
            // for further processing. As this is already processed and 
            // was found invalid.
			if(IsValidArray(pCacheData) == TRUE)
			{
				if ( DynArrayFindString( pCacheData, szTemp, TRUE, 0 ) != -1 )
					continue;
			}
			lstrcpy( szCompleteFileName, _T( "" ) );
            if(GetCompleteFileName(szTemp,szCompleteFileName,&drvInfo[0],dwNoOfAvailableDrives,szWorkingDirectory,szSystemDirectory,&bAppendToCache) == FALSE)
			{
			    if(bAppendToCache == TRUE) // szTemp contains a directory which is not physicaly exist
					                       // so add this to cache to skip it in future for checking
										   // of its existance
				{
					
				  if(IsValidArray(pCacheData) == TRUE)
				  {
				     // dwNoOfElements = DynArrayGetCount( pCacheData );
					  DynArrayAppendString(pCacheData, (LPCWSTR)szTemp,0); 
				  }
				}
				continue;
			}
            // Now fill the result to dynamic array "pColData"
            DynArrayAppendRow( pColData, 0 ); 
            // File id
            wsprintf(szTemp,_T("%ld"),HandleEntry->HandleValue);
            DynArrayAppendString2(pColData ,dwRow,szTemp,0); 
            // Type
            DynArrayAppendString2(pColData ,dwRow,(LPCWSTR)szFileType,0); 
            // Accessed by
            DynArrayAppendString2(pColData,dwRow,pszAccessedby,0); 
            // Process Name 
           sprintf(OutputLine,"%wZ",&ProcessInfo->ImageName);
           GetCompatibleStringFromMultiByte(OutputLine,szTemp,MAX_RES_STRING);
           DynArrayAppendString2(pColData ,dwRow,szTemp,0); 
          
           if(bVerbose == FALSE) // Formate file name only in non verbose mode.
		   {
		     FormatFileName(szCompleteFileName,dwFormat,COL_L_OPEN_FILENAME);
		   }
            // Open File name
            DynArrayAppendString2(pColData ,dwRow,szCompleteFileName,0); 
            dwRow++;
            bAtLeastOne = TRUE;

        }
    // Display output result.
    //Output should start after one blank line
    PrintProgressMsg(hStdHandle,NULL_STRING,screenBufferInfo);
    if(bShowNoHeader==TRUE)
    {
          dwFormat |=SR_NOHEADER;
    }
    if(bVerbose == TRUE)
    {
        pMainCols[LOF_OPEN_FILENAME].dwWidth = 80;
    }
    if(bAtLeastOne==FALSE)// if not a single open file found, show info 
                          // as -  INFO: No open file found.  
    {
        ShowMessage(stdout,GetResString(IDS_NO_OPENFILES));
    }
    else
    {
        ShowMessage(stdout,GetResString(IDS_LOCAL_OPEN_FILES));
        ShowMessage(stdout,GetResString(IDS_LOCAL_OPEN_FILES_SP1));
        ShowResults(NO_OF_COL_LOCAL_OPENFILE,pMainCols,dwFormat,pColData); 
    }
    SAFERELDYNARRAY(pColData);
	SAFERELDYNARRAY(pCacheData);
    SAFEDELETE(pszAccessedby);
    return;
}
/*****************************************************************************
Routine Description:
      Prints the message on console.
Arguments:
    [in] hOutput = Handle value for console.
    [in] pwszMsg = Message to be printed.
    [in] csbi    = Coordinates of console from where message will print.

Return Value: 
    none
   
******************************************************************************/

void PrintProgressMsg(HANDLE hOutput,LPCWSTR pwszMsg,const CONSOLE_SCREEN_BUFFER_INFO& csbi)
{
    COORD coord;
    DWORD dwSize = 0;
    WCHAR wszSpaces[80] = L"";

    if(hOutput == NULL)
        return;

    coord.X = 0;
    coord.Y = csbi.dwCursorPosition.Y;

    ZeroMemory(wszSpaces,80);
    SetConsoleCursorPosition(hOutput,coord);
    WriteConsoleW(hOutput,Replicate(wszSpaces,L"",79),79,&dwSize,NULL);

    SetConsoleCursorPosition(hOutput,coord);

    if(pwszMsg!=NULL)
        WriteConsoleW(hOutput,pwszMsg,lstrlen(pwszMsg),&dwSize,NULL);

    return;
}

/*****************************************************************************
Routine Description:
     This function will accept a path (with out drive letter), and returns
     the path with drive letter.
Arguments:
   [in]  pszSourceFile       = Source path
   [out] pszFinalPath        = Final path
   [in]  DriveTypeInfo       = Logical drive information structure pointer
   [in]  pszCurrentDirectory = Current woking directory path
   [in]  pszSystemDirectory  = Current Active (OS) System directory
   [out] pAppendToCache      = whether to pszSourceFile to cache 

Return Value: 
   BOOL:  TRUE:    if fuction successfuly returns pszFinalPath
          FALSE:   otherwise
******************************************************************************/
BOOL GetCompleteFileName(LPCTSTR pszSourceFile,LPTSTR pszFinalPath,struct DriveTypeInfo *pdrvInfo,DWORD dwTotalDrives,LPCTSTR pszCurrentDirectory,LPCTSTR pszSystemDirectory,PBOOL pAppendToCache) 
{

   /////////////////////////////////////////////////////////////////////////////////////////////////////////////
   //                  ALGORITHM USED 
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // Following is the procedure for getting full path name ..
  // 1. First check if the first character in pszSourceFile is '\' .
  // 2. If first character of pszSourceFile is '\' then check for the second character...
  // 3. If second character is ';' then than take 3 rd character as drive letter and 
  //    find rest of string for 3rd "\" (Or 4th from first). String after 3rd character 
  //    will be final path. for example let the source string is 
  //    \;Z:00000000000774c8\sanny\c$\nt\base\fs\utils\OpenFiles\Changed\obj\i386
  //    then final path is z:\nt\base\fs\utils\OpenFiles\Changed\obj\i386
  // 4. If second character is not ';' then try to find pszSourceFile for its existance 
  //	 by first prefixing the available drive letter one by one. The first occurence 
  //     of file existance will be the final valid path. Appending of file letter has
 //      a rule. First append FIXED DRIVES then try to append MOVABLE DRIVES.
 //     
 //       Here there is a known limitation. Let there exists two files with same name like...   
 //        c:\document\abc.doc and d:\documet\abc.doc and actual file opened is d:\documet\abc.doc
 //       then this will show final path as c:\documet\abc.doc as it starts with A:....Z:(also preference
 //	      will be given to FIXED TYPE DRIVE).
//   5.  If first character is not '\' then prefix Current working directory path to file name. 
//       and check it for its existance. IF this not exits then search this path by prefixing 
//       logical drive letter to it. 
 ///////////////////////////////////////////////////////////////////////////////////////////////////////
   
   CHString szTemp(pszSourceFile); // Temp string
   DWORD dwTemp = 0;// Temp variable
   LONG lTemp = 0;
   LONG lCount = 0;
   TCHAR  szTempStr[MAX_PATH+1] = NULL_STRING;
   HANDLE hHandle = NULL;
   DWORD  dwFoundCount = 0;
   WIN32_FIND_DATA win32FindData; // data buffer for FindFirstFile function.
   DriveTypeInfo *pHeadPosition = pdrvInfo; // Hold the head position.
   *pAppendToCache = FALSE; // Make it false by default.
   // check if first character is '\'
   TCHAR szSystemDrive[5] = NULL_STRING;
    lstrcpyn(szSystemDrive,pszSystemDirectory,3); // First two character will be system drive (a:).
	if(pszSourceFile[0] == _T('\\'))
	{
		// Check if second character if it is ';'
		if(pszSourceFile[1] == ';')
		{
     	   pszFinalPath[0] = pszSourceFile[2]; // make 3rd character as drive letter
           pszFinalPath[1]  = ':'; // make 2nd character ':'
		   pszFinalPath[2]  = '\0'; // make 3nd character NULL
		   dwFoundCount = 0;
		   for (lTemp = 0;lTemp <5;lTemp++) // search for 3rd '\'
		   {
               lCount = szTemp.Find(_T("\\"));
			   if(lCount!=-1) 
			   {
                   dwFoundCount++;
				   if(dwFoundCount == 4 )// this should always (if any)after 4rd character from start
				   {
					   lstrcat(pszFinalPath,(LPCWSTR)szTemp.Mid(lCount));
					   return TRUE;
				   }
				   szTemp = szTemp.Mid(lCount+1);
				   continue;
			   }
			   *pAppendToCache = TRUE;
			   return FALSE;
		   }
		}
		else
		{
			
			// check first of all for system drive
		   szTemp = szSystemDrive;
		   szTemp+=pszSourceFile;
		   // now check for its existance....
		   hHandle = FindFirstFile((LPCWSTR)szTemp,&win32FindData);
		   if(hHandle != INVALID_HANDLE_VALUE)
		   {
			   FindClose(hHandle); // closed opened find handle
			   lstrcpy(pszFinalPath,(LPCWSTR)szTemp);
			   return TRUE;
		   }
			// check file for each  FIXED drive
			for (dwTemp=0;dwTemp<dwTotalDrives;dwTemp++,pdrvInfo++)
			{
				if(lstrcmpi(szSystemDrive,pdrvInfo->szDrive) == 0)
					continue; // as system drive is already checked
				if(pdrvInfo->uiDriveType == DRIVE_FIXED)
				{
				   szTemp = pdrvInfo->szDrive;
				   szTemp+=pszSourceFile;
				   // now check for its existance....
				   hHandle = FindFirstFile((LPCWSTR)szTemp,&win32FindData);
				   if(hHandle == INVALID_HANDLE_VALUE)
				   {
					   continue;
				   }
				   else
				   {
					   FindClose(hHandle); // closed opened find handle
					   lstrcpy(pszFinalPath,(LPCWSTR)szTemp);
					   return TRUE;
				   }

				} // end if
			} // End for loop
			pdrvInfo = pHeadPosition ; // retore original position.
			// check file for other drive which is present...
			for (dwTemp=0;dwTemp<dwTotalDrives;dwTemp++,pdrvInfo++)
			{
				// Check for NON_FIXED drive only if it is physicaly present
                if((pdrvInfo->uiDriveType != DRIVE_FIXED) && (pdrvInfo->bDrivePresent == TRUE))
				{
				   szTemp = pdrvInfo->szDrive;
				   szTemp+=pszSourceFile;
				   // now check for its existance....
				   hHandle = FindFirstFile((LPCWSTR)szTemp,&win32FindData);
				   if(hHandle == INVALID_HANDLE_VALUE)
				   {
					   continue;
				   }
				   else
				   {
					   FindClose(hHandle); // closed opened find handle
					   lstrcpy(pszFinalPath,(LPCWSTR)szTemp);
					   return TRUE;
				   }

				} // end if
			} // End for loop

			// Now try if file is opend on remote system without 
			// having drive map. in this we are assuming that file name 
			// is containing atleast 3 '\' characters. 
			szTemp = pszSourceFile;
      	    pszFinalPath[0] = '\\'; // make 3rd character '\'
            pszFinalPath[1]  = '\0'; // make 2nd character '\o'
			dwFoundCount = 0;
		   for (lTemp = 0;lTemp <4;lTemp++) // search for 3rd '\'
		   {
               lCount = szTemp.Find(_T("\\"));
			   if(lCount!=-1) 
			   {
				   szTemp = szTemp.Mid(lCount+1);
				   dwFoundCount++;
			   }
			   else
			   {
				   break;
			   }
    		   if (dwFoundCount == 3)
			   {
				    lstrcat(pszFinalPath,pszSourceFile);
                    // Now try to check its physical existance 
					hHandle = FindFirstFile(pszFinalPath,&win32FindData);

					if(hHandle == INVALID_HANDLE_VALUE)
					{
						// Now try to append \* to it...(this will check if
						// if pszFinalPath is a directory or not)
						lstrcpy(szTempStr,pszFinalPath);
						lstrcat(szTempStr,L"\\*");
						hHandle = FindFirstFile(szTempStr,&win32FindData);

						if(hHandle == INVALID_HANDLE_VALUE)
						{
							// now its sure this is not a valid directory or file
							// so append it to chache 
							*pAppendToCache = TRUE;
							return FALSE;

						}
                        FindClose(hHandle);
						return TRUE;
					}
					FindClose(hHandle);
				    return TRUE;
			   }
		   } // End for
		}// End else
	} // end if
    else // means string not started with '\'
	{

		lstrcpy(pszFinalPath,pszCurrentDirectory);
		lstrcat(pszFinalPath,L"\\");
		lstrcat(pszFinalPath,pszSourceFile);
	   hHandle = FindFirstFile((LPCWSTR)szTemp,&win32FindData);
	   if(hHandle != INVALID_HANDLE_VALUE)
	   {
		   FindClose(hHandle); // closed opened find handle
		   return TRUE;
		   
	   }
    	// check first of all for system drive
	   szTemp = szSystemDrive;
	   szTemp+=pszSourceFile;
	   // now check for its existance....
	   hHandle = FindFirstFile((LPCWSTR)szTemp,&win32FindData);
	   if(hHandle != INVALID_HANDLE_VALUE)
	   {
		   FindClose(hHandle); // closed opened find handle
		   lstrcpy(pszFinalPath,(LPCWSTR)szTemp);
		   return TRUE;
	   }
	   // restores the head position for the pointer.
      pdrvInfo = pHeadPosition ;
	// check file for each  FIXED drive
		for (dwTemp=0;dwTemp<dwTotalDrives;dwTemp++,pdrvInfo++)
		{
			if(lstrcmpi(szSystemDrive,pdrvInfo->szDrive) == 0)
				continue; // as system drive is already checked

			if(pdrvInfo->uiDriveType == DRIVE_FIXED)
			{
			   szTemp = pdrvInfo->szDrive;
			   szTemp += L"\\"; // append \ 
			   szTemp+=pszSourceFile;
			   // now check for its existance....
			   hHandle = FindFirstFile((LPCWSTR)szTemp,&win32FindData);

			   if(hHandle == INVALID_HANDLE_VALUE)
			   {
				   continue;
			   }
			   else
			   {
				   FindClose(hHandle); // closed opened find handle
				   lstrcpy(pszFinalPath,(LPCWSTR)szTemp);
				   return TRUE;
			   }
			} // end if
		} // End for loop
		pdrvInfo = pHeadPosition ; // retore original position.

		// check file for other drive (Like Floppy or CD-ROM etc. ) which is present...
		for (dwTemp=0;dwTemp<dwTotalDrives;dwTemp++,pdrvInfo++)
		{
			if((pdrvInfo->uiDriveType != DRIVE_FIXED) && (pdrvInfo->bDrivePresent == TRUE))
			{
			   szTemp = pdrvInfo->szDrive;
			   szTemp += L"\\"; // append '\'
			   szTemp+=pszSourceFile;
			   // now check for its existance....
			   hHandle = FindFirstFile((LPCWSTR)szTemp,&win32FindData);
			   if(hHandle == INVALID_HANDLE_VALUE)
			   {
				   continue;
			   }
			   else
			   {
				   FindClose(hHandle); // closed opened find handle
				   lstrcpy(pszFinalPath,(LPCWSTR)szTemp);
				   return TRUE;
			   }
			} // end if
		} // End for loop
	}
    *pAppendToCache = TRUE;
	return FALSE;
}
/*****************************************************************************
Routine Description:
     This routine will format the pFileName according to column width
     
Arguments:
  [in/out]  pFileName  :  path to be formatted
  [in]      dwFormat   :  Format given
  [in]      dwColWidth :  Column width 
Return Value: 
    none
******************************************************************************/

void FormatFileName(LPTSTR pFileName,DWORD dwFormat,LONG dwColWidth)
{
    CHString szCHString(pFileName);
	if((szCHString.GetLength()>(dwColWidth))&&
		(dwFormat == SR_FORMAT_TABLE))
	{
        // If file path is too big to fit in column width
        // then it is cut like..
        // c:\..\rest_of_the_path.
        CHString szTemp = szCHString.Right(dwColWidth-6);;
		DWORD dwTemp = szTemp.GetLength();
		szTemp = szTemp.Mid(szTemp.Find(SINGLE_SLASH),
                           dwTemp);
        szCHString.Format(L"%s%s%s",szCHString.Mid(0,3),
                                    DOT_DOT,
                                    szTemp);
	}
	lstrcpy(pFileName,(LPCWSTR)szCHString);
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\openfiles\query.h ===
// *********************************************************************************
// 
//  Copyright (c) Microsoft Corporation
//  
//  Module Name:
//
//		Query.h  
//  
//  Abstract:
//  
//		macros and function prototypes of Query.cpp
//  
//  Author:
//  
// 	  Akhil Gokhale (akhil.gokhale@wipro.com) 1-Nov-2000
//  
//  Revision History:
//  
// 	  Akhil Gokhale (akhil.gokhale@wipro.com) 1-Nov-2000 : Created It.
//  
// *********************************************************************************

#ifndef _QUERY_H
#define _QUERY_H
#include "openfiles.h"
#define COL_WIDTH_HOSTNAME          15
#define COL_WIDTH_ID                8
#define COL_WIDTH_ACCESSED_BY       20
#define COL_WIDTH_TYPE              10
#define COL_WIDTH_LOCK              10    
#define COL_WIDTH_OPEN_MODE         15
#define COL_WIDTH_OPEN_FILE         36

#define MAX_OUTPUT_COLUMN            7 

#define COL_HOSTNAME        GetResString(IDS_STRING_HOSTNAME)
#define COL_ID              GetResString(IDS_STRING_ID)
#define COL_ACCESSED_BY     GetResString(IDS_STRING_ACCESSED_BY)
#define COL_TYPE            GetResString(IDS_STRING_TYPE)
#define COL_LOCK            GetResString(IDS_STRING_LOCK)
#define COL_OPEN_MODE       GetResString(IDS_STRING_OPEN_MODE)
#define COL_OPEN_FILE       GetResString(IDS_STRING_OPEN_FILE)

#define MAC_OS              GetResString(IDS_MAC_OS)
 

#define RV_ERROR_C_CPP_FUNCTIONS  -1



BOOL QueryOpenFiles(LONG argc,
                    LPCTSTR argv[]);
BOOL DoQuery(PTCHAR pszServer,
             BOOL bShowNoHeader,
			 PTCHAR pszFormat,
			 BOOL bVerbose);
BOOL GetHostName(PTCHAR pszServer);
BOOL GetHostNameFromFQDN(LPTSTR pszServer);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\print\sources.inc ===
!IF 0

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    sources.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

USE_MSVCRT=1

TARGETNAME=print
TARGETPATH=obj
TARGETTYPE=PROGRAM

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\print.cxx ..\print.rc

INCLUDES=..\.;..\..\ulib\inc

!IF "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "ntsd"
!IFDEF NOMEMLEAK
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DUNICODE=1
!ELSE
!IFDEF STACK_TRACE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DSTACK_TRACE -DUNICODE=1
!ELSE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DUNICODE=1
!ENDIF
!ENDIF
!ELSE    # NTDEBUG
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=0 -DUNICODE=1
!ENDIF   # NTDEBUG

TARGETLIBS=..\..\ulib\src\$(ALT_PROJECT)\$(O)\ulib.lib $(SDK_LIB_PATH)\ntdll.lib

UMTYPE=console

W32_SB=1
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\pentbug\makefile.inc ===
pbmsg.rc: msg00001.bin

pbmsg.h msg00001.bin: pbmsg.mc
    mc -v -h .\ pbmsg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\print\print.cxx ===
/*++

Copyright (c) 1991-2000  Microsoft Corporation

Module Name:

        print.cxx

Abstract:


Author:

        Jaime F. Sasson - jaimes - 14-Jun-1991

Environment:

        ULIB, User Mode

--*/

#include "ulib.hxx"
#include "arg.hxx"
#include "path.hxx"
#include "wstring.hxx"
#include "system.hxx"
#include "array.hxx"
#include "arrayit.hxx"
#include "smsg.hxx"
#include "stream.hxx"
#include "rtmsg.h"
#include "prtstrm.hxx"
#include "file.hxx"
#include "print.hxx"

extern "C" {
#include <stdio.h>
#include <string.h>
}

PSTREAM Get_Standard_Input_Stream();
PSTREAM Get_Standard_Output_Stream();

DEFINE_CONSTRUCTOR( PRINT, PROGRAM );


BOOLEAN
PRINT::Initialize(
        )

/*++

Routine Description:

        Initializes a PRINT class.

Arguments:

        None.

Return Value:

        BOOLEAN - Indicates if the initialization succeeded.


--*/


{
        ARGUMENT_LEXEMIZER      ArgLex;
        ARRAY                           LexArray;

        ARRAY                           ArgumentArray;
        FLAG_ARGUMENT           FlagDisplayHelp;

        STRING_ARGUMENT         ProgramNameArgument;
        PWSTRING                        InvalidArgument;

        PATH_ARGUMENT           DeviceArgument;
        PPATH                           DevicePath;
        PCWSTRING                       DeviceString;
        PPATH                           FilePath;
        PCWSTRING                       FileString;
        PARRAY                          PathArray;
        PARRAY_ITERATOR         PathArrayIterator;
        PFSN_FILE                       FsnFile;


        _StandardOutput = Get_Standard_Output_Stream();

        if (_StandardOutput == NULL) {
            DebugPrint("PRINT: Out of memory\n");
            return FALSE;
        }

        //
        // Initialize MESSAGE class
        //
        _Message.Initialize( _StandardOutput, Get_Standard_Input_Stream() );

        //
        //      Parse command line
        //
        if ( !LexArray.Initialize() ) {
                DebugAbort( "LexArray.Initialize() failed \n" );
                return( FALSE );
    }
        if ( !ArgLex.Initialize( &LexArray ) ) {
                DebugAbort( "ArgLex.Initialize() failed \n" );
                return( FALSE );
    }
        ArgLex.PutSwitches( "/" );
        ArgLex.SetCaseSensitive( FALSE );
        ArgLex.PutStartQuotes( "\"" );
        ArgLex.PutEndQuotes( "\"" );

        if( !ArgLex.PrepareToParse() ) {
                DebugAbort( "ArgLex.PrepareToParse() failed \n" );
                return( FALSE );
        }
        if ( !ArgumentArray.Initialize() ) {
                DebugAbort( "ArgumentArray.Initialize() failed \n" );
                return( FALSE );
        }
        if( !ProgramNameArgument.Initialize("*") ||
                !DeviceArgument.Initialize( "/D:*" ) ||
                !_BufferSize.Initialize( "/B:*" ) ||
                !_Ticks1.Initialize( "/U:*" ) ||
                !_Ticks2.Initialize( "/M:*" ) ||
                !_Ticks3.Initialize( "/S:*" ) ||
                !_NumberOfFiles.Initialize( "/Q:*" ) ||
                !_FlagRemoveFiles.Initialize( "/T" ) ||
                !_Files.Initialize( "*", FALSE, TRUE ) ||
                !_FlagCancelPrinting.Initialize( "/C" ) ||
                !_FlagAddFiles.Initialize( "/P" ) ||
                !FlagDisplayHelp.Initialize( "/?" ) ) {
                DebugAbort( "Unable to initialize flag or string arguments \n" );
                return( FALSE );
        }
        if( !ArgumentArray.Put( &ProgramNameArgument ) ||
                !ArgumentArray.Put( &DeviceArgument ) ||
                !ArgumentArray.Put( &_BufferSize ) ||
                !ArgumentArray.Put( &_Ticks1 ) ||
                !ArgumentArray.Put( &_Ticks2 ) ||
                !ArgumentArray.Put( &_Ticks3 ) ||
                !ArgumentArray.Put( &_NumberOfFiles ) ||
                !ArgumentArray.Put( &_FlagRemoveFiles ) ||
                !ArgumentArray.Put( &_Files ) ||
                !ArgumentArray.Put( &_FlagCancelPrinting ) ||
                !ArgumentArray.Put( &_FlagAddFiles ) ||
                !ArgumentArray.Put( &FlagDisplayHelp ) ) {
                DebugAbort( "ArgumentArray.Put() failed \n" );
                return( FALSE );
        }
        if( !ArgLex.DoParsing( &ArgumentArray ) ) {
                InvalidArgument = ArgLex.QueryInvalidArgument();
                DebugPtrAssert( InvalidArgument );
                _Message.Set( MSG_PRINT_INVALID_SWITCH );
                _Message.Display( "%W", InvalidArgument );
                return( FALSE );
        }

        //
        //      /B: /U: /M: /S: /Q: /T: /C: and /P: are not implemented
        //      if one of these arguments was found in the command line
        //      then inform user, and don't print anything
        //
        if( _BufferSize.IsValueSet() ) {
                _Message.Set( MSG_PRINT_NOT_IMPLEMENTED );
                _Message.Display( "%s", "/B:" );
                return( FALSE );
        }
        if( _Ticks1.IsValueSet() ) {
                _Message.Set( MSG_PRINT_NOT_IMPLEMENTED );
                _Message.Display( "%s", "/U:" );
                return( FALSE );
        }
        if( _Ticks2.IsValueSet() ) {
                _Message.Set( MSG_PRINT_NOT_IMPLEMENTED );
                _Message.Display( "%s", "/M:" );
                return( FALSE );
        }
        if( _Ticks3.IsValueSet() ) {
                _Message.Set( MSG_PRINT_NOT_IMPLEMENTED );
                _Message.Display( "%s", "/S:" );
                return( FALSE );
        }
        if( _NumberOfFiles.IsValueSet() ) {
                _Message.Set( MSG_PRINT_NOT_IMPLEMENTED );
                _Message.Display( "%s", "/Q:" );
                return( FALSE );
        }
        if( _FlagRemoveFiles.IsValueSet() ) {
                _Message.Set( MSG_PRINT_NOT_IMPLEMENTED );
                _Message.Display( "%s", "/T:" );
                return( FALSE );
        }
        if( _FlagCancelPrinting.IsValueSet() ) {
                _Message.Set( MSG_PRINT_NOT_IMPLEMENTED );
                _Message.Display( "%s", "/C:" );
                return( FALSE );
        }
        if( _FlagAddFiles.IsValueSet() ) {
                _Message.Set( MSG_PRINT_NOT_IMPLEMENTED );
                _Message.Display( "%s", "/P:" );
                return( FALSE );
        }

        //
        //      Displays help message if /? was found in the command line
        //
        if( FlagDisplayHelp.QueryFlag() ) {
                _Message.Set( MSG_PRINT_HELP_MESSAGE );
                _Message.Display( " " );
                return( FALSE );
        }

        //
        //      If no filename was specified, display error message
        //
        if( _Files.QueryPathCount() == 0 ) {
                _Message.Set( MSG_PRINT_NO_FILE );
                _Message.Display( " " );
                return( FALSE );
        }

        //
        // Get device name if one exists. Otherwise use PRN as default
        //
        if( !DeviceArgument.IsValueSet() ) {
                DevicePath = NEW( PATH );
                DebugPtrAssert( DevicePath );
        if( !DevicePath->Initialize( (LPWSTR)L"PRN" ) ) {
                        _Message.Set( MSG_PRINT_UNABLE_INIT_DEVICE );
                        _Message.Display( "%s", "PRN" );
                        return( FALSE );
                }
        } else {
                DevicePath = DeviceArgument.GetPath();
                DebugPtrAssert( DevicePath );
        }
        if( !_Printer.Initialize( DevicePath ) ) {
                DeviceString = DevicePath->GetPathString();
                DebugPtrAssert( DeviceString );
                _Message.Set( MSG_PRINT_UNABLE_INIT_DEVICE );
                _Message.Display( "%W", DeviceString );
                if( !DeviceArgument.IsValueSet() ) {
                        DELETE( DevicePath );
                }
                return( FALSE );
        }

        //
        //      Get FSNODE of each file and put them in an array
        //
        PathArray = _Files.GetPathArray();
        DebugPtrAssert( PathArray );
        PathArrayIterator = ( PARRAY_ITERATOR )PathArray->QueryIterator();
        DebugPtrAssert( PathArrayIterator );

        if( !_FsnFileArray.Initialize() ) {
                DebugAbort( "_FsnFileArray.Initialize() failed \n" );
                return( FALSE );
        }
        while( ( FilePath = ( PPATH )PathArrayIterator->GetNext() ) != NULL ) {
                FsnFile = SYSTEM::QueryFile( FilePath );
                if( FsnFile != NULL ) {
                        _FsnFileArray.Put( ( POBJECT )FsnFile );
                } else {
                        FileString = FilePath->GetPathString();
                        _Message.Set( MSG_PRINT_FILE_NOT_FOUND );
                        _Message.Display( "%W", FileString );
                }
        }
        DELETE( PathArrayIterator );
        return( TRUE );
}


BOOLEAN
PRINT::PrintFiles(
        )

/*++

Routine Description:

        Prints the files specified by the user.

Arguments:

        None.

Return Value:

        BOOLEAN - TRUE if all files were printed.


--*/

{
        PFSN_FILE                       FsnFile;
        PSTREAM                         FileStream;
        PARRAY_ITERATOR         ArrayIterator;
        PBYTE                           Buffer;
        ULONG                           Size;
        ULONG                           BytesRead;
        ULONG                           BytesWritten;
        PCPATH                          FilePath;
        PCWSTRING                       FileName;
        INT                             _BufferStreamType;
        INT                             BytesConverted;
        INT                             cbStuff;
        LPSTR                           lpStuffANSI;
        BOOL                            fUsedDefault;


        Size = 512;
        Buffer = ( PBYTE )MALLOC( ( size_t )Size );
        lpStuffANSI = ( LPSTR )MALLOC( ( size_t )Size );
        if (Buffer == NULL || lpStuffANSI == NULL) {
            DebugPrint("PRINT: Out of memory\n");
            return FALSE;
        }
        ArrayIterator = ( PARRAY_ITERATOR )_FsnFileArray.QueryIterator();
        if (ArrayIterator == NULL) {
            DebugPrint("PRINT: ArrayIterator equals NULL\n");
            return FALSE;
        }
        while( ( FsnFile = ( PFSN_FILE )ArrayIterator->GetNext() ) != NULL ) {
                FileStream = ( PSTREAM )FsnFile->QueryStream( READ_ACCESS );
                if (FileStream == NULL) {
                    DebugPrint("PRINT: FileStream equals NULL\n");
                    return FALSE;
                }

                FileName = FsnFile->GetPath()->GetPathString();
                if( FileName != NULL ) {
                    _Message.Set( MSG_PRINT_PRINTING );
                    _Message.Display( "%W", FileName );
                }

                _BufferStreamType = -1;
                while( !FileStream->IsAtEnd() ) {
                        FileStream->Read( Buffer, Size, &BytesRead );
                        // is file unicode?
                        if (_BufferStreamType < 0) {
                           if (IsTextUnicode((LPTSTR)Buffer, (INT)BytesRead,
                            NULL) ) {
                              _BufferStreamType = 1;
                           } else {
                              _BufferStreamType = 0;
                           }
                        }
                        // does the buffer need to be converted?
                        if (_BufferStreamType == 1) {

                           cbStuff = Size;
                           BytesConverted = WideCharToMultiByte(CP_ACP,0,
                                   (LPTSTR)Buffer,BytesRead/sizeof(WCHAR),
                                   lpStuffANSI,cbStuff,NULL,&fUsedDefault) ;
                           DebugAssert(cbStuff>0);
                           DebugAssert(BytesConverted >= 0);
                           _Printer.Write((PBYTE)lpStuffANSI,BytesConverted,&BytesWritten );
                        } else {
                           _Printer.Write( Buffer, BytesRead, &BytesWritten );
                        }
                }
                _Printer.WriteByte( '\f' );
                DELETE( FileStream );
        }
        DELETE( ArrayIterator );
        return( TRUE );
}




BOOL
PRINT::Terminate(
        )

/*++

Routine Description:

        Deletes objects created during initialization.

Arguments:

        None.

Return Value:

        None.


--*/

{
        return( TRUE );
}





ULONG __cdecl
main()

{
        DEFINE_CLASS_DESCRIPTOR( PRINT );


        {

                PRINT   Print;


                if( Print.Initialize() ) {
                        Print.PrintFiles();
                }
        //      Print.Terminate();
                return( 0 );
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\openfiles\query.cpp ===
/******************************************************************************

  Copyright (C) Microsoft Corporation

  Module Name:
      Query.CPP 

  Abstract: 
       This module deals with Query functionality of OpenFiles.exe 
       NT command line utility.

  Author:
  
       Akhil Gokhale (akhil.gokhale@wipro.com) 1-Nov-2000
  
 Revision History:
  
       Akhil Gokhale (akhil.gokhale@wipro.com) 1-Nov-2000 : Created It.


*****************************************************************************/
#include "pch.h"
#include "query.h"
/*****************************************************************************
Routine Description:

  This function Queries for all open files in for the server and display them.

Arguments:

    [in]    pszServer      : Will have the server name. 
    [in]    bShowNoHeader  : Will have the value whether to show header or not.
    [in]    pszFormat      : Will have the format required to show the result.
    [in]    bVerbose       : Will have the value whether to show verbose 
                             result.

Return Value: 
    TRUE if query successful
    else FALSE
   
******************************************************************************/

BOOL 
DoQuery(PTCHAR pszServer,
        BOOL bShowNoHeader, 
        PTCHAR pszFormat,
        BOOL bVerbose)
{

    CHString   szCHString;
    DWORD dwEntriesRead = 0;// Receives the count of elements actually 
                            // enumerated by "NetFileEnum" function
    DWORD dwTotalEntries = 0;//Receives the total number of entries that could 
                             //have been enumerated from the current 
                             //resume position by "NetFileEnum" function
    DWORD dwResumeHandle = 0;//Contains a resume handle which is used to 
                             //continue an existing file search. 
                             //The handle should be zero on the first call and 
                             //left unchanged for subsequent calls. 
                             //If resume_handle is NULL, 
                             //then no resume handle is stored. This variable
                             // used in calling "NetFileEnum" function.

    BOOL bAtLeastOne = FALSE;//Contains the state whether at least one record
                             //found for this query

    DWORD dwFormat = SR_FORMAT_TABLE;//Stores format flag required to show 
                                    // result on console. Default format 
                                    //is TABLE
    
    LPFILE_INFO_3 pFileInfo3_1 = NULL;// LPFILE_INFO_3  structure contains the 
                                      // identification number and other 
                                      // pertinent information about files, 
                                      // devices, and pipes.

    LPSERVER_INFO_100 pServerInfo = NULL;//The SERVER_INFO_100 structure 
                                         //contains information about the 
                                         //specified server, including the name 
                                         //and platform
    DWORD dwError = 0;//Contains return value for "NetFileEnum" function
    
    LONG lRowNo = 0;// Row index variable 
    
    LPTSTR pszServerType = new TCHAR[MIN_MEMORY_REQUIRED+1];//Stores server type
                                                       // information 

    AFP_FILE_INFO* pFileInfo = NULL;
    DWORD hEnumHandle = 0;
    HRESULT hr = S_OK;
    NET_API_STATUS retval = NERR_Success;
    AFP_SERVER_HANDLE ulSFMServerConnection = 0;
    typedef  DWORD (*FILEENUMPROC)(AFP_SERVER_HANDLE,LPBYTE*,DWORD,LPDWORD,LPDWORD,LPDWORD);
    typedef  DWORD (*CONNECTPROC) (LPWSTR,PAFP_SERVER_HANDLE);
    typedef  DWORD (*MEMFREEPROC) (LPVOID);
    TCHAR   szDllPath[MAX_PATH+1] = NULL_STRING;// buffer for Windows directory
    // AfpAdminConnect and AfpAdminFileEnum functions are undocumented function
    // and used only for MAC client.
    CONNECTPROC  AfpAdminConnect = NULL; // Function Pointer
    FILEENUMPROC AfpAdminFileEnum = NULL;// Function Pointer
    MEMFREEPROC  AfpAdminBufferFree = NULL; // Function Pointer
    HMODULE hModule = 0;          // To store retval for LoadLibrary

    DWORD dwIndx = 0;               //  Indx variable
    DWORD dwRow  = 0;             //   Row No indx.



    //server name to be shown
    LPTSTR pszServerNameToShow = new TCHAR[MIN_MEMORY_REQUIRED+ 1];
    LPTSTR pszTemp = new TCHAR[MIN_MEMORY_REQUIRED+ 1];
    //Some column required to hide in non verbose mode query
    DWORD  dwMask = bVerbose?SR_TYPE_STRING:SR_HIDECOLUMN|SR_TYPE_STRING;
    TCOLUMNS pMainCols[]=
    {
        {NULL_STRING,COL_WIDTH_HOSTNAME,dwMask,NULL_STRING,NULL,NULL},
        {NULL_STRING,COL_WIDTH_ID,SR_TYPE_STRING,NULL_STRING,NULL,NULL},
        {NULL_STRING,COL_WIDTH_ACCESSED_BY,SR_TYPE_STRING,NULL_STRING,NULL,NULL},
        {NULL_STRING,COL_WIDTH_TYPE,SR_TYPE_STRING,NULL_STRING,NULL,NULL},
        {NULL_STRING,COL_WIDTH_LOCK,dwMask,NULL_STRING,NULL,NULL},
        {NULL_STRING,COL_WIDTH_OPEN_MODE,dwMask,NULL_STRING,NULL,NULL},
        {NULL_STRING,COL_WIDTH_OPEN_FILE,SR_TYPE_STRING|(SR_NO_TRUNCATION&~(SR_WORDWRAP)),NULL_STRING,NULL,NULL}
       
    };

    TARRAY pColData  = CreateDynamicArray();//array to stores 
                                            //result                 
    
    if((pszServerNameToShow == NULL)||
       (pszServerType       == NULL)||
       (pColData            == NULL)||
       (pszTemp             == NULL))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        DISPLAY_MESSAGE(stderr,GetResString(IDS_ID_SHOW_ERROR));
        ShowLastError(stderr);
        SAFEDELETE(pszServerNameToShow);
        SAFEDELETE(pszServerType);
        SAFERELDYNARRAY(pColData);
        SAFEDELETE(pszTemp);
        return FALSE;
    }
    
    // Initialize allocated arrays 
    memset(pszServerNameToShow,0,MIN_MEMORY_REQUIRED*sizeof(TCHAR));
    memset(pszServerType,0,MIN_MEMORY_REQUIRED*sizeof(TCHAR));

    // Fill column headers with TEXT.
    lstrcpy(pMainCols[0].szColumn, COL_HOSTNAME);
    lstrcpy(pMainCols[1].szColumn, COL_ID);
    lstrcpy(pMainCols[2].szColumn, COL_ACCESSED_BY);
    lstrcpy(pMainCols[3].szColumn, COL_TYPE);
    lstrcpy(pMainCols[4].szColumn, COL_LOCK);
    lstrcpy(pMainCols[5].szColumn, COL_OPEN_MODE);
    lstrcpy(pMainCols[6].szColumn, COL_OPEN_FILE);
    if(pszFormat!=NULL)
    {
        if(lstrcmpi(pszFormat,GetResString(IDS_LIST))==0)
        {
            dwFormat = SR_FORMAT_LIST;
        }
        else if(lstrcmpi(pszFormat,GetResString(IDS_CSV))==0)
        {
            dwFormat = SR_FORMAT_CSV;
        }
    }

    // Check if local machine
    if((pszServer == NULL)||
       (IsLocalSystem(pszServer)==TRUE))
    {
        DWORD dwBuffLength;
        dwBuffLength = MAX_COMPUTERNAME_LENGTH + 1 ;
        // Gets the name of computer for local machine.
        GetComputerName(pszServerNameToShow,&dwBuffLength);
        // Show Local Open files
        DoLocalOpenFiles (dwFormat,bShowNoHeader,bVerbose,NULL_STRING);
        ShowMessage(stdout,GetResString(IDS_SHARED_OPEN_FILES));
        ShowMessage(stdout,GetResString(IDS_LOCAL_OPEN_FILES_SP2));
    }
    else
    {
        // pszServername can be changed in GetHostName function
        // so a copy of pszServer is passed.
        lstrcpy(pszServerNameToShow, pszServer);
        if(GetHostName(pszServerNameToShow)==FALSE)
        {
            SAFEDELETE(pszServerNameToShow);
            SAFEDELETE(pszServerType);
            SAFERELDYNARRAY(pColData);
            SAFEDELETE(pszTemp);

            return FALSE;
        }
    }

    // Server type is "Windows" as NetFileEnum enumerates file only for 
    // files opened for windows client
    lstrcpy(pszServerType,GetResString(IDS_STRING_WINDOWS));
    do
    {
        //The NetFileEnum function returns information about some 
        // or all open files (from Windows client) on a server
        dwError = NetFileEnum( pszServer, NULL, NULL, 3,
                              (LPBYTE*)&pFileInfo3_1,
                               MAX_PREFERRED_LENGTH,
                               &dwEntriesRead,
                               &dwTotalEntries,
                               (PDWORD_PTR)&dwResumeHandle );

        if(dwError == ERROR_ACCESS_DENIED)
        {
            SetLastError(ERROR_ACCESS_DENIED);
            DISPLAY_MESSAGE(stderr,GetResString(IDS_ID_SHOW_ERROR));
            ShowLastError(stderr);
            SAFEDELETE(pszServerNameToShow);
            SAFEDELETE(pszServerType);
            SAFERELDYNARRAY(pColData);
            SAFEDELETE(pszTemp);

            return FALSE;
        }
        if( dwError == NERR_Success || dwError == ERROR_MORE_DATA )
        {

            for ( dwIndx = 0; dwIndx < dwEntriesRead;
                  dwIndx++, pFileInfo3_1++ )
            {

                // Now fill the result to dynamic array "pColData"
                DynArrayAppendRow( pColData, 0 ); 
                // Hostname
                DynArrayAppendString2(pColData,dwRow,pszServerNameToShow,0); 
                // id
                wsprintf(pszTemp,_T("%lu"),pFileInfo3_1->fi3_id);
                DynArrayAppendString2(pColData ,dwRow,pszTemp,0); 
                // Accessed By
                if(lstrlen(pFileInfo3_1->fi3_username)<=0)
                {
                    DynArrayAppendString2(pColData,dwRow,
                                      GetResString(IDS_NA),0); 

                }
                else
                {
                    DynArrayAppendString2(pColData,dwRow,
                                       pFileInfo3_1->fi3_username,0); 

                }
                // Type  
                DynArrayAppendString2(pColData,dwRow,pszServerType,0);
                // Locks
                wsprintf(pszTemp,_T("%ld"),pFileInfo3_1->fi3_num_locks);
                DynArrayAppendString2(pColData ,dwRow,pszTemp,0); 


                 // Checks for  open file mode
                if((pFileInfo3_1->fi3_permissions & PERM_FILE_READ)&&
                   (pFileInfo3_1->fi3_permissions & PERM_FILE_WRITE ))
                {
                     DynArrayAppendString2(pColData,dwRow,
                                        GetResString(IDS_READ_WRITE),0);
                }
                else if(pFileInfo3_1->fi3_permissions & PERM_FILE_WRITE )
                {
                     DynArrayAppendString2(pColData,dwRow,
                                        GetResString(IDS_WRITE),0);

                }
                else if(pFileInfo3_1->fi3_permissions & PERM_FILE_READ )
                {
                      DynArrayAppendString2(pColData,dwRow,
                                         GetResString(IDS_READ),0);
                }
                else
                {
                    DynArrayAppendString2(pColData,dwRow,
                                       GetResString(IDS_NOACCESS),0);

                }

                
                // If show result is  table mode and if 
                // open file length is gerater than 
                // column with, Open File string cut from right
                // by COL_WIDTH_OPEN_FILE-5 and "..." will be
                // inserted before the string.
                // Example o/p:  ...notepad.exe
                szCHString = pFileInfo3_1->fi3_pathname;
                if(bVerbose==FALSE)
                {
                    if((szCHString.GetLength()>(COL_WIDTH_OPEN_FILE-5))&&
                        (dwFormat == SR_FORMAT_TABLE))
                    {
                        // If file path is too big to fit in column width
                        // then it is cut like..
                        // c:\...\rest_of_the_path.
                        CHString szTemp = szCHString.Right(COL_WIDTH_OPEN_FILE-5);;
                        DWORD dwTemp = szTemp.GetLength();
                        szTemp = szTemp.Mid(szTemp.Find(SINGLE_SLASH),
                                           dwTemp);
                        szCHString.Format(L"%s%s%s",szCHString.Mid(0,3),
                                                    DOT_DOT,
                                                    szTemp);
                        pMainCols[6].dwWidth = COL_WIDTH_OPEN_FILE+1;      
                    }
                }
                else
                {

                    pMainCols[6].dwWidth = 80;        
                }

               // Open File name
                DynArrayAppendString2(pColData,dwRow,
                                   (LPCWSTR)szCHString,0);
                     
                bAtLeastOne = TRUE;
                dwRow++;
            }// Enf for loop
        }
        // Free the block
        if( pFileInfo3_1 !=NULL)
        {
            NetApiBufferFree( pFileInfo3_1 ); 
            pFileInfo3_1 = NULL;
        }

    } while ( dwError == ERROR_MORE_DATA );

    // Now Enumerate  Open files for MAC Client..................

    // Server type is "Machintosh" as AfpAdminFileEnum enumerates file only for 
    // files opened for Mac client
    lstrcpy(pszServerType,MAC_OS);
    do
    {

        // DLL required stored always in \windows\system32 directory....        
        // so get windows directory first.
        if(GetSystemDirectory(szDllPath, MAX_PATH)!= 0)
        {
            
            lstrcat(szDllPath,MAC_DLL_FILE_NAME); // appending dll file name
            hModule = ::LoadLibrary (szDllPath);

            if(hModule==NULL)
            {
                DISPLAY_MESSAGE(stderr,GetResString(IDS_ID_SHOW_ERROR));
                ShowLastError(stderr); // Shows the error string set by API function.
                SAFEDELETE(pszServerNameToShow);
                SAFEDELETE(pszServerType);
                SAFERELDYNARRAY(pColData);
                SAFEDELETE(pszTemp);
                return FALSE;

            }
        }
        else
        {
                DISPLAY_MESSAGE(stderr,GetResString(IDS_ID_SHOW_ERROR));
                ShowLastError(stderr); // Shows the error string set by API function.
                SAFEDELETE(pszServerNameToShow);
                SAFEDELETE(pszServerType);
                SAFERELDYNARRAY(pColData);
                SAFEDELETE(pszTemp);
                return FALSE;
        }

        AfpAdminConnect = (CONNECTPROC)::GetProcAddress (hModule,"AfpAdminConnect");
        AfpAdminFileEnum = (FILEENUMPROC)::GetProcAddress (hModule,"AfpAdminFileEnum");
        AfpAdminBufferFree = (MEMFREEPROC)::GetProcAddress (hModule,"AfpAdminBufferFree");

        if((AfpAdminConnect    == NULL) ||
           (AfpAdminFileEnum   == NULL) ||
           (AfpAdminBufferFree == NULL))
        {
            DISPLAY_MESSAGE(stderr,GetResString(IDS_ID_SHOW_ERROR));
            ShowLastError(stderr); // Shows the error string set by API function.
            SAFEDELETE(pszServerNameToShow);
            SAFEDELETE(pszServerType);
            SAFERELDYNARRAY(pColData);
            SAFEDELETE(pszTemp);
            FREE_LIBRARY(hModule);
             return FALSE;
        }

        // Connection ID is required for AfpAdminFileEnum function.   
        // So connect to server to get connect id...
        DWORD retval_connect =  AfpAdminConnect(const_cast<LPWSTR>(pszServer),
                                &ulSFMServerConnection );
        if(retval_connect!=0)
        {
            DISPLAY_MESSAGE(stderr,GetResString(IDS_ID_SHOW_ERROR));
            ShowLastError(stderr); // Shows the error string set by API function.
            SAFEDELETE(pszServerNameToShow);
            SAFEDELETE(pszServerType);
            SAFERELDYNARRAY(pColData);
            SAFEDELETE(pszTemp);
            FREE_LIBRARY(hModule);
             return FALSE;
        }

        //The AfpAdminFileEnum function returns information about some 
        // or all open files (from MAC client) on a server
         dwError =     AfpAdminFileEnum( ulSFMServerConnection,
                                      (PBYTE*)&pFileInfo,
                                      (DWORD)-1L,
                                      &dwEntriesRead,
                                      &dwTotalEntries,
                                      &hEnumHandle );
        if(dwError == ERROR_ACCESS_DENIED)
        {
            SetLastError(ERROR_ACCESS_DENIED);
            DISPLAY_MESSAGE(stderr,GetResString(IDS_ID_SHOW_ERROR));
            ShowLastError(stderr);
            SAFEDELETE(pszServerNameToShow);
            SAFEDELETE(pszServerType);
            SAFERELDYNARRAY(pColData);
            SAFEDELETE(pszTemp);
            FREE_LIBRARY(hModule);
            return FALSE;
        }

        if( dwError == NERR_Success || dwError == ERROR_MORE_DATA )
        {

           for ( dwIndx = 0 ; dwIndx < dwEntriesRead;
                  dwIndx++, pFileInfo++ )
            {
                
                // Now fill the result to dynamic array "pColData"
                DynArrayAppendRow( pColData, 0 ); 
                // Hostname
                DynArrayAppendString2(pColData,dwRow,pszServerNameToShow,0); 
                // id
                wsprintf(pszTemp,_T("%lu"),pFileInfo->afpfile_id );
                DynArrayAppendString2(pColData ,dwRow,pszTemp,0); 
                // Accessed By
                if(lstrlen(pFileInfo->afpfile_username )<=0)
                {
                    DynArrayAppendString2(pColData,dwRow,
                                      GetResString(IDS_NA),0); 

                }
                else
                {
                    DynArrayAppendString2(pColData,dwRow,
                                       pFileInfo->afpfile_username,0); 

                }
                // Server Type  
                DynArrayAppendString2(pColData,dwRow,pszServerType,0);
                // Locks
                wsprintf(pszTemp,_T("%ld"),pFileInfo->afpfile_num_locks );
                DynArrayAppendString2(pColData ,dwRow,pszTemp,0); 

                // Checks for  open file mode
                if((pFileInfo->afpfile_open_mode  & AFP_OPEN_MODE_READ)&&
                   (pFileInfo->afpfile_open_mode  & AFP_OPEN_MODE_WRITE ))
                {
                     DynArrayAppendString2(pColData,dwRow,
                                        GetResString(IDS_READ_WRITE),0);
                }
                else if(pFileInfo->afpfile_open_mode  & AFP_OPEN_MODE_WRITE )
                {
                     DynArrayAppendString2(pColData,dwRow,
                                        GetResString(IDS_WRITE),0);

                }
                else if(pFileInfo->afpfile_open_mode  & AFP_OPEN_MODE_READ )
                {
                      DynArrayAppendString2(pColData,dwRow,
                                         GetResString(IDS_READ),0);
                }
                else
                {
                    DynArrayAppendString2(pColData,dwRow,
                                       GetResString(IDS_NOACCESS),0);
                }
               
                // If show result is  table mode and if 
                // open file length is gerater than 
                // column with, Open File string cut from right
                // by COL_WIDTH_OPEN_FILE-5 and "..." will be
                // inserted before the string.
                // Example o/p:  ...notepad.exe
                szCHString = pFileInfo->afpfile_path ;
                
                 if(bVerbose==FALSE)
                {
                    if((szCHString.GetLength()>(COL_WIDTH_OPEN_FILE-5))&&
                        (dwFormat == SR_FORMAT_TABLE))
                    {
                        // If file path is too big to fit in column width
                        // then it is cut like..
                        // c:\...\rest_of_the_path.
                        CHString szTemp = szCHString.Right(COL_WIDTH_OPEN_FILE-5);;
                        DWORD dwTemp = szTemp.GetLength();
                        szTemp = szTemp.Mid(szTemp.Find(SINGLE_SLASH),
                                           dwTemp);
                        szCHString.Format(L"%s%s%s",szCHString.Mid(0,3),
                                                    DOT_DOT,
                                                    szTemp);
                        pMainCols[6].dwWidth = COL_WIDTH_OPEN_FILE+1;      
                    }
                }
                else
                {

                    pMainCols[6].dwWidth = 80;        
                }

               // Open File name
                DynArrayAppendString2(pColData,dwRow,
                                   (LPCWSTR)szCHString,0);
                     
                bAtLeastOne = TRUE;
                dwRow++;
            }// Enf for loop
        }
        // Free the block
        if( pFileInfo!=NULL)
        {
            AfpAdminBufferFree( pFileInfo ); 
            pFileInfo = NULL;
        }

    } while ( dwError == ERROR_MORE_DATA );

    if(bAtLeastOne==FALSE)// if not a single open file found, show info 
                          // as -  INFO: No open file found.  
    {
        ShowMessage(stdout,GetResString(IDS_NO_OPENFILES));
    }
    else
    {

        // Display output result.
        if(bShowNoHeader==TRUE)
        {
              dwFormat |=SR_NOHEADER;
        }
        //Output should start after one blank line
        ShowMessage(stdout,BLANK_LINE);
        ShowResults(MAX_OUTPUT_COLUMN,pMainCols,dwFormat,pColData);   
        // Destroy dynamic array.
        SAFERELDYNARRAY(pColData);

    }
    SAFEDELETE(pszServerNameToShow);
    SAFEDELETE(pszServerType);
    SAFERELDYNARRAY(pColData);
    SAFEDELETE(pszTemp);
    FREE_LIBRARY(hModule);

    return TRUE;
}
// ***************************************************************************
// Routine Description:
//    This routine gets Hostname of remote computer 
//
// Arguments:
//     [in/out] pszServer   = ServerName
// Return Value:
//      TRUE : if server name retured successfully
//      FALSE: otherwise
// ***************************************************************************
BOOL GetHostName(PTCHAR pszServer)
{
    if(pszServer == NULL)
        return FALSE;
    BOOL bReturnValue = FALSE; // function return state.
    char* pszServerName = new char[MIN_MEMORY_REQUIRED+1];//char is used as winsock 
                                       // required these type.
    HOSTENT* hostEnt = NULL;//The Windows Sockets hostEnt structure is 
                             //used by functions to store information 
                             //about a given host.

    WORD wVersionRequested; //Variable used to store highest version 
                            //number that Windows Sockets can support.
                            // The high-order byte specifies the minor
                            // version (revision) number; the low-order
                            // byte specifies the major version number
    WSADATA wsaData;//Variable receive details of the Windows Sockets 
                    //implementation
    DWORD dwErr; // strore error code
    if(pszServerName==NULL)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        DISPLAY_MESSAGE(stderr,GetResString(IDS_ID_SHOW_ERROR));
        //Release allocated memory safely
        ShowLastError(stderr);
        return FALSE;
    }
    wVersionRequested = MAKEWORD( 2, 2 );
    
    //WSAStartup function initiates use of 
    //Ws2_32.dll by a process
    dwErr = WSAStartup( wVersionRequested, &wsaData );
    if(dwErr!=0) 
    {
        SetLastError(WSAGetLastError());
        DISPLAY_MESSAGE(stderr,GetResString(IDS_ID_SHOW_ERROR));
        ShowLastError(stderr);
        return FALSE;
    }
    // Initialize arrays...
    memset(pszServerName,0,MIN_MEMORY_REQUIRED);
    GetAsMultiByteString(pszServer,pszServerName,MIN_MEMORY_REQUIRED);
    if(IsValidIPAddress(pszServer))
    {
        unsigned long ulInetAddr  = 0;//unsigned long is used as winsock 
                                    // required this type. Variable 
                                    // used 
       
        // inet_addr function converts a string containing an 
        //(Ipv4) Internet Protocol dotted address into a proper 
        //address for the IN_ADDR structure.
        ulInetAddr  = inet_addr( pszServerName );
        
        // gethostbyaddr function retrieves the host information 
        //corresponding to a network address.
        hostEnt = gethostbyaddr( (char *) &ulInetAddr,
                                  sizeof( ulInetAddr ), 
                                  PF_INET);

        if(hostEnt != NULL)
        {
            // As hostEnt->h_name is of type char so convert it 
            // to unicode string
            GetAsUnicodeStringEx(hostEnt->h_name,pszServer,  
                                 MAX_COMPUTERNAME_LENGTH);
            bReturnValue = GetHostNameFromFQDN( pszServer);        
        }
        else
        {
            SetLastError(WSAGetLastError());
            DISPLAY_MESSAGE(stderr,GetResString(IDS_ID_SHOW_ERROR));
            ShowLastError(stderr);
        }
    }
    // Check  validity for the server name 
    else if (IsValidServer(pszServer))
    {
        
        hostEnt =  gethostbyname(pszServerName);
        if(hostEnt != NULL)
        {
            // As hostEnt->h_name is of type char so convert it 
            // to unicode string
            GetAsUnicodeStringEx(hostEnt->h_name,pszServer,  
                                 MAX_COMPUTERNAME_LENGTH);
            bReturnValue = GetHostNameFromFQDN( pszServer);        
        }
        else
        {
            SetLastError(WSAGetLastError());
            DISPLAY_MESSAGE(stderr,GetResString(IDS_ID_SHOW_ERROR));
            ShowLastError(stderr);
        }
    }
    else
    {
       // server name is incorrect, show error message. 
        DISPLAY_MESSAGE(stderr,GetResString(IDS_ID_SHOW_ERROR ));
        DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_SERVER_NAME));
    }
    //WSACleanup function terminates use of the Ws2_32.dll.
    WSACleanup( );
    SAFEDELETE(pszServerName);
    return bReturnValue;
}
// ***************************************************************************
// Routine Description:
//    This routine gets Hostname from FQDN name. 
//
// Arguments:
//     [in/out] pszServer   = ServerName
// Return Value:
//      TRUE : if server name retured successfully
//      FALSE: otherwise
// ***************************************************************************

BOOL 
GetHostNameFromFQDN(LPTSTR pszServer)
{
    BOOL bReturnValue = FALSE;
    if(pszServer==NULL)
        return FALSE;
    LPTSTR pszTemp = new TCHAR[lstrlen(pszServer)+1];
    LPTSTR pszTempHeadPos;

    if(pszTemp==NULL)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
         DISPLAY_MESSAGE(stderr,GetResString(IDS_ID_SHOW_ERROR));
        ShowLastError(stderr);
    }
    else
    {
        // Following is done to chekc Fully Qualified Domain Name.
        // This will extract a string coming before "."
        // for example FQDN = akhil.wipro.com...
        // String of interest is akhil, which will be exracted 
        // in following manner.
        pszTempHeadPos = pszTemp;
        pszTemp = _tcstok(pszServer,SINGLE_DOT);
        pszTemp = 0;// putting explicitly NULL character. at 
                    // the place where "." comes.
        
        bReturnValue = TRUE;
    }
    SAFEDELETE(pszTempHeadPos);
    return bReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\openfiles\resource.h ===
#define IDS_HELP_LINE1                  1
#define IDS_HELP_LINE2                  2
#define IDS_HELP_LINE3                  3
#define IDS_HELP_LINE4                  4
#define IDS_HELP_LINE5                  5
#define IDS_HELP_LINE6                  6
#define IDS_HELP_LINE7                  7
#define IDS_HELP_LINE8                  8
#define IDS_HELP_LINE9                  9
#define IDS_HELP_LINE10                 10
#define IDS_HELP_LINE11                 11
#define IDS_HELP_LINE12                 12
#define IDS_HELP_LINE13                 13
#define IDS_HELP_LINE14                 14
#define IDS_HELP_LINE15                 15
#define IDS_HELP_LINE16                 16
#define IDS_HELP_LINE17                 17
#define IDS_HELP_LINE18                 18
#define IDS_HELP_LINE19                 19
#define IDS_HELP_LINE20                 20
#define IDS_HELP_LINE21                 21
#define IDS_HELP_LINE22                 22
#define IDS_HELP_LINE23                 23
#define IDS_HELP_LINE24                 24
#define IDS_HELP_LINE25                 25
#define IDS_HELP_LINE26                 26
#define IDS_HELP_LINE27                 27
#define IDS_HELP_LINE28                 28
#define IDS_HELP_LINE29                 29
#define IDS_HELP_LINE30                 30
#define IDS_HELP_LINE31                 31
#define IDS_HELP_LINE32                 32
#define IDS_HELP_LINE33                 33
#define IDS_HELP_LINE34                 34
#define IDS_HELP_LINE35                 35
#define IDS_HELP_LINE36                 36
#define IDS_HELP_LINE_END               37

#define IDS_FAILURE                     60
#define IDS_SUCCESS                     61
#define IDS_SUCCESS_DISCONNECT          62
#define IDS_ERROR_DISCONNECT            64
#define IDS_ERROR_USERNAME_BUT_NOMACHINE 66
#define IDS_ERROR_PASSWORD_BUT_NOUSERNAME 67
#define IDS_STRING_HOSTNAME             68
#define IDS_STRING_ID                   69
#define IDS_STRING_ACCESSED_BY          71
#define IDS_STRING_TYPE                 72
#define IDS_STRING_LOCK                 73
#define IDS_STRING_OPEN_MODE            74
#define IDS_STRING_OPEN_FILE            75
#define IDS_STRING_WINDOWS              76
#define IDS_STRING_UNKNOWN              77
#define IDS_READ                        78
#define IDS_WRITE                       79
#define IDS_READ_WRITE                  80
#define IDS_NO_OPENFILES                81
#define IDS_FORMAT_OPTIONS              82

#define IDS_HELP_MAIN1                  100
#define IDS_HELP_MAIN2                  101
#define IDS_HELP_MAIN3                  102
#define IDS_HELP_MAIN4                  103
#define IDS_HELP_MAIN5                  104
#define IDS_HELP_MAIN6                  105
#define IDS_HELP_MAIN7                  106
#define IDS_HELP_MAIN8                  107
#define IDS_HELP_MAIN9                  108
#define IDS_HELP_MAIN10                 109
#define IDS_HELP_MAIN11                 110
#define IDS_HELP_MAIN12                 111
#define IDS_HELP_MAIN_END               112

#define IDS_HELP_QUERY1                 121
#define IDS_HELP_QUERY2                 122
#define IDS_HELP_QUERY3                 123
#define IDS_HELP_QUERY4                 124
#define IDS_HELP_QUERY5                 125
#define IDS_HELP_QUERY6                 126
#define IDS_HELP_QUERY7                 127
#define IDS_HELP_QUERY8                 128
#define IDS_HELP_QUERY9                 129
#define IDS_HELP_QUERY10                130
#define IDS_HELP_QUERY11                131
#define IDS_HELP_QUERY12                132
#define IDS_HELP_QUERY13                133
#define IDS_HELP_QUERY14                134
#define IDS_HELP_QUERY15                135
#define IDS_HELP_QUERY16                136
#define IDS_HELP_QUERY17                137
#define IDS_HELP_QUERY18                138
#define IDS_HELP_QUERY19                139
#define IDS_HELP_QUERY20                140
#define IDS_HELP_QUERY21                141
#define IDS_HELP_QUERY22                142
#define IDS_HELP_QUERY23                143
#define IDS_HELP_QUERY24                144
#define IDS_HELP_QUERY25                145
#define IDS_HELP_QUERY_END              146

#define IDS_LIST                        150
#define IDS_CSV                         151
#define IDS_NO_ID_ACC_OF                152
#define IDS_NOACCESS                    153
#define IDS_GIVEN_CREDENTIAL            154
#define IDS_ERROR_ID                    155   
#define IDS_ID_SHOW_ERROR               156
#define IDS_INTERNAL_FAILURE            157  
#define IDS_ACCESS_DENIED               158  
#define IDS_INVALID_CREDENTIALS         159 
#define IDS_OPENMODE_OPTION             160 
#define IDS_INVALID_SYNTAX              161
#define IDS_AUTHENTICATION_FAILURE      162  
#define IDS_INVALID_SERVER_NAME         164
#define IDS_HEADER_NOT_ALLOWED          165
#define IDS_LOCAL_SYSTEM                166
#define IDS_NA                          167
#define IDS_SERVER_EMPTY                168
#define IDS_ID_SHOW_WARNING             169
#define IDS_USERNAME_EMPTY              170
#define IDS_INVALID_OS                  171 
#define IDS_MAC_OS                      172
#define IDS_READ_SLASH_WRITE            173
#define IDS_WRITE_SLASH_READ            174
#define IDS_DOT_EOL                     175
#define IDS_NO_D_OPENFILES              176
#define IDS_ACCESSBY_EMPTY              177
#define IDS_OPEN_FILE_EMPTY             178
#define IDS_TYPE_Q_HELP                 179 
#define IDS_TYPE_D_HELP                 180
#define IDS_CANNOT_READ_REGISTRY		181 
#define IDS_CANNOT_WRITE_REGISTRY		182
#define IDS_LOCAL_OPEN_FILES            183
#define IDS_SHARED_OPEN_FILES           184 
#define IDS_WAIT                        185
#define IDS_STRING_PROCESS_ID           186
#define IDS_STRING_PROCESS_NAME         187
#define IDS_WARN_NO_LOCAL_FILE          188
#define IDS_LOCAL_OPEN_FILES_SP1        189 
#define IDS_LOCAL_OPEN_FILES_SP2        190
#define IDS_UTILITY_NAME                191
#define IDS_ERROR_SYSTEM_INFO           192
#define IDS_ERROR_VERSION_MISMATCH      193
#define IDS_REMOTE_NOT_SUPPORTED        194
#define IDS_ERROR_VERSION_MISMATCH1		195
#define IDS_REMOTE_NOT_SUPPORTED1		196
#define IDS_FILE_TYPE                   197 
#define IDS_FILE_ARCHIVE                198
#define IDS_FILE_COMPRESSED             199
#define IDS_FILE_ENCRYPTED              220
#define IDS_FILE_HIDDEN                 221
#define IDS_FILE_NORMAL                 222
#define IDS_FILE_OFFLINE                223
#define IDS_FILE_READONLY               224
#define IDS_FILE_DIRECTORY              225 
#define IDS_LOCAL_NEEDS_TO_SET          227
#define IDS_LOCAL_FLG_SET               228
#define IDS_LOCAL_FLG_RESET             229 
#define IDS_LOCAL_ON                    230
#define IDS_LOCAL_OFF                   231
#define IDS_LOCAL_OPTION                232
#define IDS_LOCAL_FLG_ALREADY_RESET     233  
#define IDS_LOCAL_FLG_ALREADY_SET       234 

#define IDS_HELP_LOCAL1                 250
#define IDS_HELP_LOCAL2                 251
#define IDS_HELP_LOCAL3                 252
#define IDS_HELP_LOCAL4                 253
#define IDS_HELP_LOCAL5                 254
#define IDS_HELP_LOCAL6                 255
#define IDS_HELP_LOCAL7                 256
#define IDS_HELP_LOCAL8                 257
#define IDS_HELP_LOCAL9                 258
#define IDS_HELP_LOCAL_END              259
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\pentbug\pentnt.c ===
/*++

Copyright (c) 1994-2000  Microsoft Corporation

Module Name:

    pentnt.c

Abstract:

    This module contains a simple program to detect the Pentium FPU
    FDIV precision error, and offers to force floating point emulation
    on if the bug is present.

Author:

    Bryan M. Willman (bryanwi) 7-Dec-1994

Revision History:

--*/

#define         UNICODE
#include        <stdio.h>
#include        <time.h>
#include        <stdlib.h>
#include        <string.h>
#include        <fcntl.h>
#include        <io.h>
#include        <windows.h>
#include        <ctype.h>
#include        <assert.h>
#include        <locale.h>

#include        <stdarg.h>
#include        "pbmsg.h"

void    SetForceNpxEmulation(ULONG setting);
void    TestForDivideError();
void    ScanArgs(int argc, char **argv);
void    GetSystemState();
void    printmessage (DWORD messageID, ...);
int     ms_p5_test_fdiv(void);

//
// Core control state vars
//
BOOLEAN     NeedHelp;

BOOLEAN     Force;
ULONG       ForceValue;

BOOLEAN     FDivError;

BOOLEAN     NTOK;

ULONG       CurrentForceValue;

ULONG       FloatHardware;

//
// ForceValue and CurrentForceValue
//
#define     FORCE_OFF         0   // User wants emulation turned off
#define     FORCE_CONDITIONAL 1   // User wants emulation iff we detect bad pentium
#define     FORCE_ALWAYS      2   // User wants emulation regardless

//
// hardware fp status
//
#define     FLOAT_NONE      0   // No fp hardware
#define     FLOAT_ON        1   // Fp hardware is present and active
#define     FLOAT_OFF       2   // Fp hardware is present and disabled

void
__cdecl
main(
    int argc,
    char **argv
    )
/*++

Routine Description:

    Main procedure for pentnt.

    First, we call a series of routines that build a state vector
    in some booleans.

    We'll then act on these control variables:

        NeedHelp -  User has asked for help, or made a command error

        Force    -  True if user has asked to change a force setting
        ForceValue - Has no meaning if Force is FALSE.  Else says
                     what the user wants us to do.

        FloatHardware - Indicates if there is any and whether it's on

        NTOK         - Indicates if first OS version with fix is what
                        we are running

        FdivError - if TRUE, FP gives WRONG answer, else, gives right answer
        CurrentForceValue - what the current force setting is

    All of these will be set before we do any work.

Arguments:

    argc - count of arguments, including the name of our proggram

    argv - argument list - see command line syntax above

Return Value:

    Exit(0) - nothing changed, and current state is OK

    Exit(1) - either a state change was requested, or just help,
                or the current state may have a problem.

    Exit(2) - we hit something really weird....


--*/
{
    CHAR    lBuf[16];
    DWORD   dwCodePage;
    LANGID  LangId;

    //
    // build up state vector in global booleans
    //
    ScanArgs(argc, argv);
    GetSystemState();
    TestForDivideError();

    /*
    printf("NeedHelp = %d  Force = %d  ForceValue = %d\n",
            NeedHelp, Force, ForceValue);
    printf("FDivError = %d  NTOK = %d  CurrentForceValue = %d  FloatHardware = %d\n",
            FDivError, NTOK, CurrentForceValue, FloatHardware);
    */

    // Since FormatMessage checks the current TEB's locale, and the Locale for
    // CHCP is initialized when the message class is initialized, the TEB has to
    // be updated after the code page is changed successfully.

    // Why are we doing this, you ask.  Well, the FE guys have plans to add
    // more than one set of language resources to this module, but not all
    // the possible resources.  So this limited set is what they plan for.
    // If FormatMessage can't find the right language, it falls back to
    // something hopefully useful.


    // Set the console output CP to OEMCP.
    SetConsoleOutputCP(GetOEMCP());

    dwCodePage = GetConsoleOutputCP();

    sprintf(lBuf, ".%d", dwCodePage);

    switch( dwCodePage )
    {
    case 932:
        LangId = MAKELANGID( LANG_JAPANESE, SUBLANG_DEFAULT );
        break;
    case 949:
        LangId = MAKELANGID( LANG_KOREAN, SUBLANG_KOREAN );
        break;
    case 936:
        LangId = MAKELANGID( LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED );
        break;
    case 950:
        LangId = MAKELANGID( LANG_CHINESE, SUBLANG_CHINESE_TRADITIONAL );
        break;
    default:
        LangId = PRIMARYLANGID(LANGIDFROMLCID( GetUserDefaultLCID() ));
        if (LangId == LANG_JAPANESE ||
            LangId == LANG_KOREAN   ||
            LangId == LANG_CHINESE    ) {
            LangId = MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US );
        }
        else {
            LangId = MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT );
        }
        break;
    }

    SetThreadLocale( MAKELCID(LangId, SORT_DEFAULT) );
    setlocale(LC_ALL, lBuf);

    //
    // ok, we know the state of the command and the machine, do work
    //

    //
    // if they asked for help, or did something that indicates they don't
    // understand how the program works, print help and exit.
    //
    if (NeedHelp) {
        printmessage(MSG_PENTBUG_HELP);
        exit(1);
    }

    //
    // never do anything if there's no floating point hardware in the box
    //
    if (FloatHardware == FLOAT_NONE) {
        printmessage(MSG_PENTBUG_NO_FLOAT_HARDWARE);
        exit(0);
    }

    //
    // never do anything if it's the wrong version of NT.
    //
    if (!NTOK) {
        printmessage(MSG_PENTBUG_NEED_NTOK);
        exit(1);
    }

    assert(NTOK == TRUE);
    assert(NeedHelp == FALSE);
    assert((FloatHardware == FLOAT_ON) || (FloatHardware == FLOAT_OFF));

    if (Force) {

        switch (ForceValue) {

        case FORCE_OFF:

            if (CurrentForceValue == FORCE_OFF) {

                if (FloatHardware == FLOAT_ON) {
                    //
                    // user wants fp on, fp is on, fp set to be on
                    // all is as it should be
                    //
                    printmessage(MSG_PENTBUG_IS_OFF_OK);
                    exit(FDivError);
                }

                if (FloatHardware == FLOAT_OFF) {
                    //
                    // user need to reboot to finish turning emulation off
                    //
                    printmessage(MSG_PENTBUG_IS_OFF_REBOOT);
                    exit(1);
                }

            } else {
                //
                // they want it off, it's not off, so turn it off
                // remind them to reboot
                //
                SetForceNpxEmulation(FORCE_OFF);
                printmessage(MSG_PENTBUG_TURNED_OFF);
                printmessage(MSG_PENTBUG_REBOOT);
                exit(1);
            }
            break;

        case FORCE_CONDITIONAL:

            if (CurrentForceValue == FORCE_CONDITIONAL) {

                if (FDivError) {
                    //
                    // tell them to reboot
                    //
                    printmessage(MSG_PENTBUG_IS_ON_COND_REBOOT);
                    exit(1);
                } else {
                    //
                    // tell them to be happy
                    //
                    printmessage(MSG_PENTBUG_IS_ON_COND_OK);
                    exit(0);
                }

            } else {
                //
                // set it to what they want and tell them to reboot
                //
                SetForceNpxEmulation(ForceValue);
                printmessage(MSG_PENTBUG_TURNED_ON_CONDITIONAL);
                printmessage(MSG_PENTBUG_REBOOT);
                exit(1);
            }
            break;

        case FORCE_ALWAYS:

            if (CurrentForceValue == FORCE_ALWAYS) {

                if (FloatHardware == FLOAT_OFF) {
                    //
                    // tell them to be happy
                    //
                    printmessage(MSG_PENTBUG_IS_ON_ALWAYS_OK);
                    exit(0);
                } else {
                    //
                    // tell them to reboot to finish
                    //
                    printmessage(MSG_PENTBUG_IS_ON_ALWAYS_REBOOT);
                    exit(1);
                }

            } else {
                SetForceNpxEmulation(ForceValue);
                printmessage(MSG_PENTBUG_TURNED_ON_ALWAYS);
                printmessage(MSG_PENTBUG_REBOOT);
                exit(1);
            }
            break;

        default:
            printf("pentnt: INTERNAL ERROR\n");
            exit(2);

        } // switch
    }



    //
    // no action requested, just report state and give advice
    //
    assert(Force == FALSE);

    if (!FDivError) {

        if (FloatHardware == FLOAT_ON) {
            printmessage(MSG_PENTBUG_FLOAT_WORKS);
        } else {
            printmessage(MSG_PENTBUG_EMULATION_ON_AND_WORKS);
        }
        exit(0);
    }

    //
    // since we're here, we have an fdiv error, tell user what to do about it
    //
    assert(FDivError);

    printmessage(MSG_PENTBUG_FDIV_ERROR);

    if ((CurrentForceValue == FORCE_CONDITIONAL) ||
        (CurrentForceValue == FORCE_ALWAYS))
    {
        printmessage(MSG_PENTBUG_IS_ON_REBOOT);
        exit(1);
    }

    printmessage(MSG_PENTBUG_CRITICAL_WORK);
    exit(1);

    assert((TRUE==FALSE));
}

VOID
SetForceNpxEmulation(
    ULONG   Setting
    )
/*++

Routine Description:

    SetForceNpxEmulation will simply set the ForceNpxEmulation value
    entry under the Session Manager key to the value passed in.
    0 = off
    1 = conditional
    2 = always

    If the set attempt fails, exit with a message.

--*/
{
    HKEY    hkey;
    LONG    rc;

    rc = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            TEXT("System\\CurrentControlSet\\Control\\Session Manager"),
            0,
            KEY_WRITE,
            &hkey
            );

    if (rc != ERROR_SUCCESS) {
        printmessage(MSG_PENTBUG_SET_FAILED, rc);
        exit(2);
    }

    rc = RegSetValueEx(
            hkey,
            TEXT("ForceNpxEmulation"),
            0,
            REG_DWORD,
            (unsigned char *)&Setting,
            sizeof(ULONG)
            );

    if (rc != ERROR_SUCCESS) {
        printmessage(MSG_PENTBUG_SET_FAILED, rc);
        exit(2);
    }

    return;
}

VOID
ScanArgs(
    int     argc,
    char    **argv
    )
/*++

Routine Description:

    ScanArgs - parse command line arguments, and set control flags
                to reflect what we find.

    Sets NeedHelp, Force, ForceValue.

Arguments:

    argc - count of command line args

    argv - argument vector

Return Value:

--*/
{
    int i;

    Force = FALSE;
    NeedHelp = FALSE;

    for (i = 1; i < argc; i++) {
        if ( ! ((argv[i][0] == '-') ||
                (argv[i][0] == '/')) )
        {
            NeedHelp = TRUE;
            goto done;
        }

        switch (argv[i][1]) {

        case '?':
        case 'h':
        case 'H':
            NeedHelp = TRUE;
            break;

        case 'c':
        case 'C':
            if (Force) {
                NeedHelp = TRUE;
            } else {
                Force = TRUE;
                ForceValue = FORCE_CONDITIONAL;
            }
            break;

        case 'f':
        case 'F':
            if (Force) {
                NeedHelp = TRUE;
            } else {
                Force = TRUE;
                ForceValue = FORCE_ALWAYS;
            }
            break;

        case 'o':
        case 'O':
            if (Force) {
                NeedHelp = TRUE;
            } else {
                Force = TRUE;
                ForceValue = FORCE_OFF;
            }
            break;

        default:
            NeedHelp = TRUE;
            goto done;
        }
    }

done:
    if (NeedHelp) {
        Force = FALSE;
    }
    return;
}

VOID
GetSystemState(
    )
/*++

Routine Description:

    GetSystemState - get the system version, whether the computer
                     has FP hardware or not, and whether the force
                     emulation switch is already set or not.

    Sets FloatHardware, NTOK, CurrentForceValue

Arguments:

Return Value:

--*/
{
    HKEY    hkey;
    TCHAR   Buffer[32];
    DWORD   BufferSize = 32;
    DWORD   Type;
    int     major;
    int     minor;
    LONG    rc;
    PULONG  p;
    OSVERSIONINFO   OsVersionInfo;

    NTOK = FALSE;

    //
    // decide if the system version is OK.
    //
    OsVersionInfo.dwOSVersionInfoSize = sizeof(OsVersionInfo);
    GetVersionEx(&OsVersionInfo);

    if (OsVersionInfo.dwPlatformId != VER_PLATFORM_WIN32_NT) {
        printmessage(MSG_PENTBUG_NOT_NT);
        exit(2);
    }

    if ( (OsVersionInfo.dwMajorVersion > 3) ||
         ( (OsVersionInfo.dwMajorVersion == 3) &&
           (OsVersionInfo.dwMinorVersion >= 51)   ))
    {
        //
        // build 3.51 or greater, it has the fix
        //
        NTOK = TRUE;

    } else if ( (OsVersionInfo.dwMajorVersion == 3) &&
                (OsVersionInfo.dwMinorVersion == 50))
    {
        if (OsVersionInfo.szCSDVersion[0] != (TCHAR)'\0') {
            //
            // we have a service pack for 3.5, since pack 1 and
            // later have the fix, it's OK
            //
            NTOK = TRUE;
        }
    }
    /*
    printf("debug NTOK forced true for testing\n\n\n");
    NTOK = TRUE;
    */


    //
    // determine if float hardware is present
    //
    rc = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            TEXT("Hardware\\Description\\System\\FloatingPointProcessor"),
            0,
            KEY_READ,
            &hkey
            );

    if (rc == ERROR_SUCCESS) {

        FloatHardware = FLOAT_ON;
        RegCloseKey(hkey);

    } else {

        rc = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                TEXT("Hardware\\Description\\System\\DisabledFloatingPointProcessor"),
                0,
                KEY_READ,
                &hkey
                );

        if (rc == ERROR_SUCCESS) {

            FloatHardware = FLOAT_OFF;
            RegCloseKey(hkey);

        } else {

            FloatHardware = FLOAT_NONE;

        }
    }

    //
    // determine if emulation has been forced on
    //
    rc = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            TEXT("System\\CurrentControlSet\\Control\\Session Manager"),
            0,
            KEY_READ,
            &hkey
            );

    if (rc != ERROR_SUCCESS) {
        return;
    }

    BufferSize = 32;
    rc = RegQueryValueEx(
            hkey,
            TEXT("ForceNpxEmulation"),
            0,
            &Type,
            (unsigned char *)Buffer,
            &BufferSize
            );

    if (  (rc == ERROR_SUCCESS) &&
          (Type == REG_DWORD)       )
    {
        p = (PULONG)Buffer;
        CurrentForceValue = *p;
    }

    return;
}

//
// these must be globals to make the compiler do the right thing
//

VOID
TestForDivideError(
    )
/*++

Routine Description:

    Do a divide with a known divident/divisor pair, followed by
    a multiply to see if we get the right answer back.

    FDivError = TRUE if we get the WRONG answer, FALSE.
Arguments:

Return Value:


--*/
{
    DWORD   pick;
    HANDLE  ph;
    DWORD   processmask;
    DWORD   systemmask;
    ULONG   i;

    //
    // fetch the affinity mask, which is also effectively a list
    // of processors
    //
    ph = GetCurrentProcess();
    GetProcessAffinityMask(ph, &processmask, &systemmask);

    //
    // step through the mask, testing each cpu.
    // if any is bad, we treat them all as bad
    //
    FDivError = FALSE;
    for (i = 0; i < 32; i++) {
        pick = 1 << i;

        if ((systemmask & pick) != 0) {

            //*//printf("pick = %08lx\n", pick);
            SetThreadAffinityMask(GetCurrentThread(), pick);

            //
            // call the official test function
            //
            if (ms_p5_test_fdiv()) {
                //
                // do NOT just assign func to FDivError, that will reset
                // it if a second cpu is good.  must be one way flag
                //
                FDivError = TRUE;
            }

        } // IF
    } // for
    return;
}

/***
* testfdiv.c - routine to test for correct operation of x86 FDIV instruction.
*
*Purpose:
*   Detects early steppings of Pentium with incorrect FDIV tables using
*   'official' Intel test values. Returns 1 if flawed Pentium is detected,
*   0 otherwise.
*
*/
int ms_p5_test_fdiv(void)
{
    double dTestDivisor = 3145727.0;
    double dTestDividend = 4195835.0;
    double dRslt;

    _asm {
        fld    qword ptr [dTestDividend]
        fdiv   qword ptr [dTestDivisor]
        fmul   qword ptr [dTestDivisor]
        fsubr  qword ptr [dTestDividend]
        fstp   qword ptr [dRslt]
    }

    return (dRslt > 1.0);
}


//
// Call FormatMessage and dump the result.  All messages to Stdout
//
void  printmessage (DWORD messageID, ...)
{
    unsigned short messagebuffer[4096];
    va_list ap;

    va_start(ap, messageID);

    FormatMessage(FORMAT_MESSAGE_FROM_HMODULE, NULL, messageID, 0,
                  messagebuffer, 4095, &ap);

    wprintf(messagebuffer);

    va_end(ap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\recover\recover.cxx ===
/*++

Copyright (c) 1991-2000 Microsoft Corporation

Module Name:

        recover.cxx

Abstract:

        Utility to recover data from a disk

Author:

        Norbert P. Kusters (norbertk) 12-June-1991

Revision History:

--*/

#define _NTAPI_ULIB_

#include "ulib.hxx"

#include "arg.hxx"
#include "smsg.hxx"
#include "rtmsg.h"
#include "wstring.hxx"
#include "path.hxx"

#include "system.hxx"
#include "ifssys.hxx"
#include "substrng.hxx"

#include "ulibcl.hxx"
#include "ifsentry.hxx"

int __cdecl
main(
    )
{
    STREAM_MESSAGE  Message;
    DSTRING         FsName;
    DSTRING         LibraryName;
    HANDLE          FsUtilityHandle;
    DSTRING         RecoverString;
    RECOVER_FN      Recover = NULL;

    ARGUMENT_LEXEMIZER  arglex;
    ARRAY               lex_array;
    ARRAY               arg_array;
    STRING_ARGUMENT     progname;
    FLAG_ARGUMENT       help_arg;
    PATH_ARGUMENT       path_arg;
    PWSTRING            dosdrive = NULL;
    DSTRING             ntdrive;
    NTSTATUS            Status;
    PPATH               CanonicalPath;
    PWSTRING            DirsAndName;
    PWSTRING            pwstring;

    if (!Message.Initialize(Get_Standard_Output_Stream(),
                            Get_Standard_Input_Stream())) {
        return 1;
    }

    if (!lex_array.Initialize() || !arg_array.Initialize()) {
        return 1;
    }

    if (!arglex.Initialize(&lex_array)) {
        return 1;
    }

    arglex.PutStartQuotes("\"");
    arglex.PutEndQuotes("\"");
    arglex.PutSeparators(" \t");
    arglex.SetCaseSensitive(FALSE);

    if (!arglex.PrepareToParse()) {
        return 1;
    }

    if (!progname.Initialize("*") ||
        !help_arg.Initialize("/?") ||
        !path_arg.Initialize("*")) {
        return 1;
    }

    if (!arg_array.Put(&progname) ||
        !arg_array.Put(&help_arg) ||
        !arg_array.Put(&path_arg)) {
        return 1;
    }

    if (!arglex.DoParsing(&arg_array)) {
        Message.Set(MSG_INVALID_PARAMETER);
        Message.Display("%W", pwstring = arglex.QueryInvalidArgument());
        DELETE(pwstring);
        return 1;
    }

    if (help_arg.QueryFlag()) {
        Message.Set(MSG_RECOV_INFO);
        Message.Display("");
        Message.Set(MSG_RECOV_USAGE);
        Message.Display("");
        Message.Set(MSG_RECOV_INFO2);
        Message.Display("");
        return 0;
    }

    if (!path_arg.IsValueSet()) {
        Message.Set(MSG_RECOV_USAGE);
        Message.Display("");
        return 1;
    }

    // Make sure that the user has specified a file name

    DirsAndName = path_arg.GetPath()->QueryDirsAndName();

    if (!DirsAndName || DirsAndName->QueryChCount() == 0) {

        Message.Set(MSG_RECOV_NOT_SUPPORTED);
        Message.Display("");
        DELETE(DirsAndName);
        return 1;
    }

    DELETE(DirsAndName);

    CanonicalPath = path_arg.GetPath()->QueryFullPath();

    dosdrive = CanonicalPath->QueryDevice();


    // Make sure that drive is not remote.

    if (!dosdrive ||
        SYSTEM::QueryDriveType(dosdrive) == RemoteDrive) {
        Message.Set(MSG_RECOV_CANT_NETWORK);
        Message.Display();
        DELETE(dosdrive);
        DELETE(CanonicalPath);
        return 1;
    }


    if (!IFS_SYSTEM::DosDriveNameToNtDriveName(dosdrive, &ntdrive)) {
        DELETE(dosdrive);
        DELETE(CanonicalPath);
        return 1;
    }


    if (!IFS_SYSTEM::QueryFileSystemName(&ntdrive, &FsName, &Status)) {

        if( Status == STATUS_ACCESS_DENIED ) {

            Message.Set( MSG_DASD_ACCESS_DENIED );
            Message.Display( "" );

        } else {

            Message.Set( MSG_FS_NOT_DETERMINED );
            Message.Display( "%W", dosdrive );
        }

        DELETE(dosdrive);
        DELETE(CanonicalPath);
        return 1;
    }

    Message.Set(MSG_FILE_SYSTEM_TYPE);
    Message.Display("%W", &FsName);

    if (!LibraryName.Initialize("U") ||
        !LibraryName.Strcat(&FsName) ||
        !RecoverString.Initialize("Recover")) {

        Message.Set(MSG_FMT_NO_MEMORY);
        Message.Display("");
        DELETE(dosdrive);
        DELETE(CanonicalPath);
        return(1);
    }


    if ((Recover = (RECOVER_FN)SYSTEM::QueryLibraryEntryPoint(&LibraryName,
                                                              &RecoverString,
                                                              &FsUtilityHandle))
                != NULL) {

        Recover(CanonicalPath, &Message);

        SYSTEM::FreeLibraryHandle(FsUtilityHandle);

    } else {

        Message.Set(MSG_FS_NOT_SUPPORTED);
        Message.Display("%s%W", "RECOVER", &FsName);
        Message.Set(MSG_BLANK_LINE);
        Message.Display("");
        DELETE(dosdrive);
        DELETE(CanonicalPath);
        return(1);
    }

    DELETE(dosdrive);
    DELETE(CanonicalPath);
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\recover\sources.inc ===
!IF 0

Copyright (c) 1989-2001 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

USE_MSVCRT=1

TARGETNAME=recover
TARGETPATH=obj
TARGETTYPE=PROGRAM

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\recover.rc ..\recover.cxx

INCLUDES=..\..\ulib\inc;..\..\ifsutil\inc;$(DDK_INC_PATH)

!IF "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "ntsd"
!IFDEF NOMEMLEAK
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DUNICODE=1
!ELSE
!IFDEF STACK_TRACE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DSTACK_TRACE -DUNICODE=1
!ELSE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DUNICODE=1
!ENDIF
!ENDIF
!ELSE    # NTDEBUG
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=0 -DUNICODE=1
!ENDIF   # NTDEBUG

TARGETLIBS= \
    ..\..\ulib\src\$(ALT_PROJECT)\$(O)\ulib.lib \
    ..\..\ifsutil\src\$(ALT_PROJECT)\$(O)\ifsutil.lib \
    $(SDK_LIB_PATH)\ntdll.lib

UMTYPE=console

W32_SB=1
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\reg\appvars.h ===
//
// appvars.h
//

#ifndef __APPVARS__
#define __APPVARS__
 

// if _UNICODE, build reg.exe for Win2000
// if ANSI, build reg98.exe for Win98
#ifdef REG_FOR_WIN2000
#undef REG_FOR_WIN2000
#endif
#ifdef _UNICODE
#define REG_FOR_WIN2000
#endif


#define  REG_EXE_FILEVERSION  _T("3.0")


#define  LENGTH_MESSAGE  512
#define  LENGTH_USAGE   2048

// options
#define STR_QUERY       _T("QUERY")
#define STR_ADD         _T("ADD")
#define STR_DELETE      _T("DELETE")
#define STR_COPY        _T("COPY")
#define STR_SAVE        _T("SAVE")
#define STR_RESTORE     _T("RESTORE")
#define STR_LOAD        _T("LOAD")
#define STR_UNLOAD      _T("UNLOAD")
#define STR_COMPARE     _T("COMPARE")
#define STR_EXPORT      _T("EXPORT")
#define STR_IMPORT      _T("IMPORT")


//
// ROOT Key String
//
#define STR_HKLM                    _T("HKLM")
#define STR_HKCU                    _T("HKCU")
#define STR_HKCR                    _T("HKCR")
#define STR_HKU                     _T("HKU")
#define STR_HKCC                    _T("HKCC")
#define STR_HKEY_LOCAL_MACHINE      _T("HKEY_LOCAL_MACHINE")
#define STR_HKEY_CURRENT_USER       _T("HKEY_CURRENT_USER")
#define STR_HKEY_CLASSES_ROOT       _T("HKEY_CLASSES_ROOT")
#define STR_HKEY_USERS              _T("HKEY_USERS")
#define STR_HKEY_CURRENT_CONFIG     _T("HKEY_CURRENT_CONFIG")
  

// Data type
#define  STR_REG_SZ                     _T("REG_SZ")
#define  STR_REG_EXPAND_SZ              _T("REG_EXPAND_SZ")
#define  STR_REG_MULTI_SZ               _T("REG_MULTI_SZ")
#define  STR_REG_BINARY                 _T("REG_BINARY")
#define  STR_REG_DWORD                  _T("REG_DWORD")
#define  STR_REG_DWORD_LITTLE_ENDIAN    _T("REG_DWORD_LITTLE_ENDIAN")
#define  STR_REG_DWORD_BIG_ENDIAN       _T("REG_DWORD_BIG_ENDIAN")
#define  STR_REG_NONE                   _T("REG_NONE")
#define  STR_REG_LINK                   _T("REG_LINK")
#define  STR_REG_RESOURCE_LIST          _T("REG_RESOURCE_LIST")


//
// #define Operations FLAGS
//
#define        REG_NOOPERATION          0
#define        REG_QUERY                1
#define        REG_ADD                  2
#define        REG_DELETE               4
#define        REG_COPY                 5
#define        REG_SAVE                 6
#define        REG_RESTORE              7
#define        REG_LOAD                 8
#define        REG_UNLOAD               9
#define        REG_COMPARE             10
#define        REG_EXPORT              11
#define        REG_IMPORT              12


//
// #define REG_STATUS return Codes
//
typedef        UINT    REG_STATUS;

#define        REG_STATUS_TOMANYPARAMS           50000
#define        REG_STATUS_TOFEWPARAMS            50001
#define        REG_STATUS_INVALIDPARAMS          50002
#define        REG_STATUS_BADOPERATION           50003
#define        REG_STATUS_HELP                   50004
#define        REG_STATUS_NONREMOTABLEROOT       50005
#define        REG_STATUS_NONLOADABLEROOT        50006
#define        REG_STATUS_COPYTOSELF             50007
#define        REG_STATUS_BADKEYNAME             50008
#define        REG_STATUS_NOKEYNAME              50009
#define        REG_STATUS_COMPARESELF            50010
#define        REG_STATUS_BADFILEFORMAT          50011
#define        REG_STATUS_NONREMOTABLE           50012


#define        PRINTTYPE_SAME              0
#define        PRINTTYPE_LEFT              1
#define        PRINTTYPE_RIGHT             2

#define        OUTPUTTYPE_NONE             0
#define        OUTPUTTYPE_DIFF             1
#define        OUTPUTTYPE_SAME             2
#define        OUTPUTTYPE_ALL              3


typedef struct _APPVARS 
{
    HKEY        hRootKey;
    UINT        nOperation;
    DWORD       dwRegDataType;
    BOOL        bUseRemoteMachine;
    BOOL        bCleanRemoteRootKey;
    BOOL        bRecurseSubKeys;
    BOOL        bAllValues;
    BOOL        bForce;
    BOOL        bNT4RegFile;
    BOOL        bHasDifference;
    int         nOutputType;
    TCHAR*      szFullKey;
    TCHAR*      szSubKey;
    TCHAR*      szValueName;
    TCHAR*      szMachineName;
    TCHAR*      szValue;
    TCHAR       szSeparator[3];

} APPVARS, *PAPPVARS;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\reg\add.c ===
//-----------------------------------------------------------------------//
//
// File:    add.cpp
// Created: March 1997
// By:      Martin Holladay (a-martih)
// Purpose: Registry Add (Write) Support for REG.CPP
// Modification History:
//      March 1997 (a-martih):
//          Copied from Query.cpp and modificd.
//      October 1997 (martinho)
//          Added additional termination character for MULTI_SZ strings.
//          Added \0 delimiter between MULTI_SZ strings items
//      April 1999 Zeyong Xu: re-design, revision -> version 2.0
//------------------------------------------------------------------------//

#include "stdafx.h"
#include "reg.h"


//-----------------------------------------------------------------------//
//
// AddRegistry()
//
//-----------------------------------------------------------------------//

LONG AddRegistry(PAPPVARS pAppVars, UINT argc, TCHAR *argv[])
{
    LONG        nResult;
    HKEY        hKey;
    DWORD       dwDisposition;
    BYTE*       byteData;


    //
    // Parse the cmd-line
    //
    nResult = ParseAddCmdLine(pAppVars, argc, argv);
    if(nResult != ERROR_SUCCESS)
    {
        return nResult;
    }

    //
    // Connect to the Remote Machine - if applicable
    //
    nResult = RegConnectMachine(pAppVars);
    if (nResult != ERROR_SUCCESS)
    {
        return nResult;
    }

    //
    // Create/Open the registry key
    //
    nResult = RegCreateKeyEx(pAppVars->hRootKey,
                             pAppVars->szSubKey,
                             0,
                             NULL,
                             REG_OPTION_NON_VOLATILE,
                             KEY_READ | KEY_WRITE,
                             NULL,
                             &hKey,
                             &dwDisposition);

    if( nResult == ERROR_SUCCESS &&
        pAppVars->szValueName )
    {
        // check value if existed
        DWORD dwType;
        DWORD dwLen = 1;
        nResult = RegQueryValueEx(hKey,
                                  pAppVars->szValueName,
                                  NULL,
                                  &dwType,
                                  NULL,
                                  &dwLen);
        if(nResult == ERROR_SUCCESS)
        {
            // if exist
            if(!Prompt(_T("Value %s exists, overwrite(Y/N)? "),
                       pAppVars->szValueName,
                       pAppVars->bForce) )
            {
                RegCloseKey(hKey);
                return nResult;
            }
        }

        nResult = ERROR_SUCCESS;
        switch(pAppVars->dwRegDataType)
        {
        case REG_DWORD:
        case REG_DWORD_BIG_ENDIAN:
//      case REG_DWORD_LITTLE_ENDIAN:
            //
            // auto convert szValue (hex, octal, decimal format) to dwData
            //
            {
                TCHAR* szStop = NULL;
                DWORD dwData = _tcstoul(pAppVars->szValue, &szStop, 0);
                if(_tcslen(szStop) > 0)  // invalid data format
                    nResult = REG_STATUS_INVALIDPARAMS;
                else
                    nResult = RegSetValueEx(hKey,
                                            pAppVars->szValueName,
                                            0,
                                            pAppVars->dwRegDataType,
                                            (BYTE*) &dwData,
                                            sizeof(DWORD));
            }
            break;

        case REG_BINARY:
            {

                TCHAR buff[3];
                LONG  onebyte;
                LONG  count = 0;
                TCHAR* szStart;
                TCHAR* szStop;

                //
                // Convert szValue (hex data string) to binary
                //
                dwLen = _tcslen(pAppVars->szValue);
                byteData = (BYTE*) calloc(dwLen/2 + dwLen%2,
                                                sizeof(BYTE));
                if (!byteData) {
                    nResult = ERROR_NOT_ENOUGH_MEMORY;
                    goto Cleanup;
                }

                
                buff[2] = _T('\0');

                count = 0;
                szStart = pAppVars->szValue;

                while(_tcslen(szStart) > 0)
                {
                    buff[0] = *szStart;
                    szStart++;
                    if(_tcslen(szStart) > 0)
                    {
                        buff[1] = *szStart;
                        szStart++;
                    }
                    else
                    {
                        buff[1] = _T('0');   // if half byte, append a '0'
                    }

                    // hex format
                    onebyte = _tcstol(buff, &szStop, 16);
                    if(_tcslen(szStop) > 0)  // invalid data format
                    {
                        nResult = REG_STATUS_INVALIDPARAMS;
                        break;
                    }
                    else
                    {
                        byteData[count] = (BYTE)(onebyte);
                    }

                    count++;
                }

                if(nResult == ERROR_SUCCESS)
                {
                    nResult = RegSetValueEx(hKey,
                                            pAppVars->szValueName,
                                            0,
                                            pAppVars->dwRegDataType,
                                            byteData,
                                            count);
                }

                if(byteData)
                    free(byteData);
            }
            break;

        case REG_SZ:
        case REG_EXPAND_SZ:
        case REG_NONE:
            dwLen = (_tcslen(pAppVars->szValue) + 1) * sizeof(TCHAR);
            nResult = RegSetValueEx(hKey,
                                    pAppVars->szValueName,
                                    0,
                                    pAppVars->dwRegDataType,
                                    (BYTE*) pAppVars->szValue,
                                    dwLen);
            break;

        case REG_MULTI_SZ:
            {
                BOOL  bErrorString = FALSE;
                DWORD dwLengthOfSeparator = _tcslen(pAppVars->szSeparator);
				BOOL bTrailing = FALSE;
                TCHAR* szData;
                TCHAR* pStart;
                TCHAR* pEnd;
                TCHAR* pString;


                //
                // Replace separator("\0") with '\0' for MULTI_SZ,
                // "\0" uses to separate string by default,
                // if two separators("\0\0"), error
                //
                dwLen = _tcslen(pAppVars->szValue);
                // calloc() initializes all char to 0
                szData = (TCHAR*) calloc(dwLen + 2, sizeof(TCHAR));
                pStart = pAppVars->szValue;
                pString = szData;

                if (!szData) {
                    nResult = ERROR_NOT_ENOUGH_MEMORY;
                    goto Cleanup;
                }

                while(_tcslen(pStart) > 0)
                {
                    pEnd = _tcsstr(pStart, pAppVars->szSeparator);
                    if(pEnd)
                    {
/*                      
						**** MODIFIED BY V-SMGUM ****

						    //two separators("\0\0") inside string
                        if( pEnd == pStart ||
                            //one separator("\0") in end of string
                            _tcslen(pEnd) == dwLengthOfSeparator)
                        {
                            bErrorString = TRUE;
                            break;
                        }
                        *pEnd = 0;
*/

						// 
						// MODIFIED BY V-SMGUM
						// THIS IS TO REMOVE THE TRAILING SEPERATOR EVEN IF IT IS SPECIFIED
						//

						// specifying two seperators in the data is error
						bTrailing = FALSE;
						if ( pEnd == pStart )
						{
                            bErrorString = TRUE;
                            break;
						}
						else if ( _tcslen( pEnd ) == dwLengthOfSeparator )
						{
							// set the flag
							bTrailing = TRUE;
						}
						*pEnd = 0;
                    }

					// do the concat only if start is having valid buffer
					_tcscat(pString, pStart);
					pString += _tcslen(pString) + 1;

                    if( pEnd && bTrailing == FALSE )
                        pStart = pEnd + dwLengthOfSeparator;
                    else
                        break;
                }

                // empty
                if(_tcsicmp(pAppVars->szValue, pAppVars->szSeparator) == 0)
                {
                    pString = szData + 2;
                    bErrorString = FALSE;
                }
                else
                    pString += 1; // double null terminated string

                if(bErrorString)
                {
                    nResult = REG_STATUS_INVALIDPARAMS;
                }
                else
                {
                    DWORD dwByteToWrite = (DWORD)((pString - szData) * sizeof(TCHAR));

                    nResult = RegSetValueEx(hKey,
                                        pAppVars->szValueName,
                                        0,
                                        pAppVars->dwRegDataType,
                                        (BYTE*) szData,
                                        dwByteToWrite);
                }

                if(szData)
                    free(szData);
            }
            break;

        default:
            nResult = REG_STATUS_INVALIDPARAMS;
            break;
        }

        RegCloseKey(hKey);
    }

Cleanup:
    return nResult;
}

//------------------------------------------------------------------------//
//
// ParseAddCmdLine()
//
//------------------------------------------------------------------------//

REG_STATUS ParseAddCmdLine(PAPPVARS pAppVars, UINT argc, TCHAR *argv[])
{
    REG_STATUS nResult = ERROR_SUCCESS;
    UINT i;
    BOOL bHasType = FALSE;

    if(argc < 3)
    {
        return REG_STATUS_TOFEWPARAMS;
    }

    // Machine Name and Registry key
    //
    nResult = BreakDownKeyString(argv[2], pAppVars);
    if(nResult != ERROR_SUCCESS)
        return nResult;

    // parsing
    for(i=3; i<argc; i++)
    {
        if(!_tcsicmp(argv[i], _T("/v")))
        {
            if(pAppVars->szValueName)
                return REG_STATUS_INVALIDPARAMS;

            i++;
            if(i<argc)
            {
                pAppVars->szValueName = (TCHAR*) calloc(_tcslen(argv[i]) + 1,
                                                        sizeof(TCHAR));
                if (!pAppVars->szValueName) {
                    return ERROR_NOT_ENOUGH_MEMORY;
                }
                _tcscpy(pAppVars->szValueName, argv[i]);
            }
            else
                return REG_STATUS_TOFEWPARAMS;
        }
        else if(!_tcsicmp(argv[i], _T("/ve")))
        {
            if(pAppVars->szValueName)
                return REG_STATUS_INVALIDPARAMS;

            pAppVars->szValueName = (TCHAR*) calloc(1, sizeof(TCHAR));
            if (!pAppVars->szValueName) {
                return ERROR_NOT_ENOUGH_MEMORY;
            }
        }
        else if(!_tcsicmp(argv[i], _T("/t")))
        {
            i++;
            if(i<argc)
            {
                pAppVars->dwRegDataType = IsRegDataType(argv[i]);
                if(pAppVars->dwRegDataType == (DWORD)-1)
                {
                    return REG_STATUS_INVALIDPARAMS;
                }

                bHasType = TRUE;
            }
            else
                return REG_STATUS_TOFEWPARAMS;
        }
        else if(!_tcsicmp(argv[i], _T("/s")))
        {
            if(pAppVars->dwRegDataType != REG_MULTI_SZ)
                return REG_STATUS_INVALIDPARAMS;

            i++;
            if(i<argc)
            {
                if(_tcslen(argv[i]) == 1)
                {
                    _tcscpy(pAppVars->szSeparator, argv[i]);
                }
                else
                    return REG_STATUS_INVALIDPARAMS;
            }
            else
                return REG_STATUS_TOFEWPARAMS;
        }
        else if(!_tcsicmp(argv[i], _T("/d")))
        {
            if(pAppVars->szValue)
                return REG_STATUS_INVALIDPARAMS;

            i++;
            if(i<argc)
            {
                pAppVars->szValue = (TCHAR*) calloc(_tcslen(argv[i]) + 1,
                                                    sizeof(TCHAR));
                if (!pAppVars->szValue) {
                    return ERROR_NOT_ENOUGH_MEMORY;
                }
                _tcscpy(pAppVars->szValue, argv[i]);
            }
            else
                return REG_STATUS_TOFEWPARAMS;
        }
        else if(!_tcsicmp(argv[i], _T("/f")))
        {
            pAppVars->bForce = TRUE;
        }
        else
            return REG_STATUS_TOMANYPARAMS;
    }

    // if no value, set to empty value data
    if(pAppVars->szValueName && !pAppVars->szValue)
    {
        pAppVars->szValue = (TCHAR*) calloc(1, sizeof(TCHAR));
        if (!pAppVars->szValue) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        *(pAppVars->szValue) = 0;
    }
    else if( !pAppVars->szValueName &&
        (bHasType || pAppVars->szValue) )
    {
        return REG_STATUS_INVALIDPARAMS;
    }

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\reg\compare.c ===
//-----------------------------------------------------------------------//
//
// File:    compare.cpp
// Created: April 1999
// By:      Zeyong Xu
// Purpose: Compare two registry key
//
//------------------------------------------------------------------------//

#include "stdafx.h"
#include "reg.h"
#include "compare.h"


BOOL  g_bHasDifference = FALSE;


//-----------------------------------------------------------------------//
//
// CompareRegistry()
//
//-----------------------------------------------------------------------//

LONG CompareRegistry(PAPPVARS pAppVars,
                     PAPPVARS pDstVars,
                     UINT argc,
                     TCHAR *argv[])
{
    LONG        nResult;
    HKEY        hLeftKey;
    HKEY        hRightKey;

    //
    // Parse the cmd-line
    //
    nResult = ParseCompareCmdLine(pAppVars, pDstVars, argc, argv);
    if (nResult != ERROR_SUCCESS)
    {
        return nResult;
    }

    //
    // Connect to the Remote Machine(s) - if applicable
    //
    nResult = RegConnectMachine(pAppVars);
    if (nResult != ERROR_SUCCESS)
    {
        return nResult;
    }
    nResult = RegConnectMachine(pDstVars);
    if (nResult != ERROR_SUCCESS)
    {
        return nResult;
    }

    //
    // Now implement the body of the Compare Operation
    //
    nResult = RegOpenKeyEx(pAppVars->hRootKey,
                           pAppVars->szSubKey,
                           0,
                           KEY_READ,
                           &hLeftKey);
    if (nResult != ERROR_SUCCESS)
    {
        return nResult;
    }

    nResult = RegOpenKeyEx(pDstVars->hRootKey,
                           pDstVars->szSubKey,
                           0,
                           KEY_READ,
                           &hRightKey);
    if (nResult != ERROR_SUCCESS)
    {
        return nResult;
    }

    // if try to compare the same keys
    if (pAppVars->hRootKey == pDstVars->hRootKey &&
        _tcsicmp(pAppVars->szFullKey, pDstVars->szFullKey) == 0)
    {
        RegCloseKey(hLeftKey);
        RegCloseKey(hRightKey);
        return REG_STATUS_COMPARESELF;
    }

    //
    // compare a single value if pAppVars->szValueName is not NULL
    //
    if(pAppVars->szValueName)
    {
        nResult = CompareValues(hLeftKey,
                                pAppVars->szFullKey,
                                hRightKey,
                                pDstVars->szFullKey,
                                pAppVars->szValueName,
                                pAppVars->nOutputType);
    }
    else
    {
        //
        // Recursively compare if pAppVars->bRecurseSubKeys is true
        //
        nResult = CompareEnumerateKey(hLeftKey,
                                      pAppVars->szFullKey,
                                      hRightKey,
                                      pDstVars->szFullKey,
                                      pAppVars->nOutputType,
                                      pAppVars->bRecurseSubKeys);
    }

    if(nResult == ERROR_SUCCESS)
    {
        pAppVars->bHasDifference = g_bHasDifference;
        if(g_bHasDifference)
            MyTPrintf(stdout,_T("\r\nResult Compared:  Different\r\n"));
        else
            MyTPrintf(stdout,_T("\r\nResult Compared:  Identical\r\n"));
    }
    //
    // lets clean up
    //
    RegCloseKey(hLeftKey);
    RegCloseKey(hRightKey);

    return nResult;
}


REG_STATUS ParseCompareCmdLine(PAPPVARS pAppVars,
                            PAPPVARS pDstVars,
                            UINT argc,
                            TCHAR *argv[])
{
    UINT        i;
    REG_STATUS  nResult = ERROR_SUCCESS;
    BOOL bInvalidParams = FALSE;


    //
    // Do we have a *valid* number of cmd-line params
    //
    if(argc < 4)
    {
        return REG_STATUS_TOFEWPARAMS;
    }
    else if(argc > 8)
    {
        return REG_STATUS_TOMANYPARAMS;
    }

    //
    // Left Machine Name and Registry key
    //
    nResult = BreakDownKeyString(argv[2], pAppVars);
    if(nResult != ERROR_SUCCESS)
        return nResult;

    //
    // Right Machine Name and Registry key
    //
    nResult = BreakDownKeyString(argv[3], pDstVars);
    if(nResult == REG_STATUS_NOKEYNAME)
    {
        // if no keyname for right side is specified,
        // they are comparing the same key name
        nResult = CopyKeyNameFromLeftToRight(pAppVars, pDstVars);
    }
    if( nResult != ERROR_SUCCESS)
        return nResult;

    // parsing
    for(i=4; i<argc; i++)
    {
        if(!_tcsicmp(argv[i], _T("/v")))
        {
            if(bInvalidParams || pAppVars->bRecurseSubKeys)
                return REG_STATUS_INVALIDPARAMS;
            bInvalidParams = TRUE;

            i++;
            if(i<argc)
            {
                pAppVars->szValueName = (TCHAR*) calloc(_tcslen(argv[i]) + 1,
                                                        sizeof(TCHAR));
                if (!pAppVars->szValueName) {
                    return ERROR_NOT_ENOUGH_MEMORY;
                }
                _tcscpy(pAppVars->szValueName, argv[i]);
            }
            else
                return REG_STATUS_TOFEWPARAMS;
        }
        else if(!_tcsicmp(argv[i], _T("/ve")))
        {
            if(bInvalidParams || pAppVars->bRecurseSubKeys)
                return REG_STATUS_INVALIDPARAMS;
            bInvalidParams = TRUE;

            pAppVars->szValueName = (TCHAR*) calloc(1, sizeof(TCHAR));
            if (!pAppVars->szValueName) {
                return ERROR_NOT_ENOUGH_MEMORY;
            }
        }
        else if(!_tcsicmp(argv[i], _T("/oa")))
        {
            if(bInvalidParams)
                return REG_STATUS_INVALIDPARAMS;
            bInvalidParams = TRUE;

            pAppVars->nOutputType = OUTPUTTYPE_ALL;
        }
        else if(!_tcsicmp(argv[i], _T("/od")))
        {
            if(bInvalidParams)
                return REG_STATUS_INVALIDPARAMS;
            bInvalidParams = TRUE;

            pAppVars->nOutputType = OUTPUTTYPE_DIFF;
        }
        else if(!_tcsicmp(argv[i], _T("/os")))
        {
            if(bInvalidParams)
                return REG_STATUS_INVALIDPARAMS;
            bInvalidParams = TRUE;

            pAppVars->nOutputType = OUTPUTTYPE_SAME;
        }
        else if(!_tcsicmp(argv[i], _T("/on")))
        {
            if(bInvalidParams)
                return REG_STATUS_INVALIDPARAMS;
            bInvalidParams = TRUE;

            pAppVars->nOutputType = OUTPUTTYPE_NONE;
        }
        else if(!_tcsicmp(argv[i], _T("/s")))
        {
            if(pAppVars->szValueName)
                return REG_STATUS_INVALIDPARAMS;

            pAppVars->bRecurseSubKeys = TRUE;
        }
        else
        {
            nResult = REG_STATUS_INVALIDPARAMS;
        }
    }

    return nResult;
}

REG_STATUS CopyKeyNameFromLeftToRight(APPVARS* pAppVars, APPVARS* pDstVars)
{
    // check if rootkey is remotable for right side
    if( pDstVars->bUseRemoteMachine &&
        !(pAppVars->hRootKey == HKEY_USERS ||
          pAppVars->hRootKey == HKEY_LOCAL_MACHINE) )
    {
        return REG_STATUS_NONREMOTABLEROOT;
    }

    pDstVars->szFullKey = (TCHAR*) calloc(_tcslen(pAppVars->szFullKey) + 1,
                                          sizeof(TCHAR));

    if (!pDstVars->szFullKey)
        return ERROR_NOT_ENOUGH_MEMORY;

    pDstVars->szSubKey = (TCHAR*) calloc(_tcslen(pAppVars->szSubKey) + 1,
                                          sizeof(TCHAR));

    if (!pDstVars->szSubKey) {
        free (pDstVars->szFullKey);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    _tcscpy(pDstVars->szFullKey, pAppVars->szFullKey);

    pDstVars->hRootKey = pAppVars->hRootKey;

    _tcscpy(pDstVars->szSubKey, pAppVars->szSubKey);

    return ERROR_SUCCESS;
}

//-----------------------------------------------------------------------//
//
// EnumerateKey() - Recursive
//
//-----------------------------------------------------------------------//
LONG CompareEnumerateKey(HKEY hLeftKey,
                         TCHAR* szLeftFullKeyName,
                         HKEY hRightKey,
                         TCHAR* szRightFullKeyName,
                         int nOutputType,
                         BOOL bRecurseSubKeys)
{
    DWORD   nResult;
    DWORD   dwSize;
    TCHAR*  pszLeftNameBuf;
    TCHAR*  pszRightNameBuf;
    TCHAR** pLeftArray;
    TCHAR** pRightArray;
    DWORD   dwIndex;
    DWORD dwNumOfLeftKeyName;
    DWORD dwLenOfLeftKeyName;
    DWORD dwNumOfRightKeyName;
    DWORD dwLenOfRightKeyName;
    DWORD dw;
    HKEY hLeftSubKey;
    HKEY hRightSubKey;


    // enumerate all values under current key
    nResult = CompareEnumerateValueName(hLeftKey,
                                        szLeftFullKeyName,
                                        hRightKey,
                                        szRightFullKeyName,
                                        nOutputType);

    if(!bRecurseSubKeys || nResult != ERROR_SUCCESS)
        return nResult;

    // enum all subkeys

    // query left key info
    nResult = RegQueryInfoKey(hLeftKey,
                              NULL,
                              NULL,
                              NULL,
                              &dwNumOfLeftKeyName,
                              &dwLenOfLeftKeyName,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL);

    if (nResult != ERROR_SUCCESS)
    {
        return nResult;
    }

    // query right key info
    nResult = RegQueryInfoKey(hRightKey,
                              NULL,
                              NULL,
                              NULL,
                              &dwNumOfRightKeyName,
                              &dwLenOfRightKeyName,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL);

    if (nResult != ERROR_SUCCESS)
    {
        return nResult;
    }

#ifndef REG_FOR_WIN2000    // ansi version for win98
    // fix API bugs:  RegQueryInfoKey() returns non-correct length values
    //                on remote Win98
    if(dwLenOfLeftKeyName < MAX_PATH)
        dwLenOfLeftKeyName = MAX_PATH;
    if(dwLenOfRightKeyName < MAX_PATH)
        dwLenOfRightKeyName = MAX_PATH;
#endif

    //
    // enumerate all of the subkeys in left key
    //
    dwLenOfLeftKeyName++;
    pszLeftNameBuf = (TCHAR*) calloc(dwNumOfLeftKeyName *
                                        dwLenOfLeftKeyName,
                                     sizeof(TCHAR));
    if (!pszLeftNameBuf) {
        nResult = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }
    // index array of name buffer for compare
    pLeftArray = (TCHAR**) calloc(dwNumOfLeftKeyName, sizeof(TCHAR*));
    if (!pLeftArray) {
        nResult = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    dwIndex = 0;
    while(dwIndex < dwNumOfLeftKeyName && nResult == ERROR_SUCCESS)
    {
        pLeftArray[dwIndex] = pszLeftNameBuf +
                              (dwIndex * dwLenOfLeftKeyName);
        dwSize = dwLenOfLeftKeyName;
        nResult = RegEnumKeyEx(hLeftKey,
                               dwIndex,
                               pLeftArray[dwIndex],
                               &dwSize,
                               NULL,
                               NULL,
                               NULL,
                               NULL);
        dwIndex++;
    }

    if (nResult != ERROR_SUCCESS)
    {
        if(pszLeftNameBuf)
            free(pszLeftNameBuf);
        if(pLeftArray)
            free(pLeftArray);
        return nResult;
    }

    //
    // enumerate all of the subkeys in right key
    //
    dwLenOfRightKeyName++;
    pszRightNameBuf = (TCHAR*) calloc(dwNumOfRightKeyName *
                                        dwLenOfRightKeyName,
                                     sizeof(TCHAR));
    if (!pszRightNameBuf) {
        nResult = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }
    // index array of name buffer for compare
    pRightArray = (TCHAR**) calloc(dwNumOfRightKeyName, sizeof(TCHAR*));
    if (!pRightArray) {
        nResult = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    dwIndex = 0;
    while(dwIndex < dwNumOfRightKeyName && nResult == ERROR_SUCCESS)
    {
        pRightArray[dwIndex] = pszRightNameBuf +
                               (dwIndex * dwLenOfRightKeyName);
        dwSize = dwLenOfRightKeyName;
        nResult = RegEnumKeyEx(hRightKey,
                               dwIndex,
                               pRightArray[dwIndex],
                               &dwSize,
                               NULL,
                               NULL,
                               NULL,
                               NULL);
        dwIndex++;
    }

    if (nResult != ERROR_SUCCESS)
    {
        if(pszLeftNameBuf)
            free(pszLeftNameBuf);
        if(pLeftArray)
            free(pLeftArray);
        if(pszRightNameBuf)
            free(pszRightNameBuf);
        if(pRightArray)
            free(pRightArray);
        return nResult;
    }

    // compare two subkey name array to find the same subkey
    for(dwIndex = 0;
        dwIndex < dwNumOfLeftKeyName && nResult == ERROR_SUCCESS;
        dwIndex++)
    {
        if(pLeftArray[dwIndex] == NULL)
            continue;

        for(dw = 0;
            dw < dwNumOfRightKeyName && nResult == ERROR_SUCCESS;
            dw++)
        {
            if(pRightArray[dw] == NULL)
                continue;

            // if same subey name, recusive
            if(_tcsicmp(pLeftArray[dwIndex], pRightArray[dw]) == 0)
            {
                TCHAR* szTempLeft;
                TCHAR* szTempRight;

                // print out key
                if( nOutputType == OUTPUTTYPE_SAME ||
                    nOutputType == OUTPUTTYPE_ALL )
                {
                    nResult = PrintKey(hLeftKey,
                                       szLeftFullKeyName,
                                       pLeftArray[dwIndex],
                                       PRINTTYPE_SAME);
                    if(nResult != ERROR_SUCCESS)
                        break;
                }

                //
                // Now implement the body of the Compare Operation
                //
                nResult = RegOpenKeyEx(hLeftKey,
                                       pLeftArray[dwIndex],
                                       0,
                                       KEY_READ,
                                       &hLeftSubKey);
                if (nResult != ERROR_SUCCESS)
                    break;

                nResult = RegOpenKeyEx(hRightKey,
                                       pLeftArray[dwIndex],
                                       0,
                                       KEY_READ,
                                       &hRightSubKey);
                if (nResult != ERROR_SUCCESS)
                    break;

                // create left full subkey
                szTempLeft = (TCHAR*) calloc(_tcslen(szLeftFullKeyName) +
                                          _tcslen(pLeftArray[dwIndex]) +
                                          2,
                                          sizeof(TCHAR));
                if (!szTempLeft) {
                    nResult = ERROR_NOT_ENOUGH_MEMORY;
                    goto Cleanup;
                }
                _tcscpy(szTempLeft, szLeftFullKeyName);
                _tcscat(szTempLeft, _T("\\"));
                _tcscat(szTempLeft, pLeftArray[dwIndex]);
                // create right full subkey
                szTempRight = (TCHAR*) calloc(_tcslen(szRightFullKeyName) +
                                          _tcslen(pLeftArray[dwIndex]) +
                                          2,
                                          sizeof(TCHAR));
                if (!szTempRight) {
                    free (szTempLeft);
                    nResult = ERROR_NOT_ENOUGH_MEMORY;
                    goto Cleanup;
                }
                _tcscpy(szTempRight, szRightFullKeyName);
                _tcscat(szTempRight, _T("\\"));
                _tcscat(szTempRight, pLeftArray[dwIndex]);

                // recursive to compare subkeys
                nResult = CompareEnumerateKey(hLeftSubKey,
                                              szLeftFullKeyName,
                                              hRightSubKey,
                                              szRightFullKeyName,
                                              nOutputType,
                                              bRecurseSubKeys);

                if(szTempLeft) {
                    free(szTempLeft);
                }
                if(szTempRight) {
                    free(szTempRight);
                }

                RegCloseKey(hLeftSubKey);
                RegCloseKey(hRightSubKey);

                pLeftArray[dwIndex] = NULL;
                pRightArray[dw] = NULL;
                break;
            }
        }
    }

    // Output subkey name in left key
    for(dwIndex = 0;
        dwIndex < dwNumOfLeftKeyName && nResult == ERROR_SUCCESS;
        dwIndex++)
    {
        if(pLeftArray[dwIndex] == NULL)
            continue;

        if( nOutputType == OUTPUTTYPE_DIFF ||
            nOutputType == OUTPUTTYPE_ALL )
        {
            nResult = PrintKey(hLeftKey,
                               szLeftFullKeyName,
                               pLeftArray[dwIndex],
                               PRINTTYPE_LEFT);
        }
        g_bHasDifference = TRUE;
    }
    // Output subkey name in right key
    for(dwIndex = 0;
        dwIndex < dwNumOfRightKeyName && nResult == ERROR_SUCCESS;
        dwIndex++)
    {
        if(pRightArray[dwIndex] == NULL)
            continue;

        if( nOutputType == OUTPUTTYPE_DIFF ||
            nOutputType == OUTPUTTYPE_ALL )
        {
            nResult = PrintKey(hRightKey,
                               szRightFullKeyName,
                               pRightArray[dwIndex],
                               PRINTTYPE_RIGHT);
        }
        g_bHasDifference = TRUE;
    }

Cleanup:

    if(pszLeftNameBuf)
        free(pszLeftNameBuf);
    if(pLeftArray)
        free(pLeftArray);
    if(pszRightNameBuf)
        free(pszRightNameBuf);
    if(pRightArray)
        free(pRightArray);

    return nResult;
}

LONG CompareEnumerateValueName(HKEY hLeftKey,
                               TCHAR* szLeftFullKeyName,
                               HKEY hRightKey,
                               TCHAR* szRightFullKeyName,
                               int nOutputType)

{
    DWORD   nResult = ERROR_SUCCESS;
    DWORD   dwSize;
    TCHAR*  pszLeftNameBuf = NULL;
    TCHAR*  pszRightNameBuf = NULL;
    TCHAR** pLeftArray = NULL;
    TCHAR** pRightArray = NULL;
    DWORD   dwIndex;
    DWORD dwNumOfRightValueName;
    DWORD dwLenOfRightValueName;
    DWORD dw;


    // query left key info
    DWORD dwNumOfLeftValueName;
    DWORD dwLenOfLeftValueName;
    nResult = RegQueryInfoKey(hLeftKey,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              &dwNumOfLeftValueName,
                              &dwLenOfLeftValueName,
                              NULL,
                              NULL,
                              NULL);

    if (nResult != ERROR_SUCCESS)
    {
        return nResult;
    }

    // query right key info
    nResult = RegQueryInfoKey(hRightKey,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              &dwNumOfRightValueName,
                              &dwLenOfRightValueName,
                              NULL,
                              NULL,
                              NULL);

    if (nResult != ERROR_SUCCESS)
    {
        return nResult;
    }

#ifndef REG_FOR_WIN2000    // ansi version for win98
    // fix API bugs:  RegQueryInfoKey() returns non-correct length values
    //                on remote Win98
    if(dwLenOfLeftValueName < MAX_PATH)
        dwLenOfLeftValueName = MAX_PATH;
    if(dwLenOfRightValueName < MAX_PATH)
        dwLenOfRightValueName = MAX_PATH;
#endif

    //
    // enumerate all of the values in left key
    //
    dwLenOfLeftValueName++;
    pszLeftNameBuf = (TCHAR*) calloc(dwNumOfLeftValueName *
                                        dwLenOfLeftValueName,
                                     sizeof(TCHAR));
    if (!pszLeftNameBuf) {
        nResult = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    // index array of name buffer for compare
    pLeftArray = (TCHAR**) calloc(dwNumOfLeftValueName, sizeof(TCHAR*));
    if (!pLeftArray) {
        nResult = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    dwIndex = 0;
    while(dwIndex < dwNumOfLeftValueName && nResult == ERROR_SUCCESS)
    {
        pLeftArray[dwIndex] = pszLeftNameBuf +
                              (dwIndex * dwLenOfLeftValueName);
        dwSize = dwLenOfLeftValueName;
        nResult = RegEnumValue(hLeftKey,
                               dwIndex,
                               pLeftArray[dwIndex],
                               &dwSize,
                               NULL,
                               NULL,
                               NULL,
                               NULL);
        dwIndex++;
    }

    if (nResult != ERROR_SUCCESS)
    {
        if(pszLeftNameBuf)
            free(pszLeftNameBuf);
        if(pLeftArray)
            free(pLeftArray);
        return nResult;
    }

    //
    // enumerate all of the values in right key
    //
    dwLenOfRightValueName++;
    pszRightNameBuf = (TCHAR*) calloc(dwNumOfRightValueName *
                                        dwLenOfRightValueName,
                                     sizeof(TCHAR));
    if (!pszRightNameBuf) {
        nResult = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }
    // index array of name buffer for compare
    pRightArray = (TCHAR**) calloc(dwNumOfRightValueName, sizeof(TCHAR*));
    if (!pRightArray) {
        nResult = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    dwIndex = 0;
    while(dwIndex < dwNumOfRightValueName && nResult == ERROR_SUCCESS)
    {
        pRightArray[dwIndex] = pszRightNameBuf +
                               (dwIndex * dwLenOfRightValueName);
        dwSize = dwLenOfRightValueName;
        nResult = RegEnumValue(hRightKey,
                               dwIndex,
                               pRightArray[dwIndex],
                               &dwSize,
                               NULL,
                               NULL,
                               NULL,
                               NULL);
        dwIndex++;
    }

    if (nResult != ERROR_SUCCESS)
    {
        if(pszLeftNameBuf)
            free(pszLeftNameBuf);
        if(pLeftArray)
            free(pLeftArray);
        if(pszRightNameBuf)
            free(pszRightNameBuf);
        if(pRightArray)
            free(pRightArray);
        return nResult;
    }

    // compare two valuename array to find the same valuename
    for(dwIndex = 0;
        dwIndex < dwNumOfLeftValueName && nResult == ERROR_SUCCESS;
        dwIndex++)
    {
        if(pLeftArray[dwIndex] == NULL)
            continue;

        for(dw = 0;
            dw < dwNumOfRightValueName && nResult == ERROR_SUCCESS;
            dw++)
        {
            if(pRightArray[dw] == NULL)
                continue;

            // same valuename
            if(_tcsicmp(pLeftArray[dwIndex], pRightArray[dw]) == 0)
            {
                nResult = CompareValues(hLeftKey,
                                        szLeftFullKeyName,
                                        hRightKey,
                                        szRightFullKeyName,
                                        pLeftArray[dwIndex],
                                        nOutputType);
                pLeftArray[dwIndex] = NULL;
                pRightArray[dw] = NULL;
                break;
            }
        }
    }

    // Output different valuename in left key
    for(dwIndex = 0;
        dwIndex < dwNumOfLeftValueName && nResult == ERROR_SUCCESS;
        dwIndex++)
    {
        if(pLeftArray[dwIndex] == NULL)
            continue;

        if( nOutputType == OUTPUTTYPE_DIFF ||
            nOutputType == OUTPUTTYPE_ALL )
        {
            nResult = OutputValue(hLeftKey,
                                  szLeftFullKeyName,
                                  pLeftArray[dwIndex],
                                  PRINTTYPE_LEFT);
        }
        g_bHasDifference = TRUE;
    }
    // Output different valuename in right key
    for(dwIndex = 0;
        dwIndex < dwNumOfRightValueName && nResult == ERROR_SUCCESS;
        dwIndex++)
    {
        if(pRightArray[dwIndex] == NULL)
            continue;

        if( nOutputType == OUTPUTTYPE_DIFF ||
            nOutputType == OUTPUTTYPE_ALL )
        {
            nResult = OutputValue(hRightKey,
                                  szRightFullKeyName,
                                  pRightArray[dwIndex],
                                  PRINTTYPE_RIGHT);
        }
        g_bHasDifference = TRUE;
    }

Cleanup:

    if(pszLeftNameBuf)
        free(pszLeftNameBuf);
    if(pLeftArray)
        free(pLeftArray);
    if(pszRightNameBuf)
        free(pszRightNameBuf);
    if(pRightArray)
        free(pRightArray);

    return nResult;
}


//-----------------------------------------------------------------------//
//
// CompareValues()
//
//-----------------------------------------------------------------------//

LONG CompareValues(HKEY hLeftKey,
                   TCHAR* szLeftFullKeyName,
                   HKEY hRightKey,
                   TCHAR* szRightFullKeyName,
                   TCHAR* szValueName,
                   int nOutputType)
{

    LONG        nResult;
    DWORD       dwTypeLeft;
    DWORD       dwTypeRight;
    DWORD       dwSizeLeft;
    DWORD       dwSizeRight;
    BYTE*       pDataBuffLeft = NULL;
    BYTE*       pDataBuffRight = NULL;

    //
    // First find out how much memory to allocate
    //
    nResult = RegQueryValueEx(hLeftKey,
                              szValueName,
                              0,
                              &dwTypeLeft,
                              NULL,
                              &dwSizeLeft);
    if (nResult != ERROR_SUCCESS)
    {
        return nResult;
    }
    nResult = RegQueryValueEx(hRightKey,
                              szValueName,
                              0,
                              &dwTypeRight,
                              NULL,
                              &dwSizeRight);
    if (nResult != ERROR_SUCCESS)
    {
        return nResult;
    }

    pDataBuffLeft = (BYTE*) calloc(dwSizeLeft + 1, sizeof(BYTE));
    if (!pDataBuffLeft) {
        nResult = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }
    pDataBuffRight = (BYTE*) calloc(dwSizeRight + 1, sizeof(BYTE));

    if (!pDataBuffRight) {
        nResult = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // Now get the data
    //
    nResult = RegQueryValueEx(hLeftKey,
                              szValueName,
                              0,
                              &dwTypeLeft,
                              (LPBYTE) pDataBuffLeft,
                              &dwSizeLeft);

    if (nResult == ERROR_SUCCESS)
    {
        nResult = RegQueryValueEx(hRightKey,
                                  szValueName,
                                  0,
                                  &dwTypeRight,
                                  (LPBYTE) pDataBuffRight,
                                  &dwSizeRight);
    }

    if(nResult != ERROR_SUCCESS)
    {
        if(pDataBuffLeft)
            free(pDataBuffLeft);
        if(pDataBuffRight)
            free(pDataBuffRight);
        return nResult;
    }

    if( dwTypeLeft != dwTypeRight ||
        dwSizeLeft != dwSizeRight ||
        CompareByteData(pDataBuffLeft, pDataBuffRight, dwSizeLeft) )
    {
        if( nOutputType == OUTPUTTYPE_DIFF ||
            nOutputType == OUTPUTTYPE_ALL )
        {
            // print left and right
            PrintValue(szLeftFullKeyName,
                       szValueName,
                       dwTypeLeft,
                       pDataBuffLeft,
                       dwSizeLeft,
                       PRINTTYPE_LEFT);
            PrintValue(szRightFullKeyName,
                       szValueName,
                       dwTypeRight,
                       pDataBuffRight,
                       dwSizeRight,
                       PRINTTYPE_RIGHT);
         }
         g_bHasDifference = TRUE;
    }
    else    // they are the same
    {
        if( nOutputType == OUTPUTTYPE_SAME ||
            nOutputType == OUTPUTTYPE_ALL )
        {
            PrintValue(szLeftFullKeyName,
                       szValueName,
                       dwTypeLeft,
                       pDataBuffLeft,
                       dwSizeLeft,
                       PRINTTYPE_SAME);
        }
    }

Cleanup:

    if(pDataBuffLeft)
        free(pDataBuffLeft);
    if(pDataBuffRight)
        free(pDataBuffRight);
    return nResult;
}


LONG PrintKey(HKEY hKey,
              TCHAR* szFullKeyName,
              TCHAR* szSubKeyName,
              int nPrintType)
{
    LONG  nResult;
    HKEY  hSubKey;

    // make sure key is there
    nResult = RegOpenKeyEx(hKey,
                           szSubKeyName,
                           0,
                           KEY_READ,
                           &hSubKey);
    if (nResult != ERROR_SUCCESS)
        return nResult;

    RegCloseKey(hSubKey);

    // print type
    if(nPrintType == PRINTTYPE_LEFT)
        MyTPrintf(stdout,_T("< "));
    else if(nPrintType == PRINTTYPE_RIGHT)
        MyTPrintf(stdout,_T("> "));
    else if(nPrintType == PRINTTYPE_SAME)
        MyTPrintf(stdout,_T("= "));

    MyTPrintf(stdout,_T("Key:  %s\\%s\r\n"), szFullKeyName, szSubKeyName);

    return nResult;
}


LONG OutputValue(HKEY hKey,
                 TCHAR* szFullKeyName,
                 TCHAR* szValueName,
                 int nPrintType)
{
    LONG  nResult = ERROR_SUCCESS;
    DWORD dwType;
    DWORD dwSize;
    BYTE* pDataBuff;

    //
    // First find out how much memory to allocate
    //
    nResult = RegQueryValueEx(hKey,
                              szValueName,
                              0,
                              &dwType,
                              NULL,
                              &dwSize);
    if (nResult != ERROR_SUCCESS)
    {
        return nResult;
    }

    pDataBuff = (BYTE*) calloc(dwSize + 1, sizeof(BYTE));

    if (!pDataBuff) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Now get the data
    //
    nResult = RegQueryValueEx(hKey,
                              szValueName,
                              0,
                              &dwType,
                              (LPBYTE) pDataBuff,
                              &dwSize);

    if(nResult == ERROR_SUCCESS)
    {
        PrintValue(szFullKeyName,
                   szValueName,
                   dwType,
                   pDataBuff,
                   dwSize,
                   nPrintType);
    }

    if(pDataBuff)
        free(pDataBuff);

    return nResult;
}

void PrintValue(TCHAR* szFullKeyName,
                TCHAR* szValueName,
                DWORD  dwType,
                BYTE*  pData,
                DWORD  dwSize,
                int    nPrintType)
{
    DWORD i;
    TCHAR szTypeStr[25];



    // print type
    if(nPrintType == PRINTTYPE_LEFT)
        MyTPrintf(stdout,_T("< "));
    else if(nPrintType == PRINTTYPE_RIGHT)
        MyTPrintf(stdout,_T("> "));
    else if(nPrintType == PRINTTYPE_SAME)
        MyTPrintf(stdout,_T("= "));

    // first Print Key
    MyTPrintf(stdout,_T("Value:  %s"), szFullKeyName);

    // then print ValueName  Type  Data
    GetTypeStrFromType(szTypeStr, dwType);

    if(_tcslen(szValueName) == 0)  // no name
    {
        MyTPrintf(stdout,_T("  <NO NAME>  %s  "), szTypeStr);
    }
    else
    {
        MyTPrintf(stdout,_T("  %s  %s  "), szValueName, szTypeStr);
    }

    switch (dwType)
    {
        case REG_BINARY:
            for(i=0; i<dwSize; i++)
            {
                MyTPrintf(stdout,_T("%02X"),pData[i]);
            }
            break;

        case REG_DWORD:
        case REG_DWORD_BIG_ENDIAN:
            MyTPrintf(stdout,_T("0x%x"), *((DWORD*)pData) );
            break;

        case REG_MULTI_SZ:
            {
                //
                // Replace '\0' with "\0" for MULTI_SZ
                //
                TCHAR* pEnd = (TCHAR*) pData;
                while( (BYTE*)pEnd < pData + dwSize )
                {
                    if(*pEnd == 0)
                    {
                        MyTPrintf(stdout,_T("\\0"));
                        pEnd++;
                    }
                    else
                    {
                        MyTPrintf(stdout,_T("%s"), pEnd);
                        pEnd += _tcslen(pEnd);
                    }
                }
            }

            break;

        default:
            MyTPrintf(stdout,_T("%s"), (TCHAR*) pData);
            break;
    }

    MyTPrintf(stdout,_T("\r\n"));
}

BOOL CompareByteData(BYTE* pDataBuffLeft, BYTE* pDataBuffRight, DWORD dwSize)
{
    BOOL  bDiff = FALSE;
    DWORD dw;

    for(dw=0; dw<dwSize; dw++)
    {
        if(pDataBuffLeft[dw] != pDataBuffRight[dw])
        {
            bDiff = TRUE;
            break;
        }
    }

    return bDiff;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\reg\copy.c ===
//-----------------------------------------------------------------------//
//
// File:    copy.cpp
// Created: April 1997
// By:      Martin Holladay (a-martih)
// Purpose: Registry Copy Support for REG.CPP
// Modification History:
//      Copied from Update.cpp and modificd - April 1997 (a-martih)
//      April 1999 Zeyong Xu: re-design, revision -> version 2.0
//
//------------------------------------------------------------------------//

#include "stdafx.h"
#include "reg.h"


//-----------------------------------------------------------------------//
//
// CopyRegistry()
//
//-----------------------------------------------------------------------//

LONG CopyRegistry(PAPPVARS pAppVars,
                  PAPPVARS pDstVars,
                  UINT argc,
                  TCHAR *argv[])
{
    LONG        nResult;
    HKEY        hKey;
    HKEY        hDstKey;
    DWORD       dwDisposition;
    BOOL        bOverWriteAll = FALSE;

    //
    // Parse the cmd-line
    //
    nResult = ParseCopyCmdLine(pAppVars, pDstVars, argc, argv);
    if (nResult != ERROR_SUCCESS)
    {
        return nResult;
    }

    //
    // Connect to the Remote Machine(s) - if applicable
    //
    nResult = RegConnectMachine(pAppVars);
    if (nResult != ERROR_SUCCESS)
    {
        return nResult;
    }
    nResult = RegConnectMachine(pDstVars);
    if (nResult != ERROR_SUCCESS)
    {
        return nResult;
    }

    //
    // Now implement the body of the Copy Operation
    //
    nResult = RegOpenKeyEx(pAppVars->hRootKey,
                           pAppVars->szSubKey,
                           0,
                           KEY_READ,
                           &hKey);
    if (nResult != ERROR_SUCCESS)
    {
        return nResult;
    }

    if (pAppVars->hRootKey == pDstVars->hRootKey &&
        _tcsicmp(pAppVars->szFullKey, pDstVars->szFullKey) == 0)
    {
        RegCloseKey(hKey);
        return REG_STATUS_COPYTOSELF;
    }
    else
    {
        //
        // Different Key or Different Root or Different Machine
        // So Create/Open it
        //
        nResult = RegCreateKeyEx(pDstVars->hRootKey,
                                pDstVars->szSubKey,
                                0,
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                KEY_ALL_ACCESS,
                                NULL,
                                &hDstKey,
                                &dwDisposition);

        if (nResult != ERROR_SUCCESS)
        {
            RegCloseKey(hKey);
            return nResult;
        }
    }

    //
    // Recursively copy all subkeys and values
    //
    bOverWriteAll = pAppVars->bForce;
    nResult = CopyEnumerateKey(hKey,
                               pAppVars->szSubKey,
                               hDstKey,
                               pDstVars->szSubKey,
                               &bOverWriteAll,
                               pAppVars->bRecurseSubKeys);

    //
    // lets clean up
    //
    RegCloseKey(hDstKey);
    RegCloseKey(hKey);

    return nResult;
}


REG_STATUS ParseCopyCmdLine(PAPPVARS pAppVars,
                            PAPPVARS pDstVars,
                            UINT argc,
                            TCHAR *argv[])
{
    UINT        i;
    REG_STATUS  nResult = ERROR_SUCCESS;

    //
    // Do we have a *valid* number of cmd-line params
    //
    if(argc < 4)
    {
        return REG_STATUS_TOFEWPARAMS;
    }
    else if(argc > 6)
    {
        return REG_STATUS_TOMANYPARAMS;
    }

    //
    // Source Machine Name and Registry key
    //
    nResult = BreakDownKeyString(argv[2], pAppVars);
    if(nResult != ERROR_SUCCESS)
        return nResult;

    //
    // Destination Machine Name and Registry key
    //
    nResult = BreakDownKeyString(argv[3], pDstVars);
    if(nResult != ERROR_SUCCESS)
        return nResult;

    // parsing
    for(i=4; i<argc; i++)
    {
        if(!_tcsicmp(argv[i], _T("/f")))
        {
            pAppVars->bForce = TRUE;
        }
        else if(!_tcsicmp(argv[i], _T("/s")))
        {
            pAppVars->bRecurseSubKeys = TRUE;
        }
        else
        {
            nResult = REG_STATUS_INVALIDPARAMS;
        }
    }

    return nResult;
}


//-----------------------------------------------------------------------//
//
// QueryValue()
//
//-----------------------------------------------------------------------//

LONG CopyValue(HKEY hKey,
              TCHAR* szValueName,
              HKEY hDstKey,
              TCHAR* szDstValueName,
              BOOL *pbOverWriteAll)
{

    LONG        nResult;
    DWORD       dwType, dwTmpType;
    DWORD       dwSize, dwTmpSize;
    BYTE        *pBuff;
    TCHAR       ch;
    PTSTR       PromptBuffer,PromptBufferFmt;
    DWORD       PromptBufferSize;

    //
    // First find out how much memory to allocate.
    //
    nResult = RegQueryValueEx(hKey,
                              szValueName,
                              0,
                              &dwType,
                              NULL,
                              &dwSize);

    if (nResult != ERROR_SUCCESS)
    {
        return nResult;
    }

    pBuff = (BYTE*) calloc(dwSize + 1, sizeof(BYTE));
    if (!pBuff)
        return ERROR_NOT_ENOUGH_MEMORY;

    //
    // Now get the data
    //
    nResult = RegQueryValueEx(hKey,
                              szValueName,
                              0,
                              &dwType,
                              (LPBYTE) pBuff,
                              &dwSize);

    if (nResult != ERROR_SUCCESS)
    {
        return nResult;
    }

    //
    // Copy it to the destination
    //
    if (!*pbOverWriteAll)
    {
        //
        // See if it already exists
        //
        nResult = RegQueryValueEx(hDstKey,
                                  szDstValueName,
                                  0,
                                  &dwTmpType,
                                  NULL,
                                  &dwTmpSize);
        if (nResult == ERROR_SUCCESS)
        {
            BOOL bGoodResponse = FALSE;

            //
            // allocate and fill in the prompt message
            //
            PromptBufferSize = 100; 
            PromptBufferSize += _tcslen( 
                                    szDstValueName 
                                     ? szDstValueName
                                     : g_NoName);            
            
            PromptBuffer = calloc(PromptBufferSize, sizeof(TCHAR));
            if (!PromptBuffer) {
                return ERROR_SUCCESS;
            }
            PromptBufferFmt = calloc(PromptBufferSize, sizeof(TCHAR));
            if (!PromptBufferFmt) {
                free(PromptBuffer);
                return ERROR_SUCCESS;
            }
                
            LoadString( NULL, IDS_OVERWRITE, PromptBufferFmt, PromptBufferSize);
            wsprintf(
                PromptBuffer, 
                PromptBufferFmt, 
                szDstValueName
                 ? szDstValueName
                 : g_NoName );
            
            free( PromptBufferFmt);

            while (!bGoodResponse) {
                MyTPrintf(stdout,PromptBuffer);
                
                ch = _gettchar();
                _flushall();
                switch (ch) {
                    case _T('a'): //fall through
                    case _T('y'): //fall through
                    case _T('n'):
                        bGoodResponse = TRUE;
                        break;
                    default:
                        //
                        // keep scanning.
                        //
                        ;
                }
            }

            free(PromptBuffer);
            MyTPrintf(stdout,_T("\r\n"));

            if (ch == _T('a') || ch == _T('A'))
            {
                *pbOverWriteAll = TRUE;
                bGoodResponse = TRUE;
            }
            else if (ch == _T('y') || ch == _T('Y'))
            {
                bGoodResponse = TRUE;
            }
            else if (ch == _T('n') || ch == _T('N'))
            {
                return ERROR_SUCCESS;
            }
        }
    }

    //
    // Write the Value
    //
    nResult = RegSetValueEx(hDstKey,
                            szDstValueName,
                            0,
                            dwType,
                            (PBYTE) pBuff,
                            dwSize);

    if(pBuff)
        free(pBuff);

    return nResult;
}


//-----------------------------------------------------------------------//
//
// EnumerateKey() - Recursive
//
//-----------------------------------------------------------------------//

LONG CopyEnumerateKey(HKEY hKey,
                      TCHAR* szSubKey,
                      HKEY hDstKey,
                      TCHAR* szDstSubKey,
                      BOOL *pbOverWriteAll,
                      BOOL bRecurseSubKeys)
{

    DWORD   nResult;
    UINT    i;
    DWORD   dwSize;
    DWORD   dwDisposition;
    HKEY    hSubKey;
    HKEY    hDstSubKey;
    TCHAR*  szNameBuf;
    TCHAR*  szTempName;
    TCHAR*  szDstTempName;

    // query source key info
    DWORD dwLenOfKeyName;
    DWORD dwLenOfValueName;
    nResult = RegQueryInfoKey(hKey,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              &dwLenOfKeyName,
                              NULL,
                              NULL,
                              &dwLenOfValueName,
                              NULL,
                              NULL,
                              NULL);

    if (nResult != ERROR_SUCCESS)
    {
        return nResult;
    }

#ifndef REG_FOR_WIN2000    // ansi version for win98
    // fix API bugs:  RegQueryInfoKey() returns non-correct length values
    //                on remote Win98
    if(dwLenOfKeyName < MAX_PATH)
        dwLenOfKeyName = MAX_PATH;
    if(dwLenOfValueName < MAX_PATH)
        dwLenOfValueName = MAX_PATH;
#endif

    //
    // First enumerate all of the values
    //
    dwLenOfValueName++;
    szNameBuf = (TCHAR*) calloc(dwLenOfValueName, sizeof(TCHAR));
    if (!szNameBuf) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    i = 0;
    do
    {
        dwSize = dwLenOfValueName;
        nResult = RegEnumValue(hKey,
                               i,
                               szNameBuf,
                               &dwSize,
                               NULL,
                               NULL,
                               NULL,
                               NULL);

        if (nResult == ERROR_SUCCESS)
        {
            nResult = CopyValue(hKey,
                                szNameBuf,
                                hDstKey,
                                szNameBuf,
                                pbOverWriteAll);
        }

        i++;

    } while (nResult == ERROR_SUCCESS);

    if(szNameBuf)
        free(szNameBuf);

    if (nResult == ERROR_NO_MORE_ITEMS)
        nResult = ERROR_SUCCESS;

    if( !bRecurseSubKeys ||
        nResult != ERROR_SUCCESS )
        return nResult;

    //
    // Now Enumerate all of the keys
    //
    dwLenOfKeyName++;
    szNameBuf = (TCHAR*) calloc(dwLenOfKeyName, sizeof(TCHAR));
    if (!szNameBuf) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    i = 0;
    do
    {
        dwSize = dwLenOfKeyName;
        nResult = RegEnumKeyEx(hKey,
                               i,
                               szNameBuf,
                               &dwSize,
                               NULL,
                               NULL,
                               NULL,
                               NULL);

        //
        // Else open up the subkey, create the destination key
        // and enumerate it
        //
        if (nResult == ERROR_SUCCESS)
        {
            nResult = RegOpenKeyEx(hKey,
                                   szNameBuf,
                                   0,
                                   KEY_READ,
                                   &hSubKey);
        }

        if (nResult == ERROR_SUCCESS)
        {
            nResult = RegCreateKeyEx(hDstKey,
                                     szNameBuf,
                                     0,
                                     NULL,
                                     REG_OPTION_NON_VOLATILE,
                                     KEY_ALL_ACCESS,
                                     NULL,
                                     &hDstSubKey,
                                     &dwDisposition);

            if (nResult == ERROR_SUCCESS)
            {
                //
                // Build up the needed string and go to town enumerating again
                //
                szTempName = (TCHAR*) calloc(_tcslen(szSubKey) +
                                                _tcslen(szNameBuf) +
                                                3,
                                             sizeof(TCHAR));
                if (!szTempName) {
                    nResult = ERROR_NOT_ENOUGH_MEMORY;
                    goto Cleanup;
                }

                if(_tcslen(szSubKey) > 0)
                {
                    _tcscpy(szTempName, szSubKey);
                    _tcscat(szTempName, _T("\\"));
                }
                _tcscat(szTempName, szNameBuf);

                szDstTempName = (TCHAR*) calloc(_tcslen(szDstSubKey) +
                                                    _tcslen(szNameBuf) +
                                                    3,
                                                sizeof(TCHAR));

                if (!szDstTempName) {
                    free (szTempName);
                    nResult = ERROR_NOT_ENOUGH_MEMORY;
                    goto Cleanup;
                }

                if(_tcslen(szDstSubKey) > 0)
                {
                    _tcscpy(szDstTempName, szDstSubKey);
                    _tcscat(szDstTempName, _T("\\"));
                }
                _tcscat(szDstTempName, szNameBuf);

                // recursive copy
                nResult = CopyEnumerateKey(hSubKey,
                                           szTempName,
                                           hDstSubKey,
                                           szDstTempName,
                                           pbOverWriteAll,
                                           bRecurseSubKeys);

                RegCloseKey(hSubKey);
                RegCloseKey(hDstSubKey);

                if(szTempName)
                    free(szTempName);
                if(szDstTempName)
                    free(szDstTempName);
            }
        }

        i++;

    } while (nResult == ERROR_SUCCESS);

Cleanup:
    if(szNameBuf)
        free(szNameBuf);

    if (nResult == ERROR_NO_MORE_ITEMS)
        nResult = ERROR_SUCCESS;

    return nResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\reg\export.c ===
//-----------------------------------------------------------------------//
//
// File:    export.cpp
// Created: April 1997
// By:      Zeyong Xu
// Purpose: Support EXPORT and IMPORT .reg file
//
//------------------------------------------------------------------------//

#include "stdafx.h"
#include <regeditp.h>
#include "reg.h"

extern UINT g_FileErrorStringID;

//-----------------------------------------------------------------------
//
// ExportRegFile()
//
//-----------------------------------------------------------------------

LONG ExportRegFile(PAPPVARS pAppVars, UINT argc, TCHAR *argv[])
{
    LONG        nResult;
    HKEY        hKey;

    //
    // Parse the cmd-line
    //
    nResult = ParseExportCmdLine(pAppVars, argc, argv);
    if(nResult != ERROR_SUCCESS) 
        return nResult;

    //
    // check if the key existed
    //
    nResult = RegOpenKeyEx(pAppVars->hRootKey,
                            pAppVars->szSubKey,
                            0,
                            KEY_READ,
                            &hKey);

    if(nResult == ERROR_SUCCESS) 
    {
        RegCloseKey(hKey);

        nResult = RegExportRegFile(NULL,
                                  TRUE,
                                  pAppVars->bNT4RegFile,
                                  pAppVars->szValueName,
                                  pAppVars->szFullKey);
    }

    return nResult;
}

//------------------------------------------------------------------------
//
// ParseCmdLine()
//
//------------------------------------------------------------------------
REG_STATUS ParseExportCmdLine(PAPPVARS pAppVars, UINT argc, TCHAR *argv[])
{
    REG_STATUS nResult = ERROR_SUCCESS;

    //
    // Do we have a *valid* number of cmd-line params
    //
    if (argc < 4) 
    {
        return REG_STATUS_TOFEWPARAMS;
    }
    else if (argc > 5) 
    {
        return REG_STATUS_TOMANYPARAMS;
    }

    // Machine Name and Registry key
    //
    nResult = BreakDownKeyString(argv[2], pAppVars);
    if(nResult != ERROR_SUCCESS)
        return nResult;

    // current, not remotable
    if(pAppVars->bUseRemoteMachine)
        return REG_STATUS_NONREMOTABLE;

    //
    // Get the FileName - using the szValueName string field to hold it
    //
    pAppVars->szValueName = (TCHAR*) calloc(_tcslen(argv[3]) + 1, 
                                            sizeof(TCHAR));
    _tcscpy(pAppVars->szValueName, argv[3]);


#ifdef REG_FOR_WIN2000
    //
    // option params
    //
    if(argc == 4)
        return nResult;
    
    if( argc == 5 &&
        !_tcsicmp(argv[4], _T("/nt4")))
    {        
        pAppVars->bNT4RegFile = TRUE;
    }
    else
        nResult = REG_STATUS_INVALIDPARAMS;
#else

    pAppVars->bNT4RegFile = TRUE;
    if(argc > 4)
        nResult = REG_STATUS_TOMANYPARAMS;

#endif

    return nResult;
}

//-----------------------------------------------------------------------
//
// ImportRegFile()
//
//-----------------------------------------------------------------------

LONG ImportRegFile(PAPPVARS pAppVars, UINT argc, TCHAR *argv[])
{
    LONG        nResult;

    //
    // Parse the cmd-line
    //
    nResult = ParseImportCmdLine(pAppVars, argc, argv);
    if(nResult == ERROR_SUCCESS) 
    {      
        nResult = RegImportRegFile(NULL,
                                   TRUE,
                                   pAppVars->szValueName);
    }
    
    if(nResult != ERROR_SUCCESS)
	{
		if ( g_FileErrorStringID == IDS_IMPFILEERRSUCCESS || nResult == ERROR_FILE_NOT_FOUND)
			nResult = REG_STATUS_BADFILEFORMAT;
	}

    return nResult;
}

//------------------------------------------------------------------------
//
// ParseCmdLine()
//
//------------------------------------------------------------------------
REG_STATUS ParseImportCmdLine(PAPPVARS pAppVars, UINT argc, TCHAR *argv[])
{
    REG_STATUS nResult = ERROR_SUCCESS;

    //
    // Do we have a valid number of cmd-line params
    //
    if (argc < 3) 
    {
        return REG_STATUS_TOFEWPARAMS;
    }
    else if (argc > 3) 
    {
        return REG_STATUS_TOMANYPARAMS;
    }

    //
    // Get the FileName - using the szValueName string field to hold it
    //
    pAppVars->szValueName = (TCHAR*) calloc(_tcslen(argv[2]) + 1, sizeof(TCHAR));

    if( pAppVars->szValueName ) {
        _tcscpy(pAppVars->szValueName, argv[2]);
    } else {
        nResult = ERROR_INSUFFICIENT_BUFFER;
    }
 
    return nResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\reg\compare.h ===
//
// compare.h
//

#ifndef _COMPARE_H
#define _COMPARE_H


REG_STATUS ParseCompareCmdLine(PAPPVARS pAppVars,
                               PAPPVARS pDstVars,
                               UINT argc,
                               TCHAR *argv[]);

LONG CompareValues(HKEY hLeftKey,    
                  TCHAR* szLeftFullKeyName,
                  HKEY hRightKey,
                  TCHAR* szRightFullKeyName,
                  TCHAR* szValueName,
                  int nOutputType);

LONG OutputValue(HKEY hKey,    
                 TCHAR* szFullKeyName,
                 TCHAR* szValueName,
                 BOOL bLeft);

LONG CompareEnumerateKey(HKEY hLeftKey,    
                         TCHAR* szLeftFullKeyName,
                         HKEY hRightKey,  
                         TCHAR* szRightFullKeyName,
                         int nOutputType,
                         BOOL bRecurseSubKeys);

LONG CompareEnumerateValueName(HKEY hLeftKey,  
                               TCHAR* szLeftFullKeyName,
                               HKEY hRightKey,  
                               TCHAR* szRightFullKeyName,
                               int nOutputType);

LONG PrintKey(HKEY hKey,    
              TCHAR* szFullKeyName,
              TCHAR* szSubKeyName,
              int nPrintType);

void PrintValue(TCHAR* szFullKeyName,
                TCHAR* szValueName,
                DWORD  dwType,
                BYTE*  pData,
                DWORD  dwSize,
                int    nPrintType);

REG_STATUS CopyKeyNameFromLeftToRight(APPVARS* pAppVars, APPVARS* pDstVars);

BOOL CompareByteData(BYTE* pDataBuffLeft, BYTE* pDataBuffRight, DWORD dwSize);

#endif  //_COMPARE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\reg\query.c ===
//-----------------------------------------------------------------------//
//
// File:    query.cpp
// Created: Jan 1997
// By:      Martin Holladay (a-martih)
// Purpose: Registry Query Support for REG.CPP
// Modification History:
//    Created - Jan 1997 (a-martih)
//    Aug 1997 (John Whited) Implemented a Binary output function for
//            REG_BINARY
//    Oct 1997 (martinho) fixed output for REG_MULTI_SZ \0 delimited strings
//    April 1998 - MartinHo - Incremented to 1.05 for REG_MULTI_SZ bug fixes.
//            Correct support for displaying query REG_MULTI_SZ of. Fix AV.
//    April 1999 Zeyong Xu: re-design, revision -> version 2.0
//
//------------------------------------------------------------------------//

#include "stdafx.h"
#include "reg.h"


//-----------------------------------------------------------------------//
//
// QueryRegistry()
//
//-----------------------------------------------------------------------//

LONG QueryRegistry(PAPPVARS pAppVars, UINT argc, TCHAR *argv[])
{
    LONG        nResult;
    HKEY        hKey;

    //
    // Parse the cmd-line
    //
    nResult = ParseQueryCmdLine(pAppVars, argc, argv);
    if (nResult != ERROR_SUCCESS)
    {
        return nResult;
    }

    //
    // Connect to the Remote Machine(s) - if applicable
    //
    nResult = RegConnectMachine(pAppVars);
    if (nResult != ERROR_SUCCESS)
    {
        return nResult;
    }

      //
    // Open the registry key
    //
    nResult = RegOpenKeyEx(pAppVars->hRootKey,
                           pAppVars->szSubKey,
                           0,
                           KEY_READ,
                           &hKey);

    if(nResult != ERROR_SUCCESS)
        return nResult;

    MyTPrintf(stdout,_T("\r\n! REG.EXE VERSION %s\r\n"), REG_EXE_FILEVERSION);

    //
    // if query a single registry value
    //
    if(pAppVars->szValueName)
    {
        // first print the key name
        MyTPrintf(stdout,_T("\r\n%s\r\n"), pAppVars->szFullKey);

        nResult = QueryValue(hKey, pAppVars->szValueName);
        MyTPrintf(stdout,_T("\r\n"));
    }
    else    // query a registry key
    {
        nResult = QueryEnumerateKey(hKey,
                                    pAppVars->szFullKey,
                                    pAppVars->bRecurseSubKeys);
    }

    RegCloseKey(hKey);

    return nResult;
}



//------------------------------------------------------------------------//
//
// ParseQueryCmdLine()
//
//------------------------------------------------------------------------//

REG_STATUS ParseQueryCmdLine(PAPPVARS pAppVars, UINT argc, TCHAR *argv[])
{
    REG_STATUS nResult;
    UINT i;

    if(argc < 3)
    {
        return REG_STATUS_TOFEWPARAMS;
    }
    else if(argc > 5)
    {
        return REG_STATUS_TOMANYPARAMS;
    }

    // Machine Name and Registry key
    //
    nResult = BreakDownKeyString(argv[2], pAppVars);
    if(nResult != ERROR_SUCCESS)
        return nResult;

    // parsing
    for(i=3; i<argc; i++)
    {
        if(!_tcsicmp(argv[i], _T("/v")))
        {
            if(pAppVars->szValueName || pAppVars->bRecurseSubKeys)
                return REG_STATUS_INVALIDPARAMS;

            i++;
            if(i<argc)
            {
                pAppVars->szValueName = (TCHAR*) calloc(_tcslen(argv[i]) + 1,
                                                        sizeof(TCHAR));
                if (!pAppVars->szValueName) {
                    return ERROR_NOT_ENOUGH_MEMORY;
                }
                _tcscpy(pAppVars->szValueName, argv[i]);
            }
            else
                return REG_STATUS_TOFEWPARAMS;
        }
        else if(!_tcsicmp(argv[i], _T("/ve")))
        {
            if(pAppVars->szValueName || pAppVars->bRecurseSubKeys)
                return REG_STATUS_INVALIDPARAMS;

            pAppVars->szValueName = (TCHAR*) calloc(1, sizeof(TCHAR));
            if (!pAppVars->szValueName) {
                return ERROR_NOT_ENOUGH_MEMORY;
            }
        }
        else if(!_tcsicmp(argv[i], _T("/s")))
        {
            if(pAppVars->szValueName)
                return REG_STATUS_INVALIDPARAMS;

            pAppVars->bRecurseSubKeys = TRUE;
        }
        else
            return REG_STATUS_INVALIDPARAMS;
    }

    return ERROR_SUCCESS;
}



//-----------------------------------------------------------------------//
//
// GetTypeStr()
//
//-----------------------------------------------------------------------//

void GetTypeStrFromType(TCHAR *szTypeStr, DWORD dwType)
{
    switch (dwType)
    {
    case REG_BINARY:
        _tcscpy(szTypeStr, STR_REG_BINARY);
        break;

    case REG_DWORD:
        _tcscpy(szTypeStr, STR_REG_DWORD);
        break;

    case REG_DWORD_BIG_ENDIAN:
        _tcscpy(szTypeStr, STR_REG_DWORD_BIG_ENDIAN);
        break;

    case REG_EXPAND_SZ:
        _tcscpy(szTypeStr, STR_REG_EXPAND_SZ);
        break;

    case REG_LINK:
        _tcscpy(szTypeStr, STR_REG_LINK);
        break;

    case REG_MULTI_SZ:
        _tcscpy(szTypeStr, STR_REG_MULTI_SZ);
        break;

    case REG_NONE:
        _tcscpy(szTypeStr, STR_REG_NONE);
        break;

    case REG_RESOURCE_LIST:
        _tcscpy(szTypeStr, STR_REG_RESOURCE_LIST);
        break;

    case REG_SZ:
        _tcscpy(szTypeStr, STR_REG_SZ);
        break;

    default:
        _tcscpy(szTypeStr, STR_REG_NONE);
        break;
    }
}

//-----------------------------------------------------------------------//
//
// QueryValue()
//
//-----------------------------------------------------------------------//

LONG QueryValue(HKEY hKey, TCHAR* szValueName)
{

    LONG        nResult;
    TCHAR       szTypeStr[25];
    DWORD       dwType;
    DWORD       dwSize = 1;
    UINT        i;
    BYTE*       pBuff;
    TCHAR       szEmptyString[ 2 ] = L"";

    if ( szValueName == NULL )
    {
        szValueName = szEmptyString;
    }

    //
    // First find out how much memory to allocate.
    //
    nResult = RegQueryValueEx(hKey,
                              szValueName,
                              0,
                              &dwType,
                              NULL,
                              &dwSize);

    if (nResult != ERROR_SUCCESS)
    {
        return nResult;
    }

	// to avoid problems with corrupted registry data -- 
	// always allocate memory of even no. of bytes
	dwSize += ( dwSize % 2 );

    pBuff = (BYTE*) calloc(dwSize + 2, sizeof(BYTE));
    if (!pBuff) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Now get the data
    //
    nResult = RegQueryValueEx(hKey,
                              szValueName,
                              0,
                              &dwType,
                              (LPBYTE) pBuff,
                              &dwSize);


    if (nResult != ERROR_SUCCESS)
    {
        free(pBuff);
        return nResult;
    }

    //
    // Now list the ValueName\tType\tData
    //
    GetTypeStrFromType(szTypeStr, dwType);

    MyTPrintf(stdout,
        _T("    %s\t%s\t"), 
        (_tcslen(szValueName) == 0)  // no name
         ? g_NoName
         : szValueName,
        szTypeStr);
    
    switch (dwType)
    {
        default:
        case REG_BINARY:
            for(i=0; i<dwSize; i++)
            {
                MyTPrintf(stdout,_T("%02X"),pBuff[i]);
            }
            break;

		case REG_SZ:
		case REG_EXPAND_SZ:
            MyTPrintf(stdout,_T("%s"), (LPCWSTR)pBuff );
            break;

        case REG_DWORD:
        case REG_DWORD_BIG_ENDIAN:
            MyTPrintf(stdout,_T("0x%x"), *((DWORD*)pBuff) );
            break;

        case REG_MULTI_SZ:
            {
                //
                // Replace '\0' with "\0" for MULTI_SZ
                //
                TCHAR* pEnd = (TCHAR*) pBuff;
                while( (BYTE*)pEnd < pBuff + dwSize )
                {
                    if(*pEnd == 0)
                    {
                        MyTPrintf(stdout,_T("\\0"));
                        pEnd++;
                    }
                    else
                    {
                        MyTPrintf(stdout,_T("%s"), pEnd);
                        pEnd += _tcslen(pEnd);
                    }
                }
            }

            break;
    }

    MyTPrintf(stdout,_T("\r\n"));

    if(pBuff)
        free(pBuff);

    return ERROR_SUCCESS;
}


//-----------------------------------------------------------------------//
//
// EnumerateKey() - Recursive
//
//-----------------------------------------------------------------------//

LONG QueryEnumerateKey(HKEY hKey,
                       TCHAR* szFullKey,
                       BOOL bRecurseSubKeys)
{
    DWORD   nResult;
    UINT    i;
    DWORD   dwSize;
    HKEY    hSubKey;
    TCHAR*  szNameBuf;
    TCHAR*  szTempName;

    // query source key info
    DWORD dwLenOfKeyName;
    DWORD dwLenOfValueName;
    nResult = RegQueryInfoKey(hKey,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              &dwLenOfKeyName,
                              NULL,
                              NULL,
                              &dwLenOfValueName,
                              NULL,
                              NULL,
                              NULL);

    if (nResult != ERROR_SUCCESS)
    {
        return nResult;
    }

#ifndef REG_FOR_WIN2000    // ansi version for win98
    // fix API bugs:  RegQueryInfoKey() returns non-correct length values
    //                on remote Win98
    if(dwLenOfKeyName < MAX_PATH)
        dwLenOfKeyName = MAX_PATH;
    if(dwLenOfValueName < MAX_PATH)
        dwLenOfValueName = MAX_PATH;
#endif

    // create buffer
    dwLenOfValueName++;
    szNameBuf = (TCHAR*) calloc(dwLenOfValueName, sizeof(TCHAR));
    if (!szNameBuf) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // first print the key name
    MyTPrintf(stdout,_T("\r\n%s\r\n"), szFullKey);

    //
    // enumerate all of the values
    //
    i = 0;
    do
    {
        dwSize = dwLenOfValueName;
        nResult = RegEnumValue(hKey,
                               i,
                               szNameBuf,
                               &dwSize,
                               NULL,
                               NULL,
                               NULL,
                               NULL);

        if (nResult == ERROR_SUCCESS)
        {
            nResult = QueryValue(hKey, szNameBuf);

            // continue to query
            if(nResult == ERROR_ACCESS_DENIED)
            {
                MyTPrintf(stderr,
						  _T("Error:  Access is denied in the value %s under")
                          _T(" the key %s\r\n"),
                          szNameBuf,
                          szFullKey);
                nResult = ERROR_SUCCESS;
            }
        }

        i++;

    } while (nResult == ERROR_SUCCESS);


    if(szNameBuf)
        free(szNameBuf);

    if (nResult == ERROR_NO_MORE_ITEMS)
        nResult = ERROR_SUCCESS;

    if( nResult != ERROR_SUCCESS )
        return nResult;

	//
	// SPECIAL CASE:
	// -------------
	// For HKLM\SYSTEM\CONTROLSET002 it is found to be API returning value 0 for dwMaxLength
	// though there are subkeys underneath this -- to handle this, we are doing a workaround
	// by assuming the max registry key length
	//
	if ( dwLenOfKeyName == 0 )
	{
		dwLenOfKeyName = 256;
	}
	else if ( dwLenOfKeyName < 256 )
	{
		// always assume 100% more length than what is returned by API
		dwLenOfKeyName *= 2;
	}

    //
    // Now Enumerate all of the keys
    //
    dwLenOfKeyName++;
    szNameBuf = (TCHAR*) calloc(dwLenOfKeyName, sizeof(TCHAR));
    if (!szNameBuf) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    i = 0;
    do
    {
        dwSize = dwLenOfKeyName;
        nResult = RegEnumKeyEx(hKey,
                               i,
                               szNameBuf,
                               &dwSize,
                               NULL,
                               NULL,
                               NULL,
                               NULL);

        if (nResult != ERROR_SUCCESS)
            break;

        //
        // open up the subkey, and enumerate it
        //
        nResult = RegOpenKeyEx(hKey,
                               szNameBuf,
                               0,
                               KEY_READ,
                               &hSubKey);

        //
        // Build up the needed string and go down enumerating again
        //
        szTempName = (TCHAR*) calloc(_tcslen(szFullKey) +
                                        _tcslen(szNameBuf) +
                                        2,
                                     sizeof(TCHAR));
        if (!szTempName) {
            nResult = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        _tcscpy(szTempName, szFullKey);
        _tcscat(szTempName, _T("\\"));
        _tcscat(szTempName, szNameBuf);


        if (bRecurseSubKeys && nResult == ERROR_SUCCESS)
        {
             // recursive query
            nResult = QueryEnumerateKey(hSubKey,
                                        szTempName,
                                        bRecurseSubKeys);

        }
        else
        {
            // print key
            MyTPrintf(stdout,_T("\r\n%s\r\n"), szTempName);

            if(nResult == ERROR_ACCESS_DENIED) // continue to query next key
            {
                MyTPrintf(stderr,
					      _T("Error:  Access is denied in the key %s\r\n"),
                          szTempName);
                nResult = ERROR_SUCCESS;
            }
        }

        RegCloseKey(hSubKey);
        if(szTempName)
            free(szTempName);


        i++;

    } while (nResult == ERROR_SUCCESS);

Cleanup:
    if(szNameBuf)
        free(szNameBuf);

    if (nResult == ERROR_NO_MORE_ITEMS)
        nResult = ERROR_SUCCESS;

    return nResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\reg\delete.c ===
//-----------------------------------------------------------------------//
//
// File:    delete.cpp
// Created: April 1997
// By:      Martin Holladay (a-martih)
// Purpose: Registry Delete Support for REG.CPP
// Modification History:
//      Copied from Update.cpp and modificd - April 1997 (a-martih)
//      April 1999 Zeyong Xu: re-design, revision -> version 2.0
//
//------------------------------------------------------------------------//

#include "stdafx.h"
#include "reg.h"


//-----------------------------------------------------------------------//
//
// DeleteRegistry()
//
//-----------------------------------------------------------------------//

LONG DeleteRegistry(PAPPVARS pAppVars, UINT argc, TCHAR *argv[]) 
{
    LONG        nResult;

    //
    // Parse the cmd-line
    //
    nResult = ParseDeleteCmdLine(pAppVars, argc, argv);
    if (nResult != ERROR_SUCCESS) 
    {
        return nResult;
    }

    //
    // Connect to the Remote Machine(s) - if applicable
    //
    nResult = RegConnectMachine(pAppVars);
    if (nResult != ERROR_SUCCESS) 
    {
        return nResult;
    }
  
    // if delete a value or delete all values under this key
    if( pAppVars->szValueName ||
        pAppVars->bAllValues )
    {
        nResult = DeleteValues(pAppVars);
    }
    // if delete the key
    else if (Prompt(_T("\nPermanently delete the registry key %s (Y/N)? "), 
                pAppVars->szSubKey, 
                pAppVars->bForce)) 
    {
         nResult = RecursiveDeleteKey(pAppVars->hRootKey, 
                                     pAppVars->szSubKey);
    }
   
    return nResult;
}


//------------------------------------------------------------------------//
//
// ParseDeleteCmdLine()
//
//------------------------------------------------------------------------//

REG_STATUS ParseDeleteCmdLine(PAPPVARS pAppVars, 
                              UINT argc, 
                              TCHAR *argv[]) 
{
    BOOL bHasValue = FALSE;
    REG_STATUS nResult;
    UINT i;

    if(argc < 3) 
    {
        return REG_STATUS_TOFEWPARAMS;
    }
    else if(argc > 6) 
    {
        return REG_STATUS_TOMANYPARAMS;
    }

    // Machine Name and Registry key
    //
    nResult = BreakDownKeyString(argv[2], pAppVars);
    if(nResult != ERROR_SUCCESS)
        return nResult;

    // parsing
    for(i=3; i<argc; i++)
    {
        if(!_tcsicmp(argv[i], _T("/v")))
        {
            if(bHasValue)
                return REG_STATUS_INVALIDPARAMS;

            bHasValue = TRUE;

            i++;
            if(i<argc)
            {
                pAppVars->szValueName = (TCHAR*) calloc(_tcslen(argv[i]) + 1, 
                                                        sizeof(TCHAR));
                _tcscpy(pAppVars->szValueName, argv[i]);
            }
            else
                return REG_STATUS_TOFEWPARAMS;
        }
        else if(!_tcsicmp(argv[i], _T("/ve")))
        {
            if(bHasValue)
                return REG_STATUS_INVALIDPARAMS;

            bHasValue = TRUE;

            pAppVars->szValueName = (TCHAR*) calloc(1, sizeof(TCHAR));   
        }
        else if(!_tcsicmp(argv[i], _T("/va")))
        {
            if(bHasValue)
                return REG_STATUS_INVALIDPARAMS;

            bHasValue = TRUE;
            
            pAppVars->bAllValues = TRUE; 
        }
        else if(!_tcsicmp(argv[i], _T("/f")))
        {
            pAppVars->bForce = TRUE;
        }
        else
            return REG_STATUS_INVALIDPARAMS;
    }

    return ERROR_SUCCESS;
}


//-----------------------------------------------------------------------//
//
// RecursiveDeleteKey() - Recursive registry key delete
//
//-----------------------------------------------------------------------//

LONG RecursiveDeleteKey(HKEY hKey, LPCTSTR szName) 
{
    LONG     nResult;
    HKEY     hSubKey;
    DWORD dwNumOfSubkey;
    DWORD dwLenOfKeyName;
    TCHAR* pszNameBuf; 
    DWORD dwIndex = 0;

    //
    // Open the SubKey
    //
    nResult = RegOpenKeyEx( hKey,
                            szName,
                            0,
                            KEY_ALL_ACCESS,
                            &hSubKey);
    if (nResult != ERROR_SUCCESS) 
    {
        return nResult;
    }

    // query key info
    nResult = RegQueryInfoKey(hSubKey,  
                              NULL,
                              NULL,
                              NULL,
                              &dwNumOfSubkey,
                              &dwLenOfKeyName,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL);

    if (nResult != ERROR_SUCCESS) 
    {
        RegCloseKey(hSubKey);
        return nResult;
    }

#ifndef REG_FOR_WIN2000    // ansi version for win98
        // fix API bugs:  RegQueryInfoKey() returns non-correct length values
        //                on remote Win98
        if(dwLenOfKeyName < MAX_PATH)
            dwLenOfKeyName = MAX_PATH;
#endif

    // create buffer
    dwLenOfKeyName++;
    pszNameBuf = (TCHAR*) calloc(dwNumOfSubkey * dwLenOfKeyName, 
                                        sizeof(TCHAR));

    // Now Enumerate all of the keys
    dwIndex = 0;
    while(dwIndex < dwNumOfSubkey && nResult == ERROR_SUCCESS)
    {
        DWORD dwSize = dwLenOfKeyName;
        nResult = RegEnumKeyEx(hSubKey,
                               dwIndex,
                               pszNameBuf + (dwIndex * dwLenOfKeyName),
                               &dwSize,
                               NULL,
                               NULL,
                               NULL,
                               NULL);
        dwIndex++;
    }

    dwIndex = 0;
    while(nResult == ERROR_SUCCESS && dwIndex < dwNumOfSubkey)
    {
        nResult = RecursiveDeleteKey(hSubKey, 
                                     pszNameBuf + (dwIndex * dwLenOfKeyName));
        if(nResult != ERROR_SUCCESS)
            break;

        dwIndex++;
    }

    // freee memory
    if(pszNameBuf)
        free(pszNameBuf);

    // close this subkey and delete it
    RegCloseKey(hSubKey);
    if (nResult == ERROR_SUCCESS) 
        nResult = RegDeleteKey(hKey, szName);

    return nResult;
}


LONG DeleteValues(PAPPVARS pAppVars) 
{
    LONG   nResult;
    HKEY   hSubKey;
    TCHAR* pszNameBuf = NULL;
    DWORD dwIndex = 0;
    DWORD dwSize = 0;


    if( pAppVars->bAllValues &&
        !Prompt(_T("\nDelete all values under the registry key %s (Y/N)? "), 
                      pAppVars->szSubKey, 
                      pAppVars->bForce)) 
    {
        return ERROR_SUCCESS;
    }
    else if( pAppVars->szValueName &&
             !Prompt(_T("\nDelete the registry value %s (Y/N)? "), 
                      pAppVars->szValueName, 
                      pAppVars->bForce)) 
    {
        return ERROR_SUCCESS;
    }

    // Open the registry key
    nResult = RegOpenKeyEx(pAppVars->hRootKey,
                           pAppVars->szSubKey,
                           0,
                           KEY_ALL_ACCESS,
                           &hSubKey);

    if( nResult != ERROR_SUCCESS)
    {
        return nResult;
    }

    if(pAppVars->szValueName)   // delete a single value
    {
        nResult = RegDeleteValue(hSubKey, pAppVars->szValueName);                               
    }
    else if(pAppVars->bAllValues)  // delete all values
    {
        // query source key info
        DWORD dwLenOfValueName;
        DWORD dwNumOfValues;
        nResult = RegQueryInfoKey(hSubKey,  
                                  NULL,
                                  NULL,
                                  NULL,
                                  NULL,
                                  NULL,
                                  NULL,
                                  &dwNumOfValues,
                                  &dwLenOfValueName,
                                  NULL,
                                  NULL,
                                  NULL);

        if (nResult != ERROR_SUCCESS) 
        {
            RegCloseKey(hSubKey);
            return nResult;
        }

#ifndef REG_FOR_WIN2000    // ansi version for win98
        // fix API bugs:  RegQueryInfoKey() returns non-correct length values
        //                on remote Win98
        if(dwLenOfValueName < MAX_PATH)
            dwLenOfValueName = MAX_PATH;
#endif

        // create buffer
        dwLenOfValueName++;
        pszNameBuf = (TCHAR*) calloc(dwNumOfValues * dwLenOfValueName, 
                                            sizeof(TCHAR));

        // Now Enumerate all values
        dwIndex = 0;
        dwSize = 0;
        while(dwIndex < dwNumOfValues && nResult == ERROR_SUCCESS)
        {
            dwSize = dwLenOfValueName;
            nResult = RegEnumValue(hSubKey,
                                   dwIndex,
                                   pszNameBuf + (dwIndex * dwLenOfValueName),
                                   &dwSize,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL);
            dwIndex++;
        }

        dwIndex = 0;
        while(nResult == ERROR_SUCCESS && dwIndex < dwNumOfValues)
        {
            nResult = RegDeleteValue(hSubKey, 
                                     pszNameBuf + (dwIndex * dwLenOfValueName));
            if(nResult != ERROR_SUCCESS)
                break;

            dwIndex++;
        }

        // free memory
        if(pszNameBuf)
            free(pszNameBuf);
    }

    RegCloseKey(hSubKey);

    return nResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\reg\reg.h ===
//-----------------------------------------------------------------------//
//
// File:    Reg.h
// Created: Jan 1997
// By:      Martin Holladay (a-martih)
// Purpose: Header file for Reg.cpp
// Modification History:
//      Created - Jan 1997 (a-martih)
//      Aug 1997 - MartinHo - Incremented to 1.01 for bug fixes in:
//              load.cpp, unload.cpp, update.cpp, save.cpp & restore.cpp
//      Sept 1997 - MartinHo - Incremented to 1.02 for update:
//              increased value date max to 2048 bytes
//      Oct 1997 - MartinHo - Incremented to 1.03 for REG_MULTI_SZ bug fixes.
//              Correct support for REG_MULTI_SZ with query, add and update.
//      April 1998 - MartinHo - Fixed RegOpenKey() in Query.cpp to not require
//              KEY_ALL_ACCESS but rather KEY_READ.
//      June 1998 - MartinHo - Increased LEN_MACHINENAME to 18 to account for the
//              leading "\\" characters. (version 1.05)
//      Feb  1999 - A-ERICR - added reg dump, reg find, and many bug fixes(1.06)
//      April 1999 Zeyong Xu: re-design, revision -> version 2.0
//
//------------------------------------------------------------------------//


#ifndef _REG_H
#define _REG_H


#include "appvars.h"


LONG AddRegistry(PAPPVARS pAppVars, UINT argc, TCHAR *argv[]);

VOID
InitGlobalStrings(
    VOID);

void InitAppVars(PAPPVARS pAppVars);
void FreeAppVars(PAPPVARS pAppVars);
void Banner();
REG_STATUS BreakDownKeyString(TCHAR *szStr, PAPPVARS pAppVars);
REG_STATUS ParseKeyName(TCHAR *szStr, PAPPVARS pAppVars);
BOOL BSearchRegistry(LPTSTR lpszKey, 
                     PTSTR lpszSearch, 
                     LPTSTR lpszValue, 
                     DWORD dwType, 
                     DWORD dwSizeOfValue);
LONG CopyEnumerateKey(HKEY hKey,    
                      TCHAR* szSubKey,
                      HKEY hDstKey,  
                      TCHAR* szDstSubKey,
                      BOOL *bOverWriteAll,
                      BOOL bSubToAll);
LONG CopyRegistry(PAPPVARS pAppVars,
                  PAPPVARS pDstVars,
                  UINT argc,
                  TCHAR *argv[]);
LONG CopyValue(HKEY hKey,    
              TCHAR* szValueName,
              HKEY hDstKey,
              TCHAR* szDstValueName,
              BOOL *bOverWriteAll);
LONG RecursiveDeleteKey(HKEY hKey, LPCTSTR szName);
LONG DeleteRegistry(PAPPVARS pAppVars, UINT argc, TCHAR *argv[]);
LONG DeleteValues(PAPPVARS pAppVars);
void ErrorMessage(UINT nErr);
void GetTypeStrFromType(TCHAR *szTypeStr, DWORD dwType);
REG_STATUS ParseMachineName(TCHAR* szStr, PAPPVARS pAppVars);
DWORD IsRegDataType(TCHAR *szStr); 
LONG LoadHive(PAPPVARS pAppVars, UINT argc, TCHAR *argv[]);
BOOL Prompt(LPCTSTR szFormat, LPCTSTR szStr, BOOL bForce); 
LONG QueryEnumerateKey(HKEY hKey,
                       TCHAR* szFullKey, 
                       BOOL bRecurseSubKeys);
LONG QueryRegistry(PAPPVARS pAppVars, UINT argc, TCHAR *argv[]);
LONG QueryValue(HKEY hKey, TCHAR* szValueName);
LONG RegAdjustTokenPrivileges(TCHAR *szMachine, 
                              TCHAR *szPrivilege, 
                              LONG nAttribute);
LONG RegConnectMachine(PAPPVARS pAppVars);
LONG RestoreHive(PAPPVARS pAppVars, UINT argc, TCHAR *argv[]);
LONG RegRestoreKeyWin98(HKEY hKey,  
                        TCHAR* szSubKey, 
                        TCHAR* szFile);  
LONG SaveHive(PAPPVARS pAppVars, UINT argc, TCHAR *argv[]);
LONG UnLoadHive(PAPPVARS pAppVars, UINT argc, TCHAR *argv[]);
void Usage(APPVARS AppVars);
void Who();

LONG ExportRegFile(PAPPVARS pAppVars,UINT argc,TCHAR *argv[]);
LONG ImportRegFile(PAPPVARS pAppVars,UINT argc,TCHAR *argv[]);

REG_STATUS ParseExportCmdLine(PAPPVARS pAppVars, UINT argc, TCHAR *argv[]);
REG_STATUS ParseImportCmdLine(PAPPVARS pAppVars, UINT argc, TCHAR *argv[]);
REG_STATUS ParseRegCmdLine(PAPPVARS pAppVars, UINT argc, TCHAR *argv[]);
REG_STATUS ParseAddCmdLine(PAPPVARS pAppVars, UINT argc, TCHAR *argv[]);
REG_STATUS ParseCopyCmdLine(PAPPVARS pAppVars,
                            PAPPVARS pDstVars,
                            UINT argc,
                            TCHAR *argv[]); 
REG_STATUS ParseDeleteCmdLine(PAPPVARS pAppVars, 
                              UINT argc, 
                              TCHAR *argv[]);
REG_STATUS ParseQueryCmdLine(PAPPVARS pAppVars, UINT argc, TCHAR *argv[]);
REG_STATUS ParseSaveCmdLine(PAPPVARS pAppVars, UINT argc, TCHAR *argv[]);
REG_STATUS ParseUnLoadCmdLine(PAPPVARS pAppVars, UINT argc, TCHAR *argv[]);
REG_STATUS ParseExportCmdLine(PAPPVARS pAppVars, UINT argc, TCHAR *argv[]);
REG_STATUS ParseImportCmdLine(PAPPVARS pAppVars, UINT argc, TCHAR *argv[]);

LONG CompareRegistry(PAPPVARS pAppVars,
                     PAPPVARS pDstVars,
                     UINT argc,
                     TCHAR *argv[]);

int __cdecl
MyTPrintf(
	FILE* fp,
    LPCTSTR FormatString,
    ...
    );

extern TCHAR g_NoName[100];

BOOL SetThreadUILanguage0( DWORD dwReserved );

#endif  //_REG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\reg\reg1632.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REG1632.H
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        06 Apr 1994
*
*  Win32 and MS-DOS compatibility macros for the Registry Editor.
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  06 Apr 1994 TCS Original implementation.
*
*******************************************************************************/

#ifndef _INC_REG1632
#define _INC_REG1632

#ifndef LPCHAR
typedef CHAR FAR*                       LPCHAR;
#endif

#ifdef WIN32
#define WSPRINTF(x)                     wsprintf ##x
#else
#define WSPRINTF(x)                     sprintf ##x
#endif

#ifdef WIN32
#define STRCMP(string1, string2)        lstrcmp(string1, string2)
#else
#define STRCMP(string1, string2)        _fstrcmp(string1, string2)
#endif

#ifdef WIN32
#define STRCPY(string1, string2)        lstrcpy(string1, string2)
#else
#define STRCPY(string1, string2)        _fstrcpy(string1, string2)
#endif

#ifdef WIN32
#define STRLEN(string)                  lstrlen(string)
#else
#define STRLEN(string)                  _fstrlen(string)
#endif

#ifdef WIN32
#define STRCHR(string, character)       wcschr(string, character)
#else
#define STRCHR(string, character)       _fstrchr(string, character)
#endif

#ifdef WIN32
#define CHARNEXT(string)                CharNext(string)
#else
#define CHARNEXT(string)                (string + 1)
#endif

#ifdef WIN32
#define CHARUPPERSTRING(string)         CharUpper(string)
#else
#define CHARUPPERSTRING(string)         _fstrupr(string)
#endif

#ifdef WIN32
#define FILE_HANDLE                     HANDLE
#else
#define FILE_HANDLE                     int
#endif

#ifdef WIN32
#define FILE_NUMBYTES                   DWORD
#else
#define FILE_NUMBYTES                   unsigned
#endif

#ifdef WIN32
#define OPENREADFILE(pfilename, handle)                                     \
    ((handle = CreateFile(pfilename, GENERIC_READ, FILE_SHARE_READ,         \
        NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL)) !=               \
        INVALID_HANDLE_VALUE)
#else
#define OPENREADFILE(pfilename, handle)                                     \
    (_dos_open(pfilename, _O_RDONLY, &handle) == 0)
#endif

#ifdef WIN32
#define OPENWRITEFILE(pfilename, handle)                                    \
    ((handle = CreateFile(pfilename, GENERIC_WRITE, 0,                      \
        NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL)) !=               \
        INVALID_HANDLE_VALUE)
#else
#define OPENWRITEFILE(pfilename, handle)                                    \
    (_dos_creat(pfilename, _A_NORMAL, &handle) == 0)
#endif

#ifdef WIN32
#define READFILE(handle, buffer, count, pnumbytes)                          \
    ReadFile(handle, buffer, count, pnumbytes, NULL)
#else
#define READFILE(handle, buffer, count, pnumbytes)                          \
    (_dos_read(handle, buffer, count, pnumbytes) == 0)
#endif

#ifdef WIN32
#define WRITEFILE(handle, buffer, count, pnumbytes)                         \
    WriteFile(handle, buffer, count, pnumbytes, NULL)
#else
#define WRITEFILE(handle, buffer, count, pnumbytes)                         \
    (_dos_write(handle, buffer, count, pnumbytes) == 0)
#endif

#ifdef WIN32
#define SEEKCURRENTFILE(handle, count)                                      \
    (SetFilePointer(handle, (LONG) count, NULL, FILE_CURRENT))
#else
#define SEEKCURRENTFILE(handle, count)                                      \
    (_dos_seek(handle, (unsigned long) count, SEEK_CUR))
#endif

#ifdef WIN32
#define CLOSEFILE(handle)               CloseHandle(handle)
#else
#define CLOSEFILE(handle)               _dos_close(handle)
#endif

#ifdef WIN32
#define GETFILESIZE(handle)             GetFileSize(handle, NULL)
#else
DWORD
NEAR PASCAL
GetFileSize(
    FILE_HANDLE hFile
    );
#define GETFILESIZE(handle)             GetFileSize(handle)
#endif

#endif // _INC_REG1632
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\reg\reg.c ===
//-----------------------------------------------------------------------//
//
// File:    Reg.cpp
// Created: Jan 1997
// By:      Martin Holladay (a-martih)
// Purpose: Command-line registry manipulation (query, add, update, etc)
// Modification History:
//      Created - Jan 1997 (a-martih)
//      Oct 1997 (martinho)
//          Fixed up help on Add and Update to display REG_MULTI_SZ examples.
//      Oct 1997 (martinho)
//          Changed /F to /FORCE under usage for delete
//      April 1999 Zeyong Xu: re-design, revision -> version 2.0
//
//-----------------------------------------------------------------------//

#include "stdafx.h"
#include "reg.h"

TCHAR g_NoName[100];

VOID
InitGlobalStrings(
    VOID
    )
{
    LoadString(
        NULL, 
        IDS_NONAME, 
        g_NoName, 
        sizeof(g_NoName)/sizeof(TCHAR));
}


//------------------------------------------------------------------------//
//
// main()
//
//------------------------------------------------------------------------//

int __cdecl wmain(int argc, TCHAR *argv[], TCHAR *envp[])
{
    APPVARS     AppVars;    // Used for all operation
    APPVARS     DstVars;    // Used for COPY/COMPARE operation
    UINT        nResult;

	// set the appropriate thread codepage
    SetThreadUILanguage0( 0);
    
	InitAppVars(&AppVars);
    InitAppVars(&DstVars);

    InitGlobalStrings();

    //
    // Determine the opertion - and pass control to the *deserving* function
    //
    nResult = ParseRegCmdLine(&AppVars, argc, argv);

    if(nResult == REG_STATUS_BADOPERATION)
    {
        TCHAR  szString[LENGTH_MESSAGE] = {0};
        LoadString(NULL,
                   IDS_ERROR_BADOPERATION,
                   szString,
                   LENGTH_MESSAGE);
        MyTPrintf(stderr,_T("%s"), szString);
    }
    else if(nResult == REG_STATUS_HELP)
    {
        Banner();
        Usage(AppVars);
    }
    else if(nResult == ERROR_SUCCESS)
    {
        //
        // At this point we have a valid operation
        //
        switch(AppVars.nOperation)
        {
            case REG_QUERY:

                nResult = QueryRegistry(&AppVars, argc, argv);
                break;

            case REG_DELETE:

                nResult = DeleteRegistry(&AppVars, argc, argv);
                break;

            case REG_ADD:

                nResult = AddRegistry(&AppVars, argc, argv);
                break;

            case REG_COPY:

                nResult = CopyRegistry(&AppVars, &DstVars, argc, argv);
                break;

            case REG_SAVE:

                nResult = SaveHive(&AppVars, argc, argv);
                break;

            case REG_RESTORE:

                nResult = RestoreHive(&AppVars, argc, argv);
                break;

            case REG_LOAD:

                nResult = LoadHive(&AppVars, argc, argv);
                break;

            case REG_UNLOAD:

                nResult = UnLoadHive(&AppVars, argc, argv);
                break;

            case REG_COMPARE:

                nResult = CompareRegistry(&AppVars, &DstVars, argc, argv);
                break;

            case REG_EXPORT:
                nResult = ExportRegFile(&AppVars, argc, argv);
                break;

            case REG_IMPORT:
                nResult = ImportRegFile(&AppVars, argc, argv);
                break;

            default:
                nResult = REG_STATUS_INVALIDPARAMS;
                break;
        }
    }

    if(nResult != ERROR_SUCCESS &&
       nResult != REG_STATUS_BADOPERATION &&
       nResult != REG_STATUS_HELP)
    {
        ErrorMessage(nResult);
    }
    else if(nResult == ERROR_SUCCESS &&
            AppVars.nOperation != REG_QUERY)
    {
        //
        // Print "The operation completed successfully" message
        //
        TCHAR  szString[LENGTH_MESSAGE] = {0};
        LoadString(NULL,
                   IDS_SUCCESS,
                   szString,
                   LENGTH_MESSAGE);
        MyTPrintf(stdout,_T("%s"), szString);
    }

    FreeAppVars(&AppVars);
    FreeAppVars(&DstVars);

    if(nResult == REG_STATUS_HELP)
        nResult = ERROR_SUCCESS;

    nResult = !(!nResult);    // cast to 0 or 1

    if(AppVars.nOperation == REG_COMPARE)
    {
        if( nResult == 0 &&  // no error
            AppVars.bHasDifference)
        {
            nResult = 2;     // has difference
        }
    }

    return nResult;
}


//------------------------------------------------------------------------//
//
// ParseRegCmdLine()
//   Find out the operation - each operation parses it's own cmd-line
//
//------------------------------------------------------------------------//

REG_STATUS ParseRegCmdLine(PAPPVARS pAppVars, UINT argc, TCHAR *argv[])
{
    REG_STATUS  nResult = ERROR_SUCCESS;

    // Set default operation
    pAppVars->nOperation = REG_NOOPERATION;

    //
    // Do we have any cmd-line params
    //
    if(argc == 1)
    {
        return REG_STATUS_HELP;
    }

    //
    // If we fell through - we need to get the operation
    // MUST be the first parameter
    //
    if(_tcsicmp(argv[1], STR_QUERY) == 0)
    {
        pAppVars->nOperation = REG_QUERY;
    }
    else if(_tcsicmp(argv[1], STR_ADD) == 0)
    {
        pAppVars->nOperation = REG_ADD;
    }
    else if(_tcsicmp(argv[1], STR_DELETE) == 0)
    {
        pAppVars->nOperation = REG_DELETE;
    }
    else if(_tcsicmp(argv[1], STR_COPY) == 0)
    {
        pAppVars->nOperation = REG_COPY;
    }
    else if(_tcsicmp(argv[1], STR_SAVE) == 0)
    {
        pAppVars->nOperation = REG_SAVE;
    }
    else if(_tcsicmp(argv[1], STR_RESTORE) == 0)
    {
        pAppVars->nOperation = REG_RESTORE;
    }
    else if(_tcsicmp(argv[1], STR_LOAD) == 0)
    {
        pAppVars->nOperation = REG_LOAD;
    }
    else if(_tcsicmp(argv[1], STR_UNLOAD) == 0)
    {
        pAppVars->nOperation = REG_UNLOAD;
    }
    else if(_tcsicmp(argv[1], STR_COMPARE) == 0)
    {
        pAppVars->nOperation = REG_COMPARE;
    }
    else if(_tcsicmp(argv[1], STR_EXPORT) == 0)
    {
        pAppVars->nOperation = REG_EXPORT;
    }
    else if(_tcsicmp(argv[1], STR_IMPORT) == 0)
    {
        pAppVars->nOperation = REG_IMPORT;
    }
    else if((_tcsicmp(argv[1], _T("-?")) == 0) ||
            (_tcsicmp(argv[1], _T("/?")) == 0) ||
            (_tcsicmp(argv[1], _T("-h")) == 0) ||
            (_tcsicmp(argv[1], _T("/h")) == 0))
    {
        nResult = REG_STATUS_HELP;
    }
    else
    {
        nResult = REG_STATUS_BADOPERATION;
    }


    if(nResult == ERROR_SUCCESS && argc == 3)
    {
        if((_tcsicmp(argv[2], _T("-?")) == 0) ||
           (_tcsicmp(argv[2], _T("/?")) == 0) ||
           (_tcsicmp(argv[2], _T("-h")) == 0) ||
           (_tcsicmp(argv[2], _T("/h")) == 0))
        {
            nResult = REG_STATUS_HELP;
        }
    }

    return nResult;
}

//------------------------------------------------------------------------//
//
// AllocAppVars() - Allocate memory for the AppVars
//
//------------------------------------------------------------------------//

void InitAppVars(PAPPVARS pAppVars)
{
    // initialize
    pAppVars->nOperation = REG_NOOPERATION;
    pAppVars->hRootKey = HKEY_LOCAL_MACHINE;
    pAppVars->dwRegDataType = REG_SZ;
    pAppVars->bUseRemoteMachine = FALSE;
    pAppVars->bCleanRemoteRootKey = FALSE;
    pAppVars->bRecurseSubKeys = FALSE;
    pAppVars->bForce = FALSE;
    pAppVars->bAllValues = FALSE;
    pAppVars->bNT4RegFile = FALSE;
    pAppVars->bHasDifference = FALSE;
    pAppVars->nOutputType = OUTPUTTYPE_DIFF;
    pAppVars->szMachineName = NULL;
    pAppVars->szFullKey = NULL;
    pAppVars->szSubKey = NULL;
    pAppVars->szValueName = NULL;
    pAppVars->szValue = NULL;
    _tcscpy(pAppVars->szSeparator, _T("\\0"));
}


//------------------------------------------------------------------------//
//
// FreeAppVars()
//
//------------------------------------------------------------------------//

void FreeAppVars(PAPPVARS pAppVars)
{
    if(pAppVars->szMachineName)
        free(pAppVars->szMachineName);
    if(pAppVars->szFullKey)
        free(pAppVars->szFullKey);
    if(pAppVars->szSubKey)
        free(pAppVars->szSubKey);
    if(pAppVars->szValueName)
        free(pAppVars->szValueName);
    if(pAppVars->szValue)
        free(pAppVars->szValue);

    if(pAppVars->bCleanRemoteRootKey)
    {
        RegCloseKey(pAppVars->hRootKey);
    }
}


//------------------------------------------------------------------------//
//
// ErrorMessage() - Displays error string
//
//------------------------------------------------------------------------//

void ErrorMessage(UINT nErr)
{
    TCHAR  szString[LENGTH_MESSAGE] = {0};

    // First check for OUR Errors
    switch(nErr)
    {
        case REG_STATUS_TOMANYPARAMS:
            LoadString(NULL,
                       IDS_ERROR_TOMANYPARAMS,
                       szString,
                       LENGTH_MESSAGE);
            break;

        case REG_STATUS_TOFEWPARAMS:
            LoadString(NULL,
                       IDS_ERROR_TOFEWPARAMS,
                       szString,
                       LENGTH_MESSAGE);
            break;

        case REG_STATUS_INVALIDPARAMS:
            LoadString(NULL,
                       IDS_ERROR_INVALIDPARAMS,
                       szString,
                       LENGTH_MESSAGE);
            break;

        case REG_STATUS_NONREMOTABLEROOT:
            LoadString(NULL,
                       IDS_ERROR_NONREMOTABLEROOT,
                       szString,
                       LENGTH_MESSAGE);
            break;

        case REG_STATUS_NONLOADABLEROOT:
            LoadString(NULL,
                       IDS_ERROR_NONLOADABLEROOT,
                       szString,
                       LENGTH_MESSAGE);
            break;

        case REG_STATUS_COPYTOSELF:
            LoadString(NULL,
                       IDS_ERROR_COPYTOSELF,
                       szString,
                       LENGTH_MESSAGE);
            break;

        case REG_STATUS_COMPARESELF:
            LoadString(NULL,
                       IDS_ERROR_COMPARESELF,
                       szString,
                       LENGTH_MESSAGE);
            break;

        case REG_STATUS_BADKEYNAME:
        case REG_STATUS_NOKEYNAME:
            LoadString(NULL,
                       IDS_ERROR_BADKEYNAME,
                       szString,
                       LENGTH_MESSAGE);
            break;

        case REG_STATUS_BADFILEFORMAT:
            LoadString(NULL,
                       IDS_ERROR_BADFILEFORMAT,
                       szString,
                       LENGTH_MESSAGE);
            break;

        case REG_STATUS_NONREMOTABLE:
            LoadString(NULL,
                       IDS_ERROR_NONREMOTABLE,
                       szString,
                       LENGTH_MESSAGE);
            break;

        //
        // Deal with these two Win32 Error Values - I don't like the
        // text strings displayed
        //
        case ERROR_FILE_NOT_FOUND:
        case ERROR_PATH_NOT_FOUND:
            LoadString(NULL,
                       IDS_ERROR_PATHNOTFOUND,
                       szString,
                       LENGTH_MESSAGE);
            break;

        //
        // Must be a Win32 Error number
        //
        default:
        {
            TCHAR* szMessage;
            if(FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                    FORMAT_MESSAGE_FROM_SYSTEM,
                             NULL,
                             nErr,
                             0,
                             (LPTSTR) &szMessage,
                             0,
                             NULL))
            {
                wsprintf(szString, _T("\r\nError:  %s"), szMessage);
                LocalFree(szMessage);
            }
            else
            {
                wsprintf(szString,
                         _T("\r\nError:  Unknown Return Code %d\r\n"),
                         nErr);
            }
            break;
        }
    }

    // print the error message
    MyTPrintf(stderr, _T("%s"), szString);
}


//------------------------------------------------------------------------//
//
// Prompt() - Answer Y/N question if bForce == FALSE
//
//------------------------------------------------------------------------//

BOOL Prompt(LPCTSTR szFormat, LPCTSTR szStr, BOOL bForce)
{
    TCHAR ch;

    if(bForce == TRUE)
    {
        return TRUE;
    }

    MyTPrintf(stdout,szFormat, szStr);
    ch = (TCHAR)_gettchar();

    if(ch == _T( 'y' ) || ch == _T( 'Y' ) )
    {
        return TRUE;
    }

    return FALSE;
}

// break down [\\MachineName\]keyName
REG_STATUS BreakDownKeyString(TCHAR *szStr, PAPPVARS pAppVars)
{
    REG_STATUS nResult = ERROR_SUCCESS;
    TCHAR* pTemp;
    TCHAR* szTempStr;

    szTempStr = (TCHAR*) calloc(_tcslen(szStr) + 1, sizeof(TCHAR));
    if (!szTempStr) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    _tcscpy(szTempStr, szStr);

    //
    // figure out machine name
    //
    pTemp = szTempStr;

     // machine name
    if( szTempStr[0] == _T('\\') &&
        szTempStr[1] == _T('\\') )
    {
        pTemp = _tcschr(szTempStr + 2, _T('\\'));

        if(pTemp)
        {
            *pTemp = 0;
            pTemp += 1;
        }

        nResult = ParseMachineName(szTempStr, pAppVars);
    }

    // parse key name
    if( nResult == ERROR_SUCCESS)
    {
        if(pTemp && _tcslen(pTemp) > 0)
        {
            nResult = ParseKeyName(pTemp, pAppVars);
        }
        else
        {
            nResult = REG_STATUS_NOKEYNAME;
        }
    }

    if(szTempStr)
        free(szTempStr);

    return nResult;
}

//------------------------------------------------------------------------//
//
// FindAndAdjustKeyName()
//
// null out the cmdline based on what we think the end of the argument is
//
// we do this because users might not quote out the cmdline properly.
//
//------------------------------------------------------------------------//
PTCHAR
AdjustKeyName(
    PTCHAR szStr
    )
{
    PTCHAR p;

    p = _tcschr(szStr, _T('\"'));
    if (p != NULL) {
        *p = 0;        
    }

    p = _tcschr(szStr, _T('/'));
    if (p != NULL) {
        *p = 0;        
    }

    return szStr;
    
}


//------------------------------------------------------------------------//
//
// ParseKeyName()
//
// Pass the full registry path in szStr
//
// Based on input - Sets AppMember fields:
//
//      hRootKey
//      szKey
//      szValueName
//      szValue
//
//------------------------------------------------------------------------//

REG_STATUS ParseKeyName(TCHAR *szStr, PAPPVARS pAppVars)
{
    REG_STATUS nResult = ERROR_SUCCESS;
    TCHAR* pTemp;
    TCHAR* szRootKey;

    //
    // figure out what root key was specified
    //
    pTemp = _tcschr(szStr, _T('\\'));
    if (pTemp != NULL)
    {
        *pTemp = 0;
        pTemp += 1;
    }

    if (*szStr == '\"') {
        szStr += 1;
    }

    //
    // Check the ROOT has been entered
    //
    szRootKey = (TCHAR*) calloc(_tcslen(STR_HKEY_CURRENT_CONFIG) + 1,
                                       sizeof(TCHAR));
    if (!szRootKey) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    if (_tcsicmp(szStr, STR_HKEY_CURRENT_USER) == 0 ||
        _tcsicmp(szStr, STR_HKCU) == 0)
    {
        pAppVars->hRootKey = HKEY_CURRENT_USER;
        _tcscpy(szRootKey, STR_HKEY_CURRENT_USER);

        // check remotable and loadable
        if(pAppVars->bUseRemoteMachine)
            nResult = REG_STATUS_NONREMOTABLEROOT;
        else if( pAppVars->nOperation == REG_LOAD ||
                 pAppVars->nOperation == REG_UNLOAD )
            nResult = REG_STATUS_NONLOADABLEROOT;
    }
    else if (_tcsicmp(szStr, STR_HKEY_CLASSES_ROOT) == 0 ||
             _tcsicmp(szStr, STR_HKCR) == 0)
    {
        pAppVars->hRootKey = HKEY_CLASSES_ROOT;
        _tcscpy(szRootKey, STR_HKEY_CLASSES_ROOT);

        // check remotable and loadable
        if(pAppVars->bUseRemoteMachine)
            nResult = REG_STATUS_NONREMOTABLEROOT;
        else if( pAppVars->nOperation == REG_LOAD ||
                 pAppVars->nOperation == REG_UNLOAD )
            nResult = REG_STATUS_NONLOADABLEROOT;
    }
    else if (_tcsicmp(szStr, STR_HKEY_CURRENT_CONFIG) == 0 ||
             _tcsicmp(szStr, STR_HKCC) == 0)
    {
        pAppVars->hRootKey = HKEY_CURRENT_CONFIG;
        _tcscpy(szRootKey, STR_HKEY_CURRENT_CONFIG);

        // check remotable and loadable
        if(pAppVars->bUseRemoteMachine)
            nResult = REG_STATUS_NONREMOTABLEROOT;
        else if( pAppVars->nOperation == REG_LOAD ||
                 pAppVars->nOperation == REG_UNLOAD )
            nResult = REG_STATUS_NONLOADABLEROOT;
    }
    else if (_tcsicmp(szStr, STR_HKEY_LOCAL_MACHINE) == 0 ||
             _tcsicmp(szStr, STR_HKLM) == 0)
    {
        pAppVars->hRootKey = HKEY_LOCAL_MACHINE;
        _tcscpy(szRootKey, STR_HKEY_LOCAL_MACHINE);
    }
    else if (_tcsicmp(szStr, STR_HKEY_USERS) == 0 ||
             _tcsicmp(szStr, STR_HKU) == 0)
    {
        pAppVars->hRootKey = HKEY_USERS;
        _tcscpy(szRootKey, STR_HKEY_USERS);
    }
    else
    {
        nResult = REG_STATUS_BADKEYNAME;
    }

    if(nResult == ERROR_SUCCESS)
    {
        //
        // parse the subkey
        //
        if (pTemp == NULL)
        {
            // only root key, subkey is empty
            pAppVars->szSubKey = (TCHAR*) calloc(1,
                                                 sizeof(TCHAR));
            if (!pAppVars->szSubKey) {
                nResult = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }
            pAppVars->szFullKey = (TCHAR*) calloc(_tcslen(szRootKey) + 1,
                                                  sizeof(TCHAR));
            if (!pAppVars->szFullKey) {
                free (pAppVars->szSubKey);
                pAppVars->szSubKey = NULL;
                nResult = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }
            _tcscpy(pAppVars->szFullKey, szRootKey);
        }
        else
        {
            //
            // figure out what root key was specified
            //
            pTemp = AdjustKeyName(pTemp);
            
            // get subkey
            pAppVars->szSubKey = (TCHAR*) calloc(_tcslen(pTemp) + 1,
                                                 sizeof(TCHAR));
            if (!pAppVars->szSubKey) {
                nResult = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }
            _tcscpy(pAppVars->szSubKey, pTemp);

            // get fullkey
            pAppVars->szFullKey = (TCHAR*) calloc(_tcslen(szRootKey) +
                                        _tcslen(pAppVars->szSubKey) +
                                        2,
                                        sizeof(TCHAR));
            if (!pAppVars->szFullKey) {
                free (pAppVars->szSubKey);
                pAppVars->szSubKey = NULL;
                nResult = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }
            _tcscpy(pAppVars->szFullKey, szRootKey);
            _tcscat(pAppVars->szFullKey, _T("\\"));
            _tcscat(pAppVars->szFullKey, pAppVars->szSubKey);
        }
    }
Cleanup:
    if(szRootKey)
        free(szRootKey);

    return nResult;
}


//------------------------------------------------------------------------//
//
// IsRegDataType()
//
//------------------------------------------------------------------------//

DWORD IsRegDataType(TCHAR *szStr)
{
    DWORD   nResult = (DWORD)-1;

    if(_tcsicmp(szStr, STR_REG_SZ) == 0)
    {
        nResult = REG_SZ;
    }
    else if(_tcsicmp(szStr, STR_REG_EXPAND_SZ) == 0)
    {
        nResult = REG_EXPAND_SZ;
    }
    else if(_tcsicmp(szStr, STR_REG_MULTI_SZ) == 0)
    {
        nResult = REG_MULTI_SZ;
    }
    else if(_tcsicmp(szStr, STR_REG_BINARY) == 0)
    {
        nResult = REG_BINARY;
    }
    else if(_tcsicmp(szStr, STR_REG_DWORD) == 0)
    {
        nResult = REG_DWORD;
    }
    else if(_tcsicmp(szStr, STR_REG_DWORD_LITTLE_ENDIAN) == 0)
    {
        nResult = REG_DWORD_LITTLE_ENDIAN;
    }
    else if(_tcsicmp(szStr, STR_REG_DWORD_BIG_ENDIAN) == 0)
    {
        nResult = REG_DWORD_BIG_ENDIAN;
    }
    else if(_tcsicmp(szStr, STR_REG_NONE) == 0)
    {
        nResult = REG_NONE;
    }

    return nResult;
}


//------------------------------------------------------------------------//
//
// Banner()
//
//------------------------------------------------------------------------//

void Banner()
{
    TCHAR   szCopyRight[LENGTH_MESSAGE] = {0};
    LONG    rc = 0;


    rc = LoadString( NULL,
                     IDS_REG_BANNER,
                     szCopyRight,
                     LENGTH_MESSAGE);
    if( rc ) {
        MyTPrintf( stdout,_T("\r\n%s\r\n"), szCopyRight );
    }

    rc = LoadString( NULL,
                     IDS_COPYRIGHT,
                     szCopyRight,
                     LENGTH_MESSAGE);
    if( rc ) {
        MyTPrintf( stdout,_T("%s\r\n"), szCopyRight );
    }
}


//------------------------------------------------------------------------//
//
// Usage() - Display Usage Information
//
//------------------------------------------------------------------------//

void Usage(APPVARS AppVars)
{
    TCHAR szUsage1[LENGTH_USAGE] = {0};
    TCHAR szUsage2[LENGTH_USAGE] = {0};

    switch(AppVars.nOperation)
    {
    case REG_QUERY:
        LoadString(NULL,
                   IDS_USAGE_QUERY,
                   szUsage1,
                   LENGTH_USAGE);
        break;

    case REG_ADD:
        LoadString(NULL,
                   IDS_USAGE_ADD1,
                   szUsage1,
                   LENGTH_USAGE);

        LoadString(NULL,
                   IDS_USAGE_ADD2,
                   szUsage2,
                   LENGTH_USAGE);
        break;

    case REG_DELETE:
        LoadString(NULL,
                   IDS_USAGE_DELETE,
                   szUsage1,
                   LENGTH_USAGE);
        break;

    case REG_COPY:
        LoadString(NULL,
                   IDS_USAGE_COPY,
                   szUsage1,
                   LENGTH_USAGE);
        break;

    case REG_SAVE:
        LoadString(NULL,
                   IDS_USAGE_SAVE,
                   szUsage1,
                   LENGTH_USAGE);
        break;

    case REG_RESTORE:
        LoadString(NULL,
                   IDS_USAGE_RESTORE,
                   szUsage1,
                   LENGTH_USAGE);
        break;

    case REG_LOAD:
        LoadString(NULL,
                   IDS_USAGE_LOAD,
                   szUsage1,
                   LENGTH_USAGE);
        break;

    case REG_UNLOAD:
        LoadString(NULL,
                   IDS_USAGE_UNLOAD,
                   szUsage1,
                   LENGTH_USAGE);
       break;

    case REG_COMPARE:
        LoadString(NULL,
                   IDS_USAGE_COMPARE1,
                   szUsage1,
                   LENGTH_USAGE);
        LoadString(NULL,
                   IDS_USAGE_COMPARE2,
                   szUsage2,
                   LENGTH_USAGE);
        break;

    case REG_EXPORT:
        LoadString(NULL,
                   IDS_USAGE_EXPORT,
                   szUsage1,
                   LENGTH_USAGE);
        break;

    case REG_IMPORT:
        LoadString(NULL,
                   IDS_USAGE_IMPORT,
                   szUsage1,
                   LENGTH_USAGE);
        break;

    default:
        LoadString(NULL,
                   IDS_USAGE_REG,
                   szUsage1,
                   LENGTH_USAGE);
        break;
    }

    MyTPrintf(stdout,_T("%s%s"), szUsage1, szUsage2);
}


//------------------------------------------------------------------------//
//
// IsMachineName()
//
//------------------------------------------------------------------------//

REG_STATUS ParseMachineName(TCHAR* szStr, PAPPVARS pAppVars)
{
    //
    // copy string
    //
    if(!_tcsicmp(szStr, _T("\\\\")))             // need a machine name
        return REG_STATUS_BADKEYNAME;
    else if(!_tcsicmp(szStr, _T("\\\\.")))       // current machine
        return ERROR_SUCCESS;

    pAppVars->szMachineName = (TCHAR*) calloc(_tcslen(szStr) + 1,
                                              sizeof(TCHAR));
    if (!pAppVars->szMachineName) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    _tcscpy(pAppVars->szMachineName, szStr);

    pAppVars->bUseRemoteMachine = TRUE;

    return ERROR_SUCCESS;
}


LONG RegConnectMachine(PAPPVARS pAppVars)
{
    HKEY hKeyConnect;
    LONG nResult = ERROR_SUCCESS;

    if (pAppVars->bUseRemoteMachine)
    {
        // close the remote key
        if(pAppVars->bCleanRemoteRootKey)
            RegCloseKey(pAppVars->hRootKey);

        // connect to remote key
        nResult = RegConnectRegistry(pAppVars->szMachineName,
                                     pAppVars->hRootKey,
                                     &hKeyConnect);
        if (nResult == ERROR_SUCCESS)
        {
            pAppVars->hRootKey = hKeyConnect;
            pAppVars->bCleanRemoteRootKey = TRUE;
        }
    }

    return nResult;
}

//
//  BOOL
//  IsConsoleHandle(
//      IN HANDLE ConsoleHandle
//      );
//

#define IsConsoleHandle( h )                                                \
    ((( DWORD_PTR )( h )) & 1 )


TCHAR ReallyBigBuffer[4096];
CHAR ReallyBigBufferAnsi[4096];

int __cdecl
MyTPrintf(
	FILE* fp,
    LPCTSTR FormatString,
    ...
    )
/*++

Routine Description:

    This is a function that does what tprintf should really do for console
    applications.
    
    tprintf converts strings for the terminal to ansi codepage instead of
    oem codepage.  This doesn't work for localized apps where the ansi codepage
    conversions do not match the oem codepage conversions.
    
    This routine uses WriteConsole() api instead, which does the correct
    thing for console apps, but only if the app is writing to the console.  if 
    it's not writing to the console, WriteConsole will fail, so we have to do 
    something different.  So the output unicode text is converted to and saved 
    in ansi codepage format.  This means you can look at the output text with 
    "notepad.exe" but not with the "type" command for instance.

Arguments:

    FormatString - format string

Return Value:

    Number of characters written to stdout.

--*/

{
    va_list arglist;
    HANDLE Handle;
    DWORD CharsIn, CharsOut;
    PSTR pBuffer;
    BOOL Success;

    va_start(arglist,FormatString);

    CharsIn = _vsntprintf( ReallyBigBuffer, sizeof(ReallyBigBuffer)/sizeof(TCHAR), FormatString, arglist );

    
    //
    // If the standard output handle is a console handle, write the string 
    // via console api
    //
    Handle = GetStdHandle( fp == stderr ? STD_ERROR_HANDLE : STD_OUTPUT_HANDLE );

    if ( IsConsoleHandle( Handle )) {

        Success = WriteConsole(
                               Handle,
                               ReallyBigBuffer,
                               CharsIn,
                               &CharsOut,
                               NULL
                               );
    } else {
#ifdef UNICODE
        //
        // convert to ansi codepage and write to stdout
        //
        int     rc;

        rc = WideCharToMultiByte(
                                CP_ACP,
                                0,
                                ReallyBigBuffer,
                                CharsIn,
                                ReallyBigBufferAnsi,
                                sizeof( ReallyBigBufferAnsi ),
                                NULL,
                                NULL
                                );
        if ( rc == 0 ) {
            Success = FALSE;
            goto exit;
        }

        pBuffer = ReallyBigBufferAnsi;
#else
        pBuffer = ReallyBigBuffer;
#endif

        Success = WriteFile(
                           Handle,
                           pBuffer,
                           CharsIn,
                           &CharsOut,
                           NULL
                           );
    }

exit:
    va_end(arglist);

    //
    // Return the number of characters written.
    //

    if ( Success ) {

        return CharsOut;

    } else {

        return 0;
    }


    

}

 
// ***************************************************************************
// Routine Description:
//	
//		Complex scripts cannot be rendered in the console, so we
//		force the English (US) resource.
//	  
// Arguments:
//		[ in ] dwReserved  => must be zero
//
// Return Value:
//		TRUE / FALSE
//
// ***************************************************************************
BOOL SetThreadUILanguage0( DWORD dwReserved )
{
	// local variables
	HMODULE hKernel32Lib = NULL;
	const CHAR cstrFunctionName[] = "SetThreadUILanguage";
	typedef BOOLEAN (WINAPI * FUNC_SetThreadUILanguage)( DWORD dwReserved );
	FUNC_SetThreadUILanguage pfnSetThreadUILanguage = NULL;
	
	// try loading the kernel32 dynamic link library
	hKernel32Lib = LoadLibrary( _T( "kernel32.dll" ) );
	if ( hKernel32Lib != NULL )
	{
		// library loaded successfully ... now load the addresses of functions
		pfnSetThreadUILanguage = (FUNC_SetThreadUILanguage) GetProcAddress( hKernel32Lib, cstrFunctionName );

		// we will keep the library loaded in memory only if all the functions were loaded successfully
		if ( pfnSetThreadUILanguage == NULL )
		{
			// some (or) all of the functions were not loaded ... unload the library
			FreeLibrary( hKernel32Lib );
			hKernel32Lib = NULL;
			pfnSetThreadUILanguage = NULL;
			return FALSE;
		}
		else
		{
			// call the function
			((FUNC_SetThreadUILanguage) pfnSetThreadUILanguage)( dwReserved );
		}
	}

	// unload the library and return success
	FreeLibrary( hKernel32Lib );
	hKernel32Lib = NULL;
	pfnSetThreadUILanguage = NULL;
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\reg\regdebug.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGDEBUG.H
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        05 Mar 1994
*
*  Debug routines for the Registry Editor.
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  05 Mar 1994 TCS Original implementation.
*
*******************************************************************************/

#ifndef _INC_REGDEBUG
#define _INC_REGDEBUG

#if (!defined(WINNT) && defined(DEBUG)) || (defined(WINNT) && DBG)

VOID
__cdecl
_DbgPrintf(
    PSTR pFormatString,
    ...
    );

#define DbgPrintf(x)                    _DbgPrintf ##x

#else

#define DbgPrintf(x)

#endif

#endif // _INC_REGDEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\reg\regdebug.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGDEBUG.C
*
*  VERSION:     4.0
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        21 Nov 1993
*
*  Debug routines for the Registry Editor.
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  21 Nov 1993 TCS Original implementation.
*
*******************************************************************************/

#include "stdafx.h"

#if (!defined(WINNT) && defined(DEBUG)) || (defined(WINNT) && DBG)

#define SIZE_DEBUG_BUFFER               100

/*******************************************************************************
*
*  _DbgPrintf
*
*  DESCRIPTION:
*     Simple implementation of the "debug printf" routine.  Takes the given
*     format string and argument list and outputs the formatted string to the
*     debugger.  Only available in debug builds-- use the DbgPrintf macro
*     defined in REGEDIT.H to access this service or to ignore the printf.
*
*  PARAMETERS:
*     lpFormatString, printf-style format string.
*     ..., variable argument list.
*
*******************************************************************************/

VOID
__cdecl
_DbgPrintf(
    PSTR pFormatString,
    ...
    )
{

    va_list arglist;
    CHAR DebugBuffer[SIZE_DEBUG_BUFFER];

    va_start(arglist, pFormatString);

    wvsprintfA(DebugBuffer, pFormatString, arglist);

    OutputDebugStringA(DebugBuffer);
//    MessageBoxA(NULL, DebugBuffer, "RegEdit", MB_OK);

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\reg\regdef.h ===
/* Do not include this before Windows.h */

/* ASM
; DO NOT INCLUDE THIS BEFORE WINDOWS.INC
*/

#define Dereference(x)  x=x;

/*XLATOFF*/
#pragma warning (disable:4209)      // turn off redefinition warning (with vmm.h)
/*XLATON*/

#ifndef _WINREG_
//  WINREG.H uses DECLARE_HANDLE(HKEY) giving incompatible types.
typedef DWORD       HKEY;
#endif

/*XLATOFF*/
#pragma warning (default:4209)      // turn on redefinition warning (with vmm.h)
/*XLATON*/

#define MAXKEYNAME      256
        // Max length of a key name string
#define MAXVALUENAME_LENGTH MAXKEYNAME
        // Max length of a value name string
#define MAXDATA_LENGTH      16L*1024L
        // Max length of a value data item
        

#ifndef REG_SZ
#define REG_SZ      0x0001
#endif

#ifndef REG_BINARY
#define REG_BINARY  0x0003
#endif

#ifndef REG_DWORD
#define REG_DWORD       0x0004
#endif

#ifndef FALSE
#define FALSE   0
#endif
#ifndef TRUE
#define TRUE    ~FALSE
#endif

/* following equates are also defined in Windows.h. To avoid warnings
 *  we should make these equates  conditional
 */


#ifndef ERROR_SUCCESS           
#define ERROR_SUCCESS           0L
#endif

#ifndef ERROR_FILE_NOT_FOUND
#define ERROR_FILE_NOT_FOUND        2L
#endif

#ifndef ERROR_ACCESS_DENIED
#define ERROR_ACCESS_DENIED              5L
#endif

#ifndef ERROR_BADDB
#define ERROR_BADDB                      1009L
#endif

#ifndef ERROR_MORE_DATA
#define ERROR_MORE_DATA                  234L
#endif

#ifndef ERROR_BADKEY
#define ERROR_BADKEY             1010L
#endif

#ifndef ERROR_CANTOPEN
#define ERROR_CANTOPEN                   1011L
#endif

#ifndef ERROR_CANTREAD
#define ERROR_CANTREAD                   1012L
#define ERROR_CANTWRITE                  1013L
#endif

#ifndef ERROR_REGISTRY_CORRUPT
#define ERROR_REGISTRY_CORRUPT           1015L
#define ERROR_REGISTRY_IO_FAILED         1016L
#endif

#ifndef ERROR_KEY_DELETED
#define ERROR_KEY_DELETED                1018L
#endif

#ifndef ERROR_OUTOFMEMORY
#define ERROR_OUTOFMEMORY          14L
#endif

#ifndef ERROR_INVALID_PARAMETER
#define ERROR_INVALID_PARAMETER        87L
#endif

#ifndef ERROR_LOCK_FAILED
#define ERROR_LOCK_FAILED                167L
#endif

#ifndef ERROR_NO_MORE_ITEMS
#define ERROR_NO_MORE_ITEMS       259L
#endif  

// INTERNAL

#ifndef ERROR_CANTOPEN16_FILENOTFOUND32
#define ERROR_CANTOPEN16_FILENOTFOUND32 0xffff0000
#define ERROR_CANTREAD16_FILENOTFOUND32 0xffff0001
#endif

#ifndef HKEY_CLASSES_ROOT
#define HKEY_CLASSES_ROOT          ((HKEY)0x80000000)
#endif

#ifndef HKEY_CURRENT_USER
#define HKEY_CURRENT_USER              ((HKEY)0x80000001)
#endif

#ifndef HKEY_LOCAL_MACHINE
#define HKEY_LOCAL_MACHINE             ((HKEY)0x80000002)
#endif

#ifndef HKEY_USERS
#define HKEY_USERS                     ((HKEY)0x80000003)
#endif

#ifndef HKEY_PERFORMANCE_DATA
#define HKEY_PERFORMANCE_DATA          ((HKEY)0x80000004)
#endif

#ifndef HKEY_CURRENT_CONFIG
#define HKEY_CURRENT_CONFIG            ((HKEY)0x80000005)
#endif

#ifndef HKEY_DYN_DATA
#define HKEY_DYN_DATA                  ((HKEY)0x80000006)
#endif

// INTERNAL

#ifndef HKEY_PREDEF_KEYS
#define HKEY_PREDEF_KEYS    7
#endif

#define MAXREGFILES     HKEY_PREDEF_KEYS    

// sub function indices for Registry services in VMM for 16 bit callers

#define RegOpenKey_Idx      0x100
#define RegCreateKey_Idx    0x101
#define RegCloseKey_Idx     0x102
#define RegDeleteKey_Idx    0x103
#define RegSetValue_Idx     0x104
#define RegQueryValue_Idx   0x105
#define RegEnumKey_Idx      0x106
#define RegDeleteValue_Idx  0x107
#define RegEnumValue_Idx    0x108
#define RegQueryValueEx_Idx 0x109
#define RegSetValueEx_Idx   0x10A
#define RegFlushKey_Idx     0x10B
#define RegLoadKey_Idx      0x10C
#define RegUnLoadKey_Idx    0x10D
#define RegSaveKey_Idx      0x10E
#define RegRestore_Idx      0x10F
#define RegRemapPreDefKey_Idx   0x110

// Data structure passed to SYSDM.CPL DMRegistryError function
//  After UI, the function is to call
//  RegRestore(DWORD iLevel, LPREGQRSTR lpRgRstr)
//

struct Reg_Query_Restore_s {
DWORD   dwRQR_Err;      // Error code
DWORD   hRQR_RootKey;       // Root key for file
DWORD   dwRQR_Reference;    // Reference data for RegRestore
TCHAR   szRQR_SubKey[MAXKEYNAME]; // Subkey (for hives) or NULL string
TCHAR   szRQR_FileName[MAX_PATH]; // File name of bad file
};
typedef struct Reg_Query_Restore_s REGQRSTR;
typedef REGQRSTR FAR * LPREGQRSTR;


// END INTERNAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\reg\regeditp.c ===
//---------------------------------------------------------------------------
//
//  TITLE:       Regeditp.c : Defines the private API RegExportRegFile() and 
//               RegImportRegFile() for regedit.exe and reskit\reg.exe 
//
//  AUTHOR:      Zeyong Xu
//
//  DATE:        March 1999
//
//---------------------------------------------------------------------------


#include "stdafx.h"
#include "regporte.h"
#include "regeditp.h"


HWND        g_hRegProgressWnd;
HINSTANCE   g_hInstance;
BOOL        g_fSaveInDownlevelFormat;


//
//  RegImportRegFile
//  PARAMETERS:
//     hWnd, handle of parent window.
//     fSilentMode, TRUE if no messages should be displayed, else FALSE.
//     lpFileName, address of file name buffer.
//
LONG WINAPI RegImportRegFile(HWND hWnd,
                             BOOL fSilentMode,
                             LPTSTR lpFileName)
{

    ImportRegFileWorker(lpFileName);

    if(g_FileErrorStringID == IDS_IMPFILEERRSUCCESS)
        return ERROR_SUCCESS;
    else
        return GetLastError();
}


//
// RegExportRegFile
// PARAMETERS:
//    hWnd, handle of parent window.
//    fSilentMode, TRUE if no messages should be displayed, else FALSE.
//    lpFileName, address of file name buffer.
//    lpRegistryFullKey,
//
LONG WINAPI RegExportRegFile(HWND hWnd,
                             BOOL fSilentMode,
                             BOOL fUseDownlevelFormat,
                             LPTSTR lpFileName,
                             LPTSTR lpRegistryFullKey)
{
    if (fUseDownlevelFormat)
    {
        g_fSaveInDownlevelFormat = TRUE;
        ExportWin40RegFile(lpFileName, lpRegistryFullKey);
    }
    else
    {
        ExportWinNT50RegFile(lpFileName, lpRegistryFullKey);
    }

    if (g_FileErrorStringID == IDS_EXPFILEERRFILEWRITE) 
    {
        InternalMessageBox(g_hInstance, 
                           hWnd, 
                           MAKEINTRESOURCE(g_FileErrorStringID),
                           MAKEINTRESOURCE(IDS_REGEDIT), 
                           MB_ICONERROR | MB_OK,
                           lpFileName);

    }

    if(g_FileErrorStringID == IDS_EXPFILEERRSUCCESS)
        return ERROR_SUCCESS;
    else
        return GetLastError();
}


#ifdef WINNT
//  RegDeleteKeyRecursive
//  DESCRIPTION:
//     Adapted from \\kernel\razzle3,mvdm\wow32\wshell.c,WOWRegDeleteKey().
//     The Windows 95 implementation of RegDeleteKey recursively deletes all
//     the subkeys of the specified registry branch, but the NT implementation
//     only deletes leaf keys.


LONG RegDeleteKeyRecursive(HKEY hKey,
                           LPCTSTR lpszSubKey)
/*++
Routine Description:

    There is a significant difference between the Win3.1 and Win32
    behavior of RegDeleteKey when the key in question has subkeys.
    The Win32 API does not allow you to delete a key with subkeys,
    while the Win3.1 API deletes a key and all its subkeys.

    This routine is a recursive worker that enumerates the subkeys
    of a given key, applies itself to each one, then deletes itself.

    It specifically does not attempt to deal rationally with the
    case where the caller may not have access to some of the subkeys
    of the key to be deleted.  In this case, all the subkeys which
    the caller can delete will be deleted, but the api will still
    return ERROR_ACCESS_DENIED.

Arguments:
    hKey - Supplies a handle to an open registry key.
    lpszSubKey - Supplies the name of a subkey which is to be deleted
                 along with all of its subkeys.
Return Value:
    ERROR_SUCCESS - entire subtree successfully deleted.
    ERROR_ACCESS_DENIED - given subkey could not be deleted.
--*/
{
    DWORD i;
    HKEY Key;
    LONG Status;
    DWORD ClassLength=0;
    DWORD SubKeys;
    DWORD MaxSubKey;
    DWORD MaxClass;
    DWORD Values;
    DWORD MaxValueName;
    DWORD MaxValueData;
    DWORD SecurityLength;
    FILETIME LastWriteTime;
    LPTSTR NameBuffer;

    //
    // First open the given key so we can enumerate its subkeys
    //
    Status = RegOpenKeyEx(hKey,
                          lpszSubKey,
                          0,
                          KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE,
                          &Key);
    if (Status != ERROR_SUCCESS) 
    {
        //
        // possibly we have delete access, but not enumerate/query.
        // So go ahead and try the delete call, but don't worry about
        // any subkeys.  If we have any, the delete will fail anyway.
        //
	    return(RegDeleteKey(hKey,lpszSubKey));
    }

    //
    // Use RegQueryInfoKey to determine how big to allocate the buffer
    // for the subkey names.
    //
    Status = RegQueryInfoKey(Key,
                             NULL,
                             &ClassLength,
                             0,
                             &SubKeys,
                             &MaxSubKey,
                             &MaxClass,
                             &Values,
                             &MaxValueName,
                             &MaxValueData,
                             &SecurityLength,
                             &LastWriteTime);
    if ((Status != ERROR_SUCCESS) &&
        (Status != ERROR_MORE_DATA) &&
        (Status != ERROR_INSUFFICIENT_BUFFER)) 
    {
        RegCloseKey(Key);
        return(Status);
    }

    NameBuffer = (LPTSTR) LocalAlloc(LPTR, (MaxSubKey + 1)*sizeof(TCHAR));
    if (NameBuffer == NULL) 
    {
        RegCloseKey(Key);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Enumerate subkeys and apply ourselves to each one.
    //
    i=0;
    do 
    {
        Status = RegEnumKey(Key,
                            i,
                            NameBuffer,
                            MaxSubKey+1);

        if (Status == ERROR_SUCCESS) 
        {
	        Status = RegDeleteKeyRecursive(Key,NameBuffer);
        }

        if (Status != ERROR_SUCCESS) 
        {
            //
            // Failed to delete the key at the specified index.  Increment
            // the index and keep going.  We could probably bail out here,
            // since the api is going to fail, but we might as well keep
            // going and delete everything we can.
            //
            ++i;
        }

    } while ( (Status != ERROR_NO_MORE_ITEMS) &&
              (i < SubKeys) );

    LocalFree((HLOCAL) NameBuffer);
    RegCloseKey(Key);
    return(RegDeleteKey(hKey,lpszSubKey));
}
#endif




//
// MessagePump
// DESCRIPTION:
//    Processes the next queued message, if any.
// PARAMETERS:
//    hDialogWnd, handle of modeless dialog.
//
BOOL PASCAL MessagePump(HWND hDialogWnd)
{
    MSG Msg;
    BOOL fGotMessage;

    if ((fGotMessage = PeekMessage(&Msg, NULL, 0, 0, PM_REMOVE)))
    {
        if (!IsDialogMessage(hDialogWnd, &Msg)) 
        {
            TranslateMessage(&Msg);
            DispatchMessage(&Msg);
        }

    }

    return fGotMessage;
}

// InternalMessageBox
int PASCAL InternalMessageBox(HINSTANCE hInst, 
                              HWND hWnd,
                              LPCTSTR pszFormat,
                              LPCTSTR pszTitle,
                              UINT fuStyle,
                              ...)
{
    TCHAR szTitle[80];
    TCHAR szFormat[512];
    LPTSTR pszMessage;
    BOOL fOk;
    int result;
    va_list ArgList;

    if (HIWORD(pszTitle))
    {
        // do nothing
    }
    else
    {
        // Allow this to be a resource ID
        LoadString(hInst, LOWORD(pszTitle), szTitle, ARRAYSIZE(szTitle));
        pszTitle = szTitle;
    }

    if (HIWORD(pszFormat))
    {
        // do nothing
    }
    else
    {
        // Allow this to be a resource ID
        LoadString(hInst, LOWORD(pszFormat), szFormat, ARRAYSIZE(szFormat));
        pszFormat = szFormat;
    }

    va_start(ArgList, fuStyle);
    fOk = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                        FORMAT_MESSAGE_FROM_STRING,
                        pszFormat, 
                        0,
                        0, 
                        (LPTSTR)&pszMessage,
                        0,
                        &ArgList);

    va_end(ArgList);

    if (fOk && pszMessage)
    {
        result = MessageBox(hWnd, 
                            pszMessage, 
                            pszTitle,
                            fuStyle | MB_SETFOREGROUND);
        LocalFree(pszMessage);
    }
    else
    {
        return -1;
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\reg\regeditp.h ===
//---------------------------------------------------------------------------
//
//  TITLE:       REGEDITP.H
//
//  AUTHOR:      Zeyong Xu
//
//  DATE:        March 1999
//
//---------------------------------------------------------------------------


#ifndef _INC_REGEDITP
#define _INC_REGEDITP


#define ARRAYSIZE(x)        (sizeof(x) / sizeof(x[0]))


#ifdef __cplusplus
extern "C" {
#endif


LONG WINAPI RegImportRegFile(HWND hWnd,
                             BOOL fSilentMode,
                             LPTSTR lpFileName);

LONG WINAPI RegExportRegFile(HWND hWnd,
                             BOOL fSilentMode,
                             BOOL fUseDownlevelFormat,
                             LPTSTR lpFileName,
                             LPTSTR lpRegistryFullKey);

#ifdef __cplusplus
}
#endif


BOOL PASCAL MessagePump(HWND hDialogWnd);

int  PASCAL InternalMessageBox(HINSTANCE hInst,
                               HWND hWnd,
                               LPCTSTR pszFormat,
                               LPCTSTR pszTitle,
                               UINT fuStyle,
                               ...);

// The Windows 95 and Windows NT implementations of RegDeleteKey differ in 
// how they handle subkeys of the specified key to delete.  Windows 95 will 
// delete them, but NT won't, so we hide the differences using this macro.
#ifdef WINNT
LONG RegDeleteKeyRecursive(HKEY hKey,
                           LPCTSTR lpszSubKey);
#else
#define RegDeleteKeyRecursive(hkey, lpsz)   RegDeleteKey(hkey, lpsz)
#endif


#endif // _INC_REGEDITP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\reg\regporte.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGPORTE.H
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        06 Apr 1994
*
*  File import and export engine routines for the Registry Editor.
*
*******************************************************************************/

#ifndef _INC_REGPORTE
#define _INC_REGPORTE

#ifndef LPHKEY
#define LPHKEY                          HKEY FAR*
#endif

typedef struct _REGISTRY_ROOT {
    LPTSTR lpKeyName;
    HKEY hKey;
}   REGISTRY_ROOT;

#define INDEX_HKEY_CLASSES_ROOT         0
#define INDEX_HKEY_CURRENT_USER         1
#define INDEX_HKEY_LOCAL_MACHINE        2
#define INDEX_HKEY_USERS                3
//  #define INDEX_HKEY_PERFORMANCE_DATA     4
#define INDEX_HKEY_CURRENT_CONFIG	    4
#define INDEX_HKEY_DYN_DATA		        5

//  #define NUMBER_REGISTRY_ROOTS		    7
#define NUMBER_REGISTRY_ROOTS		    6

//  BUGBUG:  This is supposed to be enough for one keyname plus one predefined
//  handle name.
#define SIZE_SELECTED_PATH              (MAXKEYNAME + 40)

extern const TCHAR g_HexConversion[];

extern UINT g_FileErrorStringID;

#define ERK_OPEN    0
#define ERK_CREATE  1
#define ERK_DELETE  2


DWORD
PASCAL
EditRegistryKey(
    LPHKEY lphKey,
    LPTSTR lpFullKeyName,
    UINT uOperation
    );

VOID
PASCAL
ImportRegFileWorker(
    LPTSTR lpFileName
    );

VOID
PASCAL
ExportWinNT50RegFile(
    LPTSTR lpFileName,
    LPTSTR lpSelectedPath
    );

VOID
PASCAL
ExportWin40RegFile(
    LPTSTR lpFileName,
    LPTSTR lpSelectedPath
    );

VOID
PASCAL
ImportRegFileUICallback(
    UINT Percentage
    );

#endif // _INC_REGPORTE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\reg\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by reg.rc
//
#define IDS_COPYRIGHT                   1
#define IDS_USAGE_REG                   2
#define IDS_USAGE_QUERY                 3
#define IDS_USAGE_ADD1                  4
#define IDS_USAGE_ADD2                  5
#define IDS_USAGE_DELETE                6
#define IDS_USAGE_COPY                  7
#define IDS_USAGE_SAVE                  8
#define IDS_USAGE_RESTORE               9
#define IDS_USAGE_LOAD                  10
#define IDS_USAGE_UNLOAD                11
#define IDS_USAGE_COMPARE1              12
#define IDS_USAGE_COMPARE2              13
#define IDS_USAGE_EXPORT                14
#define IDS_USAGE_IMPORT                15
#define IDS_REGEDIT                     16
#define IDS_SUCCESS                     39
#define IDS_ERROR_BADOPERATION          40
#define IDS_ERROR_TOMANYPARAMS          41
#define IDS_ERROR_TOFEWPARAMS           42
#define IDS_ERROR_INVALIDPARAMS         43
#define IDS_ERROR_NONREMOTABLEROOT      44
#define IDS_ERROR_NONLOADABLEROOT       45
#define IDS_ERROR_COPYTOSELF            46
#define IDS_ERROR_COMPARESELF           47
#define IDS_ERROR_BADKEYNAME            48
#define IDS_ERROR_BADFILEFORMAT         49
#define IDS_ERROR_NONREMOTABLE          50
#define IDS_ERROR_PATHNOTFOUND          51
#define IDS_IMPFILEERRSUCCESS           128
#define IDS_IMPFILEERRFILEOPEN          129
#define IDS_IMPFILEERRFILEREAD          130
#define IDS_IMPFILEERRREGOPEN           131
#define IDS_IMPFILEERRREGSET            132
#define IDS_IMPFILEERRFORMATBAD         133
#define IDS_IMPFILEERRVERBAD            134
#define IDS_EXPFILEERRSUCCESS           136
#define IDS_EXPFILEERRBADREGPATH        137
#define IDS_EXPFILEERRFILEOPEN          138
#define IDS_EXPFILEERRREGOPEN           139
#define IDS_EXPFILEERRREGENUM           140
#define IDS_EXPFILEERRFILEWRITE         141
#define IDS_REG_BANNER                  142
#define IDS_OVERWRITE                   143
#define IDS_NONAME                      144

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\reg\save.c ===
//-----------------------------------------------------------------------//
//
// File:    save.cpp
// Created: March 1997
// By:      Martin Holladay (a-martih)
// Purpose: Registry Save Support for REG.CPP
// Modification History:
//      Copied from Copy.cpp and modificd - May 1997 (a-martih)
//      Aug 1997 - MartinHo
//          Fixed bug which didn't allow you to specify a ROOT key.
//          Example REG SAVE HKLM\Software didn't work - but should have
//      April 1999 Zeyong Xu: re-design, revision -> version 2.0
//
//------------------------------------------------------------------------//

#include "stdafx.h"
#include "reg.h"


//-----------------------------------------------------------------------//
//
// SaveHive()
//
//-----------------------------------------------------------------------//

LONG SaveHive(PAPPVARS pAppVars, UINT argc, TCHAR *argv[])
{
    LONG        nResult;
    HKEY        hKey;

    //
    // Parse the cmd-line
    //
    nResult = ParseSaveCmdLine(pAppVars, argc, argv);
    if (nResult != ERROR_SUCCESS)
    {
        return nResult;
    }

#ifndef REG_FOR_WIN2000  // ANSI version for Win98
    // because RegLoadKey() failed on remote Win98,
    // works local only on Win98, cancel SAVE for remote
    if(pAppVars->bUseRemoteMachine)
        return REG_STATUS_NONREMOTABLE;
#endif

    //
    // Connect to the Remote Machine - if applicable
    //
    nResult = RegConnectMachine(pAppVars);
    if (nResult != ERROR_SUCCESS)
    {
        return nResult;
    }

    //
    // Open the key
    //
    if ((nResult = RegOpenKeyEx(pAppVars->hRootKey,
                                pAppVars->szSubKey,
                                0,
                                KEY_READ,
                                &hKey)) == ERROR_SUCCESS)
    {
        //
        // Acquire the necessary privilages and call the API
        //
        nResult = RegAdjustTokenPrivileges(pAppVars->szMachineName,
                                           SE_BACKUP_NAME,
                                           SE_PRIVILEGE_ENABLED);
        if (nResult == ERROR_SUCCESS)
        {
            nResult = RegSaveKey(hKey, pAppVars->szValueName, NULL);
        }

        RegCloseKey(hKey);
    }

#ifndef REG_FOR_WIN2000
    // since the newly created file has the hidden attibute on win98,
    // remove this hidden attribute (work for local machine only)
    if (nResult == ERROR_SUCCESS)
        SetFileAttributes(pAppVars->szValueName, FILE_ATTRIBUTE_ARCHIVE);
#endif

    return nResult;
}


//-----------------------------------------------------------------------//
//
// RestoreHive()
//
//-----------------------------------------------------------------------//

LONG RestoreHive(PAPPVARS pAppVars, UINT argc, TCHAR *argv[])
{
    LONG        nResult;
    HKEY        hKey;

    //
    // Parse the cmd-line
    //
    nResult = ParseSaveCmdLine(pAppVars, argc, argv);
    if (nResult != ERROR_SUCCESS)
    {
        return nResult;
    }

#ifndef REG_FOR_WIN2000  // ANSI version for Win98
    // because RegLoadKey() failed on remote Win98,
    // works local only on Win98
    if(pAppVars->bUseRemoteMachine)
        return REG_STATUS_NONREMOTABLE;
#endif

    //
    // Connect to the Remote Machine(s) - if applicable
    //
    nResult = RegConnectMachine(pAppVars);
    if (nResult != ERROR_SUCCESS)
    {
        return nResult;
    }

    //
    // Open the Key
    //
    if ((nResult = RegOpenKeyEx(pAppVars->hRootKey,
                                pAppVars->szSubKey,
                                0,
                                KEY_ALL_ACCESS,
                                &hKey))  == ERROR_SUCCESS)
    {

#ifdef REG_FOR_WIN2000  // works on Win2000(unicode) only, not Win98(ansi)

        // Acquire the necessary privilages and call the API
        nResult = RegAdjustTokenPrivileges(pAppVars->szMachineName,
                                           SE_RESTORE_NAME,
                                           SE_PRIVILEGE_ENABLED);
        if (nResult == ERROR_SUCCESS)
        {
            nResult = RegRestoreKey(hKey, pAppVars->szValueName, 0);
        }
        RegCloseKey(hKey);

#else  // works on Win98(ansi) only, not Win2000(unicode)

        RegCloseKey(hKey);
        nResult = RegRestoreKeyWin98(pAppVars->hRootKey,
                                     pAppVars->szSubKey,
                                     pAppVars->szValueName);

#endif

    }

    return nResult;
}


//-----------------------------------------------------------------------//
//
// LoadHive()
//
//-----------------------------------------------------------------------//

LONG LoadHive(PAPPVARS pAppVars, UINT argc, TCHAR *argv[])
{
    LONG        nResult;

    //
    // Parse the cmd-line
    //
    nResult = ParseSaveCmdLine(pAppVars, argc, argv);
    if (nResult != ERROR_SUCCESS)
    {
        return nResult;
    }

#ifndef REG_FOR_WIN2000  // ANSI version for Win98
    // because RegLoadKey() failed on remote Win98,
    // works local only on Win98
    if(pAppVars->bUseRemoteMachine)
        return REG_STATUS_NONREMOTABLE;
#endif

    //
    // Connect to the Remote Machine(s) - if applicable
    //
    nResult = RegConnectMachine(pAppVars);
    if (nResult != ERROR_SUCCESS)
    {
        return nResult;
    }

    //
    // Acquire the necessary privilages and call the API
    //
    nResult = RegAdjustTokenPrivileges(pAppVars->szMachineName,
                                       SE_RESTORE_NAME,
                                       SE_PRIVILEGE_ENABLED);
    if (nResult == ERROR_SUCCESS)
    {
        nResult = RegLoadKey(pAppVars->hRootKey,
                             pAppVars->szSubKey,
                             pAppVars->szValueName);
    }

    return nResult;
}


//-----------------------------------------------------------------------//
//
// UnLoadHive()
//
//-----------------------------------------------------------------------//

LONG UnLoadHive(PAPPVARS pAppVars, UINT argc, TCHAR *argv[])
{
    LONG        nResult;

    //
    // Parse the cmd-line
    //
    nResult = ParseUnLoadCmdLine(pAppVars, argc, argv);
    if (nResult != ERROR_SUCCESS)
    {
        return nResult;
    }

#ifndef REG_FOR_WIN2000  // ANSI version for Win98
    // because RegUnLoadKey() failed on remote Win98,
    // works local only on Win98
    if(pAppVars->bUseRemoteMachine)
        return REG_STATUS_NONREMOTABLE;
#endif

    //
    // Connect to the Remote Machine(s) - if applicable
    //
    nResult = RegConnectMachine(pAppVars);
    if (nResult != ERROR_SUCCESS)
    {
        return nResult;
    }

    //
    // Acquire the necessary privilages and call the API
    //
    nResult = RegAdjustTokenPrivileges(pAppVars->szMachineName,
                                       SE_RESTORE_NAME,
                                       SE_PRIVILEGE_ENABLED);
    if (nResult == ERROR_SUCCESS)
    {
        nResult = RegUnLoadKey(pAppVars->hRootKey, pAppVars->szSubKey);
    }

    return nResult;
}



//------------------------------------------------------------------------//
//
// ParseSaveCmdLine()
//
//------------------------------------------------------------------------//

REG_STATUS ParseSaveCmdLine(PAPPVARS pAppVars, UINT argc, TCHAR *argv[])
{
    REG_STATUS nResult = ERROR_SUCCESS;

    //
    // Do we have a *valid* number of cmd-line params
    //
    if (argc < 4)
    {
        return REG_STATUS_TOFEWPARAMS;
    }
    else if (argc > 4)
    {
        return REG_STATUS_TOMANYPARAMS;
    }

    // Machine Name and Registry key
    //
    nResult = BreakDownKeyString(argv[2], pAppVars);
    if(nResult != ERROR_SUCCESS)
        return nResult;

    //
    // Get the FileName - using the szValueName string field to hold it
    //
    pAppVars->szValueName = (TCHAR*) calloc(_tcslen(argv[3]) + 1,
                                            sizeof(TCHAR));
    if (!pAppVars->szValueName) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    _tcscpy(pAppVars->szValueName, argv[3]);

    return nResult;
}

//------------------------------------------------------------------------//
//
// ParseUnLoadCmdLine()
//
//------------------------------------------------------------------------//

REG_STATUS ParseUnLoadCmdLine(PAPPVARS pAppVars, UINT argc, TCHAR *argv[])
{
    REG_STATUS nResult = ERROR_SUCCESS;

    //
    // Do we have a *valid* number of cmd-line params
    //
    if (argc < 3)
    {
        return REG_STATUS_TOFEWPARAMS;
    }
    else if (argc > 3)
    {
        return REG_STATUS_TOMANYPARAMS;
    }

    // Machine Name and Registry key
    //
    nResult = BreakDownKeyString(argv[2], pAppVars);

    return nResult;
}


//------------------------------------------------------------------------//
//
// AdjustTokenPrivileges()
//
//------------------------------------------------------------------------//

LONG RegAdjustTokenPrivileges(TCHAR *szMachine,
                              TCHAR *szPrivilege,
                              LONG nAttribute)
{
    // works on Win2000(unicode) only, not Win98(ansi)
#ifdef REG_FOR_WIN2000

    HANDLE              hToken;
    TOKEN_PRIVILEGES    tkp;

    if(!OpenProcessToken(GetCurrentProcess(),
                         TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                         &hToken))
    {
        return GetLastError();
    }

    if(!LookupPrivilegeValue(szMachine,
                             szPrivilege,
                             &tkp.Privileges[0].Luid))
    {
        return GetLastError();
    }

    tkp.PrivilegeCount = 1;
    tkp.Privileges[0].Attributes = nAttribute;

    if(!AdjustTokenPrivileges(hToken,
                              FALSE,
                              &tkp,
                              0,
                              (PTOKEN_PRIVILEGES) NULL,
                              NULL))
    {
        return GetLastError();
    }

#endif

    return ERROR_SUCCESS;
}

//-----------------------------------------------------------------------//
// RegRestoreKeyWin98() for Win98 only (ANSI version)
// because RegRestoreKey() does not work on Win98
//-----------------------------------------------------------------------//
LONG RegRestoreKeyWin98(HKEY hRootKey,        // handle to a root key
                        TCHAR* szSubKey, // name of subkey
                        TCHAR* szFile)   // hive filename
{
    LONG        nResult;
    HKEY        hKey;
    HKEY        hTempKey;
    TCHAR       szTempHive[50];
    LONG        nRetUnload;


    // avoid key name conflict, reduce failed possibility
    _tcscpy(szTempHive, _T("TEMP_HIVE_FOR_RESTORE_0000"));
    if(_tcsicmp(szSubKey, szTempHive) == 0)
        _tcscpy(szTempHive, _T("TEMP_HIVE_FOR_RESTORE_1111"));
    nResult = RegOpenKeyEx(hRootKey,
                           szTempHive,
                           0,
                           KEY_READ,
                           &hTempKey);
    if(nResult == ERROR_SUCCESS)
    {
        RegCloseKey(hTempKey);
        _tcscpy(szTempHive, _T("TEMP_HIVE_FOR_RESTORE_RETRY_0000"));
    }

    // load hive file to szTempHive key
    nResult = RegLoadKey(hRootKey,
                         szTempHive,
                         szFile);
    if(nResult != ERROR_SUCCESS)
        return nResult;

    nResult = RecursiveDeleteKey(hRootKey,
                                 szSubKey);

    if(nResult == ERROR_SUCCESS)
    {
        // Create the Key
        nResult = RegCreateKeyEx(hRootKey,
                                szSubKey,
                                0,
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                KEY_ALL_ACCESS,
                                NULL,
                                &hKey,
                                NULL);

        if(nResult == ERROR_SUCCESS)
        {
            // Now open TempHive key
            nResult = RegOpenKeyEx(hRootKey,
                                   szTempHive,
                                   0,
                                   KEY_READ,
                                   &hTempKey);

            if (nResult == ERROR_SUCCESS)
            {
                // Recursively copy the entire hive
                BOOL bOverWriteAll = TRUE;
                nResult = CopyEnumerateKey(hTempKey,
                                           szTempHive,
                                           hKey,
                                           szSubKey,
                                           &bOverWriteAll,
                                           TRUE);
                RegCloseKey(hTempKey);
            }

            RegCloseKey(hKey);
        }
    }

    // unload the temphive key
    nRetUnload = RegUnLoadKey(hRootKey, szTempHive);
    if(nResult == ERROR_SUCCESS)
        nResult = nRetUnload;

    return nResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\reg\regporte.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGPORTE.C
*
*  VERSION:     5.00
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        06 Apr 1994
*
*  Histry:      Zeyong Xu modified it in March 1999
*
*  .REG format file import and export engine routines for the Registry Editor.
*
*******************************************************************************/

#include "stdafx.h"
#include "regeditp.h"
#include "reg1632.h"
#include "regdef.h"
#include "regdebug.h"
#include "regporte.h"

extern BOOL  g_fSaveInDownlevelFormat;
TCHAR  g_ValueNameBuffer[MAXVALUENAME_LENGTH];
BYTE   g_ValueDataBuffer[MAXDATA_LENGTH * sizeof(TCHAR)];


//  Association between the ASCII name and the handle of the registry key.
const REGISTRY_ROOT g_RegistryRoots[] = {
    TEXT("HKEY_CLASSES_ROOT"), HKEY_CLASSES_ROOT,
    TEXT("HKEY_CURRENT_USER"), HKEY_CURRENT_USER,
    TEXT("HKEY_LOCAL_MACHINE"), HKEY_LOCAL_MACHINE,
    TEXT("HKEY_USERS"), HKEY_USERS,
    TEXT("HKEY_CURRENT_CONFIG"), HKEY_CURRENT_CONFIG,
    TEXT("HKEY_DYN_DATA"), HKEY_DYN_DATA
};

const TCHAR s_RegistryHeader[] = TEXT("REGEDIT");

const TCHAR s_OldWin31RegFileRoot[] = TEXT(".classes");

const TCHAR s_Win40RegFileHeader[] = TEXT("REGEDIT4\n\n");

//
// New header is required for version 5.0 because the version detection code
// in Win 4.0 regedit was not quite correct (See comments in ImportRegFile for
// details)
//
const WORD s_UnicodeByteOrderMark = 0xFEFF;
const TCHAR s_WinNT50RegFileHeader[] = TEXT("Windows Registry Editor Version");
const TCHAR s_WinNT50RegFileVersion[] = TEXT("5.00");

const TCHAR s_HexPrefix[] = TEXT("hex");
const TCHAR s_DwordPrefix[] = TEXT("dword:");
const TCHAR g_HexConversion[16] = {TEXT('0'), TEXT('1'), TEXT('2'), TEXT('3'), TEXT('4'),
                                   TEXT('5'), TEXT('6'), TEXT('7'), TEXT('8'), TEXT('9'),
                                   TEXT('a'), TEXT('b'), TEXT('c'), TEXT('d'), TEXT('e'), TEXT('f')};
const TCHAR s_FileLineBreak[] = TEXT(",\\\n  ");

#define SIZE_FILE_IO_BUFFER             512

typedef struct _FILE_IO {
    //
    // Space for unicode/ansi conversions, assumes worst case
    // where every unicode char is a double-byte char
    //
    CHAR ConversionBuffer[(SIZE_FILE_IO_BUFFER + 1)*sizeof(TCHAR)];

    TCHAR Buffer[SIZE_FILE_IO_BUFFER + 1];
    FILE_HANDLE hFile;
    int BufferOffset;
    int CurrentColumn;
    int CharsAvailable;
    DWORD FileSizeDiv100;
    DWORD FileOffset;
    UINT LastPercentage;
#ifdef DEBUG
    BOOL fValidateUngetChar;
#endif
}   FILE_IO;

FILE_IO s_FileIo;

UINT g_FileErrorStringID;

UINT g_ImportFileVersion;

BOOL s_fTreatFileAsUnicode = TRUE;

VOID
NEAR PASCAL
ImportWin31RegFile(
    VOID
    );

VOID
NEAR PASCAL
ImportNewerRegFile(
    VOID
    );

VOID
NEAR PASCAL
ParseHeader(
    LPHKEY lphKey
    );

VOID
NEAR PASCAL
ParseValuename(
    HKEY hKey
    );

VOID
NEAR PASCAL
ParseDefaultValue(
    HKEY hKey
    );

BOOL
NEAR PASCAL
ParseString(
    LPTSTR lpString,
    LPDWORD cbStringData
    );

BOOL
NEAR PASCAL
ParseHexSequence(
    LPBYTE lpHexData,
    LPDWORD lpcbHexData
    );

BOOL
NEAR PASCAL
ParseHexDword(
    LPDWORD lpDword
    );

BOOL
NEAR PASCAL
ParseHexByte(
    LPBYTE lpByte
    );

BOOL
NEAR PASCAL
ParseHexDigit(
    LPBYTE lpDigit
    );

BOOL
NEAR PASCAL
ParseEndOfLine(
    VOID
    );

VOID
NEAR PASCAL
SkipWhitespace(
    VOID
    );

VOID
NEAR PASCAL
SkipPastEndOfLine(
    VOID
    );

BOOL
NEAR PASCAL
GetChar(
    PTCHAR lpChar
    );

VOID
NEAR PASCAL
UngetChar(
    VOID
    );

BOOL
NEAR PASCAL
MatchChar(
    TCHAR CharToMatch
    );

BOOL
NEAR PASCAL
IsWhitespace(
    TCHAR Char
    );

BOOL
NEAR PASCAL
IsNewLine(
    TCHAR Char
    );

VOID
NEAR PASCAL
PutBranch(
    HKEY hKey,
    LPTSTR lpKeyName
    );

VOID
NEAR PASCAL
PutLiteral(
    LPCTSTR lpString
    );

VOID
NEAR PASCAL
PutString(
    LPCTSTR lpString
    );

VOID
NEAR PASCAL
PutBinary(
    CONST BYTE FAR* lpBuffer,
    DWORD Type,
    DWORD cbBytes
    );

VOID
NEAR PASCAL
PutDword(
    DWORD Dword,
    BOOL fLeadingZeroes
    );

VOID
NEAR PASCAL
PutChar(
    TCHAR Char
    );

VOID
NEAR PASCAL
FlushIoBuffer(
    VOID
    );

/*******************************************************************************
*
*  EditRegistryKey
*
*  DESCRIPTION:
*     Parses the pFullKeyName string and creates a handle to the registry key.
*
*  PARAMETERS:
*     lphKey, location to store handle to registry key.
*     lpFullKeyName, string of form "HKEY_LOCAL_MACHINE\Subkey1\Subkey2".
*     fCreate, TRUE if key should be created, else FALSE for open only.
*     (returns), ERROR_SUCCESS, no errors occurred, phKey is valid,
*                ERROR_CANTOPEN, registry access error of some form,
*                ERROR_BADKEY, incorrectly formed pFullKeyName.
*
*******************************************************************************/

DWORD
PASCAL
EditRegistryKey(
    LPHKEY lphKey,
    LPTSTR lpFullKeyName,
    UINT uOperation
    )
{

    LPTSTR lpSubKeyName;
    TCHAR PrevChar;
    HKEY hRootKey;
    UINT Counter;
    DWORD Result;

    if ((lpSubKeyName = (LPTSTR) STRCHR(lpFullKeyName, TEXT('\\'))) != NULL) {

        PrevChar = *lpSubKeyName;
        *lpSubKeyName++ = 0;

    }

    CHARUPPERSTRING(lpFullKeyName);

    hRootKey = NULL;

    for (Counter = 0; Counter < NUMBER_REGISTRY_ROOTS; Counter++) {

        if (STRCMP(g_RegistryRoots[Counter].lpKeyName, lpFullKeyName) == 0) {

            hRootKey = g_RegistryRoots[Counter].hKey;
            break;

        }

    }

    if (hRootKey) {

        Result = ERROR_CANTOPEN;

        switch (uOperation) {
        case ERK_CREATE:
            if (RegCreateKey(hRootKey, lpSubKeyName, lphKey) == ERROR_SUCCESS)
                Result = ERROR_SUCCESS;
            break;
        case ERK_OPEN:
            //
            // Used when exporting.
            //
            if(RegOpenKeyEx(hRootKey,lpSubKeyName,0,KEY_ENUMERATE_SUB_KEYS|KEY_QUERY_VALUE,lphKey) == ERROR_SUCCESS)
                Result = ERROR_SUCCESS;
            break;
        case ERK_DELETE:
            RegDeleteKeyRecursive(hRootKey, lpSubKeyName);
            // asssume success... don't care if this fails
            Result = ERROR_SUCCESS;
            *lphKey = NULL;
            break;
        }

    }

    else
        Result = ERROR_BADKEY;

    if (lpSubKeyName != NULL) {

        lpSubKeyName--;
        *lpSubKeyName = PrevChar;

    }

    return Result;

}

/*******************************************************************************
*
*  ImportRegFileWorker
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     lpFileName, address of name of file to be imported.
*
*******************************************************************************/

VOID
PASCAL
ImportRegFileWorker(
    LPTSTR lpFileName
    )
{

    TCHAR Char;
    LPCTSTR lpHeader;
    BOOL fNewRegistryFile;
#ifdef UNICODE
    UINT Temp, i;
    TCHAR StrToIntBuf[2];
    LPCTSTR lp50Header;
#endif // UNICODE
    DWORD cch;
    TCHAR tchBuffer[MAX_PATH] = {0};
    LPTSTR lpFilePart;

    g_FileErrorStringID = IDS_IMPFILEERRSUCCESS;

    // OPENREADFILE used to be OpenFile(), but there isn't any Unicode version
    // of that API, so now it's CreateFile().  But OpenFile searched the path
    // automatically, whereas CreateFile does not.  Corel's 'Perfect Office v6'
    // install app depends on the path being searched, so do it manually.

    cch = SearchPath(NULL,                // pointer to search path
                     lpFileName,          // pointer to filename
                     NULL,                // pointer to extension
                     ARRAYSIZE(tchBuffer), // size, in characters, of buffer
                     (TCHAR*)tchBuffer,   // pointer to buffer for found filename
                     &lpFilePart);        // pointer to pointer to file component);

    if ((cch != 0) && (cch <= MAX_PATH) && OPENREADFILE((TCHAR*)tchBuffer, s_FileIo.hFile)) {

        WORD wBOM;
        DWORD NumberOfBytesRead;

        s_FileIo.FileSizeDiv100 = GETFILESIZE(s_FileIo.hFile) / 100;
        s_FileIo.FileOffset = 0;
        s_FileIo.LastPercentage = 0;

        //
        // Read the first two bytes. If it's the Unicode byte order mark,
        // set a flag so all the rest of the file will be interpreted
        // as ANSI or Unicode text properly.
        //
        if (!READFILE(s_FileIo.hFile, &wBOM,
            sizeof(wBOM), &NumberOfBytesRead)) {

            g_FileErrorStringID = IDS_IMPFILEERRFILEREAD;
            goto exit_gracefully;
        }

        if (wBOM == s_UnicodeByteOrderMark)
            s_fTreatFileAsUnicode = TRUE;
        else {
            s_fTreatFileAsUnicode = FALSE;
            // We probably just read "RE" from "REGEDIT4".  Back up the file
            // position so the ANSI import routines get what they expect
            SetFilePointer(s_FileIo.hFile, -2, NULL, FILE_CURRENT);
        }

        //
        //  The following will force GetChar to read in the first block of data.
        //

        // Unfortunately, in the Unicode version, it's not so clean.
        // SIZE_FILE_IO_BUFFER is in bytes, but s_FileIo.BufferOffset is in chars,
        // so we divide according to whether we're reading ANSI or Unicode.

        s_FileIo.BufferOffset = SIZE_FILE_IO_BUFFER / (s_fTreatFileAsUnicode ? sizeof(WCHAR) : 1);

        SkipWhitespace();

        lpHeader = s_RegistryHeader;
        g_ImportFileVersion = 0;

# if 0
    Sit back, and I will tell ye a tale of woe.

    Win95 and NT 4 shipped with regedit compiled ANSI.  There are a couple
    of registry types on NT (namely REG_EXPAND_SZ and REG_MULTI_SZ) that
    weren't on Win95, and which regedit doesn't really understand.  regedit
    treats these registry types as hex binary streams.

    You can probably see where this is going.

    If you exported, say your user TEMP environment variable on NT 4
    using regedit, you'd get something that looked like this:

REGEDIT4

[HKEY_CURRENT_USER\Environment]
"TEMP"=hex(2):25,53,59,53,54,45,4d,44,52,49,56,45,25,5c,53,48,54,65,6d,70,00

    ...a nice, null-terminated ANSI string.  Nice, that is, until we decided
    to compile regedit UNICODE for NT 5.  A unicode regedit exports your
    user TEMP variable like this:

REGEDIT4

[HKEY_CURRENT_USER\Environment]
"TEMP"=hex(2):25,00,53,00,59,00,53,00,54,00,45,00,4d,00,44,00,52,00,49,00,56,\
  00,45,00,25,00,5c,00,53,00,48,00,54,00,65,00,6d,00,70,00,00,00

    ...mmmm.  Unicode.  Of course, a unicode regedit also expects anything
    it imports to have all those interspersed zeroes, too.  Otherwise,
    it dumps garbage into your registry.  All it takes is a -DUNICODE, and
    regedit is suddenly incompatible with the thousdands of existing .reg
    files out there.

    So just bump the version in the header to REGEDIT5 and be done with
    it, right?  Wrong.  The regedit on Win95 and NT 4 looks at the first
    character after the string "REGEDIT" and compares it to the digit "4".
    If that character is anything other than the digit "4", the parser
    assumes it is looking at a Windows 3.1 file.  Yep.  There will only
    ever be two formats, right?  Just Win95 and Win3.1.  That's all the
    world needs.

    So a completely new .reg file header had to be invented, so that the
    older, brain damaged regedits of the world would simply regect the new,
    unicodized .reg files outright.  An NT 5 .reg file, exporting your user
    TEMP variable, looks like this:

Windows Registry Editor Version 5.00

[HKEY_CURRENT_USER\Environment]
"TEMP"=hex(2):25,00,53,00,59,00,53,00,54,00,45,00,4d,00,44,00,52,00,49,00,56,\
  00,45,00,25,00,5c,00,53,00,48,00,54,00,65,00,6d,00,70,00,00,00

    The parser is still brain-dead, but it does bother to convert that 5.00
    into a version number, so that future generations can bump it to 5.50 or
    6.00, and the regedit 5.00 that shipped with NT 5.00 will properly reject
    the files.
#endif // 0

#ifdef UNICODE
        //
        // Compare to the new .reg file header
        //
        lp50Header = s_WinNT50RegFileHeader;
        while (*lp50Header != 0) {

            if (MatchChar(*lp50Header))
                lp50Header = CharNext(lp50Header);

            else
                break;

        }

        //
        // If the above loop pushed lp50Header to its terminating null
        // character, then the header matches.
        //
        if (0 == *lp50Header) {

            SkipWhitespace();
            //
            // Now, decode the version number into a hex, _WIN32_WINNT
            // style version number.
            //
            StrToIntBuf[1] = 0;

            //
            // Any number of digits can come before the decimal point
            //
            while (!MatchChar(TEXT('.'))) {
                if (!GetChar(StrToIntBuf) || !IsCharAlphaNumeric(*StrToIntBuf)) {
                    g_FileErrorStringID = IDS_IMPFILEERRFORMATBAD;
                    goto exit_gracefully;
                }

//                Temp = StrToInt(StrToIntBuf);
                Temp = _tcstoul(StrToIntBuf, NULL, 10);
                // Hex version number, so move left four bits.
                g_ImportFileVersion <<= 4;
                g_ImportFileVersion += Temp;
            }

            //
            // Fixed at two digits after the decimal point
            //
            for (i = 0; i < 2; i++) {
                if (!GetChar(StrToIntBuf) || !IsCharAlphaNumeric(*StrToIntBuf)) {
                    g_FileErrorStringID = IDS_IMPFILEERRFORMATBAD;
                    goto exit_gracefully;
                }

//                Temp = StrToInt(StrToIntBuf);
                Temp = _tcstoul(StrToIntBuf, NULL, 10);
                // Hex version number, so move left four bits.
                g_ImportFileVersion <<= 4;
                g_ImportFileVersion += Temp;
            }

            //
            // For NT 5, reject any version number that isn't
            // 5.  This can be expanded into a switch statement
            // when the version number is bumped later.
            //
            if (0x0500 != g_ImportFileVersion) {
                g_FileErrorStringID = IDS_IMPFILEERRVERBAD;
                goto exit_gracefully;
            }
            else {
                SkipWhitespace();
                ImportNewerRegFile();
            }

        } // if (0 == *lp50Header)
        //
        // It doesn't use the new .reg file header, so
        // it's not an NT 5.0+ registry file, so use the brain dead
        // older algorithm to see if it's a valid older registry file
        //
        else {
#endif // UNICODE

            while (*lpHeader != 0) {

                if (MatchChar(*lpHeader))
                    lpHeader = CharNext(lpHeader);

                else
                    break;

            }

            if (*lpHeader == 0) {

                //
                // Win95's and NT 4's regedit shipped with this line
                // of code.  It is the cause of all of the suffering above.
                // Notice the incorrect assumption:  "If the very next
                // character isn't a '4', then we must be reading
                // a Windows 3.1 registry file!"  Of course there won't
                // be a version 5 of regedit.  Version 4 was perfect!
                //
                fNewRegistryFile = MatchChar(TEXT('4'));

                SkipWhitespace();

                if (GetChar(&Char) && IsNewLine(Char)) {

                    if (fNewRegistryFile) {
                        g_ImportFileVersion = 0x0400;
                        ImportNewerRegFile();
                    }
                    else {
                        g_ImportFileVersion = 0x0310;
                        ImportWin31RegFile();
                    }

                }

            } // if (*lpHeader == 0)

            else
                g_FileErrorStringID = IDS_IMPFILEERRFORMATBAD;
#ifdef UNICODE
        }
#endif // UNICODE

    } // if (OPENREADFILE...

    else {
        { TCHAR buff[250];
          wsprintf(buff, TEXT("REGEDIT:  CreateFile failed, GetLastError() = %d\n"), GetLastError());
        OutputDebugString(buff);
        }
        s_FileIo.hFile = NULL;
        g_FileErrorStringID = IDS_IMPFILEERRFILEOPEN;
    }

exit_gracefully:

    if (s_FileIo.hFile) {
        CLOSEFILE(s_FileIo.hFile);
    }

}

/*******************************************************************************
*
*  ImportWin31RegFile
*
*  DESCRIPTION:
*     Imports the contents of a Windows 3.1 style registry file into the
*     registry.
*
*     We scan over the file looking for lines of the following type:
*        HKEY_CLASSES_ROOT\keyname = value_data
*        HKEY_CLASSES_ROOT\keyname =value_data
*        HKEY_CLASSES_ROOT\keyname value_data
*        HKEY_CLASSES_ROOT\keyname                          (null value data)
*
*     In all cases, any number of spaces may follow 'keyname'.  Although we
*     only document the first syntax, the Windows 3.1 Regedit handled all of
*     these formats as valid, so this version will as well (fortunately, it
*     doesn't make the parsing any more complex!).
*
*     Note, we also support replacing HKEY_CLASSES_ROOT with \.classes above
*     which must come from some early releases of Windows.
*
*  PARAMETERS:
*     (none).
*
*******************************************************************************/

VOID
NEAR PASCAL
ImportWin31RegFile(
    VOID
    )
{

    HKEY hKey;
    TCHAR Char;
    BOOL fSuccess;
    LPCTSTR lpClassesRoot;
    TCHAR KeyName[MAXKEYNAME];
    UINT Index;

    //
    //  Keep an open handle to the classes root.  We may prevent some
    //  unneccessary flushing.
    //
    if(RegOpenKeyEx(HKEY_CLASSES_ROOT,NULL,0,KEY_SET_VALUE,&hKey) != ERROR_SUCCESS) {

        g_FileErrorStringID = IDS_IMPFILEERRREGOPEN;
        return;

    }

    while (TRUE) {

        //
        //  Check for the end of file condition.
        //

        if (!GetChar(&Char))
            break;

        UngetChar();                    //  Not efficient, but works for now.

        //
        //  Match the beginning of the line against one of the two aliases for
        //  HKEY_CLASSES_ROOT.
        //

        if (MatchChar(TEXT('\\')))
            lpClassesRoot = s_OldWin31RegFileRoot;

        else
            lpClassesRoot = g_RegistryRoots[INDEX_HKEY_CLASSES_ROOT].lpKeyName;

        fSuccess = TRUE;

        while (*lpClassesRoot != 0) {

            if (!MatchChar(*lpClassesRoot++)) {

                fSuccess = FALSE;
                break;

            }

        }

        //
        //  Make sure that we have a backslash seperating one of the aliases
        //  from the keyname.
        //

        if (fSuccess)
            fSuccess = MatchChar(TEXT('\\'));

        if (fSuccess) {

            //
            //  We've found one of the valid aliases, so read in the keyname.
            //

            //  fSuccess = TRUE;        //  Must be TRUE if we're in this block
            Index = 0;

            while (GetChar(&Char)) {

                if (Char == TEXT(' ') || IsNewLine(Char))
                    break;

                //
                //  Make sure that the keyname buffer doesn't overflow.  We must
                //  leave room for a terminating null.
                //

                if (Index >= (sizeof(KeyName)/sizeof(TCHAR)) - 1) {

                    fSuccess = FALSE;
                    break;

                }

                KeyName[Index++] = Char;

            }

            if (fSuccess) {

                KeyName[Index] = 0;

                //
                //  Now see if we have a value to assign to this keyname.
                //

                SkipWhitespace();

                if (MatchChar(TEXT('=')))
                    MatchChar(TEXT(' '));

                //  fSuccess = TRUE;    //  Must be TRUE if we're in this block
                Index = 0;

                while (GetChar(&Char)) {

                    if (IsNewLine(Char))
                        break;

                    //
                    //  Make sure that the value data buffer doesn't overflow.
                    //  Because this is always string data, we must leave room
                    //  for a terminating null.
                    //

                    if (Index >= MAXDATA_LENGTH - 1) {

                        fSuccess = FALSE;
                        break;

                    }

                    ((PTSTR)g_ValueDataBuffer)[Index++] = Char;

                }

                if (fSuccess) {

                    ((PTSTR)g_ValueDataBuffer)[Index] = 0;

                    if (RegSetValue(hKey, KeyName, REG_SZ, (LPCTSTR)g_ValueDataBuffer,
                        Index*sizeof(TCHAR)) != ERROR_SUCCESS)
                        g_FileErrorStringID = IDS_IMPFILEERRREGSET;

                }

            }

        }

        //
        //  Somewhere along the line, we had a parsing error, so resynchronize
        //  on the next line.
        //

        if (!fSuccess)
            SkipPastEndOfLine();

    }

    RegFlushKey(hKey);
    RegCloseKey(hKey);

}

/*******************************************************************************
*
*  ImportNewerRegFile
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
NEAR PASCAL
ImportNewerRegFile(
    VOID
    )
{

    HKEY hLocalMachineKey;
    HKEY hUsersKey;
    HKEY hKey;
    TCHAR Char;

#ifdef WINNT
    hLocalMachineKey = NULL;
    hUsersKey = NULL;
#else
    //
    //  Keep open handles for the predefined roots to prevent the registry
    //  library from flushing after every single RegOpenKey/RegCloseKey
    //  operation.
    //

    RegOpenKey(HKEY_LOCAL_MACHINE, NULL, &hLocalMachineKey);
    RegOpenKey(HKEY_USERS, NULL, &hUsersKey);

#ifdef DEBUG
    if (hLocalMachineKey == NULL)
        DbgPrintf(("Unable to open HKEY_LOCAL_MACHINE\n\r"));
    if (hUsersKey == NULL)
        DbgPrintf(("Unable to open HKEY_USERS\n\r"));
#endif
#endif

    hKey = NULL;

    while (TRUE) {

        SkipWhitespace();

        //
        //  Check for the end of file condition.
        //

        if (!GetChar(&Char))
            break;

        switch (Char) {

            case TEXT('['):
                //
                //  If a registry key is currently open, we must close it first.
                //  If ParseHeader happens to fail (for example, no closing
                //  bracket), then hKey will be NULL and any values that we
                //  parse must be ignored.
                //

                if (hKey != NULL) {

                    RegCloseKey(hKey);
                    hKey = NULL;

                }

                ParseHeader(&hKey);

                break;

            case TEXT('"'):
                //
                //  As noted above, if we don't have an open registry key, then
                //  just skip the line.
                //

                if (hKey != NULL)
                    ParseValuename(hKey);

                else
                    SkipPastEndOfLine();

                break;

            case TEXT('@'):
                //
                //
                //

                if (hKey != NULL)
                    ParseDefaultValue(hKey);

                else
                    SkipPastEndOfLine();

                break;

            case TEXT(';'):
                //
                //  This line is a comment so just dump the rest of it.
                //

                SkipPastEndOfLine();

                break;

            default:
                if (IsNewLine(Char))
                    break;

                SkipPastEndOfLine();

                break;

        }

    }

    if (hKey != NULL)
        RegCloseKey(hKey);

    if (hUsersKey != NULL)
        RegCloseKey(hUsersKey);

    if (hLocalMachineKey != NULL)
        RegCloseKey(hLocalMachineKey);

}

/*******************************************************************************
*
*  ParseHeader
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

#define SIZE_FULL_KEYNAME (MAXKEYNAME + 40)

VOID
NEAR PASCAL
ParseHeader(
    LPHKEY lphKey
    )
{

    TCHAR FullKeyName[SIZE_FULL_KEYNAME];
    int CurrentIndex;
    int LastRightBracketIndex;
    TCHAR Char;
    UINT uOperation = ERK_CREATE;

    CurrentIndex = 0;
    LastRightBracketIndex = -1;

    if (!GetChar(&Char))
        return;

    if (Char == TEXT('-')) {
        if (!GetChar(&Char))
            return;
        uOperation = ERK_DELETE;
    }

    do {

        if (IsNewLine(Char))
            break;

        if (Char == TEXT(']'))
            LastRightBracketIndex = CurrentIndex;

        FullKeyName[CurrentIndex++] = Char;

        if (CurrentIndex == SIZE_FULL_KEYNAME) {

            do {

                if (Char == TEXT(']'))
                    LastRightBracketIndex = -1;

                if (IsNewLine(Char))
                    break;

            }   while (GetChar(&Char));

            break;

        }

    } while (GetChar(&Char));

    if (LastRightBracketIndex != -1) {

        FullKeyName[LastRightBracketIndex] = 0;

        switch (EditRegistryKey(lphKey, FullKeyName, uOperation)) {

            case ERROR_CANTOPEN:
                g_FileErrorStringID = IDS_IMPFILEERRREGOPEN;
                break;

        }

    }

}

/*******************************************************************************
*
*  ParseValuename
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
NEAR PASCAL
ParseValuename(
    HKEY hKey
    )
{

    DWORD Type;
	DWORD dwResult = 0;
    TCHAR ValueName[MAXVALUENAME_LENGTH];
    DWORD cbData;
    LPCTSTR lpPrefix;

    cbData = sizeof(ValueName);

    if (!ParseString(ValueName, &cbData))
        goto ParseError;

    SkipWhitespace();

    if (!MatchChar(TEXT('=')))
        goto ParseError;

    SkipWhitespace();

    //
    //  REG_SZ.
    //
    //  "ValueName" = "string of text"
    //

    if (MatchChar(TEXT('"'))) {

        //  BUGBUG:  Line continuations for strings?

        cbData = MAXDATA_LENGTH;

        if (!ParseString((PTSTR)g_ValueDataBuffer, &cbData) || !ParseEndOfLine())
            goto ParseError;

        Type = REG_SZ;

    }

    //
    //  REG_DWORD.
    //
    //  "ValueName" = dword: 12345678
    //

    else if (MatchChar(s_DwordPrefix[0])) {

        lpPrefix = &s_DwordPrefix[1];

        while (*lpPrefix != 0)
            if (!MatchChar(*lpPrefix++))
                goto ParseError;

        SkipWhitespace();

        if (!ParseHexDword((LPDWORD) g_ValueDataBuffer) || !ParseEndOfLine())
            goto ParseError;

        Type = REG_DWORD;
        cbData = sizeof(DWORD);

    }
    else if (MatchChar('-')) {

        if (!ParseEndOfLine())
            goto ParseError;
        RegDeleteValue(hKey, ValueName);

        return;
    }

    //
    //  REG_BINARY and other.
    //
    //  "ValueName" = hex: 00 , 11 , 22
    //  "ValueName" = hex(12345678): 00, 11, 22
    //

    else {

        lpPrefix = s_HexPrefix;

        while (*lpPrefix != 0)
            if (!MatchChar(*lpPrefix++))
                goto ParseError;

        //
        //  Check if this is a type of registry data that we don't directly
        //  support.  If so, then it's just a dump of hex data of the specified
        //  type.
        //

        if (MatchChar(TEXT('('))) {

            if (!ParseHexDword(&Type) || !MatchChar(TEXT(')')))
                goto ParseError;

        }

        else
            Type = REG_BINARY;

        if (!MatchChar(TEXT(':')) || !ParseHexSequence(g_ValueDataBuffer, &cbData) ||
            !ParseEndOfLine())
            goto ParseError;

    }

#ifdef UNICODE
    //
    // If we're compiled UNICODE and we're reading an older, ANSI .reg
    // file, we have to write all of the data to the registry using
    // RegSetValueExA, because it was read from the registry using
    // RegQueryValueExA.
    //
    if ((g_ImportFileVersion < 0x0500) && ((REG_EXPAND_SZ == Type) || (REG_MULTI_SZ == Type))) {
        CHAR AnsiValueName[MAXVALUENAME_LENGTH];

        //
        // It's much easier to convert the value name to ANSI
        // and call RegSetValueExA than to try to convert
        // a REG_MULTI_SZ to Unicode before calling RegSetValueExW.
        // We don't lose anything because this is coming from a
        // downlevel .reg file that could only contain ANSI characters
        // to begin with.
        //
        WideCharToMultiByte(
            CP_ACP,
            0,
            ValueName,
            -1,
            AnsiValueName,
            MAXVALUENAME_LENGTH,
            NULL,
            NULL
        );

        if (RegSetValueExA(
                hKey,
                AnsiValueName,
                0,
                Type,
                g_ValueDataBuffer,
                cbData)
            != ERROR_SUCCESS)
            g_FileErrorStringID = IDS_IMPFILEERRREGSET;
    }
    else {
#endif // UNICODE
		dwResult = RegSetValueEx(hKey, ValueName, 0, Type, g_ValueDataBuffer, cbData);
        if ( dwResult != ERROR_SUCCESS)
		{
            g_FileErrorStringID = IDS_IMPFILEERRREGSET;
			SetLastError( dwResult );
		}
#ifdef UNICODE
    }
#endif // UNICODE

    return;

ParseError:
    SkipPastEndOfLine();

}

/*******************************************************************************
*
*  ParseDefaultValue
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
NEAR PASCAL
ParseDefaultValue(
    HKEY hKey
    )
{

    BOOL fSuccess;
    DWORD cbData;

    fSuccess = FALSE;

    SkipWhitespace();

    if (MatchChar(TEXT('='))) {

        SkipWhitespace();

        if (MatchChar(TEXT('"'))) {

            //  BUGBUG:  Line continuations for strings?

            cbData = MAXDATA_LENGTH;

            if (ParseString((PTSTR)g_ValueDataBuffer, &cbData) && ParseEndOfLine()) {

                if (RegSetValue(hKey, NULL, REG_SZ, (LPCTSTR)g_ValueDataBuffer,
                    cbData) != ERROR_SUCCESS)
                    g_FileErrorStringID = IDS_IMPFILEERRREGSET;

                fSuccess = TRUE;

            }

        }

    }

    if (!fSuccess)
        SkipPastEndOfLine();

}

/*******************************************************************************
*
*  ParseString
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL
NEAR PASCAL
ParseString(
    LPTSTR lpString,
    LPDWORD lpcbStringData
    )
{

    TCHAR Char;
    DWORD cbMaxStringData;
    DWORD cbStringData;

    cbMaxStringData = *lpcbStringData;
    cbStringData = 1;                   //  Account for the null terminator

    while (GetChar(&Char)) {

        if (cbStringData >= cbMaxStringData)
            return FALSE;

        switch (Char) {

            case TEXT('\\'):
                if (!GetChar(&Char))
                    return FALSE;

                switch (Char) {

                    case TEXT('\\'):
                        *lpString++ = TEXT('\\');
                        break;

                    case TEXT('"'):
                        *lpString++ = TEXT('"');
                        break;

                    default:
                        DbgPrintf(("ParseString:  Invalid escape sequence"));
                        return FALSE;

                }
                break;

            case TEXT('"'):
                *lpString = 0;
                *lpcbStringData = cbStringData * sizeof(TCHAR);
                return TRUE;

            default:
                if (IsNewLine(Char))
                    return FALSE;

                *lpString++ = Char;
                break;

        }

        cbStringData++;

    }

    return FALSE;

}

/*******************************************************************************
*
*  ParseHexSequence
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL
NEAR PASCAL
ParseHexSequence(
    LPBYTE lpHexData,
    LPDWORD lpcbHexData
    )
{

    DWORD cbHexData;

    cbHexData = 0;

    do {

        if (cbHexData >= MAXDATA_LENGTH)
            return FALSE;

        SkipWhitespace();

        if (MatchChar(TEXT('\\')) && !ParseEndOfLine())
            return FALSE;

        SkipWhitespace();

        if (!ParseHexByte(lpHexData++))
            break;

        cbHexData++;

        SkipWhitespace();

    }   while (MatchChar(TEXT(',')));

    *lpcbHexData = cbHexData;

    return TRUE;

}

/*******************************************************************************
*
*  ParseHexDword
*
*  DESCRIPTION:
*     Parses a one dword hexadecimal string from the registry file stream and
*     converts it to a binary number.  A maximum of eight hex digits will be
*     parsed from the stream.
*
*  PARAMETERS:
*     lpByte, location to store binary number.
*     (returns), TRUE if a hexadecimal dword was parsed, else FALSE.
*
*******************************************************************************/

BOOL
NEAR PASCAL
ParseHexDword(
    LPDWORD lpDword
    )
{

    UINT CountDigits;
    DWORD Dword;
    BYTE Byte;

    Dword = 0;
    CountDigits = 0;

    while (TRUE) {

        if (!ParseHexDigit(&Byte))
            break;

        Dword = (Dword << 4) + (DWORD) Byte;

        if (++CountDigits == 8)
            break;

    }

    *lpDword = Dword;

    return CountDigits != 0;

}

/*******************************************************************************
*
*  ParseHexByte
*
*  DESCRIPTION:
*     Parses a one byte hexadecimal string from the registry file stream and
*     converts it to a binary number.
*
*  PARAMETERS:
*     lpByte, location to store binary number.
*     (returns), TRUE if a hexadecimal byte was parsed, else FALSE.
*
*******************************************************************************/

BOOL
NEAR PASCAL
ParseHexByte(
    LPBYTE lpByte
    )
{

    BYTE SecondDigit;

    if (ParseHexDigit(lpByte)) {

        if (ParseHexDigit(&SecondDigit))
            *lpByte = (BYTE) ((*lpByte << 4) | SecondDigit);

        return TRUE;

    }

    else
        return FALSE;

}

/*******************************************************************************
*
*  ParseHexDigit
*
*  DESCRIPTION:
*     Parses a hexadecimal character from the registry file stream and converts
*     it to a binary number.
*
*  PARAMETERS:
*     lpDigit, location to store binary number.
*     (returns), TRUE if a hexadecimal digit was parsed, else FALSE.
*
*******************************************************************************/

BOOL
NEAR PASCAL
ParseHexDigit(
    LPBYTE lpDigit
    )
{

    TCHAR Char;
    BYTE Digit;

    if (GetChar(&Char)) {

        if (Char >= TEXT('0') && Char <= TEXT('9'))
            Digit = (BYTE) (Char - TEXT('0'));

        else if (Char >= TEXT('a') && Char <= TEXT('f'))
            Digit = (BYTE) (Char - TEXT('a') + 10);

        else if (Char >= TEXT('A') && Char <= TEXT('F'))
            Digit = (BYTE) (Char - TEXT('A') + 10);

        else {

            UngetChar();

            return FALSE;

        }

        *lpDigit = Digit;

        return TRUE;

    }

    return FALSE;

}

/*******************************************************************************
*
*  ParseEndOfLine
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL
NEAR PASCAL
ParseEndOfLine(
    VOID
    )
{

    TCHAR Char;
    BOOL fComment;
    BOOL fFoundOneEndOfLine;

    fComment = FALSE;
    fFoundOneEndOfLine = FALSE;

    while (GetChar(&Char)) {

        if (IsWhitespace(Char))
            continue;

        if (IsNewLine(Char)) {

            fComment = FALSE;
            fFoundOneEndOfLine = TRUE;

        }

        //
        //  Like .INIs and .INFs, comments begin with a semicolon character.
        //

        else if (Char == TEXT(';'))
            fComment = TRUE;

        else if (!fComment) {

            UngetChar();

            break;

        }

    }

    return fFoundOneEndOfLine;

}

/*******************************************************************************
*
*  SkipWhitespace
*
*  DESCRIPTION:
*     Advances the registry file pointer to the first character past any
*     detected whitespace.
*
*  PARAMETERS:
*     (none).
*
*******************************************************************************/

VOID
NEAR PASCAL
SkipWhitespace(
    VOID
    )
{

    TCHAR Char;

    while (GetChar(&Char)) {

        if (!IsWhitespace(Char)) {

            UngetChar();
            break;

        }

    }

}

/*******************************************************************************
*
*  SkipPastEndOfLine
*
*  DESCRIPTION:
*     Advances the registry file pointer to the first character past the first
*     detected new line character.
*
*  PARAMETERS:
*     (none).
*
*******************************************************************************/

VOID
NEAR PASCAL
SkipPastEndOfLine(
    VOID
    )
{

    TCHAR Char;

    while (GetChar(&Char)) {

        if (IsNewLine(Char))
            break;

    }

    while (GetChar(&Char)) {

        if (!IsNewLine(Char)) {

            UngetChar();
            break;

        }

    }

}

/*******************************************************************************
*
*  GetChar
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL
NEAR PASCAL
GetChar(
    PTCHAR lpChar
    )
{

    FILE_NUMBYTES NumberOfBytesRead;
    UINT NewPercentage;

    // If we're at the end of the buffer, read some more.
    // SIZE_FILE_IO_BUFFER is in bytes, but s_FileIo.BufferOffset is in chars,
    // so we multiply according to whether we're reading ANSI or Unicode.
    if ((s_FileIo.BufferOffset * (s_fTreatFileAsUnicode ? sizeof(WCHAR) : 1)) == SIZE_FILE_IO_BUFFER) {

        if (TRUE == s_fTreatFileAsUnicode) {
            if (!READFILE(s_FileIo.hFile, s_FileIo.Buffer,
                SIZE_FILE_IO_BUFFER, &NumberOfBytesRead)) {

                g_FileErrorStringID = IDS_IMPFILEERRFILEREAD;
                return FALSE;
            }

            s_FileIo.CharsAvailable = ((int) NumberOfBytesRead / 2);
        }
        else {
            if (!READFILE(s_FileIo.hFile, s_FileIo.ConversionBuffer,
                SIZE_FILE_IO_BUFFER, &NumberOfBytesRead)) {

                g_FileErrorStringID = IDS_IMPFILEERRFILEREAD;
                return FALSE;
            }

            {
                int i;

#ifdef UNICODE
                i = MultiByteToWideChar(
                        CP_ACP,
                        MB_PRECOMPOSED,
                        s_FileIo.ConversionBuffer,
                        NumberOfBytesRead,
                        s_FileIo.Buffer,
                        SIZE_FILE_IO_BUFFER
                        );
#else
                lstrcpyn(s_FileIo.Buffer, s_FileIo.ConversionBuffer, NumberOfBytesRead + 1);
                i = lstrlen(s_FileIo.Buffer);
#endif //UNICODE

                s_FileIo.CharsAvailable = i;
            }
        }

        s_FileIo.BufferOffset = 0;
        s_FileIo.FileOffset += NumberOfBytesRead;

        if (s_FileIo.FileSizeDiv100 != 0) {

            NewPercentage = ((UINT) (s_FileIo.FileOffset /
                s_FileIo.FileSizeDiv100));

            if (NewPercentage > 100)
                NewPercentage = 100;

        }

        else
            NewPercentage = 100;

        if (s_FileIo.LastPercentage != NewPercentage) {

            s_FileIo.LastPercentage = NewPercentage;
// no UI
//            ImportRegFileUICallback(NewPercentage);

        }

    }

    if (s_FileIo.BufferOffset >= s_FileIo.CharsAvailable)
        return FALSE;

    *lpChar = s_FileIo.Buffer[s_FileIo.BufferOffset++];

    return TRUE;

}

/*******************************************************************************
*
*  UngetChar
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
NEAR PASCAL
UngetChar(
    VOID
    )
{

#ifdef DEBUG
    if (s_FileIo.fValidateUngetChar)
        DbgPrintf(("REGEDIT ERROR: Too many UngetChar's called!\n\r"));
#endif

    s_FileIo.BufferOffset--;

}

/*******************************************************************************
*
*  MatchChar
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL
NEAR PASCAL
MatchChar(
    TCHAR CharToMatch
    )
{

    BOOL fMatch;
    TCHAR NextChar;

    fMatch = FALSE;

    if (GetChar(&NextChar)) {

        if (CharToMatch == NextChar)
            fMatch = TRUE;

        else
            UngetChar();

    }

    return fMatch;

}

/*******************************************************************************
*
*  IsWhitespace
*
*  DESCRIPTION:
*     Checks if the given character is whitespace.
*
*  PARAMETERS:
*     Char, character to check.
*     (returns), TRUE if character is whitespace, else FALSE.
*
*******************************************************************************/

BOOL
NEAR PASCAL
IsWhitespace(
    TCHAR Char
    )
{

    return Char == TEXT(' ') || Char == TEXT('\t');

}

/*******************************************************************************
*
*  IsNewLine
*
*  DESCRIPTION:
*     Checks if the given character is a new line character.
*
*  PARAMETERS:
*     Char, character to check.
*     (returns), TRUE if character is a new line, else FALSE.
*
*******************************************************************************/

BOOL
NEAR PASCAL
IsNewLine(
    TCHAR Char
    )
{

    return Char == TEXT('\n') || Char == TEXT('\r');

}

/*******************************************************************************
*
*  ExportWinNT50RegFile
*
*  DESCRIPTION:
*      Exports an NT 5.0, unicode registry file.  Use this export function
*      for all future .reg file writing.
*
*  PARAMETERS:
*
*******************************************************************************/
VOID
PASCAL
ExportWinNT50RegFile(
    LPTSTR lpFileName,
    LPTSTR lpSelectedPath
    )
{

    HKEY hKey;
    TCHAR SelectedPath[SIZE_SELECTED_PATH];

    g_FileErrorStringID = IDS_EXPFILEERRSUCCESS;

    if (lpSelectedPath != NULL && EditRegistryKey(&hKey, lpSelectedPath,
        ERK_OPEN) != ERROR_SUCCESS) {

        g_FileErrorStringID = IDS_EXPFILEERRBADREGPATH;
        return;

    }

    if (OPENWRITEFILE(lpFileName, s_FileIo.hFile)) {

        DWORD dwNumberOfBytesWritten;

        s_FileIo.BufferOffset = 0;
        s_FileIo.CurrentColumn = 0;

        WRITEFILE(s_FileIo.hFile, &s_UnicodeByteOrderMark, sizeof(s_UnicodeByteOrderMark), &dwNumberOfBytesWritten);

        PutLiteral(s_WinNT50RegFileHeader);
        PutLiteral(TEXT(" "));
        PutLiteral(s_WinNT50RegFileVersion);
        PutLiteral(TEXT("\n\n"));

        if (lpSelectedPath != NULL) {

            STRCPY(SelectedPath, lpSelectedPath);
            PutBranch(hKey, SelectedPath);

        }

        else {

            STRCPY(SelectedPath,
                g_RegistryRoots[INDEX_HKEY_LOCAL_MACHINE].lpKeyName);
            PutBranch(HKEY_LOCAL_MACHINE, SelectedPath);

            STRCPY(SelectedPath,
                g_RegistryRoots[INDEX_HKEY_USERS].lpKeyName);
            PutBranch(HKEY_USERS, SelectedPath);

        }

        FlushIoBuffer();

        CLOSEFILE(s_FileIo.hFile);

    }

    else
        g_FileErrorStringID = IDS_EXPFILEERRFILEOPEN;

    if (lpSelectedPath != NULL)
        RegCloseKey(hKey);

}

/*******************************************************************************
*
*  ExportWin40RegFile
*
*  DESCRIPTION:
*      This function is only kept around to export old, ANSI, regedit 4 .reg
*      files.  Don't touch it except to fix bugs.  Meddling with this code
*      path will result in .reg files that can't be read by older verions
*      of regedit, which is the whole reason this code path is here.  Meddle
*      with ExportWinNT50RegFile if you want to break backwards compatibility.
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
PASCAL
ExportWin40RegFile(
    LPTSTR lpFileName,
    LPTSTR lpSelectedPath
    )
{

    HKEY hKey;
    TCHAR SelectedPath[SIZE_SELECTED_PATH];

    g_FileErrorStringID = IDS_EXPFILEERRSUCCESS;

    if (lpSelectedPath != NULL && EditRegistryKey(&hKey, lpSelectedPath,
        ERK_OPEN) != ERROR_SUCCESS) {

        g_FileErrorStringID = IDS_EXPFILEERRBADREGPATH;
        return;

    }

    if (OPENWRITEFILE(lpFileName, s_FileIo.hFile)) {

        s_FileIo.BufferOffset = 0;
        s_FileIo.CurrentColumn = 0;

        PutLiteral(s_Win40RegFileHeader);

        if (lpSelectedPath != NULL) {

            STRCPY(SelectedPath, lpSelectedPath);
            PutBranch(hKey, SelectedPath);

        }

        else {

            STRCPY(SelectedPath,
                g_RegistryRoots[INDEX_HKEY_LOCAL_MACHINE].lpKeyName);
            PutBranch(HKEY_LOCAL_MACHINE, SelectedPath);

            STRCPY(SelectedPath,
                g_RegistryRoots[INDEX_HKEY_USERS].lpKeyName);
            PutBranch(HKEY_USERS, SelectedPath);

        }

        FlushIoBuffer();

        CLOSEFILE(s_FileIo.hFile);

    }

    else
        g_FileErrorStringID = IDS_EXPFILEERRFILEOPEN;

    if (lpSelectedPath != NULL)
        RegCloseKey(hKey);

}

/*******************************************************************************
*
*  PutBranch
*
*  DESCRIPTION:
*     Writes out all of the value names and their data and recursively calls
*     this routine for all of the key's subkeys to the registry file stream.
*
*  PARAMETERS:
*     hKey, registry key to write to file.
*     lpFullKeyName, string that gives the full path, including the root key
*        name, of the hKey.
*
*******************************************************************************/

VOID
NEAR PASCAL
PutBranch(
    HKEY hKey,
    LPTSTR lpFullKeyName
    )
{

    LONG RegError;
    DWORD EnumIndex;
    DWORD cbValueName;
    DWORD cbValueData;
    DWORD Type;
    LPTSTR lpSubKeyName;
    int MaximumSubKeyLength;
    HKEY hSubKey;

    //
    //  Write out the section header.
    //

    PutChar(TEXT('['));
    PutLiteral(lpFullKeyName);
    PutLiteral(TEXT("]\n"));

    //
    //  Write out all of the value names and their data.
    //

    EnumIndex = 0;

    while (TRUE) {

        cbValueName = sizeof(g_ValueNameBuffer);
        cbValueData = MAXDATA_LENGTH;

        if ((RegError = RegEnumValue(hKey, EnumIndex++, g_ValueNameBuffer,
            &cbValueName, NULL, &Type, g_ValueDataBuffer, &cbValueData))
            != ERROR_SUCCESS)
            break;

        //
        //  If cbValueName is zero, then this is the default value of
        //  the key, or the Windows 3.1 compatible key value.
        //

        if (cbValueName)
            PutString(g_ValueNameBuffer);

        else
            PutChar(TEXT('@'));

        PutChar(TEXT('='));

        switch (Type) {

            case REG_SZ:
                PutString((LPTSTR) g_ValueDataBuffer);
                break;

            case REG_DWORD:
                if (cbValueData == sizeof(DWORD)) {

                    PutLiteral(s_DwordPrefix);
                    PutDword(*((LPDWORD) g_ValueDataBuffer), TRUE);
                    break;

                }
                //  FALL THROUGH

            case REG_BINARY:
            default:
                PutBinary((LPBYTE) g_ValueDataBuffer, Type, cbValueData);
                break;

        }

        PutChar(TEXT('\n'));

        if (g_FileErrorStringID == IDS_EXPFILEERRFILEWRITE)
            return;

    }

    PutChar(TEXT('\n'));

    if (RegError != ERROR_NO_MORE_ITEMS)
        g_FileErrorStringID = IDS_EXPFILEERRREGENUM;

    //
    //  Write out all of the subkeys and recurse into them.
    //

    lpSubKeyName = lpFullKeyName + STRLEN(lpFullKeyName);
    *lpSubKeyName++ = TEXT('\\');
    MaximumSubKeyLength = MAXKEYNAME - STRLEN(lpSubKeyName);

    EnumIndex = 0;

    while (TRUE) {

        if ((RegError = RegEnumKey(hKey, EnumIndex++, lpSubKeyName,
            MaximumSubKeyLength)) != ERROR_SUCCESS)
            break;

        if(RegOpenKeyEx(hKey,lpSubKeyName,0,KEY_ENUMERATE_SUB_KEYS|KEY_QUERY_VALUE,&hSubKey) == ERROR_SUCCESS) {

            PutBranch(hSubKey, lpFullKeyName);

            RegCloseKey(hSubKey);

            if (g_FileErrorStringID == IDS_EXPFILEERRFILEWRITE)
                return;

        }

        else
            g_FileErrorStringID = IDS_EXPFILEERRREGOPEN;

    }

    if (RegError != ERROR_NO_MORE_ITEMS)
        g_FileErrorStringID = IDS_EXPFILEERRREGENUM;

}

/*******************************************************************************
*
*  PutLiteral
*
*  DESCRIPTION:
*     Writes a literal string to the registry file stream.  No special handling
*     is done for the string-- it is written out as is.
*
*  PARAMETERS:
*     lpLiteral, null-terminated literal to write to file.
*
*******************************************************************************/

VOID
NEAR PASCAL
PutLiteral(
    LPCTSTR lpLiteral
    )
{

    while (*lpLiteral != 0)
        PutChar(*lpLiteral++);

}

/*******************************************************************************
*
*  PutString
*
*  DESCRIPTION:
*     Writes a string to the registry file stream.  A string is surrounded by
*     double quotes and some characters may be translated to escape sequences
*     to enable a parser to read the string back in.
*
*  PARAMETERS:
*     lpString, null-terminated string to write to file.
*
*******************************************************************************/

VOID
NEAR PASCAL
PutString(
    LPCTSTR lpString
    )
{

    TCHAR Char;

    PutChar(TEXT('"'));

    while ((Char = *lpString++) != 0) {

        switch (Char) {

            case TEXT('\\'):
            case TEXT('"'):
                PutChar(TEXT('\\'));
                //  FALL THROUGH

            default:
                PutChar(Char);
                break;

        }

    }

    PutChar(TEXT('"'));

}

/*******************************************************************************
*
*  PutBinary
*
*  DESCRIPTION:
*     Writes a sequence of hexadecimal bytes to the registry file stream.  The
*     output is formatted such that it doesn't exceed a defined line length.
*
*  PARAMETERS:
*     lpBuffer, bytes to write to file.
*     Type, value data type.
*     cbBytes, number of bytes to write.
*
*******************************************************************************/

VOID
NEAR PASCAL
PutBinary(
    CONST BYTE FAR* lpBuffer,
    DWORD Type,
    DWORD cbBytes
    )
{

    BOOL fFirstByteOnLine;
    BYTE Byte;

#ifdef UNICODE
    // If we're writing one of the string formats that regedit doesn't write
    // natively (but rather converts to a string of hex digits for streaming
    // out), AND we're writing in downlevel/ANSI/REGEDIT4 format, we aren't
    // going to write out the high byte of each (internally Unicode) character.
    // So we will be writing half as many characters as the buffer byte size.
    if (g_fSaveInDownlevelFormat &&
        ((Type == REG_EXPAND_SZ) || (Type == REG_MULTI_SZ))) {
        cbBytes = cbBytes / 2;
    }
#endif

    PutLiteral(s_HexPrefix);

    if (Type != REG_BINARY) {

        PutChar(TEXT('('));
        PutDword(Type, FALSE);
        PutChar(TEXT(')'));

    }

    PutChar(TEXT(':'));

    fFirstByteOnLine = TRUE;

    while (cbBytes--) {

        if (s_FileIo.CurrentColumn > 75 && !fFirstByteOnLine) {

            PutLiteral(s_FileLineBreak);

            fFirstByteOnLine = TRUE;

        }

        if (!fFirstByteOnLine)
            PutChar(TEXT(','));

        Byte = *lpBuffer++;

#ifdef UNICODE
        // If we're writing one of the string formats that regedit doesn't
        // write natively (REG_EXPAND_SZ and REG_MULTI_SZ values get converted
        // to a string of hex digits for streaming out), AND we're writing in
        // downlevel/ANSI/REGEDIT4 format, we don't want to write out the high
        // byte of each (internally Unicode) character.  So in those cases, we
        // advance another byte to get to the next ANSI character.  Yes, this
        // will lose data on non-SBCS characters, but that's what you get for
        // saving in the downlevel format.

        if (g_fSaveInDownlevelFormat &&
            ((Type == REG_EXPAND_SZ) || (Type == REG_MULTI_SZ))) {
            lpBuffer++;
        }
#endif

        PutChar(g_HexConversion[Byte >> 4]);
        PutChar(g_HexConversion[Byte & 0x0F]);

        fFirstByteOnLine = FALSE;

    }

}

/*******************************************************************************
*
*  PutChar
*
*  DESCRIPTION:
*     Writes a 32-bit word to the registry file stream.
*
*  PARAMETERS:
*     Dword, dword to write to file.
*
*******************************************************************************/

VOID
NEAR PASCAL
PutDword(
    DWORD Dword,
    BOOL fLeadingZeroes
    )
{

    int nTemp;
    int CurrentNibble;
    TCHAR Char;
    BOOL fWroteNonleadingChar;

    fWroteNonleadingChar = fLeadingZeroes;

    for (CurrentNibble = 7; CurrentNibble >= 0; CurrentNibble--) {

        nTemp = Dword;
        Char = g_HexConversion[(nTemp >> (CurrentNibble * 4)) & 0x0F];

        if (fWroteNonleadingChar || Char != TEXT('0')) {

            PutChar(Char);
            fWroteNonleadingChar = TRUE;

        }

    }

    //
    //  We need to write at least one character, so if we haven't written
    //  anything yet, just spit out one zero.
    //

    if (!fWroteNonleadingChar)
        PutChar(TEXT('0'));

}

/*******************************************************************************
*
*  PutChar
*
*  DESCRIPTION:
*     Writes one character to the registry file stream using an intermediate
*     buffer.
*
*  PARAMETERS:
*     Char, character to write to file.
*
*******************************************************************************/

VOID
NEAR PASCAL
PutChar(
    TCHAR Char
    )
{

    //
    //  Keep track of what column we're currently at.  This is useful in cases
    //  such as writing a large binary registry record.  Instead of writing one
    //  very long line, the other Put* routines can break up their output.
    //

    if (Char != TEXT('\n'))
        s_FileIo.CurrentColumn++;

    else {

        //
        //  Force a carriage-return, line-feed sequence to keep things like, oh,
        //  Notepad happy.
        //

        PutChar(TEXT('\r'));

        s_FileIo.CurrentColumn = 0;

    }

    s_FileIo.Buffer[s_FileIo.BufferOffset++] = Char;

    if (s_FileIo.BufferOffset == SIZE_FILE_IO_BUFFER)
        FlushIoBuffer();

}

/*******************************************************************************
*
*  FlushIoBuffer
*
*  DESCRIPTION:
*     Flushes the contents of the registry file stream to the disk and resets
*     the buffer pointer.
*
*  PARAMETERS:
*     (none).
*
*******************************************************************************/

VOID
NEAR PASCAL
FlushIoBuffer(
    VOID
    )
{

    FILE_NUMBYTES NumberOfBytesWritten;

    if (s_FileIo.BufferOffset) {

        if (g_fSaveInDownlevelFormat)
        {
            //
            // Convert Unicode to ANSI before writing.
            //

            int i;

#ifdef UNICODE
            i = WideCharToMultiByte(
                    CP_ACP,
                    0,
                    s_FileIo.Buffer,
                    s_FileIo.BufferOffset,
                    s_FileIo.ConversionBuffer,
                    sizeof(s_FileIo.ConversionBuffer),
                    NULL,
                    NULL
                    );
#else
                lstrcpyn(s_FileIo.ConversionBuffer, s_FileIo.Buffer, s_FileIo.BufferOffset + 1);
                i = lstrlen(s_FileIo.ConversionBuffer);
#endif //UNICODE

            if (!WRITEFILE(s_FileIo.hFile, s_FileIo.ConversionBuffer, i,
                &NumberOfBytesWritten) || (FILE_NUMBYTES) i !=
                NumberOfBytesWritten)

                g_FileErrorStringID = IDS_EXPFILEERRFILEWRITE;
        }
        else
        {
            //
            // Write Unicode text
            //
            if (!WRITEFILE(s_FileIo.hFile, s_FileIo.Buffer, s_FileIo.BufferOffset * sizeof(WCHAR),
                &NumberOfBytesWritten) || (FILE_NUMBYTES) (s_FileIo.BufferOffset * sizeof(WCHAR)) !=
                NumberOfBytesWritten)
                g_FileErrorStringID = IDS_EXPFILEERRFILEWRITE;
        }
    }

    s_FileIo.BufferOffset = 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\reg\stdafx.h ===
// stdafx.h : include file for standard system include files,
//            or project specific include files that are used frequently, 
//            but are changed infrequently
//


#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>

#include "resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\regedit\reg1632.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REG1632.H
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        06 Apr 1994
*
*  Win32 and MS-DOS compatibility macros for the Registry Editor.
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  06 Apr 1994 TCS Original implementation.
*
*******************************************************************************/

#ifndef _INC_REG1632
#define _INC_REG1632

#ifndef LPCHAR
typedef CHAR FAR*                       LPCHAR;
#endif

#ifdef WIN32
#define WSPRINTF(x)                     wsprintf ##x
#else
#define WSPRINTF(x)                     sprintf ##x
#endif

#ifdef WIN32
#define STRCMP(string1, string2)        lstrcmp(string1, string2)
#else
#define STRCMP(string1, string2)        _fstrcmp(string1, string2)
#endif

#ifdef WIN32
#define STRCPY(string1, string2)        lstrcpy(string1, string2)
#else
#define STRCPY(string1, string2)        _fstrcpy(string1, string2)
#endif

#ifdef WIN32
#define STRLEN(string)                  lstrlen(string)
#else
#define STRLEN(string)                  _fstrlen(string)
#endif

#ifdef WIN32
#define STRCHR(string, character)       StrChr(string, character)
#else
#define STRCHR(string, character)       _fstrchr(string, character)
#endif

#ifdef WIN32
#define CHARNEXT(string)                CharNext(string)
#else
#define CHARNEXT(string)                (string + 1)
#endif

#ifdef WIN32
#define CHARUPPERSTRING(string)         CharUpper(string)
#else
#define CHARUPPERSTRING(string)         _fstrupr(string)
#endif

#ifdef WIN32
#define FILE_HANDLE                     HANDLE
#else
#define FILE_HANDLE                     int
#endif

#ifdef WIN32
#define FILE_NUMBYTES                   DWORD
#else
#define FILE_NUMBYTES                   unsigned
#endif

#ifdef WIN32
#define OPENREADFILE(pfilename, handle)                                     \
    ((handle = CreateFile(pfilename, GENERIC_READ, FILE_SHARE_READ,         \
        NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL)) !=               \
        INVALID_HANDLE_VALUE)
#else
#define OPENREADFILE(pfilename, handle)                                     \
    (_dos_open(pfilename, _O_RDONLY, &handle) == 0)
#endif

#ifdef WIN32
#define OPENWRITEFILE(pfilename, handle)                                    \
    ((handle = CreateFile(pfilename, GENERIC_WRITE, 0,                      \
        NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL)) !=               \
        INVALID_HANDLE_VALUE)
#else
#define OPENWRITEFILE(pfilename, handle)                                    \
    (_dos_creat(pfilename, _A_NORMAL, &handle) == 0)
#endif

#ifdef WIN32
#define READFILE(handle, buffer, count, pnumbytes)                          \
    ReadFile(handle, buffer, count, pnumbytes, NULL)
#else
#define READFILE(handle, buffer, count, pnumbytes)                          \
    (_dos_read(handle, buffer, count, pnumbytes) == 0)
#endif

#ifdef WIN32
#define WRITEFILE(handle, buffer, count, pnumbytes)                         \
    WriteFile(handle, buffer, count, pnumbytes, NULL)
#else
#define WRITEFILE(handle, buffer, count, pnumbytes)                         \
    (_dos_write(handle, buffer, count, pnumbytes) == 0)
#endif

#ifdef WIN32
#define SEEKCURRENTFILE(handle, count)                                      \
    (SetFilePointer(handle, (LONG) count, NULL, FILE_CURRENT))
#else
#define SEEKCURRENTFILE(handle, count)                                      \
    (_dos_seek(handle, (unsigned long) count, SEEK_CUR))
#endif

#ifdef WIN32
#define CLOSEFILE(handle)               CloseHandle(handle)
#else
#define CLOSEFILE(handle)               _dos_close(handle)
#endif

#ifdef WIN32
#define GETFILESIZE(handle)             GetFileSize(handle, NULL)
#else
DWORD
NEAR PASCAL
GetFileSize(
    FILE_HANDLE hFile
    );
#define GETFILESIZE(handle)             GetFileSize(handle)
#endif

#endif // _INC_REG1632
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\regedit\regbined.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGBINED.H
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        05 Mar 1994
*
*  Binary edit dialog for use by the Registry Editor.
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  05 Mar 1994 TCS Original implementation.
*
*******************************************************************************/

#ifndef _INC_REGBINED
#define _INC_REGBINED

INT_PTR
CALLBACK
EditBinaryValueDlgProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
PASCAL
RegisterHexEditClass(
    VOID
    );

#endif // _INC_REGBINED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\regedit\regbined.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGBINED.C
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        05 Mar 1994
*
*  Binary edit dialog for use by the Registry Editor.
*
*  Hexadecimal editor control for use by the Registry Editor.  Little attempt
*  is made to make this a generic control-- only one instance is assumed to
*  ever exist.
*
*******************************************************************************/

#include "pch.h"
#include "regresid.h"
#include "reghelp.h"

//
//  Following structure and data are used to move the controls of the
//  EditBinaryValue dialog so that the HexEdit control fills up the appropriate
//  amount of space based on the system metrics.
//

typedef struct _MOVEWND {
    int ControlID;
    UINT SetWindowPosFlags;
}   MOVEWND;

const TCHAR s_HexEditClassName[] = HEXEDIT_CLASSNAME;

const TCHAR s_HexEditClipboardFormatName[] = TEXT("RegEdit_HexData");

const TCHAR s_HexWordFormatSpec[] = TEXT("%04X");
const TCHAR s_HexByteFormatSpec[] = TEXT("%02X");

const MOVEWND s_EditBinaryValueMoveWnd[] = {
    IDOK,           SWP_NOSIZE | SWP_NOZORDER,
    IDCANCEL,       SWP_NOSIZE | SWP_NOZORDER,
    IDC_VALUENAME,  SWP_NOMOVE | SWP_NOZORDER,
    IDC_VALUEDATA,  SWP_NOMOVE | SWP_NOZORDER
};

const DWORD s_EditBinaryValueHelpIDs[] = {
    IDC_VALUEDATA, IDH_REGEDIT_VALUEDATA,
    IDC_VALUENAME, IDH_REGEDIT_VALUENAME,
    0, 0
};


#define HEM_SETBUFFER                   (WM_USER + 1)

//  Number of bytes that are displayed per line.  NOTE:  Assumptions have been
//  made that this is power of two.
#define BYTES_PER_HEXEDIT_LINE          8
#define BYTES_PER_HEXEDIT_LINE_MASK     0x0007

//
//  This font is used by the HexEdit window for all output.  The lfHeight
//  member is calculated later based on the system configuration.
//

LOGFONT s_HexEditFont = {
    0,                                  //  lfHeight
    0,                                  //  lfWidth
    0,                                  //  lfEscapement
    0,                                  //  lfOrientation
    FW_NORMAL,                          //  lfWeight
    FALSE,                              //  lfItalic
    FALSE,                              //  lfUnderline
    FALSE,                              //  lfStrikeout
    ANSI_CHARSET,                       //  lfCharSet
    OUT_DEFAULT_PRECIS,                 //  lfOutPrecision
    CLIP_DEFAULT_PRECIS,                //  lfClipPrecision
    DEFAULT_QUALITY,                    //  lfQuality
    FIXED_PITCH | FF_DONTCARE,          //  lfPitchAndFamily
    TEXT("Courier")                     //  lfFaceName
};

//
//  Reference data for the HexEdit window.  Because we only ever expect one
//  instance of this class to exist, we can safely create one instance of this
//  structure now to avoid allocating and managing the structure later.
//

typedef struct _HEXEDITDATA {
    UINT Flags;
    PBYTE pBuffer;
    int cbBuffer;
    int cbBufferMax;
    int cxWindow;                       //  Width of the window
    int cyWindow;                       //  Height of the window
    HFONT hFont;                        //  Font being used for output
    LONG FontHeight;                    //  Height of the above font
    LONG FontMaxWidth;                  //  Maximum width of the above font
    int LinesVisible;                   //  Number of lines can be displayed
    int MaximumLines;                   //  Total number of lines
    int FirstVisibleLine;               //  Line number of top of display
    int xHexDumpStart;
    int xHexDumpByteWidth;
    int xAsciiDumpStart;
    int CaretIndex;
    int MinimumSelectedIndex;
    int MaximumSelectedIndex;
    int xPrevMessagePos;                //  Cursor point on last mouse message
    int yPrevMessagePos;                //  Cursor point on last mouse message
}   HEXEDITDATA;

//  Set if window has input focus, clear if not.
#define HEF_FOCUS                       0x00000001
#define HEF_NOFOCUS                     0x00000000
//  Set if dragging a range with mouse, clear if not.
#define HEF_DRAGGING                    0x00000002
#define HEF_NOTDRAGGING                 0x00000000
//  Set if editing ASCII column, clear if editing hexadecimal column.
#define HEF_CARETINASCIIDUMP            0x00000004
#define HEF_CARETINHEXDUMP              0x00000000
//
#define HEF_INSERTATLOWNIBBLE           0x00000008
#define HEF_INSERTATHIGHNIBBLE          0x00000000
//  Set if caret should be shown at the end of the previous line instead of at
//  the beginning of it's real caret line, clear if not.
#define HEF_CARETATENDOFLINE            0x00000010

HEXEDITDATA s_HexEditData;

typedef struct _HEXEDITCLIPBOARDDATA {
    DWORD cbSize;
    BYTE Data[1];
}   HEXEDITCLIPBOARDDATA, *LPHEXEDITCLIPBOARDDATA;

UINT s_HexEditClipboardFormat;

BOOL
PASCAL
EditBinaryValue_OnInitDialog(
    HWND hWnd,
    HWND hFocusWnd,
    LPARAM lParam
    );

LRESULT
PASCAL
HexEditWndProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
PASCAL
HexEdit_OnNcCreate(
    HWND hWnd,
    LPCREATESTRUCT lpCreateStruct
    );

VOID
PASCAL
HexEdit_OnSize(
    HWND hWnd,
    UINT State,
    int cx,
    int cy
    );

VOID
PASCAL
HexEdit_SetScrollInfo(
    HWND hWnd
    );

VOID
PASCAL
HexEdit_OnVScroll(
    HWND hWnd,
    HWND hCtlWnd,
    UINT Code,
    int Position
    );

VOID
PASCAL
HexEdit_OnPaint(
    HWND hWnd
    );

VOID
PASCAL
HexEdit_PaintRect(
    HDC hDC,
    LPRECT lpUpdateRect
    );

VOID
PASCAL
HexEdit_OnSetFocus(
    HWND hWnd
    );

VOID
PASCAL
HexEdit_OnKillFocus(
    HWND hWnd
    );

VOID
PASCAL
HexEdit_OnLButtonDown(
    HWND hWnd,
    BOOL fDoubleClick,
    int x,
    int y,
    UINT KeyFlags
    );

VOID
PASCAL
HexEdit_OnMouseMove(
    HWND hWnd,
    int x,
    int y,
    UINT KeyFlags
    );

VOID
PASCAL
HexEdit_OnLButtonUp(
    HWND hWnd,
    int x,
    int y,
    UINT KeyFlags
    );

int
PASCAL
HexEdit_HitTest(
    int x,
    int y
    );

VOID
PASCAL
HexEdit_OnKey(
    HWND hWnd,
    UINT VirtualKey,
    BOOL fDown,
    int cRepeat,
    UINT Flags
    );

VOID
PASCAL
HexEdit_OnChar(
    HWND hWnd,
    TCHAR Char,
    int cRepeat
    );

VOID
PASCAL
HexEdit_SetCaretPosition(
    HWND hWnd
    );

VOID
PASCAL
HexEdit_EnsureCaretVisible(
    HWND hWnd
    );

VOID
PASCAL
HexEdit_ChangeCaretIndex(
    HWND hWnd,
    int NewCaretIndex,
    BOOL fExtendSelection
    );

VOID
PASCAL
HexEdit_DeleteRange(
    HWND hWnd,
    UINT SourceKey
    );

BOOL
PASCAL
HexEdit_OnCopy(
    HWND hWnd
    );

BOOL
PASCAL
HexEdit_OnPaste(
    HWND hWnd
    );

VOID
PASCAL
HexEdit_OnContextMenu(
    HWND hWnd,
    int x,
    int y
    );

/*******************************************************************************
*
*  EditBinaryValueDlgProc
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

INT_PTR
CALLBACK
EditBinaryValueDlgProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    )
{

    LPEDITVALUEPARAM lpEditValueParam;

    switch (Message) {

        HANDLE_MSG(hWnd, WM_INITDIALOG, EditBinaryValue_OnInitDialog);

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) 
            {
                case IDOK:
                case IDCANCEL:
                    lpEditValueParam = (LPEDITVALUEPARAM) GetWindowLongPtr(hWnd, DWLP_USER);
                    // Set these for both "ok" and "cancel", 
                    // lpEditValueParam->pValueData must again point to the
                    // current buffer so it can be returned and deleted
                    lpEditValueParam->cbValueData = s_HexEditData.cbBuffer;
                    lpEditValueParam->pValueData = s_HexEditData.pBuffer;
                    s_HexEditData.pBuffer = NULL;

                    EndDialog(hWnd, GET_WM_COMMAND_ID(wParam, lParam));
                    break;

                default:
                    return FALSE;

            }
            break;

        case WM_HELP:
            WinHelp(((LPHELPINFO) lParam)-> hItemHandle, g_pHelpFileName,
                HELP_WM_HELP, (ULONG_PTR) s_EditBinaryValueHelpIDs);
            break;

        case WM_CONTEXTMENU:
            WinHelp((HWND) wParam, g_pHelpFileName, HELP_CONTEXTMENU,
                (DWORD) (ULONG_PTR) s_EditBinaryValueHelpIDs);
            break;

        default:
            return FALSE;

    }

    return TRUE;

}

/*******************************************************************************
*
*  EditBinaryValue_OnInitDialog
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd,
*     hFocusWnd,
*     lParam,
*
*******************************************************************************/

BOOL
PASCAL
EditBinaryValue_OnInitDialog(
    HWND hWnd,
    HWND hFocusWnd,
    LPARAM lParam
    )
{

    LPEDITVALUEPARAM lpEditValueParam;
    RECT Rect;
    int HexEditIdealWidth;
    int dxChange;
    HWND hControlWnd;
    UINT Counter;

    SetWindowLongPtr(hWnd, DWLP_USER, lParam);
    lpEditValueParam = (LPEDITVALUEPARAM) lParam;

    SetDlgItemText(hWnd, IDC_VALUENAME, lpEditValueParam-> pValueName);

    SendDlgItemMessage(hWnd, IDC_VALUEDATA, HEM_SETBUFFER, (WPARAM)
        lpEditValueParam-> cbValueData, (LPARAM) lpEditValueParam-> pValueData);

    //
    //  Figure out how big the "ideally" size HexEdit should be-- this means
    //  displaying the address, hex dump, ASCII dump, and potentially a scroll
    //  bar.
    //

    GetWindowRect(GetDlgItem(hWnd, IDC_VALUEDATA), &Rect);

    HexEditIdealWidth = s_HexEditData.xAsciiDumpStart +
        s_HexEditData.FontMaxWidth * (BYTES_PER_HEXEDIT_LINE + 1) +
        GetSystemMetrics(SM_CXVSCROLL) + GetSystemMetrics(SM_CXEDGE) * 2;

    dxChange = HexEditIdealWidth - (Rect.right - Rect.left);

    //
    //  Resize the dialog box.
    //

    GetWindowRect(hWnd, &Rect);

    MoveWindow(hWnd, Rect.left, Rect.top, Rect.right - Rect.left + dxChange,
        Rect.bottom - Rect.top, FALSE);

    //
    //  Resize or move the controls as necessary.
    //

    for (Counter = 0; Counter < (sizeof(s_EditBinaryValueMoveWnd) /
        sizeof(MOVEWND)); Counter++) {

        hControlWnd = GetDlgItem(hWnd,
            s_EditBinaryValueMoveWnd[Counter].ControlID);

        GetWindowRect(hControlWnd, &Rect);

        if (s_EditBinaryValueMoveWnd[Counter].SetWindowPosFlags & SWP_NOSIZE) {

            MapWindowPoints(NULL, hWnd, (LPPOINT) &Rect, 2);
            Rect.left += dxChange;

        }

        else
            Rect.right += dxChange;

        SetWindowPos(hControlWnd, NULL, Rect.left, Rect.top, Rect.right -
            Rect.left, Rect.bottom - Rect.top,
            s_EditBinaryValueMoveWnd[Counter].SetWindowPosFlags);

    }

    return TRUE;

    UNREFERENCED_PARAMETER(hFocusWnd);

}

/*******************************************************************************
*
*  RegisterHexEditClass
*
*  DESCRIPTION:
*     Register the HexEdit window class with the system.
*
*  PARAMETERS:
*     (none).
*
*******************************************************************************/

BOOL
PASCAL
RegisterHexEditClass(
    VOID
    )
{

    WNDCLASS WndClass;

    s_HexEditClipboardFormat =
        RegisterClipboardFormat(s_HexEditClipboardFormatName);

    WndClass.style = CS_DBLCLKS;
    WndClass.lpfnWndProc = HexEditWndProc;
    WndClass.cbClsExtra = 0;
    WndClass.cbWndExtra = 0;
    WndClass.hInstance = g_hInstance;
    WndClass.hIcon = NULL;
    WndClass.hCursor = LoadCursor(NULL, IDC_IBEAM);
    WndClass.hbrBackground = NULL;
    WndClass.lpszMenuName = NULL;
    WndClass.lpszClassName = s_HexEditClassName;

    return (RegisterClass(&WndClass) != 0);

}

/*******************************************************************************
*
*  HexEditWndProc
*
*  DESCRIPTION:
*     Callback procedure for the HexEdit window.
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*     Message,
*     wParam,
*     lParam,
*     (returns),
*
*******************************************************************************/

LRESULT
PASCAL
HexEditWndProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    )
{

    switch (Message) {

        HANDLE_MSG(hWnd, WM_NCCREATE, HexEdit_OnNcCreate);
        HANDLE_MSG(hWnd, WM_SIZE, HexEdit_OnSize);
        HANDLE_MSG(hWnd, WM_VSCROLL, HexEdit_OnVScroll);
        HANDLE_MSG(hWnd, WM_PAINT, HexEdit_OnPaint);
        HANDLE_MSG(hWnd, WM_LBUTTONDOWN, HexEdit_OnLButtonDown);
        HANDLE_MSG(hWnd, WM_LBUTTONDBLCLK, HexEdit_OnLButtonDown);
        HANDLE_MSG(hWnd, WM_MOUSEMOVE, HexEdit_OnMouseMove);
        HANDLE_MSG(hWnd, WM_LBUTTONUP, HexEdit_OnLButtonUp);
        HANDLE_MSG(hWnd, WM_KEYDOWN, HexEdit_OnKey);
        HANDLE_MSG(hWnd, WM_CHAR, HexEdit_OnChar);

        case WM_SETFOCUS:
            HexEdit_OnSetFocus(hWnd);
            break;

        case WM_KILLFOCUS:
            HexEdit_OnKillFocus(hWnd);
            break;

        case WM_TIMER:
            HexEdit_OnMouseMove(hWnd, s_HexEditData.xPrevMessagePos,
                s_HexEditData.yPrevMessagePos, 0);
            break;

        case WM_GETDLGCODE:
            return (LPARAM) (DLGC_WANTCHARS | DLGC_WANTARROWS);

        case WM_ERASEBKGND:
            return TRUE;

        case WM_NCDESTROY:
            DeleteObject(s_HexEditData.hFont);
            break;

        case WM_CONTEXTMENU:
            HexEdit_OnContextMenu(hWnd, LOWORD(lParam), HIWORD(lParam));
            break;

        //  Message: HEM_SETBUFFER
        //  wParam:  Number of bytes in the buffer.
        //  lParam:  Pointer to the buffer.
        case HEM_SETBUFFER:
            s_HexEditData.pBuffer = (PBYTE) lParam;
            s_HexEditData.cbBuffer = (int) wParam;
            s_HexEditData.cbBufferMax = (int) wParam;

            s_HexEditData.CaretIndex = 0;
            s_HexEditData.MinimumSelectedIndex = 0;
            s_HexEditData.MaximumSelectedIndex = 0;

            s_HexEditData.FirstVisibleLine = 0;

            HexEdit_SetScrollInfo(hWnd);

            break;

        default:
            return DefWindowProc(hWnd, Message, wParam, lParam);

    }

    return 0;

}

/*******************************************************************************
*
*  HexEdit_OnNcCreate
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*
*******************************************************************************/

BOOL
PASCAL
HexEdit_OnNcCreate(
    HWND hWnd,
    LPCREATESTRUCT lpCreateStruct
    )
{

    HDC hDC;
    HFONT hPrevFont;
    TEXTMETRIC TextMetric;

    s_HexEditData.cbBuffer = 0;

    //  FEATURE:  Do this symbolically...
    s_HexEditData.Flags = 0;

    s_HexEditData.cxWindow = 0;
    s_HexEditData.cyWindow = 0;

    hDC = GetDC(hWnd);

    s_HexEditFont.lfHeight = -(10 * GetDeviceCaps(hDC, LOGPIXELSY) / 72);

    if ((s_HexEditData.hFont = CreateFontIndirect(&s_HexEditFont)) != NULL) {

        hPrevFont = SelectObject(hDC, s_HexEditData.hFont);
        GetTextMetrics(hDC, &TextMetric);
        SelectObject(hDC, hPrevFont);

        s_HexEditData.FontHeight = TextMetric.tmHeight;

        s_HexEditData.LinesVisible = s_HexEditData.cyWindow /
            s_HexEditData.FontHeight;

        s_HexEditData.FontMaxWidth = TextMetric.tmMaxCharWidth;

        s_HexEditData.xHexDumpByteWidth = s_HexEditData.FontMaxWidth * 3;
        s_HexEditData.xHexDumpStart = s_HexEditData.FontMaxWidth * 11 / 2;
        s_HexEditData.xAsciiDumpStart = s_HexEditData.xHexDumpStart +
            BYTES_PER_HEXEDIT_LINE * s_HexEditData.xHexDumpByteWidth +
            s_HexEditData.FontMaxWidth * 3 / 2;

    }

    ReleaseDC(hWnd, hDC);

    if (s_HexEditData.hFont == NULL)
        return FALSE;

    return (BOOL) DefWindowProc(hWnd, WM_NCCREATE, 0, (LPARAM) lpCreateStruct);

}

/*******************************************************************************
*
*  HexEdit_OnSize
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
PASCAL
HexEdit_OnSize(
    HWND hWnd,
    UINT State,
    int cx,
    int cy
    )
{

    s_HexEditData.cxWindow = cx;
    s_HexEditData.cyWindow = cy;

    s_HexEditData.LinesVisible = cy / s_HexEditData.FontHeight;

    HexEdit_SetScrollInfo(hWnd);

    UNREFERENCED_PARAMETER(State);
    UNREFERENCED_PARAMETER(cx);

}

/*******************************************************************************
*
*  HexEdit_SetScrollInfo
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
PASCAL
HexEdit_SetScrollInfo(
    HWND hWnd
    )
{

    SCROLLINFO ScrollInfo;

    s_HexEditData.MaximumLines = (s_HexEditData.cbBuffer +
        BYTES_PER_HEXEDIT_LINE) / BYTES_PER_HEXEDIT_LINE - 1;

    ScrollInfo.cbSize = sizeof(SCROLLINFO);
    ScrollInfo.fMask = (SIF_RANGE | SIF_PAGE | SIF_POS);
    ScrollInfo.nMin = 0;
    ScrollInfo.nMax = s_HexEditData.MaximumLines;
    ScrollInfo.nPage = s_HexEditData.LinesVisible;
    ScrollInfo.nPos = s_HexEditData.FirstVisibleLine;

    SetScrollInfo(hWnd, SB_VERT, &ScrollInfo, TRUE);

}

/*******************************************************************************
*
*  HexEdit_OnVScroll
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*
*******************************************************************************/

VOID
PASCAL
HexEdit_OnVScroll(
    HWND hWnd,
    HWND hCtlWnd,
    UINT Code,
    int Position
    )
{

    int NewFirstVisibleLine;
    SCROLLINFO ScrollInfo;

    NewFirstVisibleLine = s_HexEditData.FirstVisibleLine;

    switch (Code) {

        case SB_LINEUP:
            NewFirstVisibleLine--;
            break;

        case SB_LINEDOWN:
            NewFirstVisibleLine++;
            break;

        case SB_PAGEUP:
            NewFirstVisibleLine -= s_HexEditData.LinesVisible;
            break;

        case SB_PAGEDOWN:
            NewFirstVisibleLine += s_HexEditData.LinesVisible;
            break;

        case SB_THUMBTRACK:
        case SB_THUMBPOSITION:
            NewFirstVisibleLine = Position;
            break;

    }

    //
    //  Change the scroll bar position.  Note that SetScrollInfo will take into
    //  account the clipping between zero and the maximum value.  It will also
    //  return the final scroll bar position.
    //

    ScrollInfo.cbSize = sizeof(SCROLLINFO);
    ScrollInfo.fMask = SIF_POS;
    ScrollInfo.nPos = NewFirstVisibleLine;

    NewFirstVisibleLine = SetScrollInfo(hWnd, SB_VERT, &ScrollInfo, TRUE);

    if (s_HexEditData.FirstVisibleLine != NewFirstVisibleLine) {

        ScrollWindowEx(hWnd, 0, (s_HexEditData.FirstVisibleLine -
            NewFirstVisibleLine) * s_HexEditData.FontHeight, NULL, NULL, NULL,
            NULL, SW_INVALIDATE);

        s_HexEditData.FirstVisibleLine = NewFirstVisibleLine;

        HexEdit_SetCaretPosition(hWnd);

    }

    UNREFERENCED_PARAMETER(hCtlWnd);

}

/*******************************************************************************
*
*  HexEdit_OnPaint
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*
*******************************************************************************/

VOID
PASCAL
HexEdit_OnPaint(
    HWND hWnd
    )
{

    PAINTSTRUCT PaintStruct;

    BeginPaint(hWnd, &PaintStruct);

    HexEdit_PaintRect(PaintStruct.hdc, &PaintStruct.rcPaint);

    EndPaint(hWnd, &PaintStruct);

}

/*******************************************************************************
*
*  HexEdit_PaintRect
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
PASCAL
HexEdit_PaintRect(
    HDC hDC,
    LPRECT lpUpdateRect
    )
{

    HFONT hPrevFont;
    int CurrentByteIndex;
    BYTE Byte;
    int CurrentLine;
    int LastLine;
    int BytesOnLastLine;
    int BytesOnLine;
    BOOL fUsingHighlight;
    int Counter;
    TCHAR Buffer[5];                     //  Room for four hex digits plus null
    RECT TextRect;
    RECT AsciiTextRect;
    int x;

    if (s_HexEditData.hFont)
        hPrevFont = SelectFont(hDC, s_HexEditData.hFont);

    SetBkColor(hDC, g_clrWindow);
    SetTextColor(hDC, g_clrWindowText);

    //
    //  Figure out the range of lines of the control that must be painted.
    //  Using this information we can compute the offset into the buffer to
    //  start reading from.
    //

    CurrentLine = lpUpdateRect-> top / s_HexEditData.FontHeight;

    TextRect.bottom = CurrentLine * s_HexEditData.FontHeight;
    AsciiTextRect.bottom = TextRect.bottom;

    CurrentByteIndex = (s_HexEditData.FirstVisibleLine + CurrentLine) *
        BYTES_PER_HEXEDIT_LINE;

    LastLine = lpUpdateRect-> bottom / s_HexEditData.FontHeight;

    //
    //  Figure out if there's enough in the buffer to fill up the entire window
    //  and the last line that we paint.
    //

    if (LastLine >= s_HexEditData.MaximumLines -
        s_HexEditData.FirstVisibleLine) {

        LastLine = s_HexEditData.MaximumLines - s_HexEditData.FirstVisibleLine;

        BytesOnLastLine = s_HexEditData.cbBuffer % BYTES_PER_HEXEDIT_LINE;

    }

    else
        BytesOnLastLine = BYTES_PER_HEXEDIT_LINE;

    BytesOnLine = BYTES_PER_HEXEDIT_LINE;
    fUsingHighlight = FALSE;

    //
    //  Loop through each of the lines to be displayed.
    //

    while (CurrentLine <= LastLine) {

        //
        //  If we're on the last line of the display and this is at the end
        //  of the buffer, we may not have a complete line to paint.
        //

        if (CurrentLine == LastLine)
            BytesOnLine = BytesOnLastLine;

        TextRect.top = TextRect.bottom;
        TextRect.bottom += s_HexEditData.FontHeight;

        TextRect.left = 0;
        TextRect.right = s_HexEditData.xHexDumpStart;

        x = TextRect.right + s_HexEditData.FontMaxWidth / 2;

        wsprintf(Buffer, s_HexWordFormatSpec, CurrentByteIndex);
        ExtTextOut(hDC, 0, TextRect.top, ETO_OPAQUE, &TextRect, Buffer, 4,
            NULL);

        AsciiTextRect.top = AsciiTextRect.bottom;
        AsciiTextRect.bottom += s_HexEditData.FontHeight;
        AsciiTextRect.right = s_HexEditData.xAsciiDumpStart;

        for (Counter = 0; Counter < BytesOnLine; Counter++,
            CurrentByteIndex++) {

            //
            //  Determine what colors to use to paint the current byte.
            //

            if (CurrentByteIndex >= s_HexEditData.MinimumSelectedIndex) {

                if (CurrentByteIndex >= s_HexEditData.MaximumSelectedIndex) {

                    if (fUsingHighlight) {

                        fUsingHighlight = FALSE;

                        SetBkColor(hDC, g_clrWindow);
                        SetTextColor(hDC, g_clrWindowText);

                    }

                }

                else {

                    if (!fUsingHighlight) {

                        fUsingHighlight = TRUE;

                        SetBkColor(hDC, g_clrHighlight);
                        SetTextColor(hDC, g_clrHighlightText);

                    }

                }

            }

            Byte = s_HexEditData.pBuffer[CurrentByteIndex];

            //
            //  Paint the hexadecimal representation.
            //

            TextRect.left = TextRect.right;
            TextRect.right += s_HexEditData.xHexDumpByteWidth;

            wsprintf(Buffer, s_HexByteFormatSpec, Byte);

            ExtTextOut(hDC, x, TextRect.top, ETO_OPAQUE, &TextRect,
                Buffer, 2, NULL);

            x += s_HexEditData.xHexDumpByteWidth;

            //
            //  Paint the ASCII representation.
            //

            AsciiTextRect.left = AsciiTextRect.right;
            AsciiTextRect.right += s_HexEditData.FontMaxWidth;

            Buffer[0] = (TCHAR) (((Byte & 0x7F) >= TEXT(' ')) ? Byte : TEXT('.'));

            ExtTextOut(hDC, AsciiTextRect.left, AsciiTextRect.top, ETO_OPAQUE,
                &AsciiTextRect, Buffer, 1, NULL);

        }

        //
        //  Paint any leftover strips between the hexadecimal and ASCII columns
        //  and the ASCII column and the right edge of the window.
        //

        if (fUsingHighlight) {

            fUsingHighlight = FALSE;

            SetBkColor(hDC, g_clrWindow);
            SetTextColor(hDC, g_clrWindowText);

        }

        TextRect.left = TextRect.right;
        TextRect.right = s_HexEditData.xAsciiDumpStart;

        ExtTextOut(hDC, TextRect.left, TextRect.top, ETO_OPAQUE, &TextRect,
            NULL, 0, NULL);

        AsciiTextRect.left = AsciiTextRect.right;
        AsciiTextRect.right = s_HexEditData.cxWindow;

        ExtTextOut(hDC, AsciiTextRect.left, AsciiTextRect.top, ETO_OPAQUE,
            &AsciiTextRect, NULL, 0, NULL);

        CurrentLine++;

    }

    //
    //  Paint any remaining space in the control by filling it with the
    //  background color.
    //

    if (TextRect.bottom < lpUpdateRect-> bottom) {

        TextRect.left = 0;
        TextRect.right = s_HexEditData.cxWindow;
        TextRect.top = TextRect.bottom;
        TextRect.bottom = lpUpdateRect-> bottom;

        ExtTextOut(hDC, 0, TextRect.top, ETO_OPAQUE, &TextRect, NULL, 0, NULL);

    }

    if (s_HexEditData.hFont)
        SelectFont(hDC, hPrevFont);

}

/*******************************************************************************
*
*  HexEdit_OnSetFocus
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*
*******************************************************************************/

VOID
PASCAL
HexEdit_OnSetFocus(
    HWND hWnd
    )
{

    s_HexEditData.Flags |= HEF_FOCUS;

    CreateCaret(hWnd, NULL, 0, s_HexEditData.FontHeight);
    HexEdit_SetCaretPosition(hWnd);
    ShowCaret(hWnd);

}

/*******************************************************************************
*
*  HexEdit_OnKillFocus
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*
*******************************************************************************/

VOID
PASCAL
HexEdit_OnKillFocus(
    HWND hWnd
    )
{

    if (s_HexEditData.Flags & HEF_FOCUS) {

        s_HexEditData.Flags &= ~HEF_FOCUS;

        DestroyCaret();

    }

}

/*******************************************************************************
*
*  HexEdit_OnLButtonDown
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*     fDoubleClick, TRUE if this is a double-click message, else FALSE.
*     x, x-coordinate of the cursor relative to the client area.
*     y, y-coordinate of the cursor relative to the client area.
*     KeyFlags, state of various virtual keys.
*
*******************************************************************************/

VOID
PASCAL
HexEdit_OnLButtonDown(
    HWND hWnd,
    BOOL fDoubleClick,
    int x,
    int y,
    UINT KeyFlags
    )
{

    int NewCaretIndex;

    if (fDoubleClick) {

        HexEdit_ChangeCaretIndex(hWnd, s_HexEditData.CaretIndex + 1, TRUE);
        return;

    }

    NewCaretIndex = HexEdit_HitTest(x, y);

    HexEdit_ChangeCaretIndex(hWnd, NewCaretIndex, (KeyFlags & MK_SHIFT));

    //
    //  If we don't already have the focus, try to get it.
    //

    if (!(s_HexEditData.Flags & HEF_FOCUS))
        SetFocus(hWnd);

    SetCapture(hWnd);
    s_HexEditData.Flags |= HEF_DRAGGING;

    s_HexEditData.xPrevMessagePos = x;
    s_HexEditData.yPrevMessagePos = y;

    SetTimer(hWnd, 1, 400, NULL);

    UNREFERENCED_PARAMETER(fDoubleClick);

}

/*******************************************************************************
*
*  HexEdit_OnMouseMove
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*     x, x-coordinate of the cursor relative to the client area.
*     y, y-coordinate of the cursor relative to the client area.
*     KeyFlags, state of various virtual keys.
*
*******************************************************************************/

VOID
PASCAL
HexEdit_OnMouseMove(
    HWND hWnd,
    int x,
    int y,
    UINT KeyFlags
    )
{

    int NewCaretIndex;

    if (!(s_HexEditData.Flags & HEF_DRAGGING))
        return;

    NewCaretIndex = HexEdit_HitTest(x, y);

    HexEdit_ChangeCaretIndex(hWnd, NewCaretIndex, TRUE);

    s_HexEditData.xPrevMessagePos = x;
    s_HexEditData.yPrevMessagePos = y;

    {

    int i, j;

    i = y < 0 ? -y : y - s_HexEditData.cyWindow;
    j = 400 - ((UINT)i << 4);
    if (j < 100)
        j = 100;
    SetTimer(hWnd, 1, j, NULL);

    }

    UNREFERENCED_PARAMETER(KeyFlags);

}

/*******************************************************************************
*
*  HexEdit_OnLButtonUp
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*     x, x-coordinate of the cursor relative to the client area.
*     y, y-coordinate of the cursor relative to the client area.
*     KeyFlags, state of various virtual keys.
*
*******************************************************************************/

VOID
PASCAL
HexEdit_OnLButtonUp(
    HWND hWnd,
    int x,
    int y,
    UINT KeyFlags
    )
{

    if (!(s_HexEditData.Flags & HEF_DRAGGING))
        return;

    KillTimer(hWnd, 1);

    ReleaseCapture();
    s_HexEditData.Flags &= ~HEF_DRAGGING;

    UNREFERENCED_PARAMETER(x);
    UNREFERENCED_PARAMETER(y);
    UNREFERENCED_PARAMETER(KeyFlags);

}

/*******************************************************************************
*
*  HexEdit_HitTest
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     x, x-coordinate of the cursor relative to the client area.
*     y, y-coordinate of the cursor relative to the client area.
*     (returns), index of "hit" byte.
*
*******************************************************************************/

int
PASCAL
HexEdit_HitTest(
    int x,
    int y
    )
{

    int HitLine;
    int BytesOnHitLine;
    int HitByte;

    //
    //  Figure out which line the user clicked on and how many bytes are on that
    //  line.
    //

    if (y < 0)
        HitLine = -1;

    else if (y >= s_HexEditData.cyWindow)
        HitLine = s_HexEditData.LinesVisible + 1;

    else
        HitLine = y / s_HexEditData.FontHeight;

    HitLine += s_HexEditData.FirstVisibleLine;

    if (HitLine >= s_HexEditData.MaximumLines) {

        HitLine = s_HexEditData.MaximumLines;

        BytesOnHitLine = (s_HexEditData.cbBuffer + 1) %
            BYTES_PER_HEXEDIT_LINE;

        if (BytesOnHitLine == 0)
            BytesOnHitLine = BYTES_PER_HEXEDIT_LINE;

    }

    else {

        if (HitLine < 0)
            HitLine = 0;

        BytesOnHitLine = BYTES_PER_HEXEDIT_LINE;

    }

    //
    //
    //

    if (x < s_HexEditData.xHexDumpStart)
        x = s_HexEditData.xHexDumpStart;

    if (x >= s_HexEditData.xHexDumpStart && x <
        s_HexEditData.xHexDumpStart + s_HexEditData.xHexDumpByteWidth *
        BYTES_PER_HEXEDIT_LINE + s_HexEditData.FontMaxWidth) {

        x -= s_HexEditData.xHexDumpStart;

        HitByte = x / s_HexEditData.xHexDumpByteWidth;

        s_HexEditData.Flags &= ~HEF_CARETINASCIIDUMP;

    }

    else {

        HitByte = (x - (s_HexEditData.xAsciiDumpStart -
            s_HexEditData.FontMaxWidth / 2)) / s_HexEditData.FontMaxWidth;

        s_HexEditData.Flags |= HEF_CARETINASCIIDUMP;

    }

    //
    //  We allow the user to "hit" the first byte of any line via two ways:
    //      *  clicking before the first byte on that line.
    //      *  clicking beyond the last byte/character of either display of the
    //         previous line.
    //
    //  We would like to see the latter case so that dragging in the control
    //  works naturally-- it's possible to drag to the end of the line to select
    //  the entire range.
    //

    s_HexEditData.Flags &= ~HEF_CARETATENDOFLINE;

    if (HitByte >= BytesOnHitLine) {

        if (BytesOnHitLine == BYTES_PER_HEXEDIT_LINE) {

            HitByte = BYTES_PER_HEXEDIT_LINE;
            s_HexEditData.Flags |= HEF_CARETATENDOFLINE;

        }

        else
            HitByte = BytesOnHitLine - 1;

    }

    return HitLine * BYTES_PER_HEXEDIT_LINE + HitByte;

}

/*******************************************************************************
*
*  HexEdit_OnKey
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*     Char,
*     cRepeat,
*
*******************************************************************************/

VOID
PASCAL
HexEdit_OnKey(
    HWND hWnd,
    UINT VirtualKey,
    BOOL fDown,
    int cRepeat,
    UINT Flags
    )
{

    BOOL fControlDown;
    BOOL fShiftDown;
    int NewCaretIndex;
    UINT ScrollCode;

    fControlDown = (GetKeyState(VK_CONTROL) < 0);
    fShiftDown = (GetKeyState(VK_SHIFT) < 0);

    NewCaretIndex = s_HexEditData.CaretIndex;

    switch (VirtualKey) {

        case VK_UP:
            if (fControlDown)
                break;

            NewCaretIndex -= BYTES_PER_HEXEDIT_LINE;
            goto onkey_CheckLowerBound;

        case VK_DOWN:
            if (fControlDown)
                break;

            NewCaretIndex += BYTES_PER_HEXEDIT_LINE;

            if (NewCaretIndex / BYTES_PER_HEXEDIT_LINE >
                s_HexEditData.MaximumLines) {

                if (s_HexEditData.Flags & HEF_CARETATENDOFLINE)
                    goto onkey_MoveToEndOfBuffer;

                break;

            }

            goto onkey_CheckUpperBound;

        case VK_HOME:
            if (fControlDown)
                NewCaretIndex = 0;

            else {

                if (s_HexEditData.Flags & HEF_CARETATENDOFLINE)
                    NewCaretIndex -= BYTES_PER_HEXEDIT_LINE;

                else
                    NewCaretIndex &= (~BYTES_PER_HEXEDIT_LINE_MASK);

            }

            s_HexEditData.Flags &= ~HEF_CARETATENDOFLINE;

            goto onkey_ChangeCaretIndex;

        case VK_END:
            if (fControlDown) {

onkey_MoveToEndOfBuffer:
                s_HexEditData.Flags &= ~HEF_CARETATENDOFLINE;
                NewCaretIndex = s_HexEditData.cbBuffer;

            }

            else {

                if (s_HexEditData.Flags & HEF_CARETATENDOFLINE)
                    break;

                NewCaretIndex = (NewCaretIndex &
                    (~BYTES_PER_HEXEDIT_LINE_MASK)) + BYTES_PER_HEXEDIT_LINE;

                if (NewCaretIndex > s_HexEditData.cbBuffer)
                    NewCaretIndex = s_HexEditData.cbBuffer;

                else
                    s_HexEditData.Flags |= HEF_CARETATENDOFLINE;

            }

            goto onkey_ChangeCaretIndex;

        case VK_PRIOR:
        case VK_NEXT:
            NewCaretIndex -= s_HexEditData.FirstVisibleLine *
                BYTES_PER_HEXEDIT_LINE;

            ScrollCode = ((VirtualKey == VK_PRIOR) ? SB_PAGEUP : SB_PAGEDOWN);

            HexEdit_OnVScroll(hWnd, NULL, ScrollCode, 0);

            NewCaretIndex += s_HexEditData.FirstVisibleLine *
                BYTES_PER_HEXEDIT_LINE;

            if (VirtualKey == VK_PRIOR)
                goto onkey_CheckLowerBound;

            else
                goto onkey_CheckUpperBound;

        case VK_LEFT:
            s_HexEditData.Flags &= ~HEF_CARETATENDOFLINE;
            NewCaretIndex--;

onkey_CheckLowerBound:
            if (NewCaretIndex < 0)
                break;

            goto onkey_ChangeCaretIndex;

        case VK_RIGHT:
            s_HexEditData.Flags &= ~HEF_CARETATENDOFLINE;
            NewCaretIndex++;

onkey_CheckUpperBound:
            if (NewCaretIndex > s_HexEditData.cbBuffer)
                NewCaretIndex = s_HexEditData.cbBuffer;

onkey_ChangeCaretIndex:
            HexEdit_ChangeCaretIndex(hWnd, NewCaretIndex, fShiftDown);
            break;

        case VK_DELETE:
            if (!fControlDown) {

                if (fShiftDown)
                    HexEdit_OnChar(hWnd, IDKEY_CUT, 0);
                else
                    HexEdit_DeleteRange(hWnd, VK_DELETE);

            }
            break;

        case VK_INSERT:
            if (fShiftDown) {

                if (!fControlDown)
                    HexEdit_OnChar(hWnd, IDKEY_PASTE, 0);

            }

            else if (fControlDown)
                HexEdit_OnChar(hWnd, IDKEY_COPY, 0);
            break;

    }

}

/*******************************************************************************
*
*  HexEdit_OnChar
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*     Char,
*     cRepeat,
*
*******************************************************************************/

VOID
PASCAL
HexEdit_OnChar(
    HWND hWnd,
    TCHAR Char,
    int cRepeat
    )
{

    PBYTE pCaretByte;
    BYTE NewCaretByte;
    int PrevCaretIndex;
    RECT UpdateRect;
    BOOL fSuccess = TRUE;

    //
    //  Check for any special control characters.
    //

    switch (Char) {

        case IDKEY_COPY:
            HexEdit_OnCopy(hWnd);
            return;

        case IDKEY_PASTE:
            PrevCaretIndex = s_HexEditData.CaretIndex;

            if (HexEdit_OnPaste(hWnd))
                goto UpdateDisplay;

            return;

        case IDKEY_CUT:
            if (!HexEdit_OnCopy(hWnd))
                return;
            //  FALL THROUGH

        case VK_BACK:
            HexEdit_DeleteRange(hWnd, VK_BACK);
            return;

    }

    //
    //  Validate and convert the typed character depending on the "column" the
    //  user is typing in.
    //

    if (s_HexEditData.Flags & HEF_CARETINASCIIDUMP) {

        if (Char < TEXT(' ')) {

            MessageBeep(MB_OK);
            return;

        }

        NewCaretByte = (BYTE) Char;

    }

    else {

        Char = (CHAR) CharLower((LPTSTR) Char);

        if (Char >= TEXT('0') && Char <= TEXT('9'))
            NewCaretByte = (BYTE) (Char - TEXT('0'));

        else if (Char >= TEXT('a') && Char <= TEXT('f'))
            NewCaretByte = (BYTE) (Char - TEXT('a') + 10);

        else {

            MessageBeep(MB_OK);
            return;

        }

    }

    if (!(s_HexEditData.Flags & HEF_INSERTATLOWNIBBLE)) {

        //
        //  Check to see if we're inserting while a range is selected.  If so,
        //  delete the range and insert at the start of the range.
        //

        if (s_HexEditData.MinimumSelectedIndex !=
            s_HexEditData.MaximumSelectedIndex)
            HexEdit_DeleteRange(hWnd, 0);

        //  Verify that we aren't overruning the value data buffer.
        if (s_HexEditData.cbBuffer >= s_HexEditData.cbBufferMax)
        {
            // need a bigger buffer
            PBYTE pbValueData = LocalReAlloc(s_HexEditData.pBuffer, 
                s_HexEditData.cbBuffer + ALLOCATION_INCR, LMEM_MOVEABLE);

            if (pbValueData)
            {
                s_HexEditData.pBuffer = pbValueData;
                s_HexEditData.cbBufferMax = s_HexEditData.cbBuffer + ALLOCATION_INCR;
            }
            else
            {
                InternalMessageBox(g_hInstance, hWnd, MAKEINTRESOURCE(IDS_EDITVALNOMEMORY),
                    MAKEINTRESOURCE(IDS_EDITVALERRORTITLE), MB_ICONERROR | MB_OK, NULL);
                
                fSuccess = FALSE;
            }
        }

        if (fSuccess)
        {
            //
            //  Make room for the new byte by shifting all bytes after the insertion
            //  point down one byte.
            //

            pCaretByte = s_HexEditData.pBuffer + s_HexEditData.CaretIndex;

            MoveMemory(pCaretByte + 1, pCaretByte, s_HexEditData.cbBuffer -
                s_HexEditData.CaretIndex);

            s_HexEditData.cbBuffer++;

            HexEdit_SetScrollInfo(hWnd);

            if (s_HexEditData.Flags & HEF_CARETINASCIIDUMP)
                *pCaretByte = NewCaretByte;

            else {

                s_HexEditData.Flags |= HEF_INSERTATLOWNIBBLE;

                *pCaretByte = NewCaretByte << 4;

            }
        }

    }

    else {

        s_HexEditData.Flags &= ~HEF_INSERTATLOWNIBBLE;

        *(s_HexEditData.pBuffer + s_HexEditData.CaretIndex) |= NewCaretByte;

    }

    if (fSuccess)
    {

        PrevCaretIndex = s_HexEditData.CaretIndex;

        if (!(s_HexEditData.Flags & HEF_INSERTATLOWNIBBLE)) {

            s_HexEditData.CaretIndex++;

            s_HexEditData.MinimumSelectedIndex = s_HexEditData.CaretIndex;
            s_HexEditData.MaximumSelectedIndex = s_HexEditData.CaretIndex;

        }

UpdateDisplay:
        s_HexEditData.Flags &= ~HEF_CARETATENDOFLINE;
        HexEdit_EnsureCaretVisible(hWnd);

        UpdateRect.left = 0;
        UpdateRect.right = s_HexEditData.cxWindow;
        UpdateRect.top = (PrevCaretIndex / BYTES_PER_HEXEDIT_LINE -
            s_HexEditData.FirstVisibleLine) * s_HexEditData.FontHeight;
        UpdateRect.bottom = s_HexEditData.cyWindow;

        InvalidateRect(hWnd, &UpdateRect, FALSE);
    }
}

/*******************************************************************************
*
*  HexEdit_SetCaretPosition
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*
*******************************************************************************/

VOID
PASCAL
HexEdit_SetCaretPosition(
    HWND hWnd
    )
{

    int CaretByte;
    int xCaret;
    int yCaret;

    CaretByte = s_HexEditData.CaretIndex % BYTES_PER_HEXEDIT_LINE;

    yCaret = (s_HexEditData.CaretIndex / BYTES_PER_HEXEDIT_LINE -
        s_HexEditData.FirstVisibleLine) * s_HexEditData.FontHeight;

    //
    //  Check if caret should really be displayed at the end of the previous
    //  line.
    //

    if (s_HexEditData.Flags & HEF_CARETATENDOFLINE) {

        CaretByte = BYTES_PER_HEXEDIT_LINE;
        yCaret -= s_HexEditData.FontHeight;

    }

    //
    //  Figure out which "column" the user is editing in and thus should have
    //  the caret.
    //

    if (s_HexEditData.Flags & HEF_CARETINASCIIDUMP) {

        xCaret = s_HexEditData.xAsciiDumpStart + CaretByte *
            s_HexEditData.FontMaxWidth;

    }

    else {

        xCaret = s_HexEditData.xHexDumpStart + CaretByte *
            s_HexEditData.xHexDumpByteWidth;

        if (s_HexEditData.Flags & HEF_INSERTATLOWNIBBLE)
            xCaret += s_HexEditData.FontMaxWidth * 3 / 2;

    }

    SetCaretPos(xCaret, yCaret);

}

/*******************************************************************************
*
*  HexEdit_EnsureCaretVisible
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*
*******************************************************************************/

VOID
PASCAL
HexEdit_EnsureCaretVisible(
    HWND hWnd
    )
{

    int CaretLine;
    int LastVisibleLine;
    int Delta;

    if (!(s_HexEditData.Flags & HEF_FOCUS))
        return;

    CaretLine = s_HexEditData.CaretIndex / BYTES_PER_HEXEDIT_LINE;

    //
    //  Check if caret should really be displayed at the end of the previous
    //  line.
    //

    if (s_HexEditData.Flags & HEF_CARETATENDOFLINE)
        CaretLine--;

    LastVisibleLine = s_HexEditData.FirstVisibleLine +
        s_HexEditData.LinesVisible - 1;

    if (CaretLine > LastVisibleLine)
        Delta = LastVisibleLine;

    else if (CaretLine < s_HexEditData.FirstVisibleLine)
        Delta = s_HexEditData.FirstVisibleLine;

    else
        Delta = -1;

    if (Delta != -1) {

        ScrollWindowEx(hWnd, 0, (Delta - CaretLine) * s_HexEditData.FontHeight,
            NULL, NULL, NULL, NULL, SW_INVALIDATE);

        s_HexEditData.FirstVisibleLine += CaretLine - Delta;

        HexEdit_SetScrollInfo(hWnd);

    }

    HexEdit_SetCaretPosition(hWnd);

}

/*******************************************************************************
*
*  HexEdit_ChangeCaretIndex
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*     NewCaretIndex,
*     fExtendSelection,
*
*******************************************************************************/

VOID
PASCAL
HexEdit_ChangeCaretIndex(
    HWND hWnd,
    int NewCaretIndex,
    BOOL fExtendSelection
    )
{

    int PrevMinimumSelectedIndex;
    int PrevMaximumSelectedIndex;
    int Swap;
    int UpdateRectCount;
    RECT UpdateRect[2];
    BOOL fPrevRangeEmpty;
    HDC hDC;
    int Index;

    s_HexEditData.Flags &= ~HEF_INSERTATLOWNIBBLE;

    PrevMinimumSelectedIndex = s_HexEditData.MinimumSelectedIndex;
    PrevMaximumSelectedIndex = s_HexEditData.MaximumSelectedIndex;

    if (fExtendSelection) {

        if (s_HexEditData.CaretIndex == s_HexEditData.MaximumSelectedIndex)
            s_HexEditData.MaximumSelectedIndex = NewCaretIndex;

        else
            s_HexEditData.MinimumSelectedIndex = NewCaretIndex;

        if (s_HexEditData.MinimumSelectedIndex >
            s_HexEditData.MaximumSelectedIndex) {

            Swap = s_HexEditData.MinimumSelectedIndex;
            s_HexEditData.MinimumSelectedIndex =
                s_HexEditData.MaximumSelectedIndex;
            s_HexEditData.MaximumSelectedIndex = Swap;

        }

    }

    else {

        s_HexEditData.MinimumSelectedIndex = NewCaretIndex;
        s_HexEditData.MaximumSelectedIndex = NewCaretIndex;

    }

    s_HexEditData.CaretIndex = NewCaretIndex;

    UpdateRectCount = 0;

    if (s_HexEditData.MinimumSelectedIndex > PrevMinimumSelectedIndex) {

        UpdateRect[0].top = PrevMinimumSelectedIndex;
        UpdateRect[0].bottom = s_HexEditData.MinimumSelectedIndex;

        UpdateRectCount++;

    }

    else if (s_HexEditData.MinimumSelectedIndex < PrevMinimumSelectedIndex) {

        UpdateRect[0].top = s_HexEditData.MinimumSelectedIndex;
        UpdateRect[0].bottom = PrevMinimumSelectedIndex;

        UpdateRectCount++;

    }

    if (s_HexEditData.MaximumSelectedIndex > PrevMaximumSelectedIndex) {

        UpdateRect[UpdateRectCount].top = PrevMaximumSelectedIndex;
        UpdateRect[UpdateRectCount].bottom = s_HexEditData.MaximumSelectedIndex;

        UpdateRectCount++;

    }

    else if (s_HexEditData.MaximumSelectedIndex < PrevMaximumSelectedIndex) {

        UpdateRect[UpdateRectCount].top = s_HexEditData.MaximumSelectedIndex;
        UpdateRect[UpdateRectCount].bottom = PrevMaximumSelectedIndex;

        UpdateRectCount++;

    }

    if (fPrevRangeEmpty = (PrevMinimumSelectedIndex ==
        PrevMaximumSelectedIndex)) {

        UpdateRect[0].top = s_HexEditData.MinimumSelectedIndex;
        UpdateRect[0].bottom = s_HexEditData.MaximumSelectedIndex;

        UpdateRectCount = 1;

    }

    if (s_HexEditData.MinimumSelectedIndex ==
        s_HexEditData.MaximumSelectedIndex) {

        if (!fPrevRangeEmpty) {

            UpdateRect[0].top = PrevMinimumSelectedIndex;
            UpdateRect[0].bottom = PrevMaximumSelectedIndex;

            UpdateRectCount = 1;

        }

        else
            UpdateRectCount = 0;

    }

    if (UpdateRectCount) {

        HideCaret(hWnd);

        hDC = GetDC(hWnd);

        for (Index = 0; Index < UpdateRectCount; Index++) {

            UpdateRect[Index].top = (UpdateRect[Index].top /
                BYTES_PER_HEXEDIT_LINE - s_HexEditData.FirstVisibleLine) *
                s_HexEditData.FontHeight;
            UpdateRect[Index].bottom = (UpdateRect[Index].bottom /
                BYTES_PER_HEXEDIT_LINE - s_HexEditData.FirstVisibleLine + 1) *
                s_HexEditData.FontHeight;

            if (UpdateRect[Index].top >= s_HexEditData.cyWindow ||
                UpdateRect[Index].bottom < 0)
                continue;

            if (UpdateRect[Index].top < 0)
                UpdateRect[Index].top = 0;

            if (UpdateRect[Index].bottom > s_HexEditData.cyWindow)
                UpdateRect[Index].bottom = s_HexEditData.cyWindow;

            HexEdit_PaintRect(hDC, &UpdateRect[Index]);

        }

        ReleaseDC(hWnd, hDC);

        ShowCaret(hWnd);

    }


    HexEdit_EnsureCaretVisible(hWnd);

}

/*******************************************************************************
*
*  HexEdit_DeleteRange
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
PASCAL
HexEdit_DeleteRange(
    HWND hWnd,
    UINT SourceKey
    )
{

    int MinimumSelectedIndex;
    int MaximumSelectedIndex;
    PBYTE pMinimumSelectedByte;
    int Length;
    RECT UpdateRect;

    s_HexEditData.Flags &= ~HEF_CARETATENDOFLINE;

    MinimumSelectedIndex = s_HexEditData.MinimumSelectedIndex;
    MaximumSelectedIndex = min(s_HexEditData.MaximumSelectedIndex, s_HexEditData.cbBuffer);


    //
    //  Check to see if a range is selected.  If not, then artificially create
    //  one based on the key that caused this routine to be called.
    //

    if (MinimumSelectedIndex == MaximumSelectedIndex) {

        if (SourceKey == VK_DELETE || s_HexEditData.Flags &
            HEF_INSERTATLOWNIBBLE) {

            s_HexEditData.Flags &= ~HEF_INSERTATLOWNIBBLE;

            MaximumSelectedIndex++;

            if (MaximumSelectedIndex > s_HexEditData.cbBuffer)
                return;

        }

        else if (SourceKey == VK_BACK) {

            MinimumSelectedIndex--;

            if (MinimumSelectedIndex < 0)
                return;

        }

        else
            return;

    }

    //
    //  Compute where to start deleting from and the number of bytes to delete.
    //

    pMinimumSelectedByte = s_HexEditData.pBuffer + MinimumSelectedIndex;

    Length = MaximumSelectedIndex - MinimumSelectedIndex;

    //
    //  Delete the bytes and update all appropriate window data.
    //

    MoveMemory(pMinimumSelectedByte, pMinimumSelectedByte + Length,
        s_HexEditData.cbBuffer - MaximumSelectedIndex);

    s_HexEditData.cbBuffer -= Length;

    s_HexEditData.CaretIndex = MinimumSelectedIndex;
    s_HexEditData.MinimumSelectedIndex = MinimumSelectedIndex;
    s_HexEditData.MaximumSelectedIndex = MinimumSelectedIndex;

    HexEdit_SetScrollInfo(hWnd);

    //  REARCHITECT:  OnChar has the following same sequence!!!
    HexEdit_EnsureCaretVisible(hWnd);

    UpdateRect.left = 0;
    UpdateRect.right = s_HexEditData.cxWindow;
    UpdateRect.top = (MinimumSelectedIndex / BYTES_PER_HEXEDIT_LINE -
        s_HexEditData.FirstVisibleLine) * s_HexEditData.FontHeight;
    UpdateRect.bottom = s_HexEditData.cyWindow;

    InvalidateRect(hWnd, &UpdateRect, FALSE);

}

/*******************************************************************************
*
*  HexEdit_OnCopy
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*
*******************************************************************************/

BOOL
PASCAL
HexEdit_OnCopy(
    HWND hWnd
    )
{

    BOOL fSuccess;
    int cbClipboardData;
    LPBYTE lpStartByte;
    HANDLE hClipboardData;
    LPHEXEDITCLIPBOARDDATA lpClipboardData;

    fSuccess = FALSE;

    cbClipboardData = s_HexEditData.MaximumSelectedIndex -
        s_HexEditData.MinimumSelectedIndex;

    if (cbClipboardData != 0) {

        lpStartByte = s_HexEditData.pBuffer +
            s_HexEditData.MinimumSelectedIndex;

        if (OpenClipboard(hWnd)) {

            if ((hClipboardData = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE,
                cbClipboardData + sizeof(HEXEDITCLIPBOARDDATA) - 1)) != NULL) {

                lpClipboardData = (LPHEXEDITCLIPBOARDDATA)
                    GlobalLock(hClipboardData);
                CopyMemory(lpClipboardData-> Data, lpStartByte,
                    cbClipboardData);
                lpClipboardData-> cbSize = cbClipboardData;
                GlobalUnlock(hClipboardData);

                EmptyClipboard();
                SetClipboardData(s_HexEditClipboardFormat, hClipboardData);

                fSuccess = TRUE;

            }

            CloseClipboard();

        }

    }

    return fSuccess;

}

/*******************************************************************************
*
*  HexEdit_OnPaste
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*
*******************************************************************************/

BOOL
PASCAL
HexEdit_OnPaste(
    HWND hWnd
    )
{

    BOOL fSuccess = FALSE;
    HANDLE hClipboardData;
    PBYTE pCaretByte;

    if (s_HexEditData.Flags & HEF_INSERTATLOWNIBBLE) 
    {

        s_HexEditData.Flags &= ~HEF_INSERTATLOWNIBBLE;
        s_HexEditData.CaretIndex++;

    }

    if (OpenClipboard(hWnd)) 
    {
        if ((hClipboardData = GetClipboardData(s_HexEditClipboardFormat)) != NULL) 
        {
            LPHEXEDITCLIPBOARDDATA lpClipboardData = (LPHEXEDITCLIPBOARDDATA) GlobalLock(hClipboardData);

            if (lpClipboardData)
            {

                fSuccess = TRUE;
                if (s_HexEditData.cbBuffer + (int)lpClipboardData-> cbSize > s_HexEditData.cbBufferMax)
                {
                    // need a bigger buffer
                    PBYTE pbValueData = LocalReAlloc(s_HexEditData.pBuffer, 
                        s_HexEditData.cbBuffer + lpClipboardData-> cbSize, LMEM_MOVEABLE);

                    if (pbValueData)
                    { 
                        s_HexEditData.pBuffer = pbValueData;
                        s_HexEditData.cbBufferMax = s_HexEditData.cbBuffer + lpClipboardData-> cbSize;
                    }
                    else
                    {
                        InternalMessageBox(g_hInstance, hWnd, MAKEINTRESOURCE(IDS_EDITVALNOMEMORY),
                            MAKEINTRESOURCE(IDS_EDITVALERRORTITLE), MB_ICONERROR | MB_OK, NULL);

                        fSuccess = FALSE;
                    }
                }

                if (fSuccess) 
                {
                    DWORD cbSize;

                    if (s_HexEditData.MinimumSelectedIndex !=
                        s_HexEditData.MaximumSelectedIndex)
                        HexEdit_DeleteRange(hWnd, VK_BACK);

                    //
                    //  Make room for the new bytes by shifting all bytes after the
                    //  the insertion point down the necessary amount.
                    //

                    pCaretByte = s_HexEditData.pBuffer + s_HexEditData.CaretIndex;
                    cbSize = lpClipboardData-> cbSize;

                    MoveMemory(pCaretByte + cbSize, pCaretByte,
                        s_HexEditData.cbBuffer - s_HexEditData.CaretIndex);
                    CopyMemory(pCaretByte, lpClipboardData-> Data, cbSize);

                    s_HexEditData.cbBuffer += cbSize;
                    s_HexEditData.CaretIndex += cbSize;

                    HexEdit_SetScrollInfo(hWnd);
                }
            }

            GlobalUnlock(hClipboardData);

        }

        CloseClipboard();
    }

    return fSuccess;

}

/*******************************************************************************
*
*  HexEdit_OnContextMenu
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*     x, horizontal position of the cursor.
*     y, vertical position of the cursor.
*
*******************************************************************************/

VOID
PASCAL
HexEdit_OnContextMenu(
    HWND hWnd,
    int x,
    int y
    )
{

    HMENU hContextMenu;
    HMENU hContextPopupMenu;
    int MenuCommand;

    //
    //  Give us the focus if we don't already have it.
    //

    if (!(s_HexEditData.Flags & HEF_FOCUS))
        SetFocus(hWnd);

    //
    //  Load the HexEdit context menu from our resources.
    //

    if ((hContextMenu = LoadMenu(g_hInstance,
        MAKEINTRESOURCE(IDM_HEXEDIT_CONTEXT))) == NULL)
        return;

    hContextPopupMenu = GetSubMenu(hContextMenu, 0);

    //
    //  Disable editing menu options as appropriate.
    //

    if (s_HexEditData.MinimumSelectedIndex ==
        s_HexEditData.MaximumSelectedIndex) {

        EnableMenuItem(hContextPopupMenu, IDKEY_COPY, MF_BYCOMMAND | MF_GRAYED);
        EnableMenuItem(hContextPopupMenu, IDKEY_CUT, MF_BYCOMMAND | MF_GRAYED);
        EnableMenuItem(hContextPopupMenu, VK_DELETE, MF_BYCOMMAND | MF_GRAYED);

    }

    if (!IsClipboardFormatAvailable(s_HexEditClipboardFormat))
        EnableMenuItem(hContextPopupMenu, IDKEY_PASTE, MF_BYCOMMAND |
            MF_GRAYED);

    if (s_HexEditData.MinimumSelectedIndex == 0 &&
        s_HexEditData.MaximumSelectedIndex == s_HexEditData.cbBuffer)
        EnableMenuItem(hContextPopupMenu, ID_SELECTALL, MF_BYCOMMAND |
            MF_GRAYED);

    //
    //  Display and handle the selected command.
    //

    MenuCommand = TrackPopupMenuEx(hContextPopupMenu, TPM_RETURNCMD |
        TPM_RIGHTBUTTON | TPM_LEFTALIGN | TPM_TOPALIGN, x, y, hWnd, NULL);

    DestroyMenu(hContextMenu);

    switch (MenuCommand) {

        case IDKEY_COPY:
        case IDKEY_PASTE:
        case IDKEY_CUT:
        case VK_DELETE:
            HexEdit_OnChar(hWnd, (TCHAR) MenuCommand, 0);
            break;

        case ID_SELECTALL:
            s_HexEditData.MinimumSelectedIndex = 0;
            s_HexEditData.MaximumSelectedIndex = s_HexEditData.cbBuffer;
            s_HexEditData.CaretIndex = s_HexEditData.cbBuffer;
            HexEdit_SetCaretPosition(hWnd);
            InvalidateRect(hWnd, NULL, FALSE);
            break;

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\regedit\pch.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       PCH.H
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        05 Mar 1994
*
*  Precompiled header for the Registry Editor.
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  05 Mar 1994 TCS Original implementation.
*  07 Apr 1994 TCS Moved the definitions associated to REGISTRY_ROOT to
*                  REGPORTE.H to be more easily shared by the real mode registry
*                  tool.
*
*******************************************************************************/

#ifndef _INC_PCH
#define _INC_PCH

#define STRICT
#define _INC_OLE
#include <windows.h>
#include <windowsx.h>
#include <shellapi.h>
#include <shlobj.h>
#include <shlobjp.h>
#include <shlwapi.h>
#include <winuserp.h>
#include <comctrlp.h>
#include <memory.h>
#include <regdef.h>
#include "regporte.h"
#include "regmisc.h"
#include "regdebug.h"

#define ARRAYSIZE(x)        (sizeof(x) / sizeof(x[0]))

#define IMAGEINDEX(x)                   ((x) - IDI_FIRSTIMAGE)

typedef struct _EDITVALUEPARAM {
    PTSTR pValueName;
    PBYTE pValueData;
    UINT cbValueData;
}   EDITVALUEPARAM, FAR *LPEDITVALUEPARAM;

typedef struct _PORTVALUEPARAM 
{
    PBYTE pbData;
    UINT cbData;
}   PORTVALUEPARAM, *LPPORTVALUEPARAM;

//  Instance handle of this application.
extern HINSTANCE g_hInstance;

extern TCHAR g_NullString[];

//  TRUE if accelerator table should not be used, such as during a rename
//  operation.
extern BOOL g_fDisableAccelerators;

extern TCHAR g_KeyNameBuffer[MAXKEYNAME];
extern TCHAR g_ValueNameBuffer[MAXVALUENAME_LENGTH];

extern COLORREF g_clrWindow;
extern COLORREF g_clrWindowText;
extern COLORREF g_clrHighlight;
extern COLORREF g_clrHighlightText;

extern PTSTR g_pHelpFileName;

//  Association between the ASCII name and the handle of the registry key.
extern const REGISTRY_ROOT g_RegistryRoots[NUMBER_REGISTRY_ROOTS];

#endif // _INC_PCH
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\regedit\regcdhk.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGCDHK.H
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        05 Mar 1994
*
*  Common dialog box hook functions for the Registry Editor.
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  05 Mar 1994 TCS Original implementation.
*
*******************************************************************************/

#ifndef _INC_REGCDHK
#define _INC_REGCDHK

//  Buffer to store the starting path for a registry export or print operation.
extern TCHAR g_SelectedPath[SIZE_SELECTED_PATH];

//  TRUE if registry operation should be applied to the entire registry or to
//  only start at g_SelectedPath.
extern BOOL g_fRangeAll;

//  Contains the resource identifier for the dialog that is currently being
//  used.  Assumes that there is only one instance of a hook dialog at a time.
extern UINT g_RegCommDlgDialogTemplate;

UINT_PTR
CALLBACK
RegCommDlgHookProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    );

#endif // _INC_REGCDHK
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\regedit\regcdhk.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGCDHK.C
*
*  VERSION:     4.0
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        21 Nov 1993
*
*  Common dialog box hook functions for the Registry Editor.
*
*******************************************************************************/

#include "pch.h"
#include "regedit.h"
#include "regkey.h"
#include "regcdhk.h"
#include "regresid.h"
#include "reghelp.h"

//  Buffer to store the starting path for a registry export or print operation.
TCHAR g_SelectedPath[SIZE_SELECTED_PATH];

//  TRUE if registry operation should be applied to the entire registry or to
//  only start at g_SelectedPath.
BOOL g_fRangeAll;

//  Contains the resource identifier for the dialog that is currently being
//  used.  Assumes that there is only one instance of a hook dialog at a time.
UINT g_RegCommDlgDialogTemplate;

const DWORD s_RegCommDlgExportHelpIDs[] = {
    stc32,                 NO_HELP,
    IDC_EXPORTRANGE,       IDH_REGEDIT_EXPORT,
    IDC_RANGEALL,          IDH_REGEDIT_EXPORT,
    IDC_RANGESELECTEDPATH, IDH_REGEDIT_EXPORT,
    IDC_SELECTEDPATH,      IDH_REGEDIT_EXPORT,

    0, 0
};

const DWORD s_RegCommDlgPrintHelpIDs[] = {
    IDC_EXPORTRANGE,       IDH_REGEDIT_PRINTRANGE,
    IDC_RANGEALL,          IDH_REGEDIT_PRINTRANGE,
    IDC_RANGESELECTEDPATH, IDH_REGEDIT_PRINTRANGE,
    IDC_SELECTEDPATH,      IDH_REGEDIT_PRINTRANGE,

    0, 0
};

BOOL
PASCAL
RegCommDlg_OnInitDialog(
    HWND hWnd,
    HWND hFocusWnd,
    LPARAM lParam
    );

LRESULT
PASCAL
RegCommDlg_OnNotify(
    HWND hWnd,
    int DlgItem,
    LPNMHDR lpNMHdr
    );

UINT_PTR
PASCAL
RegCommDlg_OnCommand(
    HWND hWnd,
    int DlgItem,
    UINT NotificationCode
    );

BOOL
PASCAL
RegCommDlg_ValidateSelectedPath(
    HWND hWnd,
    BOOL fIsFileDialog
    );

/*******************************************************************************
*
*  RegCommDlgHookProc
*
*  DESCRIPTION:
*     Callback procedure for the RegCommDlg common dialog box.
*
*  PARAMETERS:
*     hWnd, handle of RegCommDlg window.
*     Message,
*     wParam,
*     lParam,
*     (returns),
*
*******************************************************************************/

UINT_PTR
CALLBACK
RegCommDlgHookProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    )
{

    int DlgItem;
    const DWORD FAR* lpHelpIDs;

    switch (Message) {

        HANDLE_MSG(hWnd, WM_INITDIALOG, RegCommDlg_OnInitDialog);

        case WM_NOTIFY:
            SetDlgMsgResult(hWnd, WM_NOTIFY, HANDLE_WM_NOTIFY(hWnd, wParam,
                lParam, RegCommDlg_OnNotify));
            return TRUE;

        case WM_COMMAND:
            return RegCommDlg_OnCommand(hWnd, GET_WM_COMMAND_ID(wParam, lParam),
                GET_WM_COMMAND_CMD(wParam, lParam));

        case WM_HELP:
            //
            //  We only want to intercept help messages for controls that we are
            //  responsible for.
            //

            DlgItem = GetDlgCtrlID(((LPHELPINFO) lParam)-> hItemHandle);

            if (DlgItem < IDC_FIRSTREGCOMMDLGID || DlgItem >
                IDC_LASTREGCOMMDLGID)
                break;

            lpHelpIDs = (g_RegCommDlgDialogTemplate == IDD_REGEXPORT) ?
                s_RegCommDlgExportHelpIDs : s_RegCommDlgPrintHelpIDs;

            WinHelp(((LPHELPINFO) lParam)-> hItemHandle, g_pHelpFileName,
                HELP_WM_HELP, (ULONG_PTR) lpHelpIDs);
            return TRUE;

        case WM_CONTEXTMENU:
            //
            //  We only want to intercept help messages for controls that we are
            //  responsible for.
            //

            DlgItem = GetDlgCtrlID((HWND) wParam);

            if (g_RegCommDlgDialogTemplate == IDD_REGEXPORT)
                lpHelpIDs = s_RegCommDlgExportHelpIDs;

            else {

                if (DlgItem < IDC_FIRSTREGCOMMDLGID || DlgItem >
                    IDC_LASTREGCOMMDLGID)
                    break;

                lpHelpIDs = s_RegCommDlgPrintHelpIDs;

            }

            WinHelp((HWND) wParam, g_pHelpFileName, HELP_CONTEXTMENU,
                (ULONG_PTR) lpHelpIDs);
            return TRUE;

    }

    return FALSE;

}

/*******************************************************************************
*
*  RegCommDlg_OnInitDialog
*
*  DESCRIPTION:
*     Initializes the RegCommDlg dialog box.
*
*  PARAMETERS:
*     hWnd, handle of RegCommDlg window.
*     hFocusWnd, handle of control to receive the default keyboard focus.
*     lParam, additional initialization data passed by dialog creation function.
*     (returns), TRUE to set focus to hFocusWnd, else FALSE to prevent a
*        keyboard focus from being set.
*
*******************************************************************************/

BOOL
PASCAL
RegCommDlg_OnInitDialog(
    HWND hWnd,
    HWND hFocusWnd,
    LPARAM lParam
    )
{

    HWND hKeyTreeWnd;
    HTREEITEM hSelectedTreeItem;
    int DlgItem;

    g_RegEditData.uExportFormat = FILE_TYPE_REGEDIT5;

    hKeyTreeWnd = g_RegEditData.hKeyTreeWnd;
    hSelectedTreeItem = TreeView_GetSelection(hKeyTreeWnd);

    KeyTree_BuildKeyPath(hKeyTreeWnd, hSelectedTreeItem, g_SelectedPath,
        BKP_TOSYMBOLICROOT);
    SetDlgItemText(hWnd, IDC_SELECTEDPATH, g_SelectedPath);

    DlgItem = (TreeView_GetParent(hKeyTreeWnd, hSelectedTreeItem) == NULL) ?
        IDC_RANGEALL : IDC_RANGESELECTEDPATH;
    CheckRadioButton(hWnd, IDC_RANGEALL, IDC_RANGESELECTEDPATH, DlgItem);

    return TRUE;

    UNREFERENCED_PARAMETER(hFocusWnd);
    UNREFERENCED_PARAMETER(lParam);

}

/*******************************************************************************
*
*  RegCommDlg_OnNotify
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of RegCommDlg window.
*     DlgItem, identifier of control.
*     lpNMHdr, control notification data.
*
*******************************************************************************/

LRESULT
PASCAL
RegCommDlg_OnNotify(
    HWND hWnd,
    int DlgItem,
    LPNMHDR lpNMHdr
    )
{

    HWND hControlWnd;
    RECT DialogRect;
    RECT ControlRect;
    int dxChange;
    LPOFNOTIFY lpon;

    switch (lpNMHdr-> code) {

        case CDN_INITDONE:
            GetWindowRect(hWnd, &DialogRect);
            // Use window coordinates because it works for mirrored 
            // and non mirrored windows.
            MapWindowPoints(NULL, hWnd, (LPPOINT)&DialogRect, 2);

            hControlWnd = GetDlgItem(hWnd, IDC_EXPORTRANGE);
            GetWindowRect(hControlWnd, &ControlRect);
            MapWindowPoints(NULL, hWnd, (LPPOINT)&ControlRect, 2);

            dxChange = DialogRect.right - ControlRect.right -
                (ControlRect.left - DialogRect.left);

            SetWindowPos(hControlWnd, NULL, 0, 0, ControlRect.right -
                ControlRect.left + dxChange, ControlRect.bottom -
                ControlRect.top, SWP_NOMOVE | SWP_NOZORDER);

            hControlWnd = GetDlgItem(hWnd, IDC_SELECTEDPATH);
            GetWindowRect(hControlWnd, &ControlRect);
            MapWindowPoints(NULL, hWnd, (LPPOINT)&ControlRect, 2);

            SetWindowPos(hControlWnd, NULL, 0, 0, ControlRect.right -
                ControlRect.left + dxChange, ControlRect.bottom -
                ControlRect.top, SWP_NOMOVE | SWP_NOZORDER);

            break;

        case CDN_TYPECHANGE:
            // lpon->lpOFN->nFilterIndex corresponds to the format types in 
            // regdef.h
            lpon = (LPOFNOTIFY) lpNMHdr;
            g_RegEditData.uExportFormat = lpon->lpOFN->nFilterIndex;
            break;

        case CDN_FILEOK:
            return ( RegCommDlg_ValidateSelectedPath(hWnd, TRUE) != FALSE );

    }

    return FALSE;

}

/*******************************************************************************
*
*  RegCommDlg_OnCommand
*
*  DESCRIPTION:
*     Handles the selection of a menu item by the user, notification messages
*     from a child control, or translated accelerated keystrokes for the
*     RegPrint dialog box.
*
*  PARAMETERS:
*     hWnd, handle of RegCommDlg window.
*     DlgItem, identifier of control.
*     NotificationCode, notification code from control.
*
*******************************************************************************/

UINT_PTR
PASCAL
RegCommDlg_OnCommand(
    HWND hWnd,
    int DlgItem,
    UINT NotificationCode
    )
{

    switch (DlgItem) {

        case IDC_RANGESELECTEDPATH:
            SetFocus(GetDlgItem(hWnd, IDC_SELECTEDPATH));
            break;

        case IDC_SELECTEDPATH:
            switch (NotificationCode) {

                case EN_SETFOCUS:
                    SendDlgItemMessage(hWnd, IDC_SELECTEDPATH, EM_SETSEL,
                        0, -1);
                    break;

                case EN_CHANGE:
                    CheckRadioButton(hWnd, IDC_RANGEALL, IDC_RANGESELECTEDPATH,
                        IDC_RANGESELECTEDPATH);
                    break;

            }
            break;

        case IDOK:
            return ( RegCommDlg_ValidateSelectedPath(hWnd, FALSE) != FALSE );

    }

    return FALSE;

}

/*******************************************************************************
*
*  RegCommDlg_ValidateSelectedPath
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of RegCommDlg window.
*     (returns), TRUE if the registry selected path is invalid, else FALSE.
*
*******************************************************************************/

BOOL
PASCAL
RegCommDlg_ValidateSelectedPath(
    HWND hWnd,
    BOOL fIsFileDialog
    )
{

    HKEY hKey;
    HWND hTitleWnd;
    TCHAR Title[256];

    if (!(g_fRangeAll = IsDlgButtonChecked(hWnd, IDC_RANGEALL))) {

        GetDlgItemText(hWnd, IDC_SELECTEDPATH, g_SelectedPath,
            sizeof(g_SelectedPath)/sizeof(TCHAR));

        if (g_SelectedPath[0] == '\0')
            g_fRangeAll = TRUE;

        else 
        {
            HTREEITEM hSelectedTreeItem = TreeView_GetSelection(g_RegEditData.hKeyTreeWnd);
            if (EditRegistryKey(RegEdit_GetComputerItem(hSelectedTreeItem), &hKey, g_SelectedPath, ERK_OPEN) !=
                ERROR_SUCCESS) 
            {

                //
                //  Determine the "real" parent of this dialog and get the
                //  message box title from that window.  Our HWND may really
                //  be a subdialog if we're a file dialog.
                //

                hTitleWnd = fIsFileDialog ? GetParent(hWnd) : hWnd;
                GetWindowText(hTitleWnd, Title, sizeof(Title)/sizeof(TCHAR));
                InternalMessageBox(g_hInstance, hTitleWnd,
                    MAKEINTRESOURCE(IDS_ERRINVALIDREGPATH), Title,
                    MB_ICONERROR | MB_OK);

                return TRUE;

            }

            RegCloseKey(hKey);

        }

    }

    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\regedit\regdebug.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGDEBUG.C
*
*  VERSION:     4.0
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        21 Nov 1993
*
*  Debug routines for the Registry Editor.
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  21 Nov 1993 TCS Original implementation.
*
*******************************************************************************/

#include "pch.h"

#if (!defined(WINNT) && defined(DEBUG)) || (defined(WINNT) && DBG)

#define SIZE_DEBUG_BUFFER               100

/*******************************************************************************
*
*  _DbgPrintf
*
*  DESCRIPTION:
*     Simple implementation of the "debug printf" routine.  Takes the given
*     format string and argument list and outputs the formatted string to the
*     debugger.  Only available in debug builds-- use the DbgPrintf macro
*     defined in REGEDIT.H to access this service or to ignore the printf.
*
*  PARAMETERS:
*     lpFormatString, printf-style format string.
*     ..., variable argument list.
*
*******************************************************************************/

VOID
CDECL
_DbgPrintf(
    PSTR pFormatString,
    ...
    )
{

    va_list arglist;
    CHAR DebugBuffer[SIZE_DEBUG_BUFFER];

    va_start(arglist, pFormatString);

    wvsprintfA(DebugBuffer, pFormatString, arglist);

    OutputDebugStringA(DebugBuffer);
//    MessageBoxA(NULL, DebugBuffer, "RegEdit", MB_OK);

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\regedit\regdebug.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGDEBUG.H
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        05 Mar 1994
*
*  Debug routines for the Registry Editor.
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  05 Mar 1994 TCS Original implementation.
*
*******************************************************************************/

#ifndef _INC_REGDEBUG
#define _INC_REGDEBUG

#if (!defined(WINNT) && defined(DEBUG)) || (defined(WINNT) && DBG)

VOID
CDECL
_DbgPrintf(
    PSTR pFormatString,
    ...
    );

#define DebugPrintf(x)                    _DbgPrintf ##x

#else

#define DebugPrintf(x)

#endif

#endif // _INC_REGDEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\regedit\regdata.cxx ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    regdata.cxx

Abstract:

    This module contains the definition for the REGISTRY_DATA
    class. This class is used to display registry data of type
    REG_RESOURCE_LIST and REG_FULL_RESOURCE_DESCRIPTOR.

Author:

    Jaime Sasson (jaimes) - 30-Nov-1993

Environment:

    Ulib, Regedit, Windows, User Mode

--*/
#include "regdata.hxx"
#include "regdesc.hxx"
#include "regfdesc.hxx"
#include "regresls.hxx"
#include "regiodsc.hxx"
#include "regiodls.hxx"
#include "regioreq.hxx"
#include "iterator.hxx"
#include "regsys.hxx"
#include "regresid.h"

#include <stdio.h>
                      
extern "C" 
{
    #include "clb.h" 
    HINSTANCE g_hInstance;                   
}


//  Definition of the structure used to pass information
//  to the DisplayBinaryDataDialogProc
typedef struct _BUFFER_INFORMATION 
{
    PBYTE   Buffer;
    ULONG   BufferSize;
    BOOL    DisplayValueType;
    ULONG   ValueType;
} BUFFER_INFORMATION, *PBUFFER_INFORMATION;

//  Constants that define buffer sizes for strings that represent a DWORD
//  and a BIG_INT.
//  These constants take into consideration the trailing '0x' and the terminating NUL
//  character.

#define MAX_LENGTH_DWORD_STRING     1+1+8+1     // 0x12345678'\0'
#define MAX_LENGTH_BIG_INT_STRING   1+1+16+1    // 0x1234567812345678'\0'


DEFINE_CONSTRUCTOR( REGISTRY_DATA, OBJECT );

DEFINE_CAST_MEMBER_FUNCTION( REGISTRY_DATA );


//
//  Static data
//
BOOL        REGISTRY_DATA::s_StringsInitialized = FALSE;
PWSTRING    REGISTRY_DATA::s_MsgBusInternal;
PWSTRING    REGISTRY_DATA::s_MsgBusIsa;
PWSTRING    REGISTRY_DATA::s_MsgBusEisa;
PWSTRING    REGISTRY_DATA::s_MsgBusMicroChannel;
PWSTRING    REGISTRY_DATA::s_MsgBusTurboChannel;
PWSTRING    REGISTRY_DATA::s_MsgBusPCIBus;
PWSTRING    REGISTRY_DATA::s_MsgBusVMEBus;
PWSTRING    REGISTRY_DATA::s_MsgBusNuBus;
PWSTRING    REGISTRY_DATA::s_MsgBusPCMCIABus;
PWSTRING    REGISTRY_DATA::s_MsgBusCBus;
PWSTRING    REGISTRY_DATA::s_MsgBusMPIBus;
PWSTRING    REGISTRY_DATA::s_MsgBusMPSABus;
PWSTRING    REGISTRY_DATA::s_MsgInvalid;
PWSTRING    REGISTRY_DATA::s_MsgDevPort;
PWSTRING    REGISTRY_DATA::s_MsgDevInterrupt;
PWSTRING    REGISTRY_DATA::s_MsgDevMemory;
PWSTRING    REGISTRY_DATA::s_MsgDevDma;
PWSTRING    REGISTRY_DATA::s_MsgIntLevelSensitive;
PWSTRING    REGISTRY_DATA::s_MsgIntLatched;
PWSTRING    REGISTRY_DATA::s_MsgMemReadWrite;
PWSTRING    REGISTRY_DATA::s_MsgMemReadOnly;
PWSTRING    REGISTRY_DATA::s_MsgMemWriteOnly;
PWSTRING    REGISTRY_DATA::s_MsgPortMemory;
PWSTRING    REGISTRY_DATA::s_MsgPortPort;
PWSTRING    REGISTRY_DATA::s_MsgShareUndetermined;
PWSTRING    REGISTRY_DATA::s_MsgShareDeviceExclusive;
PWSTRING    REGISTRY_DATA::s_MsgShareDriverExclusive;
PWSTRING    REGISTRY_DATA::s_MsgShareShared;


//------------------------------------------------------------------------------
//  _InitializeStrings
//
//  DESCRIPTION: Initialize all strings used by this class.
//
//  RETURN:  Returns TRUE if the initialization succeeds.
//------------------------------------------------------------------------------
BOOL REGISTRY_DATA::_InitializeStrings()
{
    s_MsgBusInternal       = REGEDIT_BASE_SYSTEM::QueryString( IDS_BUS_INTERNAL, ""      );
    s_MsgBusIsa            = REGEDIT_BASE_SYSTEM::QueryString( IDS_BUS_ISA, ""           );
    s_MsgBusEisa           = REGEDIT_BASE_SYSTEM::QueryString( IDS_BUS_EISA, ""          );
    s_MsgBusMicroChannel   = REGEDIT_BASE_SYSTEM::QueryString( IDS_BUS_MICRO_CHANNEL, "" );
    s_MsgBusTurboChannel   = REGEDIT_BASE_SYSTEM::QueryString( IDS_BUS_TURBO_CHANNEL, "" );
    s_MsgBusPCIBus         = REGEDIT_BASE_SYSTEM::QueryString( IDS_BUS_PCI_BUS, ""       );
    s_MsgBusVMEBus         = REGEDIT_BASE_SYSTEM::QueryString( IDS_BUS_VME_BUS, ""       );
    s_MsgBusNuBus          = REGEDIT_BASE_SYSTEM::QueryString( IDS_BUS_NU_BUS, ""        );
    s_MsgBusPCMCIABus      = REGEDIT_BASE_SYSTEM::QueryString( IDS_BUS_PCMCIA_BUS, ""    );
    s_MsgBusCBus           = REGEDIT_BASE_SYSTEM::QueryString( IDS_BUS_C_BUS, ""         );
    s_MsgBusMPIBus         = REGEDIT_BASE_SYSTEM::QueryString( IDS_BUS_MPI_BUS, ""       );
    s_MsgBusMPSABus        = REGEDIT_BASE_SYSTEM::QueryString( IDS_BUS_MPSA_BUS, ""      );
    s_MsgInvalid           = REGEDIT_BASE_SYSTEM::QueryString( IDS_INVALID, "" );
    s_MsgDevPort           = REGEDIT_BASE_SYSTEM::QueryString( IDS_DEV_PORT, "" );
    s_MsgDevInterrupt      = REGEDIT_BASE_SYSTEM::QueryString( IDS_DEV_INTERRUPT, "" );
    s_MsgDevMemory         = REGEDIT_BASE_SYSTEM::QueryString( IDS_DEV_MEMORY, "" );
    s_MsgDevDma            = REGEDIT_BASE_SYSTEM::QueryString( IDS_DEV_DMA, "" );
    s_MsgIntLevelSensitive = REGEDIT_BASE_SYSTEM::QueryString( IDS_INT_LEVEL_SENSITIVE, "" );
    s_MsgIntLatched        = REGEDIT_BASE_SYSTEM::QueryString( IDS_INT_LATCHED, ""         );
    s_MsgMemReadWrite      = REGEDIT_BASE_SYSTEM::QueryString( IDS_MEM_READ_WRITE, ""      );
    s_MsgMemReadOnly       = REGEDIT_BASE_SYSTEM::QueryString( IDS_MEM_READ_ONLY, ""       );
    s_MsgMemWriteOnly      = REGEDIT_BASE_SYSTEM::QueryString( IDS_MEM_WRITE_ONLY, ""      );
    s_MsgPortMemory        = REGEDIT_BASE_SYSTEM::QueryString( IDS_PORT_MEMORY, "" );
    s_MsgPortPort          = REGEDIT_BASE_SYSTEM::QueryString( IDS_PORT_PORT, "" );
    s_MsgShareUndetermined    = REGEDIT_BASE_SYSTEM::QueryString( IDS_SHARE_UNDETERMINED, ""       );
    s_MsgShareDeviceExclusive = REGEDIT_BASE_SYSTEM::QueryString( IDS_SHARE_DEVICE_EXCLUSIVE, ""      );
    s_MsgShareDriverExclusive = REGEDIT_BASE_SYSTEM::QueryString( IDS_SHARE_DRIVER_EXCLUSIVE, "" );
    s_MsgShareShared          = REGEDIT_BASE_SYSTEM::QueryString( IDS_SHARE_SHARED, "" );

    if ( ( s_MsgBusInternal       == NULL )  ||
         ( s_MsgBusIsa            == NULL )  ||
         ( s_MsgBusEisa           == NULL )  ||
         ( s_MsgBusMicroChannel   == NULL )  ||
         ( s_MsgBusTurboChannel   == NULL )  ||
         ( s_MsgBusPCIBus         == NULL )  ||
         ( s_MsgBusVMEBus         == NULL )  ||
         ( s_MsgBusNuBus          == NULL )  ||
         ( s_MsgBusPCMCIABus      == NULL )  ||
         ( s_MsgBusCBus           == NULL )  ||
         ( s_MsgBusMPIBus         == NULL )  ||
         ( s_MsgBusMPSABus        == NULL )  ||
         ( s_MsgInvalid           == NULL )  ||
         ( s_MsgDevPort           == NULL )  ||
         ( s_MsgDevInterrupt      == NULL )  ||
         ( s_MsgDevMemory         == NULL )  ||
         ( s_MsgDevDma            == NULL )  ||
         ( s_MsgIntLevelSensitive == NULL )  ||
         ( s_MsgIntLatched        == NULL )  ||
         ( s_MsgMemReadWrite      == NULL )  ||
         ( s_MsgMemReadOnly       == NULL )  ||
         ( s_MsgMemWriteOnly      == NULL )  ||
         ( s_MsgPortMemory        == NULL )  ||
         ( s_MsgPortPort          == NULL )  ||
         ( s_MsgShareUndetermined    == NULL )  ||
         ( s_MsgShareDeviceExclusive == NULL )  ||
         ( s_MsgShareDriverExclusive == NULL )  ||
         ( s_MsgShareShared          == NULL )
       ) {

            DELETE( s_MsgBusInternal       );
            DELETE( s_MsgBusIsa            );
            DELETE( s_MsgBusEisa           );
            DELETE( s_MsgBusMicroChannel   );
            DELETE( s_MsgBusTurboChannel   );
            DELETE( s_MsgBusPCIBus         );
            DELETE( s_MsgBusVMEBus         );
            DELETE( s_MsgBusNuBus          );
            DELETE( s_MsgBusPCMCIABus      );
            DELETE( s_MsgBusCBus           );
            DELETE( s_MsgBusMPIBus         );
            DELETE( s_MsgBusMPSABus        );
            DELETE( s_MsgInvalid           );
            DELETE( s_MsgDevPort           );
            DELETE( s_MsgDevInterrupt      );
            DELETE( s_MsgDevMemory         );
            DELETE( s_MsgDevDma            );
            DELETE( s_MsgIntLevelSensitive );
            DELETE( s_MsgIntLatched        );
            DELETE( s_MsgMemReadWrite      );
            DELETE( s_MsgMemReadOnly       );
            DELETE( s_MsgMemWriteOnly      );
            DELETE( s_MsgPortMemory        );
            DELETE( s_MsgPortPort          );
            DELETE( s_MsgShareUndetermined    );
            DELETE( s_MsgShareDeviceExclusive );
            DELETE( s_MsgShareDriverExclusive );
            DELETE( s_MsgShareShared          );

        DebugPrintTrace(( "REGEDT32: Unable to initialize strings on REGISTRY_DATA \n" ));
        s_StringsInitialized = FALSE;
    } else {
        s_StringsInitialized = TRUE;
    }
    return( s_StringsInitialized );
}

VOID DisplayResourceData(HWND hWnd, DWORD dwType, LPEDITVALUEPARAM lpEditValueParam)
{
    REGISTRY_DATA::_DisplayData(hWnd, dwType, lpEditValueParam);
}


//------------------------------------------------------------------------------
//  DisplayResourceData
//
//  DESCRIPTION: Invoke the appropriate dialog that displays registry data of type
//               REG_RESOURCE_LIST and REG_FULL_RESOURCE_DESCRIPTOR.
//
//  PARAMETERS:  hWnd - A handle to the owner window.
//               dwType - Indicates the type of the data to be displayed.
//               EditValueParam - the edit value information
//------------------------------------------------------------------------------
VOID REGISTRY_DATA::_DisplayData(HWND hWnd, DWORD dwType, LPEDITVALUEPARAM lpEditValueParam)
{
    PBYTE pbValueData = lpEditValueParam->pValueData;
    UINT  cbValueData = lpEditValueParam->cbValueData;

    if(!s_StringsInitialized) 
    {
        _InitializeStrings();
    }

    if (s_StringsInitialized)
    {
        switch(dwType) 
        {
        
        case REG_RESOURCE_LIST:
            {
                RESOURCE_LIST ResourceList;
        
                if(ResourceList.Initialize(pbValueData, cbValueData))
                {
                    REGISTRY_DATA::_DisplayResourceList(hWnd, &ResourceList);
                }
            }
            break;
        
        case REG_FULL_RESOURCE_DESCRIPTOR:
            {
                FULL_DESCRIPTOR FullDescriptor;
        
                if(FullDescriptor.Initialize(pbValueData, cbValueData)) 
                {
                    REGISTRY_DATA::_DisplayFullResourceDescriptor( hWnd, &FullDescriptor );
                }
            }
            break;
        
        case REG_RESOURCE_REQUIREMENTS_LIST:
            {
                IO_REQUIREMENTS_LIST RequirementsList;

                if( RequirementsList.Initialize(pbValueData, cbValueData)) 
                {
                    REGISTRY_DATA::_DisplayRequirementsList( hWnd, &RequirementsList );
                }
            }
            break;  
        }
    }
}


//------------------------------------------------------------------------------
//  _DisplayResourceList
//
//  DESCRIPTION: Invoke the  dialog that displays registry data of type
//               REG_RESOURCE_LIST 
//
//  PARAMETERS:  hWnd - A handle to the owner window.
//               pResourceList - Pointer to a RESOURCE_LIST object to be displayed.
//------------------------------------------------------------------------------
VOID REGISTRY_DATA::_DisplayResourceList(HWND hWnd, PCRESOURCE_LIST pResourceList)
{
    DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_RESOURCE_LIST), hWnd,
                   (DLGPROC)REGISTRY_DATA::_DisplayResourceListDialogProc,
                   (DWORD_PTR) pResourceList);
}


//------------------------------------------------------------------------------
//  _DisplayFullResourceDescriptor
//
//  DESCRIPTION: Invoke the  dialog that displays registry data of type
//               REG_FULL_RESOURCE_DESCRIPTOR.
//
//  PARAMETERS:  hWnd - A handle to the owner window.
//               pFullDescriptor - Pointer to a FULL_DESCRIPTOR object to be displayed.
//------------------------------------------------------------------------------
VOID REGISTRY_DATA::_DisplayFullResourceDescriptor(HWND hWnd, PCFULL_DESCRIPTOR pFullDescriptor)
{
    DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_FULL_RES_DESCRIPTOR), hWnd,
                   (DLGPROC)REGISTRY_DATA::_DisplayFullResourceDescriptorDialogProc,
                   (DWORD_PTR) pFullDescriptor);
}


//------------------------------------------------------------------------------
//  _DisplayRequirementsList
//
//  DESCRIPTION: Invoke the  dialog that displays registry data of type
//               REG_IO_RESOURCE_REQUIREMENTS_LIST.
//
//  PARAMETERS:  hWnd - A handle to the owner window.
//               pRequirementsList - Pointer to an IO_REQUIREMENTS_LIST object to be displayed.
//------------------------------------------------------------------------------
VOID REGISTRY_DATA::_DisplayRequirementsList(HWND hWnd, PCIO_REQUIREMENTS_LIST  pRequirementsList)
{
    DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_IO_REQUIREMENTS_LIST), hWnd,
                   (DLGPROC)REGISTRY_DATA::_DisplayRequirementsListDialogProc,
                   (DWORD_PTR) pRequirementsList );
}


//------------------------------------------------------------------------------
//  _DisplayIoDescriptor
//
//  DESCRIPTION: Invoke appropriate that displays a Port, Memory, Interrupt or DMA,
//               depending on the type of the object received as parameter.
//
//  PARAMETERS:  hWnd - A handle to the owner window.
//               pIODescriptor - Pointer to the object to be displayed.
//------------------------------------------------------------------------------
VOID REGISTRY_DATA::_DisplayIoDescriptor(HWND hWnd, PCIO_DESCRIPTOR pIODescriptor)
{
    DLGPROC     Pointer;
    LPCWSTR     Template;

    if(pIODescriptor->IsDescriptorTypePort()) 
    {
        Pointer = (DLGPROC)REGISTRY_DATA::_DisplayIoPortDialogProc;
        Template = MAKEINTRESOURCE(IDD_IO_PORT_RESOURCE);
    } 
    else if(pIODescriptor->IsDescriptorTypeMemory()) 
    {
        Pointer = (DLGPROC)REGISTRY_DATA::_DisplayIoMemoryDialogProc;
        Template = MAKEINTRESOURCE(IDD_IO_MEMORY_RESOURCE);
    } 
    else if(pIODescriptor->IsDescriptorTypeInterrupt()) 
    {
        Pointer = (DLGPROC)REGISTRY_DATA::_DisplayIoInterruptDialogProc;
        Template = MAKEINTRESOURCE(IDD_IO_INTERRUPT_RESOURCE);
    } 
    else if(pIODescriptor->IsDescriptorTypeDma()) 
    {
        Pointer = (DLGPROC)REGISTRY_DATA::_DisplayIoDmaDialogProc;
        Template = MAKEINTRESOURCE(IDD_IO_DMA_RESOURCE);
    } 
    else 
    {
        Pointer = NULL;
    }

    if(Pointer) 
    {
        DialogBoxParam(g_hInstance, Template, hWnd, Pointer, (DWORD_PTR)pIODescriptor );
    }
}

//------------------------------------------------------------------------------
//  _DisplayResourceListDialogProc
//
//  DESCRIPTION: The dialog proceedure for displaying data of type REG_RESOURCE_LIST.
//
//  PARAMETERS:  hDlg - a handle to the dialog proceedure.
//               Msg - the message passed from Windows.
//               wParam - extra message dependent data.
//               lParam - extra message dependent data.
//------------------------------------------------------------------------------
BOOL REGISTRY_DATA::_DisplayResourceListDialogProc(HWND hDlg, DWORD dwMsg, WPARAM wParam,
                                                   LPARAM lParam)
{
    switch(dwMsg) 
    {
    case WM_INITDIALOG:
        {
            LPCWSTR             InterfaceString;
            ULONG               StringSize;
            WCHAR               BusNumber[ MAX_LENGTH_DWORD_STRING ];
            PARRAY              Descriptors;
            PITERATOR           Iterator;
            PCFULL_DESCRIPTOR   FullResourceDescriptor;
            PCRESOURCE_LIST     pResourceList;

            CLB_ROW         ClbRow;
            CLB_STRING      ClbString[ ] = {{ BusNumber, 0, CLB_LEFT, NULL },
                                            { NULL,      0, CLB_LEFT, NULL }};

            ULONG Widths[] = {14, ( ULONG ) -1};

            if (((pResourceList = (PCRESOURCE_LIST)lParam) == NULL) ||
                ((Descriptors = pResourceList->GetFullResourceDescriptors()) == NULL) ||
                ((Iterator = Descriptors->QueryIterator()) == NULL )) 
            {
                EndDialog( hDlg, 0 );
                return( TRUE );
            }
            
            ClbSetColumnWidths(hDlg, IDC_LIST_RESOURCE_LISTS, Widths );

            while( ( FullResourceDescriptor = ( PCFULL_DESCRIPTOR )Iterator->GetNext() ) != NULL ) 
            {
                switch( FullResourceDescriptor->GetInterfaceType() ) 
                {
                case Internal:
                    InterfaceString = s_MsgBusInternal->GetWSTR();
                    StringSize = s_MsgBusInternal->QueryChCount();
                    break;

                case Isa:
                    InterfaceString = s_MsgBusIsa->GetWSTR();
                    StringSize = s_MsgBusIsa->QueryChCount();
                    break;

                case Eisa:
                    InterfaceString = s_MsgBusEisa->GetWSTR();
                    StringSize = s_MsgBusEisa->QueryChCount();
                    break;

                case MicroChannel:
                    InterfaceString = s_MsgBusMicroChannel->GetWSTR();
                    StringSize = s_MsgBusMicroChannel->QueryChCount();
                    break;

                case TurboChannel:
                    InterfaceString = s_MsgBusTurboChannel->GetWSTR();
                    StringSize =  s_MsgBusTurboChannel->QueryChCount();
                    break;

                case PCIBus:
                    InterfaceString = s_MsgBusPCIBus->GetWSTR();
                    StringSize =  s_MsgBusPCIBus->QueryChCount();
                    break;

                case VMEBus:
                    InterfaceString = s_MsgBusVMEBus->GetWSTR();
                    StringSize = s_MsgBusVMEBus->QueryChCount();
                    break;

                case NuBus:
                    InterfaceString = s_MsgBusNuBus->GetWSTR();
                    StringSize =  s_MsgBusNuBus->QueryChCount();
                    break;

                case PCMCIABus:
                    InterfaceString = s_MsgBusPCMCIABus->GetWSTR();
                    StringSize = s_MsgBusPCMCIABus->QueryChCount();
                    break;

                case CBus:
                    InterfaceString = s_MsgBusCBus->GetWSTR();
                    StringSize = s_MsgBusCBus->QueryChCount();
                    break;

                case MPIBus:
                    InterfaceString = s_MsgBusMPIBus->GetWSTR();
                    StringSize = s_MsgBusMPIBus->QueryChCount();
                    break;

                case MPSABus:
                    InterfaceString = s_MsgBusMPSABus->GetWSTR();
                    StringSize = s_MsgBusMPSABus->QueryChCount();
                    break;

                default:
                    InterfaceString = s_MsgInvalid->GetWSTR();
                    StringSize = s_MsgInvalid->QueryChCount();
                    break;
                }

                swprintf( BusNumber, ( LPWSTR )L"%d", FullResourceDescriptor->GetBusNumber() );

                ClbString[ 0 ].Length = wcslen( BusNumber );
                ClbString[ 0 ].Format = CLB_LEFT;
                ClbString[ 1 ].String = ( LPWSTR )InterfaceString;
                ClbString[ 1 ].Format = CLB_LEFT;
                ClbString[ 1 ].Length = StringSize;

                ClbRow.Count = 2;
                ClbRow.Strings = ClbString;
                ClbRow.Data = ( PVOID )FullResourceDescriptor;

                ClbAddData(hDlg, IDC_LIST_RESOURCE_LISTS, &ClbRow );

            }
            DELETE(Iterator);

            // Disble the Display button
            EnableWindow( GetDlgItem( hDlg, IDC_PUSH_DISPLAY_RESOURCES ), FALSE );
            return( TRUE );
        }

    case WM_COMPAREITEM:
        {
            LPCOMPAREITEMSTRUCT     lpcis;
            LPCLB_ROW               ClbRow1;
            LPCLB_ROW               ClbRow2;
            LONG                    Compare;

            PCFULL_DESCRIPTOR       FullDescriptor1;
            PCFULL_DESCRIPTOR       FullDescriptor2;

            PWSTR                   String1;
            PWSTR                   String2;

            lpcis = ( LPCOMPAREITEMSTRUCT ) lParam;

            //
            // Extract the rows to be compared.
            // First compare by bus number, and if they
            // are equal, compare by interface type
            //

            ClbRow1 = ( LPCLB_ROW ) lpcis->itemData1;
            ClbRow2 = ( LPCLB_ROW ) lpcis->itemData2;

            FullDescriptor1 = ( PCFULL_DESCRIPTOR )ClbRow1->Data;
            FullDescriptor2 = ( PCFULL_DESCRIPTOR )ClbRow2->Data;

            Compare =  FullDescriptor1->GetBusNumber() -
                        FullDescriptor2->GetBusNumber();

            if( Compare == 0 ) 
            {
                String1 = ClbRow1->Strings[1].String;
                String2 = ClbRow2->Strings[1].String;
                Compare = wcscmp( String1, String2 );
            }

            return Compare;
        }

    case WM_COMMAND:

        switch(LOWORD(wParam)) 
        {
        case IDOK:
        case IDCANCEL:
            EndDialog( hDlg, TRUE );
            return( TRUE );

        case IDC_LIST_RESOURCE_LISTS:
            {
                switch( HIWORD( wParam )) 
                {
                case LBN_SELCHANGE:
                    {
                        // Enable the display drive details button
                        EnableWindow( GetDlgItem( hDlg, IDC_PUSH_DISPLAY_RESOURCES ), TRUE);
                    }
                    break;

                case LBN_DBLCLK:
                    {
                        // Simulate that the details button was pushed
                        SendMessage(hDlg, WM_COMMAND,
                                     MAKEWPARAM( IDC_PUSH_DISPLAY_RESOURCES, BN_CLICKED),
                                     ( LPARAM ) GetDlgItem( hDlg, IDC_PUSH_DISPLAY_RESOURCES));
                    }
                    break;
                }
                break;
            }

        case IDC_PUSH_DISPLAY_RESOURCES:
            {
                PCFULL_DESCRIPTOR FullDescriptor;

                FullDescriptor = ( PCFULL_DESCRIPTOR )(_GetSelectedItem ( hDlg, IDC_LIST_RESOURCE_LISTS ) );
                if( FullDescriptor != NULL ) 
                {
                    _DisplayFullResourceDescriptor( hDlg, FullDescriptor );
                }
                return(TRUE);
            }
        }
    }
    return(FALSE);
}


//------------------------------------------------------------------------------
//  _DisplayFullResourceDescriptorDialogProc
//
//  DESCRIPTION: The dialog proceedure for displaying data of type 
//               REG_FULL_RESOURCE_DESCRIPTOR.
//
//  PARAMETERS:  hDlg - a handle to the dialog proceedure.
//               dwMsg - the message passed from Windows.
//               wParam - extra message dependent data.
//               lParam - extra message dependent data.
//------------------------------------------------------------------------------
BOOL REGISTRY_DATA::_DisplayFullResourceDescriptorDialogProc(HWND hDlg, DWORD dwMsg,
                     WPARAM  wParam, LPARAM lParam)
{
    PCBYTE                          Pointer;
    ULONG                           Size;
    STATIC PCDEVICE_SPECIFIC_DESCRIPTOR    LastSelectedDevSpecific;

    switch(dwMsg) 
    {

    case WM_INITDIALOG:
        {
            LPCWSTR                         InterfaceString;
            WCHAR                           BusNumber[ MAX_LENGTH_DWORD_STRING ];
            PARRAY                          PartialDescriptors;
            PITERATOR                       Iterator;
            PCFULL_DESCRIPTOR               FullResourceDescriptor;
            PCPARTIAL_DESCRIPTOR            PartialDescriptor;
            PCPORT_DESCRIPTOR               Port;
            PCINTERRUPT_DESCRIPTOR          Interrupt;
            PCMEMORY_DESCRIPTOR             Memory;
            PCDMA_DESCRIPTOR                Dma;
            PCDEVICE_SPECIFIC_DESCRIPTOR    DeviceSpecific;

            CLB_ROW         ClbRow;
            CLB_STRING      ClbString[ ] = {
                                { NULL, 0, CLB_LEFT, NULL },
                                { NULL, 0, CLB_LEFT, NULL },
                                { NULL, 0, CLB_LEFT, NULL },
                                { NULL, 0, CLB_LEFT, NULL }
                             };

            WCHAR           PortAddressString[ MAX_LENGTH_BIG_INT_STRING ];
            WCHAR           PortLengthString[ MAX_LENGTH_DWORD_STRING ];
            PCWSTRING       PortType;

            WCHAR           InterruptVectorString[ MAX_LENGTH_DWORD_STRING ];
            WCHAR           InterruptLevelString[ MAX_LENGTH_DWORD_STRING ];
            WCHAR           InterruptAffinityString[ MAX_LENGTH_DWORD_STRING ];
            PCWSTRING       InterruptType;

            WCHAR           MemoryAddressString[ MAX_LENGTH_BIG_INT_STRING ];
            WCHAR           MemoryLengthString[ MAX_LENGTH_DWORD_STRING ];
            PCWSTRING       MemoryAccess;

            WCHAR           DmaChannelString[ MAX_LENGTH_DWORD_STRING ];
            WCHAR           DmaPortString[ MAX_LENGTH_DWORD_STRING ];

            WCHAR           Reserved1String[ MAX_LENGTH_DWORD_STRING ];
            WCHAR           Reserved2String[ MAX_LENGTH_DWORD_STRING ];
            WCHAR           DataSizeString[ MAX_LENGTH_DWORD_STRING ];
            PCBYTE          AuxPointer;

           LastSelectedDevSpecific = NULL;

           if( ( FullResourceDescriptor = ( PCFULL_DESCRIPTOR )lParam ) == NULL ) 
           {
                EndDialog( hDlg, 0 );
                return( TRUE );
           }

           //
           //   Write the interface type
           //
           switch( FullResourceDescriptor->GetInterfaceType() ) 
           {

           case Internal:

               InterfaceString = s_MsgBusInternal->GetWSTR();
               break;

           case Isa:

               InterfaceString = s_MsgBusIsa->GetWSTR();
               break;

           case Eisa:

               InterfaceString = s_MsgBusEisa->GetWSTR();
               break;

           case MicroChannel:

               InterfaceString = s_MsgBusMicroChannel->GetWSTR();
               break;

           case TurboChannel:

               InterfaceString = s_MsgBusTurboChannel->GetWSTR();
               break;

           case PCIBus:

               InterfaceString = s_MsgBusPCIBus->GetWSTR();
               break;

           case VMEBus:

               InterfaceString = s_MsgBusVMEBus->GetWSTR();
               break;

           case NuBus:

               InterfaceString = s_MsgBusNuBus->GetWSTR();
               break;

           case PCMCIABus:

               InterfaceString = s_MsgBusPCMCIABus->GetWSTR();
               break;

           case CBus:

               InterfaceString = s_MsgBusCBus->GetWSTR();
               break;

           case MPIBus:

               InterfaceString = s_MsgBusMPIBus->GetWSTR();
               break;

           case MPSABus:

               InterfaceString = s_MsgBusMPSABus->GetWSTR();
               break;

           default:

               InterfaceString = s_MsgInvalid->GetWSTR();
               break;
           }

           SendDlgItemMessage( hDlg,
                               IDC_FULL_RES_TEXT_INTERFACE_TYPE,
                               WM_SETTEXT,
                               0,
                               ( LPARAM )InterfaceString );

           //
           //   Write the bus number
           //
           swprintf( BusNumber, ( LPWSTR )L"%d", FullResourceDescriptor->GetBusNumber() );

           SendDlgItemMessage( hDlg,
                               IDC_FULL_RES_TEXT_BUS_NUMBER,
                               WM_SETTEXT,
                               0,
                               ( LPARAM )BusNumber );

           //
           //   Write the version and revision
           //

           swprintf( BusNumber, ( LPWSTR )L"%d", FullResourceDescriptor->GetVersion() );

           SendDlgItemMessage( hDlg,
                               IDC_FULL_RES_TEXT_VERSION,
                               WM_SETTEXT,
                               0,
                               ( LPARAM )BusNumber );

           swprintf( BusNumber, ( LPWSTR )L"%d", FullResourceDescriptor->GetRevision() );

           SendDlgItemMessage( hDlg,
                               IDC_FULL_RES_TEXT_REVISION,
                               WM_SETTEXT,
                               0,
                               ( LPARAM )BusNumber );



            //
            //   Write partial descriptors
            //
            if( ( ( PartialDescriptors = FullResourceDescriptor->GetResourceDescriptors() ) == NULL ) ||
                ( ( Iterator = PartialDescriptors->QueryIterator() ) == NULL ) ) {
                EndDialog( hDlg, 0 );
                return( TRUE );
            }


            ClbRow.Strings = ClbString;
            while( ( PartialDescriptor = ( PCPARTIAL_DESCRIPTOR )Iterator->GetNext() ) != NULL ) {

                ClbRow.Data = ( PVOID )PartialDescriptor;
                if( PartialDescriptor->IsDescriptorTypePort() ) {
                    Port = ( PCPORT_DESCRIPTOR )PartialDescriptor;
                    if( ( ( ( PPORT_DESCRIPTOR )Port )->GetPhysicalAddress() )->HighPart != 0 ) {
                        swprintf( PortAddressString,
                                  ( LPWSTR )L"0x%08x%08x",
                                  ( ( ( PPORT_DESCRIPTOR )Port )->GetPhysicalAddress() )->HighPart,
                                  ( ( ( PPORT_DESCRIPTOR )Port )->GetPhysicalAddress() )->LowPart );
                    } else {
                        swprintf( PortAddressString,
                                  ( LPWSTR )L"0x%08x",
                                  ( ( ( PPORT_DESCRIPTOR )Port )->GetPhysicalAddress() )->LowPart );
                    }
                    swprintf( PortLengthString,
                              ( LPWSTR )L"%#x",
                              Port->GetLength() );

                    ClbString[ 0 ].String = ( LPWSTR )PortAddressString;
                    ClbString[ 0 ].Format = CLB_LEFT;
                    ClbString[ 0 ].Length = wcslen( PortAddressString );
                    ClbString[ 1 ].String = ( LPWSTR )PortLengthString;
                    ClbString[ 1 ].Format = CLB_LEFT;
                    ClbString[ 1 ].Length = wcslen( PortLengthString );
                    if( Port->IsPortMemory() ) {
                        PortType = s_MsgPortMemory;
                    } else {
                        PortType = s_MsgPortPort;
                    }
                    ClbString[ 2 ].String = ( LPWSTR )PortType->GetWSTR();
                    ClbString[ 2 ].Format = CLB_LEFT;
                    ClbString[ 2 ].Length = PortType->QueryChCount();

                    ClbRow.Count = 3;

                    ClbAddData( hDlg,
                                IDC_FULL_RES_LIST_PORTS,
                                &ClbRow );

                } else if( PartialDescriptor->IsDescriptorTypeInterrupt() ) {
                    Interrupt = ( PCINTERRUPT_DESCRIPTOR )PartialDescriptor;
                    swprintf( InterruptVectorString,
                              ( LPWSTR )L"%d",
                              Interrupt->GetVector() );
                    swprintf( InterruptLevelString,
                              ( LPWSTR )L"%d",
                              Interrupt->GetLevel() );
                    swprintf( InterruptAffinityString,
                              ( LPWSTR )L"0x%08x",
                              Interrupt->GetAffinity() );

                    ClbString[ 0 ].String = ( LPWSTR )InterruptVectorString;
                    ClbString[ 0 ].Length = wcslen( InterruptVectorString );
                    ClbString[ 0 ].Format = CLB_LEFT;
                    ClbString[ 1 ].String = ( LPWSTR )InterruptLevelString;
                    ClbString[ 1 ].Format = CLB_LEFT;
                    ClbString[ 1 ].Length = wcslen( InterruptLevelString );
                    ClbString[ 2 ].String = ( LPWSTR )InterruptAffinityString;
                    ClbString[ 2 ].Format = CLB_LEFT;
                    ClbString[ 2 ].Length = wcslen( InterruptAffinityString );
                    if( Interrupt->IsInterruptLatched() ) {
                        InterruptType = s_MsgIntLatched;
                    } else {
                        InterruptType = s_MsgIntLevelSensitive;
                    }
                    ClbString[ 3 ].String = ( LPWSTR )InterruptType->GetWSTR();
                    ClbString[ 3 ].Format = CLB_LEFT;
                    ClbString[ 3 ].Length = InterruptType->QueryChCount();

                    ClbRow.Count = 4;

                    ClbAddData( hDlg,
                                IDC_FULL_RES_LIST_INTERRUPTS,
                                &ClbRow );

                } else if( PartialDescriptor->IsDescriptorTypeMemory() ) {
                    Memory = ( PCMEMORY_DESCRIPTOR )PartialDescriptor;
                    if( ( ( ( PMEMORY_DESCRIPTOR )Memory )->GetStartAddress() )->HighPart != 0 ) {
                        swprintf( MemoryAddressString,
                                  ( LPWSTR )L"%#08x%08x",
                                  ( ( ( PMEMORY_DESCRIPTOR )Memory )->GetStartAddress() )->HighPart,
                                  ( ( ( PMEMORY_DESCRIPTOR )Memory )->GetStartAddress() )->LowPart );
                    } else {
                        swprintf( MemoryAddressString,
                                  ( LPWSTR )L"%#08x",
                                  ( ( ( PMEMORY_DESCRIPTOR )Memory )->GetStartAddress() )->LowPart );
                    }
                    swprintf( MemoryLengthString,
                              ( LPWSTR )L"%#x",
                              Memory->GetLength() );

                    ClbString[ 0 ].String = ( LPWSTR )MemoryAddressString;
                    ClbString[ 0 ].Length = wcslen( MemoryAddressString );
                    ClbString[ 0 ].Format = CLB_LEFT;
                    ClbString[ 1 ].String = ( LPWSTR )MemoryLengthString;
                    ClbString[ 1 ].Format = CLB_LEFT;
                    ClbString[ 1 ].Length = wcslen( MemoryLengthString );
                    if( Memory->IsMemoryReadWrite() ) {
                        MemoryAccess = s_MsgMemReadWrite;
                    } else if( Memory->IsMemoryReadOnly() ){
                        MemoryAccess = s_MsgMemReadOnly;
                    } else {
                        MemoryAccess = s_MsgMemWriteOnly;
                    }
                    ClbString[ 2 ].String = ( LPWSTR )MemoryAccess->GetWSTR();
                    ClbString[ 2 ].Format = CLB_LEFT;
                    ClbString[ 2 ].Length = MemoryAccess->QueryChCount();

                    ClbRow.Count = 3;

                    ClbAddData( hDlg,
                                IDC_FULL_RES_LIST_MEMORY,
                                &ClbRow );

                } else if( PartialDescriptor->IsDescriptorTypeDma() ) {
                    Dma = ( PDMA_DESCRIPTOR )PartialDescriptor;
                    swprintf( DmaChannelString,
                              ( LPWSTR )L"%d",
                              Dma->GetChannel() );
                    swprintf( DmaPortString,
                              ( LPWSTR )L"%d",
                              Dma->GetPort() );

                    ClbString[ 0 ].String = ( LPWSTR )DmaChannelString;
                    ClbString[ 0 ].Length = wcslen( DmaChannelString );
                    ClbString[ 0 ].Format = CLB_LEFT;
                    ClbString[ 1 ].String = ( LPWSTR )DmaPortString;
                    ClbString[ 1 ].Format = CLB_LEFT;
                    ClbString[ 1 ].Length = wcslen( DmaPortString );

                    ClbRow.Count = 2;

                    ClbAddData( hDlg,
                                IDC_FULL_RES_LIST_DMA,
                                &ClbRow );

                } else if( PartialDescriptor->IsDescriptorTypeDeviceSpecific() ) {
                    DeviceSpecific = ( PDEVICE_SPECIFIC_DESCRIPTOR )PartialDescriptor;
                    swprintf( Reserved1String,
                              ( LPWSTR )L"0x%08x",
                              DeviceSpecific->GetReserved1() );
                    swprintf( Reserved2String,
                              ( LPWSTR )L"0x%08x",
                              DeviceSpecific->GetReserved1() );
                    swprintf( DataSizeString,
                              ( LPWSTR )L"%#x",
                              DeviceSpecific->GetData( &AuxPointer ) );

                    ClbString[ 0 ].String = ( LPWSTR )Reserved1String;
                    ClbString[ 0 ].Length = wcslen( Reserved1String );
                    ClbString[ 0 ].Format = CLB_LEFT;
                    ClbString[ 1 ].String = ( LPWSTR )Reserved2String;
                    ClbString[ 1 ].Format = CLB_LEFT;
                    ClbString[ 1 ].Length = wcslen( Reserved2String );
                    ClbString[ 2 ].String = ( LPWSTR )DataSizeString;
                    ClbString[ 2 ].Length = wcslen( DataSizeString );
                    ClbString[ 2 ].Format = CLB_LEFT;

                    ClbRow.Count = 3;

                    ClbAddData( hDlg,
                                IDC_FULL_RES_LIST_DEVICE_SPECIFIC,
                                &ClbRow );

                } else {
                    DebugPrintTrace(( "REGEDT32: Unknown Descriptor \n\n" ));
                    continue;
                }

            }

            DELETE( Iterator );
            //
            // Disble the Display button
            //
            // EnableWindow( GetDlgItem( hDlg, IDC_PUSH_DISPLAY_RESOURCES ), FALSE );
            return( TRUE );
        }

    case WM_COMPAREITEM:
        {
            LPCOMPAREITEMSTRUCT     lpcis;
            LPCLB_ROW               ClbRow1;
            LPCLB_ROW               ClbRow2;
            LONG                    Compare;

            PCPARTIAL_DESCRIPTOR    Descriptor1;
            PCPARTIAL_DESCRIPTOR    Descriptor2;

            lpcis = ( LPCOMPAREITEMSTRUCT ) lParam;
   
            //
            // Extract the two rows to be compared.
            //

            ClbRow1 = ( LPCLB_ROW ) lpcis->itemData1;
            ClbRow2 = ( LPCLB_ROW ) lpcis->itemData2;

            Descriptor1 = ( PCPARTIAL_DESCRIPTOR ) ClbRow1->Data;
            Descriptor2 = ( PCPARTIAL_DESCRIPTOR ) ClbRow2->Data;

            //
            // Sort the Clbs. In the case of DMA and INTERRUPT, sort by channel
            // and vector respectively. For MEMORY and PORT sort by starting
            // physical address.
            //

            switch( lpcis->CtlID ) {

            case IDC_FULL_RES_LIST_DMA:

                //
                //  For DMA, sort by channel and port
                //

                Compare = ( ( PCDMA_DESCRIPTOR )Descriptor1 )->GetChannel() -
                          ( ( PCDMA_DESCRIPTOR )Descriptor2 )->GetChannel();
                if( Compare == 0 ) {
                    Compare = ( ( PCDMA_DESCRIPTOR )Descriptor1 )->GetPort() -
                              ( ( PCDMA_DESCRIPTOR )Descriptor2 )->GetPort();
                }
                break;

            case IDC_FULL_RES_LIST_INTERRUPTS:

                //
                // For INTERRUPT, sort by vector and level
                //

                Compare = ( ( PCINTERRUPT_DESCRIPTOR )Descriptor1 )->GetVector() -
                          ( ( PCINTERRUPT_DESCRIPTOR )Descriptor2 )->GetVector();
                if( Compare == 0 ) {
                    Compare = ( ( PCINTERRUPT_DESCRIPTOR )Descriptor1 )->GetLevel() -
                              ( ( PCINTERRUPT_DESCRIPTOR )Descriptor2 )->GetLevel();
                }
                break;

            case IDC_FULL_RES_LIST_MEMORY:

                //
                // For MEMORY sort by physical address
                //

                Compare = ( ( ( PMEMORY_DESCRIPTOR )Descriptor1 )->GetStartAddress() )->HighPart -
                          ( ( ( PMEMORY_DESCRIPTOR )Descriptor2 )->GetStartAddress() )->HighPart;
                if( Compare == 0 ) {
                    Compare = ( ( ( PMEMORY_DESCRIPTOR )Descriptor1 )->GetStartAddress() )->LowPart -
                              ( ( ( PMEMORY_DESCRIPTOR )Descriptor2 )->GetStartAddress() )->LowPart;
                }
                break;

            case IDC_FULL_RES_LIST_PORTS:

                //
                // For PORT sort by physical address
                //

                Compare = ( ( ( PPORT_DESCRIPTOR )Descriptor1 )->GetPhysicalAddress() )->HighPart -
                          ( ( ( PPORT_DESCRIPTOR )Descriptor2 )->GetPhysicalAddress() )->HighPart;
                if( Compare == 0 ) {
                    Compare = ( ( ( PPORT_DESCRIPTOR )Descriptor1 )->GetPhysicalAddress() )->LowPart -
                              ( ( ( PPORT_DESCRIPTOR )Descriptor2 )->GetPhysicalAddress() )->LowPart;
                }
                break;

            }
            return Compare;
        }

        case WM_COMMAND:

            switch( LOWORD( wParam ) ) {

            case IDOK:
            case IDCANCEL:

                EndDialog( hDlg, TRUE );
                return( TRUE );

            case IDC_FULL_RES_LIST_DMA:

                switch( HIWORD( wParam )) {

                case LBN_SELCHANGE:
                    {

                        PCPARTIAL_DESCRIPTOR   Descriptor;

                        LastSelectedDevSpecific = NULL;
                        //
                        // Remove the selection from the other list boxes
                        //
                        SendDlgItemMessage( hDlg,
                                            IDC_FULL_RES_LIST_INTERRUPTS,
                                            LB_SETCURSEL,
                                            (WPARAM) -1,
                                            0 );
                        SendDlgItemMessage( hDlg,
                                            IDC_FULL_RES_LIST_MEMORY,
                                            LB_SETCURSEL,
                                            (WPARAM) -1,
                                            0 );

                        SendDlgItemMessage( hDlg,
                                            IDC_FULL_RES_LIST_PORTS,
                                            LB_SETCURSEL,
                                            (WPARAM) -1,
                                            0 );

                        SendDlgItemMessage( hDlg,
                                            IDC_FULL_RES_LIST_DEVICE_SPECIFIC,
                                            LB_SETCURSEL,
                                            (WPARAM) -1,
                                            0 );

                        //
                        // Get the PARTIAL_DESCRIPTOR for the currently selected
                        // resource and update the share disposition display.
                        //

                        Descriptor = ( PCPARTIAL_DESCRIPTOR )_GetSelectedItem( hDlg,
                                                                              LOWORD( wParam ) );

                        if( Descriptor != NULL ) 
                        {
                            _UpdateShareDisplay( hDlg, Descriptor );
                        }
                        //
                        //  Disable the Data... button.
                        //
                        EnableWindow( GetDlgItem( hDlg, IDC_PUSH_DISPLAY_DATA ),
                                      FALSE );

                        return( TRUE );
                    }

                }
                break;

            case IDC_FULL_RES_LIST_INTERRUPTS:

                switch( HIWORD( wParam )) {

                case LBN_SELCHANGE:
                    {

                        PCPARTIAL_DESCRIPTOR   Descriptor;

                        LastSelectedDevSpecific = NULL;
                        //
                        // Remove the selection from the other list boxes
                        //
                        SendDlgItemMessage( hDlg,
                                            IDC_FULL_RES_LIST_DMA,
                                            LB_SETCURSEL,
                                            (WPARAM) -1,
                                            0 );

                        SendDlgItemMessage( hDlg,
                                            IDC_FULL_RES_LIST_MEMORY,
                                            LB_SETCURSEL,
                                            (WPARAM) -1,
                                            0 );

                        SendDlgItemMessage( hDlg,
                                            IDC_FULL_RES_LIST_PORTS,
                                            LB_SETCURSEL,
                                            (WPARAM) -1,
                                            0 );

                        SendDlgItemMessage( hDlg,
                                            IDC_FULL_RES_LIST_DEVICE_SPECIFIC,
                                            LB_SETCURSEL,
                                            (WPARAM) -1,
                                            0 );

                        //
                        // Get the PARTIAL_DESCRIPTOR for the currently selected
                        // resource and update the share disposition display.
                        //

                        Descriptor = ( PCPARTIAL_DESCRIPTOR )_GetSelectedItem( hDlg,
                                                                              LOWORD( wParam ) );

                        if( Descriptor != NULL ) 
                        {
                            _UpdateShareDisplay( hDlg, Descriptor );
                        }
                        //
                        //  Disable the Data... button.
                        //
                        EnableWindow( GetDlgItem( hDlg, IDC_PUSH_DISPLAY_DATA ),
                                      FALSE );

                        return( TRUE );
                    }

                }
                break;

            case IDC_FULL_RES_LIST_MEMORY:

                switch( HIWORD( wParam )) {

                case LBN_SELCHANGE:
                    {

                        PCPARTIAL_DESCRIPTOR   Descriptor;

                        LastSelectedDevSpecific = NULL;
                        //
                        // Remove the selection from the other list boxes
                        //
                        SendDlgItemMessage( hDlg,
                                            IDC_FULL_RES_LIST_DMA,
                                            LB_SETCURSEL,
                                            (WPARAM) -1,
                                            0 );

                        SendDlgItemMessage( hDlg,
                                            IDC_FULL_RES_LIST_INTERRUPTS,
                                            LB_SETCURSEL,
                                            (WPARAM) -1,
                                            0 );

                        SendDlgItemMessage( hDlg,
                                            IDC_FULL_RES_LIST_PORTS,
                                            LB_SETCURSEL,
                                            (WPARAM) -1,
                                            0 );

                        SendDlgItemMessage( hDlg,
                                            IDC_FULL_RES_LIST_DEVICE_SPECIFIC,
                                            LB_SETCURSEL,
                                            (WPARAM) -1,
                                            0 );

                        //
                        // Get the PARTIAL_DESCRIPTOR for the currently selected
                        // resource and update the share disposition display.
                        //

                        Descriptor = ( PCPARTIAL_DESCRIPTOR )_GetSelectedItem( hDlg,
                                                                              LOWORD( wParam ) );

                        if( Descriptor != NULL ) 
                        {
                            _UpdateShareDisplay( hDlg, Descriptor );
                        }
                        //
                        //  Disable the Data... button.
                        //
                        EnableWindow( GetDlgItem( hDlg, IDC_PUSH_DISPLAY_DATA ),
                                      FALSE );

                        return( TRUE );
                    }

                }
                break;

            case IDC_FULL_RES_LIST_PORTS:

                switch( HIWORD( wParam )) {

                case LBN_SELCHANGE:
                    {
                        PCPARTIAL_DESCRIPTOR   Descriptor;

                        LastSelectedDevSpecific = NULL;
                        //
                        // Remove the selection from the other list boxes
                        //
                        SendDlgItemMessage( hDlg,
                                            IDC_FULL_RES_LIST_DMA,
                                            LB_SETCURSEL,
                                            (WPARAM) -1,
                                            0 );

                        SendDlgItemMessage( hDlg,
                                            IDC_FULL_RES_LIST_INTERRUPTS,
                                            LB_SETCURSEL,
                                            (WPARAM) -1,
                                            0 );

                        SendDlgItemMessage( hDlg,
                                            IDC_FULL_RES_LIST_MEMORY,
                                            LB_SETCURSEL,
                                            (WPARAM) -1,
                                            0 );

                        SendDlgItemMessage( hDlg,
                                            IDC_FULL_RES_LIST_DEVICE_SPECIFIC,
                                            LB_SETCURSEL,
                                            (WPARAM) -1,
                                            0 );

                        //
                        // Get the PARTIAL_DESCRIPTOR for the currently selected
                        // resource and update the share disposition display.
                        //

                        Descriptor = ( PCPARTIAL_DESCRIPTOR )_GetSelectedItem( hDlg,
                                                                              LOWORD( wParam ) );

                        if( Descriptor != NULL ) 
                        {
                            _UpdateShareDisplay( hDlg, Descriptor );
                        }
                        //
                        //  Disable the Data... button.
                        //
                        EnableWindow( GetDlgItem( hDlg, IDC_PUSH_DISPLAY_DATA ),
                                      FALSE );

                        return( TRUE );
                    }

                }
                break;

            case IDC_FULL_RES_LIST_DEVICE_SPECIFIC:

                switch( HIWORD( wParam )) {

                case LBN_SELCHANGE:
                    {

                        PCPARTIAL_DESCRIPTOR   Descriptor;
                        PCBYTE                 Pointer;

                        //
                        // Remove the selection from the other list boxes
                        //
                        SendDlgItemMessage( hDlg,
                                            IDC_FULL_RES_LIST_DMA,
                                            LB_SETCURSEL,
                                            (WPARAM) -1,
                                            0 );

                        SendDlgItemMessage( hDlg,
                                            IDC_FULL_RES_LIST_INTERRUPTS,
                                            LB_SETCURSEL,
                                            (WPARAM) -1,
                                            0 );

                        SendDlgItemMessage( hDlg,
                                            IDC_FULL_RES_LIST_MEMORY,
                                            LB_SETCURSEL,
                                            (WPARAM) -1,
                                            0 );

                        SendDlgItemMessage( hDlg,
                                            IDC_FULL_RES_LIST_PORTS,
                                            LB_SETCURSEL,
                                            (WPARAM) -1,
                                            0 );

                        //
                        // Get the PARTIAL_DESCRIPTOR for the currently selected
                        // resource and update the share disposition display.
                        //

                        Descriptor = ( PCPARTIAL_DESCRIPTOR )_GetSelectedItem( hDlg,
                                                                              LOWORD( wParam ) );
                        LastSelectedDevSpecific = ( PCDEVICE_SPECIFIC_DESCRIPTOR )Descriptor;

                        if( Descriptor != NULL ) 
                        {
                            _UpdateShareDisplay( hDlg, Descriptor );
                        }
                        //
                        //  Enable the Data... button if necessary.
                        //

                        EnableWindow( GetDlgItem( hDlg, IDC_PUSH_DISPLAY_DATA ),
                                      ( ( Descriptor != NULL ) &&
                                        Descriptor->IsDescriptorTypeDeviceSpecific() &&
                                        ( ( ( PCDEVICE_SPECIFIC_DESCRIPTOR )Descriptor )->GetData( &Pointer ) != 0 )
                                      )
                                    );

                        return( TRUE );
                    }


                case LBN_DBLCLK:
                    {

                        //
                        // Simulate that the details button was pushed
                        //

                        SendMessage( hDlg,
                                     WM_COMMAND,
                                     MAKEWPARAM( IDC_PUSH_DISPLAY_DATA, BN_CLICKED ),
                                     ( LPARAM ) GetDlgItem( hDlg, IDC_PUSH_DISPLAY_DATA ) );
                        return( TRUE ); //  0;
                    }

                }
                break;

            case IDC_PUSH_DISPLAY_DATA:
                {
                    //
                    //  Display the device specific data
                    //
                    if( ( LastSelectedDevSpecific != NULL ) &&
                        ( ( Size = LastSelectedDevSpecific->GetData( &Pointer ) ) != 0 )
                      ) 
                    {
                        _DisplayBinaryData( hDlg, Pointer, Size);
                    }
                    return( TRUE );
                }
                break;
            }
    }
    return( FALSE );
}


//------------------------------------------------------------------------------
//  _DisplayRequirementsListDialogProc
//
//  DESCRIPTION: The dialog procedure for displaying data of type 
//               REG_RESOURCE_REQUIREMENTS_LIST.
//
//  PARAMETERS:  hDlg - a handle to the dialog proceedure.
//               dwMsg - the message passed from Windows.
//               wParam - extra message dependent data.
//               lParam - extra message dependent data.
//------------------------------------------------------------------------------
BOOL REGISTRY_DATA::_DisplayRequirementsListDialogProc(HWND hDlg, DWORD dwMsg,
                     WPARAM  wParam, LPARAM lParam)
{

    switch(dwMsg) 
    {
        case WM_INITDIALOG:
        {
            LPCWSTR                 InterfaceString;
            LPCWSTR                 DescriptorTypeString;
            ULONG                   StringSize;
            PCIO_REQUIREMENTS_LIST  RequirementsList;
            WCHAR                   BusNumberString[ MAX_LENGTH_DWORD_STRING ];
            WCHAR                   SlotNumberString[ MAX_LENGTH_DWORD_STRING ];

            PARRAY                  AlternativeLists;
            PITERATOR               AlternativeListsIterator;
            ULONG                   AlternativeListNumber;
            WCHAR                   AlternativeListNumberString[ MAX_LENGTH_DWORD_STRING ];

            PCIO_DESCRIPTOR_LIST    IoDescriptorList;

            CLB_ROW         ClbRow;
            CLB_STRING      ClbString[ ] = {
                                { NULL, 0, CLB_LEFT, NULL },
                                { NULL, 0, CLB_LEFT, NULL },
                                { NULL, 0, CLB_LEFT, NULL },
                                { NULL, 0, CLB_LEFT, NULL }
                             };


            if( ( RequirementsList = ( PCIO_REQUIREMENTS_LIST )lParam ) == NULL ) {
                EndDialog( hDlg, 0 );
                return( TRUE );
            }

            //
            //  Write the interface type
            //

            switch( RequirementsList->GetInterfaceType() ) {

            case Internal:

                InterfaceString = s_MsgBusInternal->GetWSTR();
                break;

            case Isa:

                InterfaceString = s_MsgBusIsa->GetWSTR();
                break;

            case Eisa:

                InterfaceString = s_MsgBusEisa->GetWSTR();
                break;

            case MicroChannel:

                InterfaceString = s_MsgBusMicroChannel->GetWSTR();
                break;

            case TurboChannel:

                InterfaceString = s_MsgBusTurboChannel->GetWSTR();
                break;

            case PCIBus:

                InterfaceString = s_MsgBusPCIBus->GetWSTR();
                break;

            case VMEBus:

                InterfaceString = s_MsgBusVMEBus->GetWSTR();
                break;

            case NuBus:

                InterfaceString = s_MsgBusNuBus->GetWSTR();
                break;

            case PCMCIABus:

                InterfaceString = s_MsgBusPCMCIABus->GetWSTR();
                break;

            case CBus:

                InterfaceString = s_MsgBusCBus->GetWSTR();
                break;

            case MPIBus:

                InterfaceString = s_MsgBusMPIBus->GetWSTR();
                break;

            case MPSABus:

                InterfaceString = s_MsgBusMPSABus->GetWSTR();
                break;

            default:

                InterfaceString = s_MsgInvalid->GetWSTR();
                break;
            }

            SendDlgItemMessage( hDlg,
                                IDC_IO_REQ_TEXT_INTERFACE_TYPE,
                                WM_SETTEXT,
                                0,
                                ( LPARAM )InterfaceString );

            //
            //  Write the bus number
            //

            swprintf( BusNumberString, ( LPWSTR )L"%d", RequirementsList->GetBusNumber() );

            SendDlgItemMessage( hDlg,
                                IDC_IO_REQ_TEXT_BUS_NUMBER,
                                WM_SETTEXT,
                                0,
                                ( LPARAM )BusNumberString );

            //
            //  Write the slot number
            //

            swprintf( SlotNumberString, ( LPWSTR )L"%d", RequirementsList->GetSlotNumber() );

            SendDlgItemMessage( hDlg,
                                IDC_IO_REQ_TEXT_SLOT_NUMBER,
                                WM_SETTEXT,
                                0,
                                ( LPARAM )SlotNumberString );

            //
            //  Write the entries in the column list box
            //
            if( ( ( AlternativeLists = RequirementsList->GetAlternativeLists() ) == NULL ) ||
                ( ( AlternativeListsIterator = AlternativeLists->QueryIterator() ) == NULL ) ) {
                EndDialog( hDlg, 0 );
                return( TRUE );
            }

            AlternativeListNumber = 0;
            while( ( IoDescriptorList = ( PCIO_DESCRIPTOR_LIST )AlternativeListsIterator->GetNext() ) != NULL ) {

                PARRAY          IoDescriptors;
                PITERATOR       IoDescriptorListIterator;
                PCIO_DESCRIPTOR Descriptor;
                ULONG           SubListNumber;
                WCHAR           SubListNumberString[ MAX_LENGTH_DWORD_STRING ];
                ULONG           DescriptorNumber;
                WCHAR           DescriptorNumberString[ MAX_LENGTH_DWORD_STRING ];


                if( ( ( IoDescriptors = ( PARRAY )IoDescriptorList->GetDescriptorsList() ) == NULL ) ||
                    ( ( IoDescriptorListIterator = IoDescriptors->QueryIterator() ) == NULL ) ) {
                    DELETE( AlternativeListsIterator );
                    EndDialog( hDlg, 0 );
                    return( TRUE );
                }

                AlternativeListNumber++;
                swprintf( AlternativeListNumberString, ( LPWSTR )L"%d", AlternativeListNumber );

                SubListNumber = 0;
                while( ( Descriptor = ( PCIO_DESCRIPTOR )IoDescriptorListIterator->GetNext() ) != NULL ) {
                    if( ( !Descriptor->IsResourceOptionAlternative() ) ||
                        ( SubListNumber == 0 ) ) {
                        SubListNumber++;
                        DescriptorNumber = 0;
                    }
                    DescriptorNumber++;

                    swprintf( SubListNumberString, ( LPWSTR )L"%d", SubListNumber );

                    swprintf( DescriptorNumberString, ( LPWSTR )L"%d", DescriptorNumber );

                    if( Descriptor->IsDescriptorTypePort() ) {
                        DescriptorTypeString = s_MsgDevPort->GetWSTR();
                        StringSize = s_MsgDevPort->QueryChCount();
                    } else if( Descriptor->IsDescriptorTypeInterrupt() ) {
                        DescriptorTypeString = s_MsgDevInterrupt->GetWSTR();
                        StringSize = s_MsgDevInterrupt->QueryChCount();
                    } else if( Descriptor->IsDescriptorTypeMemory() ) {
                        DescriptorTypeString = s_MsgDevMemory->GetWSTR();
                        StringSize = s_MsgDevMemory->QueryChCount();
                    } else if( Descriptor->IsDescriptorTypeDma() ) {
                        DescriptorTypeString = s_MsgDevDma->GetWSTR();
                        StringSize = s_MsgDevDma->QueryChCount();
                    } else {
                        DescriptorTypeString = s_MsgInvalid->GetWSTR();
                        StringSize = s_MsgInvalid->QueryChCount();
                    }

                    ClbString[ 0 ].String = ( LPWSTR )AlternativeListNumberString;
                    ClbString[ 0 ].Length = wcslen( AlternativeListNumberString );
                    ClbString[ 0 ].Format = CLB_LEFT;
                    ClbString[ 1 ].String = ( LPWSTR )SubListNumberString;
                    ClbString[ 1 ].Format = CLB_LEFT;
                    ClbString[ 1 ].Length = wcslen( SubListNumberString );
                    ClbString[ 2 ].String = ( LPWSTR )DescriptorNumberString;
                    ClbString[ 2 ].Format = CLB_LEFT;
                    ClbString[ 2 ].Length = wcslen( DescriptorNumberString );
                    ClbString[ 3 ].String = ( LPWSTR )DescriptorTypeString;
                    ClbString[ 3 ].Format = CLB_LEFT;
                    ClbString[ 3 ].Length = StringSize;

                    ClbRow.Count = 4;
                    ClbRow.Strings = ClbString;
                    ClbRow.Data = ( PVOID )Descriptor;

                    ClbAddData( hDlg,
                                IDC_IO_LIST_ALTERNATIVE_LISTS,
                                &ClbRow );

                }
                DELETE( IoDescriptorListIterator );
            }
            DELETE( AlternativeListsIterator );

            //
            // Disble the Display button
            //
            EnableWindow( GetDlgItem( hDlg, IDC_IO_REQ_PUSH_DISPLAY_DEVICE ), FALSE );
            return( TRUE );
        }

        case WM_COMMAND:

            switch( LOWORD( wParam ) ) {

                case IDOK:
                case IDCANCEL:

                    EndDialog( hDlg, TRUE );
                    return( TRUE );

                case IDC_IO_LIST_ALTERNATIVE_LISTS:
                {

                    switch( HIWORD( wParam )) {

                        case LBN_SELCHANGE:
                        {

                            //
                            // Enable the display device details button
                            //

                            EnableWindow( GetDlgItem( hDlg, IDC_IO_REQ_PUSH_DISPLAY_DEVICE ),
                                          TRUE );
                            return 0;
                        }

                        case LBN_DBLCLK:
                        {

                            //
                            // Simulate that the details button was pushed
                            //

                            SendMessage( hDlg,
                                         WM_COMMAND,
                                         MAKEWPARAM( IDC_IO_REQ_PUSH_DISPLAY_DEVICE, BN_CLICKED ),
                                         ( LPARAM ) GetDlgItem( hDlg, IDC_IO_REQ_PUSH_DISPLAY_DEVICE ) );
                            return 0;
                        }
                    }
                    break;
                }

                case IDC_IO_REQ_PUSH_DISPLAY_DEVICE:
                {
                    PCIO_DESCRIPTOR IoDescriptor;

                    IoDescriptor = ( PCIO_DESCRIPTOR )( _GetSelectedItem ( hDlg, IDC_IO_LIST_ALTERNATIVE_LISTS ) );
                    if( IoDescriptor != NULL ) 
                    {
                        _DisplayIoDescriptor( hDlg, IoDescriptor );
                    }
                    return( TRUE );
                }
            }
    }
    return( FALSE );
}


//------------------------------------------------------------------------------
//  _DisplayIoPortDialogProc
//
//  DESCRIPTION: The dialog proceedure for displaying an object of type IO_PORT.
//
//  PARAMETERS:  hDlg - a handle to the dialog proceedure.
//               dwMsg - the message passed from Windows.
//               wParam - extra message dependent data.
//               lParam - extra message dependent data.
//------------------------------------------------------------------------------
BOOL
APIENTRY
REGISTRY_DATA::_DisplayIoPortDialogProc(HWND hDlg, DWORD dwMsg, WPARAM wParam, LPARAM lParam)
{
    switch(dwMsg) 
    {
        case WM_INITDIALOG:
        {
            PCIO_PORT_DESCRIPTOR   Port;
            PCWSTRING              String;
            WCHAR                  AddressString[ MAX_LENGTH_BIG_INT_STRING ];

            if( ( Port = ( PCIO_PORT_DESCRIPTOR )lParam ) == NULL ) {
                EndDialog( hDlg, 0 );
                return( TRUE );
            }

            //
            // Write the port type
            //

            if( Port->IsPortMemory() ) {
                String = s_MsgPortMemory;
            } else if( Port->IsPortIo() ){
                String = s_MsgPortPort;
            } else {
                String = s_MsgInvalid;
            }
            SendDlgItemMessage( hDlg,
                               IDC_IO_TEXT_PORT_TYPE,
                               WM_SETTEXT,
                               0,
                               ( LPARAM ) String->GetWSTR() );

            //
            // Write the length
            //
            swprintf( AddressString,
                      ( LPWSTR )L"%#x",
                      Port->GetLength() );

            SendDlgItemMessage( hDlg,
                               IDC_IO_TEXT_PORT_LENGTH,
                               WM_SETTEXT,
                               0,
                               ( LPARAM )AddressString );

            //
            // Write the alignment
            //
            swprintf( AddressString,
                      ( LPWSTR )L"%#x",
                      Port->GetAlignment() );

            SendDlgItemMessage( hDlg,
                               IDC_IO_TEXT_PORT_ALIGNMENT,
                               WM_SETTEXT,
                               0,
                               ( LPARAM )AddressString );

            //
            // Write the minimum address
            //

            if( ( ( ( PIO_PORT_DESCRIPTOR )Port )->GetMinimumAddress() )->HighPart != 0 ) {
                swprintf( AddressString,
                          ( LPWSTR )L"0x%08x%08x",
                          ( ( ( PIO_PORT_DESCRIPTOR )Port )->GetMinimumAddress() )->HighPart,
                          ( ( ( PIO_PORT_DESCRIPTOR )Port )->GetMinimumAddress() )->LowPart );
            } else {
                swprintf( AddressString,
                          ( LPWSTR )L"0x%08x",
                          ( ( ( PIO_PORT_DESCRIPTOR )Port )->GetMinimumAddress() )->LowPart );
            }


            SendDlgItemMessage( hDlg,
                               IDC_IO_TEXT_PORT_MIN_ADDRESS,
                               WM_SETTEXT,
                               0,
                               ( LPARAM )AddressString );

            //
            // Write the maximum address
            //

            if( ( ( ( PIO_PORT_DESCRIPTOR )Port )->GetMaximumAddress() )->HighPart != 0 ) {
                swprintf( AddressString,
                          ( LPWSTR )L"0x%08x%08x",
                          ( ( ( PIO_PORT_DESCRIPTOR )Port )->GetMaximumAddress() )->HighPart,
                          ( ( ( PIO_PORT_DESCRIPTOR )Port )->GetMaximumAddress() )->LowPart );
            } else {
                swprintf( AddressString,
                          ( LPWSTR )L"0x%08x",
                          ( ( ( PIO_PORT_DESCRIPTOR )Port )->GetMaximumAddress() )->LowPart );
            }
            SendDlgItemMessage( hDlg,
                               IDC_IO_TEXT_PORT_MAX_ADDRESS,
                               WM_SETTEXT,
                               0,
                               ( LPARAM )AddressString );

            //
            //  Write share disposition
            //

            if( Port->IsResourceShareUndetermined() ) {
                String = s_MsgShareUndetermined;
            } else if( Port->IsResourceShareDeviceExclusive() ) {
                String = s_MsgShareDeviceExclusive;
            } else if( Port->IsResourceShareDriverExclusive() ) {
                String = s_MsgShareDriverExclusive;
            } else if( Port->IsResourceShareShared() ) {
                String = s_MsgShareShared;
            } else {
                String = s_MsgInvalid;
            }

            SendDlgItemMessage( hDlg,
                               IDC_IO_TEXT_DISPOSITION,
                               WM_SETTEXT,
                               0,
                               ( LPARAM )String->GetWSTR() );
            //
            // Set the Options
            //
            _UpdateOptionDisplay( hDlg, ( PCIO_DESCRIPTOR )Port );
            return( TRUE );
        }

        case WM_COMMAND:

            switch( LOWORD( wParam ) ) {

                case IDOK:
                case IDCANCEL:

                    EndDialog( hDlg, TRUE );
                    return( TRUE );

            }
    }
    return( FALSE );
}


//------------------------------------------------------------------------------
//  _DisplayIoMemoryDialogProc
//
//  DESCRIPTION: The dialog proceedure for displaying an object of type IO_PORT.
//
//  PARAMETERS:  hDlg - a handle to the dialog proceedure.
//               dwMsg - the message passed from Windows.
//               wParam - extra message dependent data.
//               lParam - extra message dependent data.
//------------------------------------------------------------------------------
BOOL REGISTRY_DATA::_DisplayIoMemoryDialogProc(HWND hDlg, DWORD dwMsg, WPARAM wParam, LPARAM lParam)
{
    switch(dwMsg) 
    {
        case WM_INITDIALOG:
        {
            PCIO_MEMORY_DESCRIPTOR Memory;
            PCWSTRING              String;
            WCHAR                  AddressString[ MAX_LENGTH_BIG_INT_STRING ];

            if( ( Memory = ( PCIO_MEMORY_DESCRIPTOR )lParam ) == NULL ) 
            {
                EndDialog( hDlg, 0 );
                return( TRUE );
            }

            //
            // Write the memory access
            //

            if( Memory->IsMemoryReadWrite() ) {
                String = s_MsgMemReadWrite;
            } else if( Memory->IsMemoryReadOnly() ){
                String = s_MsgMemReadOnly;
            } else if( Memory->IsMemoryWriteOnly() ){
                String = s_MsgMemWriteOnly;
            } else {
                String = s_MsgInvalid;
            }
            SendDlgItemMessage( hDlg,
                               IDC_IO_TEXT_MEM_ACCESS,
                               WM_SETTEXT,
                               0,
                               ( LPARAM ) String->GetWSTR() );

            //
            // Write the length
            //
            swprintf( AddressString,
                      ( LPWSTR )L"%#x",
                      Memory->GetLength() );

            SendDlgItemMessage( hDlg,
                               IDC_IO_TEXT_MEM_LENGTH,
                               WM_SETTEXT,
                               0,
                               ( LPARAM )AddressString );

            //
            // Write the alignment
            //
            swprintf( AddressString,
                      ( LPWSTR )L"%#x",
                      Memory->GetAlignment() );

            SendDlgItemMessage( hDlg,
                               IDC_IO_TEXT_MEM_ALIGNMENT,
                               WM_SETTEXT,
                               0,
                               ( LPARAM )AddressString );

            //
            // Write the minimum address
            //
            if( ( ( ( PIO_MEMORY_DESCRIPTOR )Memory )->GetMinimumAddress() )->HighPart != 0 ) {
                swprintf( AddressString,
                          ( LPWSTR )L"0x%08x%08x",
                          ( ( ( PIO_MEMORY_DESCRIPTOR )Memory )->GetMinimumAddress() )->HighPart,
                          ( ( ( PIO_MEMORY_DESCRIPTOR )Memory )->GetMinimumAddress() )->LowPart );
            } else {
                swprintf( AddressString,
                          ( LPWSTR )L"0x%08x",
                          ( ( ( PIO_MEMORY_DESCRIPTOR )Memory )->GetMinimumAddress() )->LowPart );
            }

            SendDlgItemMessage( hDlg,
                               IDC_IO_TEXT_MEM_MIN_ADDRESS,
                               WM_SETTEXT,
                               0,
                               ( LPARAM )AddressString );

            //
            // Write the maximum address
            //
            if( ( ( ( PIO_MEMORY_DESCRIPTOR )Memory )->GetMaximumAddress() )->HighPart != 0 ) {
                swprintf( AddressString,
                          ( LPWSTR )L"0x%08x%08x",
                          ( ( ( PIO_MEMORY_DESCRIPTOR )Memory )->GetMaximumAddress() )->HighPart,
                          ( ( ( PIO_MEMORY_DESCRIPTOR )Memory )->GetMaximumAddress() )->LowPart );
            } else {
                swprintf( AddressString,
                          ( LPWSTR )L"0x%08x",
                          ( ( ( PIO_MEMORY_DESCRIPTOR )Memory )->GetMaximumAddress() )->LowPart );
            }
            SendDlgItemMessage( hDlg,
                               IDC_IO_TEXT_MEM_MAX_ADDRESS,
                               WM_SETTEXT,
                               0,
                               ( LPARAM )AddressString );

            //
            //  Write share disposition
            //

            if( Memory->IsResourceShareUndetermined() ) {
                String = s_MsgShareUndetermined;
            } else if( Memory->IsResourceShareDeviceExclusive() ) {
                String = s_MsgShareDeviceExclusive;
            } else if( Memory->IsResourceShareDriverExclusive() ) {
                String = s_MsgShareDriverExclusive;
            } else if( Memory->IsResourceShareShared() ) {
                String = s_MsgShareShared;
            } else {
                String = s_MsgInvalid;
            }

            SendDlgItemMessage( hDlg,
                               IDC_IO_TEXT_DISPOSITION,
                               WM_SETTEXT,
                               0,
                               ( LPARAM )String->GetWSTR() );
            //
            // Set the Options
            //
            _UpdateOptionDisplay( hDlg, ( PCIO_DESCRIPTOR )Memory );
            return( TRUE );
        }

        case WM_COMMAND:

            switch( LOWORD( wParam ) ) {

                case IDOK:
                case IDCANCEL:

                    EndDialog( hDlg, TRUE );
                    return( TRUE );

            }
    }
    return( FALSE );
}


//------------------------------------------------------------------------------
//  _DisplayIoInterruptDialogProc
//
//  DESCRIPTION: The dialog proceedure for displaying an object of type IO_PORT.
//
//  PARAMETERS:  hDlg - a handle to the dialog proceedure.
//               dwMsg - the message passed from Windows.
//               wParam - extra message dependent data.
//               lParam - extra message dependent data.
//------------------------------------------------------------------------------
BOOL REGISTRY_DATA::_DisplayIoInterruptDialogProc(HWND hDlg, DWORD dwMsg,
                        WPARAM  wParam, LPARAM lParam)
{
    switch( dwMsg ) 
    {
        case WM_INITDIALOG:
        {
            PCIO_INTERRUPT_DESCRIPTOR Interrupt;
            PCWSTRING                 String;
            WCHAR                     AddressString[ MAX_LENGTH_DWORD_STRING ];

            if( ( Interrupt = ( PCIO_INTERRUPT_DESCRIPTOR )lParam ) == NULL ) 
            {
                EndDialog( hDlg, 0 );
                return( TRUE );
            }

            //
            // Write the interrupt type
            //

            if( Interrupt->IsInterruptLevelSensitive() ) 
            {
                String = s_MsgIntLevelSensitive;
            } 
            else if( Interrupt->IsInterruptLatched() )
            {
                String = s_MsgIntLatched;
            } 
            else 
            {
                String = s_MsgInvalid;
            }
            SendDlgItemMessage( hDlg,
                               IDC_IO_TEXT_INT_TYPE,
                               WM_SETTEXT,
                               0,
                               ( LPARAM ) String->GetWSTR() );

            //
            // Write the minimum vector
            //
            swprintf( AddressString,
                      ( LPWSTR )L"%#x",
                      Interrupt->GetMinimumVector() );

            SendDlgItemMessage( hDlg,
                               IDC_IO_TEXT_INT_MIN_VECTOR,
                               WM_SETTEXT,
                               0,
                               ( LPARAM )AddressString );

            //
            // Write the maximum vector
            //
            swprintf( AddressString,
                      ( LPWSTR )L"%#x",
                      Interrupt->GetMaximumVector() );

            SendDlgItemMessage( hDlg,
                               IDC_IO_TEXT_INT_MAX_VECTOR,
                               WM_SETTEXT,
                               0,
                               ( LPARAM )AddressString );

            //
            //  Write share disposition
            //

            if( Interrupt->IsResourceShareUndetermined() ) 
            {
                String = s_MsgShareUndetermined;
            }
            else if( Interrupt->IsResourceShareDeviceExclusive() ) 
            {
                String = s_MsgShareDeviceExclusive;
            } 
            else if( Interrupt->IsResourceShareDriverExclusive() ) 
            {
                String = s_MsgShareDriverExclusive;
            } 
            else if( Interrupt->IsResourceShareShared() ) 
            {
                String = s_MsgShareShared;
            } else 
            {
                String = s_MsgInvalid;
            }

            SendDlgItemMessage( hDlg,
                               IDC_IO_TEXT_DISPOSITION,
                               WM_SETTEXT,
                               0,
                               ( LPARAM )String->GetWSTR() );
            //
            // Set the Options
            //
            _UpdateOptionDisplay( hDlg, ( PCIO_DESCRIPTOR )Interrupt );
            return( TRUE );
        }

        case WM_COMMAND:

            switch( LOWORD( wParam ) ) 
            {
                case IDOK:
                case IDCANCEL:
                    EndDialog( hDlg, TRUE );
                    return( TRUE );
            }
    }
    return( FALSE );
}


//------------------------------------------------------------------------------
//  _DisplayIoDmaDialogProc
//
//  DESCRIPTION: The dialog proceedure for displaying an object of type IO_PORT.
//
//  PARAMETERS:  hDlg - a handle to the dialog proceedure.
//               dwMsg - the message passed from Windows.
//               wParam - extra message dependent data.
//               lParam - extra message dependent data.
//------------------------------------------------------------------------------
BOOL REGISTRY_DATA::_DisplayIoDmaDialogProc(HWND hDlg,DWORD dwMsg, WPARAM  wParam,
                    LPARAM lParam)
{

    switch(dwMsg) 
    {
        case WM_INITDIALOG:
        {
            PCIO_DMA_DESCRIPTOR Dma;
            PCWSTRING           String;
            WCHAR               AddressString[ MAX_LENGTH_DWORD_STRING ];

            if( ( Dma = ( PCIO_DMA_DESCRIPTOR )lParam ) == NULL ) 
            {
                EndDialog( hDlg, 0 );
                return( TRUE );
            }

            //
            // Write the minimum channel
            //
            swprintf( AddressString,
                      ( LPWSTR )L"%#x",
                      Dma->GetMinimumChannel() );

            SendDlgItemMessage( hDlg,
                               IDC_IO_TEXT_DMA_MIN_CHANNEL,
                               WM_SETTEXT,
                               0,
                               ( LPARAM )AddressString );

            //
            // Write the maximum channel
            //
            swprintf( AddressString,
                      ( LPWSTR )L"%#x",
                      Dma->GetMaximumChannel() );

            SendDlgItemMessage( hDlg,
                               IDC_IO_TEXT_DMA_MAX_CHANNEL,
                               WM_SETTEXT,
                               0,
                               ( LPARAM )AddressString );

            //
            //  Write share disposition
            //

            if( Dma->IsResourceShareUndetermined() ) {
                String = s_MsgShareUndetermined;
            } else if( Dma->IsResourceShareDeviceExclusive() ) {
                String = s_MsgShareDeviceExclusive;
            } else if( Dma->IsResourceShareDriverExclusive() ) {
                String = s_MsgShareDriverExclusive;
            } else if( Dma->IsResourceShareShared() ) {
                String = s_MsgShareShared;
            } else {
                String = s_MsgInvalid;
            }

            SendDlgItemMessage( hDlg,
                               IDC_IO_TEXT_DISPOSITION,
                               WM_SETTEXT,
                               0,
                               ( LPARAM )String->GetWSTR() );
            //
            // Set the Options
            //
            _UpdateOptionDisplay( hDlg, ( PCIO_DESCRIPTOR )Dma );
            return( TRUE );
        }

        case WM_COMMAND:

            switch( LOWORD( wParam ) ) {

                case IDOK:
                case IDCANCEL:

                    EndDialog( hDlg, TRUE );
                    return( TRUE );

            }
    }
    return( FALSE );
}



//------------------------------------------------------------------------------
//  _GetSelectedItem
//
//  DESCRIPTION: Retrieve the object associated to the currently selected row in
//               a Clb.
//
//  PARAMETERS:  hDlg    - Supplies the handle for the dialog that contains the 
//                         selected Clb.
//               ClbId   - Id of the Clb that contains the selected row.
//------------------------------------------------------------------------------
PVOID REGISTRY_DATA::_GetSelectedItem (HWND hDlg, ULONG ClbId)
{
    LONG                Index;
    LPCLB_ROW           ClbRow;
    PVOID               Descriptor;

    // Get the index of the currently selected item.
    Index = (LONG)SendDlgItemMessage(hDlg, ClbId, LB_GETCURSEL, 0, 0);
    if( Index == LB_ERR ) 
    {
        return NULL;
    }

    // Get the CLB_ROW object for this row and extract the associated
    // object.
    ClbRow = ( LPCLB_ROW ) SendDlgItemMessage(hDlg, ClbId, LB_GETITEMDATA, (WPARAM) Index, 0);
    if(( ClbRow == NULL ) || (( LONG_PTR ) ClbRow ) == LB_ERR ) 
    {
        return NULL;
    }

    Descriptor = ClbRow->Data;
    if( Descriptor == NULL ) 
    {
        return NULL;
    }
    return Descriptor;
}


//------------------------------------------------------------------------------
//  _UpdateShareDisplay
//
//  DESCRIPTION: UpdateShareDisplay hilights the appropriate sharing disposition text in
//               the supplied dialog based on the share disposition of the PARTIAL_DESCRIPTOR
//               object supplied.
//
//  PARAMETERS:  hWnd - Supplies window handle for the dialog box where share
//                      display is being updated.
//               pDescriptor - Supplies a pointer to a PARTIAL_DESCRIPTOR object whose
//                      share disposition will be displayed.
//------------------------------------------------------------------------------
VOID REGISTRY_DATA::_UpdateShareDisplay(HWND hDlg, PCPARTIAL_DESCRIPTOR pDescriptor)
{
    if(pDescriptor) 
    {
        EnableWindow( GetDlgItem( hDlg, IDC_FULL_RES_TEXT_UNDETERMINED ),
                      pDescriptor->IsResourceShareUndetermined() );

        EnableWindow( GetDlgItem( hDlg, IDC_FULL_RES_TEXT_DEVICE_EXCLUSIVE ),
                      pDescriptor->IsResourceShareDeviceExclusive() );

        EnableWindow( GetDlgItem( hDlg, IDC_FULL_RES_TEXT_DRIVER_EXCLUSIVE ),
                      pDescriptor->IsResourceShareDriverExclusive() );

        EnableWindow( GetDlgItem( hDlg,IDC_FULL_RES_TEXT_SHARED ),
                      pDescriptor->IsResourceShareShared() );
    }
}


//------------------------------------------------------------------------------
//  _UpdateOptionDisplay
//
//  DESCRIPTION: UpdateOptionDisplay highlights the appropriate Option text in
//               the supplied IO_DESCRIPTOR dialog based on the Option of the
//               IO_DESCRIPTOR object supplied.
//
//  PARAMETERS:  hWnd - Supplies window handle for the dialog box where share
//                      display is being updated.
//               pDescriptor - Supplies a pointer to a PARTIAL_DESCRIPTOR object whose
//                      share disposition will be displayed.
//------------------------------------------------------------------------------
VOID REGISTRY_DATA::_UpdateOptionDisplay(HWND hDlg, PCIO_DESCRIPTOR pDescriptor)
{
    if(pDescriptor) 
    {
        EnableWindow( GetDlgItem( hDlg, IDC_IO_TEXT_OPTION_PREFERRED ),
                      pDescriptor->IsResourceOptionPreferred() );

        EnableWindow( GetDlgItem( hDlg, IDC_IO_TEXT_OPTION_ALTERNATIVE ),
                      pDescriptor->IsResourceOptionAlternative() );
    }
}



VOID DisplayBinaryData(HWND hWnd, LPEDITVALUEPARAM lpEditValueParam, DWORD dwValueType)
{
    PBYTE pbValueData = lpEditValueParam->pValueData;
    UINT  cbValueData = lpEditValueParam->cbValueData;

    REGISTRY_DATA::_DisplayBinaryData(hWnd, pbValueData, cbValueData,
        TRUE, dwValueType);
}

//------------------------------------------------------------------------------
//  _DisplayBinaryData
//
//  DESCRIPTION: Display the contents of a buffer as binary data, in an hd-like 
//               format.
//
//  PARAMETERS:   hWnd - A handle to the owner window.
//                Data - Pointer to the buffer that contains the data to be displayed.
//                DataSize - Number of bytes in the buffer.
//                DisplayValueType - A flag that indicates whether or not the value type of the
//                  data should be displayed as a binary number.
//                ValueType - A number representing the data type. This parameter is ignored if
//                  DisplayValueTRype is FALSE.
//------------------------------------------------------------------------------
VOID REGISTRY_DATA::_DisplayBinaryData(HWND hWnd, PCBYTE  Data, ULONG   DataSize,
    BOOL fDisplayValueType, DWORD dwValueType)
{
    BUFFER_INFORMATION  BufferInfo;

    BufferInfo.Buffer = ( PBYTE )Data;
    BufferInfo.BufferSize = DataSize;
    BufferInfo.DisplayValueType = fDisplayValueType;
    BufferInfo.ValueType = dwValueType;
    DialogBoxParam(g_hInstance,
                   ( BufferInfo.DisplayValueType )? MAKEINTRESOURCE( IDD_DISPLAY_BINARY_DATA_VALUE_TYPE ) :
                                                    MAKEINTRESOURCE( IDD_DISPLAY_BINARY_DATA ),
                   hWnd,
                   ( DLGPROC )REGISTRY_DATA::_DisplayBinaryDataDialogProc,
                   ( LPARAM )&BufferInfo );
}


//------------------------------------------------------------------------------
//  _DisplayBinaryDataDialogProc
//
//  DESCRIPTION: This is the dialog procedure used in the dialog that displays
//               the data in a value entry as binary data, using a format similar
//               to the one used by the 'hd' utility.
//
//  PARAMETERS:  hDlg - a handle to the dialog proceedure.
//               dwMsg - the message passed from Windows.
//               wParam - extra message dependent data.
//               lParam - extra message dependent data.
//------------------------------------------------------------------------------
BOOL REGISTRY_DATA::_DisplayBinaryDataDialogProc(HWND hDlg, DWORD dwMsg, WPARAM wParam, 
            LPARAM lParam)
{
    STATIC  PCBYTE  Data;
    STATIC  ULONG   Size;
    STATIC  ULONG   CurrentFormat;
    STATIC  BOOL    DisplayValueType;
    STATIC  ULONG   ValueType;


    switch( dwMsg ) 
    {
        case WM_INITDIALOG:
        {
            WCHAR   AuxBuffer[16];
            //
            // Validate arguments and initialize static data
            //
            if( lParam == NULL ) {
                EndDialog( hDlg, 0 );
                return( TRUE );
            }
            Data = ( ( PBUFFER_INFORMATION )lParam )->Buffer;
            Size = ( ( PBUFFER_INFORMATION )lParam )->BufferSize;
            DisplayValueType = ( ( PBUFFER_INFORMATION )lParam )->DisplayValueType;
            ValueType = ( ( PBUFFER_INFORMATION )lParam )->ValueType;

            //
            // Display value type as an hex number if necessary
            //
            if( DisplayValueType ) {
                swprintf( AuxBuffer, ( LPWSTR )L"%#x", ValueType );
                SendDlgItemMessage( hDlg,
                                    IDT_VALUE_TYPE,
                                    WM_SETTEXT,
                                    0,
                                    ( LPARAM )AuxBuffer );
            }
            //
            // Use fixed size font
            //
            SendDlgItemMessage( hDlg,
                                IDD_DISPLAY_DATA_BINARY,
                                WM_SETFONT,
                                ( WPARAM )GetStockObject( ANSI_FIXED_FONT ),
                                FALSE );

            //
            //  Display the data in the listbox.
            //


            SendDlgItemMessage( hDlg,
                                IDC_BINARY_DATA_BYTE,
                                BM_SETCHECK,
                                ( WPARAM )TRUE,
                                0 );

            _DumpBinaryData( hDlg, Data, Size );
            CurrentFormat = IDC_BINARY_DATA_BYTE;
            return( TRUE );
        }

        case WM_COMMAND:

            switch( LOWORD( wParam ) ) {

                case IDCANCEL:
                case IDOK:
                    EndDialog( hDlg, TRUE );
                    return( TRUE );

                case IDC_BINARY_DATA_BYTE:
                case IDC_BINARY_DATA_WORD:
                case IDC_BINARY_DATA_DWORD:

                    switch( HIWORD( wParam ) ) {

                        case BN_CLICKED:
                        {
                            ULONG   TopIndex;
                            ULONG   CurrentIndex;

                            //
                            //  Ignore massage if new format is already the current format
                            //
                            if( CurrentFormat == LOWORD( wParam ) ) {
                                return( FALSE );
                            }

                            //
                            //  Save the position of current selection
                            //
                            TopIndex = (ULONG)SendDlgItemMessage( hDlg,
                                                                  IDD_DISPLAY_DATA_BINARY,
                                                                  LB_GETTOPINDEX,
                                                                  0,
                                                                  0 );

                            CurrentIndex = ( ULONG )SendDlgItemMessage( hDlg,
                                                                        IDD_DISPLAY_DATA_BINARY,
                                                                        LB_GETCURSEL,
                                                                        0,
                                                                        0 );
                            //
                            // Reset the listbox
                            //
                            SendDlgItemMessage( hDlg,
                                                IDD_DISPLAY_DATA_BINARY,
                                                LB_RESETCONTENT,
                                                0,
                                                0 );
                            //
                            // Display the data in the appropriate format
                            //
                            if( LOWORD( wParam ) == IDC_BINARY_DATA_BYTE ) {
                                _DumpBinaryData( hDlg, Data, Size );
                                CurrentFormat = IDC_BINARY_DATA_BYTE;
                            } else if( LOWORD( wParam ) == IDC_BINARY_DATA_WORD ) {
                                _DumpBinaryDataAsWords( hDlg, Data, Size );
                                CurrentFormat = IDC_BINARY_DATA_WORD;
                            } else {
                                _DumpBinaryDataAsDwords( hDlg, Data, Size );
                                CurrentFormat = IDC_BINARY_DATA_DWORD;
                            }

                            //
                            //  Restore current selection
                            //
                            SendDlgItemMessage( hDlg,
                                                IDD_DISPLAY_DATA_BINARY,
                                                LB_SETTOPINDEX,
                                                ( WPARAM )TopIndex,
                                                0 );

                            if( CurrentIndex != LB_ERR ) {
                                SendDlgItemMessage( hDlg,
                                                    IDD_DISPLAY_DATA_BINARY,
                                                    LB_SETCURSEL,
                                                    ( WPARAM )CurrentIndex,
                                                    0 );
                            }
                            return( TRUE );
                        }

                        default:

                            break;
                    }
                    break;

                default:

                    break;
            }
            break;

        default:
            break;
    }
    return( FALSE );
}


//------------------------------------------------------------------------------
//  _DumpBinaryData
//
//  DESCRIPTION:  Display the contents of a buffer in a list box, as binary data, using
//                an hd-like format.
//
//  PARAMETERS:  hDlg - a handle to the dialog proceedure.
//               Data - Buffer that contains the binary data.
//               Size - Number of bytes in the buffer.
//------------------------------------------------------------------------------
VOID REGISTRY_DATA::_DumpBinaryData(HWND hDlg, PCBYTE Data, ULONG Size)
{
    WCHAR       AuxData[80];


    DWORD       DataIndex;
    DWORD       DataIndex2;
    WORD        SeperatorChars;
    ULONG       Index;

    if (( Data == NULL ) || ( Size == 0 )) 
    {
        return;
    }

    //
    // DataIndex2 tracks multiples of 16.
    //

    DataIndex2 = 0;

    //
    // Display rows of 16 bytes of data.
    //

    for(DataIndex = 0;
        DataIndex < ( Size >> 4 );
        DataIndex++,
        DataIndex2 = DataIndex << 4 ) {

        //
        //  The string that contains the format in the sprintf below
        //  cannot be broken because cfront  on mips doesn't like it.
        //

        swprintf(AuxData,
                 (LPWSTR)L"%08x   %02x %02x %02x %02x %02x %02x %02x %02x - %02x %02x %02x %02x %02x %02x %02x %02x  %c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c",
                 DataIndex2,
                 Data[ DataIndex2 + 0  ],
                 Data[ DataIndex2 + 1  ],
                 Data[ DataIndex2 + 2  ],
                 Data[ DataIndex2 + 3  ],
                 Data[ DataIndex2 + 4  ],
                 Data[ DataIndex2 + 5  ],
                 Data[ DataIndex2 + 6  ],
                 Data[ DataIndex2 + 7  ],
                 Data[ DataIndex2 + 8  ],
                 Data[ DataIndex2 + 9  ],
                 Data[ DataIndex2 + 10 ],
                 Data[ DataIndex2 + 11 ],
                 Data[ DataIndex2 + 12 ],
                 Data[ DataIndex2 + 13 ],
                 Data[ DataIndex2 + 14 ],
                 Data[ DataIndex2 + 15 ],
                 iswprint( Data[ DataIndex2 + 0  ] )
                    ? Data[ DataIndex2 + 0  ]  : ( WCHAR )'.',
                 iswprint( Data[ DataIndex2 + 1  ] )
                    ? Data[ DataIndex2 + 1  ]  : ( WCHAR )'.',
                 iswprint( Data[ DataIndex2 + 2  ] )
                    ? Data[ DataIndex2 + 2  ]  : ( WCHAR )'.',
                 iswprint( Data[ DataIndex2 + 3  ] )
                    ? Data[ DataIndex2 + 3  ]  : ( WCHAR )'.',
                 iswprint( Data[ DataIndex2 + 4  ] )
                    ? Data[ DataIndex2 + 4  ]  : ( WCHAR )'.',
                 iswprint( Data[ DataIndex2 + 5  ] )
                    ? Data[ DataIndex2 + 5  ]  : ( WCHAR )'.',
                 iswprint( Data[ DataIndex2 + 6  ] )
                    ? Data[ DataIndex2 + 6  ]  : ( WCHAR )'.',
                 iswprint( Data[ DataIndex2 + 7  ] )
                    ? Data[ DataIndex2 + 7  ]  : ( WCHAR )'.',
                 iswprint( Data[ DataIndex2 + 8  ] )
                    ? Data[ DataIndex2 + 8  ]  : ( WCHAR )'.',
                 iswprint( Data[ DataIndex2 + 9  ] )
                    ? Data[ DataIndex2 + 9  ]  : ( WCHAR )'.',
                 iswprint( Data[ DataIndex2 + 10 ] )
                    ? Data[ DataIndex2 + 10 ]  : ( WCHAR )'.',
                 iswprint( Data[ DataIndex2 + 11 ] )
                    ? Data[ DataIndex2 + 11 ]  : ( WCHAR )'.',
                 iswprint( Data[ DataIndex2 + 12 ] )
                    ? Data[ DataIndex2 + 12 ]  : ( WCHAR )'.',
                 iswprint( Data[ DataIndex2 + 13 ] )
                    ? Data[ DataIndex2 + 13 ]  : ( WCHAR )'.',
                 iswprint( Data[ DataIndex2 + 14 ] )
                    ? Data[ DataIndex2 + 14 ]  : ( WCHAR )'.',
                 iswprint( Data[ DataIndex2 + 15 ] )
                    ? Data[ DataIndex2 + 15 ]  : ( WCHAR )'.'
                );
        SendDlgItemMessage( hDlg, IDD_DISPLAY_DATA_BINARY, LB_ADDSTRING, 0, (LONG_PTR)AuxData );
    }

    //
    // If the data size is not an even multiple of 16
    // then there is one additonal line of data to display.
    //

    if( Size % 16 != 0 ) {

        //
        // No seperator characters displayed so far.
        //

        SeperatorChars = 0;

        Index = swprintf( AuxData, (LPWSTR)L"%08x   ", DataIndex << 4 );

        //
        // Display the remaining data, one byte at a time in hex.
        //

        for( DataIndex = DataIndex2;
             DataIndex < Size;
             DataIndex++ ) {

             Index += swprintf( &AuxData[ Index ], (LPWSTR)L"%02x ", Data[ DataIndex ] );

            //
            // If eight data values have been displayed, print
            // the seperator.
            //

            if( DataIndex % 8 == 7 ) {

                Index += swprintf( &AuxData[Index], (LPWSTR)L"%s", (LPWSTR)L"- " );

                //
                // Remember that two seperator characters were
                // displayed.
                //

                SeperatorChars = 2;
            }
        }

        //
        // Fill with blanks to the printable characters position.
        // That is position 63 less 8 spaces for the 'address',
        // 3 blanks, 3 spaces for each value displayed, possibly
        // two for the seperator plus two blanks at the end.
        //

        Index += swprintf( &AuxData[ Index ],
                          (LPWSTR)L"%*c",
                          64
                          - ( 8 + 3
                          + (( DataIndex % 16 ) * 3 )
                          + SeperatorChars
                          + 2 ), ' ' );

        //
        // Display the remaining data, one byte at a time as
        // printable characters.
        //

        for(
            DataIndex = DataIndex2;
            DataIndex < Size;
            DataIndex++ ) {

            Index += swprintf( ( AuxData + Index ),
                               (LPWSTR)L"%c",
                               iswprint( Data[ DataIndex ] )
                                        ? Data[ DataIndex ] : ( WCHAR )'.'
                            );

        }

        SendDlgItemMessage( hDlg, IDD_DISPLAY_DATA_BINARY, LB_ADDSTRING, 0, (LONG_PTR)AuxData );

    }
}


//------------------------------------------------------------------------------
//  _DumpBinaryDataAsWords
//
//  DESCRIPTION:  Display the contents of a buffer in a list box, as binary data, using
//                an hd-like format.
//
//  PARAMETERS:  hDlg - a handle to the dialog proceedure.
//               Data - Buffer that contains the binary data.
//               Size - Number of bytes in the buffer.
//------------------------------------------------------------------------------
VOID REGISTRY_DATA::_DumpBinaryDataAsWords(HWND hDlg, PCBYTE Data,ULONG Size)
{
    ULONG       Index;
    WCHAR       Buffer[ 80 ];
    ULONG       DataIndex;
    ULONG       LineNumber;
    ULONG       WholeLines;


    if( ( Data == NULL ) ||
        ( Size == 0 ) ) {
        return;
    }

    //
    // Display all rows that contain 4 DWORDs.
    //

    WholeLines = Size / 16;
    DataIndex = 0;
    for( LineNumber = 0;
         LineNumber < WholeLines;
         LineNumber++,
         DataIndex += 16 ) {

        //
        //  The string that contains the format in the sprintf below
        //  cannot be broken because cfront  on mips doesn't like it.
        //

        swprintf( Buffer,
                  ( LPWSTR )L"%08x   %04x %04x %04x %04x %04x %04x %04x %04x",
                  DataIndex,
                  *( ( PUSHORT )( &Data[ DataIndex + 0  ] ) ),
                  *( ( PUSHORT )( &Data[ DataIndex + 2  ] ) ),
                  *( ( PUSHORT )( &Data[ DataIndex + 4  ] ) ),
                  *( ( PUSHORT )( &Data[ DataIndex + 6  ] ) ),
                  *( ( PUSHORT )( &Data[ DataIndex + 8  ] ) ),
                  *( ( PUSHORT )( &Data[ DataIndex + 10 ] ) ),
                  *( ( PUSHORT )( &Data[ DataIndex + 12 ] ) ),
                  *( ( PUSHORT )( &Data[ DataIndex + 14 ] ) )
                );
        SendDlgItemMessage( hDlg, IDD_DISPLAY_DATA_BINARY, LB_ADDSTRING, 0, (LONG_PTR)Buffer );
    }

    //
    // If the data size is not an even multiple of 16
    // then there is one additonal line of data to display.
    //

    if( Size % 16 != 0 ) {

        ULONG   NumberOfWords;
        ULONG   Count;

        //
        //  Determine the number of WORDs in the last line
        //

        NumberOfWords = ( Size % 16 ) / 2;

        //
        // Build the offset
        //

        Index = swprintf( Buffer, (LPWSTR)L"%08x   ", DataIndex );

        //
        // Display the remaining words, one at a time in hex.
        //

        for( Count = 0;
             Count < NumberOfWords;
             Count++,
             DataIndex += 2 ) {

             Index += swprintf( &Buffer[ Index ], (LPWSTR)L"%04x ", *( ( PUSHORT )( &Data[ DataIndex ] ) ) );

        }

        //
        //  Display the remaining byte, if any
        //

        if( Size % 2 != 0 ) {
             swprintf( &Buffer[ Index ], (LPWSTR)L"%02x ", Data[ DataIndex ] );
        }

        SendDlgItemMessage( hDlg, IDD_DISPLAY_DATA_BINARY, LB_ADDSTRING, 0, (LONG_PTR)Buffer );

    }
}


//------------------------------------------------------------------------------
//  _DumpBinaryDataAsDwords
//
//  DESCRIPTION:  Display the contents of a buffer in a list box, as DWORDs, using
//                an hd-like format.
//
//  PARAMETERS:  hDlg - a handle to the dialog proceedure.
//               Data - Buffer that contains the binary data.
//               Size - Number of bytes in the buffer.
//------------------------------------------------------------------------------
VOID REGISTRY_DATA::_DumpBinaryDataAsDwords(HWND hDlg, PCBYTE  Data, ULONG Size)
{
    ULONG       Index;
    WCHAR       Buffer[ 80 ];
    ULONG       DataIndex;
    ULONG       LineNumber;
    ULONG       WholeLines;


    if( ( Data == NULL ) ||
        ( Size == 0 ) ) {
        return;
    }

    //
    // Display all rows that contain 4 DWORDs.
    //

    WholeLines = Size / 16;
    DataIndex = 0;
    for( LineNumber = 0;
         LineNumber < WholeLines;
         LineNumber++,
         DataIndex += 16 ) {

        //
        //  The string that contains the format in the sprintf below
        //  cannot be broken because cfront  on mips doesn't like it.
        //

        swprintf( Buffer,
                  ( LPWSTR )L"%08x   %08x %08x %08x %08x",
                  DataIndex,
                  *( ( PULONG )( &Data[ DataIndex + 0  ] ) ),
                  *( ( PULONG )( &Data[ DataIndex + 4  ] ) ),
                  *( ( PULONG )( &Data[ DataIndex + 8  ] ) ),
                  *( ( PULONG )( &Data[ DataIndex + 12  ] ) )
                );
        SendDlgItemMessage( hDlg, IDD_DISPLAY_DATA_BINARY, LB_ADDSTRING, 0, (LONG_PTR)Buffer );
    }

    //
    // If the data size is not an even multiple of 16
    // then there is one additonal line of data to display.
    //

    if( Size % 16 != 0 ) {

        ULONG   NumberOfDwords;
        ULONG   Count;

        //
        // Build the offset
        //

        Index = swprintf( Buffer, (LPWSTR)L"%08x   ", DataIndex );

        //
        //  Determine the number of DWORDs in the last line
        //

        NumberOfDwords = ( Size % 16 ) / 4;

        //
        // Display the remaining dwords, one at a time, if any.
        //

        for( Count = 0;
             Count < NumberOfDwords;
             Count++,
             DataIndex += 4 ) {

             Index += swprintf( &Buffer[ Index ], (LPWSTR)L"%08x ", *( ( PULONG )( &Data[ DataIndex ] ) ) );

        }

        //
        //  Display the remaining word, if any
        //

        if( ( Size % 16 ) % 4 >= 2 ) {
             Index += swprintf( &Buffer[ Index ], (LPWSTR)L"%04x ", *( ( PUSHORT )( &Data[ DataIndex ] ) ) );
             DataIndex += 2;
        }

        //
        //  Display the remaining byte, if any
        //

        if( Size % 2 != 0 ) {
             swprintf( &Buffer[ Index ], (LPWSTR)L"%02x ", Data[ DataIndex ] );
        }

        SendDlgItemMessage( hDlg, IDD_DISPLAY_DATA_BINARY, LB_ADDSTRING, 0, (LONG_PTR)Buffer );

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\regedit\regdef.h ===
/* Do not include this before Windows.h */

/* ASM
; DO NOT INCLUDE THIS BEFORE WINDOWS.INC
*/

#define Dereference(x)  x=x;

/*XLATOFF*/
#pragma warning (disable:4209)      // turn off redefinition warning (with vmm.h)
/*XLATON*/

#ifndef _WINREG_
//  WINREG.H uses DECLARE_HANDLE(HKEY) giving incompatible types.
typedef DWORD       HKEY;
#endif

/*XLATOFF*/
#pragma warning (default:4209)      // turn on redefinition warning (with vmm.h)
/*XLATON*/

#define MAXKEYNAME      256
        // Max length of a key name string
#define MAXVALUENAME_LENGTH MAXKEYNAME
        // Max length of a value name string

//  When we need to increase the buffer to add one character, increase it by
//  (1/4)K so that we won't have to repeatly allocate for every new key stroke.
#define ALLOCATION_INCR                 256

// These file types are in the same order as the filer list in regedit.rc
// The list must start at 1
#define FILE_TYPE_REGEDIT5  1
#define FILE_TYPE_REGEDT32  2
#define FILE_TYPE_TEXT      3
#define FILE_TYPE_REGEDIT4  4

#ifndef REG_SZ
#define REG_SZ      0x0001
#endif

#ifndef REG_BINARY
#define REG_BINARY  0x0003
#endif

#ifndef REG_DWORD
#define REG_DWORD       0x0004
#endif

#ifndef FALSE
#define FALSE   0
#endif
#ifndef TRUE
#define TRUE    ~FALSE
#endif

/* following equates are also defined in Windows.h. To avoid warnings
 *  we should make these equates  conditional
 */


#ifndef ERROR_SUCCESS           
#define ERROR_SUCCESS           0L
#endif

#ifndef ERROR_FILE_NOT_FOUND
#define ERROR_FILE_NOT_FOUND        2L
#endif

#ifndef ERROR_ACCESS_DENIED
#define ERROR_ACCESS_DENIED              5L
#endif

#ifndef ERROR_BADDB
#define ERROR_BADDB                      1009L
#endif

#ifndef ERROR_MORE_DATA
#define ERROR_MORE_DATA                  234L
#endif

#ifndef ERROR_BADKEY
#define ERROR_BADKEY             1010L
#endif

#ifndef ERROR_CANTOPEN
#define ERROR_CANTOPEN                   1011L
#endif

#ifndef ERROR_CANTREAD
#define ERROR_CANTREAD                   1012L
#define ERROR_CANTWRITE                  1013L
#endif

#ifndef ERROR_REGISTRY_CORRUPT
#define ERROR_REGISTRY_CORRUPT           1015L
#define ERROR_REGISTRY_IO_FAILED         1016L
#endif

#ifndef ERROR_KEY_DELETED
#define ERROR_KEY_DELETED                1018L
#endif

#ifndef ERROR_OUTOFMEMORY
#define ERROR_OUTOFMEMORY          14L
#endif

#ifndef ERROR_INVALID_PARAMETER
#define ERROR_INVALID_PARAMETER        87L
#endif

#ifndef ERROR_LOCK_FAILED
#define ERROR_LOCK_FAILED                167L
#endif

#ifndef ERROR_NO_MORE_ITEMS
#define ERROR_NO_MORE_ITEMS       259L
#endif  

// INTERNAL

#ifndef ERROR_CANTOPEN16_FILENOTFOUND32
#define ERROR_CANTOPEN16_FILENOTFOUND32 0xffff0000
#define ERROR_CANTREAD16_FILENOTFOUND32 0xffff0001
#endif

#ifndef HKEY_CLASSES_ROOT
#define HKEY_CLASSES_ROOT          ((HKEY)0x80000000)
#endif

#ifndef HKEY_CURRENT_USER
#define HKEY_CURRENT_USER              ((HKEY)0x80000001)
#endif

#ifndef HKEY_LOCAL_MACHINE
#define HKEY_LOCAL_MACHINE             ((HKEY)0x80000002)
#endif

#ifndef HKEY_USERS
#define HKEY_USERS                     ((HKEY)0x80000003)
#endif

#ifndef HKEY_PERFORMANCE_DATA
#define HKEY_PERFORMANCE_DATA          ((HKEY)0x80000004)
#endif

#ifndef HKEY_CURRENT_CONFIG
#define HKEY_CURRENT_CONFIG            ((HKEY)0x80000005)
#endif

#ifndef HKEY_DYN_DATA
#define HKEY_DYN_DATA                  ((HKEY)0x80000006)
#endif

// INTERNAL

#ifndef HKEY_PREDEF_KEYS
#define HKEY_PREDEF_KEYS    7
#endif

#define MAXREGFILES     HKEY_PREDEF_KEYS    

// sub function indices for Registry services in VMM for 16 bit callers

#define RegOpenKey_Idx      0x100
#define RegCreateKey_Idx    0x101
#define RegCloseKey_Idx     0x102
#define RegDeleteKey_Idx    0x103
#define RegSetValue_Idx     0x104
#define RegQueryValue_Idx   0x105
#define RegEnumKey_Idx      0x106
#define RegDeleteValue_Idx  0x107
#define RegEnumValue_Idx    0x108
#define RegQueryValueEx_Idx 0x109
#define RegSetValueEx_Idx   0x10A
#define RegFlushKey_Idx     0x10B
#define RegLoadKey_Idx      0x10C
#define RegUnLoadKey_Idx    0x10D
#define RegSaveKey_Idx      0x10E
#define RegRestore_Idx      0x10F
#define RegRemapPreDefKey_Idx   0x110

// Data structure passed to SYSDM.CPL DMRegistryError function
//  After UI, the function is to call
//  RegRestore(DWORD iLevel, LPREGQRSTR lpRgRstr)
//

struct Reg_Query_Restore_s {
DWORD   dwRQR_Err;      // Error code
DWORD   hRQR_RootKey;       // Root key for file
DWORD   dwRQR_Reference;    // Reference data for RegRestore
TCHAR   szRQR_SubKey[MAXKEYNAME]; // Subkey (for hives) or NULL string
TCHAR   szRQR_FileName[MAX_PATH]; // File name of bad file
};
typedef struct Reg_Query_Restore_s REGQRSTR;
typedef REGQRSTR FAR * LPREGQRSTR;


// END INTERNAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\regedit\regdwded.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGDWDED.C
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        24 Sep 1994
*
*  Dword edit dialog for use by the Registry Editor.
*
*******************************************************************************/

#include "pch.h"
#include "regresid.h"
#include "reghelp.h"

const DWORD s_EditDwordValueHelpIDs[] = {
    IDC_VALUEDATA,      IDH_REGEDIT_VALUEDATA,
    IDC_VALUENAME,      IDH_REGEDIT_VALUENAME,
    IDC_HEXADECIMAL,    IDH_REGEDIT_DWORDBASE,
    IDC_DECIMAL,        IDH_REGEDIT_DWORDBASE,
    0, 0
};

const TCHAR s_DecimalFormatSpec[] = TEXT("%u");
const TCHAR s_HexadecimalFormatSpec[] = TEXT("%x");

//  Subclassed IDC_VALUEDATA's previous window procedure.  Only one instance of
//  this dialog is assumed to exist.
WNDPROC s_PrevValueDataWndProc;

//  The radio button that is currently selected: IDC_HEXADECIMAL or IDC_DECIMAL.
UINT s_SelectedBase;

UINT
PASCAL
GetDlgItemHex(
    HWND hWnd,
    int nIDDlgItem,
    BOOL *lpTranslated
    );

BOOL
PASCAL
EditDwordValue_OnInitDialog(
    HWND hWnd,
    HWND hFocusWnd,
    LPARAM lParam
    );

VOID
PASCAL
EditDwordValue_SetValueDataText(
    HWND hWnd,
    LPEDITVALUEPARAM lpEditValueParam,
    UINT DlgItem
    );

LRESULT
CALLBACK
EditDwordValue_ValueDataWndProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL EditDwordValue_StoreDlgValueData(HWND hWnd, LPEDITVALUEPARAM lpEditValueParam);

/*******************************************************************************
*
*  GetDlgItemHex
*
*  DESCRIPTION:
*     Like GetDlgItemInt, only for hexadecimal numbers.
*
*  PARAMETERS:
*     See GetDlgItemInt.
*
*******************************************************************************/

UINT
PASCAL
GetDlgItemHex(
    HWND hWnd,
    int nIDDlgItem,
    BOOL *lpTranslated
    )
{

    TCHAR Buffer[10];                   //  Enough to hold 8 digits, null, extra
    UINT Length;
    DWORD Dword;
    UINT Index;
    DWORD Nibble;

    Dword = 0;

    //
    //  We'll assume that the edit control contains only valid characters and
    //  doesn't begin with any spaces (for Regedit this will be true).  So, we
    //  only need to validate that the length of the string isn't too long.
    //

    Length = GetDlgItemText(hWnd, nIDDlgItem, Buffer, sizeof(Buffer)/sizeof(TCHAR));

    if (Length > 0 && Length <= 8) {

        for (Index = 0; Index < Length; Index++) {

            if (Buffer[Index] >= TEXT('0') && Buffer[Index] <= TEXT('9'))
                Nibble = Buffer[Index] - TEXT('0');
            else if (Buffer[Index] >= TEXT('a') && Buffer[Index] <= TEXT('f'))
                Nibble = Buffer[Index] - TEXT('a') + 10;
            else
                Nibble = Buffer[Index] - TEXT('A') + 10;

            Dword = (Dword << 4) + Nibble;

        }

        *lpTranslated = TRUE;
    }
    else
        *lpTranslated = FALSE;

    return Dword;

}

/*******************************************************************************
*
*  EditDwordValueDlgProc
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

INT_PTR
CALLBACK
EditDwordValueDlgProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    )
{

    LPEDITVALUEPARAM lpEditValueParam;
    BOOL Translated;
    DWORD Dword;

    lpEditValueParam = (LPEDITVALUEPARAM) GetWindowLongPtr(hWnd, DWLP_USER);

    switch (Message) {

        HANDLE_MSG(hWnd, WM_INITDIALOG, EditDwordValue_OnInitDialog);

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {

                case IDC_VALUEDATA:
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_KILLFOCUS) 
                    {
                       // EditDwordValue_StoreDlgValueData(hWnd, lpEditValueParam);   
                    }
                    break;

                case IDC_DECIMAL:
                case IDC_HEXADECIMAL:
                    if (EditDwordValue_StoreDlgValueData(hWnd, lpEditValueParam))
                    {
                        EditDwordValue_SetValueDataText(hWnd, lpEditValueParam,
                            GET_WM_COMMAND_ID(wParam, lParam));
                    }
                    else
                    {
                        // Since the value cannot be stored (only happens with decimal to
                        // hex) undo the user's choice.
                        CheckRadioButton(hWnd, IDC_HEXADECIMAL, IDC_DECIMAL, IDC_DECIMAL);
                    }
                    break;

                case IDOK:
                    if (!EditDwordValue_StoreDlgValueData(hWnd, lpEditValueParam))
                    {
                        break;   
                    }
                    // FALL THROUGH

                case IDCANCEL:
                    EndDialog(hWnd, GET_WM_COMMAND_ID(wParam, lParam));
                    break;

            }
            break;

        case WM_HELP:
            WinHelp(((LPHELPINFO) lParam)-> hItemHandle, g_pHelpFileName,
                HELP_WM_HELP, (ULONG_PTR) s_EditDwordValueHelpIDs);
            break;

        case WM_CONTEXTMENU:
            WinHelp((HWND) wParam, g_pHelpFileName, HELP_CONTEXTMENU,
                (ULONG_PTR) s_EditDwordValueHelpIDs);
            break;

        default:
            return FALSE;

    }

    return TRUE;

}

/*******************************************************************************
*
*  EditDwordValue_OnInitDialog
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of EditDwordValue window.
*     hFocusWnd,
*     lParam,
*
*******************************************************************************/

BOOL
PASCAL
EditDwordValue_OnInitDialog(
    HWND hWnd,
    HWND hFocusWnd,
    LPARAM lParam
    )
{

    LPEDITVALUEPARAM lpEditValueParam;

    SetWindowLongPtr(hWnd, DWLP_USER, lParam);
    lpEditValueParam = (LPEDITVALUEPARAM) lParam;

    s_PrevValueDataWndProc = SubclassWindow(GetDlgItem(hWnd, IDC_VALUEDATA),
        EditDwordValue_ValueDataWndProc);

    SetDlgItemText(hWnd, IDC_VALUENAME, lpEditValueParam-> pValueName);

    CheckRadioButton(hWnd, IDC_HEXADECIMAL, IDC_DECIMAL, IDC_HEXADECIMAL);
    EditDwordValue_SetValueDataText(hWnd, lpEditValueParam, IDC_HEXADECIMAL);

    return TRUE;

    UNREFERENCED_PARAMETER(hFocusWnd);

}

/*******************************************************************************
*
*  EditDwordValue_SetValueDataText
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of EditDwordValue window.
*
*******************************************************************************/

VOID
PASCAL
EditDwordValue_SetValueDataText(
    HWND hWnd,
    LPEDITVALUEPARAM lpEditValueParam,
    UINT DlgItem
    )
{

    TCHAR Buffer[12];                    //  Enough to hold 2^32 in decimal
    LPCTSTR lpFormatSpec;
    UINT uEditLength;

    s_SelectedBase = DlgItem;

    if (s_SelectedBase == IDC_DECIMAL) 
    {
        uEditLength = 10;
    } 
    else 
    {
        uEditLength = 8;
    }
    SendDlgItemMessage( hWnd, IDC_VALUEDATA, EM_LIMITTEXT, ( WPARAM )uEditLength, 0L );
    

    lpFormatSpec = (DlgItem == IDC_HEXADECIMAL) ? s_HexadecimalFormatSpec :
        s_DecimalFormatSpec;
    wsprintf(Buffer, lpFormatSpec, ((LPDWORD) lpEditValueParam->
        pValueData)[0]);
    SetDlgItemText(hWnd, IDC_VALUEDATA, Buffer);

}

/*******************************************************************************
*
*  EditDwordValue_ValueDataEditProc
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of EditDwordValue window.
*
*******************************************************************************/

LRESULT
CALLBACK
EditDwordValue_ValueDataWndProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    )
{

    TCHAR Char;

    switch (Message) {

        case WM_CHAR:
            Char = (TCHAR) wParam;

            if (Char >= TEXT(' ')) {

                if ((Char >= TEXT('0') && Char <= TEXT('9')))
                    break;

                if (s_SelectedBase == IDC_HEXADECIMAL &&
                    ((Char >= TEXT('A') && Char <= TEXT('F')) || ((Char >= TEXT('a')) &&
                    (Char <= TEXT('f')))))
                    break;

                MessageBeep(0);
                return 0;

            }
            break;

    }

    return CallWindowProc(s_PrevValueDataWndProc, hWnd, Message, wParam,
        lParam);

}

BOOL EditDwordValue_StoreDlgValueData(HWND hWnd, LPEDITVALUEPARAM lpEditValueParam)
{
    BOOL fTranslated = TRUE;
    DWORD dwValue = (s_SelectedBase == IDC_HEXADECIMAL) ?
        GetDlgItemHex(hWnd, IDC_VALUEDATA, &fTranslated) :
        GetDlgItemInt(hWnd, IDC_VALUEDATA, &fTranslated,
        FALSE);
    
    //
    // Special case: "" == 0
    //
    if(!fTranslated && GetWindowTextLength(GetDlgItem(hWnd, IDC_VALUEDATA)) == 0) {
        dwValue = 0;
        fTranslated = TRUE;
    }

    if (fTranslated)
    {
        ((LPDWORD) lpEditValueParam-> pValueData)[0] = dwValue;
    }
    else 
    {
        MessageBeep(0);
        
        if (InternalMessageBox(g_hInstance, hWnd, MAKEINTRESOURCE(IDS_EDITDWTRUNCATEDEC), 
            MAKEINTRESOURCE(IDS_EDITWARNOVERFLOW), MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2,
            NULL) == IDYES)
        {
            // Truncate Value
            dwValue = 0xffffffff;
            ((LPDWORD) lpEditValueParam-> pValueData)[0] = dwValue;
            fTranslated = TRUE;
        }
    }
    return fTranslated;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\regedit\regdrag.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGDRAG.H
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        05 Mar 1994
*
*  Drag and drop routines for the Registry Editor.
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  05 Mar 1994 TCS Original implementation.
*
*******************************************************************************/

#ifndef _INC_REGDRAG
#define _INC_REGDRAG

VOID
PASCAL
RegEdit_DragObjects(
    HWND hWnd,
    HIMAGELIST hDragImageList,
    PRECT pDragRectArray,
    int DragRectCount,
    POINT HotSpotPoint
    );

#endif // _INC_REGDRAG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\regedit\regdrag.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGDRAG.C
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        05 Mar 1994
*
*  Drag and drop routines for the Registry Editor.
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  05 Mar 1994 TCS Original implementation.
*
*******************************************************************************/

#include "pch.h"
#include "regedit.h"

typedef struct _REGDRAGDRATA {
    POINT DragRectPoint;
    POINT HotSpotPoint;
    HWND hLockWnd;
    PRECT pDragRectArray;
    int DragRectCount;
}   REGDRAGDATA;

REGDRAGDATA s_RegDragData;

VOID
PASCAL
DrawDragRects(
    VOID
    );

/*******************************************************************************
*
*  RegEdit_DragObjects
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*     hSourceWnd, handle of window initiating the drag.
*     hDragImageList, image used during drag operation, assumed to be at image
*        index 0.  May be NULL if pDragRectArray is valid.
*     pDragRectArray, array of rectangles to draw during drag operation.  May
*        be NULL if hDragImageList is valid.
*     DragRectCount, number of rectangles pointed to be pDragRectArray.
*     HotSpotPoint, offset of the cursor hotpoint relative to the image.
*
*******************************************************************************/

VOID
PASCAL
RegEdit_DragObjects(
    HWND hWnd,
    HIMAGELIST hDragImageList,
    PRECT pDragRectArray,
    int DragRectCount,
    POINT HotSpotPoint
    )
{

    RECT CurrentDropRect;
    HCURSOR hDropCursor;
    HCURSOR hNoDropCursor;
    HCURSOR hDragCursor;
    HCURSOR hNewDragCursor;
    POINT Point;
    BOOL fContinueDrag;
    MSG Msg;
    MSG PeekMsg;

    HTREEITEM hCurrentDropTreeItem = NULL;

    GetWindowRect(g_RegEditData.hKeyTreeWnd, &CurrentDropRect);

    GetCursorPos(&Point);
    Point.x -= CurrentDropRect.left;
    Point.y -= CurrentDropRect.top;

    if (hDragImageList != NULL) {
        if ( ImageList_BeginDrag(hDragImageList, 0, HotSpotPoint.x, HotSpotPoint.y) ) {
            ImageList_DragEnter(g_RegEditData.hKeyTreeWnd, Point.x, Point.y );
        }
    }

    s_RegDragData.hLockWnd = g_RegEditData.hKeyTreeWnd;
    LockWindowUpdate(s_RegDragData.hLockWnd);

    if (hDragImageList != NULL) {

        ShowCursor(FALSE);
        ImageList_DragShowNolock(TRUE);

    }

    else {

        s_RegDragData.HotSpotPoint = HotSpotPoint;
        s_RegDragData.pDragRectArray = pDragRectArray;
        s_RegDragData.DragRectCount = DragRectCount;

        s_RegDragData.DragRectPoint = Point;
        DrawDragRects();

    }

    hDropCursor = LoadCursor(NULL, IDC_ARROW);
    hDragCursor = hDropCursor;
    hNoDropCursor = LoadCursor(NULL, IDC_NO);

    SetCapture(hWnd);

    fContinueDrag = TRUE;

    while (fContinueDrag && GetMessage(&Msg, NULL, 0, 0)) {

        switch (Msg.message) {

            case WM_MOUSEMOVE:
                //
                //  If we have another WM_MOUSEMOVE message in the queue
                //  (before any other mouse message), don't process this
                //  mouse message.
                //

                if (PeekMessage(&PeekMsg, NULL, WM_MOUSEFIRST, WM_MOUSELAST,
                    PM_NOREMOVE) && PeekMsg.message == WM_MOUSEMOVE)
                    break;

                if (!PtInRect(&CurrentDropRect, Msg.pt)) {

                    hNewDragCursor = hNoDropCursor;

                }

                else {

                    hNewDragCursor = hDropCursor;

                }

                if (hNewDragCursor != hDragCursor) {

                    if (hDragImageList != NULL) {

                        if (hNewDragCursor == hDropCursor) {

                            ImageList_DragShowNolock(TRUE);
                            ShowCursor(FALSE);

                        }

                        else {

                            ImageList_DragShowNolock(FALSE);
                            ShowCursor(TRUE);
                            SetCursor(hNewDragCursor);

                        }

                    }

                    else
                        SetCursor(hNewDragCursor);

                    hDragCursor = hNewDragCursor;

                }

                Msg.pt.x -= CurrentDropRect.left;
                Msg.pt.y -= CurrentDropRect.top;

                {

                TV_HITTESTINFO TVHitTestInfo;
                HTREEITEM hTreeItem;

                TVHitTestInfo.pt = Msg.pt;
                hTreeItem = TreeView_HitTest(g_RegEditData.hKeyTreeWnd, &TVHitTestInfo);

                if (hTreeItem != hCurrentDropTreeItem) {

                    ImageList_DragShowNolock(FALSE);

//                    DbgPrintf(("Got a drop target!!!\n"));

//                    SetWindowRedraw(g_RegEditData.hKeyTreeWnd, FALSE);

                    TreeView_SelectDropTarget(g_RegEditData.hKeyTreeWnd, hTreeItem);

//                    SetWindowRedraw(g_RegEditData.hKeyTreeWnd, TRUE);

                    hCurrentDropTreeItem = hTreeItem;

                    ImageList_DragShowNolock(TRUE);

                }

                }

                if (hDragImageList != NULL)
                    ImageList_DragMove(Msg.pt.x, Msg.pt.y);

                else {

                    DrawDragRects();
                    s_RegDragData.DragRectPoint = Msg.pt;
                    DrawDragRects();

                }
                break;

            case WM_KEYDOWN:
                if (Msg.wParam != VK_ESCAPE)
                    break;
                //  FALL THROUGH

            case WM_LBUTTONDOWN:
            case WM_RBUTTONDOWN:
                fContinueDrag = FALSE;
                break;

            case WM_LBUTTONUP:
            case WM_RBUTTONUP:
                fContinueDrag = FALSE;
                break;

            default:
                TranslateMessage(&Msg);
                DispatchMessage(&Msg);
                break;

        }

    }

    ReleaseCapture();

    if (hDragImageList != NULL) {

        ImageList_DragShowNolock(FALSE);
        ImageList_EndDrag();

        if (hDragCursor == hDropCursor)
            ShowCursor(TRUE);

    }

    else
        DrawDragRects();

    LockWindowUpdate(NULL);

}

/*******************************************************************************
*
*  DragDragRects
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     (none).
*
*******************************************************************************/

VOID
PASCAL
DrawDragRects(
    VOID
    )
{

    HDC hDC;
    int Index;
    RECT Rect;

    hDC = GetDCEx(s_RegDragData.hLockWnd, NULL, DCX_WINDOW | DCX_CACHE |
        DCX_LOCKWINDOWUPDATE);

    for (Index = s_RegDragData.DragRectCount; Index >= 0; Index--) {

        Rect = s_RegDragData.pDragRectArray[Index];
        OffsetRect(&Rect, s_RegDragData.DragRectPoint.x -
            s_RegDragData.HotSpotPoint.x, s_RegDragData.DragRectPoint.y -
            s_RegDragData.HotSpotPoint.y);
        DrawFocusRect(hDC, &Rect);

    }

    ReleaseDC(s_RegDragData.hLockWnd, hDC);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\regedit\regdwded.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGDWDED.H
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        24 Sep 1994
*
*  Dword edit dialog for use by the Registry Editor.
*
*******************************************************************************/

#ifndef _INC_REGDWDED
#define _INC_REGDWDED

INT_PTR
CALLBACK
EditDwordValueDlgProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    );

#endif // _INC_REGDWDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\regedit\regdesc.cxx ===
/*++

Copyright (c) 1991      Microsoft Corporation

Module Name:

    regdesc.cxx

Abstract:

    This module contains the definitions of the member functions
    of the following classes: PARTIAL_DESCRIPTOR, PORT_DESCRIPTOR,
    INTERRUPT_DESCRIPTOR, MEMORY_DESCRIPTOR, DMA_DESCRIPTOR, and
    DEVICE_SPECIFIC_DESCRIPTOR.

Author:

    Jaime Sasson (jaimes) 02-Dec-1993

Environment:

    ULIB, User Mode


--*/

#include "regdesc.hxx"


DEFINE_CONSTRUCTOR ( PARTIAL_DESCRIPTOR, OBJECT );


PARTIAL_DESCRIPTOR::~PARTIAL_DESCRIPTOR (
    )

/*++

Routine Description:

    Destroy a PARTIAL_DESCRIPTOR.

Arguments:

    None.

Return Value:

    None.

--*/

{
}

VOID
PARTIAL_DESCRIPTOR::Construct (
    )

/*++

Routine Description:

    Construct a PARTIAL_DESCRIPTOR object.

Arguments:

    None.

Return Value:

    None.

--*/

{
        _Type = 0;
        _ShareDisposition = 0;
        _Flags = 0;
}



DEFINE_CONSTRUCTOR ( PORT_DESCRIPTOR, PARTIAL_DESCRIPTOR );


PORT_DESCRIPTOR::~PORT_DESCRIPTOR (
    )

/*++

Routine Description:

    Destroy a PORT_DESCRIPTOR.

Arguments:

    None.

Return Value:

    None.

--*/

{
}

VOID
PORT_DESCRIPTOR::Construct (
    )

/*++

Routine Description:

    Construct a PORT_DESCRIPTOR object.

Arguments:

    None.

Return Value:

    None.

--*/

{
        _PhysicalAddress.LowPart = 0;
        _PhysicalAddress.HighPart = 0;
        _Length = 0;
}



DEFINE_CONSTRUCTOR ( INTERRUPT_DESCRIPTOR, PARTIAL_DESCRIPTOR );


INTERRUPT_DESCRIPTOR::~INTERRUPT_DESCRIPTOR (
    )

/*++

Routine Description:

    Destroy a INTERRUPT_DESCRIPTOR.

Arguments:

    None.

Return Value:

    None.

--*/

{
}

VOID
INTERRUPT_DESCRIPTOR::Construct (
    )

/*++

Routine Description:

    Construct an INTERRUPT_DESCRIPTOR object.

Arguments:

    None.

Return Value:

    None.

--*/

{
    _Affinity = 0;
    _Level = 0;
    _Vector = 0;
}




// #include "ulib.hxx"
// #include "regdesc.hxx"


DEFINE_CONSTRUCTOR ( MEMORY_DESCRIPTOR, PARTIAL_DESCRIPTOR );


MEMORY_DESCRIPTOR::~MEMORY_DESCRIPTOR (
    )

/*++

Routine Description:

    Destroy a MEMORY_DESCRIPTOR.

Arguments:

    None.

Return Value:

    None.

--*/

{
}

VOID
MEMORY_DESCRIPTOR::Construct (
    )

/*++

Routine Description:

    Construct an MEMORY_DESCRIPTOR object.

Arguments:

    None.

Return Value:

    None.

--*/

{
        _StartAddress.LowPart = 0;
        _StartAddress.HighPart = 0;
        _Length = 0;
}


DEFINE_CONSTRUCTOR ( DMA_DESCRIPTOR, PARTIAL_DESCRIPTOR );


DMA_DESCRIPTOR::~DMA_DESCRIPTOR (
    )

/*++

Routine Description:

    Destroy a DMA_DESCRIPTOR.

Arguments:

    None.

Return Value:

    None.

--*/

{
}

VOID
DMA_DESCRIPTOR::Construct (
    )

/*++

Routine Description:

    Construct an MEMORY_DESCRIPTOR object.

Arguments:

    None.

Return Value:

    None.

--*/

{
    _Channel = 0;
    _Port = 0;
    _Reserved1 = 0;
}



DEFINE_CONSTRUCTOR ( DEVICE_SPECIFIC_DESCRIPTOR, PARTIAL_DESCRIPTOR );


DEVICE_SPECIFIC_DESCRIPTOR::~DEVICE_SPECIFIC_DESCRIPTOR (
    )

/*++

Routine Description:

    Destroy a DEVICE_SPECIFIC_DESCRIPTOR.

Arguments:

    None.

Return Value:

    None.

--*/

{
    _DataSize = 0;
    if( _Data != NULL ) {
        FREE( _Data );
    }
}

VOID
DEVICE_SPECIFIC_DESCRIPTOR::Construct (
    )

/*++

Routine Description:

    Construct an DEVICE_SPECIFIC_DESCRIPTOR object.

Arguments:

    None.

Return Value:

    None.

--*/

{
    _Reserved1 = 0;
    _Reserved2 = 0;
    _Data = NULL;
    _DataSize = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\regedit\regedit.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGEDIT.H
*
*  VERSION:     4.0
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        21 Nov 1993
*
*  Common header file for the Registry Editor.  Precompiled header.
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  21 Nov 1993 TCS Original implementation.
*
*******************************************************************************/

#ifndef _INC_REGEDIT
#define _INC_REGEDIT

//  Class name of main application window.
extern const TCHAR g_RegEditClassName[];

#define IDC_KEYTREE                     1
#define IDC_VALUELIST                   2
#define IDC_STATUSBAR                   3

typedef struct _REGEDITDATA {
    HWND hKeyTreeWnd;
    HWND hValueListWnd;
    HWND hStatusBarWnd;
    HWND hFocusWnd;
    int xPaneSplit;
    HIMAGELIST hImageList;
    HKEY hCurrentSelectionKey;
    int SelChangeTimerState;
    int StatusBarShowCommand;
    PTSTR pDefaultValue;
    PTSTR pValueNotSet;
    PTSTR pEmptyBinary;
    PTSTR pCollapse;
    PTSTR pModify;
    PTSTR pModifyBinary;
    PTSTR pNewKeyTemplate;
    PTSTR pNewValueTemplate;
    BOOL fAllowLabelEdits;
    HMENU hMainMenu;
    BOOL fMainMenuInited;
    BOOL fHaveNetwork;
    BOOL fProcessingFind;
    HTREEITEM hMyComputer;
    UINT uExportFormat;
}   REGEDITDATA, *PREGEDITDATA;

extern REGEDITDATA g_RegEditData;

#define SCTS_TIMERCLEAR                 0
#define SCTS_TIMERSET                   1
#define SCTS_INITIALIZING               2
#define REG_READONLY                    0
#define REG_READWRITE                   1

#define MAXKEYNAMEPATH			(MAXKEYNAME * 2)

BOOL
PASCAL
RegisterRegEditClass(
    VOID
    );

HWND
PASCAL
CreateRegEditWnd(
    VOID
    );

VOID
PASCAL
RegEdit_OnCommand(
    HWND hWnd,
    int DlgItem,
    HWND hControlWnd,
    UINT NotificationCode
    );

VOID
PASCAL
RegEdit_SetNewObjectEditMenuItems(
    HMENU hPopupMenu
    );

VOID
PASCAL
RegEdit_SetWaitCursor(
    BOOL fSet
    );

HTREEITEM     RegEdit_GetComputerItem(HTREEITEM hTreeItem);
VOID          RegEdit_InvokeSecurityEditor(HWND hWnd);
PREDEFINE_KEY RegEdit_GetPredefinedKey(HTREEITEM hTreeItem);
void          Regedit_EnableHiveMenuItems(HMENU hPopupMenu);

#define REM_UPDATESTATUSBAR             (WM_USER + 1)

#endif // _INC_REGEDIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\regedit\regedit.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGEDIT.C
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        05 Mar 1994
*
*******************************************************************************/

#include "pch.h"
#include <regstr.h>
#include "regedit.h"
#include "regkey.h"
#include "regvalue.h"
#include "regfile.h"
#include "regprint.h"
#include "regnet.h"
#include "regfind.h"
#include "regresid.h"
#include <htmlhelp.h>
#include <tchar.h>

#include "authz.h"
#include "objbase.h"
#include "aclapi.h"
#include "aclui.h"

extern HRESULT CreateSecurityInformation( IN LPCWSTR strKeyName,
                                          IN LPCWSTR strParentName,
                                          IN LPCWSTR strMachineName,
                                          IN LPCWSTR strPageTitle,
                                          IN BOOL    bRemote,
                                          IN PREDEFINE_KEY PredefinedKey,
                                          IN BOOL bReadOnly,
                                          IN HWND hWnd,
                                          OUT LPSECURITYINFO *pSi);

//
//  Popup menu indexes of the IDM_REGEDIT menu.
//

#define IDM_REGEDIT_FILE_POPUP          0
#define IDM_REGEDIT_EDIT_POPUP          1
#define IDM_REGEDIT_VIEW_POPUP          2
#define IDM_REGEDIT_FAVS_POPUP          3
#define IDM_REGEDIT_HELP_POPUP          4

//
//  Indexes of the "New->" popup menu under the IDM_REGEDIT's "Edit" menu when
//  the focus is in the KeyTree or the ValueList.  Changes because "Modify" and
//  a seperator are dynamically added/removed.
//

#define IDM_EDIT_WHENKEY_NEW_POPUP      0
#define IDM_EDIT_WHENVALUE_NEW_POPUP    2

//
//  Data structure stored in the registry to store the position and sizes of
//  various elements of the Registry Editor interface.
//

typedef struct _REGEDITVIEW {
    WINDOWPLACEMENT WindowPlacement;
    int xPaneSplit;
    int cxNameColumn;
    int cxTypeColumn;
    int cxDataColumn;
    DWORD Flags;
}   REGEDITVIEW, FAR* LPREGEDITVIEW;

#define REV_STATUSBARVISIBLE            0x00000001

//  Class name of main application window.
const TCHAR g_RegEditClassName[] = TEXT("RegEdit_RegEdit");

//  Applet specific information is stored under this key of HKEY_CURRENT_USER.
const TCHAR g_RegEditAppletKey[] = REGSTR_PATH_WINDOWSAPPLETS TEXT("\\Regedit");
//
//  Favorites information is stored under this key of HKEY_CURRENT_USER
//
const TCHAR g_RegEditFavoritesKey[] = REGSTR_PATH_WINDOWSAPPLETS TEXT("\\Regedit\\Favorites");

//  Record of type REGEDITVIEW under g_RegEditAppletKey.
const TCHAR g_RegEditViewValue[] = TEXT("View");
//  Record of type DWORD under g_RegEditAppletKey.
const TCHAR g_RegEditFindFlagsValue[] = TEXT("FindFlags");
//
//  Record of LPTSTR under g_RegEditAppletKey that rememebers that key where RegEdit was closed.
//
const TCHAR g_RegEditLastKeyValue[] = TEXT("LastKey");

//
//  Values for import/export of multiline strings
//
const TCHAR g_RegEditMultiStringsValue[] = TEXT("MultiStrings");

BOOL g_fMultiLineStrings = FALSE;


//  Data structure used when calling GetEffectiveClientRect (which takes into
//  account space taken up by the toolbars/status bars).  First half of the
//  pair is zero when at the end of the list, second half is the control id.
const int s_EffectiveClientRectData[] = {
    1, 0,                               //  For the menu bar, but is unused
    1, IDC_STATUSBAR,
    0, 0                                //  First zero marks end of data
};

//  Context sensitive help array used by the WinHelp engine.
const DWORD g_ContextMenuHelpIDs[] = {
    0, 0
};

//  Data structure used when calling MenuHelp.
const int s_RegEditMenuHelpData[] = {
    0, 0,
    0, (UINT) 0
};

REGEDITDATA g_RegEditData = {
    NULL,                               //  hKeyTreeWnd
    NULL,                               //  hValueListWnd
    NULL,                               //  hStatusBarWnd
    NULL,                               //  hFocusWnd
    0,                                  //  xPaneSplit
    NULL,                               //  hImageList
    NULL,                               //  hCurrentSelectionKey
    SCTS_INITIALIZING,                  //  SelChangeTimerState
    SW_SHOW,                            //  StatusBarShowCommand
    NULL,                               //  pDefaultValue
    NULL,                               //  pValueNotPresent
    NULL,                               //  pEmptyBinary
    NULL,                               //  pCollapse
    NULL,                               //  pModify
    NULL,                               //  pModifyBinary
    NULL,                               //  pNewKeyTemplate
    NULL,                               //  pNewValueTemplate
    FALSE,                              //  fAllowLabelEdits
    NULL,                               //  hMainMenu
    FALSE,                              //  fMainMenuInited
    FALSE,                              //  fHaveNetwork
    FALSE,                              //  fProcessingFind
    NULL,                               //  hMyComputer
    FILE_TYPE_REGEDIT5                  //  uExportFormat
};

BOOL
PASCAL
QueryRegEditView(
    LPREGEDITVIEW lpRegEditView
    );

LRESULT
PASCAL
RegEditWndProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
PASCAL
RegEdit_OnCreate(
    HWND hWnd,
    LPCREATESTRUCT lpCreateStruct
    );

BOOL
PASCAL
RegEdit_OnContextMenu(
    HWND hWnd,
    HWND hWndTarget,
    int xPos,
    int yPos
    );

VOID
PASCAL
RegEdit_OnDestroy(
    HWND hWnd
    );

LRESULT
PASCAL
RegEdit_OnNotify(
    HWND hWnd,
    int DlgItem,
    LPNMHDR lpNMHdr
    );

VOID
PASCAL
RegEdit_OnInitMenuPopup(
    HWND hWnd,
    HMENU hPopupMenu,
    UINT MenuPosition,
    BOOL fSystemMenu
    );

VOID
PASCAL
RegEdit_OnMenuSelect(
    HWND hWnd,
    WPARAM wParam,
    LPARAM lParam
    );

VOID
PASCAL
RegEdit_OnLButtonDown(
    HWND hWnd,
    BOOL fDoubleClick,
    int x,
    int y,
    UINT KeyFlags
    );

VOID
PASCAL
RegEdit_OnCommandSplit(
    HWND hWnd
    );

#define RESIZEFROM_UNKNOWN              0
#define RESIZEFROM_SPLIT                1

VOID
PASCAL
RegEdit_ResizeWindow(
    HWND hWnd,
    UINT ResizeFrom
    );

BOOL
PASCAL
RegEdit_SetImageLists(
    HWND hWnd
    );

VOID
PASCAL
RegEdit_SetSysColors(
    VOID
    );

INT_PTR PASCAL
RegAddFavoriteDlgProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    );

/*******************************************************************************
*
*  RegisterRegEditClass
*
*  DESCRIPTION:
*     Register the RegEdit window class with the system.
*
*  PARAMETERS:
*     (none).
*
*******************************************************************************/

BOOL
PASCAL
RegisterRegEditClass(
    VOID
    )
{

    WNDCLASSEX WndClassEx;

    WndClassEx.cbSize = sizeof(WNDCLASSEX);
    WndClassEx.style = CS_DBLCLKS | CS_BYTEALIGNWINDOW | CS_GLOBALCLASS;
    WndClassEx.lpfnWndProc = RegEditWndProc;
    WndClassEx.cbClsExtra = 0;
    WndClassEx.cbWndExtra = 0;
    WndClassEx.hInstance = g_hInstance;
    WndClassEx.hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_REGEDIT));
    WndClassEx.hCursor = LoadCursor(g_hInstance, MAKEINTRESOURCE(IDC_SPLIT));
    WndClassEx.hbrBackground = (HBRUSH) (COLOR_3DFACE + 1);
    WndClassEx.lpszMenuName = MAKEINTRESOURCE(IDM_REGEDIT);
    WndClassEx.lpszClassName = g_RegEditClassName;
    WndClassEx.hIconSm = LoadImage(g_hInstance, MAKEINTRESOURCE(IDI_REGEDIT),
        IMAGE_ICON, 16, 16, 0);

    return RegisterClassEx(&WndClassEx);

}

/*******************************************************************************
*
*  CreateRegEditWnd
*
*  DESCRIPTION:
*     Creates an instance of the RegEdit window.
*
*  PARAMETERS:
*     (none).
*
*******************************************************************************/

HWND
PASCAL
CreateRegEditWnd(
    VOID
    )
{

    PTSTR pTitle;
    HWND hRegEditWnd;
    REGEDITVIEW RegEditView;
    BOOL fQueryRegEditViewSuccess;

    if ((pTitle = LoadDynamicString(IDS_REGEDIT)) != NULL) {

        fQueryRegEditViewSuccess = QueryRegEditView(&RegEditView);

        hRegEditWnd = CreateWindowEx(WS_EX_WINDOWEDGE | WS_EX_ACCEPTFILES,
            g_RegEditClassName, pTitle, WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,
            CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
            NULL, NULL, g_hInstance, (LPVOID) &RegEditView);

        if (fQueryRegEditViewSuccess) {

            RegEditView.WindowPlacement.length = sizeof(RegEditView.WindowPlacement);
            if (RegEditView.WindowPlacement.showCmd == SW_SHOWMINIMIZED)
                RegEditView.WindowPlacement.showCmd = SW_SHOWDEFAULT;

            SetWindowPlacement(hRegEditWnd, &RegEditView.WindowPlacement);

        }

        else
            ShowWindow(hRegEditWnd, SW_SHOWDEFAULT);

        DeleteDynamicString(pTitle);

    }

    else
        hRegEditWnd = NULL;

    return hRegEditWnd;

}

/*******************************************************************************
*
*  QueryRegEditView
*
*  DESCRIPTION:
*     Check the registry for a data structure that contains the last positions
*     of our various interface components.
*
*  PARAMETERS:
*     (none).
*
*******************************************************************************/

BOOL
PASCAL
QueryRegEditView(
    LPREGEDITVIEW lpRegEditView
    )
{

    BOOL fSuccess;
    HKEY hKey;
    DWORD cbValueData;
    DWORD Type;
    int cxIcon;
    HDC hDC;
    int PixelsPerInch;

    fSuccess = FALSE;

    if (RegOpenKey(HKEY_CURRENT_USER, g_RegEditAppletKey, &hKey) ==
        ERROR_SUCCESS) {

        //
        //  Sort of a hack, but while we're here, pull the last find flags from
        //  the registry as well.
        //

        cbValueData = sizeof(DWORD);

        RegEdit_QueryValueEx(hKey, (LPTSTR) g_RegEditFindFlagsValue, NULL, &Type,
            (LPBYTE) &g_FindFlags, &cbValueData);

        cbValueData = sizeof(REGEDITVIEW);

        if (RegEdit_QueryValueEx(hKey, (LPTSTR) g_RegEditViewValue, NULL, &Type,
            (LPBYTE) lpRegEditView, &cbValueData) == ERROR_SUCCESS &&
            Type == REG_BINARY && cbValueData == sizeof(REGEDITVIEW))
            fSuccess = TRUE;

        RegCloseKey(hKey);

    }

    //
    //  Validate the fields from the view data structure.  Several people have
    //  run into cases where the name and data column widths were invalid so
    //  they couldn't see them.  Without this validation, the only way to fix it
    //  is to run our application... ugh.
    //

    if (fSuccess) {

        cxIcon = GetSystemMetrics(SM_CXICON);

        if (lpRegEditView-> cxNameColumn < cxIcon)
            lpRegEditView-> cxNameColumn = cxIcon;

        if (lpRegEditView-> cxDataColumn < cxIcon)
            lpRegEditView-> cxDataColumn = cxIcon;

        if (lpRegEditView-> xPaneSplit < cxIcon)
            lpRegEditView-> xPaneSplit = cxIcon;

    }

    //
    //  This is probably our first time running the Registry Editor (or else
    //  there was some sort of registry error), so pick some good(?) defaults
    //  for the various interface components.
    //

    else {

        lpRegEditView-> Flags = REV_STATUSBARVISIBLE;

        //
        //  Figure out how many pixels there are in two logical inches.  We use this
        //  to set the initial size of the TreeView pane (this is what the Cabinet
        //  does) and of the Name column of the ListView pane.
        //

        hDC = GetDC(NULL);
        PixelsPerInch = GetDeviceCaps(hDC, LOGPIXELSX);
        ReleaseDC(NULL, hDC);

        lpRegEditView-> xPaneSplit = PixelsPerInch * 9 / 4;     //  2.25 inches
        lpRegEditView-> cxNameColumn = PixelsPerInch * 5 / 4;   //  1.25 inches
        lpRegEditView-> cxTypeColumn = PixelsPerInch * 5 / 4;   //  1.25 inches
        lpRegEditView-> cxDataColumn = PixelsPerInch * 3;       //  3.00 inches

    }

    return fSuccess;

}

/*******************************************************************************
*
*  RegEditWndProc
*
*  DESCRIPTION:
*     Callback procedure for the RegEdit window.
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*     Message,
*     wParam,
*     lParam,
*     (returns),
*
*******************************************************************************/

LRESULT
PASCAL
RegEditWndProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    )
{

    switch (Message) {

        HANDLE_MSG(hWnd, WM_CREATE, RegEdit_OnCreate);
        HANDLE_MSG(hWnd, WM_DESTROY, RegEdit_OnDestroy);
        HANDLE_MSG(hWnd, WM_COMMAND, RegEdit_OnCommand);
        HANDLE_MSG(hWnd, WM_NOTIFY, RegEdit_OnNotify);
        HANDLE_MSG(hWnd, WM_INITMENUPOPUP, RegEdit_OnInitMenuPopup);
        HANDLE_MSG(hWnd, WM_LBUTTONDOWN, RegEdit_OnLButtonDown);
        HANDLE_MSG(hWnd, WM_DROPFILES, RegEdit_OnDropFiles);

        //can't use HANDLE_MSG for this because we lose the sign on the x and y parms
        case WM_CONTEXTMENU:
            if (!RegEdit_OnContextMenu(hWnd, (HWND)(wParam), GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam)))
                goto dodefault;
            break;

        //
        //  We have to update the status bar after a rename, but the tree item's
        //  text hasn't changed until after we return from the end notification,
        //  so we post this dummy message to tell ourselves to do it later.
        //
        case REM_UPDATESTATUSBAR:
            RegEdit_UpdateStatusBar();
            break;

        //
        //  We must watch for this message to know that when we're in
        //  WM_INITMENUPOPUP, we're really looking at the main menu and not a
        //  context menu.
        //
        case WM_INITMENU:
            g_RegEditData.fMainMenuInited = (g_RegEditData.hMainMenu == (HMENU)
                wParam);
            break;

        case WM_ACTIVATE:
            if (wParam == WA_INACTIVE)
                break;
            //  FALL THROUGH

        case WM_SETFOCUS:
            SetFocus(g_RegEditData.hFocusWnd);
            break;

        case WM_WININICHANGE:
            RegEdit_SetImageLists(hWnd);
            //  FALL THROUGH

        case WM_SYSCOLORCHANGE:
            RegEdit_SetSysColors();
            SendChildrenMessage(hWnd, Message, wParam, lParam);
            //  FALL THROUGH

        case WM_SIZE:
            RegEdit_ResizeWindow(hWnd, RESIZEFROM_UNKNOWN);
            break;

        case WM_TIMER:
            RegEdit_OnSelChangedTimer(hWnd);
            break;

        case WM_MENUSELECT:
            RegEdit_OnMenuSelect(hWnd, wParam, lParam);
            break;

        case WM_PAINT:
            //
            //  Force a paint of the TreeView if we're in the middle of a find.
            //  See REGFIND.C for details on this hack.
            //

            if (g_RegEditData.fProcessingFind) {

                SetWindowRedraw(g_RegEditData.hKeyTreeWnd, TRUE);
                UpdateWindow(g_RegEditData.hKeyTreeWnd);
                SetWindowRedraw(g_RegEditData.hKeyTreeWnd, FALSE);

            }
            goto dodefault;

        dodefault:
        default:
            return DefWindowProc(hWnd, Message, wParam, lParam);

    }

    return 0;

}

/*******************************************************************************
*
*  RegEdit_ExpandKeyPath
*
*  DESCRIPTION: Traverses registry tree to display the desired key path.
*
*  PARAMETERS:
*     lpExpandPath - Destination path of registry key to expand
*
*******************************************************************************/

VOID
PASCAL
RegEdit_ExpandKeyPath(
    LPTSTR lpExpandPath
    )
{
    HTREEITEM hItem, hNext;
    TCHAR KeyName[MAXKEYNAMEPATH*2];
    LPTSTR lpKeyName = KeyName;
    TCHAR ExpandBuffer[MAXKEYNAMEPATH*2];
    LPTSTR lpExpandBuffer = ExpandBuffer;
    LPTSTR lpCurrent, lpOriginal;
    BOOL bLastNode = FALSE;
    TV_ITEM TVItem;

    // Make sure we aren't already at the destination path.
    hItem = TreeView_GetSelection(g_RegEditData.hKeyTreeWnd);
    KeyTree_BuildKeyPath(g_RegEditData.hKeyTreeWnd, hItem, lpKeyName, BKP_TOCOMPUTER);
    if (!lstrcmpi(lpKeyName, lpExpandPath))
        return;

    // Intialize lpKeyName to the My Computer string
    KeyTree_BuildKeyPath(g_RegEditData.hKeyTreeWnd, g_RegEditData.hMyComputer, lpKeyName, BKP_TOCOMPUTER);

    // Walk backwards until we find a common root node and place that in lpKeyName.
    while ((hItem != g_RegEditData.hMyComputer) && hItem)
    {
        hItem = TreeView_GetParent(g_RegEditData.hKeyTreeWnd, hItem);
        KeyTree_BuildKeyPath(g_RegEditData.hKeyTreeWnd, hItem, lpKeyName, BKP_TOCOMPUTER);
        if (!_tcsncmp(lpKeyName, lpExpandPath, lstrlen(lpKeyName)))
            break;
    }
    
    // Make sure the common parent node is selected and visible.
    TreeView_SelectItem(g_RegEditData.hKeyTreeWnd, hItem);
    TreeView_EnsureVisible(g_RegEditData.hKeyTreeWnd, hItem);

    //
    // If the destination path is deeper than the common parent,
    // we want to null-terminate the path components so we can
    // expand the registry tree for each path sub-component.
    //
    lstrcpy(lpExpandBuffer, lpExpandPath);
    lpOriginal = lpExpandBuffer;
    if (lstrlen(lpExpandBuffer) >= lstrlen(lpKeyName))
    {
        while (!bLastNode)
        {
            // Try to find the next path separator
            lpCurrent = (LPTSTR) _tcschr(lpOriginal, TEXT('\\'));
            if (lpCurrent) 
            {            
                // Null-terminate the sub-string
                *lpCurrent = 0;

                // Check if there's more
                if (lpCurrent <= (lpExpandBuffer + lstrlen(lpKeyName)))
                {
                    // Now step over the path separator we just made NULL
                    lpOriginal = lpCurrent + 1;
                } else bLastNode = TRUE;
            } else bLastNode = TRUE;
        }

        // Now reset bLastNode to FALSE
        bLastNode = FALSE;
    }

    //
    // Get the first child from the common parent and start traversing the treeview
    //
    hItem = TreeView_GetChild(g_RegEditData.hKeyTreeWnd, hItem);
    while(hItem)
    {
        // Get a handle to the next node 
        hNext = TreeView_GetNextSibling(g_RegEditData.hKeyTreeWnd, hItem);

        ZeroMemory(&TVItem, sizeof(TV_ITEM));
        TVItem.hItem = hItem;
        TVItem.mask = TVIF_TEXT;
        TVItem.pszText = lpKeyName;
        TVItem.cchTextMax = sizeof(KeyName);
        TreeView_GetItem(g_RegEditData.hKeyTreeWnd, &TVItem);

        //
        // If the child node matches our path component, then we want to expand that node.
        //
        if (!lstrcmpi(lpKeyName, lpOriginal))
        {
            TreeView_Expand(g_RegEditData.hKeyTreeWnd, hItem, TVE_EXPAND);

            // Replace hNext with the first child of our freshly expanded node.
            hNext = TreeView_GetChild(g_RegEditData.hKeyTreeWnd, hItem);

            // If this is the last node, make it visible and return
            if (bLastNode || !lpCurrent)
            {
                TreeView_SelectItem(g_RegEditData.hKeyTreeWnd, hItem);
                TreeView_EnsureVisible(g_RegEditData.hKeyTreeWnd, hItem);
                return;
            }
            else lpOriginal = lpCurrent + 1;

            lpCurrent = (LPTSTR) _tcschr(lpOriginal, TEXT('\\'));
            if (!lpCurrent)
                bLastNode = TRUE;
            else *lpCurrent = 0;
        }

        // Repeat the loop with the appropriate next tree node
        hItem = hNext;
    }
}

/*******************************************************************************
*
*  RegEdit_OnContextMenu
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*     hWndTarget, handle of window in which WM_CONTEXTMENU occurred.
*     xPos
*     yPos
*
*******************************************************************************/

BOOL
PASCAL
RegEdit_OnContextMenu(
    HWND hWnd,
    HWND hWndTarget,
    int xPos,
    int yPos
    )
{
    BOOL bAccel = ((xPos == -1) && (yPos == -1)) ? TRUE : FALSE;
    if (hWndTarget == g_RegEditData.hKeyTreeWnd)
        RegEdit_OnKeyTreeContextMenu(hWndTarget, bAccel);
    else if (hWndTarget == g_RegEditData.hValueListWnd)
        RegEdit_OnValueListContextMenu(hWndTarget, bAccel);
    else
        return FALSE;
    return TRUE;
}

/*******************************************************************************
*
*  RegEdit_OnCreate
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*
*******************************************************************************/

BOOL
PASCAL
RegEdit_OnCreate(
    HWND hWnd,
    LPCREATESTRUCT lpCreateStruct
    )
{

    LPREGEDITVIEW lpRegEditView;
    UINT Index;
    TV_INSERTSTRUCT TVInsertStruct;
    TCHAR CheckChildrenKeyName[MAXKEYNAME];
    LV_COLUMN LVColumn;
    HMENU hPopupMenu;
    HKEY hKey;
    DWORD cbValueData;
    DWORD Type;
    TCHAR KeyName[MAXKEYNAMEPATH*2];
    LPTSTR lpKeyName = KeyName;
    DWORD dwStyleEx = WS_EX_CLIENTEDGE;
    DWORD dwLayout = 0;
    DWORD dwValue = 0;

    lpRegEditView = (LPREGEDITVIEW) lpCreateStruct-> lpCreateParams;

    //
    //  Load several strings that will be using very often to display the keys
    //  and values.
    //

    if ((g_RegEditData.pDefaultValue = LoadDynamicString(IDS_DEFAULTVALUE)) ==
        NULL)
        return FALSE;

    if ((g_RegEditData.pValueNotSet = LoadDynamicString(IDS_VALUENOTSET)) ==
        NULL)
        return FALSE;

    if ((g_RegEditData.pEmptyBinary = LoadDynamicString(IDS_EMPTYBINARY)) ==
        NULL)
        return FALSE;

    if ((g_RegEditData.pCollapse = LoadDynamicString(IDS_COLLAPSE)) == NULL)
        return FALSE;

    if ((g_RegEditData.pModify = LoadDynamicString(IDS_MODIFY)) == NULL)
        return FALSE;

    if ((g_RegEditData.pModifyBinary = LoadDynamicString(IDS_MODIFYBINARY)) == NULL)
        return FALSE;

    if ((g_RegEditData.pNewKeyTemplate =
        LoadDynamicString(IDS_NEWKEYNAMETEMPLATE)) == NULL)
        return FALSE;

    if ((g_RegEditData.pNewValueTemplate =
        LoadDynamicString(IDS_NEWVALUENAMETEMPLATE)) == NULL)
        return FALSE;

    /*
     * Check if the default layout for this process is RTL.  Most data
     * in the registry is best edited with LTR reading order.  So we
     * reverse the reading order for the two data windows (key tree and
     * value list) again.
     */
    if (GetProcessDefaultLayout(&dwLayout)) {
        if (dwLayout & LAYOUT_RTL) {
            dwStyleEx |= WS_EX_RTLREADING;  // Actually just switches back to LTR.
        }
    }

    //
    //  Create the left pane, a TreeView control that displays the keys of the
    //  registry.
    //

    if ((g_RegEditData.hKeyTreeWnd = CreateWindowEx(dwStyleEx,
        WC_TREEVIEW, NULL, WS_CHILD | WS_VISIBLE | WS_TABSTOP | TVS_HASBUTTONS |
        TVS_DISABLEDRAGDROP | TVS_LINESATROOT | TVS_HASLINES | TVS_EDITLABELS,
        0, 0, 0, 0, hWnd, (HMENU) IDC_KEYTREE, g_hInstance, NULL)) == NULL)
        return FALSE;

    //
    //  Create the right pane, a ListView control that displays the values of
    //  the currently selected key of the sibling TreeView control.
    //

    if ((g_RegEditData.hValueListWnd = CreateWindowEx(dwStyleEx,
        WC_LISTVIEW, NULL, WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN |
        WS_TABSTOP | LVS_REPORT | LVS_ALIGNLEFT | LVS_EDITLABELS |
        LVS_SHAREIMAGELISTS | LVS_NOSORTHEADER, 0, 0, 0, 0, hWnd,
        (HMENU) IDC_VALUELIST, g_hInstance, NULL)) == NULL)
        return FALSE;

    ListView_SetExtendedListViewStyleEx(g_RegEditData.hValueListWnd,
            LVS_EX_LABELTIP, LVS_EX_LABELTIP);

    //
    //  Create the status bar window.  We'll set it to "simple" mode now
    //  because we need only one pane that's only used when scrolling through
    //  the menus.
    //

    if ((g_RegEditData.hStatusBarWnd = CreateStatusWindow(WS_CHILD |
        SBARS_SIZEGRIP | CCS_NOHILITE, NULL, hWnd, IDC_STATUSBAR)) == NULL)
        return FALSE;

    g_RegEditData.StatusBarShowCommand = lpRegEditView-> Flags &
        REV_STATUSBARVISIBLE ? SW_SHOW : SW_HIDE;
    ShowWindow(g_RegEditData.hStatusBarWnd, g_RegEditData.StatusBarShowCommand);

    if (!RegEdit_SetImageLists(hWnd))
        return FALSE;

    RegEdit_SetSysColors();

    //
    //
    //

    TVInsertStruct.hParent = TVI_ROOT;
    TVInsertStruct.hInsertAfter = TVI_LAST;
    TVInsertStruct.item.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE |
        TVIF_PARAM | TVIF_CHILDREN;
    //  TVInsertStruct.item.hItem = NULL;
    //  TVInsertStruct.item.state = 0;
    //  TVInsertStruct.item.stateMask = 0;
    //  TVInsertStruct.item.cchTextMax = 0;

    TVInsertStruct.item.iImage = IMAGEINDEX(IDI_COMPUTER);
    TVInsertStruct.item.iSelectedImage = IMAGEINDEX(IDI_COMPUTER);
    TVInsertStruct.item.cChildren = TRUE;
    TVInsertStruct.item.lParam = 0;

    TVInsertStruct.item.pszText = LoadDynamicString(IDS_COMPUTER);
    TVInsertStruct.hParent = TreeView_InsertItem(g_RegEditData.hKeyTreeWnd,
        &TVInsertStruct);
    DeleteDynamicString(TVInsertStruct.item.pszText);

    TVInsertStruct.item.iImage = IMAGEINDEX(IDI_FOLDER);
    TVInsertStruct.item.iSelectedImage = IMAGEINDEX(IDI_FOLDEROPEN);

    for (Index = 0; Index < NUMBER_REGISTRY_ROOTS; Index++) {

#ifdef WINNT
    //
    //  HKEY_DYN_DATA is not available on NT, so don't bother including it
    //  in the tree.  Note we still keep the string around in case we can
    //  connect to the key remotely.
    //

    if (Index == INDEX_HKEY_DYN_DATA)
        continue;
#endif

        TVInsertStruct.item.pszText = g_RegistryRoots[Index].lpKeyName;
        TVInsertStruct.item.lParam = (LPARAM) g_RegistryRoots[Index].hKey;

        TVInsertStruct.item.cChildren = (RegEnumKey(g_RegistryRoots[Index].hKey,
            0, CheckChildrenKeyName, sizeof(CheckChildrenKeyName)/sizeof(TCHAR)) ==
            ERROR_SUCCESS);

        TreeView_InsertItem(g_RegEditData.hKeyTreeWnd, &TVInsertStruct);

    }

    TreeView_Expand(g_RegEditData.hKeyTreeWnd, TVInsertStruct.hParent,
        TVE_EXPAND);
    TreeView_SelectItem(g_RegEditData.hKeyTreeWnd, TVInsertStruct.hParent);

    g_RegEditData.SelChangeTimerState = SCTS_TIMERCLEAR;

    //
    //
    //

    g_RegEditData.hFocusWnd = g_RegEditData.hKeyTreeWnd;

    g_RegEditData.xPaneSplit = lpRegEditView-> xPaneSplit;

    //
    //  Set the column headings used by our report-style ListView control.
    //

    LVColumn.mask = LVCF_WIDTH | LVCF_TEXT;

    LVColumn.cx = lpRegEditView-> cxNameColumn;
    LVColumn.pszText = LoadDynamicString(IDS_NAMECOLUMNLABEL);
    ListView_InsertColumn(g_RegEditData.hValueListWnd, 0, &LVColumn);
    DeleteDynamicString(LVColumn.pszText);

    LVColumn.cx = lpRegEditView-> cxTypeColumn;
    LVColumn.pszText = LoadDynamicString(IDS_TYPECOLUMNLABEL);
    ListView_InsertColumn(g_RegEditData.hValueListWnd, 1, &LVColumn);
    DeleteDynamicString(LVColumn.pszText);

    LVColumn.cx = lpRegEditView-> cxDataColumn;
    LVColumn.pszText = LoadDynamicString(IDS_DATACOLUMNLABEL);
    ListView_InsertColumn(g_RegEditData.hValueListWnd, 2, &LVColumn);
    DeleteDynamicString(LVColumn.pszText);

    //
    //  Do a one-time zero fill of the PRINTDLGEX to have it in a known state.
    //

    memset(&g_PrintDlg, 0, sizeof(PRINTDLGEX));

    g_RegEditData.hMainMenu = GetMenu(hWnd);
    g_RegEditData.fHaveNetwork = GetSystemMetrics(SM_NETWORK) & RNC_NETWORKS;

    if (!g_RegEditData.fHaveNetwork) {

        hPopupMenu = GetSubMenu(g_RegEditData.hMainMenu,
            IDM_REGEDIT_FILE_POPUP);

        DeleteMenu(hPopupMenu, ID_CONNECT, MF_BYCOMMAND);
        DeleteMenu(hPopupMenu, ID_DISCONNECT, MF_BYCOMMAND);
        DeleteMenu(hPopupMenu, ID_NETSEPARATOR, MF_BYCOMMAND);

    }

    g_RegEditData.hMyComputer = TreeView_GetSelection(g_RegEditData.hKeyTreeWnd);

    //
    //  Send the tree-view control to the last location, if one is set.
    //
    if (RegOpenKey(HKEY_CURRENT_USER, g_RegEditAppletKey, &hKey) ==
       ERROR_SUCCESS) 
    {
        cbValueData = MAXKEYNAMEPATH * 2;

        if (RegEdit_QueryValueEx(hKey, (LPTSTR) g_RegEditLastKeyValue, NULL, &Type,
            (LPBYTE) lpKeyName, &cbValueData) == ERROR_SUCCESS &&
            Type == REG_SZ && cbValueData > 0)
        {
            RegEdit_ExpandKeyPath(lpKeyName);
        }

        cbValueData = sizeof(dwValue);
        
        if ((RegEdit_QueryValueEx(hKey, (LPTSTR) g_RegEditMultiStringsValue, NULL, &Type,
            (LPBYTE) &dwValue, &cbValueData) == ERROR_SUCCESS) &&
            (Type == REG_DWORD) && (cbValueData > 0) && (dwValue != 0))
        {
            g_fMultiLineStrings = TRUE;
        }

        RegCloseKey(hKey);  
    }

    return TRUE;

}

/*******************************************************************************
*
*  RegEdit_OnDestroy
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnDestroy(
    HWND hWnd
    )
{

    REGEDITVIEW RegEditView;
    HKEY hKey;
    HWND hValueListWnd;
    DWORD cbValueData;
    HWND hKeyTreeWnd;
    TCHAR KeyName[MAXKEYNAMEPATH * 2];
    LPTSTR lpKeyName = KeyName;

    //
    //  Write out a new RegEditView record to the registry for our next
    //  (hopeful?) activation.
    //

    if (RegCreateKey(HKEY_CURRENT_USER, g_RegEditAppletKey, &hKey) ==
        ERROR_SUCCESS) {

        RegEditView.WindowPlacement.length = sizeof(WINDOWPLACEMENT);
        GetWindowPlacement(hWnd, &RegEditView.WindowPlacement);

        RegEditView.xPaneSplit = g_RegEditData.xPaneSplit;

        hValueListWnd = g_RegEditData.hValueListWnd;
        RegEditView.cxNameColumn = ListView_GetColumnWidth(hValueListWnd, 0);
        RegEditView.cxTypeColumn = ListView_GetColumnWidth(hValueListWnd, 1);
        RegEditView.cxDataColumn = ListView_GetColumnWidth(hValueListWnd, 2);

        RegEditView.Flags = (g_RegEditData.StatusBarShowCommand == SW_HIDE) ?
            0 : REV_STATUSBARVISIBLE;

        cbValueData = sizeof(REGEDITVIEW);
        RegSetValueEx(hKey, g_RegEditViewValue, 0, REG_BINARY,
            (LPBYTE) &RegEditView, cbValueData);

        cbValueData = sizeof(DWORD);
        RegSetValueEx(hKey, g_RegEditFindFlagsValue, 0, REG_DWORD,
            (LPBYTE) &g_FindFlags, cbValueData);

        //
        // Save the key before RegEdit closes so we can start there next time!
        //
        hKeyTreeWnd = g_RegEditData.hKeyTreeWnd;
        KeyTree_BuildKeyPath(hKeyTreeWnd, TreeView_GetSelection(hKeyTreeWnd), lpKeyName, BKP_TOCOMPUTER);
        cbValueData = (lstrlen(lpKeyName) + 1) * sizeof (TCHAR);
        RegSetValueEx(hKey, g_RegEditLastKeyValue, 0, REG_SZ, (LPBYTE) lpKeyName, cbValueData);

        RegCloseKey(hKey);

    }

    TreeView_SelectItem(g_RegEditData.hKeyTreeWnd, NULL);

    if (g_RegEditData.hCurrentSelectionKey != NULL)
        RegCloseKey(g_RegEditData.hCurrentSelectionKey);

    if (g_RegEditData.hImageList != NULL)
        ImageList_Destroy(g_RegEditData.hImageList);

    PostQuitMessage(0);

}

/*******************************************************************************
*
*  RegAddFavoriteDlgProc
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

INT_PTR
PASCAL
RegAddFavoriteDlgProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    static LPTSTR lpFavoriteName;

    switch (Message) {

        case WM_INITDIALOG:
            lpFavoriteName = (LPTSTR) lParam;
            SendDlgItemMessage(hWnd, IDC_FAVORITENAME, EM_SETLIMITTEXT,
                MAXKEYNAMEPATH, 0);
            SetWindowText(GetDlgItem(hWnd, IDC_FAVORITENAME), (LPTSTR) lParam);
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {

                case IDC_FAVORITENAME:
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE)
                        EnableWindow(GetDlgItem(hWnd, IDOK),
                            SendMessage(GET_WM_COMMAND_HWND(wParam, lParam),
                            WM_GETTEXTLENGTH, 0, 0) != 0);
                    break;

                case IDOK:
                    GetDlgItemText(hWnd, IDC_FAVORITENAME, lpFavoriteName,
                        MAXKEYNAMEPATH);
                    //  FALL THROUGH

                case IDCANCEL:
                    EndDialog(hWnd, GET_WM_COMMAND_ID(wParam, lParam));
                    break;

            }
            break;

        default:
            return FALSE;

    }

    return TRUE;

}

/*******************************************************************************
*
*  RegEdit_OnAddToFavorites
*
*  DESCRIPTION:
*     Handles the selection of Favorites
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnAddToFavorites(
    HWND hWnd
    )
{
    TCHAR KeyName[MAXKEYNAMEPATH*2];
    LPTSTR lpKeyName = KeyName;
    TCHAR FavoriteName[MAXKEYNAMEPATH*2];
    LPTSTR lpFavoriteName = FavoriteName;
    LPTSTR lpCurrent, lpOriginal;
    DWORD cbValueData, dwType;
    LONG lRet;
    HKEY hKey;

    if (RegCreateKey(HKEY_CURRENT_USER, g_RegEditFavoritesKey, &hKey) ==
        ERROR_SUCCESS) 
    {
        KeyTree_BuildKeyPath(g_RegEditData.hKeyTreeWnd, TreeView_GetSelection(g_RegEditData.hKeyTreeWnd), 
            lpKeyName, BKP_TOCOMPUTER);

        lpOriginal = lpCurrent = lpKeyName;
        while (lpCurrent)
        {
            lpCurrent = (LPTSTR) _tcsrchr(lpOriginal, TEXT('\\'));
            if (lpCurrent)
            {
                lpCurrent++;
                lpOriginal = lpCurrent;
            }
        }

        while (TRUE)
        {
            lstrcpy(lpFavoriteName, lpOriginal);

            if (DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_ADDFAVORITE), hWnd,
                RegAddFavoriteDlgProc, (LPARAM) lpFavoriteName) != IDOK)
            {
                RegCloseKey(hKey);
                return;
            }

            if (*lpFavoriteName)
            {
                lRet = RegEdit_QueryValueEx(hKey, lpFavoriteName, NULL, &dwType, NULL, NULL);
                if (lRet)
                    break;
                
                InternalMessageBox(g_hInstance, hWnd, MAKEINTRESOURCE(IDS_FAVORITEEXISTS), 
                    MAKEINTRESOURCE(IDS_FAVORITEERROR), MB_ICONERROR | MB_OK);
            }
        }
    
        cbValueData = (lstrlen(lpKeyName) + 1) * sizeof(TCHAR);
        RegSetValueEx(hKey, lpFavoriteName, 0, REG_SZ, (LPBYTE) lpKeyName, cbValueData);
        
        RegCloseKey(hKey);
    }
}


/*******************************************************************************
*
*  RegRemoveFavoriteDlgProc
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

INT_PTR
PASCAL
RegRemoveFavoriteDlgProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    TCHAR KeyName[MAXKEYNAMEPATH*2];
    LPTSTR lpKeyName = KeyName;
    TCHAR ValueName[MAXKEYNAMEPATH*2];
    LPTSTR lpValueName = ValueName;
    DWORD cbValueName, dwType;
    HWND hListBox;
    HKEY hKey = NULL;
    LONG lRet;
    int i = 0;
    
    switch (Message) {

        case WM_INITDIALOG:

            if (RegCreateKey(HKEY_CURRENT_USER, g_RegEditFavoritesKey, &hKey) ==
                ERROR_SUCCESS) 
            {
                while (TRUE)
                {           
                    cbValueName = MAXKEYNAMEPATH * 2;
                    lRet = RegEnumValue(hKey, i++, lpValueName, &cbValueName, NULL, &dwType, NULL, NULL);
                    if (lRet)
                        break;
                    ListBox_AddString(GetDlgItem(hWnd, IDC_FAVORITES), lpValueName);
                }
                RegCloseKey(hKey);
            }
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {

                case IDOK:
                    hListBox = GetDlgItem(hWnd, IDC_FAVORITES);
                    if (ListBox_GetSelCount(hListBox) > 0)
                    {
                        if (RegCreateKey(HKEY_CURRENT_USER, g_RegEditFavoritesKey, &hKey) ==
                            ERROR_SUCCESS) 
                        {
                            for(i=0;i<ListBox_GetCount(hListBox);i++)
                            {
                                if (ListBox_GetSel(hListBox, i) != 0)
                                {
                                    ListBox_GetText(hListBox, i, lpValueName);
                                    RegDeleteValue(hKey, lpValueName);
                                }
                            }
                        }
                    }
                    // Fall through

                case IDCANCEL:
                    EndDialog(hWnd, GET_WM_COMMAND_ID(wParam, lParam));
                    break;

            }
            break;

        default:
            return FALSE;

    }

    return TRUE;

}

/*******************************************************************************
*
*  RegEdit_OnRemoveFavorite
*
*  DESCRIPTION:
*     Handles the removal of Favorites
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnRemoveFavorite(
    HWND hWnd
    )
{
    DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_REMFAVORITE), hWnd,
        RegRemoveFavoriteDlgProc, (LPARAM) NULL);
}

/*******************************************************************************
*
*  RegEdit_OnSelectFavorite
*
*  DESCRIPTION:
*     Handles the selection of Favorites
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*     DlgItem, the favorite index
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnSelectFavorite(
    HWND hWnd,
    int DlgItem
    )
{
    TCHAR KeyName[MAXKEYNAMEPATH*2];
    LPTSTR lpKeyName = KeyName;
    TCHAR ValueName[MAXKEYNAMEPATH*2];
    LPTSTR lpValueName = ValueName;
    DWORD cbValueData, cbValueName, dwType;
    HKEY hKey;

    if (RegOpenKey(HKEY_CURRENT_USER, g_RegEditFavoritesKey, &hKey) ==
       ERROR_SUCCESS) 
    {
        cbValueData = MAXKEYNAMEPATH * 2;
        cbValueName = MAXKEYNAMEPATH * 2;

        if (RegEnumValue(hKey, DlgItem - ID_ADDTOFAVORITES - 1, lpValueName, &cbValueName, NULL, 
            &dwType, (LPBYTE) lpKeyName, &cbValueData) == ERROR_SUCCESS &&
            dwType == REG_SZ && cbValueData > 0)
        {
            RegEdit_ExpandKeyPath(lpKeyName);
        }

        RegCloseKey(hKey);  
    }
}

/*******************************************************************************
*
*  RegEdit_OnFavorites
*
*  DESCRIPTION:
*     Handles the selection of Favorites
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnFavorites(
    HWND hWnd,
    UINT uItem
    )
{
    TCHAR KeyName[MAXKEYNAMEPATH*2];
    LPTSTR lpKeyName = KeyName;
    TCHAR ValueName[MAXKEYNAMEPATH*2];
    LPTSTR lpValueName = ValueName;
    TCHAR DataBuffer[MAXKEYNAMEPATH*2];
    LPTSTR lpData = DataBuffer;
    HMENU hMenu, hMainMenu;
    MENUITEMINFO mii;
    DWORD cbValueName, cbData, dwType;
    BOOL bRet = TRUE;
    HKEY hKey;
    LONG lRet;
    UINT i = 0;

    // Get the main RegEdit Menu handle
    hMainMenu = GetMenu(hWnd);
    if (!hMainMenu)
    {
        return;
    }

    // Now get the handle to the Favorites submenu
    hMenu = GetSubMenu(hMainMenu, uItem);
    if (!hMenu)
    {
        return;
    }

    ZeroMemory(&mii, sizeof(MENUITEMINFO));
    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_STATE;
    mii.fState = MFS_DISABLED;
    SetMenuItemInfo(hMenu, ID_REMOVEFAVORITE, FALSE, &mii);
    
    // Now remove every menuitem after the separator so we have a clean slate.
    i = 2;
    while (bRet)
    {
        bRet = DeleteMenu(hMenu, i, MF_BYPOSITION);
    }

    if (RegCreateKey(HKEY_CURRENT_USER, g_RegEditFavoritesKey, &hKey) ==
        ERROR_SUCCESS) 
    {
        i = 0;

        while (TRUE)
        {           
            cbValueName = cbData = MAXKEYNAMEPATH * 2;
            lRet = RegEnumValue(hKey, i, lpValueName, &cbValueName, NULL, &dwType, (LPBYTE) lpData, &cbData);
            if (lRet)
                break;

            if (!i)
            {
                // Enable the "Remove Favorites" menu
                ZeroMemory(&mii, sizeof(MENUITEMINFO));
                mii.cbSize = sizeof(MENUITEMINFO);
                mii.fMask = MIIM_STATE;
                mii.fState = MFS_ENABLED;
                SetMenuItemInfo(hMenu, ID_REMOVEFAVORITE, FALSE, &mii);

                // Add a separator to make things pretty
                ZeroMemory(&mii, sizeof(MENUITEMINFO));
                mii.cbSize = sizeof(MENUITEMINFO);
                mii.fMask = MIIM_TYPE;
                mii.fType = MFT_SEPARATOR;
                InsertMenuItem(hMenu, (UINT) -1, 2, &mii);
            }

            ZeroMemory(&mii, sizeof(MENUITEMINFO)); 
            mii.cbSize = sizeof(MENUITEMINFO);
            mii.fMask = MIIM_TYPE | MIIM_ID | MIIM_STATE;
            mii.fType = MFT_STRING;
            mii.wID   = ID_ADDTOFAVORITES + i + 1;
            mii.dwTypeData = lpValueName;
            mii.fState = MFS_ENABLED;
            mii.cch = lstrlen(lpValueName);
            InsertMenuItem(hMenu, ID_ADDTOFAVORITES + i + 1, FALSE, &mii);

            i++;
        }
        
        RegCloseKey(hKey);
    }

    DrawMenuBar(hWnd);
}

/*******************************************************************************
*
*  RegEdit_OnCommand
*
*  DESCRIPTION:
*     Handles the selection of a menu item by the user, notification messages
*     from a child control, or translated accelerated keystrokes for the
*     RegEdit window.
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*     DlgItem, identifier of control.
*     hControlWnd, handle of control.
*     NotificationCode, notification code from control.
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnCommand(
    HWND hWnd,
    int DlgItem,
    HWND hControlWnd,
    UINT NotificationCode
    )
{

    PTSTR pAppName;

    //
    //  Check to see if this menu command should be handled by the main window's
    //  command handler.
    //

    if (DlgItem >= ID_FIRSTCONTEXTMENUITEM && DlgItem <=
        ID_LASTCONTEXTMENUITEM) {

        if (g_RegEditData.hFocusWnd == g_RegEditData.hKeyTreeWnd)
            RegEdit_OnKeyTreeCommand(hWnd, DlgItem, NULL);

        else
            RegEdit_OnValueListCommand(hWnd, DlgItem);

    }

    switch (DlgItem) {

        case ID_IMPORTREGFILE:
            RegEdit_OnCommandImportRegFile(hWnd);
            break;

        case ID_EXPORTREGFILE:
            RegEdit_OnCommandExportRegFile(hWnd);
            break;

        case ID_LOADHIVE:
            RegEdit_OnCommandLoadHive(hWnd);
            break;
        
        case ID_UNLOADHIVE:
            RegEdit_OnCommandUnloadHive(hWnd);
            break;

        case ID_CONNECT:
            RegEdit_OnCommandConnect(hWnd);
            break;

        case ID_DISCONNECT:
            RegEdit_OnCommandDisconnect(hWnd);
            break;

        case ID_PRINT:
            RegEdit_OnCommandPrint(hWnd);
            break;

        case ID_EXIT:
            PostMessage(hWnd, WM_CLOSE, 0, 0);
            break;

        case ID_FIND:
            RegEdit_OnCommandFindNext(hWnd, TRUE);
            break;

        case ID_FINDNEXT:
            RegEdit_OnCommandFindNext(hWnd, FALSE);
            break;

        case ID_NEWKEY:
            RegEdit_OnNewKey(hWnd,
                TreeView_GetSelection(g_RegEditData.hKeyTreeWnd));
            break;

        case ID_NEWSTRINGVALUE:
            RegEdit_OnNewValue(hWnd, REG_SZ);
            break;

        case ID_NEWBINARYVALUE:
            RegEdit_OnNewValue(hWnd, REG_BINARY);
            break;

        case ID_NEWDWORDVALUE:
            RegEdit_OnNewValue(hWnd, REG_DWORD);
            break;

        case ID_NEWMULTSZVALUE:
            RegEdit_OnNewValue(hWnd, REG_MULTI_SZ);
            break;

        case ID_NEWEXPSZVALUE:
            RegEdit_OnNewValue(hWnd, REG_EXPAND_SZ);
            break;

        //
        //  Show or hide the status bar.  In either case, we'll need to resize
        //  the KeyTree and ValueList panes.
        //

        case ID_STATUSBAR:
            g_RegEditData.StatusBarShowCommand =
                (g_RegEditData.StatusBarShowCommand == SW_HIDE) ? SW_SHOW :
                SW_HIDE;
            ShowWindow(g_RegEditData.hStatusBarWnd,
                g_RegEditData.StatusBarShowCommand);
            RegEdit_ResizeWindow(hWnd, RESIZEFROM_UNKNOWN);
            break;

        case ID_SPLIT:
            RegEdit_OnCommandSplit(hWnd);
            break;

        case ID_DISPLAYBINARY:
            RegEdit_DisplayBinaryData(hWnd);
            break;

        case ID_REFRESH:
            RegEdit_OnKeyTreeRefresh(hWnd);
            break;

        case ID_ABOUT:
            pAppName = LoadDynamicString(IDS_REGEDIT);
            ShellAbout(hWnd, pAppName, g_NullString, LoadIcon(g_hInstance,
                MAKEINTRESOURCE(IDI_REGEDIT)));
            DeleteDynamicString(pAppName);
            break;

        //
        //  Cycle the focus to the next pane when the user presses "tab".  The
        //  assumption is made that there are only two panes, so the tab
        //  direction doesn't really matter.
        //

        case ID_CYCLEFOCUS:
            SetFocus(((g_RegEditData.hFocusWnd == g_RegEditData.hKeyTreeWnd) ?
                g_RegEditData.hValueListWnd : g_RegEditData.hKeyTreeWnd));
            break;

        case ID_HELPTOPICS:
            HtmlHelp( GetDesktopWindow(), TEXT("regedit.chm"), HH_HELP_FINDER, 0);
            break;

        case ID_COPYKEYNAME:
            RegEdit_OnCopyKeyName(hWnd,
            TreeView_GetSelection(g_RegEditData.hKeyTreeWnd));
            break;

        case ID_REMOVEFAVORITE:
            RegEdit_OnRemoveFavorite(hWnd);
            break;

        case ID_ADDTOFAVORITES:
            RegEdit_OnAddToFavorites(hWnd);
            break;

        case ID_PERMISSIONS:
            RegEdit_InvokeSecurityEditor(hWnd);
            break;

        default:
            if (DlgItem > ID_ADDTOFAVORITES)
            {
                RegEdit_OnSelectFavorite(hWnd, DlgItem);
                break;
            }
    }

    UNREFERENCED_PARAMETER(hControlWnd);

}

/*******************************************************************************
*
*  RegEdit_OnNotify
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*     DlgItem, identifier of control.
*     lpNMTreeView, control notification data.
*
*******************************************************************************/

LRESULT
PASCAL
RegEdit_OnNotify(
    HWND hWnd,
    int DlgItem,
    LPNMHDR lpNMHdr
    )
{

    switch (DlgItem) {

        case IDC_KEYTREE:
            switch (lpNMHdr-> code) {

                case TVN_ITEMEXPANDING:
                    return RegEdit_OnKeyTreeItemExpanding(hWnd,
                        (LPNM_TREEVIEW) lpNMHdr);

                case TVN_SELCHANGED:
                    RegEdit_OnKeyTreeSelChanged(hWnd, (LPNM_TREEVIEW) lpNMHdr);
                    break;

                case TVN_BEGINLABELEDIT:
                    return RegEdit_OnKeyTreeBeginLabelEdit(hWnd,
                        (TV_DISPINFO FAR*) lpNMHdr);

                case TVN_ENDLABELEDIT:
                    return RegEdit_OnKeyTreeEndLabelEdit(hWnd,
                        (TV_DISPINFO FAR*) lpNMHdr);

                case NM_SETFOCUS:
                    g_RegEditData.hFocusWnd = g_RegEditData.hKeyTreeWnd;
                    break;

            }
            break;

        case IDC_VALUELIST:
            switch (lpNMHdr-> code) {

                case LVN_BEGINLABELEDIT:
                    return RegEdit_OnValueListBeginLabelEdit(hWnd,
                        (LV_DISPINFO FAR*) lpNMHdr);

                case LVN_ENDLABELEDIT:
                    return RegEdit_OnValueListEndLabelEdit(hWnd,
                        (LV_DISPINFO FAR*) lpNMHdr);

                case NM_RETURN:
                case NM_DBLCLK:
                    RegEdit_OnValueListModify(hWnd, FALSE);
                    break;

                case NM_SETFOCUS:
                    g_RegEditData.hFocusWnd = g_RegEditData.hValueListWnd;
                    break;

            }
            break;

    }

    return 0;

}

/*******************************************************************************
*
*  RegEdit_OnInitMenuPopup
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnInitMenuPopup(
HWND hWnd,
HMENU hPopupMenu,
UINT MenuPosition,
BOOL fSystemMenu
)
{
    UINT uEnableFlags;
    int NewPopupPosition;
    HTREEITEM hSelectedTreeItem;
    HTREEITEM hComputerItem;
    HWND hKeyTreeWnd = g_RegEditData.hKeyTreeWnd;
    
    //
    //  We don't care about the items in the system menu or any of the context
    //  menus.  All of the context menus should have been initialized already.
    //
    
    if (fSystemMenu || !g_RegEditData.fMainMenuInited)
        return;
    
    switch (MenuPosition) 
    {
    case IDM_REGEDIT_FILE_POPUP:
        {
            Regedit_EnableHiveMenuItems(hPopupMenu);

            if (g_RegEditData.fHaveNetwork) 
            {
                //  Enable or disable the "disconnect..." item depending on
                //  whether or not we have any open connections.
                uEnableFlags = (TreeView_GetNextSibling(hKeyTreeWnd,
                    TreeView_GetRoot(hKeyTreeWnd)) != NULL) ? MF_BYCOMMAND |
                    MF_ENABLED : MF_BYCOMMAND | MF_GRAYED;
                EnableMenuItem(hPopupMenu, ID_DISCONNECT, uEnableFlags);
            }
        }
        break;
        
    case IDM_REGEDIT_EDIT_POPUP:
        // Cannot show permissions for "My Computer"
        hSelectedTreeItem = TreeView_GetSelection(hKeyTreeWnd);
        EnableMenuItem(hPopupMenu, ID_PERMISSIONS,
            (TreeView_GetParent(hKeyTreeWnd, hSelectedTreeItem) != NULL) ? 
            (MF_BYCOMMAND | MF_ENABLED) : (MF_BYCOMMAND | MF_GRAYED));

        if (g_RegEditData.hFocusWnd == hKeyTreeWnd) 
        {
            
            //
            //  Don't show items that are specific only to the ValueList
            //  context.
            //
            
            if (GetMenuItemID(hPopupMenu, 0) == ID_MODIFY) 
            {
                DeleteMenu(hPopupMenu, 0, MF_BYPOSITION);
                DeleteMenu(hPopupMenu, 0, MF_BYPOSITION);
                DeleteMenu(hPopupMenu, 0, MF_BYPOSITION);
            }
            
            RegEdit_SetKeyTreeEditMenuItems(hPopupMenu, hSelectedTreeItem);
            
            //
            //  Disable "Copy Key Name" for top-level items such as
            //  "My Computer" or a remote registry connection.
            //
            
            EnableMenuItem(hPopupMenu, ID_COPYKEYNAME,
                (TreeView_GetParent(hKeyTreeWnd,
                hSelectedTreeItem) != NULL) ? (MF_BYCOMMAND | MF_ENABLED) :
                (MF_BYCOMMAND | MF_GRAYED));
            
            NewPopupPosition = IDM_EDIT_WHENKEY_NEW_POPUP;
            
        }
        
        else
        {
            //
            //  Show menu items that are specific only to the ValueList
            //  context.
            //
            
            if (GetMenuItemID(hPopupMenu, 0) != ID_MODIFY)
            {
                InsertMenu(hPopupMenu, 0, MF_BYPOSITION | MF_SEPARATOR, 0,
                    NULL);
                InsertMenu(hPopupMenu, 0, MF_BYPOSITION | MF_STRING,
                    ID_MODIFYBINARY, g_RegEditData.pModifyBinary);
                InsertMenu(hPopupMenu, 0, MF_BYPOSITION | MF_STRING,
                    ID_MODIFY, g_RegEditData.pModify);
                SetMenuDefaultItem(hPopupMenu, 0, MF_BYPOSITION);
                
            }
            
            RegEdit_SetValueListEditMenuItems(hPopupMenu,
                ListView_GetNextItem(g_RegEditData.hValueListWnd, -1,
                LVNI_SELECTED));
            
            NewPopupPosition = IDM_EDIT_WHENVALUE_NEW_POPUP;
            
        }
        
        RegEdit_SetNewObjectEditMenuItems(GetSubMenu(hPopupMenu,
            NewPopupPosition));
        
        break;
        
    case IDM_REGEDIT_VIEW_POPUP:
        CheckMenuItem(hPopupMenu, ID_STATUSBAR, MF_BYCOMMAND |
            ((g_RegEditData.StatusBarShowCommand == SW_HIDE) ?
            MF_UNCHECKED : MF_CHECKED));

        EnableMenuItem(hPopupMenu, ID_DISPLAYBINARY, MF_BYCOMMAND |
            ((g_RegEditData.hFocusWnd == g_RegEditData.hKeyTreeWnd) ?
            MF_GRAYED : MF_ENABLED));
        break;
        
    case IDM_REGEDIT_FAVS_POPUP:
        //Only allow "add to favorites" when the selected key is a child
        //of the root key for my computer.  (don't allow favs on remote)
        hSelectedTreeItem = 
            TreeView_GetSelection(hKeyTreeWnd);
        hComputerItem = RegEdit_GetComputerItem(hSelectedTreeItem);
        
        EnableMenuItem(hPopupMenu, ID_ADDTOFAVORITES,
            ((hComputerItem == TreeView_GetRoot(hKeyTreeWnd)) &&
            (hSelectedTreeItem != TreeView_GetRoot(hKeyTreeWnd))) ?
            (MF_BYCOMMAND | MF_ENABLED) :
        (MF_BYCOMMAND | MF_GRAYED));
        break;
    }
    
}


//------------------------------------------------------------------------------
//  Regedit_EnableHiveMenuItems
//
//  DESSCRIPTION: Enables hive menu items
//
//  PARAMETERS: HMENU hPopupMenu - handle to popup menu
//------------------------------------------------------------------------------
void Regedit_EnableHiveMenuItems(HMENU hPopupMenu)
{
    UINT uLoadFlags = MF_BYCOMMAND | MF_GRAYED;
    UINT uUnloadFlags = MF_BYCOMMAND | MF_GRAYED;
    HWND hKeyTreeWnd = g_RegEditData.hKeyTreeWnd;
    
    if (g_RegEditData.hFocusWnd == hKeyTreeWnd) 
    {
        PREDEFINE_KEY hkeyPredefindedKey;
        HTREEITEM hSelectedTreeItem;
        HTREEITEM hComputerItem;
        
        // get the key's predefined root key
        hSelectedTreeItem = TreeView_GetSelection(hKeyTreeWnd);
        hkeyPredefindedKey = RegEdit_GetPredefinedKey(hSelectedTreeItem);
        
        if ((PREDEFINE_KEY_LOCAL_MACHINE == hkeyPredefindedKey) ||
            (PREDEFINE_KEY_USERS == hkeyPredefindedKey))
        {
            HTREEITEM hParentTreeItem = 
                TreeView_GetParent(hKeyTreeWnd, hSelectedTreeItem);
            HTREEITEM hComputerItem 
                = RegEdit_GetComputerItem(hSelectedTreeItem); //the computer
            
            if (hParentTreeItem == hComputerItem)
            {
                // Enable Load Hive for root keys
                uLoadFlags = MF_BYCOMMAND | MF_ENABLED;
            }
            else if (hParentTreeItem && 
                (TreeView_GetParent(hKeyTreeWnd, hParentTreeItem) ==
                hComputerItem))
            {
                // Enable Unload Hive for children of root keys
                uUnloadFlags = MF_BYCOMMAND | MF_ENABLED;
            }
        }
    }
    
    EnableMenuItem(hPopupMenu, ID_LOADHIVE, uLoadFlags);
    EnableMenuItem(hPopupMenu, ID_UNLOADHIVE, uUnloadFlags);
}


/*******************************************************************************
*
*  RegEdit_SetNewObjectEditMenuItems
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hPopupMenu,
*
*******************************************************************************/

VOID
PASCAL
RegEdit_SetNewObjectEditMenuItems(
    HMENU hPopupMenu
    )
{

    HWND hKeyTreeWnd;
    HTREEITEM hSelectedTreeItem;
    UINT EnableFlags;

    hKeyTreeWnd = g_RegEditData.hKeyTreeWnd;
    hSelectedTreeItem = TreeView_GetSelection(hKeyTreeWnd);

    if (g_RegEditData.hCurrentSelectionKey != NULL)
        EnableFlags = MF_ENABLED | MF_BYCOMMAND;
    else
        EnableFlags = MF_GRAYED | MF_BYCOMMAND;

    EnableMenuItem(hPopupMenu, ID_NEWKEY, EnableFlags);
    EnableMenuItem(hPopupMenu, ID_NEWSTRINGVALUE, EnableFlags);
    EnableMenuItem(hPopupMenu, ID_NEWBINARYVALUE, EnableFlags);
    EnableMenuItem(hPopupMenu, ID_NEWDWORDVALUE, EnableFlags);
    EnableMenuItem(hPopupMenu, ID_NEWMULTSZVALUE, EnableFlags);
    EnableMenuItem(hPopupMenu, ID_NEWEXPSZVALUE, EnableFlags);

}

/*******************************************************************************
*
*  RegEdit_OnMenuSelect
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnMenuSelect(
    HWND hWnd,
    WPARAM wParam,
    LPARAM lParam
    )
{

    MENUITEMINFO MenuItemInfo;

    //
    //  If this is one of our popup menus, then we'll fake out the MenuHelp
    //  API by sending it a normal menu item id.  This makes it easier to
    //  display context sensitive help for the popups, too.
    //

    if ((GET_WM_MENUSELECT_FLAGS(wParam, lParam) & (MF_POPUP | MF_SYSMENU)) ==
        MF_POPUP && GET_WM_MENUSELECT_HMENU(wParam, lParam) != NULL) {

        ZeroMemory(&MenuItemInfo, sizeof(MENUITEMINFO));
        MenuItemInfo.cbSize = sizeof(MENUITEMINFO);
        MenuItemInfo.fMask = MIIM_ID;

        GetMenuItemInfo((HMENU) lParam, LOWORD(wParam), TRUE, &MenuItemInfo);
        if (LOWORD(wParam) == 3)
        {
            RegEdit_OnFavorites(hWnd, LOWORD(wParam));
        }

        if (GetMenuItemInfo((HMENU) lParam, LOWORD(wParam), TRUE, &MenuItemInfo))
        {
            wParam = MenuItemInfo.wID;
        }

    }

    MenuHelp(WM_MENUSELECT, wParam, lParam, g_RegEditData.hMainMenu,
        g_hInstance, g_RegEditData.hStatusBarWnd, (UINT *)s_RegEditMenuHelpData);

}

/*******************************************************************************
*
*  RegEdit_OnLButtonDown
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*     fDoubleClick, TRUE if this is a double-click message, else FALSE.
*     x, x-coordinate of the cursor relative to the client area.
*     y, y-coordinate of the cursor relative to the client area.
*     KeyFlags, state of various virtual keys.
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnLButtonDown(
    HWND hWnd,
    BOOL fDoubleClick,
    int x,
    int y,
    UINT KeyFlags
    )
{

    LONG Style;
    RECT ClientRect;
    int cxIcon;
    int dx;
    int dy;
    HDC hDC;
    MSG Msg;
    int xLow;
    int xHigh;
    HBRUSH hDitherBrush;
    HBRUSH hPrevBrush;

    if (IsIconic(hWnd))
        return;

    Style = GetWindowLong(hWnd, GWL_STYLE);
    SetWindowLong(hWnd, GWL_STYLE, Style & (~WS_CLIPCHILDREN));

    GetEffectiveClientRect(hWnd, &ClientRect, (LPINT)s_EffectiveClientRectData);

    cxIcon = GetSystemMetrics(SM_CXICON);
    ClientRect.left += cxIcon;
    ClientRect.right -= cxIcon;

    dx = GetSystemMetrics(SM_CXSIZEFRAME);
    y = GetSystemMetrics(SM_CYEDGE);
    dy = ClientRect.bottom - ClientRect.top - y * 2;

    hDC = GetDC(hWnd);

    if ((hDitherBrush = CreateDitheredBrush()) != NULL)
        hPrevBrush = SelectBrush(hDC, hDitherBrush);

    PatBlt(hDC, x - dx / 2, y, dx, dy, PATINVERT);

    SetCapture(hWnd);

    while (GetMessage(&Msg, NULL, 0, 0)) {

        if (Msg.message == WM_KEYDOWN || Msg.message == WM_SYSKEYDOWN ||
            (Msg.message >= WM_MOUSEFIRST && Msg.message <= WM_MOUSELAST)) {

            if (Msg.message == WM_LBUTTONUP || Msg.message == WM_LBUTTONDOWN ||
                Msg.message == WM_RBUTTONDOWN)
                break;

            if (Msg.message == WM_KEYDOWN) {

                if (Msg.wParam == VK_LEFT) {

                    Msg.message = WM_MOUSEMOVE;
                    Msg.pt.x -= 2;

                }

                else if (Msg.wParam == VK_RIGHT) {

                    Msg.message = WM_MOUSEMOVE;
                    Msg.pt.x += 2;

                }

                else if (Msg.wParam == VK_RETURN || Msg.wParam == VK_ESCAPE)
                    break;

                if (Msg.pt.x > ClientRect.right)
                    Msg.pt.x = ClientRect.right;

                else if (Msg.pt.x < ClientRect.left)
                    Msg.pt.x = ClientRect.left;

                SetCursorPos(Msg.pt.x, Msg.pt.y);

            }

            if (Msg.message == WM_MOUSEMOVE) {

                ScreenToClient(hWnd, &Msg.pt);

                if (Msg.pt.x > ClientRect.right)
                    Msg.pt.x = ClientRect.right;

                else if (Msg.pt.x < ClientRect.left)
                    Msg.pt.x = ClientRect.left;

                if (x < Msg.pt.x) {

                    xLow = x;
                    xHigh = Msg.pt.x;

                }

                else {

                    xLow = Msg.pt.x;
                    xHigh = x;

                }

                xLow -= dx / 2;
                xHigh -= dx / 2;

                if (xHigh < xLow + dx)
                    ExcludeClipRect(hDC, xHigh, y, xLow + dx, y + dy);

                else
                    ExcludeClipRect(hDC, xLow + dx, y, xHigh, y + dy);

                PatBlt(hDC, xLow, y, xHigh - xLow + dx, dy, PATINVERT);
                SelectClipRgn(hDC, NULL);

                x = Msg.pt.x;

            }

        }

        else
            DispatchMessage(&Msg);

    }

    ReleaseCapture();

    PatBlt(hDC, x - dx / 2, y, dx, dy, PATINVERT);

    if (hDitherBrush != NULL)
        DeleteObject(SelectBrush(hDC, hPrevBrush));

    ReleaseDC(hWnd, hDC);

    SetWindowLong(hWnd, GWL_STYLE, Style);

    g_RegEditData.xPaneSplit = x - dx / 2;

    RegEdit_ResizeWindow(hWnd, RESIZEFROM_SPLIT);

    UNREFERENCED_PARAMETER(fDoubleClick);
    UNREFERENCED_PARAMETER(KeyFlags);

}

/*******************************************************************************
*
*  RegEdit_OnCommandSplit
*
*  DESCRIPTION:
*     Keyboard alternative to changing the position of the "split" between the
*     KeyTree and ValueList panes.
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnCommandSplit(
    HWND hWnd
    )
{

    RECT ClientRect;
    POINT MessagePos;
    POINT CursorPos;

    GetEffectiveClientRect(hWnd, &ClientRect, (LPINT)s_EffectiveClientRectData);

    MessagePos.x = g_RegEditData.xPaneSplit +
        GetSystemMetrics(SM_CXSIZEFRAME) / 2;
    MessagePos.y = (ClientRect.bottom - ClientRect.top) / 2;

    CursorPos = MessagePos;
    ClientToScreen(hWnd, &CursorPos);
    SetCursorPos(CursorPos.x, CursorPos.y);

    SetCursor(LoadCursor(g_hInstance, MAKEINTRESOURCE(IDC_SPLIT)));
    ShowCursor(TRUE);

    RegEdit_OnLButtonDown(hWnd, FALSE, MessagePos.x, MessagePos.y, 0);

    ShowCursor(FALSE);

}

/*******************************************************************************
*
*  RegEdit_ResizeWindow
*
*  DESCRIPTION:
*     Called whenever the size of the RegEdit window has changed or the size
*     of its child controls should be adjusted.
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*     ResizeFrom, source of the size change (RESIZEFROM_* constant).
*
*******************************************************************************/

VOID
PASCAL
RegEdit_ResizeWindow(
    HWND hWnd,
    UINT ResizeFrom
    )
{

    HDWP hDWP;
    RECT ClientRect;
    int Height;
    HWND hKeyTreeWnd;
    HWND hValueListWnd;
    int x;
    int dx;

    if (IsIconic(hWnd))
        return;

    //
    //  Resize and/or reposition the status bar window.  Don't do this when the
    //  resize comes from a change in the splitter position to avoid some
    //  flicker.
    //

    if (ResizeFrom == RESIZEFROM_UNKNOWN)
        SendMessage(g_RegEditData.hStatusBarWnd, WM_SIZE, 0, 0);

    if ((hDWP = BeginDeferWindowPos(2)) != NULL) {

        GetEffectiveClientRect(hWnd, &ClientRect, (LPINT)s_EffectiveClientRectData);
        Height = ClientRect.bottom - ClientRect.top;

        hKeyTreeWnd = g_RegEditData.hKeyTreeWnd;

        DeferWindowPos(hDWP, hKeyTreeWnd, NULL, 0, 0, g_RegEditData.xPaneSplit,
            Height, SWP_NOZORDER | SWP_NOACTIVATE);

        x = g_RegEditData.xPaneSplit + GetSystemMetrics(SM_CXSIZEFRAME);
        dx = ClientRect.right - ClientRect.left - x;

        hValueListWnd = g_RegEditData.hValueListWnd;

        DeferWindowPos(hDWP, hValueListWnd, NULL, x, 0, dx, Height,
            SWP_NOZORDER | SWP_NOACTIVATE);

        EndDeferWindowPos(hDWP);

    }

}

/*******************************************************************************
*
*  RegEdit_SetImageLists
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     (none).
*
*******************************************************************************/

BOOL
PASCAL
RegEdit_SetImageLists(
    HWND hWnd
    )
{

    int cxSmIcon;
    int cySmIcon;
    HIMAGELIST hImageList;
    UINT Index;
    HICON hIcon;
    UINT uFlags = TRUE;

    cxSmIcon = GetSystemMetrics(SM_CXSMICON);
    cySmIcon = GetSystemMetrics(SM_CYSMICON);


    if ( GetWindowLongPtr(hWnd , GWL_EXSTYLE) & WS_EX_LAYOUTRTL )
    {
         uFlags |= ILC_MIRROR;
    }

    if ((hImageList = ImageList_Create(cxSmIcon, cySmIcon, uFlags, IDI_LASTIMAGE -
        IDI_FIRSTIMAGE + 1, 1)) == NULL)
        return FALSE;

    //
    //  Initialize the image list with all of the icons that we'll be using
    //  throughout the Registry Editor (at least this window!).  Once set, send
    //  its handle to all interested child windows.
    //

    for (Index = IDI_FIRSTIMAGE; Index <= IDI_LASTIMAGE; Index++) {

        if ((hIcon = LoadImage(g_hInstance, MAKEINTRESOURCE(Index), IMAGE_ICON,
            cxSmIcon, cySmIcon, LR_DEFAULTCOLOR)) != NULL) {

            ImageList_AddIcon(hImageList, hIcon);
            DestroyIcon(hIcon);

        }

        else {

            ImageList_Destroy(hImageList);
            return FALSE;

        }

    }

    TreeView_SetImageList(g_RegEditData.hKeyTreeWnd, hImageList, TVSIL_NORMAL);
    ListView_SetImageList(g_RegEditData.hValueListWnd, hImageList, LVSIL_SMALL);

    if (g_RegEditData.hImageList != NULL)
        ImageList_Destroy(g_RegEditData.hImageList);

    g_RegEditData.hImageList = hImageList;

    return TRUE;

}

/*******************************************************************************
*
*  RegEdit_SetSysColors
*
*  DESCRIPTION:
*     Queries the system for any desired system colors and sets window
*     attributes as necessary.
*
*  PARAMETERS:
*     (none).
*
*******************************************************************************/

VOID
PASCAL
RegEdit_SetSysColors(
    VOID
    )
{

    g_clrHighlightText = GetSysColor(COLOR_HIGHLIGHTTEXT);
    g_clrHighlight = GetSysColor(COLOR_HIGHLIGHT);

    g_clrWindowText = GetSysColor(COLOR_WINDOWTEXT);
    g_clrWindow = GetSysColor(COLOR_WINDOW);

    //
    //  Optimize the drawing of images by informing interested parties of the
    //  background color.  This lets ImageLists avoid extra BitBlts (biggie) and
    //  ListViews do some minor stuff.
    //

    ImageList_SetBkColor(g_RegEditData.hImageList, g_clrWindow);
    ListView_SetBkColor(g_RegEditData.hValueListWnd, g_clrWindow);

}

/*******************************************************************************
*
*  RegEdit_SetWaitCursor
*
*  DESCRIPTION:
*     Simple logic to show or hide the wait cursor.  Assumes that we won't be
*     called by multiple layers, so no wait cursor count is maintained.
*
*  PARAMETERS:
*     fSet, TRUE if wait cursor should be displayed, else FALSE.
*
*******************************************************************************/

VOID
PASCAL
RegEdit_SetWaitCursor(
    BOOL fSet
    )
{

    ShowCursor(fSet);

    SetCursor(LoadCursor(NULL, fSet ? IDC_WAIT : IDC_ARROW));

}


//------------------------------------------------------------------------------
//  RegEdit_GetComputerItem
//
//  DESCRIPTION: Returns the root item (computer) of an item
//
//  PARAMETERS:  hTreeItem - treeview item
//------------------------------------------------------------------------------
HTREEITEM RegEdit_GetComputerItem(HTREEITEM hTreeItem)
{
    HTREEITEM hTreeItemRoot; 
    HTREEITEM hCurrTreeItem = hTreeItem;

    do
    {
        hTreeItemRoot = hCurrTreeItem;
        hCurrTreeItem = TreeView_GetParent(g_RegEditData.hKeyTreeWnd, hCurrTreeItem);
    }
    while (hCurrTreeItem);

    return hTreeItemRoot;
}


//------------------------------------------------------------------------------
//  RegEdit_GetPredefinedKey
//
//  DESCRIPTION: Returns the RegEdit_GetPredefinedKey of an item
//
//  PARAMETERS:  hTreeItem - treeview item
//------------------------------------------------------------------------------
PREDEFINE_KEY RegEdit_GetPredefinedKey(HTREEITEM hTreeItem)
{
    HTREEITEM hKeyTreeItem;
    HTREEITEM hCurrTreeItem = hTreeItem;
    TCHAR szKeyString[MAXKEYNAME];
    PREDEFINE_KEY  hkeyPredefindedKey = -1;
    int i;

    // Find Key
    do
    {
        hKeyTreeItem = hCurrTreeItem;
        hCurrTreeItem = TreeView_GetParent(g_RegEditData.hKeyTreeWnd, hCurrTreeItem);
    }
    while ((hCurrTreeItem) && 
           (TreeView_GetParent(g_RegEditData.hKeyTreeWnd, hCurrTreeItem)));
 
    // PREDEFINDED KEY from its name
    KeyTree_GetKeyName(hKeyTreeItem, szKeyString, ARRAYSIZE(szKeyString));
    for (i = 0; i < NUMBER_REGISTRY_ROOTS; i++) 
    {
        if (_tcscmp((TCHAR*)&szKeyString, g_RegistryRoots[i].lpKeyName) == 0)
        {
            hkeyPredefindedKey = g_RegistryRoots[i].hPreDefKey;
            break;
        }
    }

    return hkeyPredefindedKey;
}


//------------------------------------------------------------------------------
//  RegEdit_InvokeSecurityEditor
//
//  DESCRIPTION: Invokes the security editor for the currently selected item.
//
//  PARAMETERS:  hWnd - handle to the current window
//------------------------------------------------------------------------------
VOID RegEdit_InvokeSecurityEditor(HWND hWnd)
{
    HTREEITEM hSelectedTreeItem;
    HTREEITEM hParentTreeItem;
    HTREEITEM hComputerItem;
    
    BOOL fRemote;
    LPSECURITYINFO pSi;
    PREDEFINE_KEY  hkeyPredefindedKey;
    
    TCHAR szItemName[MAXKEYNAME + 1];
    TCHAR szItemParentName[MAXKEYNAME + 1];
    TCHAR szComputerName[2 + MAX_COMPUTERNAME_LENGTH + 1] = {'\\','\\'};
    DWORD cbComputerName;
    
    LPTSTR pszTitle = szItemName;
    LPTSTR pszItemName = szItemName;
    LPTSTR pszItemParentName = szItemParentName;
    LPTSTR pszComputerName = szComputerName;

    hSelectedTreeItem = TreeView_GetSelection(g_RegEditData.hKeyTreeWnd);
    hParentTreeItem = TreeView_GetParent(g_RegEditData.hKeyTreeWnd, hSelectedTreeItem);
    hComputerItem = RegEdit_GetComputerItem(hSelectedTreeItem);
    
    // ITEM NAME
    KeyTree_GetKeyName(hSelectedTreeItem, pszItemName, ARRAYSIZE(szItemName));
    
    // COMPUTER NAME
    fRemote = (hComputerItem != g_RegEditData.hMyComputer);
    if (fRemote)
    {
        KeyTree_GetKeyName(hComputerItem, pszComputerName + 2, ARRAYSIZE(szComputerName) - 2); 
    }
    else
    {
        cbComputerName = ARRAYSIZE(szComputerName) - 2;
        GetComputerName(szComputerName + 2, &cbComputerName);
    }
    
    // PARENT NAME
    if (hParentTreeItem == hComputerItem)
    { 
        pszItemName = NULL; 
        pszItemParentName = NULL;
    }
    else if (TreeView_GetParent(g_RegEditData.hKeyTreeWnd, hParentTreeItem) == hComputerItem)
    {
        pszItemParentName = NULL;         
    }
    else 
    {
        KeyTree_BuildKeyPath(g_RegEditData.hKeyTreeWnd, hParentTreeItem,
            pszItemParentName, BKP_TOSUBKEY);
    }
    
    // PREDEFINED KEY
    hkeyPredefindedKey = RegEdit_GetPredefinedKey(hSelectedTreeItem);
    
    // SECURITY INFO
    if (CreateSecurityInformation(pszItemName, pszItemParentName, pszComputerName, pszTitle,
        fRemote, hkeyPredefindedKey, FALSE, hWnd, &pSi ) == S_OK)
    {
        EditSecurity( hWnd, pSi);
        RegEdit_KeyTreeSelChanged(g_RegEditData.hKeyTreeWnd);
    }
    else
    {
        InternalMessageBox(g_hInstance, hWnd, MAKEINTRESOURCE(IDS_GET_SECURITY_KEY_NOT_ACCESSIBLE_EX),
            MAKEINTRESOURCE(IDS_SECURITY), MB_ICONERROR | MB_OK, NULL);
    }  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\regedit\regfdesc.cxx ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    regfdesc.cxx

Abstract:

    This module contains the definitions of the member functions
    of FULL_DESCRIPTOR class.

Author:

    Jaime Sasson (jaimes) 02-Dec-1993

Environment:

    ULIB, User Mode


--*/

#include "regfdesc.hxx"
#include "regdesc.hxx"
#include "iterator.hxx"


DEFINE_CONSTRUCTOR ( FULL_DESCRIPTOR, OBJECT );


FULL_DESCRIPTOR::~FULL_DESCRIPTOR (
    )

/*++

Routine Description:

    Destroy a FULL_DESCRIPTOR.

Arguments:

    None.

Return Value:

    None.

--*/

{
    Destroy();
}


VOID
FULL_DESCRIPTOR::Construct (
    )

/*++

Routine Description:

    Construct a FULL_DESCRIPTOR object.

Arguments:

    None.

Return Value:

    None.

--*/

{
        _InterfaceType = Internal;
        _BusNumber = 0;
        _Version = 0;
        _Revision = 0;
        _ResourceDescriptors = NULL;
}


VOID
FULL_DESCRIPTOR::Destroy (
    )

/*++

Routine Description:

    Worker method for object destruction.

Arguments:

    None.

Return Value:

    None.

--*/

{
    _InterfaceType = Internal;
    _BusNumber = 0;
    _Version = 0;
    _Revision = 0;
    if( _ResourceDescriptors != NULL ) {
        _ResourceDescriptors->DeleteAllMembers();
        DELETE( _ResourceDescriptors );
    }
    _ResourceDescriptors = NULL;
}



BOOLEAN
FULL_DESCRIPTOR::Initialize(
    IN  PCBYTE       Data,
    IN  ULONG        Size,
    OUT PULONG       DescriptorSize
    )

/*++

Routine Description:

    Initialize an object of type FULL_DESCRIPTOR.

Arguments:

    Data - Pointer to a buffer that contains a CM_FULL_RESOURCE_DESCRIPTOR.

    Size - Buffer size.

Return Value:

    BOOLEAN - Returns TRUE if the initialization succeeds.

--*/

{
    PCM_FULL_RESOURCE_DESCRIPTOR    FullResource;
    ULONG                           Count;
    ULONG                           i;
    ULONG                           j;

    PARRAY  TmpList;
    PPORT_DESCRIPTOR            PortDescriptor;
    PINTERRUPT_DESCRIPTOR       InterruptDescriptor;
    PMEMORY_DESCRIPTOR          MemoryDescriptor;
    PDMA_DESCRIPTOR             DmaDescriptor;
    PDEVICE_SPECIFIC_DESCRIPTOR DeviceSpecificDescriptor;
    ULONG                       DeviceSpecificDataSize;

    if( Data == NULL ) {
        return( FALSE );
    }

    Count           = 1;
    FullResource    = ( PCM_FULL_RESOURCE_DESCRIPTOR )Data;

    TmpList = ( PARRAY )NEW( ARRAY );
    if( ( TmpList == NULL ) ||
        ( !TmpList->Initialize() ) ) {
        DebugPrintTrace(("REGEDT32: Out of memory" ));
        DELETE( TmpList );
        return( FALSE );
    }

    _InterfaceType = FullResource->InterfaceType;
    _BusNumber = FullResource->BusNumber;
    _Version = FullResource->PartialResourceList.Version;
    _Revision = FullResource->PartialResourceList.Revision;

    //
    // For each CM_FULL_RESOURCE DESCRIPTOR in the current value...
    //

    for( i = 0; i < Count; i++ ) {

        PCM_PARTIAL_RESOURCE_DESCRIPTOR   PartialResourceDescriptor;

        //
        // For each CM_PARTIAL_RESOURCE_DESCRIPTOR in the list...
        //

        DeviceSpecificDataSize = 0;
        for( j = 0; j < FullResource->PartialResourceList.Count; j++ ) {

                //
                // Get a pointer to the current CM_PARTIAL_RESOURCE_DESCRIPTOR
                // in the current CM_FULLRESOURCE_DESCRIPTOR in the list.
                //

                PartialResourceDescriptor = &( FullResource[ i ].PartialResourceList.PartialDescriptors[ j ]);
                //
                //  Ignore invalid data
                //
                if( ( ULONG_PTR )PartialResourceDescriptor >
                        ( ULONG_PTR )( Data + Size - sizeof( CM_PARTIAL_RESOURCE_DESCRIPTOR ) ) ) {
                    DebugPrintTrace(( "REGEDT32: Invalid CM_PARTIAL_RESOURCE_DESCRIPTOR, j = %d \n", j ));
                    if( DescriptorSize != NULL ) {
                        *DescriptorSize = Size;
                    }
                    _ResourceDescriptors = TmpList;
                    return( TRUE );
                }

                switch( PartialResourceDescriptor->Type ) {

                case CmResourceTypePort:

                    PortDescriptor = ( PPORT_DESCRIPTOR )NEW( PORT_DESCRIPTOR );
                    if( ( PortDescriptor == NULL ) ||
                        ( !PortDescriptor->Initialize( &PartialResourceDescriptor->u.Port.Start,
                                                       PartialResourceDescriptor->u.Port.Length,
                                                       PartialResourceDescriptor->ShareDisposition,
                                                       PartialResourceDescriptor->Flags ) )
                      ) {
                        DebugPrintTrace(( "REGEDT32: Unable to create PORT_DESCRIPTOR" ));
                        DELETE( PortDescriptor );
                        TmpList->DeleteAllMembers();
                        DELETE( TmpList );
                        return( FALSE );
                    }
                    TmpList->Put( PortDescriptor );
                    break;

                case CmResourceTypeInterrupt:

                    InterruptDescriptor = ( PINTERRUPT_DESCRIPTOR )NEW( INTERRUPT_DESCRIPTOR );
                    if( ( InterruptDescriptor == NULL ) ||
                        ( !InterruptDescriptor->Initialize( PartialResourceDescriptor->u.Interrupt.Affinity,
                                                            PartialResourceDescriptor->u.Interrupt.Level,
                                                            PartialResourceDescriptor->u.Interrupt.Vector,
                                                            PartialResourceDescriptor->ShareDisposition,
                                                            PartialResourceDescriptor->Flags ) )
                      ) {
                        DebugPrintTrace(( "REGEDT32: Unable to create INTERRUPT_DESCRIPTOR" ));
                        DELETE( InterruptDescriptor );
                        TmpList->DeleteAllMembers();
                        DELETE( TmpList );
                        return( FALSE );
                    }
                    TmpList->Put( InterruptDescriptor );
                    break;

                case CmResourceTypeMemory:

                    MemoryDescriptor = ( PMEMORY_DESCRIPTOR )NEW( MEMORY_DESCRIPTOR );
                    if( ( MemoryDescriptor == NULL ) ||
                        ( !MemoryDescriptor->Initialize( &PartialResourceDescriptor->u.Memory.Start,
                                                         PartialResourceDescriptor->u.Memory.Length,
                                                         PartialResourceDescriptor->ShareDisposition,
                                                         PartialResourceDescriptor->Flags ) )
                      ) {
                        DebugPrintTrace(( "REGEDT32: Unable to create MEMORY_DESCRIPTOR" ));
                        DELETE( MemoryDescriptor );
                        TmpList->DeleteAllMembers();
                        DELETE( TmpList );
                        return( FALSE );
                    }
                    TmpList->Put( MemoryDescriptor );
                    break;

                case CmResourceTypeDma:

                    DmaDescriptor = ( PDMA_DESCRIPTOR )NEW( DMA_DESCRIPTOR );
                    if( ( DmaDescriptor == NULL ) ||
                        ( !DmaDescriptor->Initialize( PartialResourceDescriptor->u.Dma.Channel,
                                                      PartialResourceDescriptor->u.Dma.Port,
                                                      PartialResourceDescriptor->u.Dma.Reserved1,
                                                      PartialResourceDescriptor->ShareDisposition,
                                                      PartialResourceDescriptor->Flags ) )
                      ) {
                        DebugPrintTrace(( "REGEDT32: Unable to create DMA_DESCRIPTOR" ));
                        DELETE( DmaDescriptor );
                        TmpList->DeleteAllMembers();
                        DELETE( TmpList );
                        return( FALSE );
                    }
                    TmpList->Put( DmaDescriptor );
                    break;

                case CmResourceTypeDeviceSpecific:

                    DeviceSpecificDataSize = PartialResourceDescriptor->u.DeviceSpecificData.DataSize;
                    DeviceSpecificDescriptor =
                        ( PDEVICE_SPECIFIC_DESCRIPTOR )NEW( DEVICE_SPECIFIC_DESCRIPTOR );
                    if( ( DeviceSpecificDescriptor == NULL ) ||
                        ( !DeviceSpecificDescriptor->Initialize(
                                                      PartialResourceDescriptor->u.DeviceSpecificData.Reserved1,
                                                      PartialResourceDescriptor->u.DeviceSpecificData.Reserved2,
                                                      PartialResourceDescriptor->u.DeviceSpecificData.DataSize,
                                                      ( PBYTE )&PartialResourceDescriptor->u.DeviceSpecificData +
                                                          3*sizeof( ULONG ),
                                                      PartialResourceDescriptor->ShareDisposition,
                                                      PartialResourceDescriptor->Flags ) )
                      ) {
                        DebugPrintTrace(( "REGEDT32: Unable to create DEVICE_SPECIFIC_DESCRIPTOR" ));
                        DELETE( DeviceSpecificDescriptor );
                        TmpList->DeleteAllMembers();
                        DELETE( TmpList );
                        return( FALSE );
                    }
                    TmpList->Put( DeviceSpecificDescriptor );
                    break;

                default:

                    DebugPrintTrace(( "REGEDT32: Unknown PartialResourceDescriptor->Type == %#x \n",
                                PartialResourceDescriptor->Type ));
                    continue;
                }
        }

        _ResourceDescriptors = TmpList;
        //
        // Get the next CM_FULL_RESOURCE_DESCRIPTOR from the list.
        //

        FullResource = ( PCM_FULL_RESOURCE_DESCRIPTOR ) ( ( ULONG_PTR )FullResource +
                                                          sizeof( ULONG ) +
                                                          sizeof( ULONG ) +
                                                          sizeof( USHORT ) +
                                                          sizeof( USHORT ) +
                                                          sizeof( ULONG ) +
                                                          j*sizeof( CM_PARTIAL_RESOURCE_DESCRIPTOR ) +
                                                          DeviceSpecificDataSize );
//        FullResource = ( PCM_FULL_RESOURCE_DESCRIPTOR )( PartialResourceDescriptor + 1 );
//        FullResource = ( PCM_FULL_RESOURCE_DESCRIPTOR )( ( ULONG )FullResource +
//                                                            DeviceSpecificDataSize );
    }
    if( DescriptorSize != NULL ) {
        *DescriptorSize = ( ULONG )( ( ULONG_PTR )FullResource - ( ULONG_PTR )Data );

    }
    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\regedit\regfile.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGFILE.H
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        05 Mar 1994
*
*  File import and export user interface routines for the Registry Editor.
*
*******************************************************************************/

#ifndef _INC_REGFILE
#define _INC_REGFILE

HWND g_hRegProgressWnd;

VOID RegEdit_ImportRegFile(HWND hWnd, BOOL fSilentMode, LPTSTR lpFileName, HTREEITEM hComputerItem);
BOOL RegEdit_SetPrivilege(LPCTSTR lpszPrivilege, BOOL bEnablePrivilege);
VOID RegEdit_OnCommandLoadHive(HWND hWnd);
VOID RegEdit_OnCommandUnloadHive(hWnd);

VOID
PASCAL
RegEdit_OnDropFiles(
    HWND hWnd,
    HDROP hDrop
    );

VOID
PASCAL
RegEdit_OnCommandImportRegFile(
    HWND hWnd
    );

VOID
PASCAL
RegEdit_ExportRegFile(
    HWND hWnd,
    BOOL fSilentMode,
    LPTSTR lpFileName,
    LPTSTR lpSelectedPath
    );

VOID
PASCAL
RegEdit_OnCommandExportRegFile(
    HWND hWnd
    );

void RegEdit_ImportToConnectedComputer(HWND hWnd, PTSTR pszFileName);
INT_PTR RegConnectedComputerDlgProc(HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
void RegImport_OnCommandOk(HWND hWnd, PTSTR pszFileName);
INT_PTR RegImport_OnInitDialog(HWND hWnd);
BOOL RegEdit_GetFileName(HWND hWnd, UINT uTitleStringID, UINT uFilterStringID, 
    UINT uDefExtStringID, LPTSTR lpFileName, DWORD cchFileName, BOOL fOpen);

#endif // _INC_REGFILE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\regedit\regfind.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGFIND.H
*
*  VERSION:     4.00
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        14 Jul 1994
*
*******************************************************************************/

#ifndef _INC_REGFIND
#define _INC_REGFIND

extern DWORD g_FindFlags;

VOID
PASCAL
RegEdit_OnCommandFindNext(
    HWND hWnd,
    BOOL fForceDialog
    );

#endif // _INC_REGFIND
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\regedit\regfile.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGFILE.C
*
*  VERSION:     4.0
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        21 Nov 1993
*
*  File import and export user interface routines for the Registry Editor.
*
*******************************************************************************/

#include "pch.h"
#include "regedit.h"
#include "regkey.h"
#include "regfile.h"
#include "regcdhk.h"
#include "regresid.h"
#include "reghelp.h"
#include "regstred.h"
#include "regprint.h"

INT_PTR
CALLBACK
RegProgressDlgProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    );

/*******************************************************************************
*
*  RegEdit_ImportRegFile
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*     fSilentMode, TRUE if no messages should be displayed, else FALSE.
*     lpFileName, address of file name buffer.
*
*******************************************************************************/

VOID RegEdit_ImportRegFile(HWND hWnd, BOOL fSilentMode, LPTSTR lpFileName, HTREEITEM hComputerItem)
{

    if (!fSilentMode && hWnd != NULL) {

        if ((g_hRegProgressWnd = CreateDialogParam(g_hInstance,
            MAKEINTRESOURCE(IDD_REGPROGRESS), hWnd, RegProgressDlgProc,
            (LPARAM) lpFileName)) != NULL)
            EnableWindow(hWnd, FALSE);

    }

    else
        g_hRegProgressWnd = NULL;

    //
    //  Prompt user to confirm importing a .reg file if running in silent mode 
    //  without a window (i.e. invoked .reg from a folder)
    //
    if (!fSilentMode && !hWnd)
    {
        if (InternalMessageBox(g_hInstance, hWnd, MAKEINTRESOURCE(IDS_CONFIRMIMPFILE),
            MAKEINTRESOURCE(IDS_REGEDIT), MB_ICONQUESTION | MB_YESNO , lpFileName) != IDYES)
        {
            return;
        }
    }

    ImportRegFile(hWnd, lpFileName, hComputerItem);

    if (g_hRegProgressWnd != NULL) {

        EnableWindow(hWnd, TRUE);
        DestroyWindow(g_hRegProgressWnd);

    }

    if (!fSilentMode && g_FileErrorStringID != IDS_IMPFILEERRORCANCEL)
    {
        //
        // set defaults
        //
        UINT uStyle = MB_ICONERROR;

        TCHAR szComputerName[MAXKEYNAME + 1];
        LPTSTR pszComputerName = szComputerName;
        KeyTree_GetKeyName(hComputerItem, pszComputerName, ARRAYSIZE(szComputerName));

        //
        // For the resource messages that take the pszComputerName parameter,
        // map them to a local-computer version if pszComputerName is empty.
        // (Alternatively, we could  fill in "this computer" or somesuch for
        // pszComputerName, but the resulting text is sort of weird, which
        // which isn't acceptable since local-computer is the 99% case.)
        // 
        // Also map the uStyle as needed.
        //
        switch (g_FileErrorStringID)
        {
        case IDS_IMPFILEERRSUCCESS:
            if (!hWnd || *pszComputerName == 0)
            {
                g_FileErrorStringID += LOCAL_OFFSET;
            }
            uStyle = MB_ICONINFORMATION | MB_OK;
            break;

        case IDS_IMPFILEERRREGOPEN:
        case IDS_IMPFILEERRNOFILE:
            if (*pszComputerName == 0)
            {
                g_FileErrorStringID += LOCAL_OFFSET;
            }
            break;
        }

        //
        // Put up the message box
        //
        InternalMessageBox(g_hInstance, hWnd, MAKEINTRESOURCE(g_FileErrorStringID),
            MAKEINTRESOURCE(IDS_REGEDIT), uStyle, lpFileName, pszComputerName);

    }

}

/*******************************************************************************
*
*  RegEdit_OnDropFiles
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnDropFiles(
    HWND hWnd,
    HDROP hDrop
    )
{

    TCHAR FileName[MAX_PATH];
    UINT NumberOfDrops;
    UINT CurrentDrop;

    BOOL me;

    HTREEITEM hSelectedTreeItem = TreeView_GetSelection(g_RegEditData.hKeyTreeWnd);
    TreeView_SelectDropTarget(g_RegEditData.hKeyTreeWnd, hSelectedTreeItem);

    RegEdit_SetWaitCursor(TRUE);

    NumberOfDrops = DragQueryFile(hDrop, (UINT) -1, NULL, 0);

    for (CurrentDrop = 0; CurrentDrop < NumberOfDrops; CurrentDrop++) 
    {
        DragQueryFile(hDrop, CurrentDrop, FileName, sizeof(FileName)/sizeof(TCHAR));

        if (TreeView_GetNextSibling(g_RegEditData.hKeyTreeWnd, 
            TreeView_GetRoot(g_RegEditData.hKeyTreeWnd)) != NULL)
        {
            // Remote connections exist
            RegEdit_ImportToConnectedComputer(hWnd, FileName);
        }
        else
        {
            RegEdit_ImportRegFile(hWnd, FALSE, FileName, RegEdit_GetComputerItem(hSelectedTreeItem));
        }

    }

    DragFinish(hDrop);
    TreeView_SelectDropTarget(g_RegEditData.hKeyTreeWnd, NULL);

    RegEdit_OnKeyTreeRefresh(hWnd);

    RegEdit_SetWaitCursor(FALSE);

}

//------------------------------------------------------------------------------
// RegEdit_SetPrivilege
//
// DESCRIPTION: Enable a priviledge
//
// PARAMETERS: lpszPrivilege - the securty constant or its corresponding string
//             bEnablePrivilege - TRUE = enable, False = disable
//
//------------------------------------------------------------------------------
BOOL RegEdit_SetPrivilege(LPCTSTR lpszPrivilege, BOOL bEnablePrivilege)
{
    TOKEN_PRIVILEGES tp;
    LUID luid;
    HANDLE hToken;
    BOOL fSuccess = FALSE;
    HRESULT hr;

    if (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &hToken))
    {
        if (LookupPrivilegeValue(NULL, lpszPrivilege, &luid)) 
        {     
            tp.PrivilegeCount = 1;
            tp.Privileges[0].Luid = luid;
            tp.Privileges[0].Attributes = (bEnablePrivilege) ? SE_PRIVILEGE_ENABLED : 0;
            
            // Enable or disable the privilege
            if (AdjustTokenPrivileges(hToken, FALSE, &tp, sizeof(TOKEN_PRIVILEGES), 
                (PTOKEN_PRIVILEGES) NULL, (PDWORD) NULL))
            {   
                fSuccess = TRUE;
            }
        }
        CloseHandle(hToken);
    }
    return fSuccess;
}

//------------------------------------------------------------------------------
// RegEdit_OnCommandLoadHive
//
// DESCRIPTION: Open and Load a Hive
//
// PARAMETERS: hWnd - handle of RegEdit window.
//
//------------------------------------------------------------------------------
VOID RegEdit_OnCommandLoadHive(HWND hWnd)
{
    TCHAR achFileName[MAX_PATH];

    if (RegEdit_GetFileName(hWnd, IDS_LOADHVREGFILETITLE, IDS_REGLOADHVFILEFILTER, 
        IDS_REGNODEFEXT, achFileName, ARRAYSIZE(achFileName), TRUE))
    {
        EDITVALUEPARAM EditValueParam; 

        RegEdit_SetWaitCursor(TRUE);
        
        EditValueParam.cbValueData = sizeof(TCHAR) * 50;
        EditValueParam.pValueData = LocalAlloc(LPTR, EditValueParam.cbValueData);
        if (EditValueParam.pValueData)
        {
            EditValueParam.pValueData[0] = TEXT('\0');

            if (DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_INPUTHIVENAME), hWnd,
                    EditStringValueDlgProc, (LPARAM) &EditValueParam) == IDOK)
            {
                HRESULT hr;

                RegEdit_SetPrivilege(SE_RESTORE_NAME, TRUE);

                if ((hr = RegLoadKey(g_RegEditData.hCurrentSelectionKey, (PTSTR)EditValueParam.pValueData, 
                    achFileName)) == ERROR_SUCCESS)
                {
                    RegEdit_OnKeyTreeRefresh(hWnd);
                }
                else
                {
                    UINT uErrorStringID = IDS_ERRORLOADHV;
                    
                    switch (hr)
                    {
                    case ERROR_PRIVILEGE_NOT_HELD:
                        uErrorStringID = IDS_ERRORLOADHVPRIV;
                        break;
                        
                    case ERROR_SHARING_VIOLATION:
                        uErrorStringID = IDS_ERRORLOADHVNOSHARE;
                        break;

                    case ERROR_ACCESS_DENIED:
                        uErrorStringID = IDS_ERRORLOADHVNOACC;
                        break;

                    }
                    
                    InternalMessageBox(g_hInstance, hWnd, MAKEINTRESOURCE(uErrorStringID),
                        MAKEINTRESOURCE(IDS_LOADHVREGFILETITLE), MB_ICONERROR | MB_OK, achFileName);
                }

                RegEdit_SetPrivilege(SE_RESTORE_NAME, FALSE);
            }
            LocalFree(EditValueParam.pValueData);
        }

        RegEdit_SetWaitCursor(FALSE);
    }
}


//------------------------------------------------------------------------------
// RegEdit_OnCommandUnloadHive
//
// DESCRIPTION: Open and Load a Hive
//
// PARAMETERS: hWnd - handle of RegEdit window.
//
//------------------------------------------------------------------------------
VOID  RegEdit_OnCommandUnloadHive(HWND hWnd)
{
    if (InternalMessageBox(g_hInstance, hWnd,
        MAKEINTRESOURCE(IDS_CONFIRMDELHIVETEXT), MAKEINTRESOURCE(IDS_CONFIRMDELHIVETITLE), 
        MB_ICONWARNING | MB_YESNO) == IDYES)
    {
        HRESULT hr;
        TCHAR achKeyName[MAXKEYNAME];
        HTREEITEM hSelectedTreeItem = TreeView_GetSelection(g_RegEditData.hKeyTreeWnd);
    
        RegEdit_SetPrivilege(SE_RESTORE_NAME, TRUE);

        // must close key to unload it
        RegCloseKey(g_RegEditData.hCurrentSelectionKey);

        if ((hr = RegUnLoadKey(KeyTree_GetRootKey(hSelectedTreeItem), 
            KeyTree_GetKeyName(hSelectedTreeItem, achKeyName, ARRAYSIZE(achKeyName)))) ==
                    ERROR_SUCCESS)
        {
            g_RegEditData.hCurrentSelectionKey = NULL;
            RegEdit_OnKeyTreeRefresh(hWnd);
        }
        else
        {
            UINT uErrorStringID = IDS_ERRORUNLOADHV;

            switch (hr)
            {
            case ERROR_PRIVILEGE_NOT_HELD:
                uErrorStringID = IDS_ERRORUNLOADHVPRIV;
                break;
                
            case ERROR_ACCESS_DENIED:
                uErrorStringID = IDS_ERRORUNLOADHVNOACC;
                break;
            }
            
            InternalMessageBox(g_hInstance, hWnd, MAKEINTRESOURCE(uErrorStringID),
                MAKEINTRESOURCE(IDS_UNLOADHIVETITLE), MB_ICONERROR | MB_OK, achKeyName);
            // The key couldn't be unloaded so select it again 
            g_RegEditData.hCurrentSelectionKey = NULL;
            RegEdit_KeyTreeSelChanged(hWnd);
        }
   
        RegEdit_SetPrivilege(SE_RESTORE_NAME, FALSE);
    }
}

/*******************************************************************************
*
*  RegEdit_OnCommandImportRegFile
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*
*******************************************************************************/
VOID RegEdit_OnCommandImportRegFile(HWND hWnd)
{

    TCHAR achFileName[MAX_PATH];

    if (RegEdit_GetFileName(hWnd, IDS_IMPORTREGFILETITLE, IDS_REGIMPORTFILEFILTER, 
        IDS_REGFILEDEFEXT, achFileName, ARRAYSIZE(achFileName), TRUE))
    {
        // check for networked registries
        if (TreeView_GetNextSibling(g_RegEditData.hKeyTreeWnd, 
            TreeView_GetRoot(g_RegEditData.hKeyTreeWnd)) != NULL)
        {
            // Remote connections exist
            RegEdit_ImportToConnectedComputer(hWnd, achFileName);    
        }
        else
        {
            RegEdit_SetWaitCursor(TRUE);
            RegEdit_ImportRegFile(hWnd, FALSE, achFileName, NULL);
            //  PERF:  Only need to refresh the computer that we imported the
            //  file into, not the whole thing.
            RegEdit_OnKeyTreeRefresh(hWnd);
            RegEdit_SetWaitCursor(FALSE);
        }
    }
}


/*******************************************************************************
*
*  RegEdit_ExportRegFile
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*     fSilentMode, TRUE if no messages should be displayed, else FALSE.
*     lpFileName, address of file name buffer.
*     lpSelectedPath,
*
*******************************************************************************/

VOID
PASCAL
RegEdit_ExportRegFile(
    HWND hWnd,
    BOOL fSilentMode,
    LPTSTR lpFileName,
    LPTSTR lpSelectedPath
    )
{

    //
    // Fix a bug where /a or /e is specified and no file is passed in
    //
    if (lpFileName == NULL)
    {
        InternalMessageBox(g_hInstance, hWnd, MAKEINTRESOURCE(IDS_NOFILESPECIFIED),
            MAKEINTRESOURCE(IDS_REGEDIT), MB_ICONERROR | MB_OK, lpFileName);
        return;
    }

    switch (g_RegEditData.uExportFormat)
    {
    case FILE_TYPE_REGEDT32:
        ExportRegedt32File(lpFileName, lpSelectedPath);
        break;

    case FILE_TYPE_REGEDIT4:
        ExportWin40RegFile(lpFileName, lpSelectedPath);
        break;

    case FILE_TYPE_TEXT:
        RegEdit_SaveAsSubtree(lpFileName, lpSelectedPath);
        break;

    default:
        ExportWinNT50RegFile(lpFileName, lpSelectedPath);
        break;
    }

    if (g_FileErrorStringID != IDS_EXPFILEERRSUCCESS && g_FileErrorStringID != IDS_IMPFILEERRSUCCESSLOCAL)
    {
        InternalMessageBox(g_hInstance, hWnd, MAKEINTRESOURCE(g_FileErrorStringID),
            MAKEINTRESOURCE(IDS_REGEDIT), MB_ICONERROR | MB_OK, lpFileName);
    }


}


//------------------------------------------------------------------------------
//  RegEdit_OnCommandExportRegFile
//
//  DESCRIPTION:
//
//  PARAMETERS: - hWnd, handle of RegEdit window.
//------------------------------------------------------------------------------
VOID RegEdit_OnCommandExportRegFile(HWND hWnd)
{
    TCHAR achFileName[MAX_PATH];
    LPTSTR lpSelectedPath;

    if (RegEdit_GetFileName(hWnd, IDS_EXPORTREGFILETITLE, IDS_REGEXPORTFILEFILTER, 
        IDS_REGFILEDEFEXT, achFileName, ARRAYSIZE(achFileName), FALSE))
    {
        RegEdit_SetWaitCursor(TRUE);

        lpSelectedPath = g_fRangeAll ? NULL : g_SelectedPath;
        RegEdit_ExportRegFile(hWnd, FALSE, achFileName, lpSelectedPath);

        RegEdit_SetWaitCursor(FALSE);
    }
}


//------------------------------------------------------------------------------
//  RegEdit_GetFileName
//
//  DESCRIPTION: Gets a file name
//
//  PARAMETERS: hWnd - handle of RegEdit window.
//              fOpen - TRUE if importing a file, else FALSE if exporting a file.
//              lpFileName - address of file name buffer.
//              cchFileName - size of file name buffer in TCHARacters.
//
//  RETURN:     True, if successfull
//------------------------------------------------------------------------------
BOOL RegEdit_GetFileName(HWND hWnd, UINT uTitleStringID, UINT uFilterStringID, 
    UINT uDefExtStringID, LPTSTR lpFileName, DWORD cchFileName, BOOL fOpen)
{

    PTSTR pTitle = NULL;
    PTSTR pDefaultExtension = NULL;
    PTSTR pFilter = NULL;
    PTSTR pFilterChar;
    OPENFILENAME OpenFileName;
    BOOL fSuccess;

    //
    //  Load various strings that will be displayed and used by the common open
    //  or save dialog box.  Note that if any of these fail, the error is not
    //  fatal-- the common dialog box may look odd, but will still work.
    //

    pTitle = LoadDynamicString(uTitleStringID);

    if (uDefExtStringID != IDS_REGNODEFEXT)
    {
        pDefaultExtension = LoadDynamicString(uDefExtStringID);
    }

    if ((pFilter = LoadDynamicString(uFilterStringID)) != NULL) 
    {
        //  The common dialog library requires that the substrings of the
        //  filter string be separated by nulls, but we cannot load a string
        //  containing nulls.  So we use some dummy character in the resource
        //  that we now convert to nulls.

        for (pFilterChar = pFilter; *pFilterChar != 0; pFilterChar =
            CharNext(pFilterChar)) 
        {
            if (*pFilterChar == TEXT('#'))
                *pFilterChar++ = 0;

        }

    }

    *lpFileName = 0;

    memset(&OpenFileName, 0, sizeof(OPENFILENAME));

    OpenFileName.lStructSize = sizeof(OPENFILENAME);
    OpenFileName.hwndOwner = hWnd;
    OpenFileName.hInstance = g_hInstance;
    OpenFileName.lpstrFilter = pFilter;
    OpenFileName.lpstrFile = lpFileName;
    OpenFileName.nMaxFile = cchFileName;
    OpenFileName.lpstrTitle = pTitle;
    if (fOpen) 
    {
        OpenFileName.Flags = OFN_HIDEREADONLY | OFN_EXPLORER |
            OFN_FILEMUSTEXIST;

        fSuccess = GetOpenFileName(&OpenFileName);

    }

    else 
    {
        OpenFileName.lpstrDefExt = pDefaultExtension;
        OpenFileName.Flags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT |
            OFN_EXPLORER | OFN_NOREADONLYRETURN | OFN_PATHMUSTEXIST |
            OFN_ENABLEHOOK | OFN_ENABLETEMPLATE;
        OpenFileName.lpfnHook = RegCommDlgHookProc;
        OpenFileName.lpTemplateName = MAKEINTRESOURCE(IDD_REGEXPORT);
        g_RegCommDlgDialogTemplate = IDD_REGEXPORT;

        fSuccess = GetSaveFileName(&OpenFileName);

    }

    //
    //  Delete all of the dynamic strings that we loaded.
    //

    if (pTitle != NULL)
        DeleteDynamicString(pTitle);

    if (pDefaultExtension != NULL)
        DeleteDynamicString(pDefaultExtension);

    if (pFilter != NULL)
        DeleteDynamicString(pFilter);

    return fSuccess;

}


/*******************************************************************************
*
*  RegProgressDlgProc
*
*  DESCRIPTION:
*     Callback procedure for the RegAbort dialog box.
*
*  PARAMETERS:
*     hWnd, handle of RegProgress window.
*     Message,
*     wParam,
*     lParam,
*     (returns),
*
*******************************************************************************/

INT_PTR
CALLBACK
RegProgressDlgProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    )
{

    switch (Message) {

        case WM_INITDIALOG:
            //PathSetDlgItemPath(hWnd, IDC_FILENAME, (LPTSTR)lParam);
            SetDlgItemText(hWnd, IDC_FILENAME, (LPTSTR) lParam);
            break;

        default:
            return FALSE;

    }

    return TRUE;

}

/*******************************************************************************
*
*  ImportRegFileUICallback
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID ImportRegFileUICallback(UINT uPercentage)
{

    if (g_hRegProgressWnd != NULL) 
    {
        SendDlgItemMessage(g_hRegProgressWnd, IDC_PROGRESSBAR, PBM_SETPOS,
            (WPARAM) uPercentage, 0);

        while (MessagePump(g_hRegProgressWnd));
    }

}


//------------------------------------------------------------------------------
//  RegEdit_ImportToConnectedComputer
//
//  DESCRIPTION: Imports a reg. file one or more of the connected computers
//
//  PARAMETERS:  HWND hWnd
//               PTSTR pszFileName - import file
//------------------------------------------------------------------------------

void RegEdit_ImportToConnectedComputer(HWND hWnd, PTSTR pszFileName)
{
    DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_REGIMPORTNET), hWnd,
        RegConnectedComputerDlgProc, (LPARAM) pszFileName);
}


//------------------------------------------------------------------------------
//  RegConnectedComputerDlgProc
//
//  DESCRIPTION: Dlg Proc for selecting a connected computer
//
//  PARAMETERS:  
//------------------------------------------------------------------------------
INT_PTR RegConnectedComputerDlgProc(HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    switch (uMessage) 
    {
    case WM_INITDIALOG:
        SetWindowLongPtr(hWnd, DWLP_USER, lParam);
        return RegImport_OnInitDialog(hWnd);
        
    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam)) 
        {
        case IDOK:
            {
                PTSTR pszFileName = (PTSTR) GetWindowLongPtr(hWnd, DWLP_USER);
                // (pszFileName == NULL) is checked later
                RegImport_OnCommandOk(hWnd, pszFileName);
            }
            //  FALL THROUGH
            
        case IDCANCEL:
            EndDialog(hWnd, 0);
            break;
            
        }
        return TRUE;
    }
    
    return FALSE;
}


//------------------------------------------------------------------------------
//  RegImport_OnInitDialog
//
//  DESCRIPTION: Create a list of all the connected computers
//
//  PARAMETERS:  HWND hWnd
//------------------------------------------------------------------------------

INT_PTR RegImport_OnInitDialog(HWND hWnd)
{
    HWND hComputerListWnd;
    RECT ClientRect;
    LV_COLUMN LVColumn;
    LV_ITEM LVItem;
    TCHAR achComputerName[MAX_PATH];
    HWND hKeyTreeWnd;
    TV_ITEM TVItem;

    hComputerListWnd = GetDlgItem(hWnd, IDC_COMPUTERLIST);

    //  Initialize the ListView control.
    ListView_SetImageList(hComputerListWnd, g_RegEditData.hImageList,
        LVSIL_SMALL);

    LVColumn.mask = LVCF_FMT | LVCF_WIDTH;
    LVColumn.fmt = LVCFMT_LEFT;

    GetClientRect(hComputerListWnd, &ClientRect);
    LVColumn.cx = ClientRect.right - GetSystemMetrics(SM_CXVSCROLL) -
        2 * GetSystemMetrics(SM_CXEDGE);

    ListView_InsertColumn(hComputerListWnd, 0, &LVColumn);
  
    //  Walk through the local machine and each remote connection listed 
    //  in the KeyTree and add it to our RemoteList.
    LVItem.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
    LVItem.pszText = achComputerName;
    LVItem.iItem = 0;
    LVItem.iSubItem = 0;
    LVItem.iImage = IMAGEINDEX(IDI_COMPUTER);

    hKeyTreeWnd = g_RegEditData.hKeyTreeWnd;

    TVItem.mask = TVIF_TEXT;
    TVItem.hItem = TreeView_GetRoot(hKeyTreeWnd);
    TVItem.pszText = achComputerName;
    TVItem.cchTextMax = sizeof(achComputerName)/sizeof(TCHAR);

    // Set "local computer" in list
    LVItem.lParam = (LPARAM) TVItem.hItem;
    TreeView_GetItem(hKeyTreeWnd, &TVItem);
    ListView_InsertItem(hComputerListWnd, &LVItem);

    LVItem.iItem++;

    LVItem.iImage = IMAGEINDEX(IDI_REMOTE);

    while ((TVItem.hItem = TreeView_GetNextSibling(hKeyTreeWnd,
        TVItem.hItem)) != NULL)
    {

        LVItem.lParam = (LPARAM) TVItem.hItem;
        TreeView_GetItem(hKeyTreeWnd, &TVItem);
        ListView_InsertItem(hComputerListWnd, &LVItem);

        LVItem.iItem++;
    }   

    ListView_SetItemState(hComputerListWnd, 0, LVIS_FOCUSED, LVIS_FOCUSED);

    return TRUE;

}


//------------------------------------------------------------------------------
//  RegImport_OnCommandOk
//
//  DESCRIPTION: Import key to selected computers
//
//  PARAMETERS:  HWND hWnd, 
//               PTSTR pszFileName - file to import
//------------------------------------------------------------------------------
void RegImport_OnCommandOk(HWND hWnd, PTSTR pszFileName)
{
    LV_ITEM LVItem;
    HWND hComputerListWnd;

    //  Walk through each selected item in the ListView and import the reg file
    LVItem.mask = LVIF_PARAM;
    LVItem.iItem = -1;
    LVItem.iSubItem = 0;

    hComputerListWnd = GetDlgItem(hWnd, IDC_COMPUTERLIST);

    while ((LVItem.iItem = ListView_GetNextItem(hComputerListWnd, LVItem.iItem,
        LVNI_SELECTED)) != -1) 
    {
        ListView_GetItem(hComputerListWnd, &LVItem);

        RegEdit_SetWaitCursor(TRUE);
 
        RegEdit_ImportRegFile(hWnd, FALSE, pszFileName, (HTREEITEM) LVItem.lParam);

        RegEdit_OnKeyTreeRefresh(hWnd);
        RegEdit_SetWaitCursor(FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\regedit\reghelp.h ===
// Help IDs for RegEdit

#define NO_HELP				((DWORD) -1) // Disables Help for a control

#define IDH_REGEDIT_EXPORT		1000
#define IDH_REGEDIT_CONNECT		1001
#define IDH_REGEDIT_CONNECT_BROWSE	1002
#define IDH_REGEDIT_VALUENAME		1003
#define IDH_REGEDIT_VALUEDATA		1004
#define IDH_REGEDIT_LOOK		1005
#define IDH_FIND_SEARCHTEXT		1006
#define IDH_FIND_WHOLE			1007
#define IDH_FIND_NEXT_BUTTON		1008
#define IDH_REGEDIT_PRINTRANGE          1009
#define IDH_REGEDIT_DWORDBASE           1010
#define IDH_REGEDIT_DISCONNECT          1011
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\regedit\regfind.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGFIND.C
*
*  VERSION:     4.0
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        14 Jul 1994
*
*  Find routines for the Registry Editor.
*
*******************************************************************************/

#include "pch.h"
#include "regedit.h"
#include "regkey.h"
#include "regresid.h"
#include "reghelp.h"
#include "regvalue.h"

#define SIZE_FINDSPEC                   (max(MAXKEYNAME, MAXVALUENAME_LENGTH))

TCHAR s_FindSpecification[SIZE_FINDSPEC] = { 0 };

#define FIND_EXACT                      0x00000001
#define FIND_KEYS                       0x00000002
#define FIND_VALUES                     0x00000004
#define FIND_DATA                       0x00000008

//  Initialized value is the default if we don't find last known state in the
//  registry.
DWORD g_FindFlags = FIND_KEYS | FIND_VALUES | FIND_DATA;

//  Global needed to monitor the find abort dialog status.
BOOL s_fContinueFind;

//
//  Reference data for the RegFind dialog.
//

typedef struct _REGFINDDATA {
    UINT LookForCount;
}   REGFINDDATA;

REGFINDDATA s_RegFindData;

//
//  Association between the items of the RegFind dialog and the find flags.
//

typedef struct _DLGITEMFINDFLAGASSOC {
    int DlgItem;
    DWORD Flag;
}   DLGITEMFINDFLAGASSOC;

const DLGITEMFINDFLAGASSOC s_DlgItemFindFlagAssoc[] = {
    IDC_WHOLEWORDONLY,      FIND_EXACT,
        IDC_FORKEYS,            FIND_KEYS,
        IDC_FORVALUES,          FIND_VALUES,
        IDC_FORDATA,            FIND_DATA
};

const DWORD s_RegFindHelpIDs[] = {
    IDC_FINDWHAT,      IDH_FIND_SEARCHTEXT,
        IDC_GROUPBOX,      IDH_REGEDIT_LOOK,
        IDC_FORKEYS,       IDH_REGEDIT_LOOK,
        IDC_FORVALUES,     IDH_REGEDIT_LOOK,
        IDC_FORDATA,       IDH_REGEDIT_LOOK,
        IDC_WHOLEWORDONLY, IDH_FIND_WHOLE,
        IDOK,              IDH_FIND_NEXT_BUTTON,
        
        0, 0
};

BOOL
PASCAL
FindCompare(
            LPTSTR lpString
            );

INT_PTR
PASCAL
RegFindDlgProc(
               HWND hWnd,
               UINT Message,
               WPARAM wParam,
               LPARAM lParam
               );

BOOL
PASCAL
RegFind_OnInitDialog(
                     HWND hWnd,
                     HWND hFocusWnd,
                     LPARAM lParam
                     );

VOID
PASCAL
RegFind_OnCommand(
                  HWND hWnd,
                  int DlgItem,
                  HWND hControlWnd,
                  UINT NotificationCode
                  );

BOOL
PASCAL
RegFindAbortProc(
                 HWND hRegFindAbortWnd
                 );

INT_PTR
CALLBACK
RegFindAbortDlgProc(
                    HWND hWnd,
                    UINT Message,
                    WPARAM wParam,
                    LPARAM lParam
                    );

/*******************************************************************************
*
*  RegEdit_OnCommandFindNext
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnCommandFindNext(
                          HWND hWnd,
                          BOOL fForceDialog
                          )
{
    UINT uErrorStringID;
    BOOL fError = FALSE;
    BOOL fSearchedToEnd;
    HWND hFocusWnd;
    LV_ITEM LVItem;
    TCHAR ValueName[MAXVALUENAME_LENGTH];
    DWORD Type;
    DWORD cbValueData;
    TV_ITEM TVItem;
    TCHAR KeyName[MAXKEYNAME];
    HWND hRegFindAbortWnd;
    HTREEITEM hTempTreeItem;
    UINT ExpandCounter;
    HKEY hRootKey;
    HKEY hKey;
    DWORD EnumIndex;
    DWORD cbValueName;
    BOOL fFoundMatch;
    TCHAR BestValueName[MAXVALUENAME_LENGTH];
    LV_FINDINFO LVFindInfo;
    
    fSearchedToEnd = FALSE;
    hFocusWnd = NULL;
    hRegFindAbortWnd = NULL;
    
    //
    //  Check if we're to show the find dialog.  This is either due to the user
    //  explicitly choosing the "Find" menu item or causing a "Find Next" with
    //  the search specification being uninitialized.
    //
    
    if (fForceDialog || s_FindSpecification[0] == 0) {
        
        if (DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_REGFIND), hWnd,
            RegFindDlgProc) != IDOK)
            return;
        
    }
    
    RegEdit_SetWaitCursor(TRUE);
    
    //
    //  Check if we're trying to finding either value names or data.  If so,
    //  then the next match might be part of the current ValueList.
    //
    
    if (g_FindFlags & (FIND_VALUES | FIND_DATA)) {
        
        LVItem.iItem = ListView_GetNextItem(g_RegEditData.hValueListWnd, -1,
            LVNI_FOCUSED);
        LVItem.iSubItem = 0;
        LVItem.mask = LVIF_TEXT;
        LVItem.pszText = ValueName;
        LVItem.cchTextMax = sizeof(ValueName)/sizeof(TCHAR);
        
        //
        //  Walk over all of the rest of the value names attempting to find a
        //  match.
        //
        
        while ((LVItem.iItem = ListView_GetNextItem(g_RegEditData.hValueListWnd,
            LVItem.iItem, LVNI_ALL)) != -1) {
            
            ListView_GetItem(g_RegEditData.hValueListWnd, &LVItem);
            
            //
            //  Check if this value name meets our search specification.  We'll
            //  assume that this value name still exists.
            //
            
            if ((g_FindFlags & FIND_VALUES) && FindCompare(ValueName))
                goto SelectListItem;
            
            //
            //  Check if this value data meets our search specification.  We'll
            //  have to go back to the registry to determine this.
            //
            
            if (g_FindFlags & FIND_DATA) 
            {
                if ((RegEdit_QueryValueEx(g_RegEditData.hCurrentSelectionKey, ValueName,
                    NULL, &Type, NULL, &cbValueData) == ERROR_SUCCESS) && 
                    IsRegStringType(Type))
                {
                    // Allocate storage space
                    PBYTE pbDataValue = (PBYTE)LocalAlloc(LPTR, cbValueData+ExtraAllocLen(Type));
                    if (pbDataValue)
                    {
                        BOOL fSuccess = FALSE;
                        
                        if (RegEdit_QueryValueEx(g_RegEditData.hCurrentSelectionKey, ValueName,
                            NULL, &Type, pbDataValue, &cbValueData) == ERROR_SUCCESS)
                        {
                            if (Type == REG_MULTI_SZ)
                            {
                                EDITVALUEPARAM evp;
                                evp.pValueData = pbDataValue; 
                                evp.cbValueData = cbValueData;
                                
                                if (ValueList_MultiStringToString(&evp))
                                {
                                    pbDataValue = evp.pValueData;
                                }  
                            }
                            fSuccess = FindCompare((PTSTR)pbDataValue);
                        }
                        
                        LocalFree(pbDataValue);
                        if (fSuccess)
                        {
                            goto SelectListItem;
                        }
                    }
                    else
                    {
                        fError = TRUE;
                        uErrorStringID = IDS_NOMEMORY;
                        goto DismissRegFindAbortWnd;
                    }
                }
                
            }
            
        }
        
    }
    
    //
    //  Searching the registry (especially with this code!) is a lengthy
    //  operation, so we must provide a way for the user to cancel the
    //  operation.
    //
    
    s_fContinueFind = TRUE;
    
    if ((hRegFindAbortWnd = CreateDialog(g_hInstance,
        MAKEINTRESOURCE(IDD_REGFINDABORT), hWnd, RegFindAbortDlgProc)) !=
        NULL) {
        
        EnableWindow(hWnd, FALSE);
        
        //
        //  Major hack:  The following code sequence relies heavily on the
        //  TreeView to maintain the state of the find process.  Even though I'm
        //  inserting and deleting non-visible tree items, the TreeView
        //  currently flickers despite this.
        //
        //  So, we set this internal flag and turn off the TreeView's redraw
        //  flag.  Whenever we get a WM_PAINT message for our main window, we
        //  temporarily "let" it redraw itself then and only then.  That way,
        //  the user can move the modeless abort dialog or switch away and back
        //  and still have the TreeView look normal.
        //
        //  Yes, it's difficult at this time to fix the TreeView's paint logic.
        //
        
        g_RegEditData.fProcessingFind = TRUE;
        SetWindowRedraw(g_RegEditData.hKeyTreeWnd, FALSE);
        
    }
    
    //
    //  Either the user wasn't trying to find value names or data or else no
    //  matches were found.  This means that we must move on to the next branch
    //  of the registry.
    //
    //  We first walk into the children of the current branch, then the
    //  siblings, and finally pop back through the parent.
    //
    //  We use the information already in the KeyTree pane as much as possible.
    //
    
    ExpandCounter = 0;
    fFoundMatch = FALSE;
    BestValueName[0] = '\0';
    
    TVItem.mask = TVIF_TEXT | TVIF_STATE | TVIF_CHILDREN;
    TVItem.pszText = KeyName;
    TVItem.cchTextMax = sizeof(KeyName)/sizeof(TCHAR);
    
    TVItem.hItem = TreeView_GetSelection(g_RegEditData.hKeyTreeWnd);
    TreeView_GetItem(g_RegEditData.hKeyTreeWnd, &TVItem);
    
    while (TRUE) {
        
        //
        //  Check if we should cancel the find operation.  If so, restore our
        //  initial state and exit.
        //
        
        if (!RegFindAbortProc(hRegFindAbortWnd)) {
            
            if (ExpandCounter) {
                
                hTempTreeItem = TVItem.hItem;
                
                do {
                    
                    hTempTreeItem =
                        TreeView_GetParent(g_RegEditData.hKeyTreeWnd,
                        hTempTreeItem);
                    
                }   while (--ExpandCounter);
                
                TreeView_Expand(g_RegEditData.hKeyTreeWnd, hTempTreeItem,
                    TVE_COLLAPSE | TVE_COLLAPSERESET);
                
            }
            
            goto DismissRegFindAbortWnd;
            
        }
        
        //
        //  Does this branch have any children?  This would have been determined
        //  when the tree item was built by the routine KeyTree_ExpandBranch.
        //
        
        if (TVItem.cChildren) {
            
            //
            //  The branch may have children, but it may not have been expanded
            //  yet.
            //
            
            if ((hTempTreeItem = TreeView_GetChild(g_RegEditData.hKeyTreeWnd,
                TVItem.hItem)) == NULL) {
                
                if (!KeyTree_ExpandBranch(g_RegEditData.hKeyTreeWnd,
                    TVItem.hItem))
                    goto SkipToSibling;
                
                if ((hTempTreeItem = TreeView_GetChild(g_RegEditData.hKeyTreeWnd,
                    TVItem.hItem)) == NULL)
                    goto SkipToSibling;
                
                ExpandCounter++;
                
            }
            
            TVItem.hItem = hTempTreeItem;
            
        }
        
        //
        //  The branch doesn't have any children, so we'll move on to the next
        //  sibling of the current branch.  If none exists, then try finding
        //  the next sibling of the parent branch, and so on.
        //
        
        else {
            
SkipToSibling:
        while (TRUE) {
            
            if ((hTempTreeItem =
                TreeView_GetNextSibling(g_RegEditData.hKeyTreeWnd,
                TVItem.hItem)) != NULL) {
                
                TVItem.hItem = hTempTreeItem;
                break;
                
            }
            
            //
            //  If no more parents exist, then we've finished searching the
            //  tree.  We're outta here!
            //
            
            if ((TVItem.hItem =
                TreeView_GetParent(g_RegEditData.hKeyTreeWnd,
                TVItem.hItem)) == NULL) {
                
                fSearchedToEnd = TRUE;
                
                goto DismissRegFindAbortWnd;
                
            }
            
            if (ExpandCounter) {
                
                ExpandCounter--;
                
                TreeView_Expand(g_RegEditData.hKeyTreeWnd, TVItem.hItem,
                    TVE_COLLAPSE | TVE_COLLAPSERESET);
                
            }
            
        }
        
        }
        
        //
        //  If we made it this far, then we're at the next branch of the
        //  registry to evaluate.
        //
        
        TreeView_GetItem(g_RegEditData.hKeyTreeWnd, &TVItem);
        
        //
        //  Check if we're trying to find keys.
        //
        
        if (g_FindFlags & FIND_KEYS) {
            
            if (FindCompare(KeyName))
                goto SelectTreeItem;
            
        }
        
        //
        //  Check if we're trying to find value names or data.
        //
        
        if (g_FindFlags & (FIND_VALUES | FIND_DATA)) {
            
            //
            //  Try to open the registry at the new current branch.
            //
            
            hRootKey = KeyTree_BuildKeyPath(g_RegEditData.hKeyTreeWnd,
                TVItem.hItem, KeyName, BKP_TOSUBKEY);
            
            if(hRootKey && RegOpenKeyEx(hRootKey,KeyName,0,KEY_QUERY_VALUE,&hKey) ==
                ERROR_SUCCESS) {
                
                //
                //  Here's the simple case-- we're trying to find an exact match
                //  for a value name.  We can just use the registry API to do
                //  this for us!
                //
                
                if ((g_FindFlags & (FIND_VALUES | FIND_DATA | FIND_EXACT)) ==
                    (FIND_VALUES | FIND_EXACT)) {
                    
                    if (RegEdit_QueryValueEx(hKey, s_FindSpecification, NULL, NULL,
                        NULL, NULL) == ERROR_SUCCESS) {
                        
                        lstrcpy(BestValueName, s_FindSpecification);
                        fFoundMatch = TRUE;
                        
                    }
                    
                }
                
                //
                //  Bummer... we need to walk through all of the registry
                //  value/data pairs for this key to try to find a match.  Even
                //  worse, we have to look at _all_ of the entries, not just the
                //  first hit... we must display the first alphabetically
                //  matching entry!
                //
                
                else {
                    
                    EnumIndex = 0;
                    
                    while (TRUE) 
                    {
                        cbValueName = sizeof(ValueName)/sizeof(TCHAR);
                        
                        if (RegEnumValue(hKey, EnumIndex++, ValueName,
                            &cbValueName, NULL, &Type, NULL,
                            &cbValueData) == ERROR_SUCCESS)
                        {
                            PBYTE pbValueData = (g_FindFlags & FIND_DATA) ? 
                                (PBYTE)LocalAlloc(LPTR, cbValueData+ExtraAllocLen(Type)) : NULL;
                            
                            if (pbValueData || !(g_FindFlags & FIND_DATA))
                            {
                                if (RegEdit_QueryValueEx(hKey, ValueName, NULL, &Type, 
                                    pbValueData, &cbValueData) == ERROR_SUCCESS)
                                {
                                    if (pbValueData && (Type == REG_MULTI_SZ))
                                    {
                                        EDITVALUEPARAM evp;
                                        evp.pValueData = pbValueData; 
                                        evp.cbValueData = cbValueData;
                                        
                                        if (ValueList_MultiStringToString(&evp))
                                        {
                                            pbValueData = evp.pValueData;
                                        }
                                    }
                                    
                                    if (((g_FindFlags & FIND_VALUES) &&
                                        FindCompare(ValueName)) ||
                                        ((g_FindFlags & FIND_DATA) && IsRegStringType(Type) &&
                                        FindCompare((PTSTR)pbValueData))) 
                                    {
                                        //
                                        //  We've got to check if we've found a "better"
                                        //  value name to display-- one that's at the top of
                                        //  the sorted list.
                                        //
                                        
                                        if (fFoundMatch) {
                                            
                                            if (lstrcmpi(BestValueName, ValueName) > 0)
                                                lstrcpy(BestValueName, ValueName);
                                            
                                        }
                                        
                                        else {
                                            
                                            lstrcpy(BestValueName, ValueName);
                                            fFoundMatch = TRUE;
                                            
                                        }
                                        
                                    }
                                }
                                if (pbValueData)
                                {
                                    LocalFree(pbValueData);
                                }
                            }
                            else
                            {
                                fError = TRUE;
                                uErrorStringID = IDS_NOMEMORY;
                                goto DismissRegFindAbortWnd;
                            }
                        }
                        else
                        {
                            break;
                        }
                    }
                    
                }
                
                RegCloseKey(hKey);
                
                if (fFoundMatch)
                    goto SelectTreeItem;
                
            }
            
        }
        
    }
    
SelectTreeItem:
    TreeView_EnsureVisible(g_RegEditData.hKeyTreeWnd, TVItem.hItem);
    TreeView_SelectItem(g_RegEditData.hKeyTreeWnd, TVItem.hItem);
    
    if (!fFoundMatch)
        hFocusWnd = g_RegEditData.hKeyTreeWnd;
    
    else {
        
        //
        //  Right now, the TreeView_SelectItem above will cause the ValueListWnd
        //  to update, but only after a short time delay.  We want the list
        //  immediately updated, so force the timer to go off now.
        //
        
        RegEdit_OnSelChangedTimer(hWnd);
        
        if (BestValueName[0] == 0)
            LVItem.iItem = 0;
        
        else {
            
            LVFindInfo.flags = LVFI_STRING;
            LVFindInfo.psz = BestValueName;
            
            LVItem.iItem = ListView_FindItem(g_RegEditData.hValueListWnd,
                -1, &LVFindInfo);
            
        }
        
SelectListItem:
        ListView_SetItemState(g_RegEditData.hValueListWnd, -1, 0,
            LVIS_SELECTED | LVIS_FOCUSED);
        ListView_SetItemState(g_RegEditData.hValueListWnd, LVItem.iItem,
            LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
        ListView_EnsureVisible(g_RegEditData.hValueListWnd, LVItem.iItem,
            FALSE);
        
        hFocusWnd = g_RegEditData.hValueListWnd;
        
    }
    
DismissRegFindAbortWnd:
    RegEdit_SetWaitCursor(FALSE);
    
    if (hRegFindAbortWnd != NULL) {
        
        g_RegEditData.fProcessingFind = FALSE;
        SetWindowRedraw(g_RegEditData.hKeyTreeWnd, TRUE);
        
        EnableWindow(hWnd, TRUE);
        DestroyWindow(hRegFindAbortWnd);
        
    }
    
    if (hFocusWnd != NULL)
        SetFocus(hFocusWnd);
    
    if (fError)
    {
        InternalMessageBox(g_hInstance, hWnd, MAKEINTRESOURCE(uErrorStringID),
            MAKEINTRESOURCE(IDS_REGEDIT), MB_ICONERROR | MB_OK);
    }
    
    if (fSearchedToEnd)
        InternalMessageBox(g_hInstance, hWnd, MAKEINTRESOURCE(IDS_SEARCHEDTOEND),
        MAKEINTRESOURCE(IDS_REGEDIT), MB_ICONINFORMATION | MB_OK);
}

/*******************************************************************************
*
*  FindCompare
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL
PASCAL
FindCompare(
            LPTSTR lpString
            )
{
    
    if (g_FindFlags & FIND_EXACT)
        return lstrcmpi(lpString, s_FindSpecification) == 0;
    
    else
        return StrStrI(lpString, s_FindSpecification) != NULL;
    
}

/*******************************************************************************
*
*  RegFindDlgProc
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

INT_PTR
PASCAL
RegFindDlgProc(
               HWND hWnd,
               UINT Message,
               WPARAM wParam,
               LPARAM lParam
               )
{
    
    switch (Message) {
        
        HANDLE_MSG(hWnd, WM_INITDIALOG, RegFind_OnInitDialog);
        HANDLE_MSG(hWnd, WM_COMMAND, RegFind_OnCommand);
        
    case WM_HELP:
        WinHelp(((LPHELPINFO) lParam)-> hItemHandle, g_pHelpFileName,
            HELP_WM_HELP, (ULONG_PTR) s_RegFindHelpIDs);
        break;
        
    case WM_CONTEXTMENU:
        WinHelp((HWND) wParam, g_pHelpFileName, HELP_CONTEXTMENU,
            (ULONG_PTR) s_RegFindHelpIDs);
        break;
        
    default:
        return FALSE;
        
    }
    
    return TRUE;
    
}

/*******************************************************************************
*
*  RegFind_OnInitDialog
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL
PASCAL
RegFind_OnInitDialog(
                     HWND hWnd,
                     HWND hFocusWnd,
                     LPARAM lParam
                     )
{
    
    UINT Counter;
    int DlgItem;
    
    //
    //  Initialize the "Find What" edit control.
    //
    
    SendDlgItemMessage(hWnd, IDC_FINDWHAT, EM_SETLIMITTEXT,
        SIZE_FINDSPEC, 0);
    SetDlgItemText(hWnd, IDC_FINDWHAT, s_FindSpecification);
    
    //
    //  Initialize the checkboxes based on the state of the global find flags.
    //
    
    s_RegFindData.LookForCount = 0;
    
    for (Counter = 0; Counter < sizeof(s_DlgItemFindFlagAssoc) /
        sizeof(DLGITEMFINDFLAGASSOC); Counter++) {
        
        if (g_FindFlags & s_DlgItemFindFlagAssoc[Counter].Flag) {
            
            DlgItem = s_DlgItemFindFlagAssoc[Counter].DlgItem;
            
            CheckDlgButton(hWnd, DlgItem, TRUE);
            
            if (DlgItem >= IDC_FORKEYS && DlgItem <= IDC_FORDATA)
                s_RegFindData.LookForCount++;
            
        }
        
    }
    
    return TRUE;
    
    UNREFERENCED_PARAMETER(hFocusWnd);
    UNREFERENCED_PARAMETER(lParam);
    
}

/*******************************************************************************
*
*  RegFind_OnCommand
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
PASCAL
RegFind_OnCommand(
                  HWND hWnd,
                  int DlgItem,
                  HWND hControlWnd,
                  UINT NotificationCode
                  )
{
    
    UINT Counter;
    
    if (DlgItem >= IDC_FORKEYS && DlgItem <= IDC_FORDATA) {
        
        if (NotificationCode == BN_CLICKED) {
            
            IsDlgButtonChecked(hWnd, DlgItem) ? s_RegFindData.LookForCount++ :
        s_RegFindData.LookForCount--;
        
        goto EnableFindNextButton;
        
        }
        
    }
    
    else {
        
        switch (DlgItem) {
            
        case IDC_FINDWHAT:
            if (NotificationCode == EN_CHANGE) {
                
EnableFindNextButton:
            EnableWindow(GetDlgItem(hWnd, IDOK),
                s_RegFindData.LookForCount > 0 &&
                SendDlgItemMessage(hWnd, IDC_FINDWHAT,
                WM_GETTEXTLENGTH, 0, 0) != 0);
            
            }
            break;
            
        case IDOK:
            GetDlgItemText(hWnd, IDC_FINDWHAT, s_FindSpecification,
                sizeof(s_FindSpecification)/sizeof(TCHAR));
            
            for (Counter = 0; Counter < sizeof(s_DlgItemFindFlagAssoc) /
                sizeof(DLGITEMFINDFLAGASSOC); Counter++) {
                
                if (IsDlgButtonChecked(hWnd,
                    s_DlgItemFindFlagAssoc[Counter].DlgItem))
                    g_FindFlags |= s_DlgItemFindFlagAssoc[Counter].Flag;
                else
                    g_FindFlags &= ~s_DlgItemFindFlagAssoc[Counter].Flag;
                
            }
            
            //  FALL THROUGH
            
        case IDCANCEL:
            EndDialog(hWnd, DlgItem);
            break;
            
        }
        
    }
    
}

/*******************************************************************************
*
*  RegFindAbortProc
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     (returns), TRUE to continue the find, else FALSE to cancel.
*
*******************************************************************************/

BOOL
PASCAL
RegFindAbortProc(
                 HWND hRegFindAbortWnd
                 )
{
    
    while (s_fContinueFind && MessagePump(hRegFindAbortWnd))
        ;
    
    return s_fContinueFind;
    
}

/*******************************************************************************
*
*  RegAbortDlgProc
*
*  DESCRIPTION:
*     Callback procedure for the RegAbort dialog box.
*
*  PARAMETERS:
*     hWnd, handle of RegAbort window.
*     Message,
*     wParam,
*     lParam,
*     (returns),
*
*******************************************************************************/

INT_PTR
CALLBACK
RegFindAbortDlgProc(
                    HWND hWnd,
                    UINT Message,
                    WPARAM wParam,
                    LPARAM lParam
                    )
{
    
    switch (Message) {
        
    case WM_INITDIALOG:
        break;
        
    case WM_CLOSE:
    case WM_COMMAND:
        s_fContinueFind = FALSE;
        break;
        
    default:
        return FALSE;
        
    }
    
    return TRUE;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\regedit\regiodls.cxx ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    regiodls.cxx

Abstract:

    This module contains the definitions of the member functions
    of IO_DESCRIPTOR_LIST class.

Author:

    Jaime Sasson (jaimes) 02-Dec-1993

Environment:

    ULIB, User Mode


--*/

#include "regiodls.hxx"
#include "regiodsc.hxx"
#include "iterator.hxx"


DEFINE_CONSTRUCTOR ( IO_DESCRIPTOR_LIST, OBJECT );


IO_DESCRIPTOR_LIST::~IO_DESCRIPTOR_LIST (
    )

/*++

Routine Description:

    Destroy an IO_DESCRIPTOR_LIST.

Arguments:

    None.

Return Value:

    None.

--*/

{
    Destroy();
}


VOID
IO_DESCRIPTOR_LIST::Construct (
    )

/*++

Routine Description:

    Construct an IO_DESCRIPTOR_LIST object.

Arguments:

    None.

Return Value:

    None.

--*/

{
        _Version = 0;
        _Revision = 0;
        _DescriptorsList = NULL;
}


VOID
IO_DESCRIPTOR_LIST::Destroy (
    )

/*++

Routine Description:

    Worker method for object destruction.

Arguments:

    None.

Return Value:

    None.

--*/

{
    _Version = 0;
    _Revision = 0;
    if( _DescriptorsList != NULL ) {
        _DescriptorsList->DeleteAllMembers();
        DELETE( _DescriptorsList );
    }
    _DescriptorsList = NULL;
}


BOOLEAN
IO_DESCRIPTOR_LIST::Initialize(
    IN  PCBYTE       Data,
    IN  ULONG        Size,
    OUT PULONG       DescriptorSize
    )

/*++

Routine Description:

    Initialize an object of type IO_DESCRIPTOR_LIST.

Arguments:

    Data - Pointer to a buffer that contains an IO_RESOURCE_LIST.

    Size - Buffer size.

Return Value:

    BOOLEAN - Returns TRUE if the initialization succeeds.

--*/

{
    PIO_RESOURCE_LIST               IoResourceList;
    ULONG                           Count;
    ULONG                           i;
    ULONG                           j;

    PARRAY                         TmpList;
    PIO_PORT_DESCRIPTOR            PortDescriptor;
    PIO_INTERRUPT_DESCRIPTOR       InterruptDescriptor;
    PIO_MEMORY_DESCRIPTOR          MemoryDescriptor;
    PIO_DMA_DESCRIPTOR             DmaDescriptor;

    if( Data == NULL ) {
        return( FALSE );
    }

    Count           = 1;
    IoResourceList  = ( PIO_RESOURCE_LIST )Data;

    TmpList = ( PARRAY )NEW( ARRAY );
    DebugPtrAssert( TmpList );
    if( ( TmpList == NULL ) ||
        ( !TmpList->Initialize() ) ) {
        DebugPrintTrace(("REGEDT32: Out of memory" ));
        DELETE( TmpList );
        return( FALSE );
    }

    _Version = IoResourceList->Version;
    _Revision = IoResourceList->Revision;

    //
    // For each CM_FULL_RESOURCE DESCRIPTOR in the current value...
    //

    for( i = 0; i < Count; i++ ) {

        PIO_RESOURCE_DESCRIPTOR   IoResourceDescriptor;

        //
        // For each IO_RESOURCE_DESCRIPTOR in the list...
        //

        for( j = 0; j < IoResourceList->Count; j++ ) {

                //
                // Get a pointer to the current IO_RESOURCE_DESCRIPTOR
                // in the current IO_RESOURCE_LIST.
                //

                IoResourceDescriptor = &( IoResourceList->Descriptors[ j ]);
                //
                //  Ignore invalid data
                //
                if( ( ULONG_PTR )IoResourceDescriptor >
                        ( ULONG_PTR )( Data + Size - sizeof( IO_RESOURCE_DESCRIPTOR ) ) ) {
                    DebugPrintTrace(( "REGEDT32: Invalid IO_RESOURCE_DESCRIPTOR, j = %d \n", j ));
                    if( DescriptorSize != NULL ) {
                        *DescriptorSize = Size;
                    }
                    _DescriptorsList = TmpList;
                    return( TRUE );
                }

                switch( IoResourceDescriptor->Type ) {

                case CmResourceTypePort:

                    PortDescriptor = ( PIO_PORT_DESCRIPTOR )NEW( IO_PORT_DESCRIPTOR );
                    if( ( PortDescriptor == NULL ) ||
                        ( !PortDescriptor->Initialize( IoResourceDescriptor->u.Port.Length,
                                                       IoResourceDescriptor->u.Port.Alignment,
                                                       &IoResourceDescriptor->u.Port.MinimumAddress,
                                                       &IoResourceDescriptor->u.Port.MaximumAddress,
                                                       IoResourceDescriptor->Option,
                                                       IoResourceDescriptor->ShareDisposition,
                                                       IoResourceDescriptor->Flags ) )
                      ) {
                        DebugPrintTrace(( "REGEDT32: Unable to create IO_PORT_DESCRIPTOR" ));
                        DELETE( PortDescriptor );
                        TmpList->DeleteAllMembers();
                        DELETE( TmpList );
                        return( FALSE );
                    }
                    TmpList->Put( PortDescriptor );
                    break;

                case CmResourceTypeInterrupt:

                    InterruptDescriptor = ( PIO_INTERRUPT_DESCRIPTOR )NEW( IO_INTERRUPT_DESCRIPTOR );
                    if( ( InterruptDescriptor == NULL ) ||
                        ( !InterruptDescriptor->Initialize( IoResourceDescriptor->u.Interrupt.MinimumVector,
                                                            IoResourceDescriptor->u.Interrupt.MaximumVector,
                                                            IoResourceDescriptor->Option,
                                                            IoResourceDescriptor->ShareDisposition,
                                                            IoResourceDescriptor->Flags ) )
                      ) {
                        DebugPrintTrace(( "REGEDT32: Unable to create IO_INTERRUPT_DESCRIPTOR" ));
                        DELETE( InterruptDescriptor );
                        TmpList->DeleteAllMembers();
                        DELETE( TmpList );
                        return( FALSE );
                    }
                    TmpList->Put( InterruptDescriptor );
                    break;

                case CmResourceTypeMemory:

                    MemoryDescriptor = ( PIO_MEMORY_DESCRIPTOR )NEW( IO_MEMORY_DESCRIPTOR );
                    if( ( MemoryDescriptor == NULL ) ||
                        ( !MemoryDescriptor->Initialize( IoResourceDescriptor->u.Memory.Length,
                                                         IoResourceDescriptor->u.Memory.Alignment,
                                                         &IoResourceDescriptor->u.Memory.MinimumAddress,
                                                         &IoResourceDescriptor->u.Memory.MaximumAddress,
                                                         IoResourceDescriptor->Option,
                                                         IoResourceDescriptor->ShareDisposition,
                                                         IoResourceDescriptor->Flags ) )
                      ) {
                        DebugPrintTrace(( "REGEDT32: Unable to create IO_MEMORY_DESCRIPTOR" ));
                        DELETE( MemoryDescriptor );
                        TmpList->DeleteAllMembers();
                        DELETE( TmpList );
                        return( FALSE );
                    }
                    TmpList->Put( MemoryDescriptor );
                    break;

                case CmResourceTypeDma:

                    DmaDescriptor = ( PIO_DMA_DESCRIPTOR )NEW( IO_DMA_DESCRIPTOR );
                    if( ( DmaDescriptor == NULL ) ||
                        ( !DmaDescriptor->Initialize( IoResourceDescriptor->u.Dma.MinimumChannel,
                                                      IoResourceDescriptor->u.Dma.MaximumChannel,
                                                      IoResourceDescriptor->Option,
                                                      IoResourceDescriptor->ShareDisposition,
                                                      IoResourceDescriptor->Flags ) )
                      ) {
                        DebugPrintTrace(( "REGEDT32: Unable to create IO_DMA_DESCRIPTOR" ));
                        DELETE( DmaDescriptor );
                        TmpList->DeleteAllMembers();
                        DELETE( TmpList );
                        return( FALSE );
                    }
                    TmpList->Put( DmaDescriptor );
                    break;

                default:

                    DebugPrintTrace(( "REGEDT32: Unknown IoResourceDescriptor->Type == %#x \n",
                                IoResourceDescriptor->Type ));
                    continue;
                }
        }

        _DescriptorsList = TmpList;

        //
        // Get the next IO_RESOURCE_LIST from the list.
        //

        IoResourceList = ( PIO_RESOURCE_LIST )( IoResourceDescriptor + 1 );
    }
    if( DescriptorSize != NULL ) {
        *DescriptorSize = ( ULONG )( ( ULONG_PTR )IoResourceList - ( ULONG_PTR )Data );
#if DBG
        if( *DescriptorSize > Size ) {
            DebugPrintTrace(( "REGEDT32: Invalid sizes, *DescriptorSize = %d, Size = %d \n", *DescriptorSize, Size ));
        }
#endif
    }
    return( TRUE );
}

#if DBG
VOID
IO_DESCRIPTOR_LIST::DbgDumpObject(
    )

/*++

Routine Description:

    Print an IO_DESCRIPTOR_LIST object.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PITERATOR   Iterator;
    PIO_DESCRIPTOR Descriptor;

    DebugPrintTrace(( "\tVersion = %#x \n", _Version ));
    DebugPrintTrace(( "\tRevision = %#x \n", _Revision ));
    if( _DescriptorsList != NULL ) {
        Iterator = _DescriptorsList->QueryIterator();
        while( Descriptor = ( PIO_DESCRIPTOR ) Iterator->GetNext() ) {
            if( Descriptor->IsDescriptorTypePort() ) {
                ( ( PIO_PORT_DESCRIPTOR )Descriptor )->DbgDumpObject();
            } else if( Descriptor->IsDescriptorTypeInterrupt() ) {
                ( ( PIO_INTERRUPT_DESCRIPTOR )Descriptor )->DbgDumpObject();
            } else if( Descriptor->IsDescriptorTypeMemory() ) {
                ( ( PIO_MEMORY_DESCRIPTOR )Descriptor )->DbgDumpObject();
            } else if( Descriptor->IsDescriptorTypeDma() ) {
                ( ( PIO_DMA_DESCRIPTOR )Descriptor )->DbgDumpObject();
            } else {
                DebugPrintTrace(( "\tERROR: Unknown Descriptor \n\n" ));
            }
        }
        DELETE( Iterator );
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\regedit\regiodsc.cxx ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    regiodsc.cxx

Abstract:

    This module contains the definitions of the member functions
    of IO_DESCRIPTOR class.

Author:

    Jaime Sasson (jaimes) 02-Dec-1993

Environment:

    ULIB, User Mode


--*/


// don't let ntdddisk.h (included in ulib.hxx") 
// redefine values
#define _NTDDDISK_H_

#include "ulib.hxx"
#include "regiodsc.hxx"

#include <ctype.h>

DEFINE_CONSTRUCTOR ( IO_DESCRIPTOR, OBJECT );


IO_DESCRIPTOR::~IO_DESCRIPTOR (
    )

/*++

Routine Description:

    Destroy a IO_DESCRIPTOR.

Arguments:

    None.

Return Value:

    None.

--*/

{
}

VOID
IO_DESCRIPTOR::Construct (
    )

/*++

Routine Description:

    Construct a IO_DESCRIPTOR object.

Arguments:

    None.

Return Value:

    None.

--*/

{
        _Option = 0;
        _Type = 0;
        _ShareDisposition = 0;
        _Flags = 0;
}

#if DBG
VOID
IO_DESCRIPTOR::DbgDumpObject(
    )

/*++

Routine Description:

    Print a IO_DESCRIPTOR object.

Arguments:

    None.

Return Value:

    None.

--*/

{
    DebugPrintTrace(( "\t\tOption = %#x \n", _Option ));
    DebugPrintTrace(( "\t\tType = %#x \n", _Type ));
    DebugPrintTrace(( "\t\tShareDisposition = %#x \n", _ShareDisposition ));
    DebugPrintTrace(( "\t\tFlags = %x \n", _Flags ));
}
#endif

// #include "ulib.hxx"
// #include "regdesc.hxx"

// extern "C" {
//    #include <ctype.h>
// }

DEFINE_CONSTRUCTOR ( IO_PORT_DESCRIPTOR, IO_DESCRIPTOR );


IO_PORT_DESCRIPTOR::~IO_PORT_DESCRIPTOR (
    )

/*++

Routine Description:

    Destroy an IO_PORT_DESCRIPTOR.

Arguments:

    None.

Return Value:

    None.

--*/

{
}

VOID
IO_PORT_DESCRIPTOR::Construct (
    )

/*++

Routine Description:

    Construct a IO_PORT_DESCRIPTOR object.

Arguments:

    None.

Return Value:

    None.

--*/

{
        _Length = 0;
        _Alignment = 0;
        _MinimumAddress.LowPart = 0;
        _MinimumAddress.HighPart = 0;
        _MaximumAddress.LowPart = 0;
        _MaximumAddress.HighPart = 0;
}

#if DBG
VOID
IO_PORT_DESCRIPTOR::DbgDumpObject(
    )

/*++

Routine Description:

    Print a IO_PORT_DESCRIPTOR object.

Arguments:

    None.

Return Value:

    None.

--*/

{
    IO_DESCRIPTOR::DbgDumpObject();
    DebugPrintTrace(( "\t\tLength = %#lx \n", _Length ));
    DebugPrintTrace(( "\t\tAlignment = %#lx \n", _Alignment ));
    DebugPrintTrace(( "\t\tMinimumAddress.HighPart = %#lx \n", _MinimumAddress.HighPart ));
    DebugPrintTrace(( "\t\tMinimumAddress.LowPart = %#lx \n", _MinimumAddress.LowPart ));
    DebugPrintTrace(( "\t\tMaximumAddress.HighPart = %#lx \n", _MaximumAddress.HighPart ));
    DebugPrintTrace(( "\t\tMaximumAddress.LowPart = %#lx \n", _MaximumAddress.LowPart ));
    DebugPrintTrace(( "\n" ));
}
#endif

// #include "ulib.hxx"
// #include "regdesc.hxx"

// extern "C" {
//    #include <ctype.h>
// }

DEFINE_CONSTRUCTOR ( IO_INTERRUPT_DESCRIPTOR, IO_DESCRIPTOR );


IO_INTERRUPT_DESCRIPTOR::~IO_INTERRUPT_DESCRIPTOR (
    )

/*++

Routine Description:

    Destroy an IO_INTERRUPT_DESCRIPTOR.

Arguments:

    None.

Return Value:

    None.

--*/

{
}

VOID
IO_INTERRUPT_DESCRIPTOR::Construct (
    )

/*++

Routine Description:

    Construct an IO_INTERRUPT_DESCRIPTOR object.

Arguments:

    None.

Return Value:

    None.

--*/

{
    _MinimumVector = 0;
    _MaximumVector = 0;
}

#if DBG
VOID
IO_INTERRUPT_DESCRIPTOR::DbgDumpObject(
    )

/*++

Routine Description:

    Print an IO_INTERRUPT_DESCRIPTOR object.

Arguments:

    None.

Return Value:

    None.

--*/

{
    IO_DESCRIPTOR::DbgDumpObject();
    DebugPrintTrace(( "\t\tMinimumVector = %#lx \n", _MinimumVector ));
    DebugPrintTrace(( "\t\tMaximumVector = %#lx \n", _MaximumVector ));
    DebugPrintTrace(( "\n" ));
}
#endif



// #include "ulib.hxx"
// #include "regdesc.hxx"

// extern "C" {
//    #include <ctype.h>
// }

DEFINE_CONSTRUCTOR ( IO_MEMORY_DESCRIPTOR, IO_DESCRIPTOR );


IO_MEMORY_DESCRIPTOR::~IO_MEMORY_DESCRIPTOR (
    )

/*++

Routine Description:

    Destroy an IO_MEMORY_DESCRIPTOR.

Arguments:

    None.

Return Value:

    None.

--*/

{
}

VOID
IO_MEMORY_DESCRIPTOR::Construct (
    )

/*++

Routine Description:

    Construct an IO_MEMORY_DESCRIPTOR object.

Arguments:

    None.

Return Value:

    None.

--*/

{
        _Length = 0;
        _Alignment = 0;
        _MinimumAddress.LowPart = 0;
        _MinimumAddress.HighPart = 0;
        _MaximumAddress.LowPart = 0;
        _MaximumAddress.HighPart = 0;
}

#if DBG
VOID
IO_MEMORY_DESCRIPTOR::DbgDumpObject(
    )

/*++

Routine Description:

    Print an IO_MEMORY_DESCRIPTOR object.

Arguments:

    None.

Return Value:

    None.

--*/

{
    IO_DESCRIPTOR::DbgDumpObject();
    DebugPrintTrace(( "\t\tLength = %#lx \n", _Length ));
    DebugPrintTrace(( "\t\tAlignment = %#lx \n", _Alignment ));
    DebugPrintTrace(( "\t\tMinimumAddress.HighPart = %#lx \n", _MinimumAddress.HighPart ));
    DebugPrintTrace(( "\t\tMinimumAddress.LowPart = %#lx \n", _MinimumAddress.LowPart ));
    DebugPrintTrace(( "\t\tMaximumAddress.HighPart = %#lx \n", _MaximumAddress.HighPart ));
    DebugPrintTrace(( "\t\tMaximumAddress.LowPart = %#lx \n", _MaximumAddress.LowPart ));
    DebugPrintTrace(( "\n" ));
}
#endif

// #include "ulib.hxx"
// #include "regdesc.hxx"

// extern "C" {
//    #include <ctype.h>
// }

DEFINE_CONSTRUCTOR ( IO_DMA_DESCRIPTOR, IO_DESCRIPTOR );


IO_DMA_DESCRIPTOR::~IO_DMA_DESCRIPTOR (
    )

/*++

Routine Description:

    Destroy a IO_DMA_DESCRIPTOR.

Arguments:

    None.

Return Value:

    None.

--*/

{
}

VOID
IO_DMA_DESCRIPTOR::Construct (
    )

/*++

Routine Description:

    Construct an IO_DMA_DESCRIPTOR object.

Arguments:

    None.

Return Value:

    None.

--*/

{
    _MinimumChannel = 0;
    _MaximumChannel = 0;
}

#if DBG
VOID
IO_DMA_DESCRIPTOR::DbgDumpObject(
    )

/*++

Routine Description:

    Print a IO_DMA_DESCRIPTOR object.

Arguments:

    None.

Return Value:

    None.

--*/

{
    IO_DESCRIPTOR::DbgDumpObject();
    DebugPrintTrace(( "\t\tMinimumChannel = %#lx \n", _MinimumChannel ));
    DebugPrintTrace(( "\t\tMaximumChannel = %#lx \n", _MaximumChannel ));
    DebugPrintTrace(( "\n" ));
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\regedit\regioreq.cxx ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    regresls.cxx

Abstract:

    This module contains the definitions of the member functions
    of IO_REQUIREMENTS_LIST class.

Author:

    Jaime Sasson (jaimes) 02-Dec-1993

Environment:

    ULIB, User Mode


--*/

#include "regioreq.hxx"
#include "iterator.hxx"
#include "regiodsc.hxx"
#include "regiodls.hxx"


DEFINE_CONSTRUCTOR ( IO_REQUIREMENTS_LIST, OBJECT );


IO_REQUIREMENTS_LIST::~IO_REQUIREMENTS_LIST (
    )

/*++

Routine Description:

    Destroy a IO_REQUIREMENTS_LIST.

Arguments:

    None.

Return Value:

    None.

--*/

{
    Destroy();
}


VOID
IO_REQUIREMENTS_LIST::Construct (
    )

/*++

Routine Description:

    Construct an IO_REQUIREMENTS_LIST object.

Arguments:

    None.

Return Value:

    None.

--*/

{
    _InterfaceType = Internal;
    _BusNumber = 0;
    _SlotNumber = 0;
    _Reserved1 = 0;
    _Reserved2 = 0;
    _Reserved3 = 0;
    _AlternativeLists = NULL;
}


VOID
IO_REQUIREMENTS_LIST::Destroy (
    )

/*++

Routine Description:

    Worker method for object destruction.

Arguments:

    None.

Return Value:

    None.

--*/

{
    if( _AlternativeLists != NULL ) {
        _AlternativeLists->DeleteAllMembers();
        DELETE( _AlternativeLists );
    }
    _AlternativeLists = NULL;
}



BOOLEAN
IO_REQUIREMENTS_LIST::Initialize(
    IN  PCBYTE       Data,
    IN  ULONG        Size
    )

/*++

Routine Description:

    Initialize an object of type IO_REQUIREMENTS_LIST.

Arguments:

    Data - Pointer to a buffer that contains a IO_RESOURCE_REQUIREMETS_LIST.

    Size - Buffer size.

Return Value:

    BOOLEAN - Returns TRUE if the initialization succeeds.

--*/

{
    PIO_RESOURCE_LIST    ResourceList;
    ULONG                Count;
    ULONG                i;
    PARRAY               TmpList;
    ULONG                BufferSize;
    ULONG                ResourceListSize;

    if( Data == NULL ) {
        return( FALSE );
    }

    Count           = ( ( PIO_RESOURCE_REQUIREMENTS_LIST )Data )->AlternativeLists;
    ResourceList    = ( ( PIO_RESOURCE_REQUIREMENTS_LIST )Data )->List;

    TmpList = ( PARRAY )NEW( ARRAY );
    DebugPtrAssert( TmpList );
    if( ( TmpList == NULL ) ||
        ( !TmpList->Initialize() ) ) {
        DebugPrintTrace(("REGEDT32: Out of memory" ));
        DELETE( TmpList );
        return( FALSE );
    }

    //
    // For each IO_RESOURCE_LIST in the current value...
    //

    BufferSize = Size -                         // Data size
                 sizeof( ULONG ) -              // ListSize
                 sizeof( INTERFACE_TYPE ) -     // InterfaceType
                 sizeof( ULONG ) -              // BusNumber
                 sizeof( ULONG ) -              // SlotNumber
                 3*sizeof( ULONG ) -            // Reserved1, 2 and 3
                 sizeof( ULONG );               // AlternativeLists

    for( i = 0; i < Count; i++ ) {

        PIO_DESCRIPTOR_LIST   IoDescriptorList;

        IoDescriptorList = ( PIO_DESCRIPTOR_LIST )NEW( IO_DESCRIPTOR_LIST );
        if( ( IoDescriptorList == NULL ) ||
            !IoDescriptorList->Initialize( ( PCBYTE )ResourceList,
                                            BufferSize,
                                            &ResourceListSize )
          ) {
            DebugPrint( "REGEDT32: Unable to create or initialize IoDescriptorList \n" );
            DELETE( IoDescriptorList );
            TmpList->DeleteAllMembers();
            DELETE( TmpList );
            return( FALSE );
        }
        TmpList->Put( IoDescriptorList );
#if DBG
        if( BufferSize < ResourceListSize ) {
            DebugPrintTrace(( "REGEDT32: incorrect sizes, BufferSize = %d, ResourceListSize = %d \n",
                       BufferSize, ResourceListSize ));
        }
#endif
        ResourceList = ( PIO_RESOURCE_LIST )( ( ULONG_PTR )ResourceList + ResourceListSize );
        BufferSize -= ResourceListSize;
    }
    _AlternativeLists = TmpList;
    _InterfaceType = ( ( PIO_RESOURCE_REQUIREMENTS_LIST )Data )->InterfaceType;
    _BusNumber     = ( ( PIO_RESOURCE_REQUIREMENTS_LIST )Data )->BusNumber;
    _SlotNumber    = ( ( PIO_RESOURCE_REQUIREMENTS_LIST )Data )->SlotNumber;
    return( TRUE );
}

#if DBG
VOID
IO_REQUIREMENTS_LIST::DbgDumpObject(
    )

/*++

Routine Description:

    Print an IO_REQUIREMENTS_LIST object.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PITERATOR           Iterator;
    PIO_DESCRIPTOR_LIST DescriptorList;

    DebugPrintTrace(( "*** Dumping IO_REQUIREMENTS_LIST \n\n" ));
    DebugPrintTrace(( "InterfaceType = %d \n", _InterfaceType ));
    DebugPrintTrace(( "BusNumber = %#lx \n", _BusNumber ));
    DebugPrintTrace(( "SlotNumber = %#lx \n", _SlotNumber ));
    DebugPrintTrace(( "Reserved1 = %#x \n", _Reserved1 ));
    DebugPrintTrace(( "Reserved2 = %#x \n", _Reserved2 ));
    DebugPrintTrace(( "Reserved3 = %#x \n", _Reserved3 ));
    if( _AlternativeLists != NULL ) {
        Iterator = _AlternativeLists->QueryIterator();
        while( DescriptorList = ( PIO_DESCRIPTOR_LIST ) Iterator->GetNext() ) {
            DescriptorList->DbgDumpObject();
        }
        DELETE( Iterator );
    } else {
        DebugPrintTrace(( "IO_REQUIREMENTS_LIST is empty \n\n" ));
    }

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\regedit\regkey.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGKEY.H
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        05 Mar 1994
*
*  KeyTreeWnd TreeView routines for the Registry Editor.
*
*******************************************************************************/

#ifndef _INC_REGKEY
#define _INC_REGKEY

VOID
PASCAL
RegEdit_OnNewKey(
    HWND hWnd,
    HTREEITEM hTreeItem
    );

BOOL RegEdit_GetTemporaryKeyName(HWND hWnd, PTSTR pszKeyName, HKEY hKey);

LRESULT
PASCAL
RegEdit_OnKeyTreeItemExpanding(
    HWND hWnd,
    LPNM_TREEVIEW lpNMTreeView
    );

VOID
PASCAL
RegEdit_OnKeyTreeSelChanged(
    HWND hWnd,
    LPNM_TREEVIEW lpNMTreeView
    );

VOID
PASCAL
RegEdit_OnSelChangedTimer(
    HWND hWnd
    );

VOID
PASCAL
RegEdit_KeyTreeSelChanged(
    HWND hWnd
    );

VOID
PASCAL
RegEdit_OnKeyTreeBeginDrag(
    HWND hWnd,
    NM_TREEVIEW FAR* lpNMTreeView
    );

BOOL
PASCAL
RegEdit_OnKeyTreeBeginLabelEdit(
    HWND hWnd,
    TV_DISPINFO FAR* lpTVDispInfo
    );

BOOL
PASCAL
RegEdit_OnKeyTreeEndLabelEdit(
    HWND hWnd,
    TV_DISPINFO FAR* lpTVDispInfo
    );

VOID
PASCAL
RegEdit_OnKeyTreeCommand(
    HWND hWnd,
    int MenuCommand,
    HTREEITEM hTreeItem
    );

VOID
PASCAL
RegEdit_OnKeyTreeContextMenu(
    HWND hWnd,
    BOOL fByAccelerator
    );

VOID
PASCAL
RegEdit_SetKeyTreeEditMenuItems(
    HMENU hPopupMenu,
    HTREEITEM hSelectedTreeItem
    );

VOID
PASCAL
RegEdit_OnKeyTreeRefresh(
    HWND hWnd
    );

VOID
PASCAL
RegEdit_OnKeyTreeDisconnect(
    HWND hWnd,
    HTREEITEM hTreeItem
    );

VOID
PASCAL
RegEdit_UpdateStatusBar(
    VOID
    );

VOID
PASCAL
RegEdit_OnCopyKeyName(
    HWND hWnd,
    HTREEITEM hTreeItem
    );

#define BKP_TOSUBKEY                    0x0000
#define BKP_TOSYMBOLICROOT              0x0001
#define BKP_TOCOMPUTER                  (0x0002 | BKP_TOSYMBOLICROOT)

HKEY
PASCAL
KeyTree_BuildKeyPath(
    HWND hTreeViewWnd,
    HTREEITEM hTreeItem,
    LPTSTR lpKeyPath,
    UINT ToFlags
    );

BOOL
PASCAL
KeyTree_ExpandBranch(
    HWND hKeyTreeWnd,
    HTREEITEM hExpandingTreeItem
    );

HKEY  KeyTree_GetRootKey(HTREEITEM hTreeItem);
PTSTR KeyTree_GetKeyName(HTREEITEM hTreeItem, PTSTR pszName, int cchNameMax);

#endif // _INC_REGKEY
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\regedit\regmain.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGMAIN.C
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        05 Mar 1994
*
*******************************************************************************/

#include "pch.h"
#include <regstr.h>
#include "regedit.h"
#include "regfile.h"
#include "regbined.h"
#include "regresid.h"

//  Instance handle of this application.
HINSTANCE g_hInstance;

//  TRUE if accelerator table should not be used, such as during a rename
//  operation.
BOOL g_fDisableAccelerators = FALSE;

TCHAR g_KeyNameBuffer[MAXKEYNAME];
TCHAR g_ValueNameBuffer[MAXVALUENAME_LENGTH];

COLORREF g_clrWindow;
COLORREF g_clrWindowText;
COLORREF g_clrHighlight;
COLORREF g_clrHighlightText;

HWND g_hRegEditWnd;

PTSTR g_pHelpFileName;

TCHAR g_NullString[] = TEXT("");

#define PARSERET_CONTINUE               0
#define PARSERET_REFRESH                1
#define PARSERET_EXIT                   2

UINT
PASCAL
ParseCommandLine(
    VOID
    );

BOOL
PASCAL
IsRegistryToolDisabled(
    VOID
    );

int
PASCAL
ModuleEntry(
    VOID
    )
{

    HWND hPopupWnd;
    HACCEL hRegEditAccel;
    MSG Msg;
    USHORT wLanguageId = LANGIDFROMLCID(GetThreadLocale());
    INITCOMMONCONTROLSEX icce;

    g_hInstance = GetModuleHandle(NULL);

    icce.dwSize = sizeof(icce);
    icce.dwICC = ICC_ALL_CLASSES;
    InitCommonControlsEx(&icce);

    g_hRegEditWnd = FindWindow(g_RegEditClassName, NULL);

    //
    //  To prevent users from corrupting their registries,
    //  administrators can set a policy switch to prevent editing.  Check that
    //  switch now.
    //

    if (IsRegistryToolDisabled()) 
    {
        InternalMessageBox(g_hInstance, NULL, MAKEINTRESOURCE(IDS_REGEDITDISABLED),
            MAKEINTRESOURCE(IDS_REGEDIT), MB_ICONERROR | MB_OK);

        goto ModuleExit;
    }

    //
    //  Check if we were given a commandline and handle if appropriate.
    //

    switch (ParseCommandLine()) {

        case PARSERET_REFRESH:
            if (g_hRegEditWnd != NULL)
                PostMessage(g_hRegEditWnd, WM_COMMAND, ID_REFRESH, 0);
            //  FALL THROUGH

        case PARSERET_EXIT:
            goto ModuleExit;

    }

    //
    //  Allow only one instance of the Registry Editor.
    //

    if (g_hRegEditWnd != NULL) {

        if (IsIconic(g_hRegEditWnd))
            ShowWindow(g_hRegEditWnd, SW_RESTORE);

        else {

            BringWindowToTop(g_hRegEditWnd);

            if ((hPopupWnd = GetLastActivePopup(g_hRegEditWnd)) != g_hRegEditWnd)
                BringWindowToTop(hPopupWnd);

            SetForegroundWindow(hPopupWnd);

        }

        goto ModuleExit;

    }

    //
    //  Initialize and create an instance of the Registry Editor window.
    //

    if ((g_pHelpFileName = LoadDynamicString(IDS_HELPFILENAME)) == NULL)
        goto ModuleExit;

    if (!RegisterRegEditClass() || !RegisterHexEditClass())
        goto ModuleExit;

    if ((hRegEditAccel = LoadAccelerators(g_hInstance,
        MAKEINTRESOURCE(IDACCEL_REGEDIT))) == NULL)
        goto ModuleExit;

    if ((g_hRegEditWnd = CreateRegEditWnd()) != NULL) {

        while (GetMessage(&Msg, NULL, 0, 0)) {

            if (g_fDisableAccelerators || !TranslateAccelerator(g_hRegEditWnd,
                hRegEditAccel, &Msg)) {

                TranslateMessage(&Msg);
                DispatchMessage(&Msg);

            }

        }

    }

ModuleExit:
    ExitProcess(0);

    return 0;

}

/*******************************************************************************
*
*  ParseCommandline
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     (returns), TRUE to continuing loading, else FALSE to stop immediately.
*
*******************************************************************************/

UINT
PASCAL
ParseCommandLine(
    VOID
    )
{

    BOOL fSilentMode;
    BOOL fExportMode;
    LPTSTR lpCmdLine;
    LPTSTR lpFileName;
    LPTSTR lpSelectedPath;

    fSilentMode = FALSE;
    fExportMode = FALSE;

    lpCmdLine = GetCommandLine();

    //
    //  Skip past the application pathname.  Be sure to handle long filenames
    //  correctly.
    //

    if (*lpCmdLine == TEXT('\"')) {

        do
            lpCmdLine = CharNext(lpCmdLine);
        while (*lpCmdLine != 0 && *lpCmdLine != TEXT('\"'));

        if (*lpCmdLine == TEXT('\"'))
            lpCmdLine = CharNext(lpCmdLine);

    }

    else {

        while (*lpCmdLine > TEXT(' '))
            lpCmdLine = CharNext(lpCmdLine);

    }

    while (*lpCmdLine != 0 && *lpCmdLine <= TEXT(' '))
        lpCmdLine = CharNext(lpCmdLine);

    while (TRUE) {

        while (*lpCmdLine == TEXT(' '))
            lpCmdLine = CharNext(lpCmdLine);

        if (*lpCmdLine != TEXT('/') && *lpCmdLine != TEXT('-'))
            break;

        lpCmdLine = CharNext(lpCmdLine);

        while (*lpCmdLine != 0 && *lpCmdLine != TEXT(' ')) {

            switch (*lpCmdLine) {

                case TEXT('m'):
                case TEXT('M'):
                    //
                    //  Allow multiple instances mode.  Pretend we are the only
                    //  copy of regedit running.
                    //
                    g_hRegEditWnd = NULL;
                    break;

                    //
                    //  Specifies the location of the SYSTEM.DAT and USER.DAT
                    //  files in real-mode.  We don't use these switches, but
                    //  we do need to bump past the filename.
                    //
                case TEXT('l'):
                case TEXT('L'):
                case TEXT('r'):
                case TEXT('R'):
                    return PARSERET_EXIT;

                case TEXT('e'):
                case TEXT('E'):
                    fExportMode = TRUE;
                    break;

                case TEXT('a'):
                case TEXT('A'):
                    fExportMode = TRUE;
                    g_RegEditData.uExportFormat = FILE_TYPE_REGEDIT4;
                    break;

                case TEXT('s'):
                case TEXT('S'):
                    //
                    //  Silent mode where we don't show any dialogs when we
                    //  import a registry file script.
                    //
                    fSilentMode = TRUE;
                    break;

                case TEXT('v'):
                case TEXT('V'):
                    //
                    //  With the Windows 3.1 Registry Editor, this brought up
                    //  the tree-style view.  Now we always show the tree so
                    //  nothing to do here!
                    //
                    //  FALL THROUGH

                case TEXT('u'):
                case TEXT('U'):
                    //
                    //  Update, don't overwrite existing path entries in
                    //  shell\open\command or shell\open\print.  This isn't even
                    //  used by the Windows 3.1 Registry Editor!
                    //
                    //  FALL THROUGH

                default:
                    break;

            }

            lpCmdLine = CharNext(lpCmdLine);

        }

    }

    if (!fExportMode) {

        if (*lpCmdLine == 0)
            return PARSERET_CONTINUE;

        else {

            lpFileName = GetNextSubstring(lpCmdLine);

            while (lpFileName != NULL) {

                RegEdit_ImportRegFile(NULL, fSilentMode, lpFileName, NULL);
                lpFileName = GetNextSubstring(NULL);

            }

            return PARSERET_REFRESH;

        }

    }

    else {

        lpFileName = GetNextSubstring(lpCmdLine);
        lpSelectedPath = GetNextSubstring(NULL);

        if (GetNextSubstring(NULL) == NULL)
            RegEdit_ExportRegFile(NULL, fSilentMode, lpFileName, lpSelectedPath);

        return PARSERET_EXIT;

    }

}

/*******************************************************************************
*
*  IsRegistryToolDisabled
*
*  DESCRIPTION:
*     Checks the policy section of the registry to see if registry editing
*     tools should be disabled.  This switch is set by administrators to
*     protect novice users.
*
*     The Registry Editor is disabled if and only if this value exists and is
*     set.
*
*  PARAMETERS:
*     (returns), TRUE if registry tool should not be run, else FALSE.
*
*******************************************************************************/

BOOL
PASCAL
IsRegistryToolDisabled(
    VOID
    )
{

    BOOL fRegistryToolDisabled;
    HKEY hKey;
    DWORD Type;
    DWORD ValueBuffer;
    DWORD cbValueBuffer;

    fRegistryToolDisabled = FALSE;

    if (RegOpenKey(HKEY_CURRENT_USER,
           REGSTR_PATH_POLICIES TEXT("\\") REGSTR_KEY_SYSTEM,
           &hKey) == ERROR_SUCCESS) 
    {

        cbValueBuffer = sizeof(DWORD);

        if (RegEdit_QueryValueEx(hKey, REGSTR_VAL_DISABLEREGTOOLS, NULL, &Type,
            (LPSTR) &ValueBuffer, &cbValueBuffer) == ERROR_SUCCESS) 
        {

            if (Type == REG_DWORD && cbValueBuffer == sizeof(DWORD) &&
                ValueBuffer != FALSE)
                fRegistryToolDisabled = TRUE;

        }

        RegCloseKey(hKey);

    }

    return fRegistryToolDisabled;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\regedit\regmisc.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-2000
*
*  TITLE:       REGMISC.C
*
*  VERSION:     4.0
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        21 Nov 1993
*
*  Miscellaneous routines for the Registry Editor.
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  21 Nov 1993 TCS Original implementation.
*  06 Apr 1994 TCS Moved EditRegistryKey to REGPORTE.C because it needs to
*                  be available for the real-mode registry tool, too.
*
*******************************************************************************/

#include "pch.h"

/*******************************************************************************
*
*  LoadDynamicString
*
*  DESCRIPTION:
*     Wrapper for the FormatMessage function that loads a string from our
*     resource table into a dynamically allocated buffer, optionally filling
*     it with the variable arguments passed.
*
*  PARAMETERS:
*     StringID, resource identifier of the string to use.
*     (optional), parameters to use to format the string message.
*     (returns), pointer to dynamically allocated string buffer.
*
*******************************************************************************/

PTSTR
CDECL
LoadDynamicString(
    UINT StringID,
    ...
    )
{

#if 0

    PTSTR pStr;
    va_list Marker = va_start(Marker, StringID);

    FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ALLOCATE_BUFFER,
        (LPVOID) (DWORD) g_hInstance, StringID, 0, (LPTSTR) (PTSTR FAR *)
        &pStr, 0, &Marker);

#else

    TCHAR Buffer[256];
    PTSTR pStr;
    va_list Marker;

    va_start(Marker, StringID);

    LoadString(g_hInstance, StringID, Buffer, ARRAYSIZE(Buffer));

    if (0 == FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER,
        (LPVOID) (LPSTR) Buffer, 0, 0, (LPTSTR) (PTSTR FAR *) &pStr, 0, &Marker)) {
        pStr = NULL;
    }

    va_end(Marker);

#endif

    return pStr;

}

/*******************************************************************************
*
*  CopyRegistry
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hSourceKey,
*     hDestinationKey,
*
*******************************************************************************/

BOOL
PASCAL
CopyRegistry(
    HKEY hSourceKey,
    HKEY hDestinationKey
    )
{

    BOOL  fSuccess = TRUE;
    DWORD EnumIndex;
    DWORD cchValueName;
    DWORD cbValueData;
    DWORD Type;
    HKEY  hSourceSubKey;
    HKEY  hDestinationSubKey;

    //
    //  Copy all of the value names and their data.
    //

    EnumIndex = 0;

    while (TRUE)
    {
        PBYTE pbValueData;
        cchValueName = ARRAYSIZE(g_ValueNameBuffer);

        // VALUE DATA
        // Query for data size
        if (RegEnumValue(hSourceKey, EnumIndex++, g_ValueNameBuffer,
            &cchValueName, NULL, &Type, NULL, &cbValueData) != ERROR_SUCCESS)
        {
            break;
        }

        // allocate memory for data
        pbValueData =  LocalAlloc(LPTR, cbValueData+ExtraAllocLen(Type));
        if (pbValueData)
        {
            if (RegEdit_QueryValueEx(hSourceKey, g_ValueNameBuffer,
                NULL, &Type, pbValueData, &cbValueData) == ERROR_SUCCESS)
            {
                RegSetValueEx(hDestinationKey, g_ValueNameBuffer, 0, Type,
                    pbValueData, cbValueData);
            }
            else
            {
                fSuccess = FALSE;
            }
            LocalFree(pbValueData);
        }
        else
        {
            fSuccess = FALSE;
        }
    }

    if (fSuccess)
    {
        //
        //  Copy all of the subkeys and recurse into them.
        //

        EnumIndex = 0;

        while (TRUE) {

            if (RegEnumKey(hSourceKey, EnumIndex++, g_KeyNameBuffer, MAXKEYNAME) !=
                ERROR_SUCCESS)
                break;

            if(RegOpenKeyEx(hSourceKey,g_KeyNameBuffer,0,KEY_ENUMERATE_SUB_KEYS|KEY_QUERY_VALUE,&hSourceSubKey) ==
                ERROR_SUCCESS) {

                if (RegCreateKey(hDestinationKey, g_KeyNameBuffer,
                    &hDestinationSubKey) == ERROR_SUCCESS) {

                    CopyRegistry(hSourceSubKey, hDestinationSubKey);

                    RegCloseKey(hDestinationSubKey);

                }

                RegCloseKey(hSourceSubKey);

            }

        }
    }

    return fSuccess;
}

/*******************************************************************************
*
*  CreateDitheredBrush
*
*  DESCRIPTION:
*     Creates a dithered brush which is made up of alternating black and white
*     pixels.
*
*  PARAMETERS:
*     (returns), handle of dithered brush.
*
*******************************************************************************/

HBRUSH
PASCAL
CreateDitheredBrush(
    VOID
    )
{

    WORD graybits[] = {0x5555, 0xAAAA, 0x5555, 0xAAAA, 0x5555, 0xAAAA, 0x5555,
        0xAAAA};
    HBRUSH hBrush;
    HBITMAP hBitmap;

    if ((hBitmap = CreateBitmap(8, 8, 1, 1, graybits)) != NULL) {

        hBrush = CreatePatternBrush(hBitmap);
        DeleteObject(hBitmap);

    }

    else
        hBrush = NULL;

    return hBrush;

}

/*******************************************************************************
*
*  SendChildrenMessage
*
*  DESCRIPTION:
*     Sends the given message to all children of the given parent window.
*
*  PARAMETERS:
*     hWnd, handle of parent window.
*     Message, message to send.
*     wParam, message dependent data.
*     lParam, message dependent data.
*
*******************************************************************************/

VOID
PASCAL
SendChildrenMessage(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    )
{

    HWND hChildWnd;

    hChildWnd = GetWindow(hWnd, GW_CHILD);

    while (hChildWnd != NULL) {

        SendMessage(hChildWnd, Message, wParam, lParam);
        hChildWnd = GetWindow(hChildWnd, GW_HWNDNEXT);

    }

}

/*******************************************************************************
*
*  MessagePump
*
*  DESCRIPTION:
*     Processes the next queued message, if any.
*
*  PARAMETERS:
*     hDialogWnd, handle of modeless dialog.
*
*******************************************************************************/

BOOL
PASCAL
MessagePump(
    HWND hDialogWnd
    )
{

    MSG Msg;
    BOOL fGotMessage;

    if ((fGotMessage = PeekMessage(&Msg, NULL, 0, 0, PM_REMOVE))) {

        if (!IsDialogMessage(hDialogWnd, &Msg)) {

            TranslateMessage(&Msg);
            DispatchMessage(&Msg);

        }

    }

    return fGotMessage;

}

/*******************************************************************************
*
*  GetNextSubstring
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

LPTSTR
PASCAL
GetNextSubstring(
    LPTSTR lpString
    )
{

    static LPTSTR lpLastString;
    TCHAR EndChar;
    LPTSTR lpReturnString;

    if (lpString == NULL)
        lpString = lpLastString;

    while (*lpString == TEXT(' '))
        lpString++;

    if (*lpString == 0)
        lpReturnString = NULL;

    else {

        if (*lpString == TEXT('\"')) {

            EndChar = TEXT('\"');
            lpString++;

        }

        else
            EndChar = TEXT(' ');

        lpReturnString = lpString;

        while (*lpString != EndChar && *lpString != 0)
            lpString = CharNext(lpString);

        if (*lpString == EndChar)
            *lpString++ = 0;

    }

    lpLastString = lpString;

    return lpReturnString;

}

/*******************************************************************************
*
*  InternalMessageBox
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/
int
PASCAL
InternalMessageBox(
    HINSTANCE hInst,
    HWND hWnd,
    LPCTSTR pszFormat,
    LPCTSTR pszTitle,
    UINT fuStyle,
    ...
    )
{
    TCHAR szTitle[80];
    TCHAR szFormat[512];
    LPTSTR pszMessage;
    BOOL fOk;
    int result;
    va_list ArgList;

    if (HIWORD(pszTitle))
    {
        // do nothing
    }
    else
    {
        // Allow this to be a resource ID
        LoadString(hInst, LOWORD(pszTitle), szTitle, ARRAYSIZE(szTitle));
        pszTitle = szTitle;
    }

    if (HIWORD(pszFormat))
    {
        // do nothing
    }
    else
    {
        // Allow this to be a resource ID
        LoadString(hInst, LOWORD(pszFormat), szFormat, ARRAYSIZE(szFormat));
        pszFormat = szFormat;
    }

    va_start(ArgList, fuStyle);
    fOk = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER
                        | FORMAT_MESSAGE_FROM_STRING,
                        pszFormat, 0, 0, (LPTSTR)&pszMessage, 0, &ArgList);

    va_end(ArgList);

    if (fOk && pszMessage)
    {
        result = MessageBox(hWnd, pszMessage, pszTitle, fuStyle | MB_SETFOREGROUND);
        LocalFree(pszMessage);
    }
    else
    {
        return -1;
    }

    return result;
}

#ifdef WINNT
/*******************************************************************************
*
*  RegDeleteKeyRecursive
*
*  DESCRIPTION:
*     Adapted from \\kernel\razzle3,mvdm\wow32\wshell.c,WOWRegDeleteKey().
*     The Windows 95 implementation of RegDeleteKey recursively deletes all
*     the subkeys of the specified registry branch, but the NT implementation
*     only deletes leaf keys.
*
*  PARAMETERS:
*     (see below)
*
*******************************************************************************/

LONG
RegDeleteKeyRecursive(
    IN HKEY hKey,
    IN LPCTSTR lpszSubKey
    )

/*++

Routine Description:

    There is a significant difference between the Win3.1 and Win32
    behavior of RegDeleteKey when the key in question has subkeys.
    The Win32 API does not allow you to delete a key with subkeys,
    while the Win3.1 API deletes a key and all its subkeys.

    This routine is a recursive worker that enumerates the subkeys
    of a given key, applies itself to each one, then deletes itself.

    It specifically does not attempt to deal rationally with the
    case where the caller may not have access to some of the subkeys
    of the key to be deleted.  In this case, all the subkeys which
    the caller can delete will be deleted, but the api will still
    return ERROR_ACCESS_DENIED.

Arguments:

    hKey - Supplies a handle to an open registry key.

    lpszSubKey - Supplies the name of a subkey which is to be deleted
                 along with all of its subkeys.

Return Value:

    ERROR_SUCCESS - entire subtree successfully deleted.

    ERROR_ACCESS_DENIED - given subkey could not be deleted.

--*/

{
    DWORD i;
    HKEY Key;
    LONG Status;
    DWORD ClassLength=0;
    DWORD SubKeys;
    DWORD MaxSubKey;
    DWORD MaxClass;
    DWORD Values;
    DWORD MaxValueName;
    DWORD MaxValueData;
    DWORD SecurityLength;
    FILETIME LastWriteTime;
    LPTSTR NameBuffer;

    //
    // First open the given key so we can enumerate its subkeys
    //
    Status = RegOpenKeyEx(hKey,
                          lpszSubKey,
                          0,
                          KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE,
                          &Key);
    if (Status != ERROR_SUCCESS) {
        //
        // possibly we have delete access, but not enumerate/query.
        // So go ahead and try the delete call, but don't worry about
        // any subkeys.  If we have any, the delete will fail anyway.
        //
    return(RegDeleteKey(hKey,lpszSubKey));
    }

    //
    // Use RegQueryInfoKey to determine how big to allocate the buffer
    // for the subkey names.
    //
    Status = RegQueryInfoKey(Key,
                             NULL,
                             &ClassLength,
                             0,
                             &SubKeys,
                             &MaxSubKey,
                             &MaxClass,
                             &Values,
                             &MaxValueName,
                             &MaxValueData,
                             &SecurityLength,
                             &LastWriteTime);
    if ((Status != ERROR_SUCCESS) &&
        (Status != ERROR_MORE_DATA) &&
        (Status != ERROR_INSUFFICIENT_BUFFER)) {
        RegCloseKey(Key);
        return(Status);
    }

    NameBuffer = (LPTSTR) LocalAlloc(LPTR, (MaxSubKey + 1)*sizeof(TCHAR));
    if (NameBuffer == NULL) {
        RegCloseKey(Key);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Enumerate subkeys and apply ourselves to each one.
    //
    i=0;
    do {
        Status = RegEnumKey(Key,
                            i,
                            NameBuffer,
                            MaxSubKey+1);
        if (Status == ERROR_SUCCESS) {
        Status = RegDeleteKeyRecursive(Key,NameBuffer);
        }

        if (Status != ERROR_SUCCESS) {
            //
            // Failed to delete the key at the specified index.  Increment
            // the index and keep going.  We could probably bail out here,
            // since the api is going to fail, but we might as well keep
            // going and delete everything we can.
            //
            ++i;
        }

    } while ( (Status != ERROR_NO_MORE_ITEMS) &&
              (i < SubKeys) );

    LocalFree((HLOCAL) NameBuffer);
    RegCloseKey(Key);
    return(RegDeleteKey(hKey,lpszSubKey));

}
#endif


//--------------------------------------------------------------------------
//
//  RegEdit_QueryValueEx
//
//  wraps RegQueryValueEx and ensures that the returned string is NULL-
//  terminated
//
//--------------------------------------------------------------------------
LONG RegEdit_QueryValueEx(
  HKEY hKey,            // handle to key
  LPCTSTR lpValueName,  // value name
  LPDWORD lpReserved,   // reserved
  LPDWORD lpType,       // type buffer
  LPBYTE lpData,        // data buffer
  LPDWORD lpcbData      // size of data buffer
)
{
    LONG lRes = RegQueryValueEx(hKey, lpValueName, lpReserved, lpType, lpData, lpcbData);
    if (lRes == ERROR_SUCCESS
        && lpType
        && IsRegStringType(*lpType)
        && lpcbData
        && lpData
        )
    {
        // All string local allocs have an extra space in them
        // for the NULL character

        LPTSTR psz = (LPTSTR)lpData;
        int cch = (int)(*lpcbData/sizeof(TCHAR));
        if (cch > 0)
        {
            // If the string is not NULL terminated, add the additional NULL
            if (psz[cch-1] != 0)
               psz[cch] = 0;
        }
        else if (cch == 0)
        {
            if (*lpcbData == 1)
            {
                // We have allocated one extra TCHAR (2 bytes) for the NULL character
                *((BYTE *)(lpData+1)) = 0;
                *((BYTE *)(lpData+2)) = 0;
                *((BYTE *)(lpData+3)) = 0;
            }
            else
            {
                // No character was copied, but the string was not NULL terminated
                psz[0] = 0;
            }
        }
    }
    return lRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\regedit\regmisc.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGMISC.H
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        05 Mar 1994
*
*  Miscellaneous routines for the Registry Editor.
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  05 Mar 1994 TCS Original implementation.
*
*******************************************************************************/

#ifndef _INC_REGMISC
#define _INC_REGMISC

PTSTR
CDECL
LoadDynamicString(
    UINT StringID,
    ...
    );

//  Wrapper for LocalFree to make the code a little easier to read.
#define DeleteDynamicString(x)          LocalFree((HLOCAL) (x))

BOOL
PASCAL
CopyRegistry(
    HKEY hSourceKey,
    HKEY hDestinationKey
    );

HBRUSH
PASCAL
CreateDitheredBrush(
    VOID
    );

VOID
PASCAL
SendChildrenMessage(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
PASCAL
MessagePump(
    HWND hDialogWnd
    );

LPTSTR
PASCAL
GetNextSubstring(
    LPTSTR lpString
    );

int
PASCAL
InternalMessageBox(
    HINSTANCE hInst,
    HWND hWnd,
    LPCTSTR pszFormat,
    LPCTSTR pszTitle,
    UINT fuStyle,
    ...
    );

//  The Windows 95 and Windows NT implementations of RegDeleteKey differ in how
//  they handle subkeys of the specified key to delete.  Windows 95 will delete
//  them, but NT won't, so we hide the differences using this macro.
#ifdef WINNT
LONG
RegDeleteKeyRecursive(
    IN HKEY hKey,
    IN LPCTSTR lpszSubKey
    );
#else
#define RegDeleteKeyRecursive(hkey, lpsz)   RegDeleteKey(hkey, lpsz)
#endif

#define IsRegStringType(x)  (((x) == REG_SZ) || ((x) == REG_EXPAND_SZ) || ((x) == REG_MULTI_SZ))

#define ExtraAllocLen(Type) (IsRegStringType((Type)) ? sizeof(TCHAR) : 0)

LONG RegEdit_QueryValueEx(
  HKEY hKey,            // handle to key
  LPCTSTR lpValueName,  // value name
  LPDWORD lpReserved,   // reserved
  LPDWORD lpType,       // type buffer
  LPBYTE lpData,        // data buffer
  LPDWORD lpcbData      // size of data buffer
);

#endif // _INC_REGMISC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\regedit\regnet.c ===
/******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGNET.C
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        03 May 1994
*
*  Remote registry support for the Registry Editor.
*
*******************************************************************************/

#include "pch.h"
#include "regedit.h"
#include "regkey.h"
#include "regresid.h"
#include <shlobj.h>
#include "reghelp.h"

extern HRESULT SelectComputer(HWND hWnd, LPTSTR pszRemoteName, int cchMax);

const DWORD s_RegConnectHelpIDs[] = {
    IDC_REMOTENAME, IDH_REGEDIT_CONNECT,
    IDC_BROWSE,     IDH_REGEDIT_CONNECT_BROWSE,
    0, 0
};

const DWORD s_RegDisconnectHelpIDs[] = {
    IDC_REMOTELIST, IDH_REGEDIT_DISCONNECT,
    0, 0
};

INT_PTR
PASCAL
RegConnectDlgProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    );

VOID
PASCAL
RegConnect_OnCommandBrowse(
    HWND hWnd
    );

INT_PTR
PASCAL
RegDisconnectDlgProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR
PASCAL
RegDisconnect_OnInitDialog(
    HWND hWnd
    );

VOID
PASCAL
RegDisconnect_OnCommandOk(
    HWND hWnd
    );

/*******************************************************************************
*
*  RegEdit_OnCommandConnect
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnCommandConnect(HWND hWnd)
{
    
    UINT ErrorStringID;
    TCHAR RemoteName[MAX_PATH];
    LPTSTR lpUnslashedRemoteName;
    TCHAR ComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD cbComputerName;
    TV_ITEM TVItem;
    HTREEITEM hPrevTreeItem;
    TCHAR ConnectedName[MAX_PATH];
    int CompareResult;
    HKEY hLocalMachineKey;
    HWND hKeyTreeWnd;
    TV_INSERTSTRUCT TVInsertStruct;
    UINT Index;
    TCHAR CheckChildrenKeyName[MAXKEYNAME];
    
    //
    //  Query the user for the name of the remote computer to connect to.
    //

    if (SUCCEEDED(SelectComputer(hWnd, (LPTSTR)RemoteName, ARRAYSIZE(RemoteName))))
    {
        RegEdit_SetWaitCursor(TRUE);
        
        //
        //
        //
        
        lpUnslashedRemoteName = (RemoteName[0] == TEXT('\\') &&
            RemoteName[1] == TEXT('\\')) ? &RemoteName[2] : &RemoteName[0];
        
        CharLower(lpUnslashedRemoteName);
        CharUpperBuff(lpUnslashedRemoteName, 1);
        
        //
        //  Check if the user is trying to connect to the local computer and prevent
        //  this.
        //
        
        cbComputerName = sizeof(ComputerName)/sizeof(TCHAR);
        
        if (GetComputerName(ComputerName, &cbComputerName)) {
            
            if (lstrcmpi(lpUnslashedRemoteName, ComputerName) == 0) {
                
                ErrorStringID = IDS_CONNECTNOTLOCAL;
                goto error_ShowDialog;
                
            }
            
        }
        
        //
        //  Check if the user is trying to connect to an already existing registry
        //  connection and prevent this.
        //
        
        hKeyTreeWnd = g_RegEditData.hKeyTreeWnd;
        
        TVItem.mask = TVIF_TEXT | TVIF_PARAM | TVIF_HANDLE;
        TVItem.hItem = TreeView_GetRoot(hKeyTreeWnd);
        TVItem.pszText = ConnectedName;
        TVItem.cchTextMax = sizeof(ConnectedName)/sizeof(TCHAR);
        
        while (TRUE) {
            
            hPrevTreeItem = TVItem.hItem;
            TVItem.hItem = TreeView_GetNextSibling(hKeyTreeWnd, TVItem.hItem);
            
            if (TVItem.hItem == NULL)
                break;
            
            TreeView_GetItem(hKeyTreeWnd, &TVItem);
            
            CompareResult = lstrcmpi(lpUnslashedRemoteName, ConnectedName);
            
            if (CompareResult == 0) {
                
                //
                //  We're already connected to this machine.  Set the focus to the
                //  connection so the user can see where it is.
                //
                
                TreeView_SelectItem(hKeyTreeWnd, TVItem.hItem);
                return;
                
            }
            
            else if (CompareResult < 0)
                break;
            
        }
        
        //
        //  Attempt to connect to the HKEY_LOCAL_MACHINE of the remote computer.
        //  If this fails, assume that the computer doesn't exist or doesn't have
        //  the registry server running.
        //
        
        switch (RegConnectRegistry(RemoteName, HKEY_LOCAL_MACHINE,
            &hLocalMachineKey)) {
            
        case ERROR_SUCCESS:
            break;
            
        case ERROR_ACCESS_DENIED:
            ErrorStringID = IDS_CONNECTACCESSDENIED;
            goto error_ShowDialog;
            
        default:
            ErrorStringID = IDS_CONNECTBADNAME;
            goto error_ShowDialog;
            
        }
        
        //
        //  The connection to HKEY_LOCAL_MACHINE was successful, so add a tree item
        //  for the remote computer and all of its predefined roots.
        //
        
        hKeyTreeWnd = g_RegEditData.hKeyTreeWnd;
        ErrorStringID = 0;
        
        TVInsertStruct.hParent = TVI_ROOT;
        TVInsertStruct.hInsertAfter = hPrevTreeItem;
        TVInsertStruct.item.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE |
            TVIF_PARAM | TVIF_CHILDREN;
        TVInsertStruct.item.iImage = IMAGEINDEX(IDI_REMOTE);
        TVInsertStruct.item.iSelectedImage = IMAGEINDEX(IDI_REMOTE);
        TVInsertStruct.item.cChildren = TRUE;
        TVInsertStruct.item.lParam = 0;
        
        TVInsertStruct.item.pszText = lpUnslashedRemoteName;
        TVInsertStruct.hParent = TreeView_InsertItem(hKeyTreeWnd, &TVInsertStruct);
        
        TVInsertStruct.item.iImage = IMAGEINDEX(IDI_FOLDER);
        TVInsertStruct.item.iSelectedImage = IMAGEINDEX(IDI_FOLDEROPEN);
        
        for (Index = 0; Index < NUMBER_REGISTRY_ROOTS; Index++) {
            
            TVInsertStruct.item.pszText = g_RegistryRoots[Index].lpKeyName;
            
            //There is no way to determine the current user remotely
            //We would end up mapping the default user to current user
            //so let's just not show this key remotely
            if ((Index == INDEX_HKEY_CURRENT_USER) || (Index == INDEX_HKEY_CLASSES_ROOT))
                continue;
            
            if (Index == INDEX_HKEY_LOCAL_MACHINE)
                TVInsertStruct.item.lParam = (LPARAM) hLocalMachineKey;
            
            else {
                
#ifdef WINNT
                if((Index == INDEX_HKEY_DYN_DATA) || (Index == INDEX_HKEY_CURRENT_CONFIG)) {
                    continue;
                }
#endif
                
                if (RegConnectRegistry(RemoteName, g_RegistryRoots[Index].hKey,
                    (PHKEY) &TVInsertStruct.item.lParam) != ERROR_SUCCESS) {
                    
                    ErrorStringID = IDS_CONNECTROOTFAILED;
                    continue;
                    
                }
                
            }
            
            TVInsertStruct.item.cChildren =
                (RegEnumKey((HKEY) TVInsertStruct.item.lParam, 0,
                CheckChildrenKeyName, sizeof(CheckChildrenKeyName)/sizeof(TCHAR)) ==
                ERROR_SUCCESS);
            
            TreeView_InsertItem(hKeyTreeWnd, &TVInsertStruct);
            
        }
        
        TreeView_Expand(hKeyTreeWnd, TVInsertStruct.hParent, TVE_EXPAND);
        TreeView_EnsureVisible(hKeyTreeWnd, TVInsertStruct.hParent);
        
        RegEdit_SetWaitCursor(FALSE);
        
        TreeView_SelectItem(hKeyTreeWnd, TVInsertStruct.hParent);
        SetFocus(hKeyTreeWnd);
        
        if (ErrorStringID != 0) {
            
error_ShowDialog:
        InternalMessageBox(g_hInstance, hWnd, MAKEINTRESOURCE(ErrorStringID),
            MAKEINTRESOURCE(IDS_CONNECTERRORTITLE), MB_ICONERROR | MB_OK,
            RemoteName);
        
        }
    }
}

/*******************************************************************************
*
*  RegConnectDlgProc
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

INT_PTR
PASCAL
RegConnectDlgProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    )
{

    LPTSTR lpRemoteName;

    switch (Message) {

        case WM_INITDIALOG:
            SetWindowLongPtr(hWnd, DWLP_USER, (LONG) lParam);
            SendDlgItemMessage(hWnd, IDC_REMOTENAME, EM_SETLIMITTEXT,
                MAX_PATH, 0);
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {

                case IDC_REMOTENAME:
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE)
                        EnableWindow(GetDlgItem(hWnd, IDOK),
                            SendMessage(GET_WM_COMMAND_HWND(wParam, lParam),
                            WM_GETTEXTLENGTH, 0, 0) != 0);
                    break;

                case IDC_BROWSE:
                    RegConnect_OnCommandBrowse(hWnd);
                    break;

                case IDOK:
                    lpRemoteName = (LPTSTR) GetWindowLongPtr(hWnd, DWLP_USER);
                    GetDlgItemText(hWnd, IDC_REMOTENAME, lpRemoteName,
                        MAX_PATH);
                    //  FALL THROUGH

                case IDCANCEL:
                    EndDialog(hWnd, GET_WM_COMMAND_ID(wParam, lParam));
                    break;

            }
            break;

        case WM_HELP:
            WinHelp(((LPHELPINFO) lParam)-> hItemHandle, g_pHelpFileName,
                HELP_WM_HELP, (ULONG_PTR) s_RegConnectHelpIDs);
            break;

        case WM_CONTEXTMENU:
            WinHelp((HWND) wParam, g_pHelpFileName, HELP_CONTEXTMENU,
                (ULONG_PTR) s_RegConnectHelpIDs);
            break;

        default:
            return FALSE;

    }

    return TRUE;

}

/*******************************************************************************
*
*  RegConnect_OnCommandBrowse
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
PASCAL
RegConnect_OnCommandBrowse(
    HWND hWnd
    )
{

    BROWSEINFO BrowseInfo;
    LPITEMIDLIST pidlComputer;
    TCHAR RemoteName[MAX_PATH];

    BrowseInfo.hwndOwner = hWnd;
    BrowseInfo.pidlRoot = (LPITEMIDLIST) MAKEINTRESOURCE(CSIDL_NETWORK);
    BrowseInfo.pszDisplayName = RemoteName;
    BrowseInfo.lpszTitle = LoadDynamicString(IDS_COMPUTERBROWSETITLE);
    BrowseInfo.ulFlags = BIF_BROWSEFORCOMPUTER;
    BrowseInfo.lpfn = NULL;

    if ((pidlComputer = SHBrowseForFolder(&BrowseInfo)) != NULL) {

        SHFree(pidlComputer);

        SetDlgItemText(hWnd, IDC_REMOTENAME, RemoteName);
        EnableWindow(GetDlgItem(hWnd, IDOK), TRUE);

    }

    DeleteDynamicString(BrowseInfo.lpszTitle);

}

/*******************************************************************************
*
*  RegEdit_OnCommandDisconnect
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnCommandDisconnect(
    HWND hWnd
    )
{

    DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_REGDISCONNECT), hWnd,
        RegDisconnectDlgProc);

}

/*******************************************************************************
*
*  RegDisconnectDlgProc
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

INT_PTR
PASCAL
RegDisconnectDlgProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    )
{

    switch (Message) {

        case WM_INITDIALOG:
            return RegDisconnect_OnInitDialog(hWnd);

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {

                case IDOK:
                    RegDisconnect_OnCommandOk(hWnd);
                    //  FALL THROUGH

                case IDCANCEL:
                    EndDialog(hWnd, 0);
                    break;

            }
            break;

        case WM_HELP:
            WinHelp(((LPHELPINFO) lParam)-> hItemHandle, g_pHelpFileName,
                HELP_WM_HELP, (ULONG_PTR) s_RegDisconnectHelpIDs);
            break;

        case WM_CONTEXTMENU:
            WinHelp((HWND) wParam, g_pHelpFileName, HELP_CONTEXTMENU,
                (ULONG_PTR) s_RegDisconnectHelpIDs);
            break;

        default:
            return FALSE;

    }

    return TRUE;

}

/*******************************************************************************
*
*  RegDisconnect_OnInitDialog
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd,
*     hFocusWnd,
*     lParam,
*
*******************************************************************************/

INT_PTR
PASCAL
RegDisconnect_OnInitDialog(
    HWND hWnd
    )
{

    HWND hRemoteListWnd;
    RECT ClientRect;
    LV_COLUMN LVColumn;
    LV_ITEM LVItem;
    TCHAR RemoteName[MAX_PATH];
    HWND hKeyTreeWnd;
    TV_ITEM TVItem;

    hRemoteListWnd = GetDlgItem(hWnd, IDC_REMOTELIST);

    //
    //  Initialize the ListView control.
    //

    ListView_SetImageList(hRemoteListWnd, g_RegEditData.hImageList,
        LVSIL_SMALL);

    LVColumn.mask = LVCF_FMT | LVCF_WIDTH;
    LVColumn.fmt = LVCFMT_LEFT;

    GetClientRect(hRemoteListWnd, &ClientRect);
    LVColumn.cx = ClientRect.right - GetSystemMetrics(SM_CXVSCROLL) -
        2 * GetSystemMetrics(SM_CXEDGE);

    ListView_InsertColumn(hRemoteListWnd, 0, &LVColumn);

    //
    //  Walk through each remote connection listed in the KeyTree and add it
    //  to our RemoteList.
    //

    LVItem.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
    LVItem.pszText = RemoteName;
    LVItem.iItem = 0;
    LVItem.iSubItem = 0;
    LVItem.iImage = IMAGEINDEX(IDI_REMOTE);

    hKeyTreeWnd = g_RegEditData.hKeyTreeWnd;

    TVItem.mask = TVIF_TEXT;
    TVItem.hItem = TreeView_GetNextSibling(hKeyTreeWnd,
        TreeView_GetRoot(hKeyTreeWnd));
    TVItem.pszText = RemoteName;
    TVItem.cchTextMax = sizeof(RemoteName)/sizeof(TCHAR);

    do {

        LVItem.lParam = (LPARAM) TVItem.hItem;
        TreeView_GetItem(hKeyTreeWnd, &TVItem);
        ListView_InsertItem(hRemoteListWnd, &LVItem);

        LVItem.iItem++;

    }   while ((TVItem.hItem = TreeView_GetNextSibling(hKeyTreeWnd,
        TVItem.hItem)) != NULL);

    ListView_SetItemState(hRemoteListWnd, 0, LVIS_FOCUSED, LVIS_FOCUSED);

    return TRUE;

}

/*******************************************************************************
*
*  RegDisconnect_OnCommandOk
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd,
*     hFocusWnd,
*     lParam,
*
*******************************************************************************/

VOID
PASCAL
RegDisconnect_OnCommandOk(
    HWND hWnd
    )
{

    LV_ITEM LVItem;
    HWND hRemoteListWnd;

    //
    //  Walk through each selected item in the ListView and disconnect the
    //  computer.
    //

    LVItem.mask = LVIF_PARAM;
    LVItem.iItem = -1;
    LVItem.iSubItem = 0;

    hRemoteListWnd = GetDlgItem(hWnd, IDC_REMOTELIST);

    while ((LVItem.iItem = ListView_GetNextItem(hRemoteListWnd, LVItem.iItem,
        LVNI_SELECTED)) != -1) {

        ListView_GetItem(hRemoteListWnd, &LVItem);
        RegEdit_OnKeyTreeDisconnect(hWnd, (HTREEITEM) LVItem.lParam);

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\regedit\regkey.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGKEY.C
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        05 Mar 1994
*
*  KeyTreeWnd TreeView routines for the Registry Editor.
*
*******************************************************************************/

#include "pch.h"
#include "regedit.h"
#include "regkey.h"
#include "regvalue.h"
#include "regresid.h"

#define MAX_KEYNAME_TEMPLATE_ID         100

#define SELCHANGE_TIMER_ID              1

#define REFRESH_DPA_GROW                16

VOID
PASCAL
RegEdit_OnKeyTreeDelete(
    HWND hWnd,
    HTREEITEM hTreeItem
    );

VOID
PASCAL
RegEdit_OnKeyTreeRename(
    HWND hWnd,
    HTREEITEM hTreeItem
    );

int
WINAPI
DPACompareKeyNames(
    LPVOID lpString1,
    LPVOID lpString2,
    LPARAM lParam
    );

HTREEITEM
PASCAL
KeyTree_InsertItem(
    HWND hKeyTreeWnd,
    HTREEITEM hParent,
    HTREEITEM hInsertAfter,
    LPCTSTR lpText,
    UINT fHasKids,
    LPARAM lParam
    );

BOOL
PASCAL
DoesKeyHaveKids(
    HKEY hKey,
    LPTSTR lpKeyName
    );

VOID
PASCAL
KeyTree_EditLabel(
    HWND hKeyTreeWnd,
    HTREEITEM hTreeItem
    );

BOOL
PASCAL
KeyTree_CanDeleteOrRenameItem(
    HWND hWnd,
    HTREEITEM hTreeItem
    );

/*******************************************************************************
*
*  RegEdit_OnNewKey
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnNewKey(
                 HWND hWnd,
                 HTREEITEM hTreeItem
                 )
{
    TCHAR KeyName[MAXKEYNAME*2];
    UINT cchKeyName = 0;
    HKEY hRootKey;
    HKEY hKey;
    UINT ErrorStringID;
    BOOL fNewKeyIsOnlyChild;
    UINT NewKeyNameID;
    HKEY hNewKey;
    HTREEITEM hNewTreeItem;
    TV_ITEM TVItem;
    
    hRootKey = KeyTree_BuildKeyPath(g_RegEditData.hKeyTreeWnd, hTreeItem,
        KeyName, BKP_TOSUBKEY);
    cchKeyName = lstrlen(KeyName);

    if(RegOpenKeyEx(hRootKey,KeyName,0,KEY_CREATE_SUB_KEY,&hKey) != ERROR_SUCCESS) {
        
        //
        //  Get the text of the selected tree item so that we can display
        //  a more meaningful error message.
        //
        
        TVItem.mask = TVIF_TEXT;
        TVItem.hItem = hTreeItem;
        TVItem.pszText = (LPTSTR) KeyName;
        TVItem.cchTextMax = sizeof(KeyName)/sizeof(TCHAR);
        
        TreeView_GetItem(g_RegEditData.hKeyTreeWnd, &TVItem);
        
        ErrorStringID = IDS_NEWKEYPARENTOPENFAILED;
        goto error_ShowDialog;
        
    }
    
    TVItem.mask = TVIF_STATE | TVIF_CHILDREN;
    TVItem.hItem = hTreeItem;
    TreeView_GetItem(g_RegEditData.hKeyTreeWnd, &TVItem);
    
    fNewKeyIsOnlyChild = FALSE;
    
    if (TVItem.cChildren == FALSE) {
        
        //
        //  The selected key doesn't have any subkeys, so we can't do an expand
        //  on it just yet.  We'll just set a flag and later tag it with a
        //  plus/minus icon and expand it.
        //
        
        fNewKeyIsOnlyChild = TRUE;
        
    }
    
    else if (!(TVItem.state & TVIS_EXPANDED)) {
        
        //
        //  The selected key isn't expanded.  Do it now so that we can do an
        //  in-place edit and don't reenumerate the "New Key #xxx" after we do
        //  the RegCreateKey.
        //
        
        TreeView_Expand(g_RegEditData.hKeyTreeWnd, hTreeItem, TVE_EXPAND);
        
    }
    
    if (RegEdit_GetTemporaryKeyName(hWnd, KeyName, hKey))
    {
        if((cchKeyName + lstrlen(KeyName) + 1) < MAXKEYNAME)
        {
            if (RegCreateKey(hKey, KeyName, &hNewKey) != ERROR_SUCCESS)
            {
                ErrorStringID = IDS_NEWKEYCANNOTCREATE;
                goto error_CloseKey;
                
            }
            
            RegCloseKey(hNewKey);
            
            if (fNewKeyIsOnlyChild) 
            {
                TVItem.mask = TVIF_CHILDREN;
                TVItem.cChildren = TRUE;
                TreeView_SetItem(g_RegEditData.hKeyTreeWnd, &TVItem);
                
                TreeView_Expand(g_RegEditData.hKeyTreeWnd, hTreeItem, TVE_EXPAND);
                
                //  WARNING:  It is possible for our new item _not_ to be the only child
                //  if our view is out of date!
                hNewTreeItem = TreeView_GetChild(g_RegEditData.hKeyTreeWnd, hTreeItem);
                
            }
            
            else 
            {
                hNewTreeItem = KeyTree_InsertItem(g_RegEditData.hKeyTreeWnd, hTreeItem,
                    TVI_LAST, KeyName, FALSE, 0);
                
            }
            
            TreeView_SelectItem(g_RegEditData.hKeyTreeWnd, hNewTreeItem);
            KeyTree_EditLabel(g_RegEditData.hKeyTreeWnd, hNewTreeItem);
        }
        else
        {
            ErrorStringID = IDS_RENAMEKEYTOOLONG;
            goto error_CloseKey;
        }
    }
    else
    {
        ErrorStringID = IDS_NEWKEYNOUNIQUE;
        goto error_CloseKey;
    }

    RegCloseKey(hKey);
    return;
    
error_CloseKey:
    RegCloseKey(hKey);
    
    //  FEATURE:  For any errors that may crop up, we may need to turn off the
    //  child flag.
    
error_ShowDialog:
    InternalMessageBox(g_hInstance, hWnd, MAKEINTRESOURCE(ErrorStringID),
        MAKEINTRESOURCE(IDS_NEWKEYERRORTITLE), MB_ICONERROR | MB_OK,
        (LPTSTR) KeyName);
    
}


//------------------------------------------------------------------------------
//  RegEdit_GetTemporaryKeyName
//  
//  DESCRIPTION: Loop through the registry trying to find a valid temporary name 
//               until the user renames the key.
//
//  PARAMETERS:  HWND hWnd - handle to window
//               PTSTR pszKeyName
//
//  RETURN:      True, if unique name is found
//------------------------------------------------------------------------------
BOOL RegEdit_GetTemporaryKeyName(HWND hWnd, PTSTR pszKeyName, HKEY hKey)
{
    HKEY hNewKey;
    UINT uNewKeyNameID = 1;

    while (uNewKeyNameID < MAX_KEYNAME_TEMPLATE_ID) 
    {
        wsprintf(pszKeyName, g_RegEditData.pNewKeyTemplate, uNewKeyNameID);

        if(RegOpenKeyEx(hKey, pszKeyName, 0, 0, &hNewKey) == ERROR_FILE_NOT_FOUND) 
        {
            break;
        }
        RegCloseKey(hNewKey);

        uNewKeyNameID++;
    }

    if (uNewKeyNameID == MAX_KEYNAME_TEMPLATE_ID) 
    {
        InternalMessageBox(g_hInstance, hWnd, MAKEINTRESOURCE(IDS_NEWKEYNOUNIQUE),
        MAKEINTRESOURCE(IDS_NEWKEYERRORTITLE), MB_ICONERROR | MB_OK, pszKeyName);
    }

    return (uNewKeyNameID != MAX_KEYNAME_TEMPLATE_ID);
}


/*******************************************************************************
*
*  RegEdit_OnKeyTreeItemExpanding
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*     lpNMTreeView, TreeView notification data.
*
*******************************************************************************/

LRESULT
PASCAL
RegEdit_OnKeyTreeItemExpanding(
    HWND hWnd,
    LPNM_TREEVIEW lpNMTreeView
    )
{

    HWND hKeyTreeWnd;
    HTREEITEM hExpandingTreeItem;
    TCHAR KeyName[MAXKEYNAME];
    TV_ITEM TVItem;

    hKeyTreeWnd = g_RegEditData.hKeyTreeWnd;
    hExpandingTreeItem = lpNMTreeView-> itemNew.hItem;

    //
    //  Check if we're to expand the given tree item for the first time.  If so,
    //  delve into the registry to get all of the key's subkeys.
    //

    if (lpNMTreeView-> action & TVE_EXPAND && !(lpNMTreeView-> itemNew.state &
        TVIS_EXPANDEDONCE)) {

        if (TreeView_GetChild(hKeyTreeWnd, hExpandingTreeItem) != NULL)
            return FALSE;

        RegEdit_SetWaitCursor(TRUE);

        if (!KeyTree_ExpandBranch(hKeyTreeWnd, hExpandingTreeItem)) {

            //
            //  Get the text of the selected tree item so that we can display
            //  a more meaningful error message.
            //

            TVItem.mask = TVIF_TEXT;
            TVItem.hItem = hExpandingTreeItem;
            TVItem.pszText = (LPTSTR) KeyName;
            TVItem.cchTextMax = sizeof(KeyName)/sizeof(TCHAR);

            TreeView_GetItem(hKeyTreeWnd, &TVItem);

            InternalMessageBox(g_hInstance, hWnd,
                MAKEINTRESOURCE(IDS_OPENKEYCANNOTOPEN),
                MAKEINTRESOURCE(IDS_OPENKEYERRORTITLE), MB_ICONERROR | MB_OK,
                (LPTSTR) KeyName);

        }

	RegEdit_SetWaitCursor(FALSE);

    }

    return FALSE;

}

/*******************************************************************************
*
*  RegEdit_OnKeyTreeSelChanged
*
*  DESCRIPTION:
*     Depending on how the user has selected the new item in the KeyTreeWnd,
*     we call to the real worker routine, RegEdit_KeyTreeSelChanged, or delay
*     the call for several milliseconds.
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*     lpNMTreeView, TreeView notification data.
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnKeyTreeSelChanged(
    HWND hWnd,
    LPNM_TREEVIEW lpNMTreeView
    )
{

    UINT TimerDelay;

    //
    //  We delay the actual update of the selection and thus of the
    //  ValueListWnd for several milliseconds.  This avoids unnecessary flashing
    //  as the user scrolls through the tree.  (This behavior is directly taken
    //	from the Explorer.)
    //

    switch (g_RegEditData.SelChangeTimerState) {

        case SCTS_TIMERSET:
            KillTimer(hWnd, SELCHANGE_TIMER_ID);
            //  FALL THROUGH

        case SCTS_TIMERCLEAR:
#ifdef WINNT
        //
        // This behavior is extremely annoying so I am changing it.
        //
	    TimerDelay = 1;
#else
	    TimerDelay = (lpNMTreeView != NULL && lpNMTreeView-> action ==
		TVC_BYMOUSE) ? (1) : (GetDoubleClickTime() * 3 / 2);
#endif
	    SetTimer(hWnd, SELCHANGE_TIMER_ID, TimerDelay, NULL);
            g_RegEditData.SelChangeTimerState = SCTS_TIMERSET;
            break;

        //
        //  We want to punt the first selection change notification that comes
        //  through.
        //

        case SCTS_INITIALIZING:
            RegEdit_KeyTreeSelChanged(hWnd);
            break;

    }

}

/*******************************************************************************
*
*  RegEdit_OnSelChangedTimer
*
*  DESCRIPTION:
*     Called several milliseconds after a keyboard operation has selected a new
*     item in the KeyTreeWnd.  Act as if a new selection has just been made in
*     the KeyTreeWnd.
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnSelChangedTimer(
    HWND hWnd
    )
{

    KillTimer(hWnd, SELCHANGE_TIMER_ID);
    g_RegEditData.SelChangeTimerState = SCTS_TIMERCLEAR;

    RegEdit_KeyTreeSelChanged(hWnd);

}

/*******************************************************************************
*
*  RegEdit_KeyTreeSelChanged
*
*  DESCRIPTION:
*     Called after a new item has been selected in the KeyTreeWnd.  Opens a
*     registry key to the new branch and notifies the ValueListWnd to update
*     itself.
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*
*******************************************************************************/

VOID
PASCAL
RegEdit_KeyTreeSelChanged(
    HWND hWnd
    )
{

    HWND hKeyTreeWnd;
    HTREEITEM hSelectedTreeItem;
    RECT ItemRect;
    RECT ClientRect;
    RECT FromRect;
    RECT ToRect;
    HKEY hRootKey;
    TCHAR KeyName[MAXKEYNAME];
    TV_ITEM TVItem;

    hKeyTreeWnd = g_RegEditData.hKeyTreeWnd;
    hSelectedTreeItem = TreeView_GetSelection(hKeyTreeWnd);

    if (g_RegEditData.SelChangeTimerState != SCTS_INITIALIZING) {

        //
        //  Draw an animation that shows the "expansion" of the newly selected
        //  tree item to the ListView.
        //

        TreeView_GetItemRect(hKeyTreeWnd, hSelectedTreeItem, &ItemRect, TRUE);
        GetClientRect(hKeyTreeWnd, &ClientRect);
        IntersectRect(&FromRect, &ClientRect, &ItemRect);
        MapWindowPoints(hKeyTreeWnd, hWnd, (LPPOINT) &FromRect, 2);

        GetWindowRect(g_RegEditData.hValueListWnd, &ToRect);
        MapWindowPoints(NULL, hWnd, (LPPOINT) &ToRect, 2);

        DrawAnimatedRects(hWnd, IDANI_OPEN, &FromRect, &ToRect);

    }

    //
    //  Close the previously selected item's key handle, if appropriate.
    //

    if (g_RegEditData.hCurrentSelectionKey != NULL) {

        RegCloseKey(g_RegEditData.hCurrentSelectionKey);
        g_RegEditData.hCurrentSelectionKey = NULL;

    }

    RegEdit_UpdateStatusBar();

    //
    //  Simple case-- we're changing to one of the top-level labels, such as
    //  "My Computer" or a network computer name.  Right now, nothing is
    //  displayed in the ListView, so just empty it and return.
    //

    if (TreeView_GetParent(hKeyTreeWnd, hSelectedTreeItem) != NULL) {

        //
        //  Build a registry path to the selected tree item and open a registry
        //  key.
        //

        hRootKey = KeyTree_BuildKeyPath(hKeyTreeWnd, hSelectedTreeItem,
            KeyName, BKP_TOSUBKEY);

        if(RegOpenKeyEx(hRootKey,KeyName, 0, MAXIMUM_ALLOWED,
            &g_RegEditData.hCurrentSelectionKey) != ERROR_SUCCESS) {

            //
            //  Get the text of the selected tree item so that we can display
            //  a more meaningful error message.
            //

            TVItem.mask = TVIF_TEXT;
            TVItem.hItem = hSelectedTreeItem;
            TVItem.pszText = (LPTSTR) KeyName;
            TVItem.cchTextMax = sizeof(KeyName)/sizeof(TCHAR);

            TreeView_GetItem(hKeyTreeWnd, &TVItem);

            InternalMessageBox(g_hInstance, hWnd,
                MAKEINTRESOURCE(IDS_OPENKEYCANNOTOPEN),
                MAKEINTRESOURCE(IDS_OPENKEYERRORTITLE), MB_ICONERROR | MB_OK,
                (LPTSTR) KeyName);

        }

    }

    RegEdit_OnValueListRefresh(hWnd);

}

/*******************************************************************************
*
*  RegEdit_OnKeyTreeBeginLabelEdit
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*     lpTVDispInfo,
*
*******************************************************************************/

BOOL
PASCAL
RegEdit_OnKeyTreeBeginLabelEdit(
    HWND hWnd,
    TV_DISPINFO FAR* lpTVDispInfo
    )
{

    //
    //  B#7933:  We don't want the user to hurt themselves by making it too easy
    //  to rename keys and values.  Only allow renames via the menus.
    //

    //
    //  We don't get any information on the source of this editing action, so
    //  we must maintain a flag that tells us whether or not this is "good".
    //

    if (!g_RegEditData.fAllowLabelEdits)
        return TRUE;

    //
    //  All other labels are fair game.  We need to disable our keyboard
    //  accelerators so that the edit control can "see" them.
    //

    g_fDisableAccelerators = TRUE;

    return FALSE;

}

/*******************************************************************************
*
*  RegEdit_OnKeyTreeEndLabelEdit
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*     lpTVDispInfo,
*
*******************************************************************************/

BOOL
PASCAL
RegEdit_OnKeyTreeEndLabelEdit(
    HWND hWnd,
    TV_DISPINFO FAR* lpTVDispInfo
    )
{

    HWND hKeyTreeWnd;
    HKEY hRootKey;
    TCHAR SourceKeyName[MAXKEYNAME*2];
    TCHAR DestinationKeyName[MAXKEYNAME];
    HKEY hSourceKey;
    HKEY hDestinationKey;
    LPTSTR lpEndOfParentKey;
    UINT ErrorStringID;
    TV_ITEM TVItem;

    //
    //  We can reenable our keyboard accelerators now that the edit control no
    //  longer needs to "see" them.
    //

    g_fDisableAccelerators = FALSE;

    hKeyTreeWnd = g_RegEditData.hKeyTreeWnd;

    //
    //  Check to see if the user cancelled the edit.  If so, we don't care so
    //  just return.
    //

    if (lpTVDispInfo-> item.pszText == NULL)
        return FALSE;

    //
    //  Attempt to open the key to be renamed.  This may or may not be the same
    //  key that is already open.
    //

    hRootKey = KeyTree_BuildKeyPath(hKeyTreeWnd, lpTVDispInfo-> item.hItem,
        SourceKeyName, BKP_TOSUBKEY);
    if (lstrlen(SourceKeyName) >= MAXKEYNAME) {
        ErrorStringID = IDS_RENAMEKEYTOOLONG;
        goto error_ShowDialog;

    }

    if(RegOpenKeyEx(hRootKey,SourceKeyName,0,KEY_ENUMERATE_SUB_KEYS|KEY_QUERY_VALUE,&hSourceKey) != ERROR_SUCCESS) {

        ErrorStringID = IDS_RENAMEKEYOTHERERROR;
        goto error_ShowDialog;

    }

    //
    //  Take the full path name of the key (relative to a predefined root key)
    //  and replace the old key name with the new.  Make sure that this key
    //  doesn't exceed our internal buffers.
    //

    lstrcpy(DestinationKeyName, SourceKeyName);

    if ((lpEndOfParentKey = StrRChr(DestinationKeyName, NULL, TEXT('\\'))) != NULL)
        lpEndOfParentKey++;

    else
        lpEndOfParentKey = DestinationKeyName;

    *lpEndOfParentKey = 0;

    if (lstrlen(DestinationKeyName) + lstrlen(lpTVDispInfo-> item.pszText) >= MAXKEYNAME) {
        ErrorStringID = IDS_RENAMEKEYTOOLONG;
        goto error_CloseSourceKey;
    }

    lstrcpy(lpEndOfParentKey, lpTVDispInfo-> item.pszText);

    //
    //  Make sure there are no backslashes in the name.
    //

    if (StrChr(lpEndOfParentKey, TEXT('\\')) != NULL) {

        ErrorStringID = IDS_RENAMEKEYBADCHARS;
        goto error_CloseSourceKey;

    }

    //
    //  Make sure there the name isn't empty
    //

    if (DestinationKeyName[0] == 0) {
        ErrorStringID = IDS_RENAMEKEYEMPTY;
        goto error_CloseSourceKey;
    }

    //
    //  Make sure that the destination doesn't already exist.
    //
    if(RegOpenKeyEx(hRootKey,DestinationKeyName,0,KEY_QUERY_VALUE,&hDestinationKey) ==
        ERROR_SUCCESS) {

        RegCloseKey(hDestinationKey);

        ErrorStringID = IDS_RENAMEKEYEXISTS;
        goto error_CloseSourceKey;

    }

    //
    //  Create the destination key and do the copy.
    //

    if (RegCreateKey(hRootKey, DestinationKeyName, &hDestinationKey) !=
        ERROR_SUCCESS) {

        ErrorStringID = IDS_RENAMEKEYOTHERERROR;
        goto error_CloseSourceKey;

    }

    //  FEATURE:  Check this return (when it gets one!)
    if (!CopyRegistry(hSourceKey, hDestinationKey))
    {
        RegCloseKey(hDestinationKey);
        RegCloseKey(hSourceKey);

        ErrorStringID = IDS_RENAMEKEYOTHERERROR;
        goto error_ShowDialog;
    }

    RegCloseKey(hSourceKey);

    //
    //  Check to see if we're renaming the currently selected key.  If so, toss
    //  our cached key handle and change to our source key.
    //

    if (TreeView_GetSelection(hKeyTreeWnd) == lpTVDispInfo-> item.hItem) {

        RegCloseKey(g_RegEditData.hCurrentSelectionKey);

        g_RegEditData.hCurrentSelectionKey = hDestinationKey;

        //
        //  We can't just call RegEdit_UpdateStatusBar here... the tree item
        //  won't be updated until we return TRUE from this message.  So we must
        //  post a message to tell ourselves to do the update later on.
        //

        PostMessage(hWnd, REM_UPDATESTATUSBAR, 0, 0);

    }

    else
        RegCloseKey(hDestinationKey);

    if (RegDeleteKeyRecursive(hRootKey, SourceKeyName) != ERROR_SUCCESS) {

        ErrorStringID = IDS_RENAMEKEYOTHERERROR;
        goto error_ShowDialog;

    }

    return TRUE;

error_CloseSourceKey:
    RegCloseKey(hSourceKey);

error_ShowDialog:
    TVItem.hItem = lpTVDispInfo-> item.hItem;
    TVItem.mask = TVIF_TEXT;
    TVItem.pszText = SourceKeyName;
    TVItem.cchTextMax = sizeof(SourceKeyName)/sizeof(TCHAR);

    TreeView_GetItem(hKeyTreeWnd, &TVItem);

    InternalMessageBox(g_hInstance, hWnd, MAKEINTRESOURCE(ErrorStringID),
        MAKEINTRESOURCE(IDS_RENAMEKEYERRORTITLE), MB_ICONERROR | MB_OK,
        (LPTSTR) SourceKeyName);

    return FALSE;

}

/*******************************************************************************
*
*  RegEdit_OnKeyTreeCommand
*
*  DESCRIPTION:
*     Handles the selection of a menu item by the user intended for the
*     KeyTree child window.
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*     MenuCommand, identifier of menu command.
*     hTreeItem,
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnKeyTreeCommand(
    HWND hWnd,
    int MenuCommand,
    HTREEITEM hTreeItem
    )
{

    HWND hKeyTreeWnd;

    hKeyTreeWnd = g_RegEditData.hKeyTreeWnd;

    //
    //  Assume that the we mean the current selection if we're to dispatch a
    //  command that requires a tree item.  This is necessary because the tree
    //  control will let you activate the context menu of one tree item while
    //  another one is really the selected tree item.
    //

    if (hTreeItem == NULL)
        hTreeItem = TreeView_GetSelection(hKeyTreeWnd);

    switch (MenuCommand) {

        case ID_CONTEXTMENU:
            RegEdit_OnKeyTreeContextMenu(hWnd, TRUE);
            break;

        case ID_TOGGLE:
            TreeView_Expand(hKeyTreeWnd, hTreeItem, TVE_TOGGLE);
            break;

        case ID_DELETE:
            RegEdit_OnKeyTreeDelete(hWnd, hTreeItem);
            break;

        case ID_RENAME:
            RegEdit_OnKeyTreeRename(hWnd, hTreeItem);
            break;

        case ID_DISCONNECT:
            RegEdit_OnKeyTreeDisconnect(hWnd, hTreeItem);
            break;

        case ID_COPYKEYNAME:
            RegEdit_OnCopyKeyName(hWnd, hTreeItem);
            break;

        case ID_NEWKEY:
            RegEdit_OnNewKey(hWnd, hTreeItem);
            break;

        case ID_NEWSTRINGVALUE:
        case ID_NEWBINARYVALUE:
            if (hTreeItem != TreeView_GetSelection(hKeyTreeWnd)) {

                //
                //  Force the selection to occur now, so that we're dealing
                //  with the right open key.
                //

                TreeView_SelectItem(hKeyTreeWnd, hTreeItem);
                RegEdit_OnSelChangedTimer(hWnd);

            }
            //  FALL THROUGH

        default:
            //
            //  Check to see if this menu command should be handled by the main
            //  window's command handler.
            //

            if (MenuCommand >= ID_FIRSTMAINMENUITEM && MenuCommand <=
                ID_LASTMAINMENUITEM)
                RegEdit_OnCommand(hWnd, MenuCommand, NULL, 0);
            break;

    }

}

/*******************************************************************************
*
*  RegEdit_OnKeyTreeContextMenu
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnKeyTreeContextMenu(
    HWND hWnd,
    BOOL fByAccelerator
    )
{

    HWND hKeyTreeWnd;
    DWORD MessagePos;
    POINT MessagePoint;
    TV_HITTESTINFO TVHitTestInfo;
    UINT MenuID;
    HMENU hContextMenu;
    HMENU hContextPopupMenu;
    TV_ITEM TVItem;
    int MenuCommand;

    hKeyTreeWnd = g_RegEditData.hKeyTreeWnd;

    //
    //  If fByAcclerator is TRUE, then the user hit Shift-F10 to bring up the
    //  context menu.  Following the Cabinet's convention, this menu is
    //  placed at (0,0) of the KeyTree client area.
    //

    if (fByAccelerator) {

        MessagePoint.x = 0;
        MessagePoint.y = 0;

        ClientToScreen(hKeyTreeWnd, &MessagePoint);

        TVItem.hItem = TreeView_GetSelection(hKeyTreeWnd);

    }

    else {

        MessagePos = GetMessagePos();

        MessagePoint.x = GET_X_LPARAM(MessagePos);
        MessagePoint.y = GET_Y_LPARAM(MessagePos);

        TVHitTestInfo.pt = MessagePoint;
        ScreenToClient(hKeyTreeWnd, &TVHitTestInfo.pt);
        TVItem.hItem = TreeView_HitTest(hKeyTreeWnd, &TVHitTestInfo);

    }

    //
    //  Determine which context menu to use and load it up.
    //

    if (TVItem.hItem == NULL)
    {
        return;     //  No context menu for now
    }
    else 
    {
        // Select the item to be dragged
        TreeView_Select(g_RegEditData.hKeyTreeWnd, TVItem.hItem, TVGN_CARET);

        if (TreeView_GetParent(hKeyTreeWnd, TVItem.hItem) == NULL)
            MenuID = IDM_COMPUTER_CONTEXT;

        else
            MenuID = IDM_KEY_CONTEXT;

    }

    if ((hContextMenu = LoadMenu(g_hInstance, MAKEINTRESOURCE(MenuID))) == NULL)
        return;

    hContextPopupMenu = GetSubMenu(hContextMenu, 0);

    TVItem.mask = TVIF_STATE | TVIF_CHILDREN;
    TreeView_GetItem(hKeyTreeWnd, &TVItem);

    if (TVItem.state & TVIS_EXPANDED)
        ModifyMenu(hContextPopupMenu, ID_TOGGLE, MF_BYCOMMAND | MF_STRING,
            ID_TOGGLE, g_RegEditData.pCollapse);

    if (MenuID == IDM_COMPUTER_CONTEXT) {

        if (g_RegEditData.fHaveNetwork) {

            if (TreeView_GetPrevSibling(hKeyTreeWnd, TVItem.hItem) == NULL)
                EnableMenuItem(hContextPopupMenu, ID_DISCONNECT, MF_GRAYED |
                    MF_BYCOMMAND);

        }

        else {

            DeleteMenu(hContextPopupMenu, ID_DISCONNECT, MF_BYCOMMAND);
            DeleteMenu(hContextPopupMenu, ID_NETSEPARATOR, MF_BYCOMMAND);

        }

    }

    else {

        RegEdit_SetKeyTreeEditMenuItems(hContextPopupMenu, TVItem.hItem);

        if (TVItem.cChildren == 0)
            EnableMenuItem(hContextPopupMenu, ID_TOGGLE, MF_GRAYED |
                MF_BYCOMMAND);

    }

    SetMenuDefaultItem(hContextPopupMenu, ID_TOGGLE, MF_BYCOMMAND);

    MenuCommand = TrackPopupMenuEx(hContextPopupMenu, TPM_RETURNCMD |
        TPM_RIGHTBUTTON | TPM_LEFTALIGN | TPM_TOPALIGN, MessagePoint.x,
        MessagePoint.y, hWnd, NULL);

    DestroyMenu(hContextMenu);

    RegEdit_OnKeyTreeCommand(hWnd, MenuCommand, TVItem.hItem);

}

/*******************************************************************************
*
*  RegEdit_SetKeyTreeEditMenuItems
*
*  DESCRIPTION:
*     Shared routine between the main menu and the context menu to setup the
*     edit menu items.
*
*  PARAMETERS:
*     hPopupMenu, handle of popup menu to modify.
*     hTreeItem, handle of selected tree item.
*
*******************************************************************************/

VOID
PASCAL
RegEdit_SetKeyTreeEditMenuItems(
    HMENU hPopupMenu,
    HTREEITEM hSelectedTreeItem
    )
{

    UINT EnableFlags;

    EnableFlags = KeyTree_CanDeleteOrRenameItem(g_RegEditData.hKeyTreeWnd,
        hSelectedTreeItem) ? (MF_ENABLED | MF_BYCOMMAND) :
        (MF_GRAYED | MF_BYCOMMAND);

    EnableMenuItem(hPopupMenu, ID_DELETE, EnableFlags);
    EnableMenuItem(hPopupMenu, ID_RENAME, EnableFlags);

}

/*******************************************************************************
*
*  RegEdit_OnKeyTreeDelete
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnKeyTreeDelete(
    HWND hWnd,
    HTREEITEM hTreeItem
    )
{

    HWND hKeyTreeWnd;
    HKEY hRootKey;
    TCHAR KeyName[MAXKEYNAME];
    HTREEITEM hParentTreeItem;
    TV_ITEM TVItem;

    hKeyTreeWnd = g_RegEditData.hKeyTreeWnd;

    if (!KeyTree_CanDeleteOrRenameItem(hKeyTreeWnd, hTreeItem))
        return;

    if (InternalMessageBox(g_hInstance, hWnd,
        MAKEINTRESOURCE(IDS_CONFIRMDELKEYTEXT),
        MAKEINTRESOURCE(IDS_CONFIRMDELKEYTITLE), MB_ICONWARNING | MB_YESNO) !=
        IDYES)
        return;

    if (hTreeItem == TreeView_GetSelection(hKeyTreeWnd)) {

        if (g_RegEditData.hCurrentSelectionKey != NULL) {

            RegCloseKey(g_RegEditData.hCurrentSelectionKey);
            g_RegEditData.hCurrentSelectionKey = NULL;

        }

    }

    hRootKey = KeyTree_BuildKeyPath(hKeyTreeWnd, hTreeItem, KeyName,
        BKP_TOSUBKEY);

    if (RegDeleteKeyRecursive(hRootKey, KeyName) == ERROR_SUCCESS) {

        SetWindowRedraw(hKeyTreeWnd, FALSE);

        hParentTreeItem = TreeView_GetParent(hKeyTreeWnd, hTreeItem);

        TreeView_DeleteItem(hKeyTreeWnd, hTreeItem);

        //
        //  See if the key that we just deleted was the last child of its
        //  parent.  If so, remove the expand/collapse button.
        //

        if (TreeView_GetChild(hKeyTreeWnd, hParentTreeItem) == NULL) {

            TVItem.mask = TVIF_CHILDREN | TVIF_STATE;
            TVItem.hItem = hParentTreeItem;
            TVItem.cChildren = 0;
            TVItem.state = 0;
            TVItem.stateMask = TVIS_EXPANDED | TVIS_EXPANDEDONCE;
            TreeView_SetItem(hKeyTreeWnd, &TVItem);

        }

        //
        //  Make sure we can see the selected tree item now since it may be
        //  currently off-screen.
        //

        TreeView_EnsureVisible(hKeyTreeWnd, TreeView_GetSelection(hKeyTreeWnd));

        SetWindowRedraw(hKeyTreeWnd, TRUE);

        UpdateWindow(hKeyTreeWnd);

    }

    else {

        TVItem.hItem = hTreeItem;
        TVItem.mask = TVIF_TEXT;
        TVItem.pszText = KeyName;
        TVItem.cchTextMax = sizeof(KeyName)/sizeof(TCHAR);

        TreeView_GetItem(hKeyTreeWnd, &TVItem);

        InternalMessageBox(g_hInstance, hWnd,
            MAKEINTRESOURCE(IDS_DELETEKEYDELETEFAILED),
            MAKEINTRESOURCE(IDS_DELETEKEYERRORTITLE), MB_ICONERROR | MB_OK,
            KeyName);

        //
        //  Need to refresh the tree at this point, as some subkeys may have
        //  been deleted successfully even if we didn't have sufficient
        //  permissions to delete all of them.
        //
        RegEdit_OnKeyTreeRefresh(hWnd);
    }

}

/*******************************************************************************
*
*  RegEdit_OnKeyTreeRename
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnKeyTreeRename(
    HWND hWnd,
    HTREEITEM hTreeItem
    )
{

    if (KeyTree_CanDeleteOrRenameItem(g_RegEditData.hKeyTreeWnd, hTreeItem))
        KeyTree_EditLabel(g_RegEditData.hKeyTreeWnd, hTreeItem);

}

/*******************************************************************************
*
*  RegEdit_OnKeyTreeRefresh
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnKeyTreeRefresh(
    HWND hWnd
    )
{

    HDPA hDPA;
    HWND hKeyTreeWnd;
    HTREEITEM hPrevSelectedTreeItem;
    TV_ITEM EnumTVItem;
    TV_ITEM CurrentTVItem;
    HKEY hRootKey;
    TCHAR KeyName[MAXKEYNAME];
    int MaximumSubKeyLength;
    int Index;
    HKEY hEnumKey;
    int CompareResult;
    LPTSTR lpDPAKeyName;
    HTREEITEM hTempTreeItem;

    if ((hDPA = DPA_CreateEx(REFRESH_DPA_GROW, GetProcessHeap())) == NULL)
        return;

    hKeyTreeWnd = g_RegEditData.hKeyTreeWnd;

    RegEdit_SetWaitCursor(TRUE);
    SetWindowRedraw(hKeyTreeWnd, FALSE);

    hPrevSelectedTreeItem = TreeView_GetSelection(hKeyTreeWnd);

    EnumTVItem.mask = TVIF_TEXT;
    EnumTVItem.pszText = KeyName;
    EnumTVItem.cchTextMax = sizeof(KeyName)/sizeof(TCHAR);

    CurrentTVItem.mask = TVIF_STATE | TVIF_CHILDREN;
    CurrentTVItem.stateMask = 0;
    CurrentTVItem.hItem = TreeView_GetRoot(hKeyTreeWnd);

    while (TRUE) {

        TreeView_GetItem(hKeyTreeWnd, &CurrentTVItem);
        hRootKey = KeyTree_BuildKeyPath(hKeyTreeWnd, CurrentTVItem.hItem,
            KeyName, BKP_TOSUBKEY);

        if (CurrentTVItem.state & TVIS_EXPANDED) {

            //
            //  If this isn't a top-level label (and it won't be if hRootKey is
            //  not NULL), then compare the actual contents of the registry
            //  against what we're showing.
            //
            if(hRootKey && RegOpenKeyEx(hRootKey,KeyName,0,KEY_ENUMERATE_SUB_KEYS,&hEnumKey) ==
                ERROR_SUCCESS) {

                //
                //  As a result of adding new keys and renaming existing ones,
                //  the children of this item may be out of order.  For the
                //  following algorithm to work correctly, we must now sort
                //  these keys.
                //

                TreeView_SortChildren(hKeyTreeWnd, CurrentTVItem.hItem, FALSE);

                //
                //  Build a sorted dynamic array of strings that represent the
                //  keys actually in the registry at this time.
                //

                MaximumSubKeyLength = MAXKEYNAME - (lstrlen(KeyName) + 1);
                Index = 0;

                while (RegEnumKey(hEnumKey, Index, KeyName,
                    MaximumSubKeyLength) == ERROR_SUCCESS) {

                    lpDPAKeyName = NULL;
                    Str_SetPtr(&lpDPAKeyName, KeyName);
                    DPA_InsertPtr(hDPA, Index++, lpDPAKeyName);

                }

                RegCloseKey(hEnumKey);
                DPA_Sort(hDPA, DPACompareKeyNames, 0);

                //
                //  Does this key have subkeys anymore?  If not, then we need
                //  to reset it's child flag and remove all of it's children.
                //

                if (Index == 0) {

                    DPA_DeleteAllPtrs(hDPA);

                    TreeView_Expand(hKeyTreeWnd, CurrentTVItem.hItem,
                        TVE_COLLAPSE | TVE_COLLAPSERESET);

                    CurrentTVItem.cChildren = 0;
                    goto SetCurrentTreeItem;

                }

                //
                //  Merge the keys that we found during our above enumeration
                //  with the keys that our key tree lists.  Add and remove
                //  elements from the tree as appropriate.
                //

                lpDPAKeyName = DPA_FastGetPtr(hDPA, --Index);

                EnumTVItem.hItem = TreeView_GetChild(hKeyTreeWnd,
                    CurrentTVItem.hItem);
                if (EnumTVItem.hItem)
                    TreeView_GetItem(hKeyTreeWnd, &EnumTVItem);

                while (Index >= 0 && EnumTVItem.hItem != NULL) {

                    CompareResult = lstrcmpi(KeyName, lpDPAKeyName);

                    if (CompareResult == 0) {

                        EnumTVItem.hItem = TreeView_GetNextSibling(hKeyTreeWnd,
                            EnumTVItem.hItem);
                        if (EnumTVItem.hItem)
                            TreeView_GetItem(hKeyTreeWnd, &EnumTVItem);

                        goto GetNextDPAPointer;

                    }

                    else if (CompareResult > 0) {

                        KeyTree_InsertItem(hKeyTreeWnd, CurrentTVItem.hItem,
                            TVI_SORT, lpDPAKeyName, DoesKeyHaveKids(hEnumKey,
                            lpDPAKeyName), 0);

GetNextDPAPointer:
                        Str_SetPtr(&lpDPAKeyName, NULL);

                        if (--Index >= 0)
                            lpDPAKeyName = DPA_FastGetPtr(hDPA, Index);

                    }

                    else {

                        hTempTreeItem = TreeView_GetNextSibling(hKeyTreeWnd,
                            EnumTVItem.hItem);
                        TreeView_DeleteItem(hKeyTreeWnd, EnumTVItem.hItem);
                        EnumTVItem.hItem = hTempTreeItem;
                        if (EnumTVItem.hItem)
                            TreeView_GetItem(hKeyTreeWnd, &EnumTVItem);

                    }

                }

                //
                //  Once we drop to here, we may have extra items in the key
                //  tree or in the dynamic array.  Process them accordingly.
                //

                if (Index >= 0) {

                    while (TRUE) {

                        KeyTree_InsertItem(hKeyTreeWnd, CurrentTVItem.hItem,
                            TVI_SORT, lpDPAKeyName, DoesKeyHaveKids(hEnumKey,
                            lpDPAKeyName), 0);

                        Str_SetPtr(&lpDPAKeyName, NULL);

                        if (--Index < 0)
                            break;

                        lpDPAKeyName = DPA_FastGetPtr(hDPA, Index);

                    }

                }

                else {

                    while (EnumTVItem.hItem != NULL) {

                        hTempTreeItem = TreeView_GetNextSibling(hKeyTreeWnd,
                            EnumTVItem.hItem);
                        TreeView_DeleteItem(hKeyTreeWnd, EnumTVItem.hItem);
                        EnumTVItem.hItem = hTempTreeItem;

                    }

                }

                DPA_DeleteAllPtrs(hDPA);

            }

            CurrentTVItem.hItem = TreeView_GetChild(hKeyTreeWnd,
                CurrentTVItem.hItem);

        }

        else {

            //
            //  If this isn't a top-level label (and it won't be if hRootKey is
            //  not NULL), then re-check if this key has any children.
            //

            if (hRootKey != NULL) {

                TreeView_Expand(hKeyTreeWnd, CurrentTVItem.hItem, TVE_COLLAPSE |
                    TVE_COLLAPSERESET);

                CurrentTVItem.cChildren = DoesKeyHaveKids(hRootKey, KeyName);

SetCurrentTreeItem:
                TreeView_SetItem(hKeyTreeWnd, &CurrentTVItem);

            }

            //
            //  Because we're at the "bottom" of the TreeView, we now need to
            //  walk to the siblings of this tree item.  And if no siblings
            //  exist, we walk back to the parent and check again for siblings.
            //

            while (TRUE) {

                if ((hTempTreeItem = TreeView_GetNextSibling(hKeyTreeWnd,
                    CurrentTVItem.hItem)) != NULL) {

                    CurrentTVItem.hItem = hTempTreeItem;
                    break;

                }

                if ((CurrentTVItem.hItem = TreeView_GetParent(hKeyTreeWnd,
                    CurrentTVItem.hItem)) == NULL) {

                    //
                    //  We've now walked over all of the tree items, so do any
                    //  cleanup here and exit.
                    //

                    DPA_Destroy(hDPA);

                    SetWindowRedraw(hKeyTreeWnd, TRUE);

                    //
                    //  The selection may have changed as a result of having
                    //  the focus on an nonexistent key.
                    //

                    if (TreeView_GetSelection(hKeyTreeWnd) != hPrevSelectedTreeItem) {
                        RegEdit_OnKeyTreeSelChanged(hWnd, NULL);
                    } else {
                        if (RegEdit_OnValueListRefresh(hWnd) != ERROR_SUCCESS) {
                            //
                            // Its possible that the registry key was deleted and replaced with
                            // an identically-named key.  We should just trigger a selection
                            // change in this case.
                            //
                            RegEdit_OnKeyTreeSelChanged(hWnd, NULL);
                        }
                    }

                    RegEdit_SetWaitCursor(FALSE);

                    return;

                }

            }

        }

    }

}

/*******************************************************************************
*
*  DPACompareKeyNames
*
*  DESCRIPTION:
*     Callback comparision routine for refresh's DPA_Sort call.  Simply returns
*     the result of lstrcmpi.
*
*  PARAMETERS:
*     lpString1,
*     lpString2,
*     lParam, ignored optional data.
*
*******************************************************************************/

int
WINAPI
DPACompareKeyNames(
    LPVOID lpString1,
    LPVOID lpString2,
    LPARAM lParam
    )
{

    return lstrcmpi((LPTSTR) lpString2, (LPTSTR) lpString1);

}

/*******************************************************************************
*
*  RegEdit_OnKeyTreeDisconnect
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnKeyTreeDisconnect(
    HWND hWnd,
    HTREEITEM hTreeItem
    )
{

    HWND hKeyTreeWnd;
    TV_ITEM TVItem;

    hKeyTreeWnd = g_RegEditData.hKeyTreeWnd;

    //
    //  Disconnect all of the root registry handles that we've opened.
    //

    TVItem.mask = TVIF_PARAM;
    TVItem.hItem = TreeView_GetChild(hKeyTreeWnd, hTreeItem);

    while (TVItem.hItem != NULL) {

        TreeView_GetItem(hKeyTreeWnd, &TVItem);

        RegCloseKey((HKEY) TVItem.lParam);

        TVItem.hItem = TreeView_GetNextSibling(hKeyTreeWnd, TVItem.hItem);

    }

    TreeView_DeleteItem(hKeyTreeWnd, hTreeItem);

}

/*******************************************************************************
*
*  RegEdit_UpdateStatusBar
*
*  DESCRIPTION:
*     Show the full registry path in the status bar, for lack of anything
*     better to do with it.
*
*  PARAMETERS:
*     (none).
*
*******************************************************************************/

VOID
PASCAL
RegEdit_UpdateStatusBar(
    VOID
    )
{

    HWND hKeyTreeWnd;
    TCHAR KeyName[MAXKEYNAME*2];

    hKeyTreeWnd = g_RegEditData.hKeyTreeWnd;
    KeyTree_BuildKeyPath(hKeyTreeWnd, TreeView_GetSelection(hKeyTreeWnd),
        KeyName, BKP_TOCOMPUTER);
    SetWindowText(g_RegEditData.hStatusBarWnd, KeyName);

}

/*******************************************************************************
*
*  RegEdit_OnCopyKeyName
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnCopyKeyName(
    HWND hWnd,
    HTREEITEM hTreeItem
    )
{

    TCHAR KeyName[MAXKEYNAME*2];
    UINT KeyNameLength;
    HANDLE hClipboardData;
    LPTSTR lpClipboardData;

    KeyTree_BuildKeyPath(g_RegEditData.hKeyTreeWnd, hTreeItem, KeyName,
        BKP_TOSYMBOLICROOT);
    KeyNameLength = (lstrlen(KeyName) + 1) * sizeof(TCHAR);

    if (OpenClipboard(hWnd)) {

        if ((hClipboardData = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE,
            KeyNameLength)) != NULL) {

            lpClipboardData = (LPTSTR) GlobalLock(hClipboardData);
            CopyMemory(lpClipboardData, KeyName, KeyNameLength);
            GlobalUnlock(hClipboardData);

            EmptyClipboard();
            SetClipboardData(CF_UNICODETEXT, hClipboardData);

        }

        CloseClipboard();

    }

}

/*******************************************************************************
*
*  KeyTree_BuildKeyPath
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hTreeViewWnd, handle of KeyTree window.
*     hTreeItem, handle of tree item to begin building from.
*     lpKeyPath, buffer to store path in.
*     fIncludeSymbolicRootName, TRUE if root key's name should be included
*        (e.g., HKEY_LOCAL_MACHINE), else FALSE.
*
*******************************************************************************/

HKEY
PASCAL
KeyTree_BuildKeyPath(
    HWND hTreeViewWnd,
    HTREEITEM hTreeItem,
    LPTSTR lpKeyPath,
    UINT ToFlags
    )
{

    TV_ITEM TVItem;
    TCHAR SubKeyName[MAXKEYNAME*2];

    *lpKeyPath = '\0';

    TVItem.mask = TVIF_TEXT | TVIF_PARAM;
    TVItem.hItem = hTreeItem;
    TVItem.pszText = (LPTSTR) SubKeyName;
    TVItem.cchTextMax = sizeof(SubKeyName)/sizeof(TCHAR);

    while (TRUE) {

        TreeView_GetItem(hTreeViewWnd, &TVItem);

        if (TVItem.lParam != 0 && !(ToFlags & BKP_TOSYMBOLICROOT))
            break;

        if (*lpKeyPath != '\0') {

            lstrcat(SubKeyName, TEXT("\\"));
            lstrcat(SubKeyName, lpKeyPath);

        }

        lstrcpy(lpKeyPath, SubKeyName);

        if (TVItem.lParam != 0 && (ToFlags & BKP_TOCOMPUTER) != BKP_TOCOMPUTER)
            break;

        TVItem.hItem = TreeView_GetParent(hTreeViewWnd, TVItem.hItem);

        if (TVItem.hItem == NULL) {

            if ((ToFlags & BKP_TOCOMPUTER) != BKP_TOCOMPUTER)
                *lpKeyPath = '\0';

            break;

        }

    }

    return ((HKEY) TVItem.lParam);

}

/*******************************************************************************
*
*  KeyTree_InsertItem
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

HTREEITEM
PASCAL
KeyTree_InsertItem(
    HWND hKeyTreeWnd,
    HTREEITEM hParent,
    HTREEITEM hInsertAfter,
    LPCTSTR lpText,
    UINT fHasKids,
    LPARAM lParam
    )
{

    TV_INSERTSTRUCT TVInsertStruct;

    TVInsertStruct.hParent = hParent;
    TVInsertStruct.hInsertAfter = hInsertAfter;
    TVInsertStruct.item.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE |
        TVIF_PARAM | TVIF_CHILDREN;
    //  TVInsertStruct.item.hItem = NULL;
    //  TVInsertStruct.item.state = 0;
    //  TVInsertStruct.item.stateMask = 0;
    TVInsertStruct.item.pszText = (LPTSTR) lpText;
    //  TVInsertStruct.item.cchTextMax = lstrlen(lpText);
    TVInsertStruct.item.iImage = IMAGEINDEX(IDI_FOLDER);
    TVInsertStruct.item.iSelectedImage = IMAGEINDEX(IDI_FOLDEROPEN);
    TVInsertStruct.item.cChildren = fHasKids;
    TVInsertStruct.item.lParam = lParam;

    return TreeView_InsertItem(hKeyTreeWnd, &TVInsertStruct);

}

/*******************************************************************************
*
*  KeyTree_ExpandBranch
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hTreeViewWnd, handle of KeyTree window.
*     hTreeItem, handle of tree item to edit.
*
*******************************************************************************/

BOOL
PASCAL
KeyTree_ExpandBranch(
    HWND hKeyTreeWnd,
    HTREEITEM hExpandingTreeItem
    )
{

    TCHAR KeyName[MAXKEYNAME];
    HKEY hRootKey;
    HKEY hEnumKey;
    int Index;
    int MaximumSubKeyLength;

    //
    //  Nothing special needs to be done with a top-level label such as "My
    //  Computer" or a network computer name.  It's children are already filled
    //  in and are always valid.
    //

    if (TreeView_GetParent(hKeyTreeWnd, hExpandingTreeItem) == NULL)
        return TRUE;

    hRootKey = KeyTree_BuildKeyPath(hKeyTreeWnd, hExpandingTreeItem,
        KeyName, FALSE);

    if(RegOpenKeyEx(hRootKey,KeyName,0,KEY_ENUMERATE_SUB_KEYS,&hEnumKey) != ERROR_SUCCESS)
        return FALSE;

    MaximumSubKeyLength = MAXKEYNAME - (lstrlen(KeyName) + 1);
    Index = 0;

    while (RegEnumKey(hEnumKey, Index++, KeyName, MaximumSubKeyLength) ==
        ERROR_SUCCESS) {

        KeyTree_InsertItem(hKeyTreeWnd, hExpandingTreeItem, TVI_FIRST,
            KeyName, DoesKeyHaveKids(hEnumKey, KeyName), 0);

    }

    RegCloseKey(hEnumKey);

    //
    //  Sort the subkeys _after_ inserting all the items.  The above insert
    //  used to specify TVI_SORT, but on NT, expanding a key with several
    //  subkeys (e.g., HKEY_CLASSES_ROOT) would take several seconds!
    //

    TreeView_SortChildren(hKeyTreeWnd, hExpandingTreeItem, FALSE);


    return TRUE;

}

/*******************************************************************************
*
*  DoesKeyHaveKids
*
*  DESCRIPTION:
*     Checks if the given key path has any subkeys or not.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL
PASCAL
DoesKeyHaveKids(
    HKEY hKey,
    LPTSTR lpKeyName
    )
{

    BOOL fHasKids;
    HKEY hCheckChildrenKey;
    DWORD cSubKeys;

    fHasKids = FALSE;

    if(RegOpenKeyEx(hKey,lpKeyName,0,KEY_QUERY_VALUE|KEY_ENUMERATE_SUB_KEYS,
        &hCheckChildrenKey) == ERROR_SUCCESS) {

        if (RegQueryInfoKey(hCheckChildrenKey, NULL, NULL, NULL, &cSubKeys,
            NULL, NULL, NULL, NULL, NULL, NULL, NULL) == ERROR_SUCCESS &&
            cSubKeys > 0)
            fHasKids = TRUE;

        RegCloseKey(hCheckChildrenKey);

    }

    return fHasKids;

}

/*******************************************************************************
*
*  KeyTree_EditLabel
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hTreeViewWnd, handle of KeyTree window.
*     hTreeItem, handle of tree item to edit.
*
*******************************************************************************/

VOID
PASCAL
KeyTree_EditLabel(
    HWND hKeyTreeWnd,
    HTREEITEM hTreeItem
    )
{

    g_RegEditData.fAllowLabelEdits = TRUE;

    TreeView_EditLabel(hKeyTreeWnd, hTreeItem);

    g_RegEditData.fAllowLabelEdits = FALSE;

}

/*******************************************************************************
*
*  KeyTree_CanDeleteOrRenameItem
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hTreeViewWnd, handle of KeyTree window.
*     hTreeItem, handle of tree item to check.
*
*******************************************************************************/

BOOL
PASCAL
KeyTree_CanDeleteOrRenameItem(
    HWND hWnd,
    HTREEITEM hTreeItem
    )
{

    TV_ITEM TVItem;

    //
    //  Check if the selected tree item is null.  This will occur when viewing
    //  the Edit popup from the main menu with no selection made.
    //

    if (hTreeItem != NULL) {

        //
        //  Check if this tree item has any reference data indicating that it
        //  is a predefined root.  Predefined roots cannot be renamed or
        //  deleted.
        //

        TVItem.hItem = hTreeItem;
        TVItem.mask = TVIF_PARAM;
        TreeView_GetItem(hWnd, &TVItem);

        if ((HKEY) TVItem.lParam == NULL) {

            //
            //  Check that this isn't a top-level item such as "My Computer" or
            //  a remote registry connection.
            //

            if (TreeView_GetParent(hWnd, hTreeItem) != NULL)
                return TRUE;

        }

    }

    return FALSE;

}


//------------------------------------------------------------------------------
//  KeyTree_GetRootKey
//
//  DESCRIPTION: Returns the root key of the item (HKEY_ ...)
//
//  PARAMETERS:  hTreeItem - treeview item
//------------------------------------------------------------------------------
HKEY KeyTree_GetRootKey(HTREEITEM hTreeItem)
{
    TV_ITEM TVItem;
    TVItem.mask = TVIF_PARAM;
    TVItem.hItem = hTreeItem;

    TreeView_GetItem(g_RegEditData.hKeyTreeWnd, &TVItem);

    while (!TVItem.lParam)
    {
        TVItem.hItem = TreeView_GetParent(g_RegEditData.hKeyTreeWnd, TVItem.hItem);
        TreeView_GetItem(g_RegEditData.hKeyTreeWnd, &TVItem);
    }

    return ((HKEY) TVItem.lParam);
}


//------------------------------------------------------------------------------
//  KeyTree_GetKeyName
//
//  DESCRIPTION: Returns the TEXT of an item
//
//  PARAMETERS:  hTreeItem - treeview item
//               pszText - pointer to an TCHAR array
//               cchMax - number of characters in the array
//------------------------------------------------------------------------------
PTSTR KeyTree_GetKeyName(HTREEITEM hTreeItem, PTSTR pszName, int cchNameMax)
{
    TV_ITEM TVItem;

    pszName[0] = TEXT('\0');

    TVItem.mask = TVIF_TEXT;
    TVItem.hItem = hTreeItem;
    TVItem.pszText = pszName;
    TVItem.cchTextMax = cchNameMax;

    TreeView_GetItem(g_RegEditData.hKeyTreeWnd, &TVItem);

    return TVItem.pszText;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\regedit\regnet.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGNET.C
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        03 May 1994
*
*  Remote registry support for the Registry Editor.
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  03 May 1994 TCS Moved existing connection code from REGEDIT.C.
*
*******************************************************************************/

#ifndef _INC_REGNET
#define _INC_REGNET

VOID
PASCAL
RegEdit_OnCommandConnect(
    HWND hWnd
    );

VOID
PASCAL
RegEdit_OnCommandDisconnect(
    HWND hWnd
    );

#endif // _INC_REGNET
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\regedit\regobjpkr.cpp ===
//------------------------------------------------------------------------
//
//  Microsoft Windows Shell
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:      regobjpkr.cpp
//
//  Contents:  The implementation of the object picker for regedit 
//
//  Classes:   none
//
//------------------------------------------------------------------------

#include <accctrl.h>
#include <objsel.h>
#include <TCHAR.h> 


extern "C" HRESULT SelectComputer(HWND hWnd, LPTSTR pszRemoteName, int cchMax);
HRESULT InitObjectPicker(IDsObjectPicker *pDsObjectPicker);
void    GetNameFromObject(IDataObject *pdo, LPTSTR pszName, int cchMax);


//------------------------------------------------------------------------------
//  SelectComputer
//
//  DESCRIPTION: Invokes the Object Picker and returns computer name
//
//  PARAMETERS:  hWnd - handle to parent window
//               pszRemoteName[OUT] - LPTSTR
//------------------------------------------------------------------------------
HRESULT SelectComputer(HWND hWnd, LPTSTR pszRemoteName, int cchMax)
{
    HRESULT hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
    if (SUCCEEDED(hr))
    {
        IDsObjectPicker *pDsObjectPicker = NULL;
        hr = CoCreateInstance(CLSID_DsObjectPicker, NULL, CLSCTX_INPROC_SERVER,
                              IID_IDsObjectPicker, (LPVOID*) &pDsObjectPicker);
        if (SUCCEEDED(hr))
        {
            hr = InitObjectPicker(pDsObjectPicker);
            if (SUCCEEDED(hr)) 
            {
                IDataObject *pdo = NULL;
                if (pDsObjectPicker->InvokeDialog(hWnd, &pdo) == S_OK)
                {
                    GetNameFromObject(pdo, pszRemoteName, cchMax);
                    pdo->Release();
                    hr = S_OK;
                }
                else
                {
                    hr = E_FAIL;
                }
            }
            pDsObjectPicker->Release();
        }    
        CoUninitialize();
    }
    return hr;   
}


//------------------------------------------------------------------------------
//  InitObjectPicker
//
//  DESCRIPTION: Initializes the InitObjectPicker
//
//  PARAMETERS:  pDsObjectPicker - pointer to object picker obj.
//------------------------------------------------------------------------------
HRESULT InitObjectPicker(IDsObjectPicker *pDsObjectPicker) 
{
    DSOP_SCOPE_INIT_INFO aScopeInit = {0};
    DSOP_INIT_INFO  InitInfo = {0};
    
    // Initialize the DSOP_SCOPE_INIT_INFO structure.
    aScopeInit.cbSize = sizeof(DSOP_SCOPE_INIT_INFO);

    aScopeInit.flType = DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN |
                        DSOP_SCOPE_TYPE_WORKGROUP |
                        DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN |
                        DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN |
                        DSOP_SCOPE_TYPE_GLOBAL_CATALOG |
                        DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN |
                        DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE |
                        DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE;

    aScopeInit.FilterFlags.Uplevel.flBothModes = DSOP_FILTER_COMPUTERS;
    aScopeInit.FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;

    // Initialize the DSOP_INIT_INFO structure.
    InitInfo.cbSize = sizeof(InitInfo);
    InitInfo.pwzTargetComputer = NULL;  // Target is the local computer.
    InitInfo.cDsScopeInfos = 1;
    InitInfo.aDsScopeInfos = &aScopeInit;
 
    return pDsObjectPicker->Initialize(&InitInfo);
}


//------------------------------------------------------------------------------
//  GetNameFromObject
//
//  DESCRIPTION: Revieves the name of an object
//
//  PARAMETERS:  IDataObject - data object
//               pszName[OUT] - LPTSTR
//------------------------------------------------------------------------------
void GetNameFromObject(IDataObject *pdo, LPTSTR pszName, int cchMax)
{
    PDS_SELECTION_LIST pDsSelList = NULL;
    
    STGMEDIUM stgmedium = {TYMED_HGLOBAL, NULL, NULL};
    CLIPFORMAT cfDsObjectPicker = (CLIPFORMAT) RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);
    FORMATETC formatetc = {cfDsObjectPicker, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    
    // Get the global memory block containing the user's selections.
    if (SUCCEEDED(pdo->GetData(&formatetc, &stgmedium)))
    {     
        // Retrieve pointer to DS_SELECTION_LIST structure.
        pDsSelList = (PDS_SELECTION_LIST) GlobalLock(stgmedium.hGlobal);
        if (pDsSelList)
        {
            _tcsncpy(pszName, pDsSelList->aDsSelection[0].pwzName, cchMax);
            GlobalUnlock(stgmedium.hGlobal);
        }
        ReleaseStgMedium(&stgmedium);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\regedit\regporte.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-2000
*
*  TITLE:       REGPORTE.C
*
*  VERSION:     5.00
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        06 Apr 1994
*
*  File import and export engine routines for the Registry Editor.
*
*******************************************************************************/

#include "pch.h"
#include "regresid.h"
#include "reg1632.h"
#include "regedit.h"
#include "regkey.h"
#include "regfile.h"
#include "regedit.h"
#include <malloc.h>

//  Association between the ASCII name and the handle of the registry key.
const REGISTRY_ROOT g_RegistryRoots[] = {
    TEXT("HKEY_CLASSES_ROOT"), HKEY_CLASSES_ROOT, PREDEFINE_KEY_CLASSES_ROOT,
    TEXT("HKEY_CURRENT_USER"), HKEY_CURRENT_USER, PREDEFINE_KEY_CURRENT_USER,
    TEXT("HKEY_LOCAL_MACHINE"), HKEY_LOCAL_MACHINE, PREDEFINE_KEY_LOCAL_MACHINE,
    TEXT("HKEY_USERS"), HKEY_USERS, PREDEFINE_KEY_USERS,
    TEXT("HKEY_CURRENT_CONFIG"), HKEY_CURRENT_CONFIG, PREDEFINE_KEY_CURRENT_CONFIG,
    TEXT("HKEY_DYN_DATA"), HKEY_DYN_DATA, 0
};

const TCHAR s_RegistryHeader[] = TEXT("REGEDIT");

const TCHAR s_OldWin31RegFileRoot[] = TEXT(".classes");

const TCHAR s_Win40RegFileHeader[] = TEXT("REGEDIT4\n\n");

#ifdef UNICODE
//
// New header is required for version 5.0 because the version detection code
// in Win 4.0 regedit wasn't very good (See comments in ImportRegFile for
// details)
//
const WORD s_UnicodeByteOrderMark = 0xFEFF;
const TCHAR s_WinNT50RegFileHeader[] = TEXT("Windows Registry Editor Version");
const TCHAR s_WinNT50RegFileVersion[] = TEXT("5.00");
#endif

const TCHAR s_HexPrefix[] = TEXT("hex");
const TCHAR s_DwordPrefix[] = TEXT("dword:");
const TCHAR g_HexConversion[16] = {TEXT('0'), TEXT('1'), TEXT('2'), TEXT('3'), TEXT('4'),
                                   TEXT('5'), TEXT('6'), TEXT('7'), TEXT('8'), TEXT('9'),
                                   TEXT('a'), TEXT('b'), TEXT('c'), TEXT('d'), TEXT('e'), TEXT('f')};
const TCHAR s_FileLineBreak[] = TEXT(",\\\n  ");

extern BOOL g_fMultiLineStrings;

//REARCHITECT - we upped the size of this buffer from 512 to 64K to reduce the chance of hitting the bug
//where a DBCS character is split across two buffers.  The true fix was too risky at the time.
//Changed for NT5 RC2
#define SIZE_FILE_IO_BUFFER             0x10000 //64K

typedef struct _FILE_IO{
#ifdef UNICODE
    //
    // Space for unicode/ansi conversions, assumes worst case
    // where every unicode char is a double-byte char
    //
    CHAR ConversionBuffer[SIZE_FILE_IO_BUFFER*2];
#endif
    TCHAR Buffer[SIZE_FILE_IO_BUFFER];
    FILE_HANDLE hFile;
    int BufferOffset;
    int CurrentColumn;
    int CharsAvailable;
    DWORD FileSizeDiv100;
    DWORD FileOffset;
    UINT LastPercentage;
#ifdef DEBUG
    BOOL fValidateUngetChar;
#endif
}   FILE_IO;

FILE_IO s_FileIo;

UINT g_FileErrorStringID;

UINT g_ImportFileVersion;

BOOL s_fTreatFileAsUnicode = TRUE;

VOID ImportWin31RegFile(HTREEITEM hComputerItem);

VOID
NEAR PASCAL
ImportNewerRegFile(HTREEITEM hComputerItem);

VOID ParseHeader(LPHKEY lphKey, HTREEITEM hComputerItem);

VOID
NEAR PASCAL
ParseValue(
    HKEY hKey,
    LPCTSTR lpszValueName
    );

VOID
NEAR PASCAL
ParseValuename(
    HKEY hKey
    );

BOOL
NEAR PASCAL
ParseString(LPPORTVALUEPARAM pPortValueParam);

BOOL
NEAR PASCAL
ParseHexSequence(LPPORTVALUEPARAM pPortValueParam);

BOOL
NEAR PASCAL
ParseHexDword(
    LPDWORD lpDword
    );

BOOL
NEAR PASCAL
ParseHexByte(
    LPBYTE lpByte
    );

BOOL
NEAR PASCAL
ParseHexDigit(
    LPBYTE lpDigit
    );

BOOL
NEAR PASCAL
ParseEndOfLine(
    VOID
    );

VOID
NEAR PASCAL
SkipWhitespace(
    VOID
    );

VOID
NEAR PASCAL
SkipPastEndOfLine(
    VOID
    );

BOOL
NEAR PASCAL
GetChar(
    PTCHAR lpChar
    );

VOID
NEAR PASCAL
UngetChar(
    VOID
    );

BOOL
NEAR PASCAL
MatchChar(
    TCHAR CharToMatch
    );

BOOL
NEAR PASCAL
IsWhitespace(
    TCHAR Char
    );

BOOL
NEAR PASCAL
IsNewLine(
    TCHAR Char
    );

VOID
NEAR PASCAL
PutBranch(
    HKEY hKey,
    LPTSTR lpKeyName
    );

VOID
NEAR PASCAL
PutLiteral(
    LPCTSTR lpString
    );

VOID
NEAR PASCAL
PutString(
    LPCTSTR lpString
    );

VOID
NEAR PASCAL
PutBinary(
    CONST BYTE FAR* lpBuffer,
    DWORD Type,
    DWORD cbBytes
    );

VOID
NEAR PASCAL
PutDword(
    DWORD Dword,
    BOOL fLeadingZeroes
    );

VOID
NEAR PASCAL
PutChar(
    TCHAR Char
    );

VOID
NEAR PASCAL
FlushIoBuffer(
    VOID
    );

//------------------------------------------------------------------------------
//  Regedit_GetRootKeyFromComputer
//
//  DESCRIPTION: Invokes the security editor for the currently selected item.
//
//  PARAMETERS:  hWnd - handle to the current window
//------------------------------------------------------------------------------
HKEY Regedit_GetRootKeyFromComputer(HTREEITEM hComputerItem, PTSTR pszFullKeyName)
{
    HKEY hRootKey = NULL;

    if (hComputerItem == NULL)
    {
        int i;
        for (i = 0; i < NUMBER_REGISTRY_ROOTS; i++)
        {
            if (STRCMP(g_RegistryRoots[i].lpKeyName, pszFullKeyName) == 0)
            {
                hRootKey = g_RegistryRoots[i].hKey;
                break;
            }

        }
    }
    else
    {
        TCHAR acComputerName[MAXKEYNAME];
        TV_ITEM TVItem;

        // walk through each of the registry roots to see if this key
        // belongs to it
        HTREEITEM hRegistryRoot =
            TreeView_GetChild(g_RegEditData.hKeyTreeWnd, hComputerItem);

        TVItem.mask = TVIF_TEXT | TVIF_PARAM;
        TVItem.hItem = hRegistryRoot;
        TVItem.pszText = acComputerName;
        TVItem.cchTextMax = sizeof(acComputerName)/sizeof(TCHAR);

        while (hRegistryRoot != NULL)
        {
            TreeView_GetItem(g_RegEditData.hKeyTreeWnd, &TVItem);

            if (STRCMP(acComputerName, pszFullKeyName) == 0)
            {
                hRootKey = (HKEY)TVItem.lParam;
                break;
            }

            hRegistryRoot =
                TreeView_GetNextSibling(g_RegEditData.hKeyTreeWnd, hRegistryRoot);
            TVItem.hItem = hRegistryRoot;
        }
    }

    return hRootKey;
}

/*******************************************************************************
*
*  EditRegistryKey
*
*  DESCRIPTION:
*     Parses the pFullKeyName string and creates a handle to the registry key.
*
*  PARAMETERS:
*     lphKey, location to store handle to registry key.
*     lpFullKeyName, string of form "HKEY_LOCAL_MACHINE\Subkey1\Subkey2".
*     fCreate, TRUE if key should be created, else FALSE for open only.
*     (returns), ERROR_SUCCESS, no errors occurred, phKey is valid,
*                ERROR_CANTOPEN, registry access error of some form,
*                ERROR_BADKEY, incorrectly formed pFullKeyName.
*
*******************************************************************************/

DWORD EditRegistryKey(HTREEITEM hComputerItem, LPHKEY lphKey, LPTSTR lpFullKeyName, UINT uOperation)
{
    LPTSTR lpSubKeyName;
    TCHAR PrevChar;
    UINT Counter;
    DWORD Result;
    HKEY hRootKey = NULL;

    if ((lpSubKeyName = (LPTSTR) STRCHR(lpFullKeyName, TEXT('\\'))) != NULL) {

        PrevChar = *lpSubKeyName;
        *lpSubKeyName++ = 0;

    }

    CHARUPPERSTRING(lpFullKeyName);

    hRootKey = Regedit_GetRootKeyFromComputer(hComputerItem, lpFullKeyName);

    if (hRootKey)
    {
        Result = ERROR_CANTOPEN;

        switch (uOperation)
        {
        case ERK_CREATE:
            //
            // If trying to open one of these keys just return OK
            // When lpSubKeyName is NULL, you recreate the parent key
            // Since these keys are usually in use this will fail
            // This code path only occurs when restoring a whole root key
            // from a .reg file.
            //
            if (((hRootKey == HKEY_LOCAL_MACHINE) || (hRootKey == HKEY_USERS))
                && lpSubKeyName == NULL) {
                Result = ERROR_SUCCESS;
            }
            else if (RegCreateKey(hRootKey, lpSubKeyName, lphKey) == ERROR_SUCCESS)
                Result = ERROR_SUCCESS;
            break;

        case ERK_OPEN:
            //
            // Used when exporting.
            //
            if(RegOpenKeyEx(hRootKey,lpSubKeyName,0,KEY_ENUMERATE_SUB_KEYS|KEY_QUERY_VALUE,lphKey) == ERROR_SUCCESS)
                Result = ERROR_SUCCESS;
            break;

        case ERK_DELETE:
            RegDeleteKeyRecursive(hRootKey, lpSubKeyName);
            // asssume success... don't care if this fails
            Result = ERROR_SUCCESS;
            *lphKey = NULL;
            break;
        }

    }
    else
    {
        Result = ERROR_BADKEY;
    }

    if (lpSubKeyName != NULL) {

        lpSubKeyName--;
        *lpSubKeyName = PrevChar;

    }

    return Result;

}

/*******************************************************************************
*
*  ImportRegFile
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     lpFileName, address of name of file to be imported.
*
*******************************************************************************/

VOID
PASCAL
ImportRegFile(HWND hWnd, LPTSTR lpFileName, HTREEITEM hComputerItem)
{

    TCHAR Char;
    LPCTSTR lpHeader;
    BOOL fNewRegistryFile;
#ifdef UNICODE
    UINT Temp, i;
    TCHAR StrToIntBuf[2];
    LPCTSTR lp50Header;
#endif // UNICODE
    DWORD cch;
    TCHAR tchBuffer[MAX_PATH] = {0};
    LPTSTR lpFilePart;

    g_FileErrorStringID = IDS_IMPFILEERRSUCCESS;

    // OPENREADFILE used to be OpenFile(), but there isn't any Unicode version
    // of that API, so now it's CreateFile().  But OpenFile searched the path
    // automatically, whereas CreateFile does not.  Corel's 'Perfect Office v6'
    // install app depends on the path being searched, so do it manually.

    cch = SearchPath(NULL,                // pointer to search path
                     lpFileName,          // pointer to filename
                     NULL,                // pointer to extension
                     ARRAYSIZE(tchBuffer), // size, in characters, of buffer
                     (TCHAR*)tchBuffer,   // pointer to buffer for found filename
                     &lpFilePart);        // pointer to pointer to file component);

    if ((cch != 0) && (cch <= MAX_PATH) && OPENREADFILE((TCHAR*)tchBuffer, s_FileIo.hFile)) {

        WORD wBOM;
        DWORD NumberOfBytesRead;

        s_FileIo.FileSizeDiv100 = GETFILESIZE(s_FileIo.hFile) / 100;
        s_FileIo.FileOffset = 0;
        s_FileIo.CharsAvailable = 0;
        s_FileIo.LastPercentage = 0;

        //
        // Read the first two bytes. If it's the Unicode byte order mark,
        // set a flag so all the rest of the file will be interpreted
        // as ANSI or Unicode text properly.
        //
        if (!READFILE(s_FileIo.hFile, &wBOM,
            sizeof(wBOM), &NumberOfBytesRead)) {

            g_FileErrorStringID = IDS_IMPFILEERRFILEREAD;
            goto exit_gracefully;
        }

        if (wBOM == s_UnicodeByteOrderMark)
            s_fTreatFileAsUnicode = TRUE;
        else {
            s_fTreatFileAsUnicode = FALSE;
            // We probably just read "RE" from "REGEDIT4".  Back up the file
            // position so the ANSI import routines get what they expect
            SetFilePointer(s_FileIo.hFile, -2, NULL, FILE_CURRENT);
        }

        //
        //  The following will force GetChar to read in the first block of data.
        //

        s_FileIo.BufferOffset = 0;

        SkipWhitespace();

        lpHeader = s_RegistryHeader;
        g_ImportFileVersion = 0;

# if 0
    Sit back, and I will tell ye a tale of woe.

    Win95 and NT 4 shipped with regedit compiled ANSI.  There are a couple
    of registry types on NT (namely REG_EXPAND_SZ and REG_MULTI_SZ) that
    weren't on Win95, and which regedit doesn't really understand.  regedit
    treats these registry types as hex binary streams.

    You can probably see where this is going.

    If you exported, say your user TEMP environment variable on NT 4
    using regedit, you'd get something that looked like this:

REGEDIT4

[HKEY_CURRENT_USER\Environment]
"TEMP"=hex(2):25,53,59,53,54,45,4d,44,52,49,56,45,25,5c,53,48,54,65,6d,70,00

    ...a nice, null-terminated ANSI string.  Nice, that is, until we decided
    to compile regedit UNICODE for NT 5.  A unicode regedit exports your
    user TEMP variable like this:

REGEDIT4

[HKEY_CURRENT_USER\Environment]
"TEMP"=hex(2):25,00,53,00,59,00,53,00,54,00,45,00,4d,00,44,00,52,00,49,00,56,\
  00,45,00,25,00,5c,00,53,00,48,00,54,00,65,00,6d,00,70,00,00,00

    ...mmmm.  Unicode.  Of course, a unicode regedit also expects anything
    it imports to have all those interspersed zeroes, too.  Otherwise,
    it dumps garbage into your registry.  All it takes is a -DUNICODE, and
    regedit is suddenly incompatible with the thousdands of existing .reg
    files out there.

    So just bump the version in the header to REGEDIT5 and be done with
    it, right?  Wrong.  The regedit on Win95 and NT 4 looks at the first
    character after the string "REGEDIT" and compares it to the digit "4".
    If that character is anything other than the digit "4", the parser
    assumes it is looking at a Windows 3.1 file.  Yep.  There will only
    ever be two formats, right?  Just Win95 and Win3.1.  That's all the
    world needs.

    So a completely new .reg file header had to be invented, so that the
    older, regedits of the world would simply regect the new,
    unicodized .reg files outright.  An NT 5 .reg file, exporting your user
    TEMP variable, looks like this:

Windows Registry Editor Version 5.00

[HKEY_CURRENT_USER\Environment]
"TEMP"=hex(2):25,00,53,00,59,00,53,00,54,00,45,00,4d,00,44,00,52,00,49,00,56,\
  00,45,00,25,00,5c,00,53,00,48,00,54,00,65,00,6d,00,70,00,00,00

    The parser is still not very good, but it does bother to convert that 5.00
    into a version number, so that future generations can bump it to 5.50 or
    6.00, and the regedit 5.00 that shipped with NT 5.00 will properly reject
    the files.
#endif // 0

#ifdef UNICODE
        //
        // Compare to the new .reg file header
        //
        lp50Header = s_WinNT50RegFileHeader;
        while (*lp50Header != 0) {

            if (MatchChar(*lp50Header))
                lp50Header = CharNext(lp50Header);

            else
                break;

        }

        //
        // If the above loop pushed lp50Header to its terminating null
        // character, then the header matches.
        //
        if (0 == *lp50Header) {

            SkipWhitespace();
            //
            // Now, decode the version number into a hex, _WIN32_WINNT
            // style version number.
            //
            StrToIntBuf[1] = 0;

            //
            // Any number of digits can come before the decimal point
            //
            while (!MatchChar(TEXT('.'))) {
                if (!GetChar(StrToIntBuf) || !IsCharAlphaNumeric(*StrToIntBuf)) {
                    g_FileErrorStringID = IDS_IMPFILEERRFORMATBAD;
                    goto exit_gracefully;
                }

                Temp = StrToInt(StrToIntBuf);
                // Hex version number, so move left four bits.
                g_ImportFileVersion <<= 4;
                g_ImportFileVersion += Temp;
            }

            //
            // Fixed at two digits after the decimal point
            //
            for (i = 0; i < 2; i++) {
                if (!GetChar(StrToIntBuf) || !IsCharAlphaNumeric(*StrToIntBuf)) {
                    g_FileErrorStringID = IDS_IMPFILEERRFORMATBAD;
                    goto exit_gracefully;
                }

                Temp = StrToInt(StrToIntBuf);
                // Hex version number, so move left four bits.
                g_ImportFileVersion <<= 4;
                g_ImportFileVersion += Temp;
            }

            //
            // For NT 5, reject any version number that isn't
            // 5.  This can be expanded into a switch statement
            // when the version number is bumped later.
            //
            if (0x0500 != g_ImportFileVersion) {
                g_FileErrorStringID = IDS_IMPFILEERRVERBAD;
                goto exit_gracefully;
            }
            else {
                SkipWhitespace();
                ImportNewerRegFile(hComputerItem);
            }

        } // if (0 == *lp50Header)
        //
        // It doesn't use the new .reg file header, so
        // it's not an NT 5.0+ registry file, so use the
        // older algorithm to see if it's a valid older registry file
        //
        else {
#endif // UNICODE

            while (*lpHeader != 0) {

                if (MatchChar(*lpHeader))
                    lpHeader = CharNext(lpHeader);

                else
                    break;

            }

            if (*lpHeader == 0) {

                //
                // Win95's and NT 4's regedit shipped with this line
                // of code.  It is the cause of all of the suffering above.
                // Notice the incorrect assumption:  "If the very next
                // character isn't a '4', then we must be reading
                // a Windows 3.1 registry file!"  Of course there won't
                // be a version 5 of regedit.  Version 4 was perfect!
                //
                fNewRegistryFile = MatchChar(TEXT('4'));

                SkipWhitespace();

                if (GetChar(&Char) && IsNewLine(Char)) {

                    if (fNewRegistryFile) {
                        g_ImportFileVersion = 0x0400;
                        ImportNewerRegFile(hComputerItem);
                    }
                    else {
                        g_ImportFileVersion = 0x0310;
                        ImportWin31RegFile(hComputerItem);
                    }
                }
            }
            else if (!hWnd)
            {
                // only registry script files can be imported without the
                // regedit window open
                g_FileErrorStringID = IDS_IMPFILEERRNOTASCRPT;
            }
            else if (!hComputerItem || (hComputerItem ==
                RegEdit_GetComputerItem(TreeView_GetSelection(g_RegEditData.hKeyTreeWnd))))
            {
                // It's not a registry file, but since the selected key is on the computer
                // they choose, try to import it as a binary registy key (regedt32 type)

                // remove the progress dialog
                if (g_hRegProgressWnd != NULL)
                {
                    EnableWindow(hWnd, TRUE);
                    DestroyWindow(g_hRegProgressWnd);
                    g_hRegProgressWnd = NULL;
                }

                RestoreBinaryKeyFile(hWnd, lpFileName);
            }
            else
            {
                g_FileErrorStringID = IDS_IMPFILEERRFORMATBAD;
            }
#ifdef UNICODE
        }
#endif // UNICODE

    } // if (OPENREADFILE...

    else {
        { TCHAR buff[250];
          wsprintf(buff, L"REGEDIT:  CreateFile failed, GetLastError() = %d\n", GetLastError());
        OutputDebugString(buff);
        }
        s_FileIo.hFile = NULL;
        g_FileErrorStringID = IDS_IMPFILEERRFILEOPEN;
    }

#ifdef UNICODE // Urefd labels generate warnings
exit_gracefully:
#endif // UNICODE
    if (s_FileIo.hFile) {
        CLOSEFILE(s_FileIo.hFile);
    }

}

//------------------------------------------------------------------------------
//  ImportBinaryKeyFile
//
//  DESCRIPTION:  Loads a binary key file at the currently selected key
//                This is the format of regedt32.exe saved keys
//
//  PARAMETERS:   LPTSTR lpFileName - file with the binary key
//------------------------------------------------------------------------------
void RestoreBinaryKeyFile(HWND hWnd, LPTSTR lpFileName)
{
    TCHAR achKeyName[MAXKEYNAME];
    HTREEITEM hSelectedTreeItem = TreeView_GetSelection(g_RegEditData.hKeyTreeWnd);
    KeyTree_GetKeyName(hSelectedTreeItem, achKeyName, ARRAYSIZE(achKeyName));

    // confirm that they want to replace the registry key
    if (InternalMessageBox(g_hInstance, hWnd,
        MAKEINTRESOURCE(IDS_CONFIRMRESTOREKEY), MAKEINTRESOURCE(IDS_CONFIRMRESKEYTITLE),
        MB_ICONQUESTION | MB_YESNO , achKeyName) == IDYES)
    {
        HRESULT hr;

        RegEdit_SetPrivilege(SE_RESTORE_NAME, TRUE);

        // attempt to load the file as a registry key
        if ((hr = RegRestoreKey(g_RegEditData.hCurrentSelectionKey, lpFileName,
            REG_FORCE_RESTORE)) != ERROR_SUCCESS)
        {
            switch (hr)
            {
            case ERROR_PRIVILEGE_NOT_HELD:
                g_FileErrorStringID = IDS_IMPFILEERRNOPRIV;
                break;

            case ERROR_FILE_NOT_FOUND:
                g_FileErrorStringID = IDS_IMPFILEERRNOFILE;
                break;

            case ERROR_INVALID_HANDLE:
                g_FileErrorStringID = IDS_IMPFILEERRINVALID;
                break;

            default:
                g_FileErrorStringID = IDS_IMPFILEERRFORMATBAD;
                break;
            }
        }

        RegEdit_SetPrivilege(SE_RESTORE_NAME, FALSE);
    }
    else
    {
        g_FileErrorStringID = IDS_IMPFILEERRORCANCEL;
    }
}


/*******************************************************************************
*
*  ImportWin31RegFile
*
*  DESCRIPTION:
*     Imports the contents of a Windows 3.1 style registry file into the
*     registry.
*
*     We scan over the file looking for lines of the following type:
*        HKEY_CLASSES_ROOT\keyname = value_data
*        HKEY_CLASSES_ROOT\keyname =value_data
*        HKEY_CLASSES_ROOT\keyname value_data
*        HKEY_CLASSES_ROOT\keyname                          (null value data)
*
*     In all cases, any number of spaces may follow 'keyname'.  Although we
*     only document the first syntax, the Windows 3.1 Regedit handled all of
*     these formats as valid, so this version will as well (fortunately, it
*     doesn't make the parsing any more complex!).
*
*     Note, we also support replacing HKEY_CLASSES_ROOT with \.classes above
*     which must come from some early releases of Windows.
*
*  PARAMETERS: HTREEITEM hComputerItem -  computer item to receive imported key
*
*******************************************************************************/

VOID ImportWin31RegFile(HTREEITEM hComputerItem)
{

    HKEY hKey;
    TCHAR Char;
    BOOL fSuccess;
    LPCTSTR lpClassesRoot;
    TCHAR KeyName[MAXKEYNAME];
    UINT Index;

    //
    //  Keep an open handle to the classes root.  We may prevent some
    //  unneccessary flushing.
    //
    hKey = Regedit_GetRootKeyFromComputer(hComputerItem,
        g_RegistryRoots[INDEX_HKEY_CLASSES_ROOT].lpKeyName);

    if (RegOpenKeyEx(hKey, NULL, 0, KEY_SET_VALUE, &hKey) != ERROR_SUCCESS)
    {
        g_FileErrorStringID = IDS_IMPFILEERRREGOPEN;
        return;
    }

    while (TRUE) {

        //
        //  Check for the end of file condition.
        //

        if (!GetChar(&Char))
            break;

        UngetChar();                    //  Not efficient, but works for now.

        //
        //  Match the beginning of the line against one of the two aliases for
        //  HKEY_CLASSES_ROOT.
        //

        if (MatchChar(TEXT('\\')))
            lpClassesRoot = s_OldWin31RegFileRoot;

        else
            lpClassesRoot = g_RegistryRoots[INDEX_HKEY_CLASSES_ROOT].lpKeyName;

        fSuccess = TRUE;

        while (*lpClassesRoot != 0) {

            if (!MatchChar(*lpClassesRoot++)) {

                fSuccess = FALSE;
                break;

            }

        }

        //
        //  Make sure that we have a backslash seperating one of the aliases
        //  from the keyname.
        //

        if (fSuccess)
            fSuccess = MatchChar(TEXT('\\'));

        if (fSuccess) {

            //
            //  We've found one of the valid aliases, so read in the keyname.
            //

            //  fSuccess = TRUE;        //  Must be TRUE if we're in this block
            Index = 0;

            while (GetChar(&Char)) {

                if (Char == TEXT(' ') || IsNewLine(Char))
                    break;

                //
                //  Make sure that the keyname buffer doesn't overflow.  We must
                //  leave room for a terminating null.
                //

                if (Index >= (sizeof(KeyName)/sizeof(TCHAR)) - 1) {

                    fSuccess = FALSE;
                    break;

                }

                KeyName[Index++] = Char;

            }

            if (fSuccess)
            {
                UINT cMaxDataLength = ALLOCATION_INCR;
                PBYTE pbValueDataBuffer;

                KeyName[Index] = 0;

                //
                //  Now see if we have a value to assign to this keyname.
                //

                SkipWhitespace();

                if (MatchChar(TEXT('=')))
                    MatchChar(TEXT(' '));

                //  fSuccess = TRUE;    //  Must be TRUE if we're in this block
                Index = 0;

                pbValueDataBuffer = LocalAlloc(LPTR, cMaxDataLength);
                fSuccess = (pbValueDataBuffer != NULL);

                while (GetChar(&Char) && fSuccess)
                {

                    if (IsNewLine(Char))
                        break;

                    //
                    //  Make sure that the value data buffer doesn't overflow.
                    //  Because this is always string data, we must leave room
                    //  for a terminating null.
                    //

                    if (Index >= cMaxDataLength - 1)
                    {
                        PBYTE pbValueData =
                            LocalReAlloc(pbValueDataBuffer, cMaxDataLength + ALLOCATION_INCR, LMEM_MOVEABLE);

                        fSuccess = (pbValueData != NULL);
                        if (!fSuccess)
                        {
                            break;
                        }
                        else
                        {
                            pbValueDataBuffer = pbValueData;
                            cMaxDataLength += ALLOCATION_INCR;
                        }
                    }

                    ((PTSTR)pbValueDataBuffer)[Index++] = Char;

                }

                if (fSuccess)
                {

                    ((PTSTR)pbValueDataBuffer)[Index] = 0;

                    if (RegSetValue(hKey, KeyName, REG_SZ, (LPCTSTR)pbValueDataBuffer,
                        Index*sizeof(TCHAR)) != ERROR_SUCCESS)
                        g_FileErrorStringID = IDS_IMPFILEERRREGSET;
                }
                else
                {
                    g_FileErrorStringID = IDS_NOMEMORY;
                }

                if (pbValueDataBuffer)
                {
                    LocalFree(pbValueDataBuffer);
                }
            }

        }

        //
        //  Somewhere along the line, we had a parsing error, so resynchronize
        //  on the next line.
        //

        if (!fSuccess)
            SkipPastEndOfLine();

    }

    RegFlushKey(hKey);
    RegCloseKey(hKey);

}

/*******************************************************************************
*
*  ImportNewerRegFile
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
NEAR PASCAL
ImportNewerRegFile(HTREEITEM hComputerItem)
{

    HKEY hLocalMachineKey;
    HKEY hUsersKey;
    HKEY hKey;
    TCHAR Char;

#ifdef WINNT
    hLocalMachineKey = NULL;
    hUsersKey = NULL;
#else
    //
    //  Keep open handles for the predefined roots to prevent the registry
    //  library from flushing after every single RegOpenKey/RegCloseKey
    //  operation.
    //

    RegOpenKey(HKEY_LOCAL_MACHINE, NULL, &hLocalMachineKey);
    RegOpenKey(HKEY_USERS, NULL, &hUsersKey);

#ifdef DEBUG
    if (hLocalMachineKey == NULL)
        DebugPrintf(("Unable to open HKEY_LOCAL_MACHINE\n\r"));
    if (hUsersKey == NULL)
        DebugPrintf(("Unable to open HKEY_USERS\n\r"));
#endif
#endif

    hKey = NULL;

    while (TRUE) {

        SkipWhitespace();

        //
        //  Check for the end of file condition.
        //

        if (!GetChar(&Char))
            break;

        switch (Char) {

            case TEXT('['):
                //
                //  If a registry key is currently open, we must close it first.
                //  If ParseHeader happens to fail (for example, no closing
                //  bracket), then hKey will be NULL and any values that we
                //  parse must be ignored.
                //

                if (hKey != NULL) {

                    RegCloseKey(hKey);
                    hKey = NULL;

                }

                ParseHeader(&hKey, hComputerItem);

                break;

            case TEXT('"'):
                //
                //  As noted above, if we don't have an open registry key, then
                //  just skip the line.
                //

                if (hKey != NULL)
                    ParseValuename(hKey);

                else
                    SkipPastEndOfLine();

                break;

            case TEXT('@'):
                //
                //
                //

                if (hKey != NULL)
                    ParseValue(hKey, NULL);

                else
                    SkipPastEndOfLine();

                break;

            case TEXT(';'):
                //
                //  This line is a comment so just dump the rest of it.
                //

                SkipPastEndOfLine();

                break;

            default:
                if (IsNewLine(Char))
                    break;

                SkipPastEndOfLine();

                break;

        }

    }

    if (hKey != NULL)
        RegCloseKey(hKey);

    if (hUsersKey != NULL)
        RegCloseKey(hUsersKey);

    if (hLocalMachineKey != NULL)
        RegCloseKey(hLocalMachineKey);

}

/*******************************************************************************
*
*  ParseHeader
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

// REARCHITECT - each subkeyname can be MAXKEYNAME in size
// ideally - we should handle unlimited size names
// let's at least handle bigger names for now
// at least a depth of 10 with maximum length subkey names

#define SIZE_FULL_KEYNAME ((MAXKEYNAME + 40)*10)

VOID ParseHeader(LPHKEY lphKey, HTREEITEM hComputerItem)
{

    TCHAR FullKeyName[SIZE_FULL_KEYNAME];
    int CurrentIndex;
    int LastRightBracketIndex;
    TCHAR Char;
    UINT uOperation = ERK_CREATE;

    CurrentIndex = 0;
    LastRightBracketIndex = -1;

    if (!GetChar(&Char))
        return;

    if (Char == TEXT('-')) {
        if (!GetChar(&Char))
            return;
        uOperation = ERK_DELETE;
    }

    do {

        if (IsNewLine(Char))
            break;

        if (Char == TEXT(']'))
            LastRightBracketIndex = CurrentIndex;

        FullKeyName[CurrentIndex++] = Char;

        if (CurrentIndex == SIZE_FULL_KEYNAME) {

            do {

                if (Char == TEXT(']'))
                    LastRightBracketIndex = -1;

                if (IsNewLine(Char))
                    break;

            }   while (GetChar(&Char));

            break;

        }

    } while (GetChar(&Char));

    if (LastRightBracketIndex != -1)
    {
        FullKeyName[LastRightBracketIndex] = 0;

        switch (EditRegistryKey(hComputerItem, lphKey, FullKeyName, uOperation))
        {
            //
            // Be afraid of adding code to handle more error cases here.
            //
            // We broke Picture Publisher 8.0 by adding an ERROR_BADKEY
            // case.  As part of their setup, they run regedit on a v4
            // reg file that has a bad section, which EditRegistryKey
            // will fail to parse with ERROR_BADKEY.  We need to keep
            // chugging along in that case like Win2K did, or else we
            // break their setup.
            //
            case ERROR_CANTOPEN:
                g_FileErrorStringID = IDS_IMPFILEERRREGOPEN;
                break;
        }

    }

}

/*******************************************************************************
*
*  ParseValuename
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
NEAR PASCAL
ParseValuename(
    HKEY hKey
    )
{
    PORTVALUEPARAM PortValueParam;
    PortValueParam.cbData = MAXVALUENAME_LENGTH * sizeof(TCHAR);
    PortValueParam.pbData = LocalAlloc(LPTR, PortValueParam.cbData);

    if (PortValueParam.pbData)
    {
        if (ParseString(&PortValueParam))
        {
            ParseValue(hKey, (PTSTR)PortValueParam.pbData);
        }
        else
        {
            SkipPastEndOfLine();
        }
        LocalFree(PortValueParam.pbData);
    }
}

VOID
NEAR PASCAL
ParseValue(
           HKEY hKey,
           LPCTSTR lpszValueName
           )
{
    BOOL fSuccess = TRUE;
    BOOL fSkipPastLine = FALSE;
    DWORD Type;
    DWORD cbData = 0;
    DWORD cbMaxData = ALLOCATION_INCR;
    LPCTSTR lpPrefix;
    PBYTE pbValueDataBuffer;

    SkipWhitespace();

    if (!MatchChar(TEXT('=')))
    {
        fSuccess = FALSE;
        fSkipPastLine = TRUE;
    }
    else
    {

        SkipWhitespace();

        pbValueDataBuffer = LocalAlloc(LPTR, cbMaxData);
        if (!pbValueDataBuffer)
        {
            g_FileErrorStringID = IDS_IMPFILEERRREGSET;
            fSuccess = FALSE;
        }
        else
        {
            //
            //  REG_SZ.
            //
            //  "ValueName" = "string of text"
            //

            if (MatchChar(TEXT('"')))
            {

                //  FEATURE:  Line continuations for strings?

                PORTVALUEPARAM PortValueParam;
                PortValueParam.pbData = pbValueDataBuffer;
                PortValueParam.cbData = cbMaxData;

                if (!ParseString(&PortValueParam) || !ParseEndOfLine())
                {
                    fSuccess = FALSE;
                    fSkipPastLine = TRUE;
                }

                // pointer might have been swapped for one with more memory
                pbValueDataBuffer = PortValueParam.pbData;
                cbData = PortValueParam.cbData;
                Type = REG_SZ;

            }

            //
            //  REG_DWORD.
            //
            //  "ValueName" = dword: 12345678
            //

            else if (MatchChar(s_DwordPrefix[0])) {

                lpPrefix = &s_DwordPrefix[1];

                while (*lpPrefix != 0)
                {
                    if (!MatchChar(*lpPrefix++))
                    {
                        fSuccess = FALSE;
                        fSkipPastLine = TRUE;
                    }
                }

                if (fSuccess)
                {
                    SkipWhitespace();

                    if (!ParseHexDword((LPDWORD) pbValueDataBuffer) || !ParseEndOfLine())
                    {
                        fSuccess = FALSE;
                        fSkipPastLine = TRUE;
                    }

                    Type = REG_DWORD;
                    cbData = sizeof(DWORD);
                }
            }
            else if (MatchChar('-'))
            {
                if (!ParseEndOfLine())
                {
                    fSuccess = FALSE;
                    fSkipPastLine = TRUE;
                }
                else
                {
                    RegDeleteValue(hKey, lpszValueName);
                    fSuccess = FALSE;
                }
            }

            //
            //  REG_BINARY and other.
            //
            //  "ValueName" = hex: 00 , 11 , 22
            //  "ValueName" = hex(12345678): 00, 11, 22
            //

            else {

                lpPrefix = s_HexPrefix;

                while (*lpPrefix != 0)
                {
                    if (!MatchChar(*lpPrefix++))
                    {
                        fSuccess = FALSE;
                        fSkipPastLine = TRUE;
                    }
                }

                if (fSuccess)
                {
                    //
                    //  Check if this is a type of registry data that we don't directly
                    //  support.  If so, then it's just a dump of hex data of the specified
                    //  type.
                    //

                    if (MatchChar(TEXT('(')))
                    {
                        if (!ParseHexDword(&Type) || !MatchChar(TEXT(')')))
                        {
                            fSuccess = FALSE;
                            fSkipPastLine = TRUE;
                        }
                    }

                    else
                        Type = REG_BINARY;

                    if (fSuccess)
                    {
                        PORTVALUEPARAM PortValueParam;
                        PortValueParam.pbData = pbValueDataBuffer;
                        PortValueParam.cbData = cbMaxData;

                        if (!MatchChar(TEXT(':')) || !ParseHexSequence(&PortValueParam) ||
                            !ParseEndOfLine())
                        {
                            fSuccess = FALSE;
                            fSkipPastLine = TRUE;
                        }

                        // pointer might have been swapped for one with more memory
                        pbValueDataBuffer = PortValueParam.pbData;
                        cbData = PortValueParam.cbData;
                    }
                }
            }

            if (fSuccess)
            {

#ifdef UNICODE
                //
                // If we're compiled UNICODE and we're reading an older, ANSI .reg
                // file, we have to write all of the data to the registry using
                // RegSetValueExA, because it was read from the registry using
                // RegQueryValueExA.
                //
                if ((g_ImportFileVersion < 0x0500) && ((REG_EXPAND_SZ == Type) || (REG_MULTI_SZ == Type)))
                {
                    CHAR AnsiValueName[MAXVALUENAME_LENGTH];
                    AnsiValueName[0] = 0;

                    //
                    // It's much easier to convert the value name to ANSI
                    // and call RegSetValueExA than to try to convert
                    // a REG_MULTI_SZ to Unicode before calling RegSetValueExW.
                    // We don't lose anything because this is coming from a
                    // downlevel .reg file that could only contain ANSI characters
                    // to begin with.
                    //
                    WideCharToMultiByte(
                        CP_THREAD_ACP,
                        0,
                        lpszValueName,
                        -1,
                        AnsiValueName,
                        MAXVALUENAME_LENGTH,
                        NULL,
                        NULL
                        );

                    if (RegSetValueExA(
                        hKey,
                        AnsiValueName,
                        0,
                        Type,
                        pbValueDataBuffer,
                        cbData)
                        != ERROR_SUCCESS)
                        g_FileErrorStringID = IDS_IMPFILEERRREGSET;
                }
                else {
#endif // UNICODE
                    if (RegSetValueEx(hKey, lpszValueName, 0, Type, pbValueDataBuffer, cbData) !=
                        ERROR_SUCCESS)
                        g_FileErrorStringID = IDS_IMPFILEERRREGSET;
#ifdef UNICODE
                }
#endif // UNICODE

            }
            LocalFree(pbValueDataBuffer);
        }
    }

    if (fSkipPastLine)
    {
        SkipPastEndOfLine();
    }
}

/*******************************************************************************
*
*  ParseString
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL
NEAR PASCAL
ParseString(LPPORTVALUEPARAM pPortValueParam)
{
    TCHAR Char;
    DWORD cbMaxStringData;
    DWORD cbStringData;


    LPTSTR psz = (LPTSTR)pPortValueParam->pbData; // this one is incremented
    cbMaxStringData = pPortValueParam->cbData;
    cbStringData = sizeof(TCHAR);                   //  Account for the null terminator

    while (GetChar(&Char))
    {
        if (cbStringData >= cbMaxStringData)
        {
            // allocate a bigger buffer
            PBYTE pbValueData =
                LocalReAlloc(pPortValueParam->pbData, cbMaxStringData + ALLOCATION_INCR, LMEM_MOVEABLE);
            if (pbValueData)
            {
                pPortValueParam->pbData = pbValueData;
                // incr psz to next char in new buffer
                psz = (LPTSTR)(pPortValueParam->pbData + (cbMaxStringData - sizeof(TCHAR)));

                cbMaxStringData += ALLOCATION_INCR;
            }
            else
            {
                break;
            }
        }

        switch (Char) {

            case TEXT('\\'):
                if (!GetChar(&Char))
                    return FALSE;

                switch (Char) {

                    case TEXT('\\'):
                        *psz++ = TEXT('\\');
                        break;

                    case TEXT('"'):
                        *psz++ = TEXT('"');
                        break;

                    case TEXT('r'):
                        if(g_fMultiLineStrings) 
                        {
                            *psz++ = TEXT('\r');
                            break;
                        }
                        else 
                        {
                            DebugPrintf(("ParseString:  Invalid escape sequence"));
                            return FALSE;
                        }

                    case TEXT('n'):
                        if(g_fMultiLineStrings) 
                        {
                            *psz++ = TEXT('\n');
                            break;
                        }
                        else 
                        {
                            DebugPrintf(("ParseString:  Invalid escape sequence"));
                            return FALSE;
                        }

                    default:
                        DebugPrintf(("ParseString:  Invalid escape sequence"));
                        return FALSE;

                }
                break;

            case TEXT('"'):
                *psz = 0;
                pPortValueParam->cbData = cbStringData;
                return TRUE;

            default:
                if (IsNewLine(Char))
                    return FALSE;

                *psz++ = Char;
                break;

        }

        cbStringData += sizeof(TCHAR);

    }

    return FALSE;

}


/*******************************************************************************
*
*  ParseHexSequence
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL
NEAR PASCAL
ParseHexSequence(LPPORTVALUEPARAM pPortValueParam)
{
    BOOL  fSuccess = TRUE;
    DWORD cbHexData = 0;
    DWORD cbMaxStringData = pPortValueParam->cbData;
    LPBYTE lpHexData = pPortValueParam->pbData;

    do
    {
        if (cbHexData >= cbMaxStringData)
        {
            // allocate a bigger buffer
            PBYTE pbValueData = LocalReAlloc(pPortValueParam->pbData,
                cbMaxStringData + ALLOCATION_INCR, LMEM_MOVEABLE);
            if (pbValueData)
            {
                pPortValueParam->pbData = pbValueData;
                // incr psz to next char in new buffer
                lpHexData = pPortValueParam->pbData + cbMaxStringData;

                cbMaxStringData += ALLOCATION_INCR;
            }
            else
            {
                fSuccess = FALSE;
                break;
            }
        }

        SkipWhitespace();

        if (MatchChar(TEXT('\\')) && !ParseEndOfLine())
        {
            fSuccess = FALSE;
            break;
        }

        SkipWhitespace();

        if (!ParseHexByte(lpHexData++))
            break;

        cbHexData++;

        SkipWhitespace();

    }   while (MatchChar(TEXT(',')));

    pPortValueParam->cbData = cbHexData;

    return fSuccess;

}

/*******************************************************************************
*
*  ParseHexDword
*
*  DESCRIPTION:
*     Parses a one dword hexadecimal string from the registry file stream and
*     converts it to a binary number.  A maximum of eight hex digits will be
*     parsed from the stream.
*
*  PARAMETERS:
*     lpByte, location to store binary number.
*     (returns), TRUE if a hexadecimal dword was parsed, else FALSE.
*
*******************************************************************************/

BOOL
NEAR PASCAL
ParseHexDword(
    LPDWORD lpDword
    )
{

    UINT CountDigits;
    DWORD Dword;
    BYTE Byte;

    Dword = 0;
    CountDigits = 0;

    while (TRUE) {

        if (!ParseHexDigit(&Byte))
            break;

        Dword = (Dword << 4) + (DWORD) Byte;

        if (++CountDigits == 8)
            break;

    }

    *lpDword = Dword;

    return CountDigits != 0;

}

/*******************************************************************************
*
*  ParseHexByte
*
*  DESCRIPTION:
*     Parses a one byte hexadecimal string from the registry file stream and
*     converts it to a binary number.
*
*  PARAMETERS:
*     lpByte, location to store binary number.
*     (returns), TRUE if a hexadecimal byte was parsed, else FALSE.
*
*******************************************************************************/

BOOL
NEAR PASCAL
ParseHexByte(
    LPBYTE lpByte
    )
{

    BYTE SecondDigit;

    if (ParseHexDigit(lpByte)) {

        if (ParseHexDigit(&SecondDigit))
            *lpByte = (BYTE) ((*lpByte << 4) | SecondDigit);

        return TRUE;

    }

    else
        return FALSE;

}

/*******************************************************************************
*
*  ParseHexDigit
*
*  DESCRIPTION:
*     Parses a hexadecimal character from the registry file stream and converts
*     it to a binary number.
*
*  PARAMETERS:
*     lpDigit, location to store binary number.
*     (returns), TRUE if a hexadecimal digit was parsed, else FALSE.
*
*******************************************************************************/

BOOL
NEAR PASCAL
ParseHexDigit(
    LPBYTE lpDigit
    )
{

    TCHAR Char;
    BYTE Digit;

    if (GetChar(&Char)) {

        if (Char >= TEXT('0') && Char <= TEXT('9'))
            Digit = (BYTE) (Char - TEXT('0'));

        else if (Char >= TEXT('a') && Char <= TEXT('f'))
            Digit = (BYTE) (Char - TEXT('a') + 10);

        else if (Char >= TEXT('A') && Char <= TEXT('F'))
            Digit = (BYTE) (Char - TEXT('A') + 10);

        else {

            UngetChar();

            return FALSE;

        }

        *lpDigit = Digit;

        return TRUE;

    }

    return FALSE;

}

/*******************************************************************************
*
*  ParseEndOfLine
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL
NEAR PASCAL
ParseEndOfLine(
    VOID
    )
{

    TCHAR Char;
    BOOL fComment;
    BOOL fFoundOneEndOfLine;
    BOOL fEOF;

    fComment = FALSE;
    fFoundOneEndOfLine = FALSE;
    fEOF = TRUE;

    while (GetChar(&Char)) {

        if (IsWhitespace(Char))
            continue;

        if (IsNewLine(Char)) {

            fComment = FALSE;
            fFoundOneEndOfLine = TRUE;

        }

        //
        //  Like .INIs and .INFs, comments begin with a semicolon character.
        //

        else if (Char == TEXT(';'))
            fComment = TRUE;

        else if (!fComment) {

            UngetChar();
            fEOF = FALSE;
            break;

        }

    }

    return fFoundOneEndOfLine || fEOF;

}

/*******************************************************************************
*
*  SkipWhitespace
*
*  DESCRIPTION:
*     Advances the registry file pointer to the first character past any
*     detected whitespace.
*
*  PARAMETERS:
*     (none).
*
*******************************************************************************/

VOID
NEAR PASCAL
SkipWhitespace(
    VOID
    )
{

    TCHAR Char;

    while (GetChar(&Char)) {

        if (!IsWhitespace(Char)) {

            UngetChar();
            break;

        }

    }

}

/*******************************************************************************
*
*  SkipPastEndOfLine
*
*  DESCRIPTION:
*     Advances the registry file pointer to the first character past the first
*     detected new line character.
*
*  PARAMETERS:
*     (none).
*
*******************************************************************************/

VOID
NEAR PASCAL
SkipPastEndOfLine(
    VOID
    )
{

    TCHAR Char;

    while (GetChar(&Char)) {

        if (IsNewLine(Char))
            break;

    }

    while (GetChar(&Char)) {

        if (!IsNewLine(Char)) {

            UngetChar();
            break;

        }

    }

}

/*******************************************************************************
*
*  GetChar
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL
NEAR PASCAL
GetChar(
    PTCHAR lpChar
    )
{

    FILE_NUMBYTES NumberOfBytesRead;
    UINT NewPercentage;

    // If we're at the end of the buffer, read some more.
    // Initially BufferOffset and CharsAvailable will be 0
    if (s_FileIo.BufferOffset == s_FileIo.CharsAvailable) {

        if (TRUE == s_fTreatFileAsUnicode) {
            if (!READFILE(s_FileIo.hFile, s_FileIo.Buffer,
                SIZE_FILE_IO_BUFFER, &NumberOfBytesRead)) {

                g_FileErrorStringID = IDS_IMPFILEERRFILEREAD;
                return FALSE;
            }

            s_FileIo.CharsAvailable = ((int) NumberOfBytesRead / 2);
        }
        else {
            if (!READFILE(s_FileIo.hFile, s_FileIo.ConversionBuffer,
                SIZE_FILE_IO_BUFFER, &NumberOfBytesRead)) {

                g_FileErrorStringID = IDS_IMPFILEERRFILEREAD;
                return FALSE;
            }

            {
                int i;

                i = MultiByteToWideChar(
                        CP_THREAD_ACP,
                        MB_PRECOMPOSED,
                        s_FileIo.ConversionBuffer,
                        NumberOfBytesRead,
                        s_FileIo.Buffer,
                        SIZE_FILE_IO_BUFFER
                        );

                s_FileIo.CharsAvailable = i;
            }
        }

        s_FileIo.BufferOffset = 0;
        s_FileIo.FileOffset += NumberOfBytesRead;

        if (s_FileIo.FileSizeDiv100 != 0) {

            NewPercentage = ((UINT) (s_FileIo.FileOffset /
                s_FileIo.FileSizeDiv100));

            if (NewPercentage > 100)
                NewPercentage = 100;

        }

        else
            NewPercentage = 100;

        if (s_FileIo.LastPercentage != NewPercentage) {

            s_FileIo.LastPercentage = NewPercentage;
            ImportRegFileUICallback(NewPercentage);

        }

    }

    if (s_FileIo.BufferOffset >= s_FileIo.CharsAvailable)
        return FALSE;

    *lpChar = s_FileIo.Buffer[s_FileIo.BufferOffset++];

    return TRUE;

}

/*******************************************************************************
*
*  UngetChar
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
NEAR PASCAL
UngetChar(
    VOID
    )
{

#ifdef DEBUG
    if (s_FileIo.fValidateUngetChar)
        DebugPrintf(("REGEDIT ERROR: Too many UngetChar's called!\n\r"));
#endif

    s_FileIo.BufferOffset--;

}

/*******************************************************************************
*
*  MatchChar
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL
NEAR PASCAL
MatchChar(
    TCHAR CharToMatch
    )
{

    BOOL fMatch;
    TCHAR NextChar;

    fMatch = FALSE;

    if (GetChar(&NextChar)) {

        if (CharToMatch == NextChar)
            fMatch = TRUE;

        else
            UngetChar();

    }

    return fMatch;

}

/*******************************************************************************
*
*  IsWhitespace
*
*  DESCRIPTION:
*     Checks if the given character is whitespace.
*
*  PARAMETERS:
*     Char, character to check.
*     (returns), TRUE if character is whitespace, else FALSE.
*
*******************************************************************************/

BOOL
NEAR PASCAL
IsWhitespace(
    TCHAR Char
    )
{

    return Char == TEXT(' ') || Char == TEXT('\t');

}

/*******************************************************************************
*
*  IsNewLine
*
*  DESCRIPTION:
*     Checks if the given character is a new line character.
*
*  PARAMETERS:
*     Char, character to check.
*     (returns), TRUE if character is a new line, else FALSE.
*
*******************************************************************************/

BOOL
NEAR PASCAL
IsNewLine(
    TCHAR Char
    )
{

    return Char == TEXT('\n') || Char == TEXT('\r');

}

/*******************************************************************************
*
*  ExportWinNT50RegFile
*
*  DESCRIPTION:
*      Exports an NT 5.0, unicode registry file.  Use this export function
*      for all future .reg file writing.
*
*  PARAMETERS:
*
*******************************************************************************/
VOID ExportWinNT50RegFile(LPTSTR lpFileName, LPTSTR lpSelectedPath)
{
    HKEY hKey;
    TCHAR SelectedPath[SIZE_SELECTED_PATH];
    HTREEITEM hSelectedTreeItem = TreeView_GetSelection(g_RegEditData.hKeyTreeWnd);

    g_FileErrorStringID = IDS_EXPFILEERRSUCCESS;

    if (lpSelectedPath != NULL && EditRegistryKey(RegEdit_GetComputerItem(hSelectedTreeItem),
        &hKey, lpSelectedPath, ERK_OPEN) != ERROR_SUCCESS)
    {

        g_FileErrorStringID = IDS_EXPFILEERRBADREGPATH;
        return;

    }

    if (OPENWRITEFILE(lpFileName, s_FileIo.hFile)) {

        DWORD dwNumberOfBytesWritten;

        s_FileIo.BufferOffset = 0;
        s_FileIo.CurrentColumn = 0;

        WRITEFILE(s_FileIo.hFile, &s_UnicodeByteOrderMark, sizeof(s_UnicodeByteOrderMark), &dwNumberOfBytesWritten);

        PutLiteral(s_WinNT50RegFileHeader);
        PutLiteral(TEXT(" "));
        PutLiteral(s_WinNT50RegFileVersion);
        PutLiteral(TEXT("\n\n"));

        if (lpSelectedPath != NULL) {

            STRCPY(SelectedPath, lpSelectedPath);
            PutBranch(hKey, SelectedPath);

        }

        else
        {
            HTREEITEM hComputerItem = RegEdit_GetComputerItem(hSelectedTreeItem);

            STRCPY(SelectedPath,
                g_RegistryRoots[INDEX_HKEY_LOCAL_MACHINE].lpKeyName);

            PutBranch(Regedit_GetRootKeyFromComputer(hComputerItem, SelectedPath), SelectedPath);

            STRCPY(SelectedPath,
                g_RegistryRoots[INDEX_HKEY_USERS].lpKeyName);
            PutBranch(Regedit_GetRootKeyFromComputer(hComputerItem, SelectedPath), SelectedPath);

        }

        FlushIoBuffer();

        CLOSEFILE(s_FileIo.hFile);

    }

    else
        g_FileErrorStringID = IDS_EXPFILEERRFILEOPEN;

    if (lpSelectedPath != NULL)
        RegCloseKey(hKey);

}


//------------------------------------------------------------------------------
// ExportRegedt32File
//
// DESCRIPTION: This function exports file in the format of Regedt32.
//              The binary is key is stored to a file without any key path info
//
// PARAMETERS:  LPTSTR lpFileName
//              LPTSTR lpSelectedPath
//------------------------------------------------------------------------------
void ExportRegedt32File(LPTSTR lpFileName, LPTSTR lpSelectedPath)
{
    HKEY hKey = NULL;
    HTREEITEM hSelectedTreeItem = TreeView_GetSelection(g_RegEditData.hKeyTreeWnd);

    g_FileErrorStringID = IDS_EXPFILEERRSUCCESS;

    if (lpSelectedPath == NULL || EditRegistryKey(RegEdit_GetComputerItem(hSelectedTreeItem),
        &hKey, lpSelectedPath, ERK_OPEN) == ERROR_SUCCESS)
    {
        HRESULT hr;

        RegEdit_SetPrivilege(SE_BACKUP_NAME, TRUE);

        //
        // If a file with the same name already exists, we need to delete
        // it ourselves before calling RegSaveKey or that call will fail.
        //
        DeleteFile(lpFileName);

        if ((hr = RegSaveKey(hKey, lpFileName, NULL)) != ERROR_SUCCESS)
        {
            switch (hr)
            {
            case ERROR_PRIVILEGE_NOT_HELD:
                g_FileErrorStringID = IDS_EXPFILEERRNOPRIV;
                break;

            case ERROR_INVALID_HANDLE:
                g_FileErrorStringID = IDS_EXPFILEERRINVALID;
                break;

            default:
                g_FileErrorStringID = IDS_EXPFILEERRFILEWRITE;
                break;
            }

            // RegSaveKey created an empty file
            DeleteFile(lpFileName);
        }

        RegEdit_SetPrivilege(SE_BACKUP_NAME, FALSE);
    }
    else
    {
        g_FileErrorStringID = IDS_EXPFILEERRBADREGPATH;
    }
}


/*******************************************************************************
*
*  ExportWin40RegFile
*
*  DESCRIPTION:
*      This function is only kept around to export old, ANSI, regedit 4 .reg
*      files.  Don't touch it except to fix bugs.  Meddling with this code
*      path will result in .reg files that can't be read by older verions
*      of regedit, which is the whole reason this code path is here.  Meddle
*      with ExportWinNT50RegFile if you want to break backwards compatibility.
*
*  PARAMETERS:
*
*******************************************************************************/

VOID ExportWin40RegFile(LPTSTR lpFileName, LPTSTR lpSelectedPath)
{
    HKEY hKey;
    TCHAR SelectedPath[SIZE_SELECTED_PATH];
    HTREEITEM hSelectedTreeItem = TreeView_GetSelection(g_RegEditData.hKeyTreeWnd);

    g_FileErrorStringID = IDS_EXPFILEERRSUCCESS;

    if (lpSelectedPath != NULL && EditRegistryKey(RegEdit_GetComputerItem(hSelectedTreeItem),
        &hKey, lpSelectedPath, ERK_OPEN) != ERROR_SUCCESS)
    {

        g_FileErrorStringID = IDS_EXPFILEERRBADREGPATH;
        return;

    }

    if (OPENWRITEFILE(lpFileName, s_FileIo.hFile))
    {

        s_FileIo.BufferOffset = 0;
        s_FileIo.CurrentColumn = 0;

        PutLiteral(s_Win40RegFileHeader);

        if (lpSelectedPath != NULL) {

            STRCPY(SelectedPath, lpSelectedPath);
            PutBranch(hKey, SelectedPath);

        }

        else {

            STRCPY(SelectedPath,
                g_RegistryRoots[INDEX_HKEY_LOCAL_MACHINE].lpKeyName);
            PutBranch(HKEY_LOCAL_MACHINE, SelectedPath);

            STRCPY(SelectedPath,
                g_RegistryRoots[INDEX_HKEY_USERS].lpKeyName);
            PutBranch(HKEY_USERS, SelectedPath);

        }

        FlushIoBuffer();

        CLOSEFILE(s_FileIo.hFile);

    }

    else
        g_FileErrorStringID = IDS_EXPFILEERRFILEOPEN;

    if (lpSelectedPath != NULL)
        RegCloseKey(hKey);

}

/*******************************************************************************
*
*  PutBranch
*
*  DESCRIPTION:
*     Writes out all of the value names and their data and recursively calls
*     this routine for all of the key's subkeys to the registry file stream.
*
*  PARAMETERS:
*     hKey, registry key to write to file.
*     lpFullKeyName, string that gives the full path, including the root key
*        name, of the hKey.
*
*******************************************************************************/

VOID
NEAR PASCAL
PutBranch(
    HKEY hKey,
    LPTSTR lpFullKeyName
    )
{

    LONG RegError;
    DWORD EnumIndex;
    DWORD cchValueName;
    DWORD cbValueData;
    DWORD Type;
    LPTSTR lpSubKeyName;
    HKEY hSubKey;
    int nLenFullKey;
    LPTSTR lpTempFullKeyName;

    //
    //  Write out the section header.
    //

    PutChar(TEXT('['));
    PutLiteral(lpFullKeyName);
    PutLiteral(TEXT("]\n"));

    //
    //  Write out all of the value names and their data.
    //

    EnumIndex = 0;

    while (TRUE)
    {
        PBYTE pbValueData;
        cchValueName = ARRAYSIZE(g_ValueNameBuffer);

        // VALUE DATA
        // Query for data size
        RegError = RegEnumValue(hKey, EnumIndex++, g_ValueNameBuffer,
            &cchValueName, NULL, &Type, NULL, &cbValueData);

        if (RegError != ERROR_SUCCESS)
        {
            break;
        }

        // allocate memory for data
        pbValueData =  LocalAlloc(LPTR, cbValueData+ExtraAllocLen(Type));
        if (pbValueData)
        {
            if (RegEdit_QueryValueEx(hKey, g_ValueNameBuffer,
                NULL, &Type, pbValueData, &cbValueData) !=
                ERROR_SUCCESS)
            {
                g_FileErrorStringID = IDS_EXPFILEERRFILEWRITE;
            }
            else
            {
                //
                //  If cbValueName is zero, then this is the default value of
                //  the key, or the Windows 3.1 compatible key value.
                //

                if (cchValueName)
                    PutString(g_ValueNameBuffer);

                else
                    PutChar(TEXT('@'));

                PutChar(TEXT('='));

                switch (Type)
                {

                case REG_SZ:
                    PutString((LPTSTR) pbValueData);
                    break;

                case REG_DWORD:
                    if (cbValueData == sizeof(DWORD))
                    {
                        PutLiteral(s_DwordPrefix);
                        PutDword(*((LPDWORD) pbValueData), TRUE);
                        break;
                    }
                    //  FALL THROUGH

                case REG_BINARY:
                default:
                    PutBinary((LPBYTE) pbValueData, Type, cbValueData);
                    break;

                }

                PutChar(TEXT('\n'));
            }
            LocalFree(pbValueData);
        }
        else
        {
            g_FileErrorStringID = IDS_EXPFILEERRFILEWRITE;
        }

        if (g_FileErrorStringID == IDS_EXPFILEERRFILEWRITE)
            return;

    }

    PutChar(TEXT('\n'));

    if (RegError != ERROR_NO_MORE_ITEMS)
        g_FileErrorStringID = IDS_EXPFILEERRREGENUM;

    //
    //  Write out all of the subkeys and recurse into them.
    //

    //copy the existing key into a new buffer with enough room for the next key
    nLenFullKey = lstrlen(lpFullKeyName);
    lpTempFullKeyName = (LPTSTR) alloca( (nLenFullKey+MAXKEYNAME)*sizeof(TCHAR));
    lstrcpy(lpTempFullKeyName, lpFullKeyName);
    lpSubKeyName = lpTempFullKeyName + nLenFullKey;
    *lpSubKeyName++ = TEXT('\\');
    *lpSubKeyName = 0;

    EnumIndex = 0;

    while (TRUE) {

        if ((RegError = RegEnumKey(hKey, EnumIndex++, lpSubKeyName, MAXKEYNAME-1)) != ERROR_SUCCESS)
            break;

        if(RegOpenKeyEx(hKey,lpSubKeyName,0,KEY_ENUMERATE_SUB_KEYS|KEY_QUERY_VALUE,&hSubKey) == ERROR_SUCCESS) {

            PutBranch(hSubKey, lpTempFullKeyName);

            RegCloseKey(hSubKey);

            if (g_FileErrorStringID == IDS_EXPFILEERRFILEWRITE)
                return;

        }

        else
            g_FileErrorStringID = IDS_EXPFILEERRREGOPEN;

    }

    if (RegError != ERROR_NO_MORE_ITEMS)
        g_FileErrorStringID = IDS_EXPFILEERRREGENUM;

}

/*******************************************************************************
*
*  PutLiteral
*
*  DESCRIPTION:
*     Writes a literal string to the registry file stream.  No special handling
*     is done for the string-- it is written out as is.
*
*  PARAMETERS:
*     lpLiteral, null-terminated literal to write to file.
*
*******************************************************************************/

VOID
NEAR PASCAL
PutLiteral(
    LPCTSTR lpLiteral
    )
{

    while (*lpLiteral != 0)
        PutChar(*lpLiteral++);

}

/*******************************************************************************
*
*  PutString
*
*  DESCRIPTION:
*     Writes a string to the registry file stream.  A string is surrounded by
*     double quotes and some characters may be translated to escape sequences
*     to enable a parser to read the string back in.
*
*  PARAMETERS:
*     lpString, null-terminated string to write to file.
*
*******************************************************************************/

VOID
NEAR PASCAL
PutString(
    LPCTSTR lpString
    )
{

    TCHAR Char;

    PutChar(TEXT('"'));

    while ((Char = *lpString++) != 0) {

        switch (Char) {

            case TEXT('\r'):
                if(g_fMultiLineStrings) 
                {
                    PutChar('\\');
                    PutChar('r');
                }
                else 
                {
                    PutChar(Char);
                }
                break;

            case TEXT('\n'):
                if(g_fMultiLineStrings) 
                {
                    PutChar('\\');
                    PutChar('n');
                }
                else 
                {
                    PutChar(Char);
                }
                break;
            
            case TEXT('\\'):
            case TEXT('"'):
                PutChar(TEXT('\\'));
                //  FALL THROUGH

            default:
                PutChar(Char);
                break;

        }

    }

    PutChar(TEXT('"'));

}

/*******************************************************************************
*
*  PutBinary
*
*  DESCRIPTION:
*     Writes a sequence of hexadecimal bytes to the registry file stream.  The
*     output is formatted such that it doesn't exceed a defined line length.
*
*  PARAMETERS:
*     lpBuffer, bytes to write to file.
*     Type, value data type.
*     cbBytes, number of bytes to write.
*
*******************************************************************************/

VOID
NEAR PASCAL
PutBinary(
    CONST BYTE FAR* lpBuffer,
    DWORD Type,
    DWORD cbBytes
    )
{

    BOOL fFirstByteOnLine;
    BYTE Byte;

    // If we're writing one of the string formats that regedit doesn't write
    // natively (but rather converts to a string of hex digits for streaming
    // out), AND we're writing in downlevel/ANSI/REGEDIT4 format, we aren't
    // going to write out the high byte of each (internally Unicode) character.
    // So we will be writing half as many characters as the buffer byte size.

    if ((g_RegEditData.uExportFormat == FILE_TYPE_REGEDIT4) &&
        ((Type == REG_EXPAND_SZ) || (Type == REG_MULTI_SZ))) {
        cbBytes = cbBytes / 2;
    }

    PutLiteral(s_HexPrefix);

    if (Type != REG_BINARY) {

        PutChar(TEXT('('));
        PutDword(Type, FALSE);
        PutChar(TEXT(')'));

    }

    PutChar(TEXT(':'));

    fFirstByteOnLine = TRUE;

    while (cbBytes--) {

        if (s_FileIo.CurrentColumn > 75 && !fFirstByteOnLine) {

            PutLiteral(s_FileLineBreak);

            fFirstByteOnLine = TRUE;

        }

        if (!fFirstByteOnLine)
            PutChar(TEXT(','));

        Byte = *lpBuffer++;

        // If we're writing one of the string formats that regedit doesn't
        // write natively (REG_EXPAND_SZ and REG_MULTI_SZ values get converted
        // to a string of hex digits for streaming out), AND we're writing in
        // downlevel/ANSI/REGEDIT4 format, we don't want to write out the high
        // byte of each (internally Unicode) character.  So in those cases, we
        // advance another byte to get to the next ANSI character.  Yes, this
        // will lose data on non-SBCS characters, but that's what you get for
        // saving in the downlevel format.

        if ((g_RegEditData.uExportFormat == FILE_TYPE_REGEDIT4) &&
            ((Type == REG_EXPAND_SZ) || (Type == REG_MULTI_SZ))) {
            lpBuffer++;
        }

        PutChar(g_HexConversion[Byte >> 4]);
        PutChar(g_HexConversion[Byte & 0x0F]);

        fFirstByteOnLine = FALSE;

    }

}

/*******************************************************************************
*
*  PutChar
*
*  DESCRIPTION:
*     Writes a 32-bit word to the registry file stream.
*
*  PARAMETERS:
*     Dword, dword to write to file.
*
*******************************************************************************/

VOID
NEAR PASCAL
PutDword(
    DWORD Dword,
    BOOL fLeadingZeroes
    )
{

    int CurrentNibble;
    TCHAR Char;
    BOOL fWroteNonleadingChar;

    fWroteNonleadingChar = fLeadingZeroes;

    for (CurrentNibble = 7; CurrentNibble >= 0; CurrentNibble--) {

        Char = g_HexConversion[(Dword >> (CurrentNibble * 4)) & 0x0F];

        if (fWroteNonleadingChar || Char != TEXT('0')) {

            PutChar(Char);
            fWroteNonleadingChar = TRUE;

        }

    }

    //
    //  We need to write at least one character, so if we haven't written
    //  anything yet, just spit out one zero.
    //

    if (!fWroteNonleadingChar)
        PutChar(TEXT('0'));

}

/*******************************************************************************
*
*  PutChar
*
*  DESCRIPTION:
*     Writes one character to the registry file stream using an intermediate
*     buffer.
*
*  PARAMETERS:
*     Char, character to write to file.
*
*******************************************************************************/

VOID
NEAR PASCAL
PutChar(
    TCHAR Char
    )
{

    //
    //  Keep track of what column we're currently at.  This is useful in cases
    //  such as writing a large binary registry record.  Instead of writing one
    //  very long line, the other Put* routines can break up their output.
    //

    if (Char != TEXT('\n'))
        s_FileIo.CurrentColumn++;

    else {

        //
        //  Force a carriage-return, line-feed sequence to keep things like, oh,
        //  Notepad happy.
        //

        PutChar(TEXT('\r'));

        s_FileIo.CurrentColumn = 0;

    }

    s_FileIo.Buffer[s_FileIo.BufferOffset++] = Char;

    if (s_FileIo.BufferOffset == SIZE_FILE_IO_BUFFER)
        FlushIoBuffer();

}

/*******************************************************************************
*
*  FlushIoBuffer
*
*  DESCRIPTION:
*     Flushes the contents of the registry file stream to the disk and resets
*     the buffer pointer.
*
*  PARAMETERS:
*     (none).
*
*******************************************************************************/

VOID
NEAR PASCAL
FlushIoBuffer(
    VOID
    )
{

    FILE_NUMBYTES NumberOfBytesWritten;

    if (s_FileIo.BufferOffset) {

        if (g_RegEditData.uExportFormat == FILE_TYPE_REGEDIT4)
        {
            //
            // Convert Unicode to ANSI before writing.
            //

            int i;

            i = WideCharToMultiByte(
                    CP_THREAD_ACP,
                    0,
                    s_FileIo.Buffer,
                    s_FileIo.BufferOffset,
                    s_FileIo.ConversionBuffer,
                    sizeof(s_FileIo.ConversionBuffer),
                    NULL,
                    NULL
                    );

            if (!WRITEFILE(s_FileIo.hFile, s_FileIo.ConversionBuffer, i,
                &NumberOfBytesWritten) || (FILE_NUMBYTES) i !=
                NumberOfBytesWritten)

                g_FileErrorStringID = IDS_EXPFILEERRFILEWRITE;
        }
        else
        {
            //
            // Write Unicode text
            //
            if (!WRITEFILE(s_FileIo.hFile, s_FileIo.Buffer, s_FileIo.BufferOffset * sizeof(WCHAR),
                &NumberOfBytesWritten) || (FILE_NUMBYTES) (s_FileIo.BufferOffset * sizeof(WCHAR)) !=
                NumberOfBytesWritten)
                g_FileErrorStringID = IDS_EXPFILEERRFILEWRITE;
        }
    }

    s_FileIo.BufferOffset = 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\regedit\regporte.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGPORTE.H
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        06 Apr 1994
*
*  File import and export engine routines for the Registry Editor.
*
*******************************************************************************/

#ifndef _INC_REGPORTE
#define _INC_REGPORTE



#ifndef LPHKEY
#define LPHKEY                          HKEY FAR*
#endif

// PREDEFINED KEYS
typedef enum _PREDEFINE_KEY {
  PREDEFINE_KEY_CLASSES_ROOT,
  PREDEFINE_KEY_CURRENT_USER,
  PREDEFINE_KEY_LOCAL_MACHINE,
  PREDEFINE_KEY_USERS,
  PREDEFINE_KEY_CURRENT_CONFIG
} PREDEFINE_KEY;

typedef struct _REGISTRY_ROOT {
    LPTSTR lpKeyName;
    HKEY hKey;
    PREDEFINE_KEY hPreDefKey;
}   REGISTRY_ROOT;

#define INDEX_HKEY_CLASSES_ROOT         0
#define INDEX_HKEY_CURRENT_USER         1
#define INDEX_HKEY_LOCAL_MACHINE        2
#define INDEX_HKEY_USERS                3
//  #define INDEX_HKEY_PERFORMANCE_DATA     4
#define INDEX_HKEY_CURRENT_CONFIG	    4
#define INDEX_HKEY_DYN_DATA		        5

//  #define NUMBER_REGISTRY_ROOTS		    7
#define NUMBER_REGISTRY_ROOTS		    6

//  WARNING:  This is supposed to be enough for one keyname plus one predefined
//  handle name.
#define SIZE_SELECTED_PATH              (MAXKEYNAME + 40)

extern const TCHAR g_HexConversion[];

extern UINT g_FileErrorStringID;

#define ERK_OPEN    0
#define ERK_CREATE  1
#define ERK_DELETE  2

HKEY  Regedit_GetRootKeyFromComputer(HTREEITEM hComputerItem, PTSTR pszFullKeyName);
DWORD EditRegistryKey(HTREEITEM hComputerItem, LPHKEY lphKey, LPTSTR lpFullKeyName, UINT uOperation);
VOID  ImportRegFile(HWND hWnd, LPTSTR lpFileName, HTREEITEM hComputerItem);
VOID  ExportWinNT50RegFile(LPTSTR lpFileName, LPTSTR lpSelectedPath);
void  ExportRegedt32File(LPTSTR lpFileName, LPTSTR lpSelectedPath);
VOID  ExportWin40RegFile(LPTSTR lpFileName, LPTSTR lpSelectedPath);
VOID  ImportRegFileUICallback(UINT uPercentage);
void  RestoreBinaryKeyFile(HWND hWnd, LPTSTR lpFileName);

#endif // _INC_REGPORTE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\regedit\regprint.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGPRINT.C
*
*  VERSION:     4.0
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        21 Nov 1993
*
*  Print routines for the Registry Editor.
*
*******************************************************************************/

#include "pch.h"
#include "regprint.h"
#include "regcdhk.h"
#include "regresid.h"
#include "regedit.h"
#include "richedit.h"
#include "regporte.h"
#include "reg1632.h"
#include <malloc.h>

extern void PrintResourceData(PBYTE pbData, UINT uSize, DWORD dwType);

const TCHAR s_PrintLineBreak[] = TEXT(",\n  ");

PRINTDLGEX g_PrintDlg;

typedef struct _PRINT_IO {
    BOOL fContinueJob;
    UINT ErrorStringID;
    HWND hRegPrintAbortWnd;
    RECT rcPage;
    RECT rcOutput;
    PTSTR pLineBuffer;
    UINT cch;
    UINT cBufferPos;
    LPTSTR lpNewLineChars;
}   PRINT_IO;

#define CANCEL_NONE                     0x0000
#define CANCEL_MEMORY_ERROR             0x0001
#define CANCEL_PRINTER_ERROR            0x0002
#define CANCEL_ABORT                    0x0004

#define INITIAL_PRINTBUFFER_SIZE        8192

PRINT_IO s_PrintIo;

BOOL
CALLBACK
RegPrintAbortProc(
    HDC hDC,
    int Error
    );

INT_PTR
CALLBACK
RegPrintAbortDlgProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    );

void RegPrintSubtree();
void PrintBranch(HKEY hKey, LPTSTR lpFullKeyName);
void PrintKeyValues(HKEY hKey);
void PrintValueData(PBYTE pbValueData, DWORD cbValueData, DWORD dwType);
void PrintKeyHeader(HKEY hKey, LPTSTR lpFullKeyName);
void PrintClassName(HKEY hKey);
void PrintLastWriteTime(HKEY hKey);
void PrintDynamicString(UINT uStringID);
void PrintType(DWORD dwType);
void PrintBinaryData(PBYTE ValueData, UINT cbcbValueData);
void PrintDWORDData(PBYTE ValueData, UINT cbcbValueData);
void PrintLiteral(PTSTR lpLiteral);
BOOL PrintChar(TCHAR Char);
void PrintMultiString(LPTSTR pszData, int cbData);
UINT PrintToSubTreeError(UINT uPrintErrorStringID);
void PrintNewLine();

/*******************************************************************************
*
*  Implement IPrintDialogCallback
*
*  DESCRIPTION:
*     This interface is necessary to handle messages through PrintDlgEx
*     This interface doesn't need to have all the correct semantics of a COM
*     Object
*
*******************************************************************************/

typedef struct
{
    IPrintDialogCallback ipcb;
} CPrintCallback;

#define IMPL(type, pos, ptr) (type*)

static
HRESULT
CPrintCallback_QueryInterface(IPrintDialogCallback *ppcb, REFIID riid, void **ppv)
{
    CPrintCallback *this = (CPrintCallback*)ppcb;
    if (IsEqualIID (riid, &IID_IUnknown) || IsEqualIID (riid, &IID_IPrintDialogCallback))
        *ppv = &this->ipcb;
    else
    {
        *ppv = 0;
        return E_NOINTERFACE;
    }

    this->ipcb.lpVtbl->AddRef(&this->ipcb);
    return NOERROR;
}

static
ULONG
CPrintCallback_AddRef(IPrintDialogCallback *ppcb)
{
    CPrintCallback *this = (CPrintCallback*)ppcb;
    return 1;
}

static
ULONG
CPrintCallback_Release(IPrintDialogCallback *ppcb)
{
    CPrintCallback *this = (CPrintCallback*)ppcb;
    return 1;
}

static
HRESULT
CPrintCallback_InitDone(IPrintDialogCallback *ppcb)
{
    return S_OK;
}

static
HRESULT
CPrintCallback_SelectionChange(IPrintDialogCallback *ppcb)
{
    return S_OK;
}

static
HRESULT
CPrintCallback_HandleMessage(
    IPrintDialogCallback *ppcb,
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    LRESULT *pResult)
{
    *pResult = RegCommDlgHookProc(hDlg, uMsg, wParam, lParam);
    return S_OK;
}


static IPrintDialogCallbackVtbl vtblPCB =
{
    CPrintCallback_QueryInterface,
    CPrintCallback_AddRef,
    CPrintCallback_Release,
    CPrintCallback_InitDone,
    CPrintCallback_SelectionChange,
    CPrintCallback_HandleMessage
};

CPrintCallback g_callback;

/*******************************************************************************
*
*  RegEdit_OnCommandPrint
*
*  DESCRIPTION:
*     Handles the selection of the "Print" option by the user for the RegEdit
*     dialog box.
*
*  PARAMETERS:
*     hWnd, handle of RegPrint window.
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnCommandPrint(
    HWND hWnd
    )
{

    LPDEVNAMES lpDevNames;
    TEXTMETRIC TextMetric;
    DOCINFO DocInfo;
    LOGFONT lf;
    HGLOBAL hDevMode;
    HGLOBAL hDevNames;
    RECT rc;
    HWND hRichEdit;
    FORMATRANGE fr;
    HINSTANCE hInstRichEdit;
    int nOffsetX;
    int nOffsetY;
    PTSTR pszFontName;

    g_callback.ipcb.lpVtbl = &vtblPCB;

    // We have to completely fill out the PRINTDLGEX structure
    // correctly or the PrintDlgEx function will return an error.
    // The easiest way is to memset it to 0

    hDevMode = g_PrintDlg.hDevMode;
    hDevNames = g_PrintDlg.hDevNames;
    memset(&g_PrintDlg, 0, sizeof(g_PrintDlg));

    g_PrintDlg.lStructSize = sizeof(PRINTDLGEX);
    g_PrintDlg.hwndOwner = hWnd;
    g_PrintDlg.hDevMode = hDevMode;
    g_PrintDlg.hDevNames = hDevNames;
    g_PrintDlg.hDC = NULL;
    g_PrintDlg.Flags = PD_NOPAGENUMS | PD_RETURNDC | PD_ENABLEPRINTTEMPLATE;
    g_PrintDlg.Flags2 = 0;
    g_PrintDlg.ExclusionFlags = 0;
    g_PrintDlg.hInstance = g_hInstance;
    g_PrintDlg.nCopies = 1;
    g_PrintDlg.nStartPage = START_PAGE_GENERAL;
    g_PrintDlg.lpCallback = (IUnknown*) &g_callback.ipcb;
    g_PrintDlg.lpPrintTemplateName = MAKEINTRESOURCE(IDD_REGPRINT);
    g_RegCommDlgDialogTemplate = IDD_REGPRINT;

    if (FAILED(PrintDlgEx(&g_PrintDlg)))
        return;
    if (g_PrintDlg.dwResultAction != PD_RESULT_PRINT)
        return;

    s_PrintIo.ErrorStringID = IDS_PRINTERRNOMEMORY;

    if ((lpDevNames = GlobalLock(g_PrintDlg.hDevNames)) == NULL)
        goto error_ShowDialog;

    //
    //  For now, assume a page with top and bottom margins of 1/2 inch and
    //  left and right margins of 3/4 inch (the defaults of Notepad).
    //  rcPage and rcOutput are in TWIPS (1/20th of a point)
    //

    rc.left = rc.top = 0;
    rc.bottom = GetDeviceCaps(g_PrintDlg.hDC, PHYSICALHEIGHT);
    rc.right = GetDeviceCaps(g_PrintDlg.hDC, PHYSICALWIDTH);
    nOffsetX = GetDeviceCaps(g_PrintDlg.hDC, PHYSICALOFFSETX);
    nOffsetY = GetDeviceCaps(g_PrintDlg.hDC, PHYSICALOFFSETY);

    s_PrintIo.rcPage.left = s_PrintIo.rcPage.top = 0;
    s_PrintIo.rcPage.right = MulDiv(rc.right, 1440, GetDeviceCaps(g_PrintDlg.hDC, LOGPIXELSX));
    s_PrintIo.rcPage.bottom = MulDiv(rc.bottom, 1440, GetDeviceCaps(g_PrintDlg.hDC, LOGPIXELSY));

    s_PrintIo.rcOutput.left = 1080;
    s_PrintIo.rcOutput.top = 720;
    s_PrintIo.rcOutput.right = s_PrintIo.rcPage.right - 1080;
    s_PrintIo.rcOutput.bottom = s_PrintIo.rcPage.bottom - 720;

    //
    //
    //

    if ((s_PrintIo.pLineBuffer = (PTSTR) LocalAlloc(LPTR, INITIAL_PRINTBUFFER_SIZE*sizeof(TCHAR))) == NULL)
        goto error_DeleteDC;
    s_PrintIo.cch = INITIAL_PRINTBUFFER_SIZE;
    s_PrintIo.cBufferPos = 0;

    if ((s_PrintIo.hRegPrintAbortWnd = CreateDialog(g_hInstance,
        MAKEINTRESOURCE(IDD_REGPRINTABORT), hWnd, RegPrintAbortDlgProc)) ==
        NULL)
        goto error_FreeLineBuffer;

    EnableWindow(hWnd, FALSE);

    //
    //  Prepare the document for printing.
    //
    s_PrintIo.ErrorStringID = 0;
    s_PrintIo.fContinueJob = TRUE;
    s_PrintIo.lpNewLineChars = TEXT("\n");
    SetAbortProc(g_PrintDlg.hDC, RegPrintAbortProc);

    DocInfo.cbSize = sizeof(DOCINFO);
    DocInfo.lpszDocName = LoadDynamicString(IDS_REGEDIT);
    DocInfo.lpszOutput = (LPTSTR) lpDevNames + lpDevNames-> wOutputOffset;
    DocInfo.lpszDatatype = NULL;
    DocInfo.fwType = 0;

    s_PrintIo.ErrorStringID = 0;

    if (StartDoc(g_PrintDlg.hDC, &DocInfo) <= 0) {

        if (GetLastError() != ERROR_PRINT_CANCELLED)
            s_PrintIo.ErrorStringID = IDS_PRINTERRPRINTER;
        goto error_DeleteDocName;

    }

    // Print registry subtree.
    RegPrintSubtree();

    if (s_PrintIo.ErrorStringID != 0)
    {
        InternalMessageBox(g_hInstance, hWnd,
            MAKEINTRESOURCE(s_PrintIo.ErrorStringID),
            MAKEINTRESOURCE(IDS_REGEDIT), MB_ICONERROR | MB_OK);
    }

    hInstRichEdit = LoadLibrary(TEXT("riched20.dll"));

    hRichEdit = CreateWindowEx(0, RICHEDIT_CLASS, NULL, ES_MULTILINE, 0, 0, 100, 100, NULL, NULL, NULL, NULL);
    SendMessage(hRichEdit, WM_SETTEXT, 0, (LPARAM)s_PrintIo.pLineBuffer);

    pszFontName = LoadDynamicString(IDS_PRINT_FONT);
    if (pszFontName)
    {
        CHARFORMAT cf;

        cf.cbSize = sizeof(CHARFORMAT);
        cf.dwMask = CFM_FACE | CFM_BOLD;
        cf.dwEffects = 0x00;
        cf.bPitchAndFamily = FIXED_PITCH | FF_MODERN;
        wsprintf(cf.szFaceName, TEXT("%s"), pszFontName);

        SendMessage(hRichEdit, EM_SETCHARFORMAT, SCF_ALL, (LPARAM)&cf);

        DeleteDynamicString(pszFontName);
    }

    fr.hdc = g_PrintDlg.hDC;
    fr.hdcTarget = g_PrintDlg.hDC;
    fr.rc = s_PrintIo.rcOutput;
    fr.rcPage = s_PrintIo.rcPage;
    fr.chrg.cpMin = 0;
    fr.chrg.cpMax = -1;

    while (fr.chrg.cpMin < (int) s_PrintIo.cBufferPos) {
        StartPage(g_PrintDlg.hDC);

        // We have to adjust the origin because 0,0 is not at the corner of the paper
        // but is at the corner of the printable region

        SetViewportOrgEx(g_PrintDlg.hDC, -nOffsetX, -nOffsetY, NULL);
        fr.chrg.cpMin = (LONG)SendMessage(hRichEdit, EM_FORMATRANGE, TRUE, (LPARAM)&fr);
        SendMessage(hRichEdit, EM_DISPLAYBAND, 0, (LPARAM)&s_PrintIo.rcOutput);
        EndPage(g_PrintDlg.hDC);
        if (!s_PrintIo.fContinueJob)
            break;
    }
    SendMessage(hRichEdit, EM_FORMATRANGE, FALSE, 0);

    //
    //  End the print job.
    //

    if (s_PrintIo.ErrorStringID == 0 && s_PrintIo.fContinueJob) {

        if (EndDoc(g_PrintDlg.hDC) <= 0) {
            s_PrintIo.ErrorStringID = IDS_PRINTERRPRINTER;
            goto error_AbortDoc;
        }
    }

    //
    //  Either a printer error occurred or the user cancelled the printing, so
    //  abort the print job.
    //

    else {

error_AbortDoc:
        AbortDoc(g_PrintDlg.hDC);

    }

    DestroyWindow(hRichEdit);
    FreeLibrary(hInstRichEdit);

error_DeleteDocName:
    DeleteDynamicString(DocInfo.lpszDocName);

//  error_DestroyRegPrintAbortWnd:
    EnableWindow(hWnd, TRUE);
    DestroyWindow(s_PrintIo.hRegPrintAbortWnd);

error_FreeLineBuffer:
    LocalFree((HLOCAL)s_PrintIo.pLineBuffer);

error_DeleteDC:
    DeleteDC(g_PrintDlg.hDC);
    g_PrintDlg.hDC = NULL;
    GlobalUnlock(g_PrintDlg.hDevNames);

error_ShowDialog:
    if (s_PrintIo.ErrorStringID != 0)
        InternalMessageBox(g_hInstance, hWnd,
            MAKEINTRESOURCE(s_PrintIo.ErrorStringID),
            MAKEINTRESOURCE(IDS_REGEDIT), MB_ICONERROR | MB_OK);

}


//------------------------------------------------------------------------------
// RegEdit_SaveAsSubtree
//
// DESCRIPTION: Saves a subtree to a file
//
// PARAMETERS: LPTSTR lpFileName - file name
//             LPTSTR lpSelectedPath - path to key
//------------------------------------------------------------------------------
UINT RegEdit_SaveAsSubtree(LPTSTR lpFileName, LPTSTR lpSelectedPath)
{
    s_PrintIo.pLineBuffer = (PTSTR) LocalAlloc(LPTR, INITIAL_PRINTBUFFER_SIZE*sizeof(TCHAR));
    if (s_PrintIo.pLineBuffer)
    {
        FILE_HANDLE hFile;

        // Init the printing info
        s_PrintIo.pLineBuffer[0] = 0xFEFF; //unicode byte order mark
        s_PrintIo.cch = INITIAL_PRINTBUFFER_SIZE;
        s_PrintIo.cBufferPos = 1;
        s_PrintIo.fContinueJob = TRUE;
        s_PrintIo.ErrorStringID = 0;
        s_PrintIo.lpNewLineChars = TEXT("\r\n");

        RegPrintSubtree();

        // write the buffer to the file
        if (OPENWRITEFILE(lpFileName, hFile))
        {
            DWORD cbWritten = 0;

            if (!WRITEFILE(hFile, s_PrintIo.pLineBuffer, s_PrintIo.cBufferPos*sizeof(TCHAR), &cbWritten))
            {
                s_PrintIo.ErrorStringID = IDS_EXPFILEERRFILEWRITE;
            }

            CLOSEFILE(hFile);
        }
        else
        {
            s_PrintIo.ErrorStringID = IDS_EXPFILEERRFILEOPEN;
        }

        LocalFree(s_PrintIo.pLineBuffer);
    }

    return PrintToSubTreeError(s_PrintIo.ErrorStringID);
}


//------------------------------------------------------------------------------
// PrintToSubTreeError
//
// DESCRIPTION: Prints a subtree
//
// PARAMETER: UINT uPrintErrorStringID - print error string id
//------------------------------------------------------------------------------
UINT PrintToSubTreeError(UINT uPrintErrorStringID)
{
    UINT uError = uPrintErrorStringID;

    switch (uPrintErrorStringID)
    {
    case IDS_PRINTERRNOMEMORY:
        uError = IDS_SAVETREEERRNOMEMORY;

    case IDS_PRINTERRCANNOTREAD:
        uError = IDS_SAVETREEERRCANNOTREAD;
    }

    return uError;
}


//------------------------------------------------------------------------------
// RegPrintSubtree
//
// DESCRIPTION: Prints a subtree
//------------------------------------------------------------------------------
void RegPrintSubtree()
{
    HTREEITEM hSelectedTreeItem = TreeView_GetSelection(g_RegEditData.hKeyTreeWnd);

    if (g_fRangeAll)
    {
        HTREEITEM hComputerItem = RegEdit_GetComputerItem(hSelectedTreeItem);

        lstrcpy(g_SelectedPath, g_RegistryRoots[INDEX_HKEY_LOCAL_MACHINE].lpKeyName);
        PrintBranch(Regedit_GetRootKeyFromComputer(hComputerItem, g_SelectedPath),
            g_SelectedPath);

        lstrcpy(g_SelectedPath, g_RegistryRoots[INDEX_HKEY_USERS].lpKeyName);
        PrintBranch(Regedit_GetRootKeyFromComputer(hComputerItem, g_SelectedPath),
            g_SelectedPath);
    }
    else
    {
        HKEY hKey;

        if (EditRegistryKey(RegEdit_GetComputerItem(hSelectedTreeItem),
            &hKey, g_SelectedPath, ERK_OPEN) == ERROR_SUCCESS)
        {
            PrintBranch(hKey, g_SelectedPath);
            RegCloseKey(hKey);
        }
    }
}

/*******************************************************************************
*
*  RegPrintAbortProc
*
*  DESCRIPTION:
*     Callback procedure to check if the print job should be canceled.
*
*  PARAMETERS:
*     hDC, handle of printer device context.
*     Error, specifies whether an error has occurred.
*     (returns), TRUE to continue the job, else FALSE to cancel the job.
*
*******************************************************************************/

BOOL
CALLBACK
RegPrintAbortProc(
    HDC hDC,
    int Error
    )
{

    while (s_PrintIo.fContinueJob && MessagePump(s_PrintIo.hRegPrintAbortWnd))
        ;

    return s_PrintIo.fContinueJob;

    UNREFERENCED_PARAMETER(hDC);
    UNREFERENCED_PARAMETER(Error);

}

/*******************************************************************************
*
*  RegPrintAbortDlgProc
*
*  DESCRIPTION:
*     Callback procedure for the RegPrintAbort dialog box.
*
*  PARAMETERS:
*     hWnd, handle of RegPrintAbort window.
*     Message,
*     wParam,
*     lParam,
*     (returns),
*
*******************************************************************************/

INT_PTR
CALLBACK
RegPrintAbortDlgProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    )
{

    switch (Message) {

        case WM_INITDIALOG:
            break;

        case WM_CLOSE:
        case WM_COMMAND:
            s_PrintIo.fContinueJob = FALSE;
            break;

        default:
            return FALSE;

    }

    return TRUE;

}

/*******************************************************************************
*
*  PrintBranch
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

void PrintBranch(HKEY hKey, LPTSTR lpFullKeyName)
{
    // Write out the section header.
    PrintKeyHeader(hKey, lpFullKeyName);

    // Print the vales for the key.
    PrintKeyValues(hKey);

    if (s_PrintIo.ErrorStringID == 0)
    {
        HKEY hSubKey;
        int nLenFullKey;
        DWORD EnumIndex = 0;
        LPTSTR lpSubKeyName;
        LPTSTR lpTempFullKeyName;

        //  Write out all of the subkeys and recurse into them.

        //copy the existing key into a new buffer with enough room for the next key
        nLenFullKey = lstrlen(lpFullKeyName);
        lpTempFullKeyName = (LPTSTR) alloca( (nLenFullKey+MAXKEYNAME)*sizeof(TCHAR));
        lstrcpy(lpTempFullKeyName, lpFullKeyName);
        lpSubKeyName = lpTempFullKeyName + nLenFullKey;
        *lpSubKeyName++ = TEXT('\\');
        *lpSubKeyName = 0;

        PrintNewLine();

        while (s_PrintIo.fContinueJob)
        {
            if (RegEnumKey(hKey, EnumIndex++, lpSubKeyName, MAXKEYNAME-1) !=
                ERROR_SUCCESS)
                break;

            if(RegOpenKeyEx(hKey,lpSubKeyName,0,KEY_ENUMERATE_SUB_KEYS|KEY_QUERY_VALUE,&hSubKey) ==
                NO_ERROR)
            {

                PrintBranch(hSubKey, lpTempFullKeyName);
                RegCloseKey(hSubKey);
            }
            else
            {
                DebugPrintf(("RegOpenKey failed."));
            }

        }
    }
}


//------------------------------------------------------------------------------
// PrintKeyHeader
//
// DESCRIPTION: Prints the header information of a key
//
// PARAMETERS: HKEY hKey - key
//             LPTSTR lpFullKeyName - path to key
//------------------------------------------------------------------------------
void PrintKeyValues(HKEY hKey)
{
    DWORD EnumIndex = 0;

    //  Write out all of the value names and their data.
    while (s_PrintIo.fContinueJob)
    {
        DWORD Type;
        DWORD cbValueData;
        PBYTE pbValueData;
        TCHAR acAuxNumber[MAXVALUENAME_LENGTH];
        DWORD cchValueName = ARRAYSIZE(g_ValueNameBuffer);

        // Query for data size
        if (RegEnumValue(hKey, EnumIndex++, g_ValueNameBuffer,
            &cchValueName, NULL, &Type, NULL, &cbValueData) != ERROR_SUCCESS)
        {
            break;
        }

        // Print value number
        PrintDynamicString(IDS_PRINT_NUMBER);
        wsprintf(acAuxNumber, TEXT("%d"), EnumIndex - 1);
        PrintLiteral(acAuxNumber);
        PrintNewLine();

        // Print key name
        PrintDynamicString(IDS_PRINT_NAME);
        if (cchValueName)
        {
            PrintLiteral(g_ValueNameBuffer);
        }
        else
        {
            PrintDynamicString(IDS_PRINT_NO_NAME);
        }
        PrintNewLine();

        // Print Type
        PrintType(Type);

        // allocate memory for data
        pbValueData =  LocalAlloc(LPTR, cbValueData+ExtraAllocLen(Type));
        if (pbValueData)
        {
            if (RegEdit_QueryValueEx(hKey, g_ValueNameBuffer,
                NULL, &Type, pbValueData, &cbValueData) == ERROR_SUCCESS)
            {
                PrintValueData(pbValueData, cbValueData, Type);
            }
            else
            {
                s_PrintIo.ErrorStringID = IDS_PRINTERRCANNOTREAD;
            }

            if (pbValueData)
            {
                LocalFree(pbValueData);
                pbValueData = NULL;
            }
        }
        else
        {
            s_PrintIo.ErrorStringID = IDS_PRINTERRNOMEMORY;
            break;
        }
    }
}


//------------------------------------------------------------------------------
// PrintValueData
//
// DESCRIPTION: Prints the header information of a key
//
// PARAMETERS: pbValueData - byte data
//             cbValueData - count of bytes
//             dwType - data type
//------------------------------------------------------------------------------
void PrintValueData(PBYTE pbValueData, DWORD cbValueData, DWORD dwType)
{
    PrintDynamicString(IDS_PRINT_DATA);

    switch (dwType)
    {
    case REG_MULTI_SZ:
        PrintMultiString((LPTSTR)pbValueData, cbValueData);
        break;

    case REG_SZ:
    case REG_EXPAND_SZ:
        PrintLiteral((LPTSTR)pbValueData);
        PrintNewLine();
        break;

    case REG_DWORD:
        PrintDWORDData((PBYTE)pbValueData, cbValueData);
        break;

    case REG_RESOURCE_LIST:
    case REG_FULL_RESOURCE_DESCRIPTOR:
    case REG_RESOURCE_REQUIREMENTS_LIST:
        PrintResourceData((PBYTE)pbValueData, cbValueData, dwType);
        break;

    default:
        PrintBinaryData((PBYTE)pbValueData, cbValueData);
        break;
    }

    PrintNewLine();
}


//------------------------------------------------------------------------------
// PrintKeyHeader
//
// DESCRIPTION: Prints the header information of a key
//
// PARAMETERS: HKEY hKey - key
//             LPTSTR lpFullKeyName - path to key
//------------------------------------------------------------------------------
void PrintKeyHeader(HKEY hKey, LPTSTR lpFullKeyName)
{
    PrintDynamicString(IDS_PRINT_KEY_NAME);
    PrintLiteral(lpFullKeyName);
    PrintNewLine();

    PrintClassName(hKey);
    PrintLastWriteTime(hKey);
}


//------------------------------------------------------------------------------
// PrintClassName
//
// DESCRIPTION: Prints the class name
//
// PARAMETERS: HKEY hKey - key
//------------------------------------------------------------------------------
void PrintClassName(HKEY hKey)
{
    PTSTR pszClass;

    PrintDynamicString(IDS_PRINT_CLASS_NAME);

    pszClass = LocalAlloc(LPTR, ALLOCATION_INCR);
    if (pszClass)
    {
        HRESULT hr;
        DWORD cbClass = sizeof(pszClass);

        hr = RegQueryInfoKey(hKey, pszClass, &cbClass, NULL, NULL, NULL, NULL, NULL,
            NULL, NULL, NULL, NULL);

        if (hr == ERROR_MORE_DATA)
        {
            // need a bigger buffer
            PBYTE pbValueData = LocalReAlloc(pszClass, cbClass + 1, LMEM_MOVEABLE);
            if (pbValueData)
            {
                pszClass = (PTSTR)pbValueData;
                hr = RegQueryInfoKey(hKey, pszClass, &cbClass, NULL, NULL, NULL, NULL, NULL,
                    NULL, NULL, NULL, NULL);
            }
        }

        if (cbClass && (hr == ERROR_SUCCESS))
        {
            PrintLiteral(pszClass);
        }
        else
        {
            PrintDynamicString(IDS_PRINT_NO_CLASS);
        }

        LocalFree(pszClass);
    }

    PrintNewLine();
}


//------------------------------------------------------------------------------
// PrintLastWriteTime
//
// DESCRIPTION: Prints the last write time
//
// PARAMETERS: HKEY hKey - key
//------------------------------------------------------------------------------
void PrintLastWriteTime(HKEY hKey)
{
    FILETIME ftLastWriteTime;

    PrintDynamicString(IDS_PRINT_LAST_WRITE_TIME);

    if (RegQueryInfoKey(hKey, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
            NULL, NULL, NULL, &ftLastWriteTime) == ERROR_SUCCESS)
    {
        FILETIME ftLocalLastWriteTime;
        if (FileTimeToLocalFileTime(&ftLastWriteTime, &ftLocalLastWriteTime))
        {
            SYSTEMTIME stLastWriteTime;
            if (FileTimeToSystemTime(&ftLocalLastWriteTime, &stLastWriteTime))
            {
                TCHAR achData[50];
                TCHAR achTime[50];

                GetDateFormat(GetSystemDefaultLCID(), DATE_SHORTDATE, &stLastWriteTime,
                    NULL, achData, ARRAYSIZE(achData));

                GetTimeFormat(GetSystemDefaultLCID(), TIME_NOSECONDS, &stLastWriteTime,
                    NULL, achTime, ARRAYSIZE(achTime));

                PrintLiteral(achData);
                PrintLiteral(TEXT(" - "));
                PrintLiteral(achTime);
            }
        }
    }

    PrintNewLine();
}


//------------------------------------------------------------------------------
// PrintDynamicString
//
// DESCRIPTION: Prints the dynamic string
//
// PARAMETERS: UINT uStringID - resource string id
//------------------------------------------------------------------------------
void PrintDynamicString(UINT uStringID)
{
    PTSTR psz = LoadDynamicString(uStringID);
    if (psz)
    {
        PrintLiteral(psz);
        DeleteDynamicString(psz);
    }
}


//------------------------------------------------------------------------------
// PrintType
//
// DESCRIPTION: Prints the value type
//
// PARAMETERS: HKEY hKey - key
//------------------------------------------------------------------------------
void PrintType(DWORD dwType)
{
    UINT uTypeStringId;

    switch (dwType)
    {
    case REG_NONE:
        uTypeStringId = IDS_PRINT_TYPE_REG_NONE;
        break;
    case REG_SZ:
        uTypeStringId = IDS_PRINT_TYPE_REG_SZ;
        break;
    case REG_EXPAND_SZ:
        uTypeStringId = IDS_PRINT_TYPE_REG_EXPAND_SZ;
        break;
    case REG_BINARY:
        uTypeStringId = IDS_PRINT_TYPE_REG_BINARY;
        break;
    case REG_DWORD:
        uTypeStringId = IDS_PRINT_TYPE_REG_DWORD;
        break;
    case REG_LINK:
        uTypeStringId = IDS_PRINT_TYPE_REG_LINK;
        break;
    case REG_MULTI_SZ:
        uTypeStringId = IDS_PRINT_TYPE_REG_MULTI_SZ;
        break;
    case REG_RESOURCE_LIST:
        uTypeStringId = IDS_PRINT_TYPE_REG_RESOURCE_LIST;
        break;
    case REG_FULL_RESOURCE_DESCRIPTOR:
        uTypeStringId = IDS_PRINT_TYPE_REG_FULL_RESOURCE_DESCRIPTOR;
        break;
    case REG_RESOURCE_REQUIREMENTS_LIST:
        uTypeStringId = IDS_PRINT_TYPE_REG_RESOURCE_REQUIREMENTS_LIST;
        break;
    case REG_QWORD:
        uTypeStringId = IDS_PRINT_TYPE_REG_REG_QWORD;
        break;
    default:
        uTypeStringId = IDS_PRINT_TYPE_REG_UNKNOWN;
    }

    PrintDynamicString(IDS_PRINT_TYPE);
    PrintDynamicString(uTypeStringId);
    PrintNewLine();
}


/*******************************************************************************
*
*  PrintLiteral
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/
VOID PrintLiteral(PTSTR lpLiteral)
{
    if (s_PrintIo.fContinueJob)
        while (*lpLiteral != 0 && PrintChar(*lpLiteral++));
}


//------------------------------------------------------------------------------
// PrintBinaryData
//
// DESCRIPTION:  Print a string that contains the binary data
//
// PARAMETERS:   ValueData - Buffer that contains the binary data
//               cbValueData - Number of bytes in the buffer
//------------------------------------------------------------------------------
void PrintBinaryData(PBYTE ValueData, UINT cbValueData)
{
    DWORD   dwDataIndex;
    DWORD   dwDataIndex2 = 0; //tracks multiples of 16.

    if (cbValueData && ValueData)
    {
        // Display rows of 16 bytes of data.
        TCHAR achAuxData[80];

        PrintNewLine();

        for(dwDataIndex = 0;
            dwDataIndex < ( cbValueData >> 4 );
            dwDataIndex++,
            dwDataIndex2 = dwDataIndex << 4 )
        {
            //  The string that contains the format in the sprintf below
            //  cannot be broken because cfront  on mips doesn't like it.
            wsprintf(achAuxData,
                     TEXT("%08x   %02x %02x %02x %02x %02x %02x %02x %02x - %02x %02x %02x %02x %02x %02x %02x %02x  %c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c"),
                     dwDataIndex2,
                     ValueData[ dwDataIndex2 + 0  ],
                     ValueData[ dwDataIndex2 + 1  ],
                     ValueData[ dwDataIndex2 + 2  ],
                     ValueData[ dwDataIndex2 + 3  ],
                     ValueData[ dwDataIndex2 + 4  ],
                     ValueData[ dwDataIndex2 + 5  ],
                     ValueData[ dwDataIndex2 + 6  ],
                     ValueData[ dwDataIndex2 + 7  ],
                     ValueData[ dwDataIndex2 + 8  ],
                     ValueData[ dwDataIndex2 + 9  ],
                     ValueData[ dwDataIndex2 + 10 ],
                     ValueData[ dwDataIndex2 + 11 ],
                     ValueData[ dwDataIndex2 + 12 ],
                     ValueData[ dwDataIndex2 + 13 ],
                     ValueData[ dwDataIndex2 + 14 ],
                     ValueData[ dwDataIndex2 + 15 ],
                     iswprint( ValueData[ dwDataIndex2 + 0  ] )
                        ? ValueData[ dwDataIndex2 + 0  ]  : TEXT('.'),
                     iswprint( ValueData[ dwDataIndex2 + 1  ] )
                        ? ValueData[ dwDataIndex2 + 1  ]  : TEXT('.'),
                     iswprint( ValueData[ dwDataIndex2 + 2  ] )
                        ? ValueData[ dwDataIndex2 + 2  ]  : TEXT('.'),
                     iswprint( ValueData[ dwDataIndex2 + 3  ] )
                        ? ValueData[ dwDataIndex2 + 3  ]  : TEXT('.'),
                     iswprint( ValueData[ dwDataIndex2 + 4  ] )
                        ? ValueData[ dwDataIndex2 + 4  ]  : TEXT('.'),
                     iswprint( ValueData[ dwDataIndex2 + 5  ] )
                        ? ValueData[ dwDataIndex2 + 5  ]  : TEXT('.'),
                     iswprint( ValueData[ dwDataIndex2 + 6  ] )
                        ? ValueData[ dwDataIndex2 + 6  ]  : TEXT('.'),
                     iswprint( ValueData[ dwDataIndex2 + 7  ] )
                        ? ValueData[ dwDataIndex2 + 7  ]  : TEXT('.'),
                     iswprint( ValueData[ dwDataIndex2 + 8  ] )
                        ? ValueData[ dwDataIndex2 + 8  ]  : TEXT('.'),
                     iswprint( ValueData[ dwDataIndex2 + 9  ] )
                        ? ValueData[ dwDataIndex2 + 9  ]  : TEXT('.'),
                     iswprint( ValueData[ dwDataIndex2 + 10 ] )
                        ? ValueData[ dwDataIndex2 + 10 ]  : TEXT('.'),
                     iswprint( ValueData[ dwDataIndex2 + 11 ] )
                        ? ValueData[ dwDataIndex2 + 11 ]  : TEXT('.'),
                     iswprint( ValueData[ dwDataIndex2 + 12 ] )
                        ? ValueData[ dwDataIndex2 + 12 ]  : TEXT('.'),
                     iswprint( ValueData[ dwDataIndex2 + 13 ] )
                        ? ValueData[ dwDataIndex2 + 13 ]  : TEXT('.'),
                     iswprint( ValueData[ dwDataIndex2 + 14 ] )
                        ? ValueData[ dwDataIndex2 + 14 ]  : TEXT('.'),
                     iswprint( ValueData[ dwDataIndex2 + 15 ] )
                        ? ValueData[ dwDataIndex2 + 15 ]  : TEXT('.'));

            PrintLiteral(achAuxData);
            PrintNewLine();
        }

        // If the cbValueData is not an even multiple of 16
        // then there is one additonal line of data to display.
        if( cbValueData % 16 != 0 )
        {
            UINT cchBlanks = 0;
            UINT uLinePos = 0;
            DWORD dwSeperatorChars = 0;
            UINT  uIndex = wsprintf(achAuxData, TEXT("%08x   "), dwDataIndex << 4 );

            // Display the remaining data, one byte at a time in hex.
            for(dwDataIndex = dwDataIndex2;
                dwDataIndex < cbValueData;
                dwDataIndex++ )
            {
                uIndex += wsprintf((achAuxData + uIndex ), TEXT("%02x "), ValueData[dwDataIndex]);

                // If eight data values have been displayed, print the seperator.
                if( dwDataIndex % 8 == 7 )
                {
                    uIndex += wsprintf( &achAuxData[uIndex], TEXT("%s"), TEXT("- "));
                    // Remember that two seperator characters were displayed.
                    dwSeperatorChars = 2;
                }
            }

            // Fill with blanks to the printable characters position.
            // That is position 64 less 8 spaces for the 'address',
            // 3 blanks, 3 spaces for each value displayed, possibly
            // two for the seperator plus two blanks at the end.
            uLinePos = (8 + 3 + (( dwDataIndex % 16 ) * 3 ) + dwSeperatorChars + 2 );
            uLinePos = min(uLinePos, 64);

            for(cchBlanks = 64 - uLinePos;
                cchBlanks > 0;
                cchBlanks--)
            {
                achAuxData[uIndex++] = TEXT(' ');
            }

            // Display the remaining data, one byte at a time as
            // printable characters.
            for(
                dwDataIndex = dwDataIndex2;
                dwDataIndex < cbValueData;
                dwDataIndex++ )
            {

                uIndex += wsprintf(&achAuxData[ uIndex ],
                                  TEXT("%c"),
                                  iswprint( ValueData[ dwDataIndex ] )
                                   ? ValueData[ dwDataIndex ] : TEXT('.'));

            }
            PrintLiteral(achAuxData);
        }
    }
    PrintNewLine();
}


//------------------------------------------------------------------------------
// PrintDWORDData
//
// DESCRIPTION:  Prints a DWORD
//
// PARAMETERS:   ValueData - Buffer that contains the binary data
//               cbValueData - Number of bytes in the buffer
//------------------------------------------------------------------------------
void PrintDWORDData(PBYTE ValueData, UINT cbValueData)
{
    DWORD dwData = *((PDWORD)ValueData);
    if (cbValueData && ValueData)
    {
        TCHAR achAuxData[20]; // the largest dword string is only 8 hex digits
        wsprintf(achAuxData, TEXT("%#x"), dwData);

        PrintLiteral(achAuxData);
    }
    PrintNewLine();
}

/*******************************************************************************
*
*  PrintChar
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL PrintChar(TCHAR Char)
{

    //
    //  Keep track of what column we're currently at.  This is useful in cases
    //  such as writing a large binary registry record.  Instead of writing one
    //  very long line, the other Print* routines can break up their output.
    //

    if (s_PrintIo.cBufferPos == s_PrintIo.cch) {
        PTSTR pNewBuffer = LocalAlloc(LPTR, 2*s_PrintIo.cch*sizeof(TCHAR));
        if (pNewBuffer == NULL)
            return FALSE;
        memcpy(pNewBuffer, s_PrintIo.pLineBuffer, s_PrintIo.cch*sizeof(TCHAR));
        LocalFree(s_PrintIo.pLineBuffer);
        s_PrintIo.pLineBuffer = pNewBuffer;
        s_PrintIo.cch *= 2;
    }

    s_PrintIo.pLineBuffer[s_PrintIo.cBufferPos++] = Char;

    return TRUE;
}


//------------------------------------------------------------------------------
//  PrintMultiString
//
//  DESCRIPTION: Prints a multi-string
//
//  PARAMETERS:  pszData - string
//               cbData  - number of bytes in string, including nulls
//------------------------------------------------------------------------------

VOID PrintMultiString(LPTSTR pszData, int cbData)
{
    if (s_PrintIo.fContinueJob)
    {
        int i = 0;
        int ccData = (cbData / sizeof(TCHAR)) - 2; // don't want last null of last string or multi-string

        for(i = 0; i < ccData; i++)
        {
            if (pszData[i] == TEXT('\0'))
            {
                PrintNewLine();
                PrintDynamicString(IDS_PRINT_KEY_NAME_INDENT);
            }
            else
            {
                PrintChar(pszData[i]);
            }
        }
    }
    PrintNewLine();
}


//------------------------------------------------------------------------------
//  PrintNewLine()
//
//  DESCRIPTION: Prints the newline chars.
//
//  PARAMETERS:  pszData - string
//               cbData  - number of bytes in string, including nulls
//------------------------------------------------------------------------------
void PrintNewLine()
{
    PrintLiteral(s_PrintIo.lpNewLineChars);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\regedit\regresed.c ===
//------------------------------------------------------------------------------
//
//  Microsoft Windows Shell
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:      regresed.c
//
//  Contents:  Implementation of REG_RESOURCE_LIST for regedit 
//
//  Classes:   none
//
//------------------------------------------------------------------------------


#include "pch.h"
#include "regresid.h"
#include "regresed.h"
#include "clb.h"

//------------------------------------------------------------------------------
//
//  EditResourceListDlgProc
//
//  DESCRIPTION:
//
//  PARAMETERS:
//------------------------------------------------------------------------------

INT_PTR CALLBACK EditResourceListDlgProc(HWND hWnd, UINT Message, WPARAM wParam, LPARAM lParam)
{
    
    LPEDITVALUEPARAM lpEditValueParam;
    
    
    switch (Message) 
    {
        HANDLE_MSG(hWnd, WM_INITDIALOG, EditResourceList_OnInitDialog);
        
    case WM_COMMAND:
        {
            switch (GET_WM_COMMAND_ID(wParam, lParam)) 
            {
            case IDOK:
            case IDCANCEL:
                EndDialog(hWnd, GET_WM_COMMAND_ID(wParam, lParam));
                break; 
            }
        }
        break;
        
    case WM_HELP:
        break;
        
    case WM_CONTEXTMENU:
        break;
        
    default:
        return FALSE;
        
    }
    
    return TRUE;
    
}

//------------------------------------------------------------------------------
//
//  EditResourceList_OnInitDialog
//
//  DESCRIPTION:
//
//  PARAMETERS:
//------------------------------------------------------------------------------

BOOL EditResourceList_OnInitDialog(HWND hWnd, HWND hFocusWnd, LPARAM lParam)
{

    ClbSetColumnWidths(hWnd, IDC_LIST_RESOURCE_LISTS, 10);
    /*
    LPEDITVALUEPARAM lpEditValueParam;

    //  Change maximum number of characters of the edit control, to its
    //  maximum limit (from 3000 characters to 4G characters).
    SendDlgItemMessage( hWnd, IDC_VALUEDATA, EM_LIMITTEXT, 0, 0L );

    SetWindowLongPtr(hWnd, DWLP_USER, lParam);
    lpEditValueParam = (LPEDITVALUEPARAM) lParam;

    SetDlgItemText(hWnd, IDC_VALUENAME, lpEditValueParam-> pValueName);
    SetDlgItemText(hWnd, IDC_VALUEDATA, (PTSTR)lpEditValueParam-> pValueData);
    */

    return TRUE;

    UNREFERENCED_PARAMETER(hFocusWnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\regedit\regresed.h ===
//------------------------------------------------------------------------
//
//  Microsoft Windows Shell
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:      regresed.h
//
//  Contents:  REG_RESOURCE_LIST for regedit 
//
//  Classes:   none
//
//------------------------------------------------------------------------

#ifndef _INC_REGRESED
#define _INC_REGRESED

INT_PTR CALLBACK EditResourceListDlgProc(HWND hWnd, UINT Message, WPARAM wParam, LPARAM lParam);
BOOL    EditResourceList_OnInitDialog(HWND hWnd, HWND hFocusWnd, LPARAM lParam);

#endif // _INC_REGSTRED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\regedit\regprint.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGPRINT.H
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        05 Mar 1994
*
*  Print routines for the Registry Editor.
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  05 Mar 1994 TCS Original implementation.
*
*******************************************************************************/

#ifndef _INC_REGPRINT
#define _INC_REGPRINT

extern PRINTDLGEX g_PrintDlg;

void RegEdit_OnCommandPrint(HWND hWnd);
UINT RegEdit_SaveAsSubtree(LPTSTR lpFileName, LPTSTR lpSelectedPath);

#endif // _INC_REGPRINT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\regedit\regresls.cxx ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    regresls.cxx

Abstract:

    This module contains the definitions of the member functions
    of RESOURCE_LIST class.

Author:

    Jaime Sasson (jaimes) 02-Dec-1993

Environment:

    ULIB, User Mode


--*/

#include "regresls.hxx"
#include "iterator.hxx"
#include "regdesc.hxx"
#include "regfdesc.hxx"


DEFINE_CONSTRUCTOR ( RESOURCE_LIST, OBJECT );


RESOURCE_LIST::~RESOURCE_LIST (
    )

/*++

Routine Description:

    Destroy a RESOURCE_LIST.

Arguments:

    None.

Return Value:

    None.

--*/

{
    Destroy();
}


VOID
RESOURCE_LIST::Construct (
    )

/*++

Routine Description:

    Construct a RESOURCE_LIST object.

Arguments:

    None.

Return Value:

    None.

--*/

{
    _FullResourceDescriptors = NULL;
}


VOID
RESOURCE_LIST::Destroy (
    )

/*++

Routine Description:

    Worker method for object destruction.

Arguments:

    None.

Return Value:

    None.

--*/

{
    if( _FullResourceDescriptors != NULL ) {
        _FullResourceDescriptors->DeleteAllMembers();
        DELETE( _FullResourceDescriptors );
    }
    _FullResourceDescriptors = NULL;
}



BOOLEAN
RESOURCE_LIST::Initialize(
    IN  PCBYTE       Data,
    IN  ULONG        Size
    )

/*++

Routine Description:

    Initialize an object of type RESOURCE_LIST.

Arguments:

    Data - Pointer to a buffer that contains a CM_RESOURCE_LIST.

    Size - Buffer size.

Return Value:

    BOOLEAN - Returns TRUE if the initialization succeeds.

--*/

{
    PCM_FULL_RESOURCE_DESCRIPTOR    FullResource;
    ULONG                           Count;
    ULONG                           i;
    PARRAY  TmpList;
    ULONG   BufferSize;
    ULONG   FullDescriptorSize;

    if( Data == NULL ) {
        return( FALSE );
    }

    Count           = ( ( PCM_RESOURCE_LIST )Data )->Count;
    FullResource    = ( ( PCM_RESOURCE_LIST )Data )->List;

    TmpList = ( PARRAY )NEW( ARRAY );
    DebugPtrAssert( TmpList );
    if( ( TmpList == NULL ) ||
        ( !TmpList->Initialize() ) ) {
        DebugPrintTrace(("REGEDT32: Out of memory" ));
        DELETE( TmpList );
        return( FALSE );
    }

    //
    // For each CM_FULL_RESOURCE DESCRIPTOR in the current value...
    //

    BufferSize = Size -             // Data size
                 sizeof( ULONG );   // Count

    for( i = 0; i < Count; i++ ) {

        PFULL_DESCRIPTOR   FullResourceDescriptor;

        FullResourceDescriptor = ( PFULL_DESCRIPTOR )NEW( FULL_DESCRIPTOR );
        if( ( FullResourceDescriptor == NULL ) ||
            !FullResourceDescriptor->Initialize( ( PCBYTE )FullResource,
                                                 BufferSize,
                                                 &FullDescriptorSize )
          ) {
            DebugPrint( "REGEDT32: Unable to create or initialize FullResourcedescriptor \n" );
            DELETE( FullResourceDescriptor );
            TmpList->DeleteAllMembers();
            DELETE( TmpList );
            return( FALSE );
        }
        TmpList->Put( FullResourceDescriptor );

        FullResource = ( PCM_FULL_RESOURCE_DESCRIPTOR )( ( ULONG_PTR )FullResource + FullDescriptorSize );
        BufferSize -= FullDescriptorSize;
    }
    _FullResourceDescriptors = TmpList;
    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\regedit\regprintres.cpp ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    regprintres.cpp

Abstract:

    This file contains the implementation of the member functions
    of PRINT_MANAGER class.

Author:

    Jaime Sasson (jaimes) 18-Sep-1991


Environment:

    Ulib, Regedit, Windows, User Mode


--*/

#include "regprintres.h"
#include "array.hxx"
#include "regsys.hxx"
#include "iterator.hxx"
#include "regresid.h"

extern "C" 
{
    // from regprint.c
    void PrintBinaryData(PBYTE ValueData, UINT cbcbValueData);
    void PrintLiteral(PTSTR lpLiteral);
    void PrintNewLine();
}
 
BOOL PrintString(PWSTRING pwsString)
{
    PrintLiteral((PTSTR)pwsString->GetWSTR());

    return TRUE;
}

void PrintResourceData(PBYTE pbData, UINT uSize, DWORD dwType)
{
    PRINT_RESOURCE::_PrintResources(pbData, uSize, dwType);
}

BOOL        PRINT_RESOURCE::s_StringsInitialized = FALSE;
PWSTRING    PRINT_RESOURCE::s_IndentString;
PWSTRING    PRINT_RESOURCE::s_StringFullDescriptor;
PWSTRING    PRINT_RESOURCE::s_StringInterfaceType;
PWSTRING    PRINT_RESOURCE::s_StringBusNumber;
PWSTRING    PRINT_RESOURCE::s_StringVersion;
PWSTRING    PRINT_RESOURCE::s_StringRevision;
PWSTRING    PRINT_RESOURCE::s_StringPartialDescriptor;
PWSTRING    PRINT_RESOURCE::s_StringResource;
PWSTRING    PRINT_RESOURCE::s_StringDisposition;
PWSTRING    PRINT_RESOURCE::s_StringVector;
PWSTRING    PRINT_RESOURCE::s_StringLevel;
PWSTRING    PRINT_RESOURCE::s_StringAffinity;
PWSTRING    PRINT_RESOURCE::s_StringType;
PWSTRING    PRINT_RESOURCE::s_StringStart;
PWSTRING    PRINT_RESOURCE::s_StringLength;
PWSTRING    PRINT_RESOURCE::s_StringChannel;
PWSTRING    PRINT_RESOURCE::s_StringPort;
PWSTRING    PRINT_RESOURCE::s_StringReserved1;
PWSTRING    PRINT_RESOURCE::s_StringReserved2;
PWSTRING    PRINT_RESOURCE::s_StringDevSpecificData;
PWSTRING    PRINT_RESOURCE::s_StringIoInterfaceType;
PWSTRING    PRINT_RESOURCE::s_StringIoBusNumber;
PWSTRING    PRINT_RESOURCE::s_StringIoSlotNumber;
PWSTRING    PRINT_RESOURCE::s_StringIoListNumber;
PWSTRING    PRINT_RESOURCE::s_StringIoDescriptorNumber;
PWSTRING    PRINT_RESOURCE::s_StringIoOption;
PWSTRING    PRINT_RESOURCE::s_StringIoMinimumVector;
PWSTRING    PRINT_RESOURCE::s_StringIoMaximumVector;
PWSTRING    PRINT_RESOURCE::s_StringIoMinimumAddress;
PWSTRING    PRINT_RESOURCE::s_StringIoMaximumAddress;
PWSTRING    PRINT_RESOURCE::s_StringIoAlignment;
PWSTRING    PRINT_RESOURCE::s_StringIoMinimumChannel;
PWSTRING    PRINT_RESOURCE::s_StringIoMaximumChannel;



//------------------------------------------------------------------------------
// PrintResources
//
// DESCRIPTION: Prints a resouce by type
// 
//------------------------------------------------------------------------------
void PRINT_RESOURCE::_PrintResources(PBYTE pbData, UINT uSize, DWORD dwType)
{
    if(!s_StringsInitialized) 
    {
        s_StringsInitialized = _InitializeStrings();
    }

    if (s_StringsInitialized)
    {
        switch (dwType)
        {
        case REG_RESOURCE_LIST:
            _PrintDataRegResourceList(pbData, uSize);
            break;

        case REG_FULL_RESOURCE_DESCRIPTOR:
            {
                FULL_DESCRIPTOR FullDescriptor;
                if (FullDescriptor.Initialize(pbData, uSize))
                {
                    _PrintFullResourceDescriptor(&FullDescriptor, 0, FALSE);
                }
            }
            break;

        case REG_RESOURCE_REQUIREMENTS_LIST:
            _PrintDataRegRequirementsList(pbData, uSize);
            break;

        default:
            PrintBinaryData(pbData, uSize);
            break;
        }
    }
}


//------------------------------------------------------------------------------
// PrintDataRegResourceList
//
// DESCRIPTION: Initializes the static strings.
// 
//------------------------------------------------------------------------------
BOOL PRINT_RESOURCE::_InitializeStrings()
{
    PWSTR    Buffer;
    ULONG   Size;
    ULONG   Count;
    BOOLEAN fSuccess = TRUE;

    s_IndentString = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_KEY_NAME_INDENT, "" );
    s_StringFullDescriptor = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_FULL_DESCRIPTOR, "" );
    s_StringPartialDescriptor = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_PARTIAL_DESCRIPTOR, "" );
    s_StringInterfaceType = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_INTERFACE_TYPE, "" );
    s_StringBusNumber = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_BUS_NUMBER, "" );
    s_StringVersion = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_VERSION, "" );
    s_StringRevision = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_REVISION, "" );
    s_StringResource = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_RESOURCE, "" );
    s_StringDisposition = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_DISPOSITION, "" );
    s_StringType = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_IO_TYPE, "" );
    s_StringStart = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_START, "" );
    s_StringLength = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_LENGTH, "" );
    s_StringLevel = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_LEVEL, "" );
    s_StringVector = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_VECTOR, "" );
    s_StringAffinity = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_AFFINITY, "" );
    s_StringChannel = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_CHANNEL, "" );
    s_StringPort = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_PORT, "" );
    s_StringReserved1 = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_RESERVED1, "" );
    s_StringReserved2 = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_RESERVED2, "" );
    s_StringDevSpecificData = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_DEV_SPECIFIC_DATA, "" );
    s_StringIoInterfaceType = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_IO_INTERFACE_TYPE, "" );
    s_StringIoBusNumber = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_IO_BUS_NUMBER, "" );
    s_StringIoSlotNumber = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_IO_SLOT_NUMBER, "" );
    s_StringIoListNumber = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_IO_LIST_NUMBER, "" );
    s_StringIoOption = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_IO_OPTION, "" );
    s_StringIoDescriptorNumber = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_IO_DESCRIPTOR_NUMBER, "" );
    s_StringIoAlignment = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_IO_ALIGNMENT, "" );
    s_StringIoMinimumAddress = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_IO_MINIMUM_ADDRESS, "" );
    s_StringIoMaximumAddress = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_IO_MAXIMUM_ADDRESS, "" );
    s_StringIoMinimumVector = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_IO_MINIMUM_VECTOR, "" );
    s_StringIoMaximumVector = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_IO_MAXIMUM_VECTOR, "" );
    s_StringIoMinimumChannel = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_IO_MINIMUM_CHANNEL, "" );
    s_StringIoMaximumChannel = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_IO_MAXIMUM_CHANNEL, "" );
    

    if ((s_StringFullDescriptor == NULL) ||
        (s_StringPartialDescriptor == NULL) ||
        (s_StringInterfaceType == NULL) ||
        (s_StringBusNumber == NULL) ||
        (s_StringVersion == NULL) ||
        (s_StringRevision == NULL) ||
        (s_StringResource == NULL) ||
        (s_StringDisposition == NULL) ||
        (s_StringType == NULL) ||
        (s_StringStart == NULL) ||
        (s_StringLength == NULL) ||
        (s_StringLevel == NULL) ||
        (s_StringVector == NULL) ||
        (s_StringAffinity == NULL) ||
        (s_StringChannel == NULL) ||
        (s_StringPort == NULL) ||
        (s_StringReserved1 == NULL) ||
        (s_StringReserved2 == NULL) ||
        (s_StringDevSpecificData == NULL) ||
        (s_StringIoInterfaceType == NULL) ||
        (s_StringIoBusNumber == NULL) ||
        (s_StringIoSlotNumber == NULL) ||
        (s_StringIoListNumber == NULL) ||
        (s_StringIoOption == NULL) ||
        (s_StringIoDescriptorNumber == NULL) ||
        (s_StringIoAlignment == NULL) ||
        (s_StringIoMinimumAddress == NULL) ||
        (s_StringIoMaximumAddress == NULL) ||
        (s_StringIoMinimumVector == NULL) ||
        (s_StringIoMaximumVector == NULL) ||
        (s_StringIoMinimumChannel == NULL) ||
        (s_StringIoMaximumChannel == NULL))
    {
        DELETE(s_StringFullDescriptor);
        DELETE(s_StringPartialDescriptor);
        DELETE(s_StringInterfaceType);
        DELETE(s_StringBusNumber);
        DELETE(s_StringVersion);
        DELETE(s_StringRevision);
        DELETE(s_StringResource);
        DELETE(s_StringDisposition);
        DELETE(s_StringType);
        DELETE(s_StringStart);
        DELETE(s_StringLength);
        DELETE(s_StringLevel);
        DELETE(s_StringVector);
        DELETE(s_StringAffinity);
        DELETE(s_StringChannel);
        DELETE(s_StringPort);
        DELETE(s_StringReserved1);
        DELETE(s_StringReserved2);
        DELETE(s_StringDevSpecificData);
        DELETE(s_StringIoInterfaceType);
        DELETE(s_StringIoBusNumber);
        DELETE(s_StringIoSlotNumber);
        DELETE(s_StringIoListNumber);
        DELETE(s_StringIoOption);
        DELETE(s_StringIoDescriptorNumber);
        DELETE(s_StringIoAlignment);
        DELETE(s_StringIoMinimumAddress);
        DELETE(s_StringIoMaximumAddress);
        DELETE(s_StringIoMinimumVector);
        DELETE(s_StringIoMaximumVector);
        DELETE(s_StringIoMinimumChannel);
        DELETE(s_StringIoMaximumChannel);

        fSuccess = FALSE;
    }


    return fSuccess;
}


//------------------------------------------------------------------------------
// PrintDataRegResourceList
//
// DESCRIPTION: Print a REG_RESOURCE_LIST stored in a value entry of a registry 
//              key. 
// PARAMETERS:  Data - Pointer to the buffer that contais a REG_RESOURCE_LIST 
//                     data.
//              Size - Number of bytes in the buffer.
//------------------------------------------------------------------------------
void PRINT_RESOURCE::_PrintDataRegResourceList(PBYTE Data, UINT Size)
{
    RESOURCE_LIST       ResourceList;
    PARRAY              FullResourceDescriptors;
    PITERATOR           Iterator;
    PCFULL_DESCRIPTOR   FullDescriptor;
    ULONG               DescriptorNumber;

    PrintNewLine();

    if( ( Size == 0 ) ||
        ( Data == NULL ) ||
        !ResourceList.Initialize( Data, Size ) ) 
    {
        return;
    }

    if( ( ( FullResourceDescriptors = ResourceList.GetFullResourceDescriptors() ) == NULL ) ||
        ( ( Iterator = FullResourceDescriptors->QueryIterator() ) == NULL ) ) 
    {
        return;
    }
    DescriptorNumber = 0;
    while( ( FullDescriptor = ( PCFULL_DESCRIPTOR )( Iterator->GetNext() ) ) != NULL ) 
    {
        if( !_PrintFullResourceDescriptor( FullDescriptor, DescriptorNumber ) ) 
        {
            DELETE( Iterator );
            return;
        }
        DescriptorNumber++;
    }
    DELETE( Iterator );
    return;
}


//------------------------------------------------------------------------------
// PrintFullResourceDescriptor
//
// DESCRIPTION: Print the contents of a FULL_DESCRIPTOR object. 
//
// PARAMETERS:  FullDescriptor - Pointer to object to be printed.
//              DescriptorNumber -
//              PrintDescriptorNumber - A flag that indicates whether or not the 
//                                      descriptor number should be printed.
//------------------------------------------------------------------------------
BOOL PRINT_RESOURCE::_PrintFullResourceDescriptor(PCFULL_DESCRIPTOR FullDescriptor,
    UINT DescriptorNumber, BOOL PrintDescriptorNumber)

{
    DSTRING     FullDescriptorNumberString;

    DSTRING     AuxString;
    DSTRING     InterfaceType;
    DSTRING     BusNumber;
    DSTRING     Version;
    DSTRING     Revision;
    WCHAR       AuxNumber[11];
    PWSTRING     TypeString;
    ULONG       InterfaceId;
    PARRAY      Descriptors;
    PITERATOR   Iterator;
    PCPARTIAL_DESCRIPTOR    PartialDescriptor;
    ULONG       Count;

    if( !FullDescriptorNumberString.Initialize( s_IndentString ) ||
        !FullDescriptorNumberString.Strcat( s_StringFullDescriptor ) ||
        !InterfaceType.Initialize( s_IndentString ) ||
        !InterfaceType.Strcat( s_StringInterfaceType ) ||
        !BusNumber.Initialize( s_IndentString ) ||
        !BusNumber.Strcat( s_StringBusNumber ) ||
        !Version.Initialize( s_IndentString ) ||
        !Version.Strcat( s_StringVersion ) ||
        !Revision.Initialize( s_IndentString ) ||
        !Revision.Strcat( s_StringRevision )
      ) 
    {
        return FALSE;
    }

    //
    //  Build a string that contains the full descriptor number
    //  and print it
    //
    if( PrintDescriptorNumber ) {
        wsprintf( AuxNumber, (LPWSTR)L"%d", DescriptorNumber );
        if( !AuxString.Initialize( AuxNumber ) ) 
        {
            return FALSE;
        }
        FullDescriptorNumberString.Strcat( &AuxString );
        if( !PrintString( &FullDescriptorNumberString ) ) 
        {
            return FALSE;
        }
    }
    PrintNewLine();

    //
    // Print the interface type

    switch( FullDescriptor->GetInterfaceType() ) 
    {

    case Internal:

        InterfaceId =  IDS_BUS_INTERNAL;
        break;

    case Isa:

        InterfaceId =  IDS_BUS_ISA;
        break;

    case Eisa:

        InterfaceId =  IDS_BUS_EISA;
        break;

    case MicroChannel:

        InterfaceId =  IDS_BUS_MICRO_CHANNEL;
        break;

    case TurboChannel:

        InterfaceId =  IDS_BUS_TURBO_CHANNEL;
        break;

    case PCIBus:

        InterfaceId =  IDS_BUS_PCI_BUS;
        break;

    case VMEBus:

        InterfaceId =  IDS_BUS_VME_BUS;
        break;

    case NuBus:

        InterfaceId =  IDS_BUS_NU_BUS;
        break;

    case PCMCIABus:

		InterfaceId =  IDS_BUS_PCMCIA_BUS;
        break;

    case CBus:

        InterfaceId =  IDS_BUS_C_BUS;
        break;

    case MPIBus:

        InterfaceId =  IDS_BUS_MPI_BUS;
        break;

    case MPSABus:

        InterfaceId =  IDS_BUS_MPSA_BUS;
        break;

    default:

        InterfaceId =  IDS_INVALID;
        break;
    }

    TypeString =  REGEDIT_BASE_SYSTEM::QueryString( InterfaceId, "" );

    if( TypeString == NULL ) 
    {
        return FALSE;
    }
    InterfaceType.Strcat( TypeString );
    DELETE( TypeString );
    if(!PrintString( &InterfaceType )) 
    {
        return FALSE;
    }
    PrintNewLine();

    //
    //  Print the bus number
    //
    wsprintf( AuxNumber, (LPWSTR)L"%d", FullDescriptor->GetBusNumber() );
    if( !AuxString.Initialize( AuxNumber ) ) 
    {
        return FALSE;
    }
    BusNumber.Strcat( &AuxString );

    if( !PrintString( &BusNumber ) ) 
    {
        return FALSE;
    }
    PrintNewLine();

    //
    // Print version
    //
    wsprintf( AuxNumber, (LPWSTR)L"%d", FullDescriptor->GetVersion() );
    if( !AuxString.Initialize( AuxNumber ) ) 
    {
        return FALSE;
    }
    Version.Strcat( &AuxString );
    if( !PrintString( &Version ) ) 
    {
        return FALSE;
    }
    PrintNewLine();

    //
    // Print revision
    //
    wsprintf( AuxNumber, (LPWSTR)L"%d", FullDescriptor->GetRevision() );
    if( !AuxString.Initialize( AuxNumber ) ) 
    {
        return FALSE;
    }
    Revision.Strcat( &AuxString );
    if( !PrintString( &Revision ) ) 
    {
        return FALSE;
    }
    PrintNewLine();

    Descriptors = FullDescriptor->GetResourceDescriptors();
    if( ( Descriptors == NULL ) ||
        ( ( Iterator = Descriptors->QueryIterator() ) == NULL )
      ) 
    {
        return FALSE;
    }
    Count = 0;
    while( ( PartialDescriptor = ( PCPARTIAL_DESCRIPTOR )( Iterator->GetNext() ) ) != NULL ) 
    {
        if( !_PrintPartialDescriptor( PartialDescriptor, Count ) ) 
        {
            DELETE( Iterator );
            return FALSE;
        }
        Count++;
    }
    DELETE( Iterator );

    PrintNewLine();

    return TRUE;
}


//------------------------------------------------------------------------------
// PrintPartialDescriptor
//
// DESCRIPTION: Print the contents of a PARTIAL_DESCRIPTOR object. 
//
// PARAMETERS:  PartialDescriptor - Pointer to object to be printed.
//              DescriptorNumber -    
//------------------------------------------------------------------------------
BOOL PRINT_RESOURCE::_PrintPartialDescriptor(PCPARTIAL_DESCRIPTOR PartialDescriptor,
    ULONG DescriptorNumber)
{
    DSTRING     PartialDescriptorNumberString;

    DSTRING     AuxString;
    WCHAR       AuxNumber[11];
    DSTRING     ResourceString;
    DSTRING     DispositionString;
    ULONG       StringId;
    PWSTRING    String;

    if( !PartialDescriptorNumberString.Initialize( s_IndentString ) ||
        !PartialDescriptorNumberString.Strcat( s_StringPartialDescriptor ) ||
        !ResourceString.Initialize( s_IndentString ) ||
        !ResourceString.Strcat( s_StringResource ) ||
        !DispositionString.Initialize( s_IndentString ) ||
        !DispositionString.Strcat( s_StringDisposition )
      ) 
    {
        return FALSE;
    }

    //
    //  Build a string that contains the full descriptor number
    //  and print it
    //
    wsprintf( AuxNumber, (LPWSTR)L"%d", DescriptorNumber );
    if( !AuxString.Initialize( AuxNumber ) ) 
    {
        return FALSE;
    }
    PartialDescriptorNumberString.Strcat( &AuxString );
    if( !PrintString( &PartialDescriptorNumberString ) ) 
    {
        return FALSE;
    }
    PrintNewLine();

    //
    //  Print the resource type
    //
    if( PartialDescriptor->IsDescriptorTypeDma() ) {
        StringId = IDS_DEV_DMA;
    } else if( PartialDescriptor->IsDescriptorTypeInterrupt() ) {
        StringId = IDS_DEV_INTERRUPT;
    } else if( PartialDescriptor->IsDescriptorTypeMemory() ) {
        StringId = IDS_DEV_MEMORY;
    } else if( PartialDescriptor->IsDescriptorTypePort() ) {
        StringId = IDS_DEV_PORT;
    } else if( PartialDescriptor->IsDescriptorTypeDeviceSpecific() ) {
        StringId = IDS_DEV_DEVICE_SPECIFIC;
    } else {
        StringId = IDS_INVALID;
    }
    String =  REGEDIT_BASE_SYSTEM::QueryString( StringId, "" );

    if( String == NULL ) 
    {
        return FALSE;
    }
    ResourceString.Strcat( String );
    DELETE( String );
    if( !PrintString( &ResourceString ) ) 
    {
        return FALSE;
    }
    PrintNewLine();


    //
    //  Print the disposition
    //
    if( PartialDescriptor->IsResourceShareUndetermined() ) {
        StringId = IDS_SHARE_UNDETERMINED;
    } else if( PartialDescriptor->IsResourceShareDeviceExclusive() ) {
        StringId = IDS_SHARE_DEVICE_EXCLUSIVE;
    } else if( PartialDescriptor->IsResourceShareDriverExclusive() ) {
        StringId = IDS_SHARE_DRIVER_EXCLUSIVE;
    } else {
        StringId = IDS_SHARE_SHARED;
    }

    String =  REGEDIT_BASE_SYSTEM::QueryString( StringId, "" );

    if( String == NULL ) 
    {
        return FALSE;
    }
    DispositionString.Strcat( String );
    DELETE( String );
    if( !PrintString( &DispositionString ) ) 
    {
        return FALSE;
    }
    PrintNewLine();

    if( PartialDescriptor->IsDescriptorTypeDma() ) 
    {
        if( !_PrintDmaDescriptor( ( PCDMA_DESCRIPTOR )PartialDescriptor ) ) 
        {
            return FALSE;
        }
    } 
    else if( PartialDescriptor->IsDescriptorTypeInterrupt() ) 
    {
        if( !_PrintInterruptDescriptor( ( PCINTERRUPT_DESCRIPTOR )PartialDescriptor ) ) 
        {
            return FALSE;
        }
    } 
    else if( PartialDescriptor->IsDescriptorTypeMemory() ) 
    {
        if( !_PrintMemoryDescriptor( ( PCMEMORY_DESCRIPTOR )PartialDescriptor ) ) 
        {
            return FALSE;
        }
    } 
    else if( PartialDescriptor->IsDescriptorTypePort() ) 
    {
        if( !_PrintPortDescriptor( ( PCPORT_DESCRIPTOR )PartialDescriptor ) ) 
        {
            return FALSE;
        }
    } 
    else if( PartialDescriptor->IsDescriptorTypeDeviceSpecific() ) 
    {
        if( !_PrintDeviceSpecificDescriptor( ( PCDEVICE_SPECIFIC_DESCRIPTOR )PartialDescriptor ) ) 
        {
            return FALSE;
        }
    }
    PrintNewLine();

    return TRUE;
}


//------------------------------------------------------------------------------
// PrintInterruptDescriptor
//
// DESCRIPTION: Print the contents of a INTERRUPT_DESCRIPTOR object.
//
// PARAMETERS:  Descriptor - Pointer to object to be printed.
//------------------------------------------------------------------------------
BOOL PRINT_RESOURCE::_PrintInterruptDescriptor(PCINTERRUPT_DESCRIPTOR Descriptor)
{
    DSTRING     VectorString;
    DSTRING     LevelString;
    DSTRING     AffinityString;;
    DSTRING     TypeString;

    DSTRING     AuxString;
    WCHAR       AuxNumber[19];
    ULONG       StringId;
    PWSTRING    String;

    if( !VectorString.Initialize( s_IndentString ) ||
        !VectorString.Strcat( s_StringVector ) ||
        !LevelString.Initialize( s_IndentString ) ||
        !LevelString.Strcat( s_StringLevel ) ||
        !AffinityString.Initialize( s_IndentString ) ||
        !AffinityString.Strcat( s_StringAffinity ) ||
        !TypeString.Initialize( s_IndentString ) ||
        !TypeString.Strcat( s_StringType )
      ) 
    {
        return FALSE;
    }

    //
    //  Print the vector
    //
    wsprintf( AuxNumber, (LPWSTR)L"%d", Descriptor->GetVector() );
    if( !AuxString.Initialize( AuxNumber ) ) 
    {
        return FALSE;
    }
    VectorString.Strcat( &AuxString );
    if( !PrintString( &VectorString ) ) 
    {
        return FALSE;
    }
    PrintNewLine();

    //
    //  Print the level
    //
    wsprintf( AuxNumber, (LPWSTR)L"%d", Descriptor->GetLevel() );
    if( !AuxString.Initialize( AuxNumber ) ) 
    {
        return FALSE;
    }
    LevelString.Strcat( &AuxString );
    if( !PrintString( &LevelString ) ) 
    {
        return FALSE;
    }
    PrintNewLine();

    //
    //  Print the affinity
    //
    wsprintf( AuxNumber, (LPWSTR)L"0x%08x", Descriptor->GetAffinity() );
    if( !AuxString.Initialize( AuxNumber ) ) 
    {
        return FALSE;
    }
    AffinityString.Strcat( &AuxString );
    if( !PrintString( &AffinityString ) ) 
    {
        return FALSE;
    }
    PrintNewLine();

    //  Print the type
    StringId = ( Descriptor->IsInterruptLevelSensitive() )? IDS_INT_LEVEL_SENSITIVE :
                                                            IDS_INT_LATCHED;

    String =  REGEDIT_BASE_SYSTEM::QueryString( StringId, "" );
    if( String == NULL ) 
    {
        return FALSE;
    }
    TypeString.Strcat( String );
    DELETE( String );
    if( !PrintString( &TypeString ) ) 
    {
        return FALSE;
    }
    PrintNewLine();

    return TRUE;
}

//------------------------------------------------------------------------------
// PrintPortDescriptor
//
// DESCRIPTION: Print the contents of a PORT_DESCRIPTOR object.
//
// PARAMETERS:  Descriptor - Pointer to object to be printed.
//------------------------------------------------------------------------------
BOOL PRINT_RESOURCE::_PrintPortDescriptor(PCPORT_DESCRIPTOR Descriptor)
{
    DSTRING     StartAddressString;
    DSTRING     LengthString;
    DSTRING     TypeString;

    DSTRING     AuxString;
    WCHAR       AuxNumber[19];
    ULONG       StringId;
    PWSTRING    String;

    if( !StartAddressString.Initialize( s_IndentString ) ||
        !StartAddressString.Strcat( s_StringStart ) ||
        !LengthString.Initialize( s_IndentString ) ||
        !LengthString.Strcat( s_StringLength ) ||
        !TypeString.Initialize( s_IndentString ) ||
        !TypeString.Strcat( s_StringType )
      ) {
        DebugPrint( "REGEDT32: Initialization failure" );
        return FALSE;
    }

    //
    //  Print the start address
    //
    if( ( ( ( PPORT_DESCRIPTOR )Descriptor )->GetPhysicalAddress() )->HighPart != 0 ) {
        wsprintf( AuxNumber,
                  (LPWSTR)L"0x%08x%08x",
                  ( ( ( PPORT_DESCRIPTOR )Descriptor )->GetPhysicalAddress() )->HighPart,
                  ( ( ( PPORT_DESCRIPTOR )Descriptor )->GetPhysicalAddress() )->LowPart );
    } else {
        wsprintf( AuxNumber, (LPWSTR)L"0x%08x", ( ( ( PPORT_DESCRIPTOR )Descriptor )->GetPhysicalAddress() )->LowPart );
    }
    if( !AuxString.Initialize( AuxNumber ) ) {
        DebugPrint( "AuxString.Initialize() failed" );
        return FALSE;
    }
    StartAddressString.Strcat( &AuxString );
    if( !PrintString( &StartAddressString ) ) {
        return FALSE;
    }
    PrintNewLine();

    //
    //  Print the length
    //
    wsprintf( AuxNumber, (LPWSTR)L"%#x", Descriptor->GetLength() );
    if( !AuxString.Initialize( AuxNumber ) ) {
        DebugPrint( "AuxString.Initialize() failed" );
        return FALSE;
    }
    LengthString.Strcat( &AuxString );
    if( !PrintString( &LengthString ) ) {
        return FALSE;
    }
    PrintNewLine();

    //
    //  Print the type
    //

    StringId = ( Descriptor->IsPortMemory() )? IDS_PORT_MEMORY :
                                               IDS_PORT_PORT;

    String =  REGEDIT_BASE_SYSTEM::QueryString( StringId, "" );
    if( String == NULL ) {
        DebugPrintTrace(( "REGEDT32: Unable to retrieve string \n" ));
        return FALSE;
    }
    TypeString.Strcat( String );
    DELETE( String );
    if( !PrintString( &TypeString ) ) {
        return FALSE;
    }
    PrintNewLine();

    return TRUE;
}


//------------------------------------------------------------------------------
// PrintMemoryDescriptor
//
// DESCRIPTION: Print the contents of a MEMORY_DESCRIPTOR object.
//
// PARAMETERS:  Descriptor - Pointer to object to be printed.
//------------------------------------------------------------------------------
BOOL PRINT_RESOURCE::_PrintMemoryDescriptor(PCMEMORY_DESCRIPTOR   Descriptor)
{
    DSTRING     StartAddressString;
    DSTRING     LengthString;
    DSTRING     TypeString;

    DSTRING     AuxString;
    WCHAR       AuxNumber[19];
    ULONG       StringId;
    PWSTRING    String;

    if( !StartAddressString.Initialize( s_IndentString ) ||
        !StartAddressString.Strcat( s_StringStart ) ||
        !LengthString.Initialize( s_IndentString ) ||
        !LengthString.Strcat( s_StringLength ) ||
        !TypeString.Initialize( s_IndentString ) ||
        !TypeString.Strcat( s_StringType )
      ) {
        DebugPrint( "REGEDT32: Initialization failure" );
        return FALSE;
    }

    //
    //  Print the start address
    //
    if( ( ( ( PMEMORY_DESCRIPTOR )Descriptor )->GetStartAddress() )->HighPart != 0 ) {
        wsprintf( AuxNumber,
                  (LPWSTR)L"0x%08x%08x",
                  ( ( ( PMEMORY_DESCRIPTOR )Descriptor )->GetStartAddress() )->HighPart,
                  ( ( ( PMEMORY_DESCRIPTOR )Descriptor )->GetStartAddress() )->LowPart );
    } else {
        wsprintf( AuxNumber, (LPWSTR)L"0x%08x", ( ( ( PMEMORY_DESCRIPTOR )Descriptor )->GetStartAddress() )->LowPart );
    }
    if( !AuxString.Initialize( AuxNumber ) ) {
        DebugPrint( "AuxString.Initialize() failed" );
        return FALSE;
    }
    StartAddressString.Strcat( &AuxString );
    if( !PrintString( &StartAddressString ) ) {
        return FALSE;
    }
    PrintNewLine();

    //
    //  Print the length
    //
    wsprintf( AuxNumber, (LPWSTR)L"%#x", Descriptor->GetLength() );
    if( !AuxString.Initialize( AuxNumber ) ) {
        DebugPrint( "AuxString.Initialize() failed" );
        return FALSE;
    }
    LengthString.Strcat( &AuxString );
    if( !PrintString( &LengthString ) ) {
        return FALSE;
    }
    PrintNewLine();

    //
    //  Print the type
    //

    StringId = ( Descriptor->IsMemoryReadWrite() )? IDS_MEM_READ_WRITE :
                                                    ( ( Descriptor->IsMemoryReadWrite() )? IDS_MEM_READ_ONLY :
                                                                                           IDS_MEM_WRITE_ONLY );

    String =  REGEDIT_BASE_SYSTEM::QueryString( StringId, "" );
    if( String == NULL ) {
        DebugPrintTrace(( "REGEDT32: Unable to retrieve string \n" ));
        return FALSE;
    }
    TypeString.Strcat( String );
    DELETE( String );
    if( !PrintString( &TypeString ) ) {
        return FALSE;
    }
    PrintNewLine();

    return TRUE;
}


//------------------------------------------------------------------------------
// PrintDmaDescriptor
//
// DESCRIPTION: Print the contents of a DMA_DESCRIPTOR object.
//
// PARAMETERS:  Descriptor - Pointer to object to be printed.
//------------------------------------------------------------------------------
BOOL PRINT_RESOURCE::_PrintDmaDescriptor(PCDMA_DESCRIPTOR   Descriptor)
{
    DSTRING     ChannelString;
    DSTRING     PortString;

    DSTRING     AuxString;
    WCHAR       AuxNumber[19];

    if( !ChannelString.Initialize( s_IndentString ) ||
        !ChannelString.Strcat( s_StringChannel ) ||
        !PortString.Initialize( s_IndentString ) ||
        !PortString.Strcat( s_StringPort )
      ) {
        DebugPrint( "REGEDT32: Initialization failure" );
        return FALSE;
    }

    //
    //  Print the channel
    //
    wsprintf( AuxNumber, (LPWSTR)L"%d", Descriptor->GetChannel() );

    if( !AuxString.Initialize( AuxNumber ) ) {
        DebugPrint( "AuxString.Initialize() failed" );
        return FALSE;
    }
    ChannelString.Strcat( &AuxString );
    if( !PrintString( &ChannelString ) ) {
        return FALSE;
    }
    PrintNewLine();

    //
    //  Print the port
    //
    wsprintf( AuxNumber, (LPWSTR)L"%d", Descriptor->GetPort() );
    if( !AuxString.Initialize( AuxNumber ) ) {
        DebugPrint( "AuxString.Initialize() failed" );
        return FALSE;
    }
    PortString.Strcat( &AuxString );
    if( !PrintString( &PortString ) ) {
        return FALSE;
    }
    PrintNewLine();

    return TRUE;
}


//------------------------------------------------------------------------------
// PrintDeviceSpecificDescriptor
//
// DESCRIPTION: Print the contents of a DEVICE_SPECIFIC_DESCRIPTOR object.
//
// PARAMETERS:  Descriptor - Pointer to object to be printed.
//------------------------------------------------------------------------------
BOOL PRINT_RESOURCE::_PrintDeviceSpecificDescriptor(PCDEVICE_SPECIFIC_DESCRIPTOR Descriptor)
{
    DSTRING     Reserved1String;
    DSTRING     Reserved2String;
    DSTRING     DataString;

    DSTRING     AuxString;
    WCHAR       AuxNumber[19];

    ULONG       Size;
    PCBYTE      Data;

    if( !Reserved1String.Initialize( s_IndentString ) ||
        !Reserved1String.Strcat( s_StringReserved1 ) ||
        !Reserved2String.Initialize( s_IndentString ) ||
        !Reserved2String.Strcat( s_StringReserved2 ) ||
        !DataString.Initialize( s_IndentString ) ||
        !DataString.Strcat( s_StringDevSpecificData )
      ) {
        DebugPrint( "REGEDT32: Initialization failure" );
        return FALSE;
    }

    //
    //  Print reserved1
    //
    wsprintf( AuxNumber, (LPWSTR)L"0x%08x", Descriptor->GetReserved1() );

    if( !AuxString.Initialize( AuxNumber ) ) {
        DebugPrint( "AuxString.Initialize() failed" );
        return FALSE;
    }
    Reserved1String.Strcat( &AuxString );
    if( !PrintString( &Reserved1String ) ) {
        return FALSE;
    }
    PrintNewLine();

    //
    //  Print reserved2
    //
    wsprintf( AuxNumber, (LPWSTR)L"0x%08x", Descriptor->GetReserved2() );
    if( !AuxString.Initialize( AuxNumber ) ) {
        DebugPrint( "AuxString.Initialize() failed" );
        return FALSE;
    }
    Reserved2String.Strcat( &AuxString );
    if( !PrintString( &Reserved2String ) ) {
        return FALSE;
    }
    PrintNewLine();

    Size = Descriptor->GetData( &Data );
    if( ( Size != 0 ) &&
        ( Data != NULL ) ) {
        if( !PrintString( &DataString ) ) 
        {
            return FALSE;
        }
        PrintBinaryData((PBYTE)Data, Size);
        PrintNewLine();
    }
    return TRUE;
}


//------------------------------------------------------------------------------
// PrintDataRegRequirementsList
//
// DESCRIPTION: Print the contents of a DEVICE_SPECIFIC_DESCRIPTOR object.
//
// PARAMETERS:  
//------------------------------------------------------------------------------
BOOL PRINT_RESOURCE::_PrintDataRegRequirementsList(PBYTE Data, ULONG Size)
{
    IO_REQUIREMENTS_LIST    RequirementsList;
    PARRAY                  AlternativeLists;
    PITERATOR               Iterator;
    PCIO_DESCRIPTOR_LIST    ResourceList;
    ULONG                   ListNumber;

    DSTRING     AuxString;
    DSTRING     InterfaceType;
    DSTRING     BusNumber;
    DSTRING     SlotNumber;
    WCHAR       AuxNumber[11];
    PWSTRING     TypeString;
    ULONG       InterfaceId;

    PrintNewLine();

    if( ( Size == 0 ) ||
        ( Data == NULL ) ||
        !RequirementsList.Initialize( Data, Size ) ) {
        DebugPrintTrace(( "REGEDT32: Unable to initialize RequirementsList \n" ));
        return FALSE;
    }

    if( !InterfaceType.Initialize( s_IndentString ) ||
        !InterfaceType.Strcat( s_StringIoInterfaceType ) ||
        !BusNumber.Initialize( s_IndentString ) ||
        !BusNumber.Strcat( s_StringIoBusNumber ) ||
        !SlotNumber.Initialize( s_IndentString ) ||
        !SlotNumber.Strcat( s_StringIoSlotNumber )
      ) {
        DebugPrint( "REGEDT32: Initialization failure" );
        return FALSE;
    }

    //
    //  Print the interface type
    //

    switch( RequirementsList.GetInterfaceType() ) {

    case Internal:

        InterfaceId =  IDS_BUS_INTERNAL;
        break;

    case Isa:

        InterfaceId =  IDS_BUS_ISA;
        break;

    case Eisa:

        InterfaceId =  IDS_BUS_EISA;
        break;

    case MicroChannel:

        InterfaceId =  IDS_BUS_MICRO_CHANNEL;
        break;

    case TurboChannel:

        InterfaceId =  IDS_BUS_TURBO_CHANNEL;
        break;

    case PCIBus:

        InterfaceId =  IDS_BUS_PCI_BUS;
        break;

    case VMEBus:

        InterfaceId =  IDS_BUS_VME_BUS;
        break;

    case NuBus:

        InterfaceId =  IDS_BUS_NU_BUS;
        break;

    case PCMCIABus:

        InterfaceId =  IDS_BUS_PCMCIA_BUS;
        break;

    case CBus:

        InterfaceId =  IDS_BUS_C_BUS;
        break;

    case MPIBus:

        InterfaceId =  IDS_BUS_MPI_BUS;
        break;

    case MPSABus:

        InterfaceId =  IDS_BUS_MPSA_BUS;
        break;

    default:

        InterfaceId =  IDS_INVALID;
        break;
    }

    TypeString =  REGEDIT_BASE_SYSTEM::QueryString( InterfaceId, "" );

    if( TypeString == NULL ) {
        DebugPrintTrace(( "REGEDT32: Unable to retrieve string \n" ));
        return FALSE;
    }
    InterfaceType.Strcat( TypeString );
    DELETE( TypeString );
    if( !PrintString( &InterfaceType ) ) {
        return FALSE;
    }
    PrintNewLine();


    //
    //  Print the bus number
    //
    wsprintf( AuxNumber, (LPWSTR)L"%d", RequirementsList.GetBusNumber() );
    if( !AuxString.Initialize( AuxNumber ) ) {
        DebugPrint( "AuxString.Initialize() failed" );
        return FALSE;
    }
    BusNumber.Strcat( &AuxString );

    if( !PrintString( &BusNumber ) ) {
        return FALSE;
    }
    PrintNewLine();

    //
    //  Print the slot number
    //
    wsprintf( AuxNumber, (LPWSTR)L"%d", RequirementsList.GetSlotNumber() );
    if( !AuxString.Initialize( AuxNumber ) ) {
        DebugPrint( "AuxString.Initialize() failed" );
        return FALSE;
    }
    SlotNumber.Strcat( &AuxString );

    if( !PrintString( &SlotNumber ) ) {
        return FALSE;
    }
    PrintNewLine();

    //
    //  Print the resource lists
    //

    if( ( ( AlternativeLists = RequirementsList.GetAlternativeLists() ) == NULL ) ||
        ( ( Iterator = AlternativeLists->QueryIterator() ) == NULL ) ) {
        DebugPrintTrace(( "REGEDT32: Out of memory! \n" ));
        return FALSE;
    }
    ListNumber = 0;
    while( ( ResourceList = ( PCIO_DESCRIPTOR_LIST )( Iterator->GetNext() ) ) != NULL ) {
        if( !_PrintIoResourceList( ResourceList, ListNumber ) ) {
            DELETE( Iterator );
            return FALSE;
        }
        ListNumber++;
    }
    DELETE( Iterator );
    return TRUE;
}


//------------------------------------------------------------------------------
// PrintIoResourceList
//
// DESCRIPTION: Print the contents of an IO_DESCRIPTOR_LIST object.
//
// PARAMETERS:  Descriptor - Pointer to object to be printed.
//------------------------------------------------------------------------------
BOOL PRINT_RESOURCE::_PrintIoResourceList(PCIO_DESCRIPTOR_LIST DescriptorList, UINT ListNumber)
{
    DSTRING     ListNumberString;

    DSTRING     AuxString;
    WCHAR       AuxNumber[11];
    PARRAY      Descriptors;
    PITERATOR   Iterator;
    PCIO_DESCRIPTOR    IoDescriptor;
    ULONG       Count;

    if( !ListNumberString.Initialize( s_IndentString ) ||
        !ListNumberString.Strcat( s_StringIoListNumber )
      ) {
        DebugPrint( "REGEDT32: Initialization failure" );
        return FALSE;
    }

    //
    //  Build a string that contains the list number
    //  and print it
    //
    wsprintf( AuxNumber, (LPWSTR)L"%d", ListNumber );
    if( !AuxString.Initialize( AuxNumber ) ) {
    DebugPrint( "AuxString.Initialize() failed" );
        return FALSE;
    }
    ListNumberString.Strcat( &AuxString );
    if( !PrintString( &ListNumberString ) ) {
        return FALSE;
    }
    PrintNewLine();

    Descriptors = DescriptorList->GetDescriptorsList();
    if( ( Descriptors == NULL ) ||
        ( ( Iterator = Descriptors->QueryIterator() ) == NULL )
      ) {
        return FALSE;
    }
    Count = 0;
    while( ( IoDescriptor = ( PCIO_DESCRIPTOR )( Iterator->GetNext() ) ) != NULL ) {
        if( !_PrintIoDescriptor( IoDescriptor, Count ) ) {
            DELETE( Iterator );
            return FALSE;
        }
        Count++;
    }
    DELETE( Iterator );

    PrintNewLine();

    return TRUE;
}


//------------------------------------------------------------------------------
// PrintIoDescriptor
//
// DESCRIPTION: Print the contents of an IO_DESCRIPTOR object.
//
// PARAMETERS:  Descriptor - Pointer to object to be printed.
//------------------------------------------------------------------------------
BOOL PRINT_RESOURCE::_PrintIoDescriptor(PCIO_DESCRIPTOR IoDescriptor, ULONG DescriptorNumber)
{
    DSTRING     IoDescriptorNumberString;

    DSTRING     AuxString;
    WCHAR       AuxNumber[11];
    DSTRING     ResourceString;
    DSTRING     DispositionString;
    DSTRING     OptionString;
    ULONG       StringId;
    PWSTRING    String;

    if( !IoDescriptorNumberString.Initialize( s_IndentString ) ||
        !IoDescriptorNumberString.Strcat( s_StringIoDescriptorNumber ) ||
        !ResourceString.Initialize( s_IndentString ) ||
        !ResourceString.Strcat( s_StringResource ) ||
        !OptionString.Initialize( s_IndentString ) ||
        !OptionString.Strcat( s_StringIoOption ) ||
        !DispositionString.Initialize( s_IndentString ) ||
        !DispositionString.Strcat( s_StringDisposition )
      ) {
        DebugPrint( "REGEDT32: Initialization failure" );
        return FALSE;
    }

    //
    //  Build a string that contains the full descriptor number
    //  and print it
    //
    wsprintf( AuxNumber, (LPWSTR)L"%d", DescriptorNumber );
    if( !AuxString.Initialize( AuxNumber ) ) {
        DebugPrint( "AuxString.Initialize() failed" );
        return FALSE;
    }
    IoDescriptorNumberString.Strcat( &AuxString );
    if( !PrintString( &IoDescriptorNumberString ) ) {
        return FALSE;
    }
    PrintNewLine();

    //
    //  Print the resource type
    //
    if( IoDescriptor->IsDescriptorTypeDma() ) {
        StringId = IDS_DEV_DMA;
    } else if( IoDescriptor->IsDescriptorTypeInterrupt() ) {
        StringId = IDS_DEV_INTERRUPT;
    } else if( IoDescriptor->IsDescriptorTypeMemory() ) {
        StringId = IDS_DEV_MEMORY;
    } else if( IoDescriptor->IsDescriptorTypePort() ) {
        StringId = IDS_DEV_PORT;
    } else {
        StringId = IDS_INVALID;
    }
    String =  REGEDIT_BASE_SYSTEM::QueryString( StringId, "" );

    if( String == NULL ) 
    {
        DebugPrintTrace(( "REGEDT32: Unable to retrieve string \n" ));
        return FALSE;
    }
    ResourceString.Strcat( String );
    DELETE( String );
    if( !PrintString( &ResourceString ) ) {
        return FALSE;
    }
    PrintNewLine();

    //
    //  Print the option
    //

    wsprintf( AuxNumber, (LPWSTR)L"0x%08x", IoDescriptor->GetOption() );
    if( !AuxString.Initialize( AuxNumber ) ) {
        DebugPrint( "AuxString.Initialize() failed" );
        return FALSE;
    }
    OptionString.Strcat( &AuxString );
    if( !PrintString( &OptionString ) ) {
        return FALSE;
    }
    PrintNewLine();



    //
    //  Print the disposition
    //
    if( IoDescriptor->IsResourceShareUndetermined() ) {
        StringId = IDS_SHARE_UNDETERMINED;
    } else if( IoDescriptor->IsResourceShareDeviceExclusive() ) {
        StringId = IDS_SHARE_DEVICE_EXCLUSIVE;
    } else if( IoDescriptor->IsResourceShareDriverExclusive() ) {
        StringId = IDS_SHARE_DRIVER_EXCLUSIVE;
    } else {
        StringId = IDS_SHARE_SHARED;
    }

    String =  REGEDIT_BASE_SYSTEM::QueryString( StringId, "" );

    if( String == NULL ) {
        DebugPrintTrace(( "REGEDT32: Unable to retrieve string \n" ));
        return FALSE;
    }
    DispositionString.Strcat( String );
    DELETE( String );
    if( !PrintString( &DispositionString ) ) {
        return FALSE;
    }
    PrintNewLine();

    if( IoDescriptor->IsDescriptorTypeDma() ) {
        if( !_PrintIoDmaDescriptor( ( PCIO_DMA_DESCRIPTOR )IoDescriptor ) ) {
            return FALSE;
        }
    } else if( IoDescriptor->IsDescriptorTypeInterrupt() ) {
        if( !_PrintIoInterruptDescriptor( ( PCIO_INTERRUPT_DESCRIPTOR )IoDescriptor ) ) {
            return FALSE;
        }
    } else if( IoDescriptor->IsDescriptorTypeMemory() ) {
        if( !_PrintIoMemoryDescriptor( ( PCIO_MEMORY_DESCRIPTOR )IoDescriptor ) ) {
            return FALSE;
        }
    } else if( IoDescriptor->IsDescriptorTypePort() ) {
        if( !_PrintIoPortDescriptor( ( PCIO_PORT_DESCRIPTOR )IoDescriptor ) ) {
            return FALSE;
        }
    }

    PrintNewLine();

    return TRUE;
}


//------------------------------------------------------------------------------
// PrintIoInterruptDescriptor
//
// DESCRIPTION: Print the contents of an IO_INTERRUPT_DESCRIPTOR object.
//
// PARAMETERS:  Descriptor - Pointer to object to be printed.
//------------------------------------------------------------------------------
BOOL PRINT_RESOURCE::_PrintIoInterruptDescriptor(PCIO_INTERRUPT_DESCRIPTOR Descriptor)
{
    DSTRING     MinimumVectorString;
    DSTRING     MaximumVectorString;
    DSTRING     TypeString;

    DSTRING     AuxString;
    WCHAR       AuxNumber[19];
    ULONG       StringId;
    PWSTRING    String;

    if( !MinimumVectorString.Initialize( s_IndentString ) ||
        !MinimumVectorString.Strcat( s_StringIoMinimumVector ) ||
        !MaximumVectorString.Initialize( s_IndentString ) ||
        !MaximumVectorString.Strcat( s_StringIoMaximumVector ) ||
        !TypeString.Initialize( s_IndentString ) ||
        !TypeString.Strcat( s_StringType )
      ) {
        DebugPrint( "REGEDT32: Initialization failure" );
        return FALSE;
    }

    //
    //  Print the type
    //

    StringId = ( Descriptor->IsInterruptLevelSensitive() )? IDS_INT_LEVEL_SENSITIVE :
                                                            IDS_INT_LATCHED;

    String =  REGEDIT_BASE_SYSTEM::QueryString( StringId, "" );
    if( String == NULL ) {
        DebugPrintTrace(( "REGEDT32: Unable to retrieve string \n" ));
        return FALSE;
    }
    TypeString.Strcat( String );
    DELETE( String );
    if( !PrintString( &TypeString ) ) {
        return FALSE;
    }
    PrintNewLine();

    //
    //  Print the minimum vector
    //
    wsprintf( AuxNumber, (LPWSTR)L"%#x", Descriptor->GetMinimumVector() );
    if( !AuxString.Initialize( AuxNumber ) ) {
        DebugPrint( "AuxString.Initialize() failed" );
        return FALSE;
    }
    MinimumVectorString.Strcat( &AuxString );
    if( !PrintString( &MinimumVectorString ) ) {
        return FALSE;
    }
    PrintNewLine();

    //
    //  Print the maximum vector
    //
    wsprintf( AuxNumber, (LPWSTR)L"%#x", Descriptor->GetMaximumVector() );
    if( !AuxString.Initialize( AuxNumber ) ) {
        DebugPrint( "AuxString.Initialize() failed" );
        return FALSE;
    }
    MaximumVectorString.Strcat( &AuxString );
    if( !PrintString( &MaximumVectorString ) ) {
        return FALSE;
    }
    PrintNewLine();

    return TRUE;
}


//------------------------------------------------------------------------------
// PrintIoPortDescriptor
//
// DESCRIPTION: Print the contents of an IO_PORT_DESCRIPTOR object.
//
// PARAMETERS:  Descriptor - Pointer to object to be printed.
//------------------------------------------------------------------------------
BOOL PRINT_RESOURCE::_PrintIoPortDescriptor(PCIO_PORT_DESCRIPTOR Descriptor)
{
    DSTRING     MinimumAddressString;
    DSTRING     MaximumAddressString;
    DSTRING     LengthString;
    DSTRING     AlignmentString;
    DSTRING     TypeString;

    DSTRING     AuxString;
    WCHAR       AuxNumber[19];
    ULONG       StringId;
    PWSTRING    String;

    if( !MinimumAddressString.Initialize( s_IndentString ) ||
        !MinimumAddressString.Strcat( s_StringIoMinimumAddress ) ||
        !MaximumAddressString.Initialize( s_IndentString ) ||
        !MaximumAddressString.Strcat( s_StringIoMaximumAddress ) ||
        !LengthString.Initialize( s_IndentString ) ||
        !LengthString.Strcat( s_StringLength ) ||
        !AlignmentString.Initialize( s_IndentString ) ||
        !AlignmentString.Strcat( s_StringIoAlignment ) ||
        !TypeString.Initialize( s_IndentString ) ||
        !TypeString.Strcat( s_StringType )
      ) {
        DebugPrint( "REGEDT32: Initialization failure" );
        return FALSE;
    }

    //
    //  Print the type
    //

    StringId = ( Descriptor->IsPortMemory() )? IDS_PORT_MEMORY :
                                               IDS_PORT_PORT;

    String =  REGEDIT_BASE_SYSTEM::QueryString( StringId, "" );
    if( String == NULL ) {
        DebugPrintTrace(( "REGEDT32: Unable to retrieve string \n" ));
        return FALSE;
    }
    TypeString.Strcat( String );
    DELETE( String );
    if( !PrintString( &TypeString ) ) {
        return FALSE;
    }
    PrintNewLine();

    //
    //  Print the length
    //
    wsprintf( AuxNumber, (LPWSTR)L"%#x", Descriptor->GetLength() );
    if( !AuxString.Initialize( AuxNumber ) ) {
        DebugPrint( "AuxString.Initialize() failed" );
        return FALSE;
    }
    LengthString.Strcat( &AuxString );
    if( !PrintString( &LengthString ) ) {
        return FALSE;
    }
    PrintNewLine();

    //
    //  Print the alignment
    //
    wsprintf( AuxNumber, (LPWSTR)L"%#x", Descriptor->GetAlignment() );
    if( !AuxString.Initialize( AuxNumber ) ) {
        DebugPrint( "AuxString.Initialize() failed" );
        return FALSE;
    }
    AlignmentString.Strcat( &AuxString );
    if( !PrintString( &AlignmentString ) ) {
        return FALSE;
    }
    PrintNewLine();

    //
    //  Print the minimum address
    //
    if( ( ( ( PIO_PORT_DESCRIPTOR )Descriptor )->GetMinimumAddress() )->HighPart != 0 ) {
        wsprintf( AuxNumber,
                  (LPWSTR)L"0x%08x%08x",
                  ( ( ( PIO_PORT_DESCRIPTOR )Descriptor )->GetMinimumAddress() )->HighPart,
                  ( ( ( PIO_PORT_DESCRIPTOR )Descriptor )->GetMinimumAddress() )->LowPart );
    } else {
        wsprintf( AuxNumber, (LPWSTR)L"0x%08x", ( ( ( PIO_PORT_DESCRIPTOR )Descriptor )->GetMinimumAddress() )->LowPart );
    }
    if( !AuxString.Initialize( AuxNumber ) ) {
        DebugPrint( "AuxString.Initialize() failed" );
        return FALSE;
    }
    MinimumAddressString.Strcat( &AuxString );
    if( !PrintString( &MinimumAddressString ) ) {
        return FALSE;
    }
    PrintNewLine();

    //
    //  Print the maximum address
    //
    if( ( ( ( PIO_PORT_DESCRIPTOR )Descriptor )->GetMaximumAddress() )->HighPart != 0 ) {
        wsprintf( AuxNumber,
                  (LPWSTR)L"0x%08x%08x",
                  ( ( ( PIO_PORT_DESCRIPTOR )Descriptor )->GetMaximumAddress() )->HighPart,
                  ( ( ( PIO_PORT_DESCRIPTOR )Descriptor )->GetMaximumAddress() )->LowPart );
    } else {
        wsprintf( AuxNumber, (LPWSTR)L"0x%08x", ( ( ( PIO_PORT_DESCRIPTOR )Descriptor )->GetMaximumAddress() )->LowPart );
    }
    if( !AuxString.Initialize( AuxNumber ) ) {
        DebugPrint( "AuxString.Initialize() failed" );
        return FALSE;
    }
    MaximumAddressString.Strcat( &AuxString );
    if( !PrintString( &MaximumAddressString ) ) {
        return FALSE;
    }
    PrintNewLine();

    return TRUE;
}


//------------------------------------------------------------------------------
// PrintIoMemoryDescriptor
//
// DESCRIPTION:  Print the contents of an IO_MEMORY_DESCRIPTOR object.
//
// PARAMETERS:  Descriptor - Pointer to object to be printed.
//------------------------------------------------------------------------------
BOOL PRINT_RESOURCE::_PrintIoMemoryDescriptor(PCIO_MEMORY_DESCRIPTOR Descriptor)
{
    DSTRING     MinimumAddressString;
    DSTRING     MaximumAddressString;
    DSTRING     LengthString;
    DSTRING     AlignmentString;
    DSTRING     TypeString;

    DSTRING     AuxString;
    WCHAR       AuxNumber[19];
    ULONG       StringId;
    PWSTRING    String;

    if( !MinimumAddressString.Initialize( s_IndentString ) ||
        !MinimumAddressString.Strcat( s_StringIoMinimumAddress ) ||
        !MaximumAddressString.Initialize( s_IndentString ) ||
        !MaximumAddressString.Strcat( s_StringIoMaximumAddress ) ||
        !LengthString.Initialize( s_IndentString ) ||
        !LengthString.Strcat( s_StringLength ) ||
        !AlignmentString.Initialize( s_IndentString ) ||
        !AlignmentString.Strcat( s_StringIoAlignment ) ||
        !TypeString.Initialize( s_IndentString ) ||
        !TypeString.Strcat( s_StringType )
      ) {
        DebugPrint( "REGEDT32: Initialization failure" );
        return FALSE;
    }

    //
    //  Print the type
    //

    StringId = ( Descriptor->IsMemoryReadWrite() )? IDS_MEM_READ_WRITE :
                                                    ( ( Descriptor->IsMemoryReadWrite() )? IDS_MEM_READ_ONLY :
                                                                                           IDS_MEM_WRITE_ONLY );

    String =  REGEDIT_BASE_SYSTEM::QueryString( StringId, "" );
    if( String == NULL ) {
        DebugPrintTrace(( "REGEDT32: Unable to retrieve string \n" ));
        return FALSE;
    }
    TypeString.Strcat( String );
    DELETE( String );
    if( !PrintString( &TypeString ) ) {
        return FALSE;
    }
    PrintNewLine();

    //
    //  Print the length
    //
    wsprintf( AuxNumber, (LPWSTR)L"%#x", Descriptor->GetLength() );
    if( !AuxString.Initialize( AuxNumber ) ) {
        DebugPrint( "AuxString.Initialize() failed" );
        return FALSE;
    }
    LengthString.Strcat( &AuxString );
    if( !PrintString( &LengthString ) ) {
        return FALSE;
    }
    PrintNewLine();

    //
    //  Print the alignment
    //
    wsprintf( AuxNumber, (LPWSTR)L"%#x", Descriptor->GetAlignment() );
    if( !AuxString.Initialize( AuxNumber ) ) {
        DebugPrint( "AuxString.Initialize() failed" );
        return FALSE;
    }
    AlignmentString.Strcat( &AuxString );
    if( !PrintString( &AlignmentString ) ) {
        return FALSE;
    }
    PrintNewLine();

    //
    //  Print the minimum address
    //
    if( ( ( ( PIO_PORT_DESCRIPTOR )Descriptor )->GetMinimumAddress() )->HighPart != 0 ) {
        wsprintf( AuxNumber,
                  (LPWSTR)L"0x%08x%08x",
                  ( ( ( PIO_PORT_DESCRIPTOR )Descriptor )->GetMinimumAddress() )->HighPart,
                  ( ( ( PIO_PORT_DESCRIPTOR )Descriptor )->GetMinimumAddress() )->LowPart );
    } else {
        wsprintf( AuxNumber, (LPWSTR)L"0x%08x", ( ( ( PIO_PORT_DESCRIPTOR )Descriptor )->GetMinimumAddress() )->LowPart );
    }
    if( !AuxString.Initialize( AuxNumber ) ) {
        DebugPrint( "AuxString.Initialize() failed" );
        return FALSE;
    }
    MinimumAddressString.Strcat( &AuxString );
    if( !PrintString( &MinimumAddressString ) ) {
        return FALSE;
    }
    PrintNewLine();

    //
    //  Print the maximum address
    //
    if( ( ( ( PIO_PORT_DESCRIPTOR )Descriptor )->GetMaximumAddress() )->HighPart != 0 ) {
        wsprintf( AuxNumber,
                  (LPWSTR)L"0x%08x%08x",
                  ( ( ( PIO_PORT_DESCRIPTOR )Descriptor )->GetMaximumAddress() )->HighPart,
                  ( ( ( PIO_PORT_DESCRIPTOR )Descriptor )->GetMaximumAddress() )->LowPart );
    } else {
        wsprintf( AuxNumber, (LPWSTR)L"0x%08x", ( ( ( PIO_PORT_DESCRIPTOR )Descriptor )->GetMaximumAddress() )->LowPart );
    }
    if( !AuxString.Initialize( AuxNumber ) ) {
        DebugPrint( "AuxString.Initialize() failed" );
        return FALSE;
    }
    MaximumAddressString.Strcat( &AuxString );
    if( !PrintString( &MaximumAddressString ) ) {
        return FALSE;
    }
    PrintNewLine();

    return TRUE;
}


//------------------------------------------------------------------------------
// PrintIoDmaDescriptor
//
// DESCRIPTION:  Print the contents of an IO_DMA_DESCRIPTOR object.
//
// PARAMETERS:  Descriptor - Pointer to object to be printed.
//------------------------------------------------------------------------------
BOOL PRINT_RESOURCE::_PrintIoDmaDescriptor(PCIO_DMA_DESCRIPTOR Descriptor)
{
    DSTRING     MinimumChannelString;
    DSTRING     MaximumChannelString;

    DSTRING     AuxString;
    WCHAR       AuxNumber[19];

    if( !MinimumChannelString.Initialize( s_IndentString ) ||
        !MinimumChannelString.Strcat( s_StringIoMinimumChannel ) ||
        !MaximumChannelString.Initialize( s_IndentString ) ||
        !MaximumChannelString.Strcat( s_StringIoMaximumChannel )
      ) {
        DebugPrint( "REGEDT32: Initialization failure" );
        return FALSE;
    }

    //
    //  Print the minimum channel
    //
    wsprintf( AuxNumber, (LPWSTR)L"%#x", Descriptor->GetMinimumChannel() );
    if( !AuxString.Initialize( AuxNumber ) ) {
        DebugPrint( "AuxString.Initialize() failed" );
        return FALSE;
    }
    MinimumChannelString.Strcat( &AuxString );
    if( !PrintString( &MinimumChannelString ) ) {
        return FALSE;
    }
    PrintNewLine();

    //
    //  Print the maximum channel
    //
    wsprintf( AuxNumber, (LPWSTR)L"%#x", Descriptor->GetMaximumChannel() );
    if( !AuxString.Initialize( AuxNumber ) ) {
        DebugPrint( "AuxString.Initialize() failed" );
        return FALSE;
    }
    MaximumChannelString.Strcat( &AuxString );
    if( !PrintString( &MaximumChannelString ) ) {
        return FALSE;
    }
    PrintNewLine();

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\regedit\regprintres.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    regprintres.hxx

Abstract:

    This module contains the declarations for the PRINT_MANAGER class.
    The PRINT_RESOURCE class is responsible for displayning the Printer
    Setup Dialog, for printing a registry.


Author:

    Jaime Sasson (jaimes) 18-Sep-1991


Environment:



--*/


#if !defined( _PRINT_RESOURCE_ )

#define _PRINT_RESOURCE_

// don't let ntdddisk.h (included in ulib.hxx") 
// redefine values
#define _NTDDDISK_H_

#include "ulib.hxx"
#include "wstring.hxx"
#include "regresls.hxx"
#include "regfdesc.hxx"
#include "regdesc.hxx"
#include "regioreq.hxx"
#include "regiodls.hxx"
#include "regiodsc.hxx"


DECLARE_CLASS( PRINT_RESOURCE );


class PRINT_RESOURCE : public OBJECT 
{
    public:
        DECLARE_CONSTRUCTOR( PRINT_RESOURCE );
        DECLARE_CAST_MEMBER_FUNCTION( PRINT_RESOURCE );

        STATIC void _PrintResources(PBYTE pbData, UINT uSize, DWORD dwType);

    private:
        STATIC BOOL _InitializeStrings();
        STATIC void _PrintDataRegResourceList(PBYTE Data, UINT Size);
        STATIC BOOL _PrintFullResourceDescriptor(PCFULL_DESCRIPTOR FullDescriptor,
            UINT DescriptorNumber, BOOL PrintDescriptorNumber DEFAULT TRUE);
        STATIC BOOL _PrintPartialDescriptor(PCPARTIAL_DESCRIPTOR PartialDescriptor,
            ULONG DescriptorNumber);
        STATIC BOOL _PrintInterruptDescriptor(PCINTERRUPT_DESCRIPTOR Descriptor);
        STATIC BOOL _PrintPortDescriptor(PCPORT_DESCRIPTOR Descriptor);
        STATIC BOOL _PrintMemoryDescriptor(PCMEMORY_DESCRIPTOR   Descriptor);
        STATIC BOOL _PrintDmaDescriptor(PCDMA_DESCRIPTOR   Descriptor);
        STATIC BOOL _PrintDeviceSpecificDescriptor(PCDEVICE_SPECIFIC_DESCRIPTOR   Descriptor);
        STATIC BOOL _PrintDataRegRequirementsList(PBYTE Data, ULONG Size);
        STATIC BOOL _PrintIoResourceList(PCIO_DESCRIPTOR_LIST DescriptorList, UINT ListNumber);
        STATIC BOOL _PrintIoDescriptor(PCIO_DESCRIPTOR IoDescriptor, ULONG DescriptorNumber);
        STATIC BOOL _PrintIoInterruptDescriptor(PCIO_INTERRUPT_DESCRIPTOR Descriptor);
        STATIC BOOL _PrintIoPortDescriptor(PCIO_PORT_DESCRIPTOR Descriptor);
        STATIC BOOL _PrintIoMemoryDescriptor(PCIO_MEMORY_DESCRIPTOR Descriptor);
        STATIC BOOL _PrintIoDmaDescriptor(PCIO_DMA_DESCRIPTOR Descriptor);

        STATIC BOOL        s_StringsInitialized;
        STATIC PWSTRING    s_IndentString;
        STATIC PWSTRING    s_StringFullDescriptor;
        STATIC PWSTRING    s_StringInterfaceType;
        STATIC PWSTRING    s_StringBusNumber;
        STATIC PWSTRING    s_StringVersion;
        STATIC PWSTRING    s_StringRevision;
        STATIC PWSTRING    s_EmptyLine;
        STATIC PWSTRING    s_StringPartialDescriptor;
        STATIC PWSTRING    s_StringResource;
        STATIC PWSTRING    s_StringDisposition;
        STATIC PWSTRING    s_StringVector;
        STATIC PWSTRING    s_StringLevel;
        STATIC PWSTRING    s_StringAffinity;
        STATIC PWSTRING    s_StringType;
        STATIC PWSTRING    s_StringStart;
        STATIC PWSTRING    s_StringLength;
        STATIC PWSTRING    s_StringChannel;
        STATIC PWSTRING    s_StringPort;
        STATIC PWSTRING    s_StringReserved1;
        STATIC PWSTRING    s_StringReserved2;
        STATIC PWSTRING    s_StringDevSpecificData;
        STATIC PWSTRING    s_StringIoInterfaceType;
        STATIC PWSTRING    s_StringIoBusNumber;
        STATIC PWSTRING    s_StringIoSlotNumber;
        STATIC PWSTRING    s_StringIoListNumber;
        STATIC PWSTRING    s_StringIoDescriptorNumber;
        STATIC PWSTRING    s_StringIoOption;
        STATIC PWSTRING    s_StringIoMinimumVector;
        STATIC PWSTRING    s_StringIoMaximumVector;
        STATIC PWSTRING    s_StringIoMinimumAddress;
        STATIC PWSTRING    s_StringIoMaximumAddress;
        STATIC PWSTRING    s_StringIoAlignment;
        STATIC PWSTRING    s_StringIoMinimumChannel;
        STATIC PWSTRING    s_StringIoMaximumChannel;
};

extern "C" 
{
    VOID PrintResourceData(PBYTE pbData, UINT uSize, DWORD dwType);
}


#endif // _PRINT_RESOURCE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\regedit\regresid.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGRESID.H
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        05 Mar 1994
*
*  Resource identifiers for the Registry Editor.
*
*******************************************************************************/

#ifndef _INC_REGRESID
#define _INC_REGRESID

#define HEXEDIT_CLASSNAME               TEXT("HEX")

//
//
//

#define IDD_REGEXPORT                   100
#define IDD_REGPRINT                    108
#define IDD_INPUTHIVENAME               104

#define IDC_FIRSTREGCOMMDLGID           1280
#define IDC_RANGEALL                    1280
#define IDC_RANGESELECTEDPATH           1281
#define IDC_SELECTEDPATH                1282
#define IDC_EXPORTRANGE                 1283
#define IDC_LASTREGCOMMDLGID            1283

//
//
//

#define IDD_EDITSTRINGVALUE             102
#define IDD_EDITBINARYVALUE             103
#define IDD_EDITDWORDVALUE              111
#define IDD_EDITMULTISZVALUE            114
#define IDD_RESOURCE_LIST               116

#define IDC_VALUENAME                   1000
#define IDC_VALUEDATA                   1001
#define IDC_HEXADECIMAL                 1002
#define IDC_DECIMAL                     1003

// RESOURCE_LIST
#define IDC_LIST_DRIVES                     1201
#define IDC_PUSH_DRIVE_DETAILS              1202
#define IDC_PUSH_DISPLAY_RESOURCES          1203
#define IDC_PUSH_DISPLAY_DATA               1204
#define IDC_LIST_RESOURCE_LISTS             1205

#define IDC_FULL_RES_TEXT_BUS_NUMBER        1300
#define IDC_FULL_RES_TEXT_VERSION           1301
#define IDC_FULL_RES_TEXT_REVISION          1302
#define IDC_FULL_RES_TEXT_INTERFACE_TYPE    1303
#define IDC_FULL_RES_LIST_DEVICE_SPECIFIC   1304
#define IDD_FULL_RES_DESCRIPTOR             1305
#define IDC_FULL_RES_LIST_DMA               1306
#define IDC_FULL_RES_LIST_INTERRUPTS        1307
#define IDC_FULL_RES_LIST_MEMORY            1308
#define IDC_FULL_RES_LIST_PORTS             1309
#define IDC_FULL_RES_TEXT_UNDETERMINED      1310
#define IDC_FULL_RES_TEXT_SHARED            1311
#define IDC_FULL_RES_TEXT_DEVICE_EXCLUSIVE  1312
#define IDC_FULL_RES_TEXT_DRIVER_EXCLUSIVE  1313

#define IDD_IO_REQUIREMENT_LISTS            1401
#define IDD_IO_REQ_INTERFACE_TYPE           1402
#define IDD_IO_REQ_BUS_NUMBER               1403
#define IDD_IO_REQ_SLOT_NUMBER              1404

#define IDD_IO_REQUIREMENTS_LIST            1501
#define IDC_IO_LIST_ALTERNATIVE_LISTS       1502
#define IDC_IO_REQ_TEXT_INTERFACE_TYPE      1503
#define IDC_IO_REQ_TEXT_BUS_NUMBER          1504
#define IDC_IO_REQ_TEXT_SLOT_NUMBER         1505
#define IDC_IO_REQ_PUSH_DISPLAY_DEVICE      1506

#define IDD_IO_MEMORY_RESOURCE              1601
#define IDC_IO_TEXT_MEM_ACCESS              1602
#define IDC_IO_TEXT_MEM_LENGTH              1603
#define IDC_IO_TEXT_MEM_MIN_ADDRESS         1604
#define IDC_IO_TEXT_MEM_MAX_ADDRESS         1605
#define IDC_IO_TEXT_MEM_ALIGNMENT           1606

#define IDD_IO_PORT_RESOURCE                1700
#define IDC_IO_TEXT_PORT_TYPE               1701
#define IDC_IO_TEXT_PORT_LENGTH             1703
#define IDC_IO_TEXT_PORT_MIN_ADDRESS        1704
#define IDC_IO_TEXT_PORT_MAX_ADDRESS        1705
#define IDC_IO_TEXT_PORT_ALIGNMENT          1706

#define IDD_IO_INTERRUPT_RESOURCE           1800
#define IDC_IO_TEXT_INT_TYPE                1801
#define IDC_IO_TEXT_INT_MIN_VECTOR          1803
#define IDC_IO_TEXT_INT_MAX_VECTOR          1804

#define IDD_IO_DMA_RESOURCE                 1900
#define IDC_IO_TEXT_DMA_MIN_CHANNEL         1902
#define IDC_IO_TEXT_DMA_MAX_CHANNEL         1903

#define IDC_IO_TEXT_DISPOSITION             2000
#define IDC_IO_TEXT_OPTION_PREFERRED        2001
#define IDC_IO_TEXT_OPTION_ALTERNATIVE      2002

// Display binary data
#define IDD_DISPLAY_BINARY_DATA             2020
#define IDD_DISPLAY_BINARY_DATA_VALUE_TYPE  2021
#define IDD_DISPLAY_DATA_BINARY             2022
#define IDC_BINARY_DATA_BYTE                2023
#define IDC_BINARY_DATA_WORD                2024
#define IDC_BINARY_DATA_DWORD               2025
#define IDT_VALUE_TYPE                      2026

//
//
//

#define IDC_REMOTENAME                  1100
#define IDC_BROWSE                      1101

//
//
//

#define IDD_REGPRINTABORT               105

//
//  Dialog box for the Edit-> Find... menu option.
//

#define IDD_REGFIND                     106

#define IDC_FINDWHAT                    1150
#define IDC_WHOLEWORDONLY               1151
//  NOTE: The flags IDC_FOR* must be consecutive.
#define IDC_FORKEYS                     1152
#define IDC_FORVALUES                   1153
#define IDC_FORDATA                     1154
#define IDC_GROUPBOX                    1160

#define IDD_REGDISCONNECT               107
#define IDC_REMOTELIST                  1175

//
//  Dialog box for the find abort.
//
#define IDD_REGFINDABORT                109

//
// Dialog boxes for adding/removing a favorite
//
#define IDD_ADDFAVORITE			112
#define IDC_FAVORITENAME		1190
#define IDD_REMFAVORITE			113
#define IDC_FAVORITES			1191

//
//  Dialog box for Import Registry File progress display.
//

#define IDD_REGPROGRESS                 110
#define IDD_REGIMPORTNET                115

#define IDC_FILENAME                    100
#define IDC_PROGRESSBAR                 101
#define IDC_COMPUTERLIST                102

//
//  Menu resource identifiers.
//

#define IDM_REGEDIT                     103
#define IDM_KEY_CONTEXT                 104
#define IDM_VALUE_CONTEXT               105
#define IDM_VALUELIST_NOITEM_CONTEXT    106
#define IDM_COMPUTER_CONTEXT            107

//
//  HexEdit context menu identifier and items.  The IDKEY_* identifier
//  correspond to the WM_CHAR message that it corresponds to.  For example,
//  IDKEY_COPY would send a control-c to the HexEdit_OnChar routine.
//

#define IDM_HEXEDIT_CONTEXT             108

#define IDKEY_COPY                      3
#define IDKEY_PASTE                     22
#define IDKEY_CUT                       24
#define ID_SELECTALL                    0x0400

//
//  Popup menu item identifiers.  Used to determine the context menu help
//  string.
//

#define ID_FIRSTMENUPOPUPITEM           0x0200
#define ID_LASTMENUPOPUPITEM            0x027F

#define IDMP_REGISTRY                   0x0200
#define IDMP_EDIT                       0x0201
#define IDMP_VIEW                       0x0202
#define IDMP_HELP                       0x0203
#define IDMP_NEW                        0x0204
#define IDMP_FAVORITES			        0x0205

//
//  Main menu items.  If any of these items are selected from a context menu,
//  they will be automatically routed to the main window's command handler.
//

#define ID_FIRSTMAINMENUITEM            0x0280
#define ID_LASTMAINMENUITEM             0x02FF

//  Following are really keyboard accelerators.
#define ID_CYCLEFOCUS                   (ID_FIRSTMAINMENUITEM + 0x0000)

//  IMPORTANT:  Do not change the position of this identifier.  If Regedit is
//  already running and Regedit is then invoked through its commandline
//  interface, then the second instance will send a WM_COMMAND message with this
//  identifier to force a refresh.
#define ID_REFRESH                      (ID_FIRSTMAINMENUITEM + 0x0008)

#define ID_CONNECT                      (ID_FIRSTMAINMENUITEM + 0x0011)
#define ID_IMPORTREGFILE                (ID_FIRSTMAINMENUITEM + 0x0012)
#define ID_EXPORTREGFILE                (ID_FIRSTMAINMENUITEM + 0x0013)
#define ID_PRINT                        (ID_FIRSTMAINMENUITEM + 0x0014)
#define ID_EXIT                         (ID_FIRSTMAINMENUITEM + 0x0015)
#define ID_FIND                         (ID_FIRSTMAINMENUITEM + 0x0016)
#define ID_NEWKEY                       (ID_FIRSTMAINMENUITEM + 0x0017)
#define ID_NEWSTRINGVALUE               (ID_FIRSTMAINMENUITEM + 0x0018)
#define ID_NEWBINARYVALUE               (ID_FIRSTMAINMENUITEM + 0x0019)
#define ID_EXECCALC                     (ID_FIRSTMAINMENUITEM + 0x001A)
#define ID_ABOUT                        (ID_FIRSTMAINMENUITEM + 0x001B)
#define ID_STATUSBAR                    (ID_FIRSTMAINMENUITEM + 0x001C)
#define ID_SPLIT                        (ID_FIRSTMAINMENUITEM + 0x001E)
#define ID_FINDNEXT                     (ID_FIRSTMAINMENUITEM + 0x001F)
#define ID_HELPTOPICS                   (ID_FIRSTMAINMENUITEM + 0x0020)
#define ID_NETSEPARATOR                 (ID_FIRSTMAINMENUITEM + 0x0021)
#define ID_NEWDWORDVALUE                (ID_FIRSTMAINMENUITEM + 0x0022)
#define ID_COPYKEYNAME	                (ID_FIRSTMAINMENUITEM + 0x0023)
#define ID_NEWMULTSZVALUE               (ID_FIRSTMAINMENUITEM + 0x0024)
#define ID_NEWEXPSZVALUE                (ID_FIRSTMAINMENUITEM + 0x0025)
#define ID_PERMISSIONS                  (ID_FIRSTMAINMENUITEM + 0x0026)
#define ID_DISPLAYBINARY                (ID_FIRSTMAINMENUITEM + 0x0027)
#define ID_LOADHIVE                     (ID_FIRSTMAINMENUITEM + 0x0028)
#define ID_UNLOADHIVE                   (ID_FIRSTMAINMENUITEM + 0x0029)

//
//  Dual menu items.  The routing of these items depends on whether it was
//  selected from the main menu or from a context menu.
//

#define ID_FIRSTDUALMENUITEM            0x0300
#define ID_LASTDUALMENUITEM             0x037F

#define ID_DISCONNECT                   (ID_FIRSTDUALMENUITEM + 0x0000)

//
//  Context menu items.  If any of these items are selected from the main menu,
//  they will be automatically routed to the focus pane's command handler.
//

#define ID_FIRSTCONTEXTMENUITEM         0x0380
#define ID_LASTCONTEXTMENUITEM          0x03FF

//  Following are really keyboard accelerators.
#define ID_CONTEXTMENU                  (ID_FIRSTCONTEXTMENUITEM + 0x0000)

#define ID_MODIFY                       (ID_FIRSTCONTEXTMENUITEM + 0x0010)
#define ID_DELETE                       (ID_FIRSTCONTEXTMENUITEM + 0x0011)
#define ID_RENAME                       (ID_FIRSTCONTEXTMENUITEM + 0x0012)
#define ID_TOGGLE                       (ID_FIRSTCONTEXTMENUITEM + 0x0013)
#define ID_SENDTOPRINTER                (ID_FIRSTCONTEXTMENUITEM + 0x0014)
#define ID_MODIFYBINARY                 (ID_FIRSTCONTEXTMENUITEM + 0x0015)
//
//  The following are new features added by BruceGr
//
#define ID_FIRSTNEWIDENTIFIER           0x0500
#define ID_REMOVEFAVORITE               (ID_FIRSTNEWIDENTIFIER + 0x0000)
#define ID_ADDTOFAVORITES               (ID_FIRSTNEWIDENTIFIER + 0x0001)

//
//  String resource identifiers.
//

#define IDS_REGEDIT                     16
#define IDS_NAMECOLUMNLABEL             17
#define IDS_DATACOLUMNLABEL             18
#define IDS_COMPUTER                    19
#define IDS_DEFAULTVALUE                20
#define IDS_MODIFYBINARY                21
#define IDS_EMPTYBINARY                 22
#define IDS_NEWKEYNAMETEMPLATE          23
#define IDS_NEWVALUENAMETEMPLATE        24
#define IDS_COLLAPSE                    25
#define IDS_MODIFY                      26
#define IDS_VALUENOTSET                 27
#define IDS_HELPFILENAME                28
#define IDS_DWORDDATAFORMATSPEC         29
#define IDS_INVALIDDWORDDATA            30
#define IDS_TYPECOLUMNLABEL             31

#define IDS_REGEDITDISABLED             40
#define IDS_SEARCHEDTOEND               41
#define IDS_COMPUTERBROWSETITLE         42
#define IDS_NOFILESPECIFIED             43

#define IDS_CONFIRMDELKEYTEXT           48
#define IDS_CONFIRMDELKEYTITLE          49
#define IDS_CONFIRMDELVALMULTITEXT      50
#define IDS_CONFIRMDELVALTITLE          51
#define IDS_CONFIRMDELVALTEXT           52
#define IDS_CONFIRMDELHIVETEXT          53
#define IDS_CONFIRMDELHIVETITLE         54
#define IDS_CONFIRMRESTOREKEY           55
#define IDS_CONFIRMRESKEYTITLE          56

#define IDS_RENAMEKEYERRORTITLE         64
#define IDS_RENAMEPREFIX                65              //  Reserved
#define IDS_RENAMEKEYOTHERERROR         66
#define IDS_RENAMEKEYTOOLONG            67
#define IDS_RENAMEKEYEXISTS             68
#define IDS_RENAMEKEYBADCHARS           69
#define IDS_RENAMEKEYEMPTY              70

#define IDS_RENAMEVALERRORTITLE         72
#define IDS_RENAMEVALOTHERERROR         73
#define IDS_RENAMEVALEXISTS             74
#define IDS_RENAMEVALEMPTY              75

#define IDS_DELETEKEYERRORTITLE         80
#define IDS_DELETEPREFIX                81              //  Reserved
#define IDS_DELETEKEYDELETEFAILED       82

#define IDS_DELETEVALERRORTITLE         88
#define IDS_DELETEVALDELETEFAILED       89

#define IDS_OPENKEYERRORTITLE           96
#define IDS_OPENKEYCANNOTOPEN           97

#define IDS_REFRESHERRORTITLE           100
#define IDS_REFRESHCANNOTREAD           101
#define IDS_REFRESHNOMEMORY             102

#define IDS_EDITWARNOVERFLOW            110
#define IDS_EDITWARNINGTITLE            111
#define IDS_EDITVALERRORTITLE           112
#define IDS_EDITPREFIX                  113             //  Reserved
#define IDS_EDITVALCANNOTREAD           114
#define IDS_EDITVALCANNOTWRITE          115
#define IDS_EDITMULTSZEMPTYSTR          116
#define IDS_EDITMULTSZEMPTYSTRS         117
#define IDS_EDITVALNOMEMORY             118
#define IDS_EDITDWTRUNCATEDEC           119

#define IDS_IMPFILEERRNOTASCRPT         123
// #define IDS_IMPFILEERRSUCCESSNOWIN      124      // unused, reclaim!
#define IDS_IMPFILEERRINVALID           125
#define IDS_IMPFILEERRNOPRIV            126
#define IDS_IMPFILEERRORCANCEL          127
#define IDS_IMPFILEERRSUCCESS           128
#define IDS_IMPFILEERRFILEOPEN          129
#define IDS_IMPFILEERRFILEREAD          130
#define IDS_IMPFILEERRREGOPEN           131
#define IDS_IMPFILEERRREGSET            132
#define IDS_IMPFILEERRFORMATBAD         133
#define IDS_IMPFILEERRVERBAD            134
#define IDS_IMPFILEERRNOFILE            135

#define IDS_EXPFILEERRSUCCESS           136
#define IDS_EXPFILEERRBADREGPATH        137
#define IDS_EXPFILEERRFILEOPEN          138
#define IDS_EXPFILEERRREGOPEN           139
#define IDS_EXPFILEERRREGENUM           140
#define IDS_EXPFILEERRFILEWRITE         141
#define IDS_EXPFILEERRNOPRIV            142
#define IDS_EXPFILEERRINVALID           143

#define IDS_PRINTERRNOMEMORY            144
#define IDS_PRINTERRPRINTER             145
#define IDS_PRINTERRCANNOTREAD          146

#define IDS_ERRINVALIDREGPATH           148

#define IDS_CONNECTERRORTITLE           152
#define IDS_CONNECTNOTLOCAL             153
#define IDS_CONNECTBADNAME              154
#define IDS_CONNECTROOTFAILED           155
#define IDS_CONNECTACCESSDENIED         156

#define IDS_NEWKEYERRORTITLE            160
#define IDS_NEWKEYPARENTOPENFAILED      161
#define IDS_NEWKEYCANNOTCREATE          162
#define IDS_NEWKEYNOUNIQUE              163

#define IDS_NEWVALUEERRORTITLE          168
#define IDS_NEWVALUECANNOTCREATE        169
#define IDS_NEWVALUENOUNIQUE            170

#define IDS_FAVORITEEXISTS              171
#define	IDS_FAVORITEERROR               172
#define IDS_FAVORITE                    173

#define IDS_REGLOADHVFILEFILTER         180
#define IDS_LOADHVREGFILETITLE          181
#define IDS_ERRORLOADHVPRIV             182
#define IDS_ERRORLOADHV                 183
#define IDS_ERRORUNLOADHVPRIV           184
#define IDS_ERRORUNLOADHV               185
#define IDS_UNLOADHIVETITLE             186
#define IDS_ERRORUNLOADHVNOACC          187
#define IDS_ERRORLOADHVNOSHARE          188
#define IDS_ERRORLOADHVNOACC            189

#define IDS_SAVETREEERRNOMEMORY         212
#define IDS_SAVETREEERRCANNOTREAD       213
#define IDS_SAVETREEERRFILEWRITE        214
#define IDS_SAVETREEERRFILEOPEN         215

#define LOCAL_OFFSET    100
#define IDS_IMPFILEERRSUCCESSLOCAL      IDS_IMPFILEERRSUCCESS + LOCAL_OFFSET    // 228
#define IDS_IMPFILEERRREGOPENLOCAL      IDS_IMPFILEERRREGOPEN + LOCAL_OFFSET    // 231
#define IDS_IMPFILEERRNOFILELOCAL       IDS_IMPFILEERRNOFILE + LOCAL_OFFSET     // 235

#define IDS_IMPORTREGFILETITLE          300
#define IDS_EXPORTREGFILETITLE          301
#define IDS_REGIMPORTFILEFILTER         302
#define IDS_REGFILEDEFEXT               303
#define IDS_CONFIRMIMPFILE              304
#define IDS_REGEXPORTFILEFILTER         305
#define IDS_NOMEMORY                    306
#define IDS_REGNODEFEXT                 308

//  The range IDS_FIRSTMENUPOPUPITEM through IDS_LASTMENUPOPUPITEM is reserved
//  for context menu help.  This must match up with ID_FIRSTMENUPOPUPITEM
//  through ID_LASTMENUPOPUPITEM.
#define IDS_FIRSTMENUPOPUPITEM          ID_FIRSTMENUPOPUPITEM
#define IDS_LASTMENUPOPUPITEM           ID_LASTMENUPOPUPITEM

//  The range IDS_FIRSTMAINMENUITEM through IDS_LASTMAINMENUITEM is reserved for
//  context menu help.  This must match up with ID_FIRSTMAINMENUITEM through
//  ID_LASTMAINMENUITEM.

#define IDS_FIRSTMAINMENUITEM           ID_FIRSTMAINMENUITEM
#define IDS_LASTMAINMENUITEM            ID_LASTMAINMENUITEM

//  The range IDS_FIRSTCONTEXTMENUITEM through IDS_LASTCONTEXTMENUITEM is
//  reserved for context menu help.  This must match up with
//  ID_FIRSTCONTEXTMENUITEM through ID_LASTCONTEXTMENUITEM.

#define IDS_FIRSTCONTEXTMENUITEM        ID_FIRSTCONTEXTMENUITEM
#define IDS_LASTCONTEXTMENUITEM         ID_LASTCONTEXTMENUITEM

//  The range IDS_FIRSTDUALMENUITEM through IDS_LASTDUALMENUITEM is reserved for
//  context menu help.  This must match up with ID_FIRSTDUALMENUITEM through
//  ID_LASTDUALMENUITEM.
#define IDS_FIRSTDUALMENUITEM           ID_FIRSTDUALMENUITEM
#define IDS_LASTDUALMENUITEM            ID_LASTDUALMENUITEM

// SECURITY
#define IDS_SECURITY                            7000
#define IDS_SEC_EDITOR_CREATE_LINK              7001
#define IDS_SEC_EDITOR_QUERY_VALUE              7002
#define IDS_SEC_EDITOR_SET_VALUE                7003
#define IDS_SEC_EDITOR_ENUM_SUBKEYS             7004
#define IDS_SEC_EDITOR_NOTIFY                   7005
#define IDS_SEC_EDITOR_CREATE_SUBKEY            7006
#define IDS_SEC_EDITOR_DELETE                   7007
#define IDS_SEC_EDITOR_WRITE_DAC                7008
#define IDS_SEC_EDITOR_WRITE_OWNER              7009
#define IDS_SEC_EDITOR_READ_CONTROL             7010
#define IDS_SEC_EDITOR_READ                     7011
#define IDS_SEC_EDITOR_FULL_ACCESS              7012
#define IDS_SEC_EDITOR_SPECIAL_ACCESS           7013
#define IDS_SEC_EDITOR_REGISTRY_KEY             7014
#define IDS_SEC_EDITOR_APPLY_TO_SUBKEYS         7015
#define IDS_SEC_EDITOR_AUDIT_SUBKEYS            7016
#define IDS_SEC_EDITOR_CONFIRM_APPLY_TO_SUBKEYS 7017
#define IDS_SEC_EDITOR_CONFIRM_AUDIT_SUBKEYS    7018
#define IDS_SEC_EDITOR_DEFAULT_PERM_NAME        7019

#define IDS_GET_SECURITY_ACCESS_DENIED_EX       7050
#define IDS_GET_SECURITY_KEY_DELETED_EX         7051
#define IDS_GET_SECURITY_KEY_NOT_ACCESSIBLE_EX  7052

#define IDS_SET_SECURITY_ACCESS_DENIED_EX                   7070
#define IDS_SET_SECURITY_KEY_DELETED_EX                     7071
#define IDS_SET_SECURITY_RECURSIVE_EX_FAIL                  7072
#define IDS_SET_OWNER_RECURSIVE_EX_FAIL                     7073
#define IDS_SET_SECURITY_ACCESS_DENIED_RECURSIVE_EX         7074
#define IDS_SET_SECURITY_KEY_DELETED_RECURSIVE_EX           7075
#define IDS_SET_SECURITY_KEY_NOT_ACCESSIBLE_RECURSIVE_EX    7076

#define IDS_KEY_FOLDER                          7090
#define IDS_KEY_FOLDER_SUBFOLDER                7091
#define IDS_KEY_SUBFOLDER_ONLY                  7092


// RESOURSE_LIST 
#define IDS_BUS_INTERNAL                 7500
#define IDS_BUS_ISA                      7501
#define IDS_BUS_EISA                     7502
#define IDS_BUS_MICRO_CHANNEL            7503
#define IDS_BUS_TURBO_CHANNEL            7504
#define IDS_BUS_PCI_BUS                  7505
#define IDS_BUS_VME_BUS                  7506
#define IDS_BUS_NU_BUS                   7507
#define IDS_BUS_PCMCIA_BUS               7508
#define IDS_BUS_C_BUS                    7509
#define IDS_BUS_MPI_BUS                  7510
#define IDS_BUS_MPSA_BUS                 7511

#define IDS_INT_LEVEL_SENSITIVE          7520
#define IDS_INT_LATCHED                  7521

#define IDS_MEM_READ_WRITE               7530
#define IDS_MEM_READ_ONLY                7531
#define IDS_MEM_WRITE_ONLY               7532

#define IDS_PORT_MEMORY                  7540
#define IDS_PORT_PORT                    7541
#define IDS_INVALID                      7542

#define IDS_DEV_PORT                     7560
#define IDS_DEV_INTERRUPT                7561
#define IDS_DEV_MEMORY                   7562
#define IDS_DEV_DMA                      7563
#define IDS_DEV_DEVICE_SPECIFIC          7564

#define IDS_SHARE_UNDETERMINED           7580
#define IDS_SHARE_DEVICE_EXCLUSIVE       7581
#define IDS_SHARE_DRIVER_EXCLUSIVE       7582
#define IDS_SHARE_SHARED                 7583

// Printing strings
#define IDS_PRINT_TYPE_REG_NONE             8000
#define IDS_PRINT_TYPE_REG_SZ               8001
#define IDS_PRINT_TYPE_REG_EXPAND_SZ        8002
#define IDS_PRINT_TYPE_REG_BINARY           8003
#define IDS_PRINT_TYPE_REG_DWORD            8004
#define IDS_PRINT_TYPE_REG_LINK             8006
#define IDS_PRINT_TYPE_REG_MULTI_SZ         8007
#define IDS_PRINT_TYPE_REG_RESOURCE_LIST    8008
#define IDS_PRINT_TYPE_REG_FULL_RESOURCE_DESCRIPTOR     8009
#define IDS_PRINT_TYPE_REG_RESOURCE_REQUIREMENTS_LIST   8010
#define IDS_PRINT_TYPE_REG_REG_QWORD        8011
#define IDS_PRINT_TYPE_REG_UNKNOWN          8012
    
#define IDS_PRINT_SEPARATOR                 8100
#define IDS_PRINT_KEY_NAME                  8101
#define IDS_PRINT_CLASS_NAME                8102
#define IDS_PRINT_LAST_WRITE_TIME           8103
#define IDS_PRINT_NUMBER                    8104
#define IDS_PRINT_NAME                      8105
#define IDS_PRINT_TYPE                      8106
#define IDS_PRINT_DATA_SIZE                 8107
#define IDS_PRINT_DATA                      8108
#define IDS_PRINT_NO_NAME                   8109
#define IDS_PRINT_NO_CLASS                  8110
#define IDS_PRINT_KEY_NAME_INDENT           8111
#define IDS_PRINT_FONT                      8112

#define IDS_PRINT_FULL_DESCRIPTOR           8150
#define IDS_PRINT_PARTIAL_DESCRIPTOR        8151
#define IDS_PRINT_INTERFACE_TYPE            8152
#define IDS_PRINT_BUS_NUMBER                8153
#define IDS_PRINT_VERSION                   8154
#define IDS_PRINT_REVISION                  8155

#define IDS_PRINT_RESOURCE                  8160
#define IDS_PRINT_DISPOSITION               8161
#define IDS_PRINT_IO_TYPE                   8162
#define IDS_PRINT_START                     8163
#define IDS_PRINT_LENGTH                    8164
#define IDS_PRINT_LEVEL                     8165
#define IDS_PRINT_VECTOR                    8166
#define IDS_PRINT_AFFINITY                  8167
#define IDS_PRINT_CHANNEL                   8168
#define IDS_PRINT_PORT                      8169
#define IDS_PRINT_RESERVED1                 8170
#define IDS_PRINT_RESERVED2                 8171
#define IDS_PRINT_DEV_SPECIFIC_DATA         8172
         
#define IDS_PRINT_IO_INTERFACE_TYPE         8180
#define IDS_PRINT_IO_BUS_NUMBER             8181
#define IDS_PRINT_IO_SLOT_NUMBER            8182
#define IDS_PRINT_IO_LIST_NUMBER            8183
#define IDS_PRINT_IO_DESCRIPTOR_NUMBER      8184
#define IDS_PRINT_IO_OPTION                 8185
#define IDS_PRINT_IO_ALIGNMENT              8186
#define IDS_PRINT_IO_MINIMUM_ADDRESS        8187
#define IDS_PRINT_IO_MAXIMUM_ADDRESS        8188
#define IDS_PRINT_IO_MINIMUM_VECTOR         8189
#define IDS_PRINT_IO_MAXIMUM_VECTOR         8190
#define IDS_PRINT_IO_MINIMUM_CHANNEL        8191
#define IDS_PRINT_IO_MAXIMUM_CHANNEL        8192

//
//  Icon resource identifiers.
//

#define IDI_REGEDIT                     100
#define IDI_REGEDDOC                    101
#define IDI_REGFIND                     102

#define IDI_FIRSTIMAGE                  201
//  #define IDI_DIAMOND                     200
#define IDI_COMPUTER                    201
#define IDI_REMOTE                      202
#define IDI_FOLDER                      203
#define IDI_FOLDEROPEN                  204
#define IDI_STRING                      205
#define IDI_BINARY                      206
#define IDI_LASTIMAGE                   IDI_BINARY

//
//  Cursor resource identifiers.
//

#define IDC_SPLIT                       100

//
//  Accelerator resource identifiers.
//

#define IDACCEL_REGEDIT                 100

#endif // _INC_REGRESID
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\regedit\regsec.h ===
#ifndef __REGSEC_H_INCLUDED__
#define __REGSEC_H_INCLUDED__
extern "C"
{
#include "authz.h"
}
#include "objbase.h"
#include "aclapi.h"
#include "aclui.h"

//Type def for PREDEFINED KEYS
typedef enum _PREDEFINE_KEY {
  PREDEFINE_KEY_CLASSES_ROOT,
  PREDEFINE_KEY_CURRENT_USER,
  PREDEFINE_KEY_LOCAL_MACHINE,
  PREDEFINE_KEY_USERS,
  PREDEFINE_KEY_CURRENT_CONFIG
} PREDEFINE_KEY;


class CSecurityInformation : public ISecurityInformation,IEffectivePermission,ISecurityObjectTypeInfo
{
private:
  long m_cRef;
    
public:
  CSecurityInformation():m_cRef(0){}
  virtual ~CSecurityInformation(){};
  // IUnknown methods
  STDMETHOD(QueryInterface)(REFIID, LPVOID *);
  STDMETHOD_(ULONG, AddRef)();
  STDMETHOD_(ULONG, Release)();

  // ISecurityInformation methods 
  STDMETHOD(GetObjectInformation)(
      IN PSI_OBJECT_INFO pObjectInfo
  ) = 0;
  STDMETHOD(GetSecurity)(
      IN  SECURITY_INFORMATION  RequestedInformation,
      OUT PSECURITY_DESCRIPTOR  *ppSecurityDescriptor,
      IN  BOOL                  fDefault
  ) = 0;
  STDMETHOD(SetSecurity)(
      IN SECURITY_INFORMATION SecurityInformation,
      IN PSECURITY_DESCRIPTOR pSecurityDescriptor
  ) = 0;
  STDMETHOD(GetAccessRights)(
      const GUID  *pguidObjectType,
      DWORD       dwFlags,
      PSI_ACCESS  *ppAccess,
      ULONG       *pcAccesses,
      ULONG       *piDefaultAccess
  ) = 0;
  STDMETHOD(MapGeneric)(
      const GUID  *pguidObjectType,
      UCHAR       *pAceFlags,
      ACCESS_MASK *pMask
  ) = 0;
  STDMETHOD(GetInheritTypes)(
      PSI_INHERIT_TYPE  *ppInheritTypes,
      ULONG             *pcInheritTypes
  ) = 0;
  STDMETHOD(PropertySheetPageCallback)(
      HWND          hwnd, 
      UINT          uMsg, 
      SI_PAGE_TYPE  uPage
  ) = 0;
  STDMETHOD(GetEffectivePermission) (  const GUID* pguidObjectType,
                                         PSID pUserSid,
                                         LPCWSTR pszServerName,
                                         PSECURITY_DESCRIPTOR pSD,
                                         POBJECT_TYPE_LIST *ppObjectTypeList,
                                         ULONG *pcObjectTypeListLength,
                                         PACCESS_MASK *ppGrantedAccessList,
                                         ULONG *pcGrantedAccessListLength) =0;
  
  STDMETHOD(GetInheritSource)(SECURITY_INFORMATION si,
                              PACL pACL, 
                              PINHERITED_FROM *ppInheritArray) PURE;



};

class CKeySecurityInformation : public CSecurityInformation
{


private:
  
  //Name of the Key, NULL for ROOT key
  LPCWSTR m_strKeyName;
  //Name of the parent Key, NULL for root and immediate child of root.
  LPCWSTR m_strParentName;
  //Name of the server, can be NULL
  LPCWSTR m_strMachineName;
  //Title of the page
  LPCWSTR m_strPageTitle;
  //if connected to Remote System, Machine name must not be null in this case
  BOOL m_bRemote;
  PREDEFINE_KEY m_PredefinedKey;
  BOOL m_bReadOnly;
  
  //Handle to predefined key. If handle to remote registry, close in Destructor
  HKEY        m_hkeyPredefinedKey;
  LPWSTR m_strCompleteName ;  //Free in Destructor
  DWORD   m_dwFlags;
  //This HWND to application window
  HWND  m_hWnd;
  //This is HWND to currently infocus ACLUI property Sheet. Null if none
  HWND  m_hWndProperty;
  AUTHZ_RESOURCE_MANAGER_HANDLE m_ResourceManager;    //Used for access check
  AUTHZ_RESOURCE_MANAGER_HANDLE GetAUTHZ_RM(){ return m_ResourceManager; }
  HWND GetInFocusHWnd() { return m_hWndProperty? m_hWndProperty : m_hWnd; }

public:
  CKeySecurityInformation(): m_strKeyName(NULL),m_strParentName(NULL),
                             m_strMachineName(NULL), m_strPageTitle(NULL),
                             m_bRemote(false),m_PredefinedKey((PREDEFINE_KEY)0),
                             m_bReadOnly(false),m_strCompleteName(NULL),
                             m_hWnd(NULL), m_hWndProperty(NULL),
                             m_ResourceManager(NULL){}
  ~CKeySecurityInformation();

public:


  // *** ISecurityInformation methods ***
  STDMETHOD(GetObjectInformation) (PSI_OBJECT_INFO pObjectInfo );
  STDMETHOD(GetSecurity)(
    IN  SECURITY_INFORMATION  RequestedInformation,
    OUT PSECURITY_DESCRIPTOR  *ppSecurityDescriptor,
    IN  BOOL                  fDefault
  );
  STDMETHOD(SetSecurity)(
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
  );
  STDMETHOD(GetAccessRights)(
    const GUID  *pguidObjectType,
    DWORD       dwFlags,
    PSI_ACCESS  *ppAccess,
    ULONG       *pcAccesses,
    ULONG       *piDefaultAccess
  );
  STDMETHOD(MapGeneric)(
    const GUID  *pguidObjectType,
    UCHAR       *pAceFlags,
    ACCESS_MASK *pMask
  );
  STDMETHOD(GetInheritTypes)(
    PSI_INHERIT_TYPE  *ppInheritTypes,
    ULONG             *pcInheritTypes
  );
  STDMETHOD(PropertySheetPageCallback)(
    HWND          hwnd, 
    UINT          uMsg, 
    SI_PAGE_TYPE  uPage
  );
  STDMETHOD(GetEffectivePermission) (  const GUID* pguidObjectType,
                                         PSID pUserSid,
                                         LPCWSTR pszServerName,
                                         PSECURITY_DESCRIPTOR pSD,
                                         POBJECT_TYPE_LIST *ppObjectTypeList,
                                         ULONG *pcObjectTypeListLength,
                                         PACCESS_MASK *ppGrantedAccessList,
                                         ULONG *pcGrantedAccessListLength) ;

  STDMETHOD(GetInheritSource)(SECURITY_INFORMATION si,
                              PACL pACL, 
                              PINHERITED_FROM *ppInheritArray);


  HRESULT Initialize ( LPCWSTR strKeyName,
                       LPCWSTR strParentName,
                       LPCWSTR strMachineName,
                       LPCWSTR strPageTitle,
                       BOOL    bRemote,
                       PREDEFINE_KEY PredefinedKey,
                       BOOL bReadOnly,
                       HWND hWnd);

protected:
  HRESULT SetCompleteName();
  LPCWSTR GetCompleteName(){ return m_strCompleteName; }
  LPCWSTR GetCompleteName1();
  HRESULT SetHandleToPredefinedKey();


  STDMETHOD(WriteObjectSecurity)(
    LPCTSTR pszObject,
    SECURITY_INFORMATION si,
    PSECURITY_DESCRIPTOR pSD
  );

  STDMETHOD(WriteObjectSecurity)(
    HKEY hkey,
    SECURITY_INFORMATION si,
    PSECURITY_DESCRIPTOR pSD
  );

  HRESULT SetSubKeysSecurity(
    HKEY hkey,
    SECURITY_INFORMATION si,
    PSECURITY_DESCRIPTOR pSD,
    LPBOOL pbNotAllApplied,
    bool bFirstCall 
  );
  HRESULT OpenKey(
    DWORD Permission,
    PHKEY pKey 
  );

};


//
extern "C"
{

HRESULT CreateSecurityInformation( IN LPCWSTR strKeyName,
                                   IN LPCWSTR strParentName,
                                   IN LPCWSTR strMachineName,
                                   IN LPCWSTR strPageTitle,
                                   IN BOOL    bRemote,
                                   IN PREDEFINE_KEY PredefinedKey,
                                   IN BOOL bReadOnly,
                                   IN HWND hWnd,
                                   OUT LPSECURITYINFO *pSi);
}

BOOL DisplayMessage( HWND hWnd,
										 HINSTANCE hInstance,
										 DWORD dwMessageId,
										 DWORD dwCaptionId );


#endif // ~__PERMPAGE_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\regedit\regsec.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    regsec.cpp

Abstract:

    ISecurityInformation implementation for Registry Key

Author:

    Hitesh Raigandhi (raigah) May-1999


Revision History:

--*/

//Include Files:

#include "wchar.h"
#include "regsec.h"
#include "regresid.h"
#include "assert.h"



// ISecurityInformation interface implementation

EXTERN_C const GUID IID_ISecurityInformation ; 

// = { 0x965fc360, 0x16ff, 0x11d0, 0x91, 0xcb, 0x0, 0xaa, 0x0, 0xbb, 0xb7, 0x23 }; 

//The Following array defines the permission names for Registry Key Objects
SI_ACCESS siKeyAccesses[] =
{
    { NULL, 
        KEY_ALL_ACCESS,
        MAKEINTRESOURCE(IDS_SEC_EDITOR_FULL_ACCESS), 
        SI_ACCESS_GENERAL | CONTAINER_INHERIT_ACE | SI_ACCESS_SPECIFIC },
    { NULL, 
        KEY_QUERY_VALUE, 
        MAKEINTRESOURCE(IDS_SEC_EDITOR_QUERY_VALUE), 
        SI_ACCESS_SPECIFIC | CONTAINER_INHERIT_ACE },
    { NULL, 
        KEY_SET_VALUE,
        MAKEINTRESOURCE(IDS_SEC_EDITOR_SET_VALUE), 
        SI_ACCESS_SPECIFIC | CONTAINER_INHERIT_ACE },
    { NULL, 
        KEY_CREATE_SUB_KEY,
        MAKEINTRESOURCE(IDS_SEC_EDITOR_CREATE_SUBKEY), 
        SI_ACCESS_SPECIFIC | CONTAINER_INHERIT_ACE },
    { NULL, 
        KEY_ENUMERATE_SUB_KEYS,
        MAKEINTRESOURCE(IDS_SEC_EDITOR_ENUM_SUBKEYS), 
        SI_ACCESS_SPECIFIC | CONTAINER_INHERIT_ACE },
    { NULL, 
        KEY_NOTIFY,
        MAKEINTRESOURCE(IDS_SEC_EDITOR_NOTIFY), 
        SI_ACCESS_SPECIFIC | CONTAINER_INHERIT_ACE },
    { NULL, 
        KEY_CREATE_LINK,
        MAKEINTRESOURCE(IDS_SEC_EDITOR_CREATE_LINK), 
        SI_ACCESS_SPECIFIC | CONTAINER_INHERIT_ACE },
    { NULL, 
        0x00010000, /* DELETE, */
        MAKEINTRESOURCE(IDS_SEC_EDITOR_DELETE), 
        SI_ACCESS_SPECIFIC | CONTAINER_INHERIT_ACE },
    { NULL, 
        WRITE_DAC,
        MAKEINTRESOURCE(IDS_SEC_EDITOR_WRITE_DAC), 
        SI_ACCESS_SPECIFIC | CONTAINER_INHERIT_ACE },
    { NULL, 
        WRITE_OWNER,
        MAKEINTRESOURCE(IDS_SEC_EDITOR_WRITE_OWNER), 
        SI_ACCESS_SPECIFIC | CONTAINER_INHERIT_ACE },
    { NULL, 
        READ_CONTROL,
        MAKEINTRESOURCE(IDS_SEC_EDITOR_READ_CONTROL), 
        SI_ACCESS_SPECIFIC | CONTAINER_INHERIT_ACE },
    { NULL, 
        KEY_READ,
        MAKEINTRESOURCE(IDS_SEC_EDITOR_READ), 
        SI_ACCESS_GENERAL | CONTAINER_INHERIT_ACE  },
};

// The following array defines the inheritance types for Registry.
//
//
// For Keys, objects and containers are the same, so no need for OBJECT_INHERIT_ACE
//
SI_INHERIT_TYPE siKeyInheritTypes[] =
{
        NULL, 0,                                        MAKEINTRESOURCE(IDS_KEY_FOLDER),
        NULL, CONTAINER_INHERIT_ACE,                    MAKEINTRESOURCE(IDS_KEY_FOLDER_SUBFOLDER),
        NULL, INHERIT_ONLY_ACE | CONTAINER_INHERIT_ACE, MAKEINTRESOURCE(IDS_KEY_SUBFOLDER_ONLY)
};


#define iKeyDefAccess                 10     // index of value in array siKeyAccesses
#ifndef ARRAYSIZE
#define ARRAYSIZE(x)                    (sizeof(x)/sizeof(x[0]))
#endif


PWSTR _PredefinedKeyName[] = {    L"CLASSES_ROOT",
                                L"CURRENT_USER",
                                L"MACHINE",
                                L"USERS",
                                L"CONFIG" };




//CKeySecurityInformation Functions
    
HRESULT 
CKeySecurityInformation::Initialize( LPCWSTR strKeyName,
                                             LPCWSTR strParentName,
                                             LPCWSTR strMachineName,
                                             LPCWSTR strPageTitle,
                                             BOOL        bRemote,
                                             PREDEFINE_KEY PredefinedKey,    
                                             BOOL bReadOnly,
                                             HWND hWnd)
{
    if( strParentName )
        if( !strKeyName )
            return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);

     if( NULL == strMachineName )
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);

     if( NULL == hWnd )
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);

     if( NULL == strPageTitle )
         return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    
     AuthzInitializeResourceManager(NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    0, 
                                    &m_ResourceManager );


    HRESULT hr = S_OK;
    m_strKeyName = strKeyName;
    m_strParentName = strParentName;
    m_strMachineName = strMachineName;
    m_strPageTitle = strPageTitle;
    m_bRemote = bRemote;
    m_PredefinedKey = PredefinedKey;
    m_bReadOnly = bReadOnly;
    m_hWnd = hWnd;
    m_dwFlags = SI_EDIT_ALL | SI_ADVANCED | SI_CONTAINER
                        | SI_RESET_DACL_TREE | SI_RESET_SACL_TREE 
                        | SI_OWNER_RECURSE | SI_PAGE_TITLE | SI_EDIT_EFFECTIVE;

    if( m_bReadOnly )
        m_dwFlags |= SI_READONLY | SI_OWNER_READONLY ;




    //Set Handle to Predfined key
    if( S_OK    != ( hr = SetHandleToPredefinedKey() ) )
        return hr;
 

    //Set CompleteName
    if( S_OK != ( hr = SetCompleteName() ) )
        return hr;

    return S_OK;

}

CKeySecurityInformation::~CKeySecurityInformation()
{
    if( m_strCompleteName )
        LocalFree( m_strCompleteName );
    
    //Close Handle to Remote Registry if it was successfully opened.
    if( m_bRemote && m_hkeyPredefinedKey )
        RegCloseKey(m_hkeyPredefinedKey);

   AuthzFreeResourceManager(m_ResourceManager);


}



//Sets the complete name in Format:
// "\\machine_name\Predefined_keyName\regkey_path
HRESULT  
CKeySecurityInformation::SetCompleteName()
{
    UINT len = 0;
    PWSTR pstrCompleteName;
    
    if( m_bRemote )
    {
        len += wcslen( m_strMachineName );
        len++;
    }

    len += wcslen(_PredefinedKeyName[ m_PredefinedKey]);
    len++;

    if( m_strParentName )
    {
        len += wcslen(m_strParentName);
        len++;
    }

    if( m_strKeyName )
    {
        len += wcslen(m_strKeyName);
        len++;
    }

    len++;    //Terminating null

    pstrCompleteName = (PWSTR)LocalAlloc(LPTR, len * sizeof(WCHAR));
    if( pstrCompleteName == NULL )
        return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);

    if( m_bRemote )
    {
        wcscpy(pstrCompleteName,m_strMachineName);
        wcscat(pstrCompleteName, L"\\");
    }

    wcscat(pstrCompleteName,_PredefinedKeyName[ m_PredefinedKey]);
    wcscat(pstrCompleteName,L"\\");
    if(m_strParentName)
    {
        wcscat(pstrCompleteName,m_strParentName);
        wcscat(pstrCompleteName,L"\\");
    }

    if(m_strKeyName)
    {
        wcscat(pstrCompleteName, m_strKeyName );
        wcscat(pstrCompleteName,L"\\");
    }
    
    m_strCompleteName = pstrCompleteName;

    return S_OK;
}

//Doesn't have Predefined key name attached
//Caller must LocalFree
LPCWSTR 
CKeySecurityInformation::GetCompleteName1()
{
    UINT len = 0;
    PWSTR pstrCompleteName;
    
 if( m_strParentName )
 {
     len += wcslen(m_strParentName);
     len++;
 }

 if( m_strKeyName )
 {
     len += wcslen(m_strKeyName);
     len++;
 }

 len++;     //Terminating null

    pstrCompleteName = (PWSTR)LocalAlloc(LPTR, len * sizeof(WCHAR));
    if( pstrCompleteName == NULL )
        return NULL;

    if(m_strParentName)
    {
        wcscpy(pstrCompleteName,m_strParentName);
        wcscat(pstrCompleteName,L"\\");
    }

    if(m_strKeyName)
    {
        wcscat(pstrCompleteName, m_strKeyName );
        wcscat(pstrCompleteName,L"\\");
    }
    return pstrCompleteName;
}




HRESULT
CKeySecurityInformation::SetHandleToPredefinedKey()
{
    DWORD dwErr;
    HRESULT hr = S_OK;
    if( !m_bRemote ) {
        switch ( m_PredefinedKey ){
        case PREDEFINE_KEY_CLASSES_ROOT:
                m_hkeyPredefinedKey= HKEY_CLASSES_ROOT;
                break;
        case PREDEFINE_KEY_CURRENT_USER: 
                m_hkeyPredefinedKey = HKEY_CURRENT_USER;
                break;
        case PREDEFINE_KEY_LOCAL_MACHINE :
                m_hkeyPredefinedKey = HKEY_LOCAL_MACHINE;
                break;
        case PREDEFINE_KEY_USERS:
                m_hkeyPredefinedKey = HKEY_USERS;
                break;
        case PREDEFINE_KEY_CURRENT_CONFIG :
                m_hkeyPredefinedKey = HKEY_CURRENT_CONFIG;
                break;
        default:
                    //assert(false);
            break;
        }
    } 
    else {        //IsRemoteRegistry
        switch ( m_PredefinedKey ){
        case PREDEFINE_KEY_CLASSES_ROOT:
        case PREDEFINE_KEY_CURRENT_USER:
        case PREDEFINE_KEY_CURRENT_CONFIG:
                m_hkeyPredefinedKey = 0;
                break;
        case PREDEFINE_KEY_LOCAL_MACHINE :
                m_hkeyPredefinedKey = HKEY_LOCAL_MACHINE;
                break;
        case PREDEFINE_KEY_USERS:
                m_hkeyPredefinedKey = HKEY_USERS;
                break;
        default:
                    //assert(false);
                break;
        }
        if( m_hkeyPredefinedKey ){
             dwErr = RegConnectRegistry( m_strMachineName,
                                                                     m_hkeyPredefinedKey,
                                                                     &m_hkeyPredefinedKey );
            if( dwErr ) {
                m_hkeyPredefinedKey = 0;
                hr = HRESULT_FROM_WIN32( dwErr );
            }
        }
    }     //IsRemoteRegistry

    return hr;
}
/*
JeffreyS 1/24/97:
If you don't set the SI_RESET flag in
ISecurityInformation::GetObjectInformation, then fDefault should never be TRUE
so you can ignore it.  Returning E_NOTIMPL in this case is OK too.

If you want the user to be able to reset the ACL to some default state
(defined by you) then turn on SI_RESET and return your default ACL
when fDefault is TRUE.    This happens if/when the user pushes a button
that is only visible when SI_RESET is on.
*/
STDMETHODIMP 
CKeySecurityInformation::GetObjectInformation (
        PSI_OBJECT_INFO pObjectInfo )
{
        assert( NULL != pObjectInfo );
        pObjectInfo->dwFlags = m_dwFlags;
        pObjectInfo->hInstance = GetModuleHandle(NULL);
//        pObjectInfo->pszServerName = (LPWSTR)m_strMachineName;
        pObjectInfo->pszServerName = (LPWSTR)m_strMachineName;
        pObjectInfo->pszObjectName = (LPWSTR)m_strPageTitle;
        return S_OK;
}


STDMETHODIMP
CKeySecurityInformation::GetAccessRights(
        const GUID    *pguidObjectType,
        DWORD             dwFlags,
        PSI_ACCESS    *ppAccess,
        ULONG             *pcAccesses,
        ULONG             *piDefaultAccess
)
{
    assert( NULL != ppAccess );
    assert( NULL != pcAccesses );
    assert( NULL != piDefaultAccess );

    *ppAccess = siKeyAccesses;
    *pcAccesses = ARRAYSIZE(siKeyAccesses);
    *piDefaultAccess = iKeyDefAccess;

    return S_OK;
}


GENERIC_MAPPING KeyMap =
{
    KEY_READ,
    KEY_WRITE,
    KEY_READ,
    KEY_ALL_ACCESS
};

STDMETHODIMP
CKeySecurityInformation::MapGeneric(
        const GUID    *pguidObjectType,
        UCHAR             *pAceFlags,
        ACCESS_MASK *pMask
)
{
//jeffreys
// After returning from the object picker dialog, aclui passes 
//CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE to MapGeneric for validation when 
//    initializing Permission entry for <objectname> dialog.
//hiteshr: since registry keys don't have OBJECT_INHERIT_ACE, remove this FLAG,
//this will cause "this keys and subkeys" to appear as default in combobox.


    *pAceFlags &= ~OBJECT_INHERIT_ACE;
    
    MapGenericMask(pMask, &KeyMap);

    return S_OK;
}

STDMETHODIMP 
CKeySecurityInformation::GetInheritTypes (
        PSI_INHERIT_TYPE    *ppInheritTypes,
        ULONG                         *pcInheritTypes
)
{
    assert( NULL != ppInheritTypes );
    assert( NULL != pcInheritTypes );
    *ppInheritTypes = siKeyInheritTypes;
    *pcInheritTypes = ARRAYSIZE(siKeyInheritTypes);
    return S_OK;
}

STDMETHODIMP 
CKeySecurityInformation::PropertySheetPageCallback(
        HWND                    hwnd, 
        UINT                    uMsg, 
        SI_PAGE_TYPE    uPage
)
{
  switch (uMsg)
  {
  case PSPCB_SI_INITDIALOG:
    m_hWndProperty = hwnd;
    break;
  case PSPCB_RELEASE:
    m_hWndProperty = NULL;
    break;
  }

  return S_OK;
}


STDMETHODIMP 
CKeySecurityInformation::GetSecurity( IN    SECURITY_INFORMATION    RequestedInformation,
                                      OUT PSECURITY_DESCRIPTOR    *ppSecurityDescriptor,
                                      IN    BOOL    fDefault )
{
    if( fDefault )
        return E_NOTIMPL;
    
    assert( NULL != ppSecurityDescriptor );

    HRESULT hr;

    LPCTSTR pstrKeyName = GetCompleteName();
    DWORD dwErr = 0;


    dwErr = GetNamedSecurityInfo(  (LPTSTR)pstrKeyName,
                                    SE_REGISTRY_KEY,
                                    RequestedInformation,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    ppSecurityDescriptor);


    return ( ( dwErr != ERROR_SUCCESS ) ? HRESULT_FROM_WIN32(dwErr) : S_OK);

}

STDMETHODIMP 
CKeySecurityInformation::SetSecurity(IN SECURITY_INFORMATION si,
                                     IN PSECURITY_DESCRIPTOR pSD )
{
   if( NULL == pSD )
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);


   HRESULT hr = S_OK;
   SECURITY_INFORMATION siLocal = 0;
   SECURITY_DESCRIPTOR sdLocal = {0};
   ACL daclEmpty = {0};
   HKEY hkeyOld = NULL;
   HKEY hKeyNew = NULL;
   BOOL bWriteInfo = false;
   DWORD Error = 0;
   
    //
    // Create a security descriptor with no SACL and an
    // empty DACL for recursively resetting security
    //
    InitializeSecurityDescriptor(&sdLocal, SECURITY_DESCRIPTOR_REVISION);
    InitializeAcl(&daclEmpty, sizeof(ACL), ACL_REVISION);
    SetSecurityDescriptorDacl(&sdLocal, TRUE, &daclEmpty, FALSE);
    SetSecurityDescriptorSacl(&sdLocal, TRUE, &daclEmpty, FALSE);

    //
    // If we need to recursively set the Owner, get the Owner &
    // Group from pSD.
    //
    if (si & SI_OWNER_RECURSE)
    {
            PSID psid;
            BOOL bDefaulted;
            assert(si & (OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION));
            siLocal |= si & (OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION);

            if (GetSecurityDescriptorOwner(pSD, &psid, &bDefaulted))
                SetSecurityDescriptorOwner(&sdLocal, psid, bDefaulted);
           if (GetSecurityDescriptorGroup(pSD, &psid, &bDefaulted))
                SetSecurityDescriptorGroup(&sdLocal, psid, bDefaulted);
    }

    if (si & SI_RESET_DACL_TREE)
    {
        assert(si & DACL_SECURITY_INFORMATION);
        siLocal |= si & DACL_SECURITY_INFORMATION;
    }

    if (si & SI_RESET_SACL_TREE)
    {
        assert(si & SACL_SECURITY_INFORMATION);
        siLocal |= si & SACL_SECURITY_INFORMATION;
    }

   if( siLocal )
   {
      //Open the key with current Maximum Allowed Permisson
      //When applying permissons recursively , we first use current permisson,
      //if current permisson doesn't have enough rights, we reopen handle to key with
      //new permissons. If none (old or new )has enough permissons to enumerate child and
      // Query info we fail.
      REGSAM samDesired = MAXIMUM_ALLOWED;
        if( si & SACL_SECURITY_INFORMATION ) 
                samDesired |= ACCESS_SYSTEM_SECURITY;
        if( si & DACL_SECURITY_INFORMATION ) 
                samDesired |= WRITE_DAC;
        if( si & OWNER_SECURITY_INFORMATION )
                samDesired |= WRITE_OWNER;

        //Open the selected key
        if( S_OK != ( hr = OpenKey( samDesired, &hkeyOld ) ) ){
                return hr;
        }

    
        //Check if key has Enumeration Permisson
        DWORD             NumberOfSubKeys = 0;
        DWORD             MaxSubKeyLength = 0;
        
      //    Find out the total number of subkeys
        Error = RegQueryInfoKey(
                                hkeyOld,
                                NULL,
                                NULL,
                                NULL,
                                &NumberOfSubKeys,
                                &MaxSubKeyLength,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL
                                );

        if( Error != ERROR_SUCCESS ){
         if( Error == ERROR_ACCESS_DENIED ) {

            hr = WriteObjectSecurity( hkeyOld, si, pSD );

            if( hr != S_OK )
            {
               if( m_hkeyPredefinedKey != hkeyOld )
                  RegCloseKey( hkeyOld );
               return hr;
            }
            bWriteInfo = true;
            //
            //  Handle doesn't allow KEY_QUERY_VALUE or READ_CONTROL access.
            //  Open a new handle with these accesses.
            //
            samDesired = MAXIMUM_ALLOWED;
            if( si & SACL_SECURITY_INFORMATION ) {
               samDesired |= ACCESS_SYSTEM_SECURITY;
            } else if( si & DACL_SECURITY_INFORMATION ) {
               samDesired |= WRITE_DAC;
            } else if( si & OWNER_SECURITY_INFORMATION ) {
               samDesired |= WRITE_OWNER;
            }
            
            Error = RegOpenKeyEx( hkeyOld,
                                 NULL,
                                 REG_OPTION_RESERVED,
                                 samDesired,
                                 &hKeyNew
                                 );

            if( Error != ERROR_SUCCESS )
            {  
               if( m_hkeyPredefinedKey != hkeyOld )
                  RegCloseKey( hkeyOld );
               return HRESULT_FROM_WIN32(Error);                  
            }
            else
            {
               if( m_hkeyPredefinedKey != hkeyOld )
                  RegCloseKey( hkeyOld );
            }
            
              Error = RegQueryInfoKey(
                                            hKeyNew,
                                            NULL,
                                            NULL,
                                            NULL,
                                            &NumberOfSubKeys,
                                            &MaxSubKeyLength,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL );
            
            if( Error != ERROR_SUCCESS ) {
               RegCloseKey( hKeyNew );
               return HRESULT_FROM_WIN32( Error );
            }
         }
         else
         {
            if( m_hkeyPredefinedKey != hkeyOld )
               RegCloseKey( hkeyOld );
            return HRESULT_FROM_WIN32( Error );
         }
        }
      else
         hKeyNew = hkeyOld;
      
      if( NumberOfSubKeys )
      {
           assert( MaxSubKeyLength <= MAX_PATH );
        
           DWORD SubKeyNameLength = 0;
           WCHAR SubKeyName[MAX_PATH + 1];

         //
         //  The key has subkeys.
         //  Find out if we are able to enumerate the key using the handle
         //  passed as argument.
         //
         SubKeyNameLength = MAX_PATH;
         Error = RegEnumKey( hKeyNew,
                             0,
                             SubKeyName,
                             SubKeyNameLength );

         if( Error != ERROR_SUCCESS ){
            if( Error == ERROR_ACCESS_DENIED && bWriteInfo == false ){

               hr = WriteObjectSecurity( hkeyOld, si, pSD );

               if( hr != S_OK )
               {
                  if( m_hkeyPredefinedKey != hkeyOld )
                     RegCloseKey( hkeyOld );
                  return hr;
               }

               bWriteInfo = true;
               //
               //  Handle doesn't allow KEY_QUERY_VALUE or READ_CONTROL access.
               //  Open a new handle with these accesses.
               //
               samDesired = MAXIMUM_ALLOWED;
               if( si & SACL_SECURITY_INFORMATION ) {
                  samDesired |= ACCESS_SYSTEM_SECURITY;
               } else if( si & DACL_SECURITY_INFORMATION ) {
                  samDesired |= WRITE_DAC;
               } else if( si & OWNER_SECURITY_INFORMATION ) {
                  samDesired |= WRITE_OWNER;
               }
            
               Error = RegOpenKeyEx( hkeyOld,
                                    NULL,
                                    REG_OPTION_RESERVED,
                                    samDesired,
                                    &hKeyNew
                                    );

               if( Error != ERROR_SUCCESS )
               {
                  if( m_hkeyPredefinedKey != hkeyOld )
                     RegCloseKey( hkeyOld );
                  return HRESULT_FROM_WIN32(Error);                  
               }
               else
               {
                  if( m_hkeyPredefinedKey != hkeyOld )
                     RegCloseKey( hkeyOld );
               }    
               SubKeyNameLength = MAX_PATH;
               Error = RegEnumKey( hKeyNew,
                                   0,
                                   SubKeyName,
                                   SubKeyNameLength );
               
               if( Error != ERROR_SUCCESS ){
                  RegCloseKey( hKeyNew );                  
                  return HRESULT_FROM_WIN32(Error);
               }         
            }   
            else
            {
               if( m_hkeyPredefinedKey != hKeyNew )
                  RegCloseKey( hKeyNew );
               return HRESULT_FROM_WIN32(Error);
            }
               
         }

      }
   }
    //
    // Recursively apply new Owner and/or reset the ACLs
    //
    if (siLocal)
    {
        BOOL bNotAllApplied = FALSE;
      hr = SetSubKeysSecurity( hKeyNew, siLocal, &sdLocal, &bNotAllApplied, true );
        RegFlushKey( hKeyNew );
        
      if( m_hkeyPredefinedKey != hKeyNew )
                RegCloseKey( hKeyNew );        

       if( bNotAllApplied )
        {
           if( siLocal & OWNER_SECURITY_INFORMATION )
           { 
               DisplayMessage( GetInFocusHWnd(),
                            GetModuleHandle(NULL),
                            IDS_SET_OWNER_RECURSIVE_EX_FAIL,
                            IDS_SECURITY );
           }
           else if( ( siLocal & DACL_SECURITY_INFORMATION ) || ( siLocal & SACL_SECURITY_INFORMATION ) )
           { 
               DisplayMessage( GetInFocusHWnd(),
                            GetModuleHandle(NULL),
                            IDS_SET_SECURITY_RECURSIVE_EX_FAIL,
                            IDS_SECURITY);
           }

        }

      if( hr != S_OK )
         return hr;
    }

   si &= ~(SI_OWNER_RECURSE | SI_RESET_DACL_TREE | SI_RESET_SACL_TREE);

    //This sets the security for the top keys
    if (si != 0)
    {
        hr = WriteObjectSecurity( GetCompleteName(),
                                          si,
                                          pSD );

      if( hr != S_OK )
      {
         if( siLocal )
            RegCloseKey( hkeyOld );
         return hr;
      }
    }


    return hr;
}

STDMETHODIMP 
CKeySecurityInformation::WriteObjectSecurity(LPCTSTR pszObject,
                                             IN SECURITY_INFORMATION si,
                                             IN PSECURITY_DESCRIPTOR pSD )
{
        DWORD dwErr;
        SECURITY_DESCRIPTOR_CONTROL wSDControl = 0;
        DWORD dwRevision;
        PSID psidOwner = NULL;
        PSID psidGroup = NULL;
        PACL pDacl = NULL;
        PACL pSacl = NULL;
        BOOL bDefaulted;
        BOOL bPresent;

        //
        // Get pointers to various security descriptor parts for
        // calling SetNamedSecurityInfo
        //

        if( !GetSecurityDescriptorControl(pSD, &wSDControl, &dwRevision) )
        {
            dwErr = GetLastError();
            return HRESULT_FROM_WIN32(dwErr);
        }
        if( !GetSecurityDescriptorOwner(pSD, &psidOwner, &bDefaulted) )
        {
            dwErr = GetLastError();
            return HRESULT_FROM_WIN32(dwErr);
        }
        if( !GetSecurityDescriptorGroup(pSD, &psidGroup, &bDefaulted) )
        {
            dwErr = GetLastError();
            return HRESULT_FROM_WIN32(dwErr);
        }
        if( !GetSecurityDescriptorDacl(pSD, &bPresent, &pDacl, &bDefaulted) )
        {
            dwErr = GetLastError();
            return HRESULT_FROM_WIN32(dwErr);
        }
        if( !GetSecurityDescriptorSacl(pSD, &bPresent, &pSacl, &bDefaulted) )
        {
            dwErr = GetLastError();
            return HRESULT_FROM_WIN32(dwErr);
        }

        if ((si & DACL_SECURITY_INFORMATION) && (wSDControl & SE_DACL_PROTECTED))
                si |= PROTECTED_DACL_SECURITY_INFORMATION;
      else
            si |= UNPROTECTED_DACL_SECURITY_INFORMATION;
        
      if ((si & SACL_SECURITY_INFORMATION) && (wSDControl & SE_SACL_PROTECTED))
                si |= PROTECTED_SACL_SECURITY_INFORMATION;
      else
            si |= UNPROTECTED_SACL_SECURITY_INFORMATION;
      
        //if the selected key is predefined key, it has no parent and hence
        //cannot inherit any permisson from parent.
        //if PROTECTED_DACL_SECURITY_INFORMATION flag is not set in this case
        // SetSecurityInfo succeeds, but permissions are not set.[bug in SetSecurityInfo].
        if ( (si & DACL_SECURITY_INFORMATION) && !m_strKeyName )
                si |= PROTECTED_DACL_SECURITY_INFORMATION;
      else
            si |= UNPROTECTED_DACL_SECURITY_INFORMATION;

        if ( (si & SACL_SECURITY_INFORMATION) && !m_strKeyName )
                si |= PROTECTED_SACL_SECURITY_INFORMATION;
      else
            si |= UNPROTECTED_SACL_SECURITY_INFORMATION;


        //We are on the root object
        if( m_strKeyName == NULL )
        {
            dwErr = SetSecurityInfo( m_hkeyPredefinedKey,
                                             SE_REGISTRY_KEY,
                                             si,
                                             psidOwner,
                                             psidGroup,
                                             pDacl,
                                             pSacl);
        }else
        {
     
            dwErr = SetNamedSecurityInfo((LPWSTR)pszObject,
                                                    SE_REGISTRY_KEY,
                                                    si,
                                                    psidOwner,
                                                    psidGroup,
                                                    pDacl,
                                                    pSacl);
        }
        
        return (dwErr ? HRESULT_FROM_WIN32(dwErr) : S_OK);
}

STDMETHODIMP 
CKeySecurityInformation::WriteObjectSecurity(HKEY hkey,
                                             IN SECURITY_INFORMATION si,
                                             IN PSECURITY_DESCRIPTOR pSD )
{
        DWORD dwErr;
        SECURITY_DESCRIPTOR_CONTROL wSDControl = 0;
        DWORD dwRevision;
        PSID psidOwner = NULL;
        PSID psidGroup = NULL;
        PACL pDacl = NULL;
        PACL pSacl = NULL;
        BOOL bDefaulted;
        BOOL bPresent;

        //
        // Get pointers to various security descriptor parts for
        // calling SetNamedSecurityInfo
        //
        ;
        if( !GetSecurityDescriptorControl(pSD, &wSDControl, &dwRevision) )
        {
            dwErr = GetLastError();
            return HRESULT_FROM_WIN32(dwErr);
        }
        if( !GetSecurityDescriptorOwner(pSD, &psidOwner, &bDefaulted) )
        {
            dwErr = GetLastError();
            return HRESULT_FROM_WIN32(dwErr);
        }
        if( !GetSecurityDescriptorGroup(pSD, &psidGroup, &bDefaulted) )
        {
            dwErr = GetLastError();
            return HRESULT_FROM_WIN32(dwErr);
        }
        if( !GetSecurityDescriptorDacl(pSD, &bPresent, &pDacl, &bDefaulted) )
        {
            dwErr = GetLastError();
            return HRESULT_FROM_WIN32(dwErr);
        }
        if( !GetSecurityDescriptorSacl(pSD, &bPresent, &pSacl, &bDefaulted) )
        {
            dwErr = GetLastError();
            return HRESULT_FROM_WIN32(dwErr);
        }

        if ((si & DACL_SECURITY_INFORMATION) && (wSDControl & SE_DACL_PROTECTED))
                si |= PROTECTED_DACL_SECURITY_INFORMATION;
      else
            si |= UNPROTECTED_DACL_SECURITY_INFORMATION;
        if ((si & SACL_SECURITY_INFORMATION) && (wSDControl & SE_SACL_PROTECTED))
                si |= PROTECTED_SACL_SECURITY_INFORMATION;
      else
            si |= UNPROTECTED_SACL_SECURITY_INFORMATION;

        dwErr = SetSecurityInfo(    hkey,
                                             SE_REGISTRY_KEY,
                                             si,
                                             psidOwner,
                                             psidGroup,
                                             pDacl,
                                             pSacl);
        
        return (dwErr ? HRESULT_FROM_WIN32(dwErr) : S_OK);
}






HRESULT 
CKeySecurityInformation::SetSubKeysSecurity( HKEY hkey,
                                             SECURITY_INFORMATION si,
                                             PSECURITY_DESCRIPTOR pSD,
                                             LPBOOL pbNotAllApplied,
                                             bool bFirstCall )
{
        ULONG             Error;
        REGSAM            samDesired;
        HRESULT hr;
        HRESULT hrRet;
      HKEY hKeyNew;

        //For First Call we call SetSecurityInfoEx in last
        if( !bFirstCall ){

            SECURITY_DESCRIPTOR_CONTROL wSDControl = 0;
            DWORD dwRevision;
            PSID psidOwner = NULL;
            PSID psidGroup = NULL;
            PACL pDacl = NULL;
            PACL pSacl = NULL;
            BOOL bDefaulted;
            BOOL bPresent;
            DWORD dwErr;
            //
            // Get pointers to various security descriptor parts for
            // calling SetNamedSecurityInfo
            //
            if( !GetSecurityDescriptorControl(pSD, &wSDControl, &dwRevision) )
            {
                *pbNotAllApplied = TRUE;
                goto SET_FOR_CHILD;
            }
            if( !GetSecurityDescriptorOwner(pSD, &psidOwner, &bDefaulted) )
            {
                *pbNotAllApplied = TRUE;
                goto SET_FOR_CHILD;
            }
            if( !GetSecurityDescriptorGroup(pSD, &psidGroup, &bDefaulted) )
            {
                *pbNotAllApplied = TRUE;
                goto SET_FOR_CHILD;
            }
            if( !GetSecurityDescriptorDacl(pSD, &bPresent, &pDacl, &bDefaulted) )
            {
                *pbNotAllApplied = TRUE;
                goto SET_FOR_CHILD;
            }
            if( !GetSecurityDescriptorSacl(pSD, &bPresent, &pSacl, &bDefaulted) )
            {
                *pbNotAllApplied = TRUE;
                goto SET_FOR_CHILD;
            }


            if ((si & DACL_SECURITY_INFORMATION) && (wSDControl & SE_DACL_PROTECTED))
                si |= PROTECTED_DACL_SECURITY_INFORMATION;
         else
            si |= UNPROTECTED_DACL_SECURITY_INFORMATION;

            if ((si & SACL_SECURITY_INFORMATION) && (wSDControl & SE_SACL_PROTECTED))
                si |= PROTECTED_SACL_SECURITY_INFORMATION;
         else
            si |= UNPROTECTED_SACL_SECURITY_INFORMATION;

     
            dwErr = SetSecurityInfo( hkey,
                                  SE_REGISTRY_KEY,
                                  si,
                                  psidOwner,
                                  psidGroup,
                                  pDacl,
                                  pSacl);

            if( dwErr != ERROR_SUCCESS )
            {
                *pbNotAllApplied = TRUE;
                goto SET_FOR_CHILD;
                //return HRESULT_FROM_WIN32(dwErr);
            }
         //RegFlushKey( hkey );
 
        }

SET_FOR_CHILD:

        DWORD             NumberOfSubKeys = 0;
        DWORD             MaxSubKeyLength = 0;
        //    Find out the total number of subkeys
        Error = RegQueryInfoKey(
                                hkey,
                                NULL,
                                NULL,
                                NULL,
                                &NumberOfSubKeys,
                                &MaxSubKeyLength,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL
                                );

        if( Error != ERROR_SUCCESS ){
         if( Error == ERROR_ACCESS_DENIED ) {
            //
            //  Handle doesn't allow KEY_QUERY_VALUE or READ_CONTROL access.
            //  Open a new handle with these accesses.
            //
            samDesired = KEY_QUERY_VALUE | READ_CONTROL; // MAXIMUM_ALLOWED | READ_CONTROL;
            if( si & SACL_SECURITY_INFORMATION ) {
               samDesired |= ACCESS_SYSTEM_SECURITY;
            } else if( si & DACL_SECURITY_INFORMATION ) {
               samDesired |= WRITE_DAC;
            } else if( si & OWNER_SECURITY_INFORMATION ) {
               samDesired |= WRITE_OWNER;
            }
            
            Error = RegOpenKeyEx( hkey,
                                 NULL,
                                 REG_OPTION_RESERVED,
                                 samDesired,
                                 &hKeyNew
                                 );

            if( Error != ERROR_SUCCESS ) {
               *pbNotAllApplied = TRUE;
                  return S_OK;
            }
              Error = RegQueryInfoKey(
                                            hKeyNew,
                                            NULL,
                                            NULL,
                                            NULL,
                                            &NumberOfSubKeys,
                                            &MaxSubKeyLength,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL );
            
            if( Error != ERROR_SUCCESS ) {
               RegCloseKey( hKeyNew );
                  *pbNotAllApplied = TRUE;
                  return S_OK;
            }
            else
               RegCloseKey( hKeyNew );
         }
         else{
            *pbNotAllApplied = TRUE;
               return S_OK;
         }

        }
      
      if( NumberOfSubKeys == 0 ) {
         return S_OK;
      }

        assert( MaxSubKeyLength <= MAX_PATH );
        
        DWORD SubKeyNameLength = 0;
        WCHAR SubKeyName[MAX_PATH + 1];

      //
      //  The key has subkeys.
      //  Find out if we are able to enumerate the key using the handle
      //  passed as argument.
      //
      SubKeyNameLength = MAX_PATH;
      Error = RegEnumKey( hkey,
                          0,
                          SubKeyName,
                          SubKeyNameLength );

      if( Error != ERROR_SUCCESS ){
         
         if( Error == ERROR_ACCESS_DENIED ) {
            //
            //  Handle doesn't allow 'enumerate' access.
            //  Open a new handle with KEY_ENUMERATE_SUB_KEYS access.
            //

            Error = RegOpenKeyEx( hkey,
                                  NULL,
                                  REG_OPTION_RESERVED,
                                  KEY_ENUMERATE_SUB_KEYS, // samDesired,
                                  &hKeyNew
                               );
            if( Error != ERROR_SUCCESS ){
               *pbNotAllApplied = TRUE;
               return S_OK;
            }
         }
         else{
            *pbNotAllApplied = TRUE;
            return S_OK;
         }
      }
      else {
         hKeyNew = hkey;
      }


        for( DWORD Index = 0; Index < NumberOfSubKeys; Index++ ) 
      {

                //    If the key has subkeys, then for each subkey, do:
                //    - Determine the subkey name
                SubKeyNameLength = MAX_PATH;

                Error = RegEnumKey( hKeyNew,
                                Index,
                                SubKeyName,
                                SubKeyNameLength );


                if( Error != ERROR_SUCCESS ) {
                    *pbNotAllApplied = TRUE;
                    continue;
                    //return HRESULT_FROM_WIN32( Error );
                }

                //    - Open a handle to the subkey

                samDesired = MAXIMUM_ALLOWED;
                
                if( si & SACL_SECURITY_INFORMATION ) 
                        samDesired |= ACCESS_SYSTEM_SECURITY;
                if( si & DACL_SECURITY_INFORMATION ) 
                        samDesired |= WRITE_DAC;
                if( si & OWNER_SECURITY_INFORMATION )
                        samDesired |= WRITE_OWNER;

                HKEY hkeyChild;
                Error = RegOpenKeyEx( hKeyNew,
                                  SubKeyName,
                                  REG_OPTION_RESERVED,
                                  samDesired,
                                             &hkeyChild
                                                        );
                if( ERROR_SUCCESS != Error ){
                        *pbNotAllApplied = TRUE;
                        continue;
//                    return HRESULT_FROM_WIN32( Error );
                }


                //    - Set the security of the child's subkeys
                if( S_OK != ( hr = SetSubKeysSecurity( hkeyChild,
                                                                             si,
                                                                             pSD,
                                                                             pbNotAllApplied,
                                                                             false ) )    ){
                    //This case will occur only if some fatal error occur which
                    //prevents propogation on rest of the tree.
               if( hKeyNew != hkey )
                  RegCloseKey( hKeyNew );
                    RegCloseKey( hkeyChild );
                    return hr;
                }
                else{
                    RegCloseKey( hkeyChild );
                }
        
        } //For loop
      if( hKeyNew != hkey )
         RegCloseKey( hKeyNew );
        return S_OK;;
}





HRESULT
CKeySecurityInformation::OpenKey(IN  DWORD Permission,
                                                                 OUT PHKEY pKey )
{


        LPCWSTR             CompleteNameString = NULL;;
        ULONG             Error;

        if( m_strKeyName == NULL){
            //This is a predefined key
            *pKey = m_hkeyPredefinedKey;
        }
        else{
            CompleteNameString = GetCompleteName1();
            assert( CompleteNameString != NULL );
            //    Open handle to the key
            Error = RegOpenKeyEx(m_hkeyPredefinedKey,
                                                        CompleteNameString,
                                                        0,
                                                        Permission,
                                                        pKey );

            if( Error != ERROR_SUCCESS ) {
                return HRESULT_FROM_WIN32( Error );
            }
        }
        if( CompleteNameString )
            LocalFree( (HLOCAL) CompleteNameString);
        return S_OK;
}

OBJECT_TYPE_LIST g_DefaultOTL[] = {
                                    {0, 0, (LPGUID)&GUID_NULL},
                                    };
BOOL SkipLocalGroup(LPCWSTR pszServerName, PSID psid)
{

	SID_NAME_USE use;
	WCHAR szAccountName[MAX_PATH];
	WCHAR szDomainName[MAX_PATH];
	DWORD dwAccountLen = MAX_PATH;
	DWORD dwDomainLen = MAX_PATH;

	if(LookupAccountSid(pszServerName,
						 psid,
						 szAccountName,
						 &dwAccountLen,
						 szDomainName,
						 &dwDomainLen,
						 &use))
	{
		if(use == SidTypeWellKnownGroup)
			return TRUE;
	}
	//Built In sids have first subauthority of 32 ( s-1-5-32 )
	//
	if((*(GetSidSubAuthorityCount(psid)) >= 1 ) && (*(GetSidSubAuthority(psid,0)) == 32))
		return TRUE;

	return FALSE;
}


STDMETHODIMP 
CKeySecurityInformation::GetEffectivePermission(const GUID* pguidObjectType,
                                        PSID pUserSid,
                                        LPCWSTR pszServerName,
                                        PSECURITY_DESCRIPTOR pSD,
                                        POBJECT_TYPE_LIST *ppObjectTypeList,
                                        ULONG *pcObjectTypeListLength,
                                        PACCESS_MASK *ppGrantedAccessList,
                                        ULONG *pcGrantedAccessListLength)
{

    AUTHZ_RESOURCE_MANAGER_HANDLE RM = NULL;    //Used for access check
    AUTHZ_CLIENT_CONTEXT_HANDLE CC = NULL;
    LUID luid = {0xdead,0xbeef};
    AUTHZ_ACCESS_REQUEST AReq;
    AUTHZ_ACCESS_REPLY AReply;
    HRESULT hr = S_OK;    
    DWORD dwFlags;


    AReq.ObjectTypeList = g_DefaultOTL;
    AReq.ObjectTypeListLength = ARRAYSIZE(g_DefaultOTL);
    AReply.GrantedAccessMask = NULL;
    AReply.Error = NULL;

    //Get RM
    if( (RM = GetAUTHZ_RM()) == NULL )
        return S_FALSE;

    //Initialize the client context

    	BOOL bSkipLocalGroup = SkipLocalGroup(pszServerName, pUserSid);

    
    if( !AuthzInitializeContextFromSid(bSkipLocalGroup? AUTHZ_SKIP_TOKEN_GROUPS :0,
                                       pUserSid,
                                       RM,
                                       NULL,
                                       luid,
                                       NULL,
                                       &CC) )
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }



    //Do the Access Check

    AReq.DesiredAccess = MAXIMUM_ALLOWED;
    AReq.PrincipalSelfSid = NULL;
    AReq.OptionalArguments = NULL;

    AReply.ResultListLength = AReq.ObjectTypeListLength;
    AReply.SaclEvaluationResults = NULL;
    if( (AReply.GrantedAccessMask = (PACCESS_MASK)LocalAlloc(LPTR, sizeof(ACCESS_MASK)*AReply.ResultListLength) ) == NULL )
        return E_OUTOFMEMORY;
    if( (AReply.Error = (PDWORD)LocalAlloc(LPTR, sizeof(DWORD)*AReply.ResultListLength)) == NULL )
    {
        LocalFree(AReply.GrantedAccessMask);
        return E_OUTOFMEMORY;
    }
        

    if( !AuthzAccessCheck(0,
                          CC,
                          &AReq,
                          NULL,
                          pSD,
                          NULL,
                          0,
                          &AReply,
                          NULL) )
    {
        LocalFree(AReply.GrantedAccessMask);
        LocalFree(AReply.Error);
        return HRESULT_FROM_WIN32(GetLastError());
    }



    if(CC)
        AuthzFreeContext(CC);
    
        *ppObjectTypeList = AReq.ObjectTypeList;                                  
        *pcObjectTypeListLength = AReq.ObjectTypeListLength;
        *ppGrantedAccessList = AReply.GrantedAccessMask;
        *pcGrantedAccessListLength = AReq.ObjectTypeListLength;

    return S_OK;
}

STDMETHODIMP
CKeySecurityInformation::GetInheritSource(SECURITY_INFORMATION si,
                                          PACL pACL, 
                                          PINHERITED_FROM *ppInheritArray)
{

    HRESULT hr = S_OK;

    if (NULL == m_strKeyName || !pACL || !ppInheritArray)
        return E_UNEXPECTED;

    
    DWORD dwErr = ERROR_SUCCESS;
    PINHERITED_FROM pTempInherit = NULL;
    PINHERITED_FROM pTempInherit2 = NULL;
    LPWSTR pStrTemp = NULL;

    LPCWSTR pszName = GetCompleteName();
    
    pTempInherit = (PINHERITED_FROM)LocalAlloc( LPTR, sizeof(INHERITED_FROM)*pACL->AceCount);
    if(pTempInherit == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto exit_gracefully;
    }

    dwErr = GetInheritanceSource((LPWSTR)pszName,
                                        SE_REGISTRY_KEY,
                                        si,
                                        TRUE,
                                        NULL,
                                        0,
                                        pACL,
                                        NULL,
                                        &KeyMap,
                                        pTempInherit);
    
    hr = HRESULT_FROM_WIN32(dwErr);
    if( FAILED(hr) )
        goto exit_gracefully;

    DWORD nSize;
    UINT i;

    nSize = sizeof(INHERITED_FROM)*pACL->AceCount;
    for(i = 0; i < pACL->AceCount; ++i)
    {
        if(pTempInherit[i].AncestorName)
            nSize += ((wcslen(pTempInherit[i].AncestorName)+1)*sizeof(WCHAR));
    }

    pTempInherit2 = (PINHERITED_FROM)LocalAlloc( LPTR, nSize );
    if(pTempInherit2 == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto exit_gracefully;
    }
    
    pStrTemp = (LPWSTR)(pTempInherit2 + pACL->AceCount); 

    for(i = 0; i < pACL->AceCount; ++i)
    {
        pTempInherit2[i].GenerationGap = pTempInherit[i].GenerationGap;
        if(pTempInherit[i].AncestorName)
        {
            pTempInherit2[i].AncestorName = pStrTemp;
            wcscpy(pStrTemp,pTempInherit[i].AncestorName);
            pStrTemp += (wcslen(pTempInherit[i].AncestorName)+1);
        }
    }
            

exit_gracefully:

    if(SUCCEEDED(hr))
    {
        //FreeInheritedFromArray(pTempInherit, pACL->AceCount,NULL);
        *ppInheritArray = pTempInherit2;
            
    }                        
    if(pTempInherit)
        LocalFree(pTempInherit);

    return hr;
}

///////////////////////////////////////////////////////////
//
// IUnknown methods
//
///////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG)
CSecurityInformation::AddRef()
{
        return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CSecurityInformation::Release()
{
        if (--m_cRef == 0)
        {
                delete this;
                return 0;
        }

        return m_cRef;
}

STDMETHODIMP
CSecurityInformation::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
//        if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_ISecurityInformation))
        if ( IsEqualIID(riid, IID_ISecurityInformation) )

        {
                *ppv = (LPSECURITYINFO)this;
                m_cRef++;
                return S_OK;
        }
        else if(IsEqualIID(riid, IID_IEffectivePermission) )
        {
                *ppv = (LPEFFECTIVEPERMISSION)this;
                m_cRef++;
                return S_OK;

        }
        else if(IsEqualIID(riid, IID_ISecurityObjectTypeInfo) )
        {
                *ppv = (LPSecurityObjectTypeInfo)this;
                m_cRef++;
                return S_OK;

        }
        else
        {
                *ppv = NULL;
                return E_NOINTERFACE;
        }
}

HRESULT CreateSecurityInformation( IN LPCWSTR strKeyName,
                                                                     IN LPCWSTR strParentName,
                                                                     IN LPCWSTR strMachineName,
                                                                     IN LPCWSTR strPageTitle,
                                                                     IN BOOL        bRemote,
                                                                     IN PREDEFINE_KEY PredefinedKey,
                                                                     IN BOOL bReadOnly,
                                   IN HWND hWnd,
                                                                     OUT LPSECURITYINFO *ppSi)
{
    HRESULT hr;

    if( !ppSi )
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);

    
    CKeySecurityInformation *ckey = new CKeySecurityInformation;
    if( NULL == ckey )
        return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);

    if( S_OK != ( hr = ckey->Initialize(    strKeyName,
                                          strParentName,
                                          strMachineName,
                                          strPageTitle,
                                          bRemote,
                                          PredefinedKey,
                                          bReadOnly,
                                          hWnd ) ) )
    {
        delete ckey;
        return hr;
    }
    else
    {
        *ppSi = ckey;
        return S_OK;
    }
}


//Some helper functions
BOOL DisplayMessage( HWND hWnd,
                                         HINSTANCE hInstance,
                                         DWORD dwMessageId,
                                         DWORD dwCaptionId )
{
  WCHAR pszMessage[1025];
  WCHAR pszTitle[1025];
  LPWSTR lpTitle = NULL;
  
  if( !LoadString(hInstance, dwMessageId, pszMessage, 1024 ) )
      return FALSE;

  if( dwCaptionId )
  {
      if( LoadString(hInstance, dwCaptionId, pszTitle, 1024 ) )
         lpTitle = pszTitle;
  }
    

  // Display the string.
    MessageBox( hWnd, (LPCTSTR)pszMessage, (LPCTSTR)lpTitle, MB_OK | MB_ICONINFORMATION |MB_APPLMODAL );
  return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\regedit\regstred.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGSTRED.H
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        05 Mar 1994
*
*  String edit dialog for use by the Registry Editor.
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  05 Mar 1994 TCS Original implementation.
*
*******************************************************************************/

#ifndef _INC_REGSTRED
#define _INC_REGSTRED

INT_PTR
CALLBACK
EditStringValueDlgProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    );

#endif // _INC_REGSTRED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\regedit\regvalue.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGVALUE.H
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        05 Mar 1994
*
*  ValueListWnd ListView routines for the Registry Editor.
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  05 Mar 1994 TCS Original implementation.
*
*******************************************************************************/

#ifndef _INC_REGVALUE
#define _INC_REGVALUE

VOID
PASCAL
RegEdit_OnNewValue(
    HWND hWnd,
    DWORD Type
    );

VOID
PASCAL
RegEdit_OnValueListCommand(
    HWND hWnd,
    int MenuCommand
    );

VOID
PASCAL
RegEdit_OnValueListBeginDrag(
    HWND hWnd,
    NM_LISTVIEW FAR* lpNMListView
    );

BOOL
PASCAL
RegEdit_OnValueListBeginLabelEdit(
    HWND hWnd,
    LV_DISPINFO FAR* lpLVDispInfo
    );

BOOL
PASCAL
RegEdit_OnValueListEndLabelEdit(
    HWND hWnd,
    LV_DISPINFO FAR* lpLVDispInfo
    );

VOID
PASCAL
RegEdit_OnValueListCommand(
    HWND hWnd,
    int MenuCommand
    );

VOID
PASCAL
RegEdit_OnValueListContextMenu(
    HWND hWnd,
    BOOL fByAccelerator
    );

VOID
PASCAL
RegEdit_SetValueListEditMenuItems(
    HMENU hPopupMenu,
    int SelectedListIndex
    );

VOID
PASCAL
RegEdit_OnValueListModify(
    HWND hWnd,
    BOOL fEditBinary
    );

VOID PASCAL RegEdit_EditCurrentValueListItem(HWND hWnd, BOOL fEditBinary);

LONG
PASCAL
RegEdit_OnValueListRefresh(
    HWND hWnd
    );

VOID
PASCAL
ValueList_SetItemDataText(
    HWND hValueListWnd,
    int ListIndex,
    PBYTE pValueData,
    DWORD cbValueData,
    DWORD Type
    );

DWORD PASCAL ValueList_SwitchEndian(DWORD dwSrc);
BOOL PASCAL ValueList_MultiStringToString(LPEDITVALUEPARAM LPEditValueParam);
VOID PASCAL ValueList_StringToMultiString(LPEDITVALUEPARAM LPEditValueParam);
VOID PASCAL ValueList_RemoveEmptyStrings(HWND hWnd, LPEDITVALUEPARAM LPEditValueParam);
VOID RegEdit_DisplayBinaryData(HWND hWnd);

#endif // _INC_REGVALUE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\regedit\regstred.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGSTRED.C
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        05 Mar 1994
*
*  String edit dialog for use by the Registry Editor.
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  05 Mar 1994 TCS Original implementation.
*
*******************************************************************************/

#include "pch.h"
#include "regresid.h"
#include "reghelp.h"

const DWORD s_EditStringValueHelpIDs[] = {
    IDC_VALUEDATA, IDH_REGEDIT_VALUEDATA,
    IDC_VALUENAME, IDH_REGEDIT_VALUENAME,
    0, 0
};

BOOL
PASCAL
EditStringValue_OnInitDialog(
    HWND hWnd,
    HWND hFocusWnd,
    LPARAM lParam
    );

/*******************************************************************************
*
*  EditStringValueDlgProc
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

INT_PTR
CALLBACK
EditStringValueDlgProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    
    LPEDITVALUEPARAM lpEditValueParam;
    
    
    switch (Message) 
    {
        HANDLE_MSG(hWnd, WM_INITDIALOG, EditStringValue_OnInitDialog);
        
    case WM_COMMAND:
        {
            DWORD dwCommand = GET_WM_COMMAND_ID(wParam, lParam);
            switch (dwCommand) 
            {
            case IDOK:
                {
                    UINT ccValueData;
                    UINT cbValueData;
                    PBYTE pbValueData = NULL;
                    
                    lpEditValueParam = (LPEDITVALUEPARAM) GetWindowLongPtr(hWnd, DWLP_USER);
                    
                    // this maybe a multi-string, if so the sizeof(TCHAR) is added to 
                    // allow for the multi-string to be terminated also.
                    ccValueData = (UINT) SendDlgItemMessage(hWnd, IDC_VALUEDATA,
                        WM_GETTEXTLENGTH, 0, 0) + 2;
                    
                    cbValueData = ccValueData * sizeof(TCHAR);
                    
                    if (cbValueData > lpEditValueParam->cbValueData)
                    {
                        // need a bigger buffer
                        PBYTE pbValueData = 
                            LocalReAlloc(lpEditValueParam->pValueData, cbValueData, LMEM_MOVEABLE);

                        if (!pbValueData)
                        { 
                            InternalMessageBox(g_hInstance, hWnd, MAKEINTRESOURCE(IDS_EDITVALNOMEMORY),
                                MAKEINTRESOURCE(IDS_EDITVALERRORTITLE), MB_ICONERROR | MB_OK, NULL);
                            dwCommand = IDCANCEL;
                        }
                        else
                        {
                            lpEditValueParam->pValueData = pbValueData;
                        }
                    }
                    
                    // sizeof(TCHAR) to remove multi-string null char from count
                    lpEditValueParam->cbValueData = cbValueData - sizeof(TCHAR);
                    
                    GetDlgItemText(hWnd, IDC_VALUEDATA, (PTSTR)lpEditValueParam->
                        pValueData, lpEditValueParam->cbValueData - sizeof(TCHAR));

                    lpEditValueParam->pValueData[lpEditValueParam->cbValueData - sizeof(TCHAR)] 
                                = TEXT('\0');
                }
                //  FALL THROUGH
                
            case IDCANCEL:
                EndDialog(hWnd, dwCommand);
                break;
                
            }
        }
        break;
        
    case WM_HELP:
        WinHelp(((LPHELPINFO) lParam)-> hItemHandle, g_pHelpFileName,
            HELP_WM_HELP, (ULONG_PTR) s_EditStringValueHelpIDs);
        break;
        
    case WM_CONTEXTMENU:
        WinHelp((HWND) wParam, g_pHelpFileName, HELP_CONTEXTMENU,
            (ULONG_PTR) s_EditStringValueHelpIDs);
        break;
        
    default:
        return FALSE;
        
    }
    
    return TRUE;
    
}

/*******************************************************************************
*
*  EditStringValue_OnInitDialog
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of EditStringValue window.
*     hFocusWnd,
*     lParam,
*
*******************************************************************************/

BOOL
PASCAL
EditStringValue_OnInitDialog(
    HWND hWnd,
    HWND hFocusWnd,
    LPARAM lParam
    )
{
    LPEDITVALUEPARAM lpEditValueParam;

    //  Change maximum number of characters of the edit control, to its
    //  maximum limit (from 3000 characters to 4G characters).
    SendDlgItemMessage( hWnd, IDC_VALUEDATA, EM_LIMITTEXT, 0, 0L );

    SetWindowLongPtr(hWnd, DWLP_USER, lParam);
    lpEditValueParam = (LPEDITVALUEPARAM) lParam;

    SetDlgItemText(hWnd, IDC_VALUENAME, lpEditValueParam-> pValueName);
    SetDlgItemText(hWnd, IDC_VALUEDATA, (PTSTR)lpEditValueParam-> pValueData);

    return TRUE;

    UNREFERENCED_PARAMETER(hFocusWnd);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\regedit\regsys.cxx ===
#include "regdata.hxx"
#include "regsys.hxx"

#include <stdio.h>

extern "C" HINSTANCE g_hInstance;

//    #define FORMAT_MESSAGE_FROM_HMODULE    0x00000800



BOOLEAN
REGEDIT_BASE_SYSTEM::QueryResourceString(
    OUT PWSTRING    ResourceString,
    IN  MSGID       MsgId,
    IN  PCSTR       Format ...
    )
/*++

Routine Description:

    This routine computes the resource string identified by the resource
    identifier 'MsgId'.  In addition to the 'printf' format strings
    supported, 'QueryResourceString' supports :

        1. '%W' - Expects a pointer to a WSTRING.

Arguments:

    ResourceString  - Returns the resource string.
    MsgId           - Supplies the message id of the resource string.
    Format          - Supplies a 'printf' style format descriptor for the
                        arguments to the resource string.
    ...             - Supplies the arguments to the resource string.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    va_list ap;
    BOOLEAN r;

    va_start(ap, Format);
    r = QueryResourceStringV(ResourceString, MsgId, Format, ap);
    va_end(ap);

    return r;
}


BOOLEAN
REGEDIT_BASE_SYSTEM::QueryResourceStringV(
    OUT PWSTRING    ResourceString,
    IN  MSGID       MsgId,
    IN  PCSTR       Format,
    IN  va_list     VarPointer
    )
/*++

Routine Description:

    This is a 'varargs' implementation of 'QueryResourceString'.

Arguments:

    ResourceString  - Returns the resource string.
    MsgId           - Supplies the message id of the resource string.
    Format          - Supplies a 'printf' style format descriptor for the
                        arguments to the resource string.
    VarPointer      - Supplies a varargs pointer to the arguments of the
                        resource string.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    WCHAR           display_buffer[2048];
    WCHAR           UnformattedMessage[1024];
    DWORD           Status;

    if( LoadStringW(g_hInstance,
                    MsgId,
                    UnformattedMessage,
                    1024 ) == 0 ) {
        Status = GetLastError();
        DebugPrint( "LoadStringW() failed" );
        DebugPrintTrace(("LoadStringW() failed. Error = %d \n", Status ));
        return FALSE;
    }

    if( FormatMessageW(FORMAT_MESSAGE_FROM_STRING,
                       (LPVOID)UnformattedMessage,
                       0,
                       0L,
                       display_buffer,
                       sizeof( display_buffer ) / sizeof ( WCHAR ),
                       &VarPointer ) == 0 ) {
         Status = GetLastError();
         DebugPrint( "FormatMessageW() failed" );
         DebugPrintTrace(("FormatMessageW() failed. Error = %d \n", Status ));
         return FALSE;
    }

    return ResourceString->Initialize(display_buffer);
}



PWSTRING
REGEDIT_BASE_SYSTEM::QueryString(
    IN  MSGID       MsgId,
    IN  PCSTR       Format ...
    )
/*++

Routine Description:

    This routine computes the resource string identified by the resource
    identifier 'MsgId'.  In addition to the 'printf' format strings
    supported, 'QueryResourceString' supports :

        1. '%W' - Expects a pointer to a WSTRING.

Arguments:

    MsgId           - Supplies the message id of the resource string.
    Format          - Supplies a 'printf' style format descriptor for the
                        arguments to the resource string.
    ...             - Supplies the arguments to the resource string.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    va_list ap;
    BOOLEAN r;
    PWSTRING    String;

    va_start(ap, Format);
    String = NEW( DSTRING );
    if (String)
    {
        r = QueryResourceStringV(String, MsgId, Format, ap);
        va_end(ap);
        if( !r )
        {
            DELETE( String );
            String = NULL;
        }
    }
    return String;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\regedit\regvalue.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGVALUE.C
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        05 Mar 1994
*
*  ValueListWnd ListView routines for the Registry Editor.
*
*******************************************************************************/

#include "pch.h"
#include "regedit.h"
#include "regvalue.h"
#include "regstred.h"
#include "regbined.h"
#include "regdwded.h"
#include "regresid.h"


extern void DisplayResourceData(HWND hWnd, DWORD dwType, LPEDITVALUEPARAM lpEditValueParam);
extern void DisplayBinaryData(HWND hWnd, LPEDITVALUEPARAM lpEditValueParam, DWORD dwValueType);

#define MAX_VALUENAME_TEMPLATE_ID       100

//  Maximum number of bytes that will be shown in the ListView.  If the user
//  wants to see more, then they can use the edit dialogs.
#define SIZE_DATATEXT                   196

//  Allow room in a SIZE_DATATEXT buffer for one null and possibly
//  the ellipsis.
#define MAXIMUM_STRINGDATATEXT          192
const TCHAR s_StringDataFormatSpec[] = TEXT("%.192s");

//  Allow room for multiple three character pairs, one null, and possibly the
//  ellipsis.
#define MAXIMUM_BINARYDATABYTES         64
const TCHAR s_BinaryDataFormatSpec[] = TEXT("%02x ");

const TCHAR s_Ellipsis[] = TEXT("...");

const LPCTSTR s_TypeNames[] = { TEXT("REG_NONE"),
                                TEXT("REG_SZ"),
                                TEXT("REG_EXPAND_SZ"),
                                TEXT("REG_BINARY"),
                                TEXT("REG_DWORD"),
                                TEXT("REG_DWORD_BIG_ENDIAN"),
                                TEXT("REG_LINK"),
                                TEXT("REG_MULTI_SZ"),
                                TEXT("REG_RESOURCE_LIST"),
                                TEXT("REG_FULL_RESOURCE_DESCRIPTOR"),
                                TEXT("REG_RESOURCE_REQUIREMENTS_LIST"),
                                TEXT("REG_QWORD")
                              };

#define MAX_KNOWN_TYPE REG_QWORD

VOID
PASCAL
RegEdit_OnValueListDelete(
    HWND hWnd
    );

VOID
PASCAL
RegEdit_OnValueListRename(
    HWND hWnd
    );

VOID
PASCAL
ValueList_EditLabel(
    HWND hValueListWnd,
    int ListIndex
    );

/*******************************************************************************
*
*  RegEdit_OnNewValue
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnNewValue(
    HWND hWnd,
    DWORD Type
    )
{

    UINT NewValueNameID;
    TCHAR ValueName[MAXVALUENAME_LENGTH];
    DWORD Ignore;
    DWORD cbValueData;
    LV_ITEM LVItem;
    int ListIndex;
    UINT ErrorStringID;
    BYTE abValueDataBuffer[4]; // DWORD is largest init. value

    if (g_RegEditData.hCurrentSelectionKey == NULL)
        return;

    //
    //  Loop through the registry trying to find a valid temporary name until
    //  the user renames the key.
    //

    NewValueNameID = 1;

    while (NewValueNameID < MAX_VALUENAME_TEMPLATE_ID) {

        wsprintf(ValueName, g_RegEditData.pNewValueTemplate, NewValueNameID);

        if (RegEdit_QueryValueEx(g_RegEditData.hCurrentSelectionKey, ValueName,
            NULL, &Ignore, NULL, &Ignore) != ERROR_SUCCESS) {

            //
            //  For strings, we need to have at least one byte to represent the
            //  null.  For binary data, it's okay to have zero-length data.
            //

            switch (Type) {

                case REG_SZ:
                case REG_EXPAND_SZ:
                    ((PTSTR) abValueDataBuffer)[0] = 0;
                    cbValueData = sizeof(TCHAR);
                    break;

                case REG_DWORD:
                    ((LPDWORD) abValueDataBuffer)[0] = 0;
                    cbValueData = sizeof(DWORD);
                    break;

                case REG_BINARY:
                    cbValueData = 0;
                    break;

                case REG_MULTI_SZ:
                    ((PTSTR) abValueDataBuffer)[0] = 0;
                    cbValueData = sizeof(TCHAR);
                    break;
            }

            if (RegSetValueEx(g_RegEditData.hCurrentSelectionKey, ValueName, 0,
                Type, abValueDataBuffer, cbValueData) == ERROR_SUCCESS)
                break;

            else {

                ErrorStringID = IDS_NEWVALUECANNOTCREATE;
                goto error_ShowDialog;

            }

        }

        NewValueNameID++;

    }

    if (NewValueNameID == MAX_VALUENAME_TEMPLATE_ID) {

        ErrorStringID = IDS_NEWVALUENOUNIQUE;
        goto error_ShowDialog;

    }

    LVItem.mask = LVIF_TEXT | LVIF_IMAGE;
    LVItem.pszText = ValueName;
    LVItem.iItem = ListView_GetItemCount(g_RegEditData.hValueListWnd);
    LVItem.iSubItem = 0;
    LVItem.iImage = IsRegStringType(Type) ? IMAGEINDEX(IDI_STRING) :
        IMAGEINDEX(IDI_BINARY);

    if ((ListIndex = ListView_InsertItem(g_RegEditData.hValueListWnd,
        &LVItem)) != -1) {

        ValueList_SetItemDataText(g_RegEditData.hValueListWnd, ListIndex,
            abValueDataBuffer, cbValueData, Type);

        ValueList_EditLabel(g_RegEditData.hValueListWnd, ListIndex);

    }

    return;

error_ShowDialog:
    InternalMessageBox(g_hInstance, hWnd, MAKEINTRESOURCE(ErrorStringID),
        MAKEINTRESOURCE(IDS_NEWVALUEERRORTITLE), MB_ICONERROR | MB_OK);

}

/*******************************************************************************
*
*  RegEdit_OnValueListBeginLabelEdit
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*     lpLVDispInfo,
*
*******************************************************************************/

BOOL
PASCAL
RegEdit_OnValueListBeginLabelEdit(
    HWND hWnd,
    LV_DISPINFO FAR* lpLVDispInfo
    )
{

    //
    //  B#7933:  We don't want the user to hurt themselves by making it too easy
    //  to rename keys and values.  Only allow renames via the menus.
    //

    //
    //  We don't get any information on the source of this editing action, so
    //  we must maintain a flag that tells us whether or not this is "good".
    //

    if (!g_RegEditData.fAllowLabelEdits)
        return TRUE;

    //
    //  All other labels are fair game.  We need to disable our keyboard
    //  accelerators so that the edit control can "see" them.
    //

    g_fDisableAccelerators = TRUE;

    return FALSE;

}

/*******************************************************************************
*
*  RegEdit_OnValueListEndLabelEdit
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL
PASCAL
RegEdit_OnValueListEndLabelEdit(
    HWND hWnd,
    LV_DISPINFO FAR* lpLVDispInfo
    )
{
    BOOL fSuccess = TRUE;
    HWND hValueListWnd;
    DWORD cbValueData;
    DWORD Ignore;
    DWORD Type;
    TCHAR ValueName[MAXVALUENAME_LENGTH];
    UINT ErrorStringID;
    PBYTE pbValueData;

    //
    //  We can reenable our keyboard accelerators now that the edit control no
    //  longer needs to "see" them.
    //

    g_fDisableAccelerators = FALSE;

    hValueListWnd = g_RegEditData.hValueListWnd;

    //
    //  Check to see if the user cancelled the edit.  If so, we don't care so
    //  just return.
    //

    if (lpLVDispInfo-> item.pszText != NULL)
    {

        ListView_GetItemText(hValueListWnd, lpLVDispInfo-> item.iItem, 0,
            ValueName, sizeof(ValueName)/sizeof(TCHAR));

        //  Check to see if the new value name is empty
        if (lpLVDispInfo->item.pszText[0] == 0) 
        {
            ErrorStringID = IDS_RENAMEVALEMPTY;
            fSuccess = FALSE;
        }
        //  Check to see if the new name already exists
        else if (RegEdit_QueryValueEx(g_RegEditData.hCurrentSelectionKey, lpLVDispInfo->
            item.pszText, NULL, &Ignore, NULL, &Ignore) != ERROR_FILE_NOT_FOUND) 
        {
            ErrorStringID = IDS_RENAMEVALEXISTS;
            fSuccess = FALSE;
        }

        // Set new name
        if (fSuccess)
        {
            fSuccess = FALSE;

            // Query for data size
            RegEdit_QueryValueEx(g_RegEditData.hCurrentSelectionKey, ValueName,
                NULL, &Type, NULL, &cbValueData);
    
            // Allocate storage space
            pbValueData = LocalAlloc(LPTR, cbValueData+ExtraAllocLen(Type));
            if (pbValueData)
            {
                ErrorStringID = IDS_RENAMEVALOTHERERROR;

                if (RegEdit_QueryValueEx(g_RegEditData.hCurrentSelectionKey, ValueName, NULL,
                    &Type, pbValueData, &cbValueData) == ERROR_SUCCESS) 
                {

                    if (RegSetValueEx(g_RegEditData.hCurrentSelectionKey, 
                        lpLVDispInfo->item.pszText, 0, Type, pbValueData, cbValueData) ==
                        ERROR_SUCCESS) 
                    {
                        if (RegDeleteValue(g_RegEditData.hCurrentSelectionKey, ValueName) ==
                            ERROR_SUCCESS) 
                        {
                            fSuccess = TRUE;
                        }
                    }
                }
                LocalFree(pbValueData);
            }
            else
            {
                ErrorStringID = IDS_EDITVALNOMEMORY;
            }
        }

        if (!fSuccess)
        {
            InternalMessageBox(g_hInstance, hWnd, MAKEINTRESOURCE(ErrorStringID),
                MAKEINTRESOURCE(IDS_RENAMEVALERRORTITLE), MB_ICONERROR | MB_OK,
                (LPTSTR) ValueName);
        }
    }

    return fSuccess;
}

/*******************************************************************************
*
*  RegEdit_OnValueListCommand
*
*  DESCRIPTION:
*     Handles the selection of a menu item by the user intended for the
*     ValueList child window.
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*     MenuCommand, identifier of menu command.
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnValueListCommand(
    HWND hWnd,
    int MenuCommand
    )
{

    //
    //  Check to see if this menu command should be handled by the main window's
    //  command handler.
    //

    if (MenuCommand >= ID_FIRSTMAINMENUITEM && MenuCommand <=
        ID_LASTMAINMENUITEM)
        RegEdit_OnCommand(hWnd, MenuCommand, NULL, 0);

    else {

        switch (MenuCommand) {

            case ID_CONTEXTMENU:
                RegEdit_OnValueListContextMenu(hWnd, TRUE);
                break;

            case ID_MODIFY:
                RegEdit_OnValueListModify(hWnd, FALSE);
                break;

            case ID_DELETE:
                RegEdit_OnValueListDelete(hWnd);
                break;

            case ID_RENAME:
                RegEdit_OnValueListRename(hWnd);
                break;

            case ID_MODIFYBINARY:
                RegEdit_OnValueListModify(hWnd, TRUE);
                break;

        }

    }

}

/*******************************************************************************
*
*  RegEdit_OnValueListContextMenu
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnValueListContextMenu(
    HWND hWnd,
    BOOL fByAccelerator
    )
{

    HWND hValueListWnd;
    DWORD MessagePos;
    POINT MessagePoint;
    LV_HITTESTINFO LVHitTestInfo;
    int ListIndex;
    UINT MenuID;
    HMENU hContextMenu;
    HMENU hContextPopupMenu;
    int MenuCommand;

    hValueListWnd = g_RegEditData.hValueListWnd;

    //
    //  If fByAcclerator is TRUE, then the user hit Shift-F10 to bring up the
    //  context menu.  Following the Cabinet's convention, this menu is
    //  placed at (0,0) of the ListView client area.
    //

    if (fByAccelerator) {

        MessagePoint.x = 0;
        MessagePoint.y = 0;

        ClientToScreen(hValueListWnd, &MessagePoint);

        ListIndex = ListView_GetNextItem(hValueListWnd, -1, LVNI_SELECTED);

    }

    else {

        MessagePos = GetMessagePos();
        MessagePoint.x = GET_X_LPARAM(MessagePos);
        MessagePoint.y = GET_Y_LPARAM(MessagePos);

        LVHitTestInfo.pt = MessagePoint;
        ScreenToClient(hValueListWnd, &LVHitTestInfo.pt);
        ListIndex = ListView_HitTest(hValueListWnd, &LVHitTestInfo);

    }

    MenuID = (ListIndex != -1) ? IDM_VALUE_CONTEXT :
        IDM_VALUELIST_NOITEM_CONTEXT;

    if ((hContextMenu = LoadMenu(g_hInstance, MAKEINTRESOURCE(MenuID))) == NULL)
        return;

    hContextPopupMenu = GetSubMenu(hContextMenu, 0);

    if (ListIndex != -1) {

        RegEdit_SetValueListEditMenuItems(hContextMenu, ListIndex);

        SetMenuDefaultItem(hContextPopupMenu, ID_MODIFY, MF_BYCOMMAND);

    }

        //  FEATURE:  Fix constant
    else
        RegEdit_SetNewObjectEditMenuItems(GetSubMenu(hContextPopupMenu, 0));

    MenuCommand = TrackPopupMenuEx(hContextPopupMenu, TPM_RETURNCMD |
        TPM_RIGHTBUTTON | TPM_LEFTALIGN | TPM_TOPALIGN, MessagePoint.x,
        MessagePoint.y, hWnd, NULL);

    DestroyMenu(hContextMenu);

    RegEdit_OnValueListCommand(hWnd, MenuCommand);

}

/*******************************************************************************
*
*  RegEdit_SetValueListEditMenuItems
*
*  DESCRIPTION:
*     Shared routine between the main menu and the context menu to setup the
*     edit menu items.
*
*  PARAMETERS:
*     hPopupMenu, handle of popup menu to modify.
*
*******************************************************************************/

VOID
PASCAL
RegEdit_SetValueListEditMenuItems(
    HMENU hPopupMenu,
    int SelectedListIndex
    )
{

    UINT SelectedCount;
    UINT EnableFlags;

    SelectedCount = ListView_GetSelectedCount(g_RegEditData.hValueListWnd);

    //
    //  The edit option is only enabled when a single item is selected.  Note
    //  that this item is not in the main menu, but this should work fine.
    //

    if (SelectedCount == 1)
        EnableFlags = MF_ENABLED | MF_BYCOMMAND;
    else
        EnableFlags = MF_GRAYED | MF_BYCOMMAND;

    EnableMenuItem(hPopupMenu, ID_MODIFY, EnableFlags);

    //
    //  The rename option is also only enabled when a single item is selected
    //  and that item cannot be the default item.  EnableFlags is already
    //  disabled if the SelectedCount is not one from above.
    //

    if (SelectedListIndex == 0)
        EnableFlags = MF_GRAYED | MF_BYCOMMAND;

    EnableMenuItem(hPopupMenu, ID_RENAME, EnableFlags);

    //
    //  The delete option is only enabled when multiple items are selected.
    //

    if (SelectedCount > 0)
        EnableFlags = MF_ENABLED | MF_BYCOMMAND;
    else
        EnableFlags = MF_GRAYED | MF_BYCOMMAND;

    EnableMenuItem(hPopupMenu, ID_DELETE, EnableFlags);

}

/*******************************************************************************
*
*  RegEdit_OnValueListModify
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnValueListModify(HWND hWnd, BOOL fEditBinary)
{
    //  Verify that we only have one item selected
    //  Don't beep for a double-clicking on the background.
    UINT SelectedCount = ListView_GetSelectedCount(g_RegEditData.hValueListWnd);

    if (SelectedCount > 0)
    {
        if (SelectedCount != 1)
        {
            MessageBeep(0);
        }
        else
        {
            RegEdit_EditCurrentValueListItem(hWnd, fEditBinary);   
        }
    }
}

VOID PASCAL RegEdit_EditCurrentValueListItem(HWND hWnd, BOOL fEditBinary)
{
    DWORD Type;
    UINT ErrorStringID;
    BOOL fError = FALSE;
    EDITVALUEPARAM EditValueParam;
    TCHAR ValueName[MAXVALUENAME_LENGTH];
    int ListIndex = ListView_GetNextItem(g_RegEditData.hValueListWnd, -1, LVNI_SELECTED);
    LONG err;

    // VALUE NAME
    ListView_GetItemText(g_RegEditData.hValueListWnd, ListIndex, 0, ValueName, ARRAYSIZE(ValueName));
    //  This is the "(Default)" value. It either does not exist in the registry because
    //  it's value is not set, or it exists in the registry as '\0' when its value is set
    if (ListIndex == 0)
    {
        ValueName[0] = TEXT('\0');
    }
    EditValueParam.pValueName = ValueName;
    
    // VALUE DATA
    // Query for size and type
    // Note that for the DefaultValue, the value may not actually exist yet.  In that case we
    // will get back ERROR_FILE_NOT_FOUND as the error code.
    err = RegEdit_QueryValueEx(g_RegEditData.hCurrentSelectionKey, ValueName, NULL, &Type, NULL, &EditValueParam.cbValueData);
    if (err == ERROR_SUCCESS || (err == ERROR_FILE_NOT_FOUND && ValueName[0] == TEXT('\0')))
    {
        // Allocate storage space
        EditValueParam.pValueData =  LocalAlloc(LPTR, EditValueParam.cbValueData+ExtraAllocLen(Type));
        if (EditValueParam.pValueData)
        {
            UINT TemplateID = IDD_EDITBINARYVALUE;
            DLGPROC lpDlgProc = EditBinaryValueDlgProc;
            BOOL fResourceType = FALSE;

            // Initialize with registry value
            err = RegEdit_QueryValueEx(g_RegEditData.hCurrentSelectionKey, ValueName, NULL, &Type, EditValueParam.pValueData, &EditValueParam.cbValueData);
            
            // Allow the special behavior for a key's Default Value.
            if (err == ERROR_FILE_NOT_FOUND && ValueName[0] == TEXT('\0')) {
                Type = REG_SZ;
                *((TCHAR*)EditValueParam.pValueData) = TEXT('\0');
                err = ERROR_SUCCESS;
            }

            if (err == ERROR_SUCCESS)
            {
                if (!fEditBinary)
                {
                    switch (Type) 
                    {
                    case REG_SZ:
                    case REG_EXPAND_SZ:
                        TemplateID = IDD_EDITSTRINGVALUE;
                        lpDlgProc = EditStringValueDlgProc;
                        break;

                    case REG_MULTI_SZ: 
                        if(ValueList_MultiStringToString(&EditValueParam))
                        {
                            TemplateID = IDD_EDITMULTISZVALUE;
                            lpDlgProc = EditStringValueDlgProc;
                        }
                        break;

                    case REG_RESOURCE_LIST:
                    case REG_FULL_RESOURCE_DESCRIPTOR:
                    case REG_RESOURCE_REQUIREMENTS_LIST:
                        fResourceType = TRUE;
                        break;

                    case REG_DWORD_BIG_ENDIAN:
                        if (EditValueParam.cbValueData == sizeof(DWORD)) 
                        {
                            *((DWORD*)EditValueParam.pValueData) = ValueList_SwitchEndian(*((DWORD*)EditValueParam.pValueData));
                            TemplateID = IDD_EDITDWORDVALUE;
                            lpDlgProc = EditDwordValueDlgProc;
                        }
                        break;

                    case REG_DWORD:
                        if (EditValueParam.cbValueData == sizeof(DWORD)) 
                        {
                            TemplateID = IDD_EDITDWORDVALUE;
                            lpDlgProc = EditDwordValueDlgProc;

                        }
                        break;
                    }
                }

                if (fResourceType)
                {
                    // only display, no editing
                    DisplayResourceData(hWnd, Type, &EditValueParam);
                }
                else if (DialogBoxParam(g_hInstance, MAKEINTRESOURCE(TemplateID), 
                    hWnd, lpDlgProc, (LPARAM) &EditValueParam) == IDOK)
                {
                    if ((Type == REG_MULTI_SZ) && (!fEditBinary))
                    {
                        ValueList_StringToMultiString(&EditValueParam);
                        ValueList_RemoveEmptyStrings(hWnd, &EditValueParam);
                    }

                    if ((Type == REG_DWORD_BIG_ENDIAN) && (!fEditBinary) && EditValueParam.cbValueData == sizeof(DWORD)) 
                    {
                        *((DWORD*)EditValueParam.pValueData) = ValueList_SwitchEndian(*((DWORD*)EditValueParam.pValueData));
                    }

                    // set the registry value
                    if (RegSetValueEx(g_RegEditData.hCurrentSelectionKey, ValueName, 0,
                        Type, EditValueParam.pValueData, EditValueParam.cbValueData) !=
                        ERROR_SUCCESS) 
                    {
                        ErrorStringID = IDS_EDITVALCANNOTWRITE;
                        fError = TRUE;
                    }

                    // set the display value
                    ValueList_SetItemDataText(g_RegEditData.hValueListWnd, ListIndex,
                        EditValueParam.pValueData, EditValueParam.cbValueData, Type);
                }
            }
            else
            {
                ErrorStringID = IDS_EDITVALCANNOTREAD;
                fError = TRUE;
            }

            LocalFree(EditValueParam.pValueData);
        }
        else
        {
            ErrorStringID = IDS_EDITVALNOMEMORY;
            fError = TRUE;
        }
    }
    else
    {
        ErrorStringID = IDS_EDITVALCANNOTREAD;
        fError = TRUE;
    }
 
    if (fError)
    {
        InternalMessageBox(g_hInstance, hWnd, MAKEINTRESOURCE(ErrorStringID),
            MAKEINTRESOURCE(IDS_EDITVALERRORTITLE), MB_ICONERROR | MB_OK,
            (LPTSTR) ValueName);
    }
}

/*******************************************************************************
*
*  RegEdit_OnValueListDelete
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnValueListDelete(
    HWND hWnd
    )
{

    HWND hValueListWnd;
    UINT ConfirmTextStringID;
    BOOL fErrorDeleting;
    int ListStartIndex;
    int ListIndex;
    TCHAR ValueName[MAXVALUENAME_LENGTH];

    hValueListWnd = g_RegEditData.hValueListWnd;

    ConfirmTextStringID =  (ListView_GetSelectedCount(hValueListWnd) == 1) ?
        IDS_CONFIRMDELVALTEXT : IDS_CONFIRMDELVALMULTITEXT;

    if (InternalMessageBox(g_hInstance, hWnd, MAKEINTRESOURCE(ConfirmTextStringID),
        MAKEINTRESOURCE(IDS_CONFIRMDELVALTITLE),  MB_ICONWARNING | MB_YESNO) !=
        IDYES)
        return;

    SetWindowRedraw(hValueListWnd, FALSE);

    fErrorDeleting = FALSE;
    ListStartIndex = -1;

    while ((ListIndex = ListView_GetNextItem(hValueListWnd, ListStartIndex,
        LVNI_SELECTED)) != -1) {

        if (ListIndex != 0) {

            ListView_GetItemText(hValueListWnd, ListIndex, 0, ValueName,
                sizeof(ValueName)/sizeof(TCHAR));

        }

        else
            ValueName[0] = 0;

        if (RegDeleteValue(g_RegEditData.hCurrentSelectionKey, ValueName) ==
            ERROR_SUCCESS) {

            if (ListIndex != 0)
                ListView_DeleteItem(hValueListWnd, ListIndex);

            else {

                ValueList_SetItemDataText(hValueListWnd, 0, NULL, 0, REG_SZ);

                ListStartIndex = 0;

            }

        }

        else {

            fErrorDeleting = TRUE;

            ListStartIndex = ListIndex;

        }

    }

    SetWindowRedraw(hValueListWnd, TRUE);

    if (fErrorDeleting)
        InternalMessageBox(g_hInstance, hWnd,
            MAKEINTRESOURCE(IDS_DELETEVALDELETEFAILED),
            MAKEINTRESOURCE(IDS_DELETEVALERRORTITLE), MB_ICONERROR | MB_OK);

}

/*******************************************************************************
*
*  RegEdit_OnValueListRename
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnValueListRename(
    HWND hWnd
    )
{

    HWND hValueListWnd;
    int ListIndex;

    hValueListWnd = g_RegEditData.hValueListWnd;

    if (ListView_GetSelectedCount(hValueListWnd) == 1 && (ListIndex =
        ListView_GetNextItem(hValueListWnd, -1, LVNI_SELECTED)) != 0)
        ValueList_EditLabel(g_RegEditData.hValueListWnd, ListIndex);

}

/*******************************************************************************
*
*  RegEdit_OnValueListRefresh
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

LONG
PASCAL
RegEdit_OnValueListRefresh(HWND hWnd)
{
    UINT ErrorStringID;
    BOOL fError = FALSE;
    BOOL fInsertedDefaultValue;
    HWND hValueListWnd = g_RegEditData.hValueListWnd;
    LONG result = ERROR_SUCCESS;

    RegEdit_SetWaitCursor(TRUE);
    SetWindowRedraw(hValueListWnd, FALSE);

    ListView_DeleteAllItems(hValueListWnd);

    if (g_RegEditData.hCurrentSelectionKey != NULL) 
    {
        LV_ITEM LVItem;
        LONG PrevStyle;
        DWORD EnumIndex;
        TCHAR achValueName[MAXVALUENAME_LENGTH];

        LVItem.mask = LVIF_TEXT | LVIF_IMAGE;
        LVItem.pszText = achValueName;
        LVItem.iSubItem = 0;

        PrevStyle = SetWindowLong(hValueListWnd, GWL_STYLE,
            GetWindowLong(hValueListWnd, GWL_STYLE) | LVS_SORTASCENDING);

        EnumIndex = 0;
        fInsertedDefaultValue = FALSE;

        while (TRUE) 
        {
            DWORD Type;
            DWORD cbValueData = 0;
            int ListIndex;
            PBYTE pbValueData;
            DWORD cchValueName = ARRAYSIZE(achValueName);

            // VALUE DATA
            // Query for data size
            result = RegEnumValue(g_RegEditData.hCurrentSelectionKey, EnumIndex++,
                                  achValueName, &cchValueName, NULL, &Type, NULL, 
                                  &cbValueData);
            if (result != ERROR_SUCCESS)
            {
                break;
            }

            // allocate memory for data
            pbValueData =  LocalAlloc(LPTR, cbValueData+ExtraAllocLen(Type));
            if (pbValueData)
            {
                if (RegEdit_QueryValueEx(g_RegEditData.hCurrentSelectionKey, achValueName,
                    NULL, &Type, pbValueData, &cbValueData) != ERROR_SUCCESS)
                {   
                    ErrorStringID = IDS_REFRESHCANNOTREAD;
                    fError = TRUE;
                }
                else
                {
                    if (cchValueName == 0)
                    {
                        fInsertedDefaultValue = TRUE;
                    }

                    LVItem.iImage = IsRegStringType(Type) ? IMAGEINDEX(IDI_STRING) :
                        IMAGEINDEX(IDI_BINARY);

                    ListIndex = ListView_InsertItem(hValueListWnd, &LVItem);

                    ValueList_SetItemDataText(hValueListWnd, ListIndex,
                        pbValueData, cbValueData, Type);
                }
                LocalFree(pbValueData);
            }
            else
            {
                fError = TRUE;
                ErrorStringID = IDS_REFRESHNOMEMORY;
            }

            if (fError)
            {
                InternalMessageBox(g_hInstance, hWnd, MAKEINTRESOURCE(ErrorStringID),
                MAKEINTRESOURCE(IDS_REFRESHERRORTITLE), MB_ICONERROR | MB_OK,
                (LPTSTR) achValueName);
                fError = FALSE;
            }

        }

        SetWindowLong(hValueListWnd, GWL_STYLE, PrevStyle);

        LVItem.iItem = 0;
        LVItem.pszText = g_RegEditData.pDefaultValue;
        LVItem.iImage = IMAGEINDEX(IDI_STRING);

        if (fInsertedDefaultValue) 
        {
            LVItem.mask = LVIF_TEXT;
            ListView_SetItem(hValueListWnd, &LVItem);
        }
        else 
        {
            ListView_InsertItem(hValueListWnd, &LVItem);
            ValueList_SetItemDataText(hValueListWnd, 0, NULL, 0, REG_SZ);
        }
        ListView_SetItemState(hValueListWnd, 0, LVIS_FOCUSED, LVIS_FOCUSED);
    }

    SetWindowRedraw(hValueListWnd, TRUE);
    RegEdit_SetWaitCursor(FALSE);

    return result;
}


/*******************************************************************************
*
*  ValueList_SetItemDataText
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hValueListWnd, handle of ValueList window.
*     ListIndex, index into ValueList window.
*     pValueData, pointer to buffer containing data.
*     cbValueData, size of the above buffer.
*     Type, type of data this buffer contains (REG_* definition).
*
*******************************************************************************/

VOID
PASCAL
ValueList_SetItemDataText(
    HWND hValueListWnd,
    int ListIndex,
    PBYTE pValueData,
    DWORD cbValueData,
    DWORD Type
    )
{

    BOOL fMustDeleteString;
    TCHAR DataText[SIZE_DATATEXT];
    int BytesToWrite;
    PTSTR pString;

    fMustDeleteString = FALSE;

    //
    //  When pValueData is NULL, then that's a special indicator to us that this
    //  is the default value and it's value is undefined.
    //

    if (pValueData == NULL)
        pString = g_RegEditData.pValueNotSet;

    else if ((Type == REG_SZ) || (Type == REG_EXPAND_SZ)) {

        wsprintf(DataText, s_StringDataFormatSpec, (LPTSTR) pValueData);

        if ((cbValueData/sizeof(TCHAR)) > MAXIMUM_STRINGDATATEXT + 1)           //  for null
            lstrcat(DataText, s_Ellipsis);

        pString = DataText;

    }

    else if (Type == REG_DWORD || Type == REG_DWORD_BIG_ENDIAN) {

        //  FEATURE:  Check for invalid cbValueData!
        if (cbValueData == sizeof(DWORD))
        {
            DWORD dw = *((DWORD*)pValueData);

            if (Type == REG_DWORD_BIG_ENDIAN)
            {
                dw = ValueList_SwitchEndian(dw);
            }

            pString = LoadDynamicString(IDS_DWORDDATAFORMATSPEC, dw);
        }
        else
        {
            pString = LoadDynamicString(IDS_INVALIDDWORDDATA);
        }

        fMustDeleteString = TRUE;
    }
 
    else if (Type == REG_MULTI_SZ) {

        int CharsAvailableInBuffer;
        int ComponentLength;
        PTCHAR Start;

        ZeroMemory(DataText,sizeof(DataText));
        CharsAvailableInBuffer = MAXIMUM_STRINGDATATEXT+1;
        Start = DataText;
        for(pString=(PTSTR)pValueData; *pString; pString+=ComponentLength+1) {

            ComponentLength = lstrlen(pString);

            //
            // Quirky behavior of lstrcpyn is exactly what we need here.
            //
            if(CharsAvailableInBuffer > 0) {
                lstrcpyn(Start,pString,CharsAvailableInBuffer);
                Start += ComponentLength;
            }

            CharsAvailableInBuffer -= ComponentLength;

            if(CharsAvailableInBuffer > 0) {
                lstrcpyn(Start,TEXT(" "),CharsAvailableInBuffer);
                Start += 1;
            }

            CharsAvailableInBuffer -= 1;
        }

        if(CharsAvailableInBuffer < 0) {
            lstrcpy(DataText+MAXIMUM_STRINGDATATEXT,s_Ellipsis);
        }

        pString = DataText;
    }
 
    else {

        if (cbValueData == 0)
            pString = g_RegEditData.pEmptyBinary;

        else {

            BytesToWrite = min(cbValueData, MAXIMUM_BINARYDATABYTES);

            pString = DataText;

            while (BytesToWrite--)
                pString += wsprintf(pString, s_BinaryDataFormatSpec,
                    (BYTE) *pValueData++);

            *(--pString) = 0;

            if (cbValueData > MAXIMUM_BINARYDATABYTES)
                lstrcpy(pString, s_Ellipsis);

            pString = DataText;

        }

    }

    if(Type <= MAX_KNOWN_TYPE) {
        ListView_SetItemText(hValueListWnd, ListIndex, 1, (LPTSTR)s_TypeNames[Type]);
    } else {
        TCHAR TypeString[24];

        wsprintf(TypeString,TEXT("0x%x"),Type);
        ListView_SetItemText(hValueListWnd, ListIndex, 1, TypeString);
    }

    ListView_SetItemText(hValueListWnd, ListIndex, 2, pString);

    if (fMustDeleteString)
        DeleteDynamicString(pString);

}

/*******************************************************************************
*
*  ValueList_EditLabel
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hValueListWnd, handle of ValueList window.
*     ListIndex, index of item to edit.
*
*******************************************************************************/

VOID
PASCAL
ValueList_EditLabel(
    HWND hValueListWnd,
    int ListIndex
    )
{

    g_RegEditData.fAllowLabelEdits = TRUE;

    //
    //  We have to set the focus to the ListView or else ListView_EditLabel will
    //  return FALSE.  While we're at it, clear the selected state of all the
    //  items to eliminate some flicker when we move the focus back to this
    //  pane.
    //

    if (hValueListWnd != g_RegEditData.hFocusWnd) {

        ListView_SetItemState(hValueListWnd, -1, 0, LVIS_SELECTED |
            LVIS_FOCUSED);

        SetFocus(hValueListWnd);

    }

    ListView_EditLabel(hValueListWnd, ListIndex);

    g_RegEditData.fAllowLabelEdits = FALSE;

}

//------------------------------------------------------------------------------
//  ValueList_MultiStringToString
//
//  DESCRIPTION: Replaces NULL with '\r\n' to convert a Multi-String to a String
//
//  PARAMETERS:  EditValueParam - the edit value information
//------------------------------------------------------------------------------
BOOL PASCAL ValueList_MultiStringToString(LPEDITVALUEPARAM pEditValueParam)   
{
    BOOL fSuccess = TRUE;
    int iStrLen = pEditValueParam->cbValueData / sizeof(TCHAR);

    if (iStrLen > 1)
    {
        int i;
        int cNullsToReplace = 0; 
        PTSTR pszTemp = NULL;
        PTSTR psz = (TCHAR*)pEditValueParam->pValueData;

        // Determine new size 
        for (i = iStrLen - 2; i >=0; i--)
        {
            if (psz[i] == TEXT('\0'))
            {
                cNullsToReplace++;
            }
        }
        // the new string is always atleast as big as the old str, so we can convert back
        pszTemp = LocalAlloc(LPTR, pEditValueParam->cbValueData + cNullsToReplace * sizeof(TCHAR));
        if (pszTemp)
        {
            int iCurrentChar = 0;
            int iLastNull = iStrLen - 1;

            // change NULL to '\r\n'  
            for(i = 0; i < iLastNull; i++)
            {
                if (psz[i] == TEXT('\0'))
                {  
                    pszTemp[iCurrentChar++] = TEXT('\r');
                    pszTemp[iCurrentChar] = TEXT('\n');
                }
                else
                {
                    pszTemp[iCurrentChar] = psz[i];
                }
                iCurrentChar++;
            }

            pszTemp[iCurrentChar++] = TEXT('\0');

            pEditValueParam->pValueData  = (PBYTE)pszTemp;
            pEditValueParam->cbValueData = iCurrentChar * sizeof(psz[0]);
            
            LocalFree(psz);
        }
        else
        {
            fSuccess = FALSE;
        }
    }
    return fSuccess;
}


//------------------------------------------------------------------------------
//  ValueList_StringToMultiString
//
//  DESCRIPTION: Replaces '\r\n' with NULL
//
//  PARAMETERS:  EditValueParam - the edit value information
//------------------------------------------------------------------------------
VOID PASCAL ValueList_StringToMultiString(LPEDITVALUEPARAM pEditValueParam)   
{
    PTSTR psz = (TCHAR*)pEditValueParam->pValueData;
    int iStrLen = pEditValueParam->cbValueData / sizeof(TCHAR);

    if (iStrLen > 1)
    {
        int i = 0;
        int iCurrentChar = 0;

        // remove a return at the end of the string
        // because another string does not follow it.
        if (iStrLen >= 3)
        {
            if (psz[iStrLen - 3] == TEXT('\r'))
            {
                psz[iStrLen - 3] = TEXT('\0');
                iStrLen -= 2;
            }
        }

        for (i = 0; i < iStrLen; i++)
        {
            if (psz[i] == '\r')
            {  
                psz[iCurrentChar++] = TEXT('\0');
                i++; // jump past the '\n'   
            }
            else
            {
                psz[iCurrentChar++] = psz[i];
            }
        }

        // Null terminate multi-string
        psz[iCurrentChar++] = TEXT('\0');
        pEditValueParam->cbValueData = iCurrentChar * sizeof(psz[0]);
    }
}

//------------------------------------------------------------------------------
//  ValueList_RemoveEmptyStrings
//
//  DESCRIPTION: Removes empty strings from multi-strings
//
//  PARAMETERS:  EditValueParam - the edit value information
//------------------------------------------------------------------------------
VOID PASCAL ValueList_RemoveEmptyStrings(HWND hWnd, LPEDITVALUEPARAM pEditValueParam)   
{
    PTSTR psz = (TCHAR*)pEditValueParam->pValueData;
    int iStrLen = pEditValueParam->cbValueData / sizeof(TCHAR);

    if (iStrLen > 1)
    {
        int i = 0;
        int cNullStrings = 0;
        int iCurrentChar = 0;
        int iLastChar = pEditValueParam->cbValueData / sizeof(psz[0]) - 1;

        for (i = 0; i < iLastChar; i++)
        {
            if (((psz[i] != TEXT('\0')) || (psz[i+1] != TEXT('\0'))) &&
                ((psz[i] != TEXT('\0')) || (i != 0)))
            {  
                psz[iCurrentChar++] = psz[i];
            }
        }

        psz[iCurrentChar++] = TEXT('\0');

        if (iCurrentChar > 1)
        {
            cNullStrings = iLastChar - iCurrentChar;

            // Null terminate multi-string
            psz[iCurrentChar++] = TEXT('\0');

            // warn user of empty strings
            if (cNullStrings)
            {
                UINT ErrorStringID 
                    = (cNullStrings == 1) ? IDS_EDITMULTSZEMPTYSTR : IDS_EDITMULTSZEMPTYSTRS;

                InternalMessageBox(g_hInstance, hWnd, MAKEINTRESOURCE(ErrorStringID),
                MAKEINTRESOURCE(IDS_EDITWARNINGTITLE), MB_ICONERROR | MB_OK, NULL);
            }
        }
        pEditValueParam->cbValueData = (iCurrentChar * sizeof(psz[0]));
    }
}

//------------------------------------------------------------------------------
//  ValueList_SwitchEndian
//
//  DESCRIPTION: Switched a DWORD between little and big endian.
//
//  PARAMETERS:  dwSrc - the source DWORD to switch around
//------------------------------------------------------------------------------
DWORD PASCAL ValueList_SwitchEndian(DWORD dwSrc)
{
    DWORD dwDest = 0;
    BYTE * pbSrc = (BYTE *)&dwSrc;
    BYTE * pbDest = (BYTE *)&dwDest;
    int i;

    for(i = 0; i < 4; i++)
    {
        pbDest[i] = pbSrc[3-i];
    }

    return dwDest;
}

VOID RegEdit_DisplayBinaryData(HWND hWnd)
{
    DWORD Type;
    UINT ErrorStringID;
    BOOL fError = FALSE;
    EDITVALUEPARAM EditValueParam;
    TCHAR achValueName[MAXVALUENAME_LENGTH];
    int ListIndex = ListView_GetNextItem(g_RegEditData.hValueListWnd, -1, LVNI_SELECTED);
    LONG err;

    ListView_GetItemText(g_RegEditData.hValueListWnd, ListIndex, 0, achValueName, ARRAYSIZE(achValueName));
    if (ListIndex == 0)
    {
        //  This is the "(Default)" value. It either does not exist in the registry because
        //  it's value is not set, or it exists in the registry as '\0' when its value is set
        achValueName[0] = TEXT('\0');
    }
    EditValueParam.pValueName = achValueName;
    
    // get size and type
    err = RegEdit_QueryValueEx(g_RegEditData.hCurrentSelectionKey, achValueName, NULL, &Type, NULL, &EditValueParam.cbValueData);
    if (err == ERROR_SUCCESS || (err == ERROR_FILE_NOT_FOUND && achValueName[0] == TEXT('\0'))) {
        // Allocate storage space
        EditValueParam.pValueData =  LocalAlloc(LPTR, EditValueParam.cbValueData+ExtraAllocLen(Type));
        if (EditValueParam.pValueData)
        { 
            err = RegEdit_QueryValueEx(g_RegEditData.hCurrentSelectionKey, achValueName, NULL, &Type, EditValueParam.pValueData, &EditValueParam.cbValueData);
            
            // Allow the special behavior for a key's Default Value.
            if (err == ERROR_FILE_NOT_FOUND && achValueName[0] == TEXT('\0')) {
                Type = REG_SZ;
                *((TCHAR*)EditValueParam.pValueData) = TEXT('\0');
                err = ERROR_SUCCESS;
            }            
            
            if (err == ERROR_SUCCESS) {
                DisplayBinaryData(hWnd, &EditValueParam, Type);
            } else {
                ErrorStringID = IDS_EDITVALCANNOTREAD;
                fError = TRUE;
            }

            LocalFree(EditValueParam.pValueData);
        }
        else
        {
            ErrorStringID = IDS_EDITVALNOMEMORY;
            fError = TRUE;
        }
    }
    else
    {
        ErrorStringID = IDS_EDITVALCANNOTREAD;
        fError = TRUE;
    }
 
    if (fError)
    {
        InternalMessageBox(g_hInstance, hWnd, MAKEINTRESOURCE(ErrorStringID),
            MAKEINTRESOURCE(IDS_EDITVALERRORTITLE), MB_ICONERROR | MB_OK,
            (LPTSTR) achValueName);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\regedit\resource.h ===
//{{NO_DEPENDENCIES}}
// App Studio generated include file.
// Used by REGEDIT.RC
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        107
#define _APS_NEXT_COMMAND_VALUE         108
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\regedit\inc\regsec.h ===
#ifndef __REGSEC_H_INCLUDED__
#define __REGSEC_H_INCLUDED__
extern "C"
{
#include "authz.h"
}
#include "objbase.h"
#include "aclapi.h"
#include "aclui.h"

//Type def for PREDEFINED KEYS
typedef enum _PREDEFINE_KEY {
  PREDEFINE_KEY_CLASSES_ROOT,
  PREDEFINE_KEY_CURRENT_USER,
  PREDEFINE_KEY_LOCAL_MACHINE,
  PREDEFINE_KEY_USERS,
  PREDEFINE_KEY_CURRENT_CONFIG
} PREDEFINE_KEY;


class CSecurityInformation : public ISecurityInformation,IEffectivePermission,ISecurityObjectTypeInfo
{
private:
  long m_cRef;
    
public:
  CSecurityInformation():m_cRef(0){}
  virtual ~CSecurityInformation(){};
  // IUnknown methods
  STDMETHOD(QueryInterface)(REFIID, LPVOID *);
  STDMETHOD_(ULONG, AddRef)();
  STDMETHOD_(ULONG, Release)();

  // ISecurityInformation methods 
  STDMETHOD(GetObjectInformation)(
      IN PSI_OBJECT_INFO pObjectInfo
  ) = 0;
  STDMETHOD(GetSecurity)(
      IN  SECURITY_INFORMATION  RequestedInformation,
      OUT PSECURITY_DESCRIPTOR  *ppSecurityDescriptor,
      IN  BOOL                  fDefault
  ) = 0;
  STDMETHOD(SetSecurity)(
      IN SECURITY_INFORMATION SecurityInformation,
      IN PSECURITY_DESCRIPTOR pSecurityDescriptor
  ) = 0;
  STDMETHOD(GetAccessRights)(
      const GUID  *pguidObjectType,
      DWORD       dwFlags,
      PSI_ACCESS  *ppAccess,
      ULONG       *pcAccesses,
      ULONG       *piDefaultAccess
  ) = 0;
  STDMETHOD(MapGeneric)(
      const GUID  *pguidObjectType,
      UCHAR       *pAceFlags,
      ACCESS_MASK *pMask
  ) = 0;
  STDMETHOD(GetInheritTypes)(
      PSI_INHERIT_TYPE  *ppInheritTypes,
      ULONG             *pcInheritTypes
  ) = 0;
  STDMETHOD(PropertySheetPageCallback)(
      HWND          hwnd, 
      UINT          uMsg, 
      SI_PAGE_TYPE  uPage
  ) = 0;
  STDMETHOD(GetEffectivePermission) (  const GUID* pguidObjectType,
                                         PSID pUserSid,
                                         LPCWSTR pszServerName,
                                         PSECURITY_DESCRIPTOR pSD,
                                         POBJECT_TYPE_LIST *ppObjectTypeList,
                                         ULONG *pcObjectTypeListLength,
                                         PACCESS_MASK *ppGrantedAccessList,
                                         ULONG *pcGrantedAccessListLength) =0;
  
  STDMETHOD(GetInheritSource)(SECURITY_INFORMATION si,
                              PACL pACL, 
                              PINHERITED_FROM *ppInheritArray) PURE;



};

class CKeySecurityInformation : public CSecurityInformation
{


private:
  
  //Name of the Key, NULL for ROOT key
  LPCWSTR m_strKeyName;
  //Name of the parent Key, NULL for root and immediate child of root.
  LPCWSTR m_strParentName;
  //Name of the server, can be NULL
  LPCWSTR m_strMachineName;
  //Title of the page
  LPCWSTR m_strPageTitle;
  //if connected to Remote System, Machine name must not be null in this case
  BOOL m_bRemote;
  PREDEFINE_KEY m_PredefinedKey;
  BOOL m_bReadOnly;
  
  //Handle to predefined key. If handle to remote registry, close in Destructor
  HKEY        m_hkeyPredefinedKey;
  LPWSTR m_strCompleteName ;  //Free in Destructor
  DWORD   m_dwFlags;
  //This HWND to application window
  HWND  m_hWnd;
  //This is HWND to currently infocus ACLUI property Sheet. Null if none
  HWND  m_hWndProperty;
  AUTHZ_RESOURCE_MANAGER_HANDLE m_ResourceManager;    //Used for access check
  AUTHZ_RESOURCE_MANAGER_HANDLE GetAUTHZ_RM(){ return m_ResourceManager; }
  HWND GetInFocusHWnd() { return m_hWndProperty? m_hWndProperty : m_hWnd; }

public:
  CKeySecurityInformation(): m_strKeyName(NULL),m_strParentName(NULL),
                             m_strMachineName(NULL), m_strPageTitle(NULL),
                             m_bRemote(false),m_PredefinedKey((PREDEFINE_KEY)0),
                             m_bReadOnly(false),m_strCompleteName(NULL),
                             m_hWnd(NULL), m_hWndProperty(NULL),
                             m_ResourceManager(NULL){}
  ~CKeySecurityInformation();

public:


  // *** ISecurityInformation methods ***
  STDMETHOD(GetObjectInformation) (PSI_OBJECT_INFO pObjectInfo );
  STDMETHOD(GetSecurity)(
    IN  SECURITY_INFORMATION  RequestedInformation,
    OUT PSECURITY_DESCRIPTOR  *ppSecurityDescriptor,
    IN  BOOL                  fDefault
  );
  STDMETHOD(SetSecurity)(
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
  );
  STDMETHOD(GetAccessRights)(
    const GUID  *pguidObjectType,
    DWORD       dwFlags,
    PSI_ACCESS  *ppAccess,
    ULONG       *pcAccesses,
    ULONG       *piDefaultAccess
  );
  STDMETHOD(MapGeneric)(
    const GUID  *pguidObjectType,
    UCHAR       *pAceFlags,
    ACCESS_MASK *pMask
  );
  STDMETHOD(GetInheritTypes)(
    PSI_INHERIT_TYPE  *ppInheritTypes,
    ULONG             *pcInheritTypes
  );
  STDMETHOD(PropertySheetPageCallback)(
    HWND          hwnd, 
    UINT          uMsg, 
    SI_PAGE_TYPE  uPage
  );
  STDMETHOD(GetEffectivePermission) (  const GUID* pguidObjectType,
                                         PSID pUserSid,
                                         LPCWSTR pszServerName,
                                         PSECURITY_DESCRIPTOR pSD,
                                         POBJECT_TYPE_LIST *ppObjectTypeList,
                                         ULONG *pcObjectTypeListLength,
                                         PACCESS_MASK *ppGrantedAccessList,
                                         ULONG *pcGrantedAccessListLength) ;

  STDMETHOD(GetInheritSource)(SECURITY_INFORMATION si,
                              PACL pACL, 
                              PINHERITED_FROM *ppInheritArray);


  HRESULT Initialize ( LPCWSTR strKeyName,
                       LPCWSTR strParentName,
                       LPCWSTR strMachineName,
                       LPCWSTR strPageTitle,
                       BOOL    bRemote,
                       PREDEFINE_KEY PredefinedKey,
                       BOOL bReadOnly,
                       HWND hWnd);

protected:
  HRESULT SetCompleteName();
  LPCWSTR GetCompleteName(){ return m_strCompleteName; }
  LPCWSTR GetCompleteName1();
  HRESULT SetHandleToPredefinedKey();


  STDMETHOD(WriteObjectSecurity)(
    LPCTSTR pszObject,
    SECURITY_INFORMATION si,
    PSECURITY_DESCRIPTOR pSD
  );

  STDMETHOD(WriteObjectSecurity)(
    HKEY hkey,
    SECURITY_INFORMATION si,
    PSECURITY_DESCRIPTOR pSD
  );

  HRESULT SetSubKeysSecurity(
    HKEY hkey,
    SECURITY_INFORMATION si,
    PSECURITY_DESCRIPTOR pSD,
    LPBOOL pbNotAllApplied,
    bool bFirstCall 
  );
  HRESULT OpenKey(
    DWORD Permission,
    PHKEY pKey 
  );

};


//
HRESULT CreateSecurityInformation( IN LPCWSTR strKeyName,
                                   IN LPCWSTR strParentName,
                                   IN LPCWSTR strMachineName,
                                   IN LPCWSTR strPageTitle,
                                   IN BOOL    bRemote,
                                   IN PREDEFINE_KEY PredefinedKey,
                                   IN BOOL bReadOnly,
                                   IN HWND hWnd,
                                   OUT LPSECURITYINFO *pSi);

BOOL DisplayMessage( HWND hWnd,
										 HINSTANCE hInstance,
										 DWORD dwMessageId,
										 DWORD dwCaptionId );


#endif // ~__PERMPAGE_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\regedt32\regedt32.h ===
//---------------------------------------------------------------------------
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------

#include <windows.h>
#include <shellapi.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\regedt32\regedt32.c ===
//---------------------------------------------------------------------------
//
//---------------------------------------------------------------------------
#include "regedt32.h"

// stolen from the CRT, used to shirink our code

int _stdcall ModuleEntry(void)
{
    STARTUPINFO si;
    LPSTR pszCmdLine = GetCommandLine();

    if ( *pszCmdLine == '\"' ) {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine
             != '\"') );
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == '\"' )
            pszCmdLine++;
    }
    else {
        while (*pszCmdLine > ' ')
            pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= ' ')) {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfoA(&si);

    return WinMain(GetModuleHandle(NULL), NULL, pszCmdLine,
                   si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);

}


const char szFile[] = "regedit.exe";

//---------------------------------------------------------------------------
int PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    ShellExecute(HWND_DESKTOP, NULL, szFile, lpCmdLine, NULL, nCmdShow);
    ExitProcess(0);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\replace\sources.inc ===
!IF 0

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    sources.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

USE_MSVCRT=1

TARGETNAME=replace
TARGETPATH=obj
TARGETTYPE=PROGRAM

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\argument.cxx    \
        ..\support.cxx     \
        ..\replace.cxx     \
        ..\replace.rc

INCLUDES=..\.;..\..\ulib\inc

!IF "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "ntsd"
!IFDEF NOMEMLEAK
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DUNICODE=1
!ELSE
!IFDEF STACK_TRACE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DSTACK_TRACE -DUNICODE=1
!ELSE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DUNICODE=1
!ENDIF
!ENDIF
!ELSE    # NTDEBUG
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=0 -DUNICODE=1
!ENDIF   # NTDEBUG

TARGETLIBS=..\..\ulib\src\$(ALT_PROJECT)\$(O)\ulib.lib $(SDK_LIB_PATH)\ntdll.lib

UMTYPE=console

W32_SB=1
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\replace\argument.cxx ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

        Argument

Abstract:

        Argument processing for the Replace utility

Author:

        Ramon Juan San Andres (ramonsa) 01-May-1991

Notes:

        The arguments accepted  by the Replace utility are:

        Source path.-           Source path.

        Destination path.-      Destination path.

        Add switch.-            Adds new files to the target directory instead of
                                                replacing existing one. Cannot use with Subdir
                                                switch or CompareTime switch.

        Prompt switch.-         Prompts before adding/replacing a file.

        ReadOnly switch.-       Replaces red-only files as well as regular files.

        Subdir switch.-         Recurses along the destination path.

        CompareTime switch.-Replaces only thos files on the target path that
                                                are older than the corresponding file in the
                                                source path.

        Wait switch.-           Waits for the user to type any key before starting.

        Help switch.-           Displays usage

Revision History:


--*/


#include "ulib.hxx"
#include "arg.hxx"
#include "arrayit.hxx"
#include "file.hxx"
#include "system.hxx"
#include "replace.hxx"


#define MATCH_ALL_PATTERN       "*"
#define CURRENT_DIRECTORY   (LPWSTR)L"."



//
//  Global variables (global to the module)
//

PPATH_ARGUMENT          SourcePathArgument              =       NULL;
PPATH_ARGUMENT          DestinationPathArgument =       NULL;
PFLAG_ARGUMENT          AddArgument                             =       NULL;
PFLAG_ARGUMENT          PromptArgument                  =       NULL;
PFLAG_ARGUMENT          ReadOnlyArgument                =       NULL;
PFLAG_ARGUMENT          SubdirArgument                  =       NULL;
PFLAG_ARGUMENT          CompareTimeArgument             =       NULL;
PFLAG_ARGUMENT          WaitArgument                    =       NULL;
PFLAG_ARGUMENT          HelpArgument                    =       NULL;

BOOLEAN                         HelpSwitch;



VOID
REPLACE::SetArguments(
        )

/*++

Routine Description:

        Obtains the arguments for the Replace utility

Arguments:

    None.

Return Value:

    None.

Notes:

--*/

{

        //
        //      Allocate things
        //
        if (//
                //      Get the argument patterns
        //
        !_AddPattern.Initialize( (LPWSTR)L"/A" ) ||
        !_PromptPattern.Initialize( (LPWSTR)L"/P" ) ||
        !_ReadOnlyPattern.Initialize( (LPWSTR)L"/R" ) ||
        !_SubdirPattern.Initialize( (LPWSTR)L"/S" ) ||
        !_CompareTimePattern.Initialize( (LPWSTR)L"/U" ) ||
        !_WaitPattern.Initialize( (LPWSTR)L"/W" ) ||
        !_HelpPattern.Initialize( (LPWSTR)L"/?" ) ||

                //
                //      Get our parsing preferences
        //
        !_Switches.Initialize( (LPWSTR)L"/-" ) ||
        !_MultipleSwitch.Initialize( (LPWSTR)L"/APRSUW?" ) ||

                //
                //      Create the arguments
                //
                ((SourcePathArgument            = NEW PATH_ARGUMENT)     == NULL )                                                              ||
                ((DestinationPathArgument       = NEW PATH_ARGUMENT)     == NULL )                                                              ||
                ((AddArgument                           = NEW FLAG_ARGUMENT)     == NULL )                                                              ||
                ((PromptArgument                        = NEW FLAG_ARGUMENT)     == NULL )                                                              ||
                ((ReadOnlyArgument                      = NEW FLAG_ARGUMENT)     == NULL )                                                              ||
                ((SubdirArgument                        = NEW FLAG_ARGUMENT)     == NULL )                                                              ||
                ((CompareTimeArgument           = NEW FLAG_ARGUMENT)     == NULL )                                                              ||
                ((WaitArgument                          = NEW FLAG_ARGUMENT)     == NULL )                                                              ||
                ((HelpArgument                          = NEW FLAG_ARGUMENT)     == NULL )
                ) {

                DisplayMessageAndExit ( REPLACE_ERROR_NO_MEMORY,
                                                                NULL,
                                                                EXIT_NO_MEMORY );
        }


        //
        //      Parse the arguments
        //
        GetArgumentsCmd();

        //
        //      Verify the arguments
        //
        CheckArgumentConsistency();

        //
        //      Clean up
    //
    DELETE( SourcePathArgument );
        DELETE( DestinationPathArgument );
        DELETE( AddArgument );
        DELETE( PromptArgument );
        DELETE( ReadOnlyArgument );
        DELETE( SubdirArgument );
        DELETE( CompareTimeArgument );
        DELETE( WaitArgument );
        DELETE( HelpArgument );
}

VOID
REPLACE::GetArgumentsCmd(
        )

/*++

Routine Description:

        Obtains the arguments from the Command line

Arguments:

    None.

Return Value:

        None

Notes:

--*/

{

        ARRAY                           ArgArray;
        PATH_ARGUMENT           ProgramNameArgument;
    DSTRING             CmdLine;

        //
        //      Prepare for parsing
        //
        if (//
                //      Initialize the arguments
                //
                !(CmdLine.Initialize( GetCommandLine() ))                                       ||
                !(ArgArray.Initialize( 10, 10 ))                                                        ||
                !(ProgramNameArgument.Initialize( MATCH_ALL_PATTERN ))          ||
        !(SourcePathArgument->Initialize( MATCH_ALL_PATTERN, FALSE)) ||
        !(DestinationPathArgument->Initialize( MATCH_ALL_PATTERN, TRUE ))   ||
        !(AddArgument->Initialize( &_AddPattern   ))                  ||
        !(PromptArgument->Initialize( &_PromptPattern ))              ||
        !(ReadOnlyArgument->Initialize( &_ReadOnlyPattern ))          ||
        !(SubdirArgument->Initialize( &_SubdirPattern ))              ||
        !(CompareTimeArgument->Initialize( &_CompareTimePattern   ))  ||
        !(WaitArgument->Initialize( &_WaitPattern ))                  ||
        !(HelpArgument->Initialize( &_HelpPattern ))                  ||

                //
                //      Put the arguments in the argument array
                //
                !(ArgArray.Put( &ProgramNameArgument ))                                         ||
                !(ArgArray.Put( AddArgument ))                                                          ||
                !(ArgArray.Put( PromptArgument ))                                                       ||
                !(ArgArray.Put( ReadOnlyArgument ))                                                     ||
                !(ArgArray.Put( SubdirArgument ))                                                       ||
                !(ArgArray.Put( CompareTimeArgument ))                                          ||
                !(ArgArray.Put( WaitArgument ))                                                         ||
                !(ArgArray.Put( HelpArgument ))                                                         ||
                !(ArgArray.Put( SourcePathArgument ))                                           ||
                !(ArgArray.Put( DestinationPathArgument ))
                )       {

                DisplayMessageAndExit( REPLACE_ERROR_NO_MEMORY,
                                                           NULL,
                                                           EXIT_NO_MEMORY );
        }

        //
        //      Parse the arguments
        //
        ParseArguments( &CmdLine, &ArgArray );

        //
        //      Set the switches
        //
        _AddSwitch                      =       AddArgument->QueryFlag();
        _PromptSwitch           =       PromptArgument->QueryFlag();
        _ReadOnlySwitch         =       ReadOnlyArgument->QueryFlag();
        _SubdirSwitch           =       SubdirArgument->QueryFlag();
        _CompareTimeSwitch      =       CompareTimeArgument->QueryFlag();
        _WaitSwitch                     =       WaitArgument->QueryFlag();
        HelpSwitch                      =       HelpArgument->QueryFlag();

        //
        //      Set the source and destination paths.
        //
        if ( SourcePathArgument->IsValueSet() ) {
        if ((_SourcePath = SourcePathArgument->GetPath()->QueryPath()) == NULL ) {
                        DisplayMessageAndExit( REPLACE_ERROR_NO_MEMORY, NULL, EXIT_NO_MEMORY );
                }
        } else {
                _SourcePath = NULL;
        }

        if ( DestinationPathArgument->IsValueSet() ) {
                if ((_DestinationPath = DestinationPathArgument->GetPath()->QueryFullPath()) == NULL ) {
                        DisplayMessageAndExit( REPLACE_ERROR_NO_MEMORY, NULL, EXIT_NO_MEMORY );
                }
        } else {
                _DestinationPath = NULL;
        }

}

VOID
REPLACE::ParseArguments(
        IN      PWSTRING        CmdLine,
        OUT PARRAY              ArgArray
        )

/*++

Routine Description:

        Parses a group of arguments

Arguments:

        CmdLine         -       Supplies pointer to a command line to parse
        ArgArray        -       Supplies pointer to array of arguments

Return Value:

        none

Notes:

--*/

{
        ARGUMENT_LEXEMIZER      ArgLex;
        ARRAY                           LexArray;

        //
        //      Initialize lexeme array and the lexemizer.
        //
        if ( !(LexArray.Initialize( 8, 8 ))                                                                                                       ||
                 !(ArgLex.Initialize( &LexArray )) ) {

                DisplayMessageAndExit( REPLACE_ERROR_NO_MEMORY,
                                                           NULL,
                                                           EXIT_NO_MEMORY );

        }

        //
        //      Set our parsing preferences
    //
    ArgLex.PutMultipleSwitch( &_MultipleSwitch );
    ArgLex.PutSwitches( &_Switches );
    ArgLex.SetCaseSensitive( FALSE );
    ArgLex.PutSeparators( " /\t" );
    ArgLex.PutStartQuotes( "\"" );
    ArgLex.PutEndQuotes( "\"" );


        //
        //      Parse the arguments
        //
        if ( !(ArgLex.PrepareToParse( CmdLine ))) {

                DisplayMessageAndExit( REPLACE_ERROR_PARSE,
                                                           NULL,
                                                           EXIT_COMMAND_LINE_ERROR );

        }

        if ( !ArgLex.DoParsing( ArgArray ) ) {

                DisplayMessageAndExit( REPLACE_ERROR_INVALID_SWITCH,
                                                           ArgLex.QueryInvalidArgument(),
                                                           EXIT_COMMAND_LINE_ERROR );
        }


}

VOID
REPLACE::CheckArgumentConsistency (
        )

/*++

Routine Description:

        Checks the consistency of the arguments

Arguments:

        none

Return Value:

        none

Notes:

--*/

{

    PFSN_FILE   File = NULL;

        if ( HelpSwitch ) {
                //
                //      Help requested
                //
                Usage();
        }


        //
        //      Make sure that we have a source path
        //
        if ( _SourcePath == NULL ) {

                DisplayMessageAndExit( REPLACE_ERROR_SOURCE_PATH_REQUIRED,
                                                           NULL,
                                                           EXIT_COMMAND_LINE_ERROR );
        }

        //
        //      The add switch cannot be specified together with the Subdir or the
        //      CompareTime switch.
        //
        if ( _AddSwitch && (_SubdirSwitch || _CompareTimeSwitch))       {

                DisplayMessageAndExit( REPLACE_ERROR_INVALID_PARAMETER_COMBINATION,
                                                           NULL,
                                                           EXIT_COMMAND_LINE_ERROR );

        }

        //
        //      If destination path is null, then the destination path is the
        //      current directory
        //
        if ( _DestinationPath == NULL ) {

                if ( ((_DestinationPath = NEW PATH) == NULL ) ||
                         !_DestinationPath->Initialize( CURRENT_DIRECTORY, TRUE ) ) {

                        DisplayMessageAndExit( REPLACE_ERROR_NO_MEMORY,
                                                                   NULL,
                                                                   EXIT_NO_MEMORY );
                }
        } else if ( (_DestinationPath->HasWildCard())   ||
                                ((File = SYSTEM::QueryFile( _DestinationPath )) != NULL) ) {
                DisplayMessageAndExit( REPLACE_ERROR_PATH_NOT_FOUND,
                                                           _DestinationPath->GetPathString(),
                                                           EXIT_PATH_NOT_FOUND );
        }

    DELETE( File );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\runas\cred_pch.h ===
//=============================================================================
// Copyright (c) 2000 Microsoft Corporation
//
// precomp.hpp
//
// Created 02/29/2000 johnstep (John Stephens)
//=============================================================================

#define UNICODE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <malloc.h>
#include <commctrl.h>
#define _CREDUI_
#include <wincred.h>
#include <lmcons.h>
#include <netlib.h>

#define CreduiDebugLog

//-----------------------------------------------------------------------------
// Types
//-----------------------------------------------------------------------------

struct CREDUI_STRINGS
{
    WCHAR UserNameTipTitle[32];
    WCHAR UserNameTipText[256];
    WCHAR CapsLockTipTitle[32];
    WCHAR CapsLockTipText[256];
    WCHAR LogonTipTitle[32];
    WCHAR LogonTipText[256];
    WCHAR LogonTipCaps[256];
    WCHAR DnsCaption[64];
    WCHAR NetbiosCaption[64];
    WCHAR GenericCaption[64];
    WCHAR Welcome[64];
    WCHAR WelcomeBack[64];
    WCHAR Connecting[64];
    WCHAR PasswordStatic[32];
    WCHAR PinStatic[32];
    WCHAR UserNameStatic[32];
    WCHAR CertificateStatic[32];
    WCHAR Certificate[32];
    WCHAR LookupName[64];
    WCHAR EmptyReader[64];
    WCHAR UnknownCard[64];
    WCHAR BackwardsCard[64];
    WCHAR EmptyCard[64];
    WCHAR ReadingCard[64];
    WCHAR CardError[64];
    WCHAR BackwardsTipTitle[32];
    WCHAR BackwardsTipText[128];
    WCHAR SmartCardStatic[32];
    WCHAR WrongOldTipTitle[32];
    WCHAR WrongOldTipText[256];
    WCHAR NotSameTipTitle[32];
    WCHAR NotSameTipText[256];
    WCHAR TooShortTipTitle[32];
    WCHAR TooShortTipText[256];
    WCHAR Save[64];
    WCHAR Prompt[64];
};

// Private window message:

enum
{
    CREDUI_WM_APP_LOOKUP_COMPLETE   = WM_APP + 0,
    CREDUI_WM_APP_VIEW_COMPLETE     = WM_APP + 1
};

//-----------------------------------------------------------------------------
// Global Variables
//-----------------------------------------------------------------------------

extern HMODULE CreduiInstance;
extern ULONG CreduiComReferenceCount;

extern BOOL CreduiIsPersonal;
extern BOOL CreduiIsSafeMode;

extern CREDUI_STRINGS CreduiStrings;

extern UINT CreduiScarduiWmReaderArrival;
extern UINT CreduiScarduiWmReaderRemoval;
extern UINT CreduiScarduiWmCardInsertion;
extern UINT CreduiScarduiWmCardRemoval;
extern UINT CreduiScarduiWmCardCertAvail;
extern UINT CreduiScarduiWmCardStatus;

extern BOOL CreduiHasSmartCardSupport;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\replace\support.cxx ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

	Support

Abstract:

	Miscelaneous support functions for the Replace utility.

	All functions that are not involved directly in the adding\replacing
	of files go here.

Author:

	Ramon Juan San Andres (ramonsa) 02-May-1991

Revision History:

--*/



#include "ulib.hxx"
#include "system.hxx"
#include "replace.hxx"





VOID
REPLACE::DisplayMessageAndExit (
    IN  MSGID       MsgId,
    IN  PCWSTRING   String,
    IN  ULONG       ExitCode
	)

/*++

Routine Description:

	Displays a message and exits the program with the supplied error code.
	We support a maximum of one string parameter for the message.

Arguments:

	MsgId		-	Supplies the Id of the message to display.
	String		-	Supplies a string parameter for the message.
	ExitCode	-	Supplies the exit code with which to exit.

Return Value:

    None.

Notes:

--*/

{

	PATH	Path;

	if ( MsgId != 0 ) {
        if ( String ) {
		    DisplayMessage( MsgId, ERROR_MESSAGE, "%W", String );
	    } else {
		    DisplayMessage( MsgId, ERROR_MESSAGE, "" );
	    }
    }
	//
	//	Display the number of files added/ replaced.
	//
	if ( _AddSwitch ) {

		if ( _FilesAdded == 0 ) {
			DisplayMessage( REPLACE_MESSAGE_NO_FILES_ADDED );
		} else {
			DisplayMessage( REPLACE_MESSAGE_FILES_ADDED, NORMAL_MESSAGE, "%d",	_FilesAdded );
		}

	} else {

		if ( _FilesReplaced == 0 ) {
			DisplayMessage( REPLACE_MESSAGE_NO_FILES_REPLACED );
		} else {
			DisplayMessage( REPLACE_MESSAGE_FILES_REPLACED, NORMAL_MESSAGE, "%d", _FilesReplaced );
		}
	}

	exit( (int)ExitCode );

}

PWSTRING
REPLACE::QueryMessageString (
	IN MSGID	MsgId
	)
/*++

Routine Description:

	Obtains a string object initialized to the contents of some message

Arguments:

	MsgId	-	Supplies ID of the message

Return Value:

	PWSTRING	-	Pointer to initialized string object

Notes:

--*/

{

	PWSTRING	String;

    if ( ((String = NEW DSTRING) == NULL )  ||
		 !(SYSTEM::QueryResourceString( String, MsgId, "" )) ) {

		DisplayMessageAndExit( REPLACE_ERROR_NO_MEMORY, NULL, EXIT_NO_MEMORY );
	}

	return String;

}

VOID
REPLACE::ExitWithError(
	IN	DWORD		ErrorCode
	)

/*++

Routine Description:

	Displays a message based on a WIN32 error code, and exits.

Arguments:

	ErrorCode	-	Supplies Windows error code

Return Value:

	none

--*/

{
	Fatal(	EXIT_PATH_NOT_FOUND, REPLACE_ERROR_EXTENDED, "%d", ErrorCode );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\replace\replace.cxx ===
/*++

Copyright (c) 1990-2000 Microsoft Corporation

Module Name:

        Replace

Abstract:

        Replace utility

Author:

        Ramon Juan San Andres (ramonsa) 01-May-1991

Revision History:

--*/

#include "ulib.hxx"
#include "arrayit.hxx"
#include "dir.hxx"
#include "filter.hxx"
#include "file.hxx"
#include "fsnode.hxx"
#include "stream.hxx"
#include "substrng.hxx"
#include "system.hxx"
#include "replace.hxx"

//
//      Pattern that matches all files in a directory
//
#define         MATCH_ALL_FILES         "*.*"


#define CTRL_C          (WCHAR)3



//
//      Size of buffers to hold path strings
//
#define         INITIAL_PATHSTRING_BUFFER_SIZE  MAX_PATH


VOID __cdecl
main (
        )

/*++

Routine Description:

        Main function of the Replace utility

Arguments:

    None.

Return Value:

    None.

Notes:

--*/

{
    //
    //      Initialize stuff
    //
    DEFINE_CLASS_DESCRIPTOR( REPLACE );

    //
    //      Now do the replacement
    //
    {
            REPLACE Replace;

            //
            //      Initialize the Replace object.
            //
            Replace.Initialize();

            //
            //      Do our thing
            //
            Replace.DoReplace();
    }
}




DEFINE_CONSTRUCTOR( REPLACE,    PROGRAM );



BOOLEAN
REPLACE::Initialize (
        )

/*++

Routine Description:

        Initializes the REPLACE object

Arguments:

    None.

Return Value:

        TRUE if initialized, FALSE otherwise

Notes:

--*/

{
        //
        //      Initialize program object
        //
        PROGRAM::Initialize( REPLACE_MESSAGE_USAGE );

        //
        //      Allocate global structures and initialize them
        //
        InitializeThings();

        //
        //      Parse the arguments
        //
        SetArguments();

        return TRUE;
}

REPLACE::~REPLACE (
        )

/*++

Routine Description:

        Destructs a REPLACE object

Arguments:

    None.

Return Value:

    None.

Notes:

--*/

{
    //
    //      Deallocate the global structures previously allocated
    //
    DeallocateThings();

    //
    //      Exit without error
    //
    DisplayMessageAndExit( 0, NULL, EXIT_NORMAL );

}

VOID
REPLACE::InitializeThings (
        )

/*++

Routine Description:

        Initializes the global variables that need initialization

Arguments:

    None.

Return Value:

    None.

Notes:

--*/

{

    //
        //      Initialize the path string buffers
        //
    _PathString1 = (LPWSTR)MALLOC( INITIAL_PATHSTRING_BUFFER_SIZE );
    _PathString2 = (LPWSTR)MALLOC( INITIAL_PATHSTRING_BUFFER_SIZE );

    _PathString1Size = _PathString2Size = INITIAL_PATHSTRING_BUFFER_SIZE;

    _Keyboard = NEW KEYBOARD;

    if ( !_PathString1 || !_PathString2 || !_Keyboard ) {
            DisplayMessageAndExit( REPLACE_ERROR_NO_MEMORY, NULL, EXIT_NO_MEMORY );
    }

    //
    //      initialize the keyboard and set ctrl-c handling
    //
    _Keyboard->Initialize();
    _Keyboard->EnableBreakHandling();

    //
    //      Initialize our data
    //
    _SourcePath             =       NULL;
    _DestinationPath        =       NULL;
    _FilesAdded             =       0;
    _FilesReplaced          =       0;
    _SourceDirectory        =       NULL;
    _Pattern                        =       NULL;
    _FilesInSrc             =       NULL;

    _AddSwitch = FALSE;   // use by DisplayMessageAndExit before any
                          // of those boolean _*Switch is being initialized

}

VOID
REPLACE::DeallocateThings (
        )

/*++

Routine Description:

        Deallocates the stuff that was initialized in InitializeThings()

Arguments:

    None.

Return Value:

    None.

Notes:

--*/

{

    DELETE( _FilesInSrc );
    DELETE( _SourceDirectory );
    DELETE( _Pattern );
    DELETE( _Keyboard );

    FREE( _PathString1 );
    FREE( _PathString2 );

}

BOOLEAN
REPLACE::DoReplace (
        )

/*++

Routine Description:

        This is the function that performs the Replace.

Arguments:

    None.

Return Value:

        TRUE

Notes:

--*/

{

    PFSN_DIRECTORY  DestinationDirectory;
    FSN_FILTER              Filter;
    WCHAR                   Char;

    //
    //      Get the source directory object and the pattern that we will use
    //      for file matching.
    //
    GetDirectoryAndPattern( _SourcePath, &_SourceDirectory, &_Pattern );

    DebugPtrAssert( _SourceDirectory );
    DebugPtrAssert( _Pattern );

    //
    //      Get the destination directory
    //
    GetDirectory( _DestinationPath, &DestinationDirectory );

    DebugPtrAssert( DestinationDirectory );

    //
    //      Wait if requested
    //
    if ( _WaitSwitch ) {

            DisplayMessage( REPLACE_MESSAGE_PRESS_ANY_KEY );
            AbortIfCtrlC();

            //
            //      All input is in raw mode.
            //
            _Keyboard->DisableLineMode();
            GetStandardInput()->ReadChar( &Char );
            _Keyboard->EnableLineMode();

            GetStandardOutput()->WriteChar( Char );
            GetStandardOutput()->WriteChar( (WCHAR)'\r');
            GetStandardOutput()->WriteChar( (WCHAR)'\n');

            //
            //      Check for ctrl-c
            //
            if ( Char == CTRL_C ) {
                    exit ( EXIT_PATH_NOT_FOUND );
            }
    }

    //
    //      Get an array containing all the files in the source directory
    //      that match the pattern.
    //
    //      This is so that Replacer() does not have to get the same
    //      information over and over when the Subdir switch is set.
    //
    _FilesInSrc = GetFileArray( _SourceDirectory, _Pattern );
    DebugPtrAssert( _FilesInSrc );

    if ( _SubdirSwitch ) {

            //
            //      First, replace the files in the directory specified
            //
            Replacer( this, DestinationDirectory, NULL );

            Filter.Initialize();
            Filter.SetAttributes( (FSN_ATTRIBUTE)FILE_ATTRIBUTE_DIRECTORY );

            //
            //      Now traverse the destination directory, calling the
            //      replacer function for each subdirectory.
            //
            DestinationDirectory->Traverse( this,
                                                                            &Filter,
                                                                            NULL,
                                                                            REPLACE::Replacer );
    } else {

            //
            //      Call the replace function, which takes care of replacements
            //
            Replacer(this,  DestinationDirectory, NULL );
    }
    DELETE( DestinationDirectory );

    return TRUE;

}

VOID
REPLACE::GetDirectoryAndPattern(
   IN    PPATH       Path,
   OUT   PFSN_DIRECTORY *Directory,
    OUT     PWSTRING        *Pattern
   )

/*++

Routine Description:

        Given a path, this function obtains a directory object and a pattern.

        Normally, the pattern is the filename portion of the path, but if the
        entire path refers to a directory, then the pattern is "*.*"

Arguments:

        Path            -       Supplies pointer to path
        Directory       -       Supplies pointer to pointer to directory
        Pattern         -       Supplies pointer to pointer to pattern

Return Value:

        TRUE

Notes:

--*/

{
    PATH           TmpPath;
    PWSTRING            Name;
    PFSN_DIRECTORY    Dir;
    PWSTRING            Ptrn;

    DebugAssert( Path );
    DebugAssert( Directory );
    DebugAssert( Pattern );

    //
    // If the name passed is a directory, it is an error.
    // Otherwise, split the path into Directory and Pattern
    // portions.
    //
    Dir = SYSTEM::QueryDirectory( Path );

    if ( Dir ||
         (Name = Path->QueryName()) == NULL ||
         (Ptrn = Name->QueryString()) == NULL ) {

        DisplayMessageAndExit( REPLACE_ERROR_NO_FILES_FOUND,
                               Path->GetPathString(),
                               EXIT_FILE_NOT_FOUND );

    } else {

        // We're finished with Name.
        //
        DELETE( Name );

        //
        // Get the directory
        //
        TmpPath.Initialize( Path, TRUE );
        TmpPath.TruncateBase();

        Dir = SYSTEM::QueryDirectory( &TmpPath );

        if ( !Dir ) {

            DisplayMessageAndExit( REPLACE_ERROR_PATH_NOT_FOUND,
                                   Path->GetPathString(),
                                   EXIT_PATH_NOT_FOUND );
        }

        *Directory = Dir;
        *Pattern   = Ptrn;
    }
}

VOID
REPLACE::GetDirectory(
        IN              PCPATH                  Path,
        OUT     PFSN_DIRECTORY  *Directory
        )

/*++

Routine Description:

        Makes a directory out of a path.

Arguments:

        Path            -       Supplies pointer to path
        Directory       -       Supplies pointer to pointer to directory

Return Value:

        TRUE

Notes:

--*/

{
    PFSN_DIRECTORY  Dir;


    if ( !(Dir = SYSTEM::QueryDirectory( Path )) ) {

            DisplayMessageAndExit( REPLACE_ERROR_PATH_NOT_FOUND,
                                                       Path->GetPathString(),
                                                       EXIT_PATH_NOT_FOUND );
    }

    *Directory = Dir;

}

PARRAY
REPLACE::GetFileArray(
   IN    PFSN_DIRECTORY Directory,
    IN      PWSTRING        Pattern
   )

/*++

Routine Description:

        Gets an array of those files in a directory matching a pattern.

Arguments:

        Directory       -       Supplies pointer to directory
        Pattern         -       Supplies pointer to pattern

Return Value:

        Pointer to the array of files

Notes:

--*/
{

    PARRAY          Array;
    FSN_FILTER      Filter;

    DebugPtrAssert( Directory );
    DebugPtrAssert( Pattern );

    Filter.Initialize();
    Filter.SetFileName( Pattern );
    Filter.SetAttributes( (FSN_ATTRIBUTE)0, (FSN_ATTRIBUTE)0, (FSN_ATTRIBUTE)FILE_ATTRIBUTE_DIRECTORY );

    Array = Directory->QueryFsnodeArray( &Filter );

    DebugPtrAssert( Array );

    return Array;

}

BOOLEAN
REPLACE::Replacer (
        IN              PVOID           This,
        IN OUT  PFSNODE         DirectoryNode,
        IN              PPATH           DummyPath
        )
/*++

Routine Description:

        This is the heart of Replace. Given a destination directory, it
        performs the replacement/additions according to the global switches
        and the SourceDirectory and Pattern.

Arguments:

        This                    -       Supplies pointer to the REPLACE object
        Node                    -       Supplies pointer to the directory node.
        DummyPath               -       Required by FSN_DIRECTORY::Traverse(), must be
                                                NULL.

Return Value:

        BOOLEAN -       TRUE if operation successful.
                                FALSE otherwise

Notes:

--*/

{

    DebugAssert( DummyPath == NULL );
    DebugAssert( DirectoryNode->IsDirectory() );

    ((PREPLACE)This)->AbortIfCtrlC();

    if ( ((PREPLACE)This)->_AddSwitch ) {
        return ((PREPLACE)This)->AddFiles( (PFSN_DIRECTORY)DirectoryNode );
    } else {
        return ((PREPLACE)This)->ReplaceFiles( (PFSN_DIRECTORY)DirectoryNode );
    }
}

BOOLEAN
REPLACE::AddFiles (
        IN OUT  PFSN_DIRECTORY  DestinationDirectory
        )
/*++

Routine Description:

        Adds those      files from the SourceDirectory that match Pattern to the
        DestinationDirectory. The array of files is already in the
        FilesInSrc array.

Arguments:

        DestinationDirectory    -       Supplies pointer to destination
                                                                directory.

Return Value:

        BOOLEAN -       TRUE if operation successful.
                                FALSE otherwise

Notes:

--*/

{

    PARRAY_ITERATOR   Iterator;
    PFSN_FILE         File;
    PFSN_FILE         FileToCreate;
    PATH              DestinationPath;
    PWSTRING          Name;

    DebugPtrAssert( DestinationDirectory );
    DebugPtrAssert( _FilesInSrc );

    //
    //      Get destination path
    //
    DestinationPath.Initialize( DestinationDirectory->GetPath() );

    //
    //      Obtain an iterator for going thru the files
    //
    Iterator = ( PARRAY_ITERATOR )_FilesInSrc->QueryIterator( );
    if (Iterator == NULL) {
        DisplayMessageAndExit( REPLACE_ERROR_NO_MEMORY, NULL, EXIT_NO_MEMORY );
        return FALSE;       // help lint
    }

    //
    //      For each file in the array, see if it exists in the destination
    //      directory, and if it does not, then copy it.
    //
    while ( File =  (PFSN_FILE)Iterator->GetNext() ) {

        DebugAssert( !(((PFSNODE)File)->IsDirectory()) );

        Name = File->QueryName();
        if (Name == NULL) {
            DisplayMessageAndExit( REPLACE_ERROR_NO_MEMORY, NULL, EXIT_NO_MEMORY );
            return FALSE;       // help lint
        }

        //
        //      Form the path in the target file
        //
        DestinationPath.AppendBase( Name );

        DELETE( Name );

        //
        //      See if the file exists
        //
        FileToCreate = SYSTEM::QueryFile( &DestinationPath );

        //
        //      If the file does not exist, then it has to be added
        //
        if ( !FileToCreate ) {

            if ( !_PromptSwitch || Prompt( REPLACE_MESSAGE_ADD_YES_NO, &DestinationPath ) ) {

                DisplayMessage( REPLACE_MESSAGE_ADDING, NORMAL_MESSAGE, "%W", DestinationPath.GetPathString() );

                CopyTheFile( File->GetPath(), &DestinationPath );

                _FilesAdded++;
            }

        }

        DELETE( FileToCreate );

        //
        //      Set the destination path back to what it originally was
        //      ( i.e. directory specification, no file ).
        //
        DestinationPath.TruncateBase();

    }
    DELETE( Iterator );

    return TRUE;
}

BOOLEAN
REPLACE::ReplaceFiles (
        IN OUT  PFSN_DIRECTORY  DestinationDirectory
        )
/*++

Routine Description:

        Replaces those files in the DestinationDirectory that match Pattern
        by the corresponding files in SourceDirectory.

Arguments:

        DestinationDirectory    -       Supplies pointer to destination
                                                                directory.

Return Value:

        BOOLEAN -       TRUE if operation successful.
                        FALSE otherwise

Notes:

--*/

{

    PARRAY_ITERATOR     Iterator;
    PFSN_FILE           File;
    PFSN_FILE           FileToReplace;
    PATH                DestinationPath;
    PWSTRING            Name;
    PTIMEINFO           TimeSrc;
    PTIMEINFO           TimeDst;
    BOOLEAN             Proceed = TRUE;

    DebugPtrAssert( DestinationDirectory );
    DebugPtrAssert( _FilesInSrc );

    //
    //      Get destination path
    //
    DestinationPath.Initialize( DestinationDirectory->GetPath() );

    //
    //      Obtain an iterator for going thru the files
    //
    Iterator = ( PARRAY_ITERATOR )_FilesInSrc->QueryIterator( );
    if (Iterator == NULL) {
        DisplayMessageAndExit( REPLACE_ERROR_NO_MEMORY, NULL, EXIT_NO_MEMORY );
        return FALSE;       // help lint
    }

    //
    //      For each file in the array, see if it exists in the destination
    //      directory, and if it does, replace it
    //
    while ( File =  (PFSN_FILE)Iterator->GetNext() ) {

        AbortIfCtrlC();

        DebugAssert( !(((PFSNODE)File)->IsDirectory()) );

        Name = File->QueryName();
        if (Name == NULL) {
            DisplayMessageAndExit( REPLACE_ERROR_NO_MEMORY, NULL, EXIT_NO_MEMORY );
            return FALSE;       // help lint
        }

        //
        //      Form the path in the target file
        //
        DestinationPath.AppendBase( Name );

        DELETE( Name );

        //
        //      See if the file exists
        //
        FileToReplace = SYSTEM::QueryFile( &DestinationPath );


        if ( FileToReplace ) {

            //
            //      If the CompareTime switch is set, then we only proceed if
            //      the destination file is older than the source file.
            //
            if ( _CompareTimeSwitch ) {

                TimeSrc = File->QueryTimeInfo();
                TimeDst = FileToReplace->QueryTimeInfo();

                if (TimeSrc == NULL) {
                    DisplayMessageAndExit( REPLACE_ERROR_NO_MEMORY, NULL, EXIT_NO_MEMORY );
                    return FALSE;       // help lint
                }
                if (TimeDst == NULL) {
                    DisplayMessageAndExit( REPLACE_ERROR_NO_MEMORY, NULL, EXIT_NO_MEMORY );
                    return FALSE;       // help lint
                }

                Proceed = *TimeDst < *TimeSrc;

                DELETE( TimeSrc );
                DELETE( TimeDst );

            }

            if ( Proceed ) {

                //
                //      We replace the file if it is NOT read-only
                //      (unless the ReadOnly switch is set )
                //
                if ( _ReadOnlySwitch || !(FileToReplace->IsReadOnly()) ) {

                    if ( !_PromptSwitch || Prompt( REPLACE_MESSAGE_REPLACE_YES_NO, &DestinationPath ) ) {

                        DisplayMessage( REPLACE_MESSAGE_REPLACING, NORMAL_MESSAGE, "%W", DestinationPath.GetPathString() );

                        //
                        //      If the file is read-only, we reset the read-only attribute
                        //      before copying.
                        //
                        if ( FileToReplace->IsReadOnly() ) {
                            FileToReplace->ResetReadOnlyAttribute();
                        }

                        CopyTheFile( File->GetPath(), &DestinationPath );

                        _FilesReplaced++;
                    }
                } else {

                    //
                    //      The file is read-only but the ReadOnly flag was
                    //      not set, we error out.
                    //
                    DisplayMessageAndExit( REPLACE_ERROR_ACCESS_DENIED,
                                           DestinationPath.GetPathString(),
                                           EXIT_ACCESS_DENIED );
                }
            }
        }

        DELETE( FileToReplace );

        //
        //      Set the destination path back to what it originally was
        //      ( i.e. directory specification, no file name part ).
        //
        DestinationPath.TruncateBase();

    }

    DELETE( Iterator );

    return TRUE;
}

BOOLEAN
REPLACE::Prompt (
        IN      MSGID           MessageId,
        IN      PCPATH          Path
        )

/*++

Routine Description:

        Gets confirmation from the user about a file to be added/replaced

Arguments:

        MessageId       -       Supplies the Id of the message to use for prompting
        Path            -       Supplies path to use as parameter for the message.

Return Value:

        BOOLEAN -       TRUE if the user confirmed the add/replace
                                FALSE otherwise

--*/

{

    DisplayMessage( MessageId, NORMAL_MESSAGE, "%W", Path->GetPathString() );
    return _Message.IsYesResponse();

}

BOOLEAN
REPLACE::CopyTheFile (
        IN      PCPATH          SrcPath,
        IN      PCPATH          DstPath
        )

/*++

Routine Description:

        Copies a file

Arguments:

        SrcPath         -       Supplies path of source file
        DstFile         -       Supplies path of destination file

Return Value:

        BOOLEAN -       TRUE

--*/

{

    ULONG   Size;

    DebugPtrAssert( SrcPath );
    DebugPtrAssert( DstPath );

    //
    //      Make sure that the buffers are big enough to hold the
    //      paths
    //
    Size = (SrcPath->GetPathString()->QueryChCount() + 1) * 2;
    if ( Size > _PathString1Size ) {
    _PathString1 = (LPWSTR)REALLOC( _PathString1, (unsigned int)Size );
            DebugPtrAssert( _PathString1 );
            _PathString1Size = Size;
    }

    Size = (DstPath->GetPathString()->QueryChCount() + 1) * 2;
    if ( Size > _PathString2Size ) {
    _PathString2 = (LPWSTR)REALLOC( _PathString2, (unsigned int)Size );
            DebugPtrAssert( _PathString2 );
            _PathString2Size = Size;
    }

    if ( !_PathString1 || !_PathString2 ) {
            DisplayMessageAndExit( REPLACE_ERROR_NO_MEMORY, NULL, EXIT_NO_MEMORY );

    }

    //
    //  Convert the paths to LPWSTR so that we can call CopyFile()
    //
    SrcPath->GetPathString()->QueryWSTR( 0, TO_END, _PathString1, _PathString1Size/sizeof(WCHAR) );
    DstPath->GetPathString()->QueryWSTR( 0, TO_END, _PathString2, _PathString2Size/sizeof(WCHAR) );

    //
    //      Now do the copy
    //
    if ( !CopyFile( _PathString1, _PathString2, FALSE ) ) {

            ExitWithError( GetLastError() );

    }

    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\runas\dbgdef.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dbgdef.h
//
//  Contents:   Defines for debug exports in crypt32 (crypt32d.lib)
//
//  History:    17-Apr-96   kevinr   created
//              05-Sep-1997 pberkman added subsystem id's
//
//--------------------------------------------------------------------------

#ifndef DBGDEF_H
#define DBGDEF_H

#ifndef _XELIBCA_SRC_
#ifdef __cplusplus
    extern "C" 
    {
#endif
#endif


#if (DBG)

    //--------------------------------------------------------------------------
    // OSS and heap-checking
    //--------------------------------------------------------------------------
#   include <crtdbg.h>

    // To turn on heap checking (the whole nine yards) (slow):
    // set DEBUG_MASK=0x26
    // To only check for leaks:
    // set DEBUG_MASK=0x20

#   ifndef NO_OSS_DEBUG

#       include <asn1code.h>

        // To turn on OSS tracing (all encodes and decodes):
        // set OSS_DEBUG_MASK=0x02
        //
        // To turn on OSS tracing of only decoder errors
        // set OSS_DEBUG_MASK=0x10
        //
        // To send the OSS tracing output to a file:
        // set OSS_DEBUG_TRACEFILE=<filename>

        extern BOOL WINAPI DbgInitOSS( OssGlobal *pog);

#   endif  // NO_OSS_DEBUG

#endif  // DBG


//
//  05-Sep-1997 pberkman:
//
//      DEBUG_PRINT_MASK settings to turn on sub-system debugs
//
#define DBG_SS_CRYPT32                      0x00000001

#define DBG_SS_TRUSTCOMMON                  0x00010000
#define DBG_SS_TRUST                        0x00020000
#define DBG_SS_TRUSTPROV                    0x00040000
#define DBG_SS_SIP                          0x00080000
#define DBG_SS_CATALOG                      0x00100000
#define DBG_SS_SIGNING                      0x00200000
#define DBG_SS_OFFSIGN                      0x00400000
#define DBG_SS_CATDBSVC                     0x00800000

#define DBG_SS_APP                          0x10000000

typedef struct _DBG_SS_TAG
{
    DWORD       dwSS;
    const char  *pszTag;    // 7 characters!

} DBG_SS_TAG;

#define __DBG_SS_TAGS       { \
                                DBG_SS_CRYPT32,     "CRYPT32",  \
                                DBG_SS_TRUSTCOMMON, "PKITRST",  \
                                DBG_SS_TRUST,       "WINTRST",  \
                                DBG_SS_TRUSTPROV,   "SOFTPUB",  \
                                DBG_SS_CATALOG,     "MSCAT32",  \
                                DBG_SS_SIP,         "MSSIP32",  \
                                DBG_SS_SIGNING,     "MSSGN32",  \
                                DBG_SS_OFFSIGN,     "OFFSIGN",  \
                                DBG_SS_APP,         "CONAPPL",  \
                                DBG_SS_CATDBSVC,    "CATDBSV",  \
                                NULL, NULL                      \
                            }

//--------------------------------------------------------------------------
// DBG_TRACE 
//--------------------------------------------------------------------------
#if DBG 

	void DbgPrintf( DWORD dwSubSysId, LPCSTR lpFmt, ...);


#   define DBG_TRACE_EX(argFmt) DbgPrintf argFmt
#   define DBG_TRACE(argFmt)   DBG_TRACE_EX((DBG_SS_CRYPT32,argFmt))

#   define DBG_PRINTF(args)     DbgPrintf args

#else

#   define DBG_TRACE_EX(argFmt)
#   define DBG_TRACE(argFmt)

#   define DBG_PRINTF(args)

#endif  // DBG


//--------------------------------------------------------------------------
// Error-handling 
//--------------------------------------------------------------------------
#ifndef ERROR_RETURN_LABEL
#define ERROR_RETURN_LABEL ErrorReturn
#endif

#define TRACE_ERROR_EX(id,name)                                         \
name##:                                                                 \
    DBG_TRACE_EX((id,"(" #name ":%s,%d)\n", __FILE__, __LINE__));       \
    goto ERROR_RETURN_LABEL;

#define SET_ERROR_EX(id,name,err)                                       \
name##:                                                                 \
    SetLastError( (DWORD)(err));                                        \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": SetLastError " #err "\n", __FILE__, __LINE__)); \
    goto ERROR_RETURN_LABEL;

#define SET_ERROR_VAR_EX(id,name,err)                                   \
name##:                                                                 \
    SetLastError( (DWORD)(err));                                        \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": SetLastError(0x%x)\n", __FILE__, __LINE__, (err))); \
    goto ERROR_RETURN_LABEL;

#define SET_HRESULT_EX(id,name,err)                                     \
name##:                                                                 \
    hr = (HRESULT) (err);                                               \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": hr = " #err "\n", __FILE__, __LINE__)); \
    goto ERROR_RETURN_LABEL;

#define SET_HRESULT_VAR_EX(id,name,err)                                 \
name##:                                                                 \
    hr = (HRESULT) (err);                                               \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": hr = 0x%x\n" , __FILE__, __LINE__, (hr))); \
    goto ERROR_RETURN_LABEL;

#define TRACE_HRESULT_EX(id,name)                                       \
name##:                                                                 \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": hr = 0x%x\n", __FILE__, __LINE__, (hr))); \
    goto ERROR_RETURN_LABEL;

#define SET_DWRESULT_EX(id,name,err)                                     \
name##:                                                                 \
    dwResult = (DWORD) (err);                                               \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": hr = " #err "\n", __FILE__, __LINE__)); \
    goto ERROR_RETURN_LABEL;

#define TRACE_ERROR(name)               TRACE_ERROR_EX(DBG_SS_CRYPT32,name)
#define SET_ERROR(name,err)             SET_ERROR_EX(DBG_SS_CRYPT32,name,err)
#define SET_ERROR_VAR(name,err)         SET_ERROR_VAR_EX(DBG_SS_CRYPT32,name,err)
#define SET_HRESULT(name,err)           SET_HRESULT_EX(DBG_SS_CRYPT32,name,err)
#define SET_HRESULT_VAR(name,err)       SET_HRESULT_VAR_EX(DBG_SS_CRYPT32,name,err)
#define TRACE_HRESULT(name)             TRACE_HRESULT_EX(DBG_SS_CRYPT32,name)
#define SET_DWRESULT(name,err)          SET_DWRESULT_EX(DBG_SS_CRYPT32,name,err)


#define _JumpCondition(condition, label) \
    if (condition) \
    { \
	goto label; \
    } \
    else { } 

#define _JumpConditionWithExpr(condition, label, expr) \
    if (condition) \
    { \
        expr; \
	goto label; \
    } \
    else { } 

#define _JumpConditionWithPrint(condition, label, ids) \
    if (condition) \
    { \
        LocalizedWPrintf(ids); \
	goto label; \
    } \
    else { } 


#ifndef _XELIBCA_SRC_
#ifdef __cplusplus
    }       // balance of extern "C"
#endif
#endif

#endif // DBGDEF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\runas\rmtcred.h ===
#ifndef _RMTCRED_
#define _RMTCRED_

#ifndef SECURITY_WIN32
#define SECURITY_WIN32
#endif

#include    "sspi.h"
#include    "rpc.h"

#ifdef __cplusplus
extern "C" {
#endif

BOOL
WINAPI
SetProcessDefaultCredentials(
    HANDLE  hProcess,
    LPWSTR  lpPrincipal,
    LPWSTR  lpPackage,
    ULONG   fCredentials,
    PVOID   LogonID,                // must be NULL for this release.
    PVOID   pvAuthData,
    SEC_GET_KEY_FN  fnGetKey,       // must be NULL for this release.
    PVOID   pvGetKeyArg             // must be NULL for this release.
    );

#ifdef __cplusplus
}
#endif

#endif // _RMTCRED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\runas\runas.cpp ===
/*+
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1997 - 2000.
 *
 * Name : runas.cxx
 * Author:Jeffrey Richter (v-jeffrr)
 *
 * Abstract:
 * This is the RUNAS tool. It uses CreateProcessWithLogon API
 * to start processes under different security context than the
 * currently logged on user.
 *
 * Revision History:
 * PraeritG    10/8/97  To integrate this in to services.exe
 *
-*/

#define STRICT
#define UNICODE   1
#include <Windows.h>
#include <shellapi.h>
#include <stdarg.h>
#include <stdio.h>
#include <winsafer.h>
#include <wincred.h>
#include <lmcons.h>
#include <netlib.h>

#ifndef SECURITY_WIN32
#define SECURITY_WIN32
#endif

#include <security.h>

#include "dbgdef.h"
#include "stringid.h"
#include "rmtcred.h"
#include "utils.h"
#include "RunasMsg.h"

// Helper macros:
#define ARRAYSIZE(a)       ((sizeof(a))/(sizeof(a[0])))
#define FIELDOFFSET(s,m)   (size_t)&(((s *)0)->m)

#define PSAD_NULL_DATA     (-1)
#define PSAD_STRING_DATA   (-2)
#define PSAD_NO_MORE_DATA  (-1)

//
// must move to winbase.h soon!
#define LOGON_WITH_PROFILE              0x00000001
#define LOGON_NETCREDENTIALS_ONLY       0x00000002

// NT Process exit codes:
#define EXIT_CODE_SUCCEEDED 0
#define EXIT_CODE_FAILED    1

// Credential flags:
#define RUNAS_USE_SMARTCARD  0x00000001
#define RUNAS_USE_SAVEDCREDS 0x00000002
#define RUNAS_SAVE_CREDS     0x00000004

// Argument IDs for command line parsing:
enum ArgId {
    AI_ENV = 0,
    AI_NETONLY,
    AI_NOPROFILE,
    AI_PROFILE,
    AI_TRUSTLEVEL,
    AI_USER,
    AI_SMARTCARD,
    AI_SHOWTRUSTLEVELS,
    AI_SAVECRED
} ArgId;

BOOL rgArgCompat[9][9] =
{
    // ENV     NETONLY   NOPROFILE   PROFILE   TRUSTLEVEL   USER    SMARTCARD  SHOWTRUSTLEVELS  SAVECRED
    {  FALSE,  TRUE,     TRUE,       TRUE,     FALSE,       TRUE,   TRUE,      FALSE,           TRUE },   // ENV
    {  TRUE,   FALSE,    TRUE,       FALSE,    FALSE,       TRUE,   TRUE,      FALSE,           TRUE },   // NETONLY
    {  TRUE,   TRUE,     FALSE,      FALSE,    FALSE,       TRUE,   TRUE,      FALSE,           TRUE },   // NOPROFILE
    {  TRUE,   FALSE,    FALSE,      FALSE,    FALSE,       TRUE,   TRUE,      FALSE,           TRUE  },  // PROFILE
    {  FALSE,  FALSE,    FALSE,      FALSE,    FALSE,       FALSE,  FALSE,     FALSE,           FALSE },  // TRUSTLEVEL
    {  TRUE,   TRUE,     TRUE,       TRUE,     FALSE,       FALSE,  TRUE,      FALSE,           TRUE },   // USER
    {  TRUE,   TRUE,     TRUE,       TRUE,     FALSE,       TRUE,   FALSE,     FALSE,           TRUE },   // SMARTCARD
    {  FALSE,  FALSE,    FALSE,      FALSE,    FALSE,       FALSE,  FALSE,     FALSE,           FALSE },  // SHOWTRUSTLEVELS
    {  TRUE,   TRUE,     TRUE,       TRUE,     FALSE,       TRUE,   TRUE,      FALSE,           FALSE }   // SAVECRED
};

#define _CheckArgCompat(args, n, ai) \
    { \
        for (int _i = 0; _i < (n); _i++) { \
            if (FALSE == rgArgCompat[(ai)][(args)[_i]]) { \
                RunasPrintHelp(); \
                return (EXIT_CODE_FAILED); \
            } \
        } \
        (args)[(n)] = (ai); \
    }

HMODULE   hMod       = NULL;
HANDLE    g_hStdout  = NULL;

void DbgPrintf( DWORD dwSubSysId, LPCSTR pszFormat , ...)
{
    va_list args;
    CHAR    pszBuffer[1024];

    va_start(args, pszFormat);
    _vsnprintf(pszBuffer, 1024, pszFormat, args);
    va_end(args);

    OutputDebugStringA(pszBuffer); 
}

HRESULT InitializeConsoleOutput() {
    g_hStdout = GetStdHandle(STD_OUTPUT_HANDLE);
    if (INVALID_HANDLE_VALUE == g_hStdout) {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    return S_OK;
}

HRESULT LocalizedWPrintf(UINT nResourceID) {
    DWORD   ccWritten;
    DWORD   dwRetval;
    HRESULT hr;
    WCHAR   rgwszString[512];

    dwRetval = LoadStringW(hMod, nResourceID, rgwszString, ARRAYSIZE(rgwszString));
    if (0 == dwRetval) {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    if (!WriteConsoleW(g_hStdout, rgwszString, wcslen(rgwszString), &ccWritten, NULL)) {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    return S_OK;
}

HRESULT LocalizedWPrintf2(UINT nResourceID, LPWSTR pwszFormat, ...) {
    DWORD   ccWritten;
    va_list args;
    WCHAR   pwszBuffer[1024];

    HRESULT hr = LocalizedWPrintf(nResourceID);
    if (S_OK != hr) {
        return hr;
    }

    va_start(args, pwszFormat);
    _vsnwprintf(pwszBuffer, ARRAYSIZE(pwszBuffer), pwszFormat, args);
    va_end(args);

    if (!WriteConsoleW(g_hStdout, pwszBuffer, wcslen(pwszBuffer), &ccWritten, NULL)) {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    return S_OK;
}

// Same as LocalizedWPrintf, but adds a carriage return.
HRESULT LocalizedWPrintfCR(UINT nResourceID) {
    HRESULT hr = LocalizedWPrintf(nResourceID);
    wprintf(L"\n");
    return hr;
}

DWORD MyGetLastError() { 
    DWORD dwResult = GetLastError(); 

    if (ERROR_SUCCESS == dwResult) { 
        dwResult = E_FAIL; 
    }

    return dwResult; 
}

VOID
DisplayMsg(DWORD dwSource, DWORD dwMsgId, ... )
{
    DWORD    dwBytesWritten;
    DWORD    dwLen;
    LPWSTR   pwszDisplayBuffer  = NULL;
    va_list  ap;

    va_start(ap, dwMsgId);

    dwLen = FormatMessageW(dwSource | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                           NULL, 
                           dwMsgId, 
                           MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                           (LPWSTR)&pwszDisplayBuffer, 
                           0, 
                           &ap);

    if (dwLen && pwszDisplayBuffer) {
        WriteConsoleW(g_hStdout, 
                      (LPVOID)pwszDisplayBuffer, 
                      dwLen,
                      &dwBytesWritten, 
                      NULL);
    }

    if (NULL != pwszDisplayBuffer) { LocalFree(pwszDisplayBuffer); }

    va_end(ap);
}

BOOL WriteMsg(DWORD dwSource, DWORD dwMsgId, LPWSTR *ppMsg, ...)
{
    DWORD    dwBytesWritten;
    DWORD    dwLen;
    LPWSTR   pwszDisplayBuffer = NULL;
    va_list  ap;

    va_start(ap, ppMsg);

    dwLen = FormatMessageW(dwSource | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                           NULL, 
                           dwMsgId, 
                           MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                           (LPWSTR)ppMsg, 
                           0, 
                           &ap);
    va_end(ap);

    // 0 is the error return value of FormatMessage.  
    return (0 != dwLen);
}

DWORD GetCredentials
(IN      DWORD  dwCredFlags,
 IN OUT  LPWSTR pwszPassword,
 IN      DWORD  ccPasswordChars,
 IN OUT  LPWSTR pwszUserName,
 IN      DWORD  ccUserNameChars,
 IN OUT  LPWSTR pwszUserDisplayName,
 IN      DWORD  ccUserDisplayNameChars,
 IN OUT  LPWSTR pwszTarget,
 IN      DWORD  ccTarget)
{
    BOOL     fResult;
    DWORD    dwCreduiCmdlineFlags   = 0;
    DWORD    dwResult;
    LPWSTR   pwszAccountDomainName  = NULL;
    LPWSTR   pwszMarshalledCred     = NULL;

    if (RUNAS_USE_SAVEDCREDS & dwCredFlags) {
	if (NULL == wcschr(pwszUserName, L'\\') && NULL == wcschr(pwszUserName, L'@')) { 
	    // We have a username in relative form.  Try to prepend the machine name (for workstations) or domain name (for DCs). 
	    pwszAccountDomainName = GetAccountDomainName(); 
	    _JumpCondition(NULL == pwszAccountDomainName, GetAccountDomainNameError); 
	
	    // Do we have enough space for the new target name?
	    _JumpCondition(ccUserNameChars <= wcslen(pwszAccountDomainName) + wcslen(L"\\") + wcslen(pwszUserName) + 1, InsufficientBufferErr); 

	    // pwszUserName -->  pwszAccountDomainName\pwszUserName
	    memmove(pwszUserName+(wcslen(pwszAccountDomainName)+1), pwszUserName, sizeof(WCHAR)*wcslen(pwszUserName)); 
	    wcscpy(pwszUserName, pwszAccountDomainName); 
	    pwszUserName[wcslen(pwszAccountDomainName)] = L'\\'; 
	}

        USERNAME_TARGET_CREDENTIAL_INFO utci = { pwszUserName };

        // Get the marshalled credential from credman.
        fResult = CredMarshalCredentialW(UsernameTargetCredential, &utci, &pwszMarshalledCred);
        _JumpCondition(FALSE == fResult, CredMarshalCredentialWError);

        // Ensure we have a large enough buffer to copy the cred to.
        _JumpCondition(ccUserNameChars <= (wcslen(pwszMarshalledCred) + 1), InsufficientBufferErr);
        _JumpCondition(ccUserDisplayNameChars <= (wcslen(pwszUserName) + 1), InsufficientBufferErr);

        // User the user-supplied name as the display name.
        wcscpy(pwszUserDisplayName, pwszUserName);

        // Copy the marshalled cred to the user name.  We use an empty
        // passwd with the marshalled cred.
        wcscpy(pwszUserName, pwszMarshalledCred);
    }
    else {
        dwCreduiCmdlineFlags =
            CREDUI_FLAGS_USERNAME_TARGET_CREDENTIALS // These are 'runas' credentials
            | CREDUI_FLAGS_VALIDATE_USERNAME;   // Ensure that the username syntax is correct

        if (RUNAS_USE_SMARTCARD & dwCredFlags) {
            dwCreduiCmdlineFlags |= CREDUI_FLAGS_REQUIRE_SMARTCARD;

            fResult = LoadStringW(hMod, RUNASP_STRING_SMARTCARDUSER, pwszTarget, ccTarget);
            _JumpCondition(FALSE == fResult, LoadStringError);
        }
        else {
            dwCreduiCmdlineFlags |= CREDUI_FLAGS_EXCLUDE_CERTIFICATES; // we don't (yet) know how to handle certificates
            // Target buffer must be large enough to store entire username.
            _JumpCondition(ccTarget < ccUserNameChars, InsufficientBufferErr);
            wcscpy(pwszTarget, pwszUserName);
        }

        if (RUNAS_SAVE_CREDS & dwCredFlags) {
            dwCreduiCmdlineFlags |=
                CREDUI_FLAGS_PERSIST                 // persist creds automatically
                | CREDUI_FLAGS_EXPECT_CONFIRMATION;  // Don't store bogus creds into credman.
        } else {
            dwCreduiCmdlineFlags |=
                CREDUI_FLAGS_DO_NOT_PERSIST;    // Do not persist the creds
        }

        dwResult = CredUICmdLinePromptForCredentialsW
            (pwszTarget,
             NULL,
             NO_ERROR,
             pwszUserName,
             ccUserNameChars,
             pwszPassword,
             ccPasswordChars,
             NULL,
             dwCreduiCmdlineFlags);
        _JumpCondition(ERROR_SUCCESS != dwResult, CredUICmdLineGetPasswordError);

        if (RUNAS_USE_SMARTCARD & dwCredFlags) {
            // Smartcard creds are not human-readable.  Get a display name:
            fResult = CreduiGetCertDisplayNameFromMarshaledName
                (pwszUserName,
                 pwszUserDisplayName,
                 ccUserDisplayNameChars,
                 FALSE);
            _JumpCondition(FALSE == fResult, CreduiGetCertDisplayNameFromMarshaledNameError);
        }
        else {
            _JumpCondition(ccUserDisplayNameChars <= wcslen(pwszUserName), InsufficientBufferErr);
            wcscpy(pwszUserDisplayName, pwszUserName);
        }
    }

    dwResult = ERROR_SUCCESS;
 ErrorReturn:
    if (NULL != pwszAccountDomainName) { NetApiBufferFree(pwszAccountDomainName); }
    return dwResult;


SET_DWRESULT(CredMarshalCredentialWError,                     GetLastError());
SET_DWRESULT(CredUICmdLineGetPasswordError,                   dwResult);
SET_DWRESULT(CreduiGetCertDisplayNameFromMarshaledNameError,  GetLastError());
SET_DWRESULT(GetAccountDomainNameError,                       GetLastError());
SET_DWRESULT(InsufficientBufferErr,                           ERROR_INSUFFICIENT_BUFFER);
SET_DWRESULT(LoadStringError,                                 GetLastError());
}

DWORD SaveCredentials
(IN  LPWSTR pwszTarget,
 IN  BOOL   fSave)
{
    return CredUIConfirmCredentialsW(pwszTarget, fSave);
}

BOOL GetTitle
(IN   LPWSTR  pwszAppName,
 IN   LPWSTR  pwszUserName,
 IN   BOOL    fRestricted,
 IN   LPWSTR  pwszAuthzLevel,
 OUT  LPWSTR *ppwszTitle)
{
    DWORD dwMsgId = fRestricted ? RUNASP_STRING_TITLE_WITH_RESTRICTED : RUNASP_STRING_TITLE;

    return WriteMsg(FORMAT_MESSAGE_FROM_HMODULE, 
                    dwMsgId, 
                    ppwszTitle, 
                    pwszAppName, 
                    pwszUserName, 
                    pwszAuthzLevel); 
}

// Creates the process with a given "privilege level".
//
// dwAuthzLevel -- specifies the authorization level ID to create the
//                 process with.  Can be one of the following values:
//
//     SAFER_LEVELID_FULLYTRUSTED
//     SAFER_LEVELID_NORMALUSER
//     SAFER_LEVELID_CONSTRAINED
//     SAFER_LEVELID_UNTRUSTED
//
BOOL CreateProcessRestricted
(IN   DWORD                 dwAuthzLevel,
 IN   LPCWSTR               pwszAppName,
 IN   LPWSTR                pwszCmdLine,
 IN   LPWSTR                pwszCurrentDirectory,
 IN   LPSTARTUPINFO         si,
 OUT  PROCESS_INFORMATION  *pi)
{
    BOOL               fResult          = FALSE;
    DWORD              dwCreationFlags  = 0;
    SAFER_LEVEL_HANDLE hAuthzLevel      = NULL;
    HANDLE             hToken           = NULL;

    // Maintain old runas behavior:  console apps run in a new console.
    dwCreationFlags |= CREATE_NEW_CONSOLE;

    fResult = SaferCreateLevel
        (SAFER_SCOPEID_MACHINE,
         dwAuthzLevel,
         SAFER_LEVEL_OPEN,
         &hAuthzLevel,
         NULL);
    _JumpCondition(FALSE == fResult, error);

    // Generate the restricted token that we will use.
    fResult = SaferComputeTokenFromLevel
        (hAuthzLevel,
         NULL,                  // source token
         &hToken,               // target token
         SAFER_TOKEN_MAKE_INERT, // runas should run with the inert flag
         NULL);                 // reserved
    _JumpCondition(FALSE == fResult, error);

    // Launch the child process under the context of the restricted token.
    fResult = CreateProcessAsUser
        (hToken,                  // token representing the user
         pwszAppName,             // name of executable module
         pwszCmdLine,             // command-line string
         NULL,                    // process security attributes
         NULL,                    // thread security attributes
         FALSE,                   // if process inherits handles
         dwCreationFlags,         // creation flags
         NULL,                    // new environment block
         pwszCurrentDirectory,    // current directory name
         si,                      // startup information
         pi                       // process information
         );


    // success.
 error:
    if (NULL != hAuthzLevel) { SaferCloseLevel(hAuthzLevel); }
    if (NULL != hToken)      { CloseHandle(hToken); }

    return fResult;
}

DWORD FriendlyNameToTrustLevelID(LPWSTR  pwszFriendlyName,
                                 DWORD  *pdwTrustLevelID)
{
    BOOL               fResult;
    DWORD              cbSize;
    DWORD              ccWritten;
    DWORD              dwResult;
    DWORD              dwNumLevels;
    DWORD             *pdwLevelIDs                     = NULL;
    SAFER_LEVEL_HANDLE hAuthzLevel                 = NULL;
    WCHAR              wszLevelName[1024];
    DWORD              dwBufferSize = 0;

    fResult = SaferGetPolicyInformation
        (SAFER_SCOPEID_MACHINE,
         SaferPolicyLevelList,
         0,
         NULL,
         &cbSize,
         NULL);
    _JumpCondition(FALSE == fResult && ERROR_INSUFFICIENT_BUFFER != GetLastError(), GetInformationCodeAuthzPolicyWError);

    dwNumLevels = cbSize / sizeof(DWORD);
    pdwLevelIDs = (DWORD *)HeapAlloc(GetProcessHeap(), 0, cbSize);
    _JumpCondition(NULL == pdwLevelIDs, MemoryError);

    fResult = SaferGetPolicyInformation
        (SAFER_SCOPEID_MACHINE,
         SaferPolicyLevelList,
         cbSize,
         pdwLevelIDs,
         &cbSize,
         NULL);
    _JumpCondition(FALSE == fResult, GetInformationCodeAuthzPolicyWError);

    // Try each trust level, and return the one that matches the trust level
    // passed as a parameter:
    for (DWORD dwIndex = 0; dwIndex < dwNumLevels; dwIndex++)
    {
        if (SaferCreateLevel
            (SAFER_SCOPEID_MACHINE,
             pdwLevelIDs[dwIndex],
             SAFER_LEVEL_OPEN,
             &hAuthzLevel,
             NULL))
        {
            if (SaferGetLevelInformation
                (hAuthzLevel,
                 SaferObjectFriendlyName,
                 wszLevelName,
                 sizeof(wszLevelName) / sizeof(wszLevelName[0]),
                 &dwBufferSize))
            {
                if (0 == _wcsicmp(pwszFriendlyName, wszLevelName))
                {
                    // We've found the specified trust level.
                    *pdwTrustLevelID = pdwLevelIDs[dwIndex];
                    SaferCloseLevel(hAuthzLevel);
                    dwResult = ERROR_SUCCESS;
                    goto ErrorReturn;
                }
            }
            SaferCloseLevel(hAuthzLevel);
        }
    }

    // The specified level ID is not in the enumeration.
    dwResult = ERROR_NOT_FOUND;
 ErrorReturn:
    if (NULL != pdwLevelIDs) { HeapFree(GetProcessHeap(), 0, pdwLevelIDs); }
    return dwResult;

SET_DWRESULT(GetInformationCodeAuthzPolicyWError,  GetLastError());
SET_DWRESULT(MemoryError,                          ERROR_NOT_ENOUGH_MEMORY);

}

DWORD IntermediateSaferLevelsAreEnabled(BOOL *pfResult) 
{
    BOOL    fResult; 
    DWORD   cbSize; 
    DWORD   dwNumLevels; 
    DWORD   dwResult; 

    fResult = SaferGetPolicyInformation 
        (SAFER_SCOPEID_MACHINE, 
         SaferPolicyLevelList,
         0, 
         NULL, 
         &cbSize, 
         NULL); 
    _JumpCondition(!fResult && ERROR_INSUFFICIENT_BUFFER != GetLastError(), SaferGetPolicyInformationError); 

    dwNumLevels = cbSize / sizeof(DWORD); 
    // If there are more than two levels available, we know that intermediate
    // safer levels have been enabled. 
    fResult = dwNumLevels > 2; 

    *pfResult = fResult; 
    dwResult = ERROR_SUCCESS;
 ErrorReturn:
    return dwResult; 

SET_DWRESULT(SaferGetPolicyInformationError, GetLastError()); 
}

DWORD
ShowTrustLevels(VOID)
{
    BOOL               fResult;
    DWORD              cbSize;
    DWORD              ccWritten;
    DWORD              dwResult;
    DWORD              dwNumLevels;
    DWORD             *pdwLevelIDs                     = NULL;
    SAFER_LEVEL_HANDLE hAuthzLevel                     = NULL;
    WCHAR              wszLevelName[1024];
    DWORD              dwBufferSize = 0;

    // Print header:
    LocalizedWPrintf(RUNASP_STRING_TRUSTLEVELS);

    // Print trust levels:
    fResult = SaferGetPolicyInformation
        (SAFER_SCOPEID_MACHINE,
         SaferPolicyLevelList,
         0,
         NULL,
         &cbSize,
         NULL);
    _JumpCondition(FALSE == fResult && ERROR_INSUFFICIENT_BUFFER != GetLastError(), GetInformationCodeAuthzPolicyWError);

    dwNumLevels = cbSize / sizeof(DWORD);
    pdwLevelIDs = (DWORD *)HeapAlloc(GetProcessHeap(), 0, cbSize);
    _JumpCondition(NULL == pdwLevelIDs, MemoryError);

    fResult = SaferGetPolicyInformation
        (SAFER_SCOPEID_MACHINE,
         SaferPolicyLevelList,
         cbSize,
         pdwLevelIDs,
         &cbSize,
         NULL);
    _JumpCondition(FALSE == fResult, GetInformationCodeAuthzPolicyWError);

    for (DWORD dwIndex = 0; dwIndex < dwNumLevels; dwIndex++)
    {
        // Give our best effort to enumerate each trust level:
        if (SaferCreateLevel
            (SAFER_SCOPEID_MACHINE,
             pdwLevelIDs[dwIndex],
             SAFER_LEVEL_OPEN,
             &hAuthzLevel,
             NULL))
        {
            if (SaferGetLevelInformation
                (hAuthzLevel,
                 SaferObjectFriendlyName,
                 wszLevelName,
                 sizeof(wszLevelName) / sizeof(wszLevelName[0]),
                 &dwBufferSize))
            {
                WriteConsoleW(g_hStdout, wszLevelName, wcslen(wszLevelName), &ccWritten, NULL);
                WriteConsoleW(g_hStdout, L"\n", 1, &ccWritten, NULL);
            }
            SaferCloseLevel(hAuthzLevel);
        }
    }

    dwResult = ERROR_SUCCESS;
 ErrorReturn:
    if (NULL != pdwLevelIDs) { HeapFree(GetProcessHeap(), 0, pdwLevelIDs); }
    return dwResult;

SET_DWRESULT(GetInformationCodeAuthzPolicyWError,  GetLastError());
SET_DWRESULT(MemoryError,                          ERROR_NOT_ENOUGH_MEMORY);
}


VOID
RunasPrintHelp(VOID)
{
    UINT rgText[] = {
        RUNASP_STRING_HELP_LINE1,       RUNASP_STRING_HELP_LINE2,
        RUNASP_STRING_HELP_LINE3,       RUNASP_STRING_HELP_LINE4,
        RUNASP_STRING_HELP_LINE5,       RUNASP_STRING_SAFER_HELP_LINE1,
        RUNASP_STRING_HELP_LINE7,       RUNASP_STRING_HELP_LINE8,
        RUNASP_STRING_HELP_LINE9,       RUNASP_STRING_HELP_LINE10,
        RUNASP_STRING_HELP_LINE11,      RUNASP_STRING_HELP_LINE12,
        RUNASP_STRING_HELP_LINE13,      RUNASP_STRING_HELP_LINE14,
        RUNASP_STRING_HELP_LINE15,      RUNASP_STRING_HELP_LINE16,
        RUNASP_STRING_HELP_LINE17,      RUNASP_STRING_HELP_LINE18,
        RUNASP_STRING_HELP_LINE19,      RUNASP_STRING_HELP_LINE20, 
	RUNASP_STRING_SAFER_HELP_LINE2, RUNASP_STRING_SAFER_HELP_LINE3, 
	RUNASP_STRING_SAFER_HELP_LINE4, RUNASP_STRING_SAFER_HELP_LINE5,
        RUNASP_STRING_HELP_LINE25,      RUNASP_STRING_HELP_LINE26,
        RUNASP_STRING_HELP_LINE27,      RUNASP_STRING_HELP_LINE28,
        RUNASP_STRING_HELP_LINE29,      RUNASP_STRING_HELP_LINE30,
        RUNASP_STRING_HELP_LINE31,      RUNASP_STRING_HELP_LINE32
    };


    BOOL fShowSaferHelp; 

    if (ERROR_SUCCESS != IntermediateSaferLevelsAreEnabled(&fShowSaferHelp)) { 
        fShowSaferHelp = FALSE; 
    }

    for (DWORD dwIndex = 0; dwIndex < ARRAYSIZE(rgText); dwIndex++) {
        BOOL fPrintLine = TRUE;

        switch (rgText[dwIndex]) 
        {
        case RUNASP_STRING_SAFER_HELP_LINE1:
        case RUNASP_STRING_SAFER_HELP_LINE2:
        case RUNASP_STRING_SAFER_HELP_LINE3:
        case RUNASP_STRING_SAFER_HELP_LINE4:
        case RUNASP_STRING_SAFER_HELP_LINE5:
            fPrintLine = fShowSaferHelp; 
            break; 
        default:
	  ;
        }
       
        if (fPrintLine) 
            LocalizedWPrintf(rgText[dwIndex]);
    }
}

int WINAPI
WinMain(
        HINSTANCE hinstExe,
        HINSTANCE hinstExePrev,
        LPSTR pszCmdLine,
        int nCmdShow)
{

   HWINSTA  Winsta;
   HDESK    Desk;
   WCHAR   WinstaName[MAX_PATH];
   WCHAR   DeskName[MAX_PATH];
   WCHAR   DesktopName[MAX_PATH];
   DWORD   Length;
   DWORD   dwAuthzLevel;
   DWORD   dwResult = 0;
   DWORD   Logonflags = 0;
   DWORD   flags = 0;
   BOOL    fOk;
   BOOL    UseCurrentEnvironment = FALSE;
   BOOL    UseNetOnly = FALSE;
   BOOL    fCreateProcessRestricted = FALSE;
   BOOL    fSuppliedAppName = FALSE; 
   BOOL    fSuppliedUserName = FALSE;
   BOOL    fCredMan = FALSE;
#if DBG
   BOOL    fSuppliedPassword = FALSE;
#endif // DBG

   DWORD   dwCredFlags       = 0;
   LPVOID  Environment       = NULL;
   LPWSTR  pwszCurrentDir    = NULL;
   LPWSTR  pwszArgvUserName  = NULL; 
   LPWSTR  pwszTitle         = NULL;;

   WCHAR   pwszAuthzLevel[MAX_PATH];
   WCHAR   pwszDomainName[MAX_PATH];
   WCHAR   pwszUserDisplayName[CREDUI_MAX_USERNAME_LENGTH];
   WCHAR   pwszUserName[CREDUI_MAX_USERNAME_LENGTH];
   WCHAR   pwszPassword[CREDUI_MAX_PASSWORD_LENGTH];
   WCHAR   pwszTarget[CREDUI_MAX_USERNAME_LENGTH]; 
   
   int    i;

   DWORD rgdwArgs[ARRAYSIZE(rgArgCompat)];

   int nNumArgs;

   memset(&pwszAuthzLevel[0],      0, sizeof(pwszAuthzLevel));
   memset(&pwszDomainName[0],      0, sizeof(pwszDomainName));
   memset(&pwszUserDisplayName[0], 0, sizeof(pwszUserDisplayName));
   memset(&pwszUserName[0],        0, sizeof(pwszUserName));
   memset(&pwszPassword[0],        0, sizeof(pwszPassword));

   hMod = (HMODULE)hinstExe;

   if (S_OK != (dwResult = InitializeConsoleOutput()))
   {
       DisplayMsg(FORMAT_MESSAGE_FROM_HMODULE, RUNASP_STRING_ERROR_INTERNAL, dwResult);
       return (EXIT_CODE_FAILED);
   }

   LPWSTR* pszArgv = CommandLineToArgvW(GetCommandLineW(), &nNumArgs);

   if (pszArgv == NULL) {
       DisplayMsg(FORMAT_MESSAGE_FROM_HMODULE, RUNASP_STRING_ERROR_INTERNAL, MyGetLastError()); 
       return (EXIT_CODE_FAILED);
   }

   // Logging on with profile is now the default:
   Logonflags |= LOGON_WITH_PROFILE;

   for(i=1;i<nNumArgs;i++)
   {
       if(pszArgv[i][0] != L'/')
       {
           if (i == nNumArgs-1)
           {
               fSuppliedAppName = TRUE; 
               break;
           }
           else
           {
               RunasPrintHelp();
               return(EXIT_CODE_FAILED);
           }
       }

        switch(pszArgv[i][1])
        {
#if DBG
            case L'z':
            case L'Z':
            {
                LPWSTR  str = &(pszArgv[i][2]);
                while(*str != L':')
                {
                    if(*str == L'\0')
                    {
                        RunasPrintHelp();
                        return(EXIT_CODE_FAILED);
                    }
                    str++;
                }
                str++;

                wcscpy(pwszPassword, str);
                fSuppliedPassword = TRUE;
                break;
            }
#endif // DBG
            case L'p':
            case L'P': // "/profile" argument
                _CheckArgCompat(rgdwArgs, i-1, AI_PROFILE);
                break;

            case L'e':
            case L'E': // "/env" argument
            {
                _CheckArgCompat(rgdwArgs, i-1, AI_ENV);
                UseCurrentEnvironment = TRUE;
                break;
            }
            case L'n':
            case L'N':
            {
                switch (pszArgv[i][2])
                {
                    case 'e':
                    case 'E': // "/netonly" argument
                        _CheckArgCompat(rgdwArgs, i-1, AI_NETONLY);
                        UseNetOnly = TRUE;
                        Logonflags  |= LOGON_NETCREDENTIALS_ONLY;
                        Logonflags  &= ~LOGON_WITH_PROFILE;
                        break;

                    case 'o':
                    case 'O': // "/noprofile" argument
                        _CheckArgCompat(rgdwArgs, i-1, AI_NOPROFILE);
                        Logonflags &= ~LOGON_WITH_PROFILE;
                        break;

                    default:
                        RunasPrintHelp();
                        return (EXIT_CODE_FAILED);
                }

                break;
            }

            case L's':
            case L'S': // "/smartcard" argument
            {
                switch (pszArgv[i][2])
                {
                case 'a':
                case 'A':
                    _CheckArgCompat(rgdwArgs, i-1, AI_SAVECRED);
                    dwCredFlags |= RUNAS_USE_SAVEDCREDS;
                    fCredMan = TRUE;
                    break;
                case 'm':
                case 'M':
                    _CheckArgCompat(rgdwArgs, i-1, AI_SMARTCARD);
                    dwCredFlags |= RUNAS_USE_SMARTCARD;
                    break;
                case 'h':
                case 'H':
                    _CheckArgCompat(rgdwArgs, i-1, AI_SHOWTRUSTLEVELS);
                    ShowTrustLevels();
                    return (EXIT_CODE_SUCCEEDED);
                }
                break ;
            }
            case L't':
            case L'T': // "/trustlevel" argument
            {
                _CheckArgCompat(rgdwArgs, i-1, AI_TRUSTLEVEL);

                LPWSTR  str = &(pszArgv[i][2]);
                while (*str != L':')
                {
                    if (*str == L'\0')
                    {
                        RunasPrintHelp();
                        return (EXIT_CODE_FAILED);
                    }
                    str++;
                }
                str++;

                if (ERROR_SUCCESS != FriendlyNameToTrustLevelID(str, &dwAuthzLevel))
                {
                    ShowTrustLevels();
                    return (EXIT_CODE_FAILED);
                }

                // Ensure that we don't overrun our buffer: 
                if (wcslen(str) >= ARRAYSIZE(pwszAuthzLevel))
                {
                    DisplayMsg(FORMAT_MESSAGE_FROM_HMODULE, RUNASP_STRING_ERROR_ARG_TOO_LONG, pwszAuthzLevel); 
                    return (EXIT_CODE_FAILED); 
                }

                wcscpy(&pwszAuthzLevel[0], str); 
                fCreateProcessRestricted = TRUE;
                break;
            }

            case L'u':
            case L'U': // "/user" argument
            {
                _CheckArgCompat(rgdwArgs, i-1, AI_USER);
                LPWSTR  str = &(pszArgv[i][2]);
                while(*str != L':')
                {
                    if(*str == L'\0')
                    {
                        RunasPrintHelp();
                        return(EXIT_CODE_FAILED);
                    }
                    str++;
                }
                str++;

                if (CRED_MAX_USERNAME_LENGTH <= wcslen(str))
                {
                    LocalizedWPrintf(RUNASP_STRING_ERROR_USERNAME);
                    return (EXIT_CODE_FAILED);
                }

                // Ensure that we don't overrun our buffer: 
                if (wcslen(str) >= ARRAYSIZE(pwszUserName))
                {
                    DisplayMsg(FORMAT_MESSAGE_FROM_HMODULE, RUNASP_STRING_ERROR_ARG_TOO_LONG, str); 
                    return (EXIT_CODE_FAILED); 
                }
                wcscpy(pwszUserName, str); 
                pwszArgvUserName = str; // Save the supplied username in case we need to restore it. 
                fSuppliedUserName = TRUE;
                break;
            }

            default:
                  RunasPrintHelp();
                  return(EXIT_CODE_FAILED);
        }
   }



   // The command line must specify:
   // 1) an application to run 
   // 2) either a username, a trustlevel, or a smartcard option
   if(FALSE == fSuppliedAppName || 
      (FALSE == fSuppliedUserName && FALSE == fCreateProcessRestricted && 0 == (RUNAS_USE_SMARTCARD & dwCredFlags))
      )
   {
       RunasPrintHelp();
       return(EXIT_CODE_FAILED);
   }

   STARTUPINFO si;
   PROCESS_INFORMATION pi;
   ZeroMemory(&si, sizeof(si));
   si.cb = sizeof(si);

   if (TRUE == fCreateProcessRestricted)
   {
       // Username is not specified with this set of options --
       // use the current user.
       DWORD dwSize = ARRAYSIZE(pwszUserName);
       if (FALSE == GetUserNameEx(NameSamCompatible, &pwszUserName[0], &dwSize))
       {
           DisplayMsg(FORMAT_MESSAGE_FROM_HMODULE, RUNASP_STRING_ERROR_INTERNAL, MyGetLastError());
           return (EXIT_CODE_FAILED);
       }

       pwszCurrentDir = (LPWSTR)HeapAlloc(GetProcessHeap(), 0, MAX_PATH * sizeof(WCHAR));
       if (NULL == pwszCurrentDir)
       {
           DisplayMsg(FORMAT_MESSAGE_FROM_HMODULE, RUNASP_STRING_ERROR_INTERNAL, ERROR_NOT_ENOUGH_MEMORY); 
           return (EXIT_CODE_FAILED);
       }

       if (FALSE == GetCurrentDirectory(MAX_PATH, pwszCurrentDir))
       {
           DisplayMsg(FORMAT_MESSAGE_FROM_HMODULE, RUNASP_STRING_ERROR_INTERNAL, MyGetLastError());
           return (EXIT_CODE_FAILED);
       }

       if (FALSE == GetTitle(pszArgv[nNumArgs-1],
                             pwszUserName,
                             TRUE,
                             pwszAuthzLevel,
                             &pwszTitle))
       {
           DisplayMsg(FORMAT_MESSAGE_FROM_HMODULE, RUNASP_STRING_ERROR_INTERNAL, MyGetLastError());
           return (EXIT_CODE_FAILED); 
       }
       
       si.lpTitle = pwszTitle;

       // If we're just doing restricted login, we have enough information to proceed.
       fOk = CreateProcessRestricted
           (dwAuthzLevel,
            NULL,
            pszArgv[nNumArgs - 1],
            pwszCurrentDir,
            &si,
            &pi);
   }
   else
   {
       for (BOOL fDone = FALSE; !fDone; ) {
#if DBG
           // Can only supply password in checked builds.
           if (FALSE == fSuppliedPassword) {
#endif // DBG
               dwResult = GetCredentials
                   (dwCredFlags,
                    pwszPassword,
                    ARRAYSIZE(pwszPassword),
                    pwszUserName,
                    ARRAYSIZE(pwszUserName),
                    pwszUserDisplayName,
                    ARRAYSIZE(pwszUserDisplayName),
                    pwszTarget,
                    ARRAYSIZE(pwszTarget));
               if (ERROR_SUCCESS != dwResult) {
                   LocalizedWPrintf(RUNASP_STRING_ERROR_PASSWORD);
                   return (EXIT_CODE_FAILED);
               }
#if DBG
           } else {
               // If we've supplied a password, don't call GetCredentials.
               // Just copy our username to the display name and proceed.
               wcsncpy(pwszUserDisplayName, pwszUserName, ARRAYSIZE(pwszUserDisplayName)-1);
           }
#endif // DBG


           if (FALSE == GetTitle(pszArgv[nNumArgs-1],
                                 pwszUserDisplayName,
                                 FALSE,
                                 NULL,
                                 &pwszTitle)) 
           {
               DisplayMsg(FORMAT_MESSAGE_FROM_HMODULE, RUNASP_STRING_ERROR_INTERNAL, MyGetLastError());
               return (EXIT_CODE_FAILED); 
           }
           si.lpTitle = pwszTitle;

       //
       // Now we should take the pwszUserName and parse it
       // if it is Domain\User, we want to split it.
       //
           WCHAR *wstr = pwszUserName;
           while(*wstr != L'\0')
           {
               if(*wstr == L'\\')
               {
                   *wstr = L'\0';
                   wstr++;
                   //
                   // first part is domain
                   // second is user.
                   //
                   wcscpy(pwszDomainName, pwszUserName); 
                   wcscpy(pwszUserName, wstr); 
                   break;
               }
               wstr++;
           }

           DisplayMsg(FORMAT_MESSAGE_FROM_HMODULE, RUNASP_STRING_WAIT, pszArgv[nNumArgs-1], pwszUserDisplayName);

           if(UseCurrentEnvironment)
           {
               pwszCurrentDir = (LPWSTR)HeapAlloc(GetProcessHeap(), 0, MAX_PATH * sizeof(WCHAR));
               if (NULL == pwszCurrentDir) {
                   DisplayMsg(FORMAT_MESSAGE_FROM_HMODULE, RUNASP_STRING_ERROR_INTERNAL, ERROR_NOT_ENOUGH_MEMORY); 
                   return (EXIT_CODE_FAILED);
               }
               GetCurrentDirectory(MAX_PATH, pwszCurrentDir);
               Environment = GetEnvironmentStrings();
               flags |= CREATE_UNICODE_ENVIRONMENT;
           }

           fOk = CreateProcessWithLogonW
               (pwszUserName,    // Username
                pwszDomainName,  // Domain
                pwszPassword,    // Password
                Logonflags,    // logon flags
                NULL,          // Application name
                pszArgv[nNumArgs-1],    // Command line
                flags,         // flags
                Environment,   // NULL=LoggedOnUserEnv, GetEnvironmentStrings
                pwszCurrentDir,// Working Directory
                &si,           // Startup Info
                &pi);          // Process Info

           // See if we need to try again...
           fDone = TRUE;
           if (fCredMan) { // The /savecred option was specified.
               if (RUNAS_USE_SAVEDCREDS & dwCredFlags) { // We tried to use saved credentials
                   if (!fOk && CREDUI_IS_AUTHENTICATION_ERROR(GetLastError())) { 
                       // We attempted to use saved creds, and it didn't work. 
                       // Try prompting for a password.
                       dwCredFlags &= ~RUNAS_USE_SAVEDCREDS;
                       dwCredFlags |= RUNAS_SAVE_CREDS; // We'll save the new credentials if we can.
                       fDone = FALSE; // We should try to create the process again.

                       // Reset the username, it may have been modified by GetCredentials():
                       wcscpy(pwszUserName, pwszArgvUserName /*user-supplied username*/); 
                   } else { 
                       // We succeeded, or some other failure occured.
                       // Don't bother trying again.
                   }
               }
               else {
                   // We attempted to save our credentials to credman.  Only save them on success:
                   dwResult = SaveCredentials(pwszTarget, fOk);
                   // ignore errors in SaveCredentials (not much we can do on error).
               }
           }
       }
   }

   if(!fOk)
   {
      DWORD dw;
      LPWSTR wszErrorText = NULL; 

      dw = GetLastError();
      if (ERROR_SUCCESS == dw) 
          GetExitCodeProcess(pi.hProcess, &dw);
      if (ERROR_SUCCESS == dw)
          GetExitCodeThread(pi.hThread, &dw);
      if (ERROR_SUCCESS == dw)
          dw = E_FAIL; 

      if (!WriteMsg(FORMAT_MESSAGE_FROM_SYSTEM, dw, &wszErrorText, pszArgv[nNumArgs-1]))
          DisplayMsg(FORMAT_MESSAGE_FROM_HMODULE, RUNASP_STRING_ERROR_INTERNAL, dw);
      else
          DisplayMsg(FORMAT_MESSAGE_FROM_HMODULE, RUNASP_STRING_ERROR_OCCURED, pszArgv[nNumArgs-1], dw, wszErrorText); 

      return(EXIT_CODE_FAILED);
   }

   CloseHandle(pi.hProcess);
   CloseHandle(pi.hThread);
   return(EXIT_CODE_SUCCEEDED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\runas\stringid.h ===
/*+
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1997 - 1998.
 *
 * Name : stringid.h
 * Author:PraeritG
 *
-*/

#define RUNASP_STRING_HELP_LINE1        7000
#define RUNASP_STRING_HELP_LINE2        7001
#define RUNASP_STRING_HELP_LINE3        7002
#define RUNASP_STRING_HELP_LINE4        7003
#define RUNASP_STRING_HELP_LINE5        7004
#define RUNASP_STRING_SAFER_HELP_LINE1  7005
#define RUNASP_STRING_HELP_LINE7        7006
#define RUNASP_STRING_HELP_LINE8        7007
#define RUNASP_STRING_HELP_LINE9        7008
#define RUNASP_STRING_HELP_LINE10       7009
#define RUNASP_STRING_HELP_LINE11       7010
#define RUNASP_STRING_HELP_LINE12       7011
#define RUNASP_STRING_HELP_LINE13	7012
#define RUNASP_STRING_HELP_LINE14	7013
#define RUNASP_STRING_HELP_LINE15	7014
#define RUNASP_STRING_HELP_LINE16	7015
#define RUNASP_STRING_HELP_LINE17	7016
#define RUNASP_STRING_HELP_LINE18	7017
#define RUNASP_STRING_HELP_LINE19	7018
#define RUNASP_STRING_SAFER_HELP_LINE2  7019
#define RUNASP_STRING_SAFER_HELP_LINE3  7020
#define RUNASP_STRING_SAFER_HELP_LINE4  7021
#define RUNASP_STRING_SAFER_HELP_LINE5  7022
#define RUNASP_STRING_HELP_LINE24	7023
#define RUNASP_STRING_HELP_LINE25	7024
#define RUNASP_STRING_HELP_LINE26	7025
#define RUNASP_STRING_HELP_LINE27	7026
#define RUNASP_STRING_HELP_LINE28	7027
#define RUNASP_STRING_HELP_LINE29	7028
#define RUNASP_STRING_HELP_LINE30	7029
#define RUNASP_STRING_HELP_LINE31	7030
#define RUNASP_STRING_HELP_LINE32	7031
#define RUNASP_STRING_HELP_LINE20       7032 // NOTE: out of order!

// NOTE:  These defines indicate the boundaries of the SAFER help text. 
//        **These must be kept in sync with the string table in runas.rc**
// 


#define RUNASP_STRING_ERROR             7100
#define RUNASP_STRING_ERROR_SYSTEM      7101
#define RUNASP_STRING_ERROR_INPUT       7102
#define RUNASP_STRING_ERROR_ECHO        7103
#define RUNASP_STRING_ERROR_PASSWORD    7104
#define RUNASP_STRING_ERROR_USERNAME    7105

#define RUNASP_STRING_TRUSTLEVELS       7204
#define RUNASP_STRING_SMARTCARDUSER     7205

// Do not declare string IDs greater than this value!
#define RUNASP_MAX_ID 8000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\runas\utils.h ===
//=============================================================================
// Copyright (c) 2000 Microsoft Corporation
//
// dialogs.hpp
//
// Credential manager user interface classes used to get credentials.
//
// Created 02/29/2000 johnstep (John Stephens)
//=============================================================================

#ifndef __UTILS_HPP__
#define __UTILS_HPP__

#include <wincrypt.h>
#include <lm.h>

//-----------------------------------------------------------------------------
// Functions
//-----------------------------------------------------------------------------

BOOL
CreduiIsRemovableCertificate(
    CONST CERT_CONTEXT *certContext
    );

BOOL
CreduiGetCertificateDisplayName(
    CONST CERT_CONTEXT *certContext,
    WCHAR *displayName,
    ULONG displayNameMaxChars,
    WCHAR *certificateString
    );

BOOL
CreduiGetCertDisplayNameFromMarshaledName(
    WCHAR *marshaledName,
    WCHAR *displayName,
    ULONG displayNameMaxChars,
    BOOL onlyRemovable
    );

LPWSTR
GetAccountDomainName(
    VOID
    );

//-----------------------------------------------------------------------------

#endif // __UTILS_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\scandisk\fmifs.h ===
/*++

Copyright (c) 1992 Microsoft Corporation

Module Name:

    fmifs.h

Abstract:

    This header file contains the specification of the interface
    between the file manager and fmifs.dll for the purposes of
    accomplishing IFS functions.

Author:

    Norbert P. Kusters (norbertk) 6-Mar-92

--*/

#if !defined( _FMIFS_DEFN_ )

#define _FMIFS_DEFN_

typedef LONG    *PNTSTATUS;

//
// These are the defines for 'PacketType'.
// Revisions: 02/03/98: Dave Sheldon - Added FmIfsNoMediaInDevice
//

typedef enum _FMIFS_PACKET_TYPE {
    FmIfsPercentCompleted,
    FmIfsFormatReport,
    FmIfsInsertDisk,
    FmIfsIncompatibleFileSystem,
    FmIfsFormattingDestination,
    FmIfsIncompatibleMedia,
    FmIfsAccessDenied,
    FmIfsMediaWriteProtected,
    FmIfsCantLock,
    FmIfsCantQuickFormat,
    FmIfsIoError,
    FmIfsFinished,
    FmIfsBadLabel,
#if defined( DBLSPACE_ENABLED )
    FmIfsDblspaceCreateFailed,
    FmIfsDblspaceMountFailed,
    FmIfsDblspaceDriveLetterFailed,
    FmIfsDblspaceCreated,
    FmIfsDblspaceMounted,
#endif // DBLSPACE_ENABLED
    FmIfsCheckOnReboot,
    FmIfsTextMessage,
    FmIfsHiddenStatus,
    FmIfsClusterSizeTooSmall,
    FmIfsClusterSizeTooBig,
    FmIfsVolumeTooSmall,
    FmIfsVolumeTooBig,
    FmIfsNoMediaInDevice
} FMIFS_PACKET_TYPE, *PFMIFS_PACKET_TYPE;

typedef struct _FMIFS_PERCENT_COMPLETE_INFORMATION {
    ULONG   PercentCompleted;
} FMIFS_PERCENT_COMPLETE_INFORMATION, *PFMIFS_PERCENT_COMPLETE_INFORMATION;

//
// These couple of bits are used in the ValuesInMB field of the structure
// FMIFS_FORMAT_REPORT_INFORMATION.  When set, the corresponding
// ULONG value becomes in units of megabytes.  If not set, the corresponding
// ULONG value is in units of kilobytes.
//
#define TOTAL_DISK_SPACE_IN_MB      1
#define BYTES_AVAILABLE_IN_MB       2

typedef struct _FMIFS_FORMAT_REPORT_INFORMATION {
    ULONG   KiloBytesTotalDiskSpace;
    ULONG   KiloBytesAvailable;
    ULONG   ValuesInMB;
} FMIFS_FORMAT_REPORT_INFORMATION, *PFMIFS_FORMAT_REPORT_INFORMATION;

// The packet for FmIfsDblspaceCreated is a Unicode string
// giving the name of the Compressed Volume File; it is not
// necessarily zero-terminated.
//

#define DISK_TYPE_GENERIC           0
#define DISK_TYPE_SOURCE            1
#define DISK_TYPE_TARGET            2
#define DISK_TYPE_SOURCE_AND_TARGET 3

typedef struct _FMIFS_INSERT_DISK_INFORMATION {
    ULONG   DiskType;
} FMIFS_INSERT_DISK_INFORMATION, *PFMIFS_INSERT_DISK_INFORMATION;

typedef struct _FMIFS_IO_ERROR_INFORMATION {
    ULONG   DiskType;
    ULONG   Head;
    ULONG   Track;
} FMIFS_IO_ERROR_INFORMATION, *PFMIFS_IO_ERROR_INFORMATION;

typedef struct _FMIFS_FINISHED_INFORMATION {
    BOOLEAN Success;
} FMIFS_FINISHED_INFORMATION, *PFMIFS_FINISHED_INFORMATION;

typedef struct _FMIFS_CHECKONREBOOT_INFORMATION {
    OUT BOOLEAN QueryResult; // TRUE for "yes", FALSE for "no"
} FMIFS_CHECKONREBOOT_INFORMATION, *PFMIFS_CHECKONREBOOT_INFORMATION;

typedef enum _TEXT_MESSAGE_TYPE {
    MESSAGE_TYPE_PROGRESS,
    MESSAGE_TYPE_RESULTS,
    MESSAGE_TYPE_FINAL
} TEXT_MESSAGE_TYPE, *PTEXT_MESSAGE_TYPE;

typedef struct _FMIFS_TEXT_MESSAGE {
    IN TEXT_MESSAGE_TYPE    MessageType;
    IN PSTR                 Message;
} FMIFS_TEXT_MESSAGE, *PFMIFS_TEXT_MESSAGE;




//
// This is a list of supported floppy media types for format.
//

typedef enum _FMIFS_MEDIA_TYPE {
    FmMediaUnknown,
    FmMediaF5_160_512,      // 5.25", 160KB,  512 bytes/sector
    FmMediaF5_180_512,      // 5.25", 180KB,  512 bytes/sector
    FmMediaF5_320_512,      // 5.25", 320KB,  512 bytes/sector
    FmMediaF5_320_1024,     // 5.25", 320KB,  1024 bytes/sector
    FmMediaF5_360_512,      // 5.25", 360KB,  512 bytes/sector
    FmMediaF3_720_512,      // 3.5",  720KB,  512 bytes/sector
    FmMediaF5_1Pt2_512,     // 5.25", 1.2MB,  512 bytes/sector
    FmMediaF3_1Pt44_512,    // 3.5",  1.44MB, 512 bytes/sector
    FmMediaF3_2Pt88_512,    // 3.5",  2.88MB, 512 bytes/sector
    FmMediaF3_20Pt8_512,    // 3.5",  20.8MB, 512 bytes/sector
    FmMediaRemovable,       // Removable media other than floppy
    FmMediaFixed,
    FmMediaF3_120M_512,     // 3.5", 120M Floppy
#if defined(FE_SB)
    // FMR Sep.8.1994 SFT YAM
    // FMR Jul.14.1994 SFT KMR
    FmMediaF3_640_512,      // 3.5" ,  640KB,  512 bytes/sector
    FmMediaF5_640_512,      // 5.25",  640KB,  512 bytes/sector
    FmMediaF5_720_512,      // 5.25",  720KB,  512 bytes/sector
    // FMR Sep.8.1994 SFT YAM
    // FMR Jul.14.1994 SFT KMR
    FmMediaF3_1Pt2_512,     // 3.5" , 1.2Mb,   512 bytes/sector
    // FMR Sep.8.1994 SFT YAM
    // FMR Jul.14.1994 SFT KMR
    FmMediaF3_1Pt23_1024,   // 3.5" , 1.23Mb, 1024 bytes/sector
    FmMediaF5_1Pt23_1024,   // 5.25", 1.23MB, 1024 bytes/sector
    FmMediaF3_128Mb_512,    // 3.5" , 128MB,  512 bytes/sector  3.5"MO
    FmMediaF3_230Mb_512,    // 3.5" , 230MB,  512 bytes/sector  3.5"MO
    FmMediaEndOfData        // Total data count.
#endif
} FMIFS_MEDIA_TYPE, *PFMIFS_MEDIA_TYPE;

//
// The structure below defines information to be passed into ChkdskEx.
// When new fields are added, the version number will have to be upgraded
// so that only new code will reference those new fields.
//
typedef struct {
    UCHAR   Major;      // initial version is 1.0
    UCHAR   Minor;
    ULONG   Flags;
} FMIFS_CHKDSKEX_PARAM, *PFMIFS_CHKDSKEX_PARAM;

//
// Internal definitions for Flags field in FMIFS_CHKDSKEX_PARAM
//
#define FMIFS_CHKDSK_RECOVER_FREE_SPACE       0x00000002UL
#define FMIFS_CHKDSK_RECOVER_ALLOC_SPACE      0x00000004UL

//
// External definitions for Flags field in FMIFS_CHKDSKEX_PARAM
//

// FMIFS_CHKDSK_VERBOSE
//  - For FAT, chkdsk will print every filename being processed
//  - For NTFS, chkdsk will print clean up messages
// FMIFS_CHKDSK_RECOVER
//  - Perform sector checking on free and allocated space
// FMIFS_CHKDSK_EXTEND
//  - For NTFS, chkdsk will extend a volume
// FMIFS_CHKDSK_DOWNGRADE (for NT5 or later but obsolete anyway)
//  - For NTFS, this downgrade a volume from most recent NTFS version
// FMIFS_CHKDSK_ENABLE_UPGRADE (for NT5 or later but obsolete anyway)
//  - For NTFS, this upgrades a volume to most recent NTFS version
// FMIFS_CHKDSK_CHECK_IF_DIRTY
//  - Perform consistency check only if the volume is dirty
// FMIFS_CHKDSK_FORCE (for NT5 or later)
//  - Forces the volume to dismount first if necessary
// FMIFS_CHKDSK_SKIP_INDEX_SCAN
//  - Skip the scanning of each index entry
// FMIFS_CHKDSK_SKIP_CYCLE_SCAN
//  - Skip the checking of cycles within the directory tree


#define FMIFS_CHKDSK_VERBOSE                  0x00000001UL
#define FMIFS_CHKDSK_RECOVER                  (FMIFS_CHKDSK_RECOVER_FREE_SPACE | \
                                               FMIFS_CHKDSK_RECOVER_ALLOC_SPACE)
#define FMIFS_CHKDSK_EXTEND                   0x00000008UL
#define FMIFS_CHKDSK_DOWNGRADE                0x00000010UL
#define FMIFS_CHKDSK_ENABLE_UPGRADE           0x00000020UL
#define FMIFS_CHKDSK_CHECK_IF_DIRTY           0x00000080UL
#define FMIFS_CHKDSK_FORCE                    0x00000100UL
#define FMIFS_CHKDSK_SKIP_INDEX_SCAN          0x00000200UL
#define FMIFS_CHKDSK_SKIP_CYCLE_SCAN          0x00000400UL


//
// The structure below defines information to be passed into FormatEx2.
// When new fields are added, the version number will have to be upgraded
// so that only new code will reference those new fields.
//
typedef struct {
    UCHAR       Major;          // initial version is 1.0
    UCHAR       Minor;
    ULONG       Flags;
    PWSTR       LabelString;    // supplies the volume's label
    ULONG       ClusterSize;    // supplies the cluster size for the volume
} FMIFS_FORMATEX2_PARAM, *PFMIFS_FORMATEX2_PARAM;

//
// External definitions for Flags field in FMIFS_FORMATEX2_PARAM
//

// FMIFS_FORMAT_QUICK
//  - Performs a quick format
// FMIFS_FORMAT_BACKWARD_COMPATIBLE
//  - Formats a volume to be backward compatible to an older version of NTFS volume
// FMIFS_FORMAT_FORCE
//  - Forces the volume to dismount first if necessary

#define FMIFS_FORMAT_QUICK                    0x00000001UL
#define FMIFS_FORMAT_BACKWARD_COMPATIBLE      0x00000002UL
#define FMIFS_FORMAT_FORCE                    0x00000004UL

//
// Maximum length of file system format name string including version number in it
// (e.g. FAT32, NTFS 5.0, NTFS 4.0, FAT, etc)
//
#define MAX_FILE_SYSTEM_FORMAT_VERSION_NAME_LEN       16

//
// Maximum length of file system name string (e.g. NTFS, FAT32, FAT, etc)
//
#define MAX_FILE_SYSTEM_FORMAT_NAME_LEN                9

//
// Function types/interfaces.
//

typedef BOOLEAN
(*FMIFS_CALLBACK)(
    IN  FMIFS_PACKET_TYPE   PacketType,
    IN  ULONG               PacketLength,
    IN  PVOID               PacketData
    );

typedef
VOID
(*PFMIFS_FORMAT_ROUTINE)(
    IN  PWSTR               DriveName,
    IN  FMIFS_MEDIA_TYPE    MediaType,
    IN  PWSTR               FileSystemName,
    IN  PWSTR               Label,
    IN  BOOLEAN             Quick,
    IN  FMIFS_CALLBACK      Callback
    );

typedef
VOID
(*PFMIFS_FORMATEX_ROUTINE)(
    IN  PWSTR               DriveName,
    IN  FMIFS_MEDIA_TYPE    MediaType,
    IN  PWSTR               FileSystemName,
    IN  PWSTR               Label,
    IN  BOOLEAN             Quick,
    IN  ULONG               ClusterSize,
    IN  FMIFS_CALLBACK      Callback
    );

typedef
VOID
(*PFMIFS_FORMATEX2_ROUTINE)(
    IN  PWSTR                   DriveName,
    IN  FMIFS_MEDIA_TYPE        MediaType,
    IN  PWSTR                   FileSystemName,
    IN  PFMIFS_FORMATEX2_PARAM  Param,
    IN  FMIFS_CALLBACK          Callback
    );

typedef
BOOLEAN
(*PFMIFS_ENABLECOMP_ROUTINE)(
    IN  PWSTR               DriveName,
    IN  USHORT              CompressionFormat
    );

typedef
VOID
(*PFMIFS_CHKDSK_ROUTINE)(
    IN  PWSTR               DriveName,
    IN  PWSTR               FileSystemName,
    IN  BOOLEAN             Fix,
    IN  BOOLEAN             Verbose,
    IN  BOOLEAN             OnlyIfDirty,
    IN  BOOLEAN             Recover,
    IN  PWSTR               PathToCheck,
    IN  BOOLEAN             Extend,
    IN  FMIFS_CALLBACK      Callback
    );

typedef
VOID
(*PFMIFS_CHKDSKEX_ROUTINE)(
    IN  PWSTR                   DriveName,
    IN  PWSTR                   FileSystemName,
    IN  BOOLEAN                 Fix,
    IN  PFMIFS_CHKDSKEX_PARAM   Param,
    IN  FMIFS_CALLBACK          Callback
    );

typedef
VOID
(*PFMIFS_EXTEND_ROUTINE)(
    IN  PWSTR               DriveName,
    IN  BOOLEAN             Verify,
    IN  FMIFS_CALLBACK      Callback
    );

typedef
VOID
(*PFMIFS_DISKCOPY_ROUTINE)(
    IN  PWSTR           SourceDrive,
    IN  PWSTR           DestDrive,
    IN  BOOLEAN         Verify,
    IN  FMIFS_CALLBACK  Callback
    );

typedef
BOOLEAN
(*PFMIFS_SETLABEL_ROUTINE)(
    IN  PWSTR   DriveName,
    IN  PWSTR   Label
    );

typedef
BOOLEAN
(*PFMIFS_QSUPMEDIA_ROUTINE)(
    IN  PWSTR               DriveName,
    OUT PFMIFS_MEDIA_TYPE   MediaTypeArray  OPTIONAL,
    IN  ULONG               NumberOfArrayEntries,
    OUT PULONG              NumberOfMediaTypes
    );


typedef
VOID
(*PFMIFS_DOUBLESPACE_CREATE_ROUTINE)(
    IN PWSTR           HostDriveName,
    IN ULONG           Size,
    IN PWSTR           Label,
    IN PWSTR           NewDriveName,
    IN FMIFS_CALLBACK  Callback
    );

#if defined( DBLSPACE_ENABLED )
typedef
VOID
(*PFMIFS_DOUBLESPACE_DELETE_ROUTINE)(
    IN PWSTR           DblspaceDriveName,
    IN FMIFS_CALLBACK  Callback
    );

typedef
VOID
(*PFMIFS_DOUBLESPACE_MOUNT_ROUTINE)(
    IN PWSTR           HostDriveName,
    IN PWSTR           CvfName,
    IN PWSTR           NewDriveName,
    IN FMIFS_CALLBACK  Callback
    );

typedef
VOID
(*PFMIFS_DOUBLESPACE_DISMOUNT_ROUTINE)(
    IN PWSTR           DblspaceDriveName,
    IN FMIFS_CALLBACK  Callback
    );

typedef
BOOLEAN
(*PFMIFS_DOUBLESPACE_QUERY_INFO_ROUTINE)(
    IN  PWSTR       DosDriveName,
    OUT PBOOLEAN    IsRemovable,
    OUT PBOOLEAN    IsFloppy,
    OUT PBOOLEAN    IsCompressed,
    OUT PBOOLEAN    Error,
    OUT PWSTR       NtDriveName,
    IN  ULONG       MaxNtDriveNameLength,
    OUT PWSTR       CvfFileName,
    IN  ULONG       MaxCvfFileNameLength,
    OUT PWSTR       HostDriveName,
    IN  ULONG       MaxHostDriveNameLength
    );

typedef
BOOLEAN
(*PFMIFS_DOUBLESPACE_SET_AUTMOUNT_ROUTINE)(
    IN  BOOLEAN EnableAutomount
    );

#endif // DBLSPACE_ENABLED


VOID
Format(
    IN  PWSTR               DriveName,
    IN  FMIFS_MEDIA_TYPE    MediaType,
    IN  PWSTR               FileSystemName,
    IN  PWSTR               Label,
    IN  BOOLEAN             Quick,
    IN  FMIFS_CALLBACK      Callback
    );

VOID
FormatEx(
    IN  PWSTR               DriveName,
    IN  FMIFS_MEDIA_TYPE    MediaType,
    IN  PWSTR               FileSystemName,
    IN  PWSTR               Label,
    IN  BOOLEAN             Quick,
    IN  ULONG               ClusterSize,
    IN  FMIFS_CALLBACK      Callback
    );

BOOLEAN
EnableVolumeCompression(
    IN  PWSTR               DriveName,
    IN  USHORT              CompressionFormat
    );

VOID
Chkdsk(
    IN  PWSTR               DriveName,
    IN  PWSTR               FileSystemName,
    IN  BOOLEAN             Fix,
    IN  BOOLEAN             Verbose,
    IN  BOOLEAN             OnlyIfDirty,
    IN  BOOLEAN             Recover,
    IN  PWSTR               PathToCheck,
    IN  BOOLEAN             Extend,
    IN  FMIFS_CALLBACK      Callback
    );

VOID
ChkdskEx(
    IN  PWSTR                   DriveName,
    IN  PWSTR                   FileSystemName,
    IN  BOOLEAN                 Fix,
    IN  PFMIFS_CHKDSKEX_PARAM   Param,
    IN  FMIFS_CALLBACK          Callback
    );

VOID
Extend(
    IN  PWSTR               DriveName,
    IN  BOOLEAN             Verify,
    IN  FMIFS_CALLBACK      Callback
    );

VOID
DiskCopy(
    IN  PWSTR           SourceDrive,
    IN  PWSTR           DestDrive,
    IN  BOOLEAN         Verify,
    IN  FMIFS_CALLBACK  Callback
    );

BOOLEAN
SetLabel(
    IN  PWSTR   DriveName,
    IN  PWSTR   Label
    );

BOOLEAN
QuerySupportedMedia(
    IN  PWSTR               DriveName,
    OUT PFMIFS_MEDIA_TYPE   MediaTypeArray  OPTIONAL,
    IN  ULONG               NumberOfArrayEntries,
    OUT PULONG              NumberOfMediaTypes
    );

BOOLEAN
QueryAvailableFileSystemFormat(
    IN     ULONG            Index,
    OUT    PWSTR            FileSystemName,
    OUT    PUCHAR           MajorVersion,
    OUT    PUCHAR           MinorVersion,
    OUT    PBOOLEAN         Latest
);

BOOLEAN
QueryFileSystemName(
    IN     PWSTR        DriveName,
    OUT    PWSTR        FileSystemName,
    OUT    PUCHAR       MajorVersion,
    OUT    PUCHAR       MinorVersion,
    OUT    PNTSTATUS    ErrorCode
);

BOOLEAN
QueryLatestFileSystemVersion(
    IN  PWSTR   FileSystemName,
    OUT PUCHAR  MajorVersion,
    OUT PUCHAR  MinorVersion
);

VOID
DoubleSpaceCreate(
    IN PWSTR           HostDriveName,
    IN ULONG           Size,
    IN PWSTR           Label,
    IN PWSTR           NewDriveName,
    IN FMIFS_CALLBACK  Callback
    );

#if defined( DBLSPACE_ENABLED )

VOID
DoubleSpaceDelete(
    IN PWSTR           DblspaceDriveName,
    IN FMIFS_CALLBACK  Callback
    );

VOID
DoubleSpaceMount(
    IN PWSTR           HostDriveName,
    IN PWSTR           CvfName,
    IN PWSTR           NewDriveName,
    IN FMIFS_CALLBACK  Callback
    );

VOID
DoubleSpaceDismount(
    IN PWSTR           DblspaceDriveName,
    IN FMIFS_CALLBACK  Callback
    );

// Miscellaneous prototypes:
//
BOOLEAN
FmifsQueryDriveInformation(
    IN  PWSTR       DosDriveName,
    OUT PBOOLEAN    IsRemovable,
    OUT PBOOLEAN    IsFloppy,
    OUT PBOOLEAN    IsCompressed,
    OUT PBOOLEAN    Error,
    OUT PWSTR       NtDriveName,
    IN  ULONG       MaxNtDriveNameLength,
    OUT PWSTR       CvfFileName,
    IN  ULONG       MaxCvfFileNameLength,
    OUT PWSTR       HostDriveName,
    IN  ULONG       MaxHostDriveNameLength
    );

BOOLEAN
FmifsSetAutomount(
    IN  BOOLEAN EnableAutomount
    );

#endif


#endif // _FMIFS_DEFN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\scandisk\jcohen.h ===
// ************************************************************************
//
// JCOHEN.H
//
//  Microsoft Confidential
//  Copyright (c) Pacific Access Communications Corporation 1998
//  All rights reserved
//
//  Contains common include files, macros, and other stuff I use 
//  all the time.
//
// ************************************************************************


#ifndef _JCOHEN_H_
#define _JCOHEN_H_


//
// Include files
//

#include <windows.h>

#define	NULLSTR	_T("")
#define NULLCHR	_T('\0')

//
// Macros.
//

// Memory managing macros.
//
#define MALLOC(cb)      HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, cb)
#define REALLOC(lp, cb) HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, lp, cb)
#define FREE(lp)        ( (lp != NULL) ? ( (HeapFree(GetProcessHeap(), HEAP_NO_SERIALIZE, (LPVOID) lp)) ? ((lp = NULL) == NULL) : (FALSE) ) : (FALSE) )
#define NETFREE(lp)     ( (lp != NULL) ? ( (NetApiBufferFree((LPVOID) lp)) ? ((lp = NULL) == NULL) : (FALSE) ) : (FALSE) )

// Misc. macros.
//
#define EXIST(lpFileName)			( (GetFileAttributes(lpFileName) == 0xFFFFFFFF) ? (FALSE) : (TRUE) )
#define ISNUM(cChar)				((cChar >= _T('0')) && (cChar <= _T('9'))) ? (TRUE) : (FALSE)
#define	UPPER(x)					( ( (x >= _T('a')) && (x <= _T('z')) ) ? (x + _T('A') - _T('a')) : (x) )
#define RANDOM(low, high)			(high - low + 1) ? rand() % (high - low + 1) + low : 0


#endif // _JCOHEN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\runas\utils.cpp ===
//=============================================================================
// Copyright (c) 2000 Microsoft Corporation
//
// utils.cpp
//
// Credential manager user interface utility functions.
//
// Created 06/06/2000 johnstep (John Stephens)
//=============================================================================

#include "cred_pch.h"
#include "utils.h"


//=============================================================================
// CreduiIsRemovableCertificate
//
// Arguments:
//   certContext (in) - certificate context to query
//
// Returns TRUE if the certificate has a removable component (such as a smart
// card) or FALSE otherwise.
//
// Created 04/09/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiIsRemovableCertificate(
    CONST CERT_CONTEXT *certContext
    )
{
    BOOL isRemovable = FALSE;
    
    // First, determine the buffer size:
    
    DWORD bufferSize = 0;

    if (CertGetCertificateContextProperty(
            certContext,
            CERT_KEY_PROV_INFO_PROP_ID,
            NULL,
            &bufferSize))
    {
        // Allocate the buffer on the stack:

        CRYPT_KEY_PROV_INFO *provInfo;

        __try
        {
            provInfo = static_cast<CRYPT_KEY_PROV_INFO *>(alloca(bufferSize));
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            provInfo = NULL;
        }

        if (provInfo != NULL)
        {
            if (CertGetCertificateContextProperty(
                    certContext,
                    CERT_KEY_PROV_INFO_PROP_ID,
                    provInfo,
                    &bufferSize))
            {
                HCRYPTPROV provContext;

                if (CryptAcquireContext(
                        &provContext,
                        NULL,
                        provInfo->pwszProvName,
                        provInfo->dwProvType,
                        CRYPT_VERIFYCONTEXT | CRYPT_SILENT))
                {
                    DWORD impType;
                    DWORD impTypeSize = sizeof impType;

                    if (CryptGetProvParam(
                            provContext,
                            PP_IMPTYPE,
                            reinterpret_cast<BYTE *>(&impType),
                            &impTypeSize,
                            0))
                    {
                        if (impType & CRYPT_IMPL_REMOVABLE)
                        {
                            isRemovable = TRUE;
                        }
                    }

                    if (!CryptReleaseContext(provContext, 0))
                    {
                        CreduiDebugLog(
                            "CreduiIsRemovableCertificate: "
                            "CryptReleaseContext failed: %u\n",
                            GetLastError());
                    }
                }
            }
        }
    }

    return isRemovable;
}

//=============================================================================
// CreduiGetCertificateDisplayName
//
// Arguments:
//   certContext (in)
//   displayName (out)
//   displayNameMaxChars (in)
//   certificateString (in)
//
// Returns TRUE if a display name was stored or FALSE otherwise.
//
// Created 06/12/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiGetCertificateDisplayName(
    CONST CERT_CONTEXT *certContext,
    WCHAR *displayName,
    ULONG displayNameMaxChars,
    WCHAR *certificateString
    )
{
    BOOL success = FALSE;
    
    WCHAR *tempName;
    ULONG tempNameMaxChars = displayNameMaxChars / 2 - 1;

    __try
    {
        tempName =
            static_cast<WCHAR *>(
                alloca(tempNameMaxChars * sizeof (WCHAR)));
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        tempName = NULL;
    }

    if (tempName == NULL)
    {
        return FALSE;
    }
    
    displayName[0] = L'\0';
    tempName[0] = L'\0';
    
    if (CertGetNameString(
            certContext,
            CERT_NAME_FRIENDLY_DISPLAY_TYPE,
            0,
            NULL,
            tempName,
            tempNameMaxChars))
    {
        success = TRUE;
        lstrcpy(displayName, tempName);
    }

    if (CertGetNameString(
            certContext,
            CERT_NAME_FRIENDLY_DISPLAY_TYPE,
            CERT_NAME_ISSUER_FLAG,
            NULL,
            tempName,
            tempNameMaxChars))
    {
        if (lstrcmpi(displayName, tempName) != 0)
        {
            success = TRUE;

            WCHAR *where = &displayName[lstrlen(displayName)];

            if (where > displayName)
            {
                *where++ = L' ';
                *where++ = L'-';
                *where++ = L' ';
            }

            lstrcpy(where, tempName);
        }
    }

    return success;
}

//=============================================================================
// CreduiGetCertDisplayNameFromMarshaledName
//
// Arguments:
//   marshaledName (in)
//   displayName (out)
//   displayNameMaxChars (in)
//   onlyRemovable (in) - only get name if for a "removable" certificate
//
// Returns TRUE if a display name was stored or FALSE otherwise.
//
// Created 07/24/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiGetCertDisplayNameFromMarshaledName(
    WCHAR *marshaledName,
    WCHAR *displayName,
    ULONG displayNameMaxChars,
    BOOL onlyRemovable
    )
{
    BOOL success = FALSE;

    CRED_MARSHAL_TYPE credMarshalType;
    CERT_CREDENTIAL_INFO *certCredInfo;

    if (CredUnmarshalCredential(
            marshaledName,
            &credMarshalType,
            reinterpret_cast<VOID **>(&certCredInfo)))
    {
        if (credMarshalType == CertCredential)
        {
            HCERTSTORE certStore;
            CONST CERT_CONTEXT *certContext;

            certStore = CertOpenSystemStore(NULL, L"MY");

            if (certStore != NULL)
            {
                CRYPT_HASH_BLOB hashBlob;

                hashBlob.cbData = CERT_HASH_LENGTH;
                hashBlob.pbData = reinterpret_cast<BYTE *>(
                                      certCredInfo->rgbHashOfCert);

                certContext = CertFindCertificateInStore(
                                  certStore,
                                  X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                  0,
                                  CERT_FIND_SHA1_HASH,
                                  &hashBlob,
                                  NULL);

                if (certContext != NULL)
                {
                    // If onlyRemovable is TRUE, check to see if this is a
                    // certificate with a removable hardware component; this
                    // usually means a smart card:

                    if (!onlyRemovable ||
                        CreduiIsRemovableCertificate(certContext))
                    {
                        success =
                            CreduiGetCertificateDisplayName(
                                certContext,
                                displayName,
                                displayNameMaxChars,
                                NULL);
                    }

                    CertFreeCertificateContext(certContext);
                }

                // CertCloseStore returns FALSE if it fails. We could try
                // again, depending on the error returned by GetLastError:
                
                CertCloseStore(certStore, 0);
            }
        }

        CredFree(static_cast<VOID *>(certCredInfo));
    }

    return success;
}

LPWSTR
GetAccountDomainName(
    VOID
    )
/*++

Routine Description:

    Returns the name of the account domain for this machine.

    For workstatations, the account domain is the netbios computer name.
    For DCs, the account domain is the netbios domain name.

Arguments:

    None.

Return Values:

    Returns a pointer to the name.  The name should be free using NetApiBufferFree.

    NULL - on error.

--*/
{
    BOOL  CreduiIsDomainController  = FALSE; 
    DWORD WinStatus;

    LPWSTR AllocatedName = NULL;

    OSVERSIONINFOEXW versionInfo;
    versionInfo.dwOSVersionInfoSize = sizeof OSVERSIONINFOEXW;
    
    if (GetVersionEx(reinterpret_cast<OSVERSIONINFOW *>(&versionInfo)))
    {
	CreduiIsDomainController = (versionInfo.wProductType == VER_NT_DOMAIN_CONTROLLER);
    }

    //
    // If this machine is a domain controller,
    //  get the domain name.
    //

    if ( CreduiIsDomainController ) {

        WinStatus = NetpGetDomainName( &AllocatedName );

        if ( WinStatus != NO_ERROR ) {
            return NULL;
        }

    //
    // Otherwise, the 'account domain' is the computername
    //

    } else {

        WinStatus = NetpGetComputerName( &AllocatedName );

        if ( WinStatus != NO_ERROR ) {
            return NULL;
        }

    }

    return AllocatedName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\scandisk\main.c ===
//////////////////////////////////////////////////////////////////////////////
//
// MAIN.C / ChkDskW
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  8/98 - Jason Cohen (JCOHEN)
//
//////////////////////////////////////////////////////////////////////////////


// Include file(s).
//
#include "main.h"
#include <stdlib.h>
#include <shellapi.h>


// Global variable(s).
//
HINSTANCE   g_hInstance;
DWORD       g_dwDrives;
DWORD       g_dwFlags;
TCHAR       g_cSageId;


// Internal function prototype(s).
//
static INT_PTR CALLBACK Dlg_Proc(HWND, UINT, WPARAM, LPARAM);
static BOOL             Dlg_OnInitDialog(HWND, HWND, LPARAM);
static VOID             Dlg_OnCommand(HWND, INT, HWND, UINT);
static BOOL             Dlg_OnDrawItem(HWND, const DRAWITEMSTRUCT *);

static VOID             SetSageSettings(HWND, TCHAR);
static VOID             RunSageSettings(HWND, TCHAR);
static DWORD            GetSelectedDrives(HWND, DWORD);

static BOOL             TanslateCommandLine(LPTSTR);
static VOID             ProcessCommandLine(VOID);
static DWORD            GetCommandLineOptions(LPTSTR **);


// External function prototype(s).
//
HANDLE SpawnChkdsk(HWND, DWORD);


WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, INT nCmdShow)
{
    INT     nReturn;

    g_hInstance = hInstance;
    g_dwFlags = 0;
    g_dwDrives = 0;

    ProcessCommandLine();

    nReturn = (INT)DialogBox(hInstance, MAKEINTRESOURCE(IDD_MAIN), NULL, (DLGPROC) Dlg_Proc);

    return nReturn;
}


static INT_PTR CALLBACK Dlg_Proc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        // Message cracking macros.
        //
        HANDLE_MSG(hDlg, WM_INITDIALOG, Dlg_OnInitDialog);
        HANDLE_MSG(hDlg, WM_COMMAND, Dlg_OnCommand);

        case WM_DRAWITEM:
            return Dlg_OnDrawItem(hDlg, (const DRAWITEMSTRUCT *) lParam);
        
        case WM_CLOSE:
            if ( g_dwFlags & SCANDISK_SCANNING )
                g_dwFlags |= SCANDISK_CANCELSCAN;
            else
                EndDialog(hDlg, 0);

        default:
            return FALSE;
    }
    return TRUE;
}


static BOOL Dlg_OnInitDialog(HWND hDlg, HWND hwndFocus, LPARAM lParam)
{
    TCHAR       szBuffer[256];
    LPTSTR      lpBuffer;
    INT         nIndex;
    UINT        uDriveType;
    DWORD       dwMask,
                dwDefault;
    TCHAR       chDrive[] = _T("A:\\");
    SHFILEINFO  SHFileInfo;

    // Init the common control library (for the progress bar).
    //
    InitCommonControls();

    // Set the icon for the dialog.
    //
    SetClassLongPtr(hDlg, GCLP_HICON, (LONG_PTR) LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_MAIN)));

    // Load any SAGERUN settings.
    //
    if ( g_dwFlags & SCANDISK_SAGERUN )
        RunSageSettings(hDlg, g_cSageId);

    // Get the system drive so we know what to default to if there
    // are not already default drives specified in g_dwDrives.
    //
    if ( g_dwDrives )
        dwDefault = g_dwDrives;
    else
    {
        szBuffer[0] = _T('\0');
        if ( GetEnvironmentVariable(_T("SystemDrive"), szBuffer, sizeof(szBuffer)) && szBuffer[0] )
            dwDefault = 1 << (UPPER(szBuffer[0]) - _T('A'));
        else
            dwDefault = 4; // Default to the C: drive.
    }

    // Populate the list box with the drives to scan.
    //
    g_dwDrives = GetLogicalDrives();
    for (dwMask = 1; g_dwDrives & ~(dwMask - 1); dwMask <<= 1)
    {
        // Is there a logical drive?
        //
        if ( g_dwDrives & dwMask )
        {
            // Reset this bit, we will or it back in if it gets
            // added to the list box.
            //
            g_dwDrives &= ~dwMask;

            // Check the drive type and it is
            // removable or fixed, add it to the
            // list box along with the icon.
            //
            uDriveType = GetDriveType(chDrive);
            if ( ( uDriveType == DRIVE_FIXED ) ||
                 ( uDriveType == DRIVE_REMOVABLE ) )
            {
                SHGetFileInfo(chDrive, 0, &SHFileInfo, sizeof(SHFILEINFO), SHGFI_ICON | SHGFI_SMALLICON | SHGFI_DISPLAYNAME | SHGFI_TYPENAME);
                if ( (nIndex = (INT)SendDlgItemMessage(hDlg, IDC_DRIVES, LB_ADDSTRING, 0, (LPARAM) (LPCTSTR) SHFileInfo.szDisplayName)) >= 0 )
                {
                    // Or back in this bit because we successfully added
                    // the drive to the list box.
                    //
                    g_dwDrives |= dwMask;
                    SendDlgItemMessage(hDlg, IDC_DRIVES, LB_SETITEMDATA, nIndex, (LPARAM) SHFileInfo.hIcon);

                    // If this is the boot drive, we want to selecte it.
                    //
                    if (dwMask & dwDefault)
                        SendDlgItemMessage(hDlg, IDC_DRIVES, LB_SETSEL, TRUE, (LPARAM) nIndex);
                }
            }
        }

        // Go look at the next drive
        //
        chDrive[0]++;
    }

    // Check for if we are in the SAGESET mode.
    //
    if ( g_dwFlags & SCANDISK_SAGESET )
    {
        if ( lpBuffer = AllocateString(NULL, IDS_OK) )
        {
            SetDlgItemText(hDlg, IDOK, lpBuffer);
            FREE(lpBuffer);
        }
        if ( lpBuffer = AllocateString(NULL, IDS_CANCEL) )
        {
            SetDlgItemText(hDlg, IDCANCEL, lpBuffer);
            FREE(lpBuffer);
        }
        ShowWindow(GetDlgItem(hDlg, IDC_PROGRESS), SW_HIDE);
    }

    // Set the estimated time.
    //
    srand(GetTickCount());
    wsprintf(szBuffer, _T("%d hour(s) %d minute(s)"), RANDOM(0, 1), RANDOM(1, 59));
    SetDlgItemText(hDlg, IDC_ESTIMATED, szBuffer);

    // Set the default option.
    //
    CheckRadioButton(hDlg, IDC_FIX, IDC_REMIND, IDC_FIX);
    EnableWindow(GetDlgItem(hDlg, IDC_TIME), FALSE);

    // Set the default remind time.
    //
    SetDlgItemText(hDlg, IDC_TIME, _T("5:00 PM"));

    // Set the focus to the default button.
    //
    SetFocus(GetDlgItem(hDlg, IDOK));

    // If we are in SAGERUN mode, start the scan automatically.
    //
    if ( g_dwFlags & SCANDISK_SAGERUN )
    {
        if ( SpawnChkdsk(hDlg, g_dwDrives) == NULL )
            EndDialog(hDlg, 0);
    }

    return FALSE;
}


static VOID Dlg_OnCommand(HWND hDlg, INT id, HWND hwndCtl, UINT codeNotify)
{
    switch (id)
    {
        case IDOK:
            if ( g_dwFlags & SCANDISK_SAGESET )
            {
                // Just save the settings and end the dialog.
                //
                SetSageSettings(hDlg, g_cSageId);
                EndDialog(hDlg, 0);
            }
            else
            {
                // Run chkdsk on the drive(s).
                //
                if ( SpawnChkdsk(hDlg, g_dwDrives) == NULL )
                    EndDialog(hDlg, 0);
            }
            break;
        case IDCANCEL:
            if ( g_dwFlags & SCANDISK_SCANNING )
                g_dwFlags |= SCANDISK_CANCELSCAN;
            else
                EndDialog(hDlg, 0);
            break;
        case IDC_RESTART:
        case IDC_SKIP:
        case IDC_REMIND:
            EnableWindow(GetDlgItem(hDlg, IDC_TIME), id == IDC_REMIND);
            break;
    }
}


static BOOL Dlg_OnDrawItem(HWND hWnd, const DRAWITEMSTRUCT * lpDrawItem)
{
    HICON       hIcon;
    TCHAR       szBuffer[MAX_PATH];
    BOOL        bRestore = FALSE;
    COLORREF    crText,
                crBk;
    DWORD       dwColor;
    RECT        rect;
    HBRUSH      hbrBack;

    // Make sure we are drawing the right control and an item.
    //
    if ( lpDrawItem->CtlID != IDC_DRIVES )
        return FALSE;

    switch ( lpDrawItem->itemAction )
    {
        case ODA_SELECT:
        case ODA_DRAWENTIRE:

            if (lpDrawItem->itemState & ODS_SELECTED)
            {
                // Set new text/background colors and store the old ones away.
                //
                crText  = SetTextColor(lpDrawItem->hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
                crBk    = SetBkColor(lpDrawItem->hDC, GetSysColor(COLOR_HIGHLIGHT));

                // Restore the text and background colors when we are finished.
                //
                bRestore = TRUE;

                // Get the hightlight color to fill in the listbox item.
                //
                dwColor = GetSysColor(COLOR_HIGHLIGHT);

            }
            else
            {
                // Get the window color so we can clear the listbox item.
                //
                dwColor = GetSysColor(COLOR_WINDOW);
            }

            // Fill entire item rectangle with the appropriate color
            //
            hbrBack = CreateSolidBrush(dwColor);
            FillRect(lpDrawItem->hDC, &(lpDrawItem->rcItem), hbrBack);
            DeleteObject(hbrBack);

            // Display the icon associated with the item.
            //
            if ( hIcon = (HICON) SendMessage(lpDrawItem->hwndItem, LB_GETITEMDATA, lpDrawItem->itemID, (LPARAM) 0) )
            {
                DrawIconEx( lpDrawItem->hDC,
                            lpDrawItem->rcItem.left + 2,
                            lpDrawItem->rcItem.top,
                            hIcon,
                            lpDrawItem->rcItem.bottom - lpDrawItem->rcItem.top,
                            lpDrawItem->rcItem.bottom - lpDrawItem->rcItem.top,
                            0,
                            0,
                            DI_NORMAL);
            }

            // Display the text associated with the item.
            //
            if ( SendMessage(lpDrawItem->hwndItem, LB_GETTEXT, lpDrawItem->itemID, (LPARAM) szBuffer) >= 0 )
            {
                TextOut(    lpDrawItem->hDC,
                            lpDrawItem->rcItem.left + lpDrawItem->rcItem.bottom - lpDrawItem->rcItem.top + 4,
                            lpDrawItem->rcItem.top + 1,
                            szBuffer,
                            lstrlen(szBuffer));
            }

            if (bRestore)
            {
                // Restore original text and background colors.
                //
                SetTextColor(lpDrawItem->hDC, crText);
                SetBkColor(lpDrawItem->hDC, crBk);
            }
            break;

        case ODA_FOCUS:

            // Get rectangle coordinates for listbox item.
            //
            SendMessage(lpDrawItem->hwndItem, LB_GETITEMRECT, lpDrawItem->itemID, (LPARAM) &rect);
            DrawFocusRect(lpDrawItem->hDC, &rect);
            break;

    }

    return TRUE;
}


static VOID SetSageSettings(HWND hDlg, TCHAR cSageId)
{
    TCHAR szRegKey[MAX_PATH + 1];

    wsprintf(szRegKey, _T("%s\\%c"), SCANDISK_REGKEY_SAGE, cSageId);
    RegSetDword(HKCU, szRegKey, SCANDISK_REGVAL_DRIVES, GetSelectedDrives(hDlg, g_dwDrives));
    RegSetString(HKCU, szRegKey, SCANDISK_REGVAL_FIX, IsDlgButtonChecked(hDlg, IDC_AUTOFIX) ? _T("1") : _T("0"));
    RegSetString(HKCU, szRegKey, SCANDISK_REGVAL_SURFACE, IsDlgButtonChecked(hDlg, IDC_SURFACE) ? _T("1") : _T("0"));
}


static VOID RunSageSettings(HWND hDlg, TCHAR cSageId)
{
    TCHAR szRegKey[MAX_PATH + 1];

    wsprintf(szRegKey, _T("%s\\%c"), SCANDISK_REGKEY_SAGE, cSageId);
    g_dwDrives = RegGetDword(HKCU, szRegKey, SCANDISK_REGVAL_DRIVES);
    CheckDlgButton(hDlg, IDC_AUTOFIX, RegCheck(HKCU, szRegKey, SCANDISK_REGVAL_FIX) ? BST_CHECKED : BST_UNCHECKED);
    CheckDlgButton(hDlg, IDC_SURFACE, RegCheck(HKCU, szRegKey, SCANDISK_REGVAL_SURFACE) ? BST_CHECKED : BST_UNCHECKED);
}


static DWORD GetSelectedDrives(HWND hDlg, DWORD dwDrives)
{
    TCHAR       szDrive[] = _T("A:\\");
    INT         nCount,
                nIndex;
    LPINT       lpnSelected,
                lpnIndex;
    DWORD       dwMask;

    // Get the number of selected items and allocate a buffer to hold all the indexs.
    //
    if ( ( (nCount = (INT)SendDlgItemMessage(hDlg, IDC_DRIVES, LB_GETSELCOUNT, 0, 0L)) > 0 ) &&
         ( lpnSelected = (LPINT) MALLOC(nCount * sizeof(INT)) ) )
    {
        // Now get the list of selected items.
        //
        if ( (nCount = (INT)SendDlgItemMessage(hDlg, IDC_DRIVES, LB_GETSELITEMS, nCount, (LPARAM) lpnSelected)) > 0 )
        {
            // Loop through all the drives in the list box to see if they
            // are selected.
            //
            lpnIndex = lpnSelected;
            nIndex = 0;
            for (dwMask = 1; (DWORD) dwDrives & ~(dwMask - 1); dwMask <<= 1)
            {
                // Is this drive in the list box.
                //
                if ( (DWORD) dwDrives & dwMask )
                {
                    // Test to see if this item is the
                    // next selected one.
                    //
                    if ( *lpnIndex == nIndex )
                        lpnIndex++;
                    else
                        // It isn't selected so set
                        // the bit to zero.
                        //
                        dwDrives &= ~dwMask;

                    // Keep an index of what list box
                    // item this should be.
                    //
                    nIndex++;
                }

                // Go look at the next drive
                //
                szDrive[0]++;
            }
        }
        else
            dwDrives = 0;
        FREE(lpnSelected);
    }
    else
        dwDrives = 0;

    // Return drives selected (zero of failure).
    //
    return dwDrives;
}


static BOOL TanslateCommandLine(LPTSTR lpArg)
{
    DWORD   dwStrLen = lstrlen(lpArg);
    BOOL    bTranslated = TRUE;

    // First check for the slash options.
    //
    if ( *lpArg == _T('/') )
    {
        // Get rid of the slash.
        //
        lpArg++;

        // Check for /SAGESET:#
        //
        if ( _tcsncicmp(_T("SAGESET:"), lpArg, 8) == 0 )
        {
            if ( !(g_dwFlags & (SCANDISK_SAGESET | SCANDISK_SAGERUN) ) )
            {
                g_dwFlags |= SCANDISK_SAGESET;
                g_cSageId = *(lpArg + 8);
            }
        }

        // Check for /SAGERUN:#
        //
        else if ( _tcsncicmp(_T("SAGERUN:"), lpArg, 8) == 0 )
        {
            if ( !(g_dwFlags & (SCANDISK_SAGESET | SCANDISK_SAGERUN) ) )
            {
                g_dwFlags |= SCANDISK_SAGERUN;
                g_cSageId = *(lpArg + 8);
            }
        }

        // Unknown option.
        //
        else
            bTranslated = FALSE;
    }
    else
    {
        // Check to see if it is a drive letter to auto select.
        //
        if ( ( UPPER(*lpArg) >= _T('A') ) && ( UPPER(*lpArg) <= _T('Z') ) &&  // Make sure the first character is a letter.
             ( ( dwStrLen == 1) || ( ( dwStrLen > 1 ) && ( *(lpArg + 1) == _T(':') ) ) ) )  // Make sure it is one character or the second is a colon.
        {
            g_dwDrives |= 1 << (UPPER(*lpArg) - _T('A'));
        }

        // Unknown option.
        //
        else
            bTranslated = FALSE;
    }

    return bTranslated;
}


static VOID ProcessCommandLine()
{
    LPTSTR  *lpArgs = NULL;
    DWORD   dwArgs,
            dwIndex;

    dwArgs = GetCommandLineOptions(&lpArgs);
    for (dwIndex = 1; dwIndex < dwArgs; dwIndex++)
        TanslateCommandLine((LPTSTR) *(lpArgs + dwIndex));
    FREE(lpArgs);
}


static DWORD GetCommandLineOptions(LPTSTR **lpArgs)
{
    TCHAR   cParse;
    LPTSTR  lpSearch,
            lpCommandLine;
    DWORD   dwArgs      = 0,
            dwMaxArgs   = 0xFFFFFFFF;

    // Make sure we get the command line.
    //
    if ( (lpSearch = lpCommandLine = GetCommandLine()) == NULL )
        return 0;

    // Get the number of arguments so we can allocate
    // the memory for the array of command line options.
    //
    if ( lpArgs )
    {
        if ( (dwMaxArgs = GetCommandLineOptions(NULL)) == 0 )
            return 0;
        if ( (*lpArgs = (LPTSTR *) MALLOC(sizeof(LPTSTR) * dwMaxArgs)) == NULL )
            return 0;
    }

    // Now lets parse the arguments.
    //
    while ( *lpSearch && (dwArgs < dwMaxArgs) )
    {
        // Eat all preceeding spaces.
        //
        while ( *lpSearch == _T(' ') )
            lpSearch++;

        // Check to see if we need to look for a space or a quote
        // to separate the next argument.
        //
        if ( *lpSearch == _T('"') )
            cParse = *lpSearch++;
        else
            cParse = _T(' ');

        // This is be the beginning of the next argument, but
        // it isn't NULL terminated yet.
        //
        if ( lpArgs )
            *(*lpArgs + dwArgs) = lpSearch;
        dwArgs++;

        // Go through all the characters until we hit a separator.
        //
        do
        {
            // Once we get to a quote, we just want to keep going
            // until we get to a space.
            //
            if ( *lpSearch == _T('"') )
                cParse = _T(' ');

        // Only end when we reach the parsing character, which will
        // always be the space by this time (but the space won't trigger
        // the end until we hit a quote, if that is what we were originally
        // looking for).  We also need to make sure that we don't increment
        // past the NULL terminator.
        //
        }
        while ( ( *lpSearch != cParse ) && ( *lpSearch ) && ( *lpSearch++ ) );

        // If the preceeding character is a quote, that is were we want to
        // place the NULL terminator.
        //
        if ( ( lpSearch > lpCommandLine ) &&
             ( *(lpSearch - 1) == _T('"') ) )
            lpSearch--;

        // Set and increment past the NULL terminator only if we aren't already at
        // the end if the string.
        //
        if ( lpArgs && *lpSearch )
            *lpSearch++ = _T('\0');
        else
            if ( *lpSearch ) lpSearch++;
    }

    return dwArgs;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\scandisk\main.h ===
//////////////////////////////////////////////////////////////////////////////
//
// MAIN.H / ChkDskW
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  Includes all internal and external include files, defined values, macros,
//  data structures, and fucntion prototypes for the corisponding CXX file.
//
//  8/98 - Jason Cohen (JCOHEN)
//
//////////////////////////////////////////////////////////////////////////////



// Only include this file once.
//
#ifndef _MAIN_H_
#define _MAIN_H_


//
// Include file(s).
//

#include <windows.h>
#include <tchar.h>
#include <windowsx.h>
#include <commctrl.h>
#include "resource.h"
#include "jcohen.h"
#include "misc.h"
#include "registry.h"


//
// External defined value(s).
//

#define SCANDISK_SCANNING		0x00000001
#define SCANDISK_CANCELSCAN		0x00000002
#define SCANDISK_SAGERUN		0x00000004
#define SCANDISK_SAGESET		0x00000008

// Registry key(s).
//
#define SCANDISK_REGKEY_MAIN	_T("Software\\Microsoft\\Windows\\CurrentVersion\\Applets\\Scandisk")
#define SCANDISK_REGKEY_SAGE	_T("Software\\Microsoft\\Windows\\CurrentVersion\\Applets\\Scandisk\\Sage")

// Registry value(s).
//
#define SCANDISK_REGVAL_DRIVES	_T("Drives")
#define SCANDISK_REGVAL_FIX		_T("AutoFix")
#define SCANDISK_REGVAL_SURFACE	_T("SurfaceScan")


//
// External defined macro(s).
//

#ifdef _UNICODE
#define ANSIWCHAR(lpw, lpa, cb)		lpw = lpa
#define WCHARANSI(lpa, lpw, cb)		lpa = lpw
#else // _UNICODE
#define ANSIWCHAR(lpw, lpa, cb)		MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, lpa, -1, lpw, cb / 2)
#define WCHARANSI(lpa, lpw, cb)		WideCharToMultiByte(CP_ACP, 0, lpw, -1, lpa, cb, NULL, NULL)
#endif // _UNICODE


//
// External structure(s).
//


//
// External global variable(s).
//


//
// External global constant(s).
//


//
// External function prototype(s).
//


#endif // _MAIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\scandisk\chkdsk.c ===
//////////////////////////////////////////////////////////////////////////////
//
// MAIN.C / ChkDskW
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  8/98 - Jason Cohen (JCOHEN)
//
//////////////////////////////////////////////////////////////////////////////


// Include file(s).
//
#include "main.h"
#include "fmifs.h"

// Internal global variable(s).
//
static BOOL     g_bSuccess;
static HWND     g_hProgressDlg;
static HICON    g_hIconScan[3];


// External global variable(s).
//
extern HINSTANCE    g_hInstance;
extern DWORD        g_dwFlags;


// Internal function prototype(s).
//
static DWORD WINAPI     ThreadChkdsk(LPVOID);
static BOOL CALLBACK    FmifsCallback(FMIFS_PACKET_TYPE, ULONG, PVOID);
static VOID             UpdateStatus(LPSTR);
static VOID             SummaryDialog(HWND, LPTSTR, BOOL);
static INT_PTR CALLBACK SummaryProc(HWND, UINT, WPARAM, LPARAM);
static BOOL             Summary_OnInitDialog(HWND, HWND, LPARAM);
static FARPROC          LoadDllFunction(LPTSTR, LPCSTR, HINSTANCE *);


HANDLE SpawnChkdsk(HWND hDlg, DWORD dwDrives)
{
    DWORD   dwThreadId;

    // Set that we are scanning a drive currently.
    //
    g_dwFlags |= SCANDISK_SCANNING;
    g_dwFlags &= ~SCANDISK_CANCELSCAN;

    // Set up the global variables needed.
    //
    g_bSuccess = FALSE;
    g_hProgressDlg = hDlg;

    // Load the icons for the scanning animation.
    //
    g_hIconScan[0] = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_SCAN1));
    g_hIconScan[1] = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_SCAN2));
    g_hIconScan[2] = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_SCAN3));

    // Create the thread that will run chkdsk.
    //
    return CreateThread(NULL, 0, ThreadChkdsk, (LPVOID)(ULONG_PTR)dwDrives, 0, &dwThreadId);
}


static DWORD WINAPI ThreadChkdsk(LPVOID dwDrives)
{
    HINSTANCE   hFmifsDll;
    FARPROC     Chkdsk;
    WCHAR       szwFileSystem[16],
                szwDrive[] = L"A:\\";
    TCHAR       szBuffer[256];
    INT         nCount,
                nIndex;
    LPINT       lpnSelected,
                lpnIndex;
    LPTSTR      lpBuffer,
                lpCaption,
                lpCapPre;
    DWORD_PTR   dwMask;
    BOOL        bContinue,
                bSurface,
                bFix,
                bAllHappy = FALSE;

    // Load and run the Chkdsk function.
    //
    if ( (Chkdsk = LoadDllFunction(_T("FMIFS.DLL"), "Chkdsk", &hFmifsDll)) == NULL )
        return 0;

    // Get the number of selected items and allocate a buffer to hold all the indexs.
    //
    if ( ( (nCount = (INT)SendDlgItemMessage(g_hProgressDlg, IDC_DRIVES, LB_GETSELCOUNT, 0, 0L)) > 0 ) &&
         ( lpnSelected = (LPINT) MALLOC(nCount * sizeof(INT)) ) )
    {
        // Now get the list of selected items.
        //
        if ( (nCount = (INT)SendDlgItemMessage(g_hProgressDlg, IDC_DRIVES, LB_GETSELITEMS, nCount, (LPARAM) lpnSelected)) > 0 )
        {
            // Disable the controls.
            //
            EnableWindow(GetDlgItem(g_hProgressDlg, IDOK), FALSE);
            EnableWindow(GetDlgItem(g_hProgressDlg, IDC_DRIVESTEXT), FALSE);
            EnableWindow(GetDlgItem(g_hProgressDlg, IDC_DRIVES), FALSE);
            EnableWindow(GetDlgItem(g_hProgressDlg, IDC_SURFACE), FALSE);
            EnableWindow(GetDlgItem(g_hProgressDlg, IDC_AUTOFIX), FALSE);

            // Change the text of the IDCANCEL button to Cancel (from Close).
            //
            if ( lpBuffer = AllocateString(NULL, IDS_CANCEL) )
            {
                SetDlgItemText(g_hProgressDlg, IDCANCEL, lpBuffer);
                FREE(lpBuffer);
            }

            // Get the scan options.
            //
            bSurface = IsDlgButtonChecked(g_hProgressDlg, IDC_SURFACE);
            bFix = IsDlgButtonChecked(g_hProgressDlg, IDC_AUTOFIX);

            // Get the caption prefix.
            //
            lpCapPre = AllocateString(NULL, IDS_RESULTS);

            // Loop through all the drives in the list box to see if they
            // are selected.
            //
            lpnIndex = lpnSelected;
            nIndex = 0;
            bAllHappy = TRUE;
            for (dwMask = 1; ((DWORD_PTR) dwDrives & ~(dwMask - 1)) && ( !(g_dwFlags & SCANDISK_CANCELSCAN) ); dwMask <<= 1)
            {
                // Is this drive in the list box.
                //
                if ( (DWORD_PTR) dwDrives & dwMask )
                {
                    // Test to see if this item is the
                    // next selected one.
                    //
                    if ( *lpnIndex == nIndex )
                    {
                        //
                        // Ok, try and run chkdsk on this drive.
                        //

                        // Get the file system type.
                        //
                        bContinue = TRUE;
                        while ( bContinue && !GetVolumeInformationW(szwDrive, NULL, 0, NULL, NULL, NULL, szwFileSystem, sizeof(szwFileSystem)) )
                        {
                            bContinue = FALSE;
                            if ( ( GetLastError() == ERROR_NOT_READY ) &&
                                 ( lpBuffer = AllocateString(NULL, IDS_NOTREADY) ) )
                            {
                                if ( MessageBox(g_hProgressDlg, lpBuffer, NULL, MB_RETRYCANCEL | MB_ICONERROR) == IDRETRY )
                                    bContinue = TRUE;
                                FREE(lpBuffer);
                            }
                        }

                        if ( bContinue )
                        {                       
                            // Now finally launch Chkdsk.
                            //
                            Chkdsk(szwDrive, szwFileSystem, FALSE, FALSE, FALSE, bSurface, NULL, FALSE, FmifsCallback);

                            // Make sure the user didn't cancel.
                            //
                            if ( !(g_dwFlags & SCANDISK_CANCELSCAN) )
                            {
                                // Check to see if the scan on this drive returned with errors or not.
                                //
                                if ( g_bSuccess )
                                {
                                    // Get the text to use as the caption for the summary box.
                                    //
                                    if (lpCapPre)
                                        lstrcpy(szBuffer, lpCapPre);
                                    else
                                        szBuffer[0] = _T('\0');
                                    if ( SendDlgItemMessage(g_hProgressDlg, IDC_DRIVES, LB_GETTEXT, *lpnIndex, (LPARAM) szBuffer + (lstrlen(szBuffer) * sizeof(TCHAR))) > 0 )
                                        lpCaption = szBuffer;
                                    else
                                        lpCaption = NULL;

                                    // Display the summary message for this drive.
                                    //
                                    SummaryDialog(g_hProgressDlg, NULL, g_bSuccess);

                                }
                                else
                                {
                                    bAllHappy = FALSE;

                                    // If there were errors on this drive and the user
                                    // wants to automatically fix them, we need to run
                                    // the check disk function again with the fix error
                                    // flag set (/F).  We don't do this first because if
                                    // the drive can't be locked it won't even scan the
                                    // drive to see if there is an error before asking to
                                    // check on reboot.
                                    //
                                    if ( bFix )
                                        Chkdsk(szwDrive, szwFileSystem, TRUE, FALSE, FALSE, bSurface, NULL, FALSE, FmifsCallback);
                                }
                            }

                            // Make sure the memory for the summary dialog is freed.
                            //
                            SummaryDialog(NULL, NULL, FALSE);

                            // Reset the progress control.
                            //
                            SendDlgItemMessage(g_hProgressDlg, IDC_PROGRESS, PBM_SETPOS, 0, 0L);
                            SetDlgItemText(g_hProgressDlg, IDC_STATUS, NULLSTR);
                        }
                        lpnIndex++;
                    }
                    // Keep an index of what list box
                    // item this should be.
                    //
                    nIndex++;
                }

                // Go look at the next drive
                //
                szwDrive[0]++;
            }

            // Free the caption prefix.
            //
            FREE(lpCapPre);

            // Renable the controls.
            //
            EnableWindow(GetDlgItem(g_hProgressDlg, IDOK), TRUE);
            EnableWindow(GetDlgItem(g_hProgressDlg, IDC_DRIVES), TRUE);
            EnableWindow(GetDlgItem(g_hProgressDlg, IDC_DRIVESTEXT), TRUE);
            EnableWindow(GetDlgItem(g_hProgressDlg, IDC_SURFACE), TRUE);
            EnableWindow(GetDlgItem(g_hProgressDlg, IDC_AUTOFIX), TRUE);

            // Change the text of the IDCANCEL button back to Close.
            //
            if ( lpBuffer = AllocateString(NULL, IDS_CLOSE) )
            {
                SetDlgItemText(g_hProgressDlg, IDCANCEL, lpBuffer);
                FREE(lpBuffer);
            }
        }

        FREE(lpnSelected);
    }

    // Free the DLL library.
    //
    FreeLibrary(hFmifsDll);

    // Reset the scaning bit.
    //
    g_dwFlags &= ~SCANDISK_SCANNING;

    // If we are in SAGERUN mode, end the dialog now that
    // we are finished scanning.
    //
    if ( g_dwFlags & SCANDISK_SAGERUN )
        EndDialog(g_hProgressDlg, 0);

    // Return the success or failure.
    //
    return (DWORD) bAllHappy;
}




static BOOL CALLBACK FmifsCallback(FMIFS_PACKET_TYPE PacketType, ULONG PacketLength, PVOID PacketData)
{

#ifdef _DEBUG
    DWORD   dwBytes;
    TCHAR   szDebug[1024] = NULLSTR;
    HANDLE  hFile = CreateFile(_T("C:\\SCANDISK.LOG"), GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    switch (PacketType)
    {
        case FmIfsPercentCompleted:
            wsprintf(szDebug, _T("DEBUG: FmifsCallback() - FmIfsPercentCompleted (%d%%)\r\n"), ((PFMIFS_PERCENT_COMPLETE_INFORMATION) PacketData)->PercentCompleted);
            break;
        case FmIfsFormatReport:
            wsprintf(szDebug, _T("DEBUG: FmifsCallback() - FmIfsFormatReport\r\n"));
            break;
        case FmIfsInsertDisk:
            wsprintf(szDebug, _T("DEBUG: FmifsCallback() - FmIfsInsertDisk\r\n"));
            break;
        case FmIfsIncompatibleFileSystem:
            wsprintf(szDebug, _T("DEBUG: FmifsCallback() - FmIfsIncompatibleFileSystem\r\n"));
            break;
        case FmIfsFormattingDestination:
            wsprintf(szDebug, _T("DEBUG: FmifsCallback() - FmIfsFormattingDestination\r\n"));
            break;
        case FmIfsIncompatibleMedia:
            wsprintf(szDebug, _T("DEBUG: FmifsCallback() - FmIfsIncompatibleMedia\r\n"));
            break;
        case FmIfsAccessDenied:
            wsprintf(szDebug, _T("DEBUG: FmifsCallback() - FmIfsAccessDenied\r\n"));
            break;
        case FmIfsMediaWriteProtected:
            wsprintf(szDebug, _T("DEBUG: FmifsCallback() - FmIfsMediaWriteProtected\r\n"));
            break;
        case FmIfsCantLock:
            wsprintf(szDebug, _T("DEBUG: FmifsCallback() - FmIfsCantLock\r\n"));
            break;
        case FmIfsCantQuickFormat:
            wsprintf(szDebug, _T("DEBUG: FmifsCallback() - FmIfsCantQuickFormat\r\n"));
            break;
        case FmIfsIoError:
            wsprintf(szDebug, _T("DEBUG: FmifsCallback() - FmIfsIoError\r\n"));
            break;
        case FmIfsFinished:
            wsprintf(szDebug, _T("DEBUG: FmifsCallback() - FmIfsFinished (%s)\r\n"), ((PFMIFS_FINISHED_INFORMATION) PacketData)->Success ? _T("TRUE") : _T("FALSE"));
            break;
        case FmIfsBadLabel:
            wsprintf(szDebug, _T("DEBUG: FmifsCallback() - FmIfsBadLabel\r\n"));
            break;
        case FmIfsCheckOnReboot:
            wsprintf(szDebug, _T("DEBUG: FmifsCallback() - FmIfsCheckOnReboot\r\n"));
            break;
        case FmIfsTextMessage:
            break;
        case FmIfsHiddenStatus:
            wsprintf(szDebug, _T("DEBUG: FmifsCallback() - FmIfsHiddenStatus\r\n"));
            break;
        case FmIfsClusterSizeTooSmall:
            wsprintf(szDebug, _T("DEBUG: FmifsCallback() - FmIfsClusterSizeTooSmall\r\n"));
            break;
        case FmIfsClusterSizeTooBig:
            wsprintf(szDebug, _T("DEBUG: FmifsCallback() - FmIfsClusterSizeTooBig\r\n"));
            break;
        case FmIfsVolumeTooSmall:
            wsprintf(szDebug, _T("DEBUG: FmifsCallback() - FmIfsVolumeTooSmall\r\n"));
            break;
        case FmIfsVolumeTooBig:
            wsprintf(szDebug, _T("DEBUG: FmifsCallback() - FmIfsVolumeTooBig\r\n"));
            break;
        case FmIfsNoMediaInDevice:
            wsprintf(szDebug, _T("DEBUG: FmifsCallback() - FmIfsNoMediaInDevice\r\n"));
            break;
    }

    if ( hFile != INVALID_HANDLE_VALUE )
    {
        if ( szDebug[0] )
        {
            SetFilePointer(hFile, 0, 0, FILE_END);
            WriteFile(hFile, szDebug, lstrlen(szDebug) * sizeof(TCHAR), &dwBytes, NULL);
        }
        CloseHandle(hFile);
    }
#endif // _DEBUG

    switch (PacketType)
    {
        case FmIfsPercentCompleted:
            // Advance the current position of the progress bar
            // to the percent returned.
            //
            SendDlgItemMessage(g_hProgressDlg, IDC_PROGRESS, PBM_SETPOS, ((PFMIFS_PERCENT_COMPLETE_INFORMATION) PacketData)->PercentCompleted, 0L);
            SendDlgItemMessage(g_hProgressDlg, IDC_SCANDISK, STM_SETIMAGE, IMAGE_ICON, (LPARAM) g_hIconScan[((PFMIFS_PERCENT_COMPLETE_INFORMATION) PacketData)->PercentCompleted % 3]);
            break;

        case FmIfsFinished:
            g_bSuccess = !((PFMIFS_FINISHED_INFORMATION) PacketData)->Success;
            break;

        case FmIfsTextMessage:
            UpdateStatus(((PFMIFS_TEXT_MESSAGE) PacketData)->Message);
            break;

        case FmIfsCheckOnReboot:
            ((PFMIFS_CHECKONREBOOT_INFORMATION) PacketData)->QueryResult =
                            (MessageBox(g_hProgressDlg, _T("This drive contains errors and must be checked on startup.\n\n")
                                                        _T("Do you want this drive to be checked next time you restart you computer?"), _T("Scandisk"), MB_YESNO | MB_ICONERROR) == IDYES);
            break;
    }

    return ( !(g_dwFlags & SCANDISK_CANCELSCAN) );
}


static VOID UpdateStatus(LPSTR lpText)
{
    TCHAR   szTextOut[256];
    LPTSTR  lpChkDsk    = NULL,
            lpScanDisk  = NULL,
            lpSearch,
            lpCopy,
            lpNewText;
    DWORD   dwLen;
    HANDLE  hFile = INVALID_HANDLE_VALUE;
#ifdef _UNICODE
    TCHAR   wcHeader = 0x0000;
    TCHAR   szNewText[256];
#endif // _UNICODE

#ifdef _UNICODE
    if ( MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, lpText, -1, szNewText, sizeof(szNewText)) )
    {
        // If this is unicode, make sure the poitner passed in points to a unicode string.
        //
        lpNewText = szNewText;

        // See if we need to write the header bit so that notepad will
        // see the file as unicode.
        //
        if ( (hFile = CreateFile(_T("C:\\SCANDISK.LOG"), GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL)) == INVALID_HANDLE_VALUE )
            wcHeader = 0xFEFF;
#else // _UNICODE
        lpNewText = lpText;
#endif // _UNICODE

        // Write to the log file.
        //
        if ( ( hFile != INVALID_HANDLE_VALUE ) ||
             ( (hFile = CreateFile(_T("C:\\SCANDISK.LOG"), GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL)) != INVALID_HANDLE_VALUE ) )
        {
#ifdef _UNICODE
            if ( wcHeader )
                WriteFile(hFile, &wcHeader, sizeof(WCHAR), &dwLen, NULL);
#endif // _UNICODE
            SetFilePointer(hFile, 0, 0, FILE_END);
            WriteFile(hFile, (LPTSTR) lpNewText, lstrlen((LPTSTR) lpNewText) * sizeof(TCHAR), &dwLen, NULL);
            CloseHandle(hFile);
        }

        // Remove proceeding characters we don't want (space, \r, \n, \t).
        //
        for (lpSearch = (LPTSTR) lpNewText; (*lpSearch == _T(' ')) || (*lpSearch == _T('\r')) || (*lpSearch == _T('\n')) || (*lpSearch == _T('\t')); lpSearch++);

        if ( ISNUM(*lpSearch) )
        {
            // We want this info for the summary page.
            //
            SummaryDialog(g_hProgressDlg, lpSearch, FALSE);
        }
        else
        {
            if ( ( lpChkDsk = AllocateString(NULL, IDS_CHKDSK) ) &&
                 ( lpScanDisk = AllocateString(NULL, IDS_SCANDISK) ) )
            {
                dwLen = lstrlen(lpChkDsk);
                lpCopy = szTextOut;
                while ( (*lpSearch != _T('\0')) && (*lpSearch != _T('\r')) )
                {
                    if ( _tcsncmp(lpSearch, lpChkDsk, dwLen) == 0 )
                    {
                        lstrcpy(lpCopy, lpScanDisk);
                        lpSearch += dwLen;
                        lpCopy += lstrlen(lpScanDisk);
                    }
                    else
                        *lpCopy++ = *lpSearch++;
                }
                *lpCopy = _T('\0');
                SetDlgItemText(g_hProgressDlg, IDC_STATUS, szTextOut);
            }           
            FREE(lpScanDisk);
            FREE(lpChkDsk);
        }
#ifdef _UNICODE
    }
#endif // _UNICODE
}


static VOID SummaryDialog(HWND hWndParent, LPTSTR lpText, BOOL bSuccess)
{
    static LPTSTR   lpSumText[16];
    static DWORD    dwIndex = 0;

    LPTSTR          lpSearch;

    // First check to make sure lpText is a valid pointer.  If it is NULL
    // then we must be showing the summary dialog and/or freeing the memory.
    //
    if ( lpText )
    {
        // Make sure we don't already have 16 strings in our buffer.
        //
        if ( dwIndex < 16 )
        {
            //
            // lpText should already point to the first digit of the number
            // part of the summary.
            //

            // We need a pointer to the text after the number.  We will search
            // for the first space, which should divide the number and the text.
            //
            for (lpSearch = lpText; (*lpSearch) && (*lpSearch != _T(' ')); lpSearch++);

            // Now that we know where the number ends, we can allocate a buffer for it
            // and copy the number into it.
            //
            if ( lpSumText[dwIndex++] = (LPTSTR) MALLOC((size_t)((lpSearch - lpText + 1) * sizeof(TCHAR))) )
                lstrcpyn(lpSumText[dwIndex - 1], lpText, (size_t)(lpSearch - lpText + 1));

            // We should advance lpSearch to point to the text description, because now
            // it should point to a space (unless we hit the end of the string before the space).
            //
            if ( *lpSearch )
                lpSearch++;

            // Now we need to know where the text description ends.  We just want to search
            // for the first new line or line feed character.
            //
            for (lpText = lpSearch; (*lpSearch) && (*lpSearch != _T('\r')) && (*lpSearch != _T('\n')); lpSearch++);

            // Now that we know where the text ends, we can allocate a buffer for it
            // also and copy the text into it.
            //
            if ( lpSumText[dwIndex++] = (LPTSTR) MALLOC((size_t)((lpSearch - lpText + 1) * sizeof(TCHAR))) )
                lstrcpyn(lpSumText[dwIndex - 1], lpText, (size_t)(lpSearch - lpText + 1));
        }
    }
    else
    {
        // We check to make sure dwIndex still isn't zero, because if it is,
        // there is no text to display in the summary dialog or to free.
        //
        if ( dwIndex > 0 )
        {
            // If the hwnd is valid and the text is null, then we are
            // going to display the summary box.
            //
            if ( hWndParent )
                DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_SUMMARY), hWndParent, SummaryProc, (LPARAM) lpSumText);

            //
            // Now free the memory because eaither a NULL was passed in for the hwnd
            // or we already displayed the dialog and now the memory needs to be freed.
            //
            
            // Loop through all the strings that may have
            // been allocated by going back from where the index
            // is now.
            //
            // Note that some of the pointers may contain NULL
            // if a malloc failed, but the FREE() macro will check
            // with that before freeing the memory.
            //
            while ( dwIndex-- > 0 )
                FREE(lpSumText[dwIndex]);

            // Reset the index so that it doesn't get messed up
            // the next time we display a summary.
            //
            dwIndex = 0;
        }
    }
}


static INT_PTR CALLBACK SummaryProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hDlg, WM_INITDIALOG, Summary_OnInitDialog);
        case WM_COMMAND:
            if ( (INT) LOWORD(wParam) != IDOK )
                return TRUE;
        case WM_CLOSE:
            EndDialog(hDlg, 0);
            return 0;
    }
    return FALSE;
}


static BOOL Summary_OnInitDialog(HWND hDlg, HWND hwndFocus, LPARAM lParam)
{
    INT nSumId[] =
    {
        IDC_SUM1A, IDC_SUM1B, IDC_SUM2A, IDC_SUM2B,
        IDC_SUM3A, IDC_SUM3B, IDC_SUM4A, IDC_SUM4B,
        IDC_SUM5A, IDC_SUM5B, IDC_SUM6A, IDC_SUM6B,
        IDC_SUM7A, IDC_SUM7B, IDC_SUM8A, IDC_SUM8B
    };

    LPTSTR  *lpStrings = (LPTSTR *) lParam;
    DWORD   dwIndex;

    for (dwIndex = 0; dwIndex < 16; dwIndex++)
        SetDlgItemText(hDlg, nSumId[dwIndex], *(lpStrings++));

    return FALSE;
}


static FARPROC LoadDllFunction(LPTSTR lpDll, LPCSTR lpFunction, HINSTANCE * lphDll)
{
    FARPROC hFunc = NULL;

    if ( (*lphDll) = LoadLibrary(lpDll) )
    {
        if ( (hFunc = GetProcAddress(*lphDll, lpFunction)) == NULL )
        {
            FreeLibrary(*lphDll);
            *lphDll = NULL;
        }
    }
    else
        *lphDll = NULL;

    return hFunc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\scandisk\misc.c ===
//////////////////////////////////////////////////////////////////////////////
//
// MISC.CPP
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  Contains misc. functions used throughout the program.  All these functions
//  are externally exported and defined in MISC.H.
//
//  7/98 - Jason Cohen (JCOHEN)
//
//////////////////////////////////////////////////////////////////////////////


// Include files.
//
#include "misc.h"


LPTSTR AllocateString(HINSTANCE hInstance, UINT uID)
{
	TCHAR	szBuffer[512];
	LPTSTR	lpBuffer = NULL;

	if ( ( LoadString(hInstance, uID, szBuffer, sizeof(szBuffer) / sizeof(TCHAR)) ) &&
	     ( lpBuffer = (LPTSTR) MALLOC(sizeof(TCHAR) * (lstrlen(szBuffer) + 1)) ) )
		lstrcpy(lpBuffer, szBuffer);
	return lpBuffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\scandisk\misc.h ===
//////////////////////////////////////////////////////////////////////////////
//
// MISC.H
//
//  Microsoft Confidential
//  Copyright (c) Pacific Access Communications Corporation 1998
//  All rights reserved
//
//  Misc. functions prototypes.
//
//  8/98 - Jason Cohen (JCOHEN)
//
//////////////////////////////////////////////////////////////////////////////


#ifndef _MISCFUNC_H_
#define _MISCFUNC_H_


// Include files
//
#include <windows.h>
#include <tchar.h>
#include "jcohen.h"


// Exported function prototypes.
//
LPTSTR	AllocateString(HINSTANCE, UINT);


#endif // _MISCFUNC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\seclist\sources.inc ===
!IF 0

Copyright (c) 1989-2001 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

TARGETNAME=seclist
TARGETPATH=obj
TARGETTYPE=PROGRAM

SOURCES= \
    seclist.cxx \
    seclist.rc

USE_MSVCRT=1

INCLUDES= \
    ..; \
    $(PROJECT_ROOT)\fs\utils\ulib\inc; \
    $(PROJECT_ROOT)\fs\utils\ifsutil\inc; \
    $(PROJECT_ROOT)\fs\utils\ufat\inc;\
    $(DDK_INC_PATH)

C_DEFINES=-DUNICODE=1 -DNOMINMAX

!if $(FREEBUILD)
C_DEFINES=$(C_DEFINES) /DDBG=0
!else
C_DEFINES=$(C_DEFINES) /DDBG=1
!IFNDEF NOMEMLEAK
C_DEFINES=$(C_DEFINES) /DMEMLEAK
!ENDIF
!IFDEF STACK_TRACE
C_DEFINES=$(C_DEFINES) /DSTACK_TRACE
!ENDIF
!ENDIF

TARGETLIBS= \
    $(PROJECT_ROOT)\fs\utils\ulib\src\$(ALT_PROJECT)\$(O)\ulib.lib          \
    $(PROJECT_ROOT)\fs\utils\ifsutil\src\$(ALT_PROJECT)\$(O)\ifsutil.lib    \
    $(PROJECT_ROOT)\fs\utils\ufat\src\$(ALT_PROJECT)\$(O)\ufat.lib          \
    $(SDK_LIB_PATH)\ntdll.lib

UMTYPE=console

W32_SB=1
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\seclist\seclist.cxx ===
/*++

Copyright (c) 1992-2000 Microsoft Corporation

Module Name:

        SecList.cxx

Abstract:

        Sector list utility

Author:

        Bill McJohn (billmc) 30-July-92

Revision History:

--*/

#define _NTAPI_ULIB_

#include "ulib.hxx"

#include "wstring.hxx"
#include "path.hxx"
#include "smsg.hxx"

#include "system.hxx"
#include "ifssys.hxx"
#include "substrng.hxx"

#include "ulibcl.hxx"

#include "keyboard.hxx"

#include "fatvol.hxx"
#include "fatsa.hxx"
#include "rfatsa.hxx"
#include "fat.hxx"

extern "C" {
#include <stdio.h>
}

BOOLEAN HexOutput = FALSE;

BOOLEAN
FatSecList(
    PWSTRING    NtDriveName,
    PPATH       TargetPath,
    PMESSAGE    Message
    )
{
    LOG_IO_DP_DRIVE Drive;
    REAL_FAT_SA FatSa;
    PFAT        Fat;
    ULONG       SectorsPerCluster, Sector, i;
    ULONG       Cluster;

    if( !Drive.Initialize( NtDriveName, Message ) ||
        !FatSa.Initialize( &Drive, Message )      ||
        !FatSa.FAT_SA::Read()                     ||
        !(Fat = FatSa.GetFat()) ) {

        return FALSE;
    }

    SectorsPerCluster = FatSa.QuerySectorsPerCluster();

    Cluster = FatSa.QueryFileStartingCluster( TargetPath->GetPathString() );

    if( Cluster == 1 || Cluster == 0xFFFF ) {

        printf( "File not found.\n" );
        return FALSE;
    }

    if( Cluster == 0 ) {

        // Zero-length file.
        //
        return TRUE;
    }

    while( TRUE ) {

        Sector = (Cluster - FirstDiskCluster) * SectorsPerCluster +
                 FatSa.QueryStartDataLbn();

        for( i = 0; i < SectorsPerCluster; i++ ) {

            if( HexOutput ) {

                printf( "0x%x\n", Sector + i );

            } else {

                printf( "%d\n", Sector + i );
            }
        }

        if( Fat->IsEndOfChain( Cluster ) ) {

            break;
        }

        Cluster = Fat->QueryEntry( Cluster );
    }

    return TRUE;
}


int __cdecl
main(
    int argc,
    char **argv
    )
/*++
--*/
{
    WCHAR PathString[512];
    STR   DisplayBuffer[512];

    PATH Path;
    DSTRING NtDriveName, FsName, HpfsString, NtfsString, FatString;
    STREAM_MESSAGE Message;

    PWSTRING DosDriveName;

    NTSTATUS Status;
    BOOLEAN Result;
    ULONG i, Length;


    if( argc < 2 ) {

        printf( "usage: %s full-path [-x]\n", argv[0] );
        exit(1);
    }

    if( argc >= 3 &&
        argv[2][0] == '-' &&
        argv[2][1] == 'x' ) {

        HexOutput = TRUE;
    }

    if (!Message.Initialize(Get_Standard_Output_Stream(),
                        Get_Standard_Input_Stream())) {

        printf( "Can't initialize MESSAGE object.\n" );
        exit(1);
    }

    // Convert argv[1] to a WSTR using brute force.
    //
    Length = strlen( argv[1] );

    for( i = 0; i < Length; i++ ) {

        PathString[i] = argv[1][i];
    }

    PathString[Length] = 0;


    if( !Path.Initialize( PathString, TRUE ) ) {

        printf( "Unable to initialize path object.\n" );
        exit(1);
    }

    // Get the drive from the path and convert it to
    // an NTFS name.
    //
    if( (DosDriveName = Path.QueryDevice()) == NULL ) {

        DELETE( DosDriveName );
        printf( "Cannot get drive from path.\n" );
        exit(1);
    }

    if (!IFS_SYSTEM::DosDriveNameToNtDriveName(DosDriveName, &NtDriveName)) {

        DELETE(DosDriveName);
        return 1;
    }

    DELETE( DosDriveName );


    // Determine the file system on the drive.
    //
    if (!IFS_SYSTEM::QueryFileSystemName(&NtDriveName, &FsName, &Status)) {

        printf( "Cannot determine NT Drive name.  (Status = 0x%x\n)", Status );
        exit(1);
    }

    if( !FsName.QuerySTR( 0, TO_END, DisplayBuffer, 512 ) ) {

        printf( "QuerySTR failed.\n" );
        exit(1);
    }

    if( !FatString.Initialize( "FAT" ) ||
        !NtfsString.Initialize( "NTFS" ) ) {

        printf( "Can't initialize file-system name strings.\n" );
        exit(1);
    }

    if( FsName.Stricmp( &FatString ) == 0 ) {

        Result = FatSecList( &NtDriveName, &Path, &Message );

    } else if( FsName.Stricmp( &NtfsString ) == 0 ) {

        printf( "NTFS is not supported.\n" );
        exit(1);
    }

    if( Result ) {

        exit(0);

    } else {

        printf( "Seclist failed.\n" );
        exit(1);
    }
    //NOTREACHED
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\scandisk\registry.h ===
//////////////////////////////////////////////////////////////////////////////
//
// REGISTRY.H
//
//  Pacific Access Confidential
//  Copyright (c) Pacific Access Communications Corporation 1998
//  All rights reserved
//
//  Registry function prototypes for the application.
//
//  4/98 - Jason Cohen (JCOHEN)
//
//////////////////////////////////////////////////////////////////////////////


#ifndef _REGISTRY_H_
#define _REGISTRY_H_


//
// Defined root keys.
//

#define HKCR	HKEY_CLASSES_ROOT
#define HKCU	HKEY_CURRENT_USER
#define HKLM	HKEY_LOCAL_MACHINE
#define HKU		HKEY_USERS



//
// Type definitions.
//

typedef BOOL (CALLBACK * REGENUMKEYPROC) (HKEY, LPTSTR, LPARAM);
typedef BOOL (CALLBACK * REGENUMVALPROC) (LPTSTR, LPTSTR, LPARAM);


//
// External function prototypes.
//

BOOL	RegExists(HKEY, LPTSTR, LPTSTR);
BOOL	RegDelete(HKEY, LPTSTR, LPTSTR);
LPTSTR 	RegGetString(HKEY, LPTSTR, LPTSTR);
LPVOID	RegGetBin(HKEY, LPTSTR, LPTSTR);
DWORD 	RegGetDword(HKEY, LPTSTR, LPTSTR);
BOOL	RegSetString(HKEY, LPTSTR, LPTSTR, LPTSTR);
BOOL	RegSetDword(HKEY, LPTSTR, LPTSTR, DWORD);
BOOL	RegCheck(HKEY, LPTSTR, LPTSTR);
BOOL    RegEnumKeys(HKEY, LPTSTR, REGENUMKEYPROC, LPARAM, BOOL);
BOOL    RegEnumValues(HKEY, LPTSTR, REGENUMVALPROC, LPARAM, BOOL);


#endif // _REGISTRY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\scandisk\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by main.rc
//
#define IDS_SUCCESS                     1
#define IDS_FAILURE                     2
#define IDS_NOTREADY                    3
#define IDS_RESULTS                     4
#define IDS_CHKDSK                      5
#define IDS_SCANDISK                    6
#define IDS_CANCEL                      7
#define IDS_CLOSE                       8
#define IDS_OK                          9
#define IDD_MAIN                        101
#define IDI_MAIN                        101
#define IDI_WARN                        102
#define IDD_ERROR                       102
#define IDD_SUMMARY                     103
#define IDI_SCANDISK                    105
#define IDI_SCAN1                       106
#define IDI_SCAN2                       107
#define IDI_SCAN3                       108
#define IDC_RESTART2                    1001
#define IDC_FIX                         1001
#define IDC_RESTART                     1002
#define IDC_SKIP                        1003
#define IDC_REMIND                      1004
#define IDC_TIME                        1005
#define IDC_SCROLLBAR1                  1006
#define IDC_TIMESB                      1006
#define IDC_ESTIMATED                   1007
#define IDC_DRIVES                      1008
#define IDC_STATUS                      1009
#define IDC_PROGRESS                    1010
#define IDC_DRIVESTEXT                  1011
#define IDC_SURFACE                     1012
#define IDC_AUTOFIX                     1013
#define IDC_SCANDISK                    1014
#define IDC_SUM1A                       1015
#define IDC_SUM1B                       1016
#define IDC_SUM2A                       1017
#define IDC_SUM2B                       1018
#define IDC_SUM3A                       1019
#define IDC_SUM3B                       1020
#define IDC_SUM4A                       1021
#define IDC_SUM4B                       1022
#define IDC_SUM5A                       1023
#define IDC_SUM5B                       1024
#define IDC_SUM6A                       1025
#define IDC_SUM6B                       1026
#define IDC_SUM7A                       1027
#define IDC_SUM7B                       1028
#define IDC_SUM8A                       1029
#define IDC_SUM8B                       1030

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        109
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1031
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\sigverif\advanced.c ===
//
// Advanced.C
//
#include "sigverif.h"

//
//  Initialization of search dialog.
//
BOOL Search_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{   
    TCHAR szBuffer[MAX_PATH];

    g_App.hSearch = hwnd;

    // Since the "check system files" option is faster, check that option by default
    if (!g_App.bUserScan)
        CheckRadioButton(hwnd, IDC_SCAN, IDC_NOTMS, IDC_SCAN);
    else CheckRadioButton(hwnd, IDC_SCAN, IDC_NOTMS, IDC_NOTMS);

    // Pre-load the user's search path with the Windows directory
    if (!*g_App.szScanPath)
    {
        MyGetWindowsDirectory(g_App.szScanPath, MAX_PATH);
    }

    // Display the current search folder
    SetDlgItemText(hwnd, IDC_FOLDER, g_App.szScanPath);

    // Pre-load the user's search pattern with "*.*"
    if (!*g_App.szScanPattern)
    {
        MyLoadString(g_App.szScanPattern, IDS_ALL);
    }

    // Display the current search pattern.
    SetDlgItemText(hwnd, IDC_TYPE, szBuffer);

    // Now disable all the dialog items associated with IDS_NOTMS
    if (!g_App.bUserScan)
    {
        EnableWindow(GetDlgItem(hwnd, IDC_SUBFOLDERS), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_TYPE), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_FOLDER), FALSE);
        EnableWindow(GetDlgItem(hwnd, ID_BROWSE), FALSE);
    }

    // If we are searching subdirectories, check the SubFolders checkbox
    if (g_App.bSubFolders)
        CheckDlgButton(hwnd, IDC_SUBFOLDERS, BST_CHECKED);
    else CheckDlgButton(hwnd, IDC_SUBFOLDERS, BST_UNCHECKED);

    // Set the combobox value to g_App.szScanPattern
    SetDlgItemText(hwnd, IDC_TYPE, g_App.szScanPattern);

    // Initialize the combobox with several pre-defined extension types
    MyLoadString(szBuffer, IDS_EXE);
    SendMessage(GetDlgItem(hwnd, IDC_TYPE), CB_ADDSTRING, (WPARAM) 0, (LPARAM) szBuffer);
    MyLoadString(szBuffer, IDS_DLL);
    SendMessage(GetDlgItem(hwnd, IDC_TYPE), CB_ADDSTRING, (WPARAM) 0, (LPARAM) szBuffer);
    MyLoadString(szBuffer, IDS_SYS);
    SendMessage(GetDlgItem(hwnd, IDC_TYPE), CB_ADDSTRING, (WPARAM) 0, (LPARAM) szBuffer);
    MyLoadString(szBuffer, IDS_DRV);
    SendMessage(GetDlgItem(hwnd, IDC_TYPE), CB_ADDSTRING, (WPARAM) 0, (LPARAM) szBuffer);
    MyLoadString(szBuffer, IDS_OCX);
    SendMessage(GetDlgItem(hwnd, IDC_TYPE), CB_ADDSTRING, (WPARAM) 0, (LPARAM) szBuffer);
    MyLoadString(szBuffer, IDS_ALL);
    SendMessage(GetDlgItem(hwnd, IDC_TYPE), CB_ADDSTRING, (WPARAM) 0, (LPARAM) szBuffer);

    return TRUE;
}

//
//  Handle any WM_COMMAND messages sent to the search dialog
//
void Search_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    switch(id) 
    {
        //  The user clicked the ID_BROWSE button, so call BrowseForFolder and update IDC_FOLDER
        case ID_BROWSE:
            if (BrowseForFolder(hwnd, g_App.szScanPath))
            {
                SetDlgItemText(hwnd, IDC_FOLDER, g_App.szScanPath);
            }
            break;

        //  The user clicked IDC_SCAN, so disable all the IDC_NOTMS controls
        case IDC_SCAN:
            if (!g_App.bScanning)
            {
                EnableWindow(GetDlgItem(hwnd, IDC_SUBFOLDERS), FALSE);
                EnableWindow(GetDlgItem(hwnd, IDC_TYPE), FALSE);
                EnableWindow(GetDlgItem(hwnd, IDC_FOLDER), FALSE);
                EnableWindow(GetDlgItem(hwnd, ID_BROWSE), FALSE);
            }
            break;

        //  The user clicked IDC_NOTMS, so make sure all the controls are enabled
        case IDC_NOTMS:
            if (!g_App.bScanning)
            {
                EnableWindow(GetDlgItem(hwnd, IDC_SUBFOLDERS), TRUE);
                EnableWindow(GetDlgItem(hwnd, IDC_TYPE), TRUE);
                EnableWindow(GetDlgItem(hwnd, IDC_FOLDER), TRUE);
                EnableWindow(GetDlgItem(hwnd, ID_BROWSE), TRUE);
            }
            break;
    }
}

//
// This function handles any notification messages for the Search page.
//
LRESULT Search_NotifyHandler(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    NMHDR *lpnmhdr = (NMHDR *) lParam;

    switch(lpnmhdr->code)
    {
        case PSN_APPLY:         g_App.bUserScan = (IsDlgButtonChecked(hwnd, IDC_NOTMS) == BST_CHECKED);
                                if (g_App.bUserScan)
                                {
                                    // Get the search pattern from the combobox and update g_App.szScanPattern
                                    GetDlgItemText(hwnd, IDC_TYPE, g_App.szScanPattern, MAX_PATH);
                                    // Get the path from the edit control and update g_App.szScanPath
                                    GetDlgItemText(hwnd, IDC_FOLDER, g_App.szScanPath, MAX_PATH);
                                    // Get the checked/unchecked state of the "SubFolders" checkbox
                                    g_App.bSubFolders = (IsDlgButtonChecked(hwnd, IDC_SUBFOLDERS) == BST_CHECKED);
                                }
        case PSN_KILLACTIVE:    return FALSE;
    }

    return 0;
}


//
//  The search dialog procedure.  Needs to handle WM_INITDIALOG, WM_COMMAND, and WM_CLOSE/WM_DESTROY.
//
INT_PTR CALLBACK Search_DlgProc(HWND hwnd, UINT uMsg,
                                WPARAM wParam, LPARAM lParam)
{
    BOOL    fProcessed = TRUE;

    switch (uMsg) 
    {
        HANDLE_MSG(hwnd, WM_INITDIALOG, Search_OnInitDialog);
        HANDLE_MSG(hwnd, WM_COMMAND, Search_OnCommand);

        case WM_NOTIFY:
            return Search_NotifyHandler(hwnd, uMsg, wParam, lParam);

        case WM_HELP:
            SigVerif_Help(hwnd, uMsg, wParam, lParam, FALSE);
            break;

        case WM_CONTEXTMENU:
            SigVerif_Help(hwnd, uMsg, wParam, lParam, TRUE);
            break;

        default: fProcessed = FALSE;
    }

    return fProcessed;
}

void AdvancedPropertySheet(HWND hwnd)
{
    PROPSHEETPAGE   psp[NUM_PAGES];
    PROPSHEETHEADER psh;
    TCHAR           szCaption[MAX_PATH];
    TCHAR           szPage1[MAX_PATH];
    TCHAR           szPage2[MAX_PATH];
    
    ZeroMemory(&psp[0], sizeof(PROPSHEETPAGE));
    psp[0].dwSize = sizeof(PROPSHEETPAGE);
    psp[0].dwFlags = PSP_USEHICON | PSP_USETITLE;
    psp[0].hInstance = g_App.hInstance;
    psp[0].pszTemplate = MAKEINTRESOURCE(IDD_SEARCH);
    psp[0].hIcon = g_App.hIcon;
    psp[0].pfnDlgProc = Search_DlgProc;
    MyLoadString(szPage1, IDS_SEARCHTAB);
    psp[0].pszTitle = szPage1;
    psp[0].lParam = 0;
    psp[0].pfnCallback = NULL;

    ZeroMemory(&psp[1], sizeof(PROPSHEETPAGE));
    psp[1].dwSize = sizeof(PROPSHEETPAGE);
    psp[1].dwFlags = PSP_USEHICON | PSP_USETITLE;
    psp[1].hInstance = g_App.hInstance;
    psp[1].pszTemplate = MAKEINTRESOURCE(IDD_SETTINGS);
    psp[1].hIcon = g_App.hIcon;
    psp[1].pfnDlgProc = LogFile_DlgProc;
    MyLoadString(szPage2, IDS_LOGGINGTAB);
    psp[1].pszTitle = szPage2;
    psp[1].lParam = 0;
    psp[1].pfnCallback = NULL;

    ZeroMemory(&psh, sizeof(PROPSHEETHEADER));
    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_USEHICON | PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW;
    psh.hwndParent = hwnd;
    psh.hInstance = g_App.hInstance;
    psh.hIcon = g_App.hIcon;
    MyLoadString(szCaption, IDS_ADVANCED_SETTINGS);
    psh.pszCaption = szCaption;
    psh.nPages = sizeof(psp) / sizeof(PROPSHEETPAGE);
    psh.nStartPage = 0;
    psh.ppsp = (LPCPROPSHEETPAGE) &psp;
    psh.pfnCallback = NULL;

    PropertySheet(&psh);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\sigverif\browse.c ===
//
// Browse.C
//
#include "sigverif.h"

// Global browse buffer that is used until user click OK or Cancel
TCHAR g_szBrowsePath[MAX_PATH];

//
// This callback function handles the initialization of the browse dialog and when
// the user changes the selection in the tree-view.  We want to keep updating the 
// g_szBrowsePath buffer with selection changes until the user clicks OK.
//
int CALLBACK BrowseCallbackProc(
    HWND hwnd, 
    UINT uMsg, 
    LPARAM lParam, 
    LPARAM lpData 
    )
{
    int iRet = 0;
    TCHAR PathName[MAX_PATH];
    LPTSTR lpPathName = PathName;
    LPITEMIDLIST lpid;

    switch (uMsg) {
    
    case BFFM_INITIALIZED:
        //
        // Initialize the dialog with the OK button and g_szBrowsePath
        //
        SendMessage(hwnd, BFFM_ENABLEOK, (WPARAM) 0, (LPARAM) 1);
        SendMessage(hwnd, BFFM_SETSELECTION, (WPARAM) TRUE, (LPARAM) g_szBrowsePath);
        break;

    case BFFM_SELCHANGED:   
        lpid = (LPITEMIDLIST) lParam;
        
        if (SHGetPathFromIDList(lpid, lpPathName)) {
            
            //
            // If the path is good, then update g_szBrowsePath
            //
            lstrcpy(g_szBrowsePath, lpPathName);
        }
        
        SendMessage(hwnd, BFFM_ENABLEOK, (WPARAM) 0, (LPARAM) 1);
        break;
    }

    return iRet;
}  

//
// This uses SHBrowseForFolder to get the directory the user wants to search.
// We specify a callback function that updates g_szBrowsePath until the user clicks OK or Cancel.
// If they clicked OK, then we update the string passed in to us as lpszBuf.
// 
//
BOOL BrowseForFolder(HWND hwnd, LPTSTR lpszBuf) {

    BROWSEINFO          bi;
    TCHAR               szBuffer[MAX_PATH],
    szMessage[MAX_PATH];
    LPITEMIDLIST        lpid;

    //
    // Check if the lpszBuf path is valid, if so use that as the browse dialog's initial directory.
    // If it isn't valid, initialize g_szBrowsePath with the Windows directory.
    //
    if (!SetCurrentDirectory(lpszBuf)) {
        
        MyGetWindowsDirectory(g_szBrowsePath, MAX_PATH);
    
    } else {
        
        lstrcpy(g_szBrowsePath, lpszBuf);
    }

    //
    // Start the root of the browse dialog in the CSIDL_DRIVES namespace
    //
    if (!SUCCEEDED(SHGetSpecialFolderLocation(hwnd, CSIDL_DRIVES, &lpid))) {
    
        return FALSE;
    }

    //
    // This loads in the "Please select a directory" text into the dialog.
    //
    MyLoadString(szMessage, IDS_SELECTDIR);

    //
    // Setup the BrowseInfo struct.
    //
    bi.hwndOwner        = hwnd;
    bi.pidlRoot         = lpid;
    bi.pszDisplayName   = szBuffer;
    bi.lpszTitle        = szMessage;
    bi.ulFlags          = BIF_RETURNONLYFSDIRS;
    bi.lpfn             = (BFFCALLBACK) BrowseCallbackProc;
    bi.lParam           = 0x123;

    if (SHBrowseForFolder(&bi) == NULL) {
    
        return FALSE;
    }

    //
    // The user must have clicked OK, so we can update lpszBuf with g_szBrowsePath!
    //
    lstrcpy(lpszBuf, g_szBrowsePath);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\scandisk\registry.c ===
//////////////////////////////////////////////////////////////////////////////
//
// REGISTRY.C
//
//  Microsoft Confidential
//  Copyright (cMicrosoft Corporation 1998
//  All rights reserved
//
//  Registry functions for the application to easily interface with the 
//  registry.
//
//  4/98 - Jason Cohen (JCOHEN)
//
//////////////////////////////////////////////////////////////////////////////


// Include files
//
#include <windows.h>
#include "jcohen.h"
#include "registry.h"


BOOL RegExists(HKEY hKeyReg, LPTSTR lpKey, LPTSTR lpValue)
{
	HKEY	hOpenKey	= NULL;
	BOOL	bExists		= FALSE;

	if (lpKey)
	{
		if (RegOpenKeyEx(hKeyReg, lpKey, 0, KEY_ALL_ACCESS, &hOpenKey) != ERROR_SUCCESS)
			return bExists;
	}
	else
		hOpenKey = hKeyReg;

	if (lpValue)
		bExists = (RegQueryValueEx(hOpenKey, lpValue, NULL, NULL, NULL, NULL) == ERROR_SUCCESS);
	else
		bExists = TRUE;

	if (lpKey)
		RegCloseKey(hOpenKey);

	return bExists;
}


BOOL RegDelete(HKEY hRootKey, LPTSTR lpSubKey, LPTSTR lpValue) {

	BOOL bSuccess = FALSE;

	if (lpValue) {

		if (lpSubKey) {

			HKEY	hRegKey;

			if (RegOpenKeyEx(hRootKey, lpSubKey, 0, KEY_ALL_ACCESS, &hRegKey) == ERROR_SUCCESS) {

				bSuccess = (RegDeleteValue(hRegKey, lpValue) == ERROR_SUCCESS);
				RegCloseKey(hRegKey);

			}

		}
		else
			bSuccess = (RegDeleteValue(hRootKey, lpValue) == ERROR_SUCCESS);

	}
	else
		bSuccess = (RegDeleteKey(hRootKey, lpSubKey) == ERROR_SUCCESS);

	return bSuccess;

}


LPTSTR RegGetString(HKEY hKeyReg, LPTSTR lpKey, LPTSTR lpValue) {

	HKEY	hOpenKey	= NULL;
	LPTSTR	lpBuffer	= NULL,
			lpExpand	= NULL;
	DWORD	dwSize		= 0,
			dwType;

	// If the key is specified, we must open it.  Otherwise we can
	// just use the HKEY passed in.
	//
	if (lpKey)
	{
		// If the open key fails, return NULL because the value can't exist.
		//
		if (RegOpenKeyEx(hKeyReg, lpKey, 0, KEY_ALL_ACCESS, &hOpenKey) != ERROR_SUCCESS)
			return NULL;
	}
	else
		hOpenKey = hKeyReg;

	// Now query the value to get the size to allocate.  Make sure the date
	// type is a string and that the malloc doesn't fail.
	//
	if ( ( RegQueryValueEx(hOpenKey, lpValue, NULL, &dwType, NULL, &dwSize) == ERROR_SUCCESS ) &&
	     ( ( dwType == REG_SZ ) || ( dwType == REG_EXPAND_SZ ) ) &&
	     ( lpBuffer = (LPTSTR) MALLOC(dwSize) ) )
	{
		// We know the value exists and we have the memory we need to query the value again.
		//
		if ( ( RegQueryValueEx(hOpenKey, lpValue, NULL, NULL, (LPBYTE) lpBuffer, &dwSize) == ERROR_SUCCESS ) &&
		     ( ( dwType == REG_SZ ) || ( dwType == REG_EXPAND_SZ ) ) )
		{
			// We should expand it if it is supposed to be.
			//
			if ( dwType == REG_EXPAND_SZ )
			{
				if ( ( dwSize = ExpandEnvironmentStrings(lpBuffer, NULL, 0) ) &&
				     ( lpExpand = (LPTSTR) MALLOC(dwSize) ) &&
				     ( ExpandEnvironmentStrings(lpBuffer, lpExpand, dwSize) ) &&
				     ( *lpExpand ) )
				{
					// The expand workd, so free the original buffer and return
					// the expanded one.
					//
					FREE(lpBuffer);
					lpBuffer = lpExpand;
				}
				else
				{
					// The expand failed see we should free everything up
					// and return NULL.
					//
					FREE(lpExpand);
					FREE(lpBuffer);
				}
			}
		}
		else
			// For some reason the query failed, that shouldn't happen
			// but now we need to free and return NULL.
			//
			FREE(lpBuffer);
	}

	// If we opened a key, we must close it.
	//
	if (lpKey)
		RegCloseKey(hOpenKey);

	// Return the buffer allocated, or NULL if something failed.
	//
	return lpBuffer;
}


LPVOID RegGetBin(HKEY hKeyReg, LPTSTR lpKey, LPTSTR lpValue) {

	HKEY	hOpenKey	= NULL;
	LPVOID	lpBuffer	= NULL;
	DWORD	dwSize		= 0,
			dwType;

	// If the key is specified, we must open it.  Otherwise we can
	// just use the HKEY passed in.
	//
	if (lpKey)
	{
		// If the open key fails, return NULL because the value can't exist.
		//
		if (RegOpenKeyEx(hKeyReg, lpKey, 0, KEY_ALL_ACCESS, &hOpenKey) != ERROR_SUCCESS)
			return NULL;
	}
	else
		hOpenKey = hKeyReg;

	// Now query the value to get the size to allocate.  Make sure the date
	// type is a string and that the malloc doesn't fail.
	//
	if ( ( RegQueryValueEx(hOpenKey, lpValue, NULL, &dwType, NULL, &dwSize) == ERROR_SUCCESS ) &&
	     ( dwType == REG_BINARY ) &&
	     ( lpBuffer = MALLOC(dwSize) ) )
	{
		// We know the value exists and we have the memory we need to query the value again.
		//
		if ( ( RegQueryValueEx(hOpenKey, lpValue, NULL, NULL, (LPBYTE) lpBuffer, &dwSize) != ERROR_SUCCESS ) ||
		     ( dwType != REG_BINARY ) )
			// For some reason the query failed, that shouldn't happen
			// but now we need to free and return NULL.
			//
			FREE(lpBuffer);
	}

	// If we opened a key, we must close it.
	//
	if (lpKey)
		RegCloseKey(hOpenKey);

	// Return the buffer allocated, or NULL if something failed.
	//
	return lpBuffer;
}


DWORD RegGetDword(HKEY hKeyReg, LPTSTR lpKey, LPTSTR lpValue) {

	HKEY	hOpenKey	= NULL;
	DWORD	dwBuffer,
			dwSize		= sizeof(DWORD),
			dwType;


	if (lpKey) {

		if (RegOpenKeyEx(hKeyReg, lpKey, 0, KEY_ALL_ACCESS, &hOpenKey) != ERROR_SUCCESS)
			return 0;

	}
	else
		hOpenKey = hKeyReg;

	if ( (RegQueryValueEx(hOpenKey, lpValue, NULL, &dwType, (LPBYTE) &dwBuffer, &dwSize) != ERROR_SUCCESS) ||
	     (dwSize != sizeof(DWORD)) )

		dwBuffer = 0;

	if (lpKey)
		RegCloseKey(hOpenKey);

	return dwBuffer;

}


BOOL RegSetString(HKEY hRootKey, LPTSTR lpSubKey, LPTSTR lpValue, LPTSTR lpData) {

	BOOL bSuccess = FALSE;

	if (lpSubKey) {

		HKEY	hRegKey;
		DWORD	dwBuffer;

		if (RegCreateKeyEx(hRootKey, lpSubKey, 0, TEXT(""), 0, KEY_ALL_ACCESS, NULL, &hRegKey, &dwBuffer) == ERROR_SUCCESS) {

			bSuccess = (RegSetValueEx(hRegKey, lpValue, 0, REG_SZ, (CONST BYTE *) lpData, lstrlen(lpData) + 1) == ERROR_SUCCESS);
			RegCloseKey(hRegKey);

		}

	}
	else

		bSuccess = (RegSetValueEx(hRootKey, lpValue, 0, REG_SZ, (CONST BYTE *) lpData, lstrlen(lpData) + 1) == ERROR_SUCCESS);

	return bSuccess;

}


BOOL RegSetDword(HKEY hRootKey, LPTSTR lpSubKey, LPTSTR lpValue, DWORD dwData) {

	BOOL bSuccess = FALSE;

	if (lpSubKey) {

		HKEY	hRegKey;
		DWORD	dwBuffer;

		if (RegCreateKeyEx(hRootKey, lpSubKey, 0, TEXT(""), 0, KEY_ALL_ACCESS, NULL, &hRegKey, &dwBuffer) == ERROR_SUCCESS) {

			bSuccess = (RegSetValueEx(hRegKey, lpValue, 0, REG_DWORD, (CONST BYTE *) &dwData, sizeof(dwData)) == ERROR_SUCCESS);
			RegCloseKey(hRegKey);

		}

	}
	else

		bSuccess = (RegSetValueEx(hRootKey, lpValue, 0, REG_SZ, (CONST BYTE *) &dwData, sizeof(dwData)) == ERROR_SUCCESS);

	return bSuccess;

}


BOOL RegCheck(HKEY hKeyRoot, LPTSTR lpKey, LPTSTR lpValue)
{
	LPTSTR		lpBuffer;
	DWORD		dwSize = 0,
				dwType,
				dwBuffer = 0;
	HKEY		hKeyReg;
	BOOL		bReturn = FALSE;

    if (lpKey)
    {
		if (RegOpenKeyEx(hKeyRoot, lpKey, 0, KEY_ALL_ACCESS, &hKeyReg) != ERROR_SUCCESS)
			return 0;
	}
	else
		hKeyReg = hKeyRoot;

	// Query for the value and allocate the memory for the 
	// value data if it is type REG_SZ.
	//
	if (RegQueryValueEx(hKeyReg, lpValue, NULL, &dwType, NULL, &dwSize) == ERROR_SUCCESS)
    {
		if (dwType == REG_SZ)
        {
			// It is a string value, must allocate a buffer for the string.
			//
			if (lpBuffer = (LPTSTR) MALLOC(dwSize))
            {
				if ( (RegQueryValueEx(hKeyReg, lpValue, NULL, NULL, (LPBYTE) lpBuffer, &dwSize) == ERROR_SUCCESS) &&
					(*lpBuffer != '0') && (*lpBuffer) )
                {
					dwBuffer = 1;
				}
    			FREE(lpBuffer);
			}
		}
		else
        {
			// Must be a DWORD or BIN value.
			//
			RegQueryValueEx(hKeyReg, lpValue, NULL, &dwType, (LPBYTE) &dwBuffer, &dwSize);
        }

		bReturn = (dwBuffer != 0);
	}

    if (lpKey)
		RegCloseKey(hKeyReg);

	return bReturn;
}


BOOL RegEnumKeys(HKEY hKey, LPTSTR lpRegKey, REGENUMKEYPROC hCallBack, LPARAM lParam, BOOL bDelKeys)
{
	TCHAR		szKeyName[MAX_PATH + 1];
	DWORD		dwIndex		= 0,
				dwSize		= sizeof(szKeyName);
	HKEY		hKeyReg,
				hKeyEnum;
	BOOL		bReturn		= TRUE;
	
	// Open a key handle to the key to enumerate.
	//
	if ( ( lpRegKey == NULL ) || 
         ( RegOpenKeyEx(hKey, lpRegKey, 0, KEY_ALL_ACCESS, &hKeyReg) == ERROR_SUCCESS ) )
	{
		// Enumerate all the subkeys in this key.
		//
		while ( bReturn && ( RegEnumKeyEx(hKeyReg, dwIndex, szKeyName, &dwSize, NULL, NULL, NULL, NULL) == ERROR_SUCCESS ) )
		{
			if ( RegOpenKeyEx(hKeyReg, szKeyName, 0, KEY_ALL_ACCESS, &hKeyEnum) == ERROR_SUCCESS )
			{
				bReturn = hCallBack(hKeyEnum, szKeyName, lParam);
				RegCloseKey(hKeyEnum);
			}
			if ( !bDelKeys || ( RegDeleteKey(hKeyReg, szKeyName) != ERROR_SUCCESS ) )
				dwIndex++;
			dwSize = sizeof(szKeyName);
		}
		if (lpRegKey)
			RegCloseKey(hKeyReg);
	}
	else
		bReturn = FALSE;
	return bReturn;
}


BOOL RegEnumValues(HKEY hKey, LPTSTR lpRegKey, REGENUMVALPROC hCallBack, LPARAM lParam, BOOL bDelValues) {

	TCHAR		szValueName[MAX_PATH + 1];
	LPTSTR		lpBuffer;
	DWORD		dwIndex		= 0,
				dwSize		= sizeof(szValueName),
				dwDataSize	= 0,
				dwType;
	HKEY		hKeyReg;
	BOOL		bReturn		= TRUE;

	
	// Open a key handle to the key to enumerate.
	//
    if ( (lpRegKey == NULL) || 
         (RegOpenKeyEx(hKey, lpRegKey, 0, KEY_ALL_ACCESS, &hKeyReg) == ERROR_SUCCESS) ) {

		// Enumerate all the values in this key.
		//
		while (bReturn && (RegEnumValue(hKeyReg, dwIndex, szValueName, &dwSize, NULL, &dwType, NULL, &dwDataSize) == ERROR_SUCCESS)) {

			if ((dwType == REG_SZ) &&
				(lpBuffer = (LPTSTR) MALLOC(dwDataSize))) {

				if (RegQueryValueEx(hKeyReg, szValueName, NULL, NULL, (LPBYTE) lpBuffer, &dwDataSize) == ERROR_SUCCESS)
					bReturn = hCallBack(szValueName, lpBuffer, lParam);

				FREE(lpBuffer);

			}

			if ( !bDelValues || (RegDeleteValue(hKeyReg, szValueName) != ERROR_SUCCESS) )
                dwIndex++;

			dwSize = sizeof(szValueName);
			dwDataSize = 0;

		}

        if (lpRegKey)
		    RegCloseKey(hKeyReg);

	}
	else
		bReturn = FALSE;

	return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\sigverif\devnode.c ===
//
//  DEVNODE.C
//
#include "sigverif.h"
#include <initguid.h>
#include <devguid.h>

//
// Given the full path to a driver, add it to the file list.
//
LPFILENODE 
AddDriverFileToList(
    LPTSTR lpDirName, 
    LPTSTR lpFullPathName
    )
{
    LPFILENODE                  lpFileNode = NULL;
    TCHAR                       szFullPath[MAX_PATH];
    TCHAR                       szDirName[MAX_PATH];
    TCHAR                       szFileName[MAX_PATH];
    LPTSTR                      lpFilePart;
    BOOL                        bRet;

    *szFullPath = 0;
    *szDirName  = 0;
    *szFileName = 0;

    //
    // If no directory is passed in, try to get the full path
    //
    if (!lpDirName || !*lpDirName) {

        bRet = GetFullPathName(lpFullPathName, MAX_PATH, szDirName, &lpFilePart);
        
        if (bRet) {

            lstrcpy(szFullPath, szDirName);

            if (lpFilePart && *lpFilePart) {
                
                lstrcpy(szFileName, lpFilePart);
                *lpFilePart = 0;
                
                if (lstrlen(szDirName) > 3) {
                
                    *(lpFilePart - 1) = 0;
                }
            }
        }

    } else { 
        
        //
        // Use the directory and filename that was passed in to us
        // Expand out lpDirName in case there are any ".." entries
        //
        if (!GetFullPathName(lpDirName, MAX_PATH, szDirName, NULL)) {
        
            lstrcpy(szDirName, lpDirName);
        }

        lstrcpy(szFileName, lpFullPathName);
    }

    if (*szDirName && *szFileName && !IsFileAlreadyInList(szDirName, szFileName)) {
        
        //
        // Create a filenode, based on the directory and filename
        //
        lpFileNode = CreateFileNode(szDirName, szFileName);

        if (lpFileNode) { 

            InsertFileNodeIntoList(lpFileNode);

            // Increment the total number of files we've found that meet the search criteria.
            g_App.dwFiles++;
        }
    }

    return lpFileNode;
}

void 
GetFilesFromInfSection(
    HINF hInf, 
    LPTSTR lpFileName, 
    LPTSTR lpSectionName
    )
{
    TCHAR       szTarget[MAX_PATH];
    TCHAR       szBuffer[MAX_PATH];
    LPTSTR      lpBuffer;
    LPTSTR      lpString, lpSeparator;
    BOOL        bRet;
    DWORD       dwRequiredSize;
    INFCONTEXT  iContext;

    ZeroMemory(szTarget, sizeof(szTarget));
    SetupGetTargetPath(hInf, NULL, lpSectionName, szTarget, sizeof(szTarget), NULL);

    // HYDRA HACK!!!
    //
    // Check to see if the target is %WINDIR% and if %WINDIR% has been redirected, change it back!!
    // We have the real %WINDIR% stored in g_App.szWinDir, so we can stuff that into szTarget.
    // We just have to remember to put back whatever was at the end of szTarget.
    //
    if (GetWindowsDirectory(szBuffer, MAX_PATH) &&
        !_tcsnicmp(szBuffer, szTarget, lstrlen(szBuffer)) && 
        _tcsicmp(g_App.szWinDir, szBuffer)) {

        lstrcpy(szBuffer, szTarget + lstrlen(szBuffer));
        lstrcpy(szTarget, g_App.szWinDir);
        lstrcat(szTarget, szBuffer);
    }

    ZeroMemory(&iContext, sizeof(INFCONTEXT));
    bRet = SetupFindFirstLine(hInf, lpSectionName, NULL, &iContext);

    while (bRet && !g_App.bStopScan) {
        dwRequiredSize = 0;
        bRet = SetupGetLineText(&iContext, NULL, NULL, NULL, NULL, 0, &dwRequiredSize);
        if (dwRequiredSize) {
            
            lpBuffer = MALLOC((dwRequiredSize + 1) * sizeof(TCHAR));
            
            if (lpBuffer) {
            
                bRet = SetupGetLineText(&iContext, NULL, NULL, NULL, lpBuffer, dwRequiredSize, NULL);
                
                if (bRet) {
                    lpString = lpBuffer;
    
                    if (lpString && *lpString) {
                        // If there's a comma, then terminate the string at the comma
                        lpSeparator = _tcschr(lpString, TEXT(','));
                        if (lpSeparator) {
                            // Null terminate at the comma, so the first entry is a null-terminated string
                            *lpSeparator = 0;
                        }
    
                        // Make sure we didn't just terminate ourselves.
                        if (*lpString) {
                            AddDriverFileToList(szTarget, lpString);
                        }
                    }
                }
            
                FREE(lpBuffer);
            }
        }

        bRet = SetupFindNextLine(&iContext, &iContext);
    }
}

void 
GetStuffFromInfSection(
    LPTSTR lpFileName, 
    LPTSTR lpSectionName
    )
{
    TCHAR   szFullPath[MAX_PATH];
    TCHAR   szTarget[MAX_PATH];
    TCHAR   szKeyName[MAX_PATH];
    LPTSTR  lpString    = NULL;
    LPTSTR  lpSeparator = NULL;
    LPTSTR  lpBuffer    = NULL;
    DWORD   dwRequiredSize;
    HINF    hInf;
    BOOL    bRet;
    UINT    uError;

    szFullPath[0] = 0;
    GetFullPathName(lpFileName, MAX_PATH, szFullPath, NULL);

    //
    // Try opening the INF in the usual INF directory
    //
    hInf = SetupOpenInfFile(szFullPath, NULL, INF_STYLE_WIN4, &uError);
    if (hInf == INVALID_HANDLE_VALUE) {
        
        //
        // Add the INF to the file list so it shows up as unscanned.
        //
        AddDriverFileToList(NULL, lpFileName);
        return;

    } else {
        
        //
        // The INF must exist, so add it to the file list for verification!
        //
        AddDriverFileToList(NULL, szFullPath);
    }

    MyLoadString(szKeyName, IDS_COPYFILES);
    dwRequiredSize = 0;
    bRet = SetupGetLineText(NULL, hInf, lpSectionName, szKeyName, NULL, 0, &dwRequiredSize);
    if (dwRequiredSize) {
        
        lpBuffer = MALLOC((dwRequiredSize + 1) * sizeof(TCHAR));
        
        if (lpBuffer) {
        
            bRet = SetupGetLineText(NULL, hInf, lpSectionName, szKeyName, lpBuffer, dwRequiredSize, NULL);
            if (!bRet) {
                //MyMessageBox(TEXT("SetupGetLineText Failed!"));
                FREE(lpBuffer);
                return;
            }
        }

        lpString = lpBuffer;
    }

    ZeroMemory(szTarget, sizeof(szTarget));
    SetupGetTargetPath(hInf, NULL, lpSectionName, szTarget, sizeof(szTarget), NULL);

    while (lpString && *lpString && !g_App.bStopScan) {
        // If there's a comma, then bump lpSeparator to after the comma
        lpSeparator = _tcschr(lpString, TEXT(','));
        if (lpSeparator) {
            // Null terminate at the comma, so the first entry is a null-terminated string
            *lpSeparator = 0;
            lpSeparator++;
        }

        //
        // If the section has an '@' symbol, then it is directly referencing a filename
        // Otherwise, it's a section and we need to process that via GetFilesFromInfSection()
        //
        if (*lpString == TEXT('@')) {
            lpString++;
            if (*lpString) {
                AddDriverFileToList(szTarget, lpString);
            }
        } else GetFilesFromInfSection(hInf, lpFileName, lpString);

        lpString = lpSeparator;
    }

    if (lpBuffer) {
    
        FREE(lpBuffer);
    }

    SetupCloseInfFile(hInf);
}

UINT
ScanQueueCallback(
    PVOID Context,
    UINT Notification,
    UINT_PTR Param1,
    UINT_PTR Param2
    )
{
    LPFILENODE  lpFileNode;
    TCHAR       szBuffer[MAX_PATH];
    LPTSTR      lpFilePart;

    if ((Notification == SPFILENOTIFY_QUEUESCAN_SIGNERINFO) &&
        Param1) {

        //
        // Special case for printers:
        // After setupapi copies files from the file queue into their destination
        // location, the printer class installer moves some of these files into
        // other 'special' locations.  This can lead to the callback Win32Error
        // returning ERROR_FILE_NOT_FOUND or ERROR_PATH_NOT_FOUND since the file 
        // is not present in the location where setupapi put it.  So, we will 
        // catch this case for printers and not add the file to our list of 
        // files to scan.  These 'special' printer files will get added later 
        // when we call the spooler APIs.
        // Also note that we can't just skip getting the list of files for printers
        // altogether since the printer class installer only moves some of the 
        // files that setupapi copies and not all of them.
        //
        if (Context &&
            (IsEqualGUID((LPGUID)Context, &GUID_DEVCLASS_PRINTER)) &&
            ((((PFILEPATHS_SIGNERINFO)Param1)->Win32Error == ERROR_FILE_NOT_FOUND) ||
             (((PFILEPATHS_SIGNERINFO)Param1)->Win32Error == ERROR_PATH_NOT_FOUND))) {
            //
            // Assume this was a file moved by the printer class installer.  Don't
            // add it to the list of files to be scanned at this time.
            //
            return NO_ERROR;
        }

        lpFileNode = AddDriverFileToList(NULL, 
                                         (LPTSTR)((PFILEPATHS_SIGNERINFO)Param1)->Target);

        //
        // Fill in some information into the FILENODE structure since we already
        // scanned the file.
        //
        if (lpFileNode) {
        
            lpFileNode->bScanned = TRUE;
            lpFileNode->bSigned = (((PFILEPATHS_SIGNERINFO)Param1)->Win32Error == NO_ERROR);

            if (lpFileNode->bSigned) {
        
                if (((PFILEPATHS_SIGNERINFO)Param1)->CatalogFile) {
                
                    GetFullPathName(((PFILEPATHS_SIGNERINFO)Param1)->CatalogFile, MAX_PATH, szBuffer, &lpFilePart);
    
                    lpFileNode->lpCatalog = MALLOC((lstrlen(lpFilePart) + 1) * sizeof(TCHAR));
            
                    if (lpFileNode->lpCatalog) {
            
                        lstrcpy(lpFileNode->lpCatalog, lpFilePart);
                    }
                }
        
                if (((PFILEPATHS_SIGNERINFO)Param1)->DigitalSigner) {
                
                    lpFileNode->lpSignedBy = MALLOC((lstrlen(((PFILEPATHS_SIGNERINFO)Param1)->DigitalSigner) + 1) * sizeof(TCHAR));
            
                    if (lpFileNode->lpSignedBy) {
            
                        lstrcpy(lpFileNode->lpSignedBy, ((PFILEPATHS_SIGNERINFO)Param1)->DigitalSigner);
                    }
                }
        
                if (((PFILEPATHS_SIGNERINFO)Param1)->Version) {
                
                    lpFileNode->lpVersion = MALLOC((lstrlen(((PFILEPATHS_SIGNERINFO)Param1)->Version) + 1) * sizeof(TCHAR));
            
                    if (lpFileNode->lpVersion) {
            
                        lstrcpy(lpFileNode->lpVersion, ((PFILEPATHS_SIGNERINFO)Param1)->Version);
                    }
                }
    
            } else {
                // 
                // Get the icon (if the file isn't signed) so we can display it in the listview faster.
                //
                MyGetFileInfo(lpFileNode);
            }
        }
    }

    return NO_ERROR;
}

void 
BuildDriverFileList(
    void
    )
{
    HDEVINFO hDeviceInfo = INVALID_HANDLE_VALUE;
    SP_DEVINFO_DATA DeviceInfoData;
    SP_DRVINFO_DATA DriverInfoData;
    SP_DEVINSTALL_PARAMS DeviceInstallParams;
    DWORD DeviceMemberIndex;
    HSPFILEQ hFileQueue;
    DWORD ScanResult;

    //
    // Build up a list of all the devices currently present in the system.
    //
    hDeviceInfo = SetupDiGetClassDevs(NULL,
                                      NULL,
                                      NULL,
                                      DIGCF_ALLCLASSES | DIGCF_PRESENT
                                      );
    
    if (hDeviceInfo == INVALID_HANDLE_VALUE) {

        goto clean0;
    }

    DeviceInfoData.cbSize = sizeof(DeviceInfoData);
    DeviceMemberIndex = 0;

    //
    // Enumerate through the list of present devices.
    //
    while (SetupDiEnumDeviceInfo(hDeviceInfo,
                                 DeviceMemberIndex++,
                                 &DeviceInfoData
                                 ) &&
           !g_App.bStopScan) {
    
        DeviceInstallParams.cbSize = sizeof(DeviceInstallParams);

        //
        // Before we call SetupDiBuildDriverInfoList to build up a list of drivers
        // for this device we first need to set the DI_FLAGSEX_INSTALLEDDRIVER flag
        // (which tells the API to only include the currently installed driver in
        // the list) and the DI_FLAGSEX_ALLOWEXCLUDEDRVS (allow ExcludeFromSelect
        // devices in the list).
        //
        if (SetupDiGetDeviceInstallParams(hDeviceInfo,
                                          &DeviceInfoData,
                                          &DeviceInstallParams
                                          )) {
            
            DeviceInstallParams.FlagsEx = (DI_FLAGSEX_INSTALLEDDRIVER |
                                           DI_FLAGSEX_ALLOWEXCLUDEDDRVS);

            if (SetupDiSetDeviceInstallParams(hDeviceInfo,
                                              &DeviceInfoData,
                                              &DeviceInstallParams
                                              ) &&
                SetupDiBuildDriverInfoList(hDeviceInfo,
                                           &DeviceInfoData,
                                           SPDIT_CLASSDRIVER
                                           )) {

                //
                // Now we will get the one driver node that is in the list that
                // was just built and make it the selected driver node.
                //
                DriverInfoData.cbSize = sizeof(DriverInfoData);

                if (SetupDiEnumDriverInfo(hDeviceInfo,
                                          &DeviceInfoData,
                                          SPDIT_CLASSDRIVER,
                                          0,
                                          &DriverInfoData
                                          ) &&
                    SetupDiSetSelectedDriver(hDeviceInfo,
                                             &DeviceInfoData,
                                             &DriverInfoData
                                             )) {

                    hFileQueue = SetupOpenFileQueue();

                    if (hFileQueue != INVALID_HANDLE_VALUE) {

                        //
                        // Set the FileQueue parameter to the file queue we just 
                        // created and set the DI_NOVCP flag.
                        //
                        // The call SetupDiCallClassInstaller with DIF_INSTALLDEVICEFILES
                        // to build up a queue of all the files that are copied for
                        // this driver node.
                        //
                        DeviceInstallParams.FileQueue = hFileQueue;
                        DeviceInstallParams.Flags |= DI_NOVCP;

                        if (SetupDiSetDeviceInstallParams(hDeviceInfo,
                                                          &DeviceInfoData,
                                                          &DeviceInstallParams
                                                          ) &&
                            SetupDiCallClassInstaller(DIF_INSTALLDEVICEFILES,
                                                      hDeviceInfo,
                                                      &DeviceInfoData
                                                      )) {

                            //
                            // Scan the file queue and have it call our callback
                            // function for each file in the queue.
                            //
                            SetupScanFileQueue(hFileQueue,
                                               SPQ_SCAN_USE_CALLBACK_SIGNERINFO,
                                               NULL,
                                               ScanQueueCallback,
                                               (PVOID)&(DeviceInfoData.ClassGuid),
                                               &ScanResult
                                               );

                                                            
                            //
                            // Dereference the file queue so we can close it.
                            //
                            DeviceInstallParams.FileQueue = NULL;
                            DeviceInstallParams.Flags &= ~DI_NOVCP;
                            SetupDiSetDeviceInstallParams(hDeviceInfo,
                                                          &DeviceInfoData,
                                                          &DeviceInstallParams
                                                          );
                        }

                        SetupCloseFileQueue(hFileQueue);
                    }
                }

                SetupDiDestroyDriverInfoList(hDeviceInfo,
                                             &DeviceInfoData,
                                             SPDIT_CLASSDRIVER
                                             );
            }
        }
    }

clean0:
    if (hDeviceInfo != INVALID_HANDLE_VALUE) {

        SetupDiDestroyDeviceInfoList(hDeviceInfo);
    }
}

void 
BuildPrinterFileList(
    void
    )
{
    BOOL            bRet;
    DWORD           dwBytesNeeded = 0;
    DWORD           dwDrivers = 0;
    LPBYTE          lpBuffer = NULL, lpTemp = NULL;
    LPTSTR          lpFileName;
    DRIVER_INFO_3   DriverInfo;
    PDRIVER_INFO_3  lpDriverInfo;
    TCHAR           szBuffer[MAX_PATH];
    LPFILENODE      lpFileNode = NULL;

    ZeroMemory(&DriverInfo, sizeof(DRIVER_INFO_3));
    bRet = EnumPrinterDrivers(  NULL,
                                SIGVERIF_PRINTER_ENV,
                                3,
                                (LPBYTE) &DriverInfo,
                                sizeof(DRIVER_INFO_3),
                                &dwBytesNeeded,
                                &dwDrivers);

    if (!bRet && dwBytesNeeded > 0) {
        
        lpBuffer = MALLOC(dwBytesNeeded);

        //
        // If we can't get any memory then just bail out of this function
        //
        if (!lpBuffer) {

            return;
        }
        
        bRet = EnumPrinterDrivers(  NULL,
                                    SIGVERIF_PRINTER_ENV,
                                    3,
                                    (LPBYTE) lpBuffer,
                                    dwBytesNeeded,
                                    &dwBytesNeeded,
                                    &dwDrivers);
    }

    if (dwDrivers > 0) {
        
        //
        // By default, go into the System directory, since Win9x doesn't give full paths to drivers.
        //
        GetSystemDirectory(szBuffer, MAX_PATH);
        SetCurrentDirectory(szBuffer);

        for (lpTemp = lpBuffer; dwDrivers > 0; dwDrivers--) {
            
            lpDriverInfo = (PDRIVER_INFO_3) lpTemp;
            
            if (lpDriverInfo->pName) {
                
                if (lpDriverInfo->pDriverPath && *lpDriverInfo->pDriverPath) {
                    lpFileNode = AddDriverFileToList(NULL, lpDriverInfo->pDriverPath);

                    if (lpFileNode) {
                        lpFileNode->bValidateAgainstAnyOs = TRUE;
                    }
                }
                
                if (lpDriverInfo->pDataFile && *lpDriverInfo->pDataFile) {
                    lpFileNode = AddDriverFileToList(NULL, lpDriverInfo->pDataFile);

                    if (lpFileNode) {
                        lpFileNode->bValidateAgainstAnyOs = TRUE;
                    }
                }
                
                if (lpDriverInfo->pConfigFile && *lpDriverInfo->pConfigFile) {
                    lpFileNode = AddDriverFileToList(NULL, lpDriverInfo->pConfigFile);

                    if (lpFileNode) {
                        lpFileNode->bValidateAgainstAnyOs = TRUE;
                    }
                }
                
                if (lpDriverInfo->pHelpFile && *lpDriverInfo->pHelpFile) {
                    lpFileNode = AddDriverFileToList(NULL, lpDriverInfo->pHelpFile);

                    if (lpFileNode) {
                        lpFileNode->bValidateAgainstAnyOs = TRUE;
                    }
                }

                lpFileName = lpDriverInfo->pDependentFiles;
                
                while (lpFileName && *lpFileName) {
                    
                    lpFileNode = AddDriverFileToList(NULL, lpFileName);

                    if (lpFileNode) {
                        lpFileNode->bValidateAgainstAnyOs = TRUE;
                    }

                    for (;*lpFileName;lpFileName++);
                    lpFileName++;
                }
            }
            
            lpTemp += sizeof(DRIVER_INFO_3);
        }
    }

    if (lpBuffer) {
    
        FREE(lpBuffer);
    }
}

BOOL 
GetBVTFileList(
    LPTSTR lpDirName, 
    LPTSTR lpFileName
    )
{
    TCHAR szBuffer[MAX_PATH];
    LPTSTR lpString, lpFilePart;

    //
    // If the user specified the "/BVT:" switch, we want to grab the string after it 
    //
    MyLoadString(szBuffer, IDS_BVT);
    lpString = MyStrStr(GetCommandLine(), szBuffer);
    
    if (lpString && *lpString) {
        
        //
        // Switch back into the original startup directory
        //
        SetCurrentDirectory(g_App.szAppDir);

        lpString += lstrlen(szBuffer);
        
        if (!EXIST(lpString)) {
            return FALSE;
        }
        
        GetFullPathName(lpString, MAX_PATH, lpDirName, &lpFilePart);
        lstrcpy(lpFileName, lpDirName);
        *lpFilePart = 0;
        SetCurrentDirectory(lpDirName);
        return TRUE;
    }

    return FALSE;
}

BOOL 
IsNTServer(
    void
    )
{
    BOOL    bRet = FALSE;
    HKEY    hKey;
    LONG    lRet;
    DWORD   dwSize, dwType;
    TCHAR   szBuffer[MAX_PATH];
    TCHAR   szRegBuffer[MAX_PATH];

    // Open HKLM\System\CurrentControlSet\Control\ProductOptions
    MyLoadString(szRegBuffer, IDS_REG_PRODUCTOPTIONS);
    lRet = RegOpenKey(HKEY_LOCAL_MACHINE, szRegBuffer, &hKey);
    if (lRet == ERROR_SUCCESS) {
        // Now we need to query the ProductType value
        ZeroMemory(szBuffer, sizeof(szBuffer));
        dwSize = sizeof(szBuffer);
        MyLoadString(szRegBuffer, IDS_REG_PRODUCTTYPE);
        lRet = RegQueryValueEx(hKey, szRegBuffer, NULL, &dwType, (PVOID)szBuffer, &dwSize);
        if (lRet == ERROR_SUCCESS) {
            // Check to see if ProductType contained "ServerNT"
            MyLoadString(szRegBuffer, IDS_PRODUCT_SERVER);
            if (!_tcsnicmp(szRegBuffer, szBuffer, lstrlen(szRegBuffer))) {
                // If so, then we want to return TRUE!
                bRet = TRUE;
            }
        }
        RegCloseKey(hKey);
    }

    return bRet;
}

BOOL 
IsProcessorAlpha(
    void
    )
{
    OSVERSIONINFO   osinfo;
    SYSTEM_INFO     sysinfo;

    ZeroMemory(&osinfo, sizeof(OSVERSIONINFO));
    osinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&osinfo);

    if (osinfo.dwPlatformId == VER_PLATFORM_WIN32_NT) {
        ZeroMemory(&sysinfo, sizeof(SYSTEM_INFO));
        GetSystemInfo(&sysinfo);
        if (sysinfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_ALPHA) {
            return TRUE;
        }
    }

    return FALSE;
}

void 
BuildCoreFileList(
    void
    )
{
    LPFILENODE  lpFileNode;
    TCHAR       szInfName[MAX_PATH];
    TCHAR       szSectionName[MAX_PATH];
    TCHAR       szBuffer[MAX_PATH];

    //
    // Check to see if the "/BVT:" switch was specified for a custom file list
    // If so, then don't verify that the file is digitally signed.
    //
    if (GetBVTFileList(szBuffer, szInfName)) {

        GetCurrentDirectory(MAX_PATH, szBuffer);

        MyLoadString(szSectionName, IDS_MASTERFILELIST);
        GetStuffFromInfSection(szInfName, szSectionName);

        if (IsNTServer()) {
            
            SetCurrentDirectory(szBuffer);  
            MyLoadString(szSectionName, IDS_SERVERFILELIST);
            GetStuffFromInfSection(szInfName, szSectionName);
        }

        if (!IsProcessorAlpha()) {
            
            SetCurrentDirectory(szBuffer);  
            MyLoadString(szSectionName, IDS_X86FILELIST);
            GetStuffFromInfSection(szInfName, szSectionName);
        }

    } else {

        PROTECTED_FILE_DATA pfd;

        //
        // The user didn't use "/BVT:", so call SfcGetNextProtectedFile to get
        // the list of files that SFC protects.
        //
        
        pfd.FileNumber = 0;

        while (!g_App.bStopScan && SfcGetNextProtectedFile(NULL, &pfd)) {

            AddDriverFileToList(NULL, pfd.FileName);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\sigverif\logfile.c ===
//
// LOGFILE.C
//
#include "sigverif.h"

//
// We need to remember the previous logging state when we do toggling.
//
BOOL    g_bPrevLoggingEnabled = FALSE;

BOOL LogFile_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{   
    TCHAR   szBuffer[MAX_PATH];

    if (g_App.hIcon) {
        
        SetWindowLongPtr(hwnd, GCLP_HICON, (LONG_PTR) g_App.hIcon); 
    }

    g_App.hLogging = hwnd;

    g_bPrevLoggingEnabled = g_App.bLoggingEnabled;

    if (GetWindowsDirectory(szBuffer, MAX_PATH)) {

        SetCurrentDirectory(szBuffer);
    }

    SetDlgItemText(hwnd, IDC_LOGNAME, g_App.szLogFile);

    CheckDlgButton(hwnd, IDC_ENABLELOG, g_App.bLoggingEnabled ? BST_CHECKED : BST_UNCHECKED);

    EnableWindow(GetDlgItem(hwnd, IDC_VIEWLOG), g_App.bLoggingEnabled && EXIST(g_App.szLogFile));

    CheckRadioButton(hwnd, IDC_OVERWRITE, IDC_APPEND, g_App.bOverwrite ? IDC_OVERWRITE : IDC_APPEND);
    EnableWindow(GetDlgItem(hwnd, IDC_APPEND), g_App.bLoggingEnabled);
    EnableWindow(GetDlgItem(hwnd, IDC_OVERWRITE), g_App.bLoggingEnabled);
    EnableWindow(GetDlgItem(hwnd, IDC_LOGNAME), g_App.bLoggingEnabled);

    SetForegroundWindow(g_App.hDlg);
    SetForegroundWindow(hwnd);

    return TRUE;
}

void LogFile_UpdateDialog(HWND hwnd)
{
    TCHAR szBuffer[MAX_PATH];

    if (GetDlgItemText(hwnd, IDC_LOGNAME, szBuffer, MAX_PATH)) {

        EnableWindow(GetDlgItem(hwnd, IDC_VIEWLOG), g_App.bLoggingEnabled && EXIST(szBuffer));

    } else {

        EnableWindow(GetDlgItem(hwnd, IDC_VIEWLOG), FALSE);
    }

    EnableWindow(GetDlgItem(hwnd, IDC_APPEND), g_App.bLoggingEnabled);
    EnableWindow(GetDlgItem(hwnd, IDC_OVERWRITE), g_App.bLoggingEnabled);
    EnableWindow(GetDlgItem(hwnd, IDC_LOGNAME), g_App.bLoggingEnabled);
}

void LogFile_OnViewLog(HWND hwnd)
{
    TCHAR szDirName[MAX_PATH];
    TCHAR szFileName[MAX_PATH];

    if (!GetWindowsDirectory(szDirName, MAX_PATH)) {

        szDirName[0] = TEXT('\0');
    }

    if (!GetDlgItemText(hwnd, IDC_LOGNAME, szFileName, MAX_PATH)) {
        
        MyErrorBoxId(IDS_BADLOGNAME);
        return;
    }

    ShellExecute(hwnd, NULL, szFileName, NULL, szDirName, SW_SHOW);
}

BOOL LogFile_VerifyLogFile(HWND hwnd, LPTSTR lpFileName, BOOL bNoisy)
{
    TCHAR   szFileName[MAX_PATH];
    HANDLE  hFile;
    BOOL    bRet;
    HWND    hTemp;

    ZeroMemory(szFileName, sizeof(szFileName));

    bRet = GetDlgItemText(hwnd, IDC_LOGNAME, szFileName, MAX_PATH);
    
    if (bRet) {
        
        hFile = CreateFile( szFileName,
                            GENERIC_READ | GENERIC_WRITE,
                            FILE_SHARE_READ,
                            NULL, 
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL);

        if (hFile != INVALID_HANDLE_VALUE) {
            
            CloseHandle(hFile);

        } else {
            
            hFile = CreateFile( szFileName,
                                GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_READ,
                                NULL, 
                                CREATE_NEW,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);

            if (hFile != INVALID_HANDLE_VALUE) {
                
                CloseHandle(hFile);
                DeleteFile(szFileName);

            } else {
                
                //
                // If we couldn't open an existing file and we couldn't create a new one, then we fail.
                //
                bRet = FALSE;
            }
        }
    }

    if (!bRet && bNoisy) {
        
        //
        // Since we don't want to lose focus, we are going to temporarily change g_App.hDlg.  JasKey, I apologize.
        //
        hTemp = g_App.hDlg;
        g_App.hDlg = hwnd;
        MyErrorBoxId(IDS_BADLOGNAME);
        g_App.hDlg = hTemp;
    }

    //
    // If everything worked and the user wants the file name, copy it into lpFileName
    //
    if (bRet && lpFileName && *szFileName) {
        
        lstrcpy(lpFileName, szFileName);
    }

    return bRet;
}

BOOL LogFile_OnOK(HWND hwnd)
{
    HKEY    hKey;
    LONG    lRes;
    DWORD   dwDisp, dwType, dwFlags, cbData;
    TCHAR   szFileName[MAX_PATH];

    ZeroMemory(szFileName, sizeof(szFileName));

    if (LogFile_VerifyLogFile(hwnd, szFileName, FALSE)) {
        
        //
        // The file is OK to append or overwrite.
        //
        lstrcpy(g_App.szLogFile, szFileName);

    } else {
        
        return FALSE;
    }

    g_App.bOverwrite = IsDlgButtonChecked(hwnd, IDC_OVERWRITE);

    //
    // Look in the registry for any settings from the last SigVerif session
    //
    lRes = RegCreateKeyEx(  SIGVERIF_HKEY,
                            SIGVERIF_KEY,
                            0,
                            NULL,
                            0,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hKey,
                            &dwDisp);

    if (lRes == ERROR_SUCCESS) {
        
        cbData = sizeof(DWORD);
        dwFlags = 0;
        
        if (g_App.bLoggingEnabled) {
        
            dwFlags = 0x1;
        }

        if (g_App.bOverwrite) {
        
            dwFlags |= 0x2;
        }

        dwType = REG_DWORD;
        
        lRes = RegSetValueEx(   hKey,
                                SIGVERIF_FLAGS,
                                0,
                                dwType,
                                (LPBYTE) &dwFlags,
                                cbData);

        dwType = REG_SZ;
        cbData = MAX_PATH;
        
        lRes = RegSetValueEx(   hKey,
                                SIGVERIF_LOGNAME,
                                0,
                                dwType,
                                (LPBYTE) g_App.szLogFile,
                                cbData);

        RegCloseKey(hKey);
    }

    return TRUE;
}

void LogFile_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    switch (id) {
    
    case IDC_VIEWLOG:
        LogFile_OnViewLog(hwnd);
        break;

    case IDC_ENABLELOG:
        g_App.bLoggingEnabled = !g_App.bLoggingEnabled;
        
        //
        // Fall through to update...
        //

    default: 
        LogFile_UpdateDialog(hwnd);
    }
}

//
// This function handles any notification messages for the Search page.
//
LRESULT LogFile_NotifyHandler(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    NMHDR   *lpnmhdr = (NMHDR *) lParam;
    LRESULT lResult;
    BOOL    bRet;

    switch (lpnmhdr->code) {
    
    case PSN_APPLY:         
        if (LogFile_OnOK(hwnd)) {
        
            lResult = PSNRET_NOERROR;
        
        } else {
            
            lResult = PSNRET_INVALID_NOCHANGEPAGE;
        }

        SetWindowLongPtr(hwnd,
                         DWLP_MSGRESULT,
                         (LONG_PTR) lResult);
        
        return lResult;

    case PSN_KILLACTIVE:    
        bRet = !LogFile_VerifyLogFile(hwnd, NULL, TRUE);
        
        if (bRet) {
            
            SetForegroundWindow(g_App.hLogging);
            SetFocus(GetDlgItem(g_App.hLogging, IDC_LOGNAME));
        }

        SetWindowLongPtr(hwnd,
                         DWLP_MSGRESULT,
                         (LONG_PTR) bRet);
        return bRet;
    }

    return 0;
}

INT_PTR CALLBACK LogFile_DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL    fProcessed = TRUE;

    switch (uMsg) {
    HANDLE_MSG(hwnd, WM_INITDIALOG, LogFile_OnInitDialog);
    HANDLE_MSG(hwnd, WM_COMMAND, LogFile_OnCommand);

    case WM_NOTIFY:
        return LogFile_NotifyHandler(hwnd, uMsg, wParam, lParam);

    case WM_HELP:
        SigVerif_Help(hwnd, uMsg, wParam, lParam, FALSE);
        break;

    case WM_CONTEXTMENU:
        SigVerif_Help(hwnd, uMsg, wParam, lParam, TRUE);
        break;

    default: fProcessed = FALSE;
    }

    return fProcessed;
}

void PrintUnscannedFileListItems(HANDLE hFile)
{
    LPFILENODE  lpFileNode;
    TCHAR       szDirectory[MAX_PATH];
    TCHAR       szBuffer[MAX_PATH * 2];
    TCHAR       szBuffer2[MAX_PATH];
    DWORD       dwBytesWritten;

    *szDirectory = 0;

    for (lpFileNode = g_App.lpFileList;lpFileNode;lpFileNode = lpFileNode->next) {

        //
        // Make sure we only log files that have NOT been scanned.
        //
        if (!lpFileNode->bScanned) {

            if (lstrcmp(szDirectory, lpFileNode->lpDirName)) {

                SetCurrentDirectory(lpFileNode->lpDirName);
                lstrcpy(szDirectory, lpFileNode->lpDirName);

                MyLoadString(szBuffer2, IDS_DIR);
                wsprintf(szBuffer, szBuffer2, szDirectory);
                WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);
            }

            MyLoadString(szBuffer2, IDS_STRING);
            wsprintf(szBuffer, szBuffer2, lpFileNode->lpFileName);
            WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);

            //
            // Print out the reason that the file was not scanned.
            //
            if (lpFileNode->LastError != ERROR_SUCCESS) {

                //
                // We will special case the error ERROR_FILE_NOT_FOUND and display
                // the text "The file is not installed." in the log file instead of
                // the default ERROR_FILE_NOT_FOUND text "The system cannot find the
                // file specified."
                //
                if (lpFileNode->LastError == ERROR_FILE_NOT_FOUND) {

                    MyLoadString(szBuffer, IDS_FILENOTINSTALLED);
                    WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);

                } else {
                
                    LPVOID lpLastError = NULL;
    
                    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                      FORMAT_MESSAGE_FROM_SYSTEM |
                                      FORMAT_MESSAGE_IGNORE_INSERTS,
                                      NULL,
                                      lpFileNode->LastError,
                                      MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                      (LPTSTR)&lpLastError,
                                      0,
                                      NULL) != 0) {
    
                        if (lpLastError) {
    
                            WriteFile(hFile, (LPTSTR)lpLastError, lstrlen((LPTSTR)lpLastError) * sizeof(TCHAR), &dwBytesWritten, NULL);
    
                            LocalFree(lpLastError);
                        }
                    }
                }
            }
        }
    }

    MyLoadString(szBuffer, IDS_LINEFEED);
    WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);
}

void PrintFileListItems(HANDLE hFile)
{
    LPFILENODE  lpFileNode;
    TCHAR       szDirectory[MAX_PATH];
    TCHAR       szBuffer[MAX_PATH * 2];
    TCHAR       szBuffer2[MAX_PATH];
    TCHAR       szBuffer3[MAX_PATH];
    DWORD       dwBytesWritten;
    LPTSTR      lpString;
    int         iRet;
    BOOL        bMirroredApp;

    bMirroredApp = (GetWindowLong(g_App.hDlg, GWL_EXSTYLE) & WS_EX_LAYOUTRTL);

    *szDirectory = 0;

    for (lpFileNode = g_App.lpFileList;lpFileNode;lpFileNode = lpFileNode->next) {
        
        //
        // Make sure we only log files that have actually been scanned.
        //
        if (lpFileNode->bScanned) {
            
            if (lstrcmp(szDirectory, lpFileNode->lpDirName)) {
                
                SetCurrentDirectory(lpFileNode->lpDirName);
                lstrcpy(szDirectory, lpFileNode->lpDirName);

                MyLoadString(szBuffer2, IDS_DIR);
                wsprintf(szBuffer, szBuffer2, szDirectory);
                WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);
            }

            MyLoadString(szBuffer2, IDS_STRING);
            wsprintf(szBuffer, szBuffer2, lpFileNode->lpFileName);
            WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);

            MyLoadString(szBuffer, IDS_SPACES);
            WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);

            //
            // Get the date format, so we are localizable...
            //
            MyLoadString(szBuffer2, IDS_UNKNOWN);
            iRet = GetDateFormat(LOCALE_SYSTEM_DEFAULT, 
                                 bMirroredApp ?
                                     DATE_RTLREADING | DATE_SHORTDATE :
                                     DATE_SHORTDATE,
                                 &lpFileNode->LastModified,
                                 NULL,
                                 NULL,
                                 0);
            if (iRet) {
                
                lpString = MALLOC((iRet + 1) * sizeof(TCHAR));

                if (lpString) {
                    
                    iRet = GetDateFormat(LOCALE_SYSTEM_DEFAULT,
                                         bMirroredApp ?
                                             DATE_RTLREADING | DATE_SHORTDATE :
                                             DATE_SHORTDATE,
                                         &lpFileNode->LastModified,
                                         NULL,
                                         lpString,
                                         iRet);

                    if (iRet) {
                        
                        lstrcpy(szBuffer2, lpString);
                    }

                    FREE(lpString);
                }
            }

            MyLoadString(szBuffer3, IDS_STRING2);
            wsprintf(szBuffer, szBuffer3, szBuffer2);
            WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);

            MyLoadString(szBuffer, IDS_SPACES);
            WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);

            if (lpFileNode->lpVersion && *lpFileNode->lpVersion) {
                
                lstrcpy(szBuffer3, lpFileNode->lpVersion);

            } else {
                
                MyLoadString(szBuffer3, IDS_NOVERSION);
            }

            MyLoadString(szBuffer2, IDS_STRING);
            wsprintf(szBuffer, szBuffer2, szBuffer3);
            WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);

            MyLoadString(szBuffer2, IDS_STRING);
            MyLoadString(szBuffer3, lpFileNode->bSigned ? IDS_SIGNED : IDS_NOTSIGNED);
            wsprintf(szBuffer, szBuffer2, szBuffer3);
            WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);

            if (lpFileNode->lpCatalog) {
                
                lstrcpy(szBuffer3, lpFileNode->lpCatalog);

            } else { 
                
                MyLoadString(szBuffer3, IDS_NA);
            }

            MyLoadString(szBuffer2, IDS_STRING);
            wsprintf(szBuffer, szBuffer2, szBuffer3);
            WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);

            if (lpFileNode->lpSignedBy) {
                
                WriteFile(hFile, lpFileNode->lpSignedBy, lstrlen(lpFileNode->lpSignedBy) * sizeof(TCHAR), &dwBytesWritten, NULL);
            }

            MyLoadString(szBuffer, IDS_LINEFEED);
            WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);
        }
    }
}

void PrintFileList(void)
{
    HANDLE          hFile;
    DWORD           dwBytesWritten;
    TCHAR           szBuffer[MAX_PATH*2];
    TCHAR           szBuffer2[MAX_PATH];
    TCHAR           szBuffer3[MAX_PATH];
    LPTSTR          lpString = NULL;
    OSVERSIONINFO   osinfo;
    SYSTEM_INFO     sysinfo;
    int             iRet;
    BOOL            bMirroredApp;

    bMirroredApp = (GetWindowLong(g_App.hDlg, GWL_EXSTYLE) & WS_EX_LAYOUTRTL);


    //
    // Bail if logging is disabled or there's no file list
    //
    if (!g_App.bLoggingEnabled || !g_App.lpFileList) {

        return;
    }

    //
    // Get the Windows directory and make it the current directory.
    //
    if (GetWindowsDirectory(szBuffer, MAX_PATH)) {

        SetCurrentDirectory(szBuffer);
    }

    hFile = CreateFile( g_App.szLogFile,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        
        MyErrorBoxId(IDS_CANTOPENLOGFILE);
        return;
    }

    //
    // If the overwrite flag is set, truncate the file.
    //
    if (g_App.bOverwrite) {
        
        SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
        SetEndOfFile(hFile);
    
    } else SetFilePointer(hFile, 0, NULL, FILE_END);

#ifdef UNICODE
    //
    // If we are using UNICODE, then write the 0xFF and 0xFE bytes at the beginning of the file.
    //
    if (g_App.bOverwrite || (GetFileSize(hFile, NULL) == 0)) {
        
        szBuffer[0] = 0xFEFF;
        WriteFile(hFile, szBuffer, sizeof(TCHAR), &dwBytesWritten, NULL);
    }
#endif

    //
    // Write the header to the logfile.
    //
    MyLoadString(szBuffer, IDS_LOGHEADER1);
    WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);

    //
    // Get the date format, so we are localizable...
    //
    MyLoadString(szBuffer2, IDS_UNKNOWN);
    iRet = GetDateFormat(LOCALE_SYSTEM_DEFAULT,
                         bMirroredApp ?
                             DATE_RTLREADING | DATE_SHORTDATE :
                             DATE_SHORTDATE,
                         NULL,
                         NULL,
                         NULL,
                         0
                         );
    
    if (iRet) {
        
        lpString = MALLOC((iRet + 1) * sizeof(TCHAR));

        if (lpString) {
            
            iRet = GetDateFormat(LOCALE_SYSTEM_DEFAULT,
                                 bMirroredApp ?
                                     DATE_RTLREADING | DATE_SHORTDATE :
                                     DATE_SHORTDATE,
                                 NULL,
                                 NULL,
                                 lpString,
                                 iRet
                                 );

            if (iRet) {
                
                lstrcpy(szBuffer2, lpString);
            }

            FREE(lpString);
        }
    }

    //
    // Get the time format, so we are localizable...
    //
    iRet = GetTimeFormat(LOCALE_SYSTEM_DEFAULT,TIME_NOSECONDS,NULL,NULL,NULL,0);
    
    if (iRet) {
        
        lpString = MALLOC((iRet + 1) * sizeof(TCHAR));

        if (lpString) {
            
            iRet = GetTimeFormat(LOCALE_SYSTEM_DEFAULT,TIME_NOSECONDS,NULL,NULL,lpString,iRet);
        }
    }

    MyLoadString(szBuffer3, IDS_LOGHEADER2);

    if (lpString) {

        wsprintf(szBuffer, szBuffer3, szBuffer2, lpString);
        FREE(lpString);

    } else {
        
        wsprintf(szBuffer, szBuffer3, szBuffer2, szBuffer2);
    }

    WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);

    //
    // Get the OS Platform string for the log file.
    //
    MyLoadString(szBuffer, IDS_OSPLATFORM);
    WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);
    ZeroMemory(&osinfo, sizeof(OSVERSIONINFO));
    osinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&osinfo);

    switch (osinfo.dwPlatformId) {
    
    case VER_PLATFORM_WIN32_NT:         
        MyLoadString(szBuffer, IDS_WINNT); 
        break;

    case VER_PLATFORM_WIN32_WINDOWS:    
        MyLoadString(szBuffer, IDS_WIN9X); 
        break;

    case VER_PLATFORM_WIN32s:           
        MyLoadString(szBuffer, IDS_WIN3X); 
        break;

    default:                            
        MyLoadString(szBuffer, IDS_UNKNOWN);
        break;
    }

    WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);

    //
    // If this is NT, then get the processor architecture and log it
    //
    if (osinfo.dwPlatformId == VER_PLATFORM_WIN32_NT) {
        
        ZeroMemory(&sysinfo, sizeof(SYSTEM_INFO));
        GetSystemInfo(&sysinfo);
        
        //
        // Initialize szBuffer to zeroes in case of an unknown architecture
        //
        ZeroMemory(szBuffer, sizeof(szBuffer));
        
        switch (sysinfo.wProcessorArchitecture) {
        
        case PROCESSOR_ARCHITECTURE_INTEL:  
            MyLoadString(szBuffer, IDS_X86); 
            break;

        case PROCESSOR_ARCHITECTURE_MIPS:   
            MyLoadString(szBuffer, IDS_MIPS); 
            break;

        case PROCESSOR_ARCHITECTURE_ALPHA:  
            MyLoadString(szBuffer, IDS_ALPHA); 
            break;

        case PROCESSOR_ARCHITECTURE_PPC:    
            MyLoadString(szBuffer, IDS_PPC); 
            break;
        }

        if (*szBuffer) {
            
            //
            // Now write the processor type to the file
            //
            WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);
        }
    }

    //
    // Get the OS Version, Build, and CSD information and log it.
    //
    MyLoadString(szBuffer2, IDS_OSVERSION);
    wsprintf(szBuffer, szBuffer2, osinfo.dwMajorVersion, osinfo.dwMinorVersion, (osinfo.dwBuildNumber & 0xFFFF), osinfo.szCSDVersion);
    WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);

    //
    // Print out the total/signed/unsigned results right before the file list
    //
    MyLoadString(szBuffer2, IDS_TOTALS);
    wsprintf(szBuffer, szBuffer2,   g_App.dwFiles, g_App.dwSigned, g_App.dwUnsigned, 
             g_App.dwFiles - g_App.dwSigned - g_App.dwUnsigned);
    WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);

    //
    // If we are doing a user-defined search, then log the parameters.
    //
    if (g_App.bUserScan) {
        
        //
        // Write the user-specified directory
        //
        MyLoadString(szBuffer2, IDS_LOGHEADER3);
        wsprintf(szBuffer, szBuffer2, g_App.szScanPattern);
        WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);

        //
        // Write the user-specified search pattern
        //
        MyLoadString(szBuffer2, IDS_LOGHEADER4);
        wsprintf(szBuffer, szBuffer2, g_App.szScanPath);
        WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);
    }

    //
    // Write the column headers to the log file
    //
    MyLoadString(szBuffer, IDS_LOGHEADER5);
    WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);
    MyLoadString(szBuffer, IDS_LOGHEADER6);
    WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);
    PrintFileListItems(hFile);

    //
    // Write the unscanned file headers to the log file
    //
    if (g_App.dwFiles > (g_App.dwSigned + g_App.dwUnsigned)) {
        
        MyLoadString(szBuffer, IDS_LOGHEADER7);
        WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);
        MyLoadString(szBuffer, IDS_LOGHEADER8);
        WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);
        PrintUnscannedFileListItems(hFile);
    }

    CloseHandle(hFile);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\sigverif\progress.c ===
/*****************************************************************************
 *
 *  Progress.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Our private progress control (because commctrl might be damanged)
 *
 *  Contents:
 *
 *      Progress_Init
 *
 *****************************************************************************/
#include "sigverif.h"

/***************************************************************************
 *
 *  GWL_* for Progress goo.
 *
 ***************************************************************************/

#define GWL_CUR             GWLP_USERDATA

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   int | Progress_GetRectPos |
 *
 *          Compute the position within the drawing rectangle that
 *          corresponds to the current position.
 *
 *          This is basically a MulDiv, except that we don't let the
 *          bar get all the way to 100% unless it really means it.
 *
 *
 ***************************************************************************/

int Progress_GetRectPos(int cx, int iCur, int iMax)
{
    int iRc;

    if (iCur != iMax) {
        iRc = MulDiv(cx, iCur, iMax);
    } else {
        iRc = cx;
    }

    return iRc;
}

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LRESULT | Progress_OnPaint |
 *
 *          Draw the first part in the highlight colors.
 *
 *          Draw the second part in the 3dface colors.
 *
 ***************************************************************************/

void Progress_OnPaint(HWND hwnd)
{
    HDC hdc;
    PAINTSTRUCT ps;

    hdc = BeginPaint(hwnd, &ps);
    if (hdc) {
        UINT taPrev;
        RECT rc;
        int cx;
        COLORREF clrTextPrev, clrBackPrev;
        int iCur, iMax, iPct;
        int ctch;
        HFONT hfPrev;
        TCHAR tsz[256];
        SIZE size;

        /*
         *  Set up the DC generically.
         */
        taPrev = SetTextAlign(hdc, TA_CENTER | TA_TOP);
        hfPrev = SelectFont(hdc, GetWindowFont(GetParent(hwnd)));

        /*
         *  Set up the colors for the left-hand side.
         */
        clrTextPrev = SetTextColor(hdc, GetSysColor(COLOR_HIGHLIGHTTEXT));
        clrBackPrev = SetBkColor(hdc, GetSysColor(COLOR_HIGHLIGHT));

        /*
         *  Now do some math.
         */
        GetClientRect(hwnd, &rc);

        cx = rc.right;

        iCur = LOWORD(GetWindowLong(hwnd, GWL_CUR));
        iMax = HIWORD(GetWindowLong(hwnd, GWL_CUR));

        if (iMax == 0) 
        {
            iMax = 1;           /* Avoid divide by zero */
        }

        if (iCur > 0) 
        {
            iPct = (iCur * 100) / iMax;
            if (iPct < 1)
                iPct = 1;
        } else iPct = 0;

        rc.right = Progress_GetRectPos(cx, iCur, iMax);

        // Update the percentage text in the progress bar.
        wsprintf(tsz, TEXT("%d%%"), iPct);
        for(ctch=0;tsz[ctch];ctch++);

        /*
         *  Draw the left-hand side.
         */
        //ctch = GetWindowText(hwnd, tsz, cA(tsz));
        if (!GetTextExtentPoint32(hdc, tsz, ctch, &size))
        {
            ExtTextOut( hdc, cx/2, 1, 
                        ETO_CLIPPED | ETO_OPAQUE,
                        &rc, tsz, ctch, 0);
        } else {
            ExtTextOut( hdc, cx/2, (rc.bottom - rc.top - size.cy + 1) / 2, 
                        ETO_CLIPPED | ETO_OPAQUE,
                        &rc, tsz, ctch, 0);
        }

        /*
         *  Now set up for the right-hand side.
         */
        SetTextColor(hdc, GetSysColor(COLOR_WINDOWTEXT));
        SetBkColor(hdc, GetSysColor(COLOR_WINDOW));

        rc.left = rc.right;
        rc.right = cx;

        /*
         *  Draw the right-hand side.
         */
        if (!GetTextExtentPoint32(hdc, tsz, ctch, &size))
        {
            ExtTextOut( hdc, cx/2, 1, 
                        ETO_CLIPPED | ETO_OPAQUE,
                        &rc, tsz, ctch, 0);
        } else {
            ExtTextOut( hdc, cx/2, (rc.bottom - rc.top - size.cy + 1) / 2, 
                        ETO_CLIPPED | ETO_OPAQUE,
                        &rc, tsz, ctch, 0);
        }

        SetBkColor(hdc, clrBackPrev);
        SetTextColor(hdc, clrTextPrev);
        SelectFont(hdc, hfPrev);
        SetTextAlign(hdc, taPrev);

        EndPaint(hwnd, &ps);
    }
}

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LRESULT | Progress_OnSetPos |
 *
 *          Update the state and invalidate the section that is affected.
 *
 ***************************************************************************/

void Progress_OnSetPos(HWND hwnd, WPARAM wp)
{
    int iCur, iMax;
    RECT rc;
    LONG lState = GetWindowLong(hwnd, GWL_CUR);


    GetClientRect(hwnd, &rc);

    iCur = LOWORD(GetWindowLong(hwnd, GWL_CUR));
    iMax = HIWORD(GetWindowLong(hwnd, GWL_CUR));

    if (iMax == 0) {
        iMax = 1;           /* Avoid divide by zero */
    }

    rc.left = Progress_GetRectPos(rc.right, iCur, iMax);
    rc.right = Progress_GetRectPos(rc.right, (int)wp, iMax);

    InvalidateRect(hwnd, 0, 0);

    SetWindowLong(hwnd, GWL_CUR, MAKELONG(wp,HIWORD(lState)));
}

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LRESULT | Progress_WndProc |
 *
 *          There really isn't much to do.
 *
 *          The string is our window text (which Windows manages for us).
 *
 *          The progress bar itself is kept in the high/low words of
 *          our GWL_USERDATA.
 *
 *          HIWORD(GetWindowLong(GWL_USERDATA)) = maximum
 *          LOWORD(GetWindowLong(GWL_USERDATA)) = current value
 *
 ***************************************************************************/

LRESULT CALLBACK
Progress_WndProc(HWND hwnd, UINT wm, WPARAM wp, LPARAM lp)
{
    switch (wm) {

    case WM_PAINT:
        Progress_OnPaint(hwnd);
        return 0;

    /*
     *  When the range resets, invalidate so we repaint.
     *
     *  wp = new current pos
     *  lp = new range
     */
    case PBM_SETRANGE:
        lp = HIWORD(lp);
        SetWindowLong(hwnd, GWL_CUR, MAKELONG(wp, lp));
        /* FALLTHROUGH */

    /*
     *  When our text changes, invalidate so we repaint.
     */
    //case WM_SETTEXT:
        //InvalidateRect(hwnd, 0, 0);
        //break;

    case PBM_SETPOS:
        Progress_OnSetPos(hwnd, wp);
        break;

    case PBM_DELTAPOS:
        lp = LOWORD(GetWindowLong(hwnd, GWL_CUR));
        Progress_OnSetPos(hwnd, wp + lp);
        break;

    case WM_ERASEBKGND:
        return 0;
    }

    return DefWindowProc(hwnd, wm, wp, lp);
}

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | Progress_InitRegisterClass |
 *
 *          Register our window classes.
 *
 ***************************************************************************/

void Progress_InitRegisterClass(void)
{
    WNDCLASS wc;

    /*
     *  Progress control.
     */
    wc.style = 0;
    wc.lpfnWndProc = Progress_WndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = cbX(DWORD);
    wc.hInstance = g_App.hInstance;
    wc.hIcon = 0;
    wc.hCursor = LoadCursor(0, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_BACKGROUND);
    wc.lpszMenuName = 0;
    wc.lpszClassName = TEXT("progress");

    RegisterClass(&wc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\sigverif\sigverif.c ===
//
//  SIGVERIF.C
//
#define SIGVERIF_DOT_C
#include "sigverif.h"

// Allocate our global data structure
GAPPDATA    g_App;

//
//  Load a resource string into a buffer that is assumed to be MAX_PATH bytes.
//
void MyLoadString(LPTSTR lpString, UINT uId)
{
    LoadString(g_App.hInstance, uId, lpString, MAX_PATH);
}

//
//  Pop an OK messagebox with a specific string
//
void MyMessageBox(LPTSTR lpString)
{
    TCHAR szBuffer[MAX_PATH];
    LPTSTR lpBuffer = szBuffer;

    MyLoadString(lpBuffer, IDS_MSGBOX);
    MessageBox(g_App.hDlg, lpString, lpBuffer, MB_OK);
}

//
//  Pop an OK messagebox with a resource string ID
//
void MyMessageBoxId(UINT uId)
{
    TCHAR szBuffer[MAX_PATH];
    LPTSTR lpBuffer = szBuffer;

    MyLoadString(lpBuffer, uId);
    MyMessageBox(lpBuffer);
}

//
//  Pop an error messagebox with a specific string
//
void MyErrorBox(LPTSTR lpString)
{
    TCHAR szBuffer[MAX_PATH];
    LPTSTR lpBuffer = szBuffer;

    MyLoadString(lpBuffer, IDS_ERRORBOX);
    MessageBox(g_App.hDlg, lpString, lpBuffer, MB_OK);
}

//
//  Pop an error messagebox with a resource string ID
//
void MyErrorBoxId(UINT uId)
{
    TCHAR szBuffer[MAX_PATH];
    LPTSTR lpBuffer = szBuffer;

    MyLoadString(lpBuffer, uId);
    MyErrorBox(lpBuffer);
}

//
// Since Multi-User Windows will give me back a Profile directory, I need to get the real Windows directory
// Dlg_OnInitDialog initializes g_App.szWinDir with the real Windows directory, so I just use that.
//
UINT MyGetWindowsDirectory(LPTSTR lpDirName, UINT uSize)
{
    UINT  uRet = 0;

    if (lpDirName)
    {
        lstrcpy(lpDirName, g_App.szWinDir);
        uRet = lstrlen(lpDirName);
    }

    return uRet;
}

//
//  Initialization of main dialog.
//
BOOL Dlg_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    HKEY    hKey;
    LONG    lRes;
    DWORD   dwDisp, dwType, dwFlags, cbData;
    TCHAR   szBuffer[MAX_PATH];

    // Initialize global hDlg to current hwnd.
    g_App.hDlg = hwnd;

    // Set the window class to have the icon in the resource file
    if (g_App.hIcon)
    {
        SetClassLongPtr(hwnd, GCLP_HICON, (LONG_PTR) g_App.hIcon);
    }

    // Make sure the IDC_STATUS control is hidden until something happens.
    ShowWindow(GetDlgItem(g_App.hDlg, IDC_STATUS), SW_HIDE);

    // Set the range for the custom progress bar to 0-100.
    SendMessage(GetDlgItem(g_App.hDlg, IDC_PROGRESS), PBM_SETRANGE, (WPARAM) 0, (LPARAM) MAKELPARAM(0, 100));

    // Set the global lpLogName to the one that's given in the resource file
    MyLoadString(g_App.szLogFile, IDS_LOGNAME);

    //
    // Figure out what the real Windows directory is and store it in g_App.szWinDir
    // This is required because Hydra makes GetWindowsDirectory return a PROFILE directory
    //
    // We store the original CurrentDirectory in szBuffer so we can restore it after this hack.
    // Next we switch into the SYSTEM/SYSTEM32 directory and then into its parent directory.
    // This is what we want to store in g_App.szWinDir.
    //
    GetCurrentDirectory(MAX_PATH, szBuffer);
    GetSystemDirectory(g_App.szWinDir, MAX_PATH);
    SetCurrentDirectory(g_App.szWinDir);
    SetCurrentDirectory(TEXT(".."));
    GetCurrentDirectory(MAX_PATH, g_App.szWinDir);
    SetCurrentDirectory(szBuffer);

    // Set the global search folder to %WinDir%
    MyGetWindowsDirectory(g_App.szScanPath, MAX_PATH);

    // Set the global search pattern to "*.*"
    MyLoadString(g_App.szScanPattern, IDS_ALL);

    // Reset the progress bar back to zero percent
    SendMessage(GetDlgItem(g_App.hDlg, IDC_PROGRESS), PBM_SETPOS, (WPARAM) 0, (LPARAM) 0);

    // By default, we want to turn logging and set the logging mode to OVERWRITE
    g_App.bLoggingEnabled   = TRUE;
    g_App.bOverwrite        = TRUE;

    //
    // Look in the registry for any settings from the last SigVerif session
    //
    lRes = RegCreateKeyEx(  SIGVERIF_HKEY,
                            SIGVERIF_KEY,
                            0,
                            NULL,
                            0,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hKey,
                            &dwDisp);

    if (lRes == ERROR_SUCCESS)
    {
        // If all we did was create a new key, then there must not be any data.  Just close the key.
        if (dwDisp == REG_CREATED_NEW_KEY)
        {
            RegCloseKey(hKey);
        }
        else // Otherwise, query the values and set any values that we found.
        {
            cbData = sizeof(DWORD);
            lRes = RegQueryValueEx( hKey,
                                    SIGVERIF_FLAGS,
                                    NULL,
                                    &dwType,
                                    (LPBYTE) &dwFlags,
                                    &cbData);
            if (lRes == ERROR_SUCCESS)
            {
                g_App.bLoggingEnabled   = (dwFlags & 0x1);
                g_App.bOverwrite        = (dwFlags & 0x2);
            }

            cbData = MAX_PATH;
            lRes = RegQueryValueEx( hKey,
                                    SIGVERIF_LOGNAME,
                                    NULL,
                                    &dwType,
                                    (LPBYTE) szBuffer,
                                    &cbData);
            if (lRes == ERROR_SUCCESS && dwType == REG_SZ)
            {
                lstrcpy(g_App.szLogFile, szBuffer);
            }

            RegCloseKey(hKey);
        }
    }

    // Get the startup directory of SigVerif
    GetCurrentDirectory(MAX_PATH, g_App.szAppDir);

    //
    // Check if the user specified /NOBVT, /NODEV, or /NOPRN
    //
    MyLoadString(szBuffer, IDS_NOBVT);
    if (MyStrStr(GetCommandLine(), szBuffer))
        g_App.bNoBVT = TRUE;

    MyLoadString(szBuffer, IDS_NODEV);
    if (MyStrStr(GetCommandLine(), szBuffer))
        g_App.bNoDev = TRUE;

    MyLoadString(szBuffer, IDS_NOPRN);
    if (MyStrStr(GetCommandLine(), szBuffer))
        g_App.bNoPRN = TRUE;

    //
    // If the user specified the "BlySak" flag, we want to log the signed and unsigned filenames to the root.
    //
    MyLoadString(szBuffer, IDS_BLYSAK);
    if (MyStrStr(GetCommandLine(), szBuffer))
        g_App.bLogToRoot = TRUE;

    //
    // If the user specified the FullSystemScan flag, we want to scan the entire system drive and log the results.
    //
    MyLoadString(szBuffer, IDS_FULLSCAN);
    lstrcat(szBuffer, TEXT(":"));
    if (MyStrStr(GetCommandLine(), szBuffer))
    {
        g_App.bFullSystemScan     = TRUE;
        g_App.bLoggingEnabled     = TRUE;
        g_App.bLogToRoot          = TRUE;
        g_App.bUserScan           = TRUE;
        g_App.bSubFolders         = TRUE;
        lstrcpy(g_App.szScanPath, MyStrStr(GetCommandLine(), szBuffer) + lstrlen(szBuffer));

        if (g_App.szScanPath[0] == TEXT('\0')) {
            MyGetWindowsDirectory(g_App.szScanPath, MAX_PATH);
        }

        // Now that everything is set up, simulate a click to the START button...
        PostMessage(hwnd, WM_COMMAND, MAKEWPARAM(ID_START, 0), (LPARAM) 0);
    }

    //
    // If the user specified the DefaultSystemScan flag, we want to scan the entire system drive and log the results.
    //
    MyLoadString(szBuffer, IDS_DEFSCAN);
    if (MyStrStr(GetCommandLine(), szBuffer))
    {
        g_App.bFullSystemScan     = TRUE;
        g_App.bLoggingEnabled     = TRUE;
        g_App.bLogToRoot          = TRUE;

        // Now that everything is set up, simulate a click to the START button...
        PostMessage(hwnd, WM_COMMAND, MAKEWPARAM(ID_START, 0), (LPARAM) 0);
    }

    return TRUE;
}

//
//  Build file list according to dialog settings, then verify the files in the list
//
void WINAPI ProcessFileList(void)
{
    DWORD dwCount = 0;
    TCHAR szBuffer[MAX_PATH];

    // Set the scanning flag to TRUE, so we don't double-scan
    g_App.bScanning = TRUE;

    // Assume a successful install.
    g_App.LastError = ERROR_SUCCESS;

    // Change the "Start" to "Stop"
    MyLoadString(szBuffer, IDS_STOP);
    SetDlgItemText(g_App.hDlg, ID_START, szBuffer);

    EnableWindow(GetDlgItem(g_App.hDlg, ID_ADVANCED), FALSE);
    EnableWindow(GetDlgItem(g_App.hDlg, IDCANCEL), FALSE);

    // Display the text that says "Building file list..."
    MyLoadString(szBuffer, IDS_STATUS_BUILD);
    SetDlgItemText(g_App.hDlg, IDC_STATUS, szBuffer);

    // Hide the IDC_INFOTEXT text item so it doesn't cover IDC_STATUS
    //ShowWindow(GetDlgItem(g_App.hDlg, IDC_INFOTEXT), SW_HIDE);

    // Make sure the IDC_STATUS text item visible
    ShowWindow(GetDlgItem(g_App.hDlg, IDC_STATUS), SW_SHOW);

    // Free any memory that we may have allocated for the g_App.lpFileList
    DestroyFileList(TRUE);

    // Now actually build the g_App.lpFileList list given the dialog settings
    if (g_App.bUserScan)
    {
        BuildFileList(g_App.szScanPath);
    }
    else
    {
        if (!g_App.bNoDev && !g_App.bStopScan) {
            BuildDriverFileList();
        }

        if (!g_App.bNoPRN && !g_App.bStopScan) {
            BuildPrinterFileList();
        }

        if (!g_App.bNoBVT && !g_App.bStopScan) {
            BuildCoreFileList();
        }
    }

    // Check if there is even a file list to verify.
    if (g_App.lpFileList)
    {
        if (!g_App.bStopScan)
        {
            // Display the "Scanning File List..." text
            MyLoadString(szBuffer, IDS_STATUS_SCAN);
            SetDlgItemText(g_App.hDlg, IDC_STATUS, szBuffer);

            // Reset the progress bar back to zero percent while it's invisible.
            SendMessage(GetDlgItem(g_App.hDlg, IDC_PROGRESS), PBM_SETPOS, (WPARAM) 0, (LPARAM) 0);

            //
            // WooHoo! Let's display the progress bar and start cranking on the file list!
            //
            ShowWindow(GetDlgItem(g_App.hDlg, IDC_PROGRESS), SW_SHOW);
            VerifyFileList();
            ShowWindow(GetDlgItem(g_App.hDlg, IDC_PROGRESS), SW_HIDE);
        }
    }
    else
    {
        //
        // The IDC_NOTMS code displays it's own error message, so only display
        // an error dialog if we are doing a System Integrity Scan
        //
        if (!g_App.bStopScan && !g_App.bUserScan)
        {
            MyMessageBoxId(IDS_NOSYSTEMFILES);
        }
    }

    // Disable the start button while we clean up the g_App.lpFileList
    EnableWindow(GetDlgItem(g_App.hDlg, ID_START), FALSE);

    if (!g_App.bStopScan)
    {
        // Display the text that says "Writing Log File..."
        MyLoadString(szBuffer, IDS_STATUS_LOG);
        SetDlgItemText(g_App.hDlg, IDC_STATUS, szBuffer);

        // Write the results to the log file
        PrintFileList();
    }
    else
    {
        // If the user clicked STOP, let them know about it.
        MyMessageBoxId(IDS_SCANSTOPPED);
    }

    // Display the text that says "Freeing File List..."
    MyLoadString(szBuffer, IDS_STATUS_FREE);
    SetDlgItemText(g_App.hDlg, IDC_STATUS, szBuffer);

    // Free all the memory that we allocated for the g_App.lpFileList
    DestroyFileList(FALSE);

    // Hide the IDC_STATUS text item so it doesn't cover IDC_STATUS
    ShowWindow(GetDlgItem(g_App.hDlg, IDC_STATUS), SW_HIDE);

    // Change the "Stop" button back to "Start"
    MyLoadString(szBuffer, IDS_START);
    SetDlgItemText(g_App.hDlg, ID_START, szBuffer);

    EnableWindow(GetDlgItem(g_App.hDlg, ID_START), TRUE);
    EnableWindow(GetDlgItem(g_App.hDlg, ID_ADVANCED), TRUE);
    EnableWindow(GetDlgItem(g_App.hDlg, IDCANCEL), TRUE);

    // Clear the scanning flag
    g_App.bScanning = FALSE;
    g_App.bStopScan = FALSE;

    //
    // If the user started SigVerif with the FullSystemScan flag, then we exit.
    //
    if (g_App.bFullSystemScan)
    {
        PostMessage(g_App.hDlg, WM_CLOSE, (WPARAM) 0, (LPARAM) 0);
    }
}

//  Spawns a thread to do the scan so the GUI remains responsive.
void Dlg_OnPushStartButton(HWND hwnd)
{
    HANDLE hThread;
    DWORD dwThreadId;

    // Check if we are already scanning... if so, bail.
    if (g_App.bScanning)
        return;

    // Create a thread where Search_ProcessFileList can go without tying up the GUI thread.
    hThread = CreateThread(NULL,
                           0,
                           (LPTHREAD_START_ROUTINE) ProcessFileList,
                           0,
                           0,
                           &dwThreadId);
}

//  Handle any WM_COMMAND messages sent to the search dialog
void Dlg_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    switch(id)
    {
        //
        //  The user clicked ID_START, so if we aren't scanning start scanning.
        //  If we are scanning, then stop the tests because the button actually says "Stop"
        //
        case ID_START:
            if (!g_App.bScanning)
            {
                Dlg_OnPushStartButton(hwnd);
            } 
            else if (!g_App.bStopScan)
            {
                g_App.bStopScan = TRUE;
                g_App.LastError = ERROR_CANCELLED;
            }
            break;

        //
        //  The user clicked IDCANCEL, so if the tests are running try to stop them before exiting.
        //
        case IDCANCEL:
            if (g_App.bScanning)
            {
                g_App.bStopScan = TRUE;
                g_App.LastError = ERROR_CANCELLED;
            } else SendMessage(hwnd, WM_CLOSE, 0, 0);
            break;

        //  Pop up the IDD_SETTINGS dialog so the user can change their log settings.
        case ID_ADVANCED:
            if (!g_App.bScanning)
            {
                AdvancedPropertySheet(hwnd);
            }
            break;
    }
}

void SigVerif_Help(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL bContext)
{
    static DWORD SigVerif_HelpIDs[] =
    {
        IDC_SCAN,           IDH_SIGVERIF_SEARCH_CHECK_SYSTEM,
        IDC_NOTMS,          IDH_SIGVERIF_SEARCH_LOOK_FOR,
        IDC_TYPE,           IDH_SIGVERIF_SEARCH_SCAN_FILES,
        IDC_FOLDER,         IDH_SIGVERIF_SEARCH_LOOK_IN_FOLDER,
        IDC_SUBFOLDERS,     IDH_SIGVERIF_SEARCH_INCLUDE_SUBFOLDERS,
        IDC_ENABLELOG,      IDH_SIGVERIF_LOGGING_ENABLE_LOGGING,
        IDC_APPEND,         IDH_SIGVERIF_LOGGING_APPEND,
        IDC_OVERWRITE,      IDH_SIGVERIF_LOGGING_OVERWRITE,
        IDC_LOGNAME,        IDH_SIGVERIF_LOGGING_FILENAME,
        IDC_VIEWLOG,        IDH_SIGVERIF_LOGGING_VIEW_LOG,
        0,0
    };

    static DWORD Windows_HelpIDs[] =
    {
        ID_BROWSE,      IDH_BROWSE,
        0,0
    };

    HWND hItem = NULL;
    LPHELPINFO lphi = NULL;
    POINT point;

    switch (uMsg)
    {
        case WM_HELP:
            lphi = (LPHELPINFO) lParam;
            if (lphi && (lphi->iContextType == HELPINFO_WINDOW))   // must be for a control
                hItem = (HWND) lphi->hItemHandle;
            break;

        case WM_CONTEXTMENU:
            hItem = (HWND) wParam;
            point.x = GET_X_LPARAM(lParam);
            point.y = GET_Y_LPARAM(lParam);
            if (ScreenToClient(hwnd, &point))
            {
                hItem = ChildWindowFromPoint(hwnd, point);
            }
            break;
    }

    if (hItem)
    {
        if (GetWindowLong(hItem, GWL_ID) == ID_BROWSE)
        {
            WinHelp(hItem,
                    (LPCTSTR) WINDOWS_HELPFILE,
                    (bContext ? HELP_CONTEXTMENU : HELP_WM_HELP),
                    (ULONG_PTR) Windows_HelpIDs);
        }
        else
        {
            WinHelp(hItem,
                    (LPCTSTR) SIGVERIF_HELPFILE,
                    (bContext ? HELP_CONTEXTMENU : HELP_WM_HELP),
                    (ULONG_PTR) SigVerif_HelpIDs);
        }
    }
}

//
//  The main dialog procedure.  Needs to handle WM_INITDIALOG, WM_COMMAND, and WM_CLOSE/WM_DESTROY.
//
INT_PTR CALLBACK DlgProc(HWND hwnd, UINT uMsg,
                         WPARAM wParam, LPARAM lParam)
{
    BOOL    fProcessed = TRUE;

    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_INITDIALOG, Dlg_OnInitDialog);
        HANDLE_MSG(hwnd, WM_COMMAND, Dlg_OnCommand);

        case WM_CLOSE:
            if (g_App.bScanning)
                g_App.bStopScan = TRUE;
            else 
                EndDialog(hwnd, IDCANCEL);
            break;

        default: fProcessed = FALSE;
    }

    return fProcessed;
}

//
//  Program entry point.  Set up for creation of IDD_DIALOG.
//
WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                LPSTR lpszCmdParam, int nCmdShow)
{
    HWND hwnd;
    TCHAR szAppName[MAX_PATH];

    // Zero-Initialize our global data structure
    ZeroMemory(&g_App, sizeof(GAPPDATA));

    // Initialize global hInstance variable
    g_App.hInstance = hInstance;

    // Look for any existing instances of SigVerif...
    MyLoadString(szAppName, IDS_SIGVERIF);
    hwnd = FindWindow(NULL, szAppName);
    if (!hwnd)
    {
        // We definitely need this for the progress bar, and maybe other stuff too.
        InitCommonControls();

        // Register the custom control we use for the progress bar
        Progress_InitRegisterClass();

        // Load the icon from the resource file that we will use everywhere
        g_App.hIcon = LoadIcon(g_App.hInstance, MAKEINTRESOURCE(IDI_ICON1));

        // Create the IDD_DIALOG and use DlgProc as the main procedure
        DialogBox(hInstance, MAKEINTRESOURCE(IDD_DIALOG), NULL, DlgProc);

        // Free the icon
        if (g_App.hIcon) {
            DestroyIcon(g_App.hIcon);
            g_App.hIcon = NULL;
        }
    }
    else
    {
        // If there is already an instance of SigVerif running, make that one foreground and we exit.
        SetForegroundWindow(hwnd);
    }

    //
    // If we encountered any errors during our scan, then return the error code,
    // otherwise return 0 if all the files are signed or 1 if we found any
    // unsigned files.
    //
    if (g_App.LastError != ERROR_SUCCESS) {
        return g_App.LastError;
    } else {
        return ((g_App.dwUnsigned > 0) ? 1 : 0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\sigverif\sigverif.h ===
//
//  SIGVERIF.H
//
#include <windows.h>
#include <windowsx.h>
#include <shellapi.h>
#include <commctrl.h>
#include <setupapi.h>
#include <cfgmgr32.h>
#include <tchar.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <winspool.h>
#include <imagehlp.h>
#include <capi.h>
#include <softpub.h>
#include <sfc.h>
#include "resource.h"

// Macros and pre-defined values
#define     cbX(X)      sizeof(X)
#define     cA(a)       (cbX(a)/cbX(a[0]))
#define     MALLOC(x)   HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (x))
#define     FREE(x)     if (x) { HeapFree(GetProcessHeap(), 0, (x)); x = NULL; }
#define     EXIST(x)    (GetFileAttributes(x) != 0xFFFFFFFF)
#define     MAX_INT     0x7FFFFFFF
#define     HASH_SIZE   100
#define     NUM_PAGES   2

// Registry key/value names for storing previous settings
#define     SIGVERIF_HKEY       HKEY_CURRENT_USER
#define     SIGVERIF_KEY        TEXT("Software\\Microsoft\\Sigverif")
#define     SIGVERIF_FLAGS      TEXT("Flags")
#define     SIGVERIF_LOGNAME    TEXT("Logname")

#define SIGVERIF_PRINTER_ENV	TEXT("All")

// This structure holds all the information for a specific file.
typedef struct tagFileNode
{
    LPTSTR          lpFileName;
    LPTSTR          lpDirName;
    LPTSTR          lpVersion;
    LPTSTR          lpCatalog;
    LPTSTR          lpSignedBy;
    LPTSTR          lpTypeName;
    INT             iIcon;
    BOOL            bSigned;
    BOOL            bScanned;
    BOOL            bValidateAgainstAnyOs;
    DWORD           LastError;
    SYSTEMTIME      LastModified;
    struct  tagFileNode *next;
} FILENODE, *LPFILENODE;

// This structure is used by walkpath to keep track of subdirectories
typedef struct tagDirNode {
    TCHAR   DirName[MAX_PATH];
    struct  tagDirNode *next;
} DIRNODE, *LPDIRNODE;

// This structure is used when we walk the devicemanager list.
typedef struct _DeviceTreeNode 
{
    struct _DeviceTreeNode *Child;
    struct _DeviceTreeNode *Sibling;
    DEVINST    DevInst;
    TCHAR      Driver[MAX_PATH];
} DEVTREENODE, *PDEVTREENODE;

typedef struct _DeviceTreeData 
{
    HDEVINFO hDeviceInfo;
    DEVTREENODE RootNode;
} DEVICETREE, *PDEVICETREE;

// This is our global data structure that hold our global variables.
typedef struct tagAppData
{
    HWND        hDlg;
    HWND        hLogging;
    HWND        hSearch;
    HICON       hIcon;
    HINSTANCE   hInstance;
    TCHAR       szScanPath[MAX_PATH];
    TCHAR       szScanPattern[MAX_PATH];
    TCHAR       szAppDir[MAX_PATH];
    TCHAR       szLogFile[MAX_PATH];
    TCHAR       szWinDir[MAX_PATH];
    LPFILENODE  lpFileList;
    LPFILENODE  lpFileLast;
    HCATADMIN   hCatAdmin;
    DWORD       dwFiles;
    DWORD       dwSigned;
    DWORD       dwUnsigned;
    BOOL        bNoBVT;
    BOOL        bNoDev;
    BOOL        bNoPRN;
    BOOL        bOverwrite;
    BOOL        bLoggingEnabled;
    BOOL        bLogToRoot;
    BOOL        bFullSystemScan;
    BOOL        bScanning;
    BOOL        bStopScan;
    BOOL        bUserScan;
    BOOL        bSubFolders;
    DWORD       LastError;
} GAPPDATA, *LPGAPPDATA;

// Global function prototypes
BOOL BrowseForFolder(HWND hwnd, LPTSTR lpszBuf);
void BuildFileList(LPTSTR lpPathName);
BOOL VerifyFileList(void);
BOOL VerifyFileNode(LPFILENODE lpFileNode);
void MyLoadString(LPTSTR lpString, UINT uId);
void MyMessageBox(LPTSTR lpString);
void MyErrorBox(LPTSTR lpString);
void MyErrorBoxId(UINT uId);
void MyMessageBoxId(UINT uId);
UINT MyGetWindowsDirectory(LPTSTR lpDirName, UINT uSize);
LPTSTR MyStrStr(LPTSTR lpString, LPTSTR lpSubString);
INT_PTR CALLBACK Details_DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK ListView_DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK LogFile_DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
LPFILENODE CreateFileNode(LPTSTR lpDirectory, LPTSTR lpFileName);
BOOL IsFileAlreadyInList(LPTSTR lpDirName, LPTSTR lpFileName);
void SigVerif_Help(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL bContext);
void AdvancedPropertySheet(HWND hwnd);
void InsertFileNodeIntoList(LPFILENODE lpFileNode);
void DestroyFileList(BOOL bClear);
void DestroyFileNode(LPFILENODE lpFileNode);
void PrintFileList(void);
void Progress_InitRegisterClass(void);
void BuildDriverFileList(void);
void BuildPrinterFileList(void);
void BuildCoreFileList(void);
void MyGetFileInfo(LPFILENODE lpFileInfo);


//
// Context-Sensitive Help/Identifiers specific to SigVerif
//
#define SIGVERIF_HELPFILE                       TEXT("SIGVERIF.HLP")
#define WINDOWS_HELPFILE                        TEXT("WINDOWS.HLP")
#define IDH_SIGVERIF_SEARCH_CHECK_SYSTEM        1000
#define IDH_SIGVERIF_SEARCH_LOOK_FOR            1010
#define IDH_SIGVERIF_SEARCH_SCAN_FILES          1020
#define IDH_SIGVERIF_SEARCH_LOOK_IN_FOLDER      1030
#define IDH_SIGVERIF_SEARCH_INCLUDE_SUBFOLDERS  1040
#define IDH_SIGVERIF_LOGGING_ENABLE_LOGGING     1050
#define IDH_SIGVERIF_LOGGING_APPEND             1060
#define IDH_SIGVERIF_LOGGING_OVERWRITE          1070
#define IDH_SIGVERIF_LOGGING_FILENAME           1080
#define IDH_SIGVERIF_LOGGING_VIEW_LOG           1090

//
// Context-Sensitive Help Identifiers for Browse button
//
#define IDH_BROWSE  28496

//
// g_App is allocated in SIGVERIF.C, so everywhere else we want to make it extern
//
#ifndef SIGVERIF_DOT_C
extern GAPPDATA g_App;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\sigverif\filelist.c ===
//
//  FILELIST.C
//
#include "sigverif.h"

LPTSTR MyStrStr(LPTSTR lpString, LPTSTR lpSubString)
{
    if (!lpString || !lpSubString)
        return NULL;

    // Make both strings lowercase, so we don't have to worry about case-sensitivity.
    CharLowerBuff(lpString, lstrlen(lpString));
    CharLowerBuff(lpSubString, lstrlen(lpSubString));

    return (_tcsstr(lpString, lpSubString));
}

void InsertFileNodeIntoList(LPFILENODE lpFileNode)
{
    LPFILENODE  lpTempNode = g_App.lpFileList;
    LPFILENODE  lpPrevNode = NULL;
    INT         iRet;

    if (!lpFileNode)
        return;

    if (!g_App.lpFileList)
    {
        //
        // Initialize the global file lists
        //
        g_App.lpFileList = lpFileNode;
        g_App.lpFileLast = lpFileNode;
    }
    else
    {
        for(lpTempNode=g_App.lpFileList;lpTempNode;lpTempNode=lpTempNode->next)
        {
            //
            // Insert items sorted by directory and then filename
            //
            iRet = lstrcmp(lpTempNode->lpDirName, lpFileNode->lpDirName);
            if (iRet == 0)
            {
                //
                // If the directory names match, key off the filename
                //
                iRet = lstrcmp(lpTempNode->lpFileName, lpFileNode->lpFileName);
            }

            if (iRet >= 0)
            {
                if (!lpPrevNode)
                {
                    //
                    // Insert at the head of the list
                    //
                    lpFileNode->next = lpTempNode;
                    g_App.lpFileList = lpFileNode;
                    return;
                }
                else
                {
                    //
                    // Inserting between lpPrevNode and lpTempNode
                    //
                    lpFileNode->next = lpTempNode;
                    lpPrevNode->next = lpFileNode;
                    return;
                }
            }

            lpPrevNode = lpTempNode;
        }

        //
        // There were no matches, so insert this item at the end of the list
        //
        g_App.lpFileLast->next = lpFileNode;
        g_App.lpFileLast = lpFileNode;
    }
}

BOOL IsFileAlreadyInList(LPTSTR lpDirName, LPTSTR lpFileName)
{
    LPFILENODE lpFileNode;

    CharLowerBuff(lpDirName, lstrlen(lpDirName));
    CharLowerBuff(lpFileName, lstrlen(lpFileName));

    for(lpFileNode=g_App.lpFileList;lpFileNode;lpFileNode=lpFileNode->next)
    {
        if (!lstrcmp(lpFileNode->lpFileName, lpFileName) && !lstrcmp(lpFileNode->lpDirName, lpDirName))
        {
            return TRUE;
        }
    }

    return FALSE;
}

// Free all the memory allocated in a single File Node.
void DestroyFileNode(LPFILENODE lpFileNode)
{
    if (!lpFileNode) {
        return;
    }

    if (lpFileNode->lpFileName) {
        FREE(lpFileNode->lpFileName);
    }

    if (lpFileNode->lpDirName) {
        FREE(lpFileNode->lpDirName);
    }

    if (lpFileNode->lpVersion) {
        FREE(lpFileNode->lpVersion);
    }

    if (lpFileNode->lpCatalog) {
        FREE(lpFileNode->lpCatalog);
    }

    if (lpFileNode->lpSignedBy) {
        FREE(lpFileNode->lpSignedBy);
    }

    if (lpFileNode->lpTypeName) {
        FREE(lpFileNode->lpTypeName);
    }

    if (lpFileNode) {
        FREE(lpFileNode);
        lpFileNode = NULL;
    }
}

// Free all the memory allocated in the g_App.lpFileList.
void DestroyFileList(
    BOOL bClear)
{
    LPFILENODE lpFileNode;

    while(g_App.lpFileList)
    {
        lpFileNode = g_App.lpFileList->next;
        DestroyFileNode(g_App.lpFileList);
        g_App.lpFileList = lpFileNode;
    }

    g_App.lpFileLast = NULL;

    if (bClear) {
        g_App.dwFiles    = 0;
        g_App.dwSigned   = 0;
        g_App.dwUnsigned = 0;
    }
}

LPFILENODE CreateFileNode(LPTSTR lpDirectory, LPTSTR lpFileName)
{
    LPFILENODE                  lpFileNode;
    TCHAR                       szDirName[MAX_PATH];
    FILETIME                    ftLocalTime;
    WIN32_FILE_ATTRIBUTE_DATA   faData;
    BOOL                        bRet;
    
    GetCurrentDirectory(MAX_PATH, szDirName);
    CharLowerBuff(szDirName, lstrlen(szDirName));

    lpFileNode = (LPFILENODE) MALLOC(sizeof(FILENODE));

    if (lpFileNode) 
    {
        lpFileNode->lpFileName = (LPTSTR) MALLOC((lstrlen(lpFileName) + 1) * sizeof(TCHAR));

        if (!lpFileNode->lpFileName) 
        {
            goto clean0;
        }
        
        lstrcpy(lpFileNode->lpFileName, lpFileName);
        CharLowerBuff(lpFileNode->lpFileName, lstrlen(lpFileNode->lpFileName));
    
        if (lpDirectory)
        {
            lpFileNode->lpDirName = (LPTSTR) MALLOC((lstrlen(lpDirectory) + 1) * sizeof(TCHAR));
            
            if (!lpFileNode->lpDirName) 
            {
                goto clean0;
            }
                
            lstrcpy(lpFileNode->lpDirName, lpDirectory);
            CharLowerBuff(lpFileNode->lpDirName, lstrlen(lpFileNode->lpDirName));
        }
        else
        {
            lpFileNode->lpDirName = (LPTSTR) MALLOC((lstrlen(szDirName) + 1) * sizeof(TCHAR));

            if (!lpFileNode->lpDirName) 
            {
                goto clean0;
            }
            
            lstrcpy(lpFileNode->lpDirName, szDirName);
            CharLowerBuff(lpFileNode->lpDirName, lstrlen(lpFileNode->lpDirName));
        }
    
        if (lpDirectory)
            SetCurrentDirectory(lpDirectory);
    
        ZeroMemory(&faData, sizeof(WIN32_FILE_ATTRIBUTE_DATA));
        bRet = GetFileAttributesEx(lpFileName, GetFileExInfoStandard, &faData);
        if (bRet) 
        {
            // Store away the last access time for logging purposes.
            FileTimeToLocalFileTime(&faData.ftLastWriteTime, &ftLocalTime);
            FileTimeToSystemTime(&ftLocalTime, &lpFileNode->LastModified);
        }
    }
    
    if (lpDirectory)
        SetCurrentDirectory(szDirName);

    return lpFileNode;

clean0:

    //
    // If we get here then we weren't able to allocate all of the memory needed
    // for this structure, so free up any memory we were able to allocate and
    // reutnr NULL.
    //
    if (lpFileNode) 
    {
        if (lpFileNode->lpFileName) 
        {
            FREE(lpFileNode->lpFileName);
        }

        if (lpFileNode->lpDirName) 
        {
            FREE(lpFileNode->lpDirName);
        }

        FREE(lpFileNode);
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\sigverif\listview.c ===
//
// LISTVIEW.C
//
#include "sigverif.h"

HWND    g_hListView         = NULL;
HWND    g_hStatus           = NULL;
BOOL    g_bSortOrder[]      = { FALSE, FALSE, FALSE, FALSE, FALSE};
RECT    g_Rect;

// Initialize the image lists for the icons in the listview control.
BOOL WINAPI ListView_SetImageLists(HWND hwndList)
{
    SHFILEINFO      sfi;
    HIMAGELIST      himlSmall;
    HIMAGELIST      himlLarge;
    BOOL            bSuccess = TRUE;
    TCHAR           szDriveRoot[MAX_PATH];

    MyGetWindowsDirectory(szDriveRoot, cA(szDriveRoot));
    szDriveRoot[3] = 0;
    himlSmall = (HIMAGELIST)SHGetFileInfo((LPCTSTR)szDriveRoot, 
                                          0,
                                          &sfi, 
                                          sizeof(SHFILEINFO), 
                                          SHGFI_SYSICONINDEX | SHGFI_SMALLICON);

    himlLarge = (HIMAGELIST)SHGetFileInfo((LPCTSTR)szDriveRoot, 
                                          0,
                                          &sfi, 
                                          sizeof(SHFILEINFO), 
                                          SHGFI_SYSICONINDEX | SHGFI_LARGEICON);

    if (himlSmall && himlLarge) {
        ListView_SetImageList(hwndList, himlSmall, LVSIL_SMALL);
        ListView_SetImageList(hwndList, himlLarge, LVSIL_NORMAL);
    } else bSuccess = FALSE;

    return bSuccess;
}

//
// Insert everything from the g_App.lpFileList into the listview control.
//
void ListView_InsertItems(void)
{
    LPFILENODE  lpFileNode;
    LV_ITEM     lvi;
    TCHAR       szBuffer[MAX_PATH];
    LPTSTR      lpString;
    int         iRet;
    BOOL        bMirroredApp;

    bMirroredApp = (GetWindowLong(g_App.hDlg, GWL_EXSTYLE) & WS_EX_LAYOUTRTL);

    for (lpFileNode=g_App.lpFileList;lpFileNode;lpFileNode=lpFileNode->next) {

        if (lpFileNode->bScanned &&
            !lpFileNode->bSigned &&
            SetCurrentDirectory(lpFileNode->lpDirName)) {

            //
            // Initialize lvi and insert the filename and icon into the first column.
            //
            ZeroMemory(&lvi, sizeof(LV_ITEM));
            lvi.mask = LVIF_TEXT;
            lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
            lvi.iImage = lpFileNode->iIcon;
            lvi.lParam = (LPARAM) lpFileNode;
            lvi.iSubItem = 0;
            lvi.pszText = lpFileNode->lpFileName;
            lvi.iItem = MAX_INT;
            lvi.iItem = ListView_InsertItem(g_hListView, &lvi);

            //
            // Insert the directory name into the second column.
            //
            lvi.mask = LVIF_TEXT;
            lvi.iSubItem = 1;
            lvi.pszText = lpFileNode->lpDirName;
            ListView_SetItem(g_hListView, &lvi);

            //
            // Get the date format, so we are localizable...
            //
            MyLoadString(szBuffer, IDS_UNKNOWN);

            iRet = GetDateFormat(LOCALE_SYSTEM_DEFAULT, 
                                 bMirroredApp ? 
                                    DATE_RTLREADING | DATE_SHORTDATE :
                                    DATE_SHORTDATE,
                                 &lpFileNode->LastModified,
                                 NULL,
                                 NULL,
                                 0);

            if (iRet) {

                lpString = MALLOC((iRet + 1) * sizeof(TCHAR));

                if (lpString) {

                    iRet = GetDateFormat(LOCALE_SYSTEM_DEFAULT,
                                         bMirroredApp ?
                                            DATE_RTLREADING | DATE_SHORTDATE :
                                            DATE_SHORTDATE,
                                         &lpFileNode->LastModified,
                                         NULL,
                                         lpString,
                                         iRet);

                    if (iRet) {

                        lstrcpy(szBuffer, lpString);
                    }

                    FREE(lpString);
                }
            }

            lvi.mask = LVIF_TEXT;
            lvi.iSubItem = 2;
            lvi.pszText = szBuffer;
            ListView_SetItem(g_hListView, &lvi);

            //
            // Insert the filetype string into the fourth column.
            //
            if (lpFileNode->lpTypeName) {

                lstrcpy(szBuffer, lpFileNode->lpTypeName);

            } else {
                
                MyLoadString(szBuffer, IDS_UNKNOWN);
            }

            lvi.mask = LVIF_TEXT;
            lvi.iSubItem = 3;
            lvi.pszText = szBuffer;
            ListView_SetItem(g_hListView, &lvi);

            //
            // Insert the version string into the fifth column.
            //
            if (lpFileNode->lpVersion) {

                lstrcpy(szBuffer, lpFileNode->lpVersion);

            } else {
                
                MyLoadString(szBuffer, IDS_NOVERSION);
            }

            lvi.mask = LVIF_TEXT;
            lvi.iSubItem = 4;
            lvi.pszText = szBuffer;
            ListView_SetItem(g_hListView, &lvi);
        }
    }
}

//
// Initialize the listview dialog.  First, we are going to load the global icon resource.
// Then we are going to create a status window and the actual listview control.
// Then we need to add the four columns and work out their default widths.
//
BOOL ListView_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{   
    LV_COLUMN   lvc;
    RECT        rect, rectResultsText, rectStatusBar, rectCancelButton, rectClient;
    TCHAR       szBuffer[MAX_PATH];
    TCHAR       szBuffer2[MAX_PATH];
    INT         iCol = 0, iWidth = 0;

    //
    // Load the global icon resource
    //
    if (g_App.hIcon) {

        SetClassLongPtr(hwnd, GCLP_HICON, (LONG_PTR) g_App.hIcon); 
    }

    //
    // Create the status window at the bottom of the dialog
    //
    g_hStatus = CreateStatusWindow(WS_CHILD | WS_VISIBLE,
                                   NULL,
                                   hwnd,
                                   (UINT) IDC_STATUSWINDOW);

    //
    // Load the status string and fill it in with the correct values.
    //
    MyLoadString(szBuffer, IDS_NUMFILES);
    wsprintf(szBuffer2, szBuffer,   g_App.dwFiles, g_App.dwSigned, g_App.dwUnsigned, 
             g_App.dwFiles - g_App.dwSigned - g_App.dwUnsigned);
    SendMessage(g_hStatus, WM_SETTEXT, (WPARAM) 0, (LPARAM) szBuffer2);

    GetWindowRect(hwnd, &g_Rect);
    GetClientRect(hwnd, &rectClient);

    //
    // Get the windows RECT values for the dialog, the static text, and the status window.
    // We will use these values to figure out where to put the listview and the columns.
    //
    GetWindowRect(hwnd, &rect);
    GetWindowRect(GetDlgItem(hwnd, IDC_RESULTSTEXT), &rectResultsText);
    GetWindowRect(g_hStatus, &rectStatusBar);
    GetWindowRect(GetDlgItem(hwnd, IDCANCEL), &rectCancelButton);

    MoveWindow(GetDlgItem(hwnd, IDCANCEL), 
               (GetWindowLong(hwnd, GWL_EXSTYLE) & WS_EX_LAYOUTRTL)
                 ? (rect.right - rect.left) - (rectCancelButton.right - rectCancelButton.left) - (rect.right - rectResultsText.right)
                 : (rect.right - rectResultsText.left) - (rectCancelButton.right - rectCancelButton.left) - (( 2 * (rectResultsText.left - rect.left)) / 3),
               (rectClient.bottom - rectClient.top) - (rectStatusBar.bottom - rectStatusBar.top) - (rectCancelButton.bottom - rectCancelButton.top) - 10,
               rectCancelButton.right - rectCancelButton.left,
               rectCancelButton.bottom - rectCancelButton.top,
               TRUE);

    GetWindowRect(GetDlgItem(hwnd, IDCANCEL), &rectCancelButton);

    //
    // Create the listview window!  I am using some really screwey logic to figure out how
    // big to make the listview and where to put it, but it seems to work.
    //
    g_hListView = CreateWindowEx(WS_EX_CLIENTEDGE, 
                                 WC_LISTVIEW, TEXT(""), 
                                 WS_TABSTOP | WS_VSCROLL | WS_VISIBLE | WS_CHILD | WS_BORDER | 
                                 LVS_SINGLESEL | LVS_REPORT | LVS_AUTOARRANGE | LVS_SHAREIMAGELISTS,
                                 ((rectResultsText.left - rect.left) * 2) / 3,
                                 (rectResultsText.bottom - rectResultsText.top) * 2,
                                 (rect.right - rect.left) - 2 * (rectResultsText.left - rect.left),
                                 rectCancelButton.top - rectResultsText.bottom - 20,
                                 hwnd, 
                                 (HMENU) IDC_LISTVIEW, 
                                 g_App.hInstance, 
                                 NULL);


    //
    // If the CreateWindowEx failed, then bail.
    //
    if (!g_hListView) {
    
        return FALSE;
    }

    //
    // Initialize the icon lists
    //
    ListView_SetImageLists(g_hListView);

    //
    // Create the first listview column for the icon and the file name.
    //
    lvc.mask = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH;
    lvc.fmt = LVCFMT_LEFT;
    lvc.cx = (rectResultsText.right - rectResultsText.left) / 5;
    lvc.pszText = szBuffer;
    MyLoadString(szBuffer, IDS_COL_NAME);
    lvc.cchTextMax = MAX_PATH;
    ListView_InsertColumn(g_hListView, iCol++, &lvc);   

    //
    // Create the second listview column for the directory name.
    //
    iWidth += lvc.cx;
    lvc.cx = (rectResultsText.right - rectResultsText.left) / 4;
    MyLoadString(szBuffer, IDS_COL_FOLDER);
    ListView_InsertColumn(g_hListView, iCol++, &lvc);

    //
    // Create the third listview column for the date name.
    //
    iWidth += lvc.cx;
    lvc.cx = (rectResultsText.right - rectResultsText.left) / 6;
    lvc.fmt = LVCFMT_CENTER;
    MyLoadString(szBuffer, IDS_COL_DATE);
    ListView_InsertColumn(g_hListView, iCol++, &lvc);

    //
    // Create the fourth listview column for the filetype string.
    //
    iWidth += lvc.cx;
    lvc.cx = (rectResultsText.right - rectResultsText.left) / 6;
    lvc.fmt = LVCFMT_CENTER;
    MyLoadString(szBuffer, IDS_COL_TYPE);
    ListView_InsertColumn(g_hListView, iCol++, &lvc);

    //
    // Create the fifth listview column for the version string.
    //
    iWidth += lvc.cx;
    lvc.cx = (rectResultsText.right - rectResultsText.left) - iWidth - 5;
    lvc.fmt = LVCFMT_CENTER;
    MyLoadString(szBuffer, IDS_COL_VERSION);
    ListView_InsertColumn(g_hListView, iCol++, &lvc);

    //
    // Now that the columns are set up, insert all the files in g_App.lpFileList!
    //
    ListView_InsertItems();

    //
    // Initialize the sorting order array to all FALSE.
    //
    g_bSortOrder[0] = FALSE;
    g_bSortOrder[1] = FALSE;
    g_bSortOrder[2] = FALSE;
    g_bSortOrder[3] = FALSE;

    SetForegroundWindow(g_App.hDlg);
    SetForegroundWindow(hwnd);
    SetFocus(GetDlgItem(hwnd, IDCANCEL));

    return TRUE;
}

//
// This function checks to see how big the sizing rectangle will be.  If the user is trying
// to size the dialog to less than the values in g_Rect, then we will fix the rectangle values
//
BOOL ListView_OnSizing(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    RECT    rect;
    LPRECT  lpRect = (LPRECT) lParam;
    BOOL    bRet = FALSE;

    GetWindowRect(hwnd, &rect);

    if ((lpRect->right - lpRect->left) < (g_Rect.right - g_Rect.left)) {
        lpRect->left = rect.left;
        lpRect->right = lpRect->left + (g_Rect.right - g_Rect.left);
        bRet = TRUE;
    }

    if ((lpRect->bottom - lpRect->top) < (g_Rect.bottom - g_Rect.top)) {
        lpRect->top = rect.top;
        lpRect->bottom = lpRect->top + (g_Rect.bottom - g_Rect.top);
        bRet = TRUE;
    }

    return bRet;
}

//
// This function allows us to resize the listview control and status windows when the
// user resizes the results dialog.  Thankfully, we can make everything relative using
// the RECT values for the main dialog, the static text, and the status window.
//
void ListView_ResizeWindow(HWND hwnd)
{
    RECT    rect, rectResultsText, rectStatusBar, rectCancelButton, rectClient;
    BOOL    bMirroredApp;

    bMirroredApp = (GetWindowLong(hwnd, GWL_EXSTYLE) & WS_EX_LAYOUTRTL);

    GetWindowRect(hwnd, &rect);

    if ((rect.right - rect.left) < (g_Rect.right - g_Rect.left)) {
        
        MoveWindow(hwnd,
                   rect.left,
                   rect.top,
                   g_Rect.right - g_Rect.left,
                   rect.bottom - rect.top,
                   TRUE);
    }

    if ((rect.bottom - rect.top) < (g_Rect.bottom - g_Rect.top)) {
        
        MoveWindow(hwnd,
                   rect.left,
                   rect.top,
                   rect.right - rect.left,
                   g_Rect.bottom - g_Rect.top,
                   TRUE);
    }

    GetClientRect(hwnd, &rectClient);
    GetWindowRect(GetDlgItem(hwnd, IDC_RESULTSTEXT), &rectResultsText);
    GetWindowRect(GetDlgItem(hwnd, IDCANCEL), &rectCancelButton);
    GetWindowRect(g_hStatus, &rectStatusBar);


    MoveWindow(g_hStatus,
               0,
               (rect.bottom - rect.top) - (rectStatusBar.bottom - rectStatusBar.top),
               rect.right - rect.left,
               rectStatusBar.bottom - rectStatusBar.top,
               TRUE);

    MoveWindow(GetDlgItem(hwnd, IDCANCEL), 
               (GetWindowLong(hwnd, GWL_EXSTYLE) & WS_EX_LAYOUTRTL)
                 ? (rect.right - rect.left) - (rectCancelButton.right - rectCancelButton.left) - (rect.right - rectResultsText.right)
                 : (rect.right - rectResultsText.left) - (rectCancelButton.right - rectCancelButton.left) - (( 2 * (rectResultsText.left - rect.left)) / 3),
               (rectClient.bottom - rectClient.top) - (rectStatusBar.bottom - rectStatusBar.top) - (rectCancelButton.bottom - rectCancelButton.top) - 10,
               rectCancelButton.right - rectCancelButton.left,
               rectCancelButton.bottom - rectCancelButton.top,
               TRUE);

    GetWindowRect(GetDlgItem(hwnd, IDCANCEL), &rectCancelButton);

    MoveWindow(g_hListView,
               bMirroredApp
                 ? ((rect.right - rectResultsText.right) * 2) / 3
                 : ((rectResultsText.left - rect.left) * 2) / 3,
               (rectResultsText.bottom - rectResultsText.top) * 2,
               bMirroredApp
                 ? (rect.right - rect.left) - 2 * (rect.right - rectResultsText.right)
                 : (rect.right - rect.left) - 2 * (rectResultsText.left - rect.left),
               rectCancelButton.top - rectResultsText.bottom - 20,
               TRUE);

}

//
// This function is a callback that returns a value for ListView_SortItems.
// ListView_SortItems wants a negative, zero, or positive number.
// Since CompareString returns 1,2,3 we just subtract 2 from the return value.
//
// We use the g_bSortOrder array to figure out which way we have sorted in the past.
//
// Warning: we don't check for error values from CompareString
//
int CALLBACK ListView_CompareNames(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    LPFILENODE  lpFileNode1;
    LPFILENODE  lpFileNode2;
    FILETIME    FileTime1, FileTime2;
    int         iResult = 2;

    //
    // Depending on the sort order, we swap the order of comparison
    //
    if (g_bSortOrder[lParamSort]) {
        lpFileNode2 = (LPFILENODE) lParam1;
        lpFileNode1 = (LPFILENODE) lParam2;
    } else {
        lpFileNode1 = (LPFILENODE) lParam1;
        lpFileNode2 = (LPFILENODE) lParam2;
    }

    switch (lParamSort) {
    // We are comparing the file names
    case 0: iResult = CompareString(LOCALE_SYSTEM_DEFAULT, 
                                    NORM_IGNORECASE | NORM_IGNOREWIDTH, 
                                    lpFileNode1->lpFileName, 
                                    -1, 
                                    lpFileNode2->lpFileName,
                                    -1);
        break;

        // We are comparing the directory names
    case 1: iResult = CompareString(LOCALE_SYSTEM_DEFAULT, 
                                    NORM_IGNORECASE | NORM_IGNOREWIDTH, 
                                    lpFileNode1->lpDirName, 
                                    -1, 
                                    lpFileNode2->lpDirName,
                                    -1);
        break;

        // We are comparing the LastWriteTime's between the two files.
    case 2: SystemTimeToFileTime(&lpFileNode1->LastModified, &FileTime1);
        SystemTimeToFileTime(&lpFileNode2->LastModified, &FileTime2);
        iResult = CompareFileTime(&FileTime1, &FileTime2);
        return iResult;

        break;

        // We are comparing the filetype strings
    case 3: iResult = CompareString(LOCALE_SYSTEM_DEFAULT, 
                                    NORM_IGNORECASE | NORM_IGNOREWIDTH, 
                                    lpFileNode1->lpTypeName, 
                                    -1, 
                                    lpFileNode2->lpTypeName,
                                    -1);
        break;

        // We are comparing the version strings
    case 4: iResult = CompareString(LOCALE_SYSTEM_DEFAULT, 
                                    NORM_IGNORECASE | NORM_IGNOREWIDTH, 
                                    lpFileNode1->lpVersion, 
                                    -1, 
                                    lpFileNode2->lpVersion,
                                    -1);
        break;
    }

    return(iResult - 2);
}

//
// This function handles the clicks on the column headers and calls ListView_SortItems with the
// ListView_CompareNames callback previously defined.  It then toggles the sortorder for that column.
//
LRESULT ListView_NotifyHandler(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    NMHDR       *lpnmhdr = (NMHDR *) lParam;
    NM_LISTVIEW *lpnmlv = (NM_LISTVIEW *) lParam;

    switch (lpnmhdr->code) {
    case LVN_COLUMNCLICK:
        switch (lpnmlv->iSubItem) {
        case 0: 
        case 1:
        case 2: 
        case 3: 
        case 4: ListView_SortItems(lpnmlv->hdr.hwndFrom, ListView_CompareNames, (LPARAM) lpnmlv->iSubItem);
            g_bSortOrder[lpnmlv->iSubItem] = !(g_bSortOrder[lpnmlv->iSubItem]);
            break;
        }
        break;
    }

    return 0;
}

//
// The only thing we look for here is the IDCANCEL if the user hit ESCAPE
//
void ListView_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    switch (id) {
    case IDCANCEL:
        SendMessage(hwnd, WM_CLOSE, 0, 0);
        break;
    }
}

INT_PTR CALLBACK ListView_DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL    fProcessed = TRUE;

    switch (uMsg) {
    HANDLE_MSG(hwnd, WM_INITDIALOG, ListView_OnInitDialog);
    HANDLE_MSG(hwnd, WM_COMMAND, ListView_OnCommand);

    case WM_NOTIFY:
        return ListView_NotifyHandler(hwnd, uMsg, wParam, lParam);

    case WM_CLOSE:
        if (g_hStatus) {

            DestroyWindow(g_hStatus);
            g_hStatus = NULL;
        }

        if (g_hListView) {

            DestroyWindow(g_hListView);
            g_hListView = NULL;
        }

        EndDialog(hwnd, ID_CLOSE);
        break;

    case WM_SIZING:
        fProcessed = ListView_OnSizing(hwnd, wParam, lParam);
        break;

    case WM_SIZE:
        ListView_ResizeWindow(hwnd);
        break;

    default: fProcessed = FALSE;
    }

    return fProcessed;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\sigverif\verify.c ===
//
// VERIFY.C
//
#include "sigverif.h"

//
// Find the file extension and place it in the lpFileNode->lpTypeName field
//
void MyGetFileTypeName(LPFILENODE lpFileInfo)
{
    TCHAR szBuffer[MAX_PATH];
    TCHAR szBuffer2[MAX_PATH];
    TCHAR szExt[MAX_PATH];
    LPTSTR lpExtension;

    // Initialize szBuffer to be an empty string.
    szBuffer[0] = 0;

    // Walk to the end of lpFileName
    for (lpExtension = lpFileInfo->lpFileName; *lpExtension; lpExtension++);

    // Walk backwards until we hit a '.' and we'll use that as our extension
    for (lpExtension--; *lpExtension && lpExtension >= lpFileInfo->lpFileName; lpExtension--) {
        
        if (lpExtension[0] == TEXT('.')) {
            
            lstrcpy(szExt, lpExtension + 1);
            CharUpperBuff(szExt, lstrlen(szExt));
            MyLoadString(szBuffer2, IDS_FILETYPE);
            wsprintf(szBuffer, szBuffer2, szExt);
        }
    }

    // If there's no extension, then just call this a "File".
    if (szBuffer[0] == 0) {
        
        MyLoadString(szBuffer, IDS_FILE);
    }

    lpFileInfo->lpTypeName = MALLOC((lstrlen(szBuffer) + 1) * sizeof(TCHAR));

    if (lpFileInfo->lpTypeName) {
        
        lstrcpy(lpFileInfo->lpTypeName, szBuffer);
    }
}

//
// Use SHGetFileInfo to get the icon index for the specified file.
//
void MyGetFileInfo(LPFILENODE lpFileInfo)
{
    SHFILEINFO  sfi;

    ZeroMemory(&sfi, sizeof(SHFILEINFO));
    SHGetFileInfo(  lpFileInfo->lpFileName,
                    0,
                    &sfi,
                    sizeof(SHFILEINFO),
                    SHGFI_SYSICONINDEX | SHGFI_SMALLICON | SHGFI_TYPENAME);

    lpFileInfo->iIcon = sfi.iIcon;

    if (*sfi.szTypeName) {
        
        lpFileInfo->lpTypeName = MALLOC((lstrlen(sfi.szTypeName) + 1) * sizeof(TCHAR));

        if (lpFileInfo->lpTypeName) {
            
            lstrcpy(lpFileInfo->lpTypeName, sfi.szTypeName);
        }

    } else {

        MyGetFileTypeName(lpFileInfo);
    }
}

void GetFileVersion(LPFILENODE lpFileInfo)
{
    DWORD               dwHandle, dwRet, dwLength;
    BOOL                bRet;
    LPVOID              lpData = NULL;
    LPVOID              lpBuffer;
    VS_FIXEDFILEINFO    *lpInfo;
    TCHAR               szBuffer[MAX_PATH];
    TCHAR               szBuffer2[MAX_PATH];

    dwRet = GetFileVersionInfoSize(lpFileInfo->lpFileName, &dwHandle);
    
    if (dwRet) {
        
        lpData = MALLOC(dwRet + 1);
        
        if (lpData) {
            
            bRet = GetFileVersionInfo(lpFileInfo->lpFileName, dwHandle, dwRet, lpData);
            
            if (bRet) {
                
                lpBuffer = NULL;
                dwLength = 0;
                bRet = VerQueryValue(lpData, TEXT("\\"), &lpBuffer, &dwLength);
                
                if (bRet) {
                    
                    lpInfo = (VS_FIXEDFILEINFO *) lpBuffer;

                    MyLoadString(szBuffer2, IDS_VERSION);
                    wsprintf(szBuffer, szBuffer2,   HIWORD(lpInfo->dwFileVersionMS), LOWORD(lpInfo->dwFileVersionMS),
                             HIWORD(lpInfo->dwFileVersionLS), LOWORD(lpInfo->dwFileVersionLS));

                    lpFileInfo->lpVersion = MALLOC((lstrlen(szBuffer) + 1) * sizeof(TCHAR));

                    if (lpFileInfo->lpVersion) {
                        
                        lstrcpy(lpFileInfo->lpVersion, szBuffer);
                    }
                }
            }

            FREE(lpData);
        }
    }

    if (!lpFileInfo->lpVersion) {
        
        MyLoadString(szBuffer, IDS_NOVERSION);
        lpFileInfo->lpVersion = MALLOC((lstrlen(szBuffer) + 1) * sizeof(TCHAR));

        if (lpFileInfo->lpVersion) {
            
            lstrcpy(lpFileInfo->lpVersion, szBuffer);
        }
    }
}

/*************************************************************************
*   Function : VerifyIsFileSigned
*   Purpose : Calls WinVerifyTrust with Policy Provider GUID to
*   verify if an individual file is signed.
**************************************************************************/
BOOL VerifyIsFileSigned(LPTSTR pcszMatchFile, PDRIVER_VER_INFO lpVerInfo)
{
    INT                 iRet;
    HRESULT             hRes;
    WINTRUST_DATA       WinTrustData;
    WINTRUST_FILE_INFO  WinTrustFile;
    GUID                gOSVerCheck = DRIVER_ACTION_VERIFY;
    GUID                gPublishedSoftware = WINTRUST_ACTION_GENERIC_VERIFY_V2;
#ifndef UNICODE
    WCHAR               wszFileName[MAX_PATH];
#endif

    ZeroMemory(&WinTrustData, sizeof(WINTRUST_DATA));
    WinTrustData.cbStruct = sizeof(WINTRUST_DATA);
    WinTrustData.dwUIChoice = WTD_UI_NONE;
    WinTrustData.fdwRevocationChecks = WTD_REVOKE_NONE;
    WinTrustData.dwUnionChoice = WTD_CHOICE_FILE;
    WinTrustData.dwStateAction = WTD_STATEACTION_AUTO_CACHE;
    WinTrustData.pFile = &WinTrustFile;
    WinTrustData.pPolicyCallbackData = (LPVOID)lpVerInfo;

    ZeroMemory(lpVerInfo, sizeof(DRIVER_VER_INFO));
    lpVerInfo->cbStruct = sizeof(DRIVER_VER_INFO);

    ZeroMemory(&WinTrustFile, sizeof(WINTRUST_FILE_INFO));
    WinTrustFile.cbStruct = sizeof(WINTRUST_FILE_INFO);

#ifndef UNICODE
    iRet = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pcszMatchFile, -1, (LPWSTR)&wszFileName, cA(wszFileName));
    WinTrustFile.pcwszFilePath = wszFileName;
#else
    WinTrustFile.pcwszFilePath = pcszMatchFile;
#endif

    hRes = WinVerifyTrust(g_App.hDlg, &gOSVerCheck, &WinTrustData);
    if (hRes != ERROR_SUCCESS) {
    
        hRes = WinVerifyTrust(g_App.hDlg, &gPublishedSoftware, &WinTrustData);
    }

    //
    // Free the pcSignerCertContext member of the DRIVER_VER_INFO struct
    // that was allocated in our call to WinVerifyTrust.
    //
    if (lpVerInfo && lpVerInfo->pcSignerCertContext) {

        CertFreeCertificateContext(lpVerInfo->pcSignerCertContext);
        lpVerInfo->pcSignerCertContext = NULL;
    }

    return(hRes == ERROR_SUCCESS);
}

//
// Given a specific LPFILENODE, verify that the file is signed or unsigned.
// Fill in all the necessary structures so the listview control can display properly.
//
BOOL VerifyFileNode(LPFILENODE lpFileNode)
{
    HANDLE                  hFile;
    BOOL                    bRet;
    HCATINFO                hCatInfo = NULL;
    HCATINFO                PrevCat;
    WINTRUST_DATA           WinTrustData;
    WINTRUST_CATALOG_INFO   WinTrustCatalogInfo;
    DRIVER_VER_INFO         VerInfo;
    GUID                    gSubSystemDriver = DRIVER_ACTION_VERIFY;
    HRESULT                 hRes;
    DWORD                   cbHash = HASH_SIZE;
    BYTE                    szHash[HASH_SIZE];
    LPBYTE                  lpHash = szHash;
    CATALOG_INFO            CatInfo;
    LPTSTR                  lpFilePart;
    TCHAR                   szBuffer[MAX_PATH];
    static TCHAR            szCurrentDirectory[MAX_PATH];
    OSVERSIONINFO           OsVersionInfo;
#ifndef UNICODE
    WCHAR UnicodeKey[MAX_PATH];
#endif

    // If this is the first item we are verifying, then initialize the static buffer.
    if (lpFileNode == g_App.lpFileList) {
        
        ZeroMemory(szCurrentDirectory, sizeof(szCurrentDirectory));
    }

    //
    // Check the current directory against the one in the lpFileNode.
    // We only want to call SetCurrentDirectory if the path is different.
    //
    if (lstrcmp(szCurrentDirectory, lpFileNode->lpDirName)) {
        
        if (!SetCurrentDirectory(lpFileNode->lpDirName)) {
        
            return FALSE;
        }

        lstrcpy(szCurrentDirectory, lpFileNode->lpDirName);
    }

    //
    // Get the handle to the file, so we can call CryptCATAdminCalcHashFromFileHandle
    //
    hFile = CreateFile( lpFileNode->lpFileName,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        
        lpFileNode->LastError = GetLastError();

        return FALSE;
    }

    // Initialize the hash buffer
    ZeroMemory(lpHash, HASH_SIZE);

    // Generate the hash from the file handle and store it in lpHash
    if (!CryptCATAdminCalcHashFromFileHandle(hFile, &cbHash, lpHash, 0)) {
        
        //
        // If we couldn't generate a hash, it might be an individually signed catalog.
        // If it's a catalog, zero out lpHash and cbHash so we know there's no hash to check.
        //
        if (IsCatalogFile(hFile, NULL)) {
            
            lpHash = NULL;
            cbHash = 0;
        
        } else {  // If it wasn't a catalog, we'll bail and this file will show up as unscanned.
            
            CloseHandle(hFile);
            return FALSE;
        }
    }

    // Close the file handle
    CloseHandle(hFile);

    //
    // Now we have the file's hash.  Initialize the structures that
    // will be used later on in calls to WinVerifyTrust.
    //
    ZeroMemory(&WinTrustData, sizeof(WINTRUST_DATA));
    WinTrustData.cbStruct = sizeof(WINTRUST_DATA);
    WinTrustData.dwUIChoice = WTD_UI_NONE;
    WinTrustData.fdwRevocationChecks = WTD_REVOKE_NONE;
    WinTrustData.dwUnionChoice = WTD_CHOICE_CATALOG;
    WinTrustData.dwStateAction = WTD_STATEACTION_AUTO_CACHE;
    WinTrustData.pPolicyCallbackData = (LPVOID)&VerInfo;

    ZeroMemory(&VerInfo, sizeof(DRIVER_VER_INFO));
    VerInfo.cbStruct = sizeof(DRIVER_VER_INFO);

    //
    // Only validate against the current OS Version, unless the bValidateAgainstAnyOs
    // parameter was TRUE.  In that case we will just leave the sOSVersionXxx fields
    // 0 which tells WinVerifyTrust to validate against any OS.
    //
    if (!lpFileNode->bValidateAgainstAnyOs) {
        OsVersionInfo.dwOSVersionInfoSize = sizeof(OsVersionInfo);
        if (GetVersionEx(&OsVersionInfo)) {
            VerInfo.sOSVersionLow.dwMajor = OsVersionInfo.dwMajorVersion;
            VerInfo.sOSVersionLow.dwMinor = OsVersionInfo.dwMinorVersion;
            VerInfo.sOSVersionHigh.dwMajor = OsVersionInfo.dwMajorVersion;
            VerInfo.sOSVersionHigh.dwMinor = OsVersionInfo.dwMinorVersion;
        }
    }


    WinTrustData.pCatalog = &WinTrustCatalogInfo;

    ZeroMemory(&WinTrustCatalogInfo, sizeof(WINTRUST_CATALOG_INFO));
    WinTrustCatalogInfo.cbStruct = sizeof(WINTRUST_CATALOG_INFO);
    WinTrustCatalogInfo.pbCalculatedFileHash = lpHash;
    WinTrustCatalogInfo.cbCalculatedFileHash = cbHash;
#ifdef UNICODE
    WinTrustCatalogInfo.pcwszMemberTag = lpFileNode->lpFileName;
#else
    MultiByteToWideChar(CP_ACP, 0, lpFileNode->lpFileName, -1, UnicodeKey, cA(UnicodeKey));
    WinTrustCatalogInfo.pcwszMemberTag = UnicodeKey;
#endif

    //
    // Now we try to find the file hash in the catalog list, via CryptCATAdminEnumCatalogFromHash
    //
    PrevCat = NULL;

    if (g_App.hCatAdmin) {
        hCatInfo = CryptCATAdminEnumCatalogFromHash(g_App.hCatAdmin, lpHash, cbHash, 0, &PrevCat);
    } else {
        hCatInfo = NULL;
    }

    //
    // We want to cycle through the matching catalogs until we find one that matches both hash and member tag
    //
    bRet = FALSE;
    while (hCatInfo && !bRet) {
        
        ZeroMemory(&CatInfo, sizeof(CATALOG_INFO));
        CatInfo.cbStruct = sizeof(CATALOG_INFO);
        
        if (CryptCATCatalogInfoFromContext(hCatInfo, &CatInfo, 0)) {
            
            WinTrustCatalogInfo.pcwszCatalogFilePath = CatInfo.wszCatalogFile;

            // Now verify that the file is an actual member of the catalog.
            hRes = WinVerifyTrust(g_App.hDlg, &gSubSystemDriver, &WinTrustData);
            
            if (hRes == ERROR_SUCCESS) {
#ifdef UNICODE
                GetFullPathName(CatInfo.wszCatalogFile, MAX_PATH, szBuffer, &lpFilePart);
#else
                WideCharToMultiByte(CP_ACP, 0, CatInfo.wszCatalogFile, -1, szBuffer, sizeof(szBuffer), NULL, NULL);
                GetFullPathName(szBuffer, MAX_PATH, szBuffer, &lpFilePart);
#endif
                lpFileNode->lpCatalog = MALLOC((lstrlen(lpFilePart) + 1) * sizeof(TCHAR));

                if (lpFileNode->lpCatalog) {

                    lstrcpy(lpFileNode->lpCatalog, lpFilePart);
                }

                bRet = TRUE;
            }

            //
            // Free the pcSignerCertContext member of the DRIVER_VER_INFO struct
            // that was allocated in our call to WinVerifyTrust.
            //
            if (VerInfo.pcSignerCertContext != NULL) {

                CertFreeCertificateContext(VerInfo.pcSignerCertContext);
                VerInfo.pcSignerCertContext = NULL;
            }
        }

        if (!bRet) {
            
            // The hash was in this catalog, but the file wasn't a member... so off to the next catalog
            PrevCat = hCatInfo;
            hCatInfo = CryptCATAdminEnumCatalogFromHash(g_App.hCatAdmin, lpHash, cbHash, 0, &PrevCat);
        }
    }

    // Mark this file as having been scanned.
    lpFileNode->bScanned = TRUE;

    if (!hCatInfo) {
        
        //
        // If it wasn't found in the catalogs, check if the file is individually signed.
        //
        bRet = VerifyIsFileSigned(lpFileNode->lpFileName, (PDRIVER_VER_INFO)&VerInfo);
        
        if (bRet) {
            
            // If so, mark the file as being signed.
            lpFileNode->bSigned = TRUE;
        }
    
    } else {
        
        // The file was verified in the catalogs, so mark it as signed and free the catalog context.
        lpFileNode->bSigned = TRUE;
        CryptCATAdminReleaseCatalogContext(g_App.hCatAdmin, hCatInfo, 0);
    }

    if (lpFileNode->bSigned) {

#ifdef UNICODE
        lpFileNode->lpVersion = MALLOC((lstrlen(VerInfo.wszVersion) + 1) * sizeof(TCHAR));

        if (lpFileNode->lpVersion) {
            
            lstrcpy(lpFileNode->lpVersion, VerInfo.wszVersion);
        }

        lpFileNode->lpSignedBy = MALLOC((lstrlen(VerInfo.wszSignedBy) + 1) * sizeof(TCHAR));

        if (lpFileNode->lpSignedBy) {
            
            lstrcpy(lpFileNode->lpSignedBy, VerInfo.wszSignedBy);
        }
#else
        WideCharToMultiByte(CP_ACP, 0, VerInfo.wszVersion, -1, szBuffer, sizeof(szBuffer), NULL, NULL);
        lpFileNode->lpVersion = MALLOC((lstrlen(szBuffer) + 1) * sizeof(TCHAR));

        if (lpFileNode->lpVersion) {
            
            lstrcpy(lpFileNode->lpVersion, szBuffer);
        }

        WideCharToMultiByte(CP_ACP, 0, VerInfo.wszSignedBy, -1, szBuffer, sizeof(szBuffer), NULL, NULL);
        lpFileNode->lpSignedBy = MALLOC((lstrlen(szBuffer) + 1) * sizeof(TCHAR));

        if (lpFileNode->lpSignedBy) {
            
            lstrcpy(lpFileNode->lpSignedBy, szBuffer);
        }
#endif
    
    } else {
        // 
        // Get the icon (if the file isn't signed) so we can display it in the listview faster.
        //
        MyGetFileInfo(lpFileNode);
    }

    return lpFileNode->bSigned;
}

//
// This function loops through g_App.lpFileList to verify each file.  We want to make this loop as tight
// as possible and keep the progress bar updating as we go.  When we are done, we want to pop up a
// dialog that allows the user to choose "Details" which will give them the listview control.
//
BOOL VerifyFileList(void)
{
    LPFILENODE lpFileNode;
    DWORD       dwCount = 0;
    DWORD       dwPercent = 0;
    DWORD       dwCurrent = 0;
    TCHAR       szBuffer[MAX_PATH];
    TCHAR       szBuffer2[MAX_PATH];
    DWORD       dwBytesWritten;
    HANDLE      hSigverif = INVALID_HANDLE_VALUE;
    HANDLE      hTotals = INVALID_HANDLE_VALUE;
    HANDLE      hFileSigned = INVALID_HANDLE_VALUE;
    HANDLE      hFileUnsigned = INVALID_HANDLE_VALUE;
    HANDLE      hFileUnscanned = INVALID_HANDLE_VALUE;

    // Initialize the signed and unsigned counts
    g_App.dwSigned    = 0;
    g_App.dwUnsigned  = 0;

    // If we don't already have an g_App.hCatAdmin handle, acquire one.
    if (!g_App.hCatAdmin) {
        CryptCATAdminAcquireContext(&g_App.hCatAdmin, NULL, 0);
    }

    //
    //  If the user specified test switches, then we want to open log files to record
    //  the scanning results as they happen.  SIGVERIF.TXT has every file before it is
    //  scanned (in case of a fault), SIGNED.TXT gets signed files, UNSIGNED.TXT gets
    //  unsigned files, UNSCANNED.TXT gets everything else.  TOTALS.TXT was added last
    //  and gets the text from the status window on the results dialog.
    //
    if (g_App.bLogToRoot) {
        MyGetWindowsDirectory(szBuffer, MAX_PATH);
        szBuffer[3] = 0;
        lstrcat(szBuffer, TEXT("SIGVERIF.TXT"));

        hSigverif = CreateFile( szBuffer, 
                                GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_READ,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);

        if (hSigverif != INVALID_HANDLE_VALUE) {

            SetFilePointer(hSigverif, 0, NULL, FILE_BEGIN);
            SetEndOfFile(hSigverif);
        }

        MyGetWindowsDirectory(szBuffer, MAX_PATH);
        szBuffer[3] = 0;
        lstrcat(szBuffer, TEXT("TOTALS.TXT"));

        hTotals = CreateFile(   szBuffer, 
                                GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_READ,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);

        if (hTotals != INVALID_HANDLE_VALUE) {

            SetFilePointer(hTotals, 0, NULL, FILE_BEGIN);
            SetEndOfFile(hTotals);
        }

        MyGetWindowsDirectory(szBuffer, MAX_PATH);
        szBuffer[3] = 0;
        lstrcat(szBuffer, TEXT("SIGNED.TXT"));

        hFileSigned = CreateFile(   szBuffer, 
                                    GENERIC_READ | GENERIC_WRITE,
                                    FILE_SHARE_READ,
                                    NULL,
                                    CREATE_ALWAYS,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL);

        if (hFileSigned != INVALID_HANDLE_VALUE) {

            SetFilePointer(hFileSigned, 0, NULL, FILE_BEGIN);
            SetEndOfFile(hFileSigned);
        }

        MyGetWindowsDirectory(szBuffer, MAX_PATH);
        szBuffer[3] = 0;
        lstrcat(szBuffer, TEXT("UNSIGNED.TXT"));

        hFileUnsigned = CreateFile( szBuffer, 
                                    GENERIC_READ | GENERIC_WRITE,
                                    FILE_SHARE_READ,
                                    NULL,
                                    CREATE_ALWAYS,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL);

        if (hFileUnsigned != INVALID_HANDLE_VALUE) {

            SetFilePointer(hFileUnsigned, 0, NULL, FILE_BEGIN);
            SetEndOfFile(hFileUnsigned);
        }

        MyGetWindowsDirectory(szBuffer, MAX_PATH);
        szBuffer[3] = 0;
        lstrcat(szBuffer, TEXT("UNSCANNED.TXT"));

        hFileUnscanned = CreateFile( szBuffer, 
                                     GENERIC_READ | GENERIC_WRITE,
                                     FILE_SHARE_READ,
                                     NULL,
                                     CREATE_ALWAYS,
                                     FILE_ATTRIBUTE_NORMAL,
                                     NULL); 

        if (hFileUnscanned != INVALID_HANDLE_VALUE) {

            SetFilePointer(hFileUnscanned, 0, NULL, FILE_BEGIN);
            SetEndOfFile(hFileUnscanned);
        }

#ifdef UNICODE
        // If we are using UNICODE, then write the 0xFF and 0xFE bytes at the beginning of the file.
        ZeroMemory(szBuffer, sizeof(szBuffer));
        szBuffer[0] = 0xFEFF;

        if (hSigverif != INVALID_HANDLE_VALUE) {

            WriteFile(hSigverif, szBuffer, sizeof(TCHAR), &dwBytesWritten, NULL);
        }

        if (hTotals != INVALID_HANDLE_VALUE) {

            WriteFile(hTotals, szBuffer, sizeof(TCHAR), &dwBytesWritten, NULL);
        }

        if (hFileSigned != INVALID_HANDLE_VALUE) {

            WriteFile(hFileSigned, szBuffer, sizeof(TCHAR), &dwBytesWritten, NULL);
        }

        if (hFileUnsigned != INVALID_HANDLE_VALUE) {

            WriteFile(hFileUnsigned, szBuffer, sizeof(TCHAR), &dwBytesWritten, NULL);
        }

        if (hFileUnscanned != INVALID_HANDLE_VALUE) {

            WriteFile(hFileUnscanned, szBuffer, sizeof(TCHAR), &dwBytesWritten, NULL);
        }
#endif
    }

    //
    // Start looping through each file and update the progress bar if we cross a percentage boundary.
    //
    for (lpFileNode=g_App.lpFileList;lpFileNode && !g_App.bStopScan;lpFileNode=lpFileNode->next,dwCount++) {
        
        // Figure out the current percentage and update if it has increased.
        dwPercent = (dwCount * 100) / g_App.dwFiles;
        
        if (dwPercent > dwCurrent) {
            
            dwCurrent = dwPercent;
            SendMessage(GetDlgItem(g_App.hDlg, IDC_PROGRESS), PBM_SETPOS, (WPARAM) dwCurrent, (LPARAM) 0);
        }

        // Log the current file to hSigverif, in case something bad happens.
        if (g_App.bLogToRoot && hSigverif != INVALID_HANDLE_VALUE) {
            
            MyLoadString(szBuffer2, IDS_STRING_LINEFEED);
            wsprintf(szBuffer, szBuffer2, lpFileNode->lpFileName);

            WriteFile(hSigverif, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);
            FlushFileBuffers(hSigverif);
        }

        //
        // Verify the file node if it hasn't already been scanned.
        //
        if (!lpFileNode->bScanned) {
        
            VerifyFileNode(lpFileNode);
        }

        // In case something went wrong, make sure the version information gets filled in.
        if (!lpFileNode->lpVersion) {
            
            GetFileVersion(lpFileNode);
        }

        if (lpFileNode->bScanned) {
            
            // If the file was signed, increment the g_App.dwSigned or g_App.dwUnsigned counter.
            if (lpFileNode->bSigned) {
                
                g_App.dwSigned++;
                
                if (g_App.bLogToRoot && hFileSigned != INVALID_HANDLE_VALUE) {
                    
                    MyLoadString(szBuffer2, IDS_STRING_LINEFEED);
                    wsprintf(szBuffer, szBuffer2, lpFileNode->lpFileName);

                    WriteFile(hFileSigned, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);
                }

            } else {
                
                g_App.dwUnsigned++;
                
                if (g_App.bLogToRoot && hFileUnsigned != INVALID_HANDLE_VALUE) {
                    
                    if (g_App.bFullSystemScan) {
                        
                        lstrcpy(szBuffer, lpFileNode->lpDirName);
                        if (*(szBuffer + lstrlen(szBuffer) - 1) != TEXT('\\'))
                            lstrcat(szBuffer, TEXT("\\"));
                        lstrcat(szBuffer, lpFileNode->lpFileName);
                        WriteFile(hFileUnsigned, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);

                        MyLoadString(szBuffer, IDS_LINEFEED);
                        WriteFile(hFileUnsigned, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);
                    
                    } else {
                        
                        MyLoadString(szBuffer2, IDS_STRING_LINEFEED);
                        wsprintf(szBuffer, szBuffer2, lpFileNode->lpFileName);
                        WriteFile(hFileUnsigned, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);
                    }
                }
            }
        } else {
            
            if (g_App.bLogToRoot && hFileUnscanned != INVALID_HANDLE_VALUE) {
                
                MyLoadString(szBuffer2, IDS_STRING_LINEFEED);
                wsprintf(szBuffer, szBuffer2, lpFileNode->lpFileName);
                WriteFile(hFileUnscanned, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);
            }
        }
    }

    if (g_App.bLogToRoot) {
        
        // Load the status string and fill it in with the correct values.
        MyLoadString(szBuffer, IDS_NUMFILES);
        wsprintf(szBuffer2, szBuffer,   g_App.dwFiles, g_App.dwSigned, g_App.dwUnsigned, 
                 g_App.dwFiles - g_App.dwSigned - g_App.dwUnsigned);
        
        if (hTotals != INVALID_HANDLE_VALUE) {
        
            WriteFile(hTotals, szBuffer2, lstrlen(szBuffer2) * sizeof(TCHAR), &dwBytesWritten, NULL);
        }
        
        if (hTotals != INVALID_HANDLE_VALUE) {
        
            CloseHandle(hTotals);
        }

        if (hSigverif != INVALID_HANDLE_VALUE) {
        
            CloseHandle(hSigverif);
        }
        
        if (hFileSigned != INVALID_HANDLE_VALUE) {
        
            CloseHandle(hFileSigned);
        }
        
        if (hFileUnsigned != INVALID_HANDLE_VALUE) {
        
            CloseHandle(hFileUnsigned);
        }
        
        if (hFileUnsigned != INVALID_HANDLE_VALUE) {
        
            CloseHandle(hFileUnscanned);
        }
    }

    // If we had an g_App.hCatAdmin, free it and set it to zero so we can acquire a new one in the future.
    if (g_App.hCatAdmin) {
        
        CryptCATAdminReleaseContext(g_App.hCatAdmin,0);
        g_App.hCatAdmin = NULL;
    }

    if (!g_App.bStopScan && !g_App.bFullSystemScan) {
        
        // If the user never clicked STOP, then make sure the progress bar hits 100%
        if (!g_App.bStopScan) {
        
            SendMessage(GetDlgItem(g_App.hDlg, IDC_PROGRESS), PBM_SETPOS, (WPARAM) 100, (LPARAM) 0);
        }

        if (!g_App.dwUnsigned) {
            
            // If there weren't any unsigned files, then we want to tell the user that everything is dandy!
            if (g_App.dwSigned) {
            
                MyMessageBoxId(IDS_ALLSIGNED);
            
            } else {
                
                MyMessageBoxId(IDS_NOPROBLEMS);
            }
        
        } else {
            
            // Show the user the results by going directly to IDD_RESULTS
            DialogBox(g_App.hInstance, MAKEINTRESOURCE(IDD_RESULTS), g_App.hDlg, ListView_DlgProc);
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\sigverif\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by sigverif.rc
//
#define IDS_COL_NAME                    1
#define IDS_COL_FOLDER                  2
#define IDS_COL_SIZE                    3
#define IDS_COL_TYPE                    4
#define IDS_COL_VERSION                 5
#define IDS_COL_SIGNEDBY                6
#define IDS_COL_DATE                    7
#define IDS_KB                          8
#define IDS_NOPROBLEMS                  9
#define IDS_ALLSIGNED                   10
#define IDS_MSGBOX                      11
#define IDS_ERRORBOX                    12
#define IDS_NUMFILES                    13
#define IDS_SIGNED                      14
#define IDS_NOTSIGNED                   15
#define IDS_NOFILES                     16
#define IDS_STOP                        17
#define IDS_START                       18
#define IDS_ALL                         19
#define IDS_EXE                         20
#define IDS_SYS                         21
#define IDS_OCX                         22
#define IDS_DLL                         23
#define IDS_DRV                         24
#define IDS_BADDIR                      25
#define IDS_FILENOTINSTALLED            26
#define IDS_SELECTDIR                   29
#define IDS_SCANSTOPPED                 30
#define IDS_NOVERSION                   31
#define IDS_LOGNAME                     32
#define IDS_BADLOGNAME                  33
#define IDS_CANTOPENLOGFILE             34
#define IDS_LOGHEADER1                  35
#define IDS_LOGHEADER2                  36
#define IDS_LOGHEADER3                  37
#define IDS_LOGHEADER4                  38
#define IDS_LOGHEADER5                  39
#define IDS_LOGHEADER6                  40
#define IDS_LOGHEADER7                  41
#define IDS_DIR                         42
#define IDS_VERSION                     43
#define IDS_STRING                      44
#define IDS_OSPLATFORM                  45
#define IDS_OSVERSION                   46
#define IDS_WINNT                       47
#define IDS_WIN9X                       48
#define IDS_WIN3X                       49
#define IDS_UNKNOWN                     50
#define IDS_NA                          51
#define IDS_LINEFEED                    52
#define IDS_SPACES                      53
#define IDS_FILETYPE                    54
#define IDS_FILE                        55
#define IDS_BLYSAK                      58
#define IDS_NOSYSTEMFILES               59
#define IDS_COPYFILES                   65
#define IDS_MASTERFILELIST              68
#define IDS_LOGHEADER8                  69
#define IDS_STRING_LINEFEED             70
#define IDS_TOTALS                      73
#define IDS_BVT                         74
#define IDS_SIGVERIF                    76
#define IDS_NODEV                       77
#define IDS_NOPRN                       78
#define IDS_NOBVT                       79
#define IDS_STRING2                     80
#define IDS_STATUS_BUILD                83
#define IDS_STATUS_FREE                 84
#define IDS_STATUS_LOG                  85
#define IDS_STATUS_SCAN                 86
#define IDS_ADVANCED_SETTINGS           87
#define IDS_SEARCHTAB                   88
#define IDS_LOGGINGTAB                  89
#define IDS_X86                         90
#define IDS_MIPS                        91
#define IDS_ALPHA                       92
#define IDS_PPC                         93
#define IDS_REG_PRODUCTOPTIONS          94
#define IDS_REG_PRODUCTTYPE             95
#define IDS_PRODUCT_SERVER              96
#define IDS_SERVERFILELIST              97
#define IDS_FULLSCAN                    98
#define IDS_DEFSCAN                     99
#define IDS_X86FILELIST                 100
#define IDD_DIALOG                      101
#define IDI_ICON1                       102
#define IDB_BITMAP1                     102
#define IDD_DETAILS                     103
#define IDD_RESULTS                     104
#define IDD_SETTINGS                    105
#define IDD_ADVANCED                    106
#define IDD_SEARCH                      107
#define ID_VIEWLOG                      1000
#define IDC_BITMAP                      1000
#define IDC_FOLDER                      1001
#define IDC_TEXT                        1001
#define IDC_SCAN                        1002
#define IDC_NOTMS                       1003
#define IDC_SUBFOLDERS                  1004
#define ID_CLOSE                        1005
#define ID_START                        1006
#define ID_BROWSE                       1007
#define IDC_PROGRESS                    1008
#define IDC_LISTVIEW                    1009
#define IDC_STATUSWINDOW                1010
#define ID_SETTINGS                     1011
#define ID_ADVANCED                     1011
#define IDC_TYPE                        1013
#define IDC_FREELIST                    1014
#define ID_DETAILS_OK                   1015
#define ID_DETAILS                      1016
#define IDC_RESULTSTEXT                 1017
#define IDC_LOGNAME                     1018
#define IDC_OVERWRITE                   1019
#define IDC_APPEND                      1020
#define IDC_ENABLELOG                   1021
#define IDC_VIEWLOG                     1022
#define IDC_TAB1                        1023
#define IDC_STATUS                      1024
#define IDC_INFOTEXT                    1025

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

//
// Version Information
//
#include <winver.h>
#include <ntverp.h>
#define VER_FILETYPE                    VFT_APP
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "File Signature Verification"
#define VER_INTERNALNAME_STR            "sigverif.exe"
#define VER_ORIGINALFILENAME_STR        "sigverif.exe"
#include "common.ver"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\sigverif\walkpath.c ===
//
// WALKPATH.C
//
#include "sigverif.h"

LPDIRNODE   g_lpDirList = NULL;
LPDIRNODE   g_lpDirEnd  = NULL;
BOOL        g_bRecurse  = TRUE;

//
// This function takes a directory name and a search pattern and looks for all files mathching the pattern.
// If bRecurse is set, then it will add subdirectories to the end of the g_lpDirList for subsequent traversal.
// 
// In this routine we allocate and fill in some of the lpFileNode values that we know about.
//
void FindFile(DIRNODE *lpDir, TCHAR *lpDirName, TCHAR *lpFileName)
{
    DWORD           dwRet;
    BOOL            bOk = TRUE;
    HANDLE          hFind;
    LPFILENODE      lpFileNode;
    LPDIRNODE       lpDirNode;
    WIN32_FIND_DATA FindFileData;

    // If the user clicked STOP, then bail immediately!
    // If the directory is bogus, then skip to the next one.
    if (!g_App.bStopScan && SetCurrentDirectory(lpDirName)) {
        
        // If the user wants to look in subdirectories, then we need to find everything in the current directory
        // and if it's a directory we want to add it to the end of the g_lpDirList.
        if (g_bRecurse) {
            
            hFind = FindFirstFile(TEXT("*.*"), &FindFileData);
            
            if (hFind != INVALID_HANDLE_VALUE) {
                
                bOk = TRUE;
                while (bOk && !g_App.bStopScan) {
                    
                    if (lstrcmp(FindFileData.cFileName, TEXT(".")) &&
                        lstrcmp(FindFileData.cFileName, TEXT("..")) &&
                        (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {

                        lpDirNode = (LPDIRNODE) MALLOC(sizeof(DIRNODE));

                        if (lpDirNode) {

                            dwRet = GetFullPathName(FindFileData.cFileName, MAX_PATH, lpDirNode->DirName, 0);
                            if (!dwRet || dwRet >= MAX_PATH) {
                                GetShortPathName(lpDirName, lpDirNode->DirName, MAX_PATH);
                                GetFullPathName(FindFileData.cFileName, MAX_PATH, lpDirNode->DirName, 0);
                                SetCurrentDirectory(lpDirName);
                            }
                        }

                        g_lpDirEnd->next  = lpDirNode;
                        g_lpDirEnd        = lpDirNode;
                    }
                    
                    bOk = FindNextFile(hFind, &FindFileData);
                }

                FindClose(hFind);
            }
        }

        // We have added any subdirectories to the dir list, so now we can actually look for
        // the lpFileName search pattern and start adding to the g_App.lpFileList.
        hFind = FindFirstFile(lpFileName, &FindFileData);
        if (hFind != INVALID_HANDLE_VALUE) {
            
            bOk = TRUE;

            // While there are more files to be found, keep looking in the directory...
            while (bOk && !g_App.bStopScan) {
                
                if (lstrcmp(FindFileData.cFileName, TEXT(".")) &&
                    lstrcmp(FindFileData.cFileName, TEXT("..")) &&
                    !(FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
                    
                    //
                    // Allocate an lpFileNode, fill it in, and add it to the end of g_App.lpFileList
                    //
                    // We need to call CharLowerBuff on the file and dir names because
                    // the catalog files all contain lower-case names for the files.
                    //
                    lpFileNode = CreateFileNode(lpDirName, FindFileData.cFileName);

                    if (lpFileNode) {
                        
                        if (!g_App.lpFileList)
                            g_App.lpFileList = lpFileNode;
                        else g_App.lpFileLast->next = lpFileNode;
                        g_App.lpFileLast = lpFileNode;

                        // Increment the total number of files we've found that meet the search criteria.
                        g_App.dwFiles++;
                    }
                }

                // Get the next file meeting the search pattern.
                bOk = FindNextFile(hFind, &FindFileData);
            }

            FindClose(hFind);
        }
    }

    // Free the memory allocated in the directory node.
    lpDir       = g_lpDirList;
    g_lpDirList = g_lpDirList->next;
    FREE(lpDir);
}

//
// Build an g_App.lpFileList given the user settings in the main dialog.
//
void BuildFileList(LPTSTR lpPathName)
{
    TCHAR       FileName[MAX_PATH];
    TCHAR       Extension[MAX_PATH];
    LPTSTR      lpFileName = FileName;
    LPTSTR      lpExtension = Extension;
    LPDIRNODE   lpDirNode;

    // Check if this is a valid starting directory.
    // If not, then pop up an error message.
    if (!SetCurrentDirectory(lpPathName)) {
        MyErrorBoxId(IDS_BADDIR);
        return;
    }

    // If the "Include Subdirectories" is checked, then bRecurse is TRUE.
    if (g_App.bSubFolders)
        g_bRecurse = TRUE;
    else g_bRecurse = FALSE;

    // Get the search pattern from the resource or the user-specified string
    if (g_App.bUserScan)
        lstrcpy(lpFileName, g_App.szScanPattern);
    else MyLoadString(lpFileName, IDS_ALL);

    // Allocate the first entry in the g_lpDirList and set it to the
    // current directory.
    lpDirNode       = (LPDIRNODE) MALLOC(sizeof(DIRNODE));

    if (lpDirNode) {
        lstrcpy(lpDirNode->DirName, lpPathName);
        lpDirNode->next = NULL;
    }

    g_lpDirList     = lpDirNode;
    g_lpDirEnd      = lpDirNode;

    // Process the g_lpDirList as long as the user doesn't click STOP!
    while (g_lpDirList && !g_App.bStopScan)
        FindFile(g_lpDirList, g_lpDirList->DirName, lpFileName);

    // Make sure all the memory allocated to the g_lpDirList is freed.
    while (g_lpDirList) {
        lpDirNode = g_lpDirList->next;  
        FREE(g_lpDirList);
        g_lpDirList = lpDirNode;
    }

    // If there weren't any files found, then let the user know about it.
    if (!g_App.lpFileList)
        MyMessageBoxId(IDS_NOFILES);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\sigverif\sigtab\sigtab.h ===
//---------------------------------------------------------------------------
//
//  File: sigtab.h
//
//  General definition of OLE Entry points, CClassFactory and CPropSheetExt
//
//  Common Code for all display property sheet extension
//
//  Copyright (c) Microsoft Corp.  1992-1998 All Rights Reserved
//
//---------------------------------------------------------------------------
#include <windows.h>
#include <windowsx.h>
#include <shlobj.h>
#include <shellapi.h>
#include <initguid.h>
#include <ole2.h>
#include <regstr.h>
#include "resource.h"
#define IDC_STATIC      (-1)

/*
    For driver signing, there are actually 3 sources of policy:

        1.  HKLM\Software\Microsoft\Driver Signing : Policy : REG_BINARY (REG_DWORD also supported)
            This is a Windows 98-compatible value that specifies the default
            behavior which applies to all users of the machine.

        2.  HKCU\Software\Microsoft\Driver Signing : Policy : REG_DWORD
            This specifies the user's preference for what behavior to employ
            upon verification failure.

        3.  HKCU\Software\Policies\Microsoft\Windows NT\Driver Signing : BehaviorOnFailedVerify : REG_DWORD
            This specifies the administrator-mandated policy on what behavior
            to employ upon verification failure.  This policy, if specified,
            overrides the user's preference.

    The algorithm for deciding on the behavior to employ is as follows:

        if (3) is specified {
            policy = (3)
        } else {
            policy = (2)
        }
        policy = MAX(policy, (1))

    Value indicating the policy in effect.  May be one of the following three values:

        DRIVERSIGN_NONE    -  silently succeed installation of unsigned/
                              incorrectly-signed files.  A PSS log entry will
                              be generated, however (as it will for all 3 types)
        DRIVERSIGN_WARNING -  warn the user, but let them choose whether or not
                              they still want to install the problematic file
        DRIVERSIGN_BLOCKING - do not allow the file to be installed
*/

#define SIGTAB_REG_KEY      TEXT("Software\\Microsoft\\Driver Signing")
#define SIGTAB_REG_VALUE    TEXT("Policy")

//
// Context-Sensitive Help/Identifiers specific to SigVerif
//
#define SIGTAB_HELPFILE                         TEXT("SYSDM.HLP")
#define IDH_CODESIGN_IGNORE                     11020
#define IDH_CODESIGN_WARN                       11021
#define IDH_CODESIGN_BLOCK                      11022
#define IDH_CODESIGN_APPLY                      11023

INT_PTR CALLBACK SigTab_DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK SigTab_PS_DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

extern "C" {
VOID
pSetupGetRealSystemTime(
    OUT LPSYSTEMTIME RealSystemTime
    );
}

//Type for an object-destroyed callback
typedef void (FAR PASCAL *LPFNDESTROYED)(void);

class CClassFactory : public IClassFactory
{
protected:
        ULONG m_cRef;

public:
        CClassFactory();
        ~CClassFactory();

        //IUnknown members
        STDMETHODIMP         QueryInterface( REFIID, LPVOID* );
        STDMETHODIMP_(ULONG) AddRef();
        STDMETHODIMP_(ULONG) Release();

        //IClassFactory members
        STDMETHODIMP         CreateInstance( LPUNKNOWN, REFIID, LPVOID* );
        STDMETHODIMP         LockServer( BOOL );
};

class CPropSheetExt : public IShellPropSheetExt, IShellExtInit
{
private:
        ULONG         m_cRef;
        LPUNKNOWN     m_pUnkOuter;    //Controlling unknown
        LPFNDESTROYED m_pfnDestroy;   //Function closure call

public:
        CPropSheetExt( LPUNKNOWN pUnkOuter, LPFNDESTROYED pfnDestroy );
        ~CPropSheetExt(void);

        // IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //  IShellExtInit methods
        STDMETHODIMP         Initialize(LPCITEMIDLIST pIDFolder, LPDATAOBJECT pDataObj,
                                        HKEY hKeyID);

        //IShellPropSheetExt methods ***
        STDMETHODIMP         AddPages( LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam );
        STDMETHODIMP         ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith,
                                         LPARAM lParam);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\sigverif\sigtab\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by sigtab.rc
//
#define IDS_PAGE_TITLE                  1
#define IDD_SIGTAB_PS                   101
#define IDD_SIGTAB                      102
#define IDC_ALL                         1000
#define IDC_IGNORE                      1000
#define IDC_PROMPT                      1001
#define IDC_WARN                        1001
#define IDC_RADIO3                      1002
#define IDC_BLOCK                       1002
#define IDC_GLOBAL                      1003
#define IDG_ADMIN                       1004
#define IDC_LINK                        1005

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1007
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

//
// Version Information
//
#include <winver.h>
#include <ntverp.h>
#define VER_FILETYPE                    VFT_APP
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "File Integrity Settings"
#define VER_INTERNALNAME_STR            "sigtab.dll"
#define VER_ORIGINALFILENAME_STR        "sigtab.dll"
#include "common.ver"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\sort\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

TARGETNAME=sort
TARGETPATH=obj
TARGETTYPE=PROGRAM

SOURCES=..\sort.c ..\sort.rc ..\sortmsg.mc

PASS0_HEADERDIR=$(O)
PASS0_SOURCEDIR=$(O)
INCLUDES=$(O)

USE_MSVCRT=1

USE_MFC=1

UMTYPE=console
UMENTRY=main
TARGETLIBS=\
        $(SDK_LIB_PATH)\user32.lib \
        $(SDK_LIB_PATH)\ntdll.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\sort\usa\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.plt

sortmsg.h sortmsg.rc msg00001.bin: ..\sortmsg.mc
    mc -v ..\sortmsg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\sigverif\sigtab\sigtab.cpp ===
//--------------------------------------------------------------------------------
//
//  File:   sigtab.cpp
//
//  General handling of OLE Entry points, CClassFactory and CPropSheetExt
//
//  Common Code for all display property sheet extension
//
//  Copyright (c) Microsoft Corp.  1992-1998 All Rights Reserved
//
//--------------------------------------------------------------------------------
#include "sigtab.h"

//---------------------------------------------------------------------------
// Globals
//---------------------------------------------------------------------------

//
// Count number of objects and number of locks.
//
HINSTANCE    g_hInst            = NULL;
LPDATAOBJECT g_lpdoTarget       = NULL;

ULONG        g_cObj             = 0;
ULONG        g_cLock            = 0;

DEFINE_GUID(g_CLSID_SigTab,     /* 95b2ac50-840c-11d2-aeaf-0020afe7266d */
            0x95b2ac50,0x840c,0x11d2,0xae,0xaf,0x00,0x20,0xaf,0xe7,0x26,0x6d);

//---------------------------------------------------------------------------
// DllMain()
//---------------------------------------------------------------------------
int APIENTRY DllMain( HINSTANCE hInstance, DWORD dwReason, LPVOID )
{
    if ( dwReason == DLL_PROCESS_ATTACH ) {        // Initializing
        g_hInst = hInstance;

        DisableThreadLibraryCalls(hInstance);
    }

    return 1;
}
//---------------------------------------------------------------------------
//      DllGetClassObject()
//
//      If someone calls with our CLSID, create an IClassFactory and pass it to
//      them, so they can create and use one of our CPropSheetExt objects.
//
//---------------------------------------------------------------------------
STDAPI DllGetClassObject( REFCLSID rclsid, REFIID riid, LPVOID* ppvOut )
{
    *ppvOut = NULL; // Assume Failure
    if ( IsEqualCLSID( rclsid, g_CLSID_SigTab ) ) {
        //
        //Check that we can provide the interface
        //
        if ( IsEqualIID( riid, IID_IUnknown) ||
             IsEqualIID( riid, IID_IClassFactory )
           ) {
            //Return our IClassFactory for CPropSheetExt objects
            *ppvOut = (LPVOID* )new CClassFactory();
            if ( NULL != *ppvOut ) {
                //AddRef the object through any interface we return
                ((CClassFactory*)*ppvOut)->AddRef();
                return NOERROR;
            }
            return E_OUTOFMEMORY;
        }
        return E_NOINTERFACE;
    } else {
        return CLASS_E_CLASSNOTAVAILABLE;
    }
}

//---------------------------------------------------------------------------
//      DllCanUnloadNow()
//
//      If we are not locked, and no objects are active, then we can exit.
//
//---------------------------------------------------------------------------
STDAPI DllCanUnloadNow()
{
    SCODE   sc;

    //
    //Our answer is whether there are any object or locks
    //
    sc = (0L == g_cObj && 0 == g_cLock) ? S_OK : S_FALSE;

    return ResultFromScode(sc);
}

//---------------------------------------------------------------------------
//      ObjectDestroyed()
//
//      Function for the CPropSheetExt object to call when it is destroyed.
//      Because we're in a DLL, we only track the number of objects here,
//      letting DllCanUnloadNow take care of the rest.
//---------------------------------------------------------------------------
void FAR PASCAL ObjectDestroyed( void )
{
    g_cObj--;
    return;
}

UINT CALLBACK
PropSheetCallback(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp)
{
    switch (uMsg) {
    case PSPCB_CREATE:
        return TRUE;    // return TRUE to continue with creation of page

    case PSPCB_RELEASE:
        if (g_lpdoTarget) {
            g_lpdoTarget->Release();
            g_lpdoTarget = NULL;
        }
        return 0;       // return value ignored

    default:
        break;
    }

    return TRUE;
}



//***************************************************************************
//
//  CClassFactory Class
//
//***************************************************************************



//---------------------------------------------------------------------------
//      Constructor
//---------------------------------------------------------------------------
CClassFactory::CClassFactory()
{
    m_cRef = 0L;
    return;
}

//---------------------------------------------------------------------------
//      Destructor
//---------------------------------------------------------------------------
CClassFactory::~CClassFactory( void )
{
    return;
}

//---------------------------------------------------------------------------
//      QueryInterface()
//---------------------------------------------------------------------------
STDMETHODIMP CClassFactory::QueryInterface( REFIID riid, LPVOID* ppv )
{
    *ppv = NULL;

    //Any interface on this object is the object pointer.
    if ( IsEqualIID( riid, IID_IUnknown ) ||
         IsEqualIID( riid, IID_IClassFactory )
       ) {
        *ppv = (LPVOID)this;
        ++m_cRef;
        return NOERROR;
    }

    return E_NOINTERFACE;
}

//---------------------------------------------------------------------------
//      AddRef()
//---------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    return ++m_cRef;
}

//---------------------------------------------------------------------------
//      Release()
//---------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    ULONG cRefT;

    cRefT = --m_cRef;

    if ( 0L == m_cRef )
        delete this;

    return cRefT;
}

//---------------------------------------------------------------------------
//      CreateInstance()
//---------------------------------------------------------------------------
STDMETHODIMP
CClassFactory::CreateInstance( LPUNKNOWN pUnkOuter,
                               REFIID riid,
                               LPVOID FAR *ppvObj
                             )
{
    CPropSheetExt*  pObj;
    HRESULT         hr = E_OUTOFMEMORY;

    *ppvObj = NULL;

    // We don't support aggregation at all.
    if ( pUnkOuter ) {
        return CLASS_E_NOAGGREGATION;
    }

    //Verify that a controlling unknown asks for IShellPropSheetExt
    if ( IsEqualIID( riid, IID_IShellPropSheetExt ) ) {
        //Create the object, passing function to notify on destruction
        pObj = new CPropSheetExt( pUnkOuter, ObjectDestroyed );

        if ( NULL == pObj ) {
            return hr;
        }

        hr = pObj->QueryInterface( riid, ppvObj );

        //Kill the object if initial creation or FInit failed.
        if ( FAILED(hr) ) {
            delete pObj;
        } else {
            g_cObj++;
        }
        return hr;
    }

    return E_NOINTERFACE;
}

//---------------------------------------------------------------------------
//      LockServer()
//---------------------------------------------------------------------------
STDMETHODIMP CClassFactory::LockServer( BOOL fLock )
{
    if ( fLock ) {
        g_cLock++;
    } else {
        g_cLock--;
    }
    return NOERROR;
}



//***************************************************************************
//
//  CPropSheetExt Class
//
//***************************************************************************



//---------------------------------------------------------------------------
//  Constructor
//---------------------------------------------------------------------------
CPropSheetExt::CPropSheetExt( LPUNKNOWN pUnkOuter, LPFNDESTROYED pfnDestroy )
{
    m_cRef = 0;
    m_pUnkOuter = pUnkOuter;
    m_pfnDestroy = pfnDestroy;
    return;
}

//---------------------------------------------------------------------------
//  Destructor
//---------------------------------------------------------------------------
CPropSheetExt::~CPropSheetExt( void )
{
    return;
}

//---------------------------------------------------------------------------
//  QueryInterface()
//---------------------------------------------------------------------------
STDMETHODIMP CPropSheetExt::QueryInterface( REFIID riid, LPVOID* ppv )
{
    *ppv = NULL;

    if (IsEqualIID(riid, IID_IShellExtInit)) {
        *ppv = (IShellExtInit *) this;
    }

    if (IsEqualIID(riid, IID_IShellPropSheetExt)) {
        *ppv = (LPVOID)this;
    }

    if (*ppv) {
        ++m_cRef;
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

//---------------------------------------------------------------------------
//  AddRef()
//---------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPropSheetExt::AddRef( void )
{
    return ++m_cRef;
}

//---------------------------------------------------------------------------
//  Release()
//---------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPropSheetExt::Release( void )
{
    ULONG cRefT;

    cRefT = --m_cRef;

    if ( m_cRef == 0 ) {
        // Tell the housing that an object is going away so that it
        // can shut down if appropriate.
        if ( NULL != m_pfnDestroy ) {
            (*m_pfnDestroy)();
        }
        delete this;
    }
    return cRefT;
}

//---------------------------------------------------------------------------
//  AddPages()
//---------------------------------------------------------------------------
STDMETHODIMP CPropSheetExt::AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam )
{
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hpage;

    psp.dwSize      = sizeof(PROPSHEETPAGE);
    psp.dwFlags     = PSP_USECALLBACK;
    psp.hIcon       = NULL;
    psp.hInstance   = g_hInst;
    psp.pszTemplate = MAKEINTRESOURCE( IDD_SIGTAB_PS );
    psp.pfnDlgProc  = (DLGPROC) SigTab_PS_DlgProc;
    psp.pfnCallback = NULL;
    psp.lParam      = 0;

    if ( ( hpage = CreatePropertySheetPage( &psp ) ) == NULL ) {
        return( E_OUTOFMEMORY );
    }

    if ( !lpfnAddPage(hpage, lParam ) ) {
        DestroyPropertySheetPage(hpage );
        return( E_FAIL );
    }
    return NOERROR;
}

//---------------------------------------------------------------------------
//  ReplacePage()
//---------------------------------------------------------------------------
STDMETHODIMP CPropSheetExt::ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam )
{
    return NOERROR;
}


//---------------------------------------------------------------------------
//  IShellExtInit member function- this interface needs only one
//---------------------------------------------------------------------------

STDMETHODIMP CPropSheetExt::Initialize(LPCITEMIDLIST pcidlFolder,
                                       LPDATAOBJECT pdoTarget,
                                       HKEY hKeyID)
{
    //
    //  The target data object is an HDROP, or list of files from the shell.
    //

    if (g_lpdoTarget) {
        g_lpdoTarget->Release();
        g_lpdoTarget = NULL;
    }

    if (pdoTarget) {
        g_lpdoTarget = pdoTarget;
        g_lpdoTarget->AddRef();
    }

    return  NOERROR;
}

BOOL
IsUserAdmin(
           VOID
           )

/*++

Routine Description:

    This routine returns TRUE if the caller's process is a
    member of the Administrators local group.

    Caller is NOT expected to be impersonating anyone and IS
    expected to be able to open their own process and process
    token.

Arguments:

    None.

Return Value:

    TRUE - Caller has Administrators local group.

    FALSE - Caller does not have Administrators local group.

--*/

{
    BOOL b;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID AdministratorsGroup;

    b = AllocateAndInitializeSid(&NtAuthority,
                                 2,
                                 SECURITY_BUILTIN_DOMAIN_RID,
                                 DOMAIN_ALIAS_RID_ADMINS,
                                 0,
                                 0,
                                 0,
                                 0,
                                 0,
                                 0,
                                 &AdministratorsGroup
                                );

    if (b) {

        if (!CheckTokenMembership(NULL,
                                  AdministratorsGroup,
                                  &b
                                 )) {
            b = FALSE;
        }

        FreeSid(AdministratorsGroup);
    }

    return(b);
}

void GetCurrentDriverSigningPolicy( LPDWORD lpdwDefault, LPDWORD lpdwPolicy, LPDWORD lpdwPreference )
{
    SYSTEMTIME RealSystemTime;
    DWORD dwSize, dwType;
    DWORD dwDefault, dwPolicy, dwPreference;
    HKEY hKey;
    CONST TCHAR pszDrvSignPath[]                     = REGSTR_PATH_DRIVERSIGN;
    CONST TCHAR pszDrvSignPolicyPath[]               = REGSTR_PATH_DRIVERSIGN_POLICY;
    CONST TCHAR pszDrvSignPolicyValue[]              = REGSTR_VAL_POLICY;
    CONST TCHAR pszDrvSignBehaviorOnFailedVerifyDS[] = REGSTR_VAL_BEHAVIOR_ON_FAILED_VERIFY;

    dwPolicy = dwPreference = (DWORD) -1;

    RealSystemTime.wDayOfWeek = LOWORD(&hKey) | 4;
    pSetupGetRealSystemTime(&RealSystemTime);
    dwDefault = (((RealSystemTime.wMilliseconds+2)&15)^8)/4;

    //
    // Retrieve the user policy.
    //
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER,
                                      pszDrvSignPolicyPath,
                                      0,
                                      KEY_READ,
                                      &hKey)) {
        dwSize = sizeof(dwPolicy);
        if (ERROR_SUCCESS == RegQueryValueEx(hKey,
                                             pszDrvSignBehaviorOnFailedVerifyDS,
                                             NULL,
                                             &dwType,
                                             (PBYTE)&dwPolicy,
                                             &dwSize)) {
            //
            // Finally, make sure a valid policy value was specified.
            //
            if ((dwType != REG_DWORD) ||
                (dwSize != sizeof(DWORD)) ||
                !((dwPolicy == DRIVERSIGN_NONE) || (dwPolicy == DRIVERSIGN_WARNING) || (dwPolicy == DRIVERSIGN_BLOCKING))) {
                //
                // Bogus entry for user policy--ignore it.
                //
                dwPolicy = DRIVERSIGN_NONE;
            }
        }

        RegCloseKey(hKey);
    }

    //
    // Finally, retrieve the user preference.
    //
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER,
                                      pszDrvSignPath,
                                      0,
                                      KEY_READ,
                                      &hKey)) {
        dwSize = sizeof(dwPreference);
        if (ERROR_SUCCESS == RegQueryValueEx(hKey,
                                             pszDrvSignPolicyValue,
                                             NULL,
                                             &dwType,
                                             (PBYTE)&dwPreference,
                                             &dwSize)) {
            if ((dwType != REG_DWORD) ||
                (dwSize != sizeof(DWORD)) ||
                !((dwPreference == DRIVERSIGN_NONE) || (dwPreference == DRIVERSIGN_WARNING) || (dwPreference == DRIVERSIGN_BLOCKING))) {
                //
                // Bogus entry for user preference--ignore it.
                //
                dwPreference = DRIVERSIGN_NONE;
            }
        }

        RegCloseKey(hKey);
    }

    //
    // Store the values into the user buffer.
    //
    *lpdwDefault    = dwDefault;
    *lpdwPolicy     = dwPolicy;
    *lpdwPreference = dwPreference;
}

DWORD SigTab_UpdateDialog(HWND hwnd)
{
    DWORD   dwPreference = DRIVERSIGN_NONE;
    DWORD   dwDefault = DRIVERSIGN_NONE;
    DWORD   dwPolicy = DRIVERSIGN_NONE;
    DWORD   dwRet;
    DWORD   dwCurSel;

    //
    // Get the current policy settings from the registry.
    //
    GetCurrentDriverSigningPolicy(&dwDefault, &dwPolicy, &dwPreference);

    //
    // If there is no preference, set it to the policy or the default.
    //
    if (dwPreference == (DWORD) -1) {
        if (dwPolicy != (DWORD) -1)
            dwPreference = dwPolicy;
        else dwPreference = dwDefault;
    }

    //
    // Figure out which item is really selected and re-select it.  This will get rid of any checked && disabled items.
    //
    dwCurSel = dwPreference;
    if (IsDlgButtonChecked(hwnd, IDC_IGNORE) && IsWindowEnabled(GetDlgItem(hwnd, IDC_IGNORE)))
        dwCurSel = IDC_IGNORE;
    if (IsDlgButtonChecked(hwnd, IDC_WARN) && IsWindowEnabled(GetDlgItem(hwnd, IDC_WARN)))
        dwCurSel = IDC_WARN;
    if (IsDlgButtonChecked(hwnd, IDC_BLOCK) && IsWindowEnabled(GetDlgItem(hwnd, IDC_BLOCK)))
        dwCurSel = IDC_BLOCK;
    EnableWindow(GetDlgItem(hwnd, IDC_IGNORE), TRUE);
    EnableWindow(GetDlgItem(hwnd, IDC_WARN), TRUE);
    EnableWindow(GetDlgItem(hwnd, IDC_BLOCK), TRUE);
    CheckRadioButton(hwnd, IDC_IGNORE, IDC_BLOCK, dwCurSel);

    //
    // If there is a policy for this user, it overrides any preferences so grey everything but the policy setting.
    //
    if (dwPolicy != (DWORD) -1) {
        //
        // If the system default is stronger, it will be used instead.
        //
        if (dwDefault > dwPolicy)
            dwPolicy = dwDefault;

        EnableWindow(GetDlgItem(hwnd, IDC_IGNORE), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_WARN), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_BLOCK), FALSE);
        switch (dwPolicy) {
        case DRIVERSIGN_WARNING:    EnableWindow(GetDlgItem(hwnd, IDC_WARN), TRUE);
            CheckRadioButton(hwnd, IDC_IGNORE, IDC_BLOCK, IDC_WARN);
            break;

        case DRIVERSIGN_BLOCKING:   EnableWindow(GetDlgItem(hwnd, IDC_BLOCK), TRUE);
            CheckRadioButton(hwnd, IDC_IGNORE, IDC_BLOCK, IDC_BLOCK);
            break;

        default:                    EnableWindow(GetDlgItem(hwnd, IDC_IGNORE), TRUE);
            CheckRadioButton(hwnd, IDC_IGNORE, IDC_BLOCK, IDC_IGNORE);
            break;
        }

        dwPreference = dwPolicy;        
    } else {
        //
        // Grey out the items being over-ridden by the systen policy.  Bump the selection down to the first available slot.
        //
        switch (dwDefault) {
        case DRIVERSIGN_BLOCKING:   if (IsDlgButtonChecked(hwnd, IDC_WARN) || IsDlgButtonChecked(hwnd, IDC_IGNORE))
                CheckRadioButton(hwnd, IDC_IGNORE, IDC_BLOCK, IDC_BLOCK);
            EnableWindow(GetDlgItem(hwnd, IDC_IGNORE), FALSE);
            EnableWindow(GetDlgItem(hwnd, IDC_WARN), FALSE);
            break;

        case DRIVERSIGN_WARNING:    if (IsDlgButtonChecked(hwnd, IDC_IGNORE))
                CheckRadioButton(hwnd, IDC_IGNORE, IDC_BLOCK, IDC_WARN);
            EnableWindow(GetDlgItem(hwnd, IDC_IGNORE), FALSE);
            break;
        }

        //
        // If the system default is stronger, it will be used instead.
        //
        if (dwDefault > dwPreference)
            dwPreference = dwDefault;
    }

    if (IsUserAdmin()) {
        //
        // If the administrator can set the default, make everything available for selection.
        //
        if (IsDlgButtonChecked(hwnd, IDC_GLOBAL)) {
            EnableWindow(GetDlgItem(hwnd, IDC_IGNORE), TRUE);
            EnableWindow(GetDlgItem(hwnd, IDC_WARN), TRUE);
            EnableWindow(GetDlgItem(hwnd, IDC_BLOCK), TRUE);
        }
    }

    return dwPreference;
}

//
//  Initialization of search dialog.
//
BOOL SigTab_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    DWORD   dwPreference = DRIVERSIGN_NONE;
    DWORD   dwDefault = DRIVERSIGN_NONE;
    DWORD   dwPolicy = DRIVERSIGN_NONE;
    BOOL    bAdmin;

    ShowWindow(hwnd, SW_SHOW);

    CheckRadioButton(hwnd, IDC_IGNORE, IDC_BLOCK, IDC_IGNORE);
    CheckDlgButton(hwnd, IDC_GLOBAL, BST_UNCHECKED);

    bAdmin = IsUserAdmin();
    ShowWindow(GetDlgItem(hwnd, IDC_GLOBAL), bAdmin ? SW_SHOW : SW_HIDE);
    ShowWindow(GetDlgItem(hwnd, IDG_ADMIN), bAdmin ? SW_SHOW : SW_HIDE);

    GetCurrentDriverSigningPolicy(&dwDefault, &dwPolicy, &dwPreference);

    //
    // Call SigTab_UpdateDialog to initialize the dialog
    //
    dwPreference = SigTab_UpdateDialog(hwnd);

    //
    // Check the radio button for their calculated "preference".
    //
    switch (dwPreference) {
    case DRIVERSIGN_WARNING:    CheckRadioButton(hwnd, IDC_IGNORE, IDC_BLOCK, IDC_WARN);
        break;
    case DRIVERSIGN_BLOCKING:   CheckRadioButton(hwnd, IDC_IGNORE, IDC_BLOCK, IDC_BLOCK);
        break;
    }

    //
    // If the user is an administrator, check the "Global" box if the preference matches the default setting.
    //
    if (bAdmin) {
        switch (dwDefault) {
        case DRIVERSIGN_WARNING:    if (IsDlgButtonChecked(hwnd, IDC_WARN))
                CheckDlgButton(hwnd, IDC_GLOBAL, BST_CHECKED);
            break;

        case DRIVERSIGN_BLOCKING:   if (IsDlgButtonChecked(hwnd, IDC_BLOCK))
                CheckDlgButton(hwnd, IDC_GLOBAL, BST_CHECKED);
            break;

        case DRIVERSIGN_NONE:       if (IsDlgButtonChecked(hwnd, IDC_IGNORE))
                CheckDlgButton(hwnd, IDC_GLOBAL, BST_CHECKED);
            break;
        }

        //
        // If the administrator can set the default, make everything available for selection.
        //
        if (IsDlgButtonChecked(hwnd, IDC_GLOBAL)) {
            EnableWindow(GetDlgItem(hwnd, IDC_IGNORE), TRUE);
            EnableWindow(GetDlgItem(hwnd, IDC_WARN), TRUE);
            EnableWindow(GetDlgItem(hwnd, IDC_BLOCK), TRUE);
        }
    }

    return TRUE;
}

void SigTab_Help(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL bContext)
{
    static DWORD SigTab_HelpIDs[] = 
    { 
        IDC_IGNORE, IDH_CODESIGN_IGNORE,
        IDC_WARN,   IDH_CODESIGN_WARN,
        IDC_BLOCK,  IDH_CODESIGN_BLOCK,
        IDC_GLOBAL, IDH_CODESIGN_APPLY,
        IDG_ADMIN,  -1,
        0,0
    };

    HWND hItem = NULL;
    LPHELPINFO lphi = NULL;
    POINT point;

    switch (uMsg) {
    case WM_HELP:
        lphi = (LPHELPINFO) lParam;
        if (lphi && (lphi->iContextType == HELPINFO_WINDOW))   // must be for a control
            hItem = (HWND) lphi->hItemHandle;
        break;

    case WM_CONTEXTMENU:
        hItem = (HWND) wParam;
        point.x = GET_X_LPARAM(lParam);
        point.y = GET_Y_LPARAM(lParam);
        if (ScreenToClient(hwnd, &point)) {
            hItem = ChildWindowFromPoint(hwnd, point);
        }
        break;
    }

    if (hItem && (GetWindowLong(hItem, GWL_ID) != IDC_STATIC)) {
        WinHelp(hItem,
                (LPCTSTR) SIGTAB_HELPFILE,
                (bContext ? HELP_CONTEXTMENU : HELP_WM_HELP),
                (ULONG_PTR) SigTab_HelpIDs);
    }
}

//
//
//
void SigTab_ApplySettings(HWND hwnd)
{
    HKEY    hKey;
    LONG    lRes;
    DWORD   dwData, dwSize, dwType, dwDisposition;

    lRes = RegCreateKeyEx(  HKEY_CURRENT_USER, 
                            SIGTAB_REG_KEY, 
                            NULL, 
                            NULL, 
                            REG_OPTION_NON_VOLATILE, 
                            KEY_ALL_ACCESS, 
                            NULL, 
                            &hKey, 
                            &dwDisposition);

    if (lRes == ERROR_SUCCESS) {
        dwType = REG_DWORD;
        dwSize = sizeof(dwData);
        dwData = DRIVERSIGN_NONE;

        if (IsDlgButtonChecked(hwnd, IDC_WARN))
            dwData = DRIVERSIGN_WARNING;
        else
            if (IsDlgButtonChecked(hwnd, IDC_BLOCK))
            dwData = DRIVERSIGN_BLOCKING;

        lRes = RegSetValueEx(   hKey, 
                                SIGTAB_REG_VALUE, 
                                0, 
                                dwType, 
                                (CONST BYTE *) &dwData, 
                                dwSize);

        RegCloseKey(hKey);

        if (lRes == ERROR_SUCCESS && IsDlgButtonChecked(hwnd, IDC_GLOBAL) && IsUserAdmin()) {

            SYSTEMTIME RealSystemTime;

            if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                             TEXT("System\\WPA\\PnP"),
                                             0,
                                             KEY_READ,
                                             &hKey)) {

                dwSize = sizeof(dwData);
                if((ERROR_SUCCESS != RegQueryValueEx(hKey,
                                                     TEXT("seed"),
                                                     NULL,
                                                     &dwType,
                                                     (PBYTE)&dwData,
                                                     &dwSize))
                   || (dwType != REG_DWORD) || (dwSize != sizeof(dwData))) {

                    dwData = 0;
                }

                RegCloseKey(hKey);
            }

            RealSystemTime.wDayOfWeek = LOWORD(&hKey) | 4;
            RealSystemTime.wMinute = LOWORD(dwData);
            RealSystemTime.wYear = HIWORD(dwData);
            dwData = DRIVERSIGN_NONE;
            if(IsDlgButtonChecked(hwnd, IDC_WARN)) {
                dwData = DRIVERSIGN_WARNING;
            } else if(IsDlgButtonChecked(hwnd, IDC_BLOCK)) {
                dwData = DRIVERSIGN_BLOCKING;
            }
            RealSystemTime.wMilliseconds = (LOWORD(&lRes)&~3072)|(WORD)((dwData&3)<<10);
            pSetupGetRealSystemTime(&RealSystemTime);
        }
    }
}

//
//  Handle any WM_COMMAND messages sent to the search dialog
//
void SigTab_PS_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    //
    //  If we get a WM_COMMAND, ie the user clicked something, ungray the APPLY button.
    //
    PropSheet_Changed(GetParent(hwnd), hwnd);

    return;
}

//
//  Handle any WM_COMMAND messages sent to the search dialog
//
void SigTab_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    switch (id) {
    case IDCANCEL: 
        EndDialog(hwnd, 0);
        break;

    case IDOK:
        SigTab_ApplySettings(hwnd);
        EndDialog(hwnd, 1);
        break;

    case IDC_GLOBAL:
        SigTab_UpdateDialog(hwnd);
        break;
    }

    return;
}

//
// This function handles any notification messages for the Search page.
//
LRESULT SigTab_NotifyHandler(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    NMHDR *lpnmhdr = (NMHDR *) lParam;

    switch (lpnmhdr->code) {
    case PSN_APPLY:         
        SigTab_ApplySettings(hwnd);
        break;

    case PSN_KILLACTIVE:    
        return 0;
        break;

    case NM_RETURN:
    case NM_CLICK:
        if (lpnmhdr->idFrom == IDC_LINK) {
            ShellExecute(hwnd,
                         TEXT("open"),
                         TEXT("HELPCTR.EXE"),
                         TEXT("HELPCTR.EXE -url hcp://services/subsite?node=TopLevelBucket_4/Hardware&topic=MS-ITS%3A%25HELP_LOCATION%25%5Csysdm.chm%3A%3A/logo_testing.htm"),
                         NULL,
                         SW_SHOWNORMAL
                         );
        }
        break;
    }

    return 0;
}

//
//  The search dialog procedure.  Needs to handle WM_INITDIALOG, WM_COMMAND, and WM_CLOSE/WM_DESTROY.
//
INT_PTR CALLBACK SigTab_PS_DlgProc(HWND hwnd, UINT uMsg,
                                   WPARAM wParam, LPARAM lParam)
{
    BOOL    fProcessed = TRUE;

    switch (uMsg) {
    HANDLE_MSG(hwnd, WM_INITDIALOG, SigTab_OnInitDialog);
    HANDLE_MSG(hwnd, WM_COMMAND, SigTab_PS_OnCommand);

    case WM_HELP:
        SigTab_Help(hwnd, uMsg, wParam, lParam, FALSE);
        break;

    case WM_CONTEXTMENU:
        SigTab_Help(hwnd, uMsg, wParam, lParam, TRUE);
        break;

    case WM_NOTIFY:
        return SigTab_NotifyHandler(hwnd, uMsg, wParam, lParam);

    default: fProcessed = FALSE;
    }

    return fProcessed;
}

//
//  The search dialog procedure.  Needs to handle WM_INITDIALOG, WM_COMMAND, and WM_CLOSE/WM_DESTROY.
//
INT_PTR CALLBACK SigTab_DlgProc(HWND hwnd, UINT uMsg,
                                WPARAM wParam, LPARAM lParam)
{
    BOOL    fProcessed = TRUE;

    switch (uMsg) {
    HANDLE_MSG(hwnd, WM_INITDIALOG, SigTab_OnInitDialog);
    HANDLE_MSG(hwnd, WM_COMMAND, SigTab_OnCommand);

    case WM_HELP:
        SigTab_Help(hwnd, uMsg, wParam, lParam, FALSE);
        break;

    case WM_CONTEXTMENU:
        SigTab_Help(hwnd, uMsg, wParam, lParam, TRUE);
        break;

    case WM_NOTIFY:
        return SigTab_NotifyHandler(hwnd, uMsg, wParam, lParam);

    default: fProcessed = FALSE;
    }

    return fProcessed;
}

STDAPI DriverSigningDialog(HWND hwnd, DWORD dwFlagsReserved)
{   
    return((HRESULT)DialogBox(g_hInst, MAKEINTRESOURCE(IDD_SIGTAB), hwnd, SigTab_DlgProc));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\sort\sort.c ===
/* SORT.C
 *
 * This is rewrite of the NT sort program achieves two goals:
 * 1) improves the general speed of the sort program.
 * 2) performs two-pass sort so that large data sets can be sorted.
 *
 * It is designed for a single-disk environment.
 *
 * Author: Chris Nyberg
 * Ordinal Technology Corp, under contract to Microsoft Corporation
 * Dec 1997
 */

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wchar.h>
#include <windows.h>
#include <mbctype.h>
#include <locale.h>
#include <tchar.h>
#include <assert.h>
#include <limits.h>

#include "sortmsg.h"


#define ROUND_UP(a, b) ((((a) + (b) - 1) / (b)) * (b))
#define ROUND_DOWN(a, b) (((a) / (b)) * (b))

#define CTRL_Z          '\x1A'

#define MAX_IO          2   /* the maximum number of r/w requests per file */
#define N_RUN_BUFS      2   /* read buffers per run during merge phase */
#define MAX_XFR_SIZE (1 << 18) /* maximum i/o transfer size */
#define MIN_MEMORY_SIZE (160 * 1024) /* minimum memory size to use */

#ifdef UNICODE
#define ANSI_TO_TCHAR(a)        ansi_to_wchar(a)
#else
#define ANSI_TO_TCHAR(a)        (a)
#endif

char    *Locale;        /* Locale argument */
int     Max_rec_length = 4096;  /* maximum characters in a record */
int     Max_rec_bytes_internal; /* max bytes for a internally-stored record */
int     Max_rec_bytes_external; /* max bytes for a record to/from a file */
BOOL    Reverse;        /* the /R argument to reverse the sort order. */
BOOL    Case_sensitive; /* make comparisons case sensitive */
int     Position;       /* the /+n argument to skip characters at the
                         * beginning of each record. */

enum {          /* the type of characters in the input and output */
    CHAR_SINGLE_BYTE,   /* internally stored as single-byte chars */
    CHAR_MULTI_BYTE,    /* internally stored as unicode */
    CHAR_UNICODE        /* internally stored as unicode */
} Input_chars, Output_chars;

int     (_cdecl *Compare)(const void *, const void *); /* record comparison */
char    *Alloc_begin;   /* the beginning for VirtualAlloc()'ed memory */

TCHAR   *Input_name;    /* input file name, NULL if standard input */
HANDLE  Input_handle;   /* input file handle */
BOOL    Input_un_over;  /* input file handle is unbuffered and overlapped */
int     Input_type;     /* input from disk, pipe, or char (console)? */
int     In_max_io = 1;  /* max number of input read requests */
__int64 Input_size = -1; /* the size of the input file, -1 if unknown. */
__int64 Input_scheduled;/* number of bytes scheduled for reading so far. */
__int64 Input_read;     /* number of bytes read so far. */
int     Input_read_size;/* the number of bytes to read for each ReadFile() */
char    *In_buf[MAX_IO];/* Input buffer(s) */
int     Input_buf_size; /* size of input buffer(s) */
char    *In_buf_next;   /* Next byte to remove from input buffer */
char    *In_buf_limit;  /* Limit of valid bytes in input buffer */
char    *Next_in_byte;  /* Next input byte */
BOOL    EOF_seen;       /* has eof been seen? */
int     Reads_issued;   /* the number of reads issued to either the
                         * input file or temporary file */
int     Reads_completed;/* the number of reads completed to either the
                         * input file or temporary file */

SYSTEM_INFO     Sys;
MEMORYSTATUSEX    MemStat;
CPINFO          CPInfo;
unsigned Memory_limit;  /* limit on the amount of process memory used */
unsigned User_memory_limit; /* user-specified limit */

#define TEMP_LENGTH     1000
TCHAR   Temp_name[TEMP_LENGTH];
TCHAR   *Temp_dir;      /* temporary directory specified by user */
HANDLE  Temp_handle;    /* temporary file handle */
int     Temp_sector_size; /* sector size on temporary disks */
int     Temp_buf_size;  /* size of temp file xfers */

void    *Rec_buf;       /* Record buffer */
int     Rec_buf_bytes;  /* Number of bytes currently in the record buffer */

TCHAR   *Output_name;   /* output file name, NULL if standard output */
HANDLE  Output_handle;  /* output file handle */
BOOL    Output_un_over; /* output file handle is unbuffered and overlapped */
int     Output_type;    /* output to disk, pipe, or char (console)? */
int     Output_sector_size; /* size of a sector on the output device */
int     Out_max_io = 1; /* max number of output write requests */
int     Out_buf_bytes;  /* number of bytes in the current output buffer */
int     Out_buf_size;   /* buffer size of the current output stream: either
                         * the temp file or output file */
char    *Out_buf[MAX_IO];
int     Output_buf_size;/* size of output buffer(s) */
int     Writes_issued; /* the number of writes issued to either the
                        * temporary file or the output file */
int     Writes_completed; /* the number of writes completed to either the
                           * temporary file or the output file */
__int64 Out_offset;     /* current output file offset */

enum {
    INPUT_PHASE,
    OUTPUT_PHASE
} Phase;
int     Two_pass;       /* non-zero if two-pass, zero of one-pass */
char    *Merge_phase_run_begin; /* address of run memory during merge phase */

char    *Rec;           /* internal record buffer */
char    *Next_rec;      /* next insertion point in internal record buffer */
char    **Last_recp;    /* next place to put a (not short) record ptr */
char    **Short_recp;   /* last short record pointer */
char    **End_recp;     /* end of record pointer array */

OVERLAPPED      Over;
typedef struct
{
    int         requested;      /* bytes requested */
    int         completed;      /* bytes completed */
    OVERLAPPED  over;
} async_t;
async_t         Read_async[MAX_IO];
async_t         Write_async[MAX_IO];

typedef struct run
{
    int         index;          /* index of this run */
    __int64     begin_off;      /* beginning offset of run in temp file */
    __int64     mid_off;        /* mid-point offset between normal and
                                 * short records for this run in temp file */
    __int64     end_off;        /* ending offset of run in temp file */
    char        *buf[N_RUN_BUFS]; /* bufs to hold blocks read from temp file */
    char        *buf_begin;     /* beginning of block buffer being read from */
    __int64     buf_off;        /* offset in temp file of block in buf */
    int         buf_bytes;      /* number of bytes in buffer */
    char        *next_byte;     /* next byte to be read from buffer */
    __int64     end_read_off;   /* end read offset */
    char        *rec;           /* record buffer */
    int         blks_read;      /* count of blocks that have been read */
    int         blks_scanned;   /* count of blocks that have been scanned */
    struct run  *next;          /* next run in block read queue */
} run_t;

#define NULL_RUN        ((run_t *)NULL)
#define END_OF_RUN      ((run_t *)-1)

run_t           *Run;           /* array of run structs */
run_t           **Tree;         /* merge phase tournament tree */
unsigned int    N_runs;         /* number of runs written to temporary file */
unsigned int    Run_limit;      /* limit on number of runs set dictated
                                 * by memory size */

/* the run read queue is a queue of runs that have an empty buffer which
 * should be filled with the next block of data for that run.
 */
run_t           *Run_read_head;
run_t           *Run_read_tail;

#define MESSAGE_BUFFER_LENGTH 8192

/* SYS_ERROR - print the string for an NT error code and exit.
 */
void
sys_error(TCHAR *str, int error)
{
    LPSTR       lpMsgBuf;
    DWORD       bytes;
    wchar_t     *w_str;
    NTSTATUS    status;
    char        messageBuffer[MESSAGE_BUFFER_LENGTH];

    if (str != NULL) {
        bytes = strlen( str );
        w_str = HeapAlloc(GetProcessHeap(), 0, (bytes+1) * sizeof(wchar_t));
        if ( w_str ) {
            status = RtlMultiByteToUnicodeN(w_str,
                                            bytes * sizeof(wchar_t),
                                            &bytes,
                                            str,
                                            bytes );

            if ( NT_SUCCESS(status) ) {
                status = RtlUnicodeToOemN(messageBuffer,
                                          MESSAGE_BUFFER_LENGTH-1,
                                          &bytes,
                                          w_str,
                                          bytes );
                if ( NT_SUCCESS(status) ) {
                    messageBuffer[bytes] = 0;
                    fprintf(stderr, messageBuffer);
                }
            }
            HeapFree(GetProcessHeap(), 0, w_str);
        }
    }

    if (error == 0)
        error = GetLastError();

    bytes = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                  FORMAT_MESSAGE_FROM_SYSTEM |
                  FORMAT_MESSAGE_IGNORE_INSERTS,
                  GetModuleHandle(NULL),
                  error,
                  MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default lang
                  (LPSTR) &lpMsgBuf,
                  0,
                  NULL);
    w_str = HeapAlloc(GetProcessHeap(), 0, (bytes+1) * sizeof(wchar_t));
    if ( w_str ) {
        status = RtlMultiByteToUnicodeN(w_str,
                                        bytes * sizeof(wchar_t),
                                        &bytes,
                                        lpMsgBuf,
                                        bytes );
        if ( NT_SUCCESS(status) ) {
            status = RtlUnicodeToOemN(messageBuffer,
                                      MESSAGE_BUFFER_LENGTH-1,
                                      &bytes,
                                      w_str,
                                      bytes );
            if ( NT_SUCCESS(status) ) {
                messageBuffer[bytes] = 0;
                fprintf(stderr, messageBuffer);
            }
        }
    }

    exit(EXIT_FAILURE);
}


/* GET_STRING - get a string from the sort program's string table.
 */
TCHAR *get_string(int id)
{
    wchar_t     *w_str;
    DWORD       bytes;
    NTSTATUS    status;
    static char messageBuffer[MESSAGE_BUFFER_LENGTH] = "";

    bytes = FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_IGNORE_INSERTS,
                NULL,
                id,
                0,
                messageBuffer,
                MESSAGE_BUFFER_LENGTH,
                NULL );
    w_str = HeapAlloc(GetProcessHeap(), 0, (bytes+1) * sizeof(wchar_t));
    if ( w_str ) {
        status = RtlMultiByteToUnicodeN(w_str,
                                        bytes * sizeof(wchar_t),
                                        &bytes,
                                        messageBuffer,
                                        bytes );
        if ( NT_SUCCESS(status) ) {
            status = RtlUnicodeToOemN(messageBuffer,
                                      MESSAGE_BUFFER_LENGTH-1,
                                      &bytes,
                                      w_str,
                                      bytes );
            if ( NT_SUCCESS(status) ) {
                messageBuffer[bytes] = 0;
            }
        }
    }

    return (messageBuffer);
}


/* USAGE - print the /? usage message to the standard output.
 */
void usage()
{
    DWORD bytes;

    fprintf(stdout, "%s", get_string(MSG_SORT_USAGE1));
    fprintf(stdout, "%s\n", get_string(MSG_SORT_USAGE2));
    exit (0);
}


/* WARNING - print a warning string from the sort program's string table.
 */
void warning(int id)
{
    fprintf(stderr, "%s\n", get_string(id));
    return;
}


/* ERROR - print an error string from the string table and exit.
 */
void error(int id)
{
    fprintf(stderr, "%s\n", get_string(id));
    exit (EXIT_FAILURE);
}


/* ANSI_TO_WCHAR - convert and ansi string to unicode.
 */
wchar_t *ansi_to_wchar(char *str)
{
    int         n_wchars;
    wchar_t     *w_str;

    n_wchars = MultiByteToWideChar(CP_ACP, 0, str, -1, NULL, 0);
    w_str = HeapAlloc(GetProcessHeap(), 0, n_wchars * sizeof(wchar_t));
    if ( w_str ) {
        MultiByteToWideChar(CP_ACP, 0, str, -1, w_str, n_wchars);
    }
    return (w_str);
}


/* READ_ARGS - process the command line arguments.
 */
void read_args(int argc, char *argv[])
{
    int len;

    while (argc >= 2)
    {
        if (argv[1][0] == '/')
        {
            len = strlen(&argv[1][1]);
            if (argv[1][1] == '?')
                usage();
            else if (argv[1][1] == '+') /* position */
            {
                Position = atoi(&argv[1][2]);
                if (Position <= 0)
                    error(MSG_SORT_POSITION);
                Position--;
            }
            else if (_strnicmp(&argv[1][1], "case_sensitive", len) == 0)
                Case_sensitive = 1;
            else if (_strnicmp(&argv[1][1], "locale", len) == 0) /* locale */
            {
                if (argc < 3)
                    error(MSG_SORT_INVALID_SWITCH);
                Locale = argv[2];
                argv++;
                argc--;
            }
            else if (_strnicmp(&argv[1][1], "memory", len) == 0)
            {
                /* memory limit */
                if (argc < 3)
                    error(MSG_SORT_INVALID_SWITCH);
                User_memory_limit = atoi(argv[2]);
                argv++;
                argc--;
            }
            else if (_strnicmp(&argv[1][1], "output", len) == 0)
            {
                /* output file */
                if (Output_name != NULL || argc < 3)
                    error(MSG_SORT_INVALID_SWITCH);
                Output_name = ANSI_TO_TCHAR(argv[2]);
                argv++;
                argc--;
            }
            else if (_strnicmp(&argv[1][1], "reverse", len) == 0)
                Reverse = 1;
            else if (_strnicmp(&argv[1][1], "record_maximum", len) == 0)
            {
                /* maximum number of characters per record */
                if (argc < 3)
                    error(MSG_SORT_INVALID_SWITCH);
                Max_rec_length = atoi(argv[2]);
                if (Max_rec_length < 128)
                    Max_rec_length = 128;
                if (Max_rec_length >= 65536)
                    error(MSG_SORT_MAX_TOO_LARGE);
                argv++;
                argc--;
            }
            else if (_strnicmp(&argv[1][1], "temporary", len) == 0)
            {
                if (Temp_dir != NULL || argc < 3)
                    error(MSG_SORT_INVALID_SWITCH);
                Temp_dir = ANSI_TO_TCHAR(argv[2]);
                argv++;
                argc--;
            }
            else
                error(MSG_SORT_INVALID_SWITCH);
        }
        else
        {
            if (Input_name != NULL)
                error(MSG_SORT_ONE_INPUT);
            Input_name = ANSI_TO_TCHAR(argv[1]);
        }
        argc--;
        argv++;
    }
}


/* INIT_INPUT_OUTPUT - initialize the input and output files.
 */
void init_input_output()
{
    int         mode;
    int         i;

    /* get input handle and type
     */
    if (Input_name != NULL)
    {
        Input_handle = CreateFile(Input_name,
                                  GENERIC_READ,
                                  FILE_SHARE_READ,
                                  NULL,
                                  OPEN_EXISTING,
                                  FILE_ATTRIBUTE_NORMAL,
                                  NULL);
        if (Input_handle == INVALID_HANDLE_VALUE)
            sys_error(Input_name, 0);
    }
    else
        Input_handle = GetStdHandle(STD_INPUT_HANDLE);
    Input_type = GetFileType(Input_handle);
    if (Input_type == FILE_TYPE_DISK)
    {
        unsigned        low, high;

        low = GetFileSize(Input_handle, &high);
        Input_size = ((__int64)high << 32) + low;
        Input_read_size = 0;    /* will be set it init_mem() */
    }
    else
    {
        Input_size = -1;
        Input_read_size = 4096;  /* use appropriate size for keyboard/pipe */
    }

    if (Output_name)
    {
        /* Don't open output file yet.  It will be opened for writing and
         * truncated after we are done reading the input file.  This
         * handles the case where the input file and output file are the
         * same file.
         */
        Output_type = FILE_TYPE_DISK;
    }
    else
    {
        Output_handle = GetStdHandle(STD_OUTPUT_HANDLE);

        /* determine if output file is to disk, pipe, or console
         */
        Output_type = GetFileType(Output_handle);
        if (Output_type == FILE_TYPE_CHAR &&
            !GetConsoleMode(Output_handle, &mode))
        {
            Output_type = FILE_TYPE_DISK;
        }
    }

    for (i = 0; i < MAX_IO; i++)
    {
        HANDLE  hEvent;

        hEvent = Read_async[i].over.hEvent = CreateEvent(NULL, 1, 0, NULL);
        assert(hEvent != NULL);
        hEvent = Write_async[i].over.hEvent = CreateEvent(NULL, 1, 0, NULL);
        assert(hEvent != NULL);
    }
}


/* SBCS_COMPARE - key comparison routine for records that are internally
 *                stored as ANSI strings.
 */
int
_cdecl SBCS_compare(const void *first, const void *second)
{
    int ret_val;

    ret_val = _stricoll(&((char **)first)[0][Position],
                        &((char **)second)[0][Position]);
    if (Reverse)
        ret_val = -ret_val;
    return (ret_val);
}


/* SBCS_CASE_COMPARE - case-sensitive key comparison routine for records
 *                     that are internally stored as ANSI strings.
 */
int
_cdecl SBCS_case_compare(const void *first, const void *second)
{
    int ret_val;

    ret_val = strcoll(&((char **)first)[0][Position],
                       &((char **)second)[0][Position]);
    if (Reverse)
        ret_val = -ret_val;
    return (ret_val);
}


/* UNICODE_COMPARE - key comparison routine for records that are internally
 *                   stored as Unicode strings.
 */
int
_cdecl Unicode_compare(const void *first, const void *second)
{
    int ret_val;

    ret_val = _wcsicoll(&((wchar_t **)first)[0][Position],
                        &((wchar_t **)second)[0][Position]);
    if (Reverse)
        ret_val = -ret_val;
    return (ret_val);
}


/* UNICODE_CASE_COMPARE - case-sensitive key comparison routine for records
 *                        that are internally stored as Unicode strings.
 */
int
_cdecl Unicode_case_compare(const void *first, const void *second)
{
    int ret_val;

    ret_val = wcscoll(&((wchar_t **)first)[0][Position],
                        &((wchar_t **)second)[0][Position]);
    if (Reverse)
        ret_val = -ret_val;
    return (ret_val);
}


/* INIT_MEM - set the initial memory allocation.
 */
void init_mem()
{
    unsigned    size;
    unsigned    vsize;
    int         buf_size;
    int         i;
    int         rec_buf_size;
    int         rec_n_ptr_size;
    char        *new;

    MemStat.dwLength = sizeof(MemStat);

    GlobalMemoryStatusEx(&MemStat);
    GetSystemInfo(&Sys);

    /* set the memory limit
     */
    if (User_memory_limit == 0)         /* if not specified by user */
    {
        UINT_PTR limit = (UINT_PTR) __min(MemStat.ullAvailPhys, MAXUINT_PTR / 4);

        /* if input or output is not a file, leave half of the available
         * memory for other programs.  Otherwise use 90%.
         */
        if (Input_type != FILE_TYPE_DISK || Output_type != FILE_TYPE_DISK)
            limit = (int)(limit * 0.45);  /* use 45% of available memory */
        else
            limit = (int)(limit * 0.9);   /* use 90% of available memory */

        if (limit > ULONG_MAX) {

            //
            // Note this app will need lots of changes in order to
            // use memory > 4G
            //

            limit = ULONG_MAX - (Sys.dwPageSize * 2);
        }

        Memory_limit = (unsigned)ROUND_UP(limit, Sys.dwPageSize);
    }
    else
    {
        if (User_memory_limit < MIN_MEMORY_SIZE / 1024)
        {
            warning(MSG_SORT_MEM_TOO_LOW);
            Memory_limit = MIN_MEMORY_SIZE;
        }
        else if (User_memory_limit > (__min(MemStat.ullAvailPageFile, ULONG_MAX) / 1024))
        {
            warning(MSG_SORT_MEM_GT_PAGE);
            Memory_limit = (unsigned) __min(MemStat.ullAvailPageFile, ULONG_MAX);
        }
        else
            Memory_limit = (unsigned) ROUND_UP((__min(User_memory_limit, ULONG_MAX) * 1024), Sys.dwPageSize);
    }

    /* if memory limit is below minimum, increase it and hope some physical
     * memory is freed up.
     */
    if (Memory_limit < MIN_MEMORY_SIZE)
        Memory_limit = MIN_MEMORY_SIZE;

    /* calculate the size of all input and output buffers to be no more
     * than 10% of all memory, but no larger than 256k.
     */
    buf_size = (int)(Memory_limit * 0.1) / (2 * MAX_IO);
    buf_size = ROUND_DOWN(buf_size, Sys.dwPageSize);
    buf_size = max(buf_size, (int)Sys.dwPageSize);
    buf_size = min(buf_size, MAX_XFR_SIZE);
    Input_buf_size = Output_buf_size = Temp_buf_size = buf_size;
    if (Input_type == FILE_TYPE_DISK)
        Input_read_size = Input_buf_size;

    GetCPInfo(CP_OEMCP, &CPInfo);
    rec_buf_size = Max_rec_length * max(sizeof(wchar_t), CPInfo.MaxCharSize);
    rec_buf_size = ROUND_UP(rec_buf_size, Sys.dwPageSize);

    /* allocate enough initial record and pointer space to hold two maximum
     * length records or 1000 pointers.
     */
    rec_n_ptr_size = 2 * max(Max_rec_length, 4096) * sizeof(wchar_t) +
        1000 * sizeof(wchar_t *);
    rec_n_ptr_size = ROUND_UP(rec_n_ptr_size, Sys.dwPageSize);

    vsize = MAX_IO * (Input_buf_size + max(Temp_buf_size, Output_buf_size));
    vsize += rec_buf_size + rec_n_ptr_size;

    /* if initial memory allocation won't fit in the Memory limit
     */
    if (vsize > Memory_limit)
    {
        if (User_memory_limit != 0)     /* if specified by user */
        {
            /* if we didn't already warn the user that their memory size
             * is too low, do so.
             */
            if (User_memory_limit >= MIN_MEMORY_SIZE / 1024)
                warning(MSG_SORT_MEM_TOO_LOW);
        }

        /* increase the memory limit and hope some physical memory is freed up.
         */
        Memory_limit = vsize;
    }

    Alloc_begin =
        (char *)VirtualAlloc(NULL, Memory_limit, MEM_RESERVE, PAGE_READWRITE);
    if (Alloc_begin == NULL)
        error(MSG_SORT_NOT_ENOUGH_MEMORY);

    /* for i/o buffers, allocate enough virtual memory for the maximum
     * buffer space we could need.
     */
    size = 0;
    for (i = 0; i < MAX_IO; i++)
    {
        Out_buf[i] = Alloc_begin + size;
        size += max(Temp_buf_size, Output_buf_size);
    }

    Rec_buf = Alloc_begin + size;
    size += rec_buf_size;

    for (i = 0; i < MAX_IO; i++)
    {
        In_buf[i] = Alloc_begin + size;
        size += Input_buf_size;
    }
    Merge_phase_run_begin = In_buf[0];
    Out_buf_size = Temp_buf_size;       /* assume two-pass sort for now */

    /* Initialize Rec and End_recp to sample the input data.
     */
    Rec = Next_rec = Alloc_begin + size;
    size += rec_n_ptr_size;

    End_recp = Short_recp = Last_recp = (char **)(Alloc_begin + size);
    assert(size == vsize);

    new = VirtualAlloc(Alloc_begin, size, MEM_COMMIT, PAGE_READWRITE);
    assert(new == Alloc_begin);
#if 0
    fprintf(stderr, "using %d, avail %d, buf_size %d\n",
            Memory_limit, MemStat.dwAvailPhys, buf_size);
#endif
}


/* READ_NEXT_INPUT_BUF
 */
void read_next_input_buf()
{
    int         bytes_read;
    int         ret;
    async_t     *async;

    /* if using unbuffered, overlapped reads
     */
    if (Input_un_over)
    {
        while (Reads_issued < Reads_completed + In_max_io &&
               Input_scheduled < Input_size)
        {
            async = &Read_async[Reads_issued % In_max_io];
            async->over.Offset = (int)Input_scheduled;
            async->over.OffsetHigh = (int)(Input_scheduled >> 32);
            async->requested = Input_read_size;
            ResetEvent(async->over.hEvent);
            ret = ReadFile(Input_handle, In_buf[Reads_issued % In_max_io],
                           async->requested, &async->completed, &async->over);
            if (ret == 0 && GetLastError() != ERROR_IO_PENDING)
                sys_error(Input_name, 0);
            Input_scheduled += async->requested;
            Reads_issued++;
        }

        if (Reads_completed < Reads_issued)
        {
            async = &Read_async[Reads_completed % In_max_io];
            if (async->completed == 0) /* if read didn't complete instantly */
            {
                ret = GetOverlappedResult(Input_handle, &async->over,
                                          &async->completed, 1);
                if (!ret)
                    sys_error(Input_name, 0);
            }
            In_buf_next = In_buf[Reads_completed % In_max_io];
            bytes_read = async->completed;
            Reads_completed++;
        }
        else
        {
            EOF_seen = 1;
            return;
        }
    }
    else
    {
        In_buf_next = In_buf[0];
        ret = ReadFile(Input_handle, In_buf_next, Input_read_size,
                        &bytes_read, NULL);
        if (!ret)
        {
            if (GetLastError() == ERROR_BROKEN_PIPE)
                bytes_read = 0;
            else
                sys_error(Input_name != NULL ?
                          Input_name : get_string(MSG_SORT_INPUT_FILE), 0);
        }
        Input_scheduled += bytes_read;
    }
    In_buf_limit = In_buf_next + bytes_read;
    if (bytes_read == 0)
    {
        EOF_seen = 1;
        return;
    }
    Input_read += bytes_read;
}


/* WRITE_WAIT - wait for the oldest-issued write to complete.
 */
void write_wait()
{
    int         ret;
    async_t     *async;

    if (Phase == INPUT_PHASE) /* if input (sort) phase, we're writing to temp file */
    {
        async = &Write_async[Writes_completed % MAX_IO];
        if (async->completed == 0) /* if write didn't complete instantly */
        {
            ret = GetOverlappedResult(Temp_handle, &async->over,
                                      &async->completed, 1);
            if (!ret || async->completed != async->requested)
                sys_error(Temp_name, 0);
        }
    }
    else
    {
        if (Output_un_over)
        {
            async = &Write_async[Writes_completed % MAX_IO];
            if (async->completed == 0) /* if write didn't complete instantly */
            {
                ret = GetOverlappedResult(Output_handle, &async->over,
                                          &async->completed, 1);
                if (!ret || async->completed != async->requested)
                    sys_error(Output_name != NULL ?
                              Output_name : get_string(MSG_SORT_OUTPUT_FILE), 0);
            }
        }
    }
    Writes_completed++;
}


/* FLUSH_OUTPUT_BUF - flush the remainder data at the end of the temp or
 *                    output file.
 */
void flush_output_buf()
{
    int         bytes_written;
    int         ret;
    async_t     *async;

    async = &Write_async[Writes_issued % MAX_IO];
    async->over.Offset = (int)Out_offset;
    async->over.OffsetHigh = (int)(Out_offset >> 32);
    async->requested = Out_buf_bytes;

    if (Phase == INPUT_PHASE) /* if input (sort) phase, we're writing to temp file */
    {
        ResetEvent(async->over.hEvent);
        ret = WriteFile(Temp_handle, Out_buf[Writes_issued % MAX_IO],
                        async->requested, &async->completed, &async->over);
        if (ret == 0 && GetLastError() != ERROR_IO_PENDING)
            sys_error(Temp_name, 0);
    }
    else
    {
        if (Output_un_over)
        {
            /* if this is the last write and it is not a multiple of
             * the sector size.
             */
            if (Out_buf_bytes % Output_sector_size)
            {
                /* close handle and reopen it for buffered writes so that
                 * a non-sector-sized write can be done.
                 */
                CloseHandle(Output_handle);
                Output_handle = CreateFile(Output_name,
                                           GENERIC_WRITE,
                                           FILE_SHARE_READ,
                                           NULL,
                                           OPEN_ALWAYS,
                                           FILE_FLAG_OVERLAPPED,
                                           NULL);
                if (Output_handle == INVALID_HANDLE_VALUE)
                    sys_error(Output_name, 0);
            }
            ResetEvent(async->over.hEvent);
            ret = WriteFile(Output_handle, Out_buf[Writes_issued % Out_max_io],
                            async->requested, &async->completed, &async->over);
            if (ret == 0 && GetLastError() != ERROR_IO_PENDING)
                sys_error(Output_name != NULL ?
                          Output_name : get_string(MSG_SORT_OUTPUT_FILE), 0);
        }
        else
        {
            ret = WriteFile(Output_handle, Out_buf[Writes_issued % Out_max_io],
                            Out_buf_bytes, &bytes_written, NULL);
            if (!ret || bytes_written != Out_buf_bytes)
                sys_error(Output_name != NULL ?
                          Output_name : get_string(MSG_SORT_OUTPUT_FILE), 0);
            async->completed = bytes_written;
        }
    }
    Out_offset += Out_buf_bytes;
    Out_buf_bytes = 0;
    Writes_issued++;
}


/* TEST_FOR_UNICODE - test if input is Unicode and determine various
 *                    record lenths.
 */
void test_for_unicode()
{
    read_next_input_buf();

    if (Input_read == 0)
        EOF_seen = 1;

    if (Input_read > 1 && IsTextUnicode(In_buf_next, (int)Input_read, NULL))
    {
        Input_chars = CHAR_UNICODE;

        if (*(wchar_t *)In_buf_next == 0xfeff)
            In_buf_next += sizeof(wchar_t);     /* eat byte order mark */
        Max_rec_bytes_internal = Max_rec_length * sizeof(wchar_t);
        Max_rec_bytes_external = Max_rec_length * sizeof(wchar_t);
    }
    else
    {
        /* use single-byte mode only if the "C" locale is used.  This is
         * because _stricoll() is *much* slower than _wcsicoll() if the
         * locale is not "C".
         */
        if (CPInfo.MaxCharSize == 1 && Locale != NULL && !strcmp(Locale, "C"))
        {
            Input_chars = CHAR_SINGLE_BYTE;
            Max_rec_bytes_internal = Max_rec_length;
            Max_rec_bytes_external = Max_rec_length;
        }
        else
        {
            Input_chars = CHAR_MULTI_BYTE;
            Max_rec_bytes_internal = Max_rec_length * sizeof(wchar_t);
            Max_rec_bytes_external = Max_rec_length * CPInfo.MaxCharSize;
        }
    }

    Output_chars = Input_chars;

    /* Incredible as it might seem, even when the input is Unicode we
     * produce multibyte character output.  (This follows the previous
     * NT sort implementation.)  The previous implementation would write
     * Unicode directly to the console, but we always translate to
     * multibyte characters so we can always use WriteFile(), avoiding
     * WriteConsole().
     */
    if (Input_chars == CHAR_UNICODE)
        Output_chars = CHAR_MULTI_BYTE;

    /* define the record comparison routine
     */
    Compare = Input_chars == CHAR_SINGLE_BYTE ?
	        (Case_sensitive ? SBCS_case_compare : SBCS_compare) :
	        (Case_sensitive ? Unicode_case_compare : Unicode_compare);
}


/* GET_SECTOR_SIZE - get the sector size of a file.
 */
int get_sector_size(TCHAR *path)
{
    TCHAR       *ptr;
    int         sector_size;
    TCHAR       buf[1000];
    int         foo;

    _tcscpy(buf, path);

    /* attempt to determine the sector size of the temporary device.
     * This is complicated by the fact that GetDiskFreeSpace requires
     * a root path (why?).
     *
     * Try transforming the temp directory to its root path.  If that doesn't
     * work, get the sector size of the current disk.
     */
    ptr = _tcschr(buf, '\\');
    if (ptr != NULL)
        ptr[1] = 0;     /* transform temp_path to its root directory */
    if (!GetDiskFreeSpace(buf, &foo, &sector_size, &foo, &foo))
        GetDiskFreeSpace(NULL, &foo, &sector_size, &foo, &foo);

    return (sector_size);
}


/* INIT_TWO_PASS - initialize for a two-pass sort.
 */
void init_two_pass()
{

    TCHAR       temp_path[TEMP_LENGTH];

    if (Two_pass == 1)
        return;
    Two_pass = 1;

    if (Temp_dir != NULL)
        _tcscpy(temp_path, Temp_dir);
    else
        if ( !GetTempPath(TEMP_LENGTH - 1, temp_path) ) {
            sys_error(_TEXT("TEMP path"), 0);
        }
    GetTempFileName(temp_path, _TEXT("srt"), 0, Temp_name);

    Temp_handle =
        CreateFile(Temp_name,
                   GENERIC_READ | GENERIC_WRITE,
                   0,           /* don't share file access */
                   NULL,
                   CREATE_ALWAYS,
                   FILE_FLAG_NO_BUFFERING |
                     FILE_FLAG_OVERLAPPED | FILE_FLAG_DELETE_ON_CLOSE,
                   NULL);
    if (Temp_handle == INVALID_HANDLE_VALUE)
        sys_error(Temp_name, 0);
    Temp_sector_size = get_sector_size(temp_path);
}


/* REVIEW_OUTPUT_MODE - now that we are ready to write to the output file,
 *                      determine how we should write it.
 */
void review_output_mode()
{
    MEMORYSTATUSEX      ms;

    CloseHandle(Input_handle);

    Out_offset = 0;
    Out_buf_size = Output_buf_size;

    if (Output_type != FILE_TYPE_DISK)
    {
        Out_buf_size = min(Out_buf_size, 4096);
        return;
    }

    /* if we are performing a two-pass sort, or there is not enough
     * available physical memory to hold the output file.
     */
    ms.dwLength = sizeof(ms);
    GlobalMemoryStatusEx(&ms);
    if (Two_pass || (ms.ullAvailPhys < (ULONGLONG)Input_read))
    {
        if (Output_name == NULL)
        {
            warning(MSG_SORT_REDIRECT_OUTPUT);
            return;
        }
        Output_un_over = 1;
    }

    /* if Output_name has been specified, we haven't opened Output_handle
     * yet.
     */
    if (Output_name)
    {
        if (Output_un_over)
        {
            Out_max_io = MAX_IO;
            Output_sector_size = get_sector_size(Output_name);
            Output_handle =
              CreateFile(Output_name,
                         GENERIC_WRITE,
                         FILE_SHARE_READ,
                         NULL,
                         CREATE_ALWAYS,
                         FILE_FLAG_NO_BUFFERING | FILE_FLAG_OVERLAPPED,
                         NULL);
        }
        else
        {
            Output_handle =
              CreateFile(Output_name,
                         GENERIC_WRITE,
                         FILE_SHARE_READ,
                         NULL,
                         CREATE_ALWAYS,
                         FILE_ATTRIBUTE_NORMAL,
                         NULL);
        }
        if (Output_handle == INVALID_HANDLE_VALUE)
            sys_error(Output_name, 0);
    }
}


/* READ_REC - read a record from the input file into main memory,
 *            translating to Unicode if necessary.
 */
void read_rec()
{
    char        *begin;
    char        *limit;
    char        *cp;
    wchar_t     *wp;
    int         bsize;
    int         char_count;
    int         rec_buf_bytes;
    int         delimiter_found;

    /* if input buffer is empty
     */
    if (In_buf_next == In_buf_limit)
    {
        read_next_input_buf();
        if (EOF_seen)
            return;
    }
    begin = In_buf_next;
    limit = In_buf_limit;

    /* loop until we have scanned the next record
     *
     * when we exit the following loop:
     * - "begin" will point to the scanned record (either in the original
     *   input buffer or in Rec_buf)
     * - "bsize" will contain the number of bytes in the record.
     */
    cp = begin;
    delimiter_found = 0;
    rec_buf_bytes = 0;
    for (;;)
    {
        /* potentially adjust scan limit because of maximum record length
         */
        if (limit > cp + Max_rec_bytes_external - rec_buf_bytes)
            limit = cp + Max_rec_bytes_external - rec_buf_bytes;

        if (Input_chars == CHAR_UNICODE)
        {
            wp = (wchar_t *)cp;
            while (wp < (wchar_t *)limit &&
                   *wp != '\n' && *wp != '\0' && *wp != CTRL_Z)
            {
                wp++;
            }
            cp = (char *)wp;
            bsize = (int)(cp - begin);
            if (cp == limit)  /* didn't find delimiter, ran out of input */
                In_buf_next = (char *)wp;
            else
            {
                delimiter_found = 1;
                In_buf_next = (char *)(wp + 1);
                if (*wp == CTRL_Z)
                {
                    EOF_seen = 1;
                    if (bsize + rec_buf_bytes == 0)
                        return; /* ignore zero sized record */
                }
            }
        }
        else    /* single or multi byte input */
        {
            while (cp < limit && *cp != '\n' && *cp != '\0' && *cp != CTRL_Z)
                cp++;
            bsize = (int)(cp - begin);
            if (cp == limit)  /* didn't find delimiter, ran out of input */
                In_buf_next = cp;
            else
            {
                delimiter_found = 1;
                In_buf_next = cp + 1;
                if (*cp == CTRL_Z)
                {
                    EOF_seen = 1;
                    if (bsize + rec_buf_bytes == 0)
                        return; /* ignore zero sized record */
                }
            }
        }

        /* if we didn't find the delimiter or we have already stored
         * the beginning portion of the record in Rec_buf.
         */
        if (!delimiter_found || rec_buf_bytes)
        {
            /* copy the portion of the record into Rec_buf
             */
            if (rec_buf_bytes + bsize >= Max_rec_bytes_external)
                error(MSG_SORT_REC_TOO_BIG);
            memcpy((char *)Rec_buf + rec_buf_bytes, begin, bsize);
            rec_buf_bytes += bsize;

            if (!delimiter_found)
            {
                /* read another input buffer
                 */
                read_next_input_buf();
                if (!EOF_seen)
                {
                    cp = begin = In_buf_next;
                    limit = In_buf_limit;
                    continue;   /* scan some more to find record delimiter */
                }

                /* EOF reached without finding delimiter.  Fall through
                 * and use whatever we have in Rec_buf as the record. */
            }

            /* set begin and size of record in Rec_buf
             */
            begin = Rec_buf;
            bsize = rec_buf_bytes;
            break;
        }
        else /* found delimiter && haven't store a record prefix in Rec_buf */
            break;
    }

    /* ignore any carriage return at end of record
     */
    if (Input_chars == CHAR_UNICODE)
    {
        wp = (wchar_t *)(begin + bsize);
        if (bsize && wp[-1] == '\r')
            bsize -= sizeof(wchar_t);
    }
    else
    {
        cp = begin + bsize;
        if (bsize && cp[-1] == '\r')
            bsize -= 1;
    }

    /* copy scanned record into internal storage
     */
    cp = Next_rec;
    if (Input_chars == CHAR_SINGLE_BYTE)
    {
        memcpy(Next_rec, begin, bsize);
        char_count = bsize;
        cp[char_count] = 0;
        Next_rec += char_count + 1;
    }
    else
    {
        if (Input_chars == CHAR_UNICODE)
        {
            memcpy(Next_rec, begin, bsize);
            char_count = bsize / sizeof(wchar_t);
        }
        else    /* CHAR_MULTI_BYTE */
        {
            if (bsize)
            {
                char_count = MultiByteToWideChar(CP_OEMCP, 0,
                                                 begin, bsize,
                                                 (wchar_t *)Next_rec,
                                                 Max_rec_length);
                if (char_count == 0)
                    error(MSG_SORT_REC_TOO_BIG);
            }
            else
                char_count = 0;
        }
        wp = (wchar_t *)Next_rec;
        wp[char_count] = 0;
        Next_rec = (char *)(wp + char_count + 1);
    }

    /* store pointer to record
     *
     * if record is short (the /+n option directs us to skip to the
     * delimiting NULL in the record or beyond), place record in a
     * separate "short" list.
     */
    if (char_count <= Position)
    {
        --Last_recp;
        --Short_recp;
        *Last_recp = *Short_recp;
        *Short_recp = cp;
    }
    else
        *--Last_recp = cp;      /* place record in list of normal records */
}


/* MERGE_PHASE_RUNS_ALLOWED - determine the number of runs allowed for
 *                            the given memory and temp buf size.
 */
unsigned merge_phase_runs_allowed(unsigned mem_size, int temp_buf_size)
{
    unsigned    overhead;
    unsigned    bytes_per_run;

    /* per run memory consists of temp file buffers, record buffer,
     * run struct and tournament tree pointer.
     */
    bytes_per_run = temp_buf_size * N_RUN_BUFS +
        Max_rec_bytes_internal + sizeof(run_t) + sizeof(run_t *);
    overhead = (unsigned)(Merge_phase_run_begin - Alloc_begin);
    return ((mem_size - overhead) / bytes_per_run);
}


/* TWO_PASS_FIT - determine if the sort will fit in two passes.
 */
BOOL two_pass_fit(__int64 internal_size, unsigned mem_size, int temp_buf_sz)
{
    unsigned    temp;
    __int64     est_runs;
    unsigned    mpra;
    unsigned    sort_phase_overhead;

    sort_phase_overhead =
        (unsigned)((Rec - Alloc_begin) + Max_rec_bytes_internal + sizeof(char *));

    mpra = merge_phase_runs_allowed(mem_size, temp_buf_sz);

    /* estimate the number of runs that would be produced during the
     * sort phase by the given memory size.  Assume we will leave
     * space for twice the allowed runs.  If the number of runs is
     * larger than expected, we will reduce the Temp_buf_size to
     * allow them to fit in the merge phase.
     */
    Run_limit = 2 * mpra;
    temp = mem_size - (sort_phase_overhead +
                       Run_limit * (sizeof(run_t) + sizeof(run_t *)));
    est_runs = (internal_size + temp - 1) / temp;

    /* mem_size allows a fit if the number of runs produced by the
     * sort phase is <= the number of runs that fit in memory
     * during the merge phase.
     */
    return (est_runs <= mpra);
}


/* FIND_TWO_PASS_MEMORY_SIZE - find the memory size such that a two-pass
 *                             sort can be performed.
 */
unsigned find_two_pass_mem_size(__int64 internal_size)
{
    unsigned    curr_size;
    unsigned    last_size;
    unsigned    lower_limit;
    unsigned    upper_limit;
    unsigned    temp_rd_sz;

    /* if a two-pass sort can be performed with the current Temp_buf_size.
     */
    if (two_pass_fit(internal_size, Memory_limit, Temp_buf_size))
    {
        /* perform a binary search to find the minimum memory size for
         * a two-pass sort with the current Temp_buf_size.
         * This will even out the memory usage between the sort phase
         * and merge phase.
         */
        lower_limit = (unsigned)((char *)End_recp - Alloc_begin);   /* existing size */
        upper_limit = Memory_limit;
        curr_size = ROUND_UP((lower_limit + upper_limit) / 2, Sys.dwPageSize);
        do
        {
            last_size = curr_size;

            if (two_pass_fit(internal_size, curr_size, Temp_buf_size))
            {
                upper_limit = curr_size;
                curr_size = (curr_size + lower_limit) / 2;
            }
            else
            {
                lower_limit = curr_size;
                curr_size = (curr_size + upper_limit) / 2;
            }
            curr_size = ROUND_UP(curr_size, Sys.dwPageSize);

        } while (curr_size != last_size);

        return (curr_size);
    }
    else
    {
        /* keep reducing theoretical temp file read size until it fits.
         * This iteration is an exercise directed at getting a
         * reasonable (not too large) Run_limit.  The actual temp file
         * read size will not be set until the beginning of the merge phase.
         */
        for (temp_rd_sz = Temp_buf_size - Sys.dwPageSize;
             temp_rd_sz >= Sys.dwPageSize; temp_rd_sz -= Sys.dwPageSize)
        {
            if (two_pass_fit(internal_size, Memory_limit, temp_rd_sz))
                break;
        }

        /* if it didn't even fit with the mimium temp buf read size, give up.
         */
        if (temp_rd_sz < Sys.dwPageSize)
            error(MSG_SORT_NOT_ENOUGH_MEMORY);

        return (Memory_limit);
    }
}


/* STRATEGY - determine if we have sufficent memory for a one-pass sort,
 *            or if we should optimize for a two-pass sort.
 */
void strategy()
{
    int         ptr_bytes;
    int         delta;
    unsigned    new_size;
    int         n_recs;
    int         n_internal_bytes;
    int         bytes_read;
    __int64     est_internal_size;
    __int64     est_one_pass_size;

    /* determine appropriate memory size to use
     */
    if (Input_type != FILE_TYPE_DISK)
    {
        /* Don't know the size of the input.  Allocate as much memory
         * as possible and hope it fits in either one or two passes.
         */
        new_size = Memory_limit;
        Run_limit = merge_phase_runs_allowed(new_size, Sys.dwPageSize);
    }
    else
    {
        n_recs = (int)(End_recp - Last_recp);
        n_internal_bytes = (int)(Next_rec - Rec);
        bytes_read = (int)Input_read - (int)(In_buf_limit - In_buf_next);

        /* estimate the amount of internal memory it would take to
         * hold the entire input file.
         */
        est_internal_size = (__int64)
          (((double)(n_internal_bytes + n_recs * sizeof(char *)) / bytes_read)
            * Input_size);

        /* calculate the total estimated amount of main memory for a one
         * pass sort.  Since smaller record sizes than those already sampled
         * can require additional memory (more ptrs per record byte), we will
         * bump up the estimated record and pointer size by 10%.
         */
        est_one_pass_size = (__int64)
          ((double)est_internal_size * 1.1 +
           (Rec - Alloc_begin) + Max_rec_bytes_internal + sizeof(char *));
        est_one_pass_size = ROUND_UP(est_one_pass_size, Sys.dwPageSize);

        if (User_memory_limit)
        {
            new_size = Memory_limit;    /* da user's da boss */
            Run_limit = merge_phase_runs_allowed(new_size, Sys.dwPageSize);
        }
        else if (est_one_pass_size <= Memory_limit)
        {
            new_size = (int)est_one_pass_size;  /* plan for one pass sort */
            Run_limit = 2;      /* just in case we don't make it */
        }
        else
        {
            /* find memory size for a two-pass sort
             */
            new_size = find_two_pass_mem_size(est_internal_size);
            init_two_pass();
        }

        /* if input file and sort memory will not fit in available memory,
         * access input file as unbuffered and overlapped.
         */
        if (Input_size + est_one_pass_size > Memory_limit)
        {
            if (Input_name == NULL)
                warning(MSG_SORT_REDIRECT_INPUT);
            else
            {
                /* close input file handle,
                 * reopen it handle as unbuffered and overlapped.
                 */
                CloseHandle(Input_handle);
                Input_handle =
                  CreateFile(Input_name,
                             GENERIC_READ,
                             FILE_SHARE_READ,
                             NULL,
                             OPEN_EXISTING,
                             FILE_FLAG_NO_BUFFERING | FILE_FLAG_OVERLAPPED,
                             NULL);
                if (Input_handle == INVALID_HANDLE_VALUE)
                    sys_error(Input_name, 0);
                Input_un_over = 1;
                In_max_io = MAX_IO;
            }
        }
    }
#if 0
    fprintf(stderr, "new_size: %d\n", new_size);
#endif
    assert(new_size > (unsigned)((char *)End_recp - Alloc_begin));
    if (VirtualAlloc(Alloc_begin, new_size, MEM_COMMIT, PAGE_READWRITE)
        == NULL)
    {
        error(MSG_SORT_NOT_ENOUGH_MEMORY);
    }

    /* allocate the run array and tournament tree backwards from the end
     * of the newly allocated memory.
     */
    Tree = (run_t **)(Alloc_begin + new_size - Run_limit * sizeof(run_t *));
    Run = (run_t *)((char *)Tree - Run_limit * sizeof(run_t));

    /* reallocate record pointers to end of the enlarged memory block.
     */
    delta = (int)((char **)Run - End_recp);
    ptr_bytes = (int)((char *)End_recp - (char *)Last_recp);
    memcpy(Last_recp + delta, Last_recp, ptr_bytes);
    Last_recp += delta;
    Short_recp += delta;
    End_recp += delta;
}


/* READ_INPUT - read records from the input file until there is not enough
 *              space for a maximum-length record.
 */
void read_input()
{
    /* While there is space for a maximum-length record and its pointer
     */
    while (!EOF_seen && (char *)(Last_recp - 1) - Next_rec >=
           Max_rec_bytes_internal + (int)sizeof(char *))
    {
        read_rec();
    }
}


/* SAMPLE_INPUT - read some records into the initial memory allocation
 *                so we can later analyze the records.
 */
void sample_input()
{
    /* read some input and test for unicode
     */
    test_for_unicode();

    /* Read records into the initially small memory allocation so that
     * we can calculate average record lengths.
     */
    if (!EOF_seen)
        read_input();
}


/* SORT - sort the "normal" length records in main memory.
 */
void sort()
{
    qsort(Last_recp, (unsigned)(Short_recp - Last_recp), sizeof(void *), Compare);
}


/* OUTPUT_REC - output a record to either the temporary or output file.
 */
void output_rec(char *cp)
{
    int         buf_bytes;
    int         copy_size;
    int         bsize;
    char        *rec;

    /* copy/transform record bytes into Rec_buf
     */
    rec = Rec_buf;
    if (Output_chars == CHAR_UNICODE)
    {
        bsize = wcslen((wchar_t *)cp) * sizeof(wchar_t);
        memcpy(rec, cp, bsize);

        if (Phase == INPUT_PHASE) /* if input phase and writing to temp disks */
        {
            *(wchar_t *)(rec + bsize) = L'\0';
            bsize += sizeof(wchar_t);
        }
        else
        {
            *(wchar_t *)(rec + bsize) = L'\r';
            bsize += sizeof(wchar_t);
            *(wchar_t *)(rec + bsize) = L'\n';
            bsize += sizeof(wchar_t);
        }
    }
    else
    {
        if (Output_chars == CHAR_MULTI_BYTE)
        {
            bsize = WideCharToMultiByte(CP_OEMCP, 0,
                                        (wchar_t *)cp, -1,
                                        rec, Max_rec_bytes_external,
                                        NULL, NULL);
            assert(bsize != 0);
            bsize--;    /* ignore trailing zero */
        }
        else /* Output_chars == CHAR_SINGLE_BYTE */
        {
            bsize = strlen(cp);
            memcpy(rec, cp, bsize);
        }

        if (Phase == INPUT_PHASE)     /* if input phase and writing to temp disks */
            rec[bsize++] = '\0';
        else
        {
            rec[bsize++] = '\r';
            rec[bsize++] = '\n';
        }
    }

    /* copy record bytes to output buffer and initiate a write, if necessary
     */
    buf_bytes = Out_buf_bytes;
    for (;;)
    {
        copy_size = min(bsize, Out_buf_size - buf_bytes);
        memcpy(Out_buf[Writes_issued % (Phase == INPUT_PHASE ? MAX_IO : Out_max_io)]
               + buf_bytes, rec, copy_size);
        buf_bytes += copy_size;

        if (buf_bytes < Out_buf_size)
            break;

        Out_buf_bytes = buf_bytes;
        /* if all write buffers have a write pending */
        if (Writes_completed + Out_max_io == Writes_issued)
            write_wait();
        flush_output_buf();
        buf_bytes = 0;

        bsize -= copy_size;
        if (bsize == 0)
            break;
        rec += copy_size;
    }
    Out_buf_bytes = buf_bytes;
}


/* OUTPUT_NORMAL - output records whose length is greater than the
 *                 starting compare Position.
 */
void output_normal()
{
    int         i, n;

    n = (int)(Short_recp - Last_recp);
    for (i = 0; i < n; i++)
        output_rec(Last_recp[i]);
}


/* OUTPUT_SHORTS - output records whose length is equal to or less than the
 *                 starting compare Position.
 */
void output_shorts()
{
    int         i, n;

    n = (int)(End_recp - Short_recp);
    for (i = 0; i < n; i++)
        output_rec(Short_recp[i]);
}


/* COMPLETE_WRITES - finish the writing of the temp or output file.
 */
void complete_writes()
{
    /* wait for all pending writes to complete
     */
    while (Writes_completed != Writes_issued)
        write_wait();

    /* if necessary, issue one last write (possibly unbuffered).
     */
    if (Out_buf_bytes)
    {
        flush_output_buf();
        write_wait();
    }
}


/* WRITE_RECS - write out the records which have been read from the input
 *              file into main memory, divided into "short" and "normal"
 *              records, and sorted.
 *
 *              This routine is called to either write a run of records to
 *              the temporary file during a two-pass sort (Phase == INPUT_PHASE),
 *              or to write all the records to the output file during a
 *              one-pass sort.
 */
void write_recs()
{
    if (Phase == INPUT_PHASE)   /* if writing a run to the temp file */
    {
        if (N_runs == Run_limit)
            error(MSG_SORT_NOT_ENOUGH_MEMORY);
        Run[N_runs].begin_off = Out_offset + Out_buf_bytes;
    }

    if (Reverse)
        output_normal();        /* non-short records go first */
    else
        output_shorts();        /* short records go first */

    if (Phase == INPUT_PHASE)   /* if writing a run to the temp file */
        Run[N_runs].mid_off = Out_offset + Out_buf_bytes;

    if (Reverse)
        output_shorts();        /* short records go last */
    else
        output_normal();        /* non-short records go last */

    if (Phase == INPUT_PHASE)   /* if writing a run to the temp file */
    {
        int     sector_offset;

        Run[N_runs].end_off = Out_offset + Out_buf_bytes;

        /* if not on sector boundry, get on one
         */
        sector_offset = Out_buf_bytes & (Temp_sector_size - 1);
        if (sector_offset)
            memset(Out_buf[Writes_issued % MAX_IO] + Out_buf_bytes, 0,
                   Temp_sector_size - sector_offset);
        Out_buf_bytes += Temp_sector_size - sector_offset;

        N_runs++;
    }

    complete_writes();
}


/* SCHED_RUN_READ - schedule the next temp file read for the given run.
 */
void sched_run_read(run_t *run)
{
    __int64     buf_off;
    int         rem;
    int         transfer;
    int         ret;
    async_t     *async;

    buf_off = run->begin_off + run->blks_read * Temp_buf_size;
    transfer = Temp_buf_size;
    if (transfer > run->end_off - buf_off)
    {
        transfer = (int)(run->end_off - buf_off);
        rem = transfer & (Temp_sector_size - 1);
        if (rem)
            transfer += Temp_sector_size - rem;
    }

    async = &Read_async[Reads_issued % MAX_IO];
    async->over.Offset = (int)buf_off;
    async->over.OffsetHigh = (int)(buf_off >> 32);
    async->requested = transfer;
    ResetEvent(async->over.hEvent);
    ret = ReadFile(Temp_handle, run->buf[run->blks_read % N_RUN_BUFS],
                   async->requested, &async->completed, &async->over);
    if (ret == 0 && GetLastError() != ERROR_IO_PENDING)
        sys_error(Temp_name, 0);
    Reads_issued++;
}


/* QUEUE_RUN_READ - put given run on queue of runs needing their next
 *                  temp file block read.
 */
void queue_run_read(run_t *run)
{
    /* place run on read queue
     */
    run->next = NULL;
    if (Run_read_head == NULL)
        Run_read_head = Run_read_tail = run;
    else
    {
        Run_read_tail->next = run;
        Run_read_tail = run;
    }

    /* if we can schedule a read immediately, do so.
     */
    if (Reads_issued < Reads_completed + MAX_IO)
        sched_run_read(run);
}


/* WAIT_BLK_READ - wait for the oldest-issued temp file block read to complete.
 */
void wait_blk_read()
{
    assert(Reads_issued != Reads_completed);
    WaitForSingleObject(Read_async[Reads_completed % MAX_IO].over.hEvent,
                        INFINITE);
}


/* CHECK_RUN_READS - check the temp file reads to see if there are any
 *                   have finished or need to be started.
 */
void check_run_reads()
{
    __int64     buf_off;
    async_t     *async;
    run_t       *run;
    int         ret;
    int         i;
    int         bytes_read;

    if (Reads_issued == Reads_completed)    /* if nothing happening */
        return;

    /* see if most recently issued read has completed
     */
    run = Run_read_head;
    async = &Read_async[Reads_completed % MAX_IO];
    if (async->completed == 0) /* if read didn't complete instantly */
    {
        ret = GetOverlappedResult(Temp_handle, &async->over, &bytes_read, 0);
        if (!ret)
        {
            if (GetLastError() != ERROR_IO_INCOMPLETE)
                sys_error(Temp_name, 0);
            return;     /* try again */
        }
        async->completed = bytes_read;
    }

    /* process completed read
     */
    assert(async->completed == async->requested);
    buf_off = (unsigned)async->over.Offset;
    buf_off += (__int64)async->over.OffsetHigh << 32;
    assert(buf_off == run->begin_off + run->blks_read * Temp_buf_size);

    Reads_completed++;
    run->blks_read++;
    Run_read_head = run->next;

    /* Since we just finished a read, we can schedule a new read if there
     * is an unscheduled run on the run read queue.
     */
    run = Run_read_head;
    for (i = Reads_completed; i < Reads_issued; i++)
        run = run->next;   /* skip over runs with an issued/scheduled read */
    if (run != NULL)
        sched_run_read(run);
}


/* GET_NEXT_TEMP_BUF - get the next buffer of temp file data for the given run.
 */
void get_next_temp_buf(run_t *run)
{
    assert(run->next_byte == run->buf_begin + run->buf_bytes);

    /* while the next read for this run has not completed
     */
    while (run->blks_read == run->blks_scanned)
    {
        wait_blk_read();
        check_run_reads();
    }

    run->buf_off = run->begin_off + run->blks_scanned * Temp_buf_size;
    run->buf_begin = run->buf[run->blks_scanned % N_RUN_BUFS];
    run->next_byte = run->buf_begin;
    run->buf_bytes = Temp_buf_size;
    if (run->buf_bytes > run->end_off - run->buf_off)
        run->buf_bytes = (int)(run->end_off - run->buf_off);
    run->blks_scanned++;
    assert(run->blks_scanned <= run->blks_read);

    /* if there is another block to be read for this run, queue it up.
     */
    if (run->begin_off + run->blks_read * Temp_buf_size < run->end_off)
        queue_run_read(run);
}


/* READ_TEMP_REC - read the next record from the temporary file for the
 *                 given run.
 */
int read_temp_rec(run_t *run)
{
    char        *begin;
    char        *limit;
    char        *cp;
    wchar_t     *wp;
    int         bsize;
    int         char_count;
    int         rec_buf_bytes;
    int         delimiter_found;

    /* if the current read offset is up to the end offset, return false.
     */
    if (run->buf_off + (run->next_byte - run->buf_begin) >= run->end_read_off)
        return (0);

    /* if input buffer is empty
     */
    if (run->next_byte == run->buf_begin + run->buf_bytes)
        get_next_temp_buf(run);
    begin = run->next_byte;
    limit = run->buf_begin + run->buf_bytes;

    /* loop until we have scanned the next record
     *
     * when we exit the following loop:
     * - "begin" will point to the scanned record (either in the original
     *   input buffer or in Rec_buf)
     * - "bsize" will contain the number of bytes in the record.
     */
    cp = begin;
    delimiter_found = 0;
    rec_buf_bytes = 0;
    for (;;)
    {
        /* potentially adjust scan limit because of maximum record length
         */
        if (limit > cp + Max_rec_bytes_external - rec_buf_bytes)
            limit = cp + Max_rec_bytes_external - rec_buf_bytes;

        if (Input_chars == CHAR_UNICODE)
        {
            wp = (wchar_t *)cp;
            while (wp < (wchar_t *)limit && *wp != '\0')
            {
                wp++;
            }
            cp = (char *)wp;
            bsize = (int)(cp - begin);
            if (cp == limit)  /* didn't find delimiter, ran out of input */
                run->next_byte = (char *)wp;
            else
            {
                delimiter_found = 1;
                run->next_byte = (char *)(wp + 1);
            }
        }
        else    /* single or multi byte input */
        {
            while (cp < limit && *cp != '\0')
                cp++;
            bsize = (int)(cp - begin);
            if (cp == limit)  /* didn't find delimiter, ran out of input */
                run->next_byte = cp;
            else
            {
                delimiter_found = 1;
                run->next_byte = cp + 1;
            }
        }

        /* if we didn't find the delimiter or we have already stored
         * the beginning portion of the record in Rec_buf.
         */
        if (!delimiter_found || rec_buf_bytes)
        {
            /* copy the portion of the record into Rec_buf
             */
            if (rec_buf_bytes + bsize >= Max_rec_bytes_external)
                error(MSG_SORT_REC_TOO_BIG);
            memcpy((char *)Rec_buf + rec_buf_bytes, begin, bsize);
            rec_buf_bytes += bsize;

            if (!delimiter_found)
            {
                /* read another input buffer
                 */
                get_next_temp_buf(run);

                cp = begin = run->next_byte;
                limit = run->buf_begin + run->buf_bytes;
                continue;       /* scan some more to find record delimiter */
            }

            /* set begin and size of record in Rec_buf
             */
            begin = Rec_buf;
            bsize = rec_buf_bytes;
            break;
        }
        else /* found delimiter && haven't store a record prefix in Rec_buf */
            break;
    }

    /* copy scanned record into internal storage
     */
    cp = run->rec;
    if (Input_chars == CHAR_SINGLE_BYTE)
    {
        memcpy(run->rec, begin, bsize);
        char_count = bsize;
        cp[char_count] = 0;
    }
    else
    {
        if (Input_chars == CHAR_UNICODE)
        {
            memcpy(run->rec, begin, bsize);
            char_count = bsize / sizeof(wchar_t);
        }
        else    /* CHAR_MULTI_BYTE */
        {
            if (bsize)
            {
                char_count = MultiByteToWideChar(CP_OEMCP, 0,
                                                 begin, bsize,
                                                 (wchar_t *)run->rec,
                                                 Max_rec_length);
                if (char_count == 0)
                    error(MSG_SORT_CHAR_CONVERSION);
            }
        }
        wp = (wchar_t *)run->rec;
        wp[char_count] = 0;
    }

    return (1);
}


/* COPY_SHORTS - copy the "short" records for each run to the output file.
 */
void copy_shorts()
{
    unsigned int    i;
    run_t           *run;

    for (i = 0; i < N_runs; i++)
    {
        run = &Run[i];
        while (read_temp_rec(run))
            output_rec(run->rec);
    }
}


/* TREE_INSERT - insert a next record for the given run into the
 *               tournament tree.
 */
run_t *tree_insert(run_t *run, int not_empty)
{
    int         i;
    run_t       **node;
    run_t       *winner;
    run_t       *temp;
    int         (_cdecl *compare)(const void *, const void *);

    compare = Compare;

    winner = (not_empty ? run : END_OF_RUN);

    /* start at the bottom of the tournament tree, work up the the top
     * comparing the current winner run with the runs on the path to the
     * top of the tournament tree.
     */
    for (i = (run->index + N_runs) / 2; i != 0; i >>= 1)
    {
        node = &Tree[i];

        /* empty tree nodes get filled immediately, and we're done with the
         * insertion as all node above this one must be empty also.
         */
        if (*node == NULL_RUN)
        {
            *node = winner;
            return (NULL_RUN);
        }

        /* if run at current tree node has reached its end, it loses (no swap).
         */
        if (*node == END_OF_RUN)
            continue;
        else if (winner == END_OF_RUN)
        {
            /* current winner run has reached the end of its records,
             * swap and contine.
             */
            winner = *node;
            *node = END_OF_RUN;
        }
        else
        {
            /* both the winner run and the run at the current node have
             * a record.  Compare records and swap run pointer if necessary.
             */
            if (compare((void *)&winner->rec, (void *)&(*node)->rec) > 0)
            {
                temp = winner;
                winner = *node;
                *node = temp;
            }
        }
    }

    return (winner);
}


/* MERGE_RUNS - merge the runs in the temporary file to produce a stream of
 *              "normal"-length records to be written to the output file.
 */
void merge_runs()
{
    unsigned int    i;
    run_t           *run;

    /* initialize all tree nodes to be empty
     */
    for (i = 0; i < N_runs; i++)
        Tree[i] = NULL_RUN;

    /* fill tree with all runs except for the first
     */
    for (i = 1; i < N_runs; i++)
    {
        run = &Run[i];
        run = tree_insert(run, read_temp_rec(run));
        assert(run == NULL_RUN);
    }

    /* replacement-selection main loop
     */
    run = &Run[0];
    for (i = 0; ; i++)
    {
        /* replace winner record by inserting next record from the same
         * run into the tournament tree.
         */
        run = tree_insert(run, read_temp_rec(run));
        if ( (run == END_OF_RUN) ||
             (run == NULL_RUN) )
        {
            break;
        }
        output_rec(run->rec);   /* output winner record */
        if ((i & 0xff) == 0)
            check_run_reads();  /* periodically check run reads */
    }
}


/* MERGE_PASS - execute the merge pass of a two-pass sort.
 */
void merge_pass()
{
    unsigned int    i, j;
    int             per_run_mem;
    int             read_buf_size;

    per_run_mem = (int)(((char *)Run - Merge_phase_run_begin) / N_runs);
    read_buf_size = (per_run_mem - Max_rec_bytes_internal) / N_RUN_BUFS;
    read_buf_size = ROUND_DOWN(read_buf_size, Sys.dwPageSize);
    if (read_buf_size == 0)
        error(MSG_SORT_NOT_ENOUGH_MEMORY);
    if (read_buf_size > MAX_XFR_SIZE)
        read_buf_size = MAX_XFR_SIZE;
    if (Temp_buf_size > read_buf_size)
        Temp_buf_size = read_buf_size; /* adjust only if reduction */
#if 0
    fprintf(stderr, "merge phase adjustment: %d to %d\n",
            Output_buf_size, Temp_buf_size);
    fprintf(stderr, "N_runs: %d, Run_limit: %d\n", N_runs, Run_limit);
#endif
    /* initialize each run
     */
    for (i = 0; i < N_runs; i++)
    {
        Run[i].index = i;
        for (j = 0; j < N_RUN_BUFS; j++)
            Run[i].buf[j] = Merge_phase_run_begin +
              (i * N_RUN_BUFS + j) * Temp_buf_size;
        Run[i].next_byte = Run[i].buf_begin = Run[i].buf[0];
        Run[i].buf_off = Run[i].begin_off;
        Run[i].buf_bytes = 0;
        Run[i].end_read_off = Run[i].mid_off;
        Run[i].rec = Merge_phase_run_begin +
          (N_runs * N_RUN_BUFS * Temp_buf_size) + (i * Max_rec_bytes_internal);
        Run[i].blks_read = Run[i].blks_scanned = 0;
        Run[i].next = NULL;
        queue_run_read(&Run[i]);    /* queue a read of run's first block */
    }

    if (Reverse)
        merge_runs();
    else
        copy_shorts();

    /* adjust temp file ending offsets for each run to include the second
     * "half" of each run.
     */
    for (i = 0; i < N_runs; i++)
        Run[i].end_read_off = Run[i].end_off;

    if (Reverse)
        copy_shorts();
    else
        merge_runs();

    CloseHandle(Temp_handle);

    complete_writes();
}


/* CLEAR_RUN - clear the records from memory for the run just written to
 *              the temporary file.
 */
void clear_run()
{
    Last_recp = Short_recp = End_recp;
    Next_rec = Rec;
}


/* SET_LOCALE
 */
void set_locale()
{
    if (Locale == NULL)
        setlocale(LC_ALL, "");  /* use system-default locale */
    else if (strcmp(Locale, "C"))
        error(MSG_SORT_INVALID_LOCALE);
}


/* MAIN
 */
int
_cdecl main(int argc, char *argv[])
{
    Phase = INPUT_PHASE;

    read_args(argc, argv);

    set_locale();

    init_input_output();

    init_mem();

    sample_input();

    if (!EOF_seen)
        strategy();

    /* generate run(s) */
    do
    {
        if (!EOF_seen)
            read_input();

        if (Last_recp == End_recp)  /* if no records were read, ignore run */
            break;

        sort();

        if (!Two_pass)
        {
            if (EOF_seen)
                break;
            else
                init_two_pass();
        }

        write_recs();

        clear_run();

    } while (!EOF_seen);

    Phase = OUTPUT_PHASE;
    review_output_mode();

    if (Two_pass)
        merge_pass();
    else
        write_recs();
    CloseHandle(Output_handle);

    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\sort\resource.h ===
#define SORT_USAGE_FIRST	100
#define SORT_USAGE_2		101
#define SORT_USAGE_3		102
#define SORT_USAGE_5		103
#define SORT_USAGE_6		104
#define SORT_USAGE_7		105
#define SORT_USAGE_8		106
#define SORT_USAGE_9		107
#define SORT_USAGE_10		108
#define SORT_USAGE_11		109
#define SORT_USAGE_12		110
#define SORT_USAGE_13		111
#define SORT_USAGE_14		112
#define SORT_USAGE_15		113
#define SORT_USAGE_16		114
#define SORT_USAGE_17		115
#define SORT_USAGE_18		116
#define SORT_USAGE_19		117
#define SORT_USAGE_20		118
#define SORT_USAGE_21		119
#define SORT_USAGE_22		120
#define SORT_USAGE_23		121
#define SORT_USAGE_24		122
#define SORT_USAGE_25		123
#define SORT_USAGE_26		124
#define SORT_USAGE_27		125
#define SORT_USAGE_28		126
#define SORT_USAGE_29		127
#define SORT_USAGE_30		128
#define SORT_USAGE_31		129
#define SORT_USAGE_32		130
#define SORT_USAGE_33		131
#define SORT_USAGE_34		132
#define SORT_USAGE_35		133
#define SORT_USAGE_36		134
#define SORT_USAGE_37		135
#define SORT_USAGE_38		136
#define SORT_USAGE_39		137
#define SORT_USAGE_40		138
#define SORT_USAGE_41		139
#define SORT_USAGE_42		140
#define SORT_USAGE_43		141
#define SORT_USAGE_44		142
#define SORT_USAGE_45		143
#define SORT_USAGE_46		144
#define SORT_USAGE_47		145
#define SORT_USAGE_48		146
#define SORT_USAGE_49		147
#define SORT_USAGE_50		148
#define SORT_USAGE_51		149
#define SORT_USAGE_52		150
#define SORT_USAGE_53		151
#define SORT_USAGE_54		152
#define SORT_USAGE_LAST		153

#define SORT_REC_TOO_BIG	200
#define SORT_INVALID_LOCALE	201
#define SORT_POSITION		202
#define SORT_INVALID_SWITCH	203
#define SORT_MAX_TOO_LARGE	204
#define SORT_ONE_INPUT		205
#define SORT_CHAR_CONVERSION	206
#define SORT_NOT_ENOUGH_MEMORY	207

#define SORT_REDIRECT_INPUT	300
#define SORT_REDIRECT_OUTPUT	301
#define SORT_MEM_TOO_LOW	302
#define SORT_MEM_GT_PAGE	303

#define SORT_INPUT_FILE		400
#define SORT_OUTPUT_FILE	401
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\tuneup\cleanup.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// CLEANUP.CPP / Tuneup
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  Functions for the cleanup manager task wizard page.
//
//  8/98 - Jason Cohen (JCOHEN)
//
//////////////////////////////////////////////////////////////////////////////


// Internal include files.
//
#include <windows.h>
#include <tchar.h>
//#include <initguid.h>
#include <emptyvc.h>


BOOL GetCleanupSettings(HWND hLB)
{
    HKEY				hKeyVolCache,
						hClientKey;
	CLSID				clsid;
	LPEMPTYVOLUMECACHE	pVolumeCache;
	LPWSTR				wcsDisplayName,
						wcsDescription;
	TCHAR				szRegKeyName[64];
    DWORD				iSubKey;
    TCHAR				szVolCacheClient[MAX_PATH];
    TCHAR				szGUID[MAX_PATH];
    DWORD				dwGUIDSize,
						dwType,
						dwSize,
						dwRes;
    BOOL				bRet = TRUE;
	TCHAR				szDisplayName[128];
	static TCHAR		szRoot[] = _T("c:\\");
	static TCHAR		szRegVolumeCache[] = _T("Software\\Microsoft\\Windows\\CurrentVersion\\explorer\\VolumeCaches");

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szRegVolumeCache, 0, KEY_READ, &hKeyVolCache) != ERROR_SUCCESS) 
		return FALSE;

    // Enumerate through all of the clients to see how large we need to make the pClientInfo array
    //
    iSubKey = 0;
    while ( RegEnumKey(hKeyVolCache, iSubKey, szVolCacheClient, sizeof(szVolCacheClient)) != ERROR_NO_MORE_ITEMS ) 
        iSubKey++;        
    
	// Fill in the pClientInfo data structure and initialize all of the volume cache clients
	//
    iSubKey = 0;
    while ( RegEnumKey(hKeyVolCache, iSubKey++, szVolCacheClient, sizeof(szVolCacheClient)) != ERROR_NO_MORE_ITEMS )
	{
        if ( RegOpenKeyEx(hKeyVolCache, szVolCacheClient, 0, KEY_ALL_ACCESS, &hClientKey) != ERROR_SUCCESS )
			continue;

		lstrcpy(szRegKeyName, szVolCacheClient);

		// Check whether the StateFlags is non zero.
		//
		wsprintf(szDisplayName, _T("StateFlags%04d"), 0);
		dwSize = sizeof(DWORD);
		dwType = REG_DWORD;
		dwRes = 0;
		if ( RegQueryValueEx(hClientKey, szDisplayName, NULL, &dwType, (LPBYTE)&dwRes, &dwSize) == ERROR_SUCCESS )
		{
			// StateFlags overrides the flags got from Initialize(), so if it's set explicitly
			// as 0, then it's not a selected cleaner.
			//
			if (dwRes == 0)
				goto next;
		}
        
        // Get its GUID, call Initialize method to get the display name.
		//
		dwGUIDSize = sizeof(szGUID);
        dwType = REG_SZ;
        if ( RegQueryValueEx(hClientKey, NULL, NULL, &dwType, (LPBYTE)szGUID, &dwGUIDSize) == ERROR_SUCCESS )
		{
            HRESULT hr;
            WCHAR   wcsFmtID[39];
            WCHAR	wcsRoot[MAX_PATH];

#ifdef _UNICODE
			lstrcpy(wcsFmtID, szGUID);
#else // _UNICODE
            // Convert to Unicode.
			//
            MultiByteToWideChar(CP_ACP, 0, szGUID, -1, wcsFmtID, 39) ;
#endif // _UNICODE
            
            // Convert to GUID.
			//
            hr = CLSIDFromString((LPOLESTR)wcsFmtID, &clsid);
            
			*szDisplayName = 0;

            // Create an instance of the COM object for this cleanup client
			//
            pVolumeCache = NULL;
            hr = CoCreateInstance(clsid,
								  NULL,
								  CLSCTX_INPROC_SERVER,
								  IID_IEmptyVolumeCache,
								  (void **) &pVolumeCache);
                                                
            if ( SUCCEEDED(hr) )
			{
				// Set the flags to pass to the cleanup client.
				//
				DWORD dwInitializeFlags = EVCF_SETTINGSMODE;

#ifdef _UNICODE
				lstrcpy(wcsRoot, szRoot);
#else // _UNICODE
				// Convert szRoot to UNICODE.
				//
				MultiByteToWideChar(CP_ACP, 0, szRoot, -1, wcsRoot, MAX_PATH);
#endif // _UNICODE

                hr = pVolumeCache->Initialize(hClientKey,
											  (LPCWSTR) wcsRoot,
											  &((LPWSTR) wcsDisplayName),
											  &((LPWSTR) wcsDescription),
											  &dwInitializeFlags);

				if ( (dwRes == 0) && !(dwInitializeFlags & EVCF_ENABLEBYDEFAULT_AUTO) )
					// dwRes is 0 and still reach here, means there's no StateFlags, we 
					// reference the dwInitializeFlags at this case
					//
					goto next;

                if ( SUCCEEDED(hr) && (S_OK == hr) && wcsDisplayName)
#ifdef _UNICODE
					lstrcpy(szDisplayName, wcsDisplayName);
#else // _UNICODE
					WideCharToMultiByte(CP_ACP, 0, wcsDisplayName, -1, szDisplayName, 128, NULL, NULL);
#endif // _UNICODE
				else
				{
					// If the client did not return the DisplayName via the Initialize
					// Interface then we need to get it from the registry.

					// First check if their is a "display" value for the client's 
					// name that is displayed in the list box.  If not then use
					// the key name itself.
					//
					dwSize = 128;
					dwType = REG_SZ;
					if ( RegQueryValueEx(hClientKey, _T("display"), NULL, &dwType, (LPBYTE)szDisplayName, &dwSize) != ERROR_SUCCESS )
						// Count not find "display" value so use the key name instead.
						//
						lstrcpy(szDisplayName, szVolCacheClient);
             	}
			}

			if (*szDisplayName)
				SendMessage(hLB, LB_ADDSTRING, 0, (LPARAM)szDisplayName);
		}
next:
		RegCloseKey(hClientKey);
	}
        
	RegCloseKey(hKeyVolCache);
	return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\subst\subst.cxx ===
/*++

Copyright (c) 1992-2000 Microsoft Corporation

Module Name:

        subst.cxx

Abstract:

        Utility to associate a path to a drive letter

Author:

        THERESES 12-August-1992

Revision History:

--*/

#define _NTAPI_ULIB_

#include "ulib.hxx"
#include "arg.hxx"
#include "array.hxx"
#include "smsg.hxx"
#include "rtmsg.h"
#include "wstring.hxx"
#include "path.hxx"
#include "substrng.hxx"
#include "system.hxx"
#include "ulibcl.hxx"
#include "subst.hxx"
#include "dir.hxx"

#include "ntrtl.h"

BOOLEAN
QuerySubstedDrive(
    IN  DWORD   DriveNumber,
    OUT LPWSTR  PhysicalDrive,
    IN  DWORD   PhysicalDriveLength,
    IN  LPDWORD DosError
    );

VOID
DisplaySubstUsage(
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This routine displays the usage for the dos 5 label program.

Arguments:

    Message - Supplies an outlet for the messages.

Return Value:

    None.

--*/
{
    Message->Set(MSG_SUBST_INFO);
    Message->Display("");
    Message->Set(MSG_SUBST_USAGE);
    Message->Display("");
}

BOOLEAN
DeleteSubst(
    IN LPWSTR Drive,
    IN OUT PMESSAGE Message
    )
{
    BOOL    Success;
    FSTRING AuxString;

    DWORD   Status;
    WCHAR   Buffer[ MAX_PATH + 8 ];

    Success = QuerySubstedDrive( *Drive - ( WCHAR )'@',
                                 Buffer,
                                 sizeof( Buffer ) / sizeof( WCHAR ),
                                 &Status );

    if( Success ) {
        Success = DefineDosDevice( DDD_REMOVE_DEFINITION,
                                   Drive,
                                   NULL );
        if( !Success ) {
            Status = GetLastError();
        }
    }
    if (!Success) {
        if( Status == ERROR_ACCESS_DENIED ) {
            AuxString.Initialize( Drive );
            Message->Set(MSG_SUBST_ACCESS_DENIED);
            Message->Display("%W",&AuxString);
        } else {
            AuxString.Initialize( Drive );
            Message->Set(MSG_SUBST_INVALID_PARAMETER);
            Message->Display("%W",&AuxString);
        }
    }
    return Success != FALSE;
}

BOOLEAN
AddSubst(
    IN LPWSTR Drive,
    IN LPWSTR PhysicalDrive,
    IN DWORD PhysicalDriveLength,
    IN OUT PMESSAGE Message
    )
{
    DWORD           Status;
    FSTRING         AuxString;

    WCHAR   Buffer[ MAX_PATH + 8 ];

    if( !QuerySubstedDrive( Drive[0] - '@',
                            Buffer,
                            sizeof( Buffer ) / sizeof( WCHAR ),
                            &Status ) ) {
        if( Status == ERROR_FILE_NOT_FOUND ) {
            if ( wcslen(PhysicalDrive) == 3 &&
                 PhysicalDrive[1] == ':' &&
                 PhysicalDrive[2] == '\\' &&
                 PhysicalDrive[3] == 0 ) {

                UNICODE_STRING      string;

                if ( !RtlDosPathNameToNtPathName_U(PhysicalDrive, &string, NULL, NULL) ) {
                    Status = GetLastError();
                } else {
                    string.Buffer[string.Length/sizeof(string.Buffer[0]) - 1] = 0;
                    if ( !DefineDosDevice(DDD_RAW_TARGET_PATH, Drive, string.Buffer) ) {
                        Status = GetLastError();
                    } else {
                        Status = ERROR_SUCCESS;
                    }
                    RtlFreeUnicodeString(&string);
                }
            } else if( !DefineDosDevice( 0, Drive, PhysicalDrive ) ) {
                Status = GetLastError();
            } else {
                Status = ERROR_SUCCESS;
            }
        }
    } else {
        Status = ERROR_IS_SUBSTED;
    }

    if( Status != ERROR_SUCCESS ) {
        if( Status == ERROR_IS_SUBSTED ) {
            Message->Set(MSG_SUBST_ALREADY_SUBSTED);
            Message->Display("");
        } else if (Status == ERROR_FILE_NOT_FOUND) {
            AuxString.Initialize( PhysicalDrive );
            Message->Set(MSG_SUBST_PATH_NOT_FOUND);
            Message->Display("%W", &AuxString);
        } else if (Status == ERROR_ACCESS_DENIED) {
            AuxString.Initialize( PhysicalDrive );
            Message->Set(MSG_SUBST_ACCESS_DENIED);
            Message->Display("%W", &AuxString);
        } else {
            AuxString.Initialize( Drive );
            Message->Set(MSG_SUBST_INVALID_PARAMETER);
            Message->Display("%W", &AuxString );
        }
        return( FALSE );
    } else {
        return( TRUE );
    }
}

BOOLEAN
QuerySubstedDrive(
    IN  DWORD    DriveNumber,
    OUT LPWSTR   PhysicalDrive,
    IN  DWORD    PhysicalDriveLength,
    IN  LPDWORD  DosError
    )
{
    WCHAR   DriveName[3];
    FSTRING DosDevicesPattern;
    FSTRING DeviceName;
    CHNUM   Position;

    DriveName[0] = ( WCHAR )( DriveNumber + '@' );
    DriveName[1] = ( WCHAR )':';
    DriveName[2] = ( WCHAR )'\0';

    if( QueryDosDevice( DriveName,
                        PhysicalDrive,
                        PhysicalDriveLength ) != 0 ) {
        DosDevicesPattern.Initialize( (LPWSTR)L"\\??\\" );
        DeviceName.Initialize( PhysicalDrive );
        Position = DeviceName.Strstr( &DosDevicesPattern );
        if( Position == 0 ) {
            DeviceName.DeleteChAt( 0, DosDevicesPattern.QueryChCount() );
            *DosError = ERROR_SUCCESS;
            return( TRUE );
        } else {
            //
            //  This is not a Dos device
            //
            *DosError = ERROR_INVALID_PARAMETER;
            return( FALSE );
        }
    } else {
        *DosError = GetLastError();
        return( FALSE );
    }
}

VOID
DumpSubstedDrives (
    IN OUT PMESSAGE Message
    )
{
    DSTRING Source;
    WCHAR LinkBuffer[MAX_PATH + 8];
    DWORD i;
    FSTRING AuxString;
    DWORD   ErrorCode;

    Source.Initialize(L"D:\\");
    Message->Set(MSG_SUBST_SUBSTED_DRIVE);
    for (i=1;i<=MAXIMUM_DRIVES;i++) {
        if (QuerySubstedDrive(i,LinkBuffer,sizeof(LinkBuffer),&ErrorCode)) {
            Source.SetChAt((WCHAR)(i+'@'),0);
            if (wcslen(LinkBuffer) == 2 &&
                LinkBuffer[1] == ':' &&
                LinkBuffer[2] == 0) {
                LinkBuffer[2] = '\\';
                LinkBuffer[3] = 0;
            }
            AuxString.Initialize( LinkBuffer );
            Message->Display("%W%W", &Source, &AuxString);
        }
    }
}

INT
__cdecl
main(
    )
/*++

Routine Description:

    This routine emulates the dos 5 subst command for NT.

Arguments:

    None.

Return Value:

    1   - An error occured.
    0   - Success.

--*/
{
    STREAM_MESSAGE      msg;
    ARGUMENT_LEXEMIZER  arglex;
    ARRAY               lex_array;
    ARRAY               arg_array;
    STRING_ARGUMENT     progname;
    PATH_ARGUMENT       virtualdrive_arg;
    PATH_ARGUMENT       physicaldrive_arg;
    FLAG_ARGUMENT       help_arg;
    FLAG_ARGUMENT       delete_arg;
    PWSTRING            p;
    BOOL                Success=TRUE;


    if (!msg.Initialize(Get_Standard_Output_Stream(),
                        Get_Standard_Input_Stream(),
                        Get_Standard_Error_Stream())) {
        return 1;
    }

    if (!lex_array.Initialize() || !arg_array.Initialize()) {
        return 1;
    }

    if (!arglex.Initialize(&lex_array)) {
        return 1;
    }

    arglex.PutSwitches( "/" );
    arglex.PutStartQuotes( "\"" );
    arglex.PutEndQuotes( "\"" );
    arglex.PutSeparators( " \t" );
    arglex.SetCaseSensitive(FALSE);

    if (!arglex.PrepareToParse()) {
        return 1;
    }

    if ( !arg_array.Initialize() ) {
        return 1;
    }

    if (!progname.Initialize("*") ||
        !help_arg.Initialize("/?") ||
        !virtualdrive_arg.Initialize("*", FALSE) ||
        !physicaldrive_arg.Initialize("*",FALSE) ||
        !delete_arg.Initialize("/D") ) {
        return 1;
    }

    if (!arg_array.Put(&progname) ||
        !arg_array.Put(&virtualdrive_arg) ||
        !arg_array.Put(&physicaldrive_arg) ||
        !arg_array.Put(&help_arg) ||
        !arg_array.Put(&delete_arg) ) {
        return 1;
    }

    if (!arglex.DoParsing(&arg_array)) {
        if (arglex.QueryLexemeCount() > MAXIMUM_SUBST_ARGS) {
            msg.Set(MSG_SUBST_TOO_MANY_PARAMETERS);
            msg.Display("%W", p = arglex.GetLexemeAt(MAXIMUM_SUBST_ARGS));
        } else {
            msg.Set(MSG_SUBST_INVALID_PARAMETER);
            msg.Display("%W", p = arglex.QueryInvalidArgument());
        }
        DELETE(p);
        return 1;
    }

    if (help_arg.QueryFlag()) {
        DisplaySubstUsage(&msg);
        return 0;
    }

    if (delete_arg.IsValueSet() &&
        virtualdrive_arg.IsValueSet() &&
        physicaldrive_arg.IsValueSet()) {
        msg.Set(MSG_SUBST_TOO_MANY_PARAMETERS);
        msg.Display("%W", delete_arg.GetPattern() );
        return 1;
    }

    if (delete_arg.IsValueSet() &&
        !virtualdrive_arg.IsValueSet() &&
        !physicaldrive_arg.IsValueSet()) {
        msg.Set(MSG_SUBST_INVALID_PARAMETER);
        msg.Display("%W", delete_arg.GetPattern());
        return 1;
    }

    //
    //  Validate virtual drive
    //  A virtual drive MUST have the format  <drive letter>:
    //  Anything that doesn't have this format is considered an invalid parameter
    //
    if( virtualdrive_arg.IsValueSet() &&
        ( ( virtualdrive_arg.GetPath()->GetPathString()->QueryChCount() != 2 ) ||
          ( virtualdrive_arg.GetPath()->GetPathString()->QueryChAt( 1 ) != ( WCHAR )':' ) )
      ) {
        msg.Set(MSG_SUBST_INVALID_PARAMETER);
        msg.Display("%W", virtualdrive_arg.GetPath()->GetPathString() );
        return 1;
    }

    //
    //  Validate physical drive
    //  A physical drive CANNOT have the format  <drive letter>:
    //
    if( physicaldrive_arg.IsValueSet() &&
        ( physicaldrive_arg.GetPath()->GetPathString()->QueryChCount() == 2 ) &&
        ( physicaldrive_arg.GetPath()->GetPathString()->QueryChAt( 1 ) == ( WCHAR )':' )
      ) {
        msg.Set(MSG_SUBST_INVALID_PARAMETER);
        msg.Display("%W", physicaldrive_arg.GetPath()->GetPathString() );
        return 1;
    }

//
    if (virtualdrive_arg.IsValueSet()) {
        DSTRING         virtualdrivepath;
        DSTRING         colon;
        PATH            TmpPath;
        PFSN_DIRECTORY  Directory;

        virtualdrivepath.Initialize(virtualdrive_arg.GetPath()->GetPathString());
        if (virtualdrivepath.Strupr() ) {
            if (delete_arg.IsValueSet()) {
                Success = DeleteSubst(virtualdrivepath.QueryWSTR(),&msg);
            } else if (physicaldrive_arg.IsValueSet()) {
                LPWSTR physicaldrivepath;

                //
                // verify that the physical drive is an accessible path
                //
                Directory = SYSTEM::QueryDirectory( physicaldrive_arg.GetPath() );
                if( !Directory ) {
                    msg.Set(MSG_SUBST_PATH_NOT_FOUND);
                    msg.Display("%W", physicaldrive_arg.GetPath()->GetPathString());
                    return 1;
                }
                DELETE( Directory );
                TmpPath.Initialize( physicaldrive_arg.GetPath(), TRUE );
                physicaldrivepath = ( TmpPath.GetPathString() )->QueryWSTR();
                Success = AddSubst(virtualdrivepath.QueryWSTR(),
                                   physicaldrivepath,
                                   ( TmpPath.GetPathString() )->QueryChCount(),
                                   &msg
                                  );
                DELETE(physicaldrivepath);
            } else {
                msg.Set(MSG_SUBST_INVALID_PARAMETER);
                msg.Display("%W", p = arglex.GetLexemeAt(1));
                DELETE(p);
                return 1;
            }
        }
    } else {
        if (arglex.QueryLexemeCount() > 1) {
            msg.Set(MSG_SUBST_INVALID_PARAMETER);
            msg.Display("%W", p = arglex.GetLexemeAt(1));
            DELETE(p);
            return 1;
        } else {
            DumpSubstedDrives(&msg);
        }
    }

    return !Success;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\tree\tree.cxx ===
/*++

Copyright (c) 1991-2000  Microsoft Corporation

Module Name:

        tree.cxx

Abstract:

        This module contains the implementation of the TREE class.
        The TREE class implements a tree utility functionally compatible
        with the DOS 5 tree utility.
        This utility displays the directory structure of a path or drive.

        Usage:

                TREE [drive:][path] [/F] [/A] [/?]

                        /F      Display the names of files in each directory.

                        /A      Uses ASCII instead of extended characters.

                        /?      Displays a help message.


Author:

        Jaime F. Sasson - jaimes - 13-May-1991

Environment:

        ULIB, User Mode

--*/

#include "ulib.hxx"
#include "arg.hxx"
#include "array.hxx"
#include "path.hxx"
#include "wstring.hxx"
#include "substrng.hxx"
#include "dir.hxx"
#include "filter.hxx"
#include "system.hxx"
#include "arrayit.hxx"
#include "smsg.hxx"
#include "stream.hxx"
#include "rtmsg.h"
#include "tree.hxx"

extern "C" {
#include <stdio.h>
#include <string.h>
}


#define UNICODE_SINGLE_LEFT_T               0x251c
#define UNICODE_SINGLE_BOTTOM_LEFT_CORNER   0x2514
#define UNICODE_SINGLE_BOTTOM_HORIZONTAL    0x2500
#define UNICODE_SINGLE_VERTICAL             0x2502
#define UNICODE_SPACE                       0x0020


PSTREAM Get_Standard_Input_Stream();
PSTREAM Get_Standard_Output_Stream();

DEFINE_CONSTRUCTOR( TREE, PROGRAM );


BOOLEAN
TREE::Initialize(
        )

/*++

Routine Description:

        Initializes a TREE class.

Arguments:

        None.

Return Value:

        BOOLEAN - Indicates if the initialization succeeded.


--*/


{
    ARGUMENT_LEXEMIZER  ArgLex;
    ARRAY               LexArray;

    ARRAY               ArgumentArray;

    STRING_ARGUMENT     ProgramNameArgument;
    PATH_ARGUMENT       DirectoryPathArgument;
    PWSTRING            DirectoryNameString;
    PATH                DirectoryNamePath;
    PWSTRING            InvalidArgument;
    PCWSTRING           InvalidPath;
    STRING_ARGUMENT     InvalidSwitch;
    PATH                AuxPath;
    STRING_ARGUMENT     ParamNotCorrectFile;
    STRING_ARGUMENT     ParamNotCorrectAscii;
    STRING_ARGUMENT     ParamNotCorrectHelp;
    BOOLEAN             FlagInvalidPath;
    PATH                AuxInvPath;
    PWSTRING            InvPathNoDrive;
    PWSTRING            Device;
    PATH                DevPth;
    PFSN_DIRECTORY      DevDir;
#ifdef FE_SB
    PWCHAR              BufferMiddleBranch;
    PWCHAR              BufferBottomBranch;
    PWCHAR              BufferConnectingBranch;

    WCHAR               BufferMiddleBranchDBCS[] = {
                                               UNICODE_SINGLE_LEFT_T,            // 2
                                               UNICODE_SINGLE_BOTTOM_HORIZONTAL, // 2
                                               UNICODE_NULL                      // 0
                                               };
    WCHAR               BufferBottomBranchDBCS[] = {
                                               UNICODE_SINGLE_BOTTOM_LEFT_CORNER, // 2
                                               UNICODE_SINGLE_BOTTOM_HORIZONTAL,  // 2
                                               UNICODE_NULL                       // 0
                                               };

    WCHAR               BufferConnectingBranchDBCS[] = {
                                               UNICODE_SINGLE_VERTICAL, // 2
                                               UNICODE_SPACE,           // 1
                                               UNICODE_SPACE,           // 1
                                               UNICODE_NULL             // 0
                                               };

    WCHAR               BufferMiddleBranchSBCS[] = {
                                               UNICODE_SINGLE_LEFT_T,
                                               UNICODE_SINGLE_BOTTOM_HORIZONTAL,
                                               UNICODE_SINGLE_BOTTOM_HORIZONTAL,
                                               UNICODE_SINGLE_BOTTOM_HORIZONTAL,
                                               UNICODE_NULL
                                               };
    WCHAR               BufferBottomBranchSBCS[] = {
                                               UNICODE_SINGLE_BOTTOM_LEFT_CORNER,
                                               UNICODE_SINGLE_BOTTOM_HORIZONTAL,
                                               UNICODE_SINGLE_BOTTOM_HORIZONTAL,
                                               UNICODE_SINGLE_BOTTOM_HORIZONTAL,
                                               UNICODE_NULL
                                               };

    WCHAR               BufferConnectingBranchSBCS[] = {
                                               UNICODE_SINGLE_VERTICAL,
                                               UNICODE_SPACE,
                                               UNICODE_SPACE,
                                               UNICODE_SPACE,
                                               UNICODE_NULL
                                               };

    switch ( ::GetConsoleOutputCP() ) {
        case 932:
        case 936:
        case 949:
        case 950:
            BufferMiddleBranch = BufferMiddleBranchDBCS;
            BufferBottomBranch = BufferBottomBranchDBCS;
            BufferConnectingBranch = BufferConnectingBranchDBCS;
            break;

        default:

            BufferMiddleBranch = BufferMiddleBranchSBCS;
            BufferBottomBranch = BufferBottomBranchSBCS;
            BufferConnectingBranch = BufferConnectingBranchSBCS;
            break;
    }
#else

    WCHAR               BufferMiddleBranch[] = {
                                               UNICODE_SINGLE_LEFT_T,
                                               UNICODE_SINGLE_BOTTOM_HORIZONTAL,
                                               UNICODE_SINGLE_BOTTOM_HORIZONTAL,
                                               UNICODE_SINGLE_BOTTOM_HORIZONTAL,
                                               UNICODE_NULL
                                               };
    WCHAR               BufferBottomBranch[] = {
                                               UNICODE_SINGLE_BOTTOM_LEFT_CORNER,
                                               UNICODE_SINGLE_BOTTOM_HORIZONTAL,
                                               UNICODE_SINGLE_BOTTOM_HORIZONTAL,
                                               UNICODE_SINGLE_BOTTOM_HORIZONTAL,
                                               UNICODE_NULL
                                               };

    WCHAR               BufferConnectingBranch[] = {
                                               UNICODE_SINGLE_VERTICAL,
                                               UNICODE_SPACE,
                                               UNICODE_SPACE,
                                               UNICODE_SPACE,
                                               UNICODE_NULL
                                               };
#endif

    _InitialDirectory = NULL;
    FlagInvalidPath = FALSE;
    _FlagAtLeastOneSubdir = TRUE;
    _StandardOutput = Get_Standard_Output_Stream();

    //
    // Initialize MESSAGE class
    //
    _Message.Initialize( _StandardOutput, Get_Standard_Input_Stream() );

    //
    //      Parse command line
    //
    if ( !LexArray.Initialize( ) ) {
        DebugAbort( "LexArray.Initialize() failed \n" );
        return( FALSE );
    }
    if ( !ArgLex.Initialize( &LexArray ) ) {
        DebugAbort( "ArgLex.Initialize() failed \n" );
        return( FALSE );
    }
    ArgLex.PutSwitches( "/" );
    ArgLex.PutStartQuotes( "\"" );
    ArgLex.PutEndQuotes( "\"" );
    ArgLex.PutSeparators( " \t" );
    ArgLex.SetCaseSensitive( FALSE );

    if( !ArgLex.PrepareToParse() ) {
        DebugAbort( "ArgLex.PrepareToParse() failed \n" );
        return( FALSE );
    }
    if ( !ArgumentArray.Initialize() ) {
        DebugAbort( "ArgumentArray.Initialize() failed \n" );
        return( FALSE );
    }
    if( !ProgramNameArgument.Initialize("*") ||
        !_FlagDisplayFiles.Initialize( "/F" ) ||
        !_FlagUseAsciiCharacters.Initialize( "/A" ) ||
        !_FlagDisplayHelp.Initialize( "/?" ) ||
        !ParamNotCorrectFile.Initialize( "/F*" ) ||
        !ParamNotCorrectAscii.Initialize( "/A*" )       ||
        !ParamNotCorrectHelp.Initialize( "/?*" ) ||
        !InvalidSwitch.Initialize( "/*" ) ||
        !DirectoryPathArgument.Initialize( "*" ) ) {
        DebugAbort( "Unable to initialize flag or string arguments \n" );
        return( FALSE );
    }
    if( !ArgumentArray.Put( &ProgramNameArgument ) ||
        !ArgumentArray.Put( &_FlagDisplayFiles ) ||
        !ArgumentArray.Put( &_FlagUseAsciiCharacters ) ||
        !ArgumentArray.Put( &_FlagDisplayHelp ) ||
        !ArgumentArray.Put( &ParamNotCorrectFile ) ||
        !ArgumentArray.Put( &ParamNotCorrectAscii )  ||
        !ArgumentArray.Put( &ParamNotCorrectHelp ) ||
        !ArgumentArray.Put( &InvalidSwitch ) ||
        !ArgumentArray.Put( &DirectoryPathArgument ) ) {
        DebugAbort( "ArgumentArray.Put() failed \n" );
        return( FALSE );
    }
    if( !ArgLex.DoParsing( &ArgumentArray ) ) {
        InvalidArgument = ArgLex.QueryInvalidArgument();
        DebugPtrAssert( InvalidArgument );
        _Message.Set( MSG_TREE_TOO_MANY_PARAMETERS );
        _Message.Display( "%W", InvalidArgument );
        return( FALSE );
    }
    if( InvalidSwitch.IsValueSet() ) {
        InvalidArgument = InvalidSwitch.GetString();
        DebugPtrAssert( InvalidArgument );
        _Message.Set( MSG_TREE_INVALID_SWITCH );
        _Message.Display( "%W", InvalidArgument );
        return( FALSE );
    }
    if( ParamNotCorrectFile.IsValueSet() ) {
        InvalidArgument = ParamNotCorrectFile.GetLexeme();
        DebugPtrAssert( InvalidArgument );
        _Message.Set( MSG_TREE_PARAMETER_NOT_CORRECT );
        _Message.Display( "%W", InvalidArgument );
        return( FALSE );
    }
    if( ParamNotCorrectAscii.IsValueSet() ) {
        InvalidArgument = ParamNotCorrectAscii.GetLexeme();
        DebugPtrAssert( InvalidArgument );
        _Message.Set( MSG_TREE_PARAMETER_NOT_CORRECT );
        _Message.Display( "%W", InvalidArgument );
        return( FALSE );
    }
    if( ParamNotCorrectHelp.IsValueSet() ) {
        InvalidArgument = ParamNotCorrectHelp.GetLexeme();
        DebugPtrAssert( InvalidArgument );
        _Message.Set( MSG_TREE_PARAMETER_NOT_CORRECT );
        _Message.Display( "%W", InvalidArgument );
        return( FALSE );
    }


    //
    //      Displays help message if /? was found in the command line
    //
    if( _FlagDisplayHelp.QueryFlag() ) {
        _Message.Set( MSG_TREE_HELP_MESSAGE );
        _Message.Display( " " );
        return( FALSE );
    }

    //
    //      Find initial directory
    //
    if( !DirectoryPathArgument.IsValueSet() ) {
        //
        // User did't specify a path, so assume current directory
        //
        _FlagPathSupplied = FALSE;

        if (!DirectoryNamePath.Initialize((LPWSTR)L".", TRUE )) {

            DebugAbort( "DirectoryNamePath.Initialize() failed \n" );
            return( FALSE );
        }

    } else {
        //
        // User specified a path
        //

        DirectoryNameString = DirectoryPathArgument.GetPath()->QueryFullPathString();
        DebugPtrAssert( DirectoryNameString );
        DirectoryNameString->Strupr();

        if (!DirectoryNamePath.Initialize(DirectoryNameString, TRUE)) {
            DebugAbort( "DirectoryNamePath.Initialize() failed \n" );
            return( FALSE );
        }

        //
        // Save the path specified by the user as he/she typed it
        // (but in upper case)
        //
        if( !AuxPath.Initialize( DirectoryNameString, FALSE ) ) {
            DebugAbort( "AuxPath.Initialize() failed \n" );
            return( FALSE );
        }

        //
        // Validate the device if one was supplied
        // AuxPath represents the path as typed by the user, and
        // it may or may not contain a device. If it doesn't contain
        // a device, no verification is made. In this case and we are
        // sure that the device is valid
        //
        if( ( Device = AuxPath.QueryDevice() ) != NULL ) {
            if( !DevPth.Initialize( Device ) ) {
                DebugAbort( "DevPth.Initialize() failed \n" );
                return( FALSE );
            }
            if( !(DevDir = SYSTEM::QueryDirectory( &DevPth ) ) ) {
                _Message.Set( MSG_TREE_INVALID_DRIVE );
                _Message.Display( " " );
                DELETE( Device );
                return( FALSE );
            }
            DELETE( Device );
            DELETE( DevDir );
        }

        //
        // Find out if what the user specified is just a drive
        //
        if( AuxPath.IsDrive() ) {
            _FlagPathSupplied = FALSE;
        } else {
            _FlagPathSupplied = TRUE;
        }
    }

    if (NULL == (_InitialDirectory = SYSTEM::QueryDirectory( &DirectoryNamePath ))) {

        InvalidPath = DirectoryNamePath.GetPathString();
        FlagInvalidPath = TRUE;
        _FlagAtLeastOneSubdir = FALSE;
    }

    //
    //      Initialize filter for directories
    //

    if( !_FsnFilterDirectory.Initialize() ) {
        DELETE( _InitialDirectory );
        DebugAbort( "_FsnFilterDirectory.Initialize() failed \n" );
        return( FALSE );
    }
    if( !_FsnFilterDirectory.SetFileName( "*.*" ) ) {
        DELETE( _InitialDirectory );
        DebugAbort( "_FsnFilterDirectory.SetFilename() failed \n" );
        return( FALSE );
    }
    if( !_FsnFilterDirectory.SetAttributes( FSN_ATTRIBUTE_DIRECTORY,
                                            ( FSN_ATTRIBUTE )0,
                                            FSN_ATTRIBUTE_HIDDEN |
                                            FSN_ATTRIBUTE_SYSTEM ) ) {
        DELETE( _InitialDirectory );
        DebugAbort( "_FsnFilterDirectory.SetAttributes() failed \n" );
        return( FALSE );
    }

    //
    //      Initilize filter for files
    //

    if( _FlagDisplayFiles.QueryFlag() ) {
        if( !_FsnFilterFile.Initialize() ) {
            DELETE( _InitialDirectory );
            DebugAbort( "FsnFilter.Initialize() failed \n" );
            return( FALSE );
        }
        if( !_FsnFilterFile.SetFileName( "*.*" ) ) {
            DELETE( _InitialDirectory );
            DebugAbort( "FsnFilter.SetFilename() failed \n" );
            return( FALSE );
        }
        if( !_FsnFilterFile.SetAttributes( ( FSN_ATTRIBUTE )0,
                                           ( FSN_ATTRIBUTE )0,
                                           FSN_ATTRIBUTE_DIRECTORY |
                                           FSN_ATTRIBUTE_HIDDEN |
                                           FSN_ATTRIBUTE_SYSTEM ) ) {
            DELETE( _InitialDirectory );
            DebugAbort( "FsnFilter.SetAttributes() failed \n" );
            return( FALSE );
        }
    }

    //
    //      Find out what kind of characters should be used to display the tree
    //      and initialize the basic strings
    //
    if( _FlagUseAsciiCharacters.QueryFlag() ) {

        _StringForDirectory.Initialize( (LPWSTR)L"+---" );
        _StringForLastDirectory.Initialize( (LPWSTR)L"\\---" );
        _StringForFile.Initialize( (LPWSTR)L"|   " );

    } else {

        _StringForDirectory.Initialize( BufferMiddleBranch );        //  ""
        _StringForLastDirectory.Initialize( BufferBottomBranch );    //  ""
        _StringForFile.Initialize( BufferConnectingBranch );         //  "   "

    }
    _StringForFileNoDirectory.Initialize( (LPWSTR)L"    " );

    if( !_EndOfLineString.Initialize( (LPWSTR)L"\r\n" ) ) {
        DebugPrint( "_EndOfLineString.Initialize() failed" );
        DELETE( _InitialDirectory );
        return( FALSE );
    }

    _VolumeName = SYSTEM::QueryVolumeLabel( &DirectoryNamePath, &_SerialNumber );
    if (NULL == _VolumeName) {
        _Message.Set( MSG_TREE_INVALID_DRIVE );
        _Message.Display( " " );
        DELETE( Device );
        return( FALSE );
    }
    DebugPtrAssert( _VolumeName );
    _FlagAtLeastOneSubdir = FALSE;
    if( FlagInvalidPath ) {
        //
        //      If user specified an invalid path, then display the same
        //      messages that Dos 5 does.
        //
        //      First displays the volume info.
        //

        DisplayVolumeInfo();

        //
        //      Then display the path that is invalid. This path must be
        //      displayed in capital letters, must always contain a device,
        //      and must be displayed as a relative or absolute path depending
        //      on what the user specified.
        //
        Device = DirectoryNamePath.QueryDevice();
        AuxInvPath.Initialize( DirectoryNameString, FALSE );
        InvPathNoDrive = AuxInvPath.QueryDirsAndName();
        _StandardOutput->WriteString( Device );
        _StandardOutput->WriteString( InvPathNoDrive );
        _StandardOutput->WriteByte( '\r' );
        _StandardOutput->WriteByte( '\n' );

        //
        //      Display the message "Invalid Path - <path>"
        //      The path in this case cannot contain a drive even if the
        //      user specified a drive.
        //
        _Message.Set( MSG_TREE_INVALID_PATH );
        _Message.Display( "%W", InvPathNoDrive );
        DELETE( Device );
        DELETE( InvPathNoDrive );
        return( FALSE );
    }
    return( TRUE );
}


VOID
TREE::Terminate(
        )

/*++

Routine Description:

        Deletes objects created during initialization.

Arguments:

        None.

Return Value:

        None.


--*/

{
        if( _InitialDirectory != NULL ) {
                DELETE( _InitialDirectory );
        }
        if( !_FlagAtLeastOneSubdir ) {
                _Message.Set( MSG_TREE_NO_SUBDIRECTORIES );
                _Message.Display( "%s", "\r\n" );
        }

}




BOOLEAN
TREE::DisplayName (
        IN PCFSNODE     Fsn,
        IN PCWSTRING    String
        )

/*++

Routine Description:

        This method writes to the standard output the name of a file or
        directory, preceded by a string that represents pieces of the
        tree structure (pieces of the tree branches).

Arguments:

        Fsn - Pointer to a FSNODE that describes the file or directory whose
                  name is to be written.

        String - Pointer to a WSTRING object that contains the string to
                         be written before the file or directory name.

Return Value:

        BOOLEAN - returns TRUE to indicate that the operation succeeded, or
                          FALSE otherwise.

--*/


{
    PWSTRING                Name;
    PCPATH                  Path;
    PCWSTRING               InitialDirectory;
    DSTRING                 InitialDirectoryUpperCase;
    PWSTRING                Device;
    DSTRING                 EndOfLinePrecededByDot;

        DebugPtrAssert( Fsn );

        Path = Fsn->GetPath();
        DebugPtrAssert( Path );
        if( String != NULL ) {
                if( !_StandardOutput->WriteString( String, 0, String->QueryChCount() ) ) {
                        DebugAbort( "_StandardOutput->WriteString() failed \n" );
                        return( FALSE );
                }
                if( ( Name=Path->QueryName() ) == NULL ) {
                        DebugAbort( "Path->QueryName() failed \n" );
                        return( FALSE );
                }
                Name->Strcat( &_EndOfLineString );

                if( !_StandardOutput->WriteString( Name, 0, Name->QueryChCount() ) ) {
                        DebugAbort( "_StandardOutput->WriteString() failed \n" );
                        DELETE( Name );
                        return( FALSE );
                }

                DELETE( Name );
        } else {
                if( _FlagPathSupplied ) {
                        InitialDirectory = Path->GetPathString();
                        DebugPtrAssert( InitialDirectory );
                        InitialDirectoryUpperCase.Initialize( InitialDirectory );
                        InitialDirectoryUpperCase.Strupr();
                        InitialDirectoryUpperCase.Strcat( &_EndOfLineString );
                        if( !_StandardOutput->WriteString( &InitialDirectoryUpperCase ) ) {
                                DebugAbort( "_StandardOutput->WriteString() failed \n" );
                                return( FALSE );
                        }
                } else {
                        Device = PPATH(Path)->QueryDevice();
                        if (Device == NULL) {
                            DebugAbort("TREE: Path->QueryDevice() failed\n");
                            return FALSE;
                        }
                        DebugPtrAssert( Device );
                        EndOfLinePrecededByDot.Initialize( (LPWSTR)L".\r\n" );
                        Device->Strcat( &EndOfLinePrecededByDot );
                        if( !_StandardOutput->WriteString( Device, 0, TO_END ) ) {
                                DebugAbort( "_StandardOutput->WriteString() failed \n" );
                                DELETE( Device );
                                return( FALSE );
                        }
                        DELETE( Device );
                }
        }
        return( TRUE );
}


VOID
TREE::DisplayVolumeInfo (
        )

/*++

Routine Description:

        This method writes to the standard output the the volume name (if one
        is found) and the serial number.

Arguments:

        None.


Return Value:

        None.

--*/

{
        //
        //      Display volume name
        //
        if( _VolumeName->QueryChCount() == 0 ) {
                _Message.Set( MSG_TREE_DIR_LISTING_NO_VOLUME_NAME );
                _Message.Display( " " );
        } else {
                _Message.Set( MSG_TREE_DIR_LISTING_WITH_VOLUME_NAME );
                _Message.Display( "%W", _VolumeName );
        }

        //
        //      Display serial number
        //
        if( _SerialNumber.HighOrder32Bits != 0 ) {
                _Message.Set( MSG_TREE_64_BIT_SERIAL_NUMBER );
                _Message.Display( "%08X%04X%04X",
                                                  _SerialNumber.HighOrder32Bits,
                                                  _SerialNumber.LowOrder32Bits >> 16,
                                                  ( _SerialNumber.LowOrder32Bits << 16 ) >> 16);
        } else {
                _Message.Set( MSG_TREE_32_BIT_SERIAL_NUMBER );
                _Message.Display( "%04X%04X",
                                                  _SerialNumber.LowOrder32Bits >> 16,
                                                  ( _SerialNumber.LowOrder32Bits << 16 ) >> 16 );
        }
}


BOOLEAN
TREE::ExamineDirectory(
        IN      PCFSN_DIRECTORY Directory,
        IN      PCWSTRING       String
        )

/*++

Routine Description:

        Displays all files and subdirectories in the directory whose
        FSN_DIRECTORY was received as parameter.


Arguments:

        Directory - Pointer to an FSN_DIRECTORY that describes the
                                directory to be examined

        String    - Pointer to a WSTRING that contains part of the string
                                to be written in the left side of each subdiretory name
                                and file name found in the directory being examined
                                (the one whose FSN_DIRECTORY was received as parameter)

Return Value:

        BOOLEAN - Returns TRUE to indicate that the operation succeded.
                          Returns FALSE otherwise.

--*/

{
        PARRAY                          DirectoryArray;
        PFSN_DIRECTORY          FsnDirectory;
        PARRAY_ITERATOR         DirectoryArrayIterator;
        PARRAY                          FileArray;
        PARRAY_ITERATOR         FileArrayIterator;
        PFSNODE                         FsnFile;
#if 0
        PWSTRING                        StringFile;
#endif
#if 0
        PWSTRING                        StringDir;
        PWSTRING                        StringLastDir;
        PWSTRING                        StringSon;
        PWSTRING                        StringLastSon;
#endif
        DSTRING                        StringFile;
        DSTRING                        StringDir;
        DSTRING                        StringLastDir;
        DSTRING                        StringSon;
        DSTRING                        StringLastSon;

        DebugPtrAssert( Directory );

        //
        //      Build list of directories (ie., an array of PFSN_DIRECTORY of all
        //      sub-directories in the current directory
        //
        DirectoryArray = Directory->QueryFsnodeArray( &_FsnFilterDirectory );
        DebugPtrAssert( DirectoryArray );
        DirectoryArrayIterator =
                        ( PARRAY_ITERATOR )( DirectoryArray->QueryIterator() );
        DebugPtrAssert( DirectoryArrayIterator );

        //
        // If files are to be displayed (/F in the command line), then build
        // an array of files (ie., an array of PFSNODEs of all files in the
        // current directory)
        //
        if( _FlagDisplayFiles.QueryFlag() ) {
                FileArray = Directory->QueryFsnodeArray( &_FsnFilterFile );
                DebugPtrAssert( FileArray );
                FileArrayIterator =
                                ( PARRAY_ITERATOR )( FileArray->QueryIterator() );
                DebugPtrAssert( FileArrayIterator );

        //
        //  If array of files is not empty, then we need the strings
        //  to be displayed in the left side of file names. These strings
        //  will contain the pieces of the branches of the tree diagram.
        //  These strings for files are created here.
        //
        if( FileArray->QueryMemberCount() > 0 ) {
#if 0
            StringFile = NEW( DSTRING );
            DebugPtrAssert( StringFile );
#endif
            if( DirectoryArray->QueryMemberCount() > 0 ) {
                if( String == NULL ) {
                    StringFile.Initialize( &_StringForFile );
                } else {
                    StringFile.Initialize( String );
                    StringFile.Strcat( &_StringForFile );
                }
            } else {
                if( String == NULL ) {
                    StringFile.Initialize( &_StringForFileNoDirectory );
                } else {
                    StringFile.Initialize( String );
                    StringFile.Strcat( &_StringForFileNoDirectory );
                }
            }

            //
            //      Display all file names
            //
            while( ( FsnFile = ( PFSNODE )( FileArrayIterator->GetNext( ) ) ) != NULL ) {
                DisplayName( FsnFile, &StringFile );
                DELETE( FsnFile );
            }

            //
            // Display an empty line after the last file
            //
            _StandardOutput->WriteString( &StringFile, 0, StringFile.QueryChCount() );
            _StandardOutput->WriteString( &_EndOfLineString, 0, _EndOfLineString.QueryChCount() );

            }
            DELETE( FileArrayIterator );
            DELETE( FileArray );
        }

    //
    //  If list of directories is not empty
    //
    if( DirectoryArray->QueryMemberCount() > 0 ) {
        _FlagAtLeastOneSubdir = TRUE;
        //
        //  Build strings to be printed before directory name
        //
        if( String == NULL ) {
            StringDir.Initialize( &_StringForDirectory );
            StringLastDir.Initialize( &_StringForLastDirectory );
            StringSon.Initialize( &_StringForFile );
            StringLastSon.Initialize( &_StringForFileNoDirectory );
        } else {
            StringDir.Initialize( String );
            StringDir.Strcat( &_StringForDirectory );
            StringLastDir.Initialize( String );
            StringLastDir.Strcat( &_StringForLastDirectory );
            StringSon.Initialize( String );
            StringSon.Strcat( &_StringForFile );
            StringLastSon.Initialize( String );
            StringLastSon.Strcat( &_StringForFileNoDirectory );
        }
        //
        //  Display name of all directories, and examine each one of them
        //
        while( ( FsnDirectory = ( PFSN_DIRECTORY )( DirectoryArrayIterator->GetNext( ) ) ) != NULL ) {
            if( DirectoryArrayIterator->QueryCurrentIndex() != DirectoryArray->QueryMemberCount() - 1 ) {
                DisplayName( ( PCFSNODE )FsnDirectory, &StringDir );
                ExamineDirectory( FsnDirectory, &StringSon );
            } else {
                DisplayName( ( PCFSNODE )FsnDirectory, &StringLastDir );
                ExamineDirectory( FsnDirectory, &StringLastSon );
            }
            DELETE( FsnDirectory );
        }
    }
    DELETE( DirectoryArrayIterator );
    DELETE( DirectoryArray );
    return( TRUE );
}



ULONG __cdecl
main()

{
        DEFINE_CLASS_DESCRIPTOR( TREE );

        {
                TREE    Tree;
                PCFSN_DIRECTORY         Directory;

                if( Tree.Initialize() ) {
                        Tree.DisplayVolumeInfo();
                        //
                        //      Display directory name
                        //
                        Directory = Tree.GetInitialDirectory();
                        Tree.DisplayName( ( PCFSNODE )Directory, ( PCWSTRING )NULL );
                        Tree.ExamineDirectory( Directory, ( PCWSTRING )NULL );
                }
                Tree.Terminate();
        }
        return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\subst\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

TARGETNAME=subst
TARGETPATH=obj
TARGETTYPE=PROGRAM

USE_MSVCRT=1

SOURCES=..\subst.cxx   \
        ..\subst.rc

INCLUDES=..\.;                      \
         ..\..\ulib\inc;            \
         ..\..\ifsutil\inc;         \

!IF "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "ntsd"
!IFDEF NOMEMLEAK
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DUNICODE=1
!ELSE
!IFDEF STACK_TRACE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DSTACK_TRACE -DUNICODE=1
!ELSE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DUNICODE=1
!ENDIF
!ENDIF
!ELSE   # NTDEBUG
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=0 -DUNICODE=1
!ENDIF  # NTDEBUG

TARGETLIBS=                                        \
    ..\..\ulib\src\$(ALT_PROJECT)\$(O)\ulib.lib   \
    $(SDK_LIB_PATH)\ntdll.lib

UMTYPE=console

W32_SB=1
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\tree\sources.inc ===
!IF 0

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    sources.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

USE_MSVCRT=1

TARGETNAME=tree
TARGETPATH=obj
TARGETEXT=com
TARGETTYPE=PROGRAM

SOURCES=..\tree.cxx ..\tree.rc

INCLUDES=..\.;..\..\ulib\inc

!IF "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "ntsd"
!IFDEF NOMEMLEAK
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DUNICODE=1
!ELSE
!IFDEF STACK_TRACE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DSTACK_TRACE -DUNICODE=1
!ELSE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DUNICODE=1
!ENDIF
!ENDIF
!ELSE   # NTDEBUG
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=0 -DUNICODE=1
!ENDIF  # NTDEBUG

TARGETLIBS= \
    ..\..\ulib\src\$(ALT_PROJECT)\$(O)\ulib.lib \
    $(SDK_LIB_PATH)\ntdll.lib

UMTYPE=console

W32_SB=1
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\tuneup\cleanup.h ===
//////////////////////////////////////////////////////////////////////////////
//
// CLEANUP.H
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  Includes all external include files, defined values, macros, data
//  structures, and fucntion prototypes for the corisponding CXX file.
//
//  Jason Cohen (JCOHEN)
//
//////////////////////////////////////////////////////////////////////////////



// Only include this file once.
//
#ifndef _CLEANUP_H_
#define _CLEANUP_H_


// Include file(s).
//
#include <windows.h>


// External function prototype(s).
//
BOOL GetCleanupSettings(HWND);


#endif // _CLEANUP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\tuneup\howtorun.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// HOWTORUN.CPP / Tuneup
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  8/98 - Jason Cohen (JCOHEN)
//
//////////////////////////////////////////////////////////////////////////////


// Include file(s).
//
#include <windows.h>
#include <tchar.h>
#include "main.h"
#include "resource.h"
#include "registry.h"
#include "miscfunc.h"
#include "runnow.h"


// Inernal function prototype(s).
//
static BOOL CALLBACK	HowToRunDlgProc(HWND, UINT, WPARAM, LPARAM);


BOOL HowToRun()
{
	return (DialogBox(g_hInst, MAKEINTRESOURCE(IDD_FIRST), NULL, (DLGPROC) HowToRunDlgProc) != 0);
}


static BOOL CALLBACK HowToRunDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
		case WM_COMMAND:

			switch ( (INT) LOWORD(wParam) )
			{
				case IDOK:

					// If the user choose "change", we want to save that so it defaults to it
					// the next time he runs the wizard.
					//
					RegSetString(HKLM, g_szTuneupKey, g_szRegValChange, IsDlgButtonChecked(hDlg, IDC_CHANGE) ? _T("1") : _T("0"));

					if ( IsDlgButtonChecked(hDlg, IDC_CHANGE) )
					{
						// End with 1 so that the wizard will run.
						//
						EndDialog(hDlg, 1);
					}
					else
					{
						// Run the tasks now.
						//
						ShowEnableWindow(hDlg, FALSE);
						RunTasksNow(hDlg, g_Tasks);
						EndDialog(hDlg, 0);
					}
					break;

				case IDCANCEL:

					EndDialog(hDlg, 0);
					break;

				default:
					return TRUE;
			}
			return 0;

		case WM_INITDIALOG:

			// Set the initial state of the radio buttons.  If the user previously used
			// the change setting last, check that radio button.  Otherwise, default
			// to the run now button.
			//
			CheckRadioButton(hDlg, IDC_RUNNOW, IDC_CHANGE, RegCheck(HKLM, g_szTuneupKey, g_szRegValChange) ? IDC_CHANGE : IDC_RUNNOW);
			return FALSE;

		case WM_CLOSE:

			EndDialog(hDlg, 0);
			return TRUE;

		default:
			return FALSE;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\tuneup\howtorun.h ===
//////////////////////////////////////////////////////////////////////////////
//
// HOWTORUN.H
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  Includes all external include files, defined values, macros, data
//  structures, and fucntion prototypes for the corisponding CXX file.
//
//  Jason Cohen (JCOHEN)
//
//////////////////////////////////////////////////////////////////////////////



// Only include this file once.
//
#ifndef _HOWTORUN_H_
#define _HOWTORUN_H_


// Include file(s).
//
#include <windows.h>


// External function prototype(s).
//
BOOL	HowToRun(VOID);


#endif // _HOWTORUN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\tuneup\jcohen.h ===
// ************************************************************************
//
// JCOHEN.H
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  Contains common include files, macros, and other stuff I use 
//  all the time.
//
// ************************************************************************


#ifndef _JCOHEN_H_
#define _JCOHEN_H_


//
// Include files
//

#include <windows.h>

#define	NULLSTR	_T("")
#define NULLCHR	_T('\0')

//
// Macros.
//

// Memory managing macros.
//
#define MALLOC(cb)      HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, cb)
#define REALLOC(lp, cb) HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, lp, cb)
#define FREE(lp)        ( (lp != NULL) ? ( (HeapFree(GetProcessHeap(), HEAP_NO_SERIALIZE, (LPVOID) lp)) ? ((lp = NULL) == NULL) : (FALSE) ) : (FALSE) )
#define NETFREE(lp)     ( (lp != NULL) ? ( (NetApiBufferFree((LPVOID) lp)) ? ((lp = NULL) == NULL) : (FALSE) ) : (FALSE) )

// Misc. macros.
//
#define EXIST(lpFileName)			( (GetFileAttributes(lpFileName) == 0xFFFFFFFF) ? (FALSE) : (TRUE) )
#define ISNUM(cChar)				((cChar >= '0') && (cChar <= '9')) ? (TRUE) : (FALSE)
#define	UPPER(x)					( ( (x >= 'a') && (x <= 'z') ) ? (x + 'A' - 'a') : (x) )
#define RANDOM(low, high)			(high - low + 1) ? rand() % (high - low + 1) + low : 0


#endif // _JCOHEN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\tuneup\miscfunc.h ===
//////////////////////////////////////////////////////////////////////////////
//
// MISCFUNC.H
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  Misc. functions prototypes.
//
//  7/98 - Jason Cohen (JCOHEN)
//
//////////////////////////////////////////////////////////////////////////////


#ifndef _MISCFUNC_H_
#define _MISCFUNC_H_

// Inlcude file(s).
//
#include <windows.h>


// Exported function prototypes.
//
VOID	CenterWindow(HWND, HWND, BOOL = FALSE);
VOID	ShowEnableWindow(HWND, BOOL);
LPTSTR	AllocateString(HINSTANCE, UINT);
BOOL	IsUserAdmin(VOID);
VOID	ExecAndWait(HWND, LPTSTR, LPTSTR, LPTSTR, BOOL = TRUE, BOOL = FALSE);
BOOL	ErrMsg(HWND, INT);
DWORD	StartScheduler(VOID);
HFONT	GetFont(HWND, LPTSTR, DWORD, LONG, BOOL = FALSE);
BOOL	CreatePath(LPTSTR);
DWORD	GetCommandLineOptions(LPTSTR **);


#endif // _MISCFUNC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\tuneup\main.h ===
//////////////////////////////////////////////////////////////////////////////
//
// MAIN.H
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  Includes all internal and external include files, defined values, macros,
//  data structures, and fucntion prototypes for the corisponding CXX file.
//
//  Original engineer:  WillisC
//  Updated:            Jason Cohen (JCOHEN)
//
//////////////////////////////////////////////////////////////////////////////



// Only include this file once.
//
#ifndef _MAIN_H_
#define _MAIN_H_


//
// Include definition(s).
//

//#define STRICT
//#define OEMRESOURCE 1
//#define _INC_OLE
//#define INC_OLE2


//
// Include file(s).
//

#include <windows.h>
#include <tchar.h>
#include <mstask.h>
#include "resource.h"
#include "jcohen.h"
#include "registry.h"
#include "miscfunc.h"


//
// External defined value(s).
//

#define WM_PROGRESS		(WM_USER + 1000)

// Tuneup flags.
//
#define TUNEUP_CUSTOM		0x00000001	// Set if the user choose custom instead of express.
#define TUNEUP_FINISHED		0x00000002	// Set when the user presses finish instead of cancel so we know to save settings.
#define TUNEUP_OLDADMIN		0x00000004	// Set to use old admin UI for the startup group.
#define TUNEUP_AUTORUN		0x00000008	// Set if we are just going to run all the tasks.
#define TUNEUP_RUNBACKUP	0x00000010	// Set if we need to run the backup wizard at the end.
#define TUNEUP_NOSCHEDULE	0x00000020	// Set if there is no current schedule.
#define TUNEUP_QUIT			0x00000040	// Set when proccessing command line options if we don't want to run the wizard.

// Task flags (options).
//
#define TASK_SCHEDULED	0x00000001	// The job is scheduled.
#define TASK_NEW		0x00000002	// The job is newly created by this sessioin of Tune-up.
#define TASK_NOIDLE		0x00000004	// The job doesn't wait for the computer to be idle.

// Schedule settings.
//
#define TASK_ONCE		1
#define TASK_DAILY		2
#define TASK_WEEKLY		3
#define TASK_MONTHLY	4
#define TASK_BIMONTHLY	5
#define TASK_QUARTLY	6
#define TASK_YEARLY		7

// Default job flags.
//
#define DEFAULT_TASK_FLAG	TASK_FLAG_RESTART_ON_IDLE_RESUME | \
							TASK_FLAG_START_ONLY_IF_IDLE | \
							TASK_FLAG_KILL_ON_IDLE_END | \
							TASK_FLAG_DONT_START_IF_ON_BATTERIES | \
							TASK_FLAG_KILL_IF_GOING_ON_BATTERIES | \
							TASK_FLAG_SYSTEM_REQUIRED

#define DEFAULT_TASK_FLAG2	TASK_FLAG_DONT_START_IF_ON_BATTERIES | \
							TASK_FLAG_KILL_IF_GOING_ON_BATTERIES | \
							TASK_FLAG_SYSTEM_REQUIRED

// Default time scheme.
//
#define DEFAULT_TIMESCHEME	IDC_NIGHT

// Registry keys.
//
#define g_szTuneupKey			_T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Applets\\TuneUp")
#define g_szRegKeyAddOns		_T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Applets\\TuneUp\\AddOns")
#define g_szCleanUpKey			_T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\explorer\\VolumeCaches")
#define g_szCmpAgentKey			_T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\CmpAgent.exe")
#define g_szRegKeyProfiles		_T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList")

// Registry values.
//
#define g_szRegValProfileDir	_T("ProfilesDirectory")
#define g_szRegValProfilePath	_T("ProfileImagePath")
#define g_szRegValTime			_T("Time")
#define g_szRegValCustom		_T("Custom")
#define g_szRegValChange		_T("Change")
#define g_szRegValFirstTime		_T("@")

// For the third-party addon pages.
//
#define g_szRegValProgram		_T("Program")
#define g_szRegValProgParam		_T("ProgParam")
#define g_szRegValSettings		_T("Settings")
#define g_szRegValSetParam		_T("SetParam")
#define g_szRegValJobName		_T("JobName")
#define g_szRegValComment		_T("Comment")
#define g_szRegValSchedule		_T("Schedule")
#define g_szRegValTitle			_T("Title")
#define g_szRegValSubtitle		_T("Subtitle")
#define g_szRegValDescription	_T("Description")
#define REG_VAL_ACTION			_T("Action")
#define g_szRegValYesAction		_T("YesOpt")
#define g_szRegValNoAction		_T("NoOpt")
#define g_szRegValSummary		_T("Summary")


// Other strings.
//
#define g_szBackupExe			_T("NTBACKUP.EXE")


//
// External defined macro(s).
//

#ifdef _UNICODE
#define ANSIWCHAR(lpw, lpa, cb)		lpw = lpa
#define WCHARANSI(lpa, lpw, cb)		lpa = lpw
#else // _UNICODE
#define ANSIWCHAR(lpw, lpa, cb)		MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, lpa, -1, lpw, cb / 2)
#define WCHARANSI(lpa, lpw, cb)		WideCharToMultiByte(CP_ACP, 0, lpw, -1, lpa, cb, NULL, NULL)
#endif // _UNICODE


//
// External structure(s).
//

typedef struct _TASKDATA
{
	// Task scheduler job settings.
	//
	LPTSTR				lpFullPathName;		// Full path and file name of the app.
	LPTSTR				lpParameters;		// Parameters to use when running the task.
	LPTSTR				lpSetName;			// Full path and file name of the settings command (if NULL, lpFullPathName is used).
	LPTSTR				lpSetParam;			// Parameters to use with the settings command.
	LPTSTR				lpJobName;			// Name of the job file (.JOB).
	LPTSTR				lpComment;			// Comment string for the task scheduler job.
	DWORD				dwFlags;			// Original flag in ITask.
	ITask				*pTask;				// Pointer to the ITask object for the task scheduler job.
	TASK_TRIGGER		Trigger;			// Trigger structure.

	// Tuneup settings.
	//
	DWORD				dwOptions;			// Flags used by tuneup.
	INT					nSchedule;			// Whether task is once, daily, weekly, monthly, bimonthly, quarterly, or yearly.

	// Wizard page settings.
	//
	INT					nPageID;			// Resource ID for the dialog used in the wizard page.
	LPTSTR				lpTitle;			// Title of the wizard page usually in the form of MAKEINTRESOURCE(ID_STRING).
	LPTSTR				lpSubTitle;			// Subtitle of the wizard (same form as above).
	LPTSTR				lpDescription;		// Description of the task used on the wizard page (same form as above).
	LPTSTR				lpYesAction;		// String used in the Yes text.
	LPTSTR				lpNoAction;			// String used in the No text.
	LPTSTR				lpSummary;			// String used in on the summary page.

	// Pointers for the doubly linked list.
	//
	struct _TASKDATA	*lpNext;
	struct _TASKDATA	*lpBack;
}
TASKDATA, *PTASKDATA, *LPTASKDATA;


//
// External global variable(s).
//

extern HWND			g_hWnd;
extern HINSTANCE	g_hInst;
extern DWORD		g_dwFlags;
extern LPTASKDATA	g_Tasks;
extern LPTASKDATA	g_CurrentTask;
extern INT			g_nTimeScheme;
extern TCHAR		g_szAppName[64];


#endif // _MAIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\tuneup\miscfunc.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// MISCFUNC.CPP / Tuneup
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  Contains misc. functions used throughout the program.  All these functions
//  are externally exported and defined in MISCFUNC.H.
//
//  7/98 - Jason Cohen (JCOHEN)
//
//////////////////////////////////////////////////////////////////////////////


// Include files.
//
#include <windows.h>
#include <tchar.h>
#include <shellapi.h>
#include "jcohen.h"
#include "registry.h"


VOID CenterWindow(HWND hWnd, HWND hWndParent, BOOL bRightTop)
{
    RECT	rcWndParent,
			rcWnd;

	// Get the window rect for the parent window.
	//
	if (hWndParent == NULL) 
	    GetWindowRect(GetDesktopWindow(), &rcWndParent);
	else
		GetWindowRect(hWndParent, &rcWndParent);

	// Get the window rect for the window to be centered.
	//
    GetWindowRect(hWnd, &rcWnd);

	// Now center the window.
	//
    if (bRightTop)
	{
		SetWindowPos(hWnd, HWND_TOPMOST, 
			rcWndParent.right - (rcWnd.right - rcWnd.left) - 5, 
			GetSystemMetrics(SM_CYCAPTION) * 2, 
			0, 0, SWP_NOSIZE | SWP_SHOWWINDOW);
	}
	else
	{
		SetWindowPos(hWnd, NULL, 
			rcWndParent.left + (rcWndParent.right - rcWndParent.left - (rcWnd.right - rcWnd.left)) / 2,
			rcWndParent.top + (rcWndParent.bottom - rcWndParent.top - (rcWnd.bottom - rcWnd.top)) / 2,
			0, 0, SWP_NOZORDER | SWP_NOSIZE | SWP_SHOWWINDOW);
	}
}


VOID ShowEnableWindow(HWND hWnd, BOOL bEnable)
{
	EnableWindow(hWnd, bEnable);
	ShowWindow(hWnd, bEnable ? SW_SHOW : SW_HIDE);
}


LPTSTR AllocateString(HINSTANCE hInstance, UINT uID)
{
	TCHAR	szBuffer[512];
	LPTSTR	lpBuffer = NULL;

	if ( ( LoadString(hInstance, uID, szBuffer, sizeof(szBuffer) / sizeof(TCHAR)) ) &&
	     ( lpBuffer = (LPTSTR) MALLOC(sizeof(TCHAR) * (lstrlen(szBuffer) + 1)) ) )
		lstrcpy(lpBuffer, szBuffer);
	return lpBuffer;
}


//////////////////////////////////////////////////////////////////////////////
//
// EXTERNAL:
//  IsUserAdmin() 
//
//    This routine returns TRUE if the caller's process is a
//    member of the Administrators local group.
//
//    Caller is NOT expected to be impersonating anyone and IS
//    expected to be able to open their own process and process
//    token.
//
// ENTRY:
//  None.
//
// EXIT:
//  BOOL
//    TRUE  - Caller has Administrators local group.
//    FALSE - Caller does not have Administrators local group.
//
//////////////////////////////////////////////////////////////////////////////

BOOL IsUserAdmin(VOID)
{
	HANDLE						hToken = INVALID_HANDLE_VALUE;
	PTOKEN_GROUPS				pGroups = NULL;
	DWORD						dwSize,
								i;
	SID_IDENTIFIER_AUTHORITY	NtAuthority = SECURITY_NT_AUTHORITY;
	PSID						AdministratorsGroup;

	static DWORD				dwReturn = 0;

	// Save the admin status so that we don't have to
	// do all this work everytime we call this function.
	//
	if (dwReturn)
		return (dwReturn == 1); // 1 = TRUE, 2 = FALSE, 0 = Unknown yet.

	// Open the process token.
	//
	if ( OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken) )
	{
		// Get group information.
		//
		if ( !GetTokenInformation(hToken, TokenGroups, NULL, 0, &dwSize) &&
			 (GetLastError() == ERROR_INSUFFICIENT_BUFFER) &&
			 (pGroups = (PTOKEN_GROUPS) LocalAlloc(LPTR, dwSize)) &&
			 (GetTokenInformation(hToken, TokenGroups, pGroups, dwSize, &dwSize)) )
		{

			if ( AllocateAndInitializeSid(
					&NtAuthority,
					2,
					SECURITY_BUILTIN_DOMAIN_RID,
					DOMAIN_ALIAS_RID_ADMINS,
					0, 0, 0, 0, 0, 0,
					&AdministratorsGroup)
				)
			{
				// See if the user has the administrator group.
				//
				for(i = 0; (dwReturn != 1) && (i < pGroups->GroupCount); i++)
					if ( EqualSid(pGroups->Groups[i].Sid, AdministratorsGroup) ) dwReturn = 1;
				
				// If we didn't find the user in the
				// admin group, set the return option to
				// 2 (meaning we looked already but the
				// user isn't an admin.
				//
				if (dwReturn != 1)
					dwReturn = 2;

				FreeSid(AdministratorsGroup);
			}
		}

		// Clean up.
		//
		if (pGroups) {
			LocalFree((HLOCAL) pGroups);
		}
		CloseHandle(hToken);
	}

	return (dwReturn == 1); // 1 = TRUE, 2 = FALSE, 0 = Unknown yet.
}


VOID ExecAndWait(HWND hOrgWnd, LPTSTR lpExe, LPTSTR lpCmd, LPTSTR lpDir, BOOL fShowOrgWnd, BOOL fNoWait)
{
	SHELLEXECUTEINFO	sei;

	ZeroMemory((PVOID) &sei, sizeof(SHELLEXECUTEINFO));
	sei.cbSize = sizeof(SHELLEXECUTEINFO);
	sei.hwnd = hOrgWnd; 
	sei.fMask = SEE_MASK_NOCLOSEPROCESS;
	sei.lpFile = (LPCTSTR) lpExe;
	sei.lpDirectory = lpDir;
	sei.lpParameters = lpCmd;
	sei.nShow = SW_SHOW;

	if (ShellExecuteEx(&sei)) {
		
		// Hide/disable Tuneup.
		//
		WaitForInputIdle(sei.hProcess, INFINITE);
		ShowEnableWindow(hOrgWnd, FALSE);
		//ShowEnableWindow(g_hwndMain, FALSE);

		// Wait until the launched app stop.
		//
		if (!fNoWait)
			WaitForSingleObjectEx(sei.hProcess, INFINITE, FALSE);
		
		// Enable Tuneup.
		//
		EnableWindow(hOrgWnd, TRUE);
		//EnableWindow(g_hwndMain, TRUE); 

		// Don't show it?
		//
		if (fShowOrgWnd) {
			ShowWindow(hOrgWnd, SW_SHOW);
			//ShowWindow(g_hwndMain, SW_SHOW);
			SetForegroundWindow(hOrgWnd);
		}
	}
#ifdef DEBUG
	else {
		LPTSTR	lpMsgBuf;

		FormatMessage( 
			FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
			NULL, GetLastError(), MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
			&lpMsgBuf, 0, NULL
		);

		MessageBox(NULL, (LPCTSTR) lpMsgBuf, (LPCTSTR) _T("GetLastError()"), MB_OK | MB_ICONINFORMATION);
		LocalFree(lpMsgBuf);
	}
#endif
}


BOOL ErrMsg(HWND hWnd, INT nStringID)
{
	LPTSTR lpString;

	// Load the string and display the message box.
	//
	if ( lpString = AllocateString(NULL, nStringID) )
	{
		MessageBox(hWnd, lpString, NULL, MB_OK | MB_ICONEXCLAMATION);
		FREE(lpString);
	}

	// Always return TRUE.
	//
	return TRUE;
}


DWORD StartScheduler()
{
	TCHAR	szRegKeyServices[]	= _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunServies"),
			szRegValSched[]		= _T("SchedulingAgent"),
			szSchedClass[]		= _T("SAGEWINDOWCLASS"),
			szSchedTitle[]		= _T("SYSTEM AGENT COM WINDOW"),
			szSchedExe[]		= _T("MSTASK.EXE");

	STARTUPINFO         si;
	PROCESS_INFORMATION pi;

	TCHAR	szApp[MAX_PATH] = NULLSTR;
	LPTSTR	lpFilePart;

	// Check to see if it is already running.
	//
    if ( FindWindow(szSchedClass, szSchedTitle) != NULL )
        return ERROR_SUCCESS;

	// Get the full path to where MSTASK is.
	//
    if ( ( SearchPath(NULL, _T("MSTASK.EXE"), NULL, sizeof(szApp), szApp, &lpFilePart) == 0 ) ||
	     ( szApp[0] == _T('\0') ) )
        return GetLastError();

	// Add the key so the Scheduling service will start each time
	// the computer is restarted.
	//
	RegSetString(HKLM, szRegKeyServices, szRegValSched, szApp);

	// Execute the task scheduler process.
	//
    ZeroMemory(&si, sizeof(STARTUPINFO));
    si.cb = sizeof(STARTUPINFO);

    if ( !CreateProcess(szApp, NULL, NULL, NULL, FALSE, CREATE_NEW_CONSOLE | CREATE_NEW_PROCESS_GROUP, NULL, NULL, &si, &pi) )
        return GetLastError();

    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);

	return ERROR_SUCCESS;
}


HFONT GetFont(HWND hWndCtrl, LPTSTR lpFontName, DWORD dwFontSize, LONG lFontWeight, BOOL bSymbol)
{
	HFONT			hFont;
	LOGFONT			lFont;
	BOOL			bGetFont;


	// If the font name is passed in, then try to use that
	// first before getting the font of the control.
	//
	if ( lpFontName )
	{
		// Make sure the font name is not longer than
		// 32 characters (including the NULL terminator).
		//
		if ( lstrlen(lpFontName) >= sizeof(lFont.lfFaceName) )
			return NULL;

		// Setup the structure to use to get the
		// font we want.
		//
		ZeroMemory(&lFont, sizeof(LOGFONT));
		lstrcpy(lFont.lfFaceName, lpFontName);
	}
		
	// First try to get the font that we wanted.
	//
	if ( ( lpFontName == NULL ) ||
	     ( (hFont = CreateFontIndirect((LPLOGFONT) &lFont)) == NULL ) )
	{
		// Couldn't get the font we wanted, try the font of the control
		// if a valid window handle was passed in.
		//
		if ( ( hWndCtrl == NULL ) ||
		     ( (hFont = (HFONT) (WORD) SendMessage(hWndCtrl, WM_GETFONT, 0, 0L)) == NULL ) )
		{
			// All atempts to get the font failed.  We must return NULL.
			//
			return NULL;
		}
	}

	// Return the font we have now if we don't need to
	// change the size or weight.
	//
	if ( (lFontWeight == 0) && (dwFontSize == 0) )
		return hFont;

	// We must have a valid HFONT now.  Fill in the structure
	// and setup the size and weight we wanted for it.
	//
	bGetFont = GetObject(hFont, sizeof(LOGFONT), (LPVOID) &lFont);
	DeleteObject(hFont);

	if (bGetFont)
	{
		// Set the bold and point size of the font.
		//
		if (lFontWeight)
			lFont.lfWeight = lFontWeight;
		if (dwFontSize)
			lFont.lfHeight = -MulDiv(dwFontSize, GetDeviceCaps(GetDC(NULL), LOGPIXELSY), 72);
		if (bSymbol)
			lFont.lfCharSet = SYMBOL_CHARSET;

		// Create the font.
		//
		hFont = CreateFontIndirect((LPLOGFONT) &lFont);
	}
	else
		hFont = NULL;

	return hFont;
}


//***************************************************************************
//
// EXTERNAL:
//  CreatePath()
//              - Creates the whole path, not just the last directory.
//
// ENTRY:
//  lpPath      - Path to create.
//
// EXIT:
//  VOID
//
//***************************************************************************

BOOL CreatePath(LPTSTR lpPath) {
	
	LPTSTR lpFind = lpPath;

	while ( lpFind = _tcschr(lpFind + 1, _T('\\')) )
	{
		if ( !( ( lpFind - lpPath <= 2 ) && ( *(lpFind - 1) == _T(':') ) ) )
		{
			*lpFind = _T('\0');
			if (!EXIST(lpPath))
				CreateDirectory(lpPath, NULL);
			*lpFind = _T('\\');
		}
	}

	if (!EXIST(lpPath))
		return CreateDirectory(lpPath, NULL);
	else
		return TRUE;
}


DWORD GetCommandLineOptions(LPTSTR **lpArgs)
{
	TCHAR	cParse;
	LPTSTR	lpSearch,
			lpCommandLine;
	DWORD	dwArgs		= 0,
			dwMaxArgs	= 0xFFFFFFFF;

	// Make sure we get the command line.
	//
	if ( (lpSearch = lpCommandLine = GetCommandLine()) == NULL )
		return 0;

	// Get the number of arguments so we can allocate
	// the memory for the array of command line options.
	//
	if ( lpArgs )
	{
		if ( (dwMaxArgs = GetCommandLineOptions(NULL)) == 0 )
			return 0;
		if ( (*lpArgs = (LPTSTR *) MALLOC(sizeof(LPTSTR) * dwMaxArgs)) == NULL )
			return 0;
	}

	// Now lets parse the arguments.
	//
	while ( *lpSearch && (dwArgs < dwMaxArgs) )
	{
		// Eat all preceeding spaces.
		//
		while ( *lpSearch == _T(' ') )
			lpSearch++;

		// Check to see if we need to look for a space or a quote 
		// to separate the next argument.
		//
		if ( *lpSearch == _T('"') )
			cParse = *lpSearch++;
		else
			cParse = _T(' ');

		// This is be the beginning of the next argument, but 
		// it isn't NULL terminated yet.
		//
		if ( lpArgs )
			*(*lpArgs + dwArgs) = lpSearch;
		dwArgs++;

		// Go through all the characters until we hit a separator.
		//
		do 
		{
			// Once we get to a quote, we just want to keep going 
			// until we get to a space.
			//
			if ( *lpSearch == _T('"') )
				cParse = _T(' ');

		// Only end when we reach the parsing character, which will 
		// always be the space by this time (but the space won't trigger
		// the end until we hit a quote, if that is what we were originally
		// looking for).  We also need to make sure that we don't increment 
		// past the NULL terminator.
		//
		} 
		while ( ( *lpSearch != cParse ) && ( *lpSearch ) && ( *lpSearch++ ) );

		// If the preceeding character is a quote, that is were we want to 
		// place the NULL terminator.
		//
		if ( ( lpSearch > lpCommandLine ) &&
		     ( *(lpSearch - 1) == _T('"') ) )
			lpSearch--;

		// Set and increment past the NULL terminator only if we aren't already at 
		// the end if the string.
		//
		if ( lpArgs && *lpSearch )
			*lpSearch++ = _T('\0');
		else
			if ( *lpSearch ) lpSearch++;
	}

	return dwArgs;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\tuneup\main.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// MAIN.CPP / Tuneup
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  Main tuneup application file.
//
//  Original engineer:  WillisC
//  Updated:            Jason Cohen (JCOHEN)
//
//////////////////////////////////////////////////////////////////////////////

//
// Internal include file(s).
//

#include <windows.h>
#include <tchar.h>
#include "tasks.h"
#include "schedwiz.h"
#include "howtorun.h"
#include "wizard.h"
#include "scm.h"


//
// Global variable(s).
//

HWND		g_hWnd;
HINSTANCE	g_hInst;
DWORD		g_dwFlags;
LPTASKDATA	g_Tasks;
LPTASKDATA	g_CurrentTask;
INT			g_nTimeScheme;
TCHAR		g_szAppName[64];


//
// Internal (static) function prototype(s).
//

static HANDLE	GetMutex(VOID);
static HWND		CheckPrevInst(LPHANDLE);

static BOOL		TanslateCommandLine(LPTSTR);



//
// Main windows function.
//

INT PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, INT nCmdShow)
{
	HANDLE	hMutex;
	HWND	hWnd;
	LPTSTR	*lpArgs = NULL;
	DWORD	dwArgs,
			dwIndex;
	BOOL	bRunWizard;


	// First we will init any global memory we need to.
	//
	g_hInst = hInstance;
	g_nTimeScheme = 0;
	g_dwFlags = 0;
	LoadString(hInstance, IDS_TUNEUP, g_szAppName, sizeof(g_szAppName) / sizeof(TCHAR));

	// This will setup any command line options first.
	//
	dwArgs = GetCommandLineOptions(&lpArgs);
	for (dwIndex = 1; dwIndex < dwArgs; dwIndex++)
		TanslateCommandLine((LPTSTR) *(lpArgs + dwIndex));
	FREE(lpArgs);

	// If we proccessed a command line option that is designed to
	// not run tuneup, we should return now.
	//
	if ( g_dwFlags & TUNEUP_QUIT )
		return TRUE;

	// Now check for another instance of Tuneup.
	//
	if ( hWnd = CheckPrevInst(&hMutex) )
	{
		SetForegroundWindow(hWnd);
        return FALSE;
	}

	// We now need to create the job tasks.
	//
	g_Tasks = CreateTasks();
	InitJobs(g_Tasks);

	// Now we should pick up any data from the registry that we need.
	//
	if ( RegExists(HKLM, g_szTuneupKey, g_szRegValFirstTime) )
	{
		// Get previous time scheme.
		//
		g_nTimeScheme = RegGetDword(HKLM, g_szTuneupKey, g_szRegValTime);
		
		// Get previous express or custom.
		//
		if ( RegCheck(HKLM, g_szTuneupKey, g_szRegValCustom) )
			g_dwFlags |= TUNEUP_CUSTOM;
		
		// Display the how to run dialog.  If TRUE is
		// returned, we should run the wizard.  Otherwise
		// the user choose cancel or the tasks were all run
		// and we should just return.
		//
		bRunWizard = HowToRun();
	}
	else
	{
		// Set the flag so that tuneup knows this is
		// the first time it has been run.
		//
		g_dwFlags |= TUNEUP_NOSCHEDULE;

		// Set this so that we do run the wizard.
		//
		bRunWizard = TRUE;
	}

	// Now set any default values that should be set.
	//
	if ( g_nTimeScheme == 0)
		g_nTimeScheme = DEFAULT_TIMESCHEME;

	// Start the wizard if we need to.
	//
	if ( bRunWizard )
		CreateWizard(hInstance, NULL);

	// Free the job tasks we created.
	//
	FreeTasks(g_Tasks);

	// Release the mutex.
	//
	if (hMutex)
		ReleaseMutex(hMutex);

	return TRUE;
}



//
// Internal function(s).
//

static HANDLE GetMutex()
{
	const TCHAR szTuneupMutex[] = _T("TUNEUP97MUTEX");
	HANDLE		hMutex;

	// Try to open the Tuneup mutex.
	//
    if ( hMutex = OpenMutex(SYNCHRONIZE, FALSE, szTuneupMutex) )
	{
		// There is already another mutex, so we can't get one
		// and there should be another Tuneup window to find.
		//
		CloseHandle(hMutex);
		hMutex = NULL;
	}
	else
	{		
		// No mutex is present, so we should be able to get one.
		//
		hMutex = CreateMutex(NULL, FALSE, szTuneupMutex);
    }

	// Return the mutex, will be NULL if there alread is one.
	//
	return hMutex;
}


static HWND CheckPrevInst(LPHANDLE hMutex)
{
    HWND	hWnd	= NULL;
	BOOL	bPrev	= FALSE;
    int		nCount;

	// Loop until another tuneup window is found or a mutex can
	// be created.  Max of 10 times (10 seconds).
	//
	for (nCount = 0; (nCount < 10) && (!bPrev) && ( (*hMutex = GetMutex()) == NULL ); nCount++)
	{
#if 0
		// Check for the background window of the wizard.
		//
		if ( bPrev = ( ( hWnd = FindWindow(NULL, g_szAppName) ) != NULL ) )
		{
			// The background window was found, so show the prev one (i.e. Wizard).
			//
			hWnd = GetWindow(hWnd, GW_HWNDPREV);
		}
		else
		{
			// Check for the how to run dialog.
			//
			bPrev = ( ( hWnd = FindWindow(NULL, g_szAppName) ) != NULL );
		}
#else
		bPrev = ( ( hWnd = FindWindow(NULL, g_szAppName) ) != NULL );
#endif

		// If we found no window, sleep for 1 second.
		//
		if (!bPrev)
			Sleep(1000);
	}

	// Return the window handle of any previous instance (will be null if we
	// didn't find or we got a mutex).
	//
	return hWnd;
}


static BOOL TanslateCommandLine(LPTSTR lpArg)
{
	BOOL	bTranslated = TRUE;

	// Check for the /AUTORUN flag.
	//
	if ( _tcsicmp(_T("/AUTORUN"), lpArg) == 0 )
		g_dwFlags |= TUNEUP_AUTORUN;

	// Check for the /SERVICE: flag.
	//
	else if ( _tcsnicmp(_T("/SERVICE:"), lpArg, 9) == 0 )
	{
		ServiceStart(lpArg + 9);
		g_dwFlags |= TUNEUP_QUIT;
	}

	// Unknown option.
	//
	else
		bTranslated = FALSE;

	return bTranslated;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\tuneup\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Tuneup.rc
//
#define IDS_TUNEUP                      101
#define IDI_TUNEUP                      101
#define IDD_FIRST                       107
#define IDD_PROGRESS                    109
#define IDB_WATERMARK                   112
#define IDB_HEADER                      113
#define IDI_CHECK                       114
#define IDI_UNCHECK                     115
#define IDC_YES                         201
#define IDC_DENY                        202
#define IDC_RESCHED                     204
#define IDC_SETTING                     205
#define IDC_SUMLIST                     221
#define IDC_SCHEDTEXT                   250
#define IDD_WELCOME                     1000
#define IDD_TIME                        1001
#define IDD_STARTMENU                   1002
#define IDD_CLEANUP                     1008
#define IDD_TASK                        1012
#define IDD_SUMMARY                     1013
#define IDD_BACKUP                      1014
#define IDC_EXPRESS                     1025
#define IDC_MANUAL                      1026
#define IDC_NIGHT                       1027
#define IDC_DAY                         1028
#define IDC_EVENING                     1029
#define IDC_STATIC_TITLE                1034
#define IDC_USERS                       1037
#define IDC_SELUSER                     1038
#define IDC_STARTUP                     1039
#define IDC_SUMTEXT                     1043
#define IDC_RUNNOW                      1044
#define IDC_NOTASKS                     1045
#define IDC_STARTUPTEXT                 1049
#define IDC_BACKUPYES                   1050
#define IDC_BACKUPNO                    1051
#define IDC_TITLE                       1056
#define IDC_CHANGE                      1057
#define IDC_CURRENT                     1057
#define IDC_RESET                       1058
#define IDC_TASKDESC                    1058
#define IDC_PROGRAMS                    1061
#define IDC_CUSETTING                   1062
#define IDC_LISTSET                     1112
#define IDS_TASK_SMTIDY                 2010
#define IDS_TASK_CIDAEMON               2012
#define IDS_TASK_BACKUP                 2013
#define IDS_TASK_CHKDSK                 2014
#define IDS_TASK_CLEANUP                2015
#define IDS_NO_CLEANUP                  2022
#define IDS_OUTOFMEMORY                 2023
#define IDS_DEL_FILE                    2024
#define IDS_JOB_CREATE_FAIL             2025
#define IDS_RESCHED                     2026
#define IDS_SEARCHING                   2027
#define IDS_STARTUP                     2029
#define IDS_ONCOMPLETE                  2030
#define IDS_OFFICE97_STARTUP            2032
#define IDS_OFFICE95_STARTUP            2033
#define IDS_APPLET_NOTEXIST1            2034
#define IDS_APPLET_NOTEXIST2            2035
#define IDS_REM_NIGHT                   2036
#define IDS_REM_DAY                     2037
#define IDS_REM_EVENING                 2038
#define IDS_REM_CUSTOM                  2039
#define IDS_BOLDFONTNAME                2040
#define IDS_BOLDFONTSIZE                2041
#define IDS_APTUNEUP                    2042
#define IDS_CMT_SMTIDY                  2043
#define IDS_CMT_CIDAEMON                2044
#define IDS_CMT_BACKUP                  2045
#define IDS_CMT_CHKDSK                  2047
#define IDS_CMT_CLEANUP                 2048
#define IDS_CHECKFONTNAME               2049
#define IDS_TITLEFONTNAME               2050
#define IDS_TITLEFONTSIZE               2051
#define IDS_TITLE_STARTMENU             2052
#define IDS_SUBTITLE_STARTMENU          2053
#define IDS_TITLE_TIME                  2054
#define IDS_SUBTITLE_TIME               2055
#define IDS_TITLE_CHKDSK                2056
#define IDS_SUBTITLE_CHKDSK             2057
#define IDS_TITLE_CIDAEMON              2060
#define IDS_SUBTITLE_CIDAEMON           2061
#define IDS_TITLE_CLEANUP               2062
#define IDS_SUBTITLE_CLEANUP            2063
#define IDS_TITLE_SMTIDY                2066
#define IDS_SUBTITLE_SMTIDY             2067
#define IDS_TEXT_SMTIDY                 2068
#define IDS_ALLUSERS                    2074
#define IDS_DEFAULTUSER                 2075
#define IDS_YES                         2076
#define IDS_NO                          2077
#define IDS_TASKDIR                     2079
#define IDS_JOBEXT                      2080
#define IDS_CHECKFONTSIZE               2081
#define IDS_DESC_SMTIDY                 2082
#define IDS_DESC_CHKDSK                 2083
#define IDS_DESC_CLEANUP                2084
#define IDS_DESC_CIDAEMON               2085
#define IDS_YES_CHKDSK                  2086
#define IDS_NO_CHKDSK                   2087
#define IDS_YES_CIDAEMON                2088
#define IDS_NO_CIDAEMON                 2089
#define IDS_SUM_CHKDSK                  2090
#define IDS_SUM_CLEANUP                 2091
#define IDS_SUM_CIDAEMON                2092
#define IDS_STARTUPTEXT                 2093
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        117
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1063
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\tuneup\registry.h ===
//////////////////////////////////////////////////////////////////////////////
//
// REGISTRY.H
//
//  Microsoft Confidential
//  Copyright (cMicrosoft Corporation 1998
//  All rights reserved
//
//  Registry function prototypes for the application.
//
//  4/98 - Jason Cohen (JCOHEN)
//
//////////////////////////////////////////////////////////////////////////////


#ifndef _REGISTRY_H_
#define _REGISTRY_H_


//
// Include file(s).
//

#include <windows.h>


//
// Defined root keys.
//

#define HKCR	HKEY_CLASSES_ROOT
#define HKCU	HKEY_CURRENT_USER
#define HKLM	HKEY_LOCAL_MACHINE
#define HKU		HKEY_USERS


//
// Type definitions.
//

typedef BOOL (CALLBACK * REGENUMKEYPROC) (HKEY, LPTSTR, LPARAM);
typedef BOOL (CALLBACK * REGENUMVALPROC) (LPTSTR, LPTSTR, LPARAM);


//
// External function prototypes.
//

BOOL	RegExists(HKEY, LPTSTR, LPTSTR);
BOOL	RegDelete(HKEY, LPTSTR, LPTSTR);
LPTSTR 	RegGetString(HKEY, LPTSTR, LPTSTR);
LPVOID	RegGetBin(HKEY, LPTSTR, LPTSTR);
DWORD 	RegGetDword(HKEY, LPTSTR, LPTSTR);
BOOL	RegSetString(HKEY, LPTSTR, LPTSTR, LPTSTR);
BOOL	RegSetDword(HKEY, LPTSTR, LPTSTR, DWORD);
BOOL	RegCheck(HKEY, LPTSTR, LPTSTR);
BOOL    RegEnumKeys(HKEY, LPTSTR, REGENUMKEYPROC, LPARAM, BOOL);
BOOL    RegEnumValues(HKEY, LPTSTR, REGENUMVALPROC, LPARAM, BOOL);


#endif // _REGISTRY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\tuneup\registry.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// REGISTRY.C
//
//  Microsoft Confidential
//  Copyright (cMicrosoft Corporation 1998
//  All rights reserved
//
//  Registry functions for the application to easily interface with the 
//  registry.
//
//  4/98 - Jason Cohen (JCOHEN)
//
//////////////////////////////////////////////////////////////////////////////


// Include files
//
#include <windows.h>
#include "jcohen.h"
#include "registry.h"


BOOL RegExists(HKEY hKeyReg, LPTSTR lpKey, LPTSTR lpValue)
{
	HKEY	hOpenKey	= NULL;
	BOOL	bExists		= FALSE;

	if (lpKey)
	{
		if (RegOpenKeyEx(hKeyReg, lpKey, 0, KEY_ALL_ACCESS, &hOpenKey) != ERROR_SUCCESS)
			return bExists;
	}
	else
		hOpenKey = hKeyReg;

	if (lpValue)
		bExists = (RegQueryValueEx(hOpenKey, lpValue, NULL, NULL, NULL, NULL) == ERROR_SUCCESS);
	else
		bExists = TRUE;

	if (lpKey)
		RegCloseKey(hOpenKey);

	return bExists;
}


BOOL RegDelete(HKEY hRootKey, LPTSTR lpSubKey, LPTSTR lpValue) {

	BOOL bSuccess = FALSE;

	if (lpValue) {

		if (lpSubKey) {

			HKEY	hRegKey;

			if (RegOpenKeyEx(hRootKey, lpSubKey, 0, KEY_ALL_ACCESS, &hRegKey) == ERROR_SUCCESS) {

				bSuccess = (RegDeleteValue(hRegKey, lpValue) == ERROR_SUCCESS);
				RegCloseKey(hRegKey);

			}

		}
		else
			bSuccess = (RegDeleteValue(hRootKey, lpValue) == ERROR_SUCCESS);

	}
	else
		bSuccess = (RegDeleteKey(hRootKey, lpSubKey) == ERROR_SUCCESS);

	return bSuccess;

}


LPTSTR RegGetString(HKEY hKeyReg, LPTSTR lpKey, LPTSTR lpValue)
{
	HKEY	hOpenKey	= NULL;
	LPTSTR	lpBuffer	= NULL,
			lpExpand	= NULL;
	DWORD	dwSize		= 0,
			dwType;

	// If the key is specified, we must open it.  Otherwise we can
	// just use the HKEY passed in.
	//
	if (lpKey)
	{
		// If the open key fails, return NULL because the value can't exist.
		//
		if (RegOpenKeyEx(hKeyReg, lpKey, 0, KEY_ALL_ACCESS, &hOpenKey) != ERROR_SUCCESS)
			return NULL;
	}
	else
		hOpenKey = hKeyReg;

	// Now query the value to get the size to allocate.  Make sure the date
	// type is a string and that the malloc doesn't fail.
	//
	if ( ( RegQueryValueEx(hOpenKey, lpValue, NULL, &dwType, NULL, &dwSize) == ERROR_SUCCESS ) &&
	     ( ( dwType == REG_SZ ) || ( dwType == REG_EXPAND_SZ ) ) &&
	     ( lpBuffer = (LPTSTR) MALLOC(dwSize) ) )
	{
		// We know the value exists and we have the memory we need to query the value again.
		//
		if ( ( RegQueryValueEx(hOpenKey, lpValue, NULL, NULL, (LPBYTE) lpBuffer, &dwSize) == ERROR_SUCCESS ) &&
		     ( ( dwType == REG_SZ ) || ( dwType == REG_EXPAND_SZ ) ) )
		{
			// We should expand it if it is supposed to be.
			//
			if ( dwType == REG_EXPAND_SZ )
			{
				if ( ( dwSize = ExpandEnvironmentStrings(lpBuffer, NULL, 0) ) &&
				     ( lpExpand = (LPTSTR) MALLOC(dwSize * sizeof(TCHAR)) ) &&
				     ( ExpandEnvironmentStrings(lpBuffer, lpExpand, dwSize) ) &&
				     ( *lpExpand ) )
				{
					// The expand worked, so free the original buffer and return
					// the expanded one.
					//
					FREE(lpBuffer);
					lpBuffer = lpExpand;
				}
				else
				{
					// The expand failed see we should free everything up
					// and return NULL.
					//
					FREE(lpExpand);
					FREE(lpBuffer);
				}
			}
		}
		else
			// For some reason the query failed, that shouldn't happen
			// but now we need to free and return NULL.
			//
			FREE(lpBuffer);
	}

	// If we opened a key, we must close it.
	//
	if (lpKey)
		RegCloseKey(hOpenKey);

	// Return the buffer allocated, or NULL if something failed.
	//
	return lpBuffer;
}


LPVOID RegGetBin(HKEY hKeyReg, LPTSTR lpKey, LPTSTR lpValue) {

	HKEY	hOpenKey	= NULL;
	LPVOID	lpBuffer	= NULL;
	DWORD	dwSize		= 0,
			dwType;

	// If the key is specified, we must open it.  Otherwise we can
	// just use the HKEY passed in.
	//
	if (lpKey)
	{
		// If the open key fails, return NULL because the value can't exist.
		//
		if (RegOpenKeyEx(hKeyReg, lpKey, 0, KEY_ALL_ACCESS, &hOpenKey) != ERROR_SUCCESS)
			return NULL;
	}
	else
		hOpenKey = hKeyReg;

	// Now query the value to get the size to allocate.  Make sure the date
	// type is a string and that the malloc doesn't fail.
	//
	if ( ( RegQueryValueEx(hOpenKey, lpValue, NULL, &dwType, NULL, &dwSize) == ERROR_SUCCESS ) &&
	     ( dwType == REG_BINARY ) &&
	     ( lpBuffer = MALLOC(dwSize) ) )
	{
		// We know the value exists and we have the memory we need to query the value again.
		//
		if ( ( RegQueryValueEx(hOpenKey, lpValue, NULL, NULL, (LPBYTE) lpBuffer, &dwSize) != ERROR_SUCCESS ) ||
		     ( dwType != REG_BINARY ) )
			// For some reason the query failed, that shouldn't happen
			// but now we need to free and return NULL.
			//
			FREE(lpBuffer);
	}

	// If we opened a key, we must close it.
	//
	if (lpKey)
		RegCloseKey(hOpenKey);

	// Return the buffer allocated, or NULL if something failed.
	//
	return lpBuffer;
}


DWORD RegGetDword(HKEY hKeyReg, LPTSTR lpKey, LPTSTR lpValue) {

	HKEY	hOpenKey	= NULL;
	DWORD	dwBuffer,
			dwSize		= sizeof(DWORD),
			dwType;


	if (lpKey) {

		if (RegOpenKeyEx(hKeyReg, lpKey, 0, KEY_ALL_ACCESS, &hOpenKey) != ERROR_SUCCESS)
			return 0;

	}
	else
		hOpenKey = hKeyReg;

	if ( (RegQueryValueEx(hOpenKey, lpValue, NULL, &dwType, (LPBYTE) &dwBuffer, &dwSize) != ERROR_SUCCESS) ||
	     (dwSize != sizeof(DWORD)) )

		dwBuffer = 0;

	if (lpKey)
		RegCloseKey(hOpenKey);

	return dwBuffer;

}


BOOL RegSetString(HKEY hRootKey, LPTSTR lpSubKey, LPTSTR lpValue, LPTSTR lpData) {

	BOOL bSuccess = FALSE;

	if (lpSubKey) {

		HKEY	hRegKey;
		DWORD	dwBuffer;

		if (RegCreateKeyEx(hRootKey, lpSubKey, 0, TEXT(""), 0, KEY_ALL_ACCESS, NULL, &hRegKey, &dwBuffer) == ERROR_SUCCESS) {

			bSuccess = (RegSetValueEx(hRegKey, lpValue, 0, REG_SZ, (CONST BYTE *) lpData, lstrlen(lpData) + 1) == ERROR_SUCCESS);
			RegCloseKey(hRegKey);

		}

	}
	else

		bSuccess = (RegSetValueEx(hRootKey, lpValue, 0, REG_SZ, (CONST BYTE *) lpData, lstrlen(lpData) + 1) == ERROR_SUCCESS);

	return bSuccess;

}


BOOL RegSetDword(HKEY hRootKey, LPTSTR lpSubKey, LPTSTR lpValue, DWORD dwData) {

	BOOL bSuccess = FALSE;

	if (lpSubKey) {

		HKEY	hRegKey;
		DWORD	dwBuffer;

		if (RegCreateKeyEx(hRootKey, lpSubKey, 0, TEXT(""), 0, KEY_ALL_ACCESS, NULL, &hRegKey, &dwBuffer) == ERROR_SUCCESS) {

			bSuccess = (RegSetValueEx(hRegKey, lpValue, 0, REG_DWORD, (CONST BYTE *) &dwData, sizeof(dwData)) == ERROR_SUCCESS);
			RegCloseKey(hRegKey);

		}

	}
	else

		bSuccess = (RegSetValueEx(hRootKey, lpValue, 0, REG_SZ, (CONST BYTE *) &dwData, sizeof(dwData)) == ERROR_SUCCESS);

	return bSuccess;

}


BOOL RegCheck(HKEY hKeyRoot, LPTSTR lpKey, LPTSTR lpValue)
{
	LPTSTR		lpBuffer;
	DWORD		dwSize = 0,
				dwType,
				dwBuffer = 0;
	HKEY		hKeyReg;
	BOOL		bReturn = FALSE;

    if (lpKey)
    {
		if (RegOpenKeyEx(hKeyRoot, lpKey, 0, KEY_ALL_ACCESS, &hKeyReg) != ERROR_SUCCESS)
			return 0;
	}
	else
		hKeyReg = hKeyRoot;

	// Query for the value and allocate the memory for the 
	// value data if it is type REG_SZ.
	//
	if (RegQueryValueEx(hKeyReg, lpValue, NULL, &dwType, NULL, &dwSize) == ERROR_SUCCESS)
    {
		if (dwType == REG_SZ)
        {
			// It is a string value, must allocate a buffer for the string.
			//
			if (lpBuffer = (LPTSTR) MALLOC(dwSize))
            {
				if ( (RegQueryValueEx(hKeyReg, lpValue, NULL, NULL, (LPBYTE) lpBuffer, &dwSize) == ERROR_SUCCESS) &&
					(*lpBuffer != '0') && (*lpBuffer) )
                {
					dwBuffer = 1;
				}
    			FREE(lpBuffer);
			}
		}
		else
        {
			// Must be a DWORD or BIN value.
			//
			RegQueryValueEx(hKeyReg, lpValue, NULL, &dwType, (LPBYTE) &dwBuffer, &dwSize);
        }

		bReturn = (dwBuffer != 0);
	}

    if (lpKey)
		RegCloseKey(hKeyReg);

	return bReturn;
}


BOOL RegEnumKeys(HKEY hKey, LPTSTR lpRegKey, REGENUMKEYPROC hCallBack, LPARAM lParam, BOOL bDelKeys)
{
	TCHAR		szKeyName[MAX_PATH + 1];
	DWORD		dwIndex		= 0,
				dwSize		= sizeof(szKeyName);
	HKEY		hKeyReg,
				hKeyEnum;
	BOOL		bReturn		= TRUE;
	
	// Open a key handle to the key to enumerate.
	//
	if ( ( lpRegKey == NULL ) || 
         ( RegOpenKeyEx(hKey, lpRegKey, 0, KEY_ALL_ACCESS, &hKeyReg) == ERROR_SUCCESS ) )
	{
		// Enumerate all the subkeys in this key.
		//
		while ( bReturn && ( RegEnumKeyEx(hKeyReg, dwIndex, szKeyName, &dwSize, NULL, NULL, NULL, NULL) == ERROR_SUCCESS ) )
		{
			if ( RegOpenKeyEx(hKeyReg, szKeyName, 0, KEY_ALL_ACCESS, &hKeyEnum) == ERROR_SUCCESS )
			{
				bReturn = hCallBack(hKeyEnum, szKeyName, lParam);
				RegCloseKey(hKeyEnum);
			}
			if ( !bDelKeys || ( RegDeleteKey(hKeyReg, szKeyName) != ERROR_SUCCESS ) )
				dwIndex++;
			dwSize = sizeof(szKeyName);
		}
		if (lpRegKey)
			RegCloseKey(hKeyReg);
	}
	else
		bReturn = FALSE;
	return bReturn;
}


BOOL RegEnumValues(HKEY hKey, LPTSTR lpRegKey, REGENUMVALPROC hCallBack, LPARAM lParam, BOOL bDelValues) {

	TCHAR		szValueName[MAX_PATH + 1];
	LPTSTR		lpBuffer;
	DWORD		dwIndex		= 0,
				dwSize		= sizeof(szValueName),
				dwDataSize	= 0,
				dwType;
	HKEY		hKeyReg;
	BOOL		bReturn		= TRUE;

	
	// Open a key handle to the key to enumerate.
	//
    if ( (lpRegKey == NULL) || 
         (RegOpenKeyEx(hKey, lpRegKey, 0, KEY_ALL_ACCESS, &hKeyReg) == ERROR_SUCCESS) ) {

		// Enumerate all the values in this key.
		//
		while (bReturn && (RegEnumValue(hKeyReg, dwIndex, szValueName, &dwSize, NULL, &dwType, NULL, &dwDataSize) == ERROR_SUCCESS)) {

			if ((dwType == REG_SZ) &&
				(lpBuffer = (LPTSTR) MALLOC(dwDataSize))) {

				if (RegQueryValueEx(hKeyReg, szValueName, NULL, NULL, (LPBYTE) lpBuffer, &dwDataSize) == ERROR_SUCCESS)
					bReturn = hCallBack(szValueName, lpBuffer, lParam);

				FREE(lpBuffer);

			}

			if ( !bDelValues || (RegDeleteValue(hKeyReg, szValueName) != ERROR_SUCCESS) )
                dwIndex++;

			dwSize = sizeof(szValueName);
			dwDataSize = 0;

		}

        if (lpRegKey)
		    RegCloseKey(hKeyReg);

	}
	else
		bReturn = FALSE;

	return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\tuneup\runnow.h ===
//////////////////////////////////////////////////////////////////////////////
//
// RUNNOW.H
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  Includes all external include files, defined values, macros, data
//  structures, and fucntion prototypes for the corisponding CXX file.
//
//  Jason Cohen (JCOHEN)
//
//////////////////////////////////////////////////////////////////////////////


// Only include this file once.
//
#ifndef _RUNNOW_H_
#define _RUNNOW_H_


// Include file(s).
//
#include <windows.h>


// External function prototype(s).
//
VOID RunTasksNow(HWND, LPTASKDATA);


#endif // _RUNNOW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\tuneup\schedwiz.h ===
//////////////////////////////////////////////////////////////////////////////
//
// SCHEDWIZ.H / Tuneup
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  Includes all external include files, defined values, macros, data
//  structures, and fucntion prototypes for the corisponding CXX file.
//
//  7/98 - Jason Cohen (JCOHEN)
//
//////////////////////////////////////////////////////////////////////////////


// Only include this file once.
//
#ifndef _SCHEDWIZ_H_
#define _SCHEDWIZ_H_


// Include file(s).
//
#include <windows.h>
#include "main.h"


// External function prototype(s).
//
BOOL	InitJobs(LPTASKDATA);
VOID	ReleaseJobs(LPTASKDATA, BOOL);
BOOL	JobReschedule(HWND, ITask *);
LPTSTR	GetTaskTriggerText(ITask *);
LPTSTR	GetNextRunTimeText(ITask *, DWORD);

VOID	ResolveLnk(VOID);
VOID	SetTimeScheme(INT);
INT		GetTimeScheme(VOID);


#endif // _SCHEDWIZ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\tuneup\scm.h ===
//////////////////////////////////////////////////////////////////////////////
//
// SCM.H
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  Service Control Manager function prototypes.
//
//  9/98 - Jason Cohen (JCOHEN)
//
//////////////////////////////////////////////////////////////////////////////

#ifndef _SCM_H_
#define _SCM_H_


// Internal include file(s).
//
#include <windows.h>


// External function prototypes.
//
BOOL ServiceStart(LPCTSTR);
BOOL ServiceRunning(LPCTSTR);


#endif // _SCM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\tuneup\startup.h ===
//////////////////////////////////////////////////////////////////////////////
//
// STARTUP.H
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  Includes all external include files, defined values, macros, data
//  structures, and fucntion prototypes for the corisponding CXX file.
//
//  Jason Cohen (JCOHEN)
//
//////////////////////////////////////////////////////////////////////////////



// Only include this file once.
//
#ifndef _STARTUP_H_
#define _STARTUP_H_


// Include file(s).
//
#include <windows.h>


// External function prototype(s).
//
VOID	InitStartupMenu(HWND);
VOID	ReleaseStartupMenu(HWND);
BOOL	InitStartupList(HWND);
BOOL	UserHasStartupItems(VOID);
VOID	SelectUserRadio(HWND, BOOL);
BOOL	StartupDrawItem(HWND, const DRAWITEMSTRUCT *);
VOID	StartupSelectItem(HWND);


#endif // _STARTUP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\tuneup\schedwiz.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// SCHEDWIZ.CPP / Tuneup
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  Functions for the summary wizard page.
//
//  8/98 - Jason Cohen (JCOHEN)
//
//////////////////////////////////////////////////////////////////////////////


//
// Internal include file(s).
//

#include <windows.h>
#include <prsht.h>
#include "schedwiz.h"
#include "main.h"
//#include "resource.h"
//#include "mstask.h"
#include <io.h>
//#include <oleguid.h>


//
// Internal defined value(s).
//

#define TASK_BIMONTH_ODD		(TASK_JANUARY | TASK_MARCH | TASK_MAY | TASK_JULY | TASK_SEPTEMBER | TASK_NOVEMBER)
#define TASK_BIMONTH_EVEN		(TASK_FEBRUARY | TASK_APRIL | TASK_JUNE | TASK_AUGUST | TASK_OCTOBER | TASK_DECEMBER)
#define TASK_QUARTER_1			(TASK_JANUARY | TASK_MAY | TASK_SEPTEMBER)
#define TASK_QUARTER_2			(TASK_FEBRUARY | TASK_JUNE | TASK_OCTOBER)
#define TASK_QUARTER_3			(TASK_MARCH | TASK_JULY | TASK_NOVEMBER)
#define TASK_QUARTER_4			(TASK_APRIL | TASK_AUGUST | TASK_DECEMBER)
#define TASK_WHOLE_YEAR			(TASK_BIMONTH_ODD | TASK_BIMONTH_EVEN)


//
// Internal defined macro(s).
//

#define E_JOB_FAIL(x)	(x == E_OUTOFMEMORY ? IDS_OUTOFMEMORY : IDS_JOB_CREATE_FAIL)


//
// Internal global variable(s).
//

ITaskScheduler		*g_psa = NULL;


//
// Inernal function prototype(s).
//

static VOID InitJobTime(TASK_TRIGGER *, INT, INT);
static BOOL	GetJobFileName(LPTSTR, LPTSTR);
static VOID IncDate(LPWORD, LPWORD, LPWORD, INT);
static BOOL	DeleteOrgJobFile(LPTSTR);
static INT	WeekDayToNum(INT);
static VOID	taskSetNextDay(TASK_TRIGGER *);
static BOOL	IsScheduledTasks(LPTASKDATA);
static BOOL	GetTaskTrigger(ITask *, TASK_TRIGGER *);


//
// External function(s).
//


BOOL InitJobs(LPTASKDATA lpGlobalTasks)
{
    ITaskTrigger   *pTrigger = NULL;
	WORD			wTrigger;
	HRESULT			hResult;
	BOOL			bErr = FALSE;
	LPTASKDATA		lpTask;

#ifdef _UNICODE
	LPWSTR			lpwBuffer;
#else // _UNICODE
	WCHAR			szwBuffer[256];
	LPWSTR			lpwBuffer = szwBuffer;
#endif // _UNICODE

	// Initialize the COM library.
	//
	if ( ( (hResult = CoInitialize(NULL)) != S_OK ) && (hResult == S_FALSE) )
		return FALSE;

	// Initialize ISchedulingAgent.
	//
	if ( CoCreateInstance(CLSID_CSchedulingAgent, NULL, CLSCTX_INPROC_SERVER, IID_ISchedulingAgent, (void **) &g_psa) != S_OK )
		return FALSE;

	for (lpTask = lpGlobalTasks; lpTask && !bErr; lpTask = lpTask->lpNext)
	{
		// Load the task (.job) with ITaskScheduler::Activate().
		//
		ANSIWCHAR(lpwBuffer, lpTask->lpJobName, sizeof(szwBuffer));
		if ( (hResult = g_psa->Activate((LPCWSTR) lpwBuffer, IID_ITask, (IUnknown**) &lpTask->pTask)) == E_OUTOFMEMORY )
			bErr = ErrMsg(NULL, IDS_OUTOFMEMORY);
		else
		{
			// We should search for a task with the same app name if the
			// above activate call failed.
			//
			if ( hResult == S_OK )
			{
				// Get the existing flags for the job with IScheduledWorkItem::GetFlags().
				//
				if ( (hResult = lpTask->pTask->GetFlags(&lpTask->dwFlags)) == S_OK )
				{
					// Setup our internal flags for the task.
					//
					if ( lpTask->dwFlags & TASK_FLAG_DISABLED )
						lpTask->dwOptions &= ~TASK_SCHEDULED;
					else
						lpTask->dwOptions |= TASK_SCHEDULED;

					// IScheduledWorkItem::GetTrigger().
					//
					// TODO:  why do we need this data saved.
					//
					if ( (hResult = lpTask->pTask->GetTrigger((WORD) 0, &pTrigger)) == S_OK )
					{
						pTrigger->GetTrigger(&lpTask->Trigger);

						pTrigger->Release();
					}
				}
			}

			// If we didn't load the entire task successfully, we should
			// delete any that is there and create a new one.
			//
			if (hResult != S_OK)
			{
				// Delete existing (maybe corrupted) job file.
				//
				if ( !DeleteOrgJobFile(lpTask->lpJobName) )
					bErr = ErrMsg(NULL, IDS_DEL_FILE);
				else
				{
					ANSIWCHAR(lpwBuffer, lpTask->lpJobName, sizeof(szwBuffer));
					hResult = g_psa->NewWorkItem((LPCWSTR) lpwBuffer, CLSID_CTask, IID_ITask, (IUnknown**) &lpTask->pTask);
					if ( (hResult != S_OK) || (lpTask->pTask == NULL) )
						bErr = ErrMsg(NULL, E_JOB_FAIL(hResult));
					else
					{
						// Make sure Tuneup knows this is a new task and is
						// scheduled by default.
						//
						lpTask->dwOptions |= TASK_NEW;
						lpTask->dwOptions |= TASK_SCHEDULED;

						// Set the application name to the full path name of the task.
						//
						ANSIWCHAR(lpwBuffer, lpTask->lpFullPathName, sizeof(szwBuffer));
						lpTask->pTask->SetApplicationName((LPCWSTR) lpwBuffer);

						// Set the working directory for the task (always empty string).
						//
						lpTask->pTask->SetWorkingDirectory((LPCWSTR) L"");

						// Set the parameters for the task (not required).
						//
						if ( lpTask->lpParameters )
						{
							ANSIWCHAR(lpwBuffer, lpTask->lpParameters, sizeof(szwBuffer));
							lpTask->pTask->SetParameters(lpwBuffer);
						}

						// Set the comment for the task (not required).
						//
						if ( lpTask->lpComment )
						{
							ANSIWCHAR(lpwBuffer, lpTask->lpComment, sizeof(szwBuffer));
							lpTask->pTask->SetComment(lpwBuffer);
						}

						// Set the default flags for the task.
						//
						lpTask->pTask->SetFlags(lpTask->dwFlags);

						// For some reason we do this for all tasks
						// but cleanup.
						//
						if ( !( lpTask->dwOptions & TASK_NOIDLE ) )
							lpTask->pTask->SetIdleWait(10, 999);

						// Create trigger item.
						//
						if ( (hResult = lpTask->pTask->CreateTrigger(&wTrigger, &pTrigger)) != S_OK)
							bErr = ErrMsg(NULL, E_JOB_FAIL(hResult));
						else
						{
							InitJobTime(&lpTask->Trigger, lpTask->nSchedule, g_nTimeScheme);
							pTrigger->SetTrigger(&lpTask->Trigger);

							pTrigger->Release();
						}
					}
				}
			}
		}
	}

	if (bErr)
		ReleaseJobs(lpGlobalTasks, FALSE);
	return bErr;
}


VOID ReleaseJobs(LPTASKDATA lpGlobalTasks, BOOL bFinish)
{
	ITaskTrigger	*pTrigger;
	IPersistFile	*pPersistFile;
	LPTASKDATA		lpTask;

	for (lpTask = lpGlobalTasks; lpTask; lpTask = lpTask->lpNext)
	{
		// Check to see if used in initialization fail handler
		// or the item is not needed.
		//
		if ( lpTask->pTask != (ITask*) NULL )
		{
			if ( ( lpTask->dwOptions & TASK_NEW ) && !bFinish )
			{
				// The .job is newly created, and user choose Cancel.
				//
				DeleteOrgJobFile(lpTask->lpJobName);
			}
			else
			{
				// Even if the item is not scheduled, we still save it, because we
				// use the Enable/Disable flag in the .job to keep the Yes/No state.
				//
				if (bFinish)
				{
					// Take care the flag only, since the Task_Trigger is
					// auto saved in Schedule property page.
					//
					if ( !(g_dwFlags & TUNEUP_CUSTOM) || (lpTask->dwOptions & TASK_SCHEDULED) )
						lpTask->dwFlags &= ~TASK_FLAG_DISABLED;
					else
						lpTask->dwFlags |= TASK_FLAG_DISABLED;
				}
				else
				{
					// User canceled so restore Task_Trigger.
					//
					if ( lpTask->pTask->GetTrigger((WORD) 0, &pTrigger) == S_OK )
					{
						pTrigger->SetTrigger(&lpTask->Trigger);
						pTrigger->Release();
					}
				}

				// Set or restore flags.
				//
				lpTask->pTask->SetFlags(lpTask->dwFlags);	

				// Save the file, release the interfaces.
				//
				if ( lpTask->pTask->QueryInterface(IID_IPersistFile, (VOID **) &pPersistFile) == S_OK )
				{
					pPersistFile->Save((LPCOLESTR) NULL, TRUE);
					pPersistFile->Release();
				}
				lpTask->pTask->Release();

				/* BUGBUG:  I don't understand why this is here!

				// Rename the old task.
				//
				if ( ItemData[i].lpOldTaskName )
				{
					if ( bSave )
					{
						TCHAR	szSrc[MAX_PATH],
								szTgt[MAX_PATH],
								*ptr;

						//GetJobFileName(i, szTgt);		// get filename for delete or hide
						DeleteFile(szTgt);
						lstrcpy(szSrc, szTgt);
						if ( ptr = strrchr(szSrc, '\\') )
							lstrcpy(ptr+1, ItemData[i].lpOldTaskName);
						MoveFile(szSrc, szTgt);
					}
				}

				*/
			}
		}
	}

	// Release ISchedulingAgent.
	//
	g_psa->Release();

	// Close the OLE COM library.
	//
	CoUninitialize();
}


//////////////////////////////////////////////////////////////////////////////
//
// EXTERNAL:
//  JobReschedule()
//              - Reschedules a particular job.
//
// ENTRY:
//  hDlg        - Parent dialog for property sheet.
//
// EXIT:
//  BOOL
//
//////////////////////////////////////////////////////////////////////////////

BOOL JobReschedule(HWND hDlg, ITask * pJob)
{
	HPROPSHEETPAGE		hpsp[1];
    PROPSHEETHEADER		psh;
    TASK_TRIGGER		OldTrigger,
						NewTrigger;
	IProvideTaskPage	*pProvideTaskPage;
	LPTSTR				lpCaption;

	if ( pJob->QueryInterface(IID_IProvideTaskPage, (VOID**) &pProvideTaskPage) != S_OK )
		return FALSE;

	// We need the Schedule page only.
	//
	if ( pProvideTaskPage->GetPage(TASKPAGE_SCHEDULE, TRUE, &(hpsp[0])) != S_OK )
		return FALSE;

	// Get the caption string.
	//
	lpCaption = AllocateString(NULL, IDS_RESCHED);

	// Setup the property page header.
	//
	psh.dwSize		= sizeof(PROPSHEETHEADER);
	psh.dwFlags		= PSH_DEFAULT | PSH_NOAPPLYNOW;
	psh.hwndParent	= hDlg;
	psh.nPages		= 1;
	psh.nStartPage	= 0;
	psh.phpage		= (HPROPSHEETPAGE *) hpsp;
	psh.pszCaption	= lpCaption;

	// Keep original trigger.
	//
	GetTaskTrigger(pJob, &OldTrigger);

	// Display the property sheet page.
	//
	PropertySheet(&psh);

	// Release the page and other resources.
	//
	FREE(lpCaption);
	pProvideTaskPage->Release();

	// Get the new trigger, compare it to see whether it's changed.
	//
	GetTaskTrigger(pJob, &NewTrigger);

	// If the new time and the old time don't compare, then
	// we must change the time scheme to custom.
	//
	if ( memcmp((const void *) &OldTrigger, (const void *) &NewTrigger, sizeof(TASK_TRIGGER)) == 0 ) 
		return FALSE;

	return TRUE;
}


LPTSTR GetTaskTriggerText(ITask * pTask)
{
	LPWSTR	lpwBuffer;
	LPTSTR	lpReturn = NULL;
#ifdef _UNICODE
	LPTSTR	lpBuffer;
#else // _UNICODE
	TCHAR	szBuffer[256];
	LPTSTR	lpBuffer = szBuffer;
#endif // _UNICODE

	if ( pTask->GetTriggerString((WORD) 0, (LPWSTR *) &lpwBuffer) == S_OK )
	{
		// Convert the string if _UNICODE is not defined and set the
		// window to the new text.
		//
		WCHARANSI(lpBuffer, lpwBuffer, sizeof(szBuffer));

		if ( lpReturn = (LPTSTR) MALLOC(sizeof(TCHAR) * (lstrlen(lpBuffer) + 1)) )
			lstrcpy(lpReturn, lpBuffer);

		// Free the string returned from IScheduledWorkitem::GetTriggerString().
		//
		CoTaskMemFree(lpwBuffer);
	}
	return lpReturn;
}


LPTSTR GetNextRunTimeText(ITask * pTask, DWORD dwFlags)
{
	TCHAR		szTime[128],
				szDate[128];
	LPTSTR		lpReturn = NULL;
	SYSTEMTIME	stm;

	// If it's disabled, we can't get run time string.
	// JobRelease will clear it if the user cancels.
	//
	if ( dwFlags & TASK_FLAG_DISABLED )
	{
		dwFlags &= ~TASK_FLAG_DISABLED;
		pTask->SetFlags(dwFlags);
	}

	pTask->GetNextRunTime(&stm);

	if ( ( GetTimeFormat(GetUserDefaultLCID(), TIME_NOSECONDS, &stm, NULL, (LPTSTR) szTime, sizeof(szTime) / sizeof(TCHAR)) ) &&
	     ( GetDateFormat(GetUserDefaultLCID(), DATE_LONGDATE, &stm, NULL, (LPTSTR) szDate, sizeof(szDate) / sizeof(TCHAR)) ) &&
	     ( lpReturn = (LPTSTR) MALLOC(sizeof(TCHAR) * (lstrlen(szTime) + lstrlen(szDate) + 3)) ) )
	{
		wsprintf(lpReturn, _T("%s, %s"), szTime, szDate);
	}
	return lpReturn;
}


VOID SetTimeScheme(INT nTimeScheme)
{
	ITaskTrigger	*pTrigger;
	TASK_TRIGGER	SchemeTrigger;
	LPTASKDATA		lpTask;

	// Reset the static values in InitJobTime() since
	// we are resetting all the job times.
	//
	InitJobTime(NULL, 0, 0);

	// Go through all the tasks and update the task trigger for
	// the new time scheme.
	//
	for (lpTask = g_Tasks; lpTask; lpTask = lpTask->lpNext)
	{
		// Get the ITaskTrigger interface so we can set the task trigger.
		//
		if (lpTask->pTask->GetTrigger((WORD) 0, &pTrigger) == S_OK)
		{
			// Get the new task trigger for this job.
			//
			InitJobTime(&SchemeTrigger, lpTask->nSchedule, nTimeScheme);

			// Save the new task trigger to the job.
			//
			pTrigger->SetTrigger(&SchemeTrigger);

			// Release the ITaskTrigger interface.
			//
			pTrigger->Release();
		}
	}
}


static VOID InitJobTime(TASK_TRIGGER *pTrigger, INT nSchedule, INT nTimeScheme)
{
	SYSTEMTIME	stNow;
	static INT	nMonthDay	= 0,	// Used to stagger monthly items.
				nWeekDay	= 1,	// Used to staggar weekly items.
				nOnceDay	= 1;	// Used to staggar once items.

	INT			nDays[]		= { TASK_SUNDAY, TASK_MONDAY, TASK_TUESDAY, TASK_WEDNESDAY, TASK_THURSDAY, TASK_FRIDAY, TASK_SATURDAY };
	INT			nMonths[]	= { TASK_JANUARY, TASK_FEBRUARY, TASK_MARCH, TASK_APRIL, TASK_MAY, TASK_JUNE, TASK_JULY, TASK_AUGUST, TASK_SEPTEMBER, TASK_OCTOBER, TASK_NOVEMBER, TASK_DECEMBER };
	INT			nQuarters[]	= { TASK_QUARTER_1, TASK_QUARTER_2, TASK_QUARTER_3, TASK_QUARTER_4 };

	// If NULL is passed in for pTrigger,  we should reset the
	// initial values used for scheduling the tasks.
	//
	if ( pTrigger == NULL )
	{
		// Reset the static values.
		//
		nMonthDay = 0;
		nWeekDay = 1;
		nOnceDay = 1;
		return;
	}


	// Init the default trigger structure values.
	//
	ZeroMemory(pTrigger, sizeof(TASK_TRIGGER));
	pTrigger->cbTriggerSize = sizeof(TASK_TRIGGER);
	pTrigger->MinutesDuration = 999;

	// Set the trigger to activate today.
	//
	GetLocalTime(&stNow);
	pTrigger->wBeginMonth = stNow.wMonth;
	pTrigger->wBeginDay = stNow.wDay;
	pTrigger->wBeginYear = stNow.wYear;

	// Set the start hour and minute based on the time scheme.
	//
	switch (nTimeScheme)
	{
		case IDC_NIGHT:
			pTrigger->wStartHour = 0;
			pTrigger->wStartMinute = 0;
			break;
		case IDC_DAY:
			pTrigger->wStartHour = 12;
			pTrigger->wStartMinute = 00;
			break;
		case IDC_EVENING:
			pTrigger->wStartHour = 20;
			pTrigger->wStartMinute = 0;
			break;
	}

	// Set the schedule (once, daily, weekly, monthly, bimonthly, quarterly, or yearly).
	// The day of the week or month is incrimented each time so that once, weekly and
	// monthly tasks aren't scheduled for the same days.
	//
	switch (nSchedule)
	{
		case TASK_ONCE:
			pTrigger->TriggerType = TASK_TIME_TRIGGER_ONCE;
			IncDate(&(pTrigger->wBeginMonth), &(pTrigger->wBeginDay), &(pTrigger->wBeginYear), nOnceDay++);
			pTrigger->wStartHour += 2;
			break;
		case TASK_DAILY:
			pTrigger->TriggerType = TASK_TIME_TRIGGER_DAILY;
			pTrigger->Type.Daily.DaysInterval = 1;
			break;
		case TASK_WEEKLY:
			pTrigger->TriggerType = TASK_TIME_TRIGGER_WEEKLY;
			pTrigger->Type.Weekly.rgfDaysOfTheWeek = (USHORT)nDays[(((stNow.wDayOfWeek + nWeekDay++) % 7) + 7) % 7];
			pTrigger->Type.Weekly.WeeksInterval = 1;
			pTrigger->wStartMinute += 30;
			break;
		case TASK_MONTHLY:
		case TASK_BIMONTHLY:
		case TASK_QUARTLY:
		case TASK_YEARLY:
			pTrigger->TriggerType = TASK_TIME_TRIGGER_MONTHLYDATE;
			pTrigger->Type.MonthlyDate.rgfDays = (nMonthDay++ % 28) + 1;
			pTrigger->wStartHour++;
			switch (nSchedule)
			{
				case TASK_MONTHLY:
					pTrigger->Type.MonthlyDate.rgfMonths = TASK_WHOLE_YEAR;
					break;
				case TASK_BIMONTHLY:
					pTrigger->Type.MonthlyDate.rgfMonths = ((stNow.wMonth % 2) ? TASK_BIMONTH_EVEN : TASK_BIMONTH_ODD);
					break;
				case TASK_QUARTLY:
					pTrigger->Type.MonthlyDate.rgfMonths = (USHORT)nQuarters[(((stNow.wMonth + 1) % 4) + 4) % 4];
					break;
				case TASK_YEARLY:
					pTrigger->Type.MonthlyDate.rgfMonths = (USHORT)nMonths[(((stNow.wMonth + 1) % 12) + 12) % 12];
					break;
			}
			break;
	}
}


static VOID IncDate(LPWORD lpwMonth, LPWORD lpwDay, LPWORD lpwYear, INT iDays)
{
	SYSTEMTIME		SysTime;
	FILETIME		FileTime;
	LARGE_INTEGER	LargeInt;
	BOOL			bTwoDigit;

	// Setup the system structure.
	//
	ZeroMemory(&SysTime, sizeof(SYSTEMTIME));
	SysTime.wMonth = *lpwMonth;
	SysTime.wDay = *lpwDay;
	SysTime.wYear = *lpwYear;

	// Support two digit dates.
	//
	if ( bTwoDigit = ( SysTime.wYear < 100 ) )
	{
		if ( SysTime.wYear >= 80 )
			SysTime.wYear += 1900;
		else
			SysTime.wYear += 2000;
	}

	// Convert it to file time.
	//
	SystemTimeToFileTime(&SysTime, &FileTime);

	// Copy it to a large integer so we can add or subtract days.
	//
	memcpy(&LargeInt, &FileTime, sizeof(LARGE_INTEGER));

	// Add or subtract the days in nanoseconds.
	//
	LargeInt.QuadPart += iDays * Int32x32To64(24 * 60 * 60, 1000 * 10000);

	// Copy it back to the filetime structure.
	//
	memcpy(&FileTime, &LargeInt, sizeof(LARGE_INTEGER));

	// Convert it back to a systime structure.
	//
	FileTimeToSystemTime(&FileTime, &SysTime);

	// Return supported two digit dates.
	//
	if ( bTwoDigit )
	{
		if ( SysTime.wYear <= 2000 )
			SysTime.wYear -= 1900;
		else
			SysTime.wYear -= 2000;
	}

	// Return the new date.
	//
	*lpwMonth = SysTime.wMonth;
	*lpwDay = SysTime.wDay;
	*lpwYear = SysTime.wYear;
}


//////////////////////////////////////////////////////////////////////////////
//
// INTERNAL:
//  GetJobFileName() 
//    This routine returns the full path and file name to the job file
//    specified by the job name passed in.
//
// ENTRY:
//  LPTSTR lpJobName
//    This is the name of the job (as it appears in Task Scheduler) passed in.
//
//  LPTSTR lpJobFileName
//    This is the buffer that receives the full path and file name of the job
//    (%WINDIR%\Tasks\lpJobName.JOB).  Should be atleast MAX_PATH.
//    
//
// EXIT:
//  BOOL
//    TRUE  - Successfully retrieved all the information and filled in the buffer.
//    FALSE - Something failed.
//
//////////////////////////////////////////////////////////////////////////////

static BOOL GetJobFileName(LPTSTR lpJobName, LPTSTR lpJobFileName)
{
	TCHAR	szWindowsDir[MAX_PATH];
	LPTSTR	lpTaskDir,
			lpJobExt;
	DWORD	dwLength;

	// Get the windows directory.
	//
	if ( GetWindowsDirectory(szWindowsDir, sizeof(szWindowsDir)) == 0 )
		return FALSE;

	// Get rid of the backslash if windows is in the root of a drive.
	//
	if ( (dwLength = lstrlen(szWindowsDir)) == 3 )
		szWindowsDir[dwLength - 1] = _T('\0');

	// Get the task dir from the string resource.
	//
	if ( (lpTaskDir = AllocateString(NULL, IDS_TASKDIR)) == NULL )
		return FALSE;

	// Get the job extension from the string resource.
	//
	if ( (lpJobExt = AllocateString(NULL, IDS_JOBEXT)) == NULL )
	{
		FREE(lpTaskDir);
		return FALSE;
	}

	// Create the job name with all the data we have.
	//
	wsprintf(lpJobFileName, _T("%s%s\\%s%s"), szWindowsDir, lpTaskDir, lpJobName, lpJobExt);
	FREE(lpJobExt);
	FREE(lpTaskDir);
	return TRUE;
}

/*
void ConcatNextRunTime(LPSTR szOrgText, int nItem)
{
	int			nLen;
	SYSTEMTIME	stm;
	char		szTemp[128];
	DWORD		dwFlags;

	lstrcat(szOrgText, "\n");

	// get next run time string
	dwFlags = ItemData[nItem].dwFlags;
	dwFlags &= ~TASK_FLAG_DISABLED;		// if it's disabled, we can't get run time string
	pTask[nItem]->SetFlags(dwFlags);	// JobRelease will clear it if Cancel finally
	pTask[nItem]->GetNextRunTime(&stm);

	if (GetTimeFormat(GetUserDefaultLCID(), TIME_NOSECONDS, &stm, NULL,
                       (LPTSTR)szTemp, 128)) {
		lstrcat(szTemp, ", ");
		nLen = lstrlen(szTemp);
		if (GetDateFormat(GetUserDefaultLCID(), DATE_LONGDATE, &stm, NULL,
			              (LPTSTR)szTemp + nLen, 126-nLen)) 
			lstrcat(szOrgText, szTemp);
	}
}


static void taskSetNextDay(TASK_TRIGGER *pTaskTrigger)
{
	if (pTaskTrigger->wBeginMonth == 2 && pTaskTrigger->wBeginDay >= 28)
	{	pTaskTrigger->wBeginMonth++, pTaskTrigger->wBeginDay = 1;	}
	else if (pTaskTrigger->wBeginDay < 30)
		pTaskTrigger->wBeginDay++;
	else if (pTaskTrigger->wBeginMonth == 4 || pTaskTrigger->wBeginMonth == 6 ||
			 pTaskTrigger->wBeginMonth == 9 || pTaskTrigger->wBeginMonth == 11)
	{	pTaskTrigger->wBeginMonth++, pTaskTrigger->wBeginDay = 1;	}
	else if (pTaskTrigger->wBeginDay < 31)
		pTaskTrigger->wBeginDay++;
	else if (pTaskTrigger->wBeginMonth == 12)
	{	pTaskTrigger->wBeginYear++, pTaskTrigger->wBeginMonth = pTaskTrigger->wBeginDay = 1;	}
	else
	{	pTaskTrigger->wBeginMonth++, pTaskTrigger->wBeginDay = 1;	}
}
*/

//////////////////////////////////////////////////////////////////////////////
//
// INTERNAL:
//  DeleteOrgJobFile() 
//    This routine deletes the job (if it exists) with the job name passed in.
//
// ENTRY:
//  LPTSTR lpJobName - 
//    This is the name of the job (as it appears in Task Scheduler) passed in.
//
// EXIT:
//  BOOL
//    TRUE  - Either the file was successfully deleted or it didn't exist.
//    FALSE - Something failed.
//
//////////////////////////////////////////////////////////////////////////////

static BOOL DeleteOrgJobFile(LPTSTR lpJobName)
{
	TCHAR		szJobFileName[MAX_PATH];
	DWORD		dwAttr;

	// First get the full path and file name of
	// the job file.
	//
	if ( !GetJobFileName(lpJobName, szJobFileName) )
		return FALSE;
	
	// If it doesn't exit, return TRUE.
	//
	if ( !(EXIST(szJobFileName)) )
		return TRUE;

	// Make sure the file isn't read only.
	//
	if ( (dwAttr = GetFileAttributes(szJobFileName)) & _A_RDONLY )
	{
		dwAttr &= ~_A_RDONLY;
		SetFileAttributes(szJobFileName, dwAttr);
	}

	// Return the success or failure of DeleteFile().
	//
	return DeleteFile(szJobFileName);
}


/*
int	GetTimeScheme()
{
	int		i, nTimeScheme;
    ITaskTrigger   *pTrigger = NULL;
	TASK_TRIGGER	TaskTrigger, SchemeTrigger[ITEM_NUM];

	if (g_bEnableDefaultScheme == FALSE)
		return g_nTimeScheme;

	// check scheme by scheme
	for (nTimeScheme = IDC_NIGHT; nTimeScheme <= IDC_EVENING; nTimeScheme++) {
		for (i = TASK_FIRST; i <= TASK_LAST; i++) {
			if (!ItemData[i].bNeeded)
				continue;
			//InitJobTime(i, nTimeScheme, &SchemeTrigger[i]);
		}

		for (i = TASK_FIRST; i <= TASK_LAST; i++) {
			if (!ItemData[i].bNeeded)
				continue;

			if (!GetTaskTrigger(pTask[i], &TaskTrigger))
				break;
			if (memcmp((const void*)&TaskTrigger, (const void*)&SchemeTrigger[i], sizeof(TASK_TRIGGER)))
				break;
		}
		if (i == (TASK_LAST + 1))	// all the item match this scheme setting
			return nTimeScheme;
	}
	return IDC_CUSTOM;
}
*/

static BOOL GetTaskTrigger(ITask *pJob, TASK_TRIGGER *pTaskTrigger)
{
    ITaskTrigger	*pTrigger = NULL;

	if (pJob->GetTrigger((WORD)0, &pTrigger) != S_OK) 
		return FALSE;
	
	ZeroMemory(pTaskTrigger, sizeof(TASK_TRIGGER));
	pTrigger->GetTrigger(pTaskTrigger);
	pTrigger->Release();
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\tuneup\startup.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// STARTUP.CPP / Tuneup
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  Functions for the startup startmenu group wizard page.
//
//  7/98 - Jason Cohen (JCOHEN)
//
//////////////////////////////////////////////////////////////////////////////


//
// Include file(s).
//

#include "main.h"
#include <shellapi.h>
#include "startup.h"
#include <lm.h>


//
// Internal defined values.
//

#define WM_REPLACEPROC	WM_APP + 1


//
// Internal structure(s).
//

typedef struct _STARTUPLINK
{
	BOOL				bSelected;
	HICON				hIcon;
	HICON				hIconSelected;
	TCHAR				szFileName[MAX_PATH];
	TCHAR				szDisplayName[MAX_PATH];
	struct _STARTUPLINK	*lpNext;
} STARTUPLINK, *PSTARTUPLINK, *LPSTARTUPLINK;

typedef struct _USERDIR
{
	LPTSTR				lpPath;
	LPSTARTUPLINK		lpList;
} USERDIR, *PUSERDIR, *LPUSERDIR;


//
// Internal global variable(s).
//

TCHAR			g_szUserName[UNLEN + CNLEN + 1] = NULLSTR;
LPSTARTUPLINK	g_lpStartupLinks				= NULL;


//
// Inernal function prototype(s).
//

static VOID				FreeStartupLink(LPSTARTUPLINK, LPTSTR);
static VOID				InitStartupUsers(HWND);
static BOOL CALLBACK	AddString(HKEY, LPTSTR, LPARAM);
static PSID				GetUserSid(VOID);
static LPTSTR			GetSidString(PSID);
static LRESULT CALLBACK	ListBox_Proc(HWND, UINT, WPARAM, LPARAM);



VOID InitStartupMenu(HWND hDlg)
{
	PSID			pSid = NULL;
	SID_NAME_USE	SidName;
	TCHAR			szKey[MAX_PATH + 1],
					szUserName[UNLEN],
					szCompName[CNLEN],
					szDomainName[DNLEN],
					szDisplayName[UNLEN + CNLEN + 1];
	DWORD			cbUserName		= sizeof(szUserName) / sizeof(TCHAR),
					cbCompName		= sizeof(szCompName),
					cbDomainName	= sizeof(szDomainName) / sizeof(TCHAR);
	INT				nIndex = CB_ERR;
	LPTSTR			lpBuffer;
	LPUSERDIR		lpUserDir;
	LONG			lMove;
	RECT			ParentRect,
					Rect;

	// First things first, replace the list box windows procedure
	// so we can get the single click message.
	//
	ListBox_Proc(GetDlgItem(hDlg, IDC_STARTUP), WM_REPLACEPROC, 0, 0L);

	if ( IsUserAdmin() )
	{
		// Init the combo box.
		//
		InitStartupUsers(GetDlgItem(hDlg, IDC_USERS));
	}
	else
	{
		// Hide the combo box because user is not an administrator of
		// this machine.
		//
		ShowWindow(GetDlgItem(hDlg, IDC_SELUSER), FALSE);
		ShowWindow(GetDlgItem(hDlg, IDC_USERS), FALSE);

		// Now move the controls up so that they don't look out of place.
		//
		GetWindowRect(hDlg, &ParentRect);
		GetWindowRect(GetDlgItem(hDlg, IDC_SELUSER), &Rect);
		lMove = Rect.top;

		GetWindowRect(GetDlgItem(hDlg, IDC_PROGRAMS), &Rect);
		lMove -= Rect.top;
		SetWindowPos(GetDlgItem(hDlg, IDC_PROGRAMS), NULL, Rect.left - ParentRect.left, (Rect.top + lMove) - ParentRect.top, 0, 0, SWP_NOSIZE | SWP_NOZORDER);

		GetWindowRect(GetDlgItem(hDlg, IDC_STARTUP), &Rect);
		SetWindowPos(GetDlgItem(hDlg, IDC_STARTUP), NULL, Rect.left - ParentRect.left, (Rect.top + lMove) - ParentRect.top, 0, 0, SWP_NOSIZE | SWP_NOZORDER);

		// Lastly update the text box so that it make sence without the combo box.
		//
		if ( lpBuffer = AllocateString(NULL, IDS_STARTUPTEXT) )
		{
			SetDlgItemText(hDlg, IDC_STARTUPTEXT, lpBuffer);
			FREE(lpBuffer);
		}

	}

	if ( ( pSid = GetUserSid() ) &&
	     ( lpBuffer = GetSidString(pSid) ) )
	{
		// First we need the profile directory for this user.
		//
		wsprintf(szKey, _T("%s\\%s"), g_szRegKeyProfiles, lpBuffer);
		FREE(lpBuffer);
		if ( lpBuffer = RegGetString(HKLM, szKey, _T("ProfileImagePath")) )
		{
			// We only want them if the directory exists.
			//
			if ( EXIST(lpBuffer) )
			{
				// Lookup the account info with the sid so we know the user and domain name.
				//
				if ( LookupAccountSid(NULL, pSid, szUserName, &cbUserName, szDomainName, &cbDomainName, &SidName) )
				{
					// Create the display name (combine the computer/domain name with the
					// user name unless the computer/domain name is the same as the computer name).
					//
					if ( ( GetComputerName(szCompName, &cbCompName) ) &&
					     ( lstrcmp(szCompName, szDomainName) == 0 ) )
						lstrcpy(szDisplayName, szUserName);
					else
						wsprintf(szDisplayName, _T("%s\\%s"), szDomainName, szUserName);

					// Copy the display name to the global buffer.
					//
					lstrcpy(g_szUserName, szDisplayName);

					// Select the display name to the combo box.
					//
					if ( SendDlgItemMessage(hDlg, IDC_USERS, CB_SELECTSTRING, 0, (LPARAM) szDisplayName) == CB_ERR )
					{
						// It wasn't found, so we need to add it (probably because the user isn't and admin).
						//
						if ( (nIndex = (INT)SendDlgItemMessage(hDlg, IDC_USERS, CB_ADDSTRING, 0, (LPARAM) (LPCTSTR) szDisplayName)) > CB_ERR )
						{
							if ( lpUserDir = (LPUSERDIR) MALLOC(sizeof(USERDIR)) )
							{
								lpUserDir->lpPath = lpBuffer;
								if ( (nIndex = (INT)SendDlgItemMessage(hDlg, IDC_USERS, CB_SETITEMDATA, nIndex, (LPARAM) lpUserDir)) == CB_ERR )
									FREE(lpUserDir);
								SendDlgItemMessage(hDlg, IDC_USERS, CB_SELECTSTRING, 0, (LPARAM) szDisplayName);
							}
							else
							{
								SendDlgItemMessage(hDlg, IDC_USERS, CB_DELETESTRING, nIndex, 0L);
								nIndex = CB_ERR;
							}
						}
					}

					// Now populate the startup groups.
					//
					InitStartupList(hDlg);
				}
			}
			// If we just added this string, don't free the buffer
			// that has the path to the profile.
			//
			if (nIndex < 0)
				FREE(lpBuffer);
		}
	}
	FREE(pSid);
}


VOID ReleaseStartupMenu(HWND hDlg)
{
	INT			nCount,
				nIndex;
	DWORD_PTR	dwBuffer;
	LPUSERDIR	lpUserDir;

	//
	// We need to free the buffer associated with each CB item.
	//

	// First get the count.
	//
	if ( (nCount = (INT)SendDlgItemMessage(hDlg, IDC_USERS, CB_GETCOUNT, 0, 0L)) > CB_ERR )
	{
		// Now go through all the items.
		//
		for (nIndex = 0; nIndex < nCount; nIndex++)
		{
			// Free the buffer stored in the CB item.
			//
			if ( (dwBuffer = SendDlgItemMessage(hDlg, IDC_USERS, CB_GETITEMDATA, nIndex, 0L)) != CB_ERR )
			{
				lpUserDir = (LPUSERDIR)dwBuffer;
				FreeStartupLink(lpUserDir->lpList, lpUserDir->lpPath);
				FREE(lpUserDir->lpPath);
				FREE(lpUserDir);
			}
		}
	}
}


BOOL InitStartupList(HWND hDlg)
{
	INT				iIndex,
					iString = IDS_STARTUP;
	DWORD_PTR		dwBuffer;
	TCHAR			szDir[MAX_PATH];
	LPUSERDIR		lpUserDir;
	HANDLE			hFindFile;
	WIN32_FIND_DATA	FindData;
	SHFILEINFO		SHFileInfo;
	LPSTARTUPLINK	*lpNextLink = NULL;
	LPTSTR			lpOffice95,
					lpOffice97;

	// First get the currently selected user from the combo box.
	//
	if ( ( (iIndex = (INT)SendDlgItemMessage(hDlg, IDC_USERS, CB_GETCURSEL, 0, 0L)) != CB_ERR ) &&
	     ( (dwBuffer = SendDlgItemMessage(hDlg, IDC_USERS, CB_GETITEMDATA, iIndex, 0L)) != CB_ERR ) )
	{
		// Now remove all the current items from the list box.
		//
		SendDlgItemMessage(hDlg, IDC_STARTUP, LB_RESETCONTENT, 0, 0L);

		// Now get the profile directory stored as the extra data in the combo box.
		//
		lpUserDir = (LPUSERDIR)dwBuffer;

		// Check to see if we already have the files in this directory.
		//
		if ( lpUserDir->lpList )
		{
			// Add the names arleady found to the list box and set the structure pointer as the list box item data.
			//
			for (lpNextLink = &(lpUserDir->lpList); *lpNextLink; lpNextLink = &((*lpNextLink)->lpNext))
				if ( (iIndex = (INT)SendDlgItemMessage(hDlg, IDC_STARTUP, LB_ADDSTRING, 0, (LPARAM) (*lpNextLink)->szDisplayName)) >= 0 )
					SendDlgItemMessage(hDlg, IDC_STARTUP, LB_SETITEMDATA, iIndex, (LPARAM) *lpNextLink);
		}
		else
		{
			// Get the name of Office stuff which we want it default unchecked.
			//
			lpOffice95 = AllocateString(NULL, IDS_OFFICE95_STARTUP);
			lpOffice97 = AllocateString(NULL, IDS_OFFICE97_STARTUP);

			// Setup the pointer to the global structure that holds all the startup links.
			//
			lpNextLink = &lpUserDir->lpList;

			// Loop through the two directories (the actual startup items and the disabled ones).
			//
			while ( iString )
			{
				// Copy the profile path into the dir buffer.
				//
				lstrcpy(szDir, lpUserDi