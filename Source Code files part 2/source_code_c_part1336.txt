estLevelRecord = pTempLevelRecord;
                    RtlCopyMemory(pBestIdentGuid,
                                  &guidTrustedCert, sizeof(GUID));
                    goto ExitHandler2;
                }
            }
        }
#endif

        //
        // If we found any Level matches at this point, then we
        // should simply return that match.  The identified Level
        // will be the MIN() of all "grouping matches" found.
        //
        if (pAuthzLevelRecord != NULL) {
            Status = STATUS_SUCCESS;
            *pBestLevelRecord = pAuthzLevelRecord;
            ASSERT(pAuthzIdentRecord != NULL);
            RtlCopyMemory(pBestIdentGuid,
                          &pAuthzIdentRecord->IdentGuid, sizeof(GUID));
            goto ExitHandler2;
        }
    }


    //
    // Now we need to consider the default WinSafer Level and
    // return it if one was defined.  If there was no default
    // defined, then we should simply return STATUS_NOT_FOUND.
    //
    if (g_DefaultCodeLevel != NULL) {
        *pBestLevelRecord = g_DefaultCodeLevel;
        RtlCopyMemory(pBestIdentGuid, &guidDefaultRule, sizeof(GUID));
        Status = STATUS_SUCCESS;
        goto ExitHandler2;
    }
    Status = STATUS_NOT_FOUND;


ExitHandler2:
    __CodeAuthzpEnsureUnmapped(&identStruct);
    if (identStruct.UnicodeFullyQualfiedLongFileName.Buffer != NULL) {
        RtlFreeUnicodeString(&identStruct.UnicodeFullyQualfiedLongFileName);
    }
    if (identStruct.bCloseFileHandle && identStruct.hFileHandle != NULL) {
        NtClose(identStruct.hFileHandle);
    }

ExitHandler:
    return Status;
}


BOOL
SaferpSkipPolicyForAdmins(VOID)

/*++

Routine Description:

    Decides whether or not Safer policy should be skipped.
    Policy is skipped if
        1. The caller is an Admin AND
        2. The registry key specifies that the policy should be skipped
           for Admins.
           
Arguments:

Return Value:

    Returns TRUE if a policy should be skipped for admins.
    Returns FALSE otherwise or in case of any intermediate errors.

--*/

{
    static BOOL gSaferSkipPolicy = 2;
    BOOL bIsAdmin = FALSE;
    DWORD AdminSid[] = {0x201, 0x5000000, 0x20, 0x220};
    NTSTATUS Status = STATUS_SUCCESS;

    // If we have already evaluated policy once, return the cached value.
    if (2 != gSaferSkipPolicy)
    {
        return gSaferSkipPolicy;
    }

    // Set the default to "will not skip policy"
    gSaferSkipPolicy = 0;

    // Check if the caller is an admin.
    if (CheckTokenMembership(NULL, (PSID) AdminSid, &bIsAdmin))
    {
        // The caller is an Admin. Let's check whether the regkey says it's ok
        // to skip the policy for admins.
        if (bIsAdmin)
        {
            const static UNICODE_STRING SaferUnicodeKeyName = RTL_CONSTANT_STRING(L"\\Registry\\Machine\\Software\\Policies\\Microsoft\\Windows\\Safer\\CodeIdentifiers");
            const static OBJECT_ATTRIBUTES SaferObjectAttributes = RTL_CONSTANT_OBJECT_ATTRIBUTES(&SaferUnicodeKeyName, OBJ_CASE_INSENSITIVE);
            const static UNICODE_STRING SaferPolicyScope = RTL_CONSTANT_STRING(SAFER_POLICY_SCOPE);

            HANDLE hKeyEnabled = NULL;
            BYTE QueryBuffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + 64];
            PKEY_VALUE_PARTIAL_INFORMATION pKeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION) QueryBuffer;
            DWORD dwActualSize = 0;

            // Open the CodeIdentifiers key.
            Status = NtOpenKey(
                         &hKeyEnabled, 
                         KEY_QUERY_VALUE,
                         (POBJECT_ATTRIBUTES) &SaferObjectAttributes
                         );

            if (NT_SUCCESS(Status)) {

                // Read the Policy Scope value.
                Status = NtQueryValueKey(
                             hKeyEnabled,
                             (PUNICODE_STRING) &SaferPolicyScope,
                             KeyValuePartialInformation,
                             pKeyValueInfo, 
                             sizeof(QueryBuffer), 
                             &dwActualSize
                             );

		        NtClose(hKeyEnabled);

                // Skip policy if the flag is set to 1.
                if (NT_SUCCESS(Status)) {
                    if ((pKeyValueInfo->Type == REG_DWORD) &&
                        (pKeyValueInfo->DataLength == sizeof(DWORD)) &&
                        (*((PDWORD) pKeyValueInfo->Data) & 0x1)) {
                        
                        gSaferSkipPolicy = 1;
                    }
                }		
            }
        }
    }

    return gSaferSkipPolicy;

}
   

VOID
SaferpLogResultsToFile(
    LPWSTR InputImageName,
    LPWSTR LevelName,
    LPWSTR RuleTypeName,
    GUID *Guid
    )

/*++

Routine Description:

    Logs a message to a file specified in 
    
    HKLM\Software\Policies\Microsoft\Windows\Safer\CodeIdentifiers LogFileName.
    
    The format of the message is:
        TLIST.EXE (PID = 1076) identified C:\SAFERTEST\TEST.VBS as FULLY TRUSTED
        using CERTIFICATE rul, Guid = {abcdef00-abcd-abcd-abcdefabcdef00}
           
Arguments:

Return Value:

--*/

{

#define SAFER_LOG_NAME1 L" (PID = "
#define SAFER_LOG_NAME2 L") identified "
#define SAFER_LOG_NAME3 L" as "
#define SAFER_LOG_NAME4 L" using "
#define SAFER_LOG_NAME5 L" rule, Guid = "

#define SAFER_INTEGER_LENGTH 20
#define SAFER_MAX_RULE_DESCRIPTION_LENGTH 12
#define SAFER_GUID_LENGTH 38

    NTSTATUS Status = STATUS_SUCCESS;
    HANDLE hFile = NULL;
    HANDLE hKey = NULL;
    ULONG ProcessNameLength = 0;
    PWCHAR Buffer = NULL;
    ULONG BasicInfoLength = 0;
    ULONG BytesWritten = 0;

    UCHAR TmpBuf[] = {0xFF, 0xFE};

    const static UNICODE_STRING SaferUnicodeKeyName = RTL_CONSTANT_STRING(L"\\Registry\\Machine\\Software\\Policies\\Microsoft\\Windows\\Safer\\CodeIdentifiers");
    const static OBJECT_ATTRIBUTES SaferObjectAttributes = RTL_CONSTANT_OBJECT_ATTRIBUTES(&SaferUnicodeKeyName, OBJ_CASE_INSENSITIVE);
    const static UNICODE_STRING SaferPolicyScope = RTL_CONSTANT_STRING(SAFER_LOGFILE_NAME);
    PROCESS_BASIC_INFORMATION ProcInfo = {0};
    ULONG TotalSize = sizeof(SAFER_LOG_NAME1) + 
                      sizeof(SAFER_LOG_NAME2) + 
                      sizeof(SAFER_LOG_NAME3) + 
                      sizeof(SAFER_LOG_NAME4) + 
                      sizeof(SAFER_LOG_NAME5) + 
                      ((SAFER_INTEGER_LENGTH + 
                        SAFER_MAX_RULE_DESCRIPTION_LENGTH + 
                        SAFER_GUID_LENGTH) * sizeof(WCHAR));

    UCHAR QueryBuffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + MAX_PATH * sizeof(WCHAR)];
    PWCHAR ProcessImageName = NULL;
    PKEY_VALUE_PARTIAL_INFORMATION pKeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION) QueryBuffer;
    DWORD dwActualSize = 0;

    // Open the CodeIdentifiers key.
    Status = NtOpenKey(
                 &hKey, 
                 KEY_QUERY_VALUE,
                 (POBJECT_ATTRIBUTES) &SaferObjectAttributes
                 );

    if (!NT_SUCCESS(Status)) {
        return;
    }

    // Read the name of the file for logging.
    Status = NtQueryValueKey(
                 hKey,
                 (PUNICODE_STRING) &SaferPolicyScope,
                 KeyValuePartialInformation,
                 pKeyValueInfo, 
                 sizeof(QueryBuffer), 
                 &dwActualSize
                 );

    NtClose(hKey);

    // We do not care if the buffer size was too small to retrieve the logfile
    // name since this is for troubleshooting.
    if (!NT_SUCCESS(Status)) {
        return;
    }

    // This was not a string.
    if (pKeyValueInfo->Type != REG_SZ) {
        return;
    }       

    hFile = CreateFileW((LPCWSTR) pKeyValueInfo->Data, GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, 0, NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        return;
    }

    SetFilePointer (hFile, 0, NULL, FILE_BEGIN);

    WriteFile (hFile, (LPCVOID)TmpBuf, 2, &BytesWritten, NULL);

    SetFilePointer (hFile, 0, NULL, FILE_END);

    Status = NtQueryInformationProcess(NtCurrentProcess(), ProcessImageFileName, QueryBuffer, sizeof(QueryBuffer), &ProcessNameLength);

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    ProcessImageName = (PWCHAR) (QueryBuffer + ProcessNameLength - sizeof(WCHAR));
    ProcessNameLength = 1;
    while (((PUCHAR) ProcessImageName >= QueryBuffer) && (*(ProcessImageName - 1) != L'\\')) {
        ProcessImageName--;
        ProcessNameLength++;
    }

    TotalSize += (ProcessNameLength + (wcslen(InputImageName) + wcslen(LevelName)) * sizeof(WCHAR));

    Status = NtQueryInformationProcess(NtCurrentProcess(), ProcessBasicInformation, (PVOID) &ProcInfo, sizeof(PROCESS_BASIC_INFORMATION), &BasicInfoLength);

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    Buffer = (PWCHAR) RtlAllocateHeap(RtlProcessHeap(), 0, TotalSize);

    if (Buffer == NULL) {
        goto Cleanup;
    }

    swprintf(Buffer, L"%s%s%d%s%s%s%s%s%s%s{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}\r\n", 
             ProcessImageName,
             SAFER_LOG_NAME1,
             ProcInfo.UniqueProcessId,
             SAFER_LOG_NAME2,
             InputImageName,
             SAFER_LOG_NAME3,
             LevelName,
             SAFER_LOG_NAME4,
             RuleTypeName,
             SAFER_LOG_NAME5,
             Guid->Data1, Guid->Data2, Guid->Data3, Guid->Data4[0], Guid->Data4[1], Guid->Data4[2], Guid->Data4[3], Guid->Data4[4], Guid->Data4[5], Guid->Data4[6], Guid->Data4[7]);

    ASSERT((wcslen(Buffer) + 1) * sizeof(WCHAR) < TotalSize);

    WriteFile (hFile, (LPCVOID)Buffer, (wcslen(Buffer) * sizeof(WCHAR)), &BytesWritten, NULL);

    RtlFreeHeap(RtlProcessHeap(), 0, Buffer);

Cleanup:
    CloseHandle(hFile);


}

BOOL WINAPI
SaferIdentifyLevel(
        IN DWORD                dwNumProperties,
        IN PSAFER_CODE_PROPERTIES    pCodeProperties,
        OUT SAFER_LEVEL_HANDLE        *pLevelHandle,
        IN LPVOID               lpReserved
        )
/*++

Routine Description:

    Performs the code identification process.  Accepts an array of
    CODE_PROPERTIES structures that supply all of the identification
    criteria.  The final result is the least privileged match resulting
    from each element of the array.

Arguments:

    dwNumProperties - indicates the number of CODE_PROPERTIES structures
            pointed to by the CodeProperties argument.

    pCodeProperties - pointer to one or more structures that specify
            all of the input criteria that will be used to identify level.

    pLevelHandle - pointer that will receive the opened Level object
            handle when the identification operation is successful.

    lpReserved - unused, must be zero.

Return Value:

    Returns TRUE if a Level was identified and an opened handle
    to it stored in the 'LevelHandle' argument.  Otherwise this
    function returns FALSE on error and GetLastError() can be used
    to obtain additional information about the error.

--*/
{
    DWORD Index;
    NTSTATUS Status;
    BOOL ReturnValue = FALSE;
    PAUTHZLEVELTABLERECORD pBestLevelRecord;
    GUID BestIdentGuid;
    PWCHAR LocalLevelName = L"\"default\"";
    PWCHAR LocalRuleName = L"default";
    PWCHAR LocalImageName = L"Default";
    DWORD dwExtendedError = ERROR_SUCCESS;

    //
    // Validate the input parameters.
    //
    UNREFERENCED_PARAMETER(lpReserved);

    if (!ARGUMENT_PRESENT(pLevelHandle)) {
        Status = STATUS_ACCESS_VIOLATION;
        goto ExitHandler;
    }
    if (!g_bInitializedFirstTime) {
        Status = STATUS_UNSUCCESSFUL;
        goto ExitHandler;
    }
    RtlEnterCriticalSection(&g_TableCritSec);
    if (g_bNeedCacheReload) {
        Status = CodeAuthzpImmediateReloadCacheTables();
        if (!NT_SUCCESS(Status)) {
            goto ExitHandler2;
        }
    }
    if (RtlIsGenericTableEmpty(&g_CodeLevelObjTable)) {
        // There are no levels defined!  Should not happen.
        Status = STATUS_NOT_FOUND;
        goto ExitHandler2;
    }

    //
    // Do not allow filehandles unless filename is specified.
    //
    for (Index = 0; Index < dwNumProperties; Index++)
    {
        if (pCodeProperties[Index].hImageFileHandle != NULL &&
            pCodeProperties[Index].hImageFileHandle != INVALID_HANDLE_VALUE &&
            pCodeProperties[Index].ImagePath == NULL)
        {
            Status = STATUS_INVALID_PARAMETER;               
            goto ExitHandler2;
        }
    }

    if (SaferpSkipPolicyForAdmins())
    {
        pBestLevelRecord = CodeAuthzLevelObjpLookupByLevelId(
            &g_CodeLevelObjTable, SAFER_LEVELID_FULLYTRUSTED);

        RtlCopyMemory(&BestIdentGuid, &guidDefaultRule, sizeof(GUID));
        goto GotMatchingRule;
    }


    if (!ARGUMENT_PRESENT(pCodeProperties) || dwNumProperties == 0) {
        // We were given no criteria to evaluate, so just return
        // the default level.  If there was no default defined,
        // then we should simply return STATUS_NOT_FOUND.
        if (g_DefaultCodeLevel != NULL) {
            pBestLevelRecord = g_DefaultCodeLevel;
            RtlCopyMemory(&BestIdentGuid, &guidDefaultRule, sizeof(GUID));
            goto GotMatchingRule;
        } else {
            Status = STATUS_NOT_FOUND;
            goto ExitHandler2;
        }
    }

    //
    // Iterate through the list of CODE_PROPERTIES supplied
    // and determine the final code Level that should be used.
    //
    pBestLevelRecord = NULL;
    for (Index = 0; Index < dwNumProperties; Index++)
    {
        PAUTHZLEVELTABLERECORD pOneLevelRecord;
        GUID OneIdentGuid;

        Status = __CodeAuthzpIdentifyOneCodeAuthzLevel(
                        &pCodeProperties[Index],
                        &dwExtendedError,
                        &pOneLevelRecord,
                        &OneIdentGuid);
        if (NT_SUCCESS(Status)) {
            ASSERT(pOneLevelRecord != NULL);
            if (!pBestLevelRecord ||
                pOneLevelRecord->dwLevelId <
                    pBestLevelRecord->dwLevelId )
            {
                pBestLevelRecord = pOneLevelRecord;
                RtlCopyMemory(&BestIdentGuid, &OneIdentGuid, sizeof(GUID));
            }
        } else if (Status != STATUS_NOT_FOUND) {
            // An unexpected error occurred, so return that.
            goto ExitHandler2;
        }
    }
    if (pBestLevelRecord == NULL) {
        Status = STATUS_NOT_FOUND;
        goto ExitHandler2;
    }



    //
    // Now we have the result so pass back a handle to the
    // identified WinSafer Level.
    // Allocate a handle to represent this level.
    //
GotMatchingRule:
    ASSERT(pBestLevelRecord != NULL);
    if (IsEqualGUID(&guidDefaultRule, &BestIdentGuid))
    {
        // The resulting level match came from the default rule.
        // Now we have to try to guess whether the default actually
        // came from the Machine or User scope.
        DWORD dwScopeId;

        if (g_hKeyCustomRoot != NULL) {
            dwScopeId = SAFER_SCOPEID_REGISTRY;
        } else if (g_DefaultCodeLevelUser != NULL &&
                g_DefaultCodeLevelUser->dwLevelId ==
                   pBestLevelRecord->dwLevelId) {
            dwScopeId = SAFER_SCOPEID_USER;
        } else {
            dwScopeId = SAFER_SCOPEID_MACHINE;
        }

        Status = CodeAuthzpCreateLevelHandleFromRecord(
                    pBestLevelRecord,   // pLevelRecord
                    dwScopeId,          // dwScopeId
                    0,                  // dwSaferFlags
                    dwExtendedError,
                    SaferIdentityDefault,
                    &BestIdentGuid,     // pIdentRecord
                    pLevelHandle        // pLevelHandle
                    );


    }
    else if (IsEqualGUID(&guidTrustedCert, &BestIdentGuid))
    {
        // Note that when the result is from a certificate, we have
        // no way of actually knowing whether the certificate was
        // defined within the Machine or User scope, so we'll just
        // arbitrarily pick the Machine scope for the handle to be
        // based out of.  Additionally, there are no SaferFlags
        // persisted for certificates so we just assume 0.
        Status = CodeAuthzpCreateLevelHandleFromRecord(
                    pBestLevelRecord,       // pLevelRecord
                    SAFER_SCOPEID_MACHINE,   // dwScopeId
                    0,                      // dwSaferFlags
                    dwExtendedError,
                    SaferIdentityTypeCertificate,
                    &BestIdentGuid,         // pIdentRecord
                    pLevelHandle            // pLevelHandle
                    );

        LocalRuleName = L"certificate";
    }
    else
    {
        // Otherwise the result must have come from a path, hash,
        // or zone rule, so we must look up the resulting GUID in our
        // identity table and retrieve the SaferFlags that were stored
        // along with that Identity record.  But we won't panic if we
        // can't actually find the GUID anymore (even though that should
        // not ever be the case while we have the critical section).
        PAUTHZIDENTSTABLERECORD pBestIdentRecord;
        DWORD dwSaferFlags = 0;
        SAFER_IDENTIFICATION_TYPES LocalIdentificationType = SaferIdentityDefault;

        pBestIdentRecord = CodeAuthzIdentsLookupByGuid(
                &g_CodeIdentitiesTable, &BestIdentGuid);
        if (pBestIdentRecord != NULL) {
            // we identified a level, and the match came from a Identity.
            switch (pBestIdentRecord->dwIdentityType) {
                case SaferIdentityTypeImageName:
                    dwSaferFlags = pBestIdentRecord->ImageNameInfo.dwSaferFlags;
                    LocalRuleName = L"path";
                    LocalIdentificationType = SaferIdentityTypeImageName;
                    break;
                case SaferIdentityTypeImageHash:
                    dwSaferFlags = pBestIdentRecord->ImageHashInfo.dwSaferFlags;
                    LocalRuleName = L"hash";
                    LocalIdentificationType = SaferIdentityTypeImageHash;
                    break;
                case SaferIdentityTypeUrlZone:
                    dwSaferFlags = pBestIdentRecord->ImageZone.dwSaferFlags;
                    LocalRuleName = L"zone";
                    LocalIdentificationType = SaferIdentityTypeUrlZone;
                    break;
                default: break;
            }
            Status = CodeAuthzpCreateLevelHandleFromRecord(
                        pBestLevelRecord,               // pLevelRecord
                        pBestIdentRecord->dwScopeId,
                        dwSaferFlags,                   // dwSaferFlags
                        dwExtendedError,
                        LocalIdentificationType,
                        &BestIdentGuid,                 // pIdentRecord
                        pLevelHandle                    // pLevelHandle
                        );
        }
        else
        {
            Status = STATUS_UNSUCCESSFUL;

        }
    }
    if (NT_SUCCESS(Status)) {
        ReturnValue = TRUE;      // success.
    }

    switch(pBestLevelRecord->dwLevelId)
    {
    case SAFER_LEVELID_FULLYTRUSTED:
        LocalLevelName = L"Unrestricted";
        break;
    case SAFER_LEVELID_NORMALUSER:
        LocalLevelName = L"Basic User";
        break;
    case SAFER_LEVELID_CONSTRAINED:
        LocalLevelName = L"Restricted"; 
        break;
    case SAFER_LEVELID_UNTRUSTED:
        LocalLevelName = L"Untrusted";
        break;
    case SAFER_LEVELID_DISALLOWED:
        LocalLevelName = L"Disallowed";
        break;
    default:
        ASSERT(FALSE);
        break;
    }

    if (pCodeProperties->ImagePath != NULL) {
        LocalImageName = (PWSTR) pCodeProperties->ImagePath;
    }

    SaferpLogResultsToFile(
        LocalImageName,
        LocalLevelName,
        LocalRuleName, 
        &BestIdentGuid);

ExitHandler2:
    RtlLeaveCriticalSection(&g_TableCritSec);

ExitHandler:
    if (!ReturnValue) {
        BaseSetLastNTError(Status);
    }

    return ReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\winsafer\safeget.c ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    safeget.cpp         (SAFER SaferGetLevelInformation)

Abstract:

    This module implements the WinSAFER APIs to get information about a
    sepcific Authorization Level and the attributes and identities that
    are associated with it.

Author:

    Jeffrey Lawson (JLawson) - Nov 1999

Environment:

    User mode only.

Exported Functions:

    SaferGetLevelInformation

Revision History:

    Created - Nov 1999

--*/

#include "pch.h"
#pragma hdrstop
#include <winsafer.h>
#include <winsaferp.h>
#include "saferp.h"



DWORD NTAPI
__CodeAuthzpCountIdentsForLevel(
        IN DWORD        dwScopeId,
        IN DWORD        dwLevelId
        )
/*++

Routine Description:

    Determines the number of Code Identities that have been associated
    with a given WinSafer LevelId.  This number represents the number
    of identity GUIDs that will be returned to the caller.

Arguments:

    dwScopeId - specifies the Scope value that will be considered.

    dwLevelId - specifies the LevelId value to be counted.

Return Value:

    Returns the actual number of unique Code Identities that were found
        to be associated with the given LevelId.  If no Identities were
        found, then 0 will be returned.

--*/
{
    PVOID RestartKey;
    PAUTHZIDENTSTABLERECORD pAuthzIdentsRec;
    DWORD dwMatchingCount = 0;


    ASSERT(g_TableCritSec.OwningThread == UlongToHandle(GetCurrentThreadId()));


    RestartKey = NULL;
    for (pAuthzIdentsRec = (PAUTHZIDENTSTABLERECORD)
            RtlEnumerateGenericTableWithoutSplaying(
                    &g_CodeIdentitiesTable, &RestartKey);
         pAuthzIdentsRec != NULL;
         pAuthzIdentsRec = (PAUTHZIDENTSTABLERECORD)
            RtlEnumerateGenericTableWithoutSplaying(
                    &g_CodeIdentitiesTable, &RestartKey)
         )
    {
        if (pAuthzIdentsRec->dwLevelId == dwLevelId &&
            pAuthzIdentsRec->dwScopeId == dwScopeId)
            dwMatchingCount++;
    }

    return dwMatchingCount;
}



NTSTATUS NTAPI
__CodeAuthzpFetchIdentsForLevel(
        IN DWORD        dwScopeId,
        IN DWORD        dwLevelId,
        IN DWORD        dwInBufferSize,
        IN OUT LPVOID   lpQueryBuffer,
        OUT LPDWORD     pdwUsedSize
        )
/*++

Routine Description:

    Retrieves all of Code Identities that have been associated
    with a given WinSafer LevelId.  The number of identity GUIDs
    that will be returned to the caller can be determined by
    first calling __CodeAuthzpCountIdentsForLevel.  It is assumed
    that the caller has already determined and verified the appropriate
    size of the buffer that should be supplied using that function.

Arguments:

    dwScopeId - specifies the Scope value that will be considered.

    dwLevelId - specifies the LevelId value to be matched.

    dwInBufferSize - specifies the size of the output buffer.

    lpQueryBuffer - points to the output buffer that should be filled.

    pdwUsedSize - receives the actual number of bytes used.

Return Value:

    Returns the actual number of unique Code Identities that were found
        to be associated with the given LevelId.  If no Identities were
        found, then 0 will be returned.

--*/
{
    PVOID RestartKey;
    PAUTHZIDENTSTABLERECORD pIdentRecord;
    LPVOID lpNextPtr;


    ASSERT(g_TableCritSec.OwningThread == UlongToHandle(GetCurrentThreadId()));
    ASSERT(ARGUMENT_PRESENT(lpQueryBuffer));
    ASSERT(ARGUMENT_PRESENT(pdwUsedSize));


    RestartKey = NULL;
    lpNextPtr = (LPVOID) lpQueryBuffer;
    for (pIdentRecord = (PAUTHZIDENTSTABLERECORD)
                RtlEnumerateGenericTableWithoutSplaying(
                    &g_CodeIdentitiesTable, &RestartKey);
        pIdentRecord != NULL;
        pIdentRecord = (PAUTHZIDENTSTABLERECORD)
                RtlEnumerateGenericTableWithoutSplaying(
                    &g_CodeIdentitiesTable, &RestartKey))
    {
        if (pIdentRecord->dwLevelId == dwLevelId &&
            pIdentRecord->dwScopeId == dwScopeId)
        {
            if ( ((PBYTE) lpNextPtr) - ((PBYTE) lpQueryBuffer) +
                 sizeof(GUID) > dwInBufferSize ) {
                return STATUS_BUFFER_TOO_SMALL;
            }
            RtlCopyMemory( lpNextPtr, &pIdentRecord->IdentGuid, sizeof(GUID) );
            lpNextPtr = (LPVOID) ( ((PBYTE) lpNextPtr) + sizeof(GUID));
        }
    }
    ASSERT((PBYTE) lpNextPtr <= ((PBYTE) lpQueryBuffer) + dwInBufferSize);
    *pdwUsedSize = (DWORD) (((PBYTE) lpNextPtr) - ((PBYTE) lpQueryBuffer));
    return STATUS_SUCCESS;
}



NTSTATUS NTAPI
__CodeAuthzpOpenIdentifierKey(
        IN DWORD        dwScopeId,
        IN DWORD        dwLevelId,
        IN LPCWSTR      szIdentityType,
        IN REFGUID      refIdentGuid,
        OUT HANDLE     *phOpenedKey
        )
/*++

Routine Description:

Arguments:

    dwScopeId -

    dwLevelId -

    szIdentityType -

    refIdentGuid -

    phOpenedKey -

Return Value:

    Returns STATUS_SUCCESS on success.

--*/
{
    NTSTATUS Status;
    UNICODE_STRING UnicodePath;
    WCHAR szPathBuffer[MAX_PATH];


    if (!ARGUMENT_PRESENT(refIdentGuid) ||
        !ARGUMENT_PRESENT(phOpenedKey)) {
        Status = STATUS_INVALID_PARAMETER;
        goto ExitHandler;
    }
    if (g_hKeyCustomRoot != NULL) {
        if (dwScopeId != SAFER_SCOPEID_REGISTRY) {
            Status = STATUS_INVALID_PARAMETER_MIX;
            goto ExitHandler;
        }
    } else {
        if (dwScopeId != SAFER_SCOPEID_MACHINE &&
            dwScopeId != SAFER_SCOPEID_USER) {
            Status = STATUS_INVALID_PARAMETER_MIX;
            goto ExitHandler;
        }
    }
    RtlInitEmptyUnicodeString(&UnicodePath,
                szPathBuffer, sizeof(szPathBuffer));
    Status = CodeAuthzpFormatIdentityKeyPath(
                dwLevelId, szIdentityType,
                refIdentGuid, &UnicodePath);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler;
    }
    Status = CodeAuthzpOpenPolicyRootKey(
                dwScopeId, g_hKeyCustomRoot,
                UnicodePath.Buffer,
                KEY_READ, FALSE, phOpenedKey);

ExitHandler:
    return Status;
}


NTSTATUS NTAPI
__CodeAuthzpQueryIdentityRegValue(
        IN HANDLE       hKeyIdentityBase,
        IN LPWSTR       szValueName,
        IN DWORD        dwRegType,
        OUT PVOID       lpOutBuffer,
        IN ULONG        ulOutBufferSize,
        OUT PULONG      pulActualOutSize OPTIONAL
        )
/*++

Routine Description:

    Generic helper function to query a registry value, provided that a
    pre-opened registry handle to the key is already known. 

Arguments:

    hKeyIdentityBase - registry key handle.

    szValueName - null-terminated Unicode string of the registry value name.

    dwRegType - type of the registry value expected (REG_SZ, REG_DWORD, etc)
        If a registry value of the given name exists, but is not of this
        type, then this function will return STATUS_NOT_FOUND.

    lpOutBuffer - pointer to a target buffer that will receive the
        retrieved value contents.

    ulOutBufferSize - input argument that specifies the maximum size
        of the buffer pointed to by the lpOutBuffer argument.

    pulActualOutSize - output argument that receives the actual size
        of the retrieved value contents if the call is successful.

Return Value:

    Returns STATUS_SUCCESS on success.

--*/
{
    NTSTATUS Status;
    ULONG ulResultLength;
    UNICODE_STRING ValueName;
    ULONG ulValueBufferSize;
    PKEY_VALUE_PARTIAL_INFORMATION pValuePartialInfo;



    //
    // Allocate enough memory for the query buffer.
    //
    ASSERT(ARGUMENT_PRESENT(lpOutBuffer) && ulOutBufferSize > 0);
    ulValueBufferSize = sizeof(KEY_VALUE_PARTIAL_INFORMATION) +
            ulOutBufferSize + sizeof(WCHAR) * 256;
    pValuePartialInfo = (PKEY_VALUE_PARTIAL_INFORMATION)
            RtlAllocateHeap(RtlProcessHeap(), 0, ulValueBufferSize);
    if (!pValuePartialInfo) {
        Status = STATUS_NO_MEMORY;
        goto ExitHandler;
    }


    //
    // Actually query the value into the temporary query buffer.
    //
    ASSERT(ARGUMENT_PRESENT(szValueName));
    RtlInitUnicodeString(&ValueName, szValueName);
    Status = NtQueryValueKey(hKeyIdentityBase, &ValueName,
                             KeyValuePartialInformation,
                             pValuePartialInfo, ulValueBufferSize,
                             &ulResultLength);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler2;
    }
    if (pValuePartialInfo->Type != dwRegType) {
        Status = STATUS_NOT_FOUND;
        goto ExitHandler2;
    }


    //
    // Copy the resulting data from the query buffer into
    // the caller's buffer.
    //

    ulResultLength = pValuePartialInfo->DataLength;
    if (ulResultLength > ulOutBufferSize) {
        Status = STATUS_BUFFER_TOO_SMALL;
    } else {
        RtlCopyMemory(lpOutBuffer,
                      pValuePartialInfo->Data,
                      ulResultLength);
        Status = STATUS_SUCCESS;
    }

    if (ARGUMENT_PRESENT(pulActualOutSize)) {
        *pulActualOutSize = ulResultLength;
    }

ExitHandler2:
    RtlFreeHeap(RtlProcessHeap(), 0, (PVOID) pValuePartialInfo);


ExitHandler:
    return Status;
}


NTSTATUS NTAPI
__CodeAuthzpQuerySingleIdentification(
        IN PAUTHZIDENTSTABLERECORD  pSingleIdentRecord,
        OUT LPVOID                  lpQueryBuffer,
        IN DWORD                    dwInBufferSize,
        OUT PDWORD                  dwNeededSize
        )
/*++

Routine Description:

    Allows the user to retrieve information about a single identity.

    Assumes that the caller has already obtained and locked the
    global critical section.

Arguments:

    pSingleIdentRecord - pointer to the identity record structure.

    lpQueryBuffer - pointer to a user-supplied memory buffer that
        will receive the requested information.

    dwInBufferSize - specifies the size of the user's memory block.

    lpdwOutBufferSize - receives the used size of the data within the
        memory block, or the minimum necessary size if the passed
        buffer was too small.

Return Value:

    Returns STATUS_SUCCESS on success.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    HANDLE hKeyIdentity = NULL;
    ULONG ulResultLength = 0;
    ULONG ulTextLen = 0;
    PSAFER_IDENTIFICATION_HEADER pIdentCommon = NULL;

    //
    // All of these conditions should have been already verified
    // by our caller before calling us, so we only assert them.
    //
    ASSERT(ARGUMENT_PRESENT(pSingleIdentRecord));
    ASSERT(ARGUMENT_PRESENT(lpQueryBuffer) &&
           dwInBufferSize >= sizeof(SAFER_IDENTIFICATION_HEADER));
    ASSERT(pSingleIdentRecord->dwIdentityType == SaferIdentityTypeImageName ||
           pSingleIdentRecord->dwIdentityType == SaferIdentityTypeImageHash ||
           pSingleIdentRecord->dwIdentityType == SaferIdentityTypeUrlZone);


    //
    // Start filling the resulting structure with the data.
    //
    pIdentCommon = (PSAFER_IDENTIFICATION_HEADER) lpQueryBuffer;
    switch (pSingleIdentRecord->dwIdentityType)
    {
        // --------------------

        case SaferIdentityTypeImageName:
            Status = __CodeAuthzpOpenIdentifierKey(
                        pSingleIdentRecord->dwScopeId,
                        pSingleIdentRecord->dwLevelId,
                        SAFER_PATHS_REGSUBKEY,
                        &pSingleIdentRecord->IdentGuid,
                        &hKeyIdentity);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }

            pIdentCommon->dwIdentificationType = SaferIdentityTypeImageName;
            {
                PSAFER_PATHNAME_IDENTIFICATION pIdentOut = (PSAFER_PATHNAME_IDENTIFICATION) lpQueryBuffer;

                ASSERT(&pIdentOut->header == pIdentCommon);


                ulTextLen = pSingleIdentRecord->ImageNameInfo.ImagePath.Length;

                *dwNeededSize = ulTextLen + sizeof(UNICODE_NULL) +
                                sizeof(SAFER_PATHNAME_IDENTIFICATION);

                if (*dwNeededSize > dwInBufferSize) {
                    // the imagepath is vital, so we'll bail out.
                    Status = STATUS_BUFFER_TOO_SMALL;
                    goto ExitHandler2;
                } 

                pIdentOut->ImageName = (PWCHAR) (((PUCHAR) pIdentOut) + sizeof(SAFER_PATHNAME_IDENTIFICATION));

                Status = __CodeAuthzpQueryIdentityRegValue(
                            hKeyIdentity,
                            SAFER_IDS_DESCRIPTION_REGVALUE,
                            REG_SZ,
                            pIdentOut->Description,
                            SAFER_MAX_DESCRIPTION_SIZE * sizeof(WCHAR),
                            NULL);

                if (!NT_SUCCESS(Status)) {
                    pIdentOut->Description[0] = UNICODE_NULL;
                }
                
                RtlCopyMemory(pIdentOut->ImageName,
                    pSingleIdentRecord->ImageNameInfo.ImagePath.Buffer,
                    ulTextLen);
                pIdentOut->ImageName[ulTextLen / sizeof(WCHAR)] = UNICODE_NULL;

                pIdentOut->header.cbStructSize = *dwNeededSize;

                pIdentOut->dwSaferFlags =
                    pSingleIdentRecord->ImageNameInfo.dwSaferFlags;
            }
            break;

        // --------------------

        case SaferIdentityTypeImageHash:
            Status = __CodeAuthzpOpenIdentifierKey(
                        pSingleIdentRecord->dwScopeId,
                        pSingleIdentRecord->dwLevelId,
                        SAFER_HASHMD5_REGSUBKEY,
                        &pSingleIdentRecord->IdentGuid,
                        &hKeyIdentity);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }

            pIdentCommon->dwIdentificationType = SaferIdentityTypeImageHash;
            {
                PSAFER_HASH_IDENTIFICATION pIdentOut = (PSAFER_HASH_IDENTIFICATION) lpQueryBuffer;

                ASSERT(&pIdentOut->header == pIdentCommon);
                pIdentOut->header.cbStructSize =
                        sizeof(SAFER_HASH_IDENTIFICATION);

                Status = __CodeAuthzpQueryIdentityRegValue(
                            hKeyIdentity,
                            SAFER_IDS_DESCRIPTION_REGVALUE,
                            REG_SZ,
                            pIdentOut->Description,
                            SAFER_MAX_DESCRIPTION_SIZE * sizeof(WCHAR),
                            NULL
                            );
                if (!NT_SUCCESS(Status)) {
                    pIdentOut->Description[0] = UNICODE_NULL;
                }
                Status = __CodeAuthzpQueryIdentityRegValue(
                            hKeyIdentity,
                            SAFER_IDS_FRIENDLYNAME_REGVALUE,
                            REG_SZ,
                            pIdentOut->FriendlyName,
                            SAFER_MAX_FRIENDLYNAME_SIZE * sizeof(WCHAR),
                            NULL
                            );
                if (!NT_SUCCESS(Status)) {
                    pIdentOut->FriendlyName[0] = UNICODE_NULL;
                }
                ASSERT(pSingleIdentRecord->ImageHashInfo.HashSize <= SAFER_MAX_HASH_SIZE);
                RtlCopyMemory(pIdentOut->ImageHash,
                              pSingleIdentRecord->ImageHashInfo.ImageHash,
                              pSingleIdentRecord->ImageHashInfo.HashSize);
                pIdentOut->HashSize =
                        pSingleIdentRecord->ImageHashInfo.HashSize;
                pIdentOut->HashAlgorithm =
                        pSingleIdentRecord->ImageHashInfo.HashAlgorithm;
                pIdentOut->ImageSize =
                        pSingleIdentRecord->ImageHashInfo.ImageSize;
                pIdentOut->dwSaferFlags =
                        pSingleIdentRecord->ImageHashInfo.dwSaferFlags;
            }
            break;

        // --------------------

        case SaferIdentityTypeUrlZone:
        {
            PSAFER_URLZONE_IDENTIFICATION pIdentOut = (PSAFER_URLZONE_IDENTIFICATION) lpQueryBuffer;

            Status = __CodeAuthzpOpenIdentifierKey(
                        pSingleIdentRecord->dwScopeId,
                        pSingleIdentRecord->dwLevelId,
                        SAFER_SOURCEURL_REGSUBKEY,
                        &pSingleIdentRecord->IdentGuid,
                        &hKeyIdentity);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            pIdentCommon->dwIdentificationType = SaferIdentityTypeUrlZone;

            ASSERT(&pIdentOut->header == pIdentCommon);
            pIdentOut->header.cbStructSize =
                    sizeof(SAFER_URLZONE_IDENTIFICATION);

            pIdentOut->UrlZoneId =
                    pSingleIdentRecord->ImageZone.UrlZoneId;
            pIdentOut->dwSaferFlags =
                    pSingleIdentRecord->ImageZone.dwSaferFlags;
            break;
        }

        // --------------------

        default:
            Status = STATUS_INVALID_INFO_CLASS;
            goto ExitHandler;
    }

    //
    // Fill in the other information that is applicable to all types.
    //
    RtlCopyMemory(&pIdentCommon->IdentificationGuid,
                  &pSingleIdentRecord->IdentGuid,
                  sizeof(GUID));
    ASSERT(sizeof(FILETIME) == sizeof(DWORD) * 2);
    Status = __CodeAuthzpQueryIdentityRegValue(
                hKeyIdentity,
                SAFER_IDS_LASTMODIFIED_REGVALUE,
                REG_QWORD,
                &pIdentCommon->lastModified,
                sizeof(FILETIME),
                &ulResultLength
                );
    if (!NT_SUCCESS(Status)) {
        pIdentCommon->lastModified.dwHighDateTime =
            pIdentCommon->lastModified.dwLowDateTime = 0;
    }
    Status = STATUS_SUCCESS;

ExitHandler2:
    NtClose(hKeyIdentity);

ExitHandler:
    return Status;
}



NTSTATUS NTAPI
__CodeAuthzpGetAuthzLevelInfo(
    IN SAFER_LEVEL_HANDLE                      hLevelHandle,
    IN SAFER_OBJECT_INFO_CLASS     dwInfoType,
    OUT LPVOID                          lpQueryBuffer  OPTIONAL,
    IN DWORD                            dwInBufferSize,
    OUT LPDWORD                         lpdwOutBufferSize
    )
/*++

Routine Description:

    Allows the user to query various pieces of information about a
    given Level handle.

    Assumes that the caller has already obtained and locked the
    global critical section.

Arguments:

    hLevelHandle - the handle to the authorization object to evaluate.

    dwInfoType - specifies the type of information being requested.

    lpQueryBuffer - pointer to a user-supplied memory buffer that
        will receive the requested information.

    dwInBufferSize - specifies the size of the user's memory block.

    lpdwOutBufferSize - receives the used size of the data within the
        memory block, or the minimum necessary size if the passed
        buffer was too small.

Return Value:

    Returns STATUS_SUCCESS on success.

--*/
{
    const static SID_IDENTIFIER_AUTHORITY SIDAuth = SECURITY_NT_AUTHORITY;
    NTSTATUS Status;
    PAUTHZLEVELHANDLESTRUCT pAuthzLevelStruct;
    PAUTHZLEVELTABLERECORD pAuthzLevelRecord;
    PAUTHZIDENTSTABLERECORD pSingleIdentRecord = NULL;
    DWORD dwHandleScopeId;




    //
    // Obtain a pointer to the authorization Level structure.
    //
    ASSERT(g_TableCritSec.OwningThread == UlongToHandle(GetCurrentThreadId()));
    Status = CodeAuthzHandleToLevelStruct(hLevelHandle, &pAuthzLevelStruct);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler;
    }
    ASSERT(pAuthzLevelStruct != NULL);
    pAuthzLevelRecord = CodeAuthzLevelObjpLookupByLevelId(
            &g_CodeLevelObjTable, pAuthzLevelStruct->dwLevelId);
    if (!pAuthzLevelRecord) {
        Status = STATUS_INVALID_HANDLE;
        goto ExitHandler;
    }
    dwHandleScopeId = pAuthzLevelStruct->dwScopeId;


    //
    // Some of the attributes are fixed size, or are known before performing
    // the full query against the registry.  Compute their size first.
    //
    *lpdwOutBufferSize = 0;
    switch (dwInfoType)
    {
        case SaferObjectLevelId:              // DWORD
        case SaferObjectScopeId:              // DWORD
        case SaferObjectBuiltin:              // DWORD boolean
            *lpdwOutBufferSize = sizeof(DWORD);
            break;

        case SaferObjectFriendlyName:         // LPCTSTR
            if (!pAuthzLevelRecord->UnicodeFriendlyName.Buffer ||
                !pAuthzLevelRecord->UnicodeFriendlyName.Length) {
                Status = STATUS_NOT_FOUND;
                goto ExitHandler;
            }
            *lpdwOutBufferSize =
                pAuthzLevelRecord->UnicodeFriendlyName.Length +
                sizeof(UNICODE_NULL);
            break;

        case SaferObjectDescription:          // LPCTSTR
            if (!pAuthzLevelRecord->UnicodeDescription.Buffer ||
                !pAuthzLevelRecord->UnicodeDescription.Length) {
                Status = STATUS_NOT_FOUND;
                goto ExitHandler;
            }
            *lpdwOutBufferSize = pAuthzLevelRecord->UnicodeDescription.Length +
                    sizeof(UNICODE_NULL);
            break;

#ifdef ALLOW_FULL_WINSAFER
        case SaferObjectDisallowed:               // DWORD boolean
        case SaferObjectDisableMaxPrivilege:      // DWORD boolean
        case SaferObjectInvertDeletedPrivileges:  // DWORD boolean
            *lpdwOutBufferSize = sizeof(DWORD);
            break;

        case SaferObjectDeletedPrivileges:        // TOKEN_PRIVILEGES
            *lpdwOutBufferSize = (sizeof(TOKEN_PRIVILEGES) - sizeof(LUID_AND_ATTRIBUTES)) +
                pAuthzLevelRecord->DeletePrivilegeUsedCount * sizeof(LUID_AND_ATTRIBUTES);
            break;

        case SaferObjectDefaultOwner:             // TOKEN_OWNER
            *lpdwOutBufferSize = sizeof(TOKEN_OWNER);
            if (pAuthzLevelRecord->DefaultOwner != NULL)
                *lpdwOutBufferSize += RtlLengthSid(pAuthzLevelRecord->DefaultOwner);
            break;

        case SaferObjectSidsToDisable:            // TOKEN_GROUPS
            *lpdwOutBufferSize = (sizeof(TOKEN_GROUPS) - sizeof(SID_AND_ATTRIBUTES)) +
                pAuthzLevelRecord->DisableSidUsedCount * sizeof(SID_AND_ATTRIBUTES);
            for (Index = 0; Index < pAuthzLevelRecord->DisableSidUsedCount; Index++)
                *lpdwOutBufferSize += RtlLengthSid(pAuthzLevelRecord->SidsToDisable[Index].Sid);
            break;

        case SaferObjectRestrictedSidsInverted:   // TOKEN_GROUPS
            *lpdwOutBufferSize = (sizeof(TOKEN_GROUPS) - sizeof(SID_AND_ATTRIBUTES)) +
                pAuthzLevelRecord->RestrictedSidsInvUsedCount * sizeof(SID_AND_ATTRIBUTES);
            for (Index = 0; Index < pAuthzLevelRecord->RestrictedSidsInvUsedCount; Index++)
                *lpdwOutBufferSize += RtlLengthSid(pAuthzLevelRecord->RestrictedSidsInv[Index].Sid);
            break;

        case SaferObjectRestrictedSidsAdded:      // TOKEN_GROUPS
            *lpdwOutBufferSize = (sizeof(TOKEN_GROUPS) - sizeof(SID_AND_ATTRIBUTES)) +
                pAuthzLevelRecord->RestrictedSidsAddedUsedCount * sizeof(SID_AND_ATTRIBUTES);
            for (Index = 0; Index < pAuthzLevelRecord->RestrictedSidsAddedUsedCount; Index++)
                *lpdwOutBufferSize += RtlLengthSid(pAuthzLevelRecord->RestrictedSidsAdded[Index].Sid);
            break;
#endif


        case SaferObjectAllIdentificationGuids:
            *lpdwOutBufferSize = sizeof(GUID) *
                __CodeAuthzpCountIdentsForLevel(
                        dwHandleScopeId,
                        pAuthzLevelRecord->dwLevelId);
            if (!*lpdwOutBufferSize) {
                Status = STATUS_NOT_FOUND;
                goto ExitHandler;
            }
            break;


        case SaferObjectSingleIdentification:
        {
            *lpdwOutBufferSize = sizeof(SAFER_IDENTIFICATION_HEADER);
            if (ARGUMENT_PRESENT(lpQueryBuffer) &&
                dwInBufferSize >= *lpdwOutBufferSize)
            {
                PSAFER_IDENTIFICATION_HEADER pIdentCommonHeader =
                    (PSAFER_IDENTIFICATION_HEADER) lpQueryBuffer;

                if (pIdentCommonHeader->cbStructSize < *lpdwOutBufferSize) {
                    // the caller claimed that the dwInBufferSize was
                    // large enough, but the common header size doesn't.
                    goto ExitBufferTooSmall;
                }


                if (IsZeroGUID(&pIdentCommonHeader->IdentificationGuid))
                {
                    //
                    // Caller supplied a zero GUID and wants to retrieve
                    // the rule that produced the SaferIdentifyLevel
                    // result match, if this Level handle was from it.
                    //
                    if (IsZeroGUID(&pAuthzLevelStruct->identGuid)) {
                        // This was a handle that was explicitly opened
                        // by the user with SaferCreateLevel().
                        Status = STATUS_NOT_FOUND;
                        goto ExitHandler;
                    }
                    pSingleIdentRecord = CodeAuthzIdentsLookupByGuid(
                            &g_CodeIdentitiesTable,
                            &pAuthzLevelStruct->identGuid);
                    if (!pSingleIdentRecord) {
                        // This handle was obtained via a match to one of
                        // the special GUIDs or an code identity GUID
                        // that no longer exists.  Just return a blank
                        // structure with just the GUID in the header.
                        *lpdwOutBufferSize = sizeof(SAFER_IDENTIFICATION_HEADER);
                        break;
                    }

                } else {
                    //
                    // Caller is explicitly supplying the GUID of the
                    // code identifier rule that details should be
                    // retrieved for.
                    //
                    pSingleIdentRecord = CodeAuthzIdentsLookupByGuid(
                            &g_CodeIdentitiesTable,
                            &pIdentCommonHeader->IdentificationGuid);
                }


                //
                // We now have a pointer to the identity record that
                // information should be retrieved for.  Perform the
                // necessary work to marshal back the details about it.
                //
                if (!pSingleIdentRecord ||
                    pSingleIdentRecord->dwLevelId !=
                            pAuthzLevelRecord->dwLevelId ||
                    pSingleIdentRecord->dwScopeId != dwHandleScopeId)
                {
                    Status = STATUS_NOT_FOUND;
                    goto ExitHandler;
                }
                switch (pSingleIdentRecord->dwIdentityType) {
                case SaferIdentityTypeImageName:
                        // Size is calculated later on.
                        *lpdwOutBufferSize = 0;
                        break;

                    case SaferIdentityTypeImageHash:
                        *lpdwOutBufferSize = sizeof(SAFER_HASH_IDENTIFICATION);
                        break;

                    case SaferIdentityTypeUrlZone:
                        *lpdwOutBufferSize = sizeof(SAFER_URLZONE_IDENTIFICATION);
                        break;

                    default:
                        Status = STATUS_NOT_FOUND;
                        goto ExitHandler;
                }
            }
            break;
        }

        case SaferObjectExtendedError:
            *lpdwOutBufferSize = sizeof(DWORD);
            break;


        default:
            Status = STATUS_INVALID_INFO_CLASS;
            goto ExitHandler;
    }
    //ASSERTMSG("required buffer size must be computed", *lpdwOutBufferSize != 0);


    //
    // If there is not enough space for the query, then return with error.
    //
    if (*lpdwOutBufferSize != -1 &&
        (!ARGUMENT_PRESENT(lpQueryBuffer) ||
        dwInBufferSize < *lpdwOutBufferSize) )
    {
ExitBufferTooSmall:
        Status = STATUS_BUFFER_TOO_SMALL;
        goto ExitHandler;
    }


    //
    // Otherwise there is enough space for the request buffer,
    // so now actually perform the copy.
    //
    switch (dwInfoType)
    {
        case SaferObjectLevelId:              // DWORD
            *(PDWORD)lpQueryBuffer = pAuthzLevelRecord->dwLevelId;
            break;

        case SaferObjectScopeId:              // DWORD
            *(PDWORD)lpQueryBuffer = dwHandleScopeId;
            break;

        case SaferObjectBuiltin:              // DWORD boolean
            *((LPDWORD)lpQueryBuffer) =
                (pAuthzLevelRecord->Builtin ? TRUE : FALSE);
            break;

        case SaferObjectExtendedError:
            *((DWORD *)lpQueryBuffer) = pAuthzLevelStruct->dwExtendedError;
            break;

        case SaferObjectFriendlyName:         // LPCTSTR
            RtlCopyMemory(lpQueryBuffer,
                          pAuthzLevelRecord->UnicodeFriendlyName.Buffer,
                          pAuthzLevelRecord->UnicodeFriendlyName.Length);
            ((LPWSTR) lpQueryBuffer)[
                    pAuthzLevelRecord->UnicodeFriendlyName.Length /
                    sizeof(WCHAR) ] = UNICODE_NULL;
            *lpdwOutBufferSize =
                    pAuthzLevelRecord->UnicodeFriendlyName.Length +
                    sizeof(UNICODE_NULL);
            break;


        case SaferObjectDescription:          // LPCTSTR

            RtlCopyMemory(lpQueryBuffer,
                          pAuthzLevelRecord->UnicodeDescription.Buffer,
                          pAuthzLevelRecord->UnicodeDescription.Length);
            ((LPWSTR) lpQueryBuffer)[
                    pAuthzLevelRecord->UnicodeDescription.Length /
                    sizeof(WCHAR)] = UNICODE_NULL;
            *lpdwOutBufferSize =
                    pAuthzLevelRecord->UnicodeDescription.Length +
                    sizeof(UNICODE_NULL);
        break;

#ifdef ALLOW_FULL_WINSAFER
        case SaferObjectDisallowed:               // DWORD boolean
            *((LPDWORD)lpQueryBuffer) = (pAuthzLevelRecord->DisallowExecution != 0) ? TRUE : FALSE;
            break;
        case SaferObjectDisableMaxPrivilege:      // DWORD boolean
            *((LPDWORD)lpQueryBuffer) = (pAuthzLevelRecord->Flags & DISABLE_MAX_PRIVILEGE) != 0;
            break;
        case SaferObjectInvertDeletedPrivileges:  // DWORD boolean
            *((LPDWORD)lpQueryBuffer) = (pAuthzLevelRecord->InvertDeletePrivs != 0) ? TRUE : FALSE;
            break;
        case SaferObjectDeletedPrivileges:        // TOKEN_PRIVILEGES
        {
            PTOKEN_PRIVILEGES pTokenPrivs = (PTOKEN_PRIVILEGES) lpQueryBuffer;
            pTokenPrivs->PrivilegeCount = pAuthzLevelRecord->DeletePrivilegeUsedCount;
            RtlCopyMemory(&pTokenPrivs->Privileges[0],
                    &pAuthzLevelRecord->PrivilegesToDelete[0],
                    sizeof(LUID_AND_ATTRIBUTES) * pAuthzLevelRecord->DeletePrivilegeUsedCount);
            break;
        }
        case SaferObjectDefaultOwner:             // TOKEN_OWNER
        {
            PTOKEN_OWNER pTokenOwner = (PTOKEN_OWNER) lpQueryBuffer;
            if (pAuthzLevelRecord->DefaultOwner == NULL)
                pTokenOwner->Owner = NULL;
            else {
                pTokenOwner->Owner = (PSID) &pTokenOwner[1];
                Status = RtlCopySid(dwInBufferSize - sizeof(TOKEN_OWNER),
                        pTokenOwner->Owner, pAuthzLevelRecord->DefaultOwner);
                ASSERT(NT_SUCCESS(Status));
            }
            break;
        }
        case SaferObjectSidsToDisable:            // TOKEN_GROUPS (wildcard sids)
        {
            PTOKEN_GROUPS pTokenGroups = (PTOKEN_GROUPS) lpQueryBuffer;
            DWORD dwUsedOffset = (sizeof(TOKEN_GROUPS) - sizeof(SID_AND_ATTRIBUTES)) +
                    (sizeof(SID_AND_ATTRIBUTES) * pAuthzLevelRecord->DisableSidUsedCount);
            pTokenGroups->GroupCount = pAuthzLevelRecord->DisableSidUsedCount;
            for (Index = 0; Index < pAuthzLevelRecord->DisableSidUsedCount; Index++) {
                pTokenGroups->Groups[Index].Sid = (PSID) &((LPBYTE)lpQueryBuffer)[dwUsedOffset];
                DWORD dwSidLength = RtlLengthSid(pAuthzLevelRecord->SidsToDisable[Index].Sid);
                ASSERT(dwUsedOffset + dwSidLength <= dwInBufferSize);
                RtlCopyMemory(pTokenGroups->Groups[Index].Sid,
                        pAuthzLevelRecord->SidsToDisable[Index].Sid, dwSidLength);
                dwUsedOffset += dwSidLength;

    //BLACKCOMB TODO: handle wildcard sids differently?
                if (pAuthzLevelRecord->SidsToDisable[Index].WildcardPos == -1)
                    pTokenGroups->Groups[Index].Attributes = 0;
                else
                    pTokenGroups->Groups[Index].Attributes = (((DWORD) '*') << 24) |
                        (pAuthzLevelRecord->SidsToDisable[Index].WildcardPos & 0x0000FFFF);
            }
            break;
        }
        case SaferObjectRestrictedSidsInverted:   // TOKEN_GROUPS (wildcard sids)
        {
            PTOKEN_GROUPS pTokenGroups = (PTOKEN_GROUPS) lpQueryBuffer;
            DWORD dwUsedOffset = (sizeof(TOKEN_GROUPS) - sizeof(SID_AND_ATTRIBUTES)) +
                    (sizeof(SID_AND_ATTRIBUTES) * pAuthzLevelRecord->RestrictedSidsInvUsedCount);
            pTokenGroups->GroupCount = pAuthzLevelRecord->RestrictedSidsInvUsedCount;
            for (Index = 0; Index < pAuthzLevelRecord->RestrictedSidsInvUsedCount; Index++) {
                pTokenGroups->Groups[Index].Sid = (PSID) &((LPBYTE)lpQueryBuffer)[dwUsedOffset];
                DWORD dwSidLength = RtlLengthSid(pAuthzLevelRecord->RestrictedSidsInv[Index].Sid);
                ASSERT(dwUsedOffset + dwSidLength <= dwInBufferSize);
                RtlCopyMemory(pTokenGroups->Groups[Index].Sid,
                        pAuthzLevelRecord->RestrictedSidsInv[Index].Sid, dwSidLength);
                dwUsedOffset += dwSidLength;

    //BLACKCOMB TODO: handle wildcard sids differently?
                if (pAuthzLevelRecord->RestrictedSidsInv[Index].WildcardPos == -1)
                    pTokenGroups->Groups[Index].Attributes = 0;
                else
                    pTokenGroups->Groups[Index].Attributes = (((DWORD) '*') << 24) |
                        (pAuthzLevelRecord->RestrictedSidsInv[Index].WildcardPos & 0x0000FFFF);
            }
            break;
        }
        case SaferObjectRestrictedSidsAdded:      // TOKEN_GROUPS
        {
            PTOKEN_GROUPS pTokenGroups = (PTOKEN_GROUPS) lpQueryBuffer;
            DWORD dwUsedOffset = (sizeof(TOKEN_GROUPS) - sizeof(SID_AND_ATTRIBUTES)) +
                    (sizeof(SID_AND_ATTRIBUTES) * pAuthzLevelRecord->RestrictedSidsAddedUsedCount);
            pTokenGroups->GroupCount = pAuthzLevelRecord->RestrictedSidsAddedUsedCount;
            for (Index = 0; Index < pAuthzLevelRecord->RestrictedSidsAddedUsedCount; Index++) {
                pTokenGroups->Groups[Index].Attributes = 0;
                pTokenGroups->Groups[Index].Sid = (PSID) &((LPBYTE)lpQueryBuffer)[dwUsedOffset];
                DWORD dwSidLength = RtlLengthSid(pAuthzLevelRecord->RestrictedSidsAdded[Index].Sid);
                ASSERT(dwUsedOffset + dwSidLength <= dwInBufferSize);
                RtlCopyMemory(pTokenGroups->Groups[Index].Sid,
                        pAuthzLevelRecord->RestrictedSidsAdded[Index].Sid, dwSidLength);
                dwUsedOffset += dwSidLength;
            }
            break;
        }
#endif

        case SaferObjectAllIdentificationGuids:
            Status = __CodeAuthzpFetchIdentsForLevel(
                            dwHandleScopeId,
                            pAuthzLevelRecord->dwLevelId,
                            dwInBufferSize,
                            lpQueryBuffer,
                            lpdwOutBufferSize);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            break;

        case SaferObjectSingleIdentification:
            if (pSingleIdentRecord == NULL)
            {
                // One of the special identifier GUIDs is being returned,
                // or a no-longer existing identifier GUID.
                PSAFER_IDENTIFICATION_HEADER pCommon =
                    (PSAFER_IDENTIFICATION_HEADER) lpQueryBuffer;

                ASSERT(*lpdwOutBufferSize == sizeof(SAFER_IDENTIFICATION_HEADER));
                RtlZeroMemory(pCommon, sizeof(SAFER_IDENTIFICATION_HEADER));
                pCommon->cbStructSize = sizeof(SAFER_IDENTIFICATION_HEADER);
                RtlCopyMemory(&pCommon->IdentificationGuid,
                              &pAuthzLevelStruct->identGuid,
                              sizeof(GUID));
            }
            else
            {
                // Query information about a specific, existing GUID.
                Status = __CodeAuthzpQuerySingleIdentification(
                            pSingleIdentRecord,
                            lpQueryBuffer,
                            dwInBufferSize,
                            lpdwOutBufferSize
                            );
                if (!NT_SUCCESS(Status)) {
                    goto ExitHandler;
                }
            }
            break;

        default:
            ASSERTMSG("all info classes were not handled", 0);
            Status = STATUS_INVALID_INFO_CLASS;
            goto ExitHandler;
    }
    Status = STATUS_SUCCESS;



    //
    // Cleanup and epilogue code.
    //

ExitHandler:

    return Status;
}



BOOL WINAPI
SaferGetLevelInformation(
        IN SAFER_LEVEL_HANDLE          LevelHandle,
        IN SAFER_OBJECT_INFO_CLASS     dwInfoType,
        OUT LPVOID                     lpQueryBuffer    OPTIONAL ,
        IN DWORD                       dwInBufferSize,
        OUT LPDWORD                    lpdwOutBufferSize
        )
/*++

Routine Description:

    Allows the user to query various pieces of information about a
    given AuthzObject handle.

Arguments:

    LevelHandle - the handle to the authorization object to evaluate.

    dwInfoType - specifies the type of information being requested.

    lpQueryBuffer - pointer to a user-supplied memory buffer that
        will receive the requested information.

    dwInBufferSize - specifies the size of the user's memory block.

    lpdwOutBufferSize - receives the used size of the data within the
        memory block, or the minimum necessary size if the passed
        buffer was too small.

Return Value:

    Returns FALSE on error, otherwise success.

--*/
{
    NTSTATUS Status;


    if (!g_bInitializedFirstTime) {
        Status = STATUS_UNSUCCESSFUL;
        goto ExitHandler;
    }

    if (!ARGUMENT_PRESENT(lpdwOutBufferSize)) {
        Status = STATUS_INVALID_PARAMETER;
        goto ExitHandler;
    }

    RtlEnterCriticalSection(&g_TableCritSec);

    Status = __CodeAuthzpGetAuthzLevelInfo(
                    LevelHandle, dwInfoType,
                    lpQueryBuffer, dwInBufferSize,
                    lpdwOutBufferSize);

    RtlLeaveCriticalSection(&g_TableCritSec);

    if (NT_SUCCESS(Status))
        return TRUE;

ExitHandler:
    BaseSetLastNTError(Status);
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\winsafer\safeidep.c ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    SafeIdep.c        (WinSAFER Identify Objects privates)

Abstract:

    This module implements the WinSAFER APIs that loads the names (and
    high-level information) of all Authorization Levels defined within
    a given registry context.  The list of available levels is loaded
    into a Rtl Generic Table that can be enumerated and accessed using
    conventional Rtl Generic Table techniques.

Author:

    Jeffrey Lawson (JLawson) - Nov 1999

Environment:

    User mode only.

Exported Functions:

    CodeAuthzLevelObjpInitializeTable
    CodeAuthzLevelObjpLoadTable
    CodeAuthzLevelObjpEntireTableFree

Revision History:

    Created - Nov 1999

--*/

#include "pch.h"
#pragma hdrstop
#include <winsafer.h>
#include <winsaferp.h>
#include "saferp.h"




PVOID NTAPI
SaferpGenericTableAllocate (
        IN PRTL_GENERIC_TABLE      Table,
        IN CLONG                   ByteSize
        )
/*++

Routine Description:

    Internal callback for the generic table implementation.
    This function allocates memory for a new entry in a GENERIC_TABLE

Arguments:

    Table         - pointer to the Generic Table structure

    ByteSize      - the size, in bytes, of the structure to allocate

Return Value:

    Pointer to the allocated space.

--*/
{
    UNREFERENCED_PARAMETER(Table);
    return (PVOID) RtlAllocateHeap(RtlProcessHeap(), 0, ByteSize);
}


VOID NTAPI
SaferpGenericTableFree (
        IN PRTL_GENERIC_TABLE          Table,
        IN PVOID                       Buffer
        )
/*++

Routine Description:

    Internal callback for the generic table implementation.
    This function frees the space used by a GENERIC_TABLE entry.

Arguments:

    Table         - pointer to the Generic Table structure

    Buffer        - pointer to the space to deallocate.

Return Value:

    None.

--*/
{
    UNREFERENCED_PARAMETER(Table);
    ASSERT(Buffer != NULL);

    RtlFreeHeap(RtlProcessHeap(), 0, (LPVOID) Buffer);
}





RTL_GENERIC_COMPARE_RESULTS NTAPI
SaferpGuidIdentsTableCompare (
        IN PRTL_GENERIC_TABLE   Table,
        IN PVOID                FirstStruct,
        IN PVOID                SecondStruct
        )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PAUTHZIDENTSTABLERECORD FirstObj = (PAUTHZIDENTSTABLERECORD) FirstStruct;
    PAUTHZIDENTSTABLERECORD SecondObj = (PAUTHZIDENTSTABLERECORD) SecondStruct;
    int result;

    UNREFERENCED_PARAMETER(Table);

    // Explicitly handle null parameters as wildcards, allowing them
    // to match anything.  We use this for quick deletion of the table.
    if (FirstStruct == NULL || SecondStruct == NULL)
        return GenericEqual;

    // Compare ascending by guid.
    result = memcmp(&FirstObj->IdentGuid,
                    &SecondObj->IdentGuid, sizeof(GUID));
    if ( result < 0 )
        return GenericLessThan;
    else if ( result > 0 )
        return GenericGreaterThan;
    else
        return GenericEqual;
}



VOID NTAPI
CodeAuthzGuidIdentsInitializeTable(
        IN OUT PRTL_GENERIC_TABLE  pAuthzObjTable
        )
/*++

Routine Description:

Arguments:

    pAuthzObjTable - pointer to the generic table structure to initialize.

Return Value:

    Does not return a value.

--*/
{
    RtlInitializeGenericTable(
            pAuthzObjTable,
            (PRTL_GENERIC_COMPARE_ROUTINE) SaferpGuidIdentsTableCompare,
            (PRTL_GENERIC_ALLOCATE_ROUTINE) SaferpGenericTableAllocate,
            (PRTL_GENERIC_FREE_ROUTINE) SaferpGenericTableFree,
            NULL);
}


NTSTATUS NTAPI
SaferpGuidIdentsLoadTable (
        IN OUT PRTL_GENERIC_TABLE  pAuthzIdentTable,
        IN DWORD               dwScopeId,
        IN HANDLE              hKeyCustomBase,
        IN DWORD               dwLevelId,
        IN SAFER_IDENTIFICATION_TYPES dwIdentityType
        )
/*++

Routine Description:

    Loads all Code Identities of a particular fragment type and which
    map to a specific LevelId value.

Arguments:

    pAuthzIdentTable - specifies the table into which the new Code Identity
        records should be inserted.

    dwScopeId - can be AUTHZSCOPEID_USER, AUTHZSCOPEID_MACHINE, or
        AUTHSCOPEID_REGISTRY.

    hKeyCustomBase - used only if dwScopeId is AUTHZSCOPEID_REGISTRY.

    dwLevelId - specifies the LevelId for which identities should
        be loaded.

    dwIdentityType - specifies the type of identity to load.
        This can be SaferIdentityTypeImageName, SaferIdentityTypeImageHash,
        or SaferIdentityTypeUrlZone.

Return Value:

    Returns STATUS_SUCCESS if no error occurs.

--*/
{
    DWORD dwIndex;
    NTSTATUS Status;
    HANDLE hKeyIdentityBase;


    //
    // We were given the key to the root of the policy storage,
    // so we need to open the subkey that contains the Identities.
    //
    {
        WCHAR szPathSuffix[MAX_PATH];
        WCHAR szDigits[20];
        UNICODE_STRING UnicodePathSuffix;
        UNICODE_STRING UnicodeDigits;


        UnicodePathSuffix.Buffer = szPathSuffix;
        UnicodePathSuffix.Length = 0;
        UnicodePathSuffix.MaximumLength = sizeof(szPathSuffix);

        UnicodeDigits.Buffer = szDigits;
        UnicodeDigits.Length = 0;
        UnicodeDigits.MaximumLength = sizeof(szDigits);

        Status = RtlAppendUnicodeToString(
            &UnicodePathSuffix,
            SAFER_CODEIDS_REGSUBKEY L"\\");
        if (!NT_SUCCESS(Status)) return Status;
        Status = RtlIntegerToUnicodeString(
            dwLevelId, 10, &UnicodeDigits);
        if (!NT_SUCCESS(Status)) return Status;
        Status = RtlAppendUnicodeStringToString(
            &UnicodePathSuffix, &UnicodeDigits);
        if (!NT_SUCCESS(Status)) return Status;

        switch (dwIdentityType)
        {
            case SaferIdentityTypeImageName:
                Status = RtlAppendUnicodeToString(
                    &UnicodePathSuffix, L"\\" SAFER_PATHS_REGSUBKEY);
                break;

            case SaferIdentityTypeImageHash:
                Status = RtlAppendUnicodeToString(
                    &UnicodePathSuffix, L"\\" SAFER_HASHMD5_REGSUBKEY);
                break;

            case SaferIdentityTypeUrlZone:
                Status = RtlAppendUnicodeToString(
                    &UnicodePathSuffix, L"\\" SAFER_SOURCEURL_REGSUBKEY);
                break;

            default:
                Status = STATUS_INVALID_PARAMETER;
                break;
        }
        if (!NT_SUCCESS(Status)) return Status;
        ASSERT(UnicodePathSuffix.Buffer[ UnicodePathSuffix.Length /
                    sizeof(WCHAR) ] == UNICODE_NULL);


        Status = CodeAuthzpOpenPolicyRootKey(
                        dwScopeId,
                        hKeyCustomBase,
                        UnicodePathSuffix.Buffer,
                        KEY_READ,
                        FALSE,
                        &hKeyIdentityBase);
        if (!NT_SUCCESS(Status))
            return Status;
    }


    //
    // Iterate through all subkeys under this branch.
    //
    for (dwIndex = 0; ; dwIndex++)
    {
        DWORD dwLength;
        HANDLE hKeyThisIdentity;
        OBJECT_ATTRIBUTES ObjectAttributes;
        AUTHZIDENTSTABLERECORD AuthzIdentsRec;

        BYTE RawQueryBuffer[sizeof(KEY_BASIC_INFORMATION) + 256];
        PKEY_BASIC_INFORMATION pBasicInformation =
                (PKEY_BASIC_INFORMATION) &RawQueryBuffer[0];
        PKEY_VALUE_PARTIAL_INFORMATION pPartialInformation =
                (PKEY_VALUE_PARTIAL_INFORMATION) &RawQueryBuffer[0];
        UNICODE_STRING ValueName;
        UNICODE_STRING UnicodeKeyname;


        //
        // Find the next Identity GUID that we will check.
        //
        Status = NtEnumerateKey(hKeyIdentityBase,
                                dwIndex,
                                KeyBasicInformation,
                                pBasicInformation,
                                sizeof(RawQueryBuffer),
                                &dwLength);
        if (!NT_SUCCESS(Status)) {
            //
            // If this one key was too large to fit in our query buffer
            // then simply skip over it and try enumerating the next one.
            //
            if (Status == STATUS_BUFFER_OVERFLOW) {
                continue;
            } else {
                break;
            }
        }
        UnicodeKeyname.Buffer = pBasicInformation->Name;
        UnicodeKeyname.MaximumLength = UnicodeKeyname.Length =
                (USHORT) pBasicInformation->NameLength;
        // Note that UnicodeKeyname.Buffer is not necessarily null terminated.
        ASSERT(UnicodeKeyname.Length <= wcslen(UnicodeKeyname.Buffer) * sizeof(WCHAR));


        //
        // Translate the keyname (which we expect to be a GUID).
        //
        RtlZeroMemory(&AuthzIdentsRec, sizeof(AUTHZIDENTSTABLERECORD));
        Status = RtlGUIDFromString(&UnicodeKeyname,
                                   &AuthzIdentsRec.IdentGuid);
        if (!NT_SUCCESS(Status) ||
            IsZeroGUID(&AuthzIdentsRec.IdentGuid)) {
            // the keyname was apparently not numeric.
            continue;
        }
        AuthzIdentsRec.dwScopeId = dwScopeId;
        AuthzIdentsRec.dwLevelId = dwLevelId;
        AuthzIdentsRec.dwIdentityType = dwIdentityType;
        if (RtlLookupElementGenericTable(
                pAuthzIdentTable, (PVOID) &AuthzIdentsRec) != NULL) {
            // this identity GUID happens to have already been found.
            continue;
        }


        //
        // Try to open a handle to that Identity GUID.
        //
        InitializeObjectAttributes(&ObjectAttributes,
              &UnicodeKeyname,
              OBJ_CASE_INSENSITIVE,
              hKeyIdentityBase,
              NULL
              );
        Status = NtOpenKey(&hKeyThisIdentity,
                           KEY_READ,
                           &ObjectAttributes);
        if (!NT_SUCCESS(Status)) {
            // If we failed to open it, skip to the next one.
            continue;
        }


        //
        // Add the new record into our table.
        //
        switch (dwIdentityType) {
            // --------------------

            case SaferIdentityTypeImageName:
                //
                // Read the image path.
                //
                RtlInitUnicodeString(
                    &ValueName, SAFER_IDS_ITEMDATA_REGVALUE);
                Status = NtQueryValueKey(hKeyThisIdentity,
                                         &ValueName,
                                         KeyValuePartialInformation,
                                         pPartialInformation,
                                         sizeof(RawQueryBuffer),
                                         &dwLength);
                if (!NT_SUCCESS(Status)) {
                    break;
                }

                if (pPartialInformation->Type == REG_SZ ||
                    pPartialInformation->Type == REG_EXPAND_SZ) {

                    AuthzIdentsRec.ImageNameInfo.bExpandVars =
                        (pPartialInformation->Type == REG_EXPAND_SZ);
                    Status = RtlCreateUnicodeString(
                            &AuthzIdentsRec.ImageNameInfo.ImagePath,
                            (LPCWSTR) pPartialInformation->Data);
                    if (!NT_SUCCESS(Status)) {
                        break;
                    }
                } else {
                    Status = STATUS_UNSUCCESSFUL;
                    break;
                }

                //
                // Read the extra WinSafer flags.
                //
                RtlInitUnicodeString(&ValueName,
                                     SAFER_IDS_SAFERFLAGS_REGVALUE);
                Status = NtQueryValueKey(hKeyThisIdentity,
                                         &ValueName,
                                         KeyValuePartialInformation,
                                         pPartialInformation,
                                         sizeof(RawQueryBuffer),
                                         &dwLength);
                if (NT_SUCCESS(Status) &&
                    pPartialInformation->Type == REG_DWORD &&
                    pPartialInformation->DataLength == sizeof(DWORD)) {

                    AuthzIdentsRec.ImageNameInfo.dwSaferFlags =
                        (*(PDWORD) pPartialInformation->Data);

                } else {
                    // default the flags if they are missing.
                    AuthzIdentsRec.ImageNameInfo.dwSaferFlags = 0;
                    Status = STATUS_SUCCESS;
                }

                break;

            // --------------------

            case SaferIdentityTypeImageHash:
                //
                // Read the hash data and hash size.
                //
                RtlInitUnicodeString(&ValueName,
                                     SAFER_IDS_ITEMDATA_REGVALUE);
                Status = NtQueryValueKey(hKeyThisIdentity,
                                         &ValueName,
                                         KeyValuePartialInformation,
                                         pPartialInformation,
                                         sizeof(RawQueryBuffer),
                                         &dwLength);
                if (!NT_SUCCESS(Status)) {
                    break;
                }
                if (pPartialInformation->Type == REG_BINARY &&
                    pPartialInformation->DataLength > 0 &&
                    pPartialInformation->DataLength <= SAFER_MAX_HASH_SIZE) {

                    AuthzIdentsRec.ImageHashInfo.HashSize =
                        pPartialInformation->DataLength;
                    RtlCopyMemory(&AuthzIdentsRec.ImageHashInfo.ImageHash[0],
                                  pPartialInformation->Data,
                                  pPartialInformation->DataLength);

                } else {
                    Status = STATUS_UNSUCCESSFUL;
                    break;
                }

                //
                // Read the algorithm used to compute the hash.
                //
                RtlInitUnicodeString(&ValueName,
                                     SAFER_IDS_HASHALG_REGVALUE);
                Status = NtQueryValueKey(hKeyThisIdentity,
                                         &ValueName,
                                         KeyValuePartialInformation,
                                         pPartialInformation,
                                         sizeof(RawQueryBuffer),
                                         &dwLength);
                if (!NT_SUCCESS(Status)) {
                    break;
                }
                if (pPartialInformation->Type == REG_DWORD &&
                    pPartialInformation->DataLength == sizeof(DWORD)) {

                    AuthzIdentsRec.ImageHashInfo.HashAlgorithm =
                        *((PDWORD) pPartialInformation->Data);
                } else {
                    Status = STATUS_UNSUCCESSFUL;
                    break;
                }
                if ((AuthzIdentsRec.ImageHashInfo.HashAlgorithm &
                        ALG_CLASS_ALL) != ALG_CLASS_HASH) {
                    Status = STATUS_UNSUCCESSFUL;
                    break;
                }


                //
                // Read the original image size.
                //
                RtlInitUnicodeString(&ValueName,
                                     SAFER_IDS_ITEMSIZE_REGVALUE);
                Status = NtQueryValueKey(hKeyThisIdentity,
                                         &ValueName,
                                         KeyValuePartialInformation,
                                         pPartialInformation,
                                         sizeof(RawQueryBuffer),
                                         &dwLength);
                if (!NT_SUCCESS(Status)) {
                    break;
                }
                if (pPartialInformation->Type == REG_DWORD &&
                    pPartialInformation->DataLength == sizeof(DWORD)) {

                    AuthzIdentsRec.ImageHashInfo.ImageSize.LowPart =
                        *((PDWORD) pPartialInformation->Data);
                    AuthzIdentsRec.ImageHashInfo.ImageSize.HighPart = 0;
                } else if (pPartialInformation->Type == REG_QWORD &&
                           pPartialInformation->DataLength == 2 * sizeof(DWORD) ) {

                    AuthzIdentsRec.ImageHashInfo.ImageSize.QuadPart =
                        ((PLARGE_INTEGER) pPartialInformation->Data)->QuadPart;
                } else {
                    Status = STATUS_UNSUCCESSFUL;
                    break;
                }

                //
                // Read the extra WinSafer flags.
                //
                RtlInitUnicodeString(&ValueName,
                                     SAFER_IDS_SAFERFLAGS_REGVALUE);
                Status = NtQueryValueKey(hKeyThisIdentity,
                                         &ValueName,
                                         KeyValuePartialInformation,
                                         pPartialInformation,
                                         sizeof(RawQueryBuffer),
                                         &dwLength);
                if (NT_SUCCESS(Status) &&
                    pPartialInformation->Type == REG_DWORD &&
                    pPartialInformation->DataLength == sizeof(DWORD)) {

                    #ifdef SAFER_POLICY_ONLY_EXES
                    AuthzIdentsRec.ImageHashInfo.dwSaferFlags =
                        (*((PDWORD) pPartialInformation->Data)) &
                        ~SAFER_POLICY_ONLY_EXES;
                    #else
                    AuthzIdentsRec.ImageHashInfo.dwSaferFlags =
                        (*((PDWORD) pPartialInformation->Data));
                    #endif

                } else {
                    // default the flags if they are missing.
                    AuthzIdentsRec.ImageHashInfo.dwSaferFlags = 0;
                    Status = STATUS_SUCCESS;
                }


                break;

            // --------------------

            case SaferIdentityTypeUrlZone:
                //
                // Read the zone identifier.
                //
                RtlInitUnicodeString(&ValueName,
                                     SAFER_IDS_ITEMDATA_REGVALUE);
                Status = NtQueryValueKey(hKeyThisIdentity,
                                         &ValueName,
                                         KeyValuePartialInformation,
                                         pPartialInformation,
                                         sizeof(RawQueryBuffer),
                                         &dwLength);
                if (!NT_SUCCESS(Status)) {
                    break;
                }
                if (pPartialInformation->Type == REG_DWORD &&
                    pPartialInformation->DataLength == sizeof(DWORD)) {

                    AuthzIdentsRec.ImageZone.UrlZoneId =
                        * (PDWORD) pPartialInformation->Data;

                } else {
                    Status = STATUS_UNSUCCESSFUL;
                    break;
                }

                //
                // Read the extra WinSafer flags.
                //
                RtlInitUnicodeString(&ValueName,
                                     SAFER_IDS_SAFERFLAGS_REGVALUE);
                Status = NtQueryValueKey(hKeyThisIdentity,
                                         &ValueName,
                                         KeyValuePartialInformation,
                                         pPartialInformation,
                                         sizeof(RawQueryBuffer),
                                         &dwLength);
                if (NT_SUCCESS(Status) &&
                    pPartialInformation->Type == REG_DWORD &&
                    pPartialInformation->DataLength == sizeof(DWORD)) {

                    #ifdef SAFER_POLICY_ONLY_EXES
                    AuthzIdentsRec.ImageZone.dwSaferFlags =
                        (*(PDWORD) pPartialInformation->Data) &
                        ~SAFER_POLICY_ONLY_EXES;
                    #else
                    AuthzIdentsRec.ImageZone.dwSaferFlags =
                        (*(PDWORD) pPartialInformation->Data);
                    #endif

                } else {
                    // default the flags if they are missing.
                    AuthzIdentsRec.ImageZone.dwSaferFlags = 0;
                    Status = STATUS_SUCCESS;
                }

                break;

            // --------------------

            default:
                ASSERT(0 && "unexpected identity type");
                Status = STATUS_INVALID_INFO_CLASS;
        }

        // Only insert the record if we don't have
        // any other entries with this same GUID.
        if (NT_SUCCESS(Status)) {
            RtlInsertElementGenericTable(
                    pAuthzIdentTable,
                    (PVOID) &AuthzIdentsRec,
                    sizeof(AUTHZIDENTSTABLERECORD),
                    NULL);
        }
        NtClose(hKeyThisIdentity);
    }

    NtClose(hKeyIdentityBase);
    return STATUS_SUCCESS;
}


NTSTATUS NTAPI
CodeAuthzGuidIdentsLoadTableAll (
        IN PRTL_GENERIC_TABLE       pAuthzLevelTable,
        IN OUT PRTL_GENERIC_TABLE   pAuthzIdentTable,
        IN DWORD                    dwScopeId,
        IN HANDLE                   hKeyCustomBase
        )
/*++

Routine Description:

Arguments:

    pAuthzLevelTable - specifies the table that has already been
        loaded with the WinSafer Levels that should be allowed.
        These Levels do not necessarily need to have been loaded
        from the same scope from which the Code Identities are
        being loaded from.

    pAuthzIdentTable - specifies the table into which the loaded
        Code Identities should be inserted.

    dwScopeId - scope from where the Code Identities should be loaded from.
        This may be AUTHZSCOPEID_MACHINE, AUTHZSCOPEID_USER, or
        AUTHZSCOPEID_REGISTRY.

    hKeyCustomBase - only used if dwScopeId was AUTHZSCOPEID_REGISTRY.

Return Value:

    Returns STATUS_SUCCESS if no errors occurred.

--*/
{
    NTSTATUS Status;
    NTSTATUS WorstStatus = STATUS_SUCCESS;
    PVOID RestartKey;
    PAUTHZLEVELTABLERECORD pAuthzLevelRecord;


    //
    // Enumerate through all records and close the registry handles.
    //
    RestartKey = NULL;
    for (pAuthzLevelRecord = (PAUTHZLEVELTABLERECORD)
            RtlEnumerateGenericTableWithoutSplaying(
                    pAuthzLevelTable, &RestartKey);
         pAuthzLevelRecord != NULL;
         pAuthzLevelRecord = (PAUTHZLEVELTABLERECORD)
            RtlEnumerateGenericTableWithoutSplaying(
                    pAuthzLevelTable, &RestartKey)
         )
    {
        Status = SaferpGuidIdentsLoadTable(
                    pAuthzIdentTable,
                    dwScopeId,
                    hKeyCustomBase,
                    pAuthzLevelRecord->dwLevelId,
                    SaferIdentityTypeImageName);
        if (!NT_SUCCESS(Status))
            WorstStatus = Status;

        Status = SaferpGuidIdentsLoadTable(
                    pAuthzIdentTable,
                    dwScopeId,
                    hKeyCustomBase,
                    pAuthzLevelRecord->dwLevelId,
                    SaferIdentityTypeImageHash);
        if (!NT_SUCCESS(Status))
            WorstStatus = Status;

        Status = SaferpGuidIdentsLoadTable(
                    pAuthzIdentTable,
                    dwScopeId,
                    hKeyCustomBase,
                    pAuthzLevelRecord->dwLevelId,
                    SaferIdentityTypeUrlZone);
        if (!NT_SUCCESS(Status))
            WorstStatus = Status;
    }


    return WorstStatus;
}



VOID NTAPI
CodeAuthzGuidIdentsEntireTableFree (
        IN OUT PRTL_GENERIC_TABLE pAuthzIdentTable
        )
/*++

Routine Description:

    Frees the allocated memory associated with all of the entries
    currently within a Code Identities table.  Once the table has
    been emptied, it may immediately be filled again without any
    other initialization necessary.

Arguments:

    pAuthzIdentTable - pointer to the table that should be cleared.

Return Value:

    Does not return any value.

--*/
{
    ULONG NumElements;

    //
    // Now iterate through the table again and free all of the
    // elements themselves.
    //
    NumElements = RtlNumberGenericTableElements(pAuthzIdentTable);

    while ( NumElements-- > 0 ) {
        // Delete all elements.  Note that we pass NULL as the element
        // to delete because our compare function is smart enough to
        // allow treatment of NULL as a wildcard element.
        BOOL retval = RtlDeleteElementGenericTable( pAuthzIdentTable, NULL);
        ASSERT(retval == TRUE);
    }
}


PAUTHZIDENTSTABLERECORD NTAPI
CodeAuthzIdentsLookupByGuid (
        IN PRTL_GENERIC_TABLE      pAuthzIdentTable,
        IN REFGUID                 pIdentGuid
        )
/*++

Routine Description:

    This function searches for an identity within a GENERIC_TABLE.

Arguments:

    pAuthzIdentTable   - pointer to the Generic Table structure

    pIdentGuid -

Return Value:

    Returns a pointer to the Code Identity record if the GUID
    specified was found.  Otherwise NULL is returned.

--*/
{
    AUTHZIDENTSTABLERECORD AuthzIdentsRec;

    RtlCopyMemory(&AuthzIdentsRec.IdentGuid, pIdentGuid, sizeof(GUID));
    return (PAUTHZIDENTSTABLERECORD)
        RtlLookupElementGenericTable(pAuthzIdentTable,
                   (PVOID) &AuthzIdentsRec);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\winsafer\safelevp.c ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    SafeLevp.c        (WinSAFER Level table privates)

Abstract:

    This module implements the WinSAFER APIs that loads the names (and
    high-level information) of all Authorization Levels defined within
    a given registry context.  The list of available levels is loaded
    into a Rtl Generic Table that can be enumerated and accessed using
    conventional Rtl Generic Table techniques.

Author:

    Jeffrey Lawson (JLawson) - Nov 1999

Environment:

    User mode only.

Exported Functions:

    CodeAuthzLevelObjpInitializeTable
    CodeAuthzLevelObjpLoadTable
    CodeAuthzLevelObjpEntireTableFree

Revision History:

    Created - Nov 1999

--*/

#include "pch.h"
#pragma hdrstop
#include <sddl.h>
#include <winsafer.h>
#include <winsaferp.h>
#include <winsafer.rh>
#include "saferp.h"

//
// Private enumerators used as the EntryContext parameter in our
// callback function CodeAuthzpBuildRestrictedToken during the
// call to RtlQueryRegistryValues.
//
#define AUTHZREGQUERY_IGNORE                (0)
#define AUTHZREGQUERY_DISALLOWEXECUTION     (1)
#define AUTHZREGQUERY_PTR_DISABLEMAX        (2)
#define AUTHZREGQUERY_PTR_COUNT             (3)
#define AUTHZREGQUERY_PTR_PRIVS             (4)
#define AUTHZREGQUERY_PTR_INVERT            (5)
#define AUTHZREGQUERY_RSADD_COUNT           (6)
#define AUTHZREGQUERY_RSADD_SIDS            (7)
#define AUTHZREGQUERY_RSINV_COUNT           (8)
#define AUTHZREGQUERY_RSINV_SIDS            (9)
#define AUTHZREGQUERY_STD_COUNT             (10)
#define AUTHZREGQUERY_STD_SIDS              (11)
#define AUTHZREGQUERY_STD_INVERT            (12)
#define AUTHZREGQUERY_DEFAULTOWNER          (13)
#define AUTHZREGQUERY_SAFERFLAGS            (14)
#define AUTHZREGQUERY_DESCRIPTION           (15)
#define AUTHZREGQUERY_FRIENDLYNAME          (16)


//
// Prototype for the callback function used within the following table.
//
NTSTATUS NTAPI
SaferpBuildRestrictedToken(
        IN PWSTR ValueName,
        IN ULONG ValueType,
        IN PVOID ValueData,
        IN ULONG ValueLength,
        IN PVOID Context,
        IN PVOID EntryContext
        );

PVOID NTAPI
SaferpGenericTableAllocate (
        IN PRTL_GENERIC_TABLE      Table,
        IN CLONG                   ByteSize
        );

VOID NTAPI
SaferpGenericTableFree (
        IN PRTL_GENERIC_TABLE          Table,
        IN PVOID                       Buffer
        );



//
// Internal structure used as an argument to RtlQueryRegistryValues
// during the loading/parsing of an Authorization Object's restrictions.
//
RTL_QUERY_REGISTRY_TABLE CodeAuthzpBuildRestrictedTokenTable[] =
{
    // ----------- Object level flags ------------

    {(PRTL_QUERY_REGISTRY_ROUTINE)SaferpBuildRestrictedToken,
        0,
        SAFER_OBJDISALLOW_REGVALUE,
        (PVOID) AUTHZREGQUERY_DISALLOWEXECUTION,
        REG_NONE, NULL, 0},

    {(PRTL_QUERY_REGISTRY_ROUTINE)SaferpBuildRestrictedToken,
        0,
        SAFER_OBJDESCRIPTION_REGVALUEW,
        (PVOID) AUTHZREGQUERY_DESCRIPTION,
        REG_NONE, NULL, 0},

    {(PRTL_QUERY_REGISTRY_ROUTINE)SaferpBuildRestrictedToken,
        0,
        SAFER_OBJFRIENDLYNAME_REGVALUEW,
        (PVOID) AUTHZREGQUERY_FRIENDLYNAME,
        REG_NONE, NULL, 0},

    // ----------- Restriction level flags -----------

    {(PRTL_QUERY_REGISTRY_ROUTINE)SaferpBuildRestrictedToken,
        RTL_QUERY_REGISTRY_SUBKEY,
        L"Restrictions", (PVOID) AUTHZREGQUERY_IGNORE,
        REG_NONE, NULL, 0},

    {(PRTL_QUERY_REGISTRY_ROUTINE)SaferpBuildRestrictedToken,
        0,
        L"DefaultOwner", (PVOID) AUTHZREGQUERY_DEFAULTOWNER,
        REG_NONE, NULL, 0},

    {(PRTL_QUERY_REGISTRY_ROUTINE)SaferpBuildRestrictedToken,
        0,
        L"SaferFlags", (PVOID) AUTHZREGQUERY_SAFERFLAGS,
        REG_NONE, NULL, 0},

    // ----------- Privileges To Remove ------------

    {(PRTL_QUERY_REGISTRY_ROUTINE)SaferpBuildRestrictedToken,
        RTL_QUERY_REGISTRY_SUBKEY,
        L"Restrictions\\PrivsToRemove", (PVOID) AUTHZREGQUERY_IGNORE,
        REG_NONE, NULL, 0},

    {(PRTL_QUERY_REGISTRY_ROUTINE)SaferpBuildRestrictedToken,
        0,
        L"DisableMaxPrivilege", (PVOID) AUTHZREGQUERY_PTR_DISABLEMAX,
        REG_NONE, NULL, 0},

    {(PRTL_QUERY_REGISTRY_ROUTINE)SaferpBuildRestrictedToken,
        0,
        L"Count", (PVOID) AUTHZREGQUERY_PTR_COUNT,
        REG_NONE, NULL, 0},

    {(PRTL_QUERY_REGISTRY_ROUTINE)SaferpBuildRestrictedToken,
        0,
        NULL, (PVOID) AUTHZREGQUERY_PTR_PRIVS,
        REG_NONE, NULL, 0},

    {(PRTL_QUERY_REGISTRY_ROUTINE)SaferpBuildRestrictedToken,
        0,
        L"InvertPrivs", (PVOID) AUTHZREGQUERY_PTR_INVERT,
        REG_NONE, NULL, 0},

    // ----------- Sids To Disable ------------

    {(PRTL_QUERY_REGISTRY_ROUTINE)SaferpBuildRestrictedToken,
        RTL_QUERY_REGISTRY_SUBKEY,
        L"Restrictions\\SidsToDisable", (PVOID) AUTHZREGQUERY_IGNORE,
        REG_NONE, NULL, 0},

    {(PRTL_QUERY_REGISTRY_ROUTINE)SaferpBuildRestrictedToken,
        0,
        L"Count", (PVOID) AUTHZREGQUERY_STD_COUNT,
        REG_NONE, NULL, 0},

    {(PRTL_QUERY_REGISTRY_ROUTINE)SaferpBuildRestrictedToken,
        0,
        NULL, (PVOID) AUTHZREGQUERY_STD_SIDS,
        REG_NONE, NULL, 0},

    {(PRTL_QUERY_REGISTRY_ROUTINE)SaferpBuildRestrictedToken,
        0,
        L"InvertGroups", (PVOID) AUTHZREGQUERY_STD_INVERT,
        REG_NONE, NULL, 0},

    // ----------- Restricting Sids Added ------------

    {(PRTL_QUERY_REGISTRY_ROUTINE)SaferpBuildRestrictedToken,
        RTL_QUERY_REGISTRY_SUBKEY,
        L"Restrictions\\RestrictingSidsAdded", (PVOID) AUTHZREGQUERY_IGNORE,
        REG_NONE, NULL, 0},

    {(PRTL_QUERY_REGISTRY_ROUTINE)SaferpBuildRestrictedToken,
        0,
        L"Count", (PVOID) AUTHZREGQUERY_RSADD_COUNT,
        REG_NONE, NULL, 0},

    {(PRTL_QUERY_REGISTRY_ROUTINE)SaferpBuildRestrictedToken,
        0,
        NULL, (PVOID) AUTHZREGQUERY_RSADD_SIDS,
        REG_NONE, NULL, 0},

    // ----------- Restricting Sids Inverted ------------

    {(PRTL_QUERY_REGISTRY_ROUTINE)SaferpBuildRestrictedToken,
        RTL_QUERY_REGISTRY_SUBKEY,
        L"Restrictions\\RestrictingSidsInverted", (PVOID) AUTHZREGQUERY_IGNORE,
        REG_NONE, NULL, 0},

    {(PRTL_QUERY_REGISTRY_ROUTINE)SaferpBuildRestrictedToken,
        0,
        L"Count", (PVOID) AUTHZREGQUERY_RSINV_COUNT,
        REG_NONE, NULL, 0},

    {(PRTL_QUERY_REGISTRY_ROUTINE)SaferpBuildRestrictedToken,
        0,
        NULL, (PVOID) AUTHZREGQUERY_RSINV_SIDS,
        REG_NONE, NULL, 0},

    // ----------- Terminating Entry ------------

    {NULL, 0, NULL, NULL, REG_NONE, NULL, 0}

};




RTL_GENERIC_COMPARE_RESULTS NTAPI
SaferpLevelObjpTableCompare (
    IN PRTL_GENERIC_TABLE   Table,
    IN PVOID                FirstStruct,
    IN PVOID                SecondStruct
    )
/*++

Routine Description:

    Internal callback for the generic table implementation.
    Comparison callback function used to sort or search entries in the
    level table.  Sorts the object records by the order in which they
    should be evaluated to find the first matching rule for a given
    piece of code.

Arguments:

    Table - pointer to the generic table.

    FirstStruct - first element to compare.

    SecondStruct - second element to compare.

Return Value:

    Returns GenericEqual, GenericLessThan, or GenericGreaterThan.

--*/
{
    PAUTHZLEVELTABLERECORD FirstObj = (PAUTHZLEVELTABLERECORD) FirstStruct;
    PAUTHZLEVELTABLERECORD SecondObj = (PAUTHZLEVELTABLERECORD) SecondStruct;

    UNREFERENCED_PARAMETER(Table);

    // Explicitly handle null parameters as wildcards, allowing them
    // to match anything.  We use this for quick deletion of the table.
    if (FirstStruct == NULL || SecondStruct == NULL)
        return GenericEqual;

    // Compare ascending by dwLevelId.
    if ( FirstObj->dwLevelId < SecondObj->dwLevelId )
        return GenericLessThan;
    else if ( FirstObj->dwLevelId > SecondObj->dwLevelId )
        return GenericGreaterThan;

    // otherwise they are equal.
    return GenericEqual;
}



NTSTATUS NTAPI
SaferpBuildRestrictedToken(
        IN PWSTR    ValueName,
        IN ULONG    ValueType,
        IN PVOID    ValueData,
        IN ULONG    ValueLength,
        IN PVOID    Context,
        IN PVOID    EntryContext
        )
/*++

Routine Description:

    This is a callback function used during the reading and parsing
    of the registry values associated with the restricted token
    that will be built.

Arguments:

    ValueName -

    ValueType -

    ValueData -

    ValueLength -

    Context - parameter from original RtlQueryRegistryValues function call.

    EntryContext - parameter from structure entry.

Return Value:

    Returns STATUS_SUCCESS if enumeration should continue.

--*/
{
    PAUTHZLEVELTABLERECORD RegQuery = (PAUTHZLEVELTABLERECORD) Context;

    switch ((ULONG_PTR) EntryContext)
    {
    case AUTHZREGQUERY_DISALLOWEXECUTION:
        if (!RegQuery->Builtin) {
            RegQuery->DisallowExecution =
                ((ValueType == REG_DWORD) &&
                (ValueLength == sizeof(DWORD)) &&
                (*(PDWORD) ValueData) != 0);
        }
        break;
    case AUTHZREGQUERY_DESCRIPTION:
        if (ValueType == REG_SZ &&
            RegQuery->UnicodeDescription.Buffer == NULL)
        {
            RtlCreateUnicodeString(
                &RegQuery->UnicodeDescription,
                (LPCWSTR) ValueData);
        }
        break;
    case AUTHZREGQUERY_FRIENDLYNAME:
        if (ValueType == REG_SZ &&
            RegQuery->UnicodeFriendlyName.Buffer == NULL)
        {
            RtlCreateUnicodeString(
                &RegQuery->UnicodeFriendlyName,
                (LPCWSTR) ValueData);
        }
        break;
    //---------
    case AUTHZREGQUERY_DEFAULTOWNER:
        if (!RegQuery->Builtin && ValueType == REG_SZ &&
            RegQuery->DefaultOwner == NULL)
        {
            if (!ConvertStringSidToSidW(
                (LPCWSTR) ValueData,
                &RegQuery->DefaultOwner))
            {
                RegQuery->DefaultOwner = NULL;
            }
        }
        break;
    case AUTHZREGQUERY_SAFERFLAGS:
        if (!RegQuery->Builtin && ValueType == REG_DWORD &&
            ValueLength == sizeof(DWORD))
        {
            RegQuery->SaferFlags = *(LPDWORD) ValueData;
        }
        break;
    //---------
    case AUTHZREGQUERY_PTR_DISABLEMAX:
        if (!RegQuery->Builtin && ValueType == REG_DWORD &&
            ValueLength == sizeof(DWORD) &&
            (*(PDWORD) ValueData) != 0)
            RegQuery->DisableMaxPrivileges = TRUE;
        break;
    case AUTHZREGQUERY_PTR_COUNT:
        if (!RegQuery->Builtin && ValueType == REG_DWORD &&
            ValueLength == sizeof(DWORD))
        {
            ASSERT(RegQuery->PrivilegesToDelete == NULL);
            RegQuery->DeletePrivilegeCount = (*(PDWORD) ValueData);
            RegQuery->DeletePrivilegeUsedCount = 0;
            if (RegQuery->DeletePrivilegeCount > 0) {
                RegQuery->PrivilegesToDelete =
                    (PLUID_AND_ATTRIBUTES) RtlAllocateHeap(
                            RtlProcessHeap(),
                            0,
                            sizeof(LUID_AND_ATTRIBUTES) *
                                RegQuery->DeletePrivilegeCount);
                if (RegQuery->PrivilegesToDelete == NULL)
                    return STATUS_NO_MEMORY;
            }
        }
        break;
    case AUTHZREGQUERY_PTR_PRIVS:
        if (!RegQuery->Builtin && ValueType == REG_SZ &&
            _wcsnicmp(ValueName, L"Priv", 4) == 0 &&
            RegQuery->PrivilegesToDelete != NULL &&
            RegQuery->DeletePrivilegeUsedCount < RegQuery->DeletePrivilegeCount)
        {
            if (LookupPrivilegeValueW(NULL,
                (LPCWSTR) ValueData,
                &RegQuery->PrivilegesToDelete[
                    RegQuery->DeletePrivilegeUsedCount].Luid) != 0)
            {
                RegQuery->PrivilegesToDelete[
                    RegQuery->DeletePrivilegeUsedCount].Attributes = 0;
                (RegQuery->DeletePrivilegeUsedCount)++;
            }
        }
        break;
    case AUTHZREGQUERY_PTR_INVERT:
        if (!RegQuery->Builtin && ValueType == REG_DWORD &&
            ValueLength == sizeof(DWORD))
        {
            RegQuery->InvertDeletePrivs =
                ( (*(PDWORD) ValueData) != 0 ? TRUE : FALSE);
        }
        break;

    //---------
    case AUTHZREGQUERY_STD_COUNT:
        if (!RegQuery->Builtin && ValueType == REG_DWORD &&
            ValueLength == sizeof(DWORD))
        {
            ASSERT(RegQuery->SidsToDisable == NULL);
            RegQuery->DisableSidCount = (*(PDWORD) ValueData);
            RegQuery->DisableSidUsedCount = 0;
            if (RegQuery->DisableSidCount > 0) {
                RegQuery->SidsToDisable =
                    (PAUTHZ_WILDCARDSID) RtlAllocateHeap(
                            RtlProcessHeap(),
                            0,
                            sizeof(AUTHZ_WILDCARDSID) *
                                RegQuery->DisableSidCount);
                if (RegQuery->SidsToDisable == NULL)
                    return STATUS_NO_MEMORY;
            }
        }
        break;
    case AUTHZREGQUERY_STD_SIDS:
        if (!RegQuery->Builtin && ValueType == REG_SZ &&
            _wcsnicmp(ValueName, L"Group", 5) == 0 &&
            RegQuery->SidsToDisable != NULL &&
            RegQuery->DisableSidUsedCount < RegQuery->DisableSidCount)
        {
            NTSTATUS Status;
            Status = CodeAuthzpConvertWildcardStringSidToSidW(
                (LPCWSTR) ValueData,
                &RegQuery->SidsToDisable[
                    RegQuery->DisableSidUsedCount]);
            if (NT_SUCCESS(Status)) {
                (RegQuery->DisableSidUsedCount)++;
            }
        }
        break;
    case AUTHZREGQUERY_STD_INVERT:
        if (!RegQuery->Builtin && ValueType == REG_DWORD &&
            ValueLength == sizeof(DWORD))
        {
            RegQuery->InvertDisableSids =
                ( (*(PDWORD) ValueData) != 0 ? TRUE : FALSE);
        }
        break;

    //---------
    case AUTHZREGQUERY_RSADD_COUNT:
        if (!RegQuery->Builtin && ValueType == REG_DWORD &&
            ValueLength == sizeof(DWORD))
        {
            ASSERT(RegQuery->RestrictedSidsAdded == NULL);
            RegQuery->RestrictedSidsAddedCount = (*(PDWORD) ValueData);
            RegQuery->RestrictedSidsAddedUsedCount = 0;
            if (RegQuery->RestrictedSidsAddedCount > 0) {
                RegQuery->RestrictedSidsAdded =
                    (PSID_AND_ATTRIBUTES) RtlAllocateHeap(
                            RtlProcessHeap(),
                            0,
                            sizeof(SID_AND_ATTRIBUTES) *
                                RegQuery->RestrictedSidsAddedCount);
                if (RegQuery->RestrictedSidsAdded == NULL)
                    return STATUS_NO_MEMORY;
            }
        }
        break;
    case AUTHZREGQUERY_RSADD_SIDS:
        if (!RegQuery->Builtin && ValueType == REG_SZ &&
            _wcsnicmp(ValueName, L"Group", 5) == 0 &&
            RegQuery->RestrictedSidsAdded != NULL &&
            RegQuery->RestrictedSidsAddedUsedCount <
                RegQuery->RestrictedSidsAddedCount)
        {
            if (ConvertStringSidToSidW(
                (LPCWSTR) ValueData,
                &RegQuery->RestrictedSidsAdded[
                    RegQuery->RestrictedSidsAddedUsedCount].Sid) != 0)
            {
                RegQuery->RestrictedSidsAdded[
                    RegQuery->RestrictedSidsAddedUsedCount].Attributes = 0;
                (RegQuery->RestrictedSidsAddedUsedCount)++;
            }
        }
        break;

    //---------
    case AUTHZREGQUERY_RSINV_COUNT:
        if (!RegQuery->Builtin && ValueType == REG_DWORD &&
            ValueLength == sizeof(DWORD))
        {
            ASSERT(RegQuery->RestrictedSidsInv == NULL);
            RegQuery->RestrictedSidsInvCount = (*(PDWORD) ValueData);
            RegQuery->RestrictedSidsInvUsedCount = 0;
            if (RegQuery->RestrictedSidsInvCount > 0) {
                RegQuery->RestrictedSidsInv =
                    (PAUTHZ_WILDCARDSID) RtlAllocateHeap(
                            RtlProcessHeap(),
                            0,
                            sizeof(AUTHZ_WILDCARDSID) *
                                RegQuery->RestrictedSidsInvCount);
                if (RegQuery->RestrictedSidsInv == NULL)
                    return STATUS_NO_MEMORY;
            }
        }
        break;
    case AUTHZREGQUERY_RSINV_SIDS:
        if (!RegQuery->Builtin && ValueType == REG_SZ &&
            _wcsnicmp(ValueName, L"Group", 5) == 0 &&
            RegQuery->RestrictedSidsInv != NULL &&
            RegQuery->RestrictedSidsInvUsedCount <
                RegQuery->RestrictedSidsInvCount)
        {
            NTSTATUS Status;
            Status = CodeAuthzpConvertWildcardStringSidToSidW(
                (LPCWSTR) ValueData,
                &RegQuery->RestrictedSidsInv[
                    RegQuery->RestrictedSidsInvUsedCount]);
            if (NT_SUCCESS(Status)) {
                (RegQuery->RestrictedSidsInvUsedCount)++;
            }
        }
        break;
    //---------
    default:
    case AUTHZREGQUERY_IGNORE:
        // ignore anything else.
        break;
    }
    return STATUS_SUCCESS;
}


VOID NTAPI
CodeAuthzLevelObjpInitializeTable(
        IN PRTL_GENERIC_TABLE  AuthzObjTable
        )
/*++

Routine Description:

    Initializes a generic table structure to prepare it for use.
    This function must be called before CodeAuthzObjpLoadTable
    is used to load data into it.

Arguments:

    AuthzObjTable = pointer to the level table being updated.

Return Value:

    Does not return a value.

--*/
{
    RtlInitializeGenericTable(
            AuthzObjTable,
            (PRTL_GENERIC_COMPARE_ROUTINE) SaferpLevelObjpTableCompare,
            (PRTL_GENERIC_ALLOCATE_ROUTINE) SaferpGenericTableAllocate,
            (PRTL_GENERIC_FREE_ROUTINE) SaferpGenericTableFree,
            NULL);
}


VOID NTAPI
SaferpLevelObjpCleanupEntry(
        IN OUT PAUTHZLEVELTABLERECORD     pAuthzObjRecord
        )
/*++

Routine Description:

    Releases allocated memory represented within a level record.
    Does not free the record itself or remove it from the
    generic table that it belongs to.

Arguments:

    pAuthzObjRecord = pointer to the level table record itself.

Return Value:

    Does not return a value.

--*/
{
    PVOID processheap = RtlProcessHeap();

    ASSERT(pAuthzObjRecord != NULL);
    if (pAuthzObjRecord->UnicodeDescription.Buffer != NULL) {
        RtlFreeUnicodeString(&pAuthzObjRecord->UnicodeDescription);
    }
    if (pAuthzObjRecord->UnicodeFriendlyName.Buffer != NULL) {
        RtlFreeUnicodeString(&pAuthzObjRecord->UnicodeFriendlyName);
    }
    if (pAuthzObjRecord->DefaultOwner != NULL) {
        LocalFree((HLOCAL) pAuthzObjRecord->DefaultOwner);
    }
    if (pAuthzObjRecord->SidsToDisable != NULL) {
        DWORD Index;
        for (Index = 0; Index < pAuthzObjRecord->DisableSidUsedCount; Index++) {
            LocalFree((HLOCAL) pAuthzObjRecord->SidsToDisable[Index].Sid);
        }
        RtlFreeHeap(processheap, 0, (LPVOID) pAuthzObjRecord->SidsToDisable);
    }
    if (pAuthzObjRecord->PrivilegesToDelete != NULL) {
        RtlFreeHeap(processheap, 0, (LPVOID) pAuthzObjRecord->PrivilegesToDelete);
    }
    if (pAuthzObjRecord->RestrictedSidsAdded != NULL) {
        DWORD Index;
        for (Index = 0; Index < pAuthzObjRecord->RestrictedSidsAddedUsedCount; Index++) {
            LocalFree((HLOCAL) pAuthzObjRecord->RestrictedSidsAdded[Index].Sid);
        }
        RtlFreeHeap(processheap, 0, (LPVOID) pAuthzObjRecord->RestrictedSidsAdded);
    }
    if (pAuthzObjRecord->RestrictedSidsInv != NULL) {
        DWORD Index;
        for (Index = 0; Index < pAuthzObjRecord->RestrictedSidsInvUsedCount; Index++) {
            LocalFree((HLOCAL) pAuthzObjRecord->RestrictedSidsInv[Index].Sid);
        }
        RtlFreeHeap(processheap, 0, (LPVOID) pAuthzObjRecord->RestrictedSidsInv);
    }
    RtlZeroMemory(pAuthzObjRecord, sizeof(AUTHZLEVELTABLERECORD));
}



BOOL NTAPI
SaferpLoadUnicodeResourceString(
        IN HANDLE               hModule,
        IN UINT                 wID,
        OUT PUNICODE_STRING     pUnicodeString,
        IN WORD                 wLangId
    )
/*++

Routine Description:

    We roll our own instead of using LoadStringW() directly, because it
    depends on user32.dll and would introduce a new dll dependency,
    whereas this implementation only requires kernel32.dll imports.

Arguments:

    hModule - handle the module to load the resource from.

    wID - Resource ID to load.

    pUnicodeString - output buffer to receive the loaded string.  This
        string must be freed with RtlFreeUnicodeString().

    wLangId - language identifier to load.  To simply use the current
        thread locale, you may specify the value:
                MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL)

Return Value:

    Returns FALSE on error, otherwise success.

--*/
{
    NTSTATUS Status;
    UNICODE_STRING UnicodeOrig;
    HANDLE hResInfo;
    HANDLE hStringSeg;
    LPWSTR lpsz;
    int    cch;

    hResInfo = FindResourceExW(
                    hModule,
                    MAKEINTRESOURCEW(6), /* RT_STRING */
                    (LPWSTR)((LONG_PTR)(((USHORT)wID >> 4) + 1)),
                    wLangId );
    if (hResInfo) {

        /*
         * Load that segment.
         */
        hStringSeg = LoadResource(hModule, hResInfo);
        if (hStringSeg == NULL) {
            return 0;
        }

        lpsz = (LPWSTR) (hStringSeg);

        /*
         * Move past the other strings in this segment.
         * (16 strings in a segment -> & 0x0F)
         */
        wID &= 0x0F;
        for (;;) {
            cch = *((WCHAR *)lpsz++);       // PASCAL like string count
                                            // first UTCHAR is count if TCHARs
            if (wID-- == 0) break;
            lpsz += cch;                    // Step to start if next string
        }

        /*
         * Create the UNICODE_STRING version of the string based
         * off of the pointer to the read-only resource buffer.
         */
        UnicodeOrig.Buffer = (WCHAR *)lpsz;
        UnicodeOrig.Length = UnicodeOrig.MaximumLength =
                (USHORT) (cch * sizeof(WCHAR));


        /*
         * Allocate memory for the new copy, and pass that back.
         */
        Status = RtlDuplicateUnicodeString(
                        RTL_DUPLICATE_UNICODE_STRING_NULL_TERMINATE,
                        &UnicodeOrig, pUnicodeString);
        if (NT_SUCCESS(Status)) {
            return 1;
        }
    }
    return 0;
}




NTSTATUS NTAPI
SaferpEnforceDefaultLevelDefinitions(
        IN OUT PAUTHZLEVELTABLERECORD pAuthzObjTableRec
        )
/*++

Routine Description:

    Fills a level record structure with the built-in definitions of
    the 5 WinSafer level definitions.

Arguments:

    pAuthzObjTableRec - pointer to the level record to initialize.
        The dwLevelId member of the record must be initialized.  The
        rest of the structure is expected to be NULL.

Return Value:

    Returns STATUS_SUCCESS on success, otherwise error.

--*/
{
    NTSTATUS Status;
    const static SID_IDENTIFIER_AUTHORITY SIDAuth = SECURITY_NT_AUTHORITY;
    const static SID_IDENTIFIER_AUTHORITY WorldAuth = SECURITY_WORLD_SID_AUTHORITY;
    UINT uResourceID;
    HANDLE hAdvApiInst;


    if (!ARGUMENT_PRESENT(pAuthzObjTableRec)) {
        Status = STATUS_INVALID_PARAMETER;
        goto ExitHandler;
    }
    if (pAuthzObjTableRec->dwLevelId != SAFER_LEVELID_FULLYTRUSTED &&
         pAuthzObjTableRec->dwLevelId != SAFER_LEVELID_NORMALUSER &&
         pAuthzObjTableRec->dwLevelId != SAFER_LEVELID_CONSTRAINED &&
         pAuthzObjTableRec->dwLevelId != SAFER_LEVELID_UNTRUSTED &&
         pAuthzObjTableRec->dwLevelId != SAFER_LEVELID_DISALLOWED) {
        Status = STATUS_NOT_IMPLEMENTED;
        goto ExitHandler;
    }

    switch (pAuthzObjTableRec->dwLevelId)
    {
        case SAFER_LEVELID_DISALLOWED:
            uResourceID = CODEAUTHZ_RC_LEVELNAME_DISALLOWED;
            pAuthzObjTableRec->DisallowExecution = TRUE;
            break;

        // -----------------------

        case SAFER_LEVELID_UNTRUSTED:
            uResourceID = CODEAUTHZ_RC_LEVELNAME_UNTRUSTED;
            pAuthzObjTableRec->DisallowExecution = FALSE;
            ASSERT(pAuthzObjTableRec->DefaultOwner == NULL);
            Status = RtlAllocateAndInitializeSid(
                        (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 1,
                        SECURITY_PRINCIPAL_SELF_RID,
                        0, 0, 0, 0, 0, 0, 0,
                        &pAuthzObjTableRec->DefaultOwner);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            pAuthzObjTableRec->SaferFlags = SAFER_POLICY_JOBID_UNTRUSTED;

            // Privileges.
            pAuthzObjTableRec->DisableMaxPrivileges = TRUE;
            pAuthzObjTableRec->DeletePrivilegeUsedCount = 0;
            pAuthzObjTableRec->InvertDeletePrivs = FALSE;

            // Sids to restrict.
            ASSERT(pAuthzObjTableRec->RestrictedSidsAdded == NULL);
            pAuthzObjTableRec->RestrictedSidsAddedCount =
                pAuthzObjTableRec->RestrictedSidsAddedUsedCount = 5;
            pAuthzObjTableRec->RestrictedSidsAdded =
                (PSID_AND_ATTRIBUTES) RtlAllocateHeap(
                    RtlProcessHeap(), 0, 5 * sizeof(SID_AND_ATTRIBUTES));
            if (!pAuthzObjTableRec->RestrictedSidsAdded) {
                Status = STATUS_NO_MEMORY;
                goto ExitHandler;
            }
            RtlZeroMemory(pAuthzObjTableRec->RestrictedSidsAdded,
                          5 * sizeof(SID_AND_ATTRIBUTES));
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 1,
                    SECURITY_RESTRICTED_CODE_RID,
                    0, 0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->RestrictedSidsAdded[0].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &WorldAuth, 1,
                    SECURITY_WORLD_RID,
                    0, 0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->RestrictedSidsAdded[1].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 1,
                    SECURITY_INTERACTIVE_RID,
                    0, 0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->RestrictedSidsAdded[2].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 1,
                    SECURITY_AUTHENTICATED_USER_RID,
                    0, 0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->RestrictedSidsAdded[3].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 2,
                    SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_USERS,
                    0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->RestrictedSidsAdded[4].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            pAuthzObjTableRec->RestrictedSidsInvUsedCount = 0;

            // Sids to disable.
            pAuthzObjTableRec->DisableSidCount =
                pAuthzObjTableRec->DisableSidUsedCount = 5;
            ASSERT(pAuthzObjTableRec->SidsToDisable == NULL);
            pAuthzObjTableRec->SidsToDisable =
                (PAUTHZ_WILDCARDSID) RtlAllocateHeap(
                    RtlProcessHeap(), 0, 5 * sizeof(AUTHZ_WILDCARDSID));
            if (!pAuthzObjTableRec->SidsToDisable) {
                Status = STATUS_NO_MEMORY;
                goto ExitHandler;
            }
            RtlZeroMemory(pAuthzObjTableRec->SidsToDisable,
                          5 * sizeof(AUTHZ_WILDCARDSID));
            pAuthzObjTableRec->SidsToDisable[0].WildcardPos = -1;
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &WorldAuth, 1,
                    SECURITY_WORLD_RID,
                    0, 0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->SidsToDisable[0].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            pAuthzObjTableRec->SidsToDisable[1].WildcardPos = -1;
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 1,
                    SECURITY_INTERACTIVE_RID,
                    0, 0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->SidsToDisable[1].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            pAuthzObjTableRec->SidsToDisable[2].WildcardPos = -1;
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 1,
                    SECURITY_PRINCIPAL_SELF_RID,
                    0, 0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->SidsToDisable[2].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            pAuthzObjTableRec->SidsToDisable[3].WildcardPos = -1;
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 1,
                    SECURITY_AUTHENTICATED_USER_RID,
                    0, 0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->SidsToDisable[3].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            pAuthzObjTableRec->SidsToDisable[4].WildcardPos = -1;
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 2,
                    SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_USERS,
                    0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->SidsToDisable[4].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            pAuthzObjTableRec->InvertDisableSids = TRUE;
            break;

        // -----------------------

        case SAFER_LEVELID_CONSTRAINED:
            uResourceID = CODEAUTHZ_RC_LEVELNAME_CONSTRAINED;
            pAuthzObjTableRec->DisallowExecution = FALSE;
            ASSERT(pAuthzObjTableRec->DefaultOwner == NULL);
            Status = RtlAllocateAndInitializeSid(
                        (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 1,
                        SECURITY_PRINCIPAL_SELF_RID,
                        0, 0, 0, 0, 0, 0, 0,
                        &pAuthzObjTableRec->DefaultOwner);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            pAuthzObjTableRec->SaferFlags = SAFER_POLICY_JOBID_CONSTRAINED;

            // Privileges.
            pAuthzObjTableRec->DisableMaxPrivileges = TRUE;
            pAuthzObjTableRec->DeletePrivilegeUsedCount = 0;
            pAuthzObjTableRec->InvertDeletePrivs = FALSE;

            // Sids to restrict (added).
            ASSERT(pAuthzObjTableRec->RestrictedSidsAdded == NULL);
            pAuthzObjTableRec->RestrictedSidsAddedCount =
                pAuthzObjTableRec->RestrictedSidsAddedUsedCount = 1;
            pAuthzObjTableRec->RestrictedSidsAdded =
                (PSID_AND_ATTRIBUTES) RtlAllocateHeap(
                    RtlProcessHeap(), 0, 1 * sizeof(SID_AND_ATTRIBUTES));
            if (!pAuthzObjTableRec->RestrictedSidsAdded) {
                Status = STATUS_NO_MEMORY;
                goto ExitHandler;
            }
            RtlZeroMemory(pAuthzObjTableRec->RestrictedSidsAdded,
                          1 * sizeof(SID_AND_ATTRIBUTES));
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 1,
                    SECURITY_RESTRICTED_CODE_RID,
                    0, 0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->RestrictedSidsAdded[0].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }

            // Sids to restrict (inverted).
            ASSERT(pAuthzObjTableRec->RestrictedSidsInv == NULL);
            pAuthzObjTableRec->RestrictedSidsInvCount =
                pAuthzObjTableRec->RestrictedSidsInvUsedCount = 8;
            pAuthzObjTableRec->RestrictedSidsInv =
                (PAUTHZ_WILDCARDSID) RtlAllocateHeap(
                    RtlProcessHeap(), 0, 8 * sizeof(AUTHZ_WILDCARDSID));
            if (!pAuthzObjTableRec->RestrictedSidsInv) {
                Status = STATUS_NO_MEMORY;
                goto ExitHandler;
            }
            RtlZeroMemory(pAuthzObjTableRec->RestrictedSidsInv,
                          8 * sizeof(AUTHZ_WILDCARDSID));
            pAuthzObjTableRec->RestrictedSidsInv[0].WildcardPos = -1;   // exact!
            Status = RtlAllocateAndInitializeSid(
                        (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 1,
                        SECURITY_PRINCIPAL_SELF_RID,
                        0, 0, 0, 0, 0, 0, 0,
                        &pAuthzObjTableRec->RestrictedSidsInv[0].Sid);
            pAuthzObjTableRec->RestrictedSidsInv[1].WildcardPos = -1;   // exact!
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 2,
                    SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
                    0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->RestrictedSidsInv[1].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            pAuthzObjTableRec->RestrictedSidsInv[2].WildcardPos = -1;   // exact!
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 2,
                    SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_POWER_USERS,
                    0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->RestrictedSidsInv[2].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            pAuthzObjTableRec->RestrictedSidsInv[3].WildcardPos = 1;    // wildcard!
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 2,
                    SECURITY_NT_NON_UNIQUE, DOMAIN_GROUP_RID_ADMINS,
                    0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->RestrictedSidsInv[3].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            pAuthzObjTableRec->RestrictedSidsInv[4].WildcardPos = 1;    // wildcard!
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 2,
                    SECURITY_NT_NON_UNIQUE, DOMAIN_GROUP_RID_CERT_ADMINS,
                    0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->RestrictedSidsInv[4].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            pAuthzObjTableRec->RestrictedSidsInv[5].WildcardPos = 1;    // wildcard!
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 2,
                    SECURITY_NT_NON_UNIQUE, DOMAIN_GROUP_RID_SCHEMA_ADMINS,
                    0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->RestrictedSidsInv[5].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            pAuthzObjTableRec->RestrictedSidsInv[6].WildcardPos = 1;    // wildcard!
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 2,
                    SECURITY_NT_NON_UNIQUE, DOMAIN_GROUP_RID_ENTERPRISE_ADMINS,
                    0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->RestrictedSidsInv[6].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            pAuthzObjTableRec->RestrictedSidsInv[7].WildcardPos = 1;    // wildcard!
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 2,
                    SECURITY_NT_NON_UNIQUE, DOMAIN_GROUP_RID_POLICY_ADMINS,
                    0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->RestrictedSidsInv[7].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }

            // Sids to disable.
            pAuthzObjTableRec->DisableSidCount =
                pAuthzObjTableRec->DisableSidUsedCount = 7;
            ASSERT(pAuthzObjTableRec->SidsToDisable == NULL);
            pAuthzObjTableRec->SidsToDisable =
                (PAUTHZ_WILDCARDSID) RtlAllocateHeap(
                    RtlProcessHeap(), 0, 7 * sizeof(AUTHZ_WILDCARDSID));
            if (!pAuthzObjTableRec->SidsToDisable) {
                Status = STATUS_NO_MEMORY;
                goto ExitHandler;
            }
            RtlZeroMemory(pAuthzObjTableRec->SidsToDisable,
                          7 * sizeof(AUTHZ_WILDCARDSID));
            pAuthzObjTableRec->SidsToDisable[0].WildcardPos = -1;   // exact!
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 2,
                    SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
                    0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->SidsToDisable[0].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            pAuthzObjTableRec->SidsToDisable[1].WildcardPos = -1;   // exact!
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 2,
                    SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_POWER_USERS,
                    0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->SidsToDisable[1].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            pAuthzObjTableRec->SidsToDisable[2].WildcardPos = 1;    // wildcard!
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 2,
                    SECURITY_NT_NON_UNIQUE, DOMAIN_GROUP_RID_ADMINS,
                    0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->SidsToDisable[2].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            pAuthzObjTableRec->SidsToDisable[3].WildcardPos = 1;    // wildcard!
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 2,
                    SECURITY_NT_NON_UNIQUE, DOMAIN_GROUP_RID_CERT_ADMINS,
                    0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->SidsToDisable[3].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            pAuthzObjTableRec->SidsToDisable[4].WildcardPos = 1;    // wildcard!
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 2,
                    SECURITY_NT_NON_UNIQUE, DOMAIN_GROUP_RID_SCHEMA_ADMINS,
                    0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->SidsToDisable[4].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            pAuthzObjTableRec->SidsToDisable[5].WildcardPos = 1;    // wildcard!
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 2,
                    SECURITY_NT_NON_UNIQUE, DOMAIN_GROUP_RID_ENTERPRISE_ADMINS,
                    0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->SidsToDisable[5].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            pAuthzObjTableRec->SidsToDisable[6].WildcardPos = 1;    // wildcard!
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 2,
                    SECURITY_NT_NON_UNIQUE, DOMAIN_GROUP_RID_POLICY_ADMINS,
                    0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->SidsToDisable[6].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            pAuthzObjTableRec->InvertDisableSids = FALSE;
            break;

        // -----------------------

        case SAFER_LEVELID_NORMALUSER:
            uResourceID = CODEAUTHZ_RC_LEVELNAME_NORMALUSER;
            pAuthzObjTableRec->DisallowExecution = FALSE;
            ASSERT(pAuthzObjTableRec->DefaultOwner == NULL);
            Status = RtlAllocateAndInitializeSid(
                        (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 1,
                        SECURITY_PRINCIPAL_SELF_RID,
                        0, 0, 0, 0, 0, 0, 0,
                        &pAuthzObjTableRec->DefaultOwner);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            pAuthzObjTableRec->SaferFlags = 0;

            // Privileges
            pAuthzObjTableRec->DisableMaxPrivileges = TRUE;
            pAuthzObjTableRec->DeletePrivilegeUsedCount = 0;
            pAuthzObjTableRec->InvertDeletePrivs = FALSE;

            // Sids to restrict.
            pAuthzObjTableRec->RestrictedSidsAddedUsedCount =
                pAuthzObjTableRec->RestrictedSidsInvUsedCount = 0;

            // Sids to disable.
            pAuthzObjTableRec->DisableSidCount =
                pAuthzObjTableRec->DisableSidUsedCount = 7;
            ASSERT(pAuthzObjTableRec->SidsToDisable == NULL);
            pAuthzObjTableRec->SidsToDisable =
                (PAUTHZ_WILDCARDSID) RtlAllocateHeap(
                    RtlProcessHeap(), 0, 7 * sizeof(AUTHZ_WILDCARDSID));
            if (!pAuthzObjTableRec->SidsToDisable) {
                Status = STATUS_NO_MEMORY;
                goto ExitHandler;
            }
            RtlZeroMemory(pAuthzObjTableRec->SidsToDisable,
                          7 * sizeof(AUTHZ_WILDCARDSID));
            pAuthzObjTableRec->SidsToDisable[0].WildcardPos = -1;   // exact!
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 2,
                    SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
                    0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->SidsToDisable[0].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            pAuthzObjTableRec->SidsToDisable[1].WildcardPos = -1;   // exact!
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 2,
                    SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_POWER_USERS,
                    0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->SidsToDisable[1].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            pAuthzObjTableRec->SidsToDisable[2].WildcardPos = 1;    // wildcard!
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 2,
                    SECURITY_NT_NON_UNIQUE, DOMAIN_GROUP_RID_ADMINS,
                    0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->SidsToDisable[2].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            pAuthzObjTableRec->SidsToDisable[3].WildcardPos = 1;    // wildcard!
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 2,
                    SECURITY_NT_NON_UNIQUE, DOMAIN_GROUP_RID_CERT_ADMINS,
                    0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->SidsToDisable[3].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            pAuthzObjTableRec->SidsToDisable[4].WildcardPos = 1;    // wildcard!
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 2,
                    SECURITY_NT_NON_UNIQUE, DOMAIN_GROUP_RID_SCHEMA_ADMINS,
                    0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->SidsToDisable[4].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            pAuthzObjTableRec->SidsToDisable[5].WildcardPos = 1;    // wildcard!
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 2,
                    SECURITY_NT_NON_UNIQUE, DOMAIN_GROUP_RID_ENTERPRISE_ADMINS,
                    0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->SidsToDisable[5].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            pAuthzObjTableRec->SidsToDisable[6].WildcardPos = 1;    // wildcard!
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 2,
                    SECURITY_NT_NON_UNIQUE, DOMAIN_GROUP_RID_POLICY_ADMINS,
                    0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->SidsToDisable[6].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            pAuthzObjTableRec->InvertDisableSids = FALSE;
            break;

        // -----------------------

        case SAFER_LEVELID_FULLYTRUSTED:
            uResourceID = CODEAUTHZ_RC_LEVELNAME_FULLYTRUSTED;
            pAuthzObjTableRec->DisallowExecution = FALSE;
            ASSERT(pAuthzObjTableRec->DefaultOwner == NULL);
            pAuthzObjTableRec->DisableMaxPrivileges = FALSE;
            pAuthzObjTableRec->SaferFlags = 0;
            pAuthzObjTableRec->DeletePrivilegeUsedCount =
                pAuthzObjTableRec->DisableSidUsedCount =
                pAuthzObjTableRec->RestrictedSidsAddedUsedCount =
                pAuthzObjTableRec->RestrictedSidsInvUsedCount = 0;
            pAuthzObjTableRec->InvertDeletePrivs =
                pAuthzObjTableRec->InvertDisableSids = FALSE;
            break;

        // -----------------------

        default:
            // should not happen.
            Status = STATUS_UNSUCCESSFUL;
            goto ExitHandler;
    }


    //
    // Load the resource descriptions and friendly names.
    //
    hAdvApiInst = (HANDLE) GetModuleHandleW(L"advapi32");
    if (hAdvApiInst != NULL)
    {
        // load the friendly name.
        SaferpLoadUnicodeResourceString(
                    hAdvApiInst,
                    (UINT) (uResourceID + 0),
                    &pAuthzObjTableRec->UnicodeFriendlyName,
                    MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL));

        // load the description.
        SaferpLoadUnicodeResourceString(
                    hAdvApiInst,
                    (UINT) (uResourceID + 1),
                    &pAuthzObjTableRec->UnicodeDescription,
                    MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL));
    }

    Status = STATUS_SUCCESS;


ExitHandler:
    return Status;
}

DWORD
SaferpEnumerateHiddenLevels(VOID)

/*++

Routine Description:
    Reads which hidden levels should be enumerated.

Arguments:

Return Value:

    Returns DWORD.

--*/
{
    NTSTATUS Status;
    UCHAR QueryBuffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + MAX_PATH * sizeof(WCHAR)];
    PKEY_VALUE_PARTIAL_INFORMATION pKeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION) QueryBuffer;
    DWORD dwActualSize = 0;
    HKEY hKey = NULL;

    const static UNICODE_STRING SaferUnicodeKeyName = RTL_CONSTANT_STRING(L"\\Registry\\Machine\\Software\\Policies\\Microsoft\\Windows\\Safer\\CodeIdentifiers");
    const static OBJECT_ATTRIBUTES SaferObjectAttributes = RTL_CONSTANT_OBJECT_ATTRIBUTES(&SaferUnicodeKeyName, OBJ_CASE_INSENSITIVE);
    const static UNICODE_STRING SaferHiddenLevels = RTL_CONSTANT_STRING(SAFER_HIDDEN_LEVELS);


    // Open the CodeIdentifiers key.
    Status = NtOpenKey(
                 &hKey, 
                 KEY_QUERY_VALUE,
                 (POBJECT_ATTRIBUTES) &SaferObjectAttributes
                 );
    
    if (!NT_SUCCESS(Status)) {
        return 0;
    }
    
    Status = NtQueryValueKey(
                 hKey,
                 (PUNICODE_STRING) &SaferHiddenLevels,
                 KeyValuePartialInformation,
                 pKeyValueInfo, 
                 sizeof(QueryBuffer), 
                 &dwActualSize
                 );
    
    NtClose(hKey);

    if (!NT_SUCCESS(Status)) {
        return 0;
    }
    
    if (pKeyValueInfo->Type == REG_DWORD &&
        pKeyValueInfo->DataLength == sizeof(DWORD)) {
        return *((PDWORD) pKeyValueInfo->Data);
    }

    return 0;
}


NTSTATUS NTAPI
CodeAuthzLevelObjpLoadTable (
        IN OUT PRTL_GENERIC_TABLE   pAuthzObjTable,
        IN DWORD                    dwScopeId,
        IN HANDLE                   hKeyCustomRoot
        )
/*++

Routine Description:

    Pre-loads our table with a record for each Authorization Level
    encountered in the registry.  Each record in the table contains
    the LevelId, registry handle, and all restricted token attributes
    that will be needed to later compute the restricted token.

Arguments:

    AuthzObjTable = pointer to the level table being updated.  Must have
        already been initialized with CodeAuthzLevelObjpInitializeTable.


Return Value:

    Returns FALSE on error, otherwise success.

--*/
{
    DWORD dwIndex;
    NTSTATUS Status = STATUS_SUCCESS;
    HANDLE hKeyLevelObjects;
    DWORD LocalValue = 0;
    OBJECT_ATTRIBUTES ObjectAttributes;


    //
    // Open a handle to the appropriate section of the registry where
    // the Level definitions are stored.  Generally they will come only
    // from the AUTHZSCOPEID_MACHINE scope, but we allow it to be
    // specified as an argument for the group policy editing case.
    //
    Status = CodeAuthzpOpenPolicyRootKey(
                    dwScopeId,
                    hKeyCustomRoot,
                    SAFER_OBJECTS_REGSUBKEY,
                    KEY_READ,
                    FALSE,
                    &hKeyLevelObjects);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler;
    }


    //
    // Iterate through all subkeys under this branch.
    //
    for (dwIndex = 0; ; dwIndex++)
    {
        DWORD dwLength, dwLevelId;
        HANDLE hKeyThisLevelObject;
        AUTHZLEVELTABLERECORD AuthzObjTableRec;
        UNICODE_STRING UnicodeKeyname;
        BYTE RawQueryBuffer[sizeof(KEY_BASIC_INFORMATION) + 256];
        PKEY_BASIC_INFORMATION pBasicInformation =
                (PKEY_BASIC_INFORMATION) &RawQueryBuffer[0];


        //
        // Find the next Level that we will check.
        //
        Status = NtEnumerateKey(hKeyLevelObjects,
                                dwIndex,
                                KeyBasicInformation,
                                pBasicInformation,
                                sizeof(RawQueryBuffer),
                                &dwLength);
        if (!NT_SUCCESS(Status)) {
            break;
        }
        UnicodeKeyname.Buffer = pBasicInformation->Name;
        UnicodeKeyname.MaximumLength = UnicodeKeyname.Length =
                (USHORT) pBasicInformation->NameLength;
        // Note that UnicodeKeyname.Buffer is not necessarily null terminated.
        ASSERT(UnicodeKeyname.Length <= wcslen(UnicodeKeyname.Buffer) * sizeof(WCHAR));


        //
        // Translate the keyname (which we expect to be
        // purely numeric) into the integer LevelId value.
        //
        Status = RtlUnicodeStringToInteger(
                    &UnicodeKeyname, 10, &dwLevelId);
        if (!NT_SUCCESS(Status)) {
            // the keyname was apparently not numeric.
            continue;
        }


        //
        // Try to open a handle to that Level for read-only access.
        //
        InitializeObjectAttributes(&ObjectAttributes,
              &UnicodeKeyname,
              OBJ_CASE_INSENSITIVE,
              hKeyLevelObjects,
              NULL
              );
        Status = NtOpenKey(&hKeyThisLevelObject,
                           KEY_READ,
                           &ObjectAttributes);
        if (!NT_SUCCESS(Status)) {
            // If we failed to open it, skip to the next one.
            continue;
        }


        //
        // Fill in the well-known portions of the record structure.
        //
        RtlZeroMemory(&AuthzObjTableRec, sizeof(AuthzObjTableRec));
        AuthzObjTableRec.dwLevelId = dwLevelId;
        AuthzObjTableRec.Builtin =
            (dwLevelId == SAFER_LEVELID_FULLYTRUSTED ||
             dwLevelId == SAFER_LEVELID_NORMALUSER ||
             dwLevelId == SAFER_LEVELID_CONSTRAINED ||
             dwLevelId == SAFER_LEVELID_UNTRUSTED ||
             dwLevelId == SAFER_LEVELID_DISALLOWED) ? TRUE : FALSE;

		AuthzObjTableRec.isEnumerable = TRUE;  //always allow enumeration of entries defined in the registry.

        //
        // Read all of the restricted token attributes from the registry.
        // Note that for Builtin Levels, we use a different query table
        // that only attempts to read a reduced set of attributes from
        // the registry, since we'd ignore most of them anyways.
        //
        if (!AuthzObjTableRec.Builtin) {
            Status = RtlQueryRegistryValues(
                    RTL_REGISTRY_HANDLE,
                    (PCWSTR) hKeyThisLevelObject,
                    CodeAuthzpBuildRestrictedTokenTable,
                    &AuthzObjTableRec,
                    NULL
                    );
            // (We don't actually look at the Status code, since it
            // is acceptable for some values or subkeys to have not
            // been specified.)
        }


        //
        // If this is a built-in Level, then enforce the other expected attributes.
        //
        if (AuthzObjTableRec.Builtin) {
            Status = SaferpEnforceDefaultLevelDefinitions(
                            &AuthzObjTableRec);
            if (!NT_SUCCESS(Status)) {
                SaferpLevelObjpCleanupEntry(&AuthzObjTableRec);
                NtClose(hKeyThisLevelObject);
                continue;
            }
        }


        //
        // Add the new record into our table.
        //
        if (RtlLookupElementGenericTable(pAuthzObjTable,
                       (PVOID) &AuthzObjTableRec) == NULL)
        {
            // Only insert the record if we don't have any other
            // entries with this same LevelId combination.
            RtlInsertElementGenericTable(
                    pAuthzObjTable,
                    (PVOID) &AuthzObjTableRec,
                    sizeof(AUTHZLEVELTABLERECORD),
                    NULL);
        } else {
            // Otherwise something with this same LevelId already existed.
            // (like level names "01" and "1" being numerically the same).
            SaferpLevelObjpCleanupEntry(&AuthzObjTableRec);
        }
        NtClose(hKeyThisLevelObject);
    }
    NtClose(hKeyLevelObjects);


    //
    // Look through and verify that all of the default Levels were
    // actually loaded.  If they were not, then try to add them.
    //
ExitHandler:

    LocalValue = SaferpEnumerateHiddenLevels();

    for (dwIndex = 0; dwIndex < 5; dwIndex++)
    {
        const DWORD dwBuiltinLevels[5][2] = {
            {SAFER_LEVELID_DISALLOWED, TRUE},        // true = always create
            {SAFER_LEVELID_UNTRUSTED, FALSE},
            {SAFER_LEVELID_CONSTRAINED, FALSE},
            {SAFER_LEVELID_NORMALUSER, FALSE},
            {SAFER_LEVELID_FULLYTRUSTED, TRUE}       // true = always create
        };
        DWORD dwLevelId = dwBuiltinLevels[dwIndex][0];


        if ( !CodeAuthzLevelObjpLookupByLevelId (
                    pAuthzObjTable, dwLevelId))
        {
            AUTHZLEVELTABLERECORD AuthzObjTableRec;

            RtlZeroMemory(&AuthzObjTableRec, sizeof(AuthzObjTableRec));
            AuthzObjTableRec.dwLevelId = dwLevelId;
            AuthzObjTableRec.Builtin = TRUE;
            AuthzObjTableRec.isEnumerable =(BOOLEAN)(dwBuiltinLevels[dwIndex][1]) ;  //conditionally show this level

            // If the registry key specifies that the level should be shown
            // mark it as enumerable.
            if ((LocalValue & dwLevelId) == dwLevelId) {
                AuthzObjTableRec.isEnumerable = TRUE;
            }

            if (NT_SUCCESS(
                    SaferpEnforceDefaultLevelDefinitions(
                            &AuthzObjTableRec)))
            {
                RtlInsertElementGenericTable(
                        pAuthzObjTable,
                        (PVOID) &AuthzObjTableRec,
                        sizeof(AUTHZLEVELTABLERECORD),
                        NULL);
            } else {
                SaferpLevelObjpCleanupEntry(&AuthzObjTableRec);
            }
        }
    }

    return Status;
}





VOID NTAPI
CodeAuthzLevelObjpEntireTableFree (
        IN PRTL_GENERIC_TABLE   pAuthzObjTable
        )
/*++

Routine Description:

    This function frees all entries contained within a GENERIC_TABLE.

Arguments:

    AuthzObjTable   - pointer to the Generic Table structure

Return Value:

    None.

--*/
{
    ULONG NumElements;
    PVOID RestartKey;
    PAUTHZLEVELTABLERECORD pAuthzObjRecord;


    //
    // Enumerate through all records and close the registry handles.
    //
    RestartKey = NULL;
    for (pAuthzObjRecord = (PAUTHZLEVELTABLERECORD)
            RtlEnumerateGenericTableWithoutSplaying(
                    pAuthzObjTable, &RestartKey);
         pAuthzObjRecord != NULL;
         pAuthzObjRecord = (PAUTHZLEVELTABLERECORD)
            RtlEnumerateGenericTableWithoutSplaying(
                    pAuthzObjTable, &RestartKey)
         )
    {
        SaferpLevelObjpCleanupEntry(pAuthzObjRecord);
    }



    //
    // Now iterate through the table again and free all of the
    // elements themselves.
    //
    NumElements = RtlNumberGenericTableElements(pAuthzObjTable);

    while ( NumElements-- > 0 ) {
        // Delete all elements.  Note that we pass NULL as the element
        // to delete because our compare function is smart enough to
        // allow treatment of NULL as a wildcard element.
        BOOL retval = RtlDeleteElementGenericTable( pAuthzObjTable, NULL);
        ASSERT(retval == TRUE);
    }
}


PAUTHZLEVELTABLERECORD NTAPI
CodeAuthzLevelObjpLookupByLevelId (
        IN PRTL_GENERIC_TABLE      AuthzObjTable,
        IN DWORD                   dwLevelId
        )
/*++

Routine Description:

    This function searches for a given Level within a GENERIC_TABLE.

Arguments:

    AuthzObjTable   - pointer to the Generic Table structure

    dwLevelId       - the DWORD Level identifier to search for.

Return Value:

    On success, returns a pointer to the matching level record
    if it was found within the table, otherwise returns NULL.

--*/
{
    AUTHZLEVELTABLERECORD AuthzObjTableRec;

    RtlZeroMemory(&AuthzObjTableRec, sizeof(AUTHZLEVELTABLERECORD));
    AuthzObjTableRec.dwLevelId = dwLevelId;

    return (PAUTHZLEVELTABLERECORD)
        RtlLookupElementGenericTable(AuthzObjTable,
                     (PVOID) &AuthzObjTableRec);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\winsafer\safeinit.c ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    SafeInit.c        (WinSAFER Initialization)

Abstract:

    This module implements the WinSAFER APIs to initialize and
    deinitialize all housekeeping and handle tracking structures.

Author:

    Jeffrey Lawson (JLawson) - Nov 1999

Environment:

    User mode only.

Exported Functions:

    CodeAuthzInitialize                     (privately exported)
    SaferiChangeRegistryScope            (privately exported)

Revision History:

    Created - Nov 1999

--*/

#include "pch.h"
#pragma hdrstop
#include <winsafer.h>
#include <winsaferp.h>
#include <winsafer.rh>
#include "saferp.h" 
 

//#define SAFER_REGISTRY_NOTIFICATIONS


//
// Controls the maximum number of level handles that we will
// permit to be opened at any time.
//
#define MAXIMUM_LEVEL_HANDLES 64



//
// Various globals that are used for the cache of levels and
// identities so that we do not need to go to the registry each time.
//
BOOLEAN g_bInitializedFirstTime = FALSE;

CRITICAL_SECTION g_TableCritSec;
HANDLE g_hKeyCustomRoot;
DWORD g_dwKeyOptions;

DWORD g_dwLevelHandleSequence = 1;          // monotonically increasing


//
// All of the following global variables are cached settings that are
// read and parsed from the policy the first time it is needed.
// All of the variables within this block should be considered "stale"
// when the g_bNeedCacheReload flag is TRUE.
//
BOOLEAN g_bNeedCacheReload;         // indicates the following vars are stale.

RTL_GENERIC_TABLE g_CodeLevelObjTable;
RTL_GENERIC_TABLE g_CodeIdentitiesTable;
RTL_HANDLE_TABLE g_LevelHandleTable;

BOOLEAN g_bHonorScopeUser;

PAUTHZLEVELTABLERECORD g_DefaultCodeLevel;        // effective
PAUTHZLEVELTABLERECORD g_DefaultCodeLevelUser;
PAUTHZLEVELTABLERECORD g_DefaultCodeLevelMachine;


//
// Handles used to receive registry change notifications against the
// currently loaded policy and invalidate the internal cache.
//
#ifdef SAFER_REGISTRY_NOTIFICATIONS
HANDLE g_hRegNotifyEvent;           // from CreateEvent
HANDLE g_hWaitNotifyObject;         // from RegisterWaitForSingleObject
HANDLE g_hKeyNotifyBase1, g_hKeyNotifyBase2;
#endif



NTSTATUS NTAPI
SaferpSetSingleIdentificationPath(
        IN BOOLEAN bAllowCreation,
        IN OUT PAUTHZIDENTSTABLERECORD pIdentRecord,
        IN PSAFER_PATHNAME_IDENTIFICATION pIdentChanges,
        IN BOOL UpdateCache
        );


FORCEINLINE BOOLEAN
CodeAuthzpIsPowerOfTwo(
        ULONG ulValue
        )
/*++

Routine Description:

    Determines if the specified value is a whole power of 2.
    (ie, exactly one of the following: 1, 2, 4, 8, 16, 32, 64, ...)

Arguments:

    ulValue - Integer value to test.

Return Value:

    Returns TRUE on success, FALSE on failure.

--*/
{
    while (ulValue != 0) {
        if (ulValue & 1) {
            ulValue >>= 1;
            break;
        }
        ulValue >>= 1;
    }
    return (ulValue == 0);
}


FORCEINLINE ULONG
CodeAuthzpMakePowerOfTwo(
        ULONG ulValue
        )
/*++

Routine Description:

    Rounds the specified number up to the next whole power of 2.
    (ie, exactly one of the following: 1, 2, 4, 8, 16, 32, 64, ...)

Arguments:

    ulValue - Integer value to operate on.

Return Value:

    Returns the rounded result.

--*/
{
    if (ulValue) {
        ULONG ulOriginal = ulValue;
        ULONG bitmask;
        for (bitmask = 1; ulValue != 0 && bitmask != 0 &&
             (ulValue & ~bitmask) != 0; bitmask <<= 1) {
            ulValue = ulValue & ~bitmask;
        }
        ASSERTMSG("failed to make a power of two",
                  CodeAuthzpIsPowerOfTwo(ulValue));
        if (ulOriginal > ulValue) {
            // if we ended up rounding down, then round it up!
            ulValue <<= 1;
        }
        ASSERT(ulValue >= ulOriginal);
    }
    return ulValue;
}




BOOLEAN
CodeAuthzInitialize (
    IN HANDLE Handle,
    IN DWORD Reason,
    IN PVOID Reserved
    )
/*++

Routine Description:

    This is the callback procedure used by the Advapi initialization
    and deinitialization.

Arguments:

    Handle -

    Reason -

    Reserved -

Return Value:

    Returns TRUE on success, FALSE on failure.

--*/
{
    NTSTATUS Status;

    UNREFERENCED_PARAMETER(Reserved);
    UNREFERENCED_PARAMETER(Handle);
    if (Reason == DLL_PROCESS_ATTACH) {
        Status = CodeAuthzInitializeGlobals();
        if (!NT_SUCCESS(Status)) return FALSE;
    } else if (Reason == DLL_PROCESS_DETACH) {
        CodeAuthzDeinitializeGlobals();
    }
    return TRUE;
}


#ifdef SAFER_REGISTRY_NOTIFICATIONS
static VOID NTAPI
SaferpRegistryNotificationRegister(VOID)
{
    if (g_hRegNotifyEvent != NULL)
    {
        // Note that it is okay to call RNCKV again on the same
        // registry handle even if there is still an outstanding
        // change notification registered.
        if (g_hKeyNotifyBase1 != NULL) {
            RegNotifyChangeKeyValue(
                g_hKeyNotifyBase1, TRUE,
                REG_NOTIFY_CHANGE_NAME | REG_NOTIFY_CHANGE_LAST_SET,
                g_hRegNotifyEvent,
                TRUE);
        }
        if (g_hKeyNotifyBase2 != NULL) {
            RegNotifyChangeKeyValue(
                g_hKeyNotifyBase2, TRUE,
                REG_NOTIFY_CHANGE_NAME | REG_NOTIFY_CHANGE_LAST_SET,
                g_hRegNotifyEvent,
                TRUE);
        }
    }
}

static VOID NTAPI
SaferpRegistryNotificationCallback (PVOID pvArg1, BOOLEAN bArg2)
{
    UNREFERENCED_PARAMETER(pvArg1);
    UNREFERENCED_PARAMETER(bArg2);
    g_bNeedCacheReload = TRUE;
}
#endif


NTSTATUS NTAPI
CodeAuthzInitializeGlobals(VOID)
/*++

Routine Description:

    Performs one-time startup operations that should be done before
    any other handle or cache table operations are attempted.

Arguments:

    nothing

Return Value:

    Returns STATUS_SUCCESS on success.

--*/
{
    NTSTATUS Status;
    ULONG ulHandleEntrySize;


    if (g_bInitializedFirstTime) {
        // Already initialized.
        return STATUS_SUCCESS;
    }


    //
    // Initialize a bunch of tables for their first usage.
    //
    Status = RtlInitializeCriticalSection(&g_TableCritSec);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    g_bInitializedFirstTime = g_bNeedCacheReload = TRUE;
    CodeAuthzLevelObjpInitializeTable(&g_CodeLevelObjTable);
    CodeAuthzGuidIdentsInitializeTable(&g_CodeIdentitiesTable);
    g_hKeyCustomRoot = NULL;
    g_dwKeyOptions = 0;


    //
    // Initialize the table that will be used to track opened
    // WinSafer Level handles.  Note that RtlInitializeHandleTable
    // requires a structure size that is a whole power of 2.
    //
    ulHandleEntrySize = CodeAuthzpMakePowerOfTwo(sizeof(AUTHZLEVELHANDLESTRUCT));

    RtlInitializeHandleTable(
            MAXIMUM_LEVEL_HANDLES,
            ulHandleEntrySize,          // was sizeof(AUTHZLEVELHANDLESTRUCT)
            &g_LevelHandleTable);


#ifdef SAFER_REGISTRY_NOTIFICATIONS
    //
    // Create the event to catch modifications to the registry changes.
    // This allows us to notice policy changes and reload as necessary.
    //
    g_hRegNotifyEvent = CreateEvent(
              NULL,     // Security Descriptor
              TRUE,     // reset type
              FALSE,    // initial state
              NULL      // object name
            );
    if (g_hRegNotifyEvent != INVALID_HANDLE_VALUE) {
         if (!RegisterWaitForSingleObject(
                &g_hWaitNotifyObject,
                g_hRegNotifyEvent,
                SaferpRegistryNotificationCallback,
                NULL,
                INFINITE,
                WT_EXECUTEINWAITTHREAD))
         {
             CloseHandle(g_hRegNotifyEvent);
             g_hRegNotifyEvent = g_hWaitNotifyObject = NULL;
         }
    } else {
        g_hRegNotifyEvent = g_hWaitNotifyObject = NULL;
    }
    g_hKeyNotifyBase1 = g_hKeyNotifyBase2 = NULL;
#endif


    return STATUS_SUCCESS;
}


VOID NTAPI
CodeAuthzDeinitializeGlobals(VOID)
/*++

Routine Description:

    Performs one-time deinitialization operations.

Arguments:

    nothing

Return Value:

    Returns STATUS_SUCCESS on success.

--*/
{
    if (g_bInitializedFirstTime) {
#ifdef SAFER_REGISTRY_NOTIFICATIONS
        if (g_hWaitNotifyObject != NULL) {
            UnregisterWait(g_hWaitNotifyObject);
            CloseHandle(g_hWaitNotifyObject);
        }
        if (g_hRegNotifyEvent != NULL) {
            CloseHandle(g_hRegNotifyEvent);
        }
        if (g_hKeyNotifyBase1 != NULL) {
            NtClose(g_hKeyNotifyBase1);
        }
        if (g_hKeyNotifyBase2 != NULL) {
            NtClose(g_hKeyNotifyBase2);
        }
#endif
        CodeAuthzLevelObjpEntireTableFree(&g_CodeLevelObjTable);
        CodeAuthzGuidIdentsEntireTableFree(&g_CodeIdentitiesTable);
        RtlDestroyHandleTable(&g_LevelHandleTable);
        if (g_hKeyCustomRoot != NULL) {
            NtClose(g_hKeyCustomRoot);
            g_hKeyCustomRoot = NULL;
            g_dwKeyOptions = 0;
        }
        g_bInitializedFirstTime = FALSE;
        RtlDeleteCriticalSection(&g_TableCritSec);
    }
}


BOOL WINAPI
SaferiChangeRegistryScope(
        IN HKEY     hKeyCustomRoot OPTIONAL,
        IN DWORD    dwKeyOptions
        )
/*++

Routine Description:

    Closes and invalidates all currently open level handles and
    reloads all cached levels and identities.  The outstanding
    handles are closed and freed during this operation.

    If a hKeyCustomRoot is specified, all future level and identity
    operations will be performed on the levels and identies defined
    within that registry scope.  Otherwise, such operations will be
    done on the normal HKLM/HKCU policy store locations.

Arguments:

    hKeyCustomRoot - If specified, this should be an opened
            registry key handle to the base of the policy
            storage that should be used for all future operations.

    dwKeyOptions - Additional flags that should be passed in with
            the dwOptions parameter to any RegCreateKey operations,
            such as REG_OPTION_VOLATILE.

Return Value:

    Returns TRUE on success, FALSE on failure.  On error, GetLastError()
    will return a more specific indicator of the nature of the failure.

--*/

{
    NTSTATUS Status;

    Status = CodeAuthzReloadCacheTables(
                    (HANDLE) hKeyCustomRoot,
                    dwKeyOptions,
                    FALSE
                    );
    if (NT_SUCCESS(Status)) {
        return TRUE;
    } else {
        BaseSetLastNTError(Status);
        return FALSE;
    }
}


NTSTATUS NTAPI
CodeAuthzReloadCacheTables(
        IN HANDLE   hKeyCustomRoot OPTIONAL,
        IN DWORD    dwKeyOptions,
        IN BOOLEAN  bImmediateLoad
        )
/*++

Routine Description:

    Closes and invalidates all currently open level handles and
    reloads all cached levels and identities.  The outstanding
    handles are closed and freed during this operation.

    If a hKeyCustomRoot is specified, all future level and identity
    operations will be performed on the levels and identies defined
    within that registry scope.  Otherwise, such operations will be
    done on the normal HKLM/HKCU policy store locations.

Arguments:

    hKeyCustomRoot - If specified, this should be an opened
            registry key handle to the base of the policy
            storage that should be used for all future operations.

    bPopulateDefaults - If TRUE, then the default set of Level definitions
            will be inserted into the Registry if no existing Levels
            were found at the specified scope.

Return Value:

    Returns STATUS_SUCCESS on success.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;


    //
    // Ensure that the general globals have been initialized.
    //
    if (!g_bInitializedFirstTime) {
        Status = STATUS_UNSUCCESSFUL;
        goto ExitHandler;
    }
    RtlEnterCriticalSection(&g_TableCritSec);


    //
    // Initialize and blank out the tables we will be using.
    //
    CodeAuthzLevelObjpEntireTableFree(&g_CodeLevelObjTable);
    CodeAuthzGuidIdentsEntireTableFree(&g_CodeIdentitiesTable);


    //
    // Increment the sequence number.  This has the effect of
    // immediately invalidating all currently open handles, but
    // allows the caller to still close them properly.  Any
    // attempt by the caller to actually use one of the old
    // handles will result in a STATUS_INVALID_HANDLE error.
    //
    g_dwLevelHandleSequence++;


    //
    // Reset the rest of our variables.
    //
    if (g_hKeyCustomRoot != NULL) {
        NtClose(g_hKeyCustomRoot);
        g_hKeyCustomRoot = NULL;
    }
#ifdef SAFER_REGISTRY_NOTIFICATIONS
    if (g_hKeyNotifyBase1 != NULL) {
        NtClose(g_hKeyNotifyBase1);
        g_hKeyNotifyBase1 = NULL;
    }
    if (g_hKeyNotifyBase2 != NULL) {
        NtClose(g_hKeyNotifyBase2);
        g_hKeyNotifyBase2 = NULL;
    }
#endif
    g_DefaultCodeLevel = g_DefaultCodeLevelMachine =
            g_DefaultCodeLevelUser = NULL;
    g_bHonorScopeUser = FALSE;
    g_bNeedCacheReload = FALSE;
    g_dwKeyOptions = 0;



    //
    // Save a duplicated copy of the custom registry handle.
    //
    if (ARGUMENT_PRESENT(hKeyCustomRoot))
    {
        const static UNICODE_STRING SubKeyName = { 0, 0, NULL };
        OBJECT_ATTRIBUTES ObjectAttributes;

        InitializeObjectAttributes(&ObjectAttributes,
                                   (PUNICODE_STRING) &SubKeyName,
                                   OBJ_CASE_INSENSITIVE,
                                   hKeyCustomRoot,
                                   NULL
                                   );
        Status = NtOpenKey(&g_hKeyCustomRoot,
                           KEY_READ,
                           &ObjectAttributes);
        if (!NT_SUCCESS(Status)) {
            goto ExitHandler2;
        }
        g_dwKeyOptions = dwKeyOptions;
#ifdef SAFER_REGISTRY_NOTIFICATIONS
#error "open for KEY_NOTIFY"
#endif
    }
    else
    {
#ifdef SAFER_REGISTRY_NOTIFICATIONS
#endif
    }

    //
    // Perform the actual load now, if needed.
    //
    g_bNeedCacheReload = TRUE;
    if (bImmediateLoad) {
        Status = CodeAuthzpImmediateReloadCacheTables();
    } else {
        Status = STATUS_SUCCESS;
    }



ExitHandler2:
    RtlLeaveCriticalSection(&g_TableCritSec);

ExitHandler:
    return Status;
}



NTSTATUS NTAPI
CodeAuthzpImmediateReloadCacheTables(
        VOID
        )
/*++

Routine Description:

    Assumes that CodeAuthzReloadCacheTables() has already been called
    with the specified scope already, and that this function has not
    yet been called since the last reload.

Arguments:

    none

Return Value:

    returns STATUS_SUCCESS on successful completion.

--*/
{
    NTSTATUS Status;
    DWORD dwFlagValue;


    ASSERT(g_TableCritSec.OwningThread == UlongToHandle(GetCurrentThreadId()));
    ASSERT(RtlIsGenericTableEmpty(&g_CodeIdentitiesTable) &&
            RtlIsGenericTableEmpty(&g_CodeLevelObjTable));
    ASSERT(g_bNeedCacheReload != FALSE);


    //
    // Need to clear the cache reload flag, otherwise we
    // might cause undesired infinite recursion later with
    // some of the CodeAuthzPol_xxx functions.
    //
    g_bNeedCacheReload = FALSE;


    //
    // Begin loading the new policy settings from the specified location.
    //
    if (g_hKeyCustomRoot != NULL)
    {
        //
        // Read in the definitions of all WinSafer Levels from
        // the custom registry root specified.
        //
        CodeAuthzLevelObjpLoadTable(
                &g_CodeLevelObjTable,
                SAFER_SCOPEID_REGISTRY,
                g_hKeyCustomRoot);

        //
        // The HonorScopeUser flag is not relevant when a custom
        // registry scope is used, but we set it to false anyways.
        //
        g_bHonorScopeUser = FALSE;


        //
        // Load the Code Identities from the custom registry root.
        //
        CodeAuthzGuidIdentsLoadTableAll(
                &g_CodeLevelObjTable,
                &g_CodeIdentitiesTable,
                SAFER_SCOPEID_REGISTRY,
                g_hKeyCustomRoot);

        //
        // Load the Default Level specified by the custom registry root.
        //
        Status = CodeAuthzPol_GetInfoRegistry_DefaultLevel(
                SAFER_SCOPEID_REGISTRY,
                sizeof(DWORD), &dwFlagValue, NULL);
        if (NT_SUCCESS(Status)) {
            g_DefaultCodeLevelMachine =
                CodeAuthzLevelObjpLookupByLevelId(
                        &g_CodeLevelObjTable, dwFlagValue);
        } else {
            g_DefaultCodeLevelMachine = NULL;
        }
        g_DefaultCodeLevelUser = NULL;
    }
    else   // !ARGUMENT_PRESENT(hKeyCustomRoot)
    {
        g_hKeyCustomRoot = NULL;

        //
        // Read in the definitions of all WinSafer Levels from
        // the HKEY_LOCAL_MACHINE registry scope.
        //
        CodeAuthzLevelObjpLoadTable(
                &g_CodeLevelObjTable,
                SAFER_SCOPEID_MACHINE,
                NULL);

        g_bHonorScopeUser = TRUE;

        //
        // Load in all Code Identities from the HKEY_LOCAL_MACHINE
        // and possibly the HKEY_CURRENT_USER scope too.
        //
        CodeAuthzGuidIdentsLoadTableAll(
                &g_CodeLevelObjTable,
                &g_CodeIdentitiesTable,
                SAFER_SCOPEID_MACHINE,
                NULL);

        if (g_bHonorScopeUser) {
            CodeAuthzGuidIdentsLoadTableAll(
                &g_CodeLevelObjTable,
                &g_CodeIdentitiesTable,
                SAFER_SCOPEID_USER,
                NULL);
        }

        //
        // Load the Default Level specified by the machine scope.
        //
        Status = CodeAuthzPol_GetInfoRegistry_DefaultLevel(
                SAFER_SCOPEID_MACHINE,
                sizeof(DWORD), &dwFlagValue, NULL);
        if (NT_SUCCESS(Status)) {
            g_DefaultCodeLevelMachine =
                CodeAuthzLevelObjpLookupByLevelId(
                        &g_CodeLevelObjTable, dwFlagValue);
        } else {
            g_DefaultCodeLevelMachine = NULL;
        }


        //
        // Load the Default Level specified by the user scope.
        //
        Status = CodeAuthzPol_GetInfoRegistry_DefaultLevel(
                SAFER_SCOPEID_USER,
                sizeof(DWORD), &dwFlagValue, NULL);
        if (NT_SUCCESS(Status)) {
            g_DefaultCodeLevelUser =
                CodeAuthzLevelObjpLookupByLevelId(
                        &g_CodeLevelObjTable, dwFlagValue);
        } else {
            g_DefaultCodeLevelUser = NULL;
        }
    }


    //
    // Compute the effective Default Level (take the least privileged).
    //
    CodeAuthzpRecomputeEffectiveDefaultLevel();


    //
    // Now that we have fully loaded the policy, set a change
    // notification hook so that we can be alerted to updates.
    //
#ifdef SAFER_REGISTRY_NOTIFICATIONS
    g_bNeedCacheReload = FALSE;
    SaferpRegistryNotificationRegister();
#endif


    return STATUS_SUCCESS;
}



VOID NTAPI
CodeAuthzpRecomputeEffectiveDefaultLevel(
            VOID
            )
/*++

Routine Description:

Arguments:

    nothing

Return Value:

    nothing.

--*/
{
    if (g_DefaultCodeLevelMachine != NULL &&
        g_DefaultCodeLevelUser != NULL &&
        g_bHonorScopeUser)
    {
        g_DefaultCodeLevel =
            (g_DefaultCodeLevelMachine->dwLevelId <
                g_DefaultCodeLevelUser->dwLevelId ?
             g_DefaultCodeLevelMachine : g_DefaultCodeLevelUser);
    } else if (g_DefaultCodeLevelMachine != NULL) {
        g_DefaultCodeLevel = g_DefaultCodeLevelMachine;
    } else if (g_bHonorScopeUser) {
        g_DefaultCodeLevel = g_DefaultCodeLevelUser;
    } else {
        g_DefaultCodeLevel = NULL;
    }

    //
    // If we still don't have a default Level, then try to pick
    // the Fully Trusted level as default.  It still might fail
    // in the case where the Fully Trusted level doesn't exist,
    // but that shouldn't ever happen.
    //
    if (!g_DefaultCodeLevel) {
        g_DefaultCodeLevel = CodeAuthzLevelObjpLookupByLevelId(
                &g_CodeLevelObjTable, SAFER_LEVELID_FULLYTRUSTED);
        // ASSERT(g_DefaultCodeLevel != NULL);
    }
}



NTSTATUS NTAPI
CodeAuthzpDeleteKeyRecursively(
        IN HANDLE               hBaseKey,
        IN PUNICODE_STRING      pSubKey OPTIONAL
        )
/*++

Routine Description:

    Recursively delete the key, including all child values and keys.

Arguments:

    hkey - the base registry key handle to start from.

    pszSubKey - subkey to delete from.

Return Value:

    Returns ERROR_SUCCESS on success, otherwise error.

--*/
{
    NTSTATUS Status;
    BOOLEAN bCloseSubKey;
    HANDLE hSubKey;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeString;
    PKEY_BASIC_INFORMATION pKeyBasicInfo;
    DWORD dwQueryBufferSize = 0, dwActualSize = 0;


    //
    // Open the subkey so we can enumerate any children
    //
    if (ARGUMENT_PRESENT(pSubKey) &&
        pSubKey->Buffer != NULL)
    {
        InitializeObjectAttributes(&ObjectAttributes,
                                      pSubKey,
                                      OBJ_CASE_INSENSITIVE,
                                      hBaseKey,
                                      NULL
                                     );
        Status = NtOpenKey(&hSubKey, KEY_READ | DELETE, &ObjectAttributes);
        if (!NT_SUCCESS(Status)) {
            return Status;
        }
        bCloseSubKey = TRUE;
    } else {
        hSubKey = hBaseKey;
        bCloseSubKey = FALSE;
    }



    //
    // To delete a registry key, we must first ensure that all
    // children subkeys are deleted (registry values do not need
    // to be deleted in order to delete the key itself).  To do
    // this we loop enumerate
    //

    dwQueryBufferSize = 256;
    pKeyBasicInfo = RtlAllocateHeap(RtlProcessHeap(), 0,
                                   dwQueryBufferSize);
    for (;;)
    {
        Status = NtEnumerateKey(
                hSubKey, 0, KeyBasicInformation,
                pKeyBasicInfo, dwQueryBufferSize, &dwActualSize);

        if (Status == STATUS_BUFFER_TOO_SMALL ||
            Status == STATUS_BUFFER_OVERFLOW)
        {
            if (dwActualSize <= dwQueryBufferSize) {
                ASSERT(FALSE);
                break;  // should not happen, so stop now.
            }
            if (pKeyBasicInfo != NULL) {
                RtlFreeHeap(RtlProcessHeap(), 0, pKeyBasicInfo);
            }
            dwQueryBufferSize = dwActualSize;       // request a little more.
            pKeyBasicInfo = RtlAllocateHeap(RtlProcessHeap(), 0,
                                           dwQueryBufferSize);
            if (!pKeyBasicInfo) {
                break;  // stop now, but we don't care about the error.
            }

            Status = NtEnumerateKey(
                    hSubKey, 0, KeyBasicInformation,
                    pKeyBasicInfo, dwQueryBufferSize, &dwActualSize);

        }

        if (Status == STATUS_NO_MORE_ENTRIES) {
            // we've finished deleting all subkeys, stop now.
            Status = STATUS_SUCCESS;
            break;
        }
        if (!NT_SUCCESS(Status) || !pKeyBasicInfo) {
            break;
        }


        UnicodeString.Buffer = pKeyBasicInfo->Name;
        UnicodeString.MaximumLength = (USHORT) pKeyBasicInfo->NameLength;
        UnicodeString.Length = (USHORT) (pKeyBasicInfo->NameLength - sizeof(WCHAR));
        Status = CodeAuthzpDeleteKeyRecursively(hSubKey, &UnicodeString);
        if (!NT_SUCCESS(Status)) {
            break;
        }
    }
    if (pKeyBasicInfo != NULL) {
        RtlFreeHeap(RtlProcessHeap(), 0, pKeyBasicInfo);
    }
    Status = NtDeleteKey(hSubKey);

    if (bCloseSubKey) {
        NtClose(hSubKey);
    }
    return Status;
}



NTSTATUS NTAPI
CodeAuthzpFormatLevelKeyPath(
        IN DWORD                    dwLevelId,
        IN OUT PUNICODE_STRING      UnicodeSuffix
        )
/*++

Routine Description:

    Internal function to generate the path to a given subkey within the
    WinSafer policy store for the storage of a given Level.  The
    resulting path can then be supplied to CodeAuthzpOpenPolicyRootKey

Arguments:

    dwLevelId - the LevelId to process.

    UnicodeSuffix - Specifies the output buffer.  The Buffer and
            MaximumLength fields must be supplied, but the Length
            field is ignored.

Return Value:

    Returns STATUS_SUCCESS on success.

--*/
{
    NTSTATUS Status;
    UNICODE_STRING UnicodeTemp;


    if (!ARGUMENT_PRESENT(UnicodeSuffix)) {
        Status = STATUS_ACCESS_VIOLATION;
        goto ExitHandler;
    }
    UnicodeSuffix->Length = 0;
    Status = RtlAppendUnicodeToString(
                    UnicodeSuffix,
                    SAFER_OBJECTS_REGSUBKEY L"\\");
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler;
    }
    UnicodeTemp.Buffer = &UnicodeSuffix->Buffer[
                UnicodeSuffix->Length / sizeof(WCHAR) ];
    UnicodeTemp.MaximumLength = (UnicodeSuffix->MaximumLength -
                                 UnicodeSuffix->Length);
    Status = RtlIntegerToUnicodeString(dwLevelId,
                                       10,
                                       &UnicodeTemp);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler;
    }
    UnicodeSuffix->Length += UnicodeTemp.Length;


ExitHandler:
    return Status;
}



NTSTATUS NTAPI
CodeAuthzpFormatIdentityKeyPath(
        IN DWORD                    dwLevelId,
        IN LPCWSTR                  szIdentityType,
        IN REFGUID                  refIdentGuid,
        IN OUT PUNICODE_STRING      UnicodeSuffix
        )
/*++

Routine Description:

    Internal function to generate the path to a given subkey within the
    WinSafer policy store for the storage of a given Code Identity.  The
    resulting path can then be supplied to CodeAuthzpOpenPolicyRootKey

Arguments:

    dwLevelId - the LevelId to process.

    szIdentityType - should be one of the following string constants:
        SAFER_PATHS_REGSUBKEY,
        SAFER_HASHMD5_REGSUBKEY,
        SAFER_SOURCEURL_REGSUBKEY

    refIdentGuid - the GUID of the code identity.

    UnicodeSuffix - Specifies the output buffer.  The Buffer and
            MaximumLength fields must be supplied, but the Length
            field is ignored.

Return Value:

    Returns STATUS_SUCCESS on success.

--*/
{
    NTSTATUS Status;
    UNICODE_STRING UnicodeTemp;


    if (!ARGUMENT_PRESENT(refIdentGuid)) {
        Status = STATUS_INVALID_PARAMETER;
        goto ExitHandler;
    }
    if (!ARGUMENT_PRESENT(UnicodeSuffix)) {
        Status = STATUS_ACCESS_VIOLATION;
        goto ExitHandler;
    }

    UnicodeSuffix->Length = 0;
    Status = RtlAppendUnicodeToString(
                    UnicodeSuffix,
                    SAFER_CODEIDS_REGSUBKEY L"\\");
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler;
    }
    UnicodeTemp.Buffer = &UnicodeSuffix->Buffer[
                UnicodeSuffix->Length / sizeof(WCHAR) ];
    UnicodeTemp.MaximumLength = (UnicodeSuffix->MaximumLength -
                                 UnicodeSuffix->Length);
    Status = RtlIntegerToUnicodeString(dwLevelId,
                                       10,
                                       &UnicodeTemp);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler;
    }
    UnicodeSuffix->Length += UnicodeTemp.Length;
    Status = RtlAppendUnicodeToString(
                    UnicodeSuffix,
                    L"\\");
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler;
    }

    Status = RtlAppendUnicodeToString(
                    UnicodeSuffix,
                    szIdentityType);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler;
    }

    Status = RtlAppendUnicodeToString(
                    UnicodeSuffix,
                    L"\\");
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler;
    }

    Status = RtlStringFromGUID(refIdentGuid, &UnicodeTemp);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler;
    }
    Status = RtlAppendUnicodeStringToString(
                    UnicodeSuffix, &UnicodeTemp);
    RtlFreeUnicodeString(&UnicodeTemp);

ExitHandler:
    return Status;
}



NTSTATUS NTAPI
CodeAuthzpOpenPolicyRootKey(
        IN DWORD        dwScopeId,
        IN HANDLE       hKeyCustomBase OPTIONAL,
        IN LPCWSTR      szRegistrySuffix OPTIONAL,
        IN ACCESS_MASK  DesiredAccess,
        IN BOOLEAN      bCreateKey,
        OUT HANDLE     *OpenedHandle
        )
/*++

Routine Description:

    Internal function to generate the path to a given subkey within the
    WinSAFER policy store within the registry and then open that key.
    The specified subkeys can optionally be automatically created if
    they do not already exist.

Arguments:

    dwScopeId - input scope identifier.  This must be one of
        SAFER_SCOPEID_MACHINE or SAFER_SCOPEID_USER or SAFER_SCOPEID_REGISTRY.

    hKeyCustomBase - only used if dwScopeId is SAFER_SCOPEID_REGISTRY.

    szRegistrySuffix - optionally specifies a subkey name to open under
        the scope being referenced.

    DesiredAccess - specifies the access that should be used to open
        the registry key.  For example, use KEY_READ for read access.

    bCreateKey - if true, the key will be created if it does not exist.

    OpenedHandle - pointer that recieves the opened handle.  This handle
        must be closed by the caller with NtClose()

Return Value:

    Returns STATUS_SUCCESS on success.

--*/
{
    NTSTATUS Status;
    WCHAR KeyPathBuffer[MAX_PATH];
    HANDLE hKeyPolicyBase;
    UNICODE_STRING SubKeyName;
    OBJECT_ATTRIBUTES ObjectAttributes;

    USHORT KeyLength = 0;
        
    //
    // Verify that we were given a pointer to write the final handle to.
    //
    if (!ARGUMENT_PRESENT(OpenedHandle)) {
        return STATUS_INVALID_PARAMETER_4;
    }

    if (ARGUMENT_PRESENT(szRegistrySuffix)) 
    {
        KeyLength = (wcslen(szRegistrySuffix) + 1 ) * sizeof(WCHAR);
    }

    //
    // Evaluate the Scope and build the full registry path that we will
    // use to open a handle to this key.
    //
    SubKeyName.Buffer = KeyPathBuffer;
    SubKeyName.Length = 0;
    SubKeyName.MaximumLength = sizeof(KeyPathBuffer);

    if (dwScopeId == SAFER_SCOPEID_MACHINE)
    {
        KeyLength += sizeof(WCHAR) + sizeof(SAFER_HKCU_REGBASE) + sizeof(L"\\Registry\\Machine\\");

        if (SubKeyName.MaximumLength < KeyLength)
        {
            SubKeyName.Buffer = RtlAllocateHeap(RtlProcessHeap(), 0,
                                           KeyLength);
            if (SubKeyName.Buffer == NULL)
            {
                return STATUS_NO_MEMORY;
            }
            SubKeyName.MaximumLength = KeyLength;
        }
        Status = RtlAppendUnicodeToString(&SubKeyName,
                L"\\Registry\\Machine\\" SAFER_HKLM_REGBASE );
        hKeyPolicyBase = NULL;
    }
    else if (dwScopeId == SAFER_SCOPEID_USER)
    {
        UNICODE_STRING CurrentUserKeyPath;

        Status = RtlFormatCurrentUserKeyPath( &CurrentUserKeyPath );
        if (NT_SUCCESS( Status ) )
        {
            KeyLength += CurrentUserKeyPath.Length + sizeof(WCHAR) + 
                          sizeof(SAFER_HKCU_REGBASE);

            if (SubKeyName.MaximumLength < KeyLength)
            {
                SubKeyName.Buffer = RtlAllocateHeap(RtlProcessHeap(), 0,
                                               KeyLength);

                if (SubKeyName.Buffer == NULL)
                {
                    return STATUS_NO_MEMORY;
                }

                SubKeyName.MaximumLength = KeyLength;
            }

            Status = RtlAppendUnicodeStringToString(
                        &SubKeyName, &CurrentUserKeyPath );
            RtlFreeUnicodeString( &CurrentUserKeyPath );
        }
        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        Status = RtlAppendUnicodeToString( &SubKeyName,
                L"\\" SAFER_HKCU_REGBASE );
        if (!NT_SUCCESS( Status )) {
            goto Cleanup;
        }
        hKeyPolicyBase = NULL;
    }
    else if (dwScopeId == SAFER_SCOPEID_REGISTRY)
    {
        ASSERT(hKeyCustomBase != NULL);

        hKeyPolicyBase = hKeyCustomBase;

        if (SubKeyName.MaximumLength < KeyLength)
        {
            SubKeyName.Buffer = RtlAllocateHeap(RtlProcessHeap(), 0,
                                           KeyLength);
            if (SubKeyName.Buffer == NULL)
            {
                return STATUS_NO_MEMORY;
            }
            SubKeyName.MaximumLength = KeyLength;
        }
    }
    else {
        return STATUS_INVALID_PARAMETER_1;
    }


    //
    // Append whatever suffix we're supposed to append if one was given.
    //
    if (ARGUMENT_PRESENT(szRegistrySuffix)) {
        if (SubKeyName.Length > 0)
        {
            // We are appending a suffix to a partial path, so
            // make sure there is at least a single backslash
            // dividing the two strings (extra are fine).
            if (*szRegistrySuffix != L'\\') {
                Status = RtlAppendUnicodeToString(&SubKeyName, L"\\");
                if (!NT_SUCCESS(Status)) {
                    goto Cleanup;
                }
            }
        } else if (hKeyPolicyBase != NULL) {
            // Otherwise we are opening a key relative to a custom
            // specified key, and the supplied suffix happens to be
            // the first part of the path, so ensure there are no
            // leading backslashes.
            while (*szRegistrySuffix != UNICODE_NULL &&
                   *szRegistrySuffix == L'\\') szRegistrySuffix++;
        }

        Status = RtlAppendUnicodeToString(&SubKeyName, szRegistrySuffix);
        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }
    }

    //
    // Open a handle to the registry path that we are supposed to open.
    //
    InitializeObjectAttributes(&ObjectAttributes,
                                  &SubKeyName,
                                  OBJ_CASE_INSENSITIVE,
                                  hKeyPolicyBase,
                                  NULL
                                 );
    if (bCreateKey) {
        Status = NtCreateKey(OpenedHandle, DesiredAccess,
                             &ObjectAttributes, 0, NULL,
                             g_dwKeyOptions, NULL);
        if (Status == STATUS_OBJECT_NAME_NOT_FOUND)
        {
            BOOLEAN bAtLeastOnce;
            USHORT uIndex, uFinalLength;

            //
            // If we fail on the first try to open the full path, then
            // it is possible that one or more of the parent keys did
            // not already exist, so we have to retry for each.
            //
            uFinalLength = (SubKeyName.Length / sizeof(WCHAR));
            bAtLeastOnce = FALSE;
            for (uIndex = 0; uIndex < uFinalLength; uIndex++) {
                if (SubKeyName.Buffer[uIndex] == L'\\' ) {
                    HANDLE hTempKey;
                    SubKeyName.Length = uIndex * sizeof(WCHAR);
                    Status = NtCreateKey(&hTempKey, DesiredAccess,
                                         &ObjectAttributes, 0, NULL,
                                         g_dwKeyOptions, NULL);
                    if (NT_SUCCESS(Status)) {
                        NtClose(hTempKey);
                    } else if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {
                        // one of the keys leading up here still failed.
                        break;
                    }
                    bAtLeastOnce = TRUE;
                }
            }

            if (bAtLeastOnce) {
                SubKeyName.Length = uFinalLength * sizeof(WCHAR);
                Status = NtCreateKey(OpenedHandle, DesiredAccess,
                                     &ObjectAttributes, 0, NULL,
                                     g_dwKeyOptions, NULL);
            }
        }

    } else {
        Status = NtOpenKey(OpenedHandle, DesiredAccess,
                           &ObjectAttributes);
    }

Cleanup:

    if ((SubKeyName.Buffer != NULL) && (SubKeyName.Buffer != KeyPathBuffer))
    {
        RtlFreeHeap(RtlProcessHeap(), 0, SubKeyName.Buffer);
    }

    return Status;
}

BOOL WINAPI
SaferiPopulateDefaultsInRegistry(
        IN HKEY     hKeyBase,
        OUT BOOL    *pbSetDefaults
        )
/*++

Routine Description:

    Winsafer UI will use this API to populate default winsafer values 
    in the registry as follows:
                                                                             
    DefaultLevel: SAFER_LEVELID_FULLYTRUSTED
    ExecutableTypes: initialized to the latest list of attachment types
    TransparentEnabled: 1
    Policy Scope: 0 (enable policy for admins)
    Level descriptions
    
    
Arguments:

    hKeyBase - This should be an opened registry key handle to the 
               base of the policy storage that should be used for 
               to populate the defaults into. This handle should be
               opened with a miniumum of KEY_SET_VALUE access.
        
   pbSetDefaults - Pointer to a boolean that gets set when 
                   default values are actually set (UI uses this).

Return Value:

    returns STATUS_SUCCESS on successful completion.

--*/

{
    
#define SAFERP_WINDOWS L"%HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\SystemRoot%" 
    GUID WindowsGuid = {0x191cd7fa, 0xf240, 0x4a17, 0x89, 0x86, 0x94, 0xd4, 0x80, 0xa6, 0xc8, 0xca};

#define SAFERP_WINDOWS_EXE L"%HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\SystemRoot%\\*.exe" 
    GUID WindowsExeGuid = {0x7272edfb, 0xaf9f, 0x4ddf, 0xb6, 0x5b, 0xe4, 0x28, 0x2f, 0x2d, 0xee, 0xfc};

#define SAFERP_SYSTEM_EXE L"%HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\SystemRoot%\\System32\\*.exe" 
    GUID SystemExeGuid = {0x8868b733, 0x4b3a, 0x48f8, 0x91, 0x36, 0xaa, 0x6d, 0x05, 0xd4, 0xfc, 0x83};

#define SAFERP_PROGRAMFILES L"%HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\ProgramFilesDir%"
    GUID ProgramFilesGuid = {0xd2c34ab2, 0x529a, 0x46b2, 0xb2, 0x93, 0xfc, 0x85, 0x3f, 0xce, 0x72, 0xea};

    NTSTATUS    Status;
    DWORD   dwValueValue;
    PWSTR   pmszFileTypes = NULL;
    UNICODE_STRING ValueName;
    ULONG   uResultLength = 0;
    KEY_NAME_INFORMATION   pKeyInformation;
    UNICODE_STRING ucSubKeyName;
    WCHAR   szSubKeyPath[] = L"Software\\Policies\\Microsoft\\Windows\\Safer\\CodeIdentifiers\0";
    OBJECT_ATTRIBUTES ObjectAttributes;
    HKEY    hKeyFinal = NULL;
    HANDLE hAdvApiInst;
    AUTHZIDENTSTABLERECORD LocalRecord = {0};
    SAFER_PATHNAME_IDENTIFICATION PathIdent = {0};

    DWORD dwLevelIndex;
    BYTE QueryBuffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + 64];
    PKEY_VALUE_PARTIAL_INFORMATION pKeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION) QueryBuffer;
    DWORD dwActualSize = 0;

    if (!ARGUMENT_PRESENT(hKeyBase) || !ARGUMENT_PRESENT(pbSetDefaults)) {
        Status = STATUS_INVALID_PARAMETER;
        goto ExitHandler;
    }

    *pbSetDefaults = TRUE;
    
    RtlInitUnicodeString(&ucSubKeyName, szSubKeyPath);

    InitializeObjectAttributes(&ObjectAttributes,
                               (PUNICODE_STRING) &ucSubKeyName,
                               OBJ_CASE_INSENSITIVE,
                               hKeyBase,
                               NULL
                               );

    Status = NtOpenKey(&hKeyFinal,
                       KEY_WRITE | KEY_READ,
                       &ObjectAttributes);

    if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {
        
        Status = NtCreateKey(&hKeyFinal, 
                             KEY_WRITE | KEY_READ,
                             &ObjectAttributes, 
                             0, 
                             NULL,
                             REG_OPTION_NON_VOLATILE, 
                             NULL);
    }


    if (!NT_SUCCESS(Status)) {
        goto ExitHandler;
    }

    //
    // check if any default value is absent
    // if so, populate all the defaults again
    // if not, do not populate any values and return
    //
    
    RtlInitUnicodeString(&ValueName, SAFER_DEFAULTOBJ_REGVALUE);
    
    Status = NtQueryValueKey(
                 hKeyFinal,
                 (PUNICODE_STRING) &ValueName,
                 KeyValuePartialInformation,
                 pKeyValueInfo, 
                 sizeof(QueryBuffer), 
                 &dwActualSize
                 );

    if ( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {
        goto PopulateAllDefaults;
    }

    RtlInitUnicodeString(&ValueName, SAFER_TRANSPARENTENABLED_REGVALUE);
    
    Status = NtQueryValueKey(
                 hKeyFinal,
                 (PUNICODE_STRING) &ValueName,
                 KeyValuePartialInformation,
                 pKeyValueInfo, 
                 sizeof(QueryBuffer), 
                 &dwActualSize
                 );

    if ( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {
        goto PopulateAllDefaults;
    }

    RtlInitUnicodeString(&ValueName, SAFER_POLICY_SCOPE);

    Status = NtQueryValueKey(
                 hKeyFinal,
                 (PUNICODE_STRING) &ValueName,
                 KeyValuePartialInformation,
                 pKeyValueInfo, 
                 sizeof(QueryBuffer), 
                 &dwActualSize
                 );

    if ( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {
        goto PopulateAllDefaults;
    }
    
    RtlInitUnicodeString(&ValueName, SAFER_EXETYPES_REGVALUE);

    Status = NtQueryValueKey(
                 hKeyFinal,
                 (PUNICODE_STRING) &ValueName,
                 KeyValuePartialInformation,
                 pKeyValueInfo, 
                 sizeof(QueryBuffer), 
                 &dwActualSize
                 );

    if ( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {
        goto PopulateAllDefaults;
    }

    //
    // all default values are present or there was an error
    // querying one of the values no need to populate any
    //

    *pbSetDefaults = FALSE;

    goto ExitHandler;

PopulateAllDefaults:

    RtlInitUnicodeString(&ValueName, SAFER_DEFAULTOBJ_REGVALUE);

    dwValueValue = SAFER_LEVELID_FULLYTRUSTED;
    
    Status = NtSetValueKey(hKeyFinal,
                           &ValueName,
                           0,
                           REG_DWORD,
                           &dwValueValue,
                           sizeof(DWORD));

    if (!NT_SUCCESS(Status))
        goto ExitHandler;

    dwValueValue = 1;

    RtlInitUnicodeString(&ValueName, SAFER_TRANSPARENTENABLED_REGVALUE);
    
    Status = NtSetValueKey(hKeyFinal,
                           &ValueName,
                           0,
                           REG_DWORD,
                           &dwValueValue,
                           sizeof(DWORD));

    if (!NT_SUCCESS(Status))
        goto ExitHandler;

    dwValueValue = 0;

    RtlInitUnicodeString(&ValueName, SAFER_POLICY_SCOPE);
    
    Status = NtSetValueKey(hKeyFinal,
                           &ValueName,
                           0,
                           REG_DWORD,
                           &dwValueValue,
                           sizeof(DWORD));

    if (!NT_SUCCESS(Status))
        goto ExitHandler;


    //
    // prepare the MULTI_SZ value to write to the registry
    //

    RtlInitUnicodeString(&ValueName, SAFER_EXETYPES_REGVALUE);

    pmszFileTypes = RtlAllocateHeap(RtlProcessHeap(), 
                                    0,
                                    sizeof(SAFER_DEFAULT_EXECUTABLE_FILE_TYPES)
                                    );

    if (pmszFileTypes) {
            
        RtlCopyMemory(pmszFileTypes, 
                      SAFER_DEFAULT_EXECUTABLE_FILE_TYPES, 
                      sizeof(SAFER_DEFAULT_EXECUTABLE_FILE_TYPES));

        Status = NtSetValueKey(hKeyFinal,
                               &ValueName,
                               0,
                               REG_MULTI_SZ,
                               pmszFileTypes,
                               sizeof(SAFER_DEFAULT_EXECUTABLE_FILE_TYPES)
                               );

        RtlFreeHeap(RtlProcessHeap(), 
                    0, 
                    pmszFileTypes
                   );
    }

    else {

        Status = STATUS_NO_MEMORY;
        
        goto ExitHandler;

    }

    //
    // We now generate 4 rules so that the OS binaries are exempt.
    //   FULLY TRUSTED
    //     %windir%
    //     %windir%\*.exe
    //     %windir%\system32\*.exe
    //     %ProgramFiles%
    //


    LocalRecord.dwIdentityType = SaferIdentityTypeImageName;
    LocalRecord.dwLevelId = SAFER_LEVELID_FULLYTRUSTED;
    LocalRecord.dwScopeId = SAFER_SCOPEID_REGISTRY;
    LocalRecord.ImageNameInfo.bExpandVars = TRUE;
    LocalRecord.ImageNameInfo.dwSaferFlags = 0;
    RtlInitUnicodeString(&LocalRecord.ImageNameInfo.ImagePath, SAFERP_WINDOWS);
    LocalRecord.IdentGuid = WindowsGuid;

    PathIdent.header.cbStructSize = sizeof(SAFER_IDENTIFICATION_HEADER);
    PathIdent.header.dwIdentificationType = SaferIdentityTypeImageName;
    PathIdent.header.IdentificationGuid = LocalRecord.IdentGuid;
    PathIdent.dwSaferFlags = 0;
    PathIdent.ImageName = SAFERP_WINDOWS;
    PathIdent.Description[0] = L'\0';

    Status = SaferpSetSingleIdentificationPath(TRUE,
                                               &LocalRecord,
                                               &PathIdent,
                                               FALSE
                                               );
    if (!NT_SUCCESS(Status))
        goto ExitHandler;

    RtlInitUnicodeString(&LocalRecord.ImageNameInfo.ImagePath, SAFERP_WINDOWS_EXE);
    LocalRecord.IdentGuid = WindowsExeGuid;
    PathIdent.header.IdentificationGuid = LocalRecord.IdentGuid;
    PathIdent.ImageName = SAFERP_WINDOWS_EXE;

    Status = SaferpSetSingleIdentificationPath(TRUE,
                                               &LocalRecord,
                                               &PathIdent,
                                               FALSE
                                               );
    if (!NT_SUCCESS(Status))
        goto ExitHandler;

    RtlInitUnicodeString(&LocalRecord.ImageNameInfo.ImagePath, SAFERP_SYSTEM_EXE);
    LocalRecord.IdentGuid = SystemExeGuid;
    PathIdent.header.IdentificationGuid = LocalRecord.IdentGuid;
    PathIdent.ImageName = SAFERP_SYSTEM_EXE;

    Status = SaferpSetSingleIdentificationPath(TRUE,
                                               &LocalRecord,
                                               &PathIdent,
                                               FALSE
                                               );
    if (!NT_SUCCESS(Status))
        goto ExitHandler;

    RtlInitUnicodeString(&LocalRecord.ImageNameInfo.ImagePath, SAFERP_PROGRAMFILES);
    LocalRecord.IdentGuid = ProgramFilesGuid;
    PathIdent.header.IdentificationGuid = LocalRecord.IdentGuid;
    PathIdent.ImageName = SAFERP_PROGRAMFILES;

    Status = SaferpSetSingleIdentificationPath(TRUE,
                                               &LocalRecord,
                                               &PathIdent,
                                               FALSE
                                               );
    if (!NT_SUCCESS(Status))
        goto ExitHandler;

ExitHandler:

    if (hKeyFinal) {
        NtClose(hKeyFinal);
    }

    if (NT_SUCCESS(Status)) {
        return TRUE;
    } else {
        BaseSetLastNTError(Status);
        return FALSE;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\winsafer\saferp.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    saferp.h

Abstract:

    This file implements the private (internal) functions, data types,
    data structures, and definitions used by the other WinSAFER
    code implementations.  All of the APIs listed in this header are
    not exported by ADVAPI32.DLL at all and are only callable by
    other code actually located within advapi.

Author:

    Jeffrey Lawson (JLawson)

Revision History:

--*/

#ifndef _AUTHZSAFERP_H_
#define _AUTHZSAFERP_H_

#include "safewild.h"


#ifdef __cplusplus
extern "C" {
#endif

// ---------------------------------------------------------


//
// Convenient macro for determining the number of elements in an array.
//
#ifndef ARRAYSIZE
#define ARRAYSIZE(a)                (sizeof(a)/sizeof(a[0]))
#endif


//
// Simple inlined function to return true if a GUID is all zeros.
//
FORCEINLINE BOOLEAN IsZeroGUID(REFGUID rguid1)
{
   return (
      ((unsigned long *) rguid1)[0] == 0 &&
      ((unsigned long *) rguid1)[1] == 0 &&
      ((unsigned long *) rguid1)[2] == 0 &&
      ((unsigned long *) rguid1)[3] == 0);
}



//
// Private structure used to store a table of all of the defined
// WinSafer Levels as we enumerate them to evaluate the matching one.
//
typedef struct _AUTHZLEVELTABLERECORD
{
    // The user-defined integer value that controls the relative ranking
    // of authorization level between Code Authorization Level.
    DWORD dwLevelId;

    // Boolean indicating whether this level is a "built-in" one.
    BOOLEAN Builtin;

	// Boolean indicating whether this level is enumerable
	BOOLEAN isEnumerable;

    // The short friendly name and the description.
    UNICODE_STRING UnicodeFriendlyName;
    UNICODE_STRING UnicodeDescription;

    // All of the following attributes are needed for
    // actual creation of the restricted token.
    BOOL DisallowExecution;                 // block execution entirely
    BOOL DisableMaxPrivileges;              // privilege options
    PSID DefaultOwner;                      // default owner SID
    DWORD SaferFlags;                       // special job execution flags

    BOOL InvertDisableSids;                 // SIDs specified are negative
    DWORD DisableSidCount;                  // number of deny-only SIDs
    DWORD DisableSidUsedCount;              // number actually used
    PAUTHZ_WILDCARDSID SidsToDisable;       // deny-only SIDs

    BOOL InvertDeletePrivs;                 // privileges specified are negative
    DWORD DeletePrivilegeCount;             // number of privileges
    DWORD DeletePrivilegeUsedCount;         // number actually used
    PLUID_AND_ATTRIBUTES PrivilegesToDelete;    // privileges

    DWORD RestrictedSidsInvCount;           // number of inverted restricting SIDs
    DWORD RestrictedSidsInvUsedCount;       // number actually used
    PAUTHZ_WILDCARDSID RestrictedSidsInv;   // list of inverted restricting SIDs

    DWORD RestrictedSidsAddedCount;         // number of restricting SIDs
    DWORD RestrictedSidsAddedUsedCount;     // number actually used
    PSID_AND_ATTRIBUTES RestrictedSidsAdded; // list of restricting SIDs

}
AUTHZLEVELTABLERECORD, *PAUTHZLEVELTABLERECORD;


//
// Private structure to store all code identifications.
//
#pragma warning(push)
#pragma warning(disable:4201)       // nonstandard extension used : nameless struct/union

typedef struct _AUTHZIDENTSTABLERECORD
{
    // unique identifier that distinguishes this code identity.
    GUID IdentGuid;

    // the following enumeration specifies what type of
    // code identity this record represents.
    SAFER_IDENTIFICATION_TYPES dwIdentityType;

    // Specifies what Level this Code Identification maps to.
    DWORD dwLevelId;

    // Specifies what scope this Code Identity was loaded from.
    DWORD dwScopeId;

    // Actual details about this identity.
    union {
        struct {
            BOOL bExpandVars;
            UNICODE_STRING ImagePath;
            DWORD dwSaferFlags;
        } ImageNameInfo;
        struct {
            LARGE_INTEGER ImageSize;
            DWORD HashSize;
            BYTE ImageHash[SAFER_MAX_HASH_SIZE];
            ALG_ID HashAlgorithm;
            DWORD dwSaferFlags;
        } ImageHashInfo;
        struct {
            DWORD UrlZoneId;
            DWORD dwSaferFlags;
        } ImageZone;
    };
}
AUTHZIDENTSTABLERECORD, *PAUTHZIDENTSTABLERECORD;
#pragma warning(pop)


//
// Private structure representation of a Level handle.  The
// typedef SAFER_LEVEL_HANDLE is an opaque reference to a structure of
// this type, accessed via the RtlHandleTable functions.
//
typedef struct _AUTHZLEVELHANDLESTRUCT_
{
    // This first header is required by the RTL_HANDLE_TABLE system.
    // All allocated handles will implicitly have bit 0 set.  All other
    // remaining bits can be used for our own purposes if we want.
    RTL_HANDLE_TABLE_ENTRY HandleHeader;

    // The following information is redundant.  It can be found by
    // also accessing the pLevelRecord directly.
    DWORD dwLevelId;

    // This scope identifier specifies the value that was passed to
    // the Win32 API SaferCreateLevel and is really only looked at
    // by SaferGetLevelInformation for the Identity GUID enums.
    DWORD dwScopeId;                 // (same as from pIdentRecord)

    // Stores the matching identity record that gave this result.
    // May be NULL, as in case of direct SaferCreateLevel or a
    // default Level match.
    GUID identGuid;

    // This value stores the Safer Flags that were derived from the
    // Identity Entry record when SaferIdentifyLevel finds a match.
    DWORD dwSaferFlags;

    // The sequence value indicates the "generation" at which a handle
    // was originally opened.  If this value does not match the current
    // value in the global g_dwLevelHandleSequence, then this handle
    // should be considered a no-longer valid handle.
    DWORD dwHandleSequence;

    // Extended error information - applicable for certificate rules.
    DWORD dwExtendedError;

    // the following enumeration specifies what type of
    // code identity this handle represents.
    SAFER_IDENTIFICATION_TYPES IdentificationType;

    // For future use and padding purposes.
    DWORD dwReserved;
}
AUTHZLEVELHANDLESTRUCT, *PAUTHZLEVELHANDLESTRUCT;


//
// Private structure definition used to pass around all state
// information needed during the SaferIdentifyLevel execution.
//
typedef struct _LOCALIDENTITYCONTEXT
{
    // Original query request data.
    DWORD dwCheckFlags;                 // copy of original function input
    PSAFER_CODE_PROPERTIES CodeProps;        // RO: original function input

    // Information about the hash that may have been computed.
    BOOLEAN bHaveHash;
    BYTE FinalHash[SAFER_MAX_HASH_SIZE];
    DWORD FinalHashSize;
    ALG_ID FinalHashAlgorithm;

    // File handle that may have been opened or supplied by the caller.
    HANDLE hFileHandle;

    // File handle status.  If this is TRUE then hFileHandle needs to
    // be closed before returning.
    BOOLEAN bCloseFileHandle;

    // Fully qualified NT filename of the input file.
    UNICODE_STRING UnicodeFullyQualfiedLongFileName;

    // Information about the image that may have been mapped.
    LARGE_INTEGER ImageSize;
    PVOID pImageMemory;

    // Memory mapped file status.  If this is TRUE then
    // pImageMemory needs to be unmapped before returning.
    BOOLEAN bImageMemoryNeedUnmap;
}
LOCALIDENTITYCONTEXT, *PLOCALIDENTITYCONTEXT;




//
// Various globals that are used for the cache of levels and
// identities so that we do not need to go to the registry each time.
//
extern BOOLEAN g_bInitializedFirstTime;

extern CRITICAL_SECTION g_TableCritSec;
extern HANDLE g_hKeyCustomRoot;
extern DWORD g_dwKeyOptions;

extern BOOLEAN g_bNeedCacheReload;

extern RTL_GENERIC_TABLE g_CodeLevelObjTable;
extern RTL_GENERIC_TABLE g_CodeIdentitiesTable;
extern RTL_HANDLE_TABLE g_LevelHandleTable;
extern DWORD g_dwLevelHandleSequence;

extern BOOLEAN g_bHonorScopeUser;

extern PAUTHZLEVELTABLERECORD g_DefaultCodeLevel;
extern PAUTHZLEVELTABLERECORD g_DefaultCodeLevelUser;
extern PAUTHZLEVELTABLERECORD g_DefaultCodeLevelMachine;



//
// Private function prototypes defined within SAFEINIT.C
//

NTSTATUS NTAPI
CodeAuthzInitializeGlobals(VOID);


VOID NTAPI
CodeAuthzDeinitializeGlobals(VOID);


NTSTATUS NTAPI
CodeAuthzReloadCacheTables(
        IN HANDLE   hKeyCustomRoot OPTIONAL,
        IN DWORD    dwKeyOptions,
        IN BOOLEAN  bImmediateLoad
        );


NTSTATUS NTAPI
CodeAuthzpImmediateReloadCacheTables(
        VOID
        );


NTSTATUS NTAPI
CodeAuthzpDeleteKeyRecursively(
        IN HANDLE               hBaseKey,
        IN PUNICODE_STRING      pSubKey OPTIONAL
        );


NTSTATUS NTAPI
CodeAuthzpFormatLevelKeyPath(
        IN DWORD                    dwLevelId,
        IN OUT PUNICODE_STRING      UnicodeSuffix
        );

NTSTATUS NTAPI
CodeAuthzpFormatIdentityKeyPath(
        IN DWORD                    dwLevelId,
        IN LPCWSTR                  szIdentityType,
        IN REFGUID                  refIdentGuid,
        IN OUT PUNICODE_STRING      UnicodeSuffix
        );

NTSTATUS NTAPI
CodeAuthzpOpenPolicyRootKey(
        IN DWORD            dwScopeId,
        IN HANDLE           hKeyCustomBase OPTIONAL,
        IN LPCWSTR          szRegistrySuffix OPTIONAL,
        IN ACCESS_MASK      DesiredAccess,
        IN BOOLEAN          bCreateKey,
        OUT HANDLE         *OpenedHandle
        );

VOID NTAPI
CodeAuthzpRecomputeEffectiveDefaultLevel(VOID);



//
// Private function prototypes defined within SAFEHAND.C
//


NTSTATUS NTAPI
CodeAuthzpCreateLevelHandleFromRecord(
        IN PAUTHZLEVELTABLERECORD   pLevelRecord,
        IN DWORD                    dwScopeId,
        IN DWORD                    dwSaferFlags OPTIONAL,
        IN DWORD                    dwExtendedError,
        IN SAFER_IDENTIFICATION_TYPES IdentificationType,
        IN REFGUID                  refIdentGuid OPTIONAL,
        OUT SAFER_LEVEL_HANDLE            *pLevelHandle
        );

NTSTATUS NTAPI
CodeAuthzHandleToLevelStruct(
        IN SAFER_LEVEL_HANDLE          hLevelObject,
        OUT PAUTHZLEVELHANDLESTRUCT  *pLevelStruct
        );

NTSTATUS NTAPI
CodeAuthzCreateLevelHandle(
        IN DWORD            dwLevelId,
        IN DWORD            OpenFlags,
        IN DWORD            dwScopeId,
        IN DWORD            dwSaferFlags OPTIONAL,
        OUT SAFER_LEVEL_HANDLE    *pLevelHandle);

NTSTATUS NTAPI
CodeAuthzCloseLevelHandle(
        IN SAFER_LEVEL_HANDLE      hLevelObject
        );




//
// Functions related to WinSafer Level enumeration (SAFEIDEP.C)
//

VOID NTAPI
CodeAuthzLevelObjpInitializeTable(
        IN OUT PRTL_GENERIC_TABLE   pAuthzObjTable
        );


NTSTATUS NTAPI
CodeAuthzLevelObjpLoadTable (
        IN OUT PRTL_GENERIC_TABLE   pAuthzObjTable,
        IN DWORD                    dwScopeId,
        IN HANDLE                   hKeyCustomRoot
        );

VOID NTAPI
CodeAuthzLevelObjpEntireTableFree (
        IN OUT PRTL_GENERIC_TABLE   pAuthzObjTable
        );

PAUTHZLEVELTABLERECORD NTAPI
CodeAuthzLevelObjpLookupByLevelId (
        IN PRTL_GENERIC_TABLE      pAuthzObjTable,
        IN DWORD                   dwLevelId
        );



//
// Functions related to WinSafer Code Identity enumeration. (SAFEIDEP.C)
//

VOID NTAPI
CodeAuthzGuidIdentsInitializeTable(
        IN OUT PRTL_GENERIC_TABLE  pAuthzObjTable
        );

NTSTATUS NTAPI
CodeAuthzGuidIdentsLoadTableAll (
        IN PRTL_GENERIC_TABLE       pAuthzLevelTable,
        IN OUT PRTL_GENERIC_TABLE   pAuthzIdentTable,
        IN DWORD                    dwScopeId,
        IN HANDLE                   hKeyCustomBase
        );

VOID NTAPI
CodeAuthzGuidIdentsEntireTableFree (
        IN OUT PRTL_GENERIC_TABLE pAuthzIdentTable
        );

PAUTHZIDENTSTABLERECORD NTAPI
CodeAuthzIdentsLookupByGuid (
        IN PRTL_GENERIC_TABLE      pAuthzIdentTable,
        IN REFGUID                 pIdentGuid
        );


//
// Helper functions that are used during actual identification (SAFEIDEP.C)
//

LONG NTAPI
CodeAuthzpCompareImagePath(
        IN LPCWSTR      szPathFragment,
        IN LPCWSTR      szFullImagePath);

NTSTATUS NTAPI
CodeAuthzpComputeImageHash(
        IN PVOID        pImageMemory,
        IN DWORD        dwImageSize,
        OUT PBYTE       pComputedHash OPTIONAL,
        IN OUT PDWORD   pdwHashSize OPTIONAL,
        OUT ALG_ID     *pHashAlgorithm OPTIONAL
        );



//
// Private function prototypes for low-level policy reading/writing. (SAFEPOLR.C)
//

NTSTATUS NTAPI
CodeAuthzPol_GetInfoCached_LevelListRaw(
        IN DWORD    dwScopeId,
        IN DWORD    InfoBufferSize OPTIONAL,
        OUT PVOID   InfoBuffer OPTIONAL,
        OUT PDWORD  InfoBufferRetSize OPTIONAL
        );

NTSTATUS NTAPI
CodeAuthzPol_GetInfoCached_DefaultLevel(
        IN DWORD        dwScopeId,
        IN DWORD        InfoBufferSize OPTIONAL,
        OUT PVOID       InfoBuffer OPTIONAL,
        OUT PDWORD      InfoBufferRetSize OPTIONAL
        );

NTSTATUS NTAPI
CodeAuthzPol_GetInfoRegistry_DefaultLevel(
        IN DWORD        dwScopeId,
        IN DWORD        InfoBufferSize OPTIONAL,
        OUT PVOID       InfoBuffer OPTIONAL,
        OUT PDWORD      InfoBufferRetSize OPTIONAL
        );

NTSTATUS NTAPI
CodeAuthzPol_SetInfoDual_DefaultLevel(
        IN DWORD        dwScopeId,
        IN DWORD        InfoBufferSize,
        OUT PVOID       InfoBuffer
        );

NTSTATUS NTAPI
CodeAuthzPol_GetInfoCached_HonorUserIdentities(
        IN   DWORD       dwScopeId,
        IN   DWORD       InfoBufferSize      OPTIONAL,
        OUT  PVOID       InfoBuffer          OPTIONAL,
        OUT PDWORD       InfoBufferRetSize   OPTIONAL
        );

NTSTATUS NTAPI
CodeAuthzPol_GetInfoRegistry_HonorUserIdentities(
        IN   DWORD       dwScopeId,
        IN   DWORD       InfoBufferSize      OPTIONAL,
        OUT  PVOID       InfoBuffer          OPTIONAL,
        OUT PDWORD       InfoBufferRetSize   OPTIONAL
        );

NTSTATUS NTAPI
CodeAuthzPol_SetInfoDual_HonorUserIdentities(
        IN      DWORD       dwScopeId,
        IN      DWORD       InfoBufferSize,
        IN      PVOID       InfoBuffer
        );

NTSTATUS NTAPI
CodeAuthzPol_GetInfoRegistry_TransparentEnabled(
        IN DWORD        dwScopeId,
        IN   DWORD       InfoBufferSize      OPTIONAL,
        OUT  PVOID       InfoBuffer          OPTIONAL,
        OUT PDWORD       InfoBufferRetSize   OPTIONAL
        );

NTSTATUS NTAPI
CodeAuthzPol_SetInfoRegistry_TransparentEnabled(
        IN DWORD        dwScopeId,
        IN DWORD        InfoBufferSize,
        IN PVOID        InfoBuffer
        );

NTSTATUS NTAPI
CodeAuthzPol_GetInfoRegistry_ScopeFlags(
        IN DWORD        dwScopeId,
        IN   DWORD       InfoBufferSize      OPTIONAL,
        OUT  PVOID       InfoBuffer          OPTIONAL,
        OUT PDWORD       InfoBufferRetSize   OPTIONAL
        );

NTSTATUS NTAPI
CodeAuthzPol_SetInfoRegistry_ScopeFlags(
        IN DWORD        dwScopeId,
        IN DWORD        InfoBufferSize,
        IN PVOID        InfoBuffer
        );


//
// Private function prototypes defined elsewhere.
//

LPVOID NTAPI
CodeAuthzpGetTokenInformation(
        IN HANDLE                       TokenHandle,
        IN TOKEN_INFORMATION_CLASS      TokenInformationClass
        );

NTSTATUS NTAPI
CodeAuthzIsExecutableFileType(
        IN PUNICODE_STRING  szFullPathname,
        IN BOOLEAN  bFromShellExecute,
        OUT PBOOLEAN        pbResult
        );

NTSTATUS NTAPI
CodeAuthzFullyQualifyFilename(
        IN HANDLE               hFileHandle         OPTIONAL,
        IN BOOLEAN              bSourceIsNtPath,
        IN LPCWSTR              szSourceFilePath,
        OUT PUNICODE_STRING     pUnicodeResult
        );

BOOL NTAPI
SaferpLoadUnicodeResourceString(
        IN HANDLE               hModule,
        IN UINT                 wID,
        OUT PUNICODE_STRING     pUnicodeString,
        IN WORD                 wLangId
    );


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\winsafer\safeset.c ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    safeset.c         (WinSAFER SetInformation)

Abstract:

    This module implements the WinSAFER APIs to set attributes and
    information relating to the Code Authorization Levels.

Author:

    Jeffrey Lawson (JLawson) - May 2000

Environment:

    User mode only.

Exported Functions:

    SaferSetLevelInformation

Revision History:

    Created - Nov 1999


--*/

#include "pch.h"
#pragma hdrstop
#include <sddl.h>
#include <accctrl.h>
#include <aclapi.h>
#include <winsafer.h>
#include <winsaferp.h>
#include "saferp.h"
#include "safewild.h"





NTSTATUS NTAPI
SaferpCreateSecondLevelKey(
        IN HANDLE       hObjectKeyBase,
        IN LPCWSTR      szFirstLevel,
        IN LPCWSTR      szSecondLevel OPTIONAL,
        OUT PHANDLE     phOutKey
        )
/*++

Routine Description:

    Opens a subkey under a specified registry key handle, creating that
    subkey if necessary.  Up to two subkeys (ie: two levels deep) can
    be specified by specifying both the szFirstLevel and szSecondLevel
    arguments.

Arguments:

    hObjectKeyBase - specifies a pre-opened registry handle to the
        base registry key under which the specified szFirstLevel subkey
        will be opened/created.  This registry handle must be opened
        for write access, or else subkey creation will fail.

    szFirstLevel - specifies the first level subkey to open/create.

    szSecondLevel - optionally specifies the second subkey to open/create.

    phOutKey - pointer that will receive the opened registry key handle
        on successful execution of this function.  This handle must be
        closed by the caller when its use is no longer required.

Return Value:

    Returns STATUS_SUCCESS on successful opening of the requested key.
    Otherwise returns a status code indicating the nature of the failure.

--*/
{
    NTSTATUS Status;
    UNICODE_STRING SubkeyName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE hKeyFirstLevel, hKeySecondLevel;


    ASSERT(phOutKey != NULL && szFirstLevel != NULL);

    //
    // Open a handle to the "szFirstLevel" subkey,
    // creating it if needed.
    //
    RtlInitUnicodeString(&SubkeyName, szFirstLevel);
    InitializeObjectAttributes(&ObjectAttributes,
          &SubkeyName,
          OBJ_CASE_INSENSITIVE,
          hObjectKeyBase,
          NULL
          );
    Status = NtCreateKey(&hKeyFirstLevel, KEY_WRITE,
                         &ObjectAttributes, 0, NULL,
                         g_dwKeyOptions, NULL);
    if (!NT_SUCCESS(Status)) return Status;


    //
    // Open a handle to the "szFirstLevel\szSecondLevel"
    // subkey, creating it if needed.
    //
    if (ARGUMENT_PRESENT(szSecondLevel)) {
        RtlInitUnicodeString(&SubkeyName, szSecondLevel);
        InitializeObjectAttributes(&ObjectAttributes,
              &SubkeyName,
              OBJ_CASE_INSENSITIVE,
              hKeyFirstLevel,
              NULL
              );
        Status = NtCreateKey(&hKeySecondLevel,
                (KEY_WRITE & ~KEY_CREATE_SUB_KEY),
                &ObjectAttributes, 0,
                NULL, g_dwKeyOptions, NULL);
        NtClose(hKeyFirstLevel);
        if (!NT_SUCCESS(Status)) return Status;
    }
    else {
        hKeySecondLevel = hKeyFirstLevel;
    }

    *phOutKey = hKeySecondLevel;
    return STATUS_SUCCESS;
}


NTSTATUS NTAPI
SaferpSetRegistryHelper(
        IN HANDLE       hObjectKeyBase,
        IN LPCWSTR      szFirstLevel,
        IN LPCWSTR      szSecondLevel OPTIONAL,
        IN LPCWSTR      szValueName,
        IN DWORD        dwRegType,
        IN LPVOID       lpDataBuffer,
        IN DWORD        dwDataBufferSize
        )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS Status;
    HKEY hKeySecondLevel;
    UNICODE_STRING ValueName;


    //
    // Open a handle to the correct subkey.
    //
    Status = SaferpCreateSecondLevelKey(
                    hObjectKeyBase,
                    szFirstLevel,
                    szSecondLevel,
                    &hKeySecondLevel
                    );
    if (!NT_SUCCESS(Status)) return Status;


    //
    // Write the new value to "szValueName"
    //
    RtlInitUnicodeString(&ValueName, szValueName);
    Status = NtSetValueKey(hKeySecondLevel,
            &ValueName, 0, dwRegType,
            (LPBYTE) lpDataBuffer, dwDataBufferSize);
    NtClose(hKeySecondLevel);
    return Status;
}




#ifdef ALLOW_FULL_WINSAFER
NTSTATUS NTAPI
SaferpClearRegistryListHelper(
        IN HANDLE       hObjectKeyBase,
        IN LPCWSTR      szValueCountName,
        IN LPCWSTR      szPrefixName
        )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS Status;
    BOOLEAN bCompletePass;
    BYTE LocalBuffer[256];
    ULONG ulKeyInfoSize = sizeof(LocalBuffer);
    PKEY_VALUE_BASIC_INFORMATION pKeyInfo =
            (PKEY_VALUE_BASIC_INFORMATION) LocalBuffer;
    ULONG ulKeyIndex, ulSizeUsed;


    //
    // Start iterating through all of the values under this subkey and
    // see if there are any values that match the prefix that we are
    // supposed to delete.  If we find something we should delete, then
    // we do that, but we continue iterating with the expectation that
    // the enumeration values might possibly change when we deleted.
    // So we will keep looping until we are able to enumerate completely
    // through without finding something to delete.
    //
    ulKeyIndex = 0;
    bCompletePass = TRUE;
    for (;;)
    {
        //
        // Determine the next value name under this key.
        //
        Status = NtEnumerateValueKey(hObjectKeyBase,
                                    ulKeyIndex,
                                    KeyValueBasicInformation,
                                    pKeyInfo,
                                    ulKeyInfoSize,
                                    &ulSizeUsed);
        if (!NT_SUCCESS(Status))
        {
            if (Status == STATUS_BUFFER_TOO_SMALL) {
                // Buffer is too small, so we need to enlarge.
                ASSERT(ulSizeUsed > ulKeyInfoSize);
                if (pKeyInfo != (PKEY_VALUE_BASIC_INFORMATION) LocalBuffer) {
                    RtlFreeHeap(RtlProcessHeap(), 0, pKeyInfo);
                }

                ulKeyInfoSize = ulSizeUsed;
                pKeyInfo = (PKEY_VALUE_BASIC_INFORMATION )
                        RtlAllocateHeap(RtlProcessHeap(), 0, ulKeyInfoSize);
                if (!pKeyInfo) {
                    Status = STATUS_NO_MEMORY;
                    goto ExitHandler;
                }
                continue;
            }
            else if (Status == STATUS_NO_MORE_ENTRIES) {
                // All done enumerating.
                if (bCompletePass) {
                    // We just finished a complete pass through without any
                    // deletions so we really know that we're done now.
                    break;
                } else {
                    // We haven't yet completed a full pass without hitting
                    // any deletions so we must try again, since the value
                    // enumerations might have changed at least once.
                    bCompletePass = TRUE;
                    ulKeyIndex = 0;
                    continue;
                }
            }
            else {
                // All other errors get literally returned.
                // This is especially yucky if this error occurred partially
                // through our attempt to delete everything.
                goto ExitHandler;
            }
        }


        //
        // If this value is something that we need to delete,
        // then delete it now and then restart the enumeration.
        //
        if (_wcsnicmp(pKeyInfo->Name, szPrefixName,
                            wcslen(szPrefixName)) == 0 ||
            _wcsicmp(pKeyInfo->Name, szValueCountName) == 0)
        {
            UNICODE_STRING ValueName;

            bCompletePass = FALSE;
            ValueName.Buffer = pKeyInfo->Name;
            ValueName.MaximumLength = ValueName.Length =
                pKeyInfo->NameLength;
            ASSERT(ValueName.Length == sizeof(WCHAR) * wcslen(ValueName.Buffer));
            Status = NtDeleteValueKey(hObjectKeyBase, &ValueName);
            if (!NT_SUCCESS(Status)) {
                // Oh yuck, we got an error deleting.  This is especially
                // yucky if this error occurred partially through our
                // attempt to delete everything.
                goto ExitHandler;
            }
            continue;
        }
        ulKeyIndex++;
    }
    Status = STATUS_SUCCESS;


ExitHandler:
    if (pKeyInfo != (PKEY_VALUE_BASIC_INFORMATION) LocalBuffer) {
        RtlFreeHeap(RtlProcessHeap(), 0, pKeyInfo);
    }
    return Status;
}
#endif // ALLOW_FULL_WINSAFER




#ifdef ALLOW_FULL_WINSAFER
NTSTATUS NTAPI
SaferpSetListOfSids(
            IN HKEY             hKeyBase,
            IN LPCWSTR          szFirstLevel,
            IN LPCWSTR          szSecondLevel OPTIONAL,
            IN LPCWSTR          szValueCountName,
            IN LPCWSTR          szPrefixName,
            IN PTOKEN_GROUPS    pTokenGroups,
            IN BOOLEAN          bAllowWildcardSids
            )
/*++

Routine Description:

Arguments:

Return Value:

--*/
//BLACKCOMB TODO: This really needs to take a dwInBufferSize argument so that
//      the size of the pTokenGroups structure can be verified.
{
    NTSTATUS Status;
    HKEY hSidsToDisable;
    UNICODE_STRING ValueName;
    DWORD Index;


    //
    // First verify the SIDs and that the Attributes field
    // of all of the SIDs are zero.
    //
    for (Index = 0; Index < pTokenGroups->GroupCount; Index++)
    {
        if (!RtlValidSid(pTokenGroups->Groups[Index].Sid))
            return STATUS_INVALID_SID;

        if (pTokenGroups->Groups[Index].Attributes != 0)
        {
            if (bAllowWildcardSids) {
//BLACKCOMB TODO: handle wildcard sids differently?
                if ((pTokenGroups->Groups[Index].Attributes >> 24) != '*' &&
                    (pTokenGroups->Groups[Index].Attributes & 0x0000FFFF) >
                        ((PISID)pTokenGroups->Groups[Index].Sid)->SubAuthorityCount)
                    return STATUS_INVALID_SID;
            }
            else
                return STATUS_INVALID_SID;
        }
    }


    //
    // Open a handle to the correct subkey.
    //
    Status = SaferpCreateSecondLevelKey(
                    hKeyBase,
                    szFirstLevel,
                    szSecondLevel,
                    &hSidsToDisable);
    if (!NT_SUCCESS(Status)) goto ExitHandler2;


    //
    // Clear out all old values under the subkey.
    //
    Status = SaferpClearRegistryListHelper(
                    hSidsToDisable,
                    szValueCountName,
                    szPrefixName);
    if (!NT_SUCCESS(Status)) {
        // Bad luck!  Possibly left in incomplete state!
        NtClose(hSidsToDisable);
        goto ExitHandler2;
    }


    //
    // Now add all of the new ones we're supposed to add.
    //
    RtlInitUnicodeString(&ValueName, szValueCountName);
    Status = NtSetValueKey(hSidsToDisable,
            &ValueName, 0, REG_DWORD,
            (LPBYTE) pTokenGroups->GroupCount, sizeof(DWORD));
    if (!NT_SUCCESS(Status)) {
        // Bad luck!  Possibly left in incomplete state!
        NtClose(hSidsToDisable);
        goto ExitHandler2;
    }
    for (Index = 0; Index < pTokenGroups->GroupCount; Index++)
    {
        WCHAR ValueNameBuffer[20];
        UNICODE_STRING UnicodeStringSid;

        wsprintfW(ValueNameBuffer, L"%S%d", szPrefixName, Index);
        RtlInitUnicodeString(&ValueName, ValueNameBuffer);

//BLACKCOMB TODO: wildcard sids not yet supported
        if (bAllowWildcardSids)
            Status = xxxxx;
        else
            Status = RtlConvertSidToUnicodeString( &UnicodeStringSid,
                    pTokenGroups->Groups[Index].Sid, TRUE );
        if (!NT_SUCCESS(Status))
        {
            // Bad luck!  Possibly left in incomplete state!
            NtClose(hSidsToDisable);
            goto ExitHandler2;
        }

        Status = NtSetValueKey(hSidsToDisable,
            &ValueName, 0, REG_SZ,
            (LPBYTE) UnicodeStringSid.Buffer,
            UnicodeStringSid.Length + sizeof(UNICODE_NULL));

        RtlFreeUnicodeString( &UnicodeStringSid );

        if (!NT_SUCCESS(Status)) {
            // Bad luck!  Possibly left in incomplete state!
            NtClose(hSidsToDisable);
            goto ExitHandler2;
        }
    }
    NtClose(hSidsToDisable);
    return STATUS_SUCCESS;

ExitHandler2:
    return Status;
}
#endif // ALLOW_FULL_WINSAFER


NTSTATUS NTAPI
SaferpDeleteSingleIdentificationGuid(
        IN PAUTHZLEVELTABLERECORD     pLevelRecord,
        IN PAUTHZIDENTSTABLERECORD  pIdentRecord)
/*++

Routine Description:

    This API allows the caller to delete an existing Code Identifier.
    If the GUID exists it will be deleted from both the persisted
    registry store and the in-process identity cache.

Arguments:

    pLevelRecord - the level to which the identity belongs.

    pIdentRecord - points to the identifier record to delete.

Return Value:

    Returns STATUS_SUCCESS on successful operation.

--*/
{
    NTSTATUS Status;
    WCHAR szPathBuffer[MAX_PATH];
    UNICODE_STRING UnicodePath;
    HANDLE hKeyIdentity;
    LPCWSTR szIdentityType;


    //
    // Verify our input arguments.
    //
    if (!ARGUMENT_PRESENT(pIdentRecord) ||
        !ARGUMENT_PRESENT(pLevelRecord)) {
        // Specified a NULL buffer pointer.
        Status = STATUS_ACCESS_VIOLATION;
        goto ExitHandler;
    }


    //
    // Ensure that all of the GUIDs supplied by the user represent
    // Code Identities that exist within this Safer Level.
    //
    if (pIdentRecord->dwLevelId != pLevelRecord->dwLevelId) {
        // One of the Identifier GUIDs specified does
        // not actually exist.
        Status = STATUS_NOT_FOUND;
        goto ExitHandler;
    }


    //
    // Delete the Code Identity from the registry first.
    //
    switch (pIdentRecord->dwIdentityType) {
        case SaferIdentityTypeImageName:
            szIdentityType = SAFER_PATHS_REGSUBKEY;
            break;
        case SaferIdentityTypeImageHash:
            szIdentityType = SAFER_HASHMD5_REGSUBKEY;
            break;
        case SaferIdentityTypeUrlZone:
            szIdentityType = SAFER_SOURCEURL_REGSUBKEY;
            break;
        default:
            Status = STATUS_NOT_FOUND;
            goto ExitHandler;
    }
    RtlInitEmptyUnicodeString(
            &UnicodePath, szPathBuffer, sizeof(szPathBuffer));
    Status = CodeAuthzpFormatIdentityKeyPath(
            pIdentRecord->dwLevelId,
            szIdentityType,
            &pIdentRecord->IdentGuid,
            &UnicodePath);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler;
    }
    Status = CodeAuthzpOpenPolicyRootKey(
            pIdentRecord->dwScopeId,
            g_hKeyCustomRoot,
            szPathBuffer,
            KEY_READ | DELETE,
            FALSE, &hKeyIdentity);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler;
    }
    Status = CodeAuthzpDeleteKeyRecursively(hKeyIdentity, NULL);
    NtClose(hKeyIdentity);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler;
    }


    //
    // Delete the record from the cached table.
    //
    RtlDeleteElementGenericTable(
            &g_CodeIdentitiesTable,
            pIdentRecord);

    Status = STATUS_SUCCESS;


ExitHandler:
    return Status;
}


NTSTATUS NTAPI
SaferpSetSingleIdentificationPath(
        IN BOOLEAN bAllowCreation,
        IN OUT PAUTHZIDENTSTABLERECORD pIdentRecord,
        IN PSAFER_PATHNAME_IDENTIFICATION pIdentChanges,
        IN BOOL UpdateCache
        )
/*++

Routine Description:

    Updates the registry and the local Identification table cache
    with new properties about a ImagePath Code Identifier.

Arguments:

    bAllowCreation - indicates if the modification of this record has
        the potential of being the initial creation of this record.
        If this is false and the corresponding key location within the
        registry does not already exist, then this function call
        will fail.

    pIdentRecord - the cached code identity record that should be
        updated with new values.  This argument must always be supplied,
        even if the Code Identity is being created for the first time
        (in which case, this argument should be the new record that
        the caller has just inserted into the cached idents table).

    pIdentChanges - the input structure containing the new modifications
        that should be made to the specified Code Identity.

    UpdateCache - When FALSE, this is a default rule being created and does
        not need cache updation.

Return Value:

    Return STATUS_SUCCESS on success completion, or another error
    status code indicating the nature of the failure.

--*/
{
    const static UNICODE_STRING UnicodeLastModified =
            RTL_CONSTANT_STRING(SAFER_IDS_LASTMODIFIED_REGVALUE);
    const static UNICODE_STRING UnicodeDescription =
            RTL_CONSTANT_STRING(SAFER_IDS_DESCRIPTION_REGVALUE);
    const static UNICODE_STRING UnicodeSaferFlags =
            RTL_CONSTANT_STRING(SAFER_IDS_SAFERFLAGS_REGVALUE);
    const static UNICODE_STRING UnicodeItemData =
            RTL_CONSTANT_STRING(SAFER_IDS_ITEMDATA_REGVALUE);
    NTSTATUS Status;
    HANDLE hKeyIdentity = NULL;
    UNICODE_STRING UnicodeTemp;
    UNICODE_STRING UnicodeNewDescription;
    UNICODE_STRING UnicodeNewImagePath;
    WCHAR szPathBuffer[MAX_PATH];
    DWORD dwSaferFlags;
    FILETIME CurrentTime;
    BOOLEAN bExpandVars;


    //
    // Verify our arguments.  These things should have been ensured
    // by our caller already, so we only assert them here.
    //
    ASSERT(ARGUMENT_PRESENT(pIdentRecord) &&
           ARGUMENT_PRESENT(pIdentChanges) &&
           pIdentChanges->header.dwIdentificationType == SaferIdentityTypeImageName &&
           IsEqualGUID(&pIdentChanges->header.IdentificationGuid, &pIdentRecord->IdentGuid));


    //
    // Verify that the existing type matches the new type.
    // Cannot change identity type once it has been created.
    //
    if (pIdentRecord->dwIdentityType != SaferIdentityTypeImageName) {
        Status = STATUS_INVALID_PARAMETER;
        goto ExitHandler;
    }


    //
    // Verify that the string arguments are properly terminated.
    // We require that they fit entirely within the input buffer
    // and also have an explicit null terminator.
    //
    RtlInitUnicodeString(&UnicodeNewImagePath, pIdentChanges->ImageName);
    RtlInitUnicodeString(&UnicodeNewDescription, pIdentChanges->Description);
    if (UnicodeNewDescription.Length >=
                SAFER_MAX_DESCRIPTION_SIZE * sizeof(WCHAR) ||
        UnicodeNewImagePath.Length >= MAX_PATH * sizeof(WCHAR) ||
        UnicodeNewImagePath.Length == 0) {
        // One of these buffers was not NULL terminated.
        Status = STATUS_INVALID_PARAMETER;
        goto ExitHandler;
    }



    //
    // Open a registry handle to the Code Identity.
    //
    RtlInitEmptyUnicodeString(
            &UnicodeTemp, szPathBuffer, sizeof(szPathBuffer));
    Status = CodeAuthzpFormatIdentityKeyPath(
            pIdentRecord->dwLevelId,
            SAFER_PATHS_REGSUBKEY,
            &pIdentRecord->IdentGuid,
            &UnicodeTemp);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler;
    }
    Status = CodeAuthzpOpenPolicyRootKey(
            pIdentRecord->dwScopeId,
            g_hKeyCustomRoot,
            szPathBuffer,
            KEY_READ | KEY_WRITE,
            bAllowCreation,
            &hKeyIdentity);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler;
    }



    //
    // Set the "Last Modified" attribute in the registry.
    //
    GetSystemTimeAsFileTime(&CurrentTime);
    ASSERT(sizeof(DWORD) * 2 == sizeof(FILETIME));
    Status = NtSetValueKey(
                hKeyIdentity,
                (PUNICODE_STRING) &UnicodeLastModified,
                0, REG_QWORD, (LPBYTE) &CurrentTime,
                sizeof(DWORD) * 2);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler2;
    }

    //
    // Set the "Description" attribute in the registry.
    //
    Status = NtSetValueKey(
                hKeyIdentity,
                (PUNICODE_STRING) &UnicodeDescription,
                0, REG_SZ, (LPBYTE) UnicodeNewDescription.Buffer,
                UnicodeNewDescription.MaximumLength);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler2;
    }

    //
    // Set the "SaferFlags" attribute in the registry (and in our cache).
    //
    dwSaferFlags = pIdentChanges->dwSaferFlags;
    Status = NtSetValueKey(
                hKeyIdentity,
                (PUNICODE_STRING) &UnicodeSaferFlags,
                0, REG_DWORD, (LPBYTE) &dwSaferFlags, sizeof(DWORD));
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler2;
    }

    //
    // Set the "image pathname" attribute in the registry (and our cache).
    //
    bExpandVars = (wcschr(pIdentChanges->ImageName, L'%') != NULL ? TRUE : FALSE);
    Status = NtSetValueKey(
                hKeyIdentity,
                (PUNICODE_STRING) &UnicodeItemData,
                0, (bExpandVars ? REG_EXPAND_SZ : REG_SZ),
                (LPBYTE) UnicodeNewImagePath.Buffer,
                UnicodeNewImagePath.MaximumLength );
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler2;
    }
    if (UpdateCache) {
        RtlFreeUnicodeString(&pIdentRecord->ImageNameInfo.ImagePath);
        Status = RtlDuplicateUnicodeString(
                        RTL_DUPLICATE_UNICODE_STRING_NULL_TERMINATE,
                        &UnicodeNewImagePath,
                        &pIdentRecord->ImageNameInfo.ImagePath);
        if (!NT_SUCCESS(Status)) {
            goto ExitHandler2;
        }
        pIdentRecord->ImageNameInfo.bExpandVars = bExpandVars;
        pIdentRecord->ImageNameInfo.dwSaferFlags = dwSaferFlags;
    }

    Status = STATUS_SUCCESS;


ExitHandler2:
    NtClose(hKeyIdentity);

ExitHandler:
    return Status;
}


NTSTATUS NTAPI
SaferpSetSingleIdentificationHash(
        IN BOOLEAN bAllowCreation,
        IN OUT PAUTHZIDENTSTABLERECORD pIdentRecord,
        IN PSAFER_HASH_IDENTIFICATION pIdentChanges
        )
/*++

Routine Description:

    Updates the registry and the local Identification table cache
    with new properties about a hash Code Identifier.

Arguments:

    bAllowCreation - indicates if the modification of this record has
        the potential of being the initial creation of this record.
        If this is false and the corresponding key location within the
        registry does not already exist, then this function call
        will fail.

    pIdentRecord - the cached code identity record that should be
        updated with new values.  This argument must always be supplied,
        even if the Code Identity is being created for the first time
        (in which case, this argument should be the new record that
        the caller has just inserted into the cached idents table).

    pIdentChanges - the input structure containing the new modifications
        that should be made to the specified Code Identity.

Return Value:

    Return STATUS_SUCCESS on success completion, or another error
    status code indicating the nature of the failure.

--*/
{
    const static UNICODE_STRING UnicodeLastModified =
            RTL_CONSTANT_STRING(SAFER_IDS_LASTMODIFIED_REGVALUE);
    const static UNICODE_STRING UnicodeDescription =
            RTL_CONSTANT_STRING(SAFER_IDS_DESCRIPTION_REGVALUE);
    const static UNICODE_STRING UnicodeSaferFlags =
            RTL_CONSTANT_STRING(SAFER_IDS_SAFERFLAGS_REGVALUE);
    const static UNICODE_STRING UnicodeItemData =
            RTL_CONSTANT_STRING(SAFER_IDS_ITEMDATA_REGVALUE);
    const static UNICODE_STRING UnicodeFriendlyName =
            RTL_CONSTANT_STRING(SAFER_IDS_FRIENDLYNAME_REGVALUE);
    const static UNICODE_STRING UnicodeItemSize =
            RTL_CONSTANT_STRING(SAFER_IDS_ITEMSIZE_REGVALUE);
    const static UNICODE_STRING UnicodeHashAlgorithm =
            RTL_CONSTANT_STRING(SAFER_IDS_HASHALG_REGVALUE);

    NTSTATUS Status;
    HANDLE hKeyIdentity = NULL;
    UNICODE_STRING UnicodeTemp;
    UNICODE_STRING UnicodeNewFriendlyName;
    UNICODE_STRING UnicodeNewDescription;
    WCHAR szPathBuffer[MAX_PATH];
    DWORD dwSaferFlags;
    FILETIME CurrentTime;


    //
    // Verify our arguments.  These things should have been ensured
    // by our caller already, so we only assert them here.
    //
    ASSERT(ARGUMENT_PRESENT(pIdentRecord) &&
           ARGUMENT_PRESENT(pIdentChanges) &&
           pIdentChanges->header.dwIdentificationType == SaferIdentityTypeImageHash &&
           pIdentChanges->header.cbStructSize == sizeof(SAFER_HASH_IDENTIFICATION) &&
           IsEqualGUID(&pIdentChanges->header.IdentificationGuid, &pIdentRecord->IdentGuid));


    //
    // Verify that the existing type matches the new type.
    // Cannot change identity type once it has been created.
    //
    if (pIdentRecord->dwIdentityType != SaferIdentityTypeImageHash) {
        Status = STATUS_INVALID_PARAMETER;
        goto ExitHandler;
    }


    //
    // Verify that the string arguments are properly terminated.
    // We require that they fit entirely within the input buffer
    // and also have an explicit null terminator.
    //
    RtlInitUnicodeString(&UnicodeNewDescription, pIdentChanges->Description);
    RtlInitUnicodeString(&UnicodeNewFriendlyName, pIdentChanges->FriendlyName);
    if (UnicodeNewDescription.Length >=
                SAFER_MAX_DESCRIPTION_SIZE * sizeof(WCHAR) ||
        UnicodeNewFriendlyName.Length >=
                SAFER_MAX_FRIENDLYNAME_SIZE * sizeof(WCHAR) ||
        pIdentChanges->HashSize > SAFER_MAX_HASH_SIZE)
    {
        // One of these buffers was not NULL terminated or
        // the hash size specified was invalid.
        Status = STATUS_INVALID_PARAMETER;
        goto ExitHandler;
    }
    if ((pIdentChanges->HashAlgorithm & ALG_CLASS_ALL) != ALG_CLASS_HASH ||
        pIdentChanges->HashSize < 1) {
        // The hash algorithm method was an invalid type, or
        // a zero-length hash was supplied.
        Status = STATUS_INVALID_PARAMETER;
        goto ExitHandler;
    }


    //
    // Open a registry handle to the Code Identity.
    //
    RtlInitEmptyUnicodeString(
            &UnicodeTemp, szPathBuffer, sizeof(szPathBuffer));
    Status = CodeAuthzpFormatIdentityKeyPath(
            pIdentRecord->dwLevelId,
            SAFER_HASHMD5_REGSUBKEY,
            &pIdentRecord->IdentGuid,
            &UnicodeTemp);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler;
    }
    Status = CodeAuthzpOpenPolicyRootKey(
            pIdentRecord->dwScopeId,
            g_hKeyCustomRoot,
            szPathBuffer,
            KEY_READ | KEY_WRITE,
            bAllowCreation,
            &hKeyIdentity);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler;
    }


    //
    // Set the "Last Modified" attribute in the registry.
    //
    GetSystemTimeAsFileTime(&CurrentTime);
    ASSERT(sizeof(DWORD) * 2 == sizeof(FILETIME));
    Status = NtSetValueKey(
                hKeyIdentity,
                (PUNICODE_STRING) &UnicodeLastModified, 0,
                REG_QWORD, (LPBYTE) &CurrentTime,
                sizeof(DWORD) * 2);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler2;
    }

    //
    // Set the "Description" attribute in the registry.
    //
    Status = NtSetValueKey(
                hKeyIdentity,
                (PUNICODE_STRING) &UnicodeDescription,
                0, REG_SZ, (LPBYTE) UnicodeNewDescription.Buffer,
                UnicodeNewDescription.MaximumLength);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler2;
    }

    //
    // Set the "FriendlyName" attribute in the registry.
    //
    Status = NtSetValueKey(
                hKeyIdentity,
                (PUNICODE_STRING) &UnicodeFriendlyName,
                0, REG_SZ, (LPBYTE) UnicodeNewFriendlyName.Buffer,
                UnicodeNewFriendlyName.MaximumLength);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler2;
    }

    //
    // Set the "SaferFlags" attribute in the registry (and in our cache).
    //
    #ifdef SAFER_SAFERFLAGS_ONLY_EXES
    dwSaferFlags = (pIdentChanges->dwSaferFlags &
            ~SAFER_SAFERFLAGS_ONLY_EXES);
    #else
    dwSaferFlags = pIdentChanges->dwSaferFlags;
    #endif
    Status = NtSetValueKey(
                hKeyIdentity,
                (PUNICODE_STRING) &UnicodeSaferFlags,
                0, REG_DWORD, (LPBYTE) &dwSaferFlags, sizeof(DWORD));
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler2;
    }
    pIdentRecord->ImageNameInfo.dwSaferFlags = dwSaferFlags;


    //
    // Set the "image size" attribute in the registry (and our cache).
    //
    Status = NtSetValueKey(
                hKeyIdentity,
                (PUNICODE_STRING) &UnicodeItemSize,
                0, REG_QWORD, (LPBYTE) &pIdentChanges->ImageSize.QuadPart,
                sizeof(DWORD) * 2);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler2;
    }
    pIdentRecord->ImageHashInfo.ImageSize.QuadPart =
        pIdentChanges->ImageSize.QuadPart;


    //
    // Set the "image hash" attribute in the registry (and our cache).
    //
    Status = NtSetValueKey(
                hKeyIdentity,
                (PUNICODE_STRING) &UnicodeItemData,
                0, REG_BINARY, (LPBYTE) pIdentChanges->ImageHash,
                pIdentChanges->HashSize);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler2;
    }
    pIdentRecord->ImageHashInfo.HashSize =
        pIdentChanges->HashSize;
    RtlCopyMemory(&pIdentRecord->ImageHashInfo.ImageHash[0],
                  &pIdentChanges->ImageHash[0],
                  pIdentChanges->HashSize);

    //
    // Set the "hash algorithm" attribute in the registry (and our cache).
    //
    Status = NtSetValueKey(
                hKeyIdentity,
                (PUNICODE_STRING) &UnicodeHashAlgorithm,
                0, REG_DWORD, (LPBYTE) &pIdentChanges->HashAlgorithm,
                sizeof(DWORD));
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler2;
    }
    pIdentRecord->ImageHashInfo.HashAlgorithm =
        pIdentChanges->HashAlgorithm;


    Status = STATUS_SUCCESS;


ExitHandler2:
    NtClose(hKeyIdentity);

ExitHandler:
    return Status;
}


NTSTATUS NTAPI
SaferpSetSingleIdentificationZone(
        IN BOOLEAN bAllowCreation,
        IN OUT PAUTHZIDENTSTABLERECORD pIdentRecord,
        IN PSAFER_URLZONE_IDENTIFICATION pIdentChanges
        )
/*++

Routine Description:

    Updates the registry and the local Identification table cache
    with new properties about a URL Zone Code Identifier.

Arguments:

    bAllowCreation - indicates if the modification of this record has
        the potential of being the initial creation of this record.
        If this is false and the corresponding key location within the
        registry does not already exist, then this function call
        will fail.

    pIdentRecord - the cached code identity record that should be
        updated with new values.  This argument must always be supplied,
        even if the Code Identity is being created for the first time
        (in which case, this argument should be the new record that
        the caller has just inserted into the cached idents table).

    pIdentChanges - the input structure containing the new modifications
        that should be made to the specified Code Identity.

Return Value:

    Return STATUS_SUCCESS on success completion, or another error
    status code indicating the nature of the failure.

--*/
{
    const static UNICODE_STRING UnicodeLastModified =
            RTL_CONSTANT_STRING(SAFER_IDS_LASTMODIFIED_REGVALUE);
    const static UNICODE_STRING UnicodeSaferFlags =
            RTL_CONSTANT_STRING(SAFER_IDS_SAFERFLAGS_REGVALUE);
    const static UNICODE_STRING UnicodeItemData =
            RTL_CONSTANT_STRING(SAFER_IDS_ITEMDATA_REGVALUE);

    NTSTATUS Status;
    HANDLE hKeyIdentity = NULL;
    UNICODE_STRING UnicodeTemp;
    WCHAR szPathBuffer[MAX_PATH];
    DWORD dwSaferFlags;
    FILETIME CurrentTime;


    //
    // Verify our arguments.  These things should have been ensured
    // by our caller already, so we only assert them here.
    //
    ASSERT(ARGUMENT_PRESENT(pIdentRecord) &&
           ARGUMENT_PRESENT(pIdentChanges) &&
           pIdentChanges->header.dwIdentificationType == SaferIdentityTypeUrlZone &&
           pIdentChanges->header.cbStructSize == sizeof(SAFER_URLZONE_IDENTIFICATION) &&
           IsEqualGUID(&pIdentChanges->header.IdentificationGuid, &pIdentRecord->IdentGuid));


    //
    // Verify that the existing type matches the new type.
    // Cannot change identity type once it has been created.
    //
    if (pIdentRecord->dwIdentityType != SaferIdentityTypeUrlZone) {
        Status = STATUS_INVALID_PARAMETER;
        goto ExitHandler;
    }


    //
    // Open a registry handle to the Code Identity.
    //
    RtlInitEmptyUnicodeString(
            &UnicodeTemp, szPathBuffer, sizeof(szPathBuffer));
    Status = CodeAuthzpFormatIdentityKeyPath(
            pIdentRecord->dwLevelId,
            SAFER_SOURCEURL_REGSUBKEY,
            &pIdentRecord->IdentGuid,
            &UnicodeTemp);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler;
    }
    Status = CodeAuthzpOpenPolicyRootKey(
            pIdentRecord->dwScopeId,
            g_hKeyCustomRoot,
            szPathBuffer,
            KEY_READ | KEY_WRITE,
            bAllowCreation,
            &hKeyIdentity);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler;
    }



    //
    // Set the "Last Modified" attribute in the registry.
    //
    GetSystemTimeAsFileTime(&CurrentTime);
    ASSERT(sizeof(DWORD) * 2 == sizeof(FILETIME));
    Status = NtSetValueKey(
                hKeyIdentity,
                (PUNICODE_STRING) &UnicodeLastModified,
                0, REG_QWORD, (LPBYTE) &CurrentTime,
                sizeof(DWORD) * 2);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler2;
    }

    //
    // Set the "SaferFlags" attribute in the registry (and in our cache).
    //
    #ifdef SAFER_SAFERFLAGS_ONLY_EXES
    dwSaferFlags = (pIdentChanges->dwSaferFlags &
                    ~SAFER_SAFERFLAGS_ONLY_EXES);
    #else
    dwSaferFlags = pIdentChanges->dwSaferFlags;
    #endif
    Status = NtSetValueKey(
                hKeyIdentity,
                (PUNICODE_STRING) &UnicodeSaferFlags,
                0, REG_DWORD, (LPBYTE) &dwSaferFlags, sizeof(DWORD));
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler2;
    }
    pIdentRecord->ImageNameInfo.dwSaferFlags = dwSaferFlags;


    //
    // Set the "ZoneId" attribute in the registry (and our cache).
    //
    Status = NtSetValueKey(
                hKeyIdentity,
                (PUNICODE_STRING) &UnicodeItemData,
                0, REG_DWORD, (LPBYTE) &pIdentChanges->UrlZoneId,
                sizeof(DWORD));
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler2;
    }
    pIdentRecord->ImageZone.UrlZoneId = pIdentChanges->UrlZoneId;


    Status = STATUS_SUCCESS;


ExitHandler2:
    NtClose(hKeyIdentity);

ExitHandler:
    return Status;
}




NTSTATUS NTAPI
SaferpSetExistingSingleIdentification(
        IN OUT PAUTHZIDENTSTABLERECORD pIdentRecord,
        IN PSAFER_IDENTIFICATION_HEADER pCommon
        )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS Status;


    //
    // Verify our arguments.  These things should have been ensured
    // by our caller already, so we only assert them here.
    //
    ASSERT(ARGUMENT_PRESENT(pIdentRecord) &&
           ARGUMENT_PRESENT(pCommon) &&
           pCommon->cbStructSize >= sizeof(SAFER_IDENTIFICATION_HEADER) &&
           IsEqualGUID(&pCommon->IdentificationGuid, &pIdentRecord->IdentGuid) );



    //
    // Perform the appropriate action depending on the identification
    // data type, including verifying that the structure size matches
    // the size that we are expecting.
    //
    switch (pCommon->dwIdentificationType)
    {
        case SaferIdentityTypeImageName:

            Status = SaferpSetSingleIdentificationPath(
                        FALSE, pIdentRecord,
                        (PSAFER_PATHNAME_IDENTIFICATION) pCommon, TRUE);
            break;

        // --------------------

        case SaferIdentityTypeImageHash:
            if (pCommon->cbStructSize ==
                    sizeof(SAFER_HASH_IDENTIFICATION)) {
                // Request to change and a Unicode structure was given.
                Status = SaferpSetSingleIdentificationHash(
                        FALSE, pIdentRecord,
                        (PSAFER_HASH_IDENTIFICATION) pCommon);

            } else {
                Status = STATUS_INFO_LENGTH_MISMATCH;
            }
            break;

        // --------------------

        case SaferIdentityTypeUrlZone:
            if (pCommon->cbStructSize ==
                    sizeof(SAFER_URLZONE_IDENTIFICATION)) {
                Status = SaferpSetSingleIdentificationZone(
                        FALSE, pIdentRecord,
                        (PSAFER_URLZONE_IDENTIFICATION) pCommon);
            } else {
                Status = STATUS_INFO_LENGTH_MISMATCH;
            }
            break;

        // --------------------

        default:
            Status = STATUS_INVALID_INFO_CLASS;
    }

    return Status;
}





NTSTATUS NTAPI
SaferpCreateNewSingleIdentification(
        IN DWORD dwScopeId,
        IN PAUTHZLEVELTABLERECORD pLevelRecord,
        IN PSAFER_IDENTIFICATION_HEADER pCommon
        )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS Status;
    AUTHZIDENTSTABLERECORD NewIdentRecord;
    PAUTHZIDENTSTABLERECORD pIdentRecord;


    //
    // Verify our arguments.  These things should have been ensured
    // by our caller already, so we only assert them here.
    //
    ASSERT(ARGUMENT_PRESENT(pLevelRecord) &&
           ARGUMENT_PRESENT(pCommon) &&
           pCommon->cbStructSize >= sizeof(SAFER_IDENTIFICATION_HEADER) &&
           !CodeAuthzIdentsLookupByGuid(&g_CodeIdentitiesTable,
                                        &pCommon->IdentificationGuid) );
    if (g_hKeyCustomRoot != NULL) {
        if (dwScopeId != SAFER_SCOPEID_REGISTRY) {
            Status = STATUS_INVALID_PARAMETER_MIX;
            goto ExitHandler;
        }
    } else {
        if (dwScopeId != SAFER_SCOPEID_MACHINE &&
            dwScopeId != SAFER_SCOPEID_USER) {
            Status = STATUS_INVALID_PARAMETER_MIX;
            goto ExitHandler;
        }
        if (dwScopeId == SAFER_SCOPEID_USER && !g_bHonorScopeUser) {
            Status = STATUS_INVALID_PARAMETER_MIX;
            goto ExitHandler;
        }
    }


    //
    // Prepare a new Code Identity structure since we will likely
    // need to insert a new record for the entry that will be created.
    //
    RtlZeroMemory(&NewIdentRecord, sizeof(AUTHZIDENTSTABLERECORD));
    NewIdentRecord.dwIdentityType = pCommon->dwIdentificationType;
    NewIdentRecord.dwLevelId = pLevelRecord->dwLevelId;
    NewIdentRecord.dwScopeId = dwScopeId;
    RtlCopyMemory(&NewIdentRecord.IdentGuid,
                  &pCommon->IdentificationGuid,
                  sizeof(GUID));
    if (IsZeroGUID(&NewIdentRecord.IdentGuid)) {
        Status = STATUS_INVALID_PARAMETER;
        goto ExitHandler;
    }


    //
    // Perform the appropriate action depending on the identification
    // data type, including verifying that the structure size matches
    // the size that we are expecting.
    //
    switch (pCommon->dwIdentificationType)
    {
        // --------------------

        case SaferIdentityTypeImageName:
            RtlInsertElementGenericTable(
                &g_CodeIdentitiesTable,
                (PVOID) &NewIdentRecord,
                sizeof(AUTHZIDENTSTABLERECORD),
                NULL);
            pIdentRecord = CodeAuthzIdentsLookupByGuid(
                &g_CodeIdentitiesTable,
                &pCommon->IdentificationGuid);
            if (!pIdentRecord) {
                Status = STATUS_UNSUCCESSFUL;
                break;
            }
            Status = SaferpSetSingleIdentificationPath(
                TRUE, pIdentRecord,
                (PSAFER_PATHNAME_IDENTIFICATION) pCommon, TRUE);
            if (!NT_SUCCESS(Status)) {
                RtlDeleteElementGenericTable(
                        &g_CodeIdentitiesTable,
                        (PVOID) &NewIdentRecord);
            }
            break;

        // --------------------

        case SaferIdentityTypeImageHash:
            if (pCommon->cbStructSize ==
                    sizeof(SAFER_HASH_IDENTIFICATION)) {

                RtlInsertElementGenericTable(
                    &g_CodeIdentitiesTable,
                    (PVOID) &NewIdentRecord,
                    sizeof(AUTHZIDENTSTABLERECORD),
                    NULL);
                pIdentRecord = CodeAuthzIdentsLookupByGuid(
                    &g_CodeIdentitiesTable,
                    &pCommon->IdentificationGuid);
                if (!pIdentRecord) {
                    Status = STATUS_UNSUCCESSFUL;
                    break;
                }
                Status = SaferpSetSingleIdentificationHash(
                    TRUE, pIdentRecord,
                    (PSAFER_HASH_IDENTIFICATION) pCommon);
                if (!NT_SUCCESS(Status)) {
                    RtlDeleteElementGenericTable(
                            &g_CodeIdentitiesTable,
                            (PVOID) &NewIdentRecord);
                }

            } else {
                Status = STATUS_INFO_LENGTH_MISMATCH;
            }
            break;

        // --------------------

        case SaferIdentityTypeUrlZone:
            if (pCommon->cbStructSize ==
                    sizeof(SAFER_URLZONE_IDENTIFICATION)) {

                RtlInsertElementGenericTable(
                    &g_CodeIdentitiesTable,
                    (PVOID) &NewIdentRecord,
                    sizeof(AUTHZIDENTSTABLERECORD),
                    NULL);
                pIdentRecord = CodeAuthzIdentsLookupByGuid(
                    &g_CodeIdentitiesTable,
                    &pCommon->IdentificationGuid);
                if (!pIdentRecord) {
                    Status = STATUS_UNSUCCESSFUL;
                    break;
                }
                Status = SaferpSetSingleIdentificationZone(
                    TRUE, pIdentRecord,
                    (PSAFER_URLZONE_IDENTIFICATION) pCommon);
                if (!NT_SUCCESS(Status)) {
                    RtlDeleteElementGenericTable(
                            &g_CodeIdentitiesTable,
                            (PVOID) &NewIdentRecord);
                }

            } else {
                Status = STATUS_INFO_LENGTH_MISMATCH;
            }
            break;

        // --------------------

        default:
            Status = STATUS_INVALID_INFO_CLASS;
            break;
    }

ExitHandler:
    return Status;
}


NTSTATUS NTAPI
CodeAuthzpSetAuthzLevelInfo(
        IN SAFER_LEVEL_HANDLE                      LevelHandle,
        IN SAFER_OBJECT_INFO_CLASS     dwInfoType,
        IN LPVOID                           lpQueryBuffer,
        IN DWORD                            dwInBufferSize
        )
/*++

Routine Description:

    Allows the user to modify various pieces of information about a
    given WinSafer Level.

Arguments:

    LevelHandle - the handle to the authorization object to evaluate.

    dwInfoType - specifies the type of information being modified.

    lpQueryBuffer - pointer to a user-supplied memory buffer that
        contains the new data for the item being modified.

    dwInBufferSize - specifies the size of the user's memory block.
        For string arguments, this size includes the terminating null.

Return Value:

    Returns STATUS_SUCCESS on success.

--*/
{
    NTSTATUS Status;
    PAUTHZLEVELHANDLESTRUCT pLevelStruct;
    PAUTHZLEVELTABLERECORD pLevelRecord;
    DWORD dwHandleScopeId;
    BOOLEAN bNeedLevelRegKey;
    UNICODE_STRING ValueName, UnicodeRegistrySuffix;
    HANDLE hRegLevelBase;


    //
    // Obtain a pointer to the authorization object structure
    //
    Status = CodeAuthzHandleToLevelStruct(LevelHandle, &pLevelStruct);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler;
    }
    ASSERT(pLevelStruct != NULL);
    pLevelRecord = CodeAuthzLevelObjpLookupByLevelId(
            &g_CodeLevelObjTable, pLevelStruct->dwLevelId);
    if (!pLevelRecord) {
        Status = STATUS_INVALID_HANDLE;
        goto ExitHandler;
    }
    dwHandleScopeId = pLevelStruct->dwScopeId;


    //
    // Determine if we need to open a registry handle to the Level key.
    //
    bNeedLevelRegKey = FALSE;
    switch (dwInfoType)
    {
        case SaferObjectLevelId:              // DWORD
        case SaferObjectScopeId:              // DWORD
        case SaferObjectBuiltin:              // DWORD boolean
            // These information classes cannot be altered with this API.
            Status = STATUS_INVALID_INFO_CLASS;
            goto ExitHandler;

        case SaferObjectFriendlyName:         // LPCTSTR
        case SaferObjectDescription:          // LPCTSTR
            if (pLevelRecord->Builtin) {
                // Don't allow built-in Levels to be modified at all.
                Status = STATUS_ACCESS_DENIED;
                goto ExitHandler;
            }
            // All of these classes need to access the Level key.
            bNeedLevelRegKey = TRUE;
            break;

#ifdef ALLOW_FULL_WINSAFER
        case SaferObjectDisallowed:               // DWORD boolean
        case SaferObjectDisableMaxPrivilege:      // DWORD boolean
        case SaferObjectInvertDeletedPrivileges:  // DWORD boolean
        case SaferObjectDefaultOwner:             // TOKEN_OWNER
        case SaferObjectDeletedPrivileges:        // TOKEN_PRIVILEGES
        case SaferObjectSidsToDisable:            // TOKEN_GROUPS
        case SaferObjectRestrictedSidsInverted:   // TOKEN_GROUPS
        case SaferObjectRestrictedSidsAdded:      // TOKEN_GROUPS
            if (pLevelRecord->Builtin) {
                // Don't allow built-in Levels to be modified at all.
                Status = STATUS_ACCESS_DENIED;
                goto ExitHandler;
            }
            // All of these classes need to access the Level key.
            bNeedLevelRegKey = TRUE;
            break;
#endif

        case SaferObjectAllIdentificationGuids:
            Status = STATUS_INVALID_INFO_CLASS;
            goto ExitHandler;

        case SaferObjectSingleIdentification:
            // These only modify Code Identity keys.
            break;

        default:
            Status = STATUS_INVALID_INFO_CLASS;
            goto ExitHandler;
    }



    //
    // Open the registry handle to where this Level is stored.
    //
    if (bNeedLevelRegKey) {
        WCHAR szRegistrySuffix[MAX_PATH];

        RtlInitEmptyUnicodeString(
                    &UnicodeRegistrySuffix,
                    szRegistrySuffix,
                    sizeof(szRegistrySuffix));
        Status = CodeAuthzpFormatLevelKeyPath(
                    pLevelRecord->dwLevelId,
                    &UnicodeRegistrySuffix);
        if (!NT_SUCCESS(Status)) {
            goto ExitHandler;
        }
        Status = CodeAuthzpOpenPolicyRootKey(
                    g_hKeyCustomRoot != NULL ?
                            SAFER_SCOPEID_REGISTRY : SAFER_SCOPEID_MACHINE,
                    g_hKeyCustomRoot, szRegistrySuffix,
                    KEY_WRITE, TRUE, &hRegLevelBase);
        if (!NT_SUCCESS(Status)) {
            goto ExitHandler;
        }
    } else {
        hRegLevelBase = NULL;
    }



    //
    // Otherwise perform the actual "Set" operation.
    //
    switch (dwInfoType)
    {
        case SaferObjectFriendlyName:         // LPCTSTR
            ASSERT(hRegLevelBase != NULL);
            RtlInitUnicodeString(&ValueName,
                                 SAFER_OBJFRIENDLYNAME_REGVALUEW);
            Status = NtSetValueKey(hRegLevelBase,
                    &ValueName, 0, REG_SZ,
                    (LPBYTE) lpQueryBuffer, dwInBufferSize);
            if (NT_SUCCESS(Status)) {
                if (pLevelRecord->UnicodeFriendlyName.Buffer != NULL) {
                    RtlFreeUnicodeString(&pLevelRecord->UnicodeFriendlyName);
                }
                Status = RtlCreateUnicodeString(
                        &pLevelRecord->UnicodeFriendlyName,
                        (LPWSTR) lpQueryBuffer);
                if (!NT_SUCCESS(Status)) {
                    pLevelRecord->UnicodeFriendlyName.Buffer = NULL;
                }
            }
            goto ExitHandler2;


        case SaferObjectDescription:          // LPCTSTR
            ASSERT(hRegLevelBase != NULL);
            RtlInitUnicodeString(&ValueName,
                                 SAFER_OBJDESCRIPTION_REGVALUEW);
            Status = NtSetValueKey(hRegLevelBase,
                    &ValueName, 0, REG_SZ,
                    (LPBYTE) lpQueryBuffer, dwInBufferSize);
            if (NT_SUCCESS(Status)) {
                if (pLevelRecord->UnicodeDescription.Buffer != NULL) {
                    RtlFreeUnicodeString(&pLevelRecord->UnicodeDescription);
                }
                Status = RtlCreateUnicodeString(
                        &pLevelRecord->UnicodeDescription,
                        (LPWSTR) lpQueryBuffer);
                if (!NT_SUCCESS(Status)) {
                    pLevelRecord->UnicodeDescription.Buffer = NULL;
                }
            }
            goto ExitHandler2;


#ifdef ALLOW_FULL_WINSAFER
        case SaferObjectDisallowed:               // DWORD boolean
            ASSERT(hRegLevelBase != NULL);
            if (!ARGUMENT_PRESENT(lpQueryBuffer) ||
                    dwInBufferSize != sizeof(DWORD)) {
                Status = STATUS_INVALID_PARAMETER;
                goto ExitHandler2;
            }
            RtlInitUnicodeString(&ValueName, SAFER_OBJDISALLOW_REGVALUE);
            Status = NtSetValueKey(hRegLevelBase,
                    &ValueName, 0, REG_DWORD,
                    (LPBYTE) lpQueryBuffer, dwInBufferSize);
            if (NT_SUCCESS(Status)) {
                goto ExitHandler2;
            } else {
                pLevelRecord->DisallowExecution =
                    ( *((LPDWORD) lpQueryBuffer) != 0 ? TRUE : FALSE );
            }
            //BLACKCOMB TODO: update cached pLevelRecord on success
            break;

        case SaferObjectDisableMaxPrivilege:      // DWORD boolean
            ASSERT(hRegLevelBase != NULL);

            // Make sure the argument is the correct size.
            if (!ARGUMENT_PRESENT(lpQueryBuffer) ||
                    dwInBufferSize != sizeof(DWORD)) {
                Status = STATUS_INVALID_PARAMETER;
                goto ExitHandler2;
            }

            // Actually write the value to the correct place.
            Status = SaferpSetRegistryHelper(
                    hRegLevelBase,
                    L"Restrictions",
                    L"PrivsToRemove",
                    L"DisableMaxPrivilege",
                    REG_DWORD,
                    lpQueryBuffer,
                    dwInBufferSize);
            if (!NT_SUCCESS(Status)) goto ExitHandler2;
            //BLACKCOMB TODO: update cached pLevelRecord on success
            break;

        case SaferObjectInvertDeletedPrivileges:  // DWORD boolean
            ASSERT(hRegLevelBase != NULL);

            // Make sure the argument is the correct size.
            if (!ARGUMENT_PRESENT(lpQueryBuffer) ||
                    dwInBufferSize != sizeof(DWORD)) {
                Status = STATUS_INVALID_PARAMETER;
                goto ExitHandler2;
            }

            // Actually write the value to the correct place.
            Status = SaferpSetRegistryHelper(
                    hRegLevelBase,
                    L"Restrictions",
                    L"PrivsToRemove",
                    L"InvertPrivs",
                    REG_DWORD,
                    lpQueryBuffer,
                    dwInBufferSize);
            if (!NT_SUCCESS(Status)) goto ExitHandler2;
            //BLACKCOMB TODO: update cached pLevelRecord on success
            break;

        case SaferObjectDefaultOwner:             // TOKEN_OWNER
        {
            BOOLEAN AllocatedStringSid = FALSE;
            UNICODE_STRING UnicodeStringSid;
            PTOKEN_OWNER pTokenOwner = (PTOKEN_OWNER) lpQueryBuffer;

            ASSERT(hRegLevelBase != NULL);
            if (pTokenOwner->Owner == NULL) {
                RtlInitUnicodeString(&UnicodeStringSid, L"");
            }
            else {
                Status = RtlConvertSidToUnicodeString( &UnicodeStringSid,
                        pTokenOwner->Owner, TRUE );
                if (!NT_SUCCESS(Status)) goto ExitHandler2;
                AllocatedStringSid = TRUE;
            }

            Status = SaferpSetRegistryHelper(
                    hRegLevelBase,
                    L"Restrictions",
                    NULL,
                    L"DefaultOwner",
                    REG_SZ,
                    lpQueryBuffer,
                    dwInBufferSize);

            if (AllocatedStringSid)
                RtlFreeUnicodeString(&UnicodeStringSid);

            if (!NT_SUCCESS(Status)) goto ExitHandler2;

            //BLACKCOMB TODO: update cached pLevelRecord on success
            break;
        }

        case SaferObjectDeletedPrivileges:        // TOKEN_PRIVILEGES
        {
            HKEY hKeyPrivsToRemove;
            UNICODE_STRING ValueName;
            PTOKEN_PRIVILEGES pTokenPrivs =
                    (PTOKEN_PRIVILEGES) lpQueryBuffer;

            // Open a handle to the correct subkey.
            ASSERT(hRegLevelBase != NULL);
            Status = SaferpCreateSecondLevelKey(
                            hRegLevelBase,
                            L"Restrictions",
                            L"PrivsToRemove",
                            &hKeyPrivsToRemove);
            if (!NT_SUCCESS(Status)) goto ExitHandler2;

            // Clear out all old values under the subkey.
            Status = SaferpClearRegistryListHelper(
                            hKeyPrivsToRemove,
                            L"Count",
                            L"Priv");
            if (!NT_SUCCESS(Status)) {
                // Bad luck!  Possibly left in incomplete state!
                NtClose(hKeyPrivsToRemove);
                goto ExitHandler2;
            }

            // Now add all of the new ones we're supposed to add.
            RtlInitUnicodeString(&ValueName, L"Count");
            Status = NtSetValueKey(hKeyPrivsToRemove,
                    &ValueName, 0, REG_DWORD,
                    (LPBYTE) pTokenPrivs->PrivilegeCount, sizeof(DWORD));
            if (!NT_SUCCESS(Status)) {
                // Bad luck!  Possibly left in incomplete state!
                NtClose(hKeyPrivsToRemove);
                goto ExitHandler2;
            }
            for (Index = 0; Index < pTokenPrivs->PrivilegeCount; Index++)
            {
                WCHAR ValueNameBuffer[20];
                WCHAR PrivilegeNameBuffer[64];
                DWORD dwPrivilegeNameLen;

                wsprintfW(ValueNameBuffer, L"Priv%d", Index);
                RtlInitUnicodeString(&ValueName, ValueNameBuffer);

                dwPrivilegeNameLen = sizeof(PrivilegeNameBuffer) / sizeof(WCHAR);
                if (!LookupPrivilegeNameW(NULL,
                        &pTokenPrivs->Privileges[Index].Luid,
                        PrivilegeNameBuffer,
                        &dwPrivilegeNameLen))
                {
                    // Bad luck!  Possibly left in incomplete state!
                    Status = STATUS_NO_SUCH_PRIVILEGE;
                    NtClose(hKeyPrivsToRemove);
                    goto ExitHandler2;
                }

                Status = NtSetValueKey(hKeyPrivsToRemove,
                    &ValueName, 0, REG_SZ,
                    (LPBYTE) PrivilegeNameBuffer,
                    (wcslen(PrivilegeNameBuffer) + 1) * sizeof(WCHAR));
                if (!NT_SUCCESS(Status)) {
                    // Bad luck!  Possibly left in incomplete state!
                    NtClose(hKeyPrivsToRemove);
                    goto ExitHandler2;
                }
            }
            NtClose(hKeyPrivsToRemove);
            //BLACKCOMB TODO: update cached pLevelRecord on success
            break;
        }

        case SaferObjectSidsToDisable:            // TOKEN_GROUPS
            //BLACKCOMB TODO: allow wildcard sids to be specified.
            ASSERT(hRegLevelBase != NULL);
            Status = SaferpSetListOfSids(
                    hRegLevelBase,
                    L"Restrictions",
                    L"SidsToDisable",
                    L"Count",
                    L"Group",
                    (PTOKEN_GROUPS) lpQueryBuffer);
            if (!NT_SUCCESS(Status)) goto ExitHandler2;
            //BLACKCOMB TODO: update cached pLevelRecord on success
            break;

        case SaferObjectRestrictedSidsInverted:   // TOKEN_GROUPS
            //BLACKCOMB TODO: allow wildcard sids to be specified.
            ASSERT(hRegLevelBase != NULL);
            Status = SaferpSetListOfSids(
                    hRegLevelBase,
                    L"Restrictions",
                    L"RestrictingSidsInverted",
                    L"Count",
                    L"Group",
                    (PTOKEN_GROUPS) lpQueryBuffer);
            if (!NT_SUCCESS(Status)) goto ExitHandler2;
            //BLACKCOMB TODO: update cached pLevelRecord on success
            break;

        case SaferObjectRestrictedSidsAdded:      // TOKEN_GROUPS
            ASSERT(hRegLevelBase != NULL);
            Status = SaferpSetListOfSids(
                    hRegLevelBase,
                    L"Restrictions",
                    L"RestrictingSidsAdded",
                    L"Count",
                    L"Group",
                    (PTOKEN_GROUPS) lpQueryBuffer);
            if (!NT_SUCCESS(Status)) goto ExitHandler2;
            //BLACKCOMB TODO: update cached pLevelRecord on success
            break;
#endif

        case SaferObjectSingleIdentification:
        {
            PAUTHZIDENTSTABLERECORD pIdentRecord;
            PSAFER_IDENTIFICATION_HEADER pCommon =
                (PSAFER_IDENTIFICATION_HEADER) lpQueryBuffer;

            if (!ARGUMENT_PRESENT(pCommon)) {
                Status = STATUS_ACCESS_VIOLATION;
                goto ExitHandler2;
            }
            if (dwInBufferSize < sizeof(SAFER_IDENTIFICATION_HEADER) ||
                dwInBufferSize < pCommon->cbStructSize) {
                Status = STATUS_INFO_LENGTH_MISMATCH;
                goto ExitHandler2;
            }
            pIdentRecord = CodeAuthzIdentsLookupByGuid(
                    &g_CodeIdentitiesTable,
                    &pCommon->IdentificationGuid);
            if (!pIdentRecord)
            {
                // Request to create a new Code Identifier.
                Status = SaferpCreateNewSingleIdentification(
                        dwHandleScopeId, pLevelRecord, pCommon);
            }
            else if (pCommon->dwIdentificationType == 0)
            {
                // Request to delete an existing Code Identifier.
                if (pIdentRecord->dwLevelId != pLevelRecord->dwLevelId ||
                    pIdentRecord->dwScopeId != dwHandleScopeId) {
                    Status = STATUS_NOT_FOUND;
                } else {
                    Status = SaferpDeleteSingleIdentificationGuid(
                            pLevelRecord, pIdentRecord);
                }
            }
            else
            {
                // Request to modify an existing Code Identifier.
                if (pIdentRecord->dwLevelId != pLevelRecord->dwLevelId ||
                    pIdentRecord->dwScopeId != dwHandleScopeId)
                {
                    // This was likely a request to create a new Code
                    // Identifier, but with a GUID that already exists.
                    Status = STATUS_OBJECT_NAME_COLLISION;
                } else {
                    Status = SaferpSetExistingSingleIdentification(
                                pIdentRecord, pCommon);
                }
            }
            goto ExitHandler2;
        }


        default:
            ASSERTMSG("invalid info class unhandled earlier", 0);
            Status = STATUS_INVALID_INFO_CLASS;
            goto ExitHandler2;
    }

    Status = STATUS_SUCCESS;



    //
    // Cleanup and epilogue code.
    //
ExitHandler2:
    if (hRegLevelBase != NULL) {
        NtClose(hRegLevelBase);
    }

ExitHandler:
    return Status;
}



BOOL WINAPI
SaferSetLevelInformation(
    IN SAFER_LEVEL_HANDLE                      LevelHandle,
    IN SAFER_OBJECT_INFO_CLASS     dwInfoType,
    IN LPVOID                           lpQueryBuffer,
    IN DWORD                            dwInBufferSize
    )
/*++

Routine Description:

    Allows the user to modify various pieces of information about a
    given WinSafer Level.

Arguments:

    LevelHandle - the handle to the WinSafer Level to evaluate.

    dwInfoType - specifies the type of information being modified.

    lpQueryBuffer - pointer to a user-supplied memory buffer that
        contains the new data for the item being modified.

    dwInBufferSize - specifies the size of the user's memory block.
        For string arguments, this size includes the terminating null.

Return Value:

    Returns FALSE on error, otherwise success.

--*/
{
    NTSTATUS Status;

    if (!g_bInitializedFirstTime) {
        Status = STATUS_UNSUCCESSFUL;
        goto ExitHandler;
    }
    RtlEnterCriticalSection(&g_TableCritSec);

    Status = CodeAuthzpSetAuthzLevelInfo(
            LevelHandle, dwInfoType,
            lpQueryBuffer, dwInBufferSize);

    RtlLeaveCriticalSection(&g_TableCritSec);

    if (NT_SUCCESS(Status))
        return TRUE;

ExitHandler:
    if (Status == STATUS_OBJECT_NAME_COLLISION) {
        SetLastError(ERROR_OBJECT_ALREADY_EXISTS);
    } else {
        BaseSetLastNTError(Status);
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\winsafer\safelog.c ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    safelog.c         (SAFER Event Logging)

Abstract:

    This module implements the internal WinSAFER APIs to write eventlog
    messages.  All of our message strings are defined in ntstatus.mc
    and are physically located within ntdll.dll file.

    Currently we are just reusing the previously existing event source
    called "Application Popup", which already happens to use ntdll.dll
    as its message resource library.  Events of this source always go
    into the "System Log".

Author:

    Jeffrey Lawson (JLawson) - Apr 1999

Environment:

    User mode only.

Exported Functions:

    SaferRecordEventLogEntry

Revision History:

    Created - Nov 2000

--*/

#include "pch.h"
#pragma hdrstop
#include <winsafer.h>
#include <winsaferp.h>
#include "saferp.h"




const static GUID guidTrustedCert = SAFER_GUID_RESULT_TRUSTED_CERT;
const static GUID guidDefaultRule = SAFER_GUID_RESULT_DEFAULT_LEVEL;



BOOL WINAPI
SaferpRecordEventLogEntryHelper(
        IN NTSTATUS     LogStatusCode,
        IN LPCWSTR      szTargetPath,
        IN REFGUID      refRuleGuid,
        IN LPCWSTR      szRulePath
        )
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    WORD wNumStrings = 0;
    LPWSTR lpszStrings[5];
    HANDLE hEventSource;
    UNICODE_STRING UnicodeGuid;

    hEventSource = RegisterEventSourceW(NULL, L"Software Restriction Policy");

    if (hEventSource != NULL) {

        Status = STATUS_SUCCESS;
        RtlInitEmptyUnicodeString(&UnicodeGuid, NULL, 0);

        switch (LogStatusCode)
        {
            case STATUS_ACCESS_DISABLED_BY_POLICY_DEFAULT:
                if (!ARGUMENT_PRESENT(szTargetPath)) {
                    Status = STATUS_INVALID_PARAMETER;
                    break;
                }
                lpszStrings[0] = (LPWSTR) szTargetPath;
                wNumStrings = 1;
                break;

            case STATUS_ACCESS_DISABLED_BY_POLICY_OTHER:
                if (!ARGUMENT_PRESENT(szTargetPath) ||
                    !ARGUMENT_PRESENT(refRuleGuid)) {
                    Status = STATUS_INVALID_PARAMETER;
                    break;
                }

                Status = RtlStringFromGUID(refRuleGuid, &UnicodeGuid);
                if (NT_SUCCESS(Status)) {
                    ASSERT(UnicodeGuid.Buffer != NULL);
                    lpszStrings[0] = (LPWSTR) szTargetPath;
                    lpszStrings[1] = UnicodeGuid.Buffer;
                    wNumStrings = 2;
                }
                break;

            case STATUS_ACCESS_DISABLED_BY_POLICY_PUBLISHER:
                if (!ARGUMENT_PRESENT(szTargetPath)) {
                    Status = STATUS_INVALID_PARAMETER;
                    break;
                }
                lpszStrings[0] = (LPWSTR) szTargetPath;
                wNumStrings = 1;
                break;

            case STATUS_ACCESS_DISABLED_BY_POLICY_PATH:
                if (!ARGUMENT_PRESENT(szTargetPath) ||
                    !ARGUMENT_PRESENT(refRuleGuid) ||
                    !ARGUMENT_PRESENT(szRulePath)) {
                    Status = STATUS_INVALID_PARAMETER;
                    break;
                }
                Status = RtlStringFromGUID(refRuleGuid, &UnicodeGuid);
                if (NT_SUCCESS(Status)) {
                    ASSERT(UnicodeGuid.Buffer != NULL);
                    lpszStrings[0] = (LPWSTR) szTargetPath;
                    lpszStrings[1] = UnicodeGuid.Buffer;
                    lpszStrings[2] = (LPWSTR) szRulePath;
                    wNumStrings = 3;
                }
                break;

            default:
                Status = STATUS_INVALID_PARAMETER;
        }

        if (NT_SUCCESS(Status)) {
            ReportEventW(
                    hEventSource,           // handle to event log
                    EVENTLOG_WARNING_TYPE,  // event type
                    0,                      // event category
                    LogStatusCode,          // event ID
                    NULL,                   // current user's SID
                    wNumStrings,            // strings in lpszStrings
                    0,                      // no bytes of raw data
                    lpszStrings,            // array of error strings
                    NULL);                  // no raw data
        }

        DeregisterEventSource(hEventSource);

        if (UnicodeGuid.Buffer != NULL) {
            RtlFreeUnicodeString(&UnicodeGuid);
        }
    }

    if (NT_SUCCESS(Status)) {
        return TRUE;
    } else {
        return FALSE;
    }
}



BOOL WINAPI
SaferRecordEventLogEntry(
        IN SAFER_LEVEL_HANDLE      hAuthzLevel,
        IN LPCWSTR          szTargetPath,
        IN LPVOID           lpReserved
        )
{
    PSAFER_IDENTIFICATION_HEADER pIdentCommon;
    DWORD dwIdentBufferSize;
    BOOL bResult;


    //
    // Allocate enough memory for the largest structure we can expect
    // and then query the information about the identifier that matched.
    //
    dwIdentBufferSize = max(sizeof(SAFER_HASH_IDENTIFICATION),
                            sizeof(SAFER_PATHNAME_IDENTIFICATION));
    pIdentCommon = (PSAFER_IDENTIFICATION_HEADER)
            HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwIdentBufferSize);
    if (!pIdentCommon) {
        return FALSE;
    }
    pIdentCommon->cbStructSize = sizeof(SAFER_IDENTIFICATION_HEADER);
    if (!SaferGetLevelInformation(
            hAuthzLevel,
            SaferObjectSingleIdentification,
            pIdentCommon,
            dwIdentBufferSize,
            &dwIdentBufferSize)) {

        if (GetLastError() == ERROR_NOT_ENOUGH_MEMORY) {

            HeapFree(GetProcessHeap(), 0, pIdentCommon);
            pIdentCommon = (PSAFER_IDENTIFICATION_HEADER)
                    HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwIdentBufferSize);
            if (!pIdentCommon) {
                return FALSE;
            }
            pIdentCommon->cbStructSize = sizeof(SAFER_IDENTIFICATION_HEADER);
            if (!SaferGetLevelInformation(
                    hAuthzLevel,
                    SaferObjectSingleIdentification,
                    pIdentCommon,
                    dwIdentBufferSize,
                    &dwIdentBufferSize)) {
                bResult =  FALSE;
                goto Cleanup;
            }

        }
        else
        {
            bResult =  FALSE;
            goto Cleanup;
        }
    }


    //
    // Look at the resulting information about the identifier.
    //
    if (IsEqualGUID(&pIdentCommon->IdentificationGuid, &guidTrustedCert))
    {
        bResult = SaferpRecordEventLogEntryHelper(
                    STATUS_ACCESS_DISABLED_BY_POLICY_PUBLISHER,
                    szTargetPath, NULL, NULL);
    }
    else if (IsEqualGUID(&pIdentCommon->IdentificationGuid, &guidDefaultRule))
    {
        bResult = SaferpRecordEventLogEntryHelper(
                    STATUS_ACCESS_DISABLED_BY_POLICY_DEFAULT,
                    szTargetPath, NULL, NULL);
    }
    else if (pIdentCommon->dwIdentificationType == SaferIdentityTypeImageName)
    {
        PSAFER_PATHNAME_IDENTIFICATION pIdentPath =
                (PSAFER_PATHNAME_IDENTIFICATION) pIdentCommon;
        bResult = SaferpRecordEventLogEntryHelper(
                    STATUS_ACCESS_DISABLED_BY_POLICY_PATH,
                    szTargetPath, &pIdentCommon->IdentificationGuid,
                    pIdentPath->ImageName);
    }
    else
    {
        bResult = SaferpRecordEventLogEntryHelper(
                    STATUS_ACCESS_DISABLED_BY_POLICY_OTHER,
                    szTargetPath, &pIdentCommon->IdentificationGuid,
                    NULL);
    }

Cleanup:
    HeapFree(GetProcessHeap(), 0, pIdentCommon);

    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\winsafer\safepol.c ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    safepol.c         (SAFER Code Authorization Policy)

Abstract:

    This module implements the WinSAFER APIs

Author:

    Jeffrey Lawson (JLawson) - Apr 1999

Environment:

    User mode only.

Exported Functions:

    CodeAuthzpGetInformationCodeAuthzPolicy
    CodeAuthzpSetInformationCodeAuthzPolicy
    SaferGetPolicyInformation                 (public win32)
    SaferSetPolicyInformation                 (public win32)

Revision History:

    Created - Apr 1999

--*/

#include "pch.h"
#pragma hdrstop
#include <winsafer.h>
#include <winsaferp.h>
#include "saferp.h"




NTSTATUS NTAPI
CodeAuthzpGetInformationCodeAuthzPolicy (
        IN DWORD                            dwScopeId,
        IN SAFER_POLICY_INFO_CLASS     CodeAuthzPolicyInfoClass,
        IN DWORD                            InfoBufferSize,
        IN OUT PVOID                        InfoBuffer,
        OUT PDWORD                          InfoBufferRetSize
        )
/*++

Routine Description:


Arguments:

    dwScopeId -

    CodeAuthzPolicyInfoClass -

    InfoBufferSize -

    InfoBuffer -

    InfoBufferRetSize -

Return Value:

    Returns STATUS_SUCCESS if no error occurs, otherwise returns the
    status code indicating the nature of the failure.

--*/
{
    NTSTATUS Status;


    //
    // Handle the specific information type as appropriate.
    //
    switch (CodeAuthzPolicyInfoClass)
    {
        case SaferPolicyLevelList:
            // scope is only primary.
            Status = CodeAuthzPol_GetInfoCached_LevelListRaw(
                    dwScopeId,
                    InfoBufferSize, InfoBuffer, InfoBufferRetSize);
            break;


        case SaferPolicyDefaultLevel:
            // scope is primary or secondary for non-registry case.
            Status = CodeAuthzPol_GetInfoCached_DefaultLevel(
                    dwScopeId,
                    InfoBufferSize, InfoBuffer, InfoBufferRetSize);
            break;


        case SaferPolicyEnableTransparentEnforcement:
            // scope is only primary.
            Status = CodeAuthzPol_GetInfoRegistry_TransparentEnabled(
                    dwScopeId,
                    InfoBufferSize, InfoBuffer, InfoBufferRetSize);
            break;

        case SaferPolicyEvaluateUserScope:
            // scope is only primary.
            Status = CodeAuthzPol_GetInfoCached_HonorUserIdentities(
                    dwScopeId,
                    InfoBufferSize, InfoBuffer, InfoBufferRetSize);
            break;

        case SaferPolicyScopeFlags:
        // scope is only primary.
        Status = CodeAuthzPol_GetInfoRegistry_ScopeFlags(
                dwScopeId,
                InfoBufferSize, InfoBuffer, InfoBufferRetSize);
        break;


        default:
            Status = STATUS_INVALID_INFO_CLASS;
            break;
    }

    return Status;
}



NTSTATUS NTAPI
CodeAuthzpSetInformationCodeAuthzPolicy (
        IN DWORD                            dwScopeId,
        IN SAFER_POLICY_INFO_CLASS     CodeAuthzPolicyInfoClass,
        IN DWORD                            InfoBufferSize,
        OUT PVOID                           InfoBuffer
        )
/*++

Routine Description:


Arguments:

    dwScopeId -

    CodeAuthzPolicyInfoClass -

    InfoBufferSize -

    InfoBuffer -

Return Value:

    Returns STATUS_SUCCESS if no error occurs, otherwise returns the
    status code indicating the nature of the failure.

--*/
{
    NTSTATUS Status;


    //
    // Handle the specific information type as appropriate.
    //
    switch (CodeAuthzPolicyInfoClass)
    {
        case SaferPolicyLevelList:
            // not valid for setting.
            Status = STATUS_INVALID_INFO_CLASS;
            break;


        case SaferPolicyDefaultLevel:
            // scope is primary or secondary for non-registry case.
            Status = CodeAuthzPol_SetInfoDual_DefaultLevel(
                    dwScopeId, InfoBufferSize, InfoBuffer);
            break;


        case SaferPolicyEnableTransparentEnforcement:
            // scope is only primary.
            Status = CodeAuthzPol_SetInfoRegistry_TransparentEnabled(
                    dwScopeId, InfoBufferSize, InfoBuffer);
            break;

        case SaferPolicyScopeFlags:
            // scope is only primary.
            Status = CodeAuthzPol_SetInfoRegistry_ScopeFlags(
                    dwScopeId, InfoBufferSize, InfoBuffer);
            break;

        case SaferPolicyEvaluateUserScope:
            // scope is only primary.
            Status = CodeAuthzPol_SetInfoDual_HonorUserIdentities(
                    dwScopeId, InfoBufferSize, InfoBuffer);
            break;


        default:
            Status = STATUS_INVALID_INFO_CLASS;
            break;
    }

    return Status;
}



BOOL WINAPI
SaferGetPolicyInformation(
        IN DWORD                            dwScopeId,
        IN SAFER_POLICY_INFO_CLASS     CodeAuthzPolicyInfoClass,
        IN DWORD                            InfoBufferSize,
        IN OUT PVOID                        InfoBuffer,
        IN OUT PDWORD                       InfoBufferRetSize,
        IN LPVOID                           lpReserved
        )
/*++

Routine Description:


Arguments:

    dwScopeId -

    CodeAuthzPolicyInfoClass -

    InfoBufferSize -

    InfoBuffer -

    InfoBufferRetSize -

    lpReserved - unused, must be zero.

Return Value:

    Returns TRUE if successful, otherwise returns FALSE and sets
    the value returned by GetLastError() to be the specific cause.

--*/
{
    NTSTATUS Status;

    Status = CodeAuthzpGetInformationCodeAuthzPolicy(
            dwScopeId, CodeAuthzPolicyInfoClass,
            InfoBufferSize, InfoBuffer, InfoBufferRetSize);
    if (NT_SUCCESS(Status))
        return TRUE;

    BaseSetLastNTError(Status);
    UNREFERENCED_PARAMETER(lpReserved);
    return FALSE;
}



BOOL WINAPI
SaferSetPolicyInformation(
        IN DWORD                            dwScopeId,
        IN SAFER_POLICY_INFO_CLASS     CodeAuthzPolicyInfoClass,
        IN DWORD                            InfoBufferSize,
        IN PVOID                            InfoBuffer,
        IN LPVOID                           lpReserved
        )
/*++

Routine Description:


Arguments:

    dwScopeId -

    CodeAuthzPolicyInfoClass -

    InfoBufferSize -

    InfoBuffer -

    lpReserved - unused, must be zero.

Return Value:

    Returns TRUE if successful, otherwise returns FALSE and sets
    the value returned by GetLastError() to be the specific cause.

--*/
{
    NTSTATUS Status;

    Status = CodeAuthzpSetInformationCodeAuthzPolicy (
                dwScopeId, CodeAuthzPolicyInfoClass,
                InfoBufferSize, InfoBuffer);

    if (NT_SUCCESS(Status))
        return TRUE;

    BaseSetLastNTError(Status);
    UNREFERENCED_PARAMETER(lpReserved);
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\winsafer\safepath.c ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    SafePath.c        (WinSAFER Path Comparison)

Abstract:

    This module implements the WinSAFER APIs that evaluate the system
    policies to determine which Authorization Level has been configured
    to apply restrictions for a specified application or code library.

Author:

    Jeffrey Lawson (JLawson) - Nov 1999

Environment:

    User mode only.

Exported Functions:

    CodeAuthzpCompareImagePath

Revision History:

    Created - Nov 1999

--*/

#include "pch.h"
#pragma hdrstop
#include <winsafer.h>
#include <winsaferp.h>
#include "saferp.h"



//
// Define the following value to use the "new" comparison logic,
// that includes asterick and question mark matching.
//
#define USE_NEW_WILDCARD_EVALUATION



//
// Convenient macros for doing filename pattern matching.
//
#define IS_UCASE_CHARS_EQUAL_U(ch1, ch2) (((ch1) == (ch2)) || (RtlUpcaseUnicodeChar(ch1) == RtlUpcaseUnicodeChar(ch2)))
#define IS_PATH_SEPARATOR_U(ch) (((ch) == L'\\') || ((ch) == L'/'))
#define IS_WILDCARD_CHAR_U(ch) ((ch) == L'*')
#define IS_QUESTION_CHAR_U(ch) ((ch) == L'?')
#define IS_DOT_CHAR_U(ch) ((ch) == L'.')



FORCEINLINE LPCWSTR CodeAuthzpFindSlash (
        IN LPCWSTR      string,
        IN USHORT       length
        )
/*++

Routine Description:

    Returns a pointer to the first instance of a forward or
    backward slash within the specified string buffer.

Arguments:

    string -

    length -

Return Value:

    Returns NULL if no backslashes or forward-slashes were found within
    the string.  Otherwise returns a pointer to the matching char.

--*/
{
    while (length-- > 0) {
         if (IS_PATH_SEPARATOR_U(*string)) return string;
         string++;
    }
    return NULL;
}




#ifdef USE_NEW_WILDCARD_EVALUATION
LONG NTAPI
__CodeAuthzpCompareImagePathHelper(
        IN LPCWSTR      wild,
        IN USHORT       wildlen,
        IN LPCWSTR      actual,
        IN USHORT       actuallen
        )
/*++

Routine Description:

    Evaluates a wildcard pattern against a specified pathname and
    indicates if they match.

Arguments:

    wild -

    wildlen -

    actual -

    actuallen -

Return Value:

    0 = no match
   -1 = match exactly
    1 = match with wildcard

--*/
{
    LONG lMatchResult = -1;

    ASSERT(ARGUMENT_PRESENT(wild) &&
           !CodeAuthzpFindSlash(wild, wildlen));
    ASSERT(ARGUMENT_PRESENT(actual) &&
           !CodeAuthzpFindSlash(actual, actuallen));

    for (;;) {
        // Check for terminating conditions.
        if (wildlen == 0) {
            if (actuallen == 0) {
                return lMatchResult;
            } else {
                ASSERT(actuallen > 0);
                return 0;
            }
        }

        // Evaluate the wildcard pattern.
        if (IS_WILDCARD_CHAR_U(*wild)) {
            USHORT matchcount;

            // Skip past the asterick (possibly multiple).
            do {
                wild++; wildlen--;
            } while ( wildlen > 0 && IS_WILDCARD_CHAR_U(*wild) );

            // Try expanding the asterick to be zero or more chars.
            for (matchcount = 0; ; matchcount++) {
                if (matchcount > actuallen) {
                    return 0;       // match failed.
                }
                if (0 != __CodeAuthzpCompareImagePathHelper(
                        wild, wildlen,
                        &actual[matchcount], actuallen - matchcount))
                {
                    actual += matchcount;
                    actuallen -= matchcount;
                    break;
                }
            }

            // We've encountered a wildcard char, so remember
            // that this is no longer an "exact" match.
            lMatchResult = 1;

        } else if (IS_QUESTION_CHAR_U(*wild)) {
            // Question marks will match any single character, except
            // periods.  Question marks will also match nothing when
            // we are already at the end of the filename or segment.

            if (actuallen > 0 && !IS_DOT_CHAR_U(*actual)) {
                actual++; actuallen--;
            }
            wild++; wildlen--;

            // We've encountered a wildcard char, so remember
            // that this is no longer an "exact" match.
            lMatchResult = 1;

        } else {
            if (actuallen < 1 ||
                !IS_UCASE_CHARS_EQUAL_U(*wild, *actual)) {
                return 0;
            }
            wild++; wildlen--;
            actual++; actuallen--;
        }
    }
}


LONG NTAPI
CodeAuthzpCompareUnicodeImagePath(
        IN PCUNICODE_STRING  wildcard,
        IN PCUNICODE_STRING  actual
        )
/*++

Routine Description:

    Evaluates a wildcard pattern against a specified pathname and
    indicates if they match.

Arguments:

    wildcard -

    actual -

Return Value:

    Returns 0 if the path fragment does not match the specified imagepath.
    Returns -1 if the fragment matches the imagepath _exactly_!
    Otherwise returns a postive integer representing the "depth" of the
    the match (number of matching subdirectories).  Greater values
    indicate a "deeper" directory match.

--*/

{
    USHORT wildindex = 0, actualindex = 0;
    LONG matchquality = 0;
    BOOLEAN bNoWildcardsFound = TRUE;

    ASSERT(ARGUMENT_PRESENT(wildcard) && wildcard->Buffer != NULL);
    ASSERT(ARGUMENT_PRESENT(actual) && actual->Buffer != NULL);
    for (;;)
    {
        ASSERT(wildindex <= wildcard->Length / sizeof(WCHAR));
        ASSERT(actualindex <= actual->Length / sizeof(WCHAR));

        if (wildindex == wildcard->Length / sizeof(WCHAR))
        {
            // We've reached the end of the wildcard but the actual string has 
            // not ended.
            if (actualindex < actual->Length / sizeof(WCHAR)) {
                return matchquality;
            }

            // The wildcard matched the filename but with inexact matches.
            // Return one more than the actual depth so that we can handle
            // non-qualified path matches as worse then these.
            if (!bNoWildcardsFound) {
                return (matchquality + 1);
            } 

            ASSERT(wildindex == wildcard->Length / sizeof(WCHAR));
            return -1;                  // exact match.
        }
        else if (IS_PATH_SEPARATOR_U(wildcard->Buffer[wildindex]))
        {
            if (!IS_PATH_SEPARATOR_U(actual->Buffer[actualindex])) {
                return 0;       // no match
            }

            // Skip forward to the start of the next component.
            do {
                wildindex++;
            } while ( wildindex < wildcard->Length / sizeof(WCHAR) &&
                      IS_PATH_SEPARATOR_U(wildcard->Buffer[wildindex]) );

            // Skip forward to the start of the next component.
            do {
                actualindex++;
            } while ( actualindex < actual->Length / sizeof(WCHAR) &&
                      IS_PATH_SEPARATOR_U(actual->Buffer[actualindex]) );
        }
        else
        {
            USHORT wildlen = 0, actuallen = 0;

            // Count the length of this component of the wildcard.
            while (wildindex + wildlen < (USHORT) (wildcard->Length / sizeof(WCHAR)) &&
                   !IS_PATH_SEPARATOR_U(wildcard->Buffer[wildindex + wildlen])) {
                wildlen++;
            }
            ASSERT(wildlen > 0);

            // Count the length of this component of the actual path.
            while (actualindex + actuallen < (USHORT) (actual->Length / sizeof(WCHAR)) &&
                   !IS_PATH_SEPARATOR_U(actual->Buffer[actualindex + actuallen])) {
                actuallen++;
            }

            // Otherwise require that this component matches.
            switch (__CodeAuthzpCompareImagePathHelper(
                        &wildcard->Buffer[wildindex], wildlen,
                        &actual->Buffer[actualindex], actuallen)) {
                case 0:     // fails to match
                    return 0;
                case -1:    // matches exactly without wildcards
                    break;
                default:    // matches with wildcard expansion.
                    bNoWildcardsFound = FALSE; break;
            }

            // Increment pointers for next component.
            wildindex += wildlen;
            actualindex += actuallen;
            matchquality++;
        }

    }
}



LONG NTAPI
CodeAuthzpCompareImagePath(
        IN LPCWSTR  szPathFragment,
        IN LPCWSTR  szFullImagePath
        )
/*++

Routine Description:

    Evaluates a wildcard pattern against a specified pathname and
    indicates if they match.

Arguments:

    szPathFragment -

    szFullImagePath -

Return Value:

    Returns 0 if the path fragment does not match the specified imagepath.
    Returns -1 if the fragment matches the imagepath _exactly_!
    Otherwise returns a postive integer representing the "depth" of the
    the match (number of matching subdirectories).  Greater values
    indicate a "deeper" directory match.

--*/
{
    UNICODE_STRING UnicodePathFragment;
    UNICODE_STRING UnicodeFullImagePath;
    ULONG i = 0;
    USHORT Len = 0;
    LONG lMatchDepth = 0;

    RtlInitUnicodeString(&UnicodePathFragment, szPathFragment);
    RtlInitUnicodeString(&UnicodeFullImagePath, szFullImagePath);
    lMatchDepth = CodeAuthzpCompareUnicodeImagePath(
                      &UnicodePathFragment, &UnicodeFullImagePath);

    // We did not get a match for fully qualified name. Let's try for just a 
    // basename match.
    if (!lMatchDepth) {
        // if the rule has a '\' in it, it's not a basename match rule.
        // We only check for filename.ext rules allowing wildcards.
        if (wcschr(szPathFragment, L'\\')) {
            return 0;
        }

        Len = (UnicodeFullImagePath.Length/sizeof(WCHAR)) -1;

        // Skip from rightmost character to the the character just after the
        // last '\', if any or to the beginning of the string in absence of '\'.
        while (Len > 0 && szFullImagePath[Len] != L'\\') {
            Len--;
        }

        // A '\' exists. Move one character to the right.
        if (szFullImagePath[Len] == L'\\') {
            Len++;
        }

        // Check if there is a match of the file basename with the rule. We have
        // already checked that the rule does not have '\'.
        switch (__CodeAuthzpCompareImagePathHelper(
                    szPathFragment, UnicodePathFragment.Length/sizeof(WCHAR),
                    szFullImagePath+Len, (UnicodeFullImagePath.Length/sizeof(WCHAR))-Len)) {
            case 0:     // fails to match
                return 0;
            case -1:    // matches exactly without wildcards
            default:    // matches with wildcard expansion.

                // We treat exact matches the same as inexact matches here.
                // Thus, abc.exe is == a*.exe = *.exe.

                // Skip to the first non-'\' character.
                while ((szFullImagePath[i] == L'\\') && (szFullImagePath[i] != L'\0')) {
                    i++;
                }

                // This string is bogus. It only has 0 or more '\'s in it.
                if (szFullImagePath[i] == L'\0') {
                    return 0;
                }

                // Return the depth of the tree.
                lMatchDepth = 1;
                while (TRUE) {

                    // Skip to the first '\' while not end of string.
                    while ((szFullImagePath[i] != L'\\') && (szFullImagePath[i] != L'\0')) {
                        i++;
                    }

                    // We are at the end of the string. Return the depth.
                    if (szFullImagePath[i] == L'\0') {
                        return lMatchDepth;
                    }

                    // Skip to the first non-'\' while not end of string.
                    while ((szFullImagePath[i] == L'\\') && (szFullImagePath[i] != L'\0')) {
                        i++;
                    }

                    // We are at a non-'\' character. Increment the depth.
                    lMatchDepth++;
                }

                // Should never get here.
                ASSERT(FALSE);
        }
    }        

    return lMatchDepth;
}



#else   // #ifdef USE_NEW_WILDCARD_EVALUATION


LONG NTAPI
CodeAuthzpCompareImagePath(
        IN LPCWSTR  szPathFragment,
        IN LPCWSTR  szFullImagePath
        )
/*++

Routine Description:

    Evaluates a wildcard pattern against a specified pathname and
    indicates if they match.

Arguments:

    szPathFragment -

    szFullImagePath -

Return Value:

    Returns 0 if the path fragment does not match the specified imagepath.
    Returns -1 if the fragment matches the imagepath _exactly_!
    Otherwise returns a postive integer representing the "depth" of the
    the match (number of matching subdirectories).  Greater values
    indicate a "deeper" directory match.

--*/
{
    LONG MatchDepth = 0;
    BOOLEAN bLastWasSlash = TRUE;
    LPCWSTR pFragment = szPathFragment;
    LPCWSTR pImage = szFullImagePath;


    //
    // Verify that our arguments were all supplied.
    //
    ASSERT(ARGUMENT_PRESENT(pFragment) && ARGUMENT_PRESENT(pImage));
    if (!*pFragment || !*pImage) return 0;      // empty strings.



    //
    // Perform the actual comparison loop.
    //
    for (;;) {
        if (!*pFragment)
        {
            // We have reached the string terminator at the end of the
            // wildcard fragment.  If this was also the end of the
            // actual filename, then this is a precise match.  Otherwise
            // we'll only consider this a positive partial match if this
            // occurred on a path-separator boundary.
            if (!*pImage) return -1;        // matched exactly.
            else if (bLastWasSlash) break;
            else if (IS_PATH_SEPARATOR_U(*pImage)) break;
            else return 0;       // did not match.
        }
        else if (!*pImage)
        {
            // We have reached the end of the actual filename, but have
            // not yet found the end of the wildcard fragment.
            return 0;       // did not match.
        }
        else if (!IS_UCASE_CHARS_EQUAL_U(*pFragment, *pImage))
        {
            // The two characters were unequal.  However, this condition
            // might occur if multiple path separators occur in one and
            // not the other, so explicitly absorb multiple slashes.
            if (bLastWasSlash) {
                if (IS_PATH_SEPARATOR_U(*pFragment)) { pFragment++; continue; }
                else if (IS_PATH_SEPARATOR_U(*pImage)) { pImage++; continue; }
            }
            return 0;           // did not match.
        }
        else
        {
            // Both characters matched.  Remember if they were slashes.
            // If this is a transition to a non-separator portion of the
            // filename, then increment our depth counter.
            if (IS_PATH_SEPARATOR_U(*pFragment)) {
                bLastWasSlash = TRUE;
            } else {
                if (bLastWasSlash) {
                    MatchDepth++;
                    bLastWasSlash = FALSE;
                }
            }
        }
        pFragment++;
        pImage++;
    }
    return MatchDepth;
}

#endif      //#ifdef USE_NEW_WILDCARD_EVALUATION
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\winsafer\safewild.c ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    SafeWild.c        (WinSAFER Wildcard SID handling)

Abstract:

    This module implements various "Wildcard SID" operations that
    are used internally by the WinSAFER APIs to compute SID list
    intersections and inversions.

Author:

    Jeffrey Lawson (JLawson) - Apr 2000

Environment:

    User mode only.

Exported Functions:

    CodeAuthzpConvertWildcardStringSidToSidW        (private)
    CodeAuthzpCompareWildcardSidWithSid             (private)
    CodeAuthzpSidInWildcardList                     (private)
    CodeAuthzpInvertAndAddSids                      (private)
    CodeAuthzpExpandWildcardList                    (private)

Revision History:

    Created - Apr 2000

--*/

#include "pch.h"
#pragma hdrstop
#include <sddl.h>           // ConvertStringSidToSidW
#include "safewild.h"
#include <winsafer.h>
#include "saferp.h"        // CodeAuthzpGetTokenInformation





NTSTATUS NTAPI
CodeAuthzpConvertWildcardStringSidToSidW(
    IN LPCWSTR                  szStringSid,
    OUT PAUTHZ_WILDCARDSID      pWildcardSid
    )
/*++

Routine Description:

    Converts a textual SID into the machine-understanable binary format.
    For normal string SIDs, this is just a call to ConvertStringSidToSidW
    with the exception that this takes a AUTHZ_WILDCARDSID parameter.

    However, this function also allows a single SubAuthority to be
    optionally specified as a wildcard ('*'), which will match zero or
    more SubAuthority.  Note that only one wildcard can be present within
    any SID and must represent whole SubAuthority values.
    (ie: "S-1-5-4-*-7" or "S-1-5-4-*" is okay; but "S-1-5-4*-7" and
    "S-1-5-*-4-*-7" are both not acceptable).

Arguments:

    szStringSid - textual string SID possibly containing a wildcard.

    pWildcardSID - pointer to a AUTHZ_WILDCARDSID structure that will be
            filled with information about the boolean sid.

Return Value:

    Returns STATUS_SUCCESS on success, or another error code.

--*/
{
    DWORD dwLength;
    LPWSTR pBuffer;
    LPCWSTR pStar = NULL;
    LPCWSTR p;

    //
    // Do a quick analysis pass on the String SID and verify that
    // there is at most one '*' in it.  And if there is a '*',
    // it must represent a whole subauthority (possibly the last
    // subauthority).
    //
    ASSERT( ARGUMENT_PRESENT(szStringSid) && ARGUMENT_PRESENT(pWildcardSid) );
    for (p = szStringSid; *p; p++)
    {
        if (*p == L'-' &&
            *(p + 1) == L'*' &&
            (*(p + 2) == UNICODE_NULL || *(p + 2) == L'-') )
        {
            if (pStar != NULL) return STATUS_INVALID_SID;
            pStar = p + 1;
            p++;
        }
        else if (*p == L'*') return STATUS_INVALID_SID;
    }


    //
    // If this String SID does not contain a wildcard, then just
    // process it normally and quickly return.
    //
    if (pStar == NULL)
    {
        pWildcardSid->WildcardPos = (DWORD) -1;
        if (ConvertStringSidToSidW(szStringSid, &pWildcardSid->Sid))
            return STATUS_SUCCESS;
        else
            return STATUS_UNSUCCESSFUL;
    }


    //
    // Otherwise this was a String SID that contained a wildcard.
    //
    dwLength = wcslen(szStringSid);
    pBuffer = (LPWSTR) RtlAllocateHeap(RtlProcessHeap(), 0,
                                       sizeof(WCHAR) * (dwLength + 1));
    if (pBuffer != NULL)
    {
        PISID sid1, sid2;
        DWORD dwIndex;
        LPWSTR pNewStar;

        //
        // Copy the String SID and update our 'pStar' pointer to
        // point to the '*' within our newly copied buffer.
        //
        RtlCopyMemory(pBuffer, szStringSid,
                      sizeof(WCHAR) * (dwLength + 1));
        pNewStar = pBuffer + (pStar - szStringSid);


        //
        // Change the '*' to a '0' and convert the SID once.
        //
        *pNewStar = L'0';
        if (ConvertStringSidToSidW(pBuffer, (PSID*) &sid1))
        {
            //
            // Change the '*' to a '1' and convert the SID again.
            //
            *pNewStar = L'1';
            if (ConvertStringSidToSidW(pBuffer, (PSID*) &sid2))
            {
                //
                // Compare the resulting SIDs and find the subauthority that
                // differs only by the '0' or '1' component.  Since we expect
                // the converted SIDs to always be the same except for the
                // one SubAuthority that we changed, we use a lot of asserts.
                //
                ASSERT(sid1->Revision == sid2->Revision);
                ASSERT( RtlEqualMemory(&sid1->IdentifierAuthority.Value[0],
                    &sid2->IdentifierAuthority.Value[0],
                        6 * sizeof(sid1->IdentifierAuthority.Value[0]) ) );
                ASSERT(sid1->SubAuthorityCount == sid2->SubAuthorityCount);
                for (dwIndex = 0; dwIndex < sid1->SubAuthorityCount; dwIndex++)
                {
                    if (sid1->SubAuthority[dwIndex] != sid2->SubAuthority[dwIndex])
                    {
                        ASSERT(sid1->SubAuthority[dwIndex] == 0 &&
                            sid2->SubAuthority[dwIndex] == 1);
                        ASSERT( RtlEqualMemory(&sid1->SubAuthority[dwIndex + 1],
                                    &sid2->SubAuthority[dwIndex + 1],
                                    sizeof(sid1->SubAuthority[0]) *
                                        (sid1->SubAuthorityCount - dwIndex - 1)) );

                        //
                        // The position of the wildcard '*' has been found so
                        // squeeze it out and move the postfix SubAuthorities.
                        //
                        RtlMoveMemory(&sid1->SubAuthority[dwIndex],
                                &sid1->SubAuthority[dwIndex + 1],
                                sizeof(sid1->SubAuthority[0]) *
                                    (sid1->SubAuthorityCount - dwIndex - 1) );
                        sid1->SubAuthorityCount--;


                        //
                        // Fill in the SID_AND_ATTRIBUTES structure that
                        // we'll return to the caller.
                        // In debug builds, we place a marker in the
                        // upper-bits of the member 'Attributes' so that
                        // we can easily assert wildcard SIDs.
                        //
                        pWildcardSid->Sid = (PSID) sid1;
                        pWildcardSid->WildcardPos = dwIndex;


                        //
                        // Free any remaining resources and return success.
                        //
                        LocalFree( (HLOCAL) sid2 );
                        RtlFreeHeap(RtlProcessHeap(), 0, pBuffer);
                        return STATUS_SUCCESS;
                    }
                }

                //
                // We should never get here since we expect to find
                // at least the 1 difference that we introduced.
                //
                ASSERT(0);
                LocalFree( (HLOCAL) sid2 );
            }
            LocalFree( (HLOCAL) sid1 );
        }
        RtlFreeHeap(RtlProcessHeap(), 0, pBuffer);
        return STATUS_UNSUCCESSFUL;
    }
    return STATUS_NO_MEMORY;
}


NTSTATUS NTAPI
CodeAuthzpConvertWildcardSidToStringSidW(
    IN PAUTHZ_WILDCARDSID   pWildcardSid,
    OUT PUNICODE_STRING     pUnicodeOutput)
/*++

Routine Description:

    Converts a machine-understandable Wildcard SID into a textual string
    representation of the SID.

Arguments:

    pWildcardSID - pointer to a AUTHZ_WILDCARDSID structure that will be
            filled with information about the boolean sid.

    pUnicodeOutput - output buffer that will be allocated.

Return Value:

    Returns STATUS_SUCCESS on success, or another error code.

--*/
{
    NTSTATUS Status;
    WCHAR UniBuffer[ 256 ];
    UNICODE_STRING LocalString ;

    UCHAR   i;
    ULONG   Tmp;
    LARGE_INTEGER Auth ;

    PISID   iSid = (PISID) pWildcardSid->Sid;  // pointer to opaque structure


    if (!ARGUMENT_PRESENT(pUnicodeOutput)) {
        return STATUS_INVALID_PARAMETER;
    }

    if (RtlValidSid( iSid ) != TRUE) {
        return STATUS_INVALID_SID;
    }

    if ( iSid->Revision != SID_REVISION ) {
        return STATUS_INVALID_SID;
    }

    if (pWildcardSid->WildcardPos != -1 &&
        pWildcardSid->WildcardPos > iSid->SubAuthorityCount) {
        return STATUS_INVALID_SID;
    }

    LocalString.Buffer = UniBuffer;
    LocalString.Length = 0;
    LocalString.MaximumLength = 256 * sizeof(WCHAR);
    RtlAppendUnicodeToString(&LocalString, L"S-1-");

    // adjust the buffer so that the start of it is where the end was.
    // (note that we don't set Length, since RtlIntXXXToUnicodeString
    // directly overwrite from at the start of the buffer)
    LocalString.MaximumLength -= LocalString.Length;
    LocalString.Buffer += LocalString.Length / sizeof(WCHAR);

    if (  (iSid->IdentifierAuthority.Value[0] != 0)  ||
          (iSid->IdentifierAuthority.Value[1] != 0)     ){

        //
        // Ugly hex dump.
        //

        Auth.HighPart = (LONG) (iSid->IdentifierAuthority.Value[ 0 ] << 8) +
                        (LONG) iSid->IdentifierAuthority.Value[ 1 ] ;

        Auth.LowPart = (ULONG)iSid->IdentifierAuthority.Value[5]          +
                       (ULONG)(iSid->IdentifierAuthority.Value[4] <<  8)  +
                       (ULONG)(iSid->IdentifierAuthority.Value[3] << 16)  +
                       (ULONG)(iSid->IdentifierAuthority.Value[2] << 24);

        Status = RtlInt64ToUnicodeString(Auth.QuadPart, 16, &LocalString);

    } else {

        Tmp = (ULONG)iSid->IdentifierAuthority.Value[5]          +
              (ULONG)(iSid->IdentifierAuthority.Value[4] <<  8)  +
              (ULONG)(iSid->IdentifierAuthority.Value[3] << 16)  +
              (ULONG)(iSid->IdentifierAuthority.Value[2] << 24);

        Status = RtlIntegerToUnicodeString(
                        Tmp,
                        10,
                        &LocalString);
    }

    if ( !NT_SUCCESS( Status ) )
    {
        return Status;
    }


    if (pWildcardSid->WildcardPos != -1)
    {
        //
        // Stringify the leading sub-authorities within the SID.
        //
        for (i = 0; i < pWildcardSid->WildcardPos; i++ ) {

            // Tack on a hyphen.
            Status = RtlAppendUnicodeToString(&LocalString, L"-");
            if ( !NT_SUCCESS( Status ) ) {
                return Status;
            }

            // adjust the buffer so that the start of it is where the end was.
            // (note that we don't set Length, since RtlIntXXXToUnicodeString
            // directly overwrite from at the start of the buffer)
            LocalString.MaximumLength -= LocalString.Length;
            LocalString.Buffer += LocalString.Length / sizeof(WCHAR);

            // Tack on the next subauthority.
            ASSERT( i < iSid->SubAuthorityCount );
            Status = RtlIntegerToUnicodeString(
                            iSid->SubAuthority[ i ],
                            10,
                            &LocalString );

            if ( !NT_SUCCESS( Status ) ) {
                return Status;
            }
        }


        //
        // Place the wildcard asterick within the buffer.
        //
        Status = RtlAppendUnicodeToString(&LocalString, L"-*");
        if (!NT_SUCCESS(Status)) {
            return Status;
        }


        //
        // Stringify all remaining sub-authorities within the SID.
        //
        for (; i < iSid->SubAuthorityCount; i++ ) {

            // tack on a hyphen.
            Status = RtlAppendUnicodeToString(&LocalString, L"-");
            if ( !NT_SUCCESS(Status) ) {
                return Status;
            }

            // adjust the buffer so that the start of it is where the end was.
            // (note that we don't set Length, since RtlIntXXXToUnicodeString
            // directly overwrite from at the start of the buffer)
            LocalString.MaximumLength -= LocalString.Length;
            LocalString.Buffer += LocalString.Length / sizeof(WCHAR);

            // tack on the next subauthority.
            Status = RtlIntegerToUnicodeString(
                            iSid->SubAuthority[ i ],
                            10,
                            &LocalString);

            if ( !NT_SUCCESS( Status ) ) {
                return Status;
            }
        }
    }
    else
    {
        for (i=0;i<iSid->SubAuthorityCount ;i++ ) {

            // tack on a hyphen.
            Status = RtlAppendUnicodeToString(&LocalString, L"-");
            if ( !NT_SUCCESS( Status ) ) {
                return Status;
            }

            // adjust the buffer so that the start of it is where the end was.
            // (note that we don't set Length, since RtlIntXXXToUnicodeString
            // directly overwrite from at the start of the buffer)
            LocalString.MaximumLength -= LocalString.Length;
            LocalString.Buffer += LocalString.Length / sizeof(WCHAR);

            // tack on the next subauthority.
            Status = RtlIntegerToUnicodeString(
                            iSid->SubAuthority[ i ],
                            10,
                            &LocalString );

            if ( !NT_SUCCESS( Status ) ) {
                return Status;
            }
        }
    }

    Status = RtlDuplicateUnicodeString(
            RTL_DUPLICATE_UNICODE_STRING_NULL_TERMINATE,
            &LocalString, pUnicodeOutput);

    return Status;
}



BOOLEAN NTAPI
CodeAuthzpCompareWildcardSidWithSid(
    IN PAUTHZ_WILDCARDSID pWildcardSid,
    IN PSID pMatchSid
    )
/*++

Routine Description:

    Determines if a given SID matches when compared against a
    wildcard SID pattern.

Arguments:

    pWildcardSid - the wildcard SID pattern to evaluate.

    pMatchSid - the single SID to test.

Return Value:

    Returns TRUE if the specified wildcard SID matches against the
    specified single SID.  Otherwise returns FALSE.

--*/
{
    DWORD wildcardpos;
    ASSERT( ARGUMENT_PRESENT(pWildcardSid) && ARGUMENT_PRESENT(pMatchSid) );
    ASSERT( RtlValidSid(pWildcardSid->Sid) );

    wildcardpos = pWildcardSid->WildcardPos;
    if (wildcardpos != -1)
    {
        // This is a wildcard SID and needs to be handled specially.
        PISID wildsid = (PISID) pWildcardSid->Sid;
        PISID matchsid = (PISID) pMatchSid;

        ASSERT( wildcardpos <= wildsid->SubAuthorityCount );

        if (wildsid->Revision == matchsid->Revision )
        {
            if ( (wildsid->IdentifierAuthority.Value[0] ==
                  matchsid->IdentifierAuthority.Value[0])  &&
                 (wildsid->IdentifierAuthority.Value[1]==
                  matchsid->IdentifierAuthority.Value[1])  &&
                 (wildsid->IdentifierAuthority.Value[2] ==
                  matchsid->IdentifierAuthority.Value[2])  &&
                 (wildsid->IdentifierAuthority.Value[3] ==
                  matchsid->IdentifierAuthority.Value[3])  &&
                 (wildsid->IdentifierAuthority.Value[4] ==
                  matchsid->IdentifierAuthority.Value[4])  &&
                 (wildsid->IdentifierAuthority.Value[5] ==
                  matchsid->IdentifierAuthority.Value[5])
                )
            {
                if (matchsid->SubAuthorityCount >= wildsid->SubAuthorityCount)
                {
                    DWORD Index, IndexDiff;

                    //
                    // Ensure the prefix part of the wildcard matches.
                    //
                    ASSERT(wildcardpos <= matchsid->SubAuthorityCount );
                    for (Index = 0; Index < wildcardpos; Index++) {
                        if (wildsid->SubAuthority[Index] !=
                                matchsid->SubAuthority[Index])
                            return FALSE;
                    }

                    //
                    // Ensure the postfix part of the wildcard matches.
                    //
                    IndexDiff = (matchsid->SubAuthorityCount - wildsid->SubAuthorityCount);
                    for (Index = wildcardpos; Index < wildsid->SubAuthorityCount; Index++) {
                        if (wildsid->SubAuthority[Index] !=
                                matchsid->SubAuthority[Index + IndexDiff])
                            return FALSE;
                    }

                    return TRUE;        // matches okay!
                }
            }
        }
        return FALSE;
    }
    else
    {
        // This is a normal SID so we can compare directly.
        return RtlEqualSid(pWildcardSid->Sid, pMatchSid);
    }
}



BOOLEAN NTAPI
CodeAuthzpSidInWildcardList (
    IN PAUTHZ_WILDCARDSID   WildcardList    OPTIONAL,
    IN ULONG                WildcardCount,
    IN PSID                 SePrincipalSelfSid   OPTIONAL,
    IN PSID                 PrincipalSelfSid   OPTIONAL,
    IN PSID                 Sid
    )
/*++

Routine Description:

    Checks to see if a given SID is in the given list of Wildcards.

    N.B. The code to compute the length of a SID and test for equality
         is duplicated from the security runtime since this is such a
         frequently used routine.

    This function is mostly copied from the SepSidInSidAndAttributes
    found in ntos\se\tokendup.c, except it handles PrincipalSelfSid
    within the list as well as the passed in Sid.  SePrincipalSelfSid
    is also a parameter here, instead of an ntoskrnl global.  also the
    HonorEnabledAttribute argument was added.

Arguments:

    WildcardList - Pointer to the wildcard sid list to be examined

    WildcardCount - Number of entries in the WildcardList array.

    SePrincipalSelfSid - This parameter should optionally be the SID that
        will be replaced with the PrincipalSelfSid if this SID is encountered
        in any ACE.  This SID should be generated from SECURITY_PRINCIPAL_SELF_RID

        The parameter should be NULL if the object does not represent a principal.


    PrincipalSelfSid - If the object being access checked is an object which
        represents a principal (e.g., a user object), this parameter should
        be the SID of the object.  Any ACE containing the constant
        SECURITY_PRINCIPAL_SELF_RID is replaced by this SID.

        The parameter should be NULL if the object does not represent a principal.


    Sid - Pointer to the SID of interest


Return Value:

    A value of TRUE indicates that the SID is in the token, FALSE
    otherwise.

--*/
{
    ULONG i;

    ASSERT( ARGUMENT_PRESENT(Sid) );

    if ( !ARGUMENT_PRESENT(WildcardList) || !WildcardCount ) {
        return FALSE;
    }

    //
    // If Sid is the constant PrincipalSelfSid,
    //  replace it with the passed in PrincipalSelfSid.
    //

    if ( ARGUMENT_PRESENT(PrincipalSelfSid) &&
         ARGUMENT_PRESENT(SePrincipalSelfSid) &&
         RtlEqualSid( SePrincipalSelfSid, Sid ) )
    {
        ASSERT( !RtlEqualSid(SePrincipalSelfSid, PrincipalSelfSid) );
        Sid = PrincipalSelfSid;
    }

    //
    // Scan through the user/groups and attempt to find a match with the
    // specified SID.
    //

    for (i = 0 ; i < WildcardCount ; i++, WildcardList++)
    {
        //
        // If the SID is the principal self SID, then compare it.
        //

        if ( ARGUMENT_PRESENT(SePrincipalSelfSid) &&
             ARGUMENT_PRESENT(PrincipalSelfSid) &&
             WildcardList->WildcardPos == -1 &&
             RtlEqualSid(SePrincipalSelfSid, WildcardList->Sid))
        {
            if (RtlEqualSid( PrincipalSelfSid, Sid ))
                return TRUE;
        }

        //
        // If the Wildcard SID matches the individual SID, then great.
        //

        else if ( CodeAuthzpCompareWildcardSidWithSid(WildcardList, Sid ) )
        {
            return TRUE;
        }
    }

    return FALSE;
}



BOOLEAN NTAPI
CodeAuthzpInvertAndAddSids(
    IN HANDLE                   InAccessToken,
    IN PSID                     InTokenOwner    OPTIONAL,
    IN DWORD                    InvertSidCount,
    IN PAUTHZ_WILDCARDSID       SidsToInvert,
    IN DWORD                    SidsAddedCount  OPTIONAL,
    IN PSID_AND_ATTRIBUTES      SidsToAdd       OPTIONAL,
    OUT DWORD                  *NewDisabledSidCount,
    OUT PSID_AND_ATTRIBUTES    *NewSidsToDisable
    )
/*++

Routine Description:

    Takes an input token and extracts its membership groups.
    A "left outer" set combination (non-intersection) of the
    membership groups with the SidsToInvert parameter.
    Additionally, the SidsToAdd list specifies a list of SIDs
    that will be optionally added to the resulting set.
    The final result is returned within a specified pointer.

Arguments:

    InAccessToken - Input token from which the membership group SIDs
        will be taken from.

    InTokenOwner - Optionally specifies the TokenUser of the specifies
        InAccessToken.  This SID is used to replace any instances of
        SECURITY_PRINCIPAL_SELF_RID  that are encountered in either
        the SidsToInvert or SidsToAdd arrays.  If this value is not
        specified, then no replacements will be made.


    InvertSidCount - Number of SIDs in the SidsToInvert array.

    SidsToInvert - Array of the allowable SIDs that should be kept.
        All of the token's group SIDs that are not one of these
        will be removed from the resulting set.


    SidsAddedCount - Optional number of SIDs in the SidsToAdd array.

    SidsToAdd - Optionally specifies the SIDs that should be
        explicitly added into the resultant set after the


    NewDisabledSidCount - Receives the number of SIDs within the
        final group array.

    NewSidsToDisable - Receives a pointer to the final group array.
        This memory pointer must be freed by the caller with RtlFreeHeap().
        All SID pointers within this resultant array are pointers within
        the contiguous piece of memory that make up the list itself.


Return Value:

    A value of TRUE indicates that the operation was successful,
    FALSE otherwise.

--*/
{
    SID_IDENTIFIER_AUTHORITY SIDAuth = SECURITY_NT_AUTHORITY;
    DWORD Index;
    DWORD NewSidTotalSize;
    DWORD NewSidListCount;
    LPBYTE nextFreeByte;
    PSID_AND_ATTRIBUTES NewSidList = NULL;
    PTOKEN_GROUPS tokenGroupsPtr = NULL;
    PSID SePrincipalSelfSid = NULL;


    //
    // Generate the principal self sid value so we know what to replace.
    //
    if (ARGUMENT_PRESENT(InTokenOwner))
    {
        if (!NT_SUCCESS(RtlAllocateAndInitializeSid(&SIDAuth, 1,
            SECURITY_PRINCIPAL_SELF_RID, 0, 0, 0, 0, 0, 0, 0,
            &SePrincipalSelfSid))) goto ExitHandler;
    }


    //
    // Obtain the current SID membership list from the token.
    //
    ASSERT( ARGUMENT_PRESENT(InAccessToken) );
    tokenGroupsPtr = (PTOKEN_GROUPS) CodeAuthzpGetTokenInformation(InAccessToken, TokenGroups);
    if (!tokenGroupsPtr) goto ExitHandler;


    //
    // Edit (in place) the tokenGroups and keep only SIDs that
    // are not also present in SidsToInvert list.
    //
    NewSidTotalSize = 0;
    ASSERT( ARGUMENT_PRESENT(SidsToInvert) );
    for (Index = 0; Index < tokenGroupsPtr->GroupCount; Index++)
    {
        if ( CodeAuthzpSidInWildcardList(
            SidsToInvert,           // the wildcard list
            InvertSidCount,         // number of wildcards
            SePrincipalSelfSid,     // principal self sid to search for
            InTokenOwner,           // principal self sid to replace with
            tokenGroupsPtr->Groups[Index].Sid
            ))
        {
            // SID was found, so we need to remove its
            // SID_AND_ATTRIBUTES entry from the list.
            RtlMoveMemory(&tokenGroupsPtr->Groups[Index],
                    &tokenGroupsPtr->Groups[Index+1],
                    sizeof(SID_AND_ATTRIBUTES) *
                        (tokenGroupsPtr->GroupCount - Index - 1));
            tokenGroupsPtr->GroupCount--;
            Index--;
        } else {
            // This SID should be kept, so remember how big it was.
            NewSidTotalSize += sizeof(SID_AND_ATTRIBUTES) +
                RtlLengthSid(tokenGroupsPtr->Groups[Index].Sid);
        }
    }


    //
    // Determine the space usage for any additional SIDs we need to add.
    //
    if (ARGUMENT_PRESENT(SidsToAdd))
    {
        for (Index = 0; Index < SidsAddedCount; Index++) {
            NewSidTotalSize += sizeof(SID_AND_ATTRIBUTES) +
                RtlLengthSid(SidsToAdd[Index].Sid);
        }
    } else {
        SidsAddedCount = 0;
    }


    //
    // Allocate a fresh SID_AND_ATTRIBUTES array that also includes
    // space for any extra SIDs we need to add.
    //
    ASSERT(NewSidTotalSize > 0);
    NewSidList = (PSID_AND_ATTRIBUTES) RtlAllocateHeap(RtlProcessHeap(),
            0, NewSidTotalSize);
    if (NewSidList == NULL)
        goto ExitHandler;


    //
    // Populate the new SID_AND_ATTRIBUTES array.
    //
    nextFreeByte = ((LPBYTE)NewSidList) + sizeof(SID_AND_ATTRIBUTES) *
            (tokenGroupsPtr->GroupCount + SidsAddedCount);
    NewSidListCount = tokenGroupsPtr->GroupCount;
    for (Index = 0; Index < NewSidListCount; Index++)
    {
        DWORD dwSidLength = RtlLengthSid(tokenGroupsPtr->Groups[Index].Sid);
        ASSERT(nextFreeByte + dwSidLength <= ((LPBYTE)NewSidList) + NewSidTotalSize);

        NewSidList[Index].Sid = (PSID) nextFreeByte;
        NewSidList[Index].Attributes = 0;           // must be zero.
        RtlCopyMemory(nextFreeByte, tokenGroupsPtr->Groups[Index].Sid, dwSidLength);

        nextFreeByte += dwSidLength;
    }
    for (Index = 0; Index < SidsAddedCount; Index++)
    {
        DWORD dwSidLength = RtlLengthSid(SidsToAdd[Index].Sid);
        ASSERT(nextFreeByte + dwSidLength <= ((LPBYTE) NewSidList) + NewSidTotalSize);

        NewSidList[NewSidListCount].Sid = (PSID) nextFreeByte;
        NewSidList[NewSidListCount].Attributes = 0;         // must be zero.
        RtlCopyMemory(nextFreeByte, SidsToAdd[Index].Sid, dwSidLength);

        NewSidListCount++;
        nextFreeByte += dwSidLength;
    }
    ASSERT(nextFreeByte <= ((LPBYTE)NewSidList) + NewSidTotalSize);


    //
    // Release allocated memory, but not the resultant array that we'll return.
    //
    RtlFreeHeap(RtlProcessHeap(), 0, (LPVOID) tokenGroupsPtr);

    if (SePrincipalSelfSid != NULL)
        RtlFreeSid(SePrincipalSelfSid);


    //
    // Success, return the result.
    //
    *NewSidsToDisable = NewSidList;
    *NewDisabledSidCount = NewSidListCount;
    return TRUE;


    //
    // Release allocated memory.
    //
ExitHandler:
    if (tokenGroupsPtr != NULL)
        RtlFreeHeap(RtlProcessHeap(), 0, (LPVOID) tokenGroupsPtr);
    if (NewSidList != NULL)
        RtlFreeHeap(RtlProcessHeap(), 0, (LPVOID) NewSidList);
    if (SePrincipalSelfSid != NULL)
        RtlFreeSid(SePrincipalSelfSid);

    return FALSE;
}


BOOLEAN NTAPI
CodeAuthzpExpandWildcardList(
    IN HANDLE                   InAccessToken,
    IN PSID                     InTokenOwner   OPTIONAL,
    IN DWORD                    WildcardCount,
    IN PAUTHZ_WILDCARDSID       WildcardList,
    OUT DWORD                  *OutSidCount,
    OUT PSID_AND_ATTRIBUTES    *OutSidList
    )
/*++

Routine Description:

    Takes an input token and extracts its membership groups.
    The specified list of Wildcard SIDs are used to identify
    all matching membership groups and an allocated list of all
    such SIDs are returned.

Arguments:

    InAccessToken - Input token from which the membership group SIDs
        will be taken from.

    InTokenOwner - Optionally specifies the TokenUser of the specifies
        InAccessToken.  This SID is used to replace any instances of
        SECURITY_PRINCIPAL_SELF_RID  that are encountered in either
        the SidsToInvert or SidsToAdd arrays.  If this value is not
        specified, then no replacements will be made.


    WildcardCount - Number of SIDs in the WildcardList array.

    WildcardList - Array of the allowable SIDs that should be kept.
        All of the token's group SIDs that are not one of these
        will be removed from the resulting set.


    OutSidCount - Receives the number of SIDs within the
        final group array.

    OutSidList - Receives a pointer to the final group array.
        This memory pointer must be freed by the caller with RtlFreeHeap().
        All SID pointers within this resultant array are pointers within
        the contiguous piece of memory that make up the list itself.


Return Value:

    A value of TRUE indicates that the operation was successful,
    FALSE otherwise.

--*/
{
    SID_IDENTIFIER_AUTHORITY SIDAuth = SECURITY_NT_AUTHORITY;
    DWORD Index;
    DWORD NewSidTotalSize;
    DWORD NewSidListCount;
    LPBYTE nextFreeByte;
    PSID_AND_ATTRIBUTES NewSidList = NULL;
    PTOKEN_GROUPS tokenGroupsPtr = NULL;
    PSID SePrincipalSelfSid = NULL;


    //
    // Generate the principal self sid value so we know what to replace.
    //
    if (ARGUMENT_PRESENT(InTokenOwner))
    {
        if (!NT_SUCCESS(RtlAllocateAndInitializeSid(&SIDAuth, 1,
            SECURITY_PRINCIPAL_SELF_RID, 0, 0, 0, 0, 0, 0, 0,
            &SePrincipalSelfSid))) goto ExitHandler;
    }


    //
    // Obtain the current SID membership list from the token.
    //
    ASSERT( ARGUMENT_PRESENT(InAccessToken) );
    tokenGroupsPtr = (PTOKEN_GROUPS) CodeAuthzpGetTokenInformation(InAccessToken, TokenGroups);
    if (!tokenGroupsPtr) goto ExitHandler;


    //
    // Edit (in place) the tokenGroups and keep only SIDs that
    // are not also present in SidsToInvert list.
    //
    NewSidTotalSize = 0;
    ASSERT( ARGUMENT_PRESENT(WildcardList) );
    for (Index = 0; Index < tokenGroupsPtr->GroupCount; Index++)
    {
        if ( CodeAuthzpSidInWildcardList(
            WildcardList,           // the wildcard list
            WildcardCount,         // number of wildcards
            SePrincipalSelfSid,     // principal self sid to search for
            InTokenOwner,           // principal self sid to replace with
            tokenGroupsPtr->Groups[Index].Sid
            ))
        {
            // This SID should be kept, so remember how big it was.
            NewSidTotalSize += sizeof(SID_AND_ATTRIBUTES) +
                RtlLengthSid(tokenGroupsPtr->Groups[Index].Sid);
        } else {
            // SID was not found, so we need to remove its
            // SID_AND_ATTRIBUTES entry from the list.
            RtlMoveMemory(&tokenGroupsPtr->Groups[Index],
                    &tokenGroupsPtr->Groups[Index+1],
                    sizeof(SID_AND_ATTRIBUTES) *
                        (tokenGroupsPtr->GroupCount - Index - 1));
            tokenGroupsPtr->GroupCount--;
            Index--;
        }
    }


    //
    // Allocate a fresh SID_AND_ATTRIBUTES array that also includes
    // space for any extra SIDs we need to add.
    //
    NewSidList = (PSID_AND_ATTRIBUTES) RtlAllocateHeap(RtlProcessHeap(),
            0, NewSidTotalSize);
    if (NewSidList == NULL)
        goto ExitHandler;


    //
    // Populate the new SID_AND_ATTRIBUTES array.
    //
    nextFreeByte = ((LPBYTE)NewSidList) + sizeof(SID_AND_ATTRIBUTES) *
            tokenGroupsPtr->GroupCount;
    NewSidListCount = tokenGroupsPtr->GroupCount;
    for (Index = 0; Index < NewSidListCount; Index++)
    {
        DWORD dwSidLength = RtlLengthSid(tokenGroupsPtr->Groups[Index].Sid);
        ASSERT(nextFreeByte + dwSidLength <= ((LPBYTE)NewSidList) + NewSidTotalSize);

        NewSidList[Index].Sid = (PSID) nextFreeByte;
        NewSidList[Index].Attributes = 0;           // must be zero.
        RtlCopyMemory(nextFreeByte, tokenGroupsPtr->Groups[Index].Sid, dwSidLength);

        nextFreeByte += dwSidLength;
    }
    ASSERT(nextFreeByte <= ((LPBYTE)NewSidList) + NewSidTotalSize);


    //
    // Release allocated memory, but not the resultant array that we'll return.
    //
    RtlFreeHeap(RtlProcessHeap(), 0, (LPVOID) tokenGroupsPtr);

    if (SePrincipalSelfSid != NULL)
        RtlFreeSid(SePrincipalSelfSid);


    //
    // Success, return the result.
    //
    *OutSidList = NewSidList;
    *OutSidCount = NewSidListCount;
    return TRUE;


    //
    // Release allocated memory.
    //
ExitHandler:
    if (tokenGroupsPtr != NULL)
        RtlFreeHeap(RtlProcessHeap(), 0, (LPVOID) tokenGroupsPtr);
    if (NewSidList != NULL)
        RtlFreeHeap(RtlProcessHeap(), 0, (LPVOID) NewSidList);
    if (SePrincipalSelfSid != NULL)
        RtlFreeSid(SePrincipalSelfSid);

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\winsafer\safepolr.c ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    safepolr.c         (SAFER Code Authorization Policy)

Abstract:

    This module implements the WinSAFER APIs that query and set the
    persisted and cached policy definitions.

Author:

    Jeffrey Lawson (JLawson) - Apr 1999

Environment:

    User mode only.

Exported Functions:


Revision History:

    Created - Apr 1999

--*/

#include "pch.h"
#pragma hdrstop
#include <winsafer.h>
#include <winsaferp.h>
#include "saferp.h"




NTSTATUS NTAPI
CodeAuthzPol_GetInfoCached_LevelListRaw(
        IN DWORD    dwScopeId,
        IN DWORD    InfoBufferSize OPTIONAL,
        OUT PVOID   InfoBuffer OPTIONAL,
        OUT PDWORD  InfoBufferRetSize OPTIONAL
        )
/*++

Routine Description:

    Asks the system to query for the list of available
    WinSafer Levels for the currently loaded policy scope.

Arguments:

    dwScopeId - specifies the registry scope that will be examined.
        If the currently cached scope included a registry handle
        then AUTHZSCOPE_REGISTRY must be specified.  Otherwise,
        this must be SAFER_SCOPEID_MACHINE.

    InfoBufferSize - optionally specifies the size of input buffer
        supplied by the caller to receive the results.  If this argument
        is supplied, then InfoBuffer must also be supplied.

    InfoBuffer - optionally specifies the input buffer that was
        supplied by the caller to receive the results.  If this argument
        is supplied, then InfoBufferSize must also be supplied.

    InfoBufferRetSize - optionally specifies a pointer that will receive
        the size of the results actually written to the InfoBuffer.

Return Value:

    Returns STATUS_SUCCESS on successful return.  Otherwise a status
    code such as STATUS_BUFFER_TOO_SMALL or STATUS_NOT_FOUND.

--*/
{
    NTSTATUS Status;
    PVOID RestartKey;
    PAUTHZLEVELTABLERECORD authzobj;
    DWORD dwSizeNeeded;
    LPVOID lpNextPtr, lpEndBuffer;


    //
    // Load the list of all of the available objects.
    //
    if (!g_bInitializedFirstTime) {
        Status = STATUS_UNSUCCESSFUL;
        goto ExitHandler;
    }
    RtlEnterCriticalSection(&g_TableCritSec);
    if (g_hKeyCustomRoot != NULL) {
        if (dwScopeId != SAFER_SCOPEID_REGISTRY) {
            Status = STATUS_INVALID_PARAMETER_MIX;
            goto ExitHandler2;
        }
    } else {
        if (dwScopeId != SAFER_SCOPEID_MACHINE &&
            dwScopeId != SAFER_SCOPEID_USER) {
            Status = STATUS_INVALID_PARAMETER_MIX;
            goto ExitHandler2;
        }
    }
    if (g_bNeedCacheReload) {
        Status = CodeAuthzpImmediateReloadCacheTables();
        if (!NT_SUCCESS(Status)) {
            goto ExitHandler2;
        }
    }
    if (RtlIsGenericTableEmpty(&g_CodeLevelObjTable)) {
        Status = STATUS_NOT_FOUND;
        goto ExitHandler2;
    }

    //
    // Determine the necessary size needed to store a DWORD array
    // of all of the Levels that were found in this scope.
    //
	dwSizeNeeded = 0;
    RestartKey = NULL;
    for (authzobj = (PAUTHZLEVELTABLERECORD)
                RtlEnumerateGenericTableWithoutSplaying(
                    &g_CodeLevelObjTable, &RestartKey);
        authzobj != NULL;
        authzobj = (PAUTHZLEVELTABLERECORD)
                RtlEnumerateGenericTableWithoutSplaying(
                    &g_CodeLevelObjTable, &RestartKey))
    {
		if (authzobj->isEnumerable) {  //only allow enumeration if the level is enumerable
			dwSizeNeeded += sizeof(DWORD);
		}
	}

    if (!ARGUMENT_PRESENT(InfoBuffer) ||
            !InfoBufferSize ||
            InfoBufferSize < dwSizeNeeded)
    {
        if (ARGUMENT_PRESENT(InfoBufferRetSize))
            *InfoBufferRetSize = dwSizeNeeded;

        Status = STATUS_BUFFER_TOO_SMALL;
        goto ExitHandler2;
    }



    //
    // Fill the buffer with the resulting data.
    //
    lpNextPtr = (LPVOID) InfoBuffer;
    lpEndBuffer = (LPVOID) ( ((LPBYTE) InfoBuffer) + InfoBufferSize);
    RestartKey = NULL;
    for (authzobj = (PAUTHZLEVELTABLERECORD)
                RtlEnumerateGenericTableWithoutSplaying(
                    &g_CodeLevelObjTable, &RestartKey);
        authzobj != NULL;
        authzobj = (PAUTHZLEVELTABLERECORD)
                RtlEnumerateGenericTableWithoutSplaying(
                    &g_CodeLevelObjTable, &RestartKey))
    {
		if (authzobj->isEnumerable) {  //only allow enumeration if the level is enumerable
	        *((PDWORD)lpNextPtr) = authzobj->dwLevelId;
   		     lpNextPtr = (LPVOID) ( ((PBYTE) lpNextPtr) + sizeof(DWORD));
		}
    }
    ASSERT(lpNextPtr <= lpEndBuffer);


    //
    // Return the final buffer size and result code.
    //
    if (ARGUMENT_PRESENT(InfoBufferRetSize))
        *InfoBufferRetSize = (DWORD) ((PBYTE) lpNextPtr - (PBYTE) InfoBuffer);

    Status = STATUS_SUCCESS;

ExitHandler2:
    RtlLeaveCriticalSection(&g_TableCritSec);

ExitHandler:
    return Status;
}



NTSTATUS NTAPI
SaferpPol_GetInfoCommon_DefaultLevel(
        IN DWORD        dwScopeId,
        IN DWORD        InfoBufferSize OPTIONAL,
        OUT PVOID       InfoBuffer OPTIONAL,
        OUT PDWORD      InfoBufferRetSize OPTIONAL,
        IN BOOLEAN      bUseCached
        )
/*++

Routine Description:

    Queries the current WinSafer Level that has been configured to be
    the default policy level.

    Note that this query always accepts a constant-sized buffer that
    is only a single DWORD in length.

    Although this API directly queries the registry scope indicated,
    the pre-cached list of available Levels is used to validate the
    specified Level.

Arguments:

    dwScopeId - specifies the registry scope that will be examined.
        If the currently cached scope included a registry handle
        then AUTHZSCOPE_REGISTRY must be specified.  Otherwise,
        this can be SAFER_SCOPEID_MACHINE or SAFER_SCOPEID_USER.

    InfoBufferSize - optionally specifies the size of input buffer
        supplied by the caller to receive the results.  If this argument
        is supplied, then InfoBuffer must also be supplied.

    InfoBuffer - optionally specifies the input buffer that was
        supplied by the caller to receive the results.  If this argument
        is supplied, then InfoBufferSize must also be supplied.

    InfoBufferRetSize - optionally specifies a pointer that will receive
        the size of the results actually written to the InfoBuffer.

Return Value:

    Returns STATUS_SUCCESS on a successful query result.  InfoBuffer will
        be filled with a single DWORD of the level that has been configured
        to be the default level for this scope.  InfoBufferRetSize will
        contain the length of the result (a single DWORD).
    Returns STATUS_NOT_FOUND if no default level has been configured
        for the given scope (or the level defined does not exist).
    Returns STATUS_BUFFER_TOO_SMALL if there was a defined default level
        but a buffer was not supplied, or the buffer supplied was too
        small to accomodate the results.

--*/
{
    NTSTATUS Status;
    DWORD dwNewLevelId = (DWORD) -1;


    //
    // Open up the regkey to the base of the policies.
    //
    if (!g_bInitializedFirstTime) {
        Status = STATUS_UNSUCCESSFUL;
        goto ExitHandler;
    }
    RtlEnterCriticalSection(&g_TableCritSec);
    if (g_hKeyCustomRoot != NULL) {
        if (dwScopeId != SAFER_SCOPEID_REGISTRY) {
            Status = STATUS_INVALID_PARAMETER_MIX;
            goto ExitHandler2;
        }
    } else {
        if (dwScopeId != SAFER_SCOPEID_MACHINE &&
            dwScopeId != SAFER_SCOPEID_USER) {
            Status = STATUS_INVALID_PARAMETER_MIX;
            goto ExitHandler2;
        }
    }
    if (g_bNeedCacheReload) {
        Status = CodeAuthzpImmediateReloadCacheTables();
        if (!NT_SUCCESS(Status)) {
            goto ExitHandler2;
        }
    }
    if (RtlIsGenericTableEmpty(&g_CodeLevelObjTable)) {
        Status = STATUS_NOT_FOUND;
        goto ExitHandler2;
    }


    //
    // Query the current value setting.
    //
    if (!bUseCached)
    {
        HANDLE hKeyBase;
        ULONG ActualSize;
        UNICODE_STRING ValueName;
        WCHAR KeyPathBuffer[ MAXIMUM_FILENAME_LENGTH+6 ];
        PKEY_VALUE_FULL_INFORMATION ValueBuffer =
            (PKEY_VALUE_FULL_INFORMATION) KeyPathBuffer;

        Status = CodeAuthzpOpenPolicyRootKey(
                    dwScopeId,
                    g_hKeyCustomRoot,
                    L"\\" SAFER_CODEIDS_REGSUBKEY,
                    KEY_READ, FALSE, &hKeyBase);
        if (NT_SUCCESS(Status))
        {
            RtlInitUnicodeString(&ValueName, SAFER_DEFAULTOBJ_REGVALUE);
            Status = NtQueryValueKey(hKeyBase,
                                     &ValueName,
                                     KeyValueFullInformation,
                                     ValueBuffer,     // ptr to KeyPathBuffer
                                     sizeof(KeyPathBuffer),
                                     &ActualSize);
            if (NT_SUCCESS(Status)) {
                if (ValueBuffer->Type != REG_DWORD ||
                    ValueBuffer->DataLength != sizeof(DWORD)) {
                    Status = STATUS_NOT_FOUND;
                } else {
                    dwNewLevelId = * (PDWORD) ((PBYTE) ValueBuffer +
                            ValueBuffer->DataOffset);
                }
            }
            NtClose(hKeyBase);
        }
        if (!NT_SUCCESS(Status)) {
            goto ExitHandler2;
        }
    }
    else
    {
        if (dwScopeId == SAFER_SCOPEID_USER) {
            if (!g_DefaultCodeLevelUser) {
                dwNewLevelId = SAFER_LEVELID_FULLYTRUSTED;
            } else {
                dwNewLevelId = g_DefaultCodeLevelUser->dwLevelId;
            }
        } else {
            if (!g_DefaultCodeLevelMachine) {
                dwNewLevelId = SAFER_LEVELID_FULLYTRUSTED;
            } else {
                dwNewLevelId = g_DefaultCodeLevelMachine->dwLevelId;
            }
        }
    }


    //
    // Make sure the level we found is actually
    // valid (still in our level table).
    //
    if (!CodeAuthzLevelObjpLookupByLevelId(
            &g_CodeLevelObjTable, dwNewLevelId)) {
        Status = STATUS_NOT_FOUND;
        goto ExitHandler2;
    }


    //
    // Make sure the target buffer is large
    // enough and copy the levelid into it.
    //
    if (!ARGUMENT_PRESENT(InfoBuffer) ||
            InfoBufferSize < sizeof(DWORD)) {
        Status = STATUS_BUFFER_TOO_SMALL;
    } else {
        RtlCopyMemory(InfoBuffer, &dwNewLevelId, sizeof(DWORD));
        Status = STATUS_SUCCESS;
    }
    if (ARGUMENT_PRESENT(InfoBufferRetSize))
        *InfoBufferRetSize = sizeof(DWORD);


ExitHandler2:
    RtlLeaveCriticalSection(&g_TableCritSec);
ExitHandler:
    return Status;
}


NTSTATUS NTAPI
CodeAuthzPol_GetInfoCached_DefaultLevel(
        IN DWORD        dwScopeId,
        IN DWORD        InfoBufferSize OPTIONAL,
        OUT PVOID       InfoBuffer OPTIONAL,
        OUT PDWORD      InfoBufferRetSize OPTIONAL
        )
{
    return SaferpPol_GetInfoCommon_DefaultLevel(
        dwScopeId,
        InfoBufferSize,
        InfoBuffer,
        InfoBufferRetSize,
        TRUE);
}


NTSTATUS NTAPI
CodeAuthzPol_GetInfoRegistry_DefaultLevel(
        IN DWORD        dwScopeId,
        IN DWORD        InfoBufferSize OPTIONAL,
        OUT PVOID       InfoBuffer OPTIONAL,
        OUT PDWORD      InfoBufferRetSize OPTIONAL
        )
{
    return SaferpPol_GetInfoCommon_DefaultLevel(
        dwScopeId,
        InfoBufferSize,
        InfoBuffer,
        InfoBufferRetSize,
        FALSE);
}




NTSTATUS NTAPI
CodeAuthzPol_SetInfoDual_DefaultLevel(
        IN DWORD        dwScopeId,
        IN DWORD        InfoBufferSize,
        OUT PVOID       InfoBuffer
        )
/*++

Routine Description:

    Modifies the current WinSafer Level that has been configured to be
    the default policy level.

    Note that this query always accepts a constant-sized buffer that
    is only a single DWORD in length.

Arguments:

    dwScopeId - specifies the registry scope that will be examined.
        If the currently cached scope included a registry handle
        then AUTHZSCOPE_REGISTRY must be specified.  Otherwise,
        this can be SAFER_SCOPEID_MACHINE or SAFER_SCOPEID_USER.

    InfoBufferSize - specifies the size of input buffer
        supplied by the caller to receive the results.

    InfoBuffer - specifies the input buffer that was
        supplied by the caller to receive the results.

Return Value:

    Returns STATUS_SUCCESS on a successful query result.  InfoBuffer will
        be filled with a single DWORD of the level that has been configured
        to be the default level for this scope.  InfoBufferRetSize will
        contain the length of the result (a single DWORD).
    Returns STATUS_NOT_FOUND if no default level has been configured
        for the given scope (or the level defined does not exist).
    Returns STATUS_BUFFER_TOO_SMALL if there was a defined default level
        but a buffer was not supplied, or the buffer supplied was too
        small to accomodate the results.

--*/
{
    NTSTATUS Status;
    HANDLE hKeyBase;
    DWORD dwNewLevelId;
    UNICODE_STRING ValueName;
    PAUTHZLEVELTABLERECORD pLevelRecord;


    //
    // Open up the regkey to the base of the policies.
    //
    if (!g_bInitializedFirstTime) {
        Status = STATUS_UNSUCCESSFUL;
        goto ExitHandler;
    }
    RtlEnterCriticalSection(&g_TableCritSec);
    if (g_hKeyCustomRoot != NULL) {
        if (dwScopeId != SAFER_SCOPEID_REGISTRY) {
            Status = STATUS_INVALID_PARAMETER_MIX;
            goto ExitHandler2;
        }
    } else {
        if (dwScopeId != SAFER_SCOPEID_MACHINE &&
            dwScopeId != SAFER_SCOPEID_USER) {
            Status = STATUS_INVALID_PARAMETER_MIX;
            goto ExitHandler2;
        }
    }
    if (g_bNeedCacheReload) {
        Status = CodeAuthzpImmediateReloadCacheTables();
        if (!NT_SUCCESS(Status)) {
            goto ExitHandler2;
        }
    }
    Status = CodeAuthzpOpenPolicyRootKey(
                dwScopeId,
                g_hKeyCustomRoot,
                L"\\" SAFER_CODEIDS_REGSUBKEY,
                KEY_READ | KEY_SET_VALUE,
                TRUE, &hKeyBase);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler2;
    }


    //
    // Load the list of all of the available objects.
    //
    if (RtlIsGenericTableEmpty(&g_CodeLevelObjTable)) {
        Status = STATUS_NOT_FOUND;
        goto ExitHandler3;
    }


    //
    // If we are going to set a new default object,
    // make sure it is a valid one.
    //
    if (InfoBufferSize < sizeof(DWORD) ||
        !ARGUMENT_PRESENT(InfoBuffer))
    {
        // Caller wants to clear the default object.
        InfoBuffer = NULL;
        pLevelRecord = NULL;
    }
    else
    {
        dwNewLevelId = *(PDWORD) InfoBuffer;
        pLevelRecord = CodeAuthzLevelObjpLookupByLevelId(
                &g_CodeLevelObjTable, dwNewLevelId);
        if (!pLevelRecord)
        {
            // Caller was trying to set the default to an
            // authorization object that does not exist.
            Status = STATUS_NOT_FOUND;
            goto ExitHandler3;
        }
    }


    //
    // Write the name of the default object that is specified.
    //
    RtlInitUnicodeString(&ValueName, SAFER_DEFAULTOBJ_REGVALUE);

    Status = NtSetValueKey(hKeyBase,
                           &ValueName,
                           0,
                           REG_DWORD,
                           &dwNewLevelId,
                           sizeof(DWORD));
    if (NT_SUCCESS(Status)) {
        if (dwScopeId == SAFER_SCOPEID_USER) {
            g_DefaultCodeLevelUser = pLevelRecord;
        } else {
            g_DefaultCodeLevelMachine = pLevelRecord;
        }

        //
        // Compute the effective Default Level (take the least privileged).
        //
        CodeAuthzpRecomputeEffectiveDefaultLevel();
    }


ExitHandler3:
    NtClose(hKeyBase);
ExitHandler2:
    RtlLeaveCriticalSection(&g_TableCritSec);
ExitHandler:
    return Status;
}


NTSTATUS NTAPI
SaferpPol_GetInfoCommon_HonorUserIdentities(
        IN   DWORD       dwScopeId,
        IN   DWORD       InfoBufferSize      OPTIONAL,
        OUT  PVOID       InfoBuffer          OPTIONAL,
        OUT PDWORD       InfoBufferRetSize   OPTIONAL,
        IN   BOOLEAN    bUseCached
        )
/*++

Routine Description:

    Queries the current WinSafer policy to determine if Code Identities
    defined within the User's registry scope should be considered.

    Note that this query always accepts a constant-sized buffer that is
    only a single DWORD in length.

Arguments:

    dwScopeId - specifies the registry scope that will be examined.
        If the currently cached scope included a registry handle
        then AUTHZSCOPE_REGISTRY must be specified.  Otherwise,
        this must be SAFER_SCOPEID_MACHINE.

    InfoBufferSize - optionally specifies the size of input buffer
        supplied by the caller to receive the results.  If this argument
        is supplied, then InfoBuffer must also be supplied.

    InfoBuffer - optionally specifies the input buffer that was
        supplied by the caller to receive the results.  If this argument
        is supplied, then InfoBufferSize must also be supplied.

    InfoBufferRetSize - optionally specifies a pointer that will receive
        the size of the results actually written to the InfoBuffer.

Return Value:

    Returns STATUS_SUCCESS on a successful query result.
        InfoBuffer will be filled with a single DWORD containing
        either a TRUE or FALSE value that indicates whether the option
        is enabled. InfoBufferRetSize will contain the length of the
        result (a single DWORD).
    Returns STATUS_BUFFER_TOO_SMALL if the buffer was not supplied, or
        the buffer supplied was too small to accomodate the result.

--*/
{
    NTSTATUS Status;
    DWORD dwValueState = (DWORD) -1;


    //
    // Open up the regkey to the base of the policies.
    //
    if (!g_bInitializedFirstTime) {
        Status = STATUS_UNSUCCESSFUL;
        goto ExitHandler;
    }
    RtlEnterCriticalSection(&g_TableCritSec);
    if (g_hKeyCustomRoot != NULL) {
        if (dwScopeId != SAFER_SCOPEID_REGISTRY) {
            Status = STATUS_INVALID_PARAMETER_MIX;
            goto ExitHandler2;
        }
    } else {
        if (dwScopeId != SAFER_SCOPEID_MACHINE) {
            Status = STATUS_INVALID_PARAMETER_MIX;
            goto ExitHandler2;
        }
    }
    if (g_bNeedCacheReload) {
        Status = CodeAuthzpImmediateReloadCacheTables();
        if (!NT_SUCCESS(Status)) {
            goto ExitHandler2;
        }
    }


    //
    // Read or write the name of the policy value that is specified.
    //
    if (!bUseCached)
    {
        HANDLE hKeyBase;
        ULONG ActualSize;
        UNICODE_STRING ValueName;
        WCHAR KeyPathBuffer[ MAXIMUM_FILENAME_LENGTH+6 ];
        PKEY_VALUE_FULL_INFORMATION ValueBuffer =
            (PKEY_VALUE_FULL_INFORMATION) KeyPathBuffer;

        Status = CodeAuthzpOpenPolicyRootKey(
                    dwScopeId,
                    g_hKeyCustomRoot,
                    L"\\" SAFER_CODEIDS_REGSUBKEY,
                    KEY_READ, FALSE, &hKeyBase);
        if (NT_SUCCESS(Status))
        {
            RtlInitUnicodeString(&ValueName,
                                 SAFER_HONORUSER_REGVALUE);
            Status = NtQueryValueKey(hKeyBase,
                                     &ValueName,
                                     KeyValueFullInformation,
                                     ValueBuffer,     // ptr to KeyPathBuffer
                                     sizeof(KeyPathBuffer),
                                     &ActualSize);
            if (NT_SUCCESS(Status)) {
                if (ValueBuffer->Type != REG_DWORD ||
                    ValueBuffer->DataLength != sizeof(DWORD)) {
                    Status = STATUS_NOT_FOUND;
                } else {
                    dwValueState = * (PDWORD) ((PBYTE) ValueBuffer +
                            ValueBuffer->DataOffset);
                }
            }
            NtClose(hKeyBase);
        }
        if (!NT_SUCCESS(Status)) {
            goto ExitHandler2;
        }
    }
    else
    {
        dwValueState = (g_bHonorScopeUser ? TRUE : FALSE);
    }


    //
    // Make sure the target buffer is large
    // enough and copy the object name into it.
    //
    if (!ARGUMENT_PRESENT(InfoBuffer) ||
            InfoBufferSize < sizeof(DWORD)) {
        Status = STATUS_BUFFER_TOO_SMALL;
    } else {
        RtlCopyMemory(InfoBuffer, &dwValueState, sizeof(DWORD));
        Status = STATUS_SUCCESS;
    }
    if (ARGUMENT_PRESENT(InfoBufferRetSize))
        *InfoBufferRetSize = sizeof(DWORD);


ExitHandler2:
    RtlLeaveCriticalSection(&g_TableCritSec);
ExitHandler:
    return Status;
}


NTSTATUS NTAPI
CodeAuthzPol_GetInfoCached_HonorUserIdentities(
        IN   DWORD       dwScopeId,
        IN   DWORD       InfoBufferSize      OPTIONAL,
        OUT  PVOID       InfoBuffer          OPTIONAL,
        OUT PDWORD       InfoBufferRetSize   OPTIONAL
        )
{
    return SaferpPol_GetInfoCommon_HonorUserIdentities(
        dwScopeId, InfoBufferSize,
        InfoBuffer, InfoBufferRetSize, TRUE);
}


NTSTATUS NTAPI
CodeAuthzPol_GetInfoRegistry_HonorUserIdentities(
        IN   DWORD       dwScopeId,
        IN   DWORD       InfoBufferSize      OPTIONAL,
        OUT  PVOID       InfoBuffer          OPTIONAL,
        OUT PDWORD       InfoBufferRetSize   OPTIONAL
        )
{
    return SaferpPol_GetInfoCommon_HonorUserIdentities(
        dwScopeId, InfoBufferSize,
        InfoBuffer, InfoBufferRetSize, FALSE);
}




NTSTATUS NTAPI
CodeAuthzPol_SetInfoDual_HonorUserIdentities(
        IN      DWORD       dwScopeId,
        IN      DWORD       InfoBufferSize,
        IN      PVOID       InfoBuffer
        )
/*++

Routine Description:

    Queries the current WinSafer policy to determine if Code Identities
    defined within the User's registry scope should be considered.

    Note that this API always accepts a constant-sized buffer that is
    only a single DWORD in length.

Arguments:

    dwScopeId - specifies the registry scope that will be examined.
        If the currently cached scope included a registry handle
        then AUTHZSCOPE_REGISTRY must be specified.  Otherwise,
        this must be SAFER_SCOPEID_MACHINE.

    InfoBufferSize - specifies the size of input buffer
        supplied by the caller to receive the results.  If this argument
        is supplied, then InfoBuffer must also be supplied.

    InfoBuffer - specifies the input buffer that was
        supplied by the caller to receive the results.  If this argument
        is supplied, then InfoBufferSize must also be supplied.

Return Value:

    Returns STATUS_SUCCESS on a successful query result.  InfoBuffer will
        be filled with a single DWORD of the level that has been configured
        to be the default level for this scope.  InfoBufferRetSize will
        contain the length of the result (a single DWORD).
    Returns STATUS_NOT_FOUND if no default level has been configured
        for the given scope (or the level defined does not exist).
    Returns STATUS_BUFFER_TOO_SMALL if there was a defined default level
        but a buffer was not supplied, or the buffer supplied was too
        small to accomodate the results.

--*/
{
    HANDLE hKeyBase;
    NTSTATUS Status;
    UNICODE_STRING ValueName;


    //
    // Open up the regkey to the base of the policies.
    //
    if (!g_bInitializedFirstTime) {
        Status = STATUS_UNSUCCESSFUL;
        goto ExitHandler;
    }
    RtlEnterCriticalSection(&g_TableCritSec);
    if (g_hKeyCustomRoot != NULL) {
        if (dwScopeId != SAFER_SCOPEID_REGISTRY) {
            Status = STATUS_INVALID_PARAMETER_MIX;
            goto ExitHandler2;
        }
    } else {
        if (dwScopeId != SAFER_SCOPEID_MACHINE) {
            Status = STATUS_INVALID_PARAMETER_MIX;
            goto ExitHandler2;
        }
    }
    if (g_bNeedCacheReload) {
        Status = CodeAuthzpImmediateReloadCacheTables();
        if (!NT_SUCCESS(Status)) {
            goto ExitHandler2;
        }
    }
    Status = CodeAuthzpOpenPolicyRootKey(
                dwScopeId,
                g_hKeyCustomRoot,
                L"\\" SAFER_CODEIDS_REGSUBKEY,
                (KEY_READ | KEY_SET_VALUE),
                TRUE, &hKeyBase);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler2;
    }

    //
    // Make sure the input buffer is large enough.
    //
    if (InfoBufferSize < sizeof(DWORD) ||
        !ARGUMENT_PRESENT(InfoBuffer)) {
        Status = STATUS_BUFFER_TOO_SMALL;
        goto ExitHandler3;
    }


    //
    // Write the policy value that is specified.
    //
    RtlInitUnicodeString(&ValueName, SAFER_HONORUSER_REGVALUE);

    Status = NtSetValueKey(hKeyBase,
                           &ValueName,
                           0,
                           REG_DWORD,
                           InfoBuffer,
                           sizeof(DWORD));
    if (NT_SUCCESS(Status)) {
        BOOLEAN bNewHonorScopeUser = (*((PDWORD)InfoBuffer) != 0 ? TRUE : FALSE);

        if (g_bHonorScopeUser != bNewHonorScopeUser)
        {
            g_bHonorScopeUser = bNewHonorScopeUser;

            //
            // If the actual value is different from what we had then we
            // need to purge the identities table and reload the only the
            // parts that we should consider.
            //
            if (g_hKeyCustomRoot == NULL)
            {
                CodeAuthzGuidIdentsEntireTableFree(&g_CodeIdentitiesTable);

                CodeAuthzGuidIdentsLoadTableAll(
                        &g_CodeLevelObjTable,
                        &g_CodeIdentitiesTable,
                        SAFER_SCOPEID_MACHINE,
                        NULL);

                if (g_bHonorScopeUser) {
                    CodeAuthzGuidIdentsLoadTableAll(
                        &g_CodeLevelObjTable,
                        &g_CodeIdentitiesTable,
                        SAFER_SCOPEID_USER,
                        NULL);
                }
            }
        }
    }


ExitHandler3:
    NtClose(hKeyBase);
ExitHandler2:
    RtlLeaveCriticalSection(&g_TableCritSec);
ExitHandler:
    return Status;
}



NTSTATUS NTAPI
CodeAuthzPol_GetInfoRegistry_TransparentEnabled(
        IN DWORD        dwScopeId,
        IN   DWORD       InfoBufferSize      OPTIONAL,
        OUT  PVOID       InfoBuffer          OPTIONAL,
        OUT PDWORD       InfoBufferRetSize   OPTIONAL
        )
/*++

Routine Description:

    Queries the current "transparent enforcement" setting.  This is a
    global setting that can be used to enable or disable automatic
    WinSafer token reductions.

Arguments:

    dwScopeId - specifies the registry scope that will be examined.
        If the currently cached scope included a registry handle
        then AUTHZSCOPE_REGISTRY must be specified.  Otherwise,
        this must be SAFER_SCOPEID_MACHINE.

    InfoBufferSize - optionally specifies the size of input buffer
        supplied by the caller to receive the results.  If this argument
        is supplied, then InfoBuffer must also be supplied.

    InfoBuffer - optionally specifies the input buffer that was
        supplied by the caller to receive the results.  If this argument
        is supplied, then InfoBufferSize must also be supplied.

    InfoBufferRetSize - optionally specifies a pointer that will receive
        the size of the results actually written to the InfoBuffer.

Return Value:

    Returns STATUS_SUCCESS on a successful query result.  If the
    operation is not successful, then the contents of 'pdwEnabled'
    are left untouched.

--*/
{
    NTSTATUS Status;
    DWORD dwValueState = (DWORD) -1;


    //
    // Open up the regkey to the base of the policies.
    //
    if (!g_bInitializedFirstTime) {
        Status = STATUS_UNSUCCESSFUL;
        goto ExitHandler;
    }
    RtlEnterCriticalSection(&g_TableCritSec);
    if (g_hKeyCustomRoot != NULL) {
        if (dwScopeId != SAFER_SCOPEID_REGISTRY) {
            Status = STATUS_INVALID_PARAMETER_MIX;
            goto ExitHandler2;
        }
    } else {
        if (dwScopeId != SAFER_SCOPEID_MACHINE) {
            Status = STATUS_INVALID_PARAMETER_MIX;
            goto ExitHandler2;
        }
    }

    //
    // Query the current value setting.
    //
    {
        HANDLE hKeyBase;
        DWORD ActualSize;
        UNICODE_STRING ValueName;
        WCHAR KeyPathBuffer[ MAXIMUM_FILENAME_LENGTH+6 ];
        PKEY_VALUE_FULL_INFORMATION ValueBuffer =
            (PKEY_VALUE_FULL_INFORMATION) KeyPathBuffer;

        Status = CodeAuthzpOpenPolicyRootKey(
                    dwScopeId,
                    g_hKeyCustomRoot,
                    L"\\" SAFER_CODEIDS_REGSUBKEY,
                    KEY_READ, FALSE, &hKeyBase);
        if (NT_SUCCESS(Status)) {
            RtlInitUnicodeString(&ValueName,
                                 SAFER_TRANSPARENTENABLED_REGVALUE);
            Status = NtQueryValueKey(hKeyBase,
                                     &ValueName,
                                     KeyValueFullInformation,
                                     ValueBuffer,     // ptr to KeyPathBuffer
                                     sizeof(KeyPathBuffer),
                                     &ActualSize);
            if (NT_SUCCESS(Status)) {
                if (ValueBuffer->Type != REG_DWORD ||
                    ValueBuffer->DataLength != sizeof(DWORD)) {
                    Status = STATUS_NOT_FOUND;
                } else {
                    dwValueState = * (PDWORD) ((PBYTE) ValueBuffer +
                            ValueBuffer->DataOffset);
                }
            }
            NtClose(hKeyBase);
        }
        if (!NT_SUCCESS(Status)) {
            // On failure, just ignore it and pretend it was FALSE.
            dwValueState = FALSE;
        }
    }


    //
    // Make sure the target buffer is large
    // enough and copy the object name into it.
    //
    if (!ARGUMENT_PRESENT(InfoBuffer) ||
            InfoBufferSize < sizeof(DWORD)) {
        Status = STATUS_BUFFER_TOO_SMALL;
    } else {
        RtlCopyMemory(InfoBuffer, &dwValueState, sizeof(DWORD));
        Status = STATUS_SUCCESS;
    }
    if (ARGUMENT_PRESENT(InfoBufferRetSize))
        *InfoBufferRetSize = sizeof(DWORD);


ExitHandler2:
    RtlLeaveCriticalSection(&g_TableCritSec);
ExitHandler:
    return Status;
}


NTSTATUS NTAPI
CodeAuthzPol_SetInfoRegistry_TransparentEnabled(
        IN DWORD        dwScopeId,
        IN DWORD        InfoBufferSize,
        IN PVOID        InfoBuffer
        )
/*++

Routine Description:

    Modifies the current "transparent enforcement" setting.  This is a
    global setting that can be used to enable or disable automatic
    WinSafer token reductions.

    Note that this API always accepts a constant-sized buffer that is
    only a single DWORD in length.

Arguments:

    dwScopeId - specifies the registry scope that will be examined.
        If the currently cached scope included a registry handle
        then AUTHZSCOPE_REGISTRY must be specified.  Otherwise,
        this must be SAFER_SCOPEID_MACHINE.

    InfoBufferSize - specifies the size of input buffer
        supplied by the caller to receive the results.  If this argument
        is supplied, then InfoBuffer must also be supplied.

    InfoBuffer - specifies the input buffer that was
        supplied by the caller to receive the results.  If this argument
        is supplied, then InfoBufferSize must also be supplied.

Return Value:

    Returns STATUS_SUCCESS on a successful result.

--*/
{
    HANDLE hKeyBase;
    NTSTATUS Status;
    UNICODE_STRING ValueName;

    //
    // Open up the regkey to the base of the policies.
    //
    if (!g_bInitializedFirstTime) {
        Status = STATUS_UNSUCCESSFUL;
        goto ExitHandler;
    }
    RtlEnterCriticalSection(&g_TableCritSec);
    if (g_hKeyCustomRoot != NULL) {
        if (dwScopeId != SAFER_SCOPEID_REGISTRY) {
            Status = STATUS_INVALID_PARAMETER_MIX;
            goto ExitHandler2;
        }
    } else {
        if (dwScopeId != SAFER_SCOPEID_MACHINE) {
            Status = STATUS_INVALID_PARAMETER_MIX;
            goto ExitHandler2;
        }
    }
    Status = CodeAuthzpOpenPolicyRootKey(
                dwScopeId, g_hKeyCustomRoot,
                L"\\" SAFER_CODEIDS_REGSUBKEY,
                KEY_READ | KEY_SET_VALUE,
                TRUE, &hKeyBase);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler2;
    }


    //
    // Make sure the input buffer is large enough.
    //
    if (InfoBufferSize < sizeof(DWORD) ||
        !ARGUMENT_PRESENT(InfoBuffer)) {
        Status = STATUS_BUFFER_TOO_SMALL;
        goto ExitHandler3;
    }


    //
    // Write the policy value that is specified.
    //
    RtlInitUnicodeString(&ValueName,
                         SAFER_TRANSPARENTENABLED_REGVALUE);
    Status = NtSetValueKey(hKeyBase,
                           &ValueName,
                           0,
                           REG_DWORD,
                           InfoBuffer,
                           sizeof(DWORD));


ExitHandler3:
    NtClose(hKeyBase);
ExitHandler2:
    RtlLeaveCriticalSection(&g_TableCritSec);
ExitHandler:
    return Status;
}



NTSTATUS NTAPI
CodeAuthzPol_GetInfoRegistry_ScopeFlags(
        IN DWORD        dwScopeId,
        IN   DWORD       InfoBufferSize      OPTIONAL,
        OUT  PVOID       InfoBuffer          OPTIONAL,
        OUT PDWORD       InfoBufferRetSize   OPTIONAL
        )
/*++

Routine Description:

    Queries the current "scope flags" setting.  

Arguments:

    dwScopeId - specifies the registry scope that will be examined.
        If the currently cached scope included a registry handle
        then AUTHZSCOPE_REGISTRY must be specified.  Otherwise,
        this must be SAFER_SCOPEID_MACHINE.

    InfoBufferSize - optionally specifies the size of input buffer
        supplied by the caller to receive the results.  If this argument
        is supplied, then InfoBuffer must also be supplied.

    InfoBuffer - optionally specifies the input buffer that was
        supplied by the caller to receive the results.  If this argument
        is supplied, then InfoBufferSize must also be supplied.

    InfoBufferRetSize - optionally specifies a pointer that will receive
        the size of the results actually written to the InfoBuffer.

Return Value:

    Returns STATUS_SUCCESS on a successful query result.  If the
    operation is not successful, then the contents of 'pdwEnabled'
    are left untouched.

--*/
{
    NTSTATUS Status;
    DWORD dwValueState = (DWORD) 0;


    //
    // Open up the regkey to the base of the policies.
    //
    if (!g_bInitializedFirstTime) {
        Status = STATUS_UNSUCCESSFUL;
        goto ExitHandler;
    }
    RtlEnterCriticalSection(&g_TableCritSec);
    if (g_hKeyCustomRoot != NULL) {
        if (dwScopeId != SAFER_SCOPEID_REGISTRY) {
            Status = STATUS_INVALID_PARAMETER_MIX;
            goto ExitHandler2;
        }
    } else {
        if (dwScopeId != SAFER_SCOPEID_MACHINE) {
            Status = STATUS_INVALID_PARAMETER_MIX;
            goto ExitHandler2;
        }
    }

    //
    // Query the current value setting.
    //
    {
        HANDLE hKeyBase;
        DWORD ActualSize;
        UNICODE_STRING ValueName;
        WCHAR KeyPathBuffer[ MAXIMUM_FILENAME_LENGTH+6 ];
        PKEY_VALUE_FULL_INFORMATION ValueBuffer =
            (PKEY_VALUE_FULL_INFORMATION) KeyPathBuffer;

        Status = CodeAuthzpOpenPolicyRootKey(
                    dwScopeId,
                    g_hKeyCustomRoot,
                    L"\\" SAFER_CODEIDS_REGSUBKEY,
                    KEY_READ, FALSE, &hKeyBase);
        if (NT_SUCCESS(Status)) {
            RtlInitUnicodeString(&ValueName,
                                 SAFER_POLICY_SCOPE);
            Status = NtQueryValueKey(hKeyBase,
                                     &ValueName,
                                     KeyValueFullInformation,
                                     ValueBuffer,     // ptr to KeyPathBuffer
                                     sizeof(KeyPathBuffer),
                                     &ActualSize);
            if (NT_SUCCESS(Status)) {
                if (ValueBuffer->Type != REG_DWORD ||
                    ValueBuffer->DataLength != sizeof(DWORD)) {
                    Status = STATUS_NOT_FOUND;
                } else {
                    dwValueState = * (PDWORD) ((PBYTE) ValueBuffer +
                            ValueBuffer->DataOffset);
                }
            }
            NtClose(hKeyBase);
        }
        if (!NT_SUCCESS(Status)) {
            // On failure, just ignore it and pretend it was FALSE.
            dwValueState = 0;
        }
    }


    //
    // Make sure the target buffer is large
    // enough and copy the object name into it.
    //
    if (!ARGUMENT_PRESENT(InfoBuffer) ||
            InfoBufferSize < sizeof(DWORD)) {
        Status = STATUS_BUFFER_TOO_SMALL;
    } else {
        RtlCopyMemory(InfoBuffer, &dwValueState, sizeof(DWORD));
        Status = STATUS_SUCCESS;
    }
    if (ARGUMENT_PRESENT(InfoBufferRetSize))
        *InfoBufferRetSize = sizeof(DWORD);


ExitHandler2:
    RtlLeaveCriticalSection(&g_TableCritSec);
ExitHandler:
    return Status;
}


NTSTATUS NTAPI
CodeAuthzPol_SetInfoRegistry_ScopeFlags(
        IN DWORD        dwScopeId,
        IN DWORD        InfoBufferSize,
        IN PVOID        InfoBuffer
        )
/*++

Routine Description:

    Modifies the current "scope flags" setting.

    Note that this API always accepts a constant-sized buffer that is
    only a single DWORD in length.

Arguments:

    dwScopeId - specifies the registry scope that will be examined.
        If the currently cached scope included a registry handle
        then AUTHZSCOPE_REGISTRY must be specified.  Otherwise,
        this must be SAFER_SCOPEID_MACHINE.

    InfoBufferSize - specifies the size of input buffer
        supplied by the caller to receive the results.  If this argument
        is supplied, then InfoBuffer must also be supplied.

    InfoBuffer - specifies the input buffer that was
        supplied by the caller to receive the results.  If this argument
        is supplied, then InfoBufferSize must also be supplied.

Return Value:

    Returns STATUS_SUCCESS on a successful result.

--*/
{
    HANDLE hKeyBase;
    NTSTATUS Status;
    UNICODE_STRING ValueName;

    //
    // Open up the regkey to the base of the policies.
    //
    if (!g_bInitializedFirstTime) {
        Status = STATUS_UNSUCCESSFUL;
        goto ExitHandler;
    }
    RtlEnterCriticalSection(&g_TableCritSec);
    if (g_hKeyCustomRoot != NULL) {
        if (dwScopeId != SAFER_SCOPEID_REGISTRY) {
            Status = STATUS_INVALID_PARAMETER_MIX;
            goto ExitHandler2;
        }
    } else {
        if (dwScopeId != SAFER_SCOPEID_MACHINE) {
            Status = STATUS_INVALID_PARAMETER_MIX;
            goto ExitHandler2;
        }
    }
    Status = CodeAuthzpOpenPolicyRootKey(
                dwScopeId, g_hKeyCustomRoot,
                L"\\" SAFER_CODEIDS_REGSUBKEY,
                KEY_READ | KEY_SET_VALUE,
                TRUE, &hKeyBase);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler2;
    }


    //
    // Make sure the input buffer is large enough.
    //
    if (InfoBufferSize < sizeof(DWORD) ||
        !ARGUMENT_PRESENT(InfoBuffer)) {
        Status = STATUS_BUFFER_TOO_SMALL;
        goto ExitHandler3;
    }


    //
    // Write the policy value that is specified.
    //
    RtlInitUnicodeString(&ValueName,
                         SAFER_POLICY_SCOPE);
    Status = NtSetValueKey(hKeyBase,
                           &ValueName,
                           0,
                           REG_DWORD,
                           InfoBuffer,
                           sizeof(DWORD));


ExitHandler3:
    NtClose(hKeyBase);
ExitHandler2:
    RtlLeaveCriticalSection(&g_TableCritSec);
ExitHandler:
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\winsafer\safewild.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    SaifWild.cpp

Abstract:

    This module implements various "Wildcard SID" operations that are
    used internally by the WinSAIFER APIs to compute SID list
    intersections and inversions.

Author:

    Jeffrey Lawson (JLawson) - Apr 2000

Environment:

    User mode only.

Revision History:

    Created - Apr 2000

--*/


#ifndef _SAIFER_WILDCARD_SIDS_H_
#define _SAIFER_WILDCARD_SIDS_H_


//
// Internal structure used to represent our private "Wildcard SIDs".
//
typedef struct _AUTHZ_WILDCARDSID
{
    PSID Sid;
    DWORD WildcardPos;          // -1, or else the wildcard position of
                                // the within the subauthorities.
} AUTHZ_WILDCARDSID, *PAUTHZ_WILDCARDSID;


#ifdef __cplusplus
extern "C" {
#endif


NTSTATUS NTAPI
CodeAuthzpConvertWildcardStringSidToSidW(
    IN LPCWSTR szStringSid,
    OUT PAUTHZ_WILDCARDSID pWildcardSid
    );

NTSTATUS NTAPI
CodeAuthzpConvertWildcardSidToStringSidW(
    IN PAUTHZ_WILDCARDSID   pWildcardSid,
    OUT PUNICODE_STRING     pUnicodeOutput
    );

BOOLEAN NTAPI
CodeAuthzpCompareWildcardSidWithSid(
    IN PAUTHZ_WILDCARDSID pWildcardSid,
    IN PSID pMatchSid
    );

BOOLEAN NTAPI
CodeAuthzpSidInWildcardList (
    IN PAUTHZ_WILDCARDSID   WildcardList,
    IN ULONG                WildcardCount,
    IN PSID                 SePrincipalSelfSid   OPTIONAL,
    IN PSID                 PrincipalSelfSid   OPTIONAL,
    IN PSID                 Sid
    );

BOOLEAN NTAPI
CodeAuthzpInvertAndAddSids(
    IN HANDLE                   InAccessToken,
    IN PSID                     InTokenOwner    OPTIONAL,
    IN DWORD                    InvertSidCount,
    IN PAUTHZ_WILDCARDSID       SidsToInvert,
    IN DWORD                    SidsAddedCount  OPTIONAL,
    IN PSID_AND_ATTRIBUTES      SidsToAdd       OPTIONAL,
    OUT DWORD                  *NewDisabledSidCount,
    OUT PSID_AND_ATTRIBUTES    *NewSidsToDisable
    );

BOOLEAN NTAPI
CodeAuthzpExpandWildcardList(
    IN HANDLE                   InAccessToken,
    IN PSID                     InTokenOwner   OPTIONAL,
    IN DWORD                    WildcardCount,
    IN PAUTHZ_WILDCARDSID       WildcardList,
    OUT DWORD                  *OutSidCount,
    OUT PSID_AND_ATTRIBUTES    *OutSidList
    );


#ifdef __cplusplus
} // extern "C"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\winsafer\test\amisafe\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by amisafe.rc
//
#define IDD_AMISAFE_DIALOG              102
#define IDR_MAINFRAME                   128
#define IDB_BITMAP1                     129
#define IDC_LIST1                       1000

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        130
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\winsafer\test\amisafe\security.h ===
// Security.h: interface for the CSecurity class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SECURITY_H__080169BB_C2D8_4472_AB5A_82BFA1640AA5__INCLUDED_)
#define AFX_SECURITY_H__080169BB_C2D8_4472_AB5A_82BFA1640AA5__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CSecurity  
{
public:
	static BOOL GetLoggedInUsername(LPTSTR szInBuffer, DWORD dwInBufferSize);
	static BOOL IsTokenUntrusted(HANDLE hToken);
	static BOOL IsUntrusted();
	static BOOL IsAdministrator();
	CSecurity();
	virtual ~CSecurity();

};

#endif // !defined(AFX_SECURITY_H__080169BB_C2D8_4472_AB5A_82BFA1640AA5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\winsafer\test\amisafe\amisafe.cpp ===
// amisafe.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "amisafe.h"
#include "amisafeDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAmisafeApp

BEGIN_MESSAGE_MAP(CAmisafeApp, CWinApp)
	//{{AFX_MSG_MAP(CAmisafeApp)
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAmisafeApp construction

CAmisafeApp::CAmisafeApp()
{
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CAmisafeApp object

CAmisafeApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CAmisafeApp initialization

BOOL CAmisafeApp::InitInstance()
{
	// Standard initialization

	CAmisafeDlg dlg;
	m_pMainWnd = &dlg;
	int nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
	}
	else if (nResponse == IDCANCEL)
	{
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\winsafer\test\amisafe\amisafedlg.h ===
// amisafeDlg.h : header file
//

#if !defined(AFX_AMISAFEDLG_H__A3D21715_0B8E_4333_AF51_3E8D087B3993__INCLUDED_)
#define AFX_AMISAFEDLG_H__A3D21715_0B8E_4333_AF51_3E8D087B3993__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////
// CAmisafeDlg dialog

class CAmisafeDlg : public CDialog
{
// Construction
public:
	void AppendToLastMessage(LPCSTR szMessage, DWORD dwNewIconId = -1);
	void InsertMessage(LPCSTR szMessage, DWORD dwIconId);
	CAmisafeDlg(CWnd* pParent = NULL);	// standard constructor

// Dialog Data
	//{{AFX_DATA(CAmisafeDlg)
	enum { IDD = IDD_AMISAFE_DIALOG };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAmisafeDlg)
	protected:
	//}}AFX_VIRTUAL

// Implementation
protected:
	TCHAR szRecipients[200];
	void RunSecurityCheck(void);
	HANDLE hThread;
	static DWORD WINAPI ThreadProc(LPVOID lpParameter);
	CImageList imagelist;
	CListCtrl listcontrol;
	HICON m_hIcon;

	// Generated message map functions
	//{{AFX_MSG(CAmisafeDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnClose();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_AMISAFEDLG_H__A3D21715_0B8E_4333_AF51_3E8D087B3993__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\winsafer\test\amisafe\amisafe.h ===
// amisafe.h : main header file for the AMISAFE application
//

#if !defined(AFX_AMISAFE_H__520E3123_671D_45D1_8D35_F96C29AA23F0__INCLUDED_)
#define AFX_AMISAFE_H__520E3123_671D_45D1_8D35_F96C29AA23F0__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CAmisafeApp:
// See amisafe.cpp for the implementation of this class
//

class CAmisafeApp : public CWinApp
{
public:
	CAmisafeApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAmisafeApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CAmisafeApp)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_AMISAFE_H__520E3123_671D_45D1_8D35_F96C29AA23F0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\winsafer\test\amisafe\amisafedlg.cpp ===
// amisafeDlg.cpp : implementation file
//

#include "stdafx.h"
#include "amisafe.h"
#include "amisafeDlg.h"
#include "Security.h"
#include "SendMail.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#define ICONID_GREENCHECK 0
#define ICONID_REDCROSS 1
#define ICONID_BLUEDOT	2



BEGIN_MESSAGE_MAP(CAmisafeDlg, CDialog)
	//{{AFX_MSG_MAP(CAmisafeDlg)
	ON_WM_CLOSE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CAmisafeDlg dialog

CAmisafeDlg::CAmisafeDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CAmisafeDlg::IDD, pParent), hThread(NULL)
{
	//{{AFX_DATA_INIT(CAmisafeDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
	imagelist.Create(IDB_BITMAP1, 16, 0, RGB(255,255,255));

	// find out who to send to from the command line.
	szRecipients[0] = '\0';
#if 0
	LPTSTR szCmdLine = GetCommandLine();
	if (szCmdLine != NULL) {
		if (*szCmdLine == '"') {
			for (szCmdLine++; *szCmdLine != '"'; szCmdLine++);
		}
		while (*szCmdLine == ' ') szCmdLine++;
		strncpy(szRecipients, szCmdLine, 
				sizeof(szRecipients) / sizeof(TCHAR) - 1);
		szRecipients[sizeof(szRecipients) / sizeof(TCHAR) - 1] = '\0';
	}
#else
	if (__argc > 1 && *__argv[1] != '\0') {
		strncpy(szRecipients, __argv[1], 
				sizeof(szRecipients) / sizeof(TCHAR) - 1);
		szRecipients[sizeof(szRecipients) / sizeof(TCHAR) - 1] = '\0';
	}
#endif


	// if we still do not have a valid recipient, then apply a default.
	if (lstrlen(szRecipients) < 2) {
		if (!CSecurity::GetLoggedInUsername(szRecipients, sizeof(szRecipients) / sizeof(TCHAR))) {
			strcpy(szRecipients, "dbayer");
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CAmisafeDlg message handlers

BOOL CAmisafeDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	HWND hwndList = ::GetDlgItem(GetSafeHwnd(), IDC_LIST1);
	if (!hwndList) return FALSE;
	if (!listcontrol.Attach(hwndList)) return FALSE;
	listcontrol.SetImageList(&imagelist, LVSIL_SMALL);

	RECT listrect;
	listcontrol.GetClientRect(&listrect);
	listcontrol.InsertColumn(0, "text", LVCFMT_LEFT, listrect.right);

	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
	
	// TODO: Add extra initialization here
	listcontrol.DeleteAllItems();
	InsertMessage("Security checker starting up...", ICONID_BLUEDOT);
	hThread = ::CreateThread(NULL, 0, ThreadProc, (LPVOID) this, 0, NULL);
	
	return TRUE;  // return TRUE  unless you set the focus to a control
}


void CAmisafeDlg::RunSecurityCheck() 
{
	//
	// Determine if our process token is a member of the Administrators group.
	//
	Sleep(2000);
	if (CSecurity::IsAdministrator()) {
		InsertMessage("Running with Administrator privileges", ICONID_GREENCHECK);
	} else {
		InsertMessage("Running without Administrator privileges", ICONID_REDCROSS);
	}


	//
	// Determine if our process token is "untrusted" and does not have access to
	// resources that are ACLed specifically to the TokenUser SID.
	//
	Sleep(2000);
	if (CSecurity::IsUntrusted()) {
		InsertMessage("Running in an untrusted environment", ICONID_REDCROSS);
	} else {
		InsertMessage("Running as trusted code", ICONID_GREENCHECK);
	}


	//
	// Perform a simple MAPI test to send an email to someone.
	//
	Sleep(2000);
	InsertMessage("Attempting to initialize MAPI...", ICONID_BLUEDOT);
	{
		CInitMapi initmapi;
		if (HR_FAILED(initmapi.InitMapi())) {
			AppendToLastMessage("fail");
			InsertMessage("Failed to initialize MAPI", ICONID_REDCROSS);
		} else {
			AppendToLastMessage("ok");
			Sleep(500);


			//
			// Try to resolve some addresses to prove that we can
			// access the MAPI address book.
			//
			CAddressEnum addrenum(initmapi);
			char szNameBuffer[100];
			for (int i = 0; ; i++)
			{
				// figure out which address we will look up.
				LPSTR szSourceName = NULL;
				switch (i) {
				case 0: szSourceName = "billg"; break;
				case 1: szSourceName = "steve bal"; break;
				case 2: szSourceName = "daveth"; break;
				case 3: szSourceName = "praerit"; break;
				case 4: szSourceName = "jeff lawson"; break;
				}
				if (szSourceName == NULL) break;

				// log something within the window.
				InsertMessage("Looking up ", ICONID_BLUEDOT);
				AppendToLastMessage(szSourceName);
				AppendToLastMessage("...");

				// do the resolution.
				if (HR_FAILED(addrenum.LookupAddress(szSourceName, 
							szNameBuffer, sizeof(szNameBuffer))))
				{
					AppendToLastMessage("fail");
				} else {
					AppendToLastMessage(szNameBuffer);
				}
			}


			//
			// Compose an outgoing email to a specified recipient 
			//
			InsertMessage("Creating an outgoing e-mail...", ICONID_BLUEDOT);
			CSendMail sendmail(initmapi);
			if (HR_FAILED(sendmail.CreateMail("Test Message from AMISAFE"))) {
				AppendToLastMessage("fail");
				InsertMessage("Failed to create MAPI message", ICONID_REDCROSS);
			} else {
				if (HR_FAILED(sendmail.SetRecipients(szRecipients))) {
					AppendToLastMessage("fail");
					InsertMessage("Failed to send to ", ICONID_REDCROSS);
					AppendToLastMessage(szRecipients);
				} else {
					AppendToLastMessage("ok");
					Sleep(500);
					InsertMessage("Starting e-mail transmission...", ICONID_BLUEDOT);
					if (HR_FAILED(sendmail.Transmit())) {
						AppendToLastMessage("fail");
						InsertMessage("Failed to transmit MAPI message", ICONID_REDCROSS);
					} else {
						AppendToLastMessage("ok");
						InsertMessage("Successfully sent to ", ICONID_GREENCHECK);
						AppendToLastMessage(szRecipients);
					}
				}
			}

		}
	}

	Sleep(2000);
	InsertMessage("Finished tests.", ICONID_BLUEDOT);
}

DWORD WINAPI CAmisafeDlg::ThreadProc(LPVOID lpParameter)
{
	((CAmisafeDlg*)lpParameter)->RunSecurityCheck();
	return 0;
}

void CAmisafeDlg::InsertMessage(LPCSTR szMessage, DWORD dwIconId)
{
	listcontrol.InsertItem(listcontrol.GetItemCount(), szMessage, dwIconId);
	listcontrol.UpdateWindow();
}


void CAmisafeDlg::AppendToLastMessage(LPCSTR szMessage, DWORD dwNewIconId)
{
	int count = listcontrol.GetItemCount();
	if (count > 0) {
		char szBuffer[200] = "";
		listcontrol.GetItemText(count - 1, 0, szBuffer, sizeof(szBuffer));
		strncat(szBuffer, szMessage, sizeof(szBuffer) - strlen(szBuffer) - 1);
		szBuffer[sizeof(szBuffer) - 1] = '\0';
		listcontrol.SetItemText(count - 1, 0, szBuffer);
		listcontrol.UpdateWindow();
	}
}

void CAmisafeDlg::OnClose() 
{
	if (hThread != NULL) {
		InsertMessage("waiting for shutdown", ICONID_BLUEDOT);
		TerminateThread(hThread, 0);		// not the nicest thing
		Sleep(500);
		WaitForSingleObject(hThread, INFINITE);
		hThread = NULL;
	}	
	CDialog::OnClose();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\winsafer\test\amisafe\sendmail.cpp ===
// SendMail.cpp: implementation of the CSendMail class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "amisafe.h"
#include "SendMail.h"


#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif




//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSendMail::CSendMail(CInitMapi &_mapi) : pmsg(NULL), pmapi(_mapi)
{
}

CSendMail::~CSendMail()
{
    if (pmsg != NULL)
        UlRelease(pmsg);
}


//
//  Create an outbound message, put data in it.
//
HRESULT CSendMail::CreateMail(LPSTR szSubject)
{
    HRESULT hr;

    hr = HrCreateOutMessage(pmapi.pfldOutBox, &pmsg);
    if(hr)
        return hr;

    hr = HrInitMsg(pmsg, pmapi.pvalSentMailEID, szSubject);
    if(HR_FAILED(hr)) {
        UlRelease(pmsg);
        return hr;
    }

    return hr;
}

HRESULT CSendMail::Transmit()
{
    HRESULT hr;
    if (pmsg != NULL)
        hr = pmsg->SubmitMessage(0);
    return hr;
}


//
//  Create a message in the outbox
//
HRESULT CSendMail::HrCreateOutMessage(LPMAPIFOLDER pfldOutBox, LPMESSAGE FAR * ppmM)
{

    LPMESSAGE lpmResM = NULL;
    HRESULT hr;

    Assert(pfldOutBox);

    hr = pfldOutBox->CreateMessage(NULL, MAPI_DEFERRED_ERRORS, &lpmResM);
    if(HR_FAILED(hr))
    {
        return hr;
    }

    *ppmM = lpmResM;

    return hrSuccess;
}

//
//  Put the data from globals in the message
//
HRESULT CSendMail::HrInitMsg(LPMESSAGE pmsg, LPSPropValue pvalSentMailEID, LPSTR szSubject)
{
    HRESULT hr;
    enum {iSubj, iSentMail, iConvTopic, iConvIdx, iMsgClass, cProps};
    // PR_SUBJECT, PR_SENTMAIL_ENTRYID,
    // PR_CONVERSATION_TOPIC, PR_COVERSATION_INDEX

    SPropValue props[cProps];
    ULONG cbConvIdx = 0;
    LPBYTE lpbConvIdx = NULL;

    //subject  and conversation topic
    if(szSubject)
    {
        props[iSubj].ulPropTag = PR_SUBJECT;
        props[iSubj].Value.LPSZ = szSubject;

        props[iConvTopic].ulPropTag = PR_CONVERSATION_TOPIC;
        props[iConvTopic].Value.LPSZ = szSubject;
    }
    else
    {
        props[iSubj].ulPropTag = PR_NULL;
        props[iConvTopic].ulPropTag = PR_NULL;
    }

    // conversaton index
    //if(!ScAddConversationIndex(0, NULL, &cbConvIdx, &lpbConvIdx))
    //{
    //    props[iConvIdx].ulPropTag = PR_CONVERSATION_INDEX;
    //    props[iConvIdx].Value.bin.lpb = lpbConvIdx;
    //    props[iConvIdx].Value.bin.cb = cbConvIdx;
    //}
    //else
    //{
        props[iConvIdx].ulPropTag = PR_NULL;
    //}

    // sent mail entry id (we want to leave a copy in the "Sent Items" folder)
    props[iSentMail] = *pvalSentMailEID;

    props[iMsgClass].ulPropTag = PR_MESSAGE_CLASS;
    props[iMsgClass].Value.lpszA = "IPM.Note";

    hr = pmsg->SetProps(cProps, (LPSPropValue)&props, NULL);
    if(HR_FAILED(hr))
    {
        goto err;
    }

err:
    if (lpbConvIdx != NULL)
        MAPIFreeBuffer(lpbConvIdx);

    return hr;

}


HRESULT CSendMail::SetRecipients(LPSTR szRecipients)
{
    LPADRLIST pal = NULL;
    HRESULT hr;

    //recipients
    hr = HrCreateAddrList(pmapi.pabAddrB, &pal, szRecipients);
    if(HR_FAILED(hr))
        goto err;

    Assert(pal);

    hr = pmsg->ModifyRecipients(0, pal);
    if(HR_FAILED(hr))
    {
        goto err;
    }

err:
    FreePadrlist(pal);
    return hr;
}

//
//  Create an adrlist with resolved recipients
//
HRESULT CSendMail::HrCreateAddrList(LPADRBOOK pabAddrB, LPADRLIST * ppal, LPSTR szToRecips)
{

    HRESULT hr;
    LPADRLIST pal = NULL;
    int ind;
    #define chDELIMITER ';'


    int nToRecips = 1;
    LPSTR strToken = szToRecips;
    while (strToken = strchr(strToken, chDELIMITER))
    {
        ++strToken;
        ++nToRecips;
    }

    int cb = CbNewADRLIST(nToRecips);

    hr = MAPIAllocateBuffer(cb, (LPVOID FAR *) &pal);
    if(hr)
    {
        goto err;
    }
    ZeroMemory(pal, cb);

    hr = MAPIAllocateBuffer(2 * sizeof(SPropValue),
                            (LPVOID FAR *)&pal->aEntries[0].rgPropVals);
    if(hr)
    {
        goto err;
    }

    pal->aEntries[0].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
    pal->aEntries[0].rgPropVals[0].Value.LPSZ = szToRecips;
    pal->aEntries[0].rgPropVals[1].ulPropTag = PR_RECIPIENT_TYPE;
    pal->aEntries[0].rgPropVals[1].Value.l= MAPI_TO;
    pal->aEntries[0].cValues = 2;

    strToken = szToRecips;

    for(ind = 1; ind < nToRecips; ++ind)
    {
        LPADRENTRY pae = &pal->aEntries[ind];

        hr = MAPIAllocateBuffer(2 * sizeof(SPropValue),
                            (LPVOID FAR *)&pae->rgPropVals);
        if(hr)
        {
            goto err;
        }

        strToken = strchr(strToken, chDELIMITER);
        Assert(strToken);

        *strToken++ = '\0';

        pae->rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
        pae->rgPropVals[0].Value.LPSZ = strToken;
        pae->rgPropVals[1].ulPropTag = PR_RECIPIENT_TYPE;
        pae->rgPropVals[1].Value.l = MAPI_TO;
        pae->cValues = 2;
    }

    pal->cEntries = nToRecips;
    hr = pabAddrB->ResolveName(0, 0, NULL, pal);
    if(HR_FAILED(hr))
    {
        goto err;
    }

    *ppal = pal;

    return hrSuccess;

err:

    FreePadrlist(pal);

    return hr;
}




//////////////////////////////////////////////////////////////////////
// CInitMapi Class
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CInitMapi::CInitMapi() : fMAPIInited(FALSE), pabAddrB(NULL),
    pfldOutBox(NULL), pmdb(NULL), pses(NULL), pvalSentMailEID(NULL)
{

}

CInitMapi::~CInitMapi()
{
    DeInitMapi();
}


//
//  Init MAPI. Open address book, default message store,  outbox
//
HRESULT CInitMapi::InitMapi(void)
{

    HRESULT hr;

    hr = MAPIInitialize(NULL);
    if(hr)
    {
        return hr;
    }

    fMAPIInited = TRUE;

    hr = MAPILogonEx( NULL, NULL /* szProfile */ , NULL /* szPassword */,
                    MAPI_EXTENDED | MAPI_NEW_SESSION | MAPI_USE_DEFAULT,
                    &pses);
    if(hr)
    {
        goto err;
    }

    hr = HrOpenDefaultStore(pses, &pmdb);
    if(HR_FAILED(hr))
        goto err;

    hr = HrOpenAddressBook(pses, &pabAddrB);
    if(HR_FAILED(hr))
        goto err;

    hr = HrOpenOutFolder(pses, pmdb, &pfldOutBox);
    if(HR_FAILED(hr))
        goto err;

    /* retrieve the EntryID of the sentmail folder and change the property tag
        so that it is ready to use on a message*/
    hr = HrGetOneProp((LPMAPIPROP)pmdb, PR_IPM_SENTMAIL_ENTRYID, &pvalSentMailEID);
    if(hr)
    {
        goto err;
    }
    pvalSentMailEID->ulPropTag = PR_SENTMAIL_ENTRYID;

    return hrSuccess;

err:
    DeInitMapi();

    return hr;
}

//
//  Release MAPI interfaces and logoff
//
void CInitMapi::DeInitMapi(void)
{
    if (pfldOutBox != NULL)
    {
        UlRelease(pfldOutBox);
        pfldOutBox = NULL;
    }

    if(pmdb != NULL)
    {
        //get our message out of the outbox
        ULONG ulFlags = LOGOFF_PURGE;
        HRESULT hr;

        hr = pmdb->StoreLogoff(&ulFlags);

        UlRelease(pmdb);
        pmdb = NULL;
    }

    if (pabAddrB != NULL) {
        UlRelease(pabAddrB);
        pabAddrB = NULL;
    }

    if (pvalSentMailEID != NULL) {
        MAPIFreeBuffer(pvalSentMailEID);
        pvalSentMailEID = NULL;
    }

    if(pses != NULL)
    {
        pses->Logoff(0, 0, 0);
        UlRelease(pses);
        pses = NULL;
    }

    if(fMAPIInited)
    {
        MAPIUninitialize();
        fMAPIInited = FALSE;
    }

}

//
//  Open the default message store. (The one that has PR_DEFAULT_STORE set to
//  TRUE in the message store table.
//
HRESULT CInitMapi::HrOpenDefaultStore(LPMAPISESSION pses, LPMDB * ppmdb)
{
    HRESULT hr;
    LPMDB lpmdb = NULL;
    LPMAPITABLE ptable = NULL;
    LPSRowSet prows = NULL;
    LPSPropValue pvalProp = NULL;
    static SizedSPropTagArray(2, columns) =
                { 2, { PR_DEFAULT_STORE, PR_ENTRYID} };
    SPropValue valDefStore;
    SRestriction restDefStore;


    valDefStore.ulPropTag = PR_DEFAULT_STORE;
    valDefStore.dwAlignPad = 0;
    valDefStore.Value.b = TRUE;

    restDefStore.rt = RES_PROPERTY;
    restDefStore.res.resProperty.relop = RELOP_EQ;
    restDefStore.res.resProperty.ulPropTag = PR_DEFAULT_STORE;
    restDefStore.res.resProperty.lpProp = &valDefStore;

    Assert(pses);

    hr = pses->GetMsgStoresTable(0, &ptable);
    if (HR_FAILED(hr))
    {
        goto ret;
    }


    hr = HrQueryAllRows(ptable, (LPSPropTagArray) &columns, &restDefStore, NULL, 0, &prows);
    if (HR_FAILED(hr))
    {
        goto ret;
    }

    if (prows == NULL || prows->cRows == 0
        || prows->aRow[0].lpProps[1].ulPropTag != PR_ENTRYID)
    {
        ::MessageBox(NULL, "No default store", NULL, MB_OK);
        goto ret;
    }

    Assert(prows->cRows == 1);

    hr = pses->OpenMsgStore(0,
                        prows->aRow[0].lpProps[1].Value.bin.cb,
                        (LPENTRYID)prows->aRow[0].lpProps[1].Value.bin.lpb,
                        NULL, MDB_WRITE | MAPI_DEFERRED_ERRORS, &lpmdb);
    if (HR_FAILED(hr))
    {
        //if (GetScode(hr) != MAPI_E_USER_CANCEL)
        //    TraceFnResult(OpenMsgStore, hr);
        goto ret;
    }

#if 0
    if(hr) /*if we have a warning, display it and succeed */
    {
        LPMAPIERROR perr = NULL;

        pses->lpVtbl->GetLastError(pses, hr, 0, &perr);
        MakeMessageBox(hWnd, GetScode(hr), IDS_OPENSTOREWARN, perr, MBS_ERROR);
        MAPIFreeBuffer(perr);
    }

#endif

    Assert(lpmdb != NULL);

    *ppmdb = lpmdb;



ret:
    FreeProws(prows);
    UlRelease(ptable);

    return hr;
}

//
//  Open MAPI address book
//
HRESULT CInitMapi::HrOpenAddressBook(LPMAPISESSION pses, LPADRBOOK * ppAddrBook)
{
    HRESULT hr;
    LPADRBOOK pabAddrBook = NULL;

    Assert(pses);

    hr = pses->OpenAddressBook(0, NULL, 0, &pabAddrBook);
    if(HR_FAILED(hr))
    {
        return hr;
    }
#if 0
    if(hr) /*if we have a warning*/
    {
        LPMAPIERROR perr = NULL;

        pses->lpVtbl->GetLastError(pses, hr, 0, &perr);
        MakeMessageBox(hwnd, GetScode(hr), IDS_OPENABWARN, perr, MBS_ERROR);
        MAPIFreeBuffer(perr);
    }
#endif

    *ppAddrBook = pabAddrBook;

    return hrSuccess;
}

//
//  Open the outbox of the default store.
//  Assumes the default message store has been opened.
//
HRESULT CInitMapi::HrOpenOutFolder(LPMAPISESSION pses, LPMDB pmdb, LPMAPIFOLDER FAR * lppF)
{
    LPMAPIFOLDER lpfOutF = NULL;
    HRESULT hr;
    LPSPropValue lpspvFEID = NULL;
    ULONG  ulObjType = 0;

    Assert(pmdb);

    *lppF = NULL;
    hr = HrGetOneProp((LPMAPIPROP) pmdb, PR_IPM_OUTBOX_ENTRYID, &lpspvFEID);
    if(hr)
    {
        goto err;
    }

    Assert(lpspvFEID->ulPropTag == PR_IPM_OUTBOX_ENTRYID);

    hr = pmdb->OpenEntry(lpspvFEID->Value.bin.cb,
                        (LPENTRYID)lpspvFEID->Value.bin.lpb, NULL,
                        MAPI_MODIFY | MAPI_DEFERRED_ERRORS,
                        &ulObjType, (LPUNKNOWN FAR *) &lpfOutF);
    if(HR_FAILED(hr))
    {
        goto err;
    }

    *lppF = lpfOutF;


err:
    MAPIFreeBuffer(lpspvFEID);

    return hr;

}




//////////////////////////////////////////////////////////////////////
// CAddressEnum Class
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CAddressEnum::CAddressEnum(CInitMapi &_mapi): pmapi(_mapi)
{

}

CAddressEnum::~CAddressEnum()
{

}


HRESULT CAddressEnum::HrLookupSingleAddr(LPADRBOOK pabAddrB, 
		LPSTR szInputName, 
		LPSTR szResultBuffer, DWORD dwBufferSize)
{
    HRESULT hr;
    LPADRLIST pal = NULL;

    int cb = CbNewADRLIST(1);

    hr = MAPIAllocateBuffer(cb, (LPVOID FAR *) &pal);
    if(hr) {
        goto err;
    }
    ZeroMemory(pal, cb);

    hr = MAPIAllocateBuffer(2 * sizeof(SPropValue),
                            (LPVOID FAR *)&pal->aEntries[0].rgPropVals);
    if(hr) {
        goto err;
    }

    pal->aEntries[0].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
    pal->aEntries[0].rgPropVals[0].Value.lpszA = szInputName;
    pal->aEntries[0].rgPropVals[1].ulPropTag = PR_RECIPIENT_TYPE;
    pal->aEntries[0].rgPropVals[1].Value.l= MAPI_TO;
    pal->aEntries[0].cValues = 2;
    pal->cEntries = 1;

    hr = pabAddrB->ResolveName(0, 0, NULL, pal);
	if(HR_FAILED(hr)) {
        goto err;
    }

	for (int ind = 0; ind < (int) pal->cEntries; ind++) {
		for (int prop = 0; prop < (int) pal->aEntries[ind].cValues; prop++) {
			if (pal->aEntries[ind].rgPropVals[prop].ulPropTag == PR_DISPLAY_NAME ||
				pal->aEntries[ind].rgPropVals[prop].ulPropTag == PR_EMAIL_ADDRESS) {
				strncpy(szResultBuffer, 
						pal->aEntries[ind].rgPropVals[prop].Value.lpszA, 
						dwBufferSize);
				szResultBuffer[dwBufferSize - 1] = '\0';
				hr = S_OK;
				goto err;
			}
		}
	}
	hr = MAPI_E_NOT_FOUND;

err:

    FreePadrlist(pal);

    return hr;
}

HRESULT CAddressEnum::LookupAddress(LPSTR szInputName, LPSTR szResultBuffer, DWORD dwBufferSize)
{
	return HrLookupSingleAddr(pmapi.pabAddrB, szInputName, szResultBuffer, dwBufferSize);
}


#if 0
    HRESULT hr;
    LPABCONT pabRootCont;       // IABContainer
    LPMAPITABLE pMapiTable;

    // LPADRBOOK IAddrBook

    // Open the address book's root container
    hr = pmapi.pabAddrB->OpenEntry(0, NULL, IABContainer, MAPI_BEST_ACCESS,
            NULL, (LPUNKNOWN FAR *) &pabRootCont);
    if (HR_FAILED(hr)) {
        return hr;
    }

    hr = pabRootCont->GetContentsTable(0, &pMapiTable);
    if (HR_FAILED(hr)) {
        UlRelease(pabRootCont);
        return hr;
    }

hr = HrQueryAllRows(pMapiTable,
  LPSPropTagArray ptaga,
  LPSRestriction pres,
  NULL,     // sort order
  10,       // maximum records to return
  LPSRowSet FAR * pprows
);

        GetContentsTable
        IMAPITable::SortTable,
        IMAPITable::QueryRows
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\winsafer\test\amisafe\security.cpp ===
// Security.cpp: implementation of the CSecurity class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "amisafe.h"
#include "Security.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif


#define TESTPERM_READ 1
#define TESTPERM_WRITE 2

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSecurity::CSecurity()
{

}

CSecurity::~CSecurity()
{

}

BOOL CSecurity::IsAdministrator()
{
  	BOOL fAdmin = FALSE;
	HANDLE  hToken = NULL;
  	DWORD dwStatus;
   	DWORD dwACLSize;
  	DWORD cbps = sizeof(PRIVILEGE_SET); 
   	PACL pACL = NULL;
   	PSID psidAdmin = NULL;  	
  	PSECURITY_DESCRIPTOR psdAdmin = NULL;
  	PRIVILEGE_SET ps;
  	GENERIC_MAPPING gm;
	SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;

	// Prepare some memory
	ZeroMemory(&ps, sizeof(ps));
	ZeroMemory(&gm, sizeof(gm));

	// Get the Administrators SID
	if (AllocateAndInitializeSid(&sia, 2, 
           				SECURITY_BUILTIN_DOMAIN_RID, 
           				DOMAIN_ALIAS_RID_ADMINS,
           				0, 0, 0, 0, 0, 0, &psidAdmin) )
    {
       	// Get the Asministrators Security Descriptor (SD)
		psdAdmin = LocalAlloc(LPTR,SECURITY_DESCRIPTOR_MIN_LENGTH);
	  	if(InitializeSecurityDescriptor(psdAdmin,SECURITY_DESCRIPTOR_REVISION))
		{
 	
			// Compute size needed for the ACL then allocate the
			// memory for it
	   		dwACLSize = sizeof(ACCESS_ALLOWED_ACE) + 8 +
       		          	GetLengthSid(psidAdmin) - sizeof(DWORD);
			pACL = (PACL)LocalAlloc(LPTR, dwACLSize);

	   		// Initialize the new ACL
			if(InitializeAcl(pACL, dwACLSize, ACL_REVISION2))
	   		{
	   			// Add the access-allowed ACE to the DACL
				if(AddAccessAllowedAce(pACL,ACL_REVISION2,
				                     (TESTPERM_READ | TESTPERM_WRITE),psidAdmin))
	   			{
					// Set our DACL to the Administrator's SD
	   				if (SetSecurityDescriptorDacl(psdAdmin, TRUE, pACL, FALSE))
			   		{
			   			// AccessCheck is downright picky about what is in the SD,
			   			// so set the group and owner
		   				SetSecurityDescriptorGroup(psdAdmin,psidAdmin,FALSE);
						SetSecurityDescriptorOwner(psdAdmin,psidAdmin,FALSE);
	
					   	// Initialize GenericMapping structure even though we
					   	// won't be using generic rights
					   	gm.GenericRead = TESTPERM_READ;
					   	gm.GenericWrite = TESTPERM_WRITE;
					   	gm.GenericExecute = 0;
					   	gm.GenericAll = TESTPERM_READ | TESTPERM_WRITE;

						// AccessCheck requires an impersonation token, so lets 
						// indulge it
					   	ImpersonateSelf(SecurityImpersonation);

						if (OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, FALSE, &hToken))
						{
							if (!AccessCheck(psdAdmin, hToken, TESTPERM_READ, &gm, 
											&ps,&cbps,&dwStatus,&fAdmin))
									fAdmin = FALSE;

							CloseHandle(hToken);
						}
					}
				}
			}
		   	LocalFree(pACL);
		}
	   	LocalFree(psdAdmin);	
		FreeSid(psidAdmin);
	}		

	RevertToSelf();

	return(fAdmin);
}


BOOL CSecurity::IsUntrusted(void)
{
	BOOL fResult = FALSE;
	HANDLE hToken;

	if (OpenProcessToken(GetCurrentProcess(), 
				TOKEN_QUERY | TOKEN_DUPLICATE, &hToken)) {
		fResult = IsTokenUntrusted(hToken);
		CloseHandle(hToken);
	}
	return fResult;
}


// Return TRUE if the token does is not able to access a DACL against the
// Token User SID.  This is typically the case in these situations:
//		- the User SID is disabled (for deny-use only)
//		- there are Restricting SIDs and the User SID is not one of them.
//
// If an error occurs during the evaluation of this check, the result
// returned will be TRUE (assumed untrusted).
//
// The passed token handle must have been opened for TOKEN_QUERY and
// TOKEN_DUPLICATE access or else the evaluation will fail.

BOOL CSecurity::IsTokenUntrusted(HANDLE hToken)
{
  	BOOL fTrusted = FALSE;
  	DWORD dwStatus;
   	DWORD dwACLSize;
  	DWORD cbps = sizeof(PRIVILEGE_SET); 
   	PACL pACL = NULL;
	DWORD dwUserSidSize;
   	PTOKEN_USER psidUser = NULL;
  	PSECURITY_DESCRIPTOR psdUser = NULL;
  	PRIVILEGE_SET ps;
  	GENERIC_MAPPING gm;
	SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;
	HANDLE hImpToken;

	// Prepare some memory
	ZeroMemory(&ps, sizeof(ps));
	ZeroMemory(&gm, sizeof(gm));

	// Get the User's SID.
	if (!GetTokenInformation(hToken, TokenUser, NULL, 0, &dwUserSidSize))
	{
		psidUser = (PTOKEN_USER) LocalAlloc(LPTR, dwUserSidSize);
		if (psidUser != NULL)
		{
			if (GetTokenInformation(hToken, TokenUser, psidUser, dwUserSidSize, &dwUserSidSize))
			{
       			// Create the Security Descriptor (SD)
				psdUser = LocalAlloc(LPTR,SECURITY_DESCRIPTOR_MIN_LENGTH);
	  			if(InitializeSecurityDescriptor(psdUser,SECURITY_DESCRIPTOR_REVISION))
				{ 	
					// Compute size needed for the ACL then allocate the
					// memory for it
	   				dwACLSize = sizeof(ACCESS_ALLOWED_ACE) + 8 +
       		          			GetLengthSid(psidUser->User.Sid) - sizeof(DWORD);
					pACL = (PACL)LocalAlloc(LPTR, dwACLSize);

	   				// Initialize the new ACL
					if(InitializeAcl(pACL, dwACLSize, ACL_REVISION2))
	   				{
	   					// Add the access-allowed ACE to the DACL
						if(AddAccessAllowedAce(pACL,ACL_REVISION2,
											 (TESTPERM_READ | TESTPERM_WRITE),psidUser->User.Sid))
	   					{
							// Set our DACL to the Administrator's SD
	   						if (SetSecurityDescriptorDacl(psdUser, TRUE, pACL, FALSE))
			   				{
			   					// AccessCheck is downright picky about what is in the SD,
			   					// so set the group and owner
		   						SetSecurityDescriptorGroup(psdUser,psidUser->User.Sid,FALSE);
								SetSecurityDescriptorOwner(psdUser,psidUser->User.Sid,FALSE);
	
					   			// Initialize GenericMapping structure even though we
					   			// won't be using generic rights
					   			gm.GenericRead = TESTPERM_READ;
					   			gm.GenericWrite = TESTPERM_WRITE;
					   			gm.GenericExecute = 0;
					   			gm.GenericAll = TESTPERM_READ | TESTPERM_WRITE;

								if (ImpersonateLoggedOnUser(hToken) &&
									OpenThreadToken(GetCurrentThread(), 
											TOKEN_QUERY, FALSE, &hImpToken))
								{

									if (!AccessCheck(psdUser, hImpToken, TESTPERM_READ, &gm, 
													&ps,&cbps,&dwStatus,&fTrusted))
											fTrusted = FALSE;

									CloseHandle(hImpToken);
								}
							}
						}
					}
					LocalFree(pACL);
				}
				LocalFree(psdUser);
			}
	   		LocalFree(psidUser);
		}
	}		
	RevertToSelf();
	return(!fTrusted);
}


BOOL CSecurity::GetLoggedInUsername(LPTSTR szInBuffer, DWORD dwInBufferSize)
{
	DWORD dwUserSidSize;
   	PTOKEN_USER psidUser = NULL;
	HANDLE hToken;

	// Get the current process token.
	if (OpenProcessToken(GetCurrentProcess(), 
				TOKEN_QUERY | TOKEN_DUPLICATE, &hToken))
	{
		// Get the User's SID.
		if (!GetTokenInformation(hToken, TokenUser, NULL, 0, &dwUserSidSize))
		{
			psidUser = (PTOKEN_USER) LocalAlloc(LPTR, dwUserSidSize);
			if (psidUser != NULL)
			{
				if (GetTokenInformation(hToken, TokenUser, psidUser, dwUserSidSize, &dwUserSidSize))
				{
					TCHAR szDomain[200];
					DWORD dwDomainSize = sizeof(szDomain) / sizeof(TCHAR);
					SID_NAME_USE eSidUse;

					if (LookupAccountSid(
							NULL, psidUser->User.Sid,
							szInBuffer, &dwInBufferSize,
							szDomain, &dwDomainSize, &eSidUse))
					{
						LocalFree((HLOCAL) psidUser);
						CloseHandle(hToken);
						return TRUE;
					}
				}
				LocalFree((HLOCAL) psidUser);
			}
		}
		CloseHandle(hToken);
	}
	return NULL;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\winsafer\test\amisafe\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__1C7537B9_26C2_4C37_9931_C00CD651CD9D__INCLUDED_)
#define AFX_STDAFX_H__1C7537B9_26C2_4C37_9931_C00CD651CD9D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__1C7537B9_26C2_4C37_9931_C00CD651CD9D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\winsafer\test\canon\canon.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <tchar.h>              // for wprintf
#include <winsafer.h>
#include "..\..\saferp.h"       // for CodeAuthzFullyQualifyFilename


int __cdecl wmain(int argc, wchar_t *argv[])
{
    NTSTATUS Status;
    HANDLE hFile;
    UNICODE_STRING UnicodeResult;


    if (argc != 2) {
        wprintf(L"Invalid syntax.  No filename supplied.\n");
        return -1;
    }
    hFile = CreateFile(argv[1], GENERIC_READ, FILE_SHARE_READ, NULL,
                       OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (!hFile || hFile == INVALID_HANDLE_VALUE) {
        wprintf(L"Unable to open file: %s\n", argv[1]);
        return -1;
    }

    Status = CodeAuthzFullyQualifyFilename(
                hFile, FALSE, argv[1], &UnicodeResult);

    CloseHandle(hFile);

    if (!NT_SUCCESS(Status)) {
        wprintf(L"Unable to canonicalize filename: %s\n", argv[1]);
    }

    wprintf(L"Supplied filename:  %s\n", argv[1]);
    wprintf(L"Canonocalized result:  %*s\n",
            UnicodeResult.Length / sizeof(WCHAR), UnicodeResult.Buffer);

    RtlFreeUnicodeString(&UnicodeResult);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\winsafer\test\amisafe\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	amisafe.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\winsafer\test\amisafe\sendmail.h ===
// SendMail.h: interface for the CSendMail class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SENDMAIL_H__C61A78A1_5B70_43EA_8F58_8D7600DE68BA__INCLUDED_)
#define AFX_SENDMAIL_H__C61A78A1_5B70_43EA_8F58_8D7600DE68BA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <mapiutil.h>
#include <mapix.h>
#include <mapidbg.h>


class CInitMapi  
{
	friend class CSendMail;
	friend class CAddressEnum;
public:
	void DeInitMapi(void);
	HRESULT InitMapi(void);
	CInitMapi();
	virtual ~CInitMapi();

protected:
	LPMAPISESSION pses;
	BOOL fMAPIInited;
	LPSPropValue pvalSentMailEID;
	LPMDB pmdb;
	LPADRBOOK pabAddrB;
	LPMAPIFOLDER pfldOutBox;

private:
	static HRESULT HrOpenOutFolder(LPMAPISESSION pses, LPMDB pmdb, LPMAPIFOLDER FAR * lppF);
	static HRESULT HrOpenAddressBook(LPMAPISESSION pses, LPADRBOOK * ppAddrBook);
	static HRESULT HrOpenDefaultStore(LPMAPISESSION pses, LPMDB * ppmdb);
};


class CSendMail  
{
public:
	HRESULT SetRecipients(LPSTR szRecipients);
	HRESULT CreateMail(LPSTR szSubject);
	HRESULT Transmit();
	CSendMail(CInitMapi &_mapi);
	virtual ~CSendMail();

protected:
	CInitMapi & pmapi;
	LPMESSAGE pmsg;

private:
	static HRESULT HrCreateAddrList(LPADRBOOK pabAddrB, LPADRLIST * ppal, LPSTR szToRecips);
	static HRESULT HrInitMsg(LPMESSAGE pmsg, LPSPropValue pvalSentMailEID, LPSTR szSubject);
	static HRESULT HrCreateOutMessage(LPMAPIFOLDER pfldOutBox, LPMESSAGE FAR * ppmM);
};




class CAddressEnum  
{
public:
	HRESULT LookupAddress(LPSTR szInputName, LPSTR szResultBuffer, DWORD dwBufferSize);
	CAddressEnum(CInitMapi &_mapi);
	virtual ~CAddressEnum();

protected:
	CInitMapi & pmapi;

private:
	static HRESULT HrLookupSingleAddr(LPADRBOOK pabAddrB, 
		LPSTR szInputName, 
		LPSTR szResultBuffer, DWORD dwBufferSize);
};

#endif // !defined(AFX_SENDMAIL_H__C61A78A1_5B70_43EA_8F58_8D7600DE68BA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\winsafer\test\cmptoktst\cmptoktst.cpp ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <winsafer.h>


/*
BOOL WINAPI
CodeAuthzCompareTokenLevels (
        IN HANDLE   ClientAccessToken,
        IN HANDLE   ServerAccessToken,
        OUT PDWORD  pdwResult
        )
*/

void _cdecl main()
{
    static const levelids[4] = {
        AUTHZLEVELID_UNTRUSTED,
        AUTHZLEVELID_CONSTRAINED,
        AUTHZLEVELID_NORMALUSER,
        AUTHZLEVELID_FULLYTRUSTED
    };

    HANDLE hTokens[4];
    BOOL bStatus;
    DWORD i;
    HANDLE hProcessToken;

    bStatus = OpenProcessToken(GetCurrentProcess(),
                               TOKEN_QUERY | TOKEN_DUPLICATE,
                               &hProcessToken);
    if (!bStatus) {
        printf("Failed to open process token (lasterror=%d).\n", GetLastError());
        return;
    }


    for (int i = 0; i < 4; i++)
    {
        HAUTHZLEVEL hCodeAuthLevel;

        bStatus = CreateCodeAuthzLevel(AUTHZSCOPEID_MACHINE,
                                       levelids[i],
                                       AUTHZCRLEV_OPEN,
                                       &hCodeAuthLevel,
                                       NULL);
        if (!bStatus) {
            printf("Failed to create level %d (lasterror=%d)\n", levelids[i], GetLastError());
            return;
        }

        bStatus = ComputeAccessTokenFromCodeAuthzLevel(hCodeAuthLevel,
                                                       hProcessToken,
                                                       &hTokens[i],
                                                       0,
                                                       NULL);
        if (!bStatus) {
            printf("ComputeAccessTokenFromCodeAuthzLevel failed with GLE=%d\n", GetLastError());
            return;
        }

        bStatus = CloseCodeAuthzLevel(hCodeAuthLevel);
        if (!bStatus) {
            printf("Failed to close level.\n");
            return;
        }
    }

    for (int testi = 0; testi < 4; testi++) {
        for (int testj = 0; testj < 4; testj++) {
            DWORD dwCompareResults;
            DWORD dwExpected;

            bStatus = CodeAuthzCompareTokenLevels (
                            hTokens[testi],
                            hTokens[testj],
                            &dwCompareResults);
            if (!bStatus) {
                printf("CompareTokens failed for test %d,%d with error=%d\n",
                       testi, testj, GetLastError());
                continue;
            }

            if (testi == testj) {
                dwExpected = 0;
            } else if (testi < testj) {
                dwExpected = 1;
            } else {
                dwExpected = -1;
            }

            if (dwCompareResults != dwExpected) {
                printf("CompareTokens return wrong value for test %d,%d (actual=%d, expected=%d)\n",
                       testi, testj, dwCompareResults, dwExpected);
            } else {
                printf("CompareTokens passed test %d,%d (returned %d)\n",
                       testi, testj, dwCompareResults);
            }
        }
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\winsafer\test\desktops\dbg.h ===
//-------------------------------------------------------------------------------//
//
// Desktops - 
//
// File	   - Dbg.h.  Debugging MACROS
//
// Created - Oct 1996
//			 Martin Holladay (a-martih)
// 
// Release - NT Resource Kit December 1996 Update Release
//
//--------------------------------------------------------------------------------//


#ifdef _DEBUG

//
// Debug
//

#include "stdio.h"

//
// Debug
//
#define DBG_INIT()		(dbgFP = fopen("C:\\TEMP\\Desktops.Dbg", "w+")); \
						(fclose(dbgFP))
#define DBG_CLOSE()		((void)0)
#define DBG_TRACE(c)	(dbgFP = fopen("C:\\TEMP\\Desktops.Dbg", "a"));	\
						(fputs(c, dbgFP));	\
						(fclose(dbgFP))


#else

//
// Release
//

#define DBG_INIT()		((void)0)
#define DBG_CLOSE()		((void)0)
#define DBG_TRACE(c)	((void)0)
#define DBG_TRACEW(c)	((void)0)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\winsafer\test\desktops\cmdhand.cpp ===
////////////////////////////////////////////////////////////////////////////////
//
// File:        Cmdhand.cpp
// Created:        Feb 1996
// By:            Martin Holladay (a-martih) and Ryan D. Marshall (a-ryanm)
//
// Project:    MultiDesk - The NT Desktop Switcher
//
//
//
// Revision History:
//
//            March 1997    - Add external icon capability
//
//

/*--------------------------------------------------------------------*/
/* Include Files                                                        */
/*--------------------------------------------------------------------*/

#include <windows.h>
#include <assert.h>
#include <stdio.h>
#include <shellapi.h>
#include <commctrl.h>
#include "prsht.h"
#include "DeskSpc.h"
#include "Desktop.h"
#include "Registry.h"
#include "resource.h"
#include "CmdHand.h"
#include "Menu.h"
#include "User.h"
#include <saifer.h>

/*--------------------------------------------------------------------*/
/* Global Variables                                                   */
/*--------------------------------------------------------------------*/

extern APPVARS            AppMember;
extern DispatchFnType    CreateDisplayFn;


/*------------------------------------------------------------------------------*/
/*------------------------------------------------------------------------------*/

LRESULT CALLBACK TransparentMessageProc(
                        HWND   hWnd,
                        UINT   uMessage,
                        WPARAM wParam,
                        LPARAM lParam)
{
    switch (uMessage)
    {
        case WM_PAINT:
        {
            HDC hDC;
            HFONT hFont;
            HBRUSH hBrush;
            PAINTSTRUCT ps;
            TCHAR szTitle[200];
            RECT rect;

            hDC = BeginPaint(hWnd, &ps);
            if (hDC != NULL)
            {
                GetWindowText(hWnd, szTitle, sizeof(szTitle) / sizeof(TCHAR));
                GetClientRect(hWnd, &rect);
                hBrush = CreateSolidBrush(TRANSPARENT_BACKCOLOR);
                if (hBrush != NULL)
                {
                    FillRect(hDC, &rect, hBrush);

                    hFont = CreateFont(rect.bottom, 0, 0, 0, FW_DONTCARE,
                            TRUE, FALSE, FALSE, DEFAULT_CHARSET,
                            OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                            DEFAULT_QUALITY, DEFAULT_PITCH, TEXT("Arial"));
                    if (hFont != NULL)
                    {
                        SetTextColor(hDC, TRANSPARENT_TEXTCOLOR);
                        SetBkMode(hDC, TRANSPARENT);
                        HFONT hOldFont = (HFONT) SelectObject(hDC, hFont);
                        DrawText(hDC, szTitle, -1, &rect,
                                DT_TOP | DT_RIGHT | DT_END_ELLIPSIS);
                        SelectObject(hDC, hOldFont);
                        DeleteObject(hFont);
                    }
                    DeleteObject(hBrush);
                }
                EndPaint(hWnd, &ps);
            }
            return FALSE;
        }

        default:
            return (DefWindowProc(hWnd, uMessage, wParam, lParam));
            break;
    }
    return (0L);
}

/*------------------------------------------------------------------------------*/
/*------------------------------------------------------------------------------*/

LRESULT CALLBACK MainMessageProc(
                        HWND   hWnd,
                        UINT   uMessage,
                        WPARAM wParam,
                        LPARAM lParam)
{
    WINDOWPOS*    pWP;
    UINT        uCmdId;
    UINT        uCmdType;
    UINT        uCmdMsg;
    HWND        hTargetWnd;
    static UINT s_uTaskbarRestart;


    switch (uMessage)
    {
        case WM_CREATE:
            s_uTaskbarRestart = RegisterWindowMessage(TEXT("TaskbarCreated"));
            RegisterHotKey(hWnd, 0x7654, MOD_ALT | MOD_CONTROL, 41);        // CTRL+ALT+A
            PlaceOnTaskbar(hWnd);
            break;

        case WM_HOTKEY:
            if (wParam == 0x7654)
            {
                // keyboard hotkey invoked menu popup
                AppMember.nX = AppMember.nY = 0;
                SetWindowPos(hWnd, HWND_TOPMOST,
                      AppMember.nX, AppMember.nY,
                      AppMember.nWidth, AppMember.nHeight,
                      0);

                HideOrRevealUI(hWnd, FALSE);
                UpdateCurrentUI(hWnd);
                SetActiveWindow(hWnd);
                SetForegroundWindow(hWnd);
                break;
            }
            return DefWindowProc(hWnd, uMessage, wParam, lParam);


        //case WM_CONTEXTMENU:
        //TODO
            

        case WM_CLOSE:
            if ((UINT) wParam == WM_NO_CLOSE)
                break;
            CloseRequestHandler(hWnd);
            break;

        case WM_ENDSESSION:
            AppMember.pDesktopControl->RegSaveSettings();
            ShowWindow(hWnd, SW_HIDE);
            RemoveFromTaskbar(hWnd);
            AppMember.pDesktopControl->RunDown();
            PostThreadMessage(GetCurrentThreadId(), WM_PUMP_TERMINATE, 0, 0);
            break;

        case WM_NOTIFY:
        {
            int idCtrl = (int) wParam;
            LPNMHDR lpNmhdr = (LPNMHDR) lParam;
            NMLVDISPINFO *pnmv = (NMLVDISPINFO*) lParam;

            if (lpNmhdr->code == LVN_GETDISPINFO &&
                lpNmhdr->idFrom == IDC_DESKTOPICONLIST)
            {
                //
                // This notification is called when the ListView needs
                // to obtain information about the item that it is displaying.
                //
                static int nextindex = 0;
                static CHAR desktopname[5][MAX_NAME_LENGTH];

                // return the name of this desktop.
                AppMember.pDesktopControl->GetDesktopName(pnmv->item.iItem,
                        desktopname[nextindex], MAX_NAME_LENGTH);
                pnmv->item.pszText = desktopname[nextindex];
                pnmv->item.cchTextMax = MAX_NAME_LENGTH;
                pnmv->item.mask |= LVIF_TEXT;
                nextindex = (nextindex + 1) % 5;

                // return the state of this desktop (unused).
                pnmv->item.state = 0;
                pnmv->item.stateMask = 0;
                pnmv->item.mask |= LVIF_STATE;

                // return the icon of this desktop.
                pnmv->item.iImage = AppMember.pDesktopControl->GetDesktopIconID(pnmv->item.iItem);
                pnmv->item.mask |= LVIF_IMAGE;

                // return the ident attribute.
                #if (_WIN32_IE >= 0x0300)
                pnmv->item.iIndent = 0;
                pnmv->item.mask |= LVIF_INDENT;
                #endif
                break;
            }
            else if (lpNmhdr->code == LVN_ITEMACTIVATE  &&
                lpNmhdr->idFrom == IDC_DESKTOPICONLIST)
            {
                //
                // This notification is called when the user has single-clicked
                // an item in the listview.  We use this signal to switch desktops.
                //
                HideOrRevealUI(hWnd, TRUE);

                LPNMITEMACTIVATE lpnmia = (LPNMITEMACTIVATE)lParam;
                if (lpnmia->iItem >= 0)
                    SwitchToDesktop(lpnmia->iItem);
                break;
            }
            else if (lpNmhdr->code == NM_RCLICK &&
                lpNmhdr->idFrom == IDC_DESKTOPICONLIST)
            {
                //
                // This notification is triggered when the user right-clicks
                // on a listview item or in the listview box.
                //
                LPNMITEMACTIVATE lpnmia = (LPNMITEMACTIVATE)lParam;
                HMENU hPopupMenu = CreateListviewPopupMenu();

                // display the popup
                if (hPopupMenu != NULL)
                {
                    RECT rect;
                    WORD wChoiceId;

                    if (lpnmia->iItem < 0)
                    {
                        // clicked off of an item, so gray the item-specific options.
                        EnableMenuItem(hPopupMenu, IDM_DELETE_DESKTOP, MF_BYCOMMAND | MF_GRAYED);
                        EnableMenuItem(hPopupMenu, IDM_DESKTOP_PROPERTIES, MF_BYCOMMAND | MF_GRAYED);
                    }
                    else if (lpnmia->iItem == 0)
                    {
                        // clicked on the first Desktop, cannot delete it though.
                        EnableMenuItem(hPopupMenu, IDM_DELETE_DESKTOP, MF_BYCOMMAND | MF_GRAYED);
                    }

                    // Display the popup and get the selected choice.
                    GetWindowRect(lpNmhdr->hwndFrom, &rect);
                    wChoiceId = (WORD) TrackPopupMenu(hPopupMenu,
                        TPM_CENTERALIGN | TPM_TOPALIGN | TPM_RIGHTBUTTON | TPM_RETURNCMD | TPM_NONOTIFY,
                        (rect.left + lpnmia->ptAction.x),
                        (rect.top + lpnmia->ptAction.y), 0, hWnd, NULL);

                    DestroyMenu(hPopupMenu);

                    // Handle the choice that was selected.
                    switch (wChoiceId)
                    {
                        case IDM_NEW_DESKTOP:
                            CreateNewDesktop(hWnd);
                            break;

                        case IDM_DELETE_DESKTOP:
                            if (lpnmia->iItem >= 0) {
                                DeleteDesktop(hWnd, lpnmia->iItem);
                                UpdateCurrentUI(hWnd);
                            }
                            break;

                        case IDM_DESKTOP_PROPERTIES:
                            if (lpnmia->iItem >= 0) {
                                RenameDialog(hWnd, lpnmia->iItem);
                                UpdateCurrentUI(hWnd);
                            }
                            break;
                    }

                }
                break;
            }

            return DefWindowProc(hWnd, uMessage, wParam, lParam);
        }

        case WM_THREAD_TERMINATE:
            DestroyWindow(hWnd);
            break;


        case WM_TASKBAR:
            uCmdId = (UINT) wParam;
            uCmdMsg = (UINT) lParam;
            if (uCmdId == IDI_TASKBAR_ICON &&
                (uCmdMsg == WM_RBUTTONUP || uCmdMsg == WM_LBUTTONUP) &&
                !IsWindowVisible(hWnd))
            {
                POINT tPoint;

                GetCursorPos(&tPoint);
                AppMember.nX = tPoint.x - AppMember.nWidth;
                AppMember.nY = tPoint.y - AppMember.nHeight;
                SetWindowPos(hWnd, HWND_TOPMOST,
                      AppMember.nX, AppMember.nY,
                      AppMember.nWidth, AppMember.nHeight,
                      0);

                HideOrRevealUI(hWnd, FALSE);
                UpdateCurrentUI(hWnd);
                SetActiveWindow(hWnd);
                SetForegroundWindow(hWnd);
            }
            break;


        case WM_ACTIVATEAPP:
            // We are losing focus, so hide ourself again.
            if (!wParam)
                HideOrRevealUI(hWnd, TRUE);

            return DefWindowProc(hWnd, uMessage, wParam, lParam);


        case WM_SIZE:
            {
                RECT rect;
                GetWindowRect(hWnd, &rect);
                AppMember.nX = rect.left;
                AppMember.nY = rect.top;
                AppMember.nWidth = rect.right - rect.left;
                AppMember.nHeight = rect.bottom - rect.top;
                GetClientRect(hWnd, &rect);

                HWND hWndList = GetDlgItem(hWnd, IDC_DESKTOPICONLIST);
                SetWindowPos(hWndList, NULL,
                        0, 0, (rect.right - rect.left), (rect.bottom - rect.top),
                        SWP_NOZORDER);
            }
            return DefWindowProc(hWnd, uMessage, wParam, lParam);

        default:
            // If Explorer has just started or restarted, then be
            // sure to add ourself back to it so the user does not
            // lose the ability to invoke us.
            if(uMessage == s_uTaskbarRestart)
                PlaceOnTaskbar(hWnd);

            return DefWindowProc(hWnd, uMessage, wParam, lParam);
            break;
    }
    return 0L;
}




/*------------------------------------------------------------------------------*/
/*
/* Create a new desktop
/*
/*------------------------------------------------------------------------------*/

void CreateNewDesktop(HWND hWnd)
{
    // Use the creation wizard - or create it the old fashioned way.

    if (AppMember.pDesktopControl->GetNumDesktops() < MAX_DESKTOPS)
    {
        UINT nDskTopNum = AppMember.pDesktopControl->GetNumDesktops();
		AppMember.pDesktopControl->SaveCurrentDesktopScheme();
		AppMember.pDesktopControl->AddDesktop(CreateDisplayFn, NULL);
        RenameDialog(hWnd, nDskTopNum);
        UpdateCurrentUI(hWnd);
    }
    else
    {
        Message(TEXT("Maximum number of desktops reached"));
    }
}


//------------------------------------------------------------------------------//
//
// Delete Desktop
//
//-----------------------------------------------------------------------------//

BOOL DeleteDesktop(HWND hWnd, UINT nDesktop)        // zero based
{
    HWND    hTargetWnd, hCurrentWnd;
    UINT    nResult;

    assert(nDesktop >= 0 && nDesktop < AppMember.pDesktopControl->GetNumDesktops());

    if (nDesktop == 0)
    {
        return FALSE;
    }

    hTargetWnd = AppMember.pDesktopControl->GetWindowDesktop(nDesktop);
    nResult = AppMember.pDesktopControl->RemoveDesktop(nDesktop);
    if (nResult == SUCCESS_THREAD_TERMINATION)
    {
        if (hTargetWnd) PostMessage(hTargetWnd, WM_THREAD_TERMINATE, 0, 0);
    }

    //
    // Update the UI for the active desktop.
    //
    hCurrentWnd = AppMember.pDesktopControl->GetWindowDesktop(AppMember.pDesktopControl->GetActiveDesktop());
    UpdateCurrentUI(hCurrentWnd);

    return TRUE;
}


//------------------------------------------------------------------------------//
//
// Switch to desktop nDesktop Number
//
//-----------------------------------------------------------------------------//

void SwitchToDesktop(UINT nDesktop)         // zero based
{
    HWND hTargetWnd;

    assert(nDesktop >= 0 && nDesktop < AppMember.pDesktopControl->GetNumDesktops());

    //
    // Switching to ourself - that is easy.
    //
    if (nDesktop == AppMember.pDesktopControl->GetActiveDesktop())
    {
        return;
    }

    hTargetWnd = AppMember.pDesktopControl->GetWindowDesktop(nDesktop);
    UpdateCurrentUI(hTargetWnd);
    AppMember.pDesktopControl->ActivateDesktop(nDesktop);
}



/*------------------------------------------------------------------------------*/
/*                                                                                */
/*    RenameDialogProc() - CallBack procedure for the Rename dialog within the    */
/*    Properties property sheet and the Rename only property sheet                */
/*                                                                                */
/*------------------------------------------------------------------------------*/

LRESULT CALLBACK
RenameDialogProc(HWND    hWnd,
                 UINT    nMessage,
                 WPARAM    wParam,
                 LPARAM    lParam)
{
    static BOOL        bInitialized;
    UINT            nBtnIndex;
    CHAR            szTemp[MAX_TITLELEN + 1];
    UINT                i;
    HICON                hIcon1;
    UINT                nCurSel;
    UINT                nResult;

    switch (nMessage)
    {
        case WM_INITDIALOG:
        {
            //
            // First position the property sheet in the center of the screen
            //
            HWND hParent = GetParent(hWnd);
            assert(hParent);
            RECT rc;
            if (GetWindowRect(hParent, &rc))
            {
                SetWindowPos(
                        hParent,
                        HWND_TOP,
                        (GetSystemMetrics(SM_CXSCREEN) / 2) - ((rc.right - rc.left) / 2),
                        (GetSystemMetrics(SM_CYSCREEN) / 2) - ((rc.bottom - rc.top) / 2),
                        rc.right - rc.left,
                        rc.bottom - rc.top,
                        SWP_SHOWWINDOW);
            }

            //
            // Now initialize the controls
            //
            PRENAMEINFO pRenameInfo = ((PRENAMEINFO) ((PROPSHEETPAGE *) lParam)->lParam);
            nBtnIndex = pRenameInfo->nBtnIndex;
            SetWindowLong(hWnd, GWL_USERDATA, (LONG) nBtnIndex);
            AppMember.pDesktopControl->GetDesktopName(nBtnIndex, szTemp, MAX_TITLELEN);
            SetDlgItemText(hWnd, IDC_EDIT_NAME, szTemp);


            //
            // Initialize the SAIFER Authorization Object name too.
            // The first desktop cannot have a SAIFER object name associated with
            // it since its shell has already been launched by the time
            // Multidesk starts, so it always runs unmodified.
            //
            SendDlgItemMessage(hWnd, IDC_EDIT_SAIFER, CB_RESETCONTENT, 0, 0);
            SendDlgItemMessage(hWnd, IDC_EDIT_SAIFER, CB_ADDSTRING, 0, (LPARAM) TEXT("(No modification of trust)"));
            if (nBtnIndex != 0) {
                // all secondary desktops can be modified.
                AppMember.pDesktopControl->GetSaiferName(nBtnIndex, szTemp, MAX_TITLELEN);
                EnableWindow(GetDlgItem(hWnd, IDC_EDIT_SAIFER), TRUE);

                // Fetch the list of all object names.
                DWORD dwInfoBufferSize;
                LPTSTR InfoBuffer = NULL;
                if (!GetInformationCodeAuthzPolicy(AUTHZSCOPE_HKLM,
                        CodeAuthzPol_ObjectList,
                        0, NULL, &dwInfoBufferSize) &&
                    GetLastError() == ERROR_INSUFFICIENT_BUFFER)
                {
                    InfoBuffer = (LPTSTR) HeapAlloc(GetProcessHeap(), 0, dwInfoBufferSize);
                    if (InfoBuffer != NULL)
                    {
                        if (!GetInformationCodeAuthzPolicy(AUTHZSCOPE_HKLM,
                            CodeAuthzPol_ObjectList,
                            dwInfoBufferSize, InfoBuffer, &dwInfoBufferSize))
                        {
                            HeapFree(GetProcessHeap(), 0, InfoBuffer);
                            InfoBuffer = NULL;
                        }
                    }
                }                        


                // Iterate through and add all of the items.
                BOOL bFoundMatch = FALSE;
                if (InfoBuffer != NULL)
                {
                    DWORD dwChoiceIndex = 1;
                    LPCTSTR lpOneChoice = (LPCTSTR) InfoBuffer;
                    while (*lpOneChoice != TEXT('\0')) {
                        SendDlgItemMessage(hWnd, IDC_EDIT_SAIFER, CB_ADDSTRING, 0, (LPARAM) lpOneChoice);
                        if (!bFoundMatch && strcmp(lpOneChoice, szTemp) == 0) {
                            SendDlgItemMessage(hWnd, IDC_EDIT_SAIFER, CB_SETCURSEL, dwChoiceIndex, 0);
                            bFoundMatch = TRUE;
                        }
                        while (*lpOneChoice++) {};
                        dwChoiceIndex++;
                    }
                    HeapFree(GetProcessHeap(), 0, InfoBuffer);
                }
                if (!bFoundMatch)
                    SendDlgItemMessage(hWnd, IDC_EDIT_SAIFER, CB_SETCURSEL, 0, 0);

                
                // Display a little warning if the desktop is already running.
                DESKTOP_NODE *pCurrentNode = AppMember.pDesktopControl->GetDesktopNode(nBtnIndex);
                if (pCurrentNode != NULL && pCurrentNode->bShellStarted)
                    SetDlgItemText(hWnd, IDC_SAIFER_NOTETEXT,
                            TEXT("(desktop shell already started. changes will take effect on next multidesk session)"));
                else
                    SetDlgItemText(hWnd, IDC_SAIFER_NOTETEXT, TEXT(""));
            } else {
                // the first desktop cannot be modified.
                EnableWindow(GetDlgItem(hWnd, IDC_EDIT_SAIFER), FALSE);
                SetDlgItemText(hWnd, IDC_SAIFER_NOTETEXT,
                        TEXT("(the primary desktop cannot run with a modified token)"));
            }


            //
            // Fill up the List Box with the loaded Icons - making the current Icon First (0)
            //
            HWND hListBox = GetDlgItem(hWnd, IDC_ICONLIST);
            SendMessage(hListBox, WM_SETREDRAW, FALSE, 0L);
            for (i = 0; i < NUM_BUILTIN_ICONS; i++)
            {
                SendMessage(hListBox, LB_ADDSTRING, 0, (LPARAM) AppMember.pDesktopControl->GetBuiltinIcon(i));
            }
            SendMessage(hListBox, LB_SETCURSEL,
                AppMember.pDesktopControl->GetDesktopIconID(nBtnIndex), 0 );
            SendMessage(hListBox, WM_SETREDRAW, TRUE, 0L);


            bInitialized = TRUE;
            break;
        }

        case WM_COMMAND:
        {
            if (HIWORD (wParam) == LBN_SELCHANGE && bInitialized)     // Icon box
            {
                PropSheet_Changed(GetParent(hWnd), hWnd);
                InvalidateRect(GetDlgItem(hWnd, IDC_DEFICON), NULL, TRUE);
            }
            else if ((HIWORD(wParam) == EN_CHANGE) && bInitialized)
            {
                PropSheet_Changed(GetParent(hWnd), hWnd);
            }

            break;
        }

        case WM_MEASUREITEM:
        {
            //
            // Owner Draw List Box Control
            //
            MEASUREITEMSTRUCT *pMeasureItem = (MEASUREITEMSTRUCT *) lParam;
            pMeasureItem->itemWidth = GetSystemMetrics(SM_CXICON) + 12;
            pMeasureItem->itemHeight = GetSystemMetrics(SM_CYICON) + 4;
            break;
        }

        case WM_DRAWITEM:            // Dlg controls need redrawing
        {
            HWND hListBox = GetDlgItem(hWnd, IDC_ICONLIST);
            DRAWITEMSTRUCT *pDrawItem = (DRAWITEMSTRUCT *) lParam;

            if (wParam == IDC_DEFICON )                    // Display panel sample icon
            {
                nCurSel = SendMessage(hListBox, LB_GETCURSEL, 0, 0);
                if (nCurSel == LB_ERR)
                {
                    nCurSel = 0;
                }

                if (LB_ERR == SendMessage(hListBox, LB_GETTEXT, nCurSel, (LPARAM) &hIcon1))
                {
                    nResult = GetLastError();
                    hIcon1 = LoadIcon(AppMember.hInstance, MAKEINTRESOURCE(IDI_MULTIDESK_ICON));
                }

                DrawIcon(pDrawItem->hDC,
                         pDrawItem->rcItem.left,
                         pDrawItem->rcItem.top,
                         (HICON) hIcon1);

                UpdateWindow(hWnd);
                break;
            }

            if (pDrawItem->itemState & ODS_SELECTED)
            {
                SetBkColor(pDrawItem->hDC, GetSysColor(COLOR_HIGHLIGHT));
            }
            else
            {
                SetBkColor(pDrawItem->hDC, GetSysColor(COLOR_WINDOW));
            }

            ExtTextOut(pDrawItem->hDC, 0, 0, ETO_OPAQUE, &pDrawItem->rcItem, NULL, 0, NULL);

            if ((int) pDrawItem->itemID >= 0)
            {
                DrawIcon(pDrawItem->hDC,
                         (pDrawItem->rcItem.left + pDrawItem->rcItem.right - GetSystemMetrics(SM_CXICON)) /2,
                         (pDrawItem->rcItem.bottom + pDrawItem->rcItem.top - GetSystemMetrics(SM_CYICON)) /2,
                         (HICON) pDrawItem->itemData);

            }
            if (pDrawItem->itemState & ODS_FOCUS)
            {
                DrawFocusRect(pDrawItem->hDC, &pDrawItem->rcItem);
            }
            break;
        }

        case WM_DESTROY:
            bInitialized = FALSE;
            break;

        case WM_NOTIFY:
        {
            LPNMHDR lpNotifyMsg = (NMHDR FAR*) lParam;
            switch (lpNotifyMsg->code)
            {
                case PSN_APPLY:
                {
                    //
                    // OK or Apply button clicked, save the info -
                    //   Get the main dialog's hwnd and update the button's title

                    HWND hParent = GetParent(GetParent(hWnd));
                    assert(hParent);

                    //// Get number of desktop ////

                    nBtnIndex = (UINT) GetWindowLong(hWnd, GWL_USERDATA);

                    //// Get desktop name and save it to Node ////

                    GetDlgItemText(hWnd, IDC_EDIT_NAME, szTemp, MAX_TITLELEN);
                    AppMember.pDesktopControl->SetDesktopName(nBtnIndex, szTemp);

                    //// Get and save the Saifer object name ////

                    GetDlgItemText(hWnd, IDC_EDIT_SAIFER, szTemp, MAX_TITLELEN);
                    AppMember.pDesktopControl->SetSaiferName(nBtnIndex, szTemp);

                    //// Get and save the icon for the desktop ////

                    HWND hListBox = GetDlgItem(hWnd, IDC_ICONLIST);
                    nCurSel = SendMessage(hListBox, LB_GETCURSEL, 0, 0);
                    if (nCurSel != LB_ERR)
                    {
                        AppMember.pDesktopControl->SetDesktopIconID(nBtnIndex, nCurSel);
                    }


                    //
                    // Now update the UI
                    //                    
                    UpdateCurrentUI(hWnd);
                    break;
                }

                default:
                    break;
            }
            break;
        }

        default:
            break;
    }
    return 0L;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\winsafer\test\desktops\cmdhand.h ===
////////////////////////////////////////////////////////////////////////////////
//
// File:	Cmdhand.h
//
// Created:	Jan 1996
// By		Ryan D. Marshall (ryanm)
//			Martin Holladay (a-martih)
// 
// Project:	Resource Kit Desktop Switcher
//
//
////////////////////////////////////////////////////////////////////////////////

#ifndef __MULTIDESK_CMDHAND_H__
#define __MULTIDESK_CMDHAND_H__

//
// Command Handlers 
//
LRESULT CALLBACK TransparentMessageProc(HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK MainMessageProc(HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK RenameDialogProc(HWND hWnd, UINT uMesssage, WPARAM wParam, LPARAM lParam);

//
// Local Function Prototypes
//
void CreateNewDesktop(HWND hWnd);
BOOL DeleteCurrentDesktop(HWND hWnd);
BOOL DeleteDesktop(HWND hWnd, UINT nDesktop);
void SwitchToDesktop(UINT nDesktop);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\winsafer\test\desktops\deskspc.cpp ===
////////////////////////////////////////////////////////////////////////////////
//
// File:		MultiDesk.cpp
// Created:		Jan 1996
// By:			Martin Holladay (a-martih) and Ryan D. Marshall (a-ryanm)
// 
// Project:	Desktop Switcher
//
// Main Functions:
//			InitApplication - Initialize an instance of the Application
//			WinMain()
//			StartThreadDisplay() - Starts a UI thread
//
// Misc. Functions (helpers)
//
//
// Revision History:
//
//			March 1997	- Add external icon capability
//									 
//

#include <windows.h>       
#include <assert.h>
#include <stdio.h>
#include <shellapi.h>
#include <commctrl.h>
#include "Resource.h"
#include "DeskSpc.h"
#include "Desktop.h"
#include "Registry.h"
#include "User.h"
#include "CmdHand.h"
#include "Splash.h"

//
// Global structure to hold application wide variables
//
APPVARS AppMember;		

//
// Dispatch function for creating displays
//
DispatchFnType CreateDisplayFn = StartThreadDisplay;

/*------------------------------------------------------------------------------*/
/*------------------------------------------------------------------------------*/

BOOL InitApplication(HINSTANCE hInstance)
{
    WNDCLASSEX	wc;
    INITCOMMONCONTROLSEX iccex;


    // Initialize the common controls.
    ZeroMemory(&iccex, sizeof(INITCOMMONCONTROLSEX));
    iccex.dwSize = sizeof(INITCOMMONCONTROLSEX);
    iccex.dwICC = ICC_LISTVIEW_CLASSES;
    InitCommonControlsEx(&iccex);


    // Load the application name and description strings.	
    LoadString(hInstance, IDS_MULTIDESK, AppMember.szAppName, MAX_APPNAME);
	LoadString(hInstance, IDS_MULTIDESK, AppMember.szAppTitle, MAX_TITLELEN);
	AppMember.hApplicationIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_MULTIDESK_ICON));
	AppMember.hApplicationSmallIcon = (HICON)LoadImage(hInstance, 
												MAKEINTRESOURCE(IDI_MULTIDESK_ICON),
												IMAGE_ICON,
												16,
												16,
												LR_DEFAULTCOLOR);
	AppMember.hTaskbarIcon = (HICON) LoadImage(hInstance, 
												MAKEINTRESOURCE(IDI_TASKBAR_ICON),
												IMAGE_ICON,
												16,
												16,
												LR_DEFAULTCOLOR);

    
	// Fill in window class structure	
    wc.cbSize        = sizeof(WNDCLASSEX);
	wc.style         = CS_DBLCLKS | CS_HREDRAW | CS_VREDRAW;		// Class style(s).
    wc.hIconSm       = AppMember.hApplicationSmallIcon;
    wc.lpfnWndProc   = (WNDPROC)MainMessageProc;					// Window Procedure
    wc.cbClsExtra    = 0;											// No per-class extra data.
    wc.cbWndExtra    = 0;											// No per-window extra data.
    wc.hInstance     = hInstance;									// Owner of this class
    wc.hIcon         = AppMember.hApplicationIcon;					// Icon name from .RC
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);					// Cursor
	wc.hbrBackground = (HBRUSH)GetStockObject(LTGRAY_BRUSH);				// CreateSolidBrush(RGB(192,192,192));
	wc.lpszMenuName  = NULL;
    wc.lpszClassName = AppMember.szAppName;							// Name to register as

    
	// Register the window class and return FALSE if unsuccesful.	
    if (!RegisterClassEx(&wc))
    {
		if (!RegisterClass((LPWNDCLASS)&wc.style)) return FALSE;
    }

    // Modify the things for the second class structure.
    wc.lpfnWndProc = (WNDPROC) TransparentMessageProc;
    wc.lpszClassName = TRANSPARENT_CLASSNAME;
    wc.hbrBackground = NULL;

    
	// Register the window class and return FALSE if unsuccesful.	
    if (!RegisterClassEx(&wc))
    {
		if (!RegisterClass((LPWNDCLASS)&wc.style)) return FALSE;
    }

	
	// App inits
	AppMember.hInstance = hInstance;
    AppMember.bTrayed = FALSE;
    AppMember.nWidth = 100;
    AppMember.nHeight = 200;

    return TRUE;
}

/*------------------------------------------------------------------------------*/
/*  the thread loop that is started in a separate thread for each desktop
/*------------------------------------------------------------------------------*/

void StartThreadDisplay(void) 
{
	MSG		msg;
	BOOL	Finished;
	
	//
    // Perform initializations that apply to a specific instance
	//	
    if (!CreateMainWindow())
    {
        Message("Failed to create main window.");
        return;
    }
    if (!CreateTransparentLabelWindow())
    {
        Message("Failed to create transparent window.");
    }


	//
	// Message Pump
	//
	Finished = FALSE;
    while ((!Finished) && GetMessage(&msg, NULL, 0, 0))
    {
		TranslateMessage(&msg);
    	DispatchMessage(&msg); 

		switch (msg.message)
		{
			case WM_PUMP_TERMINATE:
				Finished = TRUE;
				break;

			case WM_THREAD_SCHEME_UPDATE:
				AppMember.pDesktopControl->FindSchemeAndSet();
				break;

			case WM_KILL_APPS:
				AppMember.pDesktopControl->KillAppsOnDesktop((HDESK) msg.wParam, (HWND) msg.lParam);
				break;
		}
    }
}


/*------------------------------------------------------------------------------*/
/*------------------------------------------------------------------------------*/

int WINAPI WinMain(HINSTANCE hInstance,
                   HINSTANCE hPrevInstance, 
                   LPSTR     lpCmdLine, 
                   int       nCmdShow)
{
	HWND		hWnd;
	HANDLE      hMultideskMutex;
	CHAR		szName[MAX_PATH];
	SPLASH_DATA	SplashData;
	HANDLE		hThread;
	DWORD		dwThreadId;
	OSVERSIONINFO versioninfo;


    //
    // We require Windows NT 5 minimum now (for Saifer,
	// Explorer as shell, local instance mutex, etc).
	//
	ZeroMemory(&versioninfo, sizeof(OSVERSIONINFO));
	versioninfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	if (!GetVersionEx(&versioninfo) ||
	    versioninfo.dwPlatformId != VER_PLATFORM_WIN32_NT ||
	    versioninfo.dwMajorVersion < 5)
    {
        Message("This application require Windows 2000 or later.");
        return FALSE;
    }
	

    //
    // Are there other instance of app running?
	//	
	hMultideskMutex = CreateMutex(NULL, TRUE, "Local\\Multi Desk Mutex");
	if (!hMultideskMutex || GetLastError() == ERROR_ALREADY_EXISTS)
	{
	    // Another instance found?  switch to it, if possible.
	    LoadString(hInstance, IDS_MULTIDESK, szName, MAX_APPNAME);
		hWnd = FindWindow(szName, szName);
		if (hWnd)
			SetForegroundWindow(hWnd);

    	return FALSE;
	}

	//
	// Start Splash Screen
	//	
	SplashData.hInstance = hInstance;
	if (hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) DoSplashWindow, (LPVOID) &SplashData, CREATE_SUSPENDED, &dwThreadId))
	{
		ResumeThread(hThread);
		WaitForSingleObject(hThread, INFINITE);
		CloseHandle(hThread);	
	}

    //
	// Initialize UI shared things
	//	
	if (!InitApplication(hInstance))
    {
		return FALSE;
    }


    //
	// Initilize desktop switching code
    //	
	AppMember.pDesktopControl = (CDesktop*) new CDesktop;
	AppMember.pDesktopControl->InitializeDesktops(CreateDisplayFn, hInstance);


	//
	// Start the display for context zero
	//	
	CreateDisplayFn();

	//
	// Tidy up
	//
	Sleep(500);
	delete AppMember.pDesktopControl;			

	//
    // Returns the value from PostQuitMessage
	//
	return 1;
}

//////////////////////////////////////////////////////////////////////////////////
// 
// Helper functions follow
//


//
// Display a messagebox with a meaningful title.
//
void Message(LPCTSTR szMsg) 
{
	if (AppMember.hInstance != NULL)
		MessageBox((HWND)AppMember.hInstance, szMsg, AppMember.szAppTitle,
		        MB_OK | MB_APPLMODAL);
	else 
		MessageBox(NULL, szMsg, TEXT("DeskTops..."), MB_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\winsafer\test\desktops\menu.cpp ===
////////////////////////////////////////////////////////////////////////////////
//
// File:	Menu.cpp
// Created:	Jan 1996
// By:		Martin Holladay (a-martih) and Ryan Marshall (a-ryanm)
// 
// Project:	Resource Kit Desktop Switcher
//
// Main Functions:
//				PopupDesktopMenu() - Desktop/Button popup menu
//				PopupMainMenu(HWND hBtn, UINT x, UINT y)
//
// Misc. Functions (helpers)
//				GetPopupLocation() - returns POINT to popup a btn menu at
//
////////////////////////////////////////////////////////////////////////////////


#include <windows.h>        
#include <assert.h> 
#include <string.h>
#include <shellapi.h>
#include "DeskSpc.h"
#include "Desktop.h"
#include "Resource.h"
#include "User.h"    

extern APPVARS AppMember;


/*------------------------------------------------------------------------------*/
/*------------------------------------------------------------------------------*/


HMENU CreateListviewPopupMenu(VOID)
{
	HMENU		hFileMenu;
	CHAR		szTitle[MAX_TITLELEN+1];
	
	//
	// Create the File Menus
	//

	hFileMenu = CreatePopupMenu();
	if (!hFileMenu) {
		return NULL;
	}
	
	LoadString(AppMember.hInstance, IDS_ADD_DESKTOP, szTitle, MAX_TITLELEN);
	if (!AppendMenu(hFileMenu, MF_STRING, (UINT) IDM_NEW_DESKTOP, szTitle)) {
		DestroyMenu(hFileMenu);
		return NULL;
	}

	AppendMenu(hFileMenu, MF_SEPARATOR, 0, NULL);

	LoadString(AppMember.hInstance, IDS_DELETE_DESKTOP, szTitle, MAX_TITLELEN);
	if (!AppendMenu(hFileMenu, MF_STRING, (UINT) IDM_DELETE_DESKTOP, szTitle)) {
		DestroyMenu(hFileMenu);
		return NULL;
	}

	AppendMenu(hFileMenu, MF_SEPARATOR, 0, NULL);

	LoadString(AppMember.hInstance, IDS_PROPERTIES, szTitle, MAX_TITLELEN);
	if (!AppendMenu(hFileMenu, MF_STRING, (UINT) IDM_DESKTOP_PROPERTIES, szTitle)) {
		DestroyMenu(hFileMenu);
		return NULL;
	}
	

	return hFileMenu;
}

/*------------------------------------------------------------------------------*/
/*------------------------------------------------------------------------------*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\winsafer\test\desktops\deskspc.h ===
////////////////////////////////////////////////////////////////////////////////
//
// File:	Deskspc.h
//
// Created:	Jan 1996
// By		Ryan D. Marshall (ryanm)
//			Martin Holladay (a-martih)
// 
// Project:	Resource Kit Desktop Switcher
//
//
////////////////////////////////////////////////////////////////////////////////

#ifndef __MULTIDESK_DESKSPC_H__
#define __MULTIDESK_DESKSPC_H__

//
// This is the main desktop context inclusion
//

#ifdef STRICT
#define PROC_PTR WNDPROC
#else 
#define PROC_PTR FARPROC
#endif


//
// Maximum string resource lengths.
//
#define MAX_TITLELEN		127
#define MAX_MESSAGE			511
#define MAX_APPNAME			63


//
// Messages
//
#define		WM_REBUILD					(WM_USER + 200)
#define		WM_RESIZE					(WM_USER + 201)
#define     WM_UPDATE_STATE				(WM_USER + 202)
#define		WM_TASKBAR					(WM_USER + 203)


//
// Transparent text window constants.
//
#define TRANSPARENT_CLASSNAME   TEXT("MultiDeskTransparentLabel")
#define TRANSPARENT_BACKCOLOR   RGB(255,0,255)      // purple
#define TRANSPARENT_TEXTCOLOR   RGB(255,255,0)      // yellow
#define TRANSPARENT_ALPHA       150
#define TRANSPARENT_POSITIONS   0,0,600,80


//
// Associated structures
//
typedef struct _RENAMEINFO {
	UINT				nBtnIndex;
} RENAMEINFO, * PRENAMEINFO;



//
// Struct to hold application global varialbles
//

class CDesktop;        // prototype.

typedef struct _APPVARS {
	UINT				nX;
	UINT				nY;
	UINT				nWidth;
	UINT				nHeight;
    BOOL                bTrayed;
	CDesktop*			pDesktopControl;
	HINSTANCE			hInstance;
	CHAR				szAppName[MAX_APPNAME+1];
	CHAR				szAppTitle[MAX_TITLELEN+1];
	HICON				hApplicationIcon;
	HICON				hApplicationSmallIcon;
	HICON				hTaskbarIcon;
} APPVARS, * PAPPVARS;

// 
// Function Prototypes
// 
BOOL InitApplication(HINSTANCE);
void Message(LPCTSTR szMsg);
void StartThreadDisplay(void);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\winsafer\test\desktops\desktop.cpp ===
////////////////////////////////////////////////////////////////////////////////
//
// File:    Desktop.cpp
// Created:    Jan 1996
// By:        Ryan Marshall (a-ryanm) and Martin Holladay (a-martih)
//
// Project:    Resource Kit Desktop Switcher (MultiDesk)
//
//
// Revision History:
//
//            March 1997    - Add external icon capability
//
////////////////////////////////////////////////////////////////////////////////


#include <windows.h>
#include <stdio.h>
#include <assert.h>
#include <shellapi.h>
#include <lmaccess.h>
#include <lmapibuf.h>
#include <stdlib.h>
#include <sddl.h>
#include "Deskspc.h"
#include "Desktop.h"
#include "Registry.h"
#include "resource.h"
#include <saifer.h>


extern APPVARS AppMember;


BOOL __SetDesktopScheme(PDESKTOP_SCHEME pDS);
BOOL __GetDesktopScheme(PDESKTOP_SCHEME pDS);
BOOL __UpdateDesktopRegistry(PDESKTOP_SCHEME pDS);
BOOL __CopyDesktopScheme(PDESKTOP_SCHEME pDS1, PDESKTOP_SCHEME pDS2);
HICON __LoadBuiltinIcon(UINT nIconNumber, HINSTANCE hDeskInstance);
BOOL __CreateDefaultName(UINT DeskNum, LPTSTR DesktopName);


/*------------------------------------------------------------------------------*/
/*                                                                              */
/*    Purpose:  Constructor for CDestop class.                                  */
/*                                                                              */
/*------------------------------------------------------------------------------*/

CDesktop::CDesktop()
{
    BeginRundown = FALSE;

    //
    //  Set the default desktop
    //
    DefaultDesktop = GetThreadDesktop(GetCurrentThreadId());

    //
    // Intialize our default icons
    //
    ZeroMemory((PVOID) DefaultIconArray, (sizeof(HICON) * NUM_BUILTIN_ICONS));
}


/*------------------------------------------------------------------------------*/
/*                                                                              */
/*    Purpose:  Destructor for CDestop class.                                   */
/*                                                                              */
/*------------------------------------------------------------------------------*/

CDesktop::~CDesktop()
{
    UINT i;


    // Need to cleanup DesktopList; closing the hDesktop in each node
    // and then delete node memory using GlobalFree().  In addition deletion
    // must start at the end of the list sawing off last node one at a time.
    //
    GlobalFree(m_DesktopList);

    //
    // Close up our default icons
    //
    for (i = 0; i < NUM_BUILTIN_ICONS; i++)
    {
        if (DefaultIconArray[i])
            DestroyIcon(DefaultIconArray[i]);
    }
}

/*------------------------------------------------------------------------------*/
/*------------------------------- PUBLIC FUNCTIONS -----------------------------*/
/*------------------------------------------------------------------------------*/

UINT
CDesktop::InitializeDesktops
(
    DispatchFnType    CreateDisplayFn,
    HINSTANCE        hInstance
)
{
    UINT ii;
    UINT RegNumOfDesktops;
    BOOL m_bFirstTime = TRUE;

    //
    // Set the hInstance and get the default icons
    //
    hDeskInstance = hInstance;

    for (ii = 0; ii < NUM_BUILTIN_ICONS; ii++)
        DefaultIconArray[ii] = __LoadBuiltinIcon(ii+1, hDeskInstance);


    //
    //  Get Information from the registry.
    //
    if (Profile_GetNewContext(&RegNumOfDesktops))
    {
        m_bFirstTime = FALSE;
    }

    if ((RegNumOfDesktops > 32) || (RegNumOfDesktops < 1))
    {
        m_bFirstTime = TRUE;
    }


    ////  Allocate the first node ////

    m_DesktopList = (PDESKTOP_NODE) GlobalAlloc(GMEM_FIXED, sizeof(DESKTOP_NODE));
    assert(m_DesktopList != NULL);

    //// Fill in default values for first node ////

    m_DesktopList->nextDN = NULL;
    m_DesktopList->DS.Initialized = FALSE;
    m_DesktopList->ThreadId = GetCurrentThreadId();
    m_DesktopList->bThread = TRUE;
    m_DesktopList->hWnd = NULL;
    m_DesktopList->hDesktop   = GetThreadDesktop(GetCurrentThreadId());
    m_DesktopList->nIconID    = 0;
    m_DesktopList->RealDesktopName[0] = TEXT('\0');
    __GetDesktopScheme(&(m_DesktopList->DS));

    //
    // Set some environ vars to init states
    //
    NumOfDesktops  = 1;
    CurrentDesktop = 0;


    if (m_bFirstTime)
    {                // No old registry info, create default desktops
        //
        // Set desktop 0's name
        //
        __CreateDefaultName(1, m_DesktopList->DesktopName);

        if (DEFAULT_NUM_DESKTOPS > 1)
        {
            for (ii = 1; ii < DEFAULT_NUM_DESKTOPS; ii++)
            {
                AddDesktop(CreateDisplayFn, NULL);
            }
        }
    }
    else
    {                // Registry info present
        //
        // Set desktop 0's name
        //
        if ( !Profile_LoadDesktopContext(0,
                                    m_DesktopList->DesktopName,
                                    m_DesktopList->SaiferName,
                                    &m_DesktopList->nIconID)    )
        {
            __CreateDefaultName(1, m_DesktopList->DesktopName);
            m_DesktopList->nIconID = 0;
        }

        for (ii = 1; ii < RegNumOfDesktops; ii++)
        {
            TCHAR DesktopName[MAX_NAME_LENGTH];
            TCHAR SaiferName[MAX_NAME_LENGTH];
            UINT nIconID;

            AddDesktop(CreateDisplayFn, NULL);

            //// Place registry info into the node for this desktop ////

            if (Profile_LoadDesktopContext(ii,
                                      DesktopName,
                                      SaiferName,
                                      &nIconID)        )
            {
                // Successfully got all info from registry
                SetDesktopName(ii, DesktopName);
                SetDesktopIconID(ii, nIconID);
                SetSaiferName(ii, SaiferName);
            }
            else
            {
                // Could not get all info from registry
                __CreateDefaultName(ii+1, DesktopName);
                SetDesktopName(ii, DesktopName);
                SetDesktopIconID(ii, ii);
                SetSaiferName(ii, TEXT(""));
            }
            if (!GetRegColorStruct(ii))
                DuplicateDefaultScheme(ii);
        }  // End for loop

    }
    return NumOfDesktops;
}


/*------------------------------------------------------------------------------*/
/*                                                                              */
/*    Purpose:  Access the default desktop handle.                              */
/*                                                                              */
/*    Returns:  The default desktop handle.                                     */
/*                                                                              */
/*------------------------------------------------------------------------------*/

HDESK CDesktop::GetDefaultDesktop(VOID) const
{
    return DefaultDesktop;
}

/*------------------------------------------------------------------------------*/
/*                                                                              */
/*    Purpose:  Access the number of desktops.                                  */
/*                                                                              */
/*    Returns:  The number of desktops.                                         */
/*                                                                              */
/*------------------------------------------------------------------------------*/

UINT CDesktop::GetNumDesktops(VOID) const
{
    return NumOfDesktops;
}

/*------------------------------------------------------------------------------*/
/*                                                                              */
/*    Purpose:  Determine the currently active desktop.                         */
/*                                                                              */
/*    Returns:  The active desktop.                                             */
/*                                                                              */
/*------------------------------------------------------------------------------*/

UINT CDesktop::GetActiveDesktop(VOID) const
{
    return CurrentDesktop;
}


/*------------------------------------------------------------------------------*/
/*                                                                                */
/*    Purpose:  Creates a new desktop.                                            */
/*                                                                                */
/*    Returns:  The index number of the newly created desktop.  Zero if error.    */
/*                                                                                */
/*------------------------------------------------------------------------------*/

UINT CDesktop::AddDesktop
(
    DispatchFnType            CreateDisplayFn,
    LPSECURITY_ATTRIBUTES    lpSA,
    UINT                    uTemplate
)
{
    PDESKTOP_NODE        pCurrentNode;
    TCHAR                szMessage[MAX_PATH];
    PTHREAD_DATA        pData;
    HDESK                hDesktop;
    LUID                UniqueId;
    UINT                i;
    TCHAR                UniqueDesktopName[MAX_NAME_LENGTH];


    ////  Create Desktop ////

    if (AllocateLocallyUniqueId(&UniqueId))
    {
        wsprintf(UniqueDesktopName, TEXT("%d"), UniqueId.LowPart);
        hDesktop = CreateDesktop(
                            UniqueDesktopName,
                            NULL,
                            NULL,
                            0,
                            MAXIMUM_ALLOWED,
                            lpSA);

        if (hDesktop == NULL)
        {
            if (GetLastError() == ERROR_NOT_ENOUGH_MEMORY)
            {
                wsprintf(szMessage, TEXT("Not enough memory to create destkop.\n\nError:  %d\n"), GetLastError());
                MessageBox(NULL, szMessage, TEXT("MultiDesk Desktop Not Created"), MB_TASKMODAL | MB_ICONEXCLAMATION | MB_OK);
            }
            return 0;
        }
    }
    else
    {
        return 0;
    }

    //// Walk the desktop node list to find end
    //// Then add new node to end of list

    i = 1;
    pCurrentNode = m_DesktopList;

    while (pCurrentNode)
    {
        if ( !pCurrentNode->nextDN )    // Found end of list; let's add new node
        {
            NumOfDesktops++;
            pCurrentNode->nextDN = (PDESKTOP_NODE) GlobalAlloc(GMEM_FIXED, sizeof(DESKTOP_NODE));
            pCurrentNode = pCurrentNode->nextDN;
            pCurrentNode->hDesktop = hDesktop;
            pCurrentNode->hWnd = NULL;
            pCurrentNode->nextDN = NULL;
            pCurrentNode->ThreadId = 0;
            pCurrentNode->DS.Initialized = FALSE;

            if ( 0 == uTemplate )
            {
                __CopyDesktopScheme(&(m_DesktopList->DS), &(pCurrentNode->DS));
            }
            else
            {
                DESKTOP_NODE * pNode;
                pNode = GetDesktopNode(uTemplate);
                if ( pNode->DS.Initialized )
                {
                    __CopyDesktopScheme(&(pNode->DS), &(pCurrentNode->DS));
                }
                else
                {
                    __CopyDesktopScheme(&(m_DesktopList->DS), &(pCurrentNode->DS));
                }
            }

            lstrcpy(pCurrentNode->RealDesktopName, UniqueDesktopName);
            __CreateDefaultName(NumOfDesktops, pCurrentNode->DesktopName);
            pCurrentNode->SaiferName[0] = TEXT('\0');
            pCurrentNode->lpSA     = lpSA;
            pCurrentNode->nIconID  = i;
            pCurrentNode->bThread  = TRUE;
            pCurrentNode->bShellStarted = FALSE;

            ////  Alllocate THREAD_DATA struct and fill in.

            pData = (PTHREAD_DATA)GlobalAlloc(GMEM_FIXED, sizeof(THREAD_DATA));
            pData->hDesktop           = hDesktop;
            pData->hDefaultDesktop = DefaultDesktop;
            pData->CreateDisplayFn = CreateDisplayFn;
            lstrcpy(pData->RealDesktopName, UniqueDesktopName);

            //// Start the thread to run this desktop ////

            HANDLE    hThread;

            hThread = CreateThread(NULL,
                                   0,
                                   (LPTHREAD_START_ROUTINE)ThreadInit,
                                   (LPVOID)pData,
                                   0,
                                   &(pCurrentNode->ThreadId));
            CloseHandle(hThread);
        }

        i++;
        pCurrentNode = pCurrentNode->nextDN;
    }

    return NumOfDesktops;
}

/*------------------------------------------------------------------------------*/
/*                                                                              */
/*    Purpose:  Returns pointer to desktop node given number of desktop.        */
/*                                                                              */
/*------------------------------------------------------------------------------*/

DESKTOP_NODE *CDesktop::GetDesktopNode( UINT uNode )
{
    DESKTOP_NODE *    pNode = NULL;
    DESKTOP_NODE *    pWalker = m_DesktopList;
    UINT            uNumDesktops = GetNumDesktops();
    UINT            ii;

    if ( uNode < uNumDesktops )
    {
        for ( ii = 0; ii < uNode; ii++ )
        {
            pWalker = pWalker->nextDN;
        }
        pNode = pWalker;
    }

    return pNode;
}

/*------------------------------------------------------------------------------*/
/*                                                                              */
/*    Purpose:  Save scheme settings of current desktop to desktop node         */
/*                                                                              */
/*------------------------------------------------------------------------------*/

BOOL
CDesktop::SaveCurrentDesktopScheme()
{
    DESKTOP_NODE *    pNodeWalker;
    UINT            ii;
    BOOL            rVal = FALSE;

    ii = 0;
    pNodeWalker = m_DesktopList;


    while (pNodeWalker)
    {
        if (ii == CurrentDesktop)
        {
            __GetDesktopScheme(&(pNodeWalker->DS));
            rVal = TRUE;
        }
        ii++;
        pNodeWalker = pNodeWalker->nextDN;
    }

    return rVal;
}


/*------------------------------------------------------------------------------*/
/*                                                                              */
/*    Purpose:  Removes an old desktop.                                         */
/*                                                                              */
/*    Returns:  The number of remaining desktops.  Zero if error.               */
/*              User GetLastError() to retrieve error information.              */
/*                                                                              */
/*------------------------------------------------------------------------------*/

UINT CDesktop::RemoveDesktop(UINT DesktopNumber)
{
    PDESKTOP_NODE        pCurrentNode;
    PDESKTOP_NODE        pPreviousNode;
    BOOL                Found;
    UINT                ii;
    UINT                rValue = 0;

    //
    //    Return an error if trying to delete desktop zero.
    //
    if ((DesktopNumber == 0) || (NumOfDesktops == 1))
    {
        SetLastError(ERROR_CANNOT_DELETE_DESKTOP_ZERO);
        return 0;
    }

    //
    //  Return an error if an invalid desktop number
    //
    if (DesktopNumber > (NumOfDesktops - 1))
    {
        SetLastError(ERROR_INVALID_DESKTOP_NUMBER);
        return 0;
    }

    //
    // If we are deleting the active desktop. Switch to desktop zero.
    //
    if (DesktopNumber == CurrentDesktop)
    {
        if (!ActivateDesktop(0))
        {
            SetLastError(ERROR_CANNOT_DELETE_ACTIVE_DESKTOP);
            return FALSE;
        }
    }

    //
    //  Find the data structure; walk the linked list of desktops
    //
    Found = FALSE;
    ii = 1;
    pPreviousNode = m_DesktopList;
    pCurrentNode  = m_DesktopList->nextDN;

    while (pCurrentNode && (!Found))
    {
        if (DesktopNumber == ii)
        {
            //
            // Full Context desktop
            //
            if (pCurrentNode->bThread)
            {
                PostThreadMessage(pCurrentNode->ThreadId, WM_KILL_APPS, (WPARAM) pCurrentNode->hDesktop, (LPARAM) pCurrentNode->hWnd);
                Sleep(100);
                rValue = SUCCESS_THREAD_TERMINATION;
            }
            else
            {
                //
                // BUGBUG: Kill all virtual apps
                //
                rValue = SUCCESS_VIRTUAL_MOVE;
            }

            NumOfDesktops--;
            pPreviousNode->nextDN = pCurrentNode->nextDN;

            GlobalFree(pCurrentNode); // Destroy Node of removed desktop!!!
            Found = TRUE;
        }
        else
        {                        // Advance along list of nodes
            ii++;
            pPreviousNode = pCurrentNode;
            pCurrentNode = pCurrentNode->nextDN;
        }
    } // End while LOOP

    return rValue;
}


/*------------------------------------------------------------------------------*/
/*                                                                              */
/*    Purpose:  Kill all programs on a desktop.                                 */
/*                                                                              */
/*------------------------------------------------------------------------------*/

static BOOL CALLBACK __EnumWindowsForClose(HWND hWnd, LPARAM lParam)
{
    TCHAR        szClass[MAX_NAME_LENGTH];
    HWND        hDesktopWnd;

    //
    // Make sure that it isn't the desktop window
    //
    hDesktopWnd = (HWND) lParam;
    if (hDesktopWnd == hWnd)
    {
        return TRUE;
    }
    GetClassName(hWnd, szClass, MAX_NAME_LENGTH);
    if (szClass[0] == TEXT('#'))
    {
        return TRUE;
    }

    //
    // Send a close message to the app
    //
    PostMessage(hWnd, WM_CLOSE, (WPARAM) WM_NO_CLOSE, 0);

    return TRUE;
}

static BOOL CALLBACK __EnumWindowsForQuit(HWND hWnd, LPARAM lParam)
{
    TCHAR        szClass[MAX_NAME_LENGTH];
    HWND        hDesktopWnd;

    //
    // Make sure that it isn't the desktop window
    //
    hDesktopWnd = (HWND) lParam;
    if (hDesktopWnd == hWnd) return TRUE;

    //
    // Extract the Class Name
    //
    GetClassName(hWnd, szClass, MAX_NAME_LENGTH);
    if (szClass[0] == TEXT('#')) return TRUE;

    //
    // Send a quit message to the app
    //
    PostMessage(hWnd, WM_QUIT, (WPARAM) WM_NO_CLOSE, 0);

    return TRUE;
}

BOOL CDesktop::KillAppsOnDesktop(HDESK hDesk, HWND hWnd)
{
    HWND        hDesktopWnd;

    hDesktopWnd = GetDesktopWindow();

    EnumDesktopWindows(hDesk, (WNDENUMPROC) __EnumWindowsForClose, (LPARAM) hDesktopWnd);
    Sleep(0);
    EnumDesktopWindows(hDesk, (WNDENUMPROC) __EnumWindowsForQuit, (LPARAM) hDesktopWnd);

    return TRUE;
}

/*------------------------------------------------------------------------------*/
/*                                                                              */
/*    Purpose:  Switches to an existing desktop.                                */
/*                                                                              */
/*    Returns:  The index number of the newly created desktop.  Zero if error.  */
/*                                                                              */
/*------------------------------------------------------------------------------*/

BOOL
CDesktop::ActivateDesktop(UINT DesktopNumber)
{
    PDESKTOP_NODE            pCurrentNode;
    BOOL                    Success;
    UINT                    i;
    PROCESS_INFORMATION        pi;
    STARTUPINFO                sui;
    TCHAR                    szShellPath[MAX_PATH + 1];

    //
    //  Return immediately if trying to switch to ourself.
    //
    if (CurrentDesktop == DesktopNumber)
    {
        return FALSE;
    }


    //// Save desktop scheme for current desktop ////

    SaveCurrentDesktopScheme();

    //
    // Active the new desktop
    //
    i = 0;
    pCurrentNode = m_DesktopList;
    while (pCurrentNode)
    {
        if (i == DesktopNumber)
        {
            Success = SwitchDesktop(pCurrentNode->hDesktop);
            if (Success)
            {
                CurrentDesktop = i;

                // Start Explorer if necessary - skipping 0 == default desktop

                if (!pCurrentNode->bShellStarted && CurrentDesktop != 0)
                {
                    HANDLE hToken = NULL;


                    lstrcpy(szShellPath, TEXT("EXPLORER.EXE"));
                    ZeroMemory((PVOID)&sui, sizeof(sui));

                    sui.lpDesktop        = pCurrentNode->RealDesktopName;
                    sui.cb                = sizeof(sui);
                    sui.lpReserved        = NULL;
                    sui.lpTitle            = NULL;
                    sui.dwFlags            = STARTF_USESHOWWINDOW;
                    sui.wShowWindow        = SW_SHOW;
                    sui.cbReserved2        = 0;
                    sui.cbReserved2        = NULL;

#if 1
                    if (pCurrentNode->SaiferName[0] != TEXT('\0'))
                    {
                        HAUTHZOBJECT hAuthzObj;
                        if (CreateCodeAuthzObject(
                                AUTHZSCOPE_HKCU, pCurrentNode->SaiferName,
                                AUTHZ_OPENEXISTING, &hAuthzObj) ||
                            CreateCodeAuthzObject(
                                AUTHZSCOPE_HKLM, pCurrentNode->SaiferName,
                                AUTHZ_OPENEXISTING, &hAuthzObj))
                        {
                            if (ComputeAccessTokenFromCodeAuthzObject(
                                        hAuthzObj,
                                        NULL,           // source token
                                        &hToken,        // target token
                                        0))             // no flags
                            {
                                // We successfully got the Restricted Token
                                // to use, so it had better be non-null.
                                assert(hToken != NULL);
                            }
                            CloseCodeAuthzObject(hAuthzObj);
                        }
                        if (hToken == NULL)
                        {
                            CurrentDesktop = 0;
                            SwitchDesktop(m_DesktopList->hDesktop);
                            PostThreadMessage(m_DesktopList->ThreadId, WM_THREAD_SCHEME_UPDATE, 0, 0);
                            Message(TEXT("The SAIFER Object Name specified for this "
                                "desktop could not be successfully found or instantianted."));
                            return FALSE;
                        }
                    }

                    if (hToken != NULL) {
                        Success = CreateProcessAsUser(
                                        hToken,
                                        NULL,
                                        szShellPath,
                                        NULL,
                                        NULL,
                                        FALSE,
                                        CREATE_DEFAULT_ERROR_MODE | CREATE_SEPARATE_WOW_VDM,
                                        NULL,
                                        NULL,
                                        &sui,
                                        &pi);
                        CloseHandle(hToken);
                    }
                    else
#endif
                        Success = CreateProcess(
                                        NULL,
                                        szShellPath,
                                        NULL,
                                        NULL,
                                        FALSE,
                                        CREATE_DEFAULT_ERROR_MODE | CREATE_SEPARATE_WOW_VDM,
                                        NULL,
                                        NULL,
                                        &sui,
                                        &pi);

                    pCurrentNode->bShellStarted = Success;

                    if (Success) {
                        CloseHandle(pi.hThread);
                        CloseHandle(pi.hProcess);
                    } else {
                        CurrentDesktop = 0;
                        SwitchDesktop(m_DesktopList->hDesktop);
                        PostThreadMessage(m_DesktopList->ThreadId, WM_THREAD_SCHEME_UPDATE, 0, 0);
                        Message(TEXT("The Windows shell could not be successfully launched."));
                        return FALSE;
                    }

                }

                PostThreadMessage(pCurrentNode->ThreadId, WM_THREAD_SCHEME_UPDATE, 0, 0);
            }

            return Success;
        }

        i++;
        pCurrentNode = pCurrentNode->nextDN;
    } // End while LOOP

    return FALSE;
}


/*------------------------------------------------------------------------------*/
/*                                                                              */
/*    Purpose:  Sets a desktop name.  (Rename)                                  */
/*                                                                              */
/*------------------------------------------------------------------------------*/

BOOL CDesktop::SetDesktopName(UINT DesktopNumber, LPCTSTR DesktopName)
{
    UINT                i;
    BOOL                Found;
    PDESKTOP_NODE        pCurrentNode;

    //
    // Verify valid string.
    //
    if ((!DesktopName) || (lstrlen(DesktopName) > MAX_NAME_LENGTH))
        return FALSE;

    //
    // Change the name in our data structure.
    //
    i = 0;
    Found = FALSE;
    pCurrentNode = m_DesktopList;
    while (pCurrentNode && !Found)
    {
        if (i == DesktopNumber)
        {
            lstrcpy(pCurrentNode->DesktopName, DesktopName);
            Found = TRUE;
        }

        i++;
        pCurrentNode = pCurrentNode->nextDN;
    }

    return Found;
}


/*------------------------------------------------------------------------------*/
/*                                                                              */
/*    Purpose:  Gets a desktop name.  (Rename)                                  */
/*                                                                              */
/*------------------------------------------------------------------------------*/

BOOL CDesktop::GetDesktopName(UINT DesktopNumber, LPTSTR DesktopName, UINT size) const
{
    UINT                i;
    BOOL                Found;
    PDESKTOP_NODE        pCurrentNode;

    //
    // Get the name from our data structure.
    //
    i = 0;
    Found = FALSE;
    pCurrentNode = m_DesktopList;
    while (pCurrentNode && !Found)
    {
        if (i == DesktopNumber)
        {
            if ((UINT) lstrlen(pCurrentNode->DesktopName) > size) return FALSE;

            lstrcpy(DesktopName, pCurrentNode->DesktopName);
            Found = TRUE;
        }

        i++;
        pCurrentNode = pCurrentNode->nextDN;
    }

    return Found;
}


/*------------------------------------------------------------------------------*/
/*                                                                              */
/*    Purpose:  Sets a desktop SAIFER authorization object name.                */
/*                                                                              */
/*------------------------------------------------------------------------------*/

BOOL CDesktop::SetSaiferName(UINT DesktopNumber, LPCTSTR SaiferName)
{
    UINT i;
    BOOL Found;
    PDESKTOP_NODE pCurrentNode;

    //
    // Verify valid string.
    //
    if ((!SaiferName) || (lstrlen(SaiferName) > MAX_NAME_LENGTH))
        return FALSE;

    //
    // Change the name in our data structure.
    //
    i = 0;
    Found = FALSE;
    pCurrentNode = m_DesktopList;
    while (pCurrentNode && !Found)
    {
        if (i == DesktopNumber)
        {
            lstrcpy(pCurrentNode->SaiferName, SaiferName);
            Found = TRUE;
        }

        i++;
        pCurrentNode = pCurrentNode->nextDN;
    }

    return Found;
}


/*------------------------------------------------------------------------------*/
/*                                                                              */
/*    Purpose:  Gets a desktop SAIFER authorization object name.                */
/*                                                                              */
/*------------------------------------------------------------------------------*/

BOOL CDesktop::GetSaiferName(UINT DesktopNumber, LPTSTR SaiferName, UINT size) const
{
    UINT i;
    BOOL Found;
    PDESKTOP_NODE pCurrentNode;

    //
    // Get the name from our data structure.
    //
    i = 0;
    Found = FALSE;
    pCurrentNode = m_DesktopList;
    while (pCurrentNode && !Found)
    {
        if (i == DesktopNumber)
        {
            if ((UINT) lstrlen(pCurrentNode->SaiferName) > size) return FALSE;

            lstrcpy(SaiferName, pCurrentNode->SaiferName);
            Found = TRUE;
        }

        i++;
        pCurrentNode = pCurrentNode->nextDN;
    }

    return Found;
}

/*------------------------------------------------------------------------------*/
/*                                                                              */
/*    Purpose:  Gets the icon for a particular desktop                          */
/*                                                                              */
/*------------------------------------------------------------------------------*/

HICON CDesktop::GetDesktopIcon(UINT nDesktopNumber) const
{
    UINT i;
    PDESKTOP_NODE pCurrentNode;

    //
    // Get the name from our data structure.
    //
    i = 0;
    pCurrentNode = m_DesktopList;
    while (pCurrentNode)
    {
        if (i == nDesktopNumber)
        {
            assert(pCurrentNode->nIconID >= 0 && pCurrentNode->nIconID < NUM_BUILTIN_ICONS);
            return DefaultIconArray[pCurrentNode->nIconID];
        }

        i++;
        pCurrentNode = pCurrentNode->nextDN;
    }

    return FALSE;
}


/*------------------------------------------------------------------------------*/
/*                                                                              */
/*    Purpose:  Gets the icon ID for a particular desktop                       */
/*                                                                              */
/*------------------------------------------------------------------------------*/

UINT CDesktop::GetDesktopIconID(UINT nDesktopNumber) const
{
    UINT i;
    PDESKTOP_NODE pCurrentNode;

    //
    // Get the name from our data structure.
    //
    i = 0;
    pCurrentNode = m_DesktopList;
    while (pCurrentNode)
    {
        if (i == nDesktopNumber)
        {
            return pCurrentNode->nIconID;
        }

        i++;
        pCurrentNode = pCurrentNode->nextDN;
    }

    return 0;
}


/*------------------------------------------------------------------------------*/
/*                                                                              */
/*    Purpose:  Sets the Desktop Icon                                           */
/*                                                                              */
/*------------------------------------------------------------------------------*/

BOOL CDesktop::SetDesktopIconID(UINT DesktopNumber, UINT nIconID)
{
    UINT i;
    BOOL Found;
    PDESKTOP_NODE pCurrentNode;

    //
    // Change the name in our data structure.
    //
    i = 0;
    Found = FALSE;
    pCurrentNode = m_DesktopList;
    while (pCurrentNode && !Found)
    {
        if (i == DesktopNumber)
        {
            pCurrentNode->nIconID = nIconID;
            Found = TRUE;
        }

        i++;
        pCurrentNode = pCurrentNode->nextDN;
    }

    return Found;
}



/*------------------------------------------------------------------------------*/
/*                                                                              */
/*    Purpose:  Sets the threads main window.                                   */
/*                                                                              */
/*------------------------------------------------------------------------------*/

BOOL CDesktop::SetThreadWindow(DWORD ThreadId, HWND hWnd)
{
    PDESKTOP_NODE pCurrentNode;

    pCurrentNode = m_DesktopList;
    while (pCurrentNode)
    {
        if (pCurrentNode->ThreadId == ThreadId)
        {
            pCurrentNode->hWnd = hWnd;
        }
        pCurrentNode = pCurrentNode->nextDN;
    }

    return FALSE;
}


/*------------------------------------------------------------------------------*/
/*                                                                              */
/*    Purpose:  Gets the threads main window.                                   */
/*                                                                              */
/*------------------------------------------------------------------------------*/

HWND CDesktop::GetThreadWindow(DWORD ThreadId) const
{
    PDESKTOP_NODE pCurrentNode;

    pCurrentNode = m_DesktopList;
    while (pCurrentNode)
    {
        if (pCurrentNode->ThreadId == ThreadId)
        {
            return pCurrentNode->hWnd;
        }
        pCurrentNode = pCurrentNode->nextDN;
    }

    return 0;
}


/*------------------------------------------------------------------------------*/
/*                                                                              */
/*    Purpose:  Gets the desktop id of a given thread.                          */
/*                                                                              */
/*------------------------------------------------------------------------------*/

UINT CDesktop::GetThreadDesktopID(DWORD ThreadId) const
{
    PDESKTOP_NODE pCurrentNode;
    UINT i;

    i = 0;
    pCurrentNode = m_DesktopList;
    while (pCurrentNode)
    {
        if (pCurrentNode->ThreadId == ThreadId)
        {
            return i;
        }

        i++;
        pCurrentNode = pCurrentNode->nextDN;
    }

    return 0;
}

/*------------------------------------------------------------------------------*/
/*                                                                              */
/*    Purpose:  Gets the threads main window.                                   */
/*                                                                              */
/*------------------------------------------------------------------------------*/

HWND CDesktop::GetWindowDesktop(UINT DesktopNumber) const
{
    PDESKTOP_NODE pCurrentNode;
    UINT i;

    i = 0;
    pCurrentNode = m_DesktopList;
    while (pCurrentNode)
    {
        if (DesktopNumber == i)
        {
            return pCurrentNode->hWnd;
        }

        i++;
        pCurrentNode = pCurrentNode->nextDN;
    }

    return 0;
}


/*------------------------------------------------------------------------------*/
/*                                                                              */
/*    Purpose:  Gets the real desktop name.                                     */
/*                                                                              */
/*------------------------------------------------------------------------------*/

BOOL CDesktop::GetRealDesktopName(HWND hWnd, LPTSTR szRealDesktopName) const
{
    PDESKTOP_NODE pCurrentNode;

    pCurrentNode = m_DesktopList;
    while (pCurrentNode)
    {
        if (pCurrentNode->hWnd == hWnd)
        {
            if (pCurrentNode->RealDesktopName[0])
                lstrcpy(szRealDesktopName, pCurrentNode->RealDesktopName);
            else
                szRealDesktopName[0] = TEXT('\0');
        }

        pCurrentNode = pCurrentNode->nextDN;
    }

    return 0;
}


/*------------------------------------------------------------------------------*/
/*                                                                              */
/*    Purpose:  Evaluate the setting of a desktop scheme.                       */
/*                                                                              */
/*------------------------------------------------------------------------------*/

BOOL CDesktop::FindSchemeAndSet(VOID)
{
    PDESKTOP_NODE pCurrentNode;
    UINT i;

    if (!BeginRundown)
    {
        i = 0;
        pCurrentNode = m_DesktopList;
        while (pCurrentNode)
        {
            if (i == CurrentDesktop)
            {
                if (pCurrentNode->ThreadId == GetCurrentThreadId())
                {
                    //
                    // Set the desktop scheme
                    //
                    return __SetDesktopScheme(&(pCurrentNode->DS));
                }
            }

            i++;
            pCurrentNode = pCurrentNode->nextDN;
        }
    }
    else
    {
        //
        // Set the desktop scheme to that of desktop 1
        //
        __SetDesktopScheme(&(m_DesktopList->DS));
    }

    return FALSE;
}


/*------------------------------------------------------------------------------*/
/*                                                                              */
/*    Purpose:  Copies the scheme from desktop 0 to desktop n.                  */
/*                                                                              */
/*------------------------------------------------------------------------------*/

BOOL CDesktop::DuplicateDefaultScheme(UINT DesktopNumber)
{
    PDESKTOP_NODE pCurrentNode;
    BOOL Success = FALSE;
    UINT i;

    i = 0;
    pCurrentNode = m_DesktopList;
    while (pCurrentNode)
    {
        if (i == DesktopNumber)
            Success = __CopyDesktopScheme(&(m_DesktopList->DS), &(pCurrentNode->DS));

        i++;
        pCurrentNode = pCurrentNode->nextDN;
    }

    return Success;
}


/*------------------------------------------------------------------------------*/
/*                                                                              */
/*    Purpose:  Gets the color struct from registry for desktop n.              */
/*                                                                              */
/*------------------------------------------------------------------------------*/

BOOL CDesktop::GetRegColorStruct(UINT DesktopNumber)
{
    PDESKTOP_NODE        pCurrentNode;
    BOOL                Success = FALSE;
    UINT                i;

    i = 0;
    pCurrentNode = m_DesktopList;
    while (pCurrentNode)
    {
        if (i == DesktopNumber)
            Success = GetDesktopSchemeRegistry(DesktopNumber, &(pCurrentNode->DS));

        i++;
        pCurrentNode = pCurrentNode->nextDN;
    }

    return Success;
}


/*------------------------------------------------------------------------------*/
/*                                                                              */
/*    Purpose:  Save off the schemes to the registry.                           */
/*                                                                              */
/*------------------------------------------------------------------------------*/

BOOL CDesktop::RegSaveSettings(VOID)
{
    PDESKTOP_NODE        pCurrentNode;
    UINT                ii;

    //
    // Set Global settings
    //
    Profile_SetNewContext(NumOfDesktops);

    //
    // Dump settings desktop by desktop
    //
    ii = 0;
    pCurrentNode = m_DesktopList;

    while (pCurrentNode)
    {
        Profile_SaveDesktopContext(ii,
                              pCurrentNode->DesktopName,
                              pCurrentNode->SaiferName,
                              pCurrentNode->nIconID);
        SetDesktopSchemeRegistry(ii, &(pCurrentNode->DS));

        ii++;
        pCurrentNode = pCurrentNode->nextDN;
    }

    return TRUE;
}


/*------------------------------------------------------------------------------*/
/*                                                                              */
/*    Purpose:  Destroy the windows one by one.                                 */
/*                                                                              */
/*------------------------------------------------------------------------------*/

BOOL CDesktop::RunDown(VOID)
{
    PDESKTOP_NODE        pCurrentNode;
    BOOL                Success;

    BeginRundown = TRUE;

    //
    // Set desktop schemes to that of desktop 1
    //
    pCurrentNode = m_DesktopList->nextDN;
    while (pCurrentNode)
    {
        //
        // Set the desktop scheme
        //
        PostThreadMessage(pCurrentNode->ThreadId, WM_THREAD_SCHEME_UPDATE, 0, 0);
        pCurrentNode = pCurrentNode->nextDN;
    }

    //
    // Remove the desktops
    //
    while (NumOfDesktops > 1)
    {
        Success = RemoveDesktop(NumOfDesktops - 1);
    }

    //
    // Flush to registry
    //
    __UpdateDesktopRegistry(&(m_DesktopList->DS));

    return TRUE;
}


/*------------------------------------------------------------------------------*/
/*                                                                              */
/*    Purpose:  Create a default desktop name.                                  */
/*                                                                              */
/*------------------------------------------------------------------------------*/

static BOOL __CreateDefaultName(UINT DeskNum, LPTSTR DesktopName)
{
    wsprintf(DesktopName, TEXT("Desktop %d"), DeskNum);

    return TRUE;
}


/*------------------------------------------------------------------------------*/
/*                                                                              */
/*    Purpose:  Gets the default icons.                                         */
/*                                                                              */
/*------------------------------------------------------------------------------*/

static HICON __LoadBuiltinIcon(UINT nIconNumber, HINSTANCE hDeskInstance)
{
    UINT resid;

    assert(NUM_BUILTIN_ICONS == 27);
    switch(nIconNumber)
    {
        case 1: resid = IDI_WIN_ICON01; break;
        case 2: resid = IDI_WIN_ICON02; break;
        case 3: resid = IDI_WIN_ICON03; break;
        case 4: resid = IDI_WIN_ICON04; break;
        case 5: resid = IDI_WIN_ICON05; break;
        case 6: resid = IDI_WIN_ICON06; break;
        case 7: resid = IDI_WIN_ICON07; break;
        case 8: resid = IDI_WIN_ICON08; break;
        case 9: resid = IDI_WIN_ICON09; break;
        case 10: resid = IDI_WIN_ICON10; break;
        case 11: resid = IDI_WIN_ICON11; break;
        case 12: resid = IDI_WIN_ICON12; break;
        case 13: resid = IDI_WIN_ICON13; break;
        case 14: resid = IDI_WIN_ICON14; break;
        case 15: resid = IDI_WIN_ICON15; break;
        case 16: resid = IDI_WIN_ICON16; break;
        case 17: resid = IDI_WIN_ICON17; break;
        case 18: resid = IDI_WIN_ICON18; break;
        case 19: resid = IDI_WIN_ICON19; break;
        case 20: resid = IDI_WIN_ICON20; break;
        case 21: resid = IDI_WIN_ICON21; break;
        case 22: resid = IDI_WIN_ICON22; break;
        case 23: resid = IDI_WIN_ICON23; break;
        case 24: resid = IDI_WIN_ICON24; break;
        case 25: resid = IDI_WIN_ICON25; break;
        case 26: resid = IDI_WIN_ICON26; break;
        case 27: resid = IDI_WIN_ICON27; break;
        default: return NULL;
    }
    
    return LoadIcon(hDeskInstance, MAKEINTRESOURCE(resid));
}

HICON CDesktop::GetBuiltinIcon(UINT nIconNumber) const
{
    if (nIconNumber < NUM_BUILTIN_ICONS)
        return DefaultIconArray[nIconNumber];
    else
        return NULL;
}


/*------------------------------------------------------------------------------*/
/*                                                                              */
/*    Purpose:  Create a new desktop.                                           */
/*                                                                              */
/*------------------------------------------------------------------------------*/

VOID ThreadInit(LPVOID hData)
{
    USEROBJECTFLAGS        uof;
    PTHREAD_DATA        ptd;
    BOOL                Success;
    DWORD                Err;

    //
    // Passed-in data
    //
    ptd = (THREAD_DATA*)hData;

    //
    // Inheiritance and flags
    //
    uof.fInherit  = TRUE;
    uof.fReserved = FALSE;
    uof.dwFlags   = DF_ALLOWOTHERACCOUNTHOOK;

    Success = SetUserObjectInformation (ptd->hDesktop,
                                        UOI_FLAGS,
                                        (LPVOID)&uof,
                                        sizeof(uof));

    //
    // Assign the thread to its desktop
    //
    Success = SetThreadDesktop(ptd->hDesktop);
    Err = GetLastError();

    //
    // Begin the Display dialog and start the shell.
    //
    ptd->CreateDisplayFn();

    //
    // End the thread
    //
    SetThreadDesktop(ptd->hDefaultDesktop);
    Success = CloseDesktop(ptd->hDesktop);
    GlobalFree(ptd);

    return;
}

/*------------------------------------------------------------------------------*/
/*----------------------------- PROTECTED FUNCTIONS ----------------------------*/
/*------------------------------------------------------------------------------*/

BOOL CDesktop::GetDesktopSchemeRegistry(UINT DesktopNumber, PDESKTOP_SCHEME pDS)
{
    BOOL bSuccess = FALSE;

    assert(pDS);

    bSuccess = Profile_LoadScheme(DesktopNumber, pDS);

    pDS->Initialized = bSuccess;
    return bSuccess;
}

BOOL CDesktop::SetDesktopSchemeRegistry(UINT DesktopNumber, PDESKTOP_SCHEME pDS)
{
    BOOL    bSuccess = FALSE;

    assert(pDS);
    if (!pDS->Initialized) return FALSE;

    bSuccess = Profile_SaveScheme(DesktopNumber, pDS);

    return bSuccess;
}


static BOOL __SetDesktopScheme(PDESKTOP_SCHEME pDS)
{
    //
    // Check if structure has been filled in
    //
    assert(pDS);
    if (!pDS->Initialized) return FALSE;

    //
    // Structure has info - Lets update the desktop scheme
    //
    Reg_SetSysColors(pDS->dwColor);
    Reg_SetWallpaper(pDS->szWallpaper, pDS->szTile);
    Reg_SetPattern(pDS->szPattern);
    Reg_SetScreenSaver(pDS->szScreenSaver, pDS->szSecure, pDS->szTimeOut, pDS->szActive);

    //
    // Now invalidate the Wallpaper and Pattern
    //
    SystemParametersInfo(SPI_SETDESKWALLPAPER, 0, pDS->szWallpaper, SPIF_SENDCHANGE);
    SystemParametersInfo(SPI_SETDESKPATTERN, 0, pDS->szPattern, SPIF_SENDCHANGE);


    return TRUE;
}

static BOOL __GetDesktopScheme(PDESKTOP_SCHEME pDS)
{
    //
    // Read the color settings from the desktop and fill in the structure
    //
    assert(pDS);

    if (Reg_GetSysColors(pDS->dwColor) &&
        Reg_GetWallpaper(pDS->szWallpaper, pDS->szTile) &&
        Reg_GetPattern(pDS->szPattern) &&
        Reg_GetScreenSaver(pDS->szScreenSaver, pDS->szSecure, pDS->szTimeOut, pDS->szActive))
    {
        //
        // Structure filled!
        //
        pDS->Initialized = TRUE;
        return TRUE;
    }

    return FALSE;
}

static BOOL __UpdateDesktopRegistry(PDESKTOP_SCHEME pDS)
{

    //
    // Update the registry
    //
    assert(pDS);
    Reg_UpdateColorRegistry(pDS->dwColor);

    return TRUE;
}


static BOOL __CopyDesktopScheme(PDESKTOP_SCHEME pDS1, PDESKTOP_SCHEME pDS2)
{

    UINT i;

    //
    // Copy the contents of pDS1 into pDS2
    //
    assert(pDS2 != NULL);
    assert(pDS1 != NULL);

    if (!pDS1->Initialized)
    {
        pDS2->Initialized = FALSE;
        return FALSE;
    }

    //
    // Copy the strings over
    //
    lstrcpy(pDS2->szWallpaper,   pDS1->szWallpaper);
    lstrcpy(pDS2->szTile,        pDS1->szTile);
    lstrcpy(pDS2->szPattern,        pDS1->szPattern);
    lstrcpy(pDS2->szScreenSaver, pDS1->szScreenSaver);
    lstrcpy(pDS2->szSecure,        pDS1->szSecure);
    lstrcpy(pDS2->szTimeOut,        pDS1->szTimeOut);
    lstrcpy(pDS2->szActive,        pDS1->szActive);

    //
    // Copy the colors over
    //
    for (i = 0; i < NUM_COLOR_ELEMENTS; i++)
    {
        pDS2->dwColor[i] = pDS1->dwColor[i];
    }

    pDS2->Initialized = TRUE;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\winsafer\test\desktops\menu.h ===
////////////////////////////////////////////////////////////////////////////////
//
// File:	Menu.h
// Created:	Jan 1996
// By:		Martin Holladay (a-martih) and Ryan Marshall (a-ryanm)
// 
// Project:	Resource Kit Desktop Switcher
//
//
//

#ifndef __MULTIDESK_MENU_H__
#define __MULTIDESK_MENU_H__

HMENU CreateListviewPopupMenu(VOID);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\winsafer\test\desktops\desktop.h ===
////////////////////////////////////////////////////////////////////////////////
//
// File:    Desktop.h
// Created:    Jan 1996
// By:        Ryan Marshall (a-ryanm) and Martin Holladay (a-martih)
// 
// Project:    Resource Kit Desktop Switcher (MultiDesk)
//
//
// Revision History:
//
//            March 1997    - Add external icon capability
//
////////////////////////////////////////////////////////////////////////////////

#ifndef __MULTIDESK_DESKTOP_H__
#define __MULTIDESK_DESKTOP_H__

//
//  Constants
//
#define MAX_NAME_LENGTH           255
#define DEFAULT_NUM_DESKTOPS      1
#define MAX_DESKTOPS              6
#define NUM_BUILTIN_ICONS         27

// 
// MUST match the number of elements in nColorElements[]
//      and the number of #define COLOR_ constants in Registry.Cpp
//
#define NUM_COLOR_ELEMENTS        23    

//
//  Error Codes
//
#define ERROR_CANNOT_DELETE_DESKTOP_ZERO      1
#define ERROR_INVALID_DESKTOP_NUMBER          2
#define ERROR_OPEN_PROCESSES                  3
#define ERROR_CANNOT_DELETE_ACTIVE_DESKTOP    4
#define SUCCESS_THREAD_TERMINATION            5
#define SUCCESS_VIRTUAL_MOVE                  6

//
//  Messages
//
#define WM_THREAD_TERMINATE         (WM_USER + 301)
#define WM_PUMP_TERMINATE           (WM_USER + 302)
#define WM_THREAD_SCHEME_UPDATE     (WM_USER + 303)
#define WM_KILL_APPS                (WM_USER + 304)
#define WM_NO_CLOSE                 (WM_USER + 305)
#define WM_UPDATEMINIMIZE           (WM_USER + 306)

//
//  Dispatch function pointer prototype
//
typedef VOID (* DispatchFnType) ( VOID ) ;


//
//  Data Structures
//
typedef struct _DESKTOP_SCHEME
{
    BOOL                    Initialized;
    DWORD                    dwColor[NUM_COLOR_ELEMENTS];
    TCHAR                    szWallpaper[MAX_NAME_LENGTH + 1];
    TCHAR                    szTile[MAX_NAME_LENGTH + 1];
    TCHAR                    szPattern[MAX_NAME_LENGTH + 1];
    TCHAR                    szScreenSaver[MAX_PATH + 1];
    TCHAR                    szSecure[MAX_NAME_LENGTH + 1];
    TCHAR                    szTimeOut[MAX_NAME_LENGTH + 1];
    TCHAR                    szActive[MAX_NAME_LENGTH + 1];
} DESKTOP_SCHEME, * PDESKTOP_SCHEME;

typedef struct _DESKTOP_NODE
{
    HWND                    hWnd;
    HDESK                    hDesktop;
    BOOL                    bThread;
    BOOL                    bShellStarted;
    DWORD                    ThreadId;
    UINT                    nIconID;
    LPSECURITY_ATTRIBUTES    lpSA;
    DESKTOP_SCHEME            DS;
    struct _DESKTOP_NODE*    nextDN;
    TCHAR                    DesktopName[MAX_NAME_LENGTH];
    TCHAR                   SaiferName[MAX_NAME_LENGTH];
    TCHAR                    RealDesktopName[MAX_NAME_LENGTH];
} DESKTOP_NODE, * PDESKTOP_NODE;

typedef struct _THREAD_DATA
{
    HDESK                    hDesktop;
    HDESK                    hDefaultDesktop;
    TCHAR                    RealDesktopName[MAX_NAME_LENGTH];
    DispatchFnType            CreateDisplayFn;
} THREAD_DATA, * PTHREAD_DATA;


//
//  Function Prototypes
//
VOID ThreadInit(LPVOID hData);


//
//  The Class
//
class CDesktop
{

public:

    // Construction, destruction, and initialization.

    CDesktop();
    ~CDesktop();
    UINT InitializeDesktops(DispatchFnType CreateDisplayFn, HINSTANCE hInstance);

public:

    UINT GetNumDesktops(VOID) const;
    UINT GetActiveDesktop(VOID) const;

    UINT AddDesktop(DispatchFnType CreateDisplayFn, 
                    LPSECURITY_ATTRIBUTES lpSA, UINT uTemplate = 0);
    UINT RemoveDesktop(UINT DesktopNumber);
    BOOL ActivateDesktop(UINT DesktopNumber);

    BOOL SetDesktopName(UINT DesktopNumber, LPCTSTR DesktopName);
    BOOL GetDesktopName(UINT DesktopNumber, LPTSTR DesktopName, UINT size) const;

    BOOL SetSaiferName(UINT DesktopNumber, LPCTSTR SaiferName);
    BOOL GetSaiferName(UINT DesktopNumber, LPTSTR SaiferName, UINT size) const;

    BOOL SetDesktopIconID(UINT DesktopNumber, UINT nIconID);
    HICON GetDesktopIcon(UINT DesktopNumber) const;
    UINT GetDesktopIconID(UINT DesktopNumber) const;
    HICON GetBuiltinIcon(UINT IconNumber) const;

public:
    // the functions are public, but have limited.

    DESKTOP_NODE *GetDesktopNode(UINT uNode);
    BOOL SaveCurrentDesktopScheme();    
    HDESK GetDefaultDesktop(VOID) const;
    BOOL SetThreadWindow(DWORD ThreadId, HWND hWnd);
    HWND GetThreadWindow(DWORD ThreadId) const;
    UINT GetThreadDesktopID(DWORD ThreadId) const;
    HWND GetWindowDesktop(UINT DesktopNumber) const;
    BOOL GetRealDesktopName(HWND hWnd, LPTSTR szRealDesktopName) const;
    BOOL FindSchemeAndSet(VOID);
    BOOL KillAppsOnDesktop(HDESK hDesk, HWND hWnd);
    BOOL RegSaveSettings(VOID);
    BOOL RunDown(VOID);


private:
    HINSTANCE        hDeskInstance;
    BOOL            BeginRundown;
    UINT            NumOfDesktops;
    UINT            CurrentDesktop;
    HICON            DefaultIconArray[NUM_BUILTIN_ICONS];
    HDESK            DefaultDesktop;
    PDESKTOP_NODE    m_DesktopList;                        // List of desktop nodes

private:
    BOOL            DuplicateDefaultScheme(UINT DesktopNumber);
    BOOL            GetRegColorStruct(UINT DesktopNumber);
    BOOL            GetDesktopSchemeRegistry(UINT DesktopNumber, PDESKTOP_SCHEME pDS);
    BOOL            SetDesktopSchemeRegistry(UINT DesktopNumber, PDESKTOP_SCHEME pDS);

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\winsafer\test\desktops\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by deskspc.rc
//
#define IDS_MULTIDESK                   1
#define IDS_DEFAULT_FONT                3
#define IDS_MENU_ERR                    4
#define IDS_PROPERTIES                  8
#define IDS_ADD_DESKTOP                 9
#define IDS_DELETE_DESKTOP              10
#define IDS_EMPTY                       18
#define IDS_RENDLG_ERR                  21
#define IDS_DELETE_VERIFY               26
#define IDS_MAX_DESKTOPS                29
#define IDS_MAX_DESKTOPS_CAPTION        30
#define IDS_RUN_BAD_CAPTION             31
#define IDS_RUN_BAD_MESSAGE             32
#define IDS_CLOSE_CAPTION               36
#define IDS_CLOSE_VERIFY                37
#define IDS_MD_PROPS                    40
#define IDS_PROPDLG_ERR                 41
#define IDS_TASKBAR_TIP                 50
#define IDS_FILE_NEWDT                  54
#define IDI_MULTIDESK_ICON              101
#define IDB_BITMAP_SPLASH               104
#define IDD_SPLASH_DIALOG               105
#define IDI_TASKBAR_ICON                148
#define IDM_NEW_DESKTOP                 151
#define IDM_DELETE_DESKTOP              152
#define IDM_DESKTOP_PROPERTIES          153
#define IDC_DESKTOPICONLIST             154
#define IDD_PROPERTIES                  182
#define IDS_PROPS                       450
#define IDS_GENERAL                     451
#define IDI_WIN_ICON01                  500
#define IDI_WIN_ICON02                  501
#define IDI_WIN_ICON03                  502
#define IDI_WIN_ICON04                  503
#define IDI_WIN_ICON05                  504
#define IDI_WIN_ICON06                  505
#define IDI_WIN_ICON07                  506
#define IDI_WIN_ICON08                  507
#define IDI_WIN_ICON09                  508
#define IDI_WIN_ICON10                  509
#define IDI_WIN_ICON11                  510
#define IDI_WIN_ICON12                  511
#define IDI_WIN_ICON13                  512
#define IDI_WIN_ICON14                  513
#define IDI_WIN_ICON15                  514
#define IDI_WIN_ICON16                  515
#define IDI_WIN_ICON17                  516
#define IDI_WIN_ICON18                  517
#define IDI_WIN_ICON19                  518
#define IDI_WIN_ICON20                  519
#define IDI_WIN_ICON21                  520
#define IDI_WIN_ICON22                  521
#define IDI_WIN_ICON23                  522
#define IDI_WIN_ICON24                  523
#define IDI_WIN_ICON25                  524
#define IDI_WIN_ICON26                  525
#define IDI_WIN_ICON27                  526
#define IDC_EDIT_NAME                   1000
#define IDC_ICONLIST                    1032
#define IDC_DEFICON                     1040
#define IDC_SAIFER_NOTETEXT             2003
#define IDC_EDIT_SAIFER                 2201

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        183
#define _APS_NEXT_COMMAND_VALUE         40004
#define _APS_NEXT_CONTROL_VALUE         1043
#define _APS_NEXT_SYMED_VALUE           155
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\winsafer\test\desktops\registry.cpp ===
////////////////////////////////////////////////////////////////////////////////
//
// File:        Registry.cpp
// Created:        Feb 1996
// By:            Martin Holladay (a-martih) and Ryan D. Marshall (a-ryanm)
// 
// Project:    MultiDesk - The NT Desktop Switcher
//
// Main Functions:
//            Profile_GetApplicationState() - retrieves the application's state variables
//            Profile_SetApplicationState() - sets the applicaion's state variables
//            
//
// Misc. Functions (helpers)
//
// Revision History:
//
//            March 1997    - Add external icon capability
//                                     
//

#include <windows.h>
#include <stdio.h>
#include <assert.h> 
#include <shellapi.h>
#include "DeskSpc.h"
#include "desktop.h"
#include "registry.h"
#include "resource.h"

extern APPVARS AppMember;

//
// Registry key names for MultiDesk params - only need file scope
//
#define MD_MULTIDESK              TEXT("Software\\Microsoft\\MultiDesk")

#define MD_CONTEXT                TEXT("Software\\Microsoft\\MultiDesk\\Context")
#define MD_NUMOFDESKTOPS          TEXT("NumOfDesktops")
#define MD_DESKTOPNAME            TEXT("DesktopName")
#define MD_SAIFERNAME             TEXT("SaiferName")
#define MD_DESKTOPICONID          TEXT("DesktopIconID")

#define WR_DESKTOP                TEXT("Control Panel\\Desktop")
#define WR_PATTERN                TEXT("Pattern")
#define WR_SCREENSAVER            TEXT("SCRNSAVE.EXE")
#define WR_ACTIVE                 TEXT("ScreenSaveActive")
#define WR_TIMEOUT                TEXT("ScreenSaveTimeOut")
#define WR_SECURE                 TEXT("ScreenSaverIsSecure")
#define WR_WALLPAPER              TEXT("Wallpaper")
#define WR_TILE                   TEXT("TileWallpaper")

///////////////////////////////////////////////////////////////////////////////
//
// defines and structs for updating the Color settings in the registry
//


//
// HKEY_CURRENT_USER sub key for colors
//
#define COLOR_SUBKEY            TEXT("Control Panel\\Colors")

//
// Two ORDERED Lists of NUM_COLOR_ELEMENTS which MUST go together
//        nColorElements and szRegColorNames
//        If you change one change the other and adjust NUM_COLOR_ELEMENTS
// 
const int nColorElements[NUM_COLOR_ELEMENTS] = {    
        COLOR_ACTIVEBORDER,                //     0 
        COLOR_ACTIVECAPTION,            //     1
        COLOR_APPWORKSPACE,                //     2
        COLOR_BACKGROUND,                //     3
        COLOR_BTNFACE,                    //     4
        COLOR_BTNHILIGHT,                //     5
        COLOR_BTNSHADOW,                //     6
        COLOR_BTNTEXT,                    //     7
        COLOR_GRAYTEXT,                    //     8
        COLOR_HIGHLIGHT,                //     9
        COLOR_HIGHLIGHTTEXT,            //    10
        COLOR_INACTIVEBORDER,            //    11
        COLOR_INACTIVECAPTION,            //    12
        COLOR_INACTIVECAPTIONTEXT,        //    13
        COLOR_INFOTEXT,                    //    14
        COLOR_INFOBK,                    //    15
        COLOR_MENU,                        //    16
        COLOR_MENUTEXT,                    //    17
        COLOR_SCROLLBAR,                //    18
        COLOR_CAPTIONTEXT,                //  19
        COLOR_WINDOW,                    //    20
        COLOR_WINDOWFRAME,                //    21
        COLOR_WINDOWTEXT,                //    22    
};


//
// List of key value names for updating the registry
// 
LPCTSTR szRegColorNames[NUM_COLOR_ELEMENTS] = {
        TEXT("ActiveBorder"),                    //  0
        TEXT("ActiveTitle"),                    //  1
        TEXT("AppWorkSpace"),                    //    2
        TEXT("Background"),                    //  3
        TEXT("ButtonFace"),                    //  4
        TEXT("ButtonHilight"),                //  5
        TEXT("ButtonShadow"),                    //  6
        TEXT("ButtonText"),                    //  7
        TEXT("GrayText"),                        //  8
        TEXT("Hilight"),                        //  9
        TEXT("HilightText"),                    // 10
        TEXT("InactiveBorder"),                // 11
        TEXT("InactiveTitle"),                // 12
        TEXT("InactiveTitleText"),            // 13
        TEXT("InfoText"),                        // 14
        TEXT("InfoWindow"),                    // 15
        TEXT("Menu"),                            // 16
        TEXT("MenuText"),                        // 17
        TEXT("Scrollbar"),                    // 18
        TEXT("TitleText"),                    // 19
        TEXT("Window"),                        // 20
        TEXT("WindowFrame"),                    // 21
        TEXT("WindowText"),                    // 22
};



////////////////////////////////////////////////////////////////////////////////
//
//

BOOL Reg_SetSysColors(const DWORD dwColor[NUM_COLOR_ELEMENTS])
{

    UINT i;
    //
    // If the a color element is different - then Change it
    // 
    for (i = 0; i < NUM_COLOR_ELEMENTS; i++) {
        if (GetSysColor(nColorElements[i]) != dwColor[i]) {
            SetSysColors(1, &nColorElements[i], &dwColor[i]);
        }
    }

    return TRUE;
}



////////////////////////////////////////////////////////////////////////////////
//
//

BOOL Reg_GetSysColors(DWORD dwColor[NUM_COLOR_ELEMENTS])
{
    UINT i;

    for (i = 0; i < NUM_COLOR_ELEMENTS; i++) {
        dwColor[i] = GetSysColor(nColorElements[i]);
    }
    return TRUE;
}



////////////////////////////////////////////////////////////////////////////////
//
//

BOOL Reg_UpdateColorRegistry(const DWORD dwColor[NUM_COLOR_ELEMENTS])
{
    
    HKEY    hKey;
    UINT    i;
    TCHAR    szTemp[12];
    
    //
    // Open the SubKey - return FALSE if it doesn't exist
    //
    if (RegOpenKeyEx(HKEY_CURRENT_USER, COLOR_SUBKEY, 0, KEY_ALL_ACCESS, &hKey) != ERROR_SUCCESS) {
        return FALSE;
    }

    //
    // Format the RGB string and write it to the registry
    //
    for (i = 0; i < NUM_COLOR_ELEMENTS; i++) {

        wsprintf(szTemp, TEXT("%d %d %d"),
            GetRValue(dwColor[i]), GetGValue(dwColor[i]), GetBValue(dwColor[i]));
        RegSetValueEx(hKey, szRegColorNames[i], 0, REG_SZ, (LPBYTE) &szTemp,
                sizeof(TCHAR) * (lstrlen(szTemp) + 1));
        
    }    

    RegCloseKey(hKey);
    return TRUE;
}

/*-------------------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------------------*/

BOOL Profile_SetNewContext(UINT NumOfDesktops)
{
    HKEY        hKey;
    DWORD        dwDisposition;
    BOOL        bResult;

    //
    // Ensure that the ..\MultiDesk Subkey exists, and if not create it.
    //
    if (RegCreateKeyEx(HKEY_CURRENT_USER, MD_MULTIDESK, 0, TEXT(""), REG_OPTION_NON_VOLATILE, 
                    KEY_ALL_ACCESS, NULL, &hKey, &dwDisposition) != ERROR_SUCCESS) 
    {
        return FALSE;
    }
    RegCloseKey(hKey);

    // 
    // Open the ..\MultiDesk\Context subkey
    //
    if (RegCreateKeyEx(HKEY_CURRENT_USER, MD_CONTEXT, 0, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, &dwDisposition) != ERROR_SUCCESS) 
    {
        return FALSE;
    }


    //
    // Write the number of destkops
    //
    if (RegSetValueEx(hKey, MD_NUMOFDESKTOPS, 0, REG_DWORD, (LPBYTE) &NumOfDesktops, sizeof(UINT)) != ERROR_SUCCESS) 
    {
        RegCloseKey(hKey);
        bResult = FALSE;
    }    
    RegCloseKey(hKey);

    return bResult;
}

/*-------------------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------------------*/

BOOL Profile_GetNewContext(UINT* NumOfDesktops)
{
    HKEY        hKey;
    DWORD        dwType;
    DWORD        ulLen;

    //
    // Open the SubKey - return FALSE if it doesn't exist
    //
    if (RegOpenKeyEx(HKEY_CURRENT_USER, MD_CONTEXT, 0, KEY_ALL_ACCESS, &hKey) != ERROR_SUCCESS) 
    {
        return FALSE;
    }


    // 
    // Get the number of desktops
    //
    ulLen = sizeof(UINT);
    if (RegQueryValueEx(hKey, MD_NUMOFDESKTOPS, NULL, &dwType, (LPBYTE) NumOfDesktops, &ulLen) != ERROR_SUCCESS) 
    {
        RegCloseKey(hKey);
        return FALSE;
    }
    RegCloseKey(hKey);

    return TRUE;
}

/*-------------------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------------------*/

BOOL
Profile_SaveDesktopContext
(
    UINT      DesktopNumber, 
    LPCTSTR   szDesktopName,
    LPCTSTR   szSaiferName,
    UINT      nIconID
)
{
    TCHAR        DesktopKey[MAX_PATH];
    HKEY        hKey;
    DWORD        dwDisposition;

    //
    // Ensure that the ..\MultiDesk Subkey exists, and if not create it.
    //
    if (RegCreateKeyEx(HKEY_CURRENT_USER, MD_MULTIDESK, 0, TEXT(""), REG_OPTION_NON_VOLATILE, 
                    KEY_ALL_ACCESS, NULL, &hKey, &dwDisposition) != ERROR_SUCCESS) 
    {
        return FALSE;
    }
    RegCloseKey(hKey);

    //
    // Ensure that the ..\MultiDesk\Context Subkey exists, and if not create it.
    //
    if (RegCreateKeyEx(HKEY_CURRENT_USER, MD_CONTEXT, 0, TEXT(""), REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS, NULL, &hKey, &dwDisposition) != ERROR_SUCCESS) 
    {
        return FALSE;
    }
    RegCloseKey(hKey);
    
    // 
    // Open the ..\MultiDesk\Context\Desktop subkey
    //
    wsprintf(DesktopKey, MD_CONTEXT TEXT("\\%02d"), DesktopNumber);
    if (RegCreateKeyEx(HKEY_CURRENT_USER, DesktopKey, 0, TEXT(""), REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS, NULL, &hKey, &dwDisposition) != ERROR_SUCCESS) 
    {
        return FALSE;
    }

    //
    // Write the desktop name
    //
    if (RegSetValueEx(hKey, MD_DESKTOPNAME, 0, REG_SZ, (const LPBYTE) szDesktopName,
            sizeof(TCHAR) * (lstrlen(szDesktopName) + 1)) != ERROR_SUCCESS) 
    {
        RegCloseKey(hKey);
        return FALSE;
    }    

    //
    // Write the Saifer name
    //
    if (RegSetValueEx(hKey, MD_SAIFERNAME, 0, REG_SZ, (const LPBYTE) szSaiferName,
            sizeof(TCHAR) * (lstrlen(szSaiferName) + 1)) != ERROR_SUCCESS) 
    {
        RegCloseKey(hKey);
        return FALSE;
    }    

    //
    // Write the Icon ID
    // 
    if (RegSetValueEx(hKey, MD_DESKTOPICONID, 0, REG_DWORD, (const LPBYTE) &nIconID,
            sizeof(UINT)) != ERROR_SUCCESS) 
    {
        RegCloseKey(hKey);
        return FALSE;
    }
    

    RegCloseKey(hKey);

    return TRUE;
}

/*-------------------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------------------*/

BOOL 
Profile_LoadDesktopContext
(
    UINT    DesktopNumber, 
    LPTSTR    szDesktopName,
    LPTSTR   szSaiferName,
    UINT *    nIconID
)
{
    TCHAR        DesktopKey[MAX_PATH];
    HKEY        hKey;
    DWORD        dwType;
    DWORD        ulLen;


    //
    // Open the SubKey - return FALSE if it doesn't exist
    //
    wsprintf(DesktopKey, MD_CONTEXT TEXT("\\%02d"), DesktopNumber);
    if (RegOpenKeyEx(HKEY_CURRENT_USER, DesktopKey, 0, KEY_ALL_ACCESS, &hKey) != ERROR_SUCCESS) 
    {
        return FALSE;
    }

    // 
    // Get the desktop name
    //
    ulLen = sizeof(TCHAR) * MAX_NAME_LENGTH;        // must be bytes not TCHAR
    if (RegQueryValueEx(hKey, MD_DESKTOPNAME, NULL, &dwType, (LPBYTE) szDesktopName, &ulLen) != ERROR_SUCCESS) 
    {
        RegCloseKey(hKey);
        return FALSE;
    }

    // 
    // Get the Saifer name
    //
    ulLen = sizeof(TCHAR) * MAX_NAME_LENGTH;        // must be bytes not TCHAR
    if (RegQueryValueEx(hKey, MD_SAIFERNAME, NULL, &dwType, (LPBYTE) szSaiferName, &ulLen) != ERROR_SUCCESS) 
    {
        RegCloseKey(hKey);
        return FALSE;
    }

    // 
    // Get the desktop UINT icon ID
    //
    ulLen = sizeof(TCHAR) * MAX_PATH;       // must be bytes not TCHAR
    if (RegQueryValueEx(hKey, MD_DESKTOPICONID, NULL, &dwType, (LPBYTE) nIconID, &ulLen) != ERROR_SUCCESS) 
    {
        *nIconID = DesktopNumber;
    }
     
    RegCloseKey(hKey);
    return TRUE;
}

/*-------------------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------------------*/

BOOL Reg_GetPattern(LPTSTR szPattern)
{
    DWORD        dwType;
    DWORD        ulLen;
    HKEY        hKey;

    //
    // Open the pattern key
    //
    if (RegOpenKeyEx(HKEY_CURRENT_USER, WR_DESKTOP, 0, KEY_ALL_ACCESS, &hKey) != ERROR_SUCCESS) 
    {
        return FALSE;
    }

    // 
    // Get the pattern
    //
    ulLen = sizeof(TCHAR) * MAX_NAME_LENGTH;            // must be bytes not TCHAR
    if (RegQueryValueEx(hKey, WR_PATTERN, NULL, &dwType, (LPBYTE) szPattern, &ulLen) != ERROR_SUCCESS) 
    {
        RegCloseKey(hKey);
        return FALSE;
    }
    szPattern[ulLen] = TEXT('\0');
    
    RegCloseKey(hKey);
    return TRUE;
}

/*-------------------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------------------*/

BOOL Reg_SetPattern(LPCTSTR szPattern)
{
    TCHAR        szOldPattern[MAX_NAME_LENGTH];
    DWORD        dwType;
    DWORD        ulLen;
    HKEY        hKey;

    //
    // Open the pattern key
    //
    if (RegOpenKeyEx(HKEY_CURRENT_USER, WR_DESKTOP, 0, KEY_ALL_ACCESS, &hKey) != ERROR_SUCCESS) 
    {
        return FALSE;
    }

    // 
    // Get the pattern
    //
    ulLen = sizeof(TCHAR) * MAX_NAME_LENGTH;        // must be bytes not TCHAR
    if (RegQueryValueEx(hKey, WR_PATTERN, NULL, &dwType, (LPBYTE) szOldPattern, &ulLen) != ERROR_SUCCESS) 
    {
        RegCloseKey(hKey);
        return FALSE;
    }

    //
    // Compare the patterns
    //
    if (!lstrcmp(szPattern, szOldPattern)) return FALSE;

    //
    // Write the pattern
    //
    if (RegSetValueEx(hKey, WR_PATTERN, 0, REG_SZ, (const LPBYTE) szPattern,
        sizeof(TCHAR) * (lstrlen(szPattern) + 1)) != ERROR_SUCCESS) 
    {
        RegCloseKey(hKey);
        return FALSE;
    }    
    RegCloseKey(hKey);

    return TRUE;
}

/*-------------------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------------------*/

BOOL Reg_GetScreenSaver(LPTSTR szScreenSaver, LPTSTR szSecure, LPTSTR szTimeOut, LPTSTR szActive)
{
    DWORD        dwType;
    DWORD        ulLen;
    HKEY        hKey;

    //
    // Open the desktop key
    //
    if (RegOpenKeyEx(HKEY_CURRENT_USER, WR_DESKTOP, 0, KEY_ALL_ACCESS, &hKey) != ERROR_SUCCESS) 
    {
        return FALSE;
    }

    // 
    // Get the screen saver Path
    //
    ulLen = sizeof(TCHAR) * MAX_PATH;       // must be bytes not TCHAR
    if (RegQueryValueEx(hKey, WR_SCREENSAVER, NULL, &dwType, (LPBYTE) szScreenSaver, &ulLen) != ERROR_SUCCESS) 
    {
        RegCloseKey(hKey);
        return FALSE;
    }
    
    // 
    // Get the screen saver Secure
    //
    ulLen = sizeof(TCHAR) * MAX_NAME_LENGTH;        // must be bytes not TCHAR
    if (RegQueryValueEx(hKey, WR_SECURE, NULL, &dwType, (LPBYTE) szSecure, &ulLen) != ERROR_SUCCESS) 
    {
        RegCloseKey(hKey);
        return FALSE;
    }
    
    // 
    // Get the screen saver TimeOut
    //
    ulLen = sizeof(TCHAR) * MAX_NAME_LENGTH;        // must be bytes not TCHAR
    if (RegQueryValueEx(hKey, WR_TIMEOUT, NULL, &dwType, (LPBYTE) szTimeOut, &ulLen) != ERROR_SUCCESS) 
    {
        RegCloseKey(hKey);
        return FALSE;
    }

    // 
    // Get the screen saver Active
    //
    ulLen = sizeof(TCHAR) * MAX_NAME_LENGTH;        // must be bytes not TCHAR
    if (RegQueryValueEx(hKey, WR_ACTIVE, NULL, &dwType, (LPBYTE) szActive, &ulLen) != ERROR_SUCCESS) 
    {
        RegCloseKey(hKey);
        return FALSE;
    }
    
    RegCloseKey(hKey);
    return TRUE;
}

/*-------------------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------------------*/

BOOL Reg_SetScreenSaver(LPCTSTR szScreenSaver, LPCTSTR szSecure, LPCTSTR szTimeOut, LPCTSTR szActive)
{
    TCHAR        szOldScreenSaver[MAX_PATH];
    TCHAR        szOldSecure[MAX_PATH];
    TCHAR        szOldTimeOut[MAX_PATH];
    TCHAR        szOldActive[MAX_PATH];
    DWORD        dwType;
    DWORD        ulLen;
    HKEY        hKey;

    //
    // Open the desktop key
    //
    if (RegOpenKeyEx(HKEY_CURRENT_USER, WR_DESKTOP, 0, KEY_ALL_ACCESS, &hKey) != ERROR_SUCCESS) 
    {
        return FALSE;
    }

    // 
    // Get the screen saver Path
    //
    ulLen = sizeof(TCHAR) * MAX_PATH;
    if (RegQueryValueEx(hKey, WR_SCREENSAVER, NULL, &dwType, (LPBYTE) szOldScreenSaver, &ulLen) != ERROR_SUCCESS) 
    {
        RegCloseKey(hKey);
        return FALSE;
    }
    if (lstrcmp(szOldScreenSaver, szScreenSaver))
        RegSetValueEx(hKey, WR_SCREENSAVER, 0, REG_SZ, (LPBYTE) szScreenSaver,
            sizeof(TCHAR) * (lstrlen(szScreenSaver) + 1));
    
    // 
    // Get the screen saver Secure
    //
    ulLen = sizeof(TCHAR) * MAX_PATH;
    if (RegQueryValueEx(hKey, WR_SECURE, NULL, &dwType, (LPBYTE) szOldSecure, &ulLen) != ERROR_SUCCESS) 
    {
        RegCloseKey(hKey);
        return FALSE;
    }
    if (lstrcmp(szOldSecure, szSecure))
        RegSetValueEx(hKey, WR_SECURE, 0, REG_SZ, (LPBYTE) szSecure,
            sizeof(TCHAR) * (lstrlen(szSecure) + 1));

    // 
    // Get the screen saver TimeOut
    //
    ulLen = sizeof(TCHAR) * MAX_PATH;
    if (RegQueryValueEx(hKey, WR_TIMEOUT, NULL, &dwType, (LPBYTE) szOldTimeOut, &ulLen) != ERROR_SUCCESS) 
    {
        RegCloseKey(hKey);
        return FALSE;
    }
    if (lstrcmp(szOldTimeOut, szTimeOut))
        RegSetValueEx(hKey, WR_TIMEOUT, 0, REG_SZ, (LPBYTE) szTimeOut,
            sizeof(TCHAR) * (lstrlen(szTimeOut) + 1));

    // 
    // Get the screen saver Active
    //
    ulLen = sizeof(TCHAR) * MAX_PATH;
    if (RegQueryValueEx(hKey, WR_ACTIVE, NULL, &dwType, (LPBYTE) szOldActive, &ulLen) != ERROR_SUCCESS) 
    {
        RegCloseKey(hKey);
        return FALSE;
    }
    if (lstrcmp(szOldActive, szActive))
        RegSetValueEx(hKey, WR_ACTIVE, 0, REG_SZ, (LPBYTE) szActive,
            sizeof(TCHAR) * (lstrlen(szActive) + 1));

    RegCloseKey(hKey);
    return TRUE;
}

/*-------------------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------------------*/

BOOL Reg_GetWallpaper(LPTSTR szWallpaper, LPTSTR szTile)
{
    DWORD        dwType;
    DWORD        ulLen;
    HKEY        hKey;

    //
    // Open the desktop key
    //
    if (RegOpenKeyEx(HKEY_CURRENT_USER, WR_DESKTOP, 0, KEY_ALL_ACCESS, &hKey) != ERROR_SUCCESS) 
    {
        return FALSE;
    }

    // 
    // Get the wallpaper Path
    //
    ulLen = sizeof(TCHAR) * MAX_PATH;
    if (RegQueryValueEx(hKey, WR_WALLPAPER, NULL, &dwType, (LPBYTE) szWallpaper, &ulLen) != ERROR_SUCCESS) 
    {
        RegCloseKey(hKey);
        return FALSE;
    }
    
    // 
    // Get the wallpaper Tile attribute
    //
    ulLen = sizeof(TCHAR) * MAX_PATH;
    if (RegQueryValueEx(hKey, WR_TILE, NULL, &dwType, (LPBYTE) szTile, &ulLen) != ERROR_SUCCESS) 
    {
        RegCloseKey(hKey);
        return FALSE;
    }

    RegCloseKey(hKey);
    return TRUE;
}

/*-------------------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------------------*/

BOOL Reg_SetWallpaper(LPCTSTR szWallpaper, LPCTSTR szTile)
{
    TCHAR        szOldWallpaper[MAX_PATH];
    TCHAR        szOldTile[MAX_PATH];
    DWORD        dwType;
    DWORD        ulLen;
    HKEY        hKey;

    //
    // Open the desktop key
    //
    if (RegOpenKeyEx(HKEY_CURRENT_USER, WR_DESKTOP, 0, KEY_ALL_ACCESS, &hKey) != ERROR_SUCCESS) 
    {
        return FALSE;
    }

    // 
    // Get the wallpaper Path
    //
    ulLen = sizeof(TCHAR) * MAX_PATH;
    if (RegQueryValueEx(hKey, WR_WALLPAPER, NULL, &dwType, (LPBYTE) szOldWallpaper, &ulLen) != ERROR_SUCCESS) 
    {
        RegCloseKey(hKey);
        return FALSE;
    }
    if (lstrcmp(szOldWallpaper, szWallpaper))
        RegSetValueEx(hKey, WR_WALLPAPER, 0, REG_SZ, (const LPBYTE) szWallpaper,
                sizeof(TCHAR) * (lstrlen(szWallpaper) + 1));
    
    // 
    // Get the wallpaper Tile Attribute
    //
    ulLen = sizeof(TCHAR) * MAX_PATH;
    if (RegQueryValueEx(hKey, WR_TILE, NULL, &dwType, (LPBYTE) szOldTile, &ulLen) != ERROR_SUCCESS) 
    {
        RegCloseKey(hKey);
        return FALSE;
    }
    if (lstrcmp(szOldTile, szTile))
        RegSetValueEx(hKey, WR_TILE, 0, REG_SZ, (const LPBYTE) szTile,
            sizeof(TCHAR) * (lstrlen(szTile) + 1));

    RegCloseKey(hKey);
    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//
//


BOOL Profile_LoadScheme(UINT DesktopNumber, PDESKTOP_SCHEME pDesktopScheme)
{
    DWORD        dwType;
    DWORD        ulLen;
    HKEY        hKey;
    TCHAR        DesktopKey[MAX_PATH + 1];
    int         i;

    //
    // Open the MultiDesk\Context\DesktopNumber key
    //
    wsprintf(DesktopKey, MD_CONTEXT TEXT("\\%02d"), DesktopNumber);
    if (RegOpenKeyEx(HKEY_CURRENT_USER, DesktopKey, 0, KEY_ALL_ACCESS, &hKey) != ERROR_SUCCESS) 
    {
        return FALSE;
    }

    //
    // Read the color settings
    //
    for (i = 0; i < NUM_COLOR_ELEMENTS; i++) {
        ulLen = sizeof(DWORD);
        if (RegQueryValueEx(hKey, szRegColorNames[i], 0, &dwType, (LPBYTE) &pDesktopScheme->dwColor[i], &ulLen) != ERROR_SUCCESS)  {
            RegCloseKey(hKey);
            return FALSE;
        }
    }

    // 
    // Get the pattern
    //
    ulLen = sizeof(pDesktopScheme->szPattern);    // must be bytes not TCHAR
    if (RegQueryValueEx(hKey, WR_PATTERN, NULL, &dwType, (LPBYTE) pDesktopScheme->szPattern, &ulLen) != ERROR_SUCCESS) 
    {
        RegCloseKey(hKey);
        return FALSE;
    }


    // 
    // Get the screen saver Path
    //
    ulLen = sizeof(pDesktopScheme->szScreenSaver);    // must be bytes not TCHAR
    if (RegQueryValueEx(hKey, WR_SCREENSAVER, NULL, &dwType, (LPBYTE) pDesktopScheme->szScreenSaver, &ulLen) != ERROR_SUCCESS) 
    {
        RegCloseKey(hKey);
        return FALSE;
    }

    // 
    // Get the screen saver Secure
    //
    ulLen = sizeof(pDesktopScheme->szSecure);    // must be bytes not TCHAR
    if (RegQueryValueEx(hKey, WR_SECURE, NULL, &dwType, (LPBYTE) pDesktopScheme->szSecure, &ulLen) != ERROR_SUCCESS) 
    {
        RegCloseKey(hKey);
        return FALSE;
    }

    // 
    // Get the screen saver TimeOut
    //
    ulLen = sizeof(pDesktopScheme->szTimeOut);    // must be bytes not TCHAR
    if (RegQueryValueEx(hKey, WR_TIMEOUT, NULL, &dwType, (LPBYTE) pDesktopScheme->szTimeOut, &ulLen) != ERROR_SUCCESS) 
    {
        RegCloseKey(hKey);
        return FALSE;
    }

    // 
    // Get the screen saver Active
    //
    ulLen = sizeof(pDesktopScheme->szActive);    // must be bytes not TCHAR
    if (RegQueryValueEx(hKey, WR_ACTIVE, NULL, &dwType, (LPBYTE) pDesktopScheme->szActive, &ulLen) != ERROR_SUCCESS) 
    {
        RegCloseKey(hKey);
        return FALSE;
    }


    // 
    // Get the wallpaper Path
    //
    ulLen = sizeof(pDesktopScheme->szWallpaper);    // bytes not TCHAR
    if (RegQueryValueEx(hKey, WR_WALLPAPER, NULL, &dwType, (LPBYTE) pDesktopScheme->szWallpaper, &ulLen) != ERROR_SUCCESS) 
    {
        RegCloseKey(hKey);
        return FALSE;
    }
    
    // 
    // Get the wallpaper Tile attribute
    //
    ulLen = sizeof(pDesktopScheme->szTile);     // bytes not TCHAR
    if (RegQueryValueEx(hKey, WR_TILE, NULL, &dwType, (LPBYTE) pDesktopScheme->szTile, &ulLen) != ERROR_SUCCESS) 
    {
        RegCloseKey(hKey);
        return FALSE;
    }


    RegCloseKey(hKey);
    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////////////
//
// 
//

BOOL Profile_SaveScheme(UINT DesktopNumber, PDESKTOP_SCHEME pDesktopScheme)
{
    DWORD        dwDisposition;
    HKEY        hKey;
    TCHAR        DesktopKey[MAX_PATH + 1];
    int         i;

    //
    // Ensure that the ..\MultiDesk Subkey exists, and if not create it.
    //
    if (RegCreateKeyEx(HKEY_CURRENT_USER, MD_MULTIDESK, 0, TEXT(""), REG_OPTION_NON_VOLATILE, 
                    KEY_ALL_ACCESS, NULL, &hKey, &dwDisposition) != ERROR_SUCCESS) 
    {
        return FALSE;
    }
    RegCloseKey(hKey);

    // 
    // As above, ensure that the ..\MultiDesk\Context subkey exist
    //
    if (RegCreateKeyEx(HKEY_CURRENT_USER, MD_CONTEXT, 0, TEXT(""), REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS, NULL, &hKey, &dwDisposition) != ERROR_SUCCESS) 
    {
        return FALSE;
    }
    RegCloseKey(hKey);

    //
    // Open the Desktop key, Create it if it doesn't exist
    //
    wsprintf(DesktopKey, MD_CONTEXT TEXT("\\%02d"), DesktopNumber);
    if (RegCreateKeyEx(HKEY_CURRENT_USER, DesktopKey, 0, TEXT(""), REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS, NULL, &hKey, &dwDisposition) != ERROR_SUCCESS) 
    {
        return FALSE;
    }

    //
    // Write the pattern
    //
    RegSetValueEx(hKey, WR_PATTERN, 0, REG_SZ, (LPBYTE) pDesktopScheme->szPattern,
            sizeof(TCHAR) * (lstrlen(pDesktopScheme->szPattern) + 1));

    //
    // Write the Screen Saver settings
    //
    RegSetValueEx(hKey, WR_SCREENSAVER, 0, REG_SZ, (LPBYTE) pDesktopScheme->szScreenSaver,
            sizeof(TCHAR) * (lstrlen(pDesktopScheme->szScreenSaver) + 1));
    RegSetValueEx(hKey, WR_SECURE, 0, REG_SZ, (LPBYTE) pDesktopScheme->szSecure,
            sizeof(TCHAR) * (lstrlen(pDesktopScheme->szSecure) + 1));
    RegSetValueEx(hKey, WR_TIMEOUT, 0, REG_SZ, (LPBYTE) pDesktopScheme->szTimeOut,
            sizeof(TCHAR) * (lstrlen(pDesktopScheme->szTimeOut) + 1));
    RegSetValueEx(hKey, WR_ACTIVE, 0, REG_SZ, (LPBYTE) pDesktopScheme->szActive,
            sizeof(TCHAR) * (lstrlen(pDesktopScheme->szActive) + 1));

    // 
    // write the wallpaper settings
    //
    RegSetValueEx(hKey, WR_WALLPAPER, 0, REG_SZ, (LPBYTE) pDesktopScheme->szWallpaper,
            sizeof(TCHAR) * (lstrlen(pDesktopScheme->szWallpaper) + 1));
    RegSetValueEx(hKey, WR_TILE, 0, REG_SZ, (LPBYTE) pDesktopScheme->szTile,
            sizeof(TCHAR) * (lstrlen(pDesktopScheme->szTile) + 1));

    // 
    //
    // Write the color settings
    //
    for (i = 0; i < NUM_COLOR_ELEMENTS; i++) {
        RegSetValueEx(hKey, szRegColorNames[i], 0, REG_BINARY,
            (LPBYTE) &pDesktopScheme->dwColor[i], sizeof(DWORD));
    }    

    RegCloseKey(hKey);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\winsafer\test\desktops\registry.h ===
////////////////////////////////////////////////////////////////////////////////
//
// File:	Registry.h
// Created:	Feb 1996
// By:		Martin Holladay (a-martih) and Ryan Marshall (a-ryanm)
// 
// Project:	MultiDesk - The NT Resource Kit Desktop Switcher
//
//
//
////////////////////////////////////////////////////////////////////////////////

#ifndef __MULTIDESK_REGISTRY_H__
#define __MULTIDESK_REGISTRY_H__

//
// Function Prototypes
//

// Copy and set the active in-use Windows colors.
BOOL Reg_GetSysColors(DWORD dwColor[NUM_COLOR_ELEMENTS]);
BOOL Reg_SetSysColors(const DWORD dwColor[NUM_COLOR_ELEMENTS]);
BOOL Reg_UpdateColorRegistry(const DWORD dwColor[NUM_COLOR_ELEMENTS]);

// Copy and set the active in-use Windows properties.
BOOL Reg_GetWallpaper(LPTSTR szWallpaper, LPTSTR szTile);
BOOL Reg_SetWallpaper(LPCTSTR szWallpaper, LPCTSTR szTile);
BOOL Reg_GetPattern(LPTSTR szPattern);
BOOL Reg_SetPattern(LPCTSTR szPattern);
BOOL Reg_GetScreenSaver(LPTSTR szScreenSaver, LPTSTR szSecure, LPTSTR szTimeOut, LPTSTR szActive);
BOOL Reg_SetScreenSaver(LPCTSTR szScreenSaver, LPCTSTR szSecure, LPCTSTR szTimeOut, LPCTSTR szActive);


// Read and save the current desktop number.
BOOL Profile_GetNewContext(UINT* NumOfDesktops);
BOOL Profile_SetNewContext(UINT NumOfDesktops);

// Read and save the properties for each desktop profile.
BOOL Profile_LoadDesktopContext(UINT DesktopNumber, LPTSTR szDesktopName, LPTSTR szSaiferName, UINT* nIconID);
BOOL Profile_SaveDesktopContext(UINT DesktopNumber, LPCTSTR szDesktopName, LPCTSTR szSaiferName, UINT nIconID);

// Read and save the stored configurations for each of the desktops.
BOOL Profile_SaveScheme(UINT DesktopNumber, PDESKTOP_SCHEME pDesktopScheme);
BOOL Profile_LoadScheme(UINT DesktopNumber, PDESKTOP_SCHEME pDesktopScheme);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\winsafer\test\desktops\splash.cpp ===
////////////////////////////////////////////////////////////////////////////////
//
// File:    Splash.cpp
// Created:    Jan 1996
// By:        Ryan Marshall (a-ryanm) and Martin Holladay (a-martih)
//
// Project:    Resource Kit Desktop Switcher (MultiDesk)
//
//
// Revision History:
//
//
////////////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <shlobj.h>
#include <shellapi.h>
#include <stdio.h>
#include "Resource.h"
#include "Splash.h"


//
// Local Prototypes
//
BOOL CALLBACK SplashWndProc(HWND hWnd, UINT nMessage, WPARAM wParam, LPARAM lParam);
BOOL SplashPaint(void);
HPALETTE PaletteFromDS(HDC hDC);
void SplashRealize(HWND hWnd, HDC hTheirDC);
void SplashErase(HDC hDC);


//
// Splash globals
//
#define     WM_SPLASHPUMP_TERMINATE        5001
#define     TIMER_ID                    (WM_USER + 5007)
#define     TIMEOUT                        3000

static const char    szSplashClass[]    = "Splash";

HBITMAP     hSplashBmp        = NULL;
BITMAP      bmSplashInfo    = {0L, 0L, 0L, 0L, 0, 0, NULL};
HINSTANCE   hSplashInst        = 0;
HWND        Splash_hWnd              = NULL;
BOOL        Splash_bLowRes          = TRUE;
BOOL        Splash_bNeedPalette      = FALSE;
DWORD       Splash_dwBitmapHeight = 0;
HBITMAP     Splash_hBitmap          = NULL;
HBITMAP     Splash_hOldBitmap      = NULL;
HDC         Splash_hImage          = NULL;
HPALETTE    Splash_hPalette          = NULL;

/*------------------------------------------------------------------------*/
/*------------------------------------------------------------------------*/

BOOL CALLBACK SplashWndProc(HWND hWnd, UINT nMessage, WPARAM wParam, LPARAM lParam)
{
    UINT    nSplashTimer    = 0;

    switch (nMessage)
    {
        case WM_NCCREATE:
            if ((Splash_hImage = CreateCompatibleDC(NULL)) == NULL)
                return FALSE;
            if ((Splash_hOldBitmap = SelectBitmap(Splash_hImage, Splash_hBitmap)) == NULL)
                return FALSE;
            if (Splash_bNeedPalette)
            {
                if ((Splash_hPalette = PaletteFromDS(Splash_hImage)) == NULL)
                    return FALSE;
            }
            return DefWindowProc(hWnd, nMessage, wParam, lParam);
        
        case WM_CREATE:
            nSplashTimer = SetTimer(hWnd, TIMER_ID, TIMEOUT, (TIMERPROC) NULL);
            if (!nSplashTimer) 
                PostQuitMessage(1);
            ShowWindow(hWnd, SW_SHOWNORMAL);
            break;
    
        case WM_PAINT:
            SplashPaint();
            break;

        case WM_ERASEBKGND:
            SplashErase((HDC) wParam);
            break;

        case WM_TIMER:
            KillTimer(hWnd, TIMER_ID);
            PostQuitMessage(1);
            break;

        case WM_ENDSESSION:
        case WM_CLOSE:
            PostQuitMessage(1);
            return (DefWindowProc(hWnd, nMessage, wParam, lParam));

        case WM_NCDESTROY:
            if (Splash_hBitmap) DeleteObject(Splash_hBitmap);
            PostThreadMessage(GetCurrentThreadId(), WM_SPLASHPUMP_TERMINATE, 0, 0);
            
        default:
            return (DefWindowProc(hWnd, nMessage, wParam, lParam));
    }

    return FALSE;
}

/*---------------------------------------------------------------------*/
/*---------------------------------------------------------------------*/

BOOL SplashPaint(void)
{
    PAINTSTRUCT            ps;
    HDC                    hDC;

    //
    // Paint the Background
    //
    hDC = BeginPaint(Splash_hWnd, &ps); 
    SplashRealize(Splash_hWnd, hDC);
    SetBkMode(hDC, TRANSPARENT);
    EndPaint(Splash_hWnd, &ps);
    
    return TRUE;
}

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/

HPALETTE PaletteFromDS(HDC hDC)
{
    DWORD        adw[257];
    int            i;
    int            n;

    n = GetDIBColorTable(hDC, 0, 256, (LPRGBQUAD) &adw[1]);

    for (i=1; i<=n; i++)
        adw[i] = RGB(GetBValue(adw[i]), GetGValue(adw[i]), GetRValue(adw[i]));

    adw[0] = MAKELONG(0x300, n);

    return CreatePalette((LPLOGPALETTE) &adw[0]);
}

/*------------------------------------------------------------------------*/
/*------------------------------------------------------------------------*/

void SplashRealize(HWND hWnd, HDC hTheirDC)
{
    HDC            hDC;
    BOOL        bRepaint = FALSE;

    if (Splash_hPalette)
    {
        hDC = hTheirDC ? hTheirDC : GetDC(hWnd);

        if (hDC)
        {
            SelectPalette(hDC, Splash_hPalette, FALSE);
            bRepaint = (RealizePalette(hDC) > 0);

            if (!hTheirDC)
                ReleaseDC(hWnd, hDC);
        }
    }

    //RedrawWindow(
    //    hWnd, 
    //    NULL, 
    //    NULL, 
    //    RDW_INVALIDATE | RDW_ERASE | RDW_ALLCHILDREN);
}

/*------------------------------------------------------------------------*/
/*------------------------------------------------------------------------*/

void SplashErase(HDC hDC)
{
    RECT    rc;

    GetClientRect((HWND)hSplashInst, &rc);
    SplashRealize(Splash_hWnd, hDC);
    BitBlt(hDC, 0, 0, rc.right, rc.bottom, Splash_hImage, 0, 0, SRCCOPY);
}

/*------------------------------------------------------------------------*/
/*------------------------------------------------------------------------*/

INT DoSplashWindow(LPVOID hData)
{
    MSG                msg;
    BOOL            bContinue;
    WNDCLASS        wc;
    HDC                hDC;
    BITMAP            Bmp;
    RECT            rc;
    DWORD            dwStyle;

    hSplashInst = ((PSPLASH_DATA) hData)->hInstance;

    //
    // Register the class
    //
    if (!GetClassInfo(hSplashInst, szSplashClass, &wc))
    {
        wc.style = 0;
        wc.lpfnWndProc = (WNDPROC) SplashWndProc;
        wc.cbClsExtra = wc.cbWndExtra = 0;
        wc.hInstance = hSplashInst;
        wc.hCursor = LoadCursor(NULL, IDC_ARROW);
        wc.hIcon = NULL;
        wc.hbrBackground = (HBRUSH)(COLOR_3DFACE + 1);
        wc.lpszMenuName = NULL;
        wc.lpszClassName = szSplashClass;

        if (!RegisterClass(&wc))
            return FALSE;
    }

    hDC = GetDC(NULL);
    Splash_bLowRes = (GetDeviceCaps(hDC, PLANES) * GetDeviceCaps(hDC, BITSPIXEL)) < 8;
    //
    // BUGBUG - Comment out lowres = TRUE below
    //
    //Splash_bLowRes = TRUE;  // test low res
    Splash_bNeedPalette = (!Splash_bLowRes && (GetDeviceCaps(hDC, RASTERCAPS) & RC_PALETTE));
    ReleaseDC(NULL, hDC);

    //
    // Load the background bitmap
    //
    Splash_hBitmap = (HBITMAP) LoadImage(
                hSplashInst, 
                MAKEINTRESOURCE(Splash_bLowRes ? IDB_BITMAP_SPLASH : IDB_BITMAP_SPLASH),
                IMAGE_BITMAP, 
                0, 
                0,
                LR_CREATEDIBSECTION);
    if (!Splash_hBitmap) return FALSE;

    //
    // Create the window based on the background image
    //
    GetObject(Splash_hBitmap, sizeof(Bmp), &Bmp);
    
    rc.left = (GetSystemMetrics(SM_CXSCREEN) - Bmp.bmWidth) / 2;
    rc.top = (GetSystemMetrics(SM_CYSCREEN) - Bmp.bmHeight) / 3; // intended
    rc.right = rc.left + Bmp.bmWidth;
    rc.bottom = rc.top + Bmp.bmHeight;
    Splash_dwBitmapHeight = Bmp.bmHeight;
    dwStyle = WS_POPUP | WS_VISIBLE; // | WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX;
    AdjustWindowRect(&rc, dwStyle, FALSE);

    Splash_hWnd = CreateWindow(
                        szSplashClass, 
                        szSplashClass, 
                        dwStyle,
                        rc.left, 
                        rc.top, 
                        rc.right - rc.left, 
                        rc.bottom - rc.top, 
                        NULL, 
                        NULL,
                        hSplashInst, 
                        Splash_hBitmap);
    if (!Splash_hWnd)
    {
        if (Splash_hBitmap) DeleteObject(Splash_hBitmap);
        return FALSE;
    }


    /*
    //
    // Register Window
    //
    wc.style         = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc   = (WNDPROC) SplashWndProc;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 0;
    wc.hInstance     = hSplashInst; 
    wc.hIcon         = NULL;
    wc.hCursor       = LoadCursor(NULL, IDC_WAIT);
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
    wc.lpszMenuName  = NULL;
    wc.lpszClassName = szSplashClass;

    if (!RegisterClass(&wc)) return FALSE;

    //
    // Create Window
    //
    hWnd = CreateWindowEx(
                WS_EX_TOPMOST,
                szSplashClass,
                szSplashClass,
                WS_POPUP | WS_VISIBLE,
                CW_USEDEFAULT,
                CW_USEDEFAULT,
                CW_USEDEFAULT,
                CW_USEDEFAULT,
                NULL,
                (HMENU) NULL,
                hSplashInst,
                NULL);
    if (!hWnd) return FALSE;
    */

    //
    // Pump Messages
    //
    bContinue = TRUE;
    while (bContinue && GetMessage(&msg, Splash_hWnd, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);

        if (msg.message == WM_SPLASHPUMP_TERMINATE)
            bContinue = FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\winsafer\test\isexe\isexe.c ===
#include <windows.h>
#include <winsafer.h>
#include <winsaferp.h>
#include <tchar.h>
#include <stdio.h>


int __cdecl wmain(int argc, wchar_t *argv[])
{
    if (argc != 2) {
        wprintf(L"Invalid syntax.  No filename supplied.\n");
        return -1;
    }
    if (IsExecutableFileTypeW(argv[1])) {
        wprintf(L"\"%s\" is executable.\n", argv[1]);
        return 1;
    } else {
        wprintf(L"\"%s\" is not executable.\n", argv[1]);
        return 0;
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\winsafer\test\desktops\splash.h ===
////////////////////////////////////////////////////////////////////////////////
//
// File:	Splash.h
// Created:	Jan 1996
// By:		Ryan Marshall (a-ryanm) and Martin Holladay (a-martih)
// 
// Project:	Resource Kit Desktop Switcher (MultiDesk)
//
//
////////////////////////////////////////////////////////////////////////////////

#ifndef __MULTIDESK_SPLASH_H__
#define __MULTIDESK_SPLASH_H__

//
// Function Prototypes
//

INT DoSplashWindow(LPVOID hData);

typedef struct _SPLASH_DATA
{
	HINSTANCE		hInstance;
} SPLASH_DATA, * PSPLASH_DATA;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\winsafer\test\guesslev\guesslev.cpp ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <winsafer.h>

int _cdecl dwcompare(const void* pv1, const void* pv2)
{
    DWORD dw1 = *(DWORD*)pv1;
    DWORD dw2 = *(DWORD*)pv2;

    if (dw1 < dw2) return -1;
    if (dw1 > dw2) return 1;

    return 0;
}

void _cdecl main()
{
    BOOL bStatus;
    DWORD dwInert;
    DWORD dwOutBufSize;
    DWORD dwNumLevels;
    DWORD i;
    HANDLE hProcessToken;

    bStatus = OpenProcessToken(GetCurrentProcess(),
                               TOKEN_QUERY,
                               &hProcessToken);
    if (!bStatus) goto done;

    bStatus = GetTokenInformation(hProcessToken,
                                  TokenSandBoxInert,
                                  &dwInert,
                                  sizeof(DWORD),
                                  &dwOutBufSize);

    if (!bStatus) goto done;

        printf("Process Token: INERT = %d\n", dwInert);

    printf("Enumerating available SAFER levels\n");

    bStatus = GetInformationCodeAuthzPolicyW(AUTHZSCOPEID_MACHINE,
                                             CodeAuthzPol_LevelList,
                                             0,
                                             NULL,
                                             &dwOutBufSize,
                                             NULL);
    if (!bStatus)
    {
        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) goto done;

        DWORD* pdwLevels = new DWORD[dwOutBufSize];
        if (!pdwLevels)
        {
            printf("Out of memory\n");
            goto done;
        }

        bStatus = GetInformationCodeAuthzPolicyW(AUTHZSCOPEID_MACHINE,
                                                 CodeAuthzPol_LevelList,
                                                 dwOutBufSize * sizeof(DWORD),
                                                 pdwLevels,
                                                 &dwOutBufSize,
                                                 NULL);
        if (!bStatus) goto done;

        dwNumLevels = dwOutBufSize / sizeof(DWORD);

        // I need to compare these in sorted order, so I do that myself rather
        // than rely on the api to do so
        qsort(pdwLevels, dwNumLevels, sizeof(DWORD), dwcompare);

        for (i = 0; i < dwNumLevels; i++)
        {
            HAUTHZLEVEL hCodeAuthLevel;
            HANDLE hOutToken;
            DWORD dwResult;

            bStatus = CreateCodeAuthzLevel(AUTHZSCOPEID_MACHINE,
                                           pdwLevels[i],
                                           AUTHZCRLEV_OPEN,
                                           &hCodeAuthLevel,
                                           NULL);
            if (!bStatus) goto done;

            bStatus = ComputeAccessTokenFromCodeAuthzLevel(hCodeAuthLevel,
                                                           hProcessToken,
                                                           NULL,
                                                           AUTHZTOKEN_COMPARE_ONLY,
                                                           (LPVOID)&dwResult);
            if (!bStatus) printf("ComputeAccessTokenFromCodeAuthzLevel failed with GLE=%d\n", GetLastError());

            if (dwResult != -1)
                printf("Level %d: Authorization comparison equal or greater privileged\n", pdwLevels[i]);
            else
                printf("Level %d: Authorization comparison less privileged.\n", pdwLevels[i]);

            bStatus = CloseCodeAuthzLevel(hCodeAuthLevel);
            if (!bStatus) goto done;
        }
    }

done:

    if (!bStatus)
    {
        printf("operation failed with GLE=%d\n", GetLastError());
    }

//    Sleep(3000);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\winsafer\test\saferbox\saferbox.c ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    saferbox.c        (WinSafer Test application)

Abstract:

    This module implements a utility program that tests some of the
    major child-execution and restricted token functionality.

Author:

    Jeffrey Lawson (JLawson) - Nov 1999
    John Lambert (johnla) - Nov 2000

Environment:

    User mode only.

Revision History:

    Created - Nov 1999

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wincrypt.h>
#include <aclapi.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <assert.h>
#include <wintrust.h>
#include <winsafer.h>
#include <winsaferp.h>
#include <tchar.h>
#include <winuser.h>
#include "resource.h"
#include <crypto\wintrustp.h>
#include <softpub.h>            // WINTRUST_ACTION_GENERIC_VERIFY_V2

HMODULE	hModule=NULL;


#ifdef DBG
//this is some bogus stuff to help when debugging in assembly
//To use this:
// run cdb saferbox args
//type: bp saferbox!_STACKMARK
//type g (this will break when the stackmark function is called.
//type t after it breaks
//look at eax to know what the stackmarker is 
//type t two more times to exit the function
DWORD _S=0;

int _fastcall _STACKMARK(int a)
{
	_S=a;
	return _S;
}
#define STACKMARK(X) _STACKMARK(X)
#else
#define STACKMARK(X) {}
#endif

//some forward declarations
void __cdecl printLastErrorWithIDSMessage(UINT resID);
void printLastErrorWithMessage(LPTSTR lpErrorMessage);
void printLastError(void);


LPTSTR getSystemMessage(long error_code)
{
	LPVOID message;
	const LPTSTR defaultMessage = TEXT("Format Message failed");
	if (!FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
		NULL,
		error_code,
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
		(LPTSTR) &message,
		0,
		NULL)) {
		message = (LPTSTR) LocalAlloc(LPTR, (_tcslen(defaultMessage) +1)* sizeof(TCHAR));
		_tcscpy(message, defaultMessage);
		return message;
	} else {
		return message;
	}
}



BOOL InitModule(void)
{
	if(!(hModule=GetModuleHandle(NULL)))
	   return FALSE;
	
	return TRUE;
}

//caller must free string with LocalFree
LPTSTR AllocAndLoadStringFromModule(HINSTANCE hModule, UINT resID)
{
	LPTSTR lpString = NULL;
	int cChars=0;

	lpString = (LPTSTR) LocalAlloc(LPTR, (MAX_USAGE_LEN + 1) * sizeof(TCHAR) );//add one for null char
	if (!lpString) {
		printLastError();
		return NULL;
	}	
	cChars = LoadString( hModule, resID, lpString, (MAX_USAGE_LEN + 1) * sizeof(TCHAR)); //could pass in NULL for hModule here.
	if (cChars > 0) {
		//we alloc'ed a big string before, realloc the string to only the needed size
		lpString = (LPTSTR) LocalReAlloc(lpString, (cChars + 1) * sizeof(TCHAR) , 0);
		return lpString; //will be NULL on LocalReAlloc error
	} else {
		return NULL;
	}
}

//caller must free string with LocalFree
LPTSTR AllocAndLoadString(UINT resID)
{
	return AllocAndLoadStringFromModule(hModule, resID);
}

void IDS_printString(UINT resID)
{
	LPTSTR lpString = NULL;

	lpString = AllocAndLoadString(resID);
	if (lpString) {
		_putts(lpString);
	} else { 
		_tprintf(TEXT("[String resource not found: 0x%x (%d)]\n"), resID, resID);
	}
	if (lpString) LocalFree(lpString);
	return;
}

void __cdecl IDS_tprintf(UINT resID, ...)
{
	va_list ap;
	LPTSTR lpString;
	
	STACKMARK(0xAABB0000);
	lpString = AllocAndLoadString(resID);
	va_start(ap, resID);
	if (lpString) {
		_vtprintf(lpString, ap);
	} else { 
		_tprintf(TEXT("[String resource not found: 0x%x (%d)]\n"), resID, resID);
	}
	if (lpString) LocalFree (lpString);
	va_end(ap);
}

void __cdecl printLastErrorWithIDSMessage(UINT resID)
{
	LPTSTR message = NULL;
	LPTSTR lpString = NULL;
	long err = GetLastError();
	
	message = getSystemMessage(err);
	lpString = AllocAndLoadString(resID);
	if (lpString) {
		_tprintf(TEXT("%s: 0x%X %s\n"), lpString, err, message);
	} else { 
		_tprintf(TEXT("[String resource not found: 0x%x (%d)]\n"), resID, resID);
		_tprintf(TEXT("0x%X %s\n"), err, message);
	}
	if (message) LocalFree (message);
	if (lpString) LocalFree (lpString);
}

void printLastErrorWithMessage(LPTSTR lpErrorMessage)
{
	LPTSTR message;
	long err = GetLastError();
	
	message = getSystemMessage(err);
	_tprintf(TEXT("%s : 0x%X %s\n"), lpErrorMessage, err, message);
	if (message) LocalFree (message);
}

void printLastError(void)
{
	LPTSTR message;
	message = getSystemMessage(GetLastError());
	_tprintf(TEXT("Error (%d) %s\n"), GetLastError(), message);
	if (message) LocalFree(message);
}

/*++

Routine Description:


    Displays a simple command line syntax help screen.

Arguments:

    nothing

Return Value:

    always returns 1.

--*/
int DisplaySyntax( void )
{
	IDS_tprintf(IDS_USAGE_SYNTAX);
    return 1;
}


BOOL GetSignedFileHash(
    IN LPCTSTR lpzFilename,
    OUT BYTE rgbFileHash[SAFER_MAX_HASH_SIZE],
    OUT DWORD *pcbFileHash,
    OUT ALG_ID *pHashAlgid
    )
{
    BOOL retval = TRUE;
	HRESULT hr;
 	const DWORD SHA1_HASH_LEN = 20;
 	const DWORD MD5_HASH_LEN	= 16;
	
    if ( !lpzFilename || !rgbFileHash || !pcbFileHash || !pHashAlgid )
        return FALSE;

    //
    // Call WTHelperGetFileHash
    //
    *pcbFileHash = SAFER_MAX_HASH_SIZE;
	STACKMARK(0xBBBB0000);
    hr = WTHelperGetFileHash(
                (LPWSTR)lpzFilename,  //TODO: convert from ANSI to UNICODE.  WTHelperGetFileHash doesn't support ANSI
                0,
                NULL,
                rgbFileHash,
                pcbFileHash,
                pHashAlgid);
	
    if ( SUCCEEDED (hr) )
    {
        if ( SHA1_HASH_LEN == *pcbFileHash )
            *pHashAlgid = CALG_SHA;
        else if ( MD5_HASH_LEN == *pcbFileHash )
            *pHashAlgid = CALG_MD5;
    } else {
		retval = FALSE;
	}

    return retval;
}




/*++

Routine Description:

    Computes the MD5 hash of a given file's contents and prints the
    resulting hash value to the screen.

Arguments:

    szFilename - filename to compute hash of.

Return Value:

    Returns 0 on success, or a non-zero exit code on failure.

--*/
BOOL ComputeMD5Hash(IN HANDLE hFile, OUT BYTE* hashResult, OUT DWORD* pdwHashSize)
{
   	BOOL retval = TRUE; 

    //
    // Open the specified file and map it into memory.
    //
    if (hFile != NULL) {
	    HANDLE  hMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
	    if ( hMapping ) {
	        DWORD dwDataLen = GetFileSize (hFile, NULL);
	
	        if (dwDataLen != -1) {
	            LPBYTE pbData = (LPBYTE) MapViewOfFile (hMapping, FILE_MAP_READ, 0, 0, dwDataLen);
	            if ( pbData ) {
	                //
	                // Generate the hash value of the specified file.
	                //
	                HCRYPTPROV  hProvider = 0;
	                if ( CryptAcquireContext(&hProvider, NULL, NULL,
	                      PROV_RSA_SIG, CRYPT_VERIFYCONTEXT) ||
	                  CryptAcquireContext(&hProvider, NULL, NULL,
	                      PROV_RSA_FULL, CRYPT_VERIFYCONTEXT) )
	                {
	                    HCRYPTHASH  hHash = 0;
	                    if ( CryptCreateHash(hProvider, CALG_MD5, 0, 0, &hHash) ) {
	                        if ( CryptHashData (hHash, pbData, dwDataLen, 0) ) {
	                            *pdwHashSize = SAFER_MAX_HASH_SIZE;
	                            
	                            if (!CryptGetHashParam(hHash, HP_HASHVAL, hashResult, pdwHashSize, 0)) {
	                                *pdwHashSize = 0;
									retval = FALSE;
	                            }
	                        } else { 
	                            retval = FALSE;
	                        }
	                        CryptDestroyHash(hHash);
	                    } else {
							retval = FALSE;
	                    }
	                    CryptReleaseContext(hProvider, 0);
	                } else {
						retval = FALSE;
	                }
	            } else {
					retval = FALSE;
	            }
	        }
	        CloseHandle(hMapping);
    	}
    }

    return retval;
}

/*++
Routine Description:


Arguments:

    szFilename - filename to compute hash of.

Return Value:

    Returns TRUE on success, or FALSE on failure.

--*/
BOOL ComputeHash( IN LPCTSTR szFilename)
{
	BYTE hashResult[SAFER_MAX_HASH_SIZE];
    DWORD dwHashsize = 0;
	DWORD dwFilesize = 0;
	HANDLE hFile = NULL;
	BOOL retval = FALSE;
	ALG_ID algId = 0;
	BOOL result = FALSE;

    hFile = CreateFile(szFilename, GENERIC_READ, FILE_SHARE_READ,
                     NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hFile) { 
		dwFilesize= GetFileSize(hFile, NULL);
		result = GetSignedFileHash(szFilename, hashResult, &dwHashsize, &algId);
		if (!result && 
				(GetLastError() != TRUST_E_NOSIGNATURE) &&  //a recognized format, but no sig
				(GetLastError() != TRUST_E_SUBJECT_FORM_UNKNOWN))  //unrecognized format, don't know how to get sig
		{ 
			printLastError();
			retval = FALSE;
			goto ExitHandler;
		} else if (!result) {
			if (!ComputeMD5Hash(hFile, hashResult, &dwHashsize)) {
				printLastError();
				retval = FALSE;
				goto ExitHandler;
			}
			algId = CALG_MD5;
		} else { 
			_tprintf(TEXT("This file is signed.\n"));
		}
	    //
	    // Print out the results.
	    //
	    if (dwHashsize != 0)
	    {

	        DWORD Index;
	        _tprintf(TEXT("%s:\n"), szFilename);
	        _tprintf(TEXT("Hash Algorithm: "));
			if (algId == CALG_MD5) {
				_tprintf(TEXT("MD5\n"));
			} else if (algId == CALG_SHA) {
				_tprintf(TEXT("SHA\n"));
			}
	        _tprintf(TEXT("Hash: "));
	        for (Index = 0; Index < dwHashsize; Index++)
	            printf("%02X", hashResult[Index]);
	        _tprintf(TEXT("\nFile size: "));
	        _tprintf(TEXT("%d\n"), dwFilesize);
	        retval = TRUE;
			goto ExitHandler;
	    } else {
			printLastError();
			retval = FALSE;
			goto ExitHandler;
	    }
	} else {
		printLastError();
		retval = FALSE;
		goto ExitHandler;
	}

ExitHandler:
	if (hFile) CloseHandle(hFile);
	return retval;
}


/*++

Routine Description:

    Creates the process with a given WinSafer restriction Level.

Arguments:

    hAuthzLevel - an opened WinSafer Level handle that specifies how
        the specified program should be launched.

    appname - filename of the program to be launched.

    cmdline - command line supplied to the program that is launched.

    pi - pointer to a structure that will be filled with information
        about the process that is created.

    bStartSuspended - if this argument is TRUE, then the process will
        be started in a suspended state, and its primary thread must
        be explicitly resumed by the calling program in order to
        begin execution.

Return Value:

    returns 0 on success, or a non-zero exit code on failure.

--*/
int CreateProcessRestricted(
        IN SAFER_LEVEL_HANDLE          hAuthzLevel,
        IN LPCTSTR               appname,
        IN LPTSTR                cmdline,
        OUT PROCESS_INFORMATION *pi,
        IN BOOL                 bStartSuspended)
{
    HANDLE hToken;
    STARTUPINFO si;


    // Generate the restricted token that we will use.
    if (!SaferComputeTokenFromLevel(
                hAuthzLevel,    // Safer Level handle
                NULL,           // source token
                &hToken,        // target token
                0,              // no flags
                NULL))          // reserved
    {
        _tprintf(TEXT("Failed to compute restricted access token.\n"));
        return 2;
    }

    // Prepare the startup info structure.
    ZeroMemory(&si, sizeof(STARTUPINFO));
    si.cb = sizeof(STARTUPINFO);


    // Launch the child process under the context of the restricted token.
    if (!CreateProcessAsUser(
            hToken,     // token representing the user
            appname,    // name of executable module
            cmdline,    // command-line string
            NULL,       // process security attributes
            NULL,       // thread security attributes
            FALSE,      // if process inherits handles
            (bStartSuspended ? CREATE_SUSPENDED : 0),   // creation flags
            NULL,       // new environment block
            NULL,       // current directory name
            &si,        // startup information
            pi          // process information
        ))
    {
        _tprintf(TEXT("Failed to execute child.\n"));
        CloseHandle(hToken);
        return 3;
    }

    // success.
    CloseHandle(hToken);
    return 0;
}


/*++

Routine Description:

    Prints the description and friendly name associated with an
    opened WinSafer Level handle.

Arguments:

    hAuthzLevel - the opened WinSafer Level handle to analyze.

Return Value:

    does not return a value.

--*/
void PrintLevelNameDescription( IN SAFER_LEVEL_HANDLE hAuthzLevel, BOOL bPrintDescription)
{
    WCHAR namebuffer[200];
    DWORD dwordbuffer;


    if (SaferGetLevelInformation(
                hAuthzLevel, SaferObjectLevelId,
                &dwordbuffer, sizeof(DWORD), NULL))
    {
        if (SaferGetLevelInformation(
                    hAuthzLevel, SaferObjectFriendlyName,
                    namebuffer, sizeof(namebuffer), NULL)) {
            IDS_tprintf(IDS_SECURITYLEVEL, namebuffer, dwordbuffer, dwordbuffer);
        } else {
			printLastErrorWithMessage(TEXT("Error getting level friendly name"));
        }

        if (bPrintDescription) {
			if (SaferGetLevelInformation(
	                hAuthzLevel, SaferObjectDescription,
	                namebuffer, sizeof(namebuffer), NULL)) {
	            IDS_tprintf(IDS_SECURITYLEVELDESC, namebuffer);
	        } else {
				printLastErrorWithMessage(TEXT("Error getting level description"));
	        }
		}
    } else {
		printLastErrorWithMessage(TEXT("Error retrieving level information"));
    }

}

BOOL
ListSingleIdentity(
        IN SAFER_LEVEL_HANDLE hAuthzLevel,
        IN REFGUID rEntryGuid
        )
/*++

Routine Description:

    Prints out details about a specific already existing Code Identity
    that has been defined for a WinSafer Level.

Arguments:

    hAuthzLevel - handle of the WinSafer Level to which the indicated
        Code Identity GUID belongs.

    rEntryGuid - pointer to the GUID of the Code Identity requested.

Return Value:

    returns TRUE on success, FALSE on failure.

--*/
{
    BOOL bRVal;
    DWORD dwBufferSize;
    SAFER_IDENTIFICATION_HEADER    caiCommon;


#if 0       // just testing
    SAFER_PATHNAME_IDENTIFICATION newimageid;

    ZeroMemory(&newimageid, sizeof(SAFER_PATHNAME_IDENTIFICATION));
    newimageid.header.cbStructSize = sizeof(SAFER_PATHNAME_IDENTIFICATION);
    newimageid.header.dwIdentificationType = SaferIdentityTypeImageName;
    CopyMemory(&newimageid.header.IdentificationGuid, rEntryGuid, sizeof(GUID));
    newimageid.bOnlyExeFiles = TRUE;
    lstrcpyW(newimageid.Description, L"new sample identity");
    newimageid.dwUIFlags = 42;
    lstrcpyW(newimageid.ImageName, L"c:\\temp\\foo\\bar.txt");
    bRVal = SetInformationCodeAuthzLevelW (
                hAuthzLevel,
                SaferObjectSingleIdentification,
                &newimageid,
                sizeof(newimageid));
    if (!bRVal) {
        printf("SetInformationCodeAuthzLevelW failed with error %d\n", GetLastError());
    } else {
        printf("SetInformationCodeAuthzLevelW was successful\n");
    }
#endif

#if 0       // just testing
    dwBufferSize = sizeof(SAFER_IDENTIFICATION_HEADER);
    ZeroMemory(&caiCommon, sizeof(SAFER_IDENTIFICATION_HEADER));
    caiCommon.cbStructSize = dwBufferSize;
    caiCommon.dwIdentificationType = 0;
    memcpy(&caiCommon.IdentificationGuid, rEntryGuid, sizeof(GUID));
    bRVal = SetInformationCodeAuthzLevelW (hAuthzLevel,
            SaferObjectSingleIdentification,
            &caiCommon,
            dwBufferSize);
    if (!bRVal) {
        printf("Failed to delete identity (error=%d)\n", GetLastError());
    } else {
        printf("Identity successfully deleted.\n");
    }
#endif


    dwBufferSize = sizeof(SAFER_IDENTIFICATION_HEADER);
    ZeroMemory (&caiCommon, sizeof(SAFER_IDENTIFICATION_HEADER));
    caiCommon.cbStructSize = dwBufferSize;
    memcpy (&caiCommon.IdentificationGuid, rEntryGuid, sizeof (GUID));

    bRVal = SaferGetLevelInformation (hAuthzLevel,
            SaferObjectSingleIdentification,
            &caiCommon,
            dwBufferSize,
            &dwBufferSize);
    if ( !bRVal && ERROR_INSUFFICIENT_BUFFER == GetLastError () )
    {
        PBYTE   pBytes = (PBYTE) LocalAlloc (LPTR, dwBufferSize);
        if ( pBytes )
        {
            PSAFER_IDENTIFICATION_HEADER pCommon =
                    (PSAFER_IDENTIFICATION_HEADER) pBytes;
            ZeroMemory(pCommon, dwBufferSize);
            pCommon->cbStructSize = sizeof(SAFER_IDENTIFICATION_HEADER);
            memcpy (&pCommon->IdentificationGuid, rEntryGuid, sizeof (GUID));

            bRVal = SaferGetLevelInformation (hAuthzLevel,
                    SaferObjectSingleIdentification,
                    pBytes,
                    dwBufferSize,
                    &dwBufferSize);
            if ( bRVal ) {
                switch (pCommon->dwIdentificationType) {
                    case SaferIdentityTypeImageName:
                        {
                            PSAFER_PATHNAME_IDENTIFICATION pImageName =
                                    (PSAFER_PATHNAME_IDENTIFICATION) pCommon;
                            ASSERT(pCommon->cbStructSize ==
                                   sizeof(SAFER_PATHNAME_IDENTIFICATION));
                            printf("  ImageName:  %S\n", pImageName->ImageName);
                            printf("Description:  %S\n", pImageName->Description);
#ifdef AUTHZPOL_SAFERFLAGS_ONLY_EXES
                            printf(" SaferFlags:  %d       OnlyExecutables:  %s\n\n",
                                   pImageName->dwSaferFlags,
                                   (pImageName->dwSaferFlags & AUTHZPOL_SAFERFLAGS_ONLY_EXES) != 0 ? "yes" : "no");
#else
                            printf(" SaferFlags:  %d\n\n",
                                   pImageName->dwSaferFlags);
#endif
                            return TRUE;
                        }

                    case SaferIdentityTypeImageHash:
                        {
                            ULONG i;
                            PSAFER_HASH_IDENTIFICATION pImageHash =
                                    (PSAFER_HASH_IDENTIFICATION) pCommon;
                            ASSERT(pCommon->cbStructSize ==
                                   sizeof(SAFER_HASH_IDENTIFICATION));
                            printf("  ImageHash:  ");
                            for (i = 0; i < pImageHash->HashSize; i++) {
                                printf("%02X ", pImageHash->ImageHash[i]);
                            }
                            printf("(%d bytes, ImageSize=%d bytes)\n",
                                   pImageHash->HashSize, pImageHash->ImageSize.LowPart);
                            printf("Description:  %S\n", pImageHash->Description);
                            printf(" SaferFlags:  %d\n\n", pImageHash->dwSaferFlags);
                            return TRUE;
                        }

                    case SaferIdentityTypeUrlZone:
                        {
                            PSAFER_URLZONE_IDENTIFICATION pUrlZone =
                                    (PSAFER_URLZONE_IDENTIFICATION) pCommon;
                            ASSERT(pCommon->cbStructSize ==
                                   sizeof(SAFER_URLZONE_IDENTIFICATION));
                            printf("   UrlZone:  %d\n", pUrlZone->UrlZoneId);
                            printf("SaferFlags:  %d\n\n", pUrlZone->dwSaferFlags);
                            return TRUE;
                        }

                    default:
                        printf("  Unexpectedly encountered identity type %d\n",
                               pCommon->dwIdentificationType);
                        break;
                }

            } else {
                printf("  GetInfo failed with LastError=%d\n", GetLastError());
            }
            LocalFree(pBytes);
        } else {
            printf("  Failed to allocate memory for query.\n");
        }
    } else {
        printf("  First GetInfo failed with LastError=%d\n", GetLastError());
    }
    return FALSE;
}



/*++

Routine Description:

    Prints all associated Code Identifiers for a given WinSafer Level.

Arguments:

    hAuthzLevel - the WinSafer Level handle to analyze.

Return Value:

    returns 0.

--*/
int ListAllIdentities( IN SAFER_LEVEL_HANDLE hAuthzLevel)
{
    DWORD dwInfoBufferSize;
    GUID *pIdentGuids;

    if (!SaferGetLevelInformation(
                hAuthzLevel,
                SaferObjectAllIdentificationGuids,
                NULL,
                0,
                &dwInfoBufferSize) &&
        GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
        dwInfoBufferSize != 0)
    {
        pIdentGuids = (GUID*) HeapAlloc(GetProcessHeap(),
                                          0, dwInfoBufferSize);
        if (pIdentGuids != NULL) {
            DWORD dwFinalBufferSize;
            if (SaferGetLevelInformation(
                        hAuthzLevel,
                        SaferObjectAllIdentificationGuids,
                        pIdentGuids,
                        dwInfoBufferSize,
                        &dwFinalBufferSize))
            {
                ULONG ulNumIdentities = dwFinalBufferSize / sizeof(GUID);
                ULONG i;

                ASSERT(dwFinalBufferSize == dwInfoBufferSize);
                _tprintf(TEXT("  Found %d identity GUIDs.\n"), ulNumIdentities);
                for (i = 0; i < ulNumIdentities; i++) {
                    if (!ListSingleIdentity(hAuthzLevel, &pIdentGuids[i])) {
                        _tprintf(TEXT("  Failed to retrieve details on identity.\n"));
                    }
                }
            } else {
                _tprintf(TEXT("  Failed to retrieve ident guid list (error=%d).\n"),
                       GetLastError());
            }
            HeapFree( GetProcessHeap(), 0, pIdentGuids);
	    }
    } else {
		IDS_tprintf(IDS_NORULESFOUND);
	}

    return 0;
}


/*++

Routine Description:

    Prints out a list of all defined WinSafer Levels, and optionally
    all Code Identifiers associated with them.

Arguments:

    bDisplayIdentifier - if this argument is TRUE, then the list of
        associated Code Identifiers will also be listed along with
        each WinSafer Level as they are enumerated.

Return Value:

    returns 0 on success, or a non-zero exit code on failure.

--*/
int ListAllLevels(DWORD dwScope, BOOL bDisplayIdentifiers)
{
    DWORD dwInfoBufferSize;
    LPBYTE InfoBuffer = NULL;

    // Fetch the list of all WinSafer LevelIds.
    if (!SaferGetPolicyInformation(
            dwScope, SaferPolicyLevelList,
            0, NULL, &dwInfoBufferSize, NULL) &&
        GetLastError() == ERROR_INSUFFICIENT_BUFFER)
    {
        InfoBuffer = (LPBYTE) HeapAlloc(GetProcessHeap(), 0, dwInfoBufferSize);
        if (InfoBuffer != NULL)
        {
            DWORD dwInfoBufferSize2;
            if (!SaferGetPolicyInformation(
                    dwScope, SaferPolicyLevelList,
                    dwInfoBufferSize, InfoBuffer, &dwInfoBufferSize2, NULL))
            {
                _tprintf(TEXT("Failed to retrieve Level list (error=%d)\n"),
                       GetLastError());
                HeapFree(GetProcessHeap(), 0, InfoBuffer);
                InfoBuffer = NULL;
            }
            ASSERTMSG("got different final size",
                      dwInfoBufferSize2 == dwInfoBufferSize);
            ASSERTMSG("expecting whole number of DWORD values",
                      dwInfoBufferSize % sizeof(DWORD) == 0);
            dwInfoBufferSize = dwInfoBufferSize2;
        } else {
            _tprintf(TEXT("Failed to allocate %d bytes of memory.\n"), dwInfoBufferSize);
            return 1;
        }
    }


    // Iterate through and add all of the items.
    if (InfoBuffer != NULL) {
        PDWORD pLevelIdList = (PDWORD) InfoBuffer;
        DWORD Index;
        for (Index = 0; Index < dwInfoBufferSize / sizeof(DWORD); Index++) {
            SAFER_LEVEL_HANDLE hAuthzLevel;
            WCHAR namebuffer[200];
            DWORD dwLevelId = pLevelIdList[Index];

            if (SaferCreateLevel(dwScope, dwLevelId,
                SAFER_LEVEL_OPEN, &hAuthzLevel, NULL))
            {
                _tprintf(TEXT("\n"));
				PrintLevelNameDescription(hAuthzLevel, !bDisplayIdentifiers);
/*
                if (SaferGetLevelInformation(hAuthzLevel, SaferObjectFriendlyName,
                            namebuffer, sizeof(namebuffer), NULL))
                    _tprintf(TEXT("LevelId %d: \"%s\"\n"), dwLevelId, namebuffer);
                else
                    _tprintf(TEXT("LevelId %d: unknown\n"), dwLevelId);
*/
                if (bDisplayIdentifiers) {
                    ListAllIdentities(hAuthzLevel);
                }

                SaferCloseLevel(hAuthzLevel);
            } else {
				_tprintf(TEXT("LevelId %d: unknown\n"), dwLevelId);
			}
        }
        HeapFree(GetProcessHeap(), 0, InfoBuffer);

        // Fetch the default level
		//TODO: for some reason my default level isn't in the registry and this part returns NOT_FOUND
		dwInfoBufferSize=0;
		STACKMARK(0xAAAC0000);
	    if (!SaferGetPolicyInformation(
	            dwScope, SaferPolicyDefaultLevel,
	            0, NULL, &dwInfoBufferSize, NULL) &&
	        GetLastError() == ERROR_INSUFFICIENT_BUFFER)
	    {
            SAFER_LEVEL_HANDLE hAuthzLevel;
            DWORD dwLevelId = 0;

	        InfoBuffer = (LPBYTE) HeapAlloc(GetProcessHeap(), 0, dwInfoBufferSize);

	        if (InfoBuffer != NULL)
	        {
	            if (!SaferGetPolicyInformation(
	                    dwScope, SaferPolicyDefaultLevel,
	                    dwInfoBufferSize, InfoBuffer, &dwInfoBufferSize, NULL))
	            {
	                _tprintf(TEXT("Failed to retrieve default level (error=%d)\n"), GetLastError());
	                HeapFree(GetProcessHeap(), 0, InfoBuffer);
	                InfoBuffer = NULL;
					return 1;
	            } else { 
					ASSERT(dwInfoBufferSize==sizeof(dwLevelId));
					memcpy(&dwLevelId,InfoBuffer, dwInfoBufferSize);	
		            if (SaferCreateLevel(dwScope, dwLevelId,
		                SAFER_LEVEL_OPEN, &hAuthzLevel, NULL))
		            {
                		_tprintf(TEXT("\n"));
						IDS_tprintf(IDS_DEFAULTLEVEL);
						PrintLevelNameDescription(hAuthzLevel, FALSE);
					}
				}
               	SaferCloseLevel(hAuthzLevel);
	        } else {
	            _tprintf(TEXT("Failed to allocate %d bytes of memory.\n"), dwInfoBufferSize);
	            return 1;
	        }
        } else {
            printLastErrorWithMessage(TEXT("Failed to retrieve default level"));
            return 1;
        }

    return 0;
    }
    _tprintf(TEXT("No Levels found in this scope.\n"));
    return 1;
}


BOOL PrintMatchingRule(	
		IN SAFER_LEVEL_HANDLE hAuthzLevel) 
{
	DWORD dwBufferSize=0;
    UNICODE_STRING UnicodeTemp;
	WCHAR lpzGuid[200];
	PSAFER_IDENTIFICATION_HEADER lpQueryBuf=NULL;
	SAFER_IDENTIFICATION_HEADER comheader;
		
	STACKMARK(0xAAAB0000);
	memset(&comheader,0,sizeof(SAFER_IDENTIFICATION_HEADER));
	comheader.cbStructSize=sizeof(SAFER_IDENTIFICATION_HEADER);
	dwBufferSize = sizeof(SAFER_IDENTIFICATION_HEADER);
	if (!SaferGetLevelInformation(
		hAuthzLevel, SaferObjectSingleIdentification, &comheader, dwBufferSize, &dwBufferSize)) {
		printLastError();            
        return FALSE;
	}
	if (GetLastError() == ERROR_NOT_FOUND) {
		IDS_tprintf(IDS_USINGDEFAULTRULE);
	} else {
		if (GetLastError() != ERROR_INSUFFICIENT_BUFFER && 
            GetLastError() != ERROR_SUCCESS) {
			printLastError();            
            return FALSE;
		}
	
		ASSERT(dwBufferSize >= sizeof (SAFER_IDENTIFICATION_HEADER));
		lpQueryBuf = (PSAFER_IDENTIFICATION_HEADER)LocalAlloc(LPTR, dwBufferSize );
		if (!lpQueryBuf) {
			printLastError();            
            return FALSE;
		}
		lpQueryBuf->cbStructSize = dwBufferSize;
		if (!SaferGetLevelInformation(hAuthzLevel, SaferObjectSingleIdentification, lpQueryBuf, dwBufferSize, &dwBufferSize) ) {
			printLastError();            
            return FALSE;
		}
		UnicodeTemp.Buffer=(PWSTR)lpzGuid;
		UnicodeTemp.MaximumLength = sizeof(lpzGuid);
		RtlStringFromGUID (&(lpQueryBuf->IdentificationGuid),&UnicodeTemp);
		//TODO: could print out whether rule was from CU or LM

		if (lpQueryBuf->dwIdentificationType == SaferIdentityTypeImageName) {
			IDS_tprintf(IDS_MATCHPATH, ((PSAFER_PATHNAME_IDENTIFICATION)lpQueryBuf)->ImageName);
		} else if (lpQueryBuf->dwIdentificationType == SaferIdentityTypeImageHash ){
			IDS_tprintf(IDS_MATCHHASH);
		} else if (lpQueryBuf->dwIdentificationType == SaferIdentityTypeUrlZone ){
			IDS_tprintf(IDS_MATCHZONE);
		} else {
			//must be a publisher certificate rule.
			IDS_tprintf(IDS_MATCHCERTORDEFAULT);
		}
		IDS_tprintf(IDS_GUIDRULEIS,UnicodeTemp.Buffer);
		LocalFree(lpQueryBuf);
	}
	_tprintf(TEXT("\n"));
    PrintLevelNameDescription(hAuthzLevel, TRUE);
	return TRUE;
}

//VerifyVersionInfo
BOOL IsMinimumVersion()
{
	DWORD tmp;
	LPVOID lpVerInfo = NULL;
	LPVOID lpValue = NULL;
	LPTSTR lpFileToVersion = TEXT("advapi32.dll");
	UINT uLen;
	//must be at least post beta 1 of whistler
	const DWORD PROD_MAJOR = 5;
	const DWORD PROD_MINOR = 1;
	const DWORD BUILD_MAJOR = 2400;

	DWORD dwBuildMajor=0, dwProductMajor=0, dwProductMinor=0;
	DWORD dwSize = GetFileVersionInfoSize(lpFileToVersion, &tmp);

	if (!dwSize) {
		printLastErrorWithIDSMessage(IDS_ERR_GETVERERR);
		return FALSE;
	}
	lpVerInfo = (LPVOID) LocalAlloc(LPTR, dwSize);
	if (!lpVerInfo) {
		printLastError();
		return FALSE;
	}
	if (! GetFileVersionInfo(lpFileToVersion, 0, dwSize, lpVerInfo)) {
		printLastErrorWithIDSMessage(IDS_ERR_GETVERERR);
		if (lpVerInfo) LocalFree(lpVerInfo);
		return FALSE;
	}
	if (!VerQueryValue(lpVerInfo, TEXT("\\"), &lpValue, &uLen)) {	// '\' indicates the root version info block
		printLastErrorWithIDSMessage(IDS_ERR_GETVERERR);
		if (lpVerInfo) LocalFree(lpVerInfo);
		return FALSE;
	}
	/*
	_tprintf(TEXT("dwFileVersionMS is %d\n"), (((VS_FIXEDFILEINFO*)lpValue)->dwFileVersionMS) >> 16);
	_tprintf(TEXT("dwFileVersionMS is %d\n"), (((VS_FIXEDFILEINFO*)lpValue)->dwFileVersionMS) & 0x0000FFFF);
	_tprintf(TEXT("dwFileVersionLS is %d\n"), (((VS_FIXEDFILEINFO*)lpValue)->dwFileVersionLS) >> 16);
	_tprintf(TEXT("dwFileVersionLS is %d\n"), (((VS_FIXEDFILEINFO*)lpValue)->dwFileVersionLS) & 0x0000FFFF);
	_tprintf(TEXT("dwProductVersionMS is %d\n"), (((VS_FIXEDFILEINFO*)lpValue)->dwProductVersionMS) >>16);
	_tprintf(TEXT("dwProductVersionMS is %d\n"), (((VS_FIXEDFILEINFO*)lpValue)->dwProductVersionMS) & 0x0000FFFF);
	_tprintf(TEXT("dwProductVersionLS is %d\n"), (((VS_FIXEDFILEINFO*)lpValue)->dwProductVersionLS) >>16);
	_tprintf(TEXT("dwProductVersionLS is %d\n"), (((VS_FIXEDFILEINFO*)lpValue)->dwProductVersionLS) & 0x0000FFFF);
	*/
	dwProductMajor = (((VS_FIXEDFILEINFO*)lpValue)->dwProductVersionMS) >>16;
	dwProductMinor = (((VS_FIXEDFILEINFO*)lpValue)->dwProductVersionMS) & 0x0000FFFF;
	dwBuildMajor = (((VS_FIXEDFILEINFO*)lpValue)->dwProductVersionLS) >>16;
	if ((dwProductMajor < PROD_MAJOR) ||
		(dwProductMajor == PROD_MAJOR && dwProductMinor < PROD_MINOR ) ||
		(dwProductMinor == PROD_MAJOR && dwProductMinor == PROD_MINOR && dwBuildMajor < BUILD_MAJOR)) {
		IDS_tprintf(IDS_ERR_INCORRECTOSVER, dwProductMajor, dwProductMinor, dwBuildMajor, PROD_MAJOR, PROD_MINOR, BUILD_MAJOR);
		if (lpVerInfo) LocalFree(lpVerInfo);
		return FALSE;
	} else {
		if (lpVerInfo) LocalFree(lpVerInfo);
		return TRUE;
	}
}

BOOL GetPathFromKeyKey(LPCTSTR lpzRegKey)
{
	HKEY hKey, hKeyHive;
	LPTSTR lpKeyname=NULL;
	LPCTSTR LP_CU_HIVE = TEXT("%HKEY_CURRENT_USER");
	LPCTSTR LP_LM_HIVE = TEXT("%HKEY_LOCAL_MACHINE");
	LPCTSTR lpLastPercentSign=NULL;
	BYTE buffer[MAX_PATH];
	LPTSTR lpValue;
	DWORD dwBufferSize = sizeof(buffer);
	LPTSTR lpHivename;
	LONG retval;

	memset(buffer, 0, dwBufferSize);
	lpHivename = _tcsstr(lpzRegKey, LP_CU_HIVE);
	if (lpHivename != NULL) {
		hKeyHive = HKEY_CURRENT_USER;
		lpKeyname = _tcsdup(&lpzRegKey[_tcslen(LP_CU_HIVE)+1]);  //remove '\' char in front
	} else {
		lpHivename = _tcsstr(lpzRegKey, LP_LM_HIVE);
		if (lpHivename != NULL) {
			hKeyHive = HKEY_LOCAL_MACHINE;
			lpKeyname = _tcsdup(&lpzRegKey[_tcslen(LP_LM_HIVE)+1]);  //remove '\' char in front
		} else {
			IDS_tprintf(IDS_ERR_REGNOTFOUND);
			return FALSE;
		}
	}
	lpLastPercentSign = wcsrchr(lpzRegKey,'%');
	if (lpLastPercentSign != &lpzRegKey[wcslen(lpzRegKey)-1]) {
		_tprintf(TEXT("bad substitution char.\n"));
		return FALSE;
	}

	lpValue = _tcsrchr(lpKeyname, '\\');
	if (lpValue==NULL) {
		IDS_tprintf(IDS_ERR_REGNOTFOUND);
		return FALSE;
	}
	*lpValue = '\0';
	lpValue = lpValue + 1;
	lpValue[wcslen(lpValue)-1] = '\0';

	if (retval = RegOpenKeyEx(hKeyHive,
						lpKeyname,
						0,
						KEY_READ,
						&hKey))	
	{
		SetLastError(retval);
		printLastError();
		return FALSE;
	} else {
		if (retval = RegQueryValueEx(hKey,
							lpValue,
							NULL,
							NULL,
							buffer,
							&dwBufferSize)) 
		{
			SetLastError(retval);
			printLastError();
			return FALSE;
		} else {
			_tprintf(TEXT("\n"));
			IDS_tprintf(IDS_REGVALUE);
			_tprintf(TEXT("%s"), buffer);
		}

	}
	free(lpKeyname);
	RegCloseKey(hKey);
	return TRUE;	
}
void PrintAndRecurse(HKEY hkey, LPCWSTR lpParentKeyname)
{
    DWORD cValue=MAX_PATH;
    DWORD cKey=MAX_PATH;
    DWORD cbData=100;
    LPWSTR lpValue[MAX_PATH * sizeof(WCHAR)];
    LPWSTR lpKey[MAX_PATH * sizeof(WCHAR)];
    LPWSTR lpFullKey[MAX_PATH * sizeof(WCHAR)];
    LPBYTE lpData=NULL;
    DWORD idx=0;
    DWORD dwType=0;
    DWORD retval=0;
    FILETIME filetime;
    BOOL bDone=FALSE;
    HKEY nextKey=NULL;
    DWORD dwNumSubKeys=0;
    DWORD dwNumValues=0;
    DWORD dwMaxValueLen=0;
    RegQueryInfoKey(hkey,NULL,NULL, NULL, &dwNumSubKeys, NULL, NULL, &dwNumValues,NULL, &dwMaxValueLen, NULL,NULL);
    do {
        lpValue[0]=L"\0";
        cbData = dwMaxValueLen;
        lpData = (LPBYTE)LocalAlloc(LPTR, dwMaxValueLen);   
        if (!lpData) {
            printLastError();
            return;
        }
        cValue=MAX_PATH;
        retval = RegEnumValue(hkey,
                idx,
                (LPWSTR)lpValue,
                &cValue,
                NULL,
                &dwType,
                lpData,
                &cbData); 
        if (retval==ERROR_NO_MORE_ITEMS) {
            bDone=TRUE;
        } else if (retval != ERROR_SUCCESS) {
            SetLastError(retval);
            bDone=TRUE;
            printLastError();
        }
        if (!bDone) {
            wprintf(L"\t%s",lpValue); 
            switch (dwType)
            {
                case REG_DWORD:
                    {
                        DWORD dwValue;
                        memcpy(&dwValue,lpData, sizeof(DWORD));
                        wprintf(L" : 0x%08X\n", dwValue);
                    }
                    break;
                case REG_QWORD:
                    {
                        __int64 qwValue;
                        memcpy(&qwValue, lpData, sizeof(__int64));
                        wprintf(L" : 0x%I64x\n", qwValue);
                    }
                    break;
                case REG_BINARY:
                    wprintf(L" : ");
                    {   int i;
                        for (i=0;i<(int)cbData;i++) {
                            wprintf(L"%02X", *(lpData+i));  
                        }
                        wprintf(L"\n");
                    }
                    break;
                case REG_SZ:
                case REG_EXPAND_SZ:
                    wprintf(L" : %s\n", lpData);    
                    break;
                case REG_MULTI_SZ:
                    {int idx=0; 
                        LPWSTR lpMultiPtr=(LPWSTR)lpData;
                        WCHAR nullchar = L'\0';
                        wprintf(L" : ");
                        do {
                            wprintf(L" %s ", lpMultiPtr);
                            lpMultiPtr+=wcslen(lpMultiPtr)+1 ;
                        } while (*(lpMultiPtr+1)!=0);
                        wprintf(L"\n");
                    }
                    break;
                default:
                    wprintf(L" ??????: 0x%X\n", lpData);    
            }   
            if (lpData) LocalFree(lpData);
            idx++;
        }
    } while (!bDone);
        
    if (dwNumSubKeys != 0) {
        idx=0;
        bDone=FALSE;
        do {
            lpKey[0]=L"\0";
            cKey=MAX_PATH;
            retval = RegEnumKeyEx(hkey,
                    idx,
                    (LPWSTR)lpKey,
                    &cKey,
                    NULL,
                    NULL,
                    NULL,
                    &filetime); 
            if (retval==ERROR_NO_MORE_ITEMS) {
                bDone=TRUE;
            } else if (retval != ERROR_SUCCESS) {
                SetLastError(retval);
                bDone=TRUE;
                printLastError();
            }
            if (!bDone) {
                wprintf(L"%s\\%s\n",lpParentKeyname,lpKey); 
                if (RegOpenKeyEx(hkey,
                        (LPWSTR)lpKey,
                        0,
                        KEY_READ,
                        &nextKey))
                {
                    bDone=TRUE;
                    printLastError();
                    return;
                } else {
                    memset(lpFullKey,0,sizeof(lpFullKey));
                    wcscat((LPWSTR)lpFullKey, lpParentKeyname);
                    wcscat((LPWSTR)lpFullKey, L"\\");
                    wcscat((LPWSTR)lpFullKey, (LPWSTR)lpKey);
                    wcscat((LPWSTR)lpFullKey, L"\0");
                    PrintAndRecurse(nextKey, (LPWSTR)lpFullKey);
                    RegCloseKey(nextKey);
                }
                idx++;
            }
        } while (!bDone);
    }
}


LONG DumpRegistry()
{
    DWORD class,subkeys,maxsubkeylen, numvalues, maxvaluename, maxvaluedatalen;
    const UNICODE_STRING HKLMSAFERKey = RTL_CONSTANT_STRING(SAFER_HKLM_REGBASE);
    const UNICODE_STRING HKCUSAFERKey = RTL_CONSTANT_STRING(SAFER_HKCU_REGBASE);
    const UNICODE_STRING HKPublisherKey = RTL_CONSTANT_STRING(L"Software\\Policies\\Microsoft\\SystemCertificates\\TrustedPublisher\\Certificates");
    HKEY hkey;
    int i;
    
    
    if (!RegOpenKeyEx(HKEY_CURRENT_USER,
            HKCUSAFERKey.Buffer,
            0,
            KEY_READ,
            &hkey)) 
    {
        IDS_tprintf(IDS_LISTING_HKCU);
        wprintf(L"%s\n",HKCUSAFERKey.Buffer); 
        PrintAndRecurse(hkey, HKCUSAFERKey.Buffer);
        RegCloseKey(hkey);
    }
    if (!RegOpenKeyEx(HKEY_CURRENT_USER,
            HKPublisherKey.Buffer,
            0,
            KEY_READ,
            &hkey)) 
    {
        wprintf(L"%s\n",HKPublisherKey.Buffer); 
        PrintAndRecurse(hkey, HKPublisherKey.Buffer);
        RegCloseKey(hkey);
    }
    if (!RegOpenKeyEx(HKEY_LOCAL_MACHINE,
            HKLMSAFERKey.Buffer,
            0,
            KEY_READ,
            &hkey))
    {
        wprintf(L"\n");
        IDS_tprintf(IDS_LISTING_HKLM);
        wprintf(L"%s\n",HKLMSAFERKey.Buffer); 
        PrintAndRecurse(hkey, HKCUSAFERKey.Buffer);
        RegCloseKey(hkey);
    }
    if (!RegOpenKeyEx(HKEY_LOCAL_MACHINE,
            HKPublisherKey.Buffer,
            0,
            KEY_READ,
            &hkey)) 
    {
        wprintf(L"%s\n",HKPublisherKey.Buffer); 
        PrintAndRecurse(hkey, HKPublisherKey.Buffer);
        RegCloseKey(hkey);
    }
    
    return ERROR_SUCCESS;
}



/*++

Routine Description:

    Main entry point.

Arguments:

    argc - count of command line arguments.

    argv - pointers to command line arguments.

Return Value:

    returns the program exit code.

--*/
int __cdecl _tmain(int argc, _TCHAR **argv, _TCHAR **envp)
{
    PROCESS_INFORMATION pi;
    DWORD dwLevelId = 0;
	BOOL fLevelIdSupplied = FALSE;
    _TCHAR appname[MAX_PATH];
    _TCHAR cmdline[1024];
    LPTSTR lpRegkey=NULL;
    int nextarg;
    SAFER_LEVEL_HANDLE hAuthzLevel;
	int retval;
	DWORD dwSuppliedCheckFlags=0;
	DWORD dwScopeId=(DWORD)-1; //means check both LM + CU
    BOOL useBreakMode = FALSE;
    enum { CMD_RUN, CMD_QUERY, CMD_HASH, CMD_LIST, CMD_LISTRULES, CMD_REGKEY, CMD_DUMPREG }
    commandMode = -1;
	
	LPTSTR A_LP_CMD_QUERY = AllocAndLoadString(IDS_CMD_QUERY);
	LPTSTR A_LP_CMD_RUN= AllocAndLoadString(IDS_CMD_RUN);
	LPTSTR A_LP_CMD_HASH= AllocAndLoadString(IDS_CMD_HASH);
	LPTSTR A_LP_CMD_LIST= AllocAndLoadString(IDS_CMD_LIST);
	LPTSTR A_LP_CMD_LISTRULES= AllocAndLoadString(IDS_CMD_LISTRULES);
	LPTSTR A_LP_CMD_REGKEY= AllocAndLoadString(IDS_CMD_REGKEY );
	LPTSTR A_LP_CMD_DUMPREG= AllocAndLoadString(IDS_CMD_DUMPREG );
	LPTSTR A_LP_FLAG_LEVELID= AllocAndLoadString(IDS_FLAG_LEVELID);
	LPTSTR A_LP_FLAG_RULETYPES= AllocAndLoadString(IDS_FLAG_RULETYPES);
	LPTSTR A_LP_RULETYPES_PATH= AllocAndLoadString(IDS_RULETYPES_PATH);
	LPTSTR A_LP_RULETYPES_HASH= AllocAndLoadString(IDS_RULETYPES_HASH);
	LPTSTR A_LP_RULETYPES_CERTIFICATE= AllocAndLoadString(IDS_RULETYPES_CERTIFICATE);
	LPTSTR A_LP_FLAG_SCOPE= AllocAndLoadString(IDS_FLAG_SCOPE);
	LPTSTR A_LP_SCOPE_HKLM= AllocAndLoadString(IDS_SCOPE_HKLM);
	LPTSTR A_LP_SCOPE_HKCU= AllocAndLoadString(IDS_SCOPE_HKCU);

	UNREFERENCED_PARAMETER(envp);
	STACKMARK(0xAAAA0001);

    //IDS_tprintf(IDS_TEST1,66,TEXT("hellow"),45456);  //test string 

	//get the module handle
	if(!InitModule()) { 
		return 1;
	}


    // if we are going to run in an altered registry
    // scope, open and set it now.
/*
    if (dwScopeId == SAFER_SCOPEID_REGISTRY) {
        HKEY hkeyBase;

        if (RegOpenKeyExW(HKEY_CURRENT_USER, L"TestKey",
                           0, KEY_READ, &hkeyBase) != ERROR_SUCCESS) {
            _tprintf(TEXT("Failed to open registry scope key (error=%d)\n"),
                   GetLastError());
            return 1;
        }

        if (!CodeAuthzChangeRegistryScope(hkeyBase)) {
            _tprintf(TEXT("Failed to change registry scope (error=%d)\n"),
                    GetLastError());
            return 1;
        }
        RegCloseKey(hkeyBase);
    }
*/

	if (!IsMinimumVersion()) {
		return 1;
	}

    // quick check of command line length.
    if (argc < 2) {
        _tprintf(TEXT("No arguments.\n"));
        return DisplaySyntax();
    }


    // Parse the command line.
    appname[0] = '\0';
    cmdline[0] = '\0';
    for (nextarg = 1; nextarg < argc; nextarg++) {
		if (_tcsicmp(argv[nextarg],A_LP_CMD_QUERY) == 0 ) {
			commandMode = CMD_QUERY;	
		} else if (_tcsicmp(argv[nextarg],A_LP_CMD_RUN) == 0 ) {
			commandMode = CMD_RUN;	
		} else if (_tcsicmp(argv[nextarg],A_LP_CMD_HASH) == 0 ) {
			commandMode = CMD_HASH;	
		} else if (_tcsicmp(argv[nextarg],A_LP_CMD_DUMPREG) == 0 ) {
			commandMode = CMD_DUMPREG;	
		} else if (_tcsicmp(argv[nextarg],A_LP_CMD_REGKEY) == 0 ) {
			commandMode = CMD_REGKEY;	
			nextarg++;
			if (nextarg!=argc) {
				lpRegkey = argv[nextarg];
			} else {
				return DisplaySyntax();
			}
		} else if (_tcsicmp(argv[nextarg],A_LP_CMD_LIST) == 0 ) {
			commandMode = CMD_LIST;	
		} else if (_tcsicmp(argv[nextarg],A_LP_CMD_LISTRULES) == 0 ) {
			commandMode = CMD_LISTRULES;	
        } else if (argv[nextarg][0] == '-' || argv[nextarg][0] == '/') {
            if (_tcsicmp(&argv[nextarg][1], A_LP_FLAG_LEVELID) == 0) {
				STACKMARK(0xAAAA000D);
				dwLevelId = _ttoi(argv[++nextarg]);
				fLevelIdSupplied = TRUE;
            } else if (_tcsicmp(&argv[nextarg][1], A_LP_FLAG_RULETYPES) == 0) {
				STACKMARK(0xAAAA000B);
				nextarg++;
				if (nextarg >= argc) {
					return DisplaySyntax();
				}
				//unknown rule types are ignored
				if (_tcscspn(argv[nextarg], A_LP_RULETYPES_PATH) < _tcslen(argv[nextarg])) {
					dwSuppliedCheckFlags = dwSuppliedCheckFlags | SAFER_CRITERIA_IMAGEPATH;
				} 
				if (_tcscspn(argv[nextarg], A_LP_RULETYPES_HASH) < _tcslen(argv[nextarg])) {
					dwSuppliedCheckFlags = dwSuppliedCheckFlags | SAFER_CRITERIA_IMAGEHASH;
				} 
				if (_tcscspn(argv[nextarg], A_LP_RULETYPES_CERTIFICATE) < _tcslen(argv[nextarg] )) {
					dwSuppliedCheckFlags = dwSuppliedCheckFlags | SAFER_CRITERIA_AUTHENTICODE;
				} 
            } else if (_tcsicmp(&argv[nextarg][1], A_LP_FLAG_SCOPE) == 0) {
				nextarg++;
				if (nextarg >= argc) {
					return DisplaySyntax();
				}
				STACKMARK(0xAAAA000F);
				if (_tcscspn(argv[nextarg], A_LP_SCOPE_HKLM) < _tcslen(argv[nextarg])) {
					dwScopeId = SAFER_SCOPEID_MACHINE;
				} else if (_tcscspn(argv[nextarg], A_LP_SCOPE_HKCU) < _tcslen(argv[nextarg])) {
					dwScopeId = SAFER_SCOPEID_USER;
				} else {
					return DisplaySyntax();
				}
            } else {
				return DisplaySyntax();
			}
        } else if (commandMode==CMD_RUN || commandMode == CMD_QUERY || commandMode == CMD_HASH) {
            LPTSTR fn;
			STACKMARK(0xAAAA000C);
			if (commandMode==CMD_RUN && !fLevelIdSupplied) {
				IDS_tprintf(IDS_ERR_NOLEVELID);	
				return DisplaySyntax();
			} 
            //
            // This argument is an explicitly named application exe.
            //
//            if (!GetFullPathName(argv[nextarg],
//                                 sizeof(appname) / sizeof(appname[0]),
//                                 appname, &fn) &&
			if (!SearchPath(NULL, argv[nextarg], NULL,
                             sizeof(appname) / sizeof(appname[0]),
                             appname, &fn)) {
				STACKMARK(0xAAAA000A);

                appname[0] = 0;
            } else {
				_tprintf(TEXT("Program to launch: %s\n"),appname);
			}

            if (commandMode == CMD_RUN) {
                //
                // All following arguments is the child's command line.
                //
                nextarg++;
				if (nextarg > argc) {
					return DisplaySyntax();
				}
                for (; nextarg < argc; nextarg++) {
                    if (_tcslen(cmdline) + _tcslen(argv[nextarg]) + 2 < sizeof(cmdline)) {
                        if (cmdline[0]) {
							_tcscat(cmdline, TEXT(" "));
						}
                        _tcscat(cmdline, argv[nextarg]);
                    } else {
                        IDS_tprintf(IDS_ERR_CMDLINETOOLONG);
                        return 0;
                    }
                }
                break;
            }
        } else {
            // Unknown garbage encountered at the end of the line.
            return DisplaySyntax();
        }
    }
	STACKMARK(0xAAAA0002);
    //
    // Application exe must always be specified for some cases.
    //
    if (commandMode == CMD_RUN || commandMode == CMD_QUERY || commandMode == CMD_HASH) {
        if (appname == NULL || appname[0] == '\0') {
            IDS_tprintf(IDS_ERR_NOAPPNAME);
            return DisplaySyntax();
        }
    }

	switch (commandMode) {
		case CMD_HASH:
			return ComputeHash(appname);
			break;
		case CMD_DUMPREG:
			return DumpRegistry();
			break;
		case CMD_REGKEY:
			return GetPathFromKeyKey(lpRegkey);
			break;
		case CMD_LIST:
		case CMD_LISTRULES:
			if (dwScopeId == -1) {
                _tprintf(TEXT("\n"));
                IDS_tprintf(IDS_LISTING_HKCU);
	   	    	retval = ListAllLevels(SAFER_SCOPEID_USER, commandMode == CMD_LISTRULES);
                _tprintf(TEXT("\n"));
                IDS_tprintf(IDS_LISTING_HKLM);
   		    	retval = ListAllLevels(SAFER_SCOPEID_MACHINE, commandMode == CMD_LISTRULES);
			} else {
   		    	retval = ListAllLevels(dwScopeId, commandMode == CMD_LISTRULES);
			}
			break;
		case CMD_QUERY:
			{
		        SAFER_CODE_PROPERTIES codeproperties;
				STACKMARK(0xAAAA0003);
			
		        ASSERT(appname != NULL);
		        // prepare the code properties struct.
		        memset(&codeproperties, 0, sizeof(codeproperties));
		        codeproperties.cbSize = sizeof(codeproperties);
		        codeproperties.dwCheckFlags = (!dwSuppliedCheckFlags) ? SAFER_CRITERIA_IMAGEPATH | SAFER_CRITERIA_IMAGEHASH | SAFER_CRITERIA_AUTHENTICODE : dwSuppliedCheckFlags;
		        codeproperties.ImagePath = appname;
		        codeproperties.dwWVTUIChoice = WTD_UI_ALL;  //ignored if SAFER_CRITERIA_AUTHENTICODE is not passed in
			
		        // Ask the system to find the authorization Level that classifies it.
		        if (!SaferIdentifyLevel(1, &codeproperties, &hAuthzLevel, NULL))
		        {
		            if (GetLastError() == ERROR_NOT_FOUND) {
		                IDS_tprintf(IDS_ERR_NOLEVELSFOUND);
		            } else {
		                printLastErrorWithIDSMessage(IDS_ERR_IMGACCESSERR);
					}
		            return 1;
		        }
		
				//print information about the rule that matched the program
				if (!PrintMatchingRule(hAuthzLevel)) {
					printLastErrorWithIDSMessage(IDS_ERR_ERRMATCHRULE);
					return 1;
				}	
		
	    		SaferCloseLevel(hAuthzLevel);
			}
			break;
		case CMD_RUN:
	        // Launch the process with the specified WinSafer Level restrictions.
			STACKMARK(0xAAAA0005);
			if (dwLevelId == SAFER_LEVELID_DISALLOWED) {
	            IDS_tprintf(IDS_ERR_PROCESSNOLAUNCH);
	            return 0;
			}  
			if (dwScopeId == -1) {
				dwScopeId  = SAFER_SCOPEID_USER;  //user didn't pass in a scope, so set it for them
			}
	        if (!SaferCreateLevel(dwScopeId, dwLevelId, SAFER_LEVEL_OPEN, &hAuthzLevel, NULL))
	        {
	            printLastError();
	            IDS_tprintf(IDS_ERR_LEVELOPENERR, dwLevelId);
	            return 1;
	        }
	        PrintLevelNameDescription(hAuthzLevel, FALSE);
			if (!CreateProcessRestricted(hAuthzLevel, appname, cmdline, &pi, useBreakMode)) {
	            if (useBreakMode) {
	                INPUT_RECORD inputrec;
	                DWORD dwNum;
	                IDS_tprintf(IDS_PROCSUSPENDED, pi.dwProcessId);
	                for (;;) {
	                    if (ReadConsoleInput(GetStdHandle(STD_INPUT_HANDLE),
	                                     &inputrec, 1, &dwNum) &&
	                        inputrec.EventType == KEY_EVENT &&
	                        inputrec.Event.KeyEvent.bKeyDown)
	                        break;
	                }
	                ResumeThread(pi.hThread);
	                IDS_tprintf(IDS_THREADRESUMED);
	            }
	
	            // Close the unnecessary handle
	            CloseHandle(pi.hThread);
	
	            // Wait for the process to terminate and then cleanup.
	            WaitForSingleObject(pi.hProcess, INFINITE);
	            CloseHandle(pi.hProcess);
	        } else {
    			printLastErrorWithIDSMessage(IDS_ERR_PROCESSLAUNCHERR);
			}
    		SaferCloseLevel(hAuthzLevel);

			break;
/*
		    // Compare or execute as appropriate.
		    if (commandMode == CMD_QUERY) {
		        // Compare the Authorization Level with the current access token.
		        DWORD dwResult;
		
		        if (!SaferComputeTokenFromLevel(
		                hAuthzLevel, NULL, NULL, AUTHZTOKEN_COMPARE_ONLY, (LPVOID) &dwResult))
		        {
		            _tprintf(TEXT("Authorization comparison failed (lasterror=%d)\n"), GetLastError());
		        } else if (dwResult != -1) {
		            _tprintf(TEXT("Authorization comparison equal or greater privileged.\n"), GetLastError());
		        } else {
		            _tprintf(TEXT("Authorization comparison less privileged.\n"), GetLastError());
		        }
		        return 0;
		    } else {
		        // Launch the process with the specified WinSafer Level restrictions.
		        ASSERT(commandMode == CMD_RUN);
		        if (!CreateProcessRestricted(hAuthzLevel, appname, cmdline, &pi, useBreakMode)) {
		            if (useBreakMode) {
		                INPUT_RECORD inputrec;
		                DWORD dwNum;
		                _tprintf(TEXT("Process %d launched and suspended.  Attach a debugger and then\n")
		                       TEXT("strike any key to resume the thread and allow debugging."),
		                       pi.dwProcessId);
		                for (;;) {
		                    if (ReadConsoleInput(GetStdHandle(STD_INPUT_HANDLE),
		                                     &inputrec, 1, &dwNum) &&
		                        inputrec.EventType == KEY_EVENT &&
		                        inputrec.Event.KeyEvent.bKeyDown)
		                        break;
		                }
		                ResumeThread(pi.hThread);
		                _tprintf(TEXT("Thread resumed.\n"));
		            }
		
		            // Close the unnecessary handle
		            CloseHandle(pi.hThread);
		
		            // Wait for the process to terminate and then cleanup.
		            WaitForSingleObject(pi.hProcess, INFINITE);
		            CloseHandle(pi.hProcess);
		
		            // close the Authorization Level handle.
		            SaferCloseLevel(hAuthzLevel);
		            retval = 0;
		        }
		    }
	    _tprintf(TEXT("Could not launch process (error=%d).\n"), GetLastError());
	    retval = 1;
*/	
	}
	if (A_LP_CMD_QUERY) LocalFree(A_LP_CMD_QUERY);
	if (A_LP_CMD_RUN) LocalFree(A_LP_CMD_RUN);
	if (A_LP_CMD_HASH) LocalFree(A_LP_CMD_HASH);
	if (A_LP_CMD_LIST) LocalFree(A_LP_CMD_LIST);
	if (A_LP_CMD_LISTRULES) LocalFree(A_LP_CMD_LISTRULES);
	if (A_LP_FLAG_LEVELID) LocalFree(A_LP_FLAG_LEVELID);
	if (A_LP_FLAG_RULETYPES) LocalFree(A_LP_FLAG_RULETYPES);
	if (A_LP_RULETYPES_PATH) LocalFree(A_LP_RULETYPES_PATH);
	if (A_LP_RULETYPES_HASH) LocalFree(A_LP_RULETYPES_HASH);
	if (A_LP_RULETYPES_CERTIFICATE) LocalFree(A_LP_RULETYPES_CERTIFICATE);

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\winsafer\test\saferbox\resource.h ===
//--------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       resource.h
//
//  Contents:   the resource header for saferbox.c
//
//  History:    25-Nov-00   johnla   created
//              
//--------------------------------------------------------------------------
//defintion for string IDS

#define MAX_USAGE_LEN 4096

#define		IDS_CMD_QUERY 					5001
#define		IDS_CMD_RUN						5002 
#define		IDS_CMD_HASH					5003
#define		IDS_CMD_LIST					5004
#define		IDS_CMD_LISTRULES				5005
#define		IDS_FLAG_LEVELID				5006
#define		IDS_FLAG_RULETYPES				5007
#define		IDS_RULETYPES_PATH				5008
#define		IDS_RULETYPES_HASH				5009
#define		IDS_RULETYPES_CERTIFICATE		5010
#define		IDS_USAGE_SYNTAX   				5011
#define 	IDS_FLAG_SCOPE					5034
#define		IDS_SCOPE_HKLM					5035
#define		IDS_SCOPE_HKCU					5036
#define		IDS_CMD_REGKEY 					5037
#define 	IDS_CMD_DUMPREG 				5038

#define		IDS_USINGDEFAULTRULE			5100
#define		IDS_MATCHPATH					5101
#define		IDS_MATCHHASH					5102
#define		IDS_MATCHZONE					5103
#define		IDS_MATCHCERTORDEFAULT			5104
#define		IDS_GUIDRULEIS					5105
#define		IDS_SECURITYLEVEL				5106
#define		IDS_SECURITYLEVELDESC			5107
#define		IDS_ERR_NOLEVELSFOUND			5108
#define		IDS_ERR_NOLEVELID				5109
#define		IDS_ERR_CMDLINETOOLONG  		5110
#define		IDS_ERR_NOAPPNAME				5111
#define		IDS_ERR_IMGACCESSERR			5112
#define		IDS_ERR_ERRMATCHRULE			5113
#define		IDS_ERR_PROCESSNOLAUNCH 		5114
#define		IDS_ERR_LEVELOPENERR			5115
#define		IDS_ERR_PROCESSLAUNCHERR		5116
#define		IDS_PROCSUSPENDED 	    		5117
#define		IDS_THREADRESUMED				5118
#define		IDS_ERR_GETVERERR				5119
#define		IDS_ERR_INCORRECTOSVER			5120
#define 	IDS_LISTING_HKCU				5121
#define 	IDS_LISTING_HKLM				5122
#define		IDS_NORULESFOUND				5123
#define 	IDS_DEFAULTLEVEL				5124
#define 	IDS_ERR_REGNOTFOUND				5125
#define 	IDS_ERR_NOREGVALUE				5126
#define 	IDS_REGVALUE					5127
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\winsafer\test\desktops\user.h ===
////////////////////////////////////////////////////////////////////////////////
//
// File:	User.h
// Created:	Jan 1996
// By:		Ryan Marshall (a-ryanm) and Martin Holladay (a-martih)
// 
// Project:	Resource Kit Desktop Switcher (MultiDesk)
//
//
////////////////////////////////////////////////////////////////////////////////

#ifndef __MULTIDESK_USER_H__
#define __MULTIDESK_USER_H__


BOOL CreateMainWindow();
BOOL CreateTransparentLabelWindow();
BOOL PlaceOnTaskbar(HWND hWnd);
BOOL RemoveFromTaskbar(HWND hWnd);
BOOL CloseRequestHandler(HWND hWnd);
void UpdateCurrentUI(HWND hWnd);
void HideOrRevealUI(HWND hWnd, BOOL bHide);
void RenameDialog(HWND hWnd, UINT nBtnIndex);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\winsafer\test\desktops\user.cpp ===
////////////////////////////////////////////////////////////////////////////////
//
// File:        User.cpp
// Created:        Feb 1996
// By:            Martin Holladay (a-martih) and Ryan D. Marshall (a-ryanm)
// 
// Project:    MultiDesk - The NT Desktop Switcher
//
//
//
// Revision History:
//
//            March 1997    - Add external icon capability
//                                     
////////////////////////////////////////////////////////////////////////////////


#include <windows.h>
#include <assert.h>
#include <shellapi.h>
#include <prsht.h>
#include <commctrl.h>
#include "Resource.h"
#include "DeskSpc.h"
#include "Desktop.h"
#include "User.h"
#include "Menu.h"
#include "CmdHand.h"

extern APPVARS AppMember;

/*------------------------------------------------------------------------------*/
/*                                                                              */
/*   Create the rectangular window that makes up the main user-interface.       */
/*                                                                              */
/*------------------------------------------------------------------------------*/

BOOL CreateMainWindow()
{
    HWND        hWnd, hWndListView; 
    DWORD       ThreadId;
    HIMAGELIST  hImgListSmall;
    UINT        ii;
    RECT        rect;

    // 
    // We had better have an instance of the app
    //
    assert(AppMember.hInstance != NULL);


    //
    // Create a main window for this application instance.
    //
    hWnd = CreateWindowEx(
            WS_EX_TOPMOST | WS_EX_DLGMODALFRAME | WS_EX_NOACTIVATE | WS_EX_TOOLWINDOW,
            AppMember.szAppName,
            AppMember.szAppTitle,
            WS_POPUPWINDOW | WS_DLGFRAME,
            AppMember.nX,
            AppMember.nY,
            AppMember.nWidth,
            AppMember.nHeight,
            NULL,
            NULL,
            AppMember.hInstance,
            NULL);

    //
    // If window could not be created, return FALSE
    //
    if (!hWnd)
    {
        return FALSE;
    }

    // 
    // Save the hWnd of the Window
    //
    ThreadId = GetCurrentThreadId();
    AppMember.pDesktopControl->SetThreadWindow(ThreadId, hWnd);


    //
    // Hide until we're supposed to be seen window
    //
    ShowWindow(hWnd, SW_HIDE);


    //
    // Create the child listview window to contain all of the icons.
    //
    GetClientRect(hWnd, &rect);
    AppMember.nWidth = rect.right;
    AppMember.nHeight = rect.bottom;
    hWndListView = CreateWindow(WC_LISTVIEW, NULL,
            WS_VISIBLE | WS_CHILDWINDOW | LVS_LIST | LVS_SINGLESEL |
            LVS_SHOWSELALWAYS | LVS_OWNERDATA,
            0, 0, AppMember.nWidth, AppMember.nHeight,
            hWnd, (HMENU) IDC_DESKTOPICONLIST, AppMember.hInstance, NULL);
    ListView_SetExtendedListViewStyle(hWndListView,
            LVS_EX_ONECLICKACTIVATE | LVS_EX_UNDERLINEHOT);

    //
    // Create an image list containing small icons and assign it.
    //
    hImgListSmall = ImageList_Create(16, 16, ILC_COLOR | ILC_MASK, NUM_BUILTIN_ICONS, 0);
    if (hImgListSmall != NULL)
    {
        for (ii = 0; ii < NUM_BUILTIN_ICONS; ii++)
            ImageList_AddIcon(hImgListSmall,
                AppMember.pDesktopControl->GetBuiltinIcon(ii));
        ListView_SetImageList(hWndListView, hImgListSmall, LVSIL_SMALL);
    }
    
    UpdateCurrentUI(hWnd);
    return TRUE;             
}

/*------------------------------------------------------------------------------*/
/*                                                                              */
/*   Make a cute little transparent layered window that displays some text      */
/*                                                                              */
/*------------------------------------------------------------------------------*/

BOOL CreateTransparentLabelWindow()
{
    HWND hWnd;
    DWORD ThreadId;
    UINT DesktopID;
    TCHAR szLabelText[MAX_NAME_LENGTH];

    // Get the saifer name
    ThreadId = GetCurrentThreadId();
    DesktopID = AppMember.pDesktopControl->GetThreadDesktopID(ThreadId);
    if (!AppMember.pDesktopControl->GetDesktopName(DesktopID, szLabelText, MAX_NAME_LENGTH) ||
        !lstrlen(szLabelText))
            lstrcpy(szLabelText, TEXT("Unknown desktop"));


    // Create the transparent window.
    hWnd = CreateWindowEx(
            WS_EX_TOPMOST | WS_EX_LAYERED | WS_EX_TRANSPARENT | WS_EX_NOACTIVATE,
            TRANSPARENT_CLASSNAME,
            szLabelText,
            WS_DISABLED | WS_VISIBLE | WS_POPUP,
            TRANSPARENT_POSITIONS,
            NULL,
            NULL,
            AppMember.hInstance,
            (LPVOID) NULL);

    if (hWnd != NULL)
    {
        SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0,
                    SWP_NOSIZE | SWP_NOREPOSITION | SWP_NOMOVE);
        SetLayeredWindowAttributes(hWnd, TRANSPARENT_BACKCOLOR,
                TRANSPARENT_ALPHA, LWA_COLORKEY | LWA_ALPHA);
        ShowWindow(hWnd, SW_SHOW);
            
        return TRUE;
    }
    return FALSE;
}

/*------------------------------------------------------------------------------*/
/*                                                                              */
/*   Add our little icon to the Task Bar Notification Area ("the Tray")         */
/*                                                                              */
/*------------------------------------------------------------------------------*/

BOOL PlaceOnTaskbar(HWND hWnd)
{
    NOTIFYICONDATA    NotifyIconData;

    //
    // Create the Icon on the Taskbar
    //
    ZeroMemory(&NotifyIconData, sizeof(NOTIFYICONDATA));
    NotifyIconData.cbSize = sizeof(NOTIFYICONDATA);
    NotifyIconData.hWnd = hWnd;
    NotifyIconData.uID = IDI_TASKBAR_ICON;
    NotifyIconData.uFlags = NIF_MESSAGE | NIF_TIP | NIF_ICON;
    NotifyIconData.uCallbackMessage = WM_TASKBAR;
    NotifyIconData.hIcon = AppMember.hTaskbarIcon;
    LoadString(AppMember.hInstance, IDS_TASKBAR_TIP, NotifyIconData.szTip, 64);
    if (!Shell_NotifyIcon(NIM_ADD, &NotifyIconData))
    {
        return FALSE;
    }
    AppMember.bTrayed = TRUE;
    return TRUE;
}

/*------------------------------------------------------------------------------*/
/*                                                                              */
/*   Remove the little icon from the Task Bar Notification Area ("the Tray")    */
/*                                                                              */
/*------------------------------------------------------------------------------*/

BOOL RemoveFromTaskbar(HWND hWnd)
{
    NOTIFYICONDATA    NotifyIconData;

    //
    // Remove the Icon from the Taskbar
    //
    ZeroMemory(&NotifyIconData, sizeof(NOTIFYICONDATA));
    NotifyIconData.cbSize = sizeof(NOTIFYICONDATA);
    NotifyIconData.hWnd = hWnd;
    NotifyIconData.uID = IDI_TASKBAR_ICON;
    if (!Shell_NotifyIcon(NIM_DELETE, &NotifyIconData))
    {
        return FALSE;
    }

    AppMember.bTrayed = FALSE;
    return TRUE;
}

/*------------------------------------------------------------------------------*/
/*                                                                              */
/*    Decided if the app should shut down                                       */
/*                                                                              */
/*------------------------------------------------------------------------------*/

BOOL CloseRequestHandler(HWND hWnd)
{
    BOOL        Shutdown = FALSE;
    TCHAR        szCaption[MAX_TITLELEN + 1];
    TCHAR        szText[MAX_MESSAGE];
    HWND        hMainWnd;
    UINT        rValue;

    //
    // Verify that user wishes to close the app.  We don't ask
    // the user for confirmation if there is only one desktop open.
    //

    if (AppMember.pDesktopControl->GetNumDesktops() > 1)
    {
        LoadString(AppMember.hInstance, IDS_CLOSE_CAPTION, szCaption, MAX_TITLELEN);
        LoadString(AppMember.hInstance, IDS_CLOSE_VERIFY, szText, MAX_MESSAGE);
        rValue = MessageBox(hWnd, szText, szCaption, MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OKCANCEL);
        if ((rValue == 0) || (rValue == IDCANCEL))
            Shutdown = FALSE;
        else 
            Shutdown = TRUE;
    }
    else
        Shutdown = TRUE;

    //
    // Get the window handle and send the Shutdown Message
    //
    if (Shutdown)
    {
        // Save any scheme changes made to the current desktop

        AppMember.pDesktopControl->SaveCurrentDesktopScheme();

        hMainWnd = AppMember.pDesktopControl->GetWindowDesktop(0);
        PostMessage(hMainWnd, WM_ENDSESSION, 0, 0); 
    }

    return Shutdown;
}



/*------------------------------------------------------------------------------*/
/*                                                                                */
/* Update UI for the current desktop (usually Add/Deletes cause change)            */
/*                                                                                */
/*------------------------------------------------------------------------------*/

void UpdateCurrentUI(HWND hWnd)
{    
    HWND hWndList = GetDlgItem(hWnd, IDC_DESKTOPICONLIST);
    if (hWndList != NULL)
    {
        ListView_SetItemCountEx(hWndList,
                AppMember.pDesktopControl->GetNumDesktops(), 0);
        for (UINT ii = 0; ii < AppMember.pDesktopControl->GetNumDesktops(); ii++)
        {
            if (ii == AppMember.pDesktopControl->GetActiveDesktop()) {
                ListView_SetItemState(hWndList, ii,
                    LVIS_FOCUSED | LVIS_SELECTED,
                    LVIS_FOCUSED | LVIS_SELECTED);
            } else {
                ListView_SetItemState(hWndList, ii,
                    LVIS_FOCUSED | LVIS_SELECTED, 0);
            }
        }
        ListView_RedrawItems(hWndList, 0,
                AppMember.pDesktopControl->GetNumDesktops() - 1);
    }
    InvalidateRect(hWnd, NULL, TRUE);
}


/*------------------------------------------------------------------------------*/
/*                                                                              */
/* Hide or show the UI for the current desktop            */
/*                                                                              */
/*------------------------------------------------------------------------------*/

void HideOrRevealUI(HWND hWnd, BOOL bHide)
{
    if (bHide)
    {
        #ifndef NOANIMATEDWINDOWS
        AnimateWindow(hWnd, 100, AW_HIDE | AW_HOR_POSITIVE | AW_VER_POSITIVE);
        #else
        ShowWindow(hWnd, SW_HIDE);
        #endif
    }
    else
    {
        #ifndef NOANIMATEDWINDOWS
        AnimateWindow(hWnd, 100, AW_HOR_NEGATIVE | AW_VER_NEGATIVE);
        #else
        ShowWindow(hWnd, SW_SHOW);
        #endif
    }
}

/*------------------------------------------------------------------------------*/
/*                                                                                */
/* Sets up and starts the RenameDialog within a Property Sheet                    */
/* The RenameDialog's messages are handled by CallBack in CmdHandlers.cpp        */
/*                                                                                */
/*------------------------------------------------------------------------------*/

void RenameDialog(HWND hWnd, UINT nBtnIndex)            // zero based
{
    PROPSHEETHEADER psh;
    PROPSHEETPAGE    pspRename;
    RENAMEINFO        sRenameInfo;
    TCHAR            szText[MAX_TITLELEN+1];
    TCHAR            szCaptionText[MAX_TITLELEN+1];
    TCHAR            szErrMsg[MAX_TITLELEN+1];

    assert(nBtnIndex >= 0 && nBtnIndex < AppMember.pDesktopControl->GetNumDesktops());
    sRenameInfo.nBtnIndex = nBtnIndex;
    
    //
    // Setup the Rename dialog page
    //
    pspRename.dwSize = sizeof(PROPSHEETPAGE);
    pspRename.dwFlags = PSP_USETITLE;
    pspRename.hInstance = AppMember.hInstance;
    pspRename.pszTemplate = MAKEINTRESOURCE(IDD_PROPERTIES);
    pspRename.pfnDlgProc = (DLGPROC) RenameDialogProc;
    pspRename.lParam = (LPARAM) &sRenameInfo;
    pspRename.pszTitle = MAKEINTRESOURCE(IDS_GENERAL);

    //
    // Setup the property sheet
    //
    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_PROPSHEETPAGE;
    psh.hwndParent = hWnd;
    psh.hInstance = AppMember.hInstance;
    LoadString(AppMember.hInstance, IDS_PROPS, szCaptionText, MAX_TITLELEN);
    psh.pszCaption = szCaptionText;
    psh.nPages = 1;
    psh.ppsp = (LPCPROPSHEETPAGE) &pspRename;

    //
    // Run the property sheet
    //
    if (PropertySheet(&psh) < 0) 
    {
        LoadString(AppMember.hInstance, IDS_RENDLG_ERR, szErrMsg, MAX_TITLELEN);
        Message(szErrMsg);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\accctrl2\src\aclapiex.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1996.
//
//  File:       ACLAPIEX.CXX
//
//  Contents:   Ex versions of the Access Control APIs
//
//  History:    14-Sep-96       MacM        Created
//
//----------------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop


//+---------------------------------------------------------------------------
//
//  Function:   GetNamedSecurityInfoExW
//
//  Synopsis:   Gets the specified security information from the indicated
//              object
//
//  Arguments:  [IN  lpObject]      --  Object for which the permissions are
//                                      needed
//              [IN  ObjectType]    --  Type of object specified by lpObject
//              [IN  SecurityInfo]  --  What is to be returned
//              [IN  lpProvider]    --  OPTIONAL If known, the provider to
//                                      handle the request.  If NULL, it will
//                                      be discovered
//              [IN  lpProperty]    --  OPTIONAL.  If present, the name of
//                                      property on the object to read from
//              [OUT ppAccessList]  --  Where the access list, if requested,
//                                      is returned.
//              [OUT ppAuditList]   --  Where the audit list, if requested,
//                                      is returned.
//              [OUT lppOwner]      --  Where the owners name, if requested,
//                                      is returned.
//              [OUT lppGroup]      --  Where the groups name, if requested,
//                                      is returned.
//              [OUT pOverlapped    --  OPTIONAL.  If present, it must point
//                                      to a valid ACTRL_OVERLAPPED structure
//                                      on input that will be filled in by
//                                      the API.  This is an indication that
//                                      the API is to be asynchronous.  If the
//                                      parameter is NULL, than the API will
//                                      be performed synchronously.
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD
WINAPI
GetNamedSecurityInfoExW(IN   LPCWSTR                lpObject,
                        IN   SE_OBJECT_TYPE         ObjectType,
                        IN   SECURITY_INFORMATION   SecurityInfo,
                        IN   LPCWSTR                lpProvider,
                        IN   LPCWSTR                lpProperty,
                        OUT  PACTRL_ACCESSW        *ppAccessList,
                        OUT  PACTRL_AUDITW         *ppAuditList,
                        OUT  LPWSTR                *lppOwner,
                        OUT  LPWSTR                *lppGroup)
{
    DWORD   dwErr = ERROR_SUCCESS;

    LOAD_PROVIDERS(dwErr);

    //
    // First, verify the parameters.  The providers expect valid parameters
    //
    if(lpObject == NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        //
        // Verify that we have the proper parameters for our SecurityInfo
        //
        if(FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION) &&
                                                        ppAccessList == NULL)
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }

        if(FLAG_ON(SecurityInfo, SACL_SECURITY_INFORMATION) &&
                                                        ppAuditList == NULL)
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }

        if(FLAG_ON(SecurityInfo, GROUP_SECURITY_INFORMATION) &&
                                                        lppGroup == NULL)
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }

        if(FLAG_ON(SecurityInfo, OWNER_SECURITY_INFORMATION) &&
                                                        lppOwner == NULL)
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }
    }

    //
    // If we have valid parameters, go do it...
    //
    if(dwErr == ERROR_SUCCESS)
    {
        //
        //
        // Find the provider
        //
        PACCPROV_PROV_INFO pProvider;

        dwErr = AccProvpGetProviderForPath(lpObject,
                                           ObjectType,
                                           lpProvider,
                                           &gAccProviders,
                                           &pProvider);

        if(dwErr == ERROR_SUCCESS)
        {
            //
            // Make the call
            //
            PTRUSTEE            pOwner, pGroup;
            __try
            {
                dwErr = (*(pProvider->pfGetRights))(
                                    lpObject,
                                    ObjectType,
                                    lpProperty,
                                    FLAG_ON(SecurityInfo,
                                            DACL_SECURITY_INFORMATION) ?
                                                    ppAccessList :
                                                    NULL,
                                    FLAG_ON(SecurityInfo,
                                            SACL_SECURITY_INFORMATION) ?
                                                    ppAuditList :
                                                    NULL,
                                    FLAG_ON(SecurityInfo,
                                            OWNER_SECURITY_INFORMATION) ?
                                                    &pOwner :
                                                    NULL,
                                    FLAG_ON(SecurityInfo,
                                            GROUP_SECURITY_INFORMATION) ?
                                                    &pGroup :
                                                    NULL);

            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                if(pProvider->pfGetRights == NULL)
                {
                    dwErr = ERROR_BAD_PROVIDER;
                }
                else
                {
                    dwErr = RtlNtStatusToDosError(GetExceptionCode());
                }
            }

            if(dwErr == ERROR_SUCCESS)
            {
                //
                // Save off our owner/group names, and free the memory
                //
                if(FLAG_ON(SecurityInfo, OWNER_SECURITY_INFORMATION))
                {
                    ACC_ALLOC_AND_COPY_STRINGW(pOwner->ptstrName,
                                               *lppOwner,
                                               dwErr);
                    AccFree(pOwner);
                }

                if(FLAG_ON(SecurityInfo, GROUP_SECURITY_INFORMATION))
                {
                    if(dwErr == ERROR_SUCCESS)
                    {
                        ACC_ALLOC_AND_COPY_STRINGW(pGroup->ptstrName,
                                                   *lppGroup,
                                                   dwErr);
                    }
                    AccFree(pGroup);
                }
            }
        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   GetNamedSecurityInfoExA
//
//  Synopsis:   Same as above, except ANSI version
//
//  Arguments:  [IN  lpObject]      --  Object for which the permissions are
//                                      needed
//              [IN  ObjectType]    --  Type of object specified by lpObject
//              [IN  SecurityInfo]  --  What is to be returned
//              [IN  lpProvider]    --  OPTIONAL If known, the provider to
//                                      handle the request.  If NULL, it will
//                                      be discovered
//              [IN  lpProperty]    --  OPTIONAL.  If present, the name of
//                                      property on the object to read from
//              [OUT ppAccessList]  --  Where the access list, if requested,
//                                      is returned.
//              [OUT ppAuditList]   --  Where the audit list, if requested,
//                                      is returned.
//              [OUT lppOwner]      --  Where the owners name, if requested,
//                                      is returned.
//              [OUT lppGroup]      --  Where the groups name, if requested,
//                                      is returned.
//              [OUT pOverlapped    --  OPTIONAL.  If present, it must point
//                                      to a valid ACTRL_OVERLAPPED structure
//                                      on input that will be filled in by
//                                      the API.  This is an indication that
//                                      the API is to be asynchronous.  If the
//                                      parameter is NULL, than the API will
//                                      be performed synchronously.
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD
WINAPI
GetNamedSecurityInfoExA(IN   LPCSTR                lpObject,
                        IN   SE_OBJECT_TYPE        ObjectType,
                        IN   SECURITY_INFORMATION  SecurityInfo,
                        IN   LPCSTR                lpProvider,
                        IN   LPCSTR                lpProperty,
                        OUT  PACTRL_ACCESSA       *ppAccessList,
                        OUT  PACTRL_AUDITA        *ppAuditList,
                        OUT  LPSTR                *lppOwner,
                        OUT  LPSTR                *lppGroup)
{
    DWORD   dwErr = ERROR_SUCCESS;

    LOAD_PROVIDERS(dwErr);

    PWSTR   pwszObject;
    PWSTR   pwszProvider = NULL;
    PWSTR   pwszProperty = NULL;


    dwErr = ConvertStringAToStringW((PSTR)lpObject,
                                    &pwszObject);
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = ConvertStringAToStringW((PSTR)lpProvider,
                                        &pwszProvider);

        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = ConvertStringAToStringW((PSTR)lpProperty,
                                            &pwszProperty);
        }
    }


    //
    // Do the call...
    //
    if(dwErr == ERROR_SUCCESS)
    {
        PWSTR   pwszOwner = NULL, pwszGroup = NULL;
        PACTRL_ACCESSW  pAccessListW = NULL;
        PACTRL_AUDITW   pAuditListW = NULL;
        dwErr = GetNamedSecurityInfoExW((PCWSTR)pwszObject,
                                        ObjectType,
                                        SecurityInfo,
                                        (PCWSTR)pwszProvider,
                                        (PCWSTR)pwszProperty,
                                        ppAccessList == NULL ?
                                                            NULL  :
                                                            &pAccessListW,
                                        ppAuditList == NULL  ?
                                                            NULL  :
                                                            &pAuditListW,
                                        lppOwner == NULL ?
                                                        NULL  :
                                                        &pwszOwner,
                                        lppGroup == NULL ?
                                                        NULL  :
                                                        &pwszGroup);
        if(dwErr == ERROR_SUCCESS)
        {
            //
            // See if we have to convert any of the returned owners or groups
            //
            if(FLAG_ON(SecurityInfo, OWNER_SECURITY_INFORMATION))
            {
                dwErr = ConvertStringWToStringA(pwszOwner,
                                                lppOwner);
            }

            if(FLAG_ON(SecurityInfo, GROUP_SECURITY_INFORMATION) &&
                                                      dwErr == ERROR_SUCCESS)
            {
                dwErr = ConvertStringWToStringA(pwszGroup,
                                                lppGroup);
            }

            if(FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION) &&
                                                     dwErr == ERROR_SUCCESS)
            {
                dwErr = ConvertAListWToAlistAInplace(pAccessListW);
                if(dwErr == ERROR_SUCCESS)
                {
                    *ppAccessList = (PACTRL_AUDITA)pAccessListW;
                }
            }

            if(FLAG_ON(SecurityInfo, SACL_SECURITY_INFORMATION) &&
                                                     dwErr == ERROR_SUCCESS)
            {
                dwErr = ConvertAListWToAlistAInplace(pAuditListW);
                if(dwErr == ERROR_SUCCESS)
                {
                    *ppAuditList = (PACTRL_AUDITA)pAuditListW;
                }
            }

            //
            // If something failed, make sure we deallocate any information
            //
            if(dwErr != ERROR_SUCCESS)
            {
                if(FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION))
                {
                    LocalFree(*ppAccessList);
                    LocalFree(pAccessListW);
                }

                if(FLAG_ON(SecurityInfo, SACL_SECURITY_INFORMATION))
                {
                    LocalFree(*ppAuditList);
                    LocalFree(pAuditListW);
                }

                if(FLAG_ON(SecurityInfo, GROUP_SECURITY_INFORMATION))
                {
                    LocalFree(*lppGroup);
                    LocalFree(pwszGroup);
                }

                if(FLAG_ON(SecurityInfo, OWNER_SECURITY_INFORMATION))
                {
                    LocalFree(*lppOwner);
                    LocalFree(pwszOwner);
                }
            }
        }
    }
    //
    // Free our allocated strings...
    //
    LocalFree(pwszObject);
    LocalFree(pwszProvider);
    LocalFree(pwszProperty);

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   SetNamedSecurityInfoExW
//
//  Synopsis:   Sets the specified security information from the indicated
//              object
//
//  Arguments:  [IN  lpObject]      --  Object for which the permissions are
//                                      needed
//              [IN  ObjectType]    --  Type of object specified by lpObject
//              [IN  SecurityInfo]  --  What is to be set
//              [IN  lpProvider]    --  OPTIONAL If known, the provider to
//                                      handle the request.  If NULL, it will
//                                      be discovered
//              [OUT pAccessList]   --  OPTIONAL  The access list to set
//              [OUT pAuditList]    --  OPTIONAL  The audit list to set
//              [OUT lppOwner]      --  OPTIONAL  The owner to set
//              [OUT lppGroup]      --  OPTIONAL  The group name to set
//              [OUT pOverlapped    --  OPTIONAL  If present, it must point
//                                      to a valid ACTRL_OVERLAPPED structure
//                                      on input that will be filled in by
//                                      the API.  This is an indication that
//                                      the API is to be asynchronous.  If the
//                                      parameter is NULL, than the API will
//                                      be performed synchronously.
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD
WINAPI
SetNamedSecurityInfoExW(IN    LPCWSTR                lpObject,
                        IN    SE_OBJECT_TYPE         ObjectType,
                        IN    SECURITY_INFORMATION   SecurityInfo,
                        IN    LPCWSTR                lpProvider,
                        IN    PACTRL_ACCESSW         pAccessList,
                        IN    PACTRL_AUDITW          pAuditList,
                        IN    LPWSTR                 lpOwner,
                        IN    LPWSTR                 lpGroup,
                        IN    PACTRL_OVERLAPPED      pOverlapped)
{
    DWORD   dwErr = ERROR_SUCCESS;

    LOAD_PROVIDERS(dwErr);

    //
    // First, verify the parameters.  The providers expect valid parameters
    //
    if(lpObject == NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        //
        // Verify that we have the proper parameters for our SecurityInfo
        //
        if(FLAG_ON(SecurityInfo, GROUP_SECURITY_INFORMATION) &&
                                                        lpGroup == NULL)
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }

        if(FLAG_ON(SecurityInfo, OWNER_SECURITY_INFORMATION) &&
                                                        lpOwner == NULL)
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }
    }

    //
    // If we have valid parameters, go do it...
    //
    if(dwErr == ERROR_SUCCESS)
    {
        CSList  ChangedList(CleanupConvertNode);

        //
        //
        // Find the provider
        //
        PACCPROV_PROV_INFO pProvider;

        dwErr = AccProvpGetProviderForPath(lpObject,
                                           ObjectType,
                                           lpProvider,
                                           &gAccProviders,
                                           &pProvider);

        if(dwErr == ERROR_SUCCESS)
        {
            //
            // Change our access lists if necessary.  This means that
            // we'll go through and change any SIDS to names.  The way the
            // conversion works is that if a node needs to have it's
            // trustee name changed, the address of the trustee's name,
            // and its old value are saved off in ChangedList.  Then, when
            // the list is destructed, it goes through and deletes the
            // current trustee name (gotten through the saved address)
            // and restores the old sid
            //
            if(!FLAG_ON(pProvider->fProviderCaps,ACTRL_CAP_KNOWS_SIDS) &&
               FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION))
            {
                dwErr = ConvertAListToNamedBasedW(pAccessList,
                                                  ChangedList);
            }

            if(dwErr == ERROR_SUCCESS &&
               !FLAG_ON(pProvider->fProviderCaps,ACTRL_CAP_KNOWS_SIDS) &&
               FLAG_ON(SecurityInfo, SACL_SECURITY_INFORMATION))
            {
                dwErr = ConvertAListToNamedBasedW(pAuditList,
                                                  ChangedList);
            }

            if(dwErr == ERROR_SUCCESS)
            {
                //
                // Check for the caller wanting a synchronous call...
                //
                ACTRL_OVERLAPPED    LocalOverlapped;
                PACTRL_OVERLAPPED   pActiveOverlapped = pOverlapped;

                if(pActiveOverlapped == NULL)
                {
                    pActiveOverlapped = &LocalOverlapped;
                }

                TRUSTEE_W   Group = {0};
                TRUSTEE_W   Owner = {0};
                PTRUSTEE    pGroup = NULL;
                PTRUSTEE    pOwner = NULL;

                if(FLAG_ON(SecurityInfo,GROUP_SECURITY_INFORMATION))
                {
                    pGroup = &Group;
                    BuildTrusteeWithName(pGroup,
                                         lpGroup);
                }

                if(FLAG_ON(SecurityInfo,OWNER_SECURITY_INFORMATION))
                {
                    pOwner = &Owner;
                    BuildTrusteeWithName(pOwner,
                                         lpOwner);
                }

                //
                // Set up the overlapped structure
                //
                memset(pActiveOverlapped, 0, sizeof(ACTRL_OVERLAPPED));
                pActiveOverlapped->hEvent = CreateEvent(NULL,
                                                        TRUE,
                                                        FALSE,
                                                        NULL);
                pActiveOverlapped->Provider = pProvider;
                if(pActiveOverlapped->hEvent == NULL)
                {
                    dwErr = GetLastError();
                }
                else
                {
                    //
                    // Make the call
                    //
                    __try
                    {
                        dwErr = (*(pProvider->pfSetAccess))(
                                                       lpObject,
                                                       ObjectType,
                                                       SecurityInfo,
                                                       pAccessList,
                                                       pAuditList,
                                                       pOwner,
                                                       pGroup,
                                                       pActiveOverlapped);
                    }
                    __except(EXCEPTION_EXECUTE_HANDLER)
                    {
                        if(pProvider->pfSetAccess == NULL)
                        {
                            dwErr = ERROR_BAD_PROVIDER;
                        }
                        else
                        {
                            dwErr = RtlNtStatusToDosError(GetExceptionCode());
                        }
                    }

                    if(dwErr != ERROR_SUCCESS)
                    {
                        CloseHandle(pActiveOverlapped->hEvent);
                    }

                }

                if(dwErr == ERROR_SUCCESS)
                {
                    //
                    // See if we're supposed to do this synchronously
                    //
                    if(pActiveOverlapped != pOverlapped)
                    {
                        DWORD   dwRet;
                        dwErr  = GetOverlappedAccessResults(
                                                        pActiveOverlapped,
                                                        TRUE,
                                                        &dwRet,
                                                        NULL);
                        if(dwErr == ERROR_SUCCESS)
                        {
                            dwErr = dwRet;
                        }
                    }
                }
            }
        }
    }

    return(dwErr);
}





//+---------------------------------------------------------------------------
//
//  Function:   SetNamedSecurityInfoExA
//
//  Synopsis:   Same as above, but an ANSI version
//
//  Arguments:  [IN  lpObject]      --  Object for which the permissions are
//                                      needed
//              [IN  ObjectType]    --  Type of object specified by lpObject
//              [IN  SecurityInfo]  --  What is to be set
//              [IN  lpProvider]    --  OPTIONAL If known, the provider to
//                                      handle the request.  If NULL, it will
//                                      be discovered
//              [OUT pAccessList]   --  OPTIONAL  The access list to set
//              [OUT pAuditList]    --  OPTIONAL  The audit list to set
//              [OUT lppOwner]      --  OPTIONAL  The owner to set
//              [OUT lppGroup]      --  OPTIONAL  The group name to set
//              [OUT pOverlapped    --  OPTIONAL  If present, it must point
//                                      to a valid ACTRL_OVERLAPPED structure
//                                      on input that will be filled in by
//                                      the API.  This is an indication that
//                                      the API is to be asynchronous.  If the
//                                      parameter is NULL, than the API will
//                                      be performed synchronously.
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//
//  Notes:      This is not a simple matter of converting a few strings/etc
//              and calling the Unicode version, since that would involve
//              processing the list twice.  Yuk.  So, we go ahead and do the
//              the conversion and update of our input structures, and make
//              the call ourselves...
//
//----------------------------------------------------------------------------
DWORD
WINAPI
SetNamedSecurityInfoExA(IN    LPCSTR                 lpObject,
                        IN    SE_OBJECT_TYPE         ObjectType,
                        IN    SECURITY_INFORMATION   SecurityInfo,
                        IN    LPCSTR                 lpProvider,
                        IN    PACTRL_ACCESSA         pAccessList,
                        IN    PACTRL_AUDITA          pAuditList,
                        IN    LPSTR                  lpOwner,
                        IN    LPSTR                  lpGroup,
                        IN    PACTRL_OVERLAPPED      pOverlapped)
{
    DWORD   dwErr = ERROR_SUCCESS;

    LOAD_PROVIDERS(dwErr);

    //
    // First, verify the parameters.  The providers expect valid parameters
    //
    if(lpObject == NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        //
        // Verify that we have the proper parameters for our SecurityInfo
        //
        if(((SecurityInfo) & (GROUP_SECURITY_INFORMATION)) &&
                                                        lpGroup == NULL)
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }

        if(FLAG_ON(SecurityInfo, OWNER_SECURITY_INFORMATION) &&
                                                        lpOwner == NULL)
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }
    }

    //
    // If we have valid parameters, go do it...
    //
    if(dwErr == ERROR_SUCCESS)
    {
        CSList  ChangedList(CleanupConvertNode);

        PWSTR   pwszObject;
        PWSTR   pwszProvider = NULL;

        dwErr = ConvertStringAToStringW((PSTR)lpObject,
                                        &pwszObject);
        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = ConvertStringAToStringW((PSTR)lpProvider,
                                            &pwszProvider);
        }

        //
        // Find the provider
        //
        PACCPROV_PROV_INFO pProvider;

        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = AccProvpGetProviderForPath(pwszObject,
                                               ObjectType,
                                               pwszProvider,
                                               &gAccProviders,
                                               &pProvider);
        }

        if(dwErr == ERROR_SUCCESS)
        {
            PACTRL_ACCESSW  pAccessW = NULL;
            PACTRL_ACCESSW  pAuditW  = NULL;

            //
            // Change our access lists if necessary.  This means that
            // we'll go through and change any SIDS to names, and all
            // ansi strings to unicode strings.  This works exactly
            // as described in SetNamedSecurityInfoExW, with the
            // exception that we don't deal exclusively with trustee
            // names, but also property names and inherit object names
            //
            BOOL    fConvertSids = (BOOL)!FLAG_ON(pProvider->fProviderCaps,
                                                  ACTRL_CAP_KNOWS_SIDS) ;
            if(FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION))
            {
                dwErr = ConvertAListAToNamedBasedW(pAccessList,
                                                   ChangedList,
                                                   fConvertSids,
                                                   &pAccessW);
            }

            if(dwErr == ERROR_SUCCESS &&
               FLAG_ON(SecurityInfo, SACL_SECURITY_INFORMATION))
            {
                dwErr = ConvertAListAToNamedBasedW(pAuditList,
                                                   ChangedList,
                                                   fConvertSids,
                                                   &pAuditW);
            }

            if(dwErr == ERROR_SUCCESS)
            {
                //
                // Check for the caller wanting a synchronous call...
                //
                ACTRL_OVERLAPPED    LocalOverlapped;
                PACTRL_OVERLAPPED   pActiveOverlapped = pOverlapped;

                if(pActiveOverlapped == NULL)
                {
                    pActiveOverlapped = &LocalOverlapped;
                }

                TRUSTEE_W   Group = {0};
                TRUSTEE_W   Owner = {0};
                PTRUSTEE    pGroup = NULL;
                PTRUSTEE    pOwner = NULL;

                if(FLAG_ON(SecurityInfo,GROUP_SECURITY_INFORMATION))
                {
                    pGroup = &Group;
                    PWSTR   pwszGroup = NULL;
                    dwErr = ConvertStringAToStringW(lpGroup,
                                                    &pwszGroup);
                    if(dwErr == ERROR_SUCCESS)
                    {
                        BuildTrusteeWithName(pGroup,
                                             pwszGroup);
                    }
                }

                if(dwErr == ERROR_SUCCESS &&
                   FLAG_ON(SecurityInfo,OWNER_SECURITY_INFORMATION))
                {
                    pOwner = &Owner;
                    PWSTR   pwszOwner = NULL;
                    dwErr = ConvertStringAToStringW(lpOwner,
                                                    &pwszOwner);
                    if(dwErr == ERROR_SUCCESS)
                    {
                        BuildTrusteeWithName(pOwner,
                                             pwszOwner);
                    }
                }

                if(dwErr == ERROR_SUCCESS)
                {
                    //
                    // Set up the overlapped structure
                    //
                    memset(pActiveOverlapped, 0, sizeof(ACTRL_OVERLAPPED));
                    pActiveOverlapped->Provider = pProvider;
                    pActiveOverlapped->hEvent = CreateEvent(NULL,
                                                            TRUE,
                                                            FALSE,
                                                            NULL);
                    if(pActiveOverlapped->hEvent == NULL)
                    {
                        dwErr = GetLastError();
                    }
                    else
                    {
                        //
                        // Make the call
                        //
                        __try
                        {
                            dwErr = (*(pProvider->pfSetAccess))(
                                                       pwszObject,
                                                       ObjectType,
                                                       SecurityInfo,
                                                       pAccessW,
                                                       pAuditW,
                                                       pOwner,
                                                       pGroup,
                                                       pActiveOverlapped);
                        }
                        __except(EXCEPTION_EXECUTE_HANDLER)
                        {
                            if(pProvider->pfSetAccess == NULL)
                            {
                                dwErr = ERROR_BAD_PROVIDER;
                            }
                            else
                            {
                                dwErr = RtlNtStatusToDosError(GetExceptionCode());
                            }
                        }

                        if(dwErr != ERROR_SUCCESS)
                        {
                            CloseHandle(pActiveOverlapped->hEvent);
                        }

                    }

                    if(dwErr == ERROR_SUCCESS)
                    {
                        //
                        // See if we're supposed to do this synchronously
                        //
                        if(pActiveOverlapped != pOverlapped)
                        {
                            DWORD   dwRet;
                            dwErr  = GetOverlappedAccessResults(
                                                        pActiveOverlapped,
                                                        TRUE,
                                                        &dwRet,
                                                        NULL);
                            if(dwErr == ERROR_SUCCESS)
                            {
                                dwErr = dwRet;
                            }
                        }
                    }
                }

                //
                // Free our allocated memory
                //
                if(pOwner != NULL)
                {
                    LocalFree(pOwner->ptstrName);
                }

                if(pGroup != NULL)
                {
                    LocalFree(pGroup->ptstrName);
                }
            }
        }

        //
        // Free our allocated strings...
        //
        LocalFree(pwszObject);
        LocalFree(pwszProvider);
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   GetSecurityInfoExW
//
//  Synopsis:   Gets the specified security information from the indicated
//              object
//
//  Arguments:  [IN  hObject]       --  Object for which the permissions are
//                                      needed
//              [IN  ObjectType]    --  Type of object specified by lpObject
//              [IN  SecurityInfo]  --  What is to be returned
//              [IN  lpProvider]    --  OPTIONAL If known, the provider to
//                                      handle the request.  If NULL, it will
//                                      be discovered
//              [IN  lpProperty]    --  OPTIONAL.  If present, the name of
//                                      property on the object to read from
//              [OUT ppAccessList]  --  Where the access list, if requested,
//                                      is returned.
//              [OUT ppAuditList]   --  Where the audit list, if requested,
//                                      is returned.
//              [OUT lppOwner]      --  Where the owners name, if requested,
//                                      is returned.
//              [OUT lppGroup]      --  Where the groups name, if requested,
//                                      is returned.
//              [OUT pOverlapped    --  OPTIONAL.  If present, it must point
//                                      to a valid ACTRL_OVERLAPPED structure
//                                      on input that will be filled in by
//                                      the API.  This is an indication that
//                                      the API is to be asynchronous.  If the
//                                      parameter is NULL, than the API will
//                                      be performed synchronously.
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//              ERROR_INVALID_HANDLE    A bad handle was encountered
//
//----------------------------------------------------------------------------
DWORD
WINAPI
GetSecurityInfoExW(IN    HANDLE                  hObject,
                   IN    SE_OBJECT_TYPE          ObjectType,
                   IN    SECURITY_INFORMATION    SecurityInfo,
                   IN    LPCWSTR                lpProvider,
                   IN    LPCWSTR                lpProperty,
                   OUT   PACTRL_ACCESSW         *ppAccessList,
                   OUT   PACTRL_AUDITW          *ppAuditList,
                   OUT   LPWSTR                 *lppOwner,
                   OUT   LPWSTR                 *lppGroup)
{
    DWORD   dwErr = ERROR_SUCCESS;

    LOAD_PROVIDERS(dwErr);

    //
    // First, verify the parameters.  The providers expect valid parameters
    //
    if(hObject == NULL)
    {
        dwErr = ERROR_INVALID_HANDLE;
    }
    else
    {
        //
        // Verify that we have the proper parameters for our SecurityInfo
        //
        if(FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION) &&
                                                        ppAccessList == NULL)
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }

        if(FLAG_ON(SecurityInfo, SACL_SECURITY_INFORMATION) &&
                                                        ppAuditList == NULL)
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }

        if(FLAG_ON(SecurityInfo, GROUP_SECURITY_INFORMATION) &&
                                                        lppGroup == NULL)
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }

        if(FLAG_ON(SecurityInfo, OWNER_SECURITY_INFORMATION) &&
                                                        lppOwner == NULL)
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }
    }

    //
    // If we have valid parameters, go do it...
    //
    if(dwErr == ERROR_SUCCESS)
    {
        //
        //
        // Find the provider
        //
        PACCPROV_PROV_INFO pProvider;

        dwErr = AccProvpGetProviderForHandle(hObject,
                                             ObjectType,
                                             lpProvider,
                                             &gAccProviders,
                                             &pProvider);

        if(dwErr == ERROR_SUCCESS)
        {
            //
            // Make the call
            //
            PTRUSTEE            pOwner, pGroup;
            __try
            {
                dwErr = (*(pProvider->pfhGetRights))(
                                    hObject,
                                    ObjectType,
                                    lpProperty,
                                    FLAG_ON(SecurityInfo,
                                            DACL_SECURITY_INFORMATION) ?
                                                     ppAccessList :
                                                     NULL,
                                    FLAG_ON(SecurityInfo,
                                            SACL_SECURITY_INFORMATION) ?
                                                     ppAuditList :
                                                     NULL,
                                    FLAG_ON(SecurityInfo,
                                            OWNER_SECURITY_INFORMATION) ?
                                                     &pOwner :
                                                     NULL,
                                    FLAG_ON(SecurityInfo,
                                            GROUP_SECURITY_INFORMATION) ?
                                                     &pGroup :
                                                     NULL);
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                if(pProvider->pfhGetRights == NULL)
                {
                    dwErr = ERROR_BAD_PROVIDER;
                }
                else
                {
                    dwErr = RtlNtStatusToDosError(GetExceptionCode());
                }
            }

            if(dwErr == ERROR_SUCCESS)
            {
                //
                // Save off our owner/group names, and deallocate the memory
                //
                if(FLAG_ON(SecurityInfo, OWNER_SECURITY_INFORMATION))
                {
                    ACC_ALLOC_AND_COPY_STRINGW(pOwner->ptstrName,
                                               *lppOwner,
                                               dwErr);
                    AccFree(pOwner);
                }

                if(FLAG_ON(SecurityInfo, GROUP_SECURITY_INFORMATION))
                {
                    if(dwErr == ERROR_SUCCESS)
                    {
                        ACC_ALLOC_AND_COPY_STRINGW(pGroup->ptstrName,
                                                   *lppGroup,
                                                   dwErr);
                    }
                    AccFree(pGroup);
                }

            }
        }
    }


    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   GetSecurityInfoExA
//
//  Synopsis:   Same as above, except ANSI version
//
//  Arguments:  [IN  hObject]       --  Object for which the permissions are
//                                      needed
//              [IN  ObjectType]    --  Type of object specified by lpObject
//              [IN  SecurityInfo]  --  What is to be returned
//              [IN  lpProvider]    --  OPTIONAL If known, the provider to
//                                      handle the request.  If NULL, it will
//                                      be discovered
//              [IN  lpProperty]    --  OPTIONAL.  If present, the name of
//                                      property on the object to read from
//              [OUT ppAccessList]  --  Where the access list, if requested,
//                                      is returned.
//              [OUT ppAuditList]   --  Where the audit list, if requested,
//                                      is returned.
//              [OUT lppOwner]      --  Where the owners name, if requested,
//                                      is returned.
//              [OUT lppGroup]      --  Where the groups name, if requested,
//                                      is returned.
//              [OUT pOverlapped    --  OPTIONAL.  If present, it must point
//                                      to a valid ACTRL_OVERLAPPED structure
//                                      on input that will be filled in by
//                                      the API.  This is an indication that
//                                      the API is to be asynchronous.  If the
//                                      parameter is NULL, than the API will
//                                      be performed synchronously.
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD
WINAPI
GetSecurityInfoExA(IN    HANDLE                  hObject,
                   IN    SE_OBJECT_TYPE          ObjectType,
                   IN    SECURITY_INFORMATION    SecurityInfo,
                   IN    LPCSTR                  lpProvider,
                   IN    LPCSTR                  lpProperty,
                   OUT   PACTRL_ACCESSA         *ppAccessList,
                   OUT   PACTRL_AUDITA          *ppAuditList,
                   OUT   LPSTR                  *lppOwner,
                   OUT   LPSTR                  *lppGroup)
{
    DWORD   dwErr = ERROR_SUCCESS;

    LOAD_PROVIDERS(dwErr);

    PWSTR   pwszProvider = NULL;
    PWSTR   pwszProperty = NULL;

    dwErr = ConvertStringAToStringW((PSTR)lpProvider,
                                    &pwszProvider);

    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = ConvertStringAToStringW((PSTR)lpProperty,
                                        &pwszProperty);
    }

    //
    // Do the call...
    //
    if(dwErr == ERROR_SUCCESS)
    {
        PWSTR   pwszOwner = NULL, pwszGroup = NULL;
        PACTRL_ACCESSW  pAccessListW = NULL;
        PACTRL_AUDITW   pAuditListW = NULL;
        dwErr = GetSecurityInfoExW(hObject,
                                   ObjectType,
                                   SecurityInfo,
                                   (PCWSTR)pwszProvider,
                                   (PCWSTR)pwszProperty,
                                   ppAccessList == NULL ?
                                                       NULL  :
                                                       &pAccessListW,
                                   ppAuditList == NULL  ?
                                                       NULL  :
                                                       &pAuditListW,
                                   lppOwner == NULL ?
                                                   NULL  :
                                                   &pwszOwner,
                                   lppGroup == NULL ?
                                                   NULL  :
                                                   &pwszGroup);
        if(dwErr == ERROR_SUCCESS)
        {
            //
            // See if we have to convert any of the returned owners or groups
            //
            if(FLAG_ON(SecurityInfo, OWNER_SECURITY_INFORMATION))
            {
                dwErr = ConvertStringWToStringA(pwszOwner,
                                                lppOwner);
            }

            if(FLAG_ON(SecurityInfo, GROUP_SECURITY_INFORMATION) &&
                                                      dwErr == ERROR_SUCCESS)
            {
                dwErr = ConvertStringWToStringA(pwszGroup,
                                                lppGroup);
            }

            if(FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION) &&
                                                     dwErr == ERROR_SUCCESS)
            {
                dwErr = ConvertAListWToAlistAInplace(pAccessListW);
                if(dwErr == ERROR_SUCCESS)
                {
                    *ppAccessList = (PACTRL_AUDITA)pAccessListW;
                }
            }

            if(FLAG_ON(SecurityInfo, SACL_SECURITY_INFORMATION) &&
                                                     dwErr == ERROR_SUCCESS)
            {
                dwErr = ConvertAListWToAlistAInplace(pAuditListW);
                if(dwErr == ERROR_SUCCESS)
                {
                    *ppAuditList = (PACTRL_AUDITA)pAuditListW;
                }
            }

            //
            // If something failed, make sure we deallocate any information
            //
            if(dwErr != ERROR_SUCCESS)
            {
                if(FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION))
                {
                    LocalFree(*ppAccessList);
                    LocalFree(pAccessListW);
                }

                if(FLAG_ON(SecurityInfo, SACL_SECURITY_INFORMATION))
                {
                    LocalFree(*ppAuditList);
                    LocalFree(pAuditListW);
                }

                if(FLAG_ON(SecurityInfo, GROUP_SECURITY_INFORMATION))
                {
                    LocalFree(*lppGroup);
                    LocalFree(pwszGroup);
                }

                if(FLAG_ON(SecurityInfo, OWNER_SECURITY_INFORMATION))
                {
                    LocalFree(*lppOwner);
                    LocalFree(pwszOwner);
                }
            }
        }
    }
    //
    // Free our allocated strings...
    //
    LocalFree(pwszProvider);
    LocalFree(pwszProperty);

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   SetSecurityInfoExW
//
//  Synopsis:   Sets the specified security information from the indicated
//              object
//
//  Arguments:  [IN  hObject]       --  Object for which the permissions are
//                                      needed
//              [IN  ObjectType]    --  Type of object specified by lpObject
//              [IN  SecurityInfo]  --  What is to be set
//              [IN  lpProvider]    --  OPTIONAL If known, the provider to
//                                      handle the request.  If NULL, it will
//                                      be discovered
//              [OUT pAccessList]   --  OPTIONAL  The access list to set
//              [OUT pAuditList]    --  OPTIONAL  The audit list to set
//              [OUT lppOwner]      --  OPTIONAL  The owner to set
//              [OUT lppGroup]      --  OPTIONAL  The group name to set
//              [OUT pOverlapped    --  OPTIONAL  If present, it must point
//                                      to a valid ACTRL_OVERLAPPED structure
//                                      on input that will be filled in by
//                                      the API.  This is an indication that
//                                      the API is to be asynchronous.  If the
//                                      parameter is NULL, than the API will
//                                      be performed synchronously.
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//              ERROR_INVALID_HANDLE    A bad handle was encountered
//
//----------------------------------------------------------------------------
DWORD
WINAPI
SetSecurityInfoExW(IN    HANDLE                 hObject,
                   IN    SE_OBJECT_TYPE         ObjectType,
                   IN    SECURITY_INFORMATION   SecurityInfo,
                   IN    LPCWSTR               lpProvider,
                   IN    PACTRL_ACCESSW         pAccessList,
                   IN    PACTRL_AUDITW          pAuditList,
                   IN    LPWSTR                lpOwner,
                   IN    LPWSTR                lpGroup,
                   OUT   PACTRL_OVERLAPPED      pOverlapped)
{
    DWORD   dwErr = ERROR_SUCCESS;

    LOAD_PROVIDERS(dwErr);

    //
    // First, verify the parameters.  The providers expect valid parameters
    //
    if(hObject == NULL || hObject == INVALID_HANDLE_VALUE)
    {
        dwErr = ERROR_INVALID_HANDLE;
    }
    else
    {
        //
        // Verify that we have the proper parameters for our SecurityInfo
        //
        if(FLAG_ON(SecurityInfo, GROUP_SECURITY_INFORMATION) &&
                                                        lpGroup == NULL)
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }

        if(FLAG_ON(SecurityInfo, OWNER_SECURITY_INFORMATION) &&
                                                        lpOwner == NULL)
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }
    }

    //
    // If we have valid parameters, go do it...
    //
    if(dwErr == ERROR_SUCCESS)
    {
        CSList  ChangedList(CleanupConvertNode);

        //
        //
        // Find the provider
        //
        PACCPROV_PROV_INFO pProvider;

        dwErr = AccProvpGetProviderForHandle(hObject,
                                             ObjectType,
                                             lpProvider,
                                             &gAccProviders,
                                             &pProvider);

        if(dwErr == ERROR_SUCCESS)
        {
            //
            // Change our access lists if necessary.  This means that
            // we'll go through and change any SIDS to names.  The way the
            // conversion works is that if a node needs to have it's
            // trustee name changed, the address of the trustee's name,
            // and its old value are saved off in ChangedList.  Then,
            // when the list is destructed, it goes through and deletes
            // the current trustee name (gotten through the saved address)
            // and restores the old name
            //
            if(!FLAG_ON(pProvider->fProviderCaps,ACTRL_CAP_KNOWS_SIDS) &&
               FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION))
            {
                dwErr = ConvertAListToNamedBasedW(pAccessList,
                                                  ChangedList);
            }

            if(dwErr == ERROR_SUCCESS &&
               !FLAG_ON(pProvider->fProviderCaps,ACTRL_CAP_KNOWS_SIDS) &&
               FLAG_ON(SecurityInfo, SACL_SECURITY_INFORMATION))
            {
                dwErr = ConvertAListToNamedBasedW(pAuditList,
                                                  ChangedList);
            }

            if(dwErr == ERROR_SUCCESS)
            {
                //
                // Check for the caller wanting a synchronous call...
                //
                ACTRL_OVERLAPPED    LocalOverlapped;
                PACTRL_OVERLAPPED   pActiveOverlapped = pOverlapped;

                if(pActiveOverlapped == NULL)
                {
                    pActiveOverlapped = &LocalOverlapped;
                }

                TRUSTEE_W   Group = {0};
                TRUSTEE_W   Owner = {0};
                PTRUSTEE    pGroup = NULL;
                PTRUSTEE    pOwner = NULL;

                if(FLAG_ON(SecurityInfo,GROUP_SECURITY_INFORMATION))
                {
                    pGroup = &Group;
                    BuildTrusteeWithName(pGroup,
                                         lpGroup);
                }

                if(FLAG_ON(SecurityInfo,OWNER_SECURITY_INFORMATION))
                {
                    pOwner = &Owner;
                    BuildTrusteeWithName(pOwner,
                                         lpOwner);
                }

                //
                // Set up the overlapped structure
                //
                memset(pActiveOverlapped, 0, sizeof(ACTRL_OVERLAPPED));
                pActiveOverlapped->Provider = pProvider;
                pActiveOverlapped->hEvent = CreateEvent(NULL,
                                                        TRUE,
                                                        FALSE,
                                                        NULL);
                if(pActiveOverlapped->hEvent == NULL)
                {
                    dwErr = GetLastError();
                }
                else
                {
                    //
                    // Make the call
                    //
                    __try
                    {
                        dwErr = (*(pProvider->pfhSetAccess))(
                                                        hObject,
                                                        ObjectType,
                                                        SecurityInfo,
                                                        pAccessList,
                                                        pAuditList,
                                                        pOwner,
                                                        pGroup,
                                                        pActiveOverlapped);
                    }
                    __except(EXCEPTION_EXECUTE_HANDLER)
                    {
                        if(pProvider->pfhSetAccess == NULL)
                        {
                            dwErr = ERROR_BAD_PROVIDER;
                        }
                        else
                        {
                            dwErr = RtlNtStatusToDosError(GetExceptionCode());
                        }
                    }

                    if(dwErr != ERROR_SUCCESS)
                    {
                        CloseHandle(pActiveOverlapped->hEvent);
                    }

                }

                if(dwErr == ERROR_SUCCESS)
                {
                    //
                    // See if we're supposed to do this synchronously
                    //
                    if(pActiveOverlapped != pOverlapped)
                    {
                        DWORD   dwRet;
                        dwErr  = GetOverlappedAccessResults(
                                                        pActiveOverlapped,
                                                        TRUE,
                                                        &dwRet,
                                                        NULL);
                        if(dwErr == ERROR_SUCCESS)
                        {
                            dwErr = dwRet;
                        }
                    }
                }
            }
        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   SetNamedSecurityInfoExA
//
//  Synopsis:   Same as above, but an ANSI version
//
//  Arguments:  [IN  hObject]       --  Object for which the permissions are
//                                      needed
//              [IN  ObjectType]    --  Type of object specified by lpObject
//              [IN  SecurityInfo]  --  What is to be set
//              [IN  lpProvider]    --  OPTIONAL If known, the provider to
//                                      handle the request.  If NULL, it will
//                                      be discovered
//              [OUT pAccessList]   --  OPTIONAL  The access list to set
//              [OUT pAuditList]    --  OPTIONAL  The audit list to set
//              [OUT lppOwner]      --  OPTIONAL  The owner to set
//              [OUT lppGroup]      --  OPTIONAL  The group name to set
//              [OUT pOverlapped    --  OPTIONAL  If present, it must point
//                                      to a valid ACTRL_OVERLAPPED structure
//                                      on input that will be filled in by
//                                      the API.  This is an indication that
//                                      the API is to be asynchronous.  If the
//                                      parameter is NULL, than the API will
//                                      be performed synchronously.
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//              ERROR_INVALID_HANDLE    A bad handle was encountered
//
//  Notes:      This is not a simple matter of converting a few strings/etc
//              and calling the Unicode version, since that would involve
//              processing the list twice.  Yuk.  So, we go ahead and do the
//              the conversion and update of our input structures, and make
//              the call ourselves...
//
//----------------------------------------------------------------------------
DWORD
WINAPI
SetSecurityInfoExA(IN    HANDLE                 hObject,
                   IN    SE_OBJECT_TYPE         ObjectType,
                   IN    SECURITY_INFORMATION   SecurityInfo,
                   IN    LPCSTR                 lpProvider,
                   IN    PACTRL_ACCESSA         pAccessList,
                   IN    PACTRL_AUDITA          pAuditList,
                   IN    LPSTR                  lpOwner,
                   IN    LPSTR                  lpGroup,
                   OUT   PACTRL_OVERLAPPED      pOverlapped)
{
    DWORD   dwErr = ERROR_SUCCESS;

    LOAD_PROVIDERS(dwErr);

    //
    // First, verify the parameters.  The providers expect valid parameters
    //
    if(hObject == NULL || hObject == INVALID_HANDLE_VALUE)
    {
        dwErr = ERROR_INVALID_HANDLE;
    }
    else
    {
        //
        // Verify that we have the proper parameters for our SecurityInfo
        //
        if(FLAG_ON(SecurityInfo, GROUP_SECURITY_INFORMATION) &&
                                                        lpGroup == NULL)
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }

        if(FLAG_ON(SecurityInfo, OWNER_SECURITY_INFORMATION) &&
                                                        lpOwner == NULL)
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }
    }

    //
    // If we have valid parameters, go do it...
    //
    if(dwErr == ERROR_SUCCESS)
    {
        CSList  ChangedList(CleanupConvertNode);

        PWSTR   pwszProvider = NULL;

        dwErr = ConvertStringAToStringW((PSTR)lpProvider,
                                        &pwszProvider);

        //
        // Find the provider
        //
        PACCPROV_PROV_INFO pProvider;

        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = AccProvpGetProviderForHandle(hObject,
                                                 ObjectType,
                                                 pwszProvider,
                                                 &gAccProviders,
                                                 &pProvider);
        }

        if(dwErr == ERROR_SUCCESS)
        {
            PACTRL_ACCESSW  pAccessW = NULL;
            PACTRL_ACCESSW  pAuditW  = NULL;

            //
            // Change our access lists if necessary.  This means that
            // we'll go through and change any SIDS to names, and all
            // ansi strings to unicode strings.  This works exactly as
            // described in SetNamedSecurityInfoExW, with the exception
            // that we don't deal exclusively with trustee names, but
            // also property names and inherit object names
            //
            if(FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION))
            {
                dwErr = ConvertAListAToNamedBasedW(pAccessList,
                                                   ChangedList,
                                                   (BOOL)FLAG_ON(
                                                     pProvider->fProviderCaps,
                                                     ACTRL_CAP_KNOWS_SIDS),
                                                   &pAccessW);
            }

            if(dwErr == ERROR_SUCCESS &&
               FLAG_ON(SecurityInfo, SACL_SECURITY_INFORMATION))
            {
                dwErr = ConvertAListAToNamedBasedW(pAuditList,
                                                   ChangedList,
                                                   (BOOL)FLAG_ON(
                                                     pProvider->fProviderCaps,
                                                     ACTRL_CAP_KNOWS_SIDS),
                                                   &pAuditW);
            }

            if(dwErr == ERROR_SUCCESS)
            {
                //
                // Check for the caller wanting a synchronous call...
                //
                ACTRL_OVERLAPPED    LocalOverlapped;
                PACTRL_OVERLAPPED   pActiveOverlapped = pOverlapped;

                if(pActiveOverlapped == NULL)
                {
                    pActiveOverlapped = &LocalOverlapped;
                }

                TRUSTEE_W   Group = {0};
                TRUSTEE_W   Owner = {0};
                PTRUSTEE    pGroup = NULL;
                PTRUSTEE    pOwner = NULL;

                if(FLAG_ON(SecurityInfo,GROUP_SECURITY_INFORMATION))
                {
                    pGroup = &Group;
                    PWSTR   pwszGroup = NULL;
                    dwErr = ConvertStringAToStringW(lpGroup,
                                                    &pwszGroup);
                    if(dwErr == ERROR_SUCCESS)
                    {
                        BuildTrusteeWithName(pGroup,
                                             pwszGroup);
                    }
                }

                if(dwErr == ERROR_SUCCESS &&
                   FLAG_ON(SecurityInfo,OWNER_SECURITY_INFORMATION))
                {
                    pOwner = &Owner;
                    PWSTR   pwszOwner = NULL;
                    dwErr = ConvertStringAToStringW(lpOwner,
                                                    &pwszOwner);
                    if(dwErr == ERROR_SUCCESS)
                    {
                        BuildTrusteeWithName(pOwner,
                                             pwszOwner);
                    }
                }

                //
                // Make the call
                //
                if(dwErr == ERROR_SUCCESS)
                {
                    //
                    // Set up the overlapped structure
                    //
                    memset(pActiveOverlapped, 0, sizeof(ACTRL_OVERLAPPED));
                    pActiveOverlapped->Provider = pProvider;
                    pActiveOverlapped->hEvent = CreateEvent(NULL,
                                                            TRUE,
                                                            FALSE,
                                                            NULL);
                    if(pActiveOverlapped->hEvent == NULL)
                    {
                        dwErr = GetLastError();
                    }
                    else
                    {
                        //
                        // Make the call
                        //
                        __try
                        {
                            dwErr = (*(pProvider->pfhSetAccess))(
                                                           hObject,
                                                           ObjectType,
                                                           SecurityInfo,
                                                           pAccessW,
                                                           pAuditW,
                                                           pOwner,
                                                           pGroup,
                                                           pActiveOverlapped);
                        }
                        __except(EXCEPTION_EXECUTE_HANDLER)
                        {
                            if(pProvider->pfhSetAccess == NULL)
                            {
                                dwErr = ERROR_BAD_PROVIDER;
                            }
                            else
                            {
                                dwErr = RtlNtStatusToDosError(GetExceptionCode());
                            }
                        }

                        if(dwErr != ERROR_SUCCESS)
                        {
                            CloseHandle(pActiveOverlapped->hEvent);
                        }

                    }


                    if(dwErr == ERROR_SUCCESS)
                    {
                        //
                        // See if we're supposed to do this synchronously
                        //
                        if(pActiveOverlapped != pOverlapped)
                        {
                            DWORD   dwRet;
                            dwErr  = GetOverlappedAccessResults(
                                                        pActiveOverlapped,
                                                        TRUE,
                                                        &dwRet,
                                                        NULL);
                            if(dwErr == ERROR_SUCCESS)
                            {
                                dwErr = dwRet;
                            }
                        }
                    }
                }

                //
                // Free our allocated memory
                //
                if(pOwner != NULL)
                {
                    LocalFree(pOwner->ptstrName);
                }

                if(pGroup != NULL)
                {
                    LocalFree(pGroup->ptstrName);
                }
            }
        }

        //
        // Free our allocated strings...
        //
        LocalFree(pwszProvider);
    }

    return(dwErr);
}





//+---------------------------------------------------------------------------
//
//  Function:   ConvertAccessToSecurityDescriptorW
//
//  Synopsis:   Creates a security descriptor out of the various access
//              entries
//
//  Arguments:  [IN  pAccessList]   --  OPTIONAL.  Access list
//              [IN  pAuditList]    --  OPTIONAL.  Audit list
//              [IN  lpOwner]       --  OPTIONAL.  Owner
//              [IN  lpGroup]       --  OPTIONAL.  Group
//              [OUT ppSecDescriptor]   Where the security descriptor is
//                                      returned
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//
//----------------------------------------------------------------------------
DWORD
WINAPI
ConvertAccessToSecurityDescriptorW(IN  PACTRL_ACCESSW        pAccessList,
                                   IN  PACTRL_AUDITW         pAuditList,
                                   IN  LPCWSTR               lpOwner,
                                   IN  LPCWSTR               lpGroup,
                                   OUT PSECURITY_DESCRIPTOR *ppSecDescriptor)
{
    DWORD   dwErr = ERROR_SUCCESS;

    LOAD_PROVIDERS(dwErr);

    //
    // First, verify the parameters.  At least one has to be present
    //
    if(pAccessList == NULL && pAuditList == NULL && lpOwner == NULL &&
                                                              lpGroup == NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        dwErr = (*gNtMartaInfo.pfAToSD)(pAccessList,
                                        pAuditList,
                                        lpOwner,
                                        lpGroup,
                                        ppSecDescriptor);
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   ConvertAccessToSecurityDescriptorA
//
//  Synopsis:   Same as above, except ANSI version
//
//  Arguments:  [IN  pAccessList]   --  OPTIONAL.  Access list
//              [IN  pAuditList]    --  OPTIONAL.  Audit list
//              [IN  lpOwner]       --  OPTIONAL.  Owner
//              [IN  lpGroup]       --  OPTIONAL.  Group
//              [OUT ppSecDescriptor]   Where the security descriptor is
//                                      returned
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//
//----------------------------------------------------------------------------
DWORD
WINAPI
ConvertAccessToSecurityDescriptorA(IN  PACTRL_ACCESSA        pAccessList,
                                   IN  PACTRL_AUDITA         pAuditList,
                                   IN  LPCSTR                lpOwner,
                                   IN  LPCSTR                lpGroup,
                                   OUT PSECURITY_DESCRIPTOR *ppSecDescriptor)
{
    DWORD   dwErr = ERROR_SUCCESS;

    LOAD_PROVIDERS(dwErr);

    //
    // First, verify the parameters.  At least one has to be present
    //
    if(pAccessList == NULL && pAuditList == NULL && lpOwner == NULL &&
                                                              lpGroup == NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        CSList          ChangedList(CleanupConvertNode);

        PWSTR           pwszGroup = NULL;
        PWSTR           pwszOwner = NULL;
        PACTRL_ACCESSW  pNewAccess = NULL;
        PACTRL_ACCESSW  pNewAudit = NULL;

        dwErr = ConvertStringAToStringW((PSTR)lpGroup,
                                        &pwszGroup);

        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = ConvertStringAToStringW((PSTR)lpOwner,
                                            &pwszOwner);
        }

        if(dwErr == ERROR_SUCCESS && pAccessList != NULL)
        {
            //
            // First, convert it to UNICODE
            //
            dwErr = ConvertAListAToNamedBasedW(pAccessList,
                                               ChangedList,
                                               FALSE,
                                               &pNewAccess);
        }

        if(dwErr == ERROR_SUCCESS && pAuditList != NULL)
        {
            PACTRL_ACCESSW  pNewList;
            dwErr = ConvertAListAToNamedBasedW(pAuditList,
                                               ChangedList,
                                               FALSE,
                                               &pNewAudit);
        }

        //
        // Now, build the Security Descriptor
        //
        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = (*gNtMartaInfo.pfAToSD)(pNewAccess,
                                            pNewAudit,
                                            pwszOwner,
                                            pwszGroup,
                                            ppSecDescriptor);
        }

        //
        // Free our allocations
        //
        LocalFree(pwszGroup);
        LocalFree(pwszOwner);
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   ConvertSDToAccessW
//
//  Synopsis:   Converts a security descriptor to the access entries
//
//  Arguments:  [IN  ObjectType]    --  Type of the object
//              [IN  ppSecDescriptor]   Security descriptor to return
//              [OUT pAccessList]   --  OPTIONAL.  Access list returned here
//              [OUT pAuditList]    --  OPTIONAL.  Audit list returned here
//              [OUT lpOwner]       --  OPTIONAL.  Owner returned here
//              [OUT lpGroup]       --  OPTIONAL.  Group returned here
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//
//----------------------------------------------------------------------------
DWORD
WINAPI
ConvertSDToAccessW(IN  SE_OBJECT_TYPE       ObjectType,
                   IN  PSECURITY_DESCRIPTOR pSecDescriptor,
                   OUT PACTRL_ACCESSW      *ppAccessList,
                   OUT PACTRL_AUDITW       *ppAuditList,
                   OUT LPWSTR              *lppOwner,
                   OUT LPWSTR              *lppGroup)
{
    DWORD   dwErr = ERROR_SUCCESS;

    LOAD_PROVIDERS(dwErr);

    //
    // Make sure we have valid parameters
    //
    if(pSecDescriptor == NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        //
        // Make sure we have something to do
        //
        SECURITY_INFORMATION    SeInfo = 0;

        if(ppAccessList != NULL)
        {
            SeInfo |= DACL_SECURITY_INFORMATION;
        }

        if(ppAuditList != NULL)
        {
            SeInfo |= SACL_SECURITY_INFORMATION;
        }

        if(lppOwner != NULL)
        {
            SeInfo |= OWNER_SECURITY_INFORMATION;
        }

        if(lppGroup != NULL)
        {
            SeInfo |= GROUP_SECURITY_INFORMATION;
        }

        if(SeInfo != 0)
        {
            dwErr = (*gNtMartaInfo.pfSDToA)(ObjectType,
                                            pSecDescriptor,
                                            ppAccessList,
                                            ppAuditList,
                                            lppOwner,
                                            lppGroup);
        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   ConvertSDToAccessA
//
//  Synopsis:   Same as above, but ANSI
//
//  Arguments:  [IN  ObjectType]    --  Type of the object
//              [IN  ppSecDescriptor]   Security descriptor to return
//              [OUT pAccessList]   --  OPTIONAL.  Access list returned here
//              [OUT pAuditList]    --  OPTIONAL.  Audit list returned here
//              [OUT lpOwner]       --  OPTIONAL.  Owner returned here
//              [OUT lpGroup]       --  OPTIONAL.  Group returned here
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//
//----------------------------------------------------------------------------
DWORD
WINAPI
ConvertSDToAccessA(IN  SE_OBJECT_TYPE       ObjectType,
                   IN  PSECURITY_DESCRIPTOR pSecDescriptor,
                   OUT PACTRL_ACCESSA      *ppAccessList,
                   OUT PACTRL_AUDITA       *ppAuditList,
                   OUT LPSTR               *lppOwner,
                   OUT LPSTR               *lppGroup)
{
    DWORD   dwErr = ERROR_SUCCESS;

    LOAD_PROVIDERS(dwErr);

    //
    // Make sure we have valid parameters
    //
    if(pSecDescriptor == NULL || ObjectType == SE_UNKNOWN_OBJECT_TYPE)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        //
        // Make sure we have something to do
        //
        SECURITY_INFORMATION    SeInfo = 0;

        if(ppAccessList != NULL)
        {
            SeInfo |= DACL_SECURITY_INFORMATION;
        }

        if(ppAuditList != NULL)
        {
            SeInfo |= SACL_SECURITY_INFORMATION;
        }

        if(lppOwner != NULL)
        {
            SeInfo |= OWNER_SECURITY_INFORMATION;
            *lppOwner = NULL;
        }

        if(lppGroup != NULL)
        {
            *lppGroup = NULL;
            SeInfo |= GROUP_SECURITY_INFORMATION;
        }

        if(SeInfo != 0)
        {
            PACTRL_ACCESSW  pAccessW = NULL, pAuditW = NULL;
            PWSTR           pwszOwner = NULL, pwszGroup = NULL;

            dwErr = ConvertSDToAccessW(ObjectType,
                                       pSecDescriptor,
                                       ppAccessList == NULL ?
                                                        NULL    :
                                                        &pAccessW,
                                       ppAuditList == NULL ?
                                                        NULL    :
                                                        &pAuditW,
                                       lppOwner == NULL ?
                                                        NULL    :
                                                        &pwszOwner,
                                       lppGroup == NULL ?
                                                        NULL    :
                                                        &pwszGroup);
            if(dwErr == ERROR_SUCCESS)
            {
                //
                // Convert them to ANSI
                //
                if(FLAG_ON(SeInfo, DACL_SECURITY_INFORMATION))
                {
                    dwErr = ConvertAListWToAlistAInplace(pAccessW);
                    if(dwErr == ERROR_SUCCESS)
                    {
                        *ppAccessList = (PACTRL_ACCESSA)pAccessW;
                    }
                }

                if(dwErr == ERROR_SUCCESS &&
                   FLAG_ON(SeInfo, SACL_SECURITY_INFORMATION))
                {
                    dwErr = ConvertAListWToAlistAInplace(pAuditW);
                    if(dwErr == ERROR_SUCCESS)
                    {
                        *ppAuditList = (PACTRL_ACCESSA)pAuditW;
                    }
                }

                if(dwErr == ERROR_SUCCESS)
                {
                    //
                    // Save off the strings
                    //
                    if(FLAG_ON(SeInfo, OWNER_SECURITY_INFORMATION))
                    {
                        dwErr = ConvertStringWToStringA(pwszOwner,
                                                        lppOwner);
                    }

                    if(dwErr == ERROR_SUCCESS &&
                       FLAG_ON(SeInfo, GROUP_SECURITY_INFORMATION))
                    {
                        dwErr = ConvertStringWToStringA(pwszGroup,
                                                        lppGroup);
                    }
                }

                if(dwErr != ERROR_SUCCESS)
                {
                    if(FLAG_ON(SeInfo, DACL_SECURITY_INFORMATION))
                    {
                        LocalFree(ppAccessList);
                    }

                    if(FLAG_ON(SeInfo, SACL_SECURITY_INFORMATION))
                    {
                        LocalFree(ppAuditList);
                    }

                    if(FLAG_ON(SeInfo, OWNER_SECURITY_INFORMATION))
                    {
                        LocalFree(lppOwner);
                    }

                    if(dwErr == ERROR_SUCCESS &&
                       FLAG_ON(SeInfo, GROUP_SECURITY_INFORMATION))
                    {
                        LocalFree(lppGroup);
                    }
                }

                //
                // Free our earlier allocated memory
                //
                LocalFree(pwszOwner);
                LocalFree(pwszGroup);
            }
        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   ConvertSecurityDescriptorToAccessW
//
//  Synopsis:   Converts a security descriptor to the access entries
//
//  Arguments:  [IN  hObject]       --  Handle to the open object
//              [IN  ObjectType]    --  Type of the object
//              [IN  ppSecDescriptor]   Security descriptor to return
//              [OUT pAccessList]   --  OPTIONAL.  Access list returned here
//              [OUT pAuditList]    --  OPTIONAL.  Audit list returned here
//              [OUT lpOwner]       --  OPTIONAL.  Owner returned here
//              [OUT lpGroup]       --  OPTIONAL.  Group returned here
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//
//----------------------------------------------------------------------------
DWORD
WINAPI
ConvertSecurityDescriptorToAccessW(IN  HANDLE               hObject,
                                   IN  SE_OBJECT_TYPE       ObjectType,
                                   IN  PSECURITY_DESCRIPTOR pSecDescriptor,
                                   OUT PACTRL_ACCESSW      *ppAccessList,
                                   OUT PACTRL_AUDITW       *ppAuditList,
                                   OUT LPWSTR             *lppOwner,
                                   OUT LPWSTR             *lppGroup)
{
    return(ConvertSDToAccessW(ObjectType,
                              pSecDescriptor,
                              ppAccessList,
                              ppAuditList,
                              lppOwner,
                              lppGroup));
}




//+---------------------------------------------------------------------------
//
//  Function:   ConvertSecurityDescriptorToAccessA
//
//  Synopsis:   Same as above, except ANSI
//
//  Arguments:  [IN  hObject]       --  Handle to the open object
//              [IN  ObjectType]    --  Type of the object
//              [IN  ppSecDescriptor]   Security descriptor to return
//              [OUT pAccessList]   --  OPTIONAL.  Access list returned here
//              [OUT pAuditList]    --  OPTIONAL.  Audit list returned here
//              [OUT lpOwner]       --  OPTIONAL.  Owner returned here
//              [OUT lpGroup]       --  OPTIONAL.  Group returned here
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//
//----------------------------------------------------------------------------
DWORD
WINAPI
ConvertSecurityDescriptorToAccessA(IN  HANDLE               hObject,
                                   IN  SE_OBJECT_TYPE       ObjectType,
                                   IN  PSECURITY_DESCRIPTOR pSecDescriptor,
                                   OUT PACTRL_ACCESSA      *ppAccessList,
                                   OUT PACTRL_AUDITA       *ppAuditList,
                                   OUT LPSTR               *lppOwner,
                                   OUT LPSTR               *lppGroup)
{
    return(ConvertSDToAccessA(ObjectType,
                              pSecDescriptor,
                              ppAccessList,
                              ppAuditList,
                              lppOwner,
                              lppGroup));
}




//+---------------------------------------------------------------------------
//
//  Function:   ConvertSecurityDescriptorToAccessNamedW
//
//  Synopsis:   Converts a security descriptor to the access entries
//
//  Arguments:  [IN  lpObject]      --  Path to the object
//              [IN  ObjectType]    --  Type of the object
//              [IN  ppSecDescriptor]   Security descriptor to return
//              [OUT pAccessList]   --  OPTIONAL.  Access list returned here
//              [OUT pAuditList]    --  OPTIONAL.  Audit list returned here
//              [OUT lpOwner]       --  OPTIONAL.  Owner returned here
//              [OUT lpGroup]       --  OPTIONAL.  Group returned here
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//
//----------------------------------------------------------------------------
DWORD
WINAPI
ConvertSecurityDescriptorToAccessNamedW(IN  LPCWSTR             lpObject,
                                        IN  SE_OBJECT_TYPE       ObjectType,
                                        IN  PSECURITY_DESCRIPTOR pSecDescriptor,
                                        OUT PACTRL_ACCESSW      *ppAccessList,
                                        OUT PACTRL_AUDITW       *ppAuditList,
                                        OUT LPWSTR             *lppOwner,
                                        OUT LPWSTR             *lppGroup)
{
    return(ConvertSDToAccessW(ObjectType,
                              pSecDescriptor,
                              ppAccessList,
                              ppAuditList,
                              lppOwner,
                              lppGroup));
}




//+---------------------------------------------------------------------------
//
//  Function:   ConvertSecurityDescriptorToAccessNamedW
//
//  Synopsis:   Same as above, except ANSI
//
//  Arguments:  [IN  lpObject]      --  Path to the object
//              [IN  ObjectType]    --  Type of the object
//              [IN  ppSecDescriptor]   Security descriptor to return
//              [OUT pAccessList]   --  OPTIONAL.  Access list returned here
//              [OUT pAuditList]    --  OPTIONAL.  Audit list returned here
//              [OUT lpOwner]       --  OPTIONAL.  Owner returned here
//              [OUT lpGroup]       --  OPTIONAL.  Group returned here
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//
//----------------------------------------------------------------------------
DWORD
WINAPI
ConvertSecurityDescriptorToAccessNamedA(IN  LPCSTR               lpObject,
                                        IN  SE_OBJECT_TYPE       ObjectType,
                                        IN  PSECURITY_DESCRIPTOR pSecDescriptor,
                                        OUT PACTRL_ACCESSA      *ppAccessList,
                                        OUT PACTRL_AUDITA       *ppAuditList,
                                        OUT LPSTR               *lppOwner,
                                        OUT LPSTR               *lppGroup)
{
    return(ConvertSDToAccessA(ObjectType,
                              pSecDescriptor,
                              ppAccessList,
                              ppAuditList,
                              lppOwner,
                              lppGroup));
}




//+---------------------------------------------------------------------------
//
//  Function:   SetEntriesInAListW
//
//  Synopsis:   Sets/Merges the given entries with the existing ones, and
//              then remarshals the results
//
//  Arguments:  [IN  cEntries]      --  Number of items in the list
//              [IN  pAccessEntryList]  Entries to set/merge
//              [IN  AccessMode]    --  Whether to do a set or a merge
//              [IN  SeInfo]        --  Type of list we're dealing with
//              [IN  lpProperty]    --  OPTIONAL Property on which to operate
//              [IN  pOldList]      --  The existing audit list
//              [OUT ppNewList]     --  Where the new list is returned
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//
//----------------------------------------------------------------------------
DWORD
WINAPI
SetEntriesInAListW(IN  ULONG                 cEntries,
                   IN  PACTRL_ACCESS_ENTRYW  pAccessEntryList,
                   IN  ACCESS_MODE           AccessMode,
                   IN  SECURITY_INFORMATION  SeInfo,
                   IN  LPCWSTR               lpProperty,
                   IN  PACTRL_AUDITW         pOldList,
                   OUT PACTRL_AUDITW        *ppNewList)
{
    DWORD   dwErr = ERROR_SUCCESS;

    LOAD_PROVIDERS(dwErr);

    //
    // First, a little parameter validation...
    //
    if((cEntries != 0 && pAccessEntryList == NULL) || ppNewList == NULL ||
       (AccessMode == DENY_ACCESS) ||
       (SeInfo != SACL_SECURITY_INFORMATION &&
                                         SeInfo != DACL_SECURITY_INFORMATION))
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        dwErr = (*gNtMartaInfo.pfSetAList)(cEntries,
                                           pAccessEntryList,
                                           AccessMode,
                                           SeInfo,
                                           lpProperty,
                                           FALSE,
                                           pOldList,
                                           ppNewList);
    }

    return(dwErr);
}





//+---------------------------------------------------------------------------
//
//  Function:   SetEntriesInAListA
//
//  Synopsis:   Same as above, but ANSI
//
//  Arguments:  [IN  cEntries]      --  Number of items in the list
//              [IN  pAccessEntryList]  Entries to set/merge
//              [IN  AccessMode]    --  Whether to do a set or a merge
//              [IN  SeInfo]        --  Type of list we're dealing with
//              [IN  lpProperty]    --  OPTIONAL Property on which to operate
//              [IN  pOldList]      --  The existing audit list
//              [OUT ppNewList]     --  Where the new list is returned
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//
//----------------------------------------------------------------------------
DWORD
WINAPI
SetEntriesInAListA(IN  ULONG                 cEntries,
                   IN  PACTRL_ACCESS_ENTRYA  pAccessEntryList,
                   IN  ACCESS_MODE           AccessMode,
                   IN  SECURITY_INFORMATION  SeInfo,
                   IN  LPCSTR                lpProperty,
                   IN  PACTRL_AUDITA         pOldList,
                   OUT PACTRL_AUDITA        *ppNewList)
{
    DWORD   dwErr = ERROR_SUCCESS;

    LOAD_PROVIDERS(dwErr);

    //
    // First, a little parameter validation...
    //
    if((cEntries != 0 && pAccessEntryList == NULL) || ppNewList == NULL ||
       (AccessMode == DENY_ACCESS) ||
       (SeInfo != SACL_SECURITY_INFORMATION &&
                                         SeInfo != DACL_SECURITY_INFORMATION))

    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        //
        // We need to build a ACTRL_ALIST
        //
        ACTRL_ACCESSA               AList;
        ACTRL_PROPERTY_ENTRYA       APE;
        ACTRL_ACCESS_ENTRY_LISTA    AAEL;

        AAEL.cEntries    = cEntries;
        AAEL.pAccessList = pAccessEntryList;

        APE.lpProperty       = (PSTR)lpProperty;
        APE.pAccessEntryList = &(AAEL);

        AList.cEntries            = 1;
        AList.pPropertyAccessList = &APE;

        //
        // Now, convert them to UNICODE
        //
        PWSTR           pwszProperty;
        PACTRL_ACCESSW  pOldW = NULL, pNewW = NULL, pTemp = NULL;
        CSList          ChangedList(CleanupConvertNode);

        //
        // Convert them all the unicode
        //
        if(pOldList != NULL)
        {
            dwErr = ConvertAListAToNamedBasedW(pOldList,
                                               ChangedList,
                                               FALSE,
                                               &pOldW);

        }

        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = ConvertAListAToNamedBasedW(&AList,
                                               ChangedList,
                                               FALSE,
                                               &pTemp);
        }

        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = ConvertStringAToStringW((PSTR)lpProperty,
                                            &pwszProperty);
        }

        //
        // Now, we'll start adding them
        if(dwErr == ERROR_SUCCESS)
        {
            PACTRL_AUDITW   pAuditW;
            dwErr = (*gNtMartaInfo.pfSetAList)(cEntries,
                                               (PACTRL_ACCESS_ENTRYW)
                                                             pAccessEntryList,
                                               AccessMode,
                                               SeInfo,
                                               pwszProperty,
                                               FALSE,
                                               pOldW,
                                               &pAuditW);
            if(dwErr == ERROR_SUCCESS)
            {
                dwErr = ConvertAListWToAlistAInplace(pAuditW);
                if(dwErr == ERROR_SUCCESS)
                {
                    *ppNewList = (PACTRL_AUDITA)pAuditW;
                }
                else
                {
                    LocalFree(pAuditW);
                }
            }

            LocalFree(pwszProperty);
        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   SetEntriesInAccessListW
//
//  Synopsis:   Sets/Merges the given entries with the existing ones, and
//              then remarshals the results
//
//  Arguments:  [IN  cEntries]      --  Number of items in the list
//              [IN  pAccessEntryList]  Entries to set/merge
//              [IN  AccessMode]    --  Whether to do a set or a merge
//              [IN  lpProperty]    --  OPTIONAL Property on which to operate
//              [IN  pOldList]      --  The existing audit list
//              [OUT ppNewList]     --  Where the new list is returned
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//
//----------------------------------------------------------------------------
DWORD
WINAPI
SetEntriesInAccessListW(IN  ULONG                cEntries,
                        IN  PACTRL_ACCESS_ENTRYW pAccessEntryList,
                        IN  ACCESS_MODE          AccessMode,
                        IN  LPCWSTR              lpProperty,
                        IN  PACTRL_ACCESSW       pOldList,
                        OUT PACTRL_ACCESSW      *ppNewList)
{
    SECURITY_INFORMATION SeInfo;

    switch(AccessMode)
    {
    case SET_AUDIT_SUCCESS:
    case SET_AUDIT_FAILURE:
        SeInfo = SACL_SECURITY_INFORMATION;
        break;

    default:
        SeInfo = DACL_SECURITY_INFORMATION;
        break;
    }

    return(SetEntriesInAListW(cEntries,
                              pAccessEntryList,
                              AccessMode,
                              SeInfo,
                              lpProperty,
                              pOldList,
                              ppNewList));
}




//+---------------------------------------------------------------------------
//
//  Function:   SetEntriesInAccessListA
//
//  Synopsis:   Same as above, except ANSI
//
//  Arguments:  [IN  cEntries]      --  Number of items in the list
//              [IN  pAccessEntryList]  Entries to set/merge
//              [IN  AccessMode]    --  Whether to do a set or a merge
//              [IN  lpProperty]    --  OPTIONAL Property on which to operate
//              [IN  pOldList]      --  The existing audit list
//              [OUT ppNewList]     --  Where the new list is returned
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//
//----------------------------------------------------------------------------
DWORD
WINAPI
SetEntriesInAccessListA(IN  ULONG                cEntries,
                        IN  PACTRL_ACCESS_ENTRYA pAccessEntryList,
                        IN  ACCESS_MODE          AccessMode,
                        IN  LPCSTR               lpProperty,
                        IN  PACTRL_ACCESSA       pOldList,
                        OUT PACTRL_ACCESSA      *ppNewList)
{
    SECURITY_INFORMATION SeInfo;

    switch(AccessMode)
    {
    case SET_AUDIT_SUCCESS:
    case SET_AUDIT_FAILURE:
        SeInfo = SACL_SECURITY_INFORMATION;
        break;

    default:
        SeInfo = DACL_SECURITY_INFORMATION;
        break;
    }

    return(SetEntriesInAListA(cEntries,
                              pAccessEntryList,
                              AccessMode,
                              SeInfo,
                              lpProperty,
                              pOldList,
                              ppNewList));
}




//+---------------------------------------------------------------------------
//
//  Function:   SetEntriesInAuditListW
//
//  Synopsis:   Sets/Merges the given entries with the existing ones, and
//              then remarshals the results
//
//  Arguments:  [IN  cEntries]      --  Number of items in the list
//              [IN  pAccessEntryList]  Entries to set/merge
//              [IN  AccessMode]    --  Whether to do a set or a merge
//              [IN  lpProperty]    --  OPTIONAL Property on which to operate
//              [IN  pOldList]      --  The existing audit list
//              [OUT ppNewList]     --  Where the new list is returned
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//
//----------------------------------------------------------------------------
DWORD
WINAPI
SetEntriesInAuditListW(IN  ULONG                 cEntries,
                       IN  PACTRL_ACCESS_ENTRYW  pAccessEntryList,
                       IN  ACCESS_MODE           AccessMode,
                       IN  LPCWSTR               lpProperty,
                       IN  PACTRL_AUDITW         pOldList,
                       OUT PACTRL_AUDITW        *ppNewList)
{
    return(SetEntriesInAListW(cEntries,
                              pAccessEntryList,
                              AccessMode,
                              SACL_SECURITY_INFORMATION,
                              lpProperty,
                              pOldList,
                              ppNewList));
}




//+---------------------------------------------------------------------------
//
//  Function:   SetEntriesInAuditListA
//
//  Synopsis:   Same as above, but ANSI
//
//  Arguments:  [IN  cEntries]      --  Number of items in the list
//              [IN  pAccessEntryList]  Entries to set/merge
//              [IN  AccessMode]    --  Whether to do a set or a merge
//              [IN  lpProperty]    --  OPTIONAL Property on which to operate
//              [IN  pOldList]      --  The existing audit list
//              [OUT ppNewList]     --  Where the new list is returned
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//
//----------------------------------------------------------------------------
DWORD
WINAPI
SetEntriesInAuditListA(IN  ULONG                 cEntries,
                       IN  PACTRL_ACCESS_ENTRYA  pAccessEntryList,
                       IN  ACCESS_MODE           AccessMode,
                       IN  LPCSTR                lpProperty,
                       IN  PACTRL_AUDITA         pOldList,
                       OUT PACTRL_AUDITA        *ppNewList)
{
    return(SetEntriesInAListA(cEntries,
                              pAccessEntryList,
                              AccessMode,
                              SACL_SECURITY_INFORMATION,
                              lpProperty,
                              pOldList,
                              ppNewList));
}




//+---------------------------------------------------------------------------
//
//  Function:   TrusteeAccessToObjectW
//
//  Synopsis:   Determines the access the trustee has to the specified
//              object
//
//  Arguments:  [IN  lpObject]      --  The object to get the access for
//              [IN  ObjectType]    --  The type of the object
//              [IN  lpProvider]    --  OPTIONAL If known, the provider to
//                                      handle the request.  If NULL, it will
//                                      be discovered
//              [IN  pTrustee]      --  The trustee for which to do the
//                                      inquiry
//              [IN  cEntries]      --  Number of TRUSTEE_ACCESS entries in
//                                      the list
//              [IN  pTrusteeAccess]--  The list of trustee access structures
//                                      to process and update
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given or the
//                                      fields in the overlapped structure
//                                      were wrong
//
//----------------------------------------------------------------------------
DWORD
WINAPI
TrusteeAccessToObjectW(IN        LPCWSTR            lpObject,
                       IN        SE_OBJECT_TYPE     ObjectType,
                       IN        LPCWSTR            lpProvider,
                       IN        PTRUSTEE_W         pTrustee,
                       IN        ULONG              cEntries,
                       IN OUT    PTRUSTEE_ACCESSW   pTrusteeAccess)
{
    DWORD   dwErr = ERROR_SUCCESS;

    LOAD_PROVIDERS(dwErr);

    //
    // First, verify the parameters.  The providers expect valid parameters
    //
    if(lpObject == NULL || pTrustee == NULL || pTrusteeAccess == NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        //
        // Find the provider
        //
        PACCPROV_PROV_INFO pProvider;
        dwErr = AccProvpGetProviderForPath(lpObject,
                                           ObjectType,
                                           lpProvider,
                                           &gAccProviders,
                                           &pProvider);

        if(dwErr == ERROR_SUCCESS)
        {
            __try
            {
                //
                // Make the calls
                //
                for(ULONG iIndex = 0;
                    iIndex < cEntries && dwErr == ERROR_SUCCESS;
                    iIndex++)
                {
                    dwErr = (*(pProvider->pfTrusteeAccess))(
                                                  lpObject,
                                                  ObjectType,
                                                  pTrustee,
                                                  &(pTrusteeAccess[iIndex]));
                }
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                if(pProvider->pfTrusteeAccess == NULL)
                {
                    dwErr = ERROR_BAD_PROVIDER;
                }
                else
                {
                    dwErr = RtlNtStatusToDosError(GetExceptionCode());
                }
            }

        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   TrusteeAccessToObjectA
//
//  Synopsis:   Same as above, but the ANSI version
//
//  Arguments:  [IN  lpObject]      --  The object to get the access for
//              [IN  ObjectType]    --  The type of the object
//              [IN  lpProvider]    --  OPTIONAL If known, the provider to
//                                      handle the request.  If NULL, it will
//                                      be discovered
//              [IN  pTrustee]      --  The trustee for which to do the
//                                      inquiry
//              [IN  cEntries]      --  Number of TRUSTEE_ACCESS entries in
//                                      the list
//              [IN  pTrusteeAccess]--  The list of trustee access structures
//                                      to process and update
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given or the
//                                      fields in the overlapped structure
//                                      were wrong
//
//----------------------------------------------------------------------------
DWORD
WINAPI
TrusteeAccessToObjectA(IN        LPCSTR             lpObject,
                       IN        SE_OBJECT_TYPE     ObjectType,
                       IN        LPCSTR             lpProvider,
                       IN        PTRUSTEE_A         pTrustee,
                       IN        ULONG              cEntries,
                       IN OUT    PTRUSTEE_ACCESSA   pTrusteeAccess)
{
    DWORD   dwErr = ERROR_SUCCESS;

    LOAD_PROVIDERS(dwErr);

    //
    // First, verify the parameters.  The providers expect valid parameters
    //
    if(lpObject == NULL || pTrustee == NULL || pTrusteeAccess == NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        PWSTR   pwszObject;
        PWSTR   pwszProvider = NULL;

        dwErr = ConvertStringAToStringW((PSTR)lpObject,
                                        &pwszObject);
        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = ConvertStringAToStringW((PSTR)lpProvider,
                                            &pwszProvider);
        }

        //
        // Find the provider
        //
        BOOL    fSidToName = TRUE;
        PACCPROV_PROV_INFO pProvider;
        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = AccProvpGetProviderForPath(pwszObject,
                                               ObjectType,
                                               pwszProvider,
                                               &gAccProviders,
                                               &pProvider);
            if(dwErr == ERROR_SUCCESS)
            {
                //
                // See if this provider can understand sids
                //
                if(FLAG_ON(pProvider->fProviderCaps,ACTRL_CAP_KNOWS_SIDS))
                {
                    fSidToName = FALSE;
                }
            }
        }

        if(dwErr == ERROR_SUCCESS)
        {
            //
            // Do the conversions...
            //
            TRUSTEE_W   TrusteeW;
            dwErr = ConvertTrusteeAToTrusteeW(pTrustee,
                                              &TrusteeW,
                                              fSidToName);
            if(dwErr == ERROR_SUCCESS)
            {
                //
                // Make the calls
                //
                for(ULONG iIndex = 0;
                    iIndex < cEntries && dwErr == ERROR_SUCCESS;
                    iIndex++)
                {
                    PWSTR   pwszProp;

                    dwErr = ConvertStringAToStringW(
                                            pTrusteeAccess[iIndex].lpProperty,
                                            &pwszProp);
                    if(dwErr == ERROR_SUCCESS)
                    {
                        TRUSTEE_ACCESSW TrusteeAccessW;

                        memcpy(&TrusteeAccessW,
                               &(pTrusteeAccess[iIndex]),
                               sizeof(TRUSTEE_ACCESSA));
                        TrusteeAccessW.lpProperty = pwszProp;

                        __try
                        {
                            dwErr = (*(pProvider->pfTrusteeAccess))(
                                                      pwszObject,
                                                      ObjectType,
                                                      &TrusteeW,
                                                      &(TrusteeAccessW));
                        }
                        __except(EXCEPTION_EXECUTE_HANDLER)
                        {
                            if(pProvider->pfTrusteeAccess == NULL)
                            {
                                dwErr = ERROR_BAD_PROVIDER;
                            }
                            else
                            {
                                dwErr = RtlNtStatusToDosError(GetExceptionCode());
                            }
                        }

                        //
                        // Copy our bits back
                        //
                        if(dwErr == ERROR_SUCCESS)
                        {
                            pTrusteeAccess[iIndex].fReturnedAccess =
                                               TrusteeAccessW.fReturnedAccess;
                        }

                        LocalFree(pwszProp);
                    }
                }

                if((PSID)TrusteeW.ptstrName != (PSID)pTrustee->ptstrName)
                {
                    LocalFree(TrusteeW.ptstrName);
                }
            }
        }

        LocalFree(pwszProvider);
        LocalFree(pwszObject);
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   CancelOverlappedAccess
//
//  Synopsis:   Cancels an overlapped access operation that is already
//              in progress
//
//  Arguments:  [IN  pOverlapped]   --  Information about the operation to
//                                      be canceled
//              [IN  fWaitForCompletion]    If TRUE, the API will wait for
//                                      the operation to complete
//              [OUT pResult]       --  Where the operation results are
//                                      returned
//              [OUT pcItemsProcessed]  OPTIONAL.  If present, the current
//                                      count of processed items is returned
//                                      here
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given or the
//                                      fields in the overlapped structure
//                                      were wrong
//
//----------------------------------------------------------------------------
DWORD
WINAPI
GetOverlappedAccessResults(IN  PACTRL_OVERLAPPED   pOverlapped,
                           IN  BOOL                fWaitForCompletion,
                           OUT PDWORD              pResult,
                           OUT PDWORD              pcItemsProcessed OPTIONAL)
{
    DWORD   dwErr = ERROR_SUCCESS;

    LOAD_PROVIDERS(dwErr);


    if(pOverlapped == NULL || pResult == NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        //
        // See if we've already called the provider for this operation
        //
        if(pOverlapped->hEvent == NULL)
        {
            *pResult = pOverlapped->Reserved2;
            if(pcItemsProcessed != NULL)
            {
                *pcItemsProcessed = pOverlapped->Reserved1;
            }
        }
        else
        {
            if(fWaitForCompletion == TRUE)
            {
                if(WaitForSingleObject(pOverlapped->hEvent, INFINITE) ==
                                                                WAIT_FAILED)
                {
                    dwErr = GetLastError();
                }
            }

            if(dwErr == ERROR_SUCCESS)
            {
                //
                // Call the underlying provider...  Note that the Provider
                // parameter must be initialized to reference our provider
                //
                PACCPROV_PROV_INFO pProvider =
                                   (PACCPROV_PROV_INFO)pOverlapped->Provider;
                if(pProvider == NULL)
                {
                    dwErr = ERROR_INVALID_PARAMETER;
                }
                else
                {
                    //
                    // Make the call
                    //

                    //
                    // Note that it could be a bogus provider ptr
                    //
                    __try
                    {
                        do
                        {
                            dwErr = (*(pProvider->pfResults))
                                                       (pOverlapped,
                                                        pResult,
                                                        pcItemsProcessed);

                        } while(dwErr == ERROR_IO_PENDING);
                    }
                    __except(EXCEPTION_EXECUTE_HANDLER)
                    {
                        if(pProvider->pfResults == NULL)
                        {
                            dwErr = ERROR_BAD_PROVIDER;
                        }
                        else
                        {
                            dwErr = RtlNtStatusToDosError(GetExceptionCode());
                        }
                    }


                    //
                    // Handle it, if it worked...
                    //
                    CloseHandle(pOverlapped->hEvent);
                    pOverlapped->hEvent = NULL;
                }
            }
        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   CancelOverlappedAccess
//
//  Synopsis:   Cancels an overlapped access operation that is already
//              in progress
//
//  Arguments:  [IN  pOverlapped]   --  Information about the operation to
//                                      be canceled
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given or the
//                                      fields in the overlapped structure
//                                      were wrong
//
//----------------------------------------------------------------------------
DWORD
WINAPI
CancelOverlappedAccess(IN       PACTRL_OVERLAPPED   pOverlapped)
{
    DWORD   dwErr = ERROR_SUCCESS;

    LOAD_PROVIDERS(dwErr);

    //
    // First, check the parameters
    //
    if(pOverlapped == NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        //
        // Call the underlying provider...  Note that the Provider
        // parameter must be initialized to reference our provider
        //
        PACCPROV_PROV_INFO pProvider =
                               (PACCPROV_PROV_INFO)pOverlapped->Provider;
        if(pProvider == NULL)
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }
        else
        {
            //
            // Make the call
            //

            //
            // Note that it could be a bogus ptr
            //
            __try
            {
                dwErr = (*(pProvider->pfCancel))(pOverlapped);
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                dwErr = ERROR_INVALID_PARAMETER;
            }

            //
            // If we get back an ERROR_INVALID_PARAMETER from the interface,
            // then we know that it didn't find this pending operation, so
            // it either has completed successfully or already been canceled.
            // Either way, not an error
            //
            if(dwErr == ERROR_INVALID_PARAMETER)
            {
                dwErr = ERROR_SUCCESS;
            }
        }
    }

    return(dwErr);
}






//+---------------------------------------------------------------------------
//
//  Function:   GetAccessPermissionsForObjectW
//
//  Synopsis:   Determines what the available and appropriate access
//              permissions that can be set for each object based upon its
//              type.  This is a provider call.
//
//  Arguments:  [IN  lpObject]      --  Object for which the permissions are
//                                      needed
//              [IN  ObjectType]    --  Type of object specified by lpObject
//              [IN  lpObjectType]  --  Gets the access rights for the specified
//                                      object type
//              [IN  lpProvider]    --  OPTIONAL If known, the provider to
//                                      handle the request.  If NULL, it will
//                                      be discovered
//              [OUT pcEntries]     --  Where the count of returned entries
//                                      is returned
//              [OUT ppAccessInfoList]  Where the access info list is
//                                      returned.  This consists of a list of
//                                      AccessBit / AccessName pairs
//              [OUT pcRights]      --  Where the count of access rights are returned
//              [OUT ppRightsList]  --  Where the list of access rights are returned
//              [OUT pfAccessFlags] --  Where the access flags are returned.
//                                      This is information about what type
//                                      of access entries this provider
//                                      supports for this object type
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//
//----------------------------------------------------------------------------
DWORD
WINAPI
GetAccessPermissionsForObjectW(IN   LPCWSTR              lpObject,
                               IN   SE_OBJECT_TYPE       ObjectType,
                               IN   LPCWSTR              lpObjectType,
                               IN   LPCWSTR              lpProvider,
                               OUT  PULONG               pcEntries,
                               OUT  PACTRL_ACCESS_INFOW *ppAccessInfoList,
                               OUT  PULONG                pcRights,
                               OUT  PACTRL_CONTROL_INFOW *ppRightsList,
                               OUT  PULONG               pfAccessFlags)
{
    DWORD   dwErr = ERROR_SUCCESS;

    LOAD_PROVIDERS(dwErr);

    //
    // First, verify the parameters.  The providers expect valid parameters
    //
    if(lpObject == NULL || pcEntries == NULL || ppAccessInfoList == NULL ||
             pfAccessFlags == NULL || ppRightsList == NULL || pcRights == NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        //
        // Find the provider
        //
        PACCPROV_PROV_INFO pProvider;
        dwErr = AccProvpGetProviderForPath(lpObject,
                                           ObjectType,
                                           lpProvider,
                                           &gAccProviders,
                                           &pProvider);

        if(dwErr == ERROR_SUCCESS)
        {
            __try
            {
                //
                // Make the call
                //
                dwErr = (*(pProvider->pfObjInfo))(lpObject,
                                                  ObjectType,
                                                  lpObjectType,
                                                  pcEntries,
                                                  ppAccessInfoList,
                                                  pcRights,
                                                  ppRightsList,
                                                  pfAccessFlags);
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                if(pProvider->pfObjInfo == NULL)
                {
                    dwErr = ERROR_BAD_PROVIDER;
                }
                else
                {
                    dwErr = RtlNtStatusToDosError(GetExceptionCode());
                }
            }
        }
    }

    return(dwErr);
}





//+---------------------------------------------------------------------------
//
//  Function:   GetAccessPermissionsForObjectA
//
//  Synopsis:   Ansi version of the above
//
//  Arguments:  [IN  lpObject]      --  Object for which the permissions are
//                                      needed
//              [IN  ObjectType]    --  Type of object specified by lpObject
//              [IN  lpObjectType]  --  Gets the access rights for the specified
//                                      object type
//              [IN  lpProvider]    --  OPTIONAL If known, the provider to
//                                      handle the request.  If NULL, it will
//                                      be discovered
//              [OUT pcEntries]     --  Where the count of returned entries
//                                      is returned
//              [OUT ppAccessInfoList]  Where the access info list is
//                                      returned.  This consists of a list of
//                                      AccessBit / AccessName pairs
//              [OUT pcRights]      --  Where the count of access rights are returned
//              [OUT ppRightsList]  --  Where the list of access rights are returned
//              [OUT pfAccessFlags] --  Where the access flags are returned.
//                                      This is information about what type
//                                      of access entries this provider
//                                      supports for this object type
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD
WINAPI
GetAccessPermissionsForObjectA(IN   LPCSTR                lpObject,
                               IN   SE_OBJECT_TYPE        ObjectType,
                               IN   LPCSTR                lpObjectType,
                               IN   LPCSTR                lpProvider,
                               OUT  PULONG                pcEntries,
                               OUT  PACTRL_ACCESS_INFOA  *ppAccessInfoList,
                               OUT  PULONG                pcRights,
                               OUT  PACTRL_CONTROL_INFOA *ppRightsList,
                               OUT  PULONG                pfAccessFlags)
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // Validate that we have valid parameters to return
    //
    if(ppAccessInfoList == NULL || ppRightsList == NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // First, convert the input parameters
    //
    PWSTR   pwszObject;
    PWSTR   pwszProvider = NULL;
    PWSTR   pwszObjType = NULL;

    dwErr = ConvertStringAToStringW((PSTR)lpObject,
                                    &pwszObject);
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = ConvertStringAToStringW((PSTR)lpProvider,
                                        &pwszProvider);

        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = ConvertStringAToStringW((PSTR)lpObjectType,
                                            &pwszObjType);
        }
    }


    //
    // If that worked, make the call
    //
    if(dwErr == ERROR_SUCCESS)
    {
        PACTRL_ACCESS_INFOW pAccessInfoListW;
        PACTRL_CONTROL_INFOW pRightsListW;
        dwErr = GetAccessPermissionsForObjectW((PCWSTR)pwszObject,
                                               ObjectType,
                                               (PCWSTR)pwszObjType,
                                               (PCWSTR)pwszProvider,
                                               pcEntries,
                                               &pAccessInfoListW,
                                               pcRights,
                                               &pRightsListW,
                                               pfAccessFlags);
        //
        // If it worked, convert it back into a ansi blob.  We can cheat here
        // and actually do it in place, since an ansi string will never be any
        // longer than a wide string
        //
        if(dwErr == ERROR_SUCCESS)
        {
            for(ULONG iIndex = 0; iIndex < *pcEntries; iIndex++)
            {
                wcstombs((PSTR)pAccessInfoListW[iIndex].lpAccessPermissionName,
                         pAccessInfoListW[iIndex].lpAccessPermissionName,
                         wcslen(pAccessInfoListW[iIndex].
                                                 lpAccessPermissionName) + 1);
            }

            *ppAccessInfoList = (PACTRL_ACCESS_INFOA)pAccessInfoListW;

            //
            // Do the same thing with the rights lists
            //
            for(iIndex = 0; iIndex < *pcRights; iIndex++)
            {
                wcstombs((PSTR)pRightsListW[iIndex].lpControlId,
                         pRightsListW[iIndex].lpControlId,
                         wcslen(pRightsListW[iIndex].lpControlId) + 1);

                wcstombs((PSTR)pRightsListW[iIndex].lpControlName,
                         pRightsListW[iIndex].lpControlName,
                         wcslen(pRightsListW[iIndex].lpControlName) + 1);
            }

            *ppRightsList = (PACTRL_CONTROL_INFOA)pRightsListW;
        }
    }

    //
    // Free our memory
    //
    LocalFree(pwszObject);
    LocalFree(pwszProvider);
    LocalFree(pwszObjType);

    return(dwErr);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\accctrl2\src\cacl.cxx ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:        cacl.cxx
//
//  Contents:    class providing merging of an access list and an ACL
//
//  Classes:     CAclBuilder
//
//  History:     Feb-94        Created         DaveMont
//
//--------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop

#define NAME_NOT_FOUND L"Name Not Found"    
//----------------------------------------------------------------------------
//
//  This is rather an odd object.  It's output is either an ACL or a list
//  (array)  of AccessEntries.  As input it takes an (optional) ACL, and
//  (optionally) multiple lists of AccessEntries.  The object maintains the
//  SID, user name, mask, etc. in AccountAccess object.
//
//  The following 3 methods are used to input access information:
//
//      SetAcl           -- can only be called once
//      ClearAll         -- used when a call to replace all access rights is made
//      AddAccessEntries -- adds a list of access entries to the object
//
//  The following method generates an ACL from the information within the object:
//
//      GetAcl           -- allocates and generates a new ACL
//
//  The following method generates a list of access entries from the information
//  within the object.  This list will match an ACL generated by GetAcl
//
//      GetAccessEntries -- allocates and generates a list of AccessEntries
//
//  The following method calculates the effective rights for a trustee based
//  on the access control information within the object (but not on privileges
//  the trustee may have):
//
//      GetEffectiveRights-- returns the effective access rights for trustee
//
//----------------------------------------------------------------------------
//+---------------------------------------------------------------------------
//
//  Member:    ctor, public
//
//  Synopsis:   initializes class member variables
//
//  Arguments: IN - [system] - the machine where the object is
//             IN - [fSaveNamesAndSids] - TRUE if this object is to be transacted
//             IN - [fUsedByProviderIndependentApi] - if TRUE, SYNCHRONIZE and
//                  READ_CONTROL are appended to any allowed masks, thus allowing
//                  PROV_OBJECT_READ, ...WRITE and ...EXECUTE to be non-overlapping.
//
//----------------------------------------------------------------------------
CAcl::CAcl(LPWSTR system,
           IS_CONTAINER fdir,
           BOOL fSaveNamesAndSids,
           BOOL fUsedByProviderIndependentApi)
   :_fused_by_provider_independent_api(fUsedByProviderIndependentApi),
    _aclrevision(ACL_REVISION2),
    _capabilities(0),
    _pcaaacl(NULL),
    _pcaaaes(NULL),
    _pcaaaclindex(0),
    _pcaaaesindex(0),
    _pcacli(NULL),
    _pcaeli(NULL),
    _system(system),
    _fdir(fdir),
    _fsave_names_and_sids(fSaveNamesAndSids)
{
}

//+---------------------------------------------------------------------------
//
//  Member:    dtor, public
//
//  Synopsis:   frees class member variables
//
//----------------------------------------------------------------------------
CAcl::~CAcl()
{
    //
    // have to delete the individual account accesses
    //
    if (_pcaaacl)
    {
        for (ULONG idx = 0; idx < _pcaaaclindex; idx++ )
        {
            delete _pcaaacl[idx];
        }
        AccFree(_pcaaacl);
    }
    if (_pcaaaes)
    {
        for (ULONG idx = 0; idx < _pcaaaesindex; idx++ )
        {
            delete _pcaaaes[idx];
        }
        AccFree(_pcaaaes);
    }
    if (_pcacli)
    {
        delete _pcacli;
    }
    if (_pcaeli)
    {
        delete _pcaeli;
    }
}
//+---------------------------------------------------------------------------
//
//  Member:    new, public
//
//  Synopsis:
//
//----------------------------------------------------------------------------
void * CAcl::operator new(size_t size)
{
    return(RtlAllocateHeap(RtlProcessHeap(), HEAP_ZERO_MEMORY, (ULONG)size));
}
//+---------------------------------------------------------------------------
//
//  Member:    delete, public
//
//  Synopsis:
//
//----------------------------------------------------------------------------
void CAcl::operator delete(void *p, size_t size)
{
    RtlFreeHeap(RtlProcessHeap(), 0, p);
}
//+---------------------------------------------------------------------------
//
//  Member:   SetAcl, public
//
//  Synopsis: Takes an input ACL and converts it into AccountAccess objects.
//
//  Arguments: IN - [pacl] - the acl from the object
//
//----------------------------------------------------------------------------
DWORD CAcl::SetAcl(PACL pacl)
{
    DWORD status;

    //
    // new the iterators if required
    //
    status = _InitIterators();
    if (status != NO_ERROR)
    {
        return(status);
    }
    //
    // initialize the ACL, if it exists
    //
    _pcacli->Init(pacl);

    //
    // allocate space for the ACL's array of account accesses
    // (if there are any ACEs)
    //

    if (_pcacli->NumberEntries() > 0)
    {
        //
        // allocate for the account accesses for the acl
        //
        if ( NULL != (_pcaaacl = (CAccountAccess **)AccAlloc(
                              (_pcacli->NumberEntries() )* sizeof(void *))))
        {
            //
            // initialize the ACLs AccountAccesses (old AAs)
            //

            for (_pcacli->FirstAce(); _pcacli->MoreAces(); _pcacli->NextAce() )
            {
                status = _AddEntry( _pcacli,
                                    &(_pcaaacl[_pcaaaclindex]),
                                    &_pcaaaclindex );
                if (status != NO_ERROR)
                {
                    break;
                }
            }
        } else
        {
            status = ERROR_NOT_ENOUGH_MEMORY;
        }
        //
        // all done with the acl iterator now, clear it.
        //
        _pcacli->Init(NULL);
    }
    return(status);
}
//+---------------------------------------------------------------------------
//
//  Member:   ClearAll, public
//
//  Synopsis: clears the account accesses for the ACL and the access entries
//            (preparatory to doing a replace all API call)
//
//  Arguments:  none
//
//----------------------------------------------------------------------------
DWORD CAcl::ClearAll()
{
    DWORD status;

    //
    // new the iterators if required
    //
    status = _InitIterators();
    if (status != NO_ERROR)
    {
        return(status);
    }
    //
    // clear out the acl, if it exists
    //
    _pcacli->Init(NULL);

    if (_pcaaacl)
    {
        for (ULONG idx = 0; idx < _pcaaaclindex; idx++ )
        {
            delete _pcaaacl[idx];
        }
        AccFree(_pcaaacl);
        _pcaaacl = NULL;
        _pcaaaclindex = 0;
    }
    status = ClearAccessEntries();

    return(status);
}
//+---------------------------------------------------------------------------
//
//  Member:   ClearAccessEntries, public
//
//  Synopsis: clears the access entries AccountAccess objects. (revert)
//
//  Arguments:  none
//
//----------------------------------------------------------------------------
DWORD CAcl::ClearAccessEntries()
{
    if (_pcaaaes)
    {
        for (ULONG idx = 0; idx < _pcaaaesindex; idx++ )
        {
            delete _pcaaaes[idx];
        }
        AccFree(_pcaaaes);
        _pcaaaes = NULL;
        _pcaaaesindex = 0;
    }
    return(NO_ERROR);
}
//+---------------------------------------------------------------------------
//
//  Member:   AddAccessEntries, public
//
//  Synopsis: converts the access entries and ACL into AccountAccess objects,
//
//  Arguments: IN - [ccount] - the number of access entries
//             IN - [pae] - the array of access entries
//
//----------------------------------------------------------------------------
DWORD CAcl::AddAccessEntries( ULONG ccount,
                              PACCESS_ENTRY pae)
{

    DWORD status = NO_ERROR;

    //
    // new the iterators if required
    //
    status = _InitIterators();
    if (status != NO_ERROR)
    {
        return(status);
    }
    //
    // initialize the iterator thru the access entries
    //
    _pcaeli->Init(ccount, pae);

    //
    // do something if there are any access entries
    //
    if (_pcaeli->NumberEntries() > 0)
    {
        //
        // if we have already processed some access entries into
        // AccountAccesses, then we need to make room for more
        // ie. do a re-alloc
        //
        if (_pcaaaes != NULL)
        {
            CAccountAccess **pcaaaestmp;

            if (NULL != (pcaaaestmp = (CAccountAccess **)AccAlloc(
                              (_pcaaaesindex +
                               _pcaeli->NumberEntries() )* sizeof(void *)) ))
            {
                //
                // after allocating enough space for the old and new access
                // entries, move the old AccountAccesses into the new space,
                //
                for (ULONG aeindex = 0; aeindex < _pcaaaesindex; aeindex++)
                {
                    status = _pcaaaes[aeindex]->Clone(&(pcaaaestmp[aeindex]));
                    if (status != NO_ERROR)
                    {
                        break;
                    }
                }
                //
                // free the old list and its contents (AccountAccesses)
                //
                if (status == NO_ERROR)
                {
                    for (ULONG idx = 0; idx < _pcaaaesindex; idx++ )
                    {
                       delete _pcaaaes[idx];
                    }
                    AccFree(_pcaaaes);
                    _pcaaaes = pcaaaestmp;
                } else
                //
                // if something failed, free the new list and what ever contents
                // got initialized
                //
                {
                    for (ULONG idx = 0; idx < aeindex; idx++ )
                    {
                       delete pcaaaestmp[idx];
                    }
                    AccFree(pcaaaestmp);
                }
            }else
            {
                status = ERROR_NOT_ENOUGH_MEMORY;
            }
        } else
        {
            //
            // allocate memory for the account accesses for the access entries
            //
            if (NULL == (_pcaaaes = (CAccountAccess **)AccAlloc(
                              (_pcaeli->NumberEntries() )* sizeof(void *)) ))
            {
                status = ERROR_NOT_ENOUGH_MEMORY;
            }

        }
        if (status == NO_ERROR)
        {
            //
            // save the number of old AccountAccesses so any that are for the
            // same trustee as a new access entry can be overridden (marked
            // unused).
            //
            ULONG countold = _pcaaaesindex;
            //
            // create AccountAccesses for the new access entries
            //
            for (_pcaeli->FirstAe(); _pcaeli->MoreAes(); _pcaeli->NextAe() )
            {
                status = _AddEntry( _pcaeli,
                                    &(_pcaaaes[_pcaaaesindex]),
                                    &_pcaaaesindex );
                if (status != NO_ERROR)
                {
                    break;
                }
            }
        }
    } else
    {
        status = ERROR_INVALID_PARAMETER;
    }
    return(status);
}
//+---------------------------------------------------------------------------
//
//  Member:     BuildAcl, public
//
//  Synopsis:   converts AccountAccess objects into ACEs and builds an ACL
//              this is a two pass operation, the first pass calculates
//              the size required for the ACL, and resolves any conficts
//              between the ACL and access entries.  The second pass
//              builds the ACL.
//
//  Arguments:  OUT - [pacl]  - the returned, built acl
//
//----------------------------------------------------------------------------
DWORD CAcl::BuildAcl(PACL *pacl)
{
    DWORD status = NO_ERROR;
    NTSTATUS ntstatus;
    ULONG cacl_size, cace_count;
    ULONG aceindex = 0;
    ULONG newidx, oldidx;

    //
    // pass1 calculates the size and number of entries for an ACL or list of
    // access entries based on the current contents of this class
    //
    status = _Pass1(&cacl_size, &cace_count, TRUE); // TRUE = build ACL

    //
    // now for pass2, building the ACL.  The first thing to do is to
    // allocate space for the ACL, then add any access entries denies
    // then add any ACL denies, then add any access entries allows,
    // then add any ACL allows.  If any ACL denies are found after the
    // first ACL allow, an error is returned.  In this case the caller must
    // use a replace all option to clear out the old ACL.
    //
    if (status == NO_ERROR)
    {
        *pacl = (PACL)AccAlloc( cacl_size);
        if (*pacl == NULL)
        {
            status = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if (status == NO_ERROR)
    {
        ntstatus = RtlCreateAcl( *pacl,
                                 cacl_size,
                                 ACL_REVISION2 );
        if (!NT_SUCCESS(ntstatus))
        {
            status = RtlNtStatusToDosError(ntstatus);
        }
    }

    if (status == NO_ERROR)
    {
        //
        // Add any access entries denies
        //
        for (ULONG newidx = 0; newidx < _pcaaaesindex ; newidx++ )
        {
            if (_pcaaaes[newidx]->AccessMode() == DENY_ACCESS)
            {
                if (_pcaaaes[newidx]->MultipleTrusteeOperation() ==
                              TRUSTEE_IS_IMPERSONATE)
                {
                    status = ERROR_INVALID_PARAMETER;
                    break;
                }
                if (!NT_SUCCESS(ntstatus = RtlAddAccessDeniedAce(*pacl,
                                           ACL_REVISION2,
                                          _pcaaaes[newidx]->AccessMask(),
                                          _pcaaaes[newidx]->Sid())))
                {
                    status = RtlNtStatusToDosError(ntstatus);
                    break;
                }
                else
                {
                    //
                    // set the inheritance
                    //
                    status = _SetAceFlags( aceindex,
                                           *pacl,
                                           _pcaaaes[newidx] );
                    if (status != NO_ERROR)
                    {
                        break;
                    }
                }
                //
                // increment the count of added aces (so can set any
                // inheritance)
                //
                aceindex++;
            }
        }
    }

    if (status == NO_ERROR)
    {
        //
        // loop thru the ACL AccountAccesses until the first allow
        //
        for (oldidx = 0; oldidx < _pcaaaclindex ; oldidx++ )
        {
            //
            //    add any denys found
            //
            if (_pcaaacl[oldidx]->AccessMode() == DENY_ACCESS)
            {
                if (!NT_SUCCESS(ntstatus = RtlAddAccessDeniedAce(
                                            *pacl,
                                            ACL_REVISION2,
                                            _pcaaacl[oldidx]->AccessMask(),
                                            _pcaaacl[oldidx]->Sid())))
                {
                    status = RtlNtStatusToDosError(ntstatus);
                    break;
                }
                else
                {
                    //
                    // set the inheritance
                    //
                    status = _SetAceFlags( aceindex,
                                           *pacl,
                                           _pcaaacl[oldidx] );
                    if (status != NO_ERROR)
                    {
                        break;
                    }
                }
                //
                // increment the count of added aces (so can set any
                // inheritance)
                //
                aceindex++;

            //
            // accessmode will be set to SE_AUDIT_BOTH in the case
            // where some other utility has put an an ACE to
            // audit both success and failure; this dll will
            // insert two aces when a request is made to set
            // both success and failure auditing
            //
            }
            else if ( (_pcaaacl[oldidx]->AccessMode() ==
                         SET_ACCESS) ||
                        (_pcaaacl[oldidx]->AccessMode() ==
                         SET_AUDIT_SUCCESS) ||
                        (_pcaaacl[oldidx]->AccessMode() ==
                         SET_AUDIT_FAILURE) ||
                        (_pcaaacl[oldidx]->AccessMode() ==
                         SE_AUDIT_BOTH))
            {
                //
                // break at the first allowed ACE
                //
                break;
            }
        } // for
    }

    if (status == NO_ERROR)
    {
        //
        // loop thru the access entries AccountAccesses
        //
        for (newidx = 0; newidx < _pcaaaesindex ; newidx++ )
        {
            //
            //    add any grants or sets found
            //
            if ( (_pcaaaes[newidx]->AccessMode() ==
                  SET_ACCESS) ||
                 (_pcaaaes[newidx]->AccessMode() ==
                  GRANT_ACCESS) )
            {
                if (_pcaaaes[newidx]->MultipleTrusteeOperation() ==
                    TRUSTEE_IS_IMPERSONATE)
                {
                    //
                    // note that no mask translations additions are
                    // done on compound ace masks
                    //
                    if (!NT_SUCCESS(ntstatus = RtlAddCompoundAce(
                                               *pacl,
                                               ACL_REVISION3,
                             COMPOUND_ACE_IMPERSONATION,
                            _pcaaaes[newidx]->AccessMask(),
                            _pcaaaes[newidx]->ImpersonateSid(),
                            _pcaaaes[newidx]->Sid())))
                    {
                        status = RtlNtStatusToDosError(ntstatus);
                        break;
                    }
                }
                else
                {
                    if (!NT_SUCCESS(ntstatus = RtlAddAccessAllowedAce(
                                                *pacl,
                                                ACL_REVISION2,
                                                _pcaaaes[newidx]->AccessMask(),
                                                _pcaaaes[newidx]->Sid())))
                    {
                        status = RtlNtStatusToDosError(ntstatus);
                        break;
                    }
                }

                //
                // set the inheritance
                //
                status = _SetAceFlags( aceindex,
                                       *pacl,
                                       _pcaaaes[newidx] );

                if (status != NO_ERROR)
                {
                    break;
                }
                //
                // increment the count of added aces (so can set
                // any inheritance)
                //
                aceindex++;
            }

            //
            // else add any audit entries
            //
            else if ( (_pcaaaes[newidx]->AccessMode() ==
                         SET_AUDIT_SUCCESS) ||
                        (_pcaaaes[newidx]->AccessMode() ==
                         SET_AUDIT_FAILURE) )
            {
                //
                // allow synchronize and read control if
                // used by provider independent API
                //
                ACCESS_MASK tmpmask;

                if (_fused_by_provider_independent_api)
                {
                    tmpmask = _pcaaaes[newidx]->AccessMask() |
                              SYNCHRONIZE | READ_CONTROL;
                } else
                {
                    tmpmask = _pcaaaes[newidx]->AccessMask();
                }

                if (!NT_SUCCESS(ntstatus = RtlAddAuditAccessAce(
                                           *pacl,
                                           ACL_REVISION2,
                                           tmpmask,
                                          _pcaaaes[newidx]->Sid(),
                                          (_pcaaaes[newidx]->AccessMode() ==
                                              SET_AUDIT_SUCCESS),
                                          (_pcaaaes[newidx]->AccessMode() ==
                                              SET_AUDIT_FAILURE))))
                {
                    status = RtlNtStatusToDosError(ntstatus);
                }
                else
                {
                    //
                    // set the inheritance
                    //
                    status = _SetAceFlags( aceindex,
                                           *pacl,
                                           _pcaaaes[newidx] );
                }

                if (status != NO_ERROR)
                {
                    break;
                }

                //
                // increment the count of added aces (so can set
                // any inheritance)
                //
                aceindex++;
            }

        } // for
    }

    if (status == NO_ERROR)
    {
        //
        // loop thru the rest of the ACLs AccountAccesses
        //
        for (; oldidx < _pcaaaclindex ; oldidx++ )
        {
            //
            //    add any sets found, error if any denys found
            //
            if (_pcaaacl[oldidx]->AccessMode() == SET_ACCESS)
            {
                if (_pcaaacl[oldidx]->MultipleTrusteeOperation() ==
                    TRUSTEE_IS_IMPERSONATE)
                {
                    //
                    // add any impersonate aces
                    //
                    if (!NT_SUCCESS(ntstatus = RtlAddCompoundAce( *pacl,
                                                ACL_REVISION3,
                                                COMPOUND_ACE_IMPERSONATION,
                                             _pcaaacl[oldidx]->AccessMask(),
                                          _pcaaacl[oldidx]->ImpersonateSid(),
                                                    _pcaaacl[oldidx]->Sid())))
                    {
                        status = RtlNtStatusToDosError(ntstatus);
                        break;
                    }
                }
                else
                {
                    //
                    // add an access allowed ACE
                    //
                    if (!NT_SUCCESS(ntstatus = RtlAddAccessAllowedAce(
                                                 *pacl,
                                                 ACL_REVISION2,
                                                 _pcaaacl[oldidx]->AccessMask(),
                                                 _pcaaacl[oldidx]->Sid())))
                    {
                        status = RtlNtStatusToDosError(ntstatus);
                        break;
                    }
                }

                //
                // set the inheritance
                //
                status = _SetAceFlags( aceindex,
                                       *pacl,
                                       _pcaaacl[oldidx] );
                if (status != NO_ERROR)
                {
                    break;
                }

                //
                // increment the count of added aces (so can
                // set any inheritance)
                //
                aceindex++;

            }
            //
            // add any audit aces
            //
            else if ( (_pcaaacl[oldidx]->AccessMode() == SET_AUDIT_SUCCESS) ||
                      (_pcaaacl[oldidx]->AccessMode() == SET_AUDIT_FAILURE) ||
                      (_pcaaacl[oldidx]->AccessMode() == SE_AUDIT_BOTH))
            {
                //
                // allow synchronize and read control if
                // used by provider independent API
                // also note that if an audit both ace
                // existed before, and is not being modified,
                // no changes are made to the ace
                //

                ACCESS_MASK tmpmask;

                if (_fused_by_provider_independent_api)
                {
                    tmpmask = _pcaaacl[oldidx]->AccessMask() |
                              SYNCHRONIZE | READ_CONTROL;
                } else
                {
                    tmpmask = _pcaaacl[oldidx]->AccessMask();
                }

                //
                // add an audit ace
                //
                if (!NT_SUCCESS(ntstatus = RtlAddAuditAccessAce(
                                             *pacl,
                                             ACL_REVISION2,
                                             tmpmask,
                                             _pcaaacl[oldidx]->Sid(),
                                             (_pcaaacl[oldidx]->AccessMode() ==
                                                 SET_AUDIT_SUCCESS),
                                             (_pcaaacl[oldidx]->AccessMode() ==
                                                 SET_AUDIT_FAILURE))))
                {
                    status = RtlNtStatusToDosError(ntstatus);
                    break;
                }
                else
                {
                    //
                    // set the inheritance
                    //
                    status = _SetAceFlags( aceindex,
                                           *pacl,
                                           _pcaaacl[oldidx] );
                    if (status != NO_ERROR)
                    {
                        break;
                    }
                }

                //
                // increment the count of added aces (so can
                // set any inheritance)
                //
                aceindex++;
            }

            //
            // unless the entry was marked as not used, it is
            // out of order
            //
            else if (_pcaaacl[oldidx]->AccessMode() !=
                       NOT_USED_ACCESS)

            {
               status = ERROR_INVALID_ACL;
               break;
            }
        } // for

    }

    if (status != NO_ERROR)
    {
        if (*pacl != NULL)
        {
            AccFree(*pacl);
        }
    }

    return(status);
}
//+---------------------------------------------------------------------------
//
//  Member:     BuildAccessEntries, public
//
//  Synopsis:  converts the ACL and access entries AccountAccesses into
//             access entries.  This is also a 2 pass operation, the first
//             pass calculates the size and the second pass resolves conflicts,
//             allocates memory and builds the access entries to return
//
//  Arguments:  OUT - [csize]  - the returned size of the access entries
//              OUT - [ccount]  - the returned count of access entries
//              OUT - [pae]  - the returned list of access entries, this buffer
//                             and each trustee name in it must be freed using
//                             AccFree (or see below)
//              IN - [fAbsolute]  - If TRUE the returned access entries are in a
//                                  single buffer and must be freed with a single
//                                  call to AccFree
//
//----------------------------------------------------------------------------
DWORD CAcl::BuildAccessEntries(PULONG csize,
                                 PULONG ccount,
                                 PACCESS_ENTRY *pae,
                                 BOOL fAbsolute)
{
    DWORD status = NO_ERROR;

    //
    // pass1 resolve conflicts and get the size of the access entries based on
    // the current contents of this class
    //
    status = _Pass1(csize, ccount, FALSE); // FALSE:build access entries
    if (status == NO_ERROR)
    {
        //
        // allocate space for the new entries
        //
        if ( NULL != (*pae = (PACCESS_ENTRY)AccAlloc(*csize) ) )
        {
            //
            // get a pointer to where the names will be put
            //
            LPWSTR nameptr = (LPWSTR)((PBYTE)(*pae) + sizeof(ACCESS_ENTRY) *
                                                *ccount);

            ULONG cintcount = 0;
            //
            // loop thru the access entries AccountAccesses
            //
            for (ULONG newidx = 0; newidx < _pcaaaesindex ; newidx++ )
            {
                //
                //    add any denys found
                //
                if (_pcaaaes[newidx]->AccessMode() == DENY_ACCESS)
                {
                    _BuildAccessEntry(_pcaaaes[newidx],
                                      &nameptr,
                                      &((*pae)[cintcount++]),
                                      fAbsolute);
                }
            }

            //
            // loop thru the ACL AccountAccesses until the first allow
            //
            for (ULONG oldidx = 0; oldidx < _pcaaaclindex ; oldidx++ )
            {
                //
                //    add any denys found
                //
                if (_pcaaacl[oldidx]->AccessMode() == DENY_ACCESS)
                {
                    _BuildAccessEntry(_pcaaacl[oldidx],
                                      &nameptr,
                                      &((*pae)[cintcount++]),
                                      fAbsolute);

                } else if ( (_pcaaacl[oldidx]->AccessMode() ==
                             SET_ACCESS)  ||
                            (_pcaaacl[oldidx]->AccessMode() ==
                             SET_AUDIT_SUCCESS) ||
                            (_pcaaacl[oldidx]->AccessMode() ==
                             SET_AUDIT_FAILURE) ||
                            (_pcaaacl[oldidx]->AccessMode() ==
                             SE_AUDIT_BOTH))
                {
                    //
                    // break at the first allowed ACE
                    //
                    break;
                }
            }
            //
            // loop thru the access entries AccountAccesses
            //
            for (newidx = 0; newidx < _pcaaaesindex ; newidx++)
            {
                //
                //    add any grants or sets found
                //
                if (  (_pcaaaes[newidx]->AccessMode() ==
                       SET_ACCESS) ||
                      (_pcaaaes[newidx]->AccessMode() ==
                       GRANT_ACCESS) ||
                      (_pcaaaes[newidx]->AccessMode() ==
                       SET_AUDIT_SUCCESS) ||
                      (_pcaaaes[newidx]->AccessMode() ==
                       SET_AUDIT_FAILURE) )
                {
                    _BuildAccessEntry(_pcaaaes[newidx],
                                      &nameptr,
                                      &((*pae)[cintcount++]),
                                      fAbsolute);
                }
            }
            //
            // loop thru the rest of the ACLs AccountAccesses
            //
            for (; oldidx < _pcaaaclindex ; oldidx++)
            {
                //
                //    add any sets found, error if any denys found
                //
                if ( (_pcaaacl[oldidx]->AccessMode() ==
                      SET_ACCESS)  ||
                     (_pcaaacl[oldidx]->AccessMode() ==
                      SET_AUDIT_SUCCESS) ||
                     (_pcaaacl[oldidx]->AccessMode() ==
                      SET_AUDIT_FAILURE))
                {
                    _BuildAccessEntry(_pcaaacl[oldidx],
                                      &nameptr,
                                      &((*pae)[cintcount++]),
                                      fAbsolute);
                //
                // unless the entry was marked as not used, it is
                // out of order
                //
                } else if (_pcaaacl[oldidx]->AccessMode() ==
                           SE_AUDIT_BOTH)
                {
                    _BuildDualAuditEntries(_pcaaacl[oldidx],
                                           &nameptr,
                                           *pae,
                                           &cintcount,
                                           fAbsolute);

                } else if (_pcaaacl[oldidx]->AccessMode() !=
                           NOT_USED_ACCESS)

                {
                   status = ERROR_INVALID_ACL;
                   AccFree(*pae);
                   break;
                }
            }
            ASSERT(*ccount == cintcount);
        } else
        {
            status = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    return(status);
}
#if 0
//+---------------------------------------------------------------------------
//
//  Member:     GetEffectiveRights, public
//
//  Synopsis:   grovels the CACLs AccountAccess objects to determine the trustees
//              effective access rights
//
//  Arguments:  IN - [ptrustee]  - the name of the trustee to get effective right
//              OUT - [accessmask] - effective rights for the trustee
//
//----------------------------------------------------------------------------
DWORD CAcl::GetEffectiveRights( PTRUSTEE ptrustee,
                                PACCESS_MASK accessmask)
{
    DWORD status = NO_ERROR;
    CAccountAccess caa;

    //
    // initialize the account access for the trustee depending on type
    // of trustee
    //
    if (ptrustee->TrusteeForm == TRUSTEE_IS_SID)
    {
        status = caa.Init( (PSID)ptrustee->ptstrName,
                           _system,
                           SET_ACCESS,
                           0,
                           0,
                           FALSE);
    }
    else if (ptrustee->TrusteeForm == TRUSTEE_IS_NAME)
    {
        status = caa.Init( ptrustee->ptstrName,
                           _system,
                           SET_ACCESS,
                           0,
                           0,
                           FALSE);
    }
    else
    {
        status = ERROR_NOT_SUPPORTED;
    }

    if (status == NO_ERROR)
    {
        //
        // a class to do the member check
        //
        CMemberCheck cmc(&caa);

        //
        // initialized the class
        //
        status = cmc.Init();
        if (status == NO_ERROR)
        {
            ACCESS_MASK allowmask = 0, denymask = 0;

            for (ULONG newidx = 0; newidx < _pcaaaesindex ; newidx++ )
            {
                //
                //    add any denys found
                //
                if (_pcaaaes[newidx]->AccessMode() == DENY_ACCESS)
                {
                    status = _ComputeEffective( _pcaaaes[newidx],
                                                &cmc,
                                                &allowmask,
                                                &denymask);
                    if (status != NO_ERROR)
                    {
                        break;
                    }
                }
            }
            if (status == NO_ERROR)
            {
                //
                // loop thru the ACL AccountAccesses until the first allow
                //
                for (ULONG oldidx = 0; oldidx < _pcaaaclindex ; oldidx++ )
                {
                    //
                    //    add any denys found
                    //
                    if (_pcaaacl[oldidx]->AccessMode() == DENY_ACCESS)
                    {
                        status = _ComputeEffective( _pcaaacl[oldidx],
                                                    &cmc,
                                                    &allowmask,
                                                    &denymask );
                        if (status != NO_ERROR)
                        {
                            break;
                        }
                    }
                    else if (_pcaaacl[oldidx]->AccessMode() == SET_ACCESS)
                    {
                        //
                        // break at the first allowed ACE
                        //
                        break;
                    }
                    else if ( (_pcaaacl[oldidx]->AccessMode() ==
                                  SET_AUDIT_SUCCESS) ||
                              (_pcaaacl[oldidx]->AccessMode() ==
                                  SET_AUDIT_FAILURE) ||
                              (_pcaaacl[oldidx]->AccessMode() ==
                                  SE_AUDIT_BOTH) )
                    {
                        //
                        // we should not encounter any audit aces when
                        // we are checking for effective access rights
                        //
                        status = ERROR_INVALID_ACL;
                        break;
                    }
                }
                if (status == NO_ERROR)
                {
                    //
                    // loop thru the access entries AccountAccesses
                    //
                    for (newidx = 0; newidx < _pcaaaesindex ; newidx++ )
                    {
                        //
                        //    add any grants, or sets found
                        //
                        if ( (_pcaaaes[newidx]->AccessMode() ==
                              SET_ACCESS) ||
                             (_pcaaaes[newidx]->AccessMode() ==
                              GRANT_ACCESS) )
                        {
                            status = _ComputeEffective( _pcaaaes[newidx],
                                                        &cmc,
                                                        &allowmask,
                                                        &denymask );
                            if (status != NO_ERROR)
                            {
                                break;
                            }
                        }
                        else if ( (_pcaaaes[newidx]->AccessMode() ==
                                      SET_AUDIT_SUCCESS) ||
                                  (_pcaaaes[newidx]->AccessMode() ==
                                      SET_AUDIT_FAILURE) ||
                                  (_pcaaaes[newidx]->AccessMode() ==
                                      SE_AUDIT_BOTH) )
                        {
                            //
                            // we should not encounter any audit aces when
                            // we are checking for effective access rights
                            //
                            status = ERROR_INVALID_ACL;
                            break;
                        }
                    }
                    if (status == NO_ERROR)
                    {
                        //
                        // loop thru the rest of the ACLs AccountAccesses
                        //
                        for (; oldidx < _pcaaaclindex ; oldidx++ )
                        {
                            //
                            //    add any sets or audits found, error if any
                            //    denys found
                            //
                            if ( (_pcaaacl[oldidx]->AccessMode() ==
                                  SET_ACCESS) )
                            {
                                status = _ComputeEffective( _pcaaacl[oldidx],
                                                            &cmc,
                                                            &allowmask,
                                                            &denymask );
                                if (status != NO_ERROR)
                                {
                                    break;
                                }
                            }
                            else if (_pcaaacl[oldidx]->AccessMode() !=
                                        NOT_USED_ACCESS)

                            {
                                //
                                // unless the entry was marked as not used, it is
                                // out of order
                                //
                                status = ERROR_INVALID_ACL;
                                break;
                            }
                        }
                    }
                }
            }
            if (status == NO_ERROR)
            {
                //
                // set the effective rights to be the alloweds minus the denieds
                // (because of required ordering)
                //
                *accessmask = allowmask & ~denymask;
            }
        }
    }


    return(status);
}
//+---------------------------------------------------------------------------
//
//  Member:     GetAuditedRights, public
//
//  Synopsis:   grovels the CACLs AccountAccess objects to determine the trustees
//              audited rights
//
//  Arguments:  IN - [ptrustee]  - the name of the trustee to get effective right
//              OUT - [successmask] - success audited rights for the trustee
//              OUT - [failuremask] - failure audited rights for the trustee
//
//----------------------------------------------------------------------------
DWORD CAcl::GetAuditedRights(PTRUSTEE ptrustee,
                               PACCESS_MASK successmask,
                               PACCESS_MASK failuremask)
{
    DWORD status;
    CAccountAccess caa;


    *successmask = 0;
    *failuremask = 0;

    //
    // initialize the account access for the trustee depending on form of
    // trustee
    //
    if (ptrustee->TrusteeForm == TRUSTEE_IS_SID)
    {
        status = caa.Init( (PSID)ptrustee->ptstrName,
                           _system,
                           SET_ACCESS,
                           0,
                           0,
                           FALSE );
    }
    else if (ptrustee->TrusteeForm == TRUSTEE_IS_NAME)
    {
        status = caa.Init( ptrustee->ptstrName,
                           _system,
                           SET_ACCESS,
                           0,
                           0,
                           FALSE );
    }
    else
    {
        status = ERROR_NOT_SUPPORTED;
    }

    if (status == NO_ERROR)
    {
        //
        // a class to do the member check
        //
        CMemberCheck cmc(&caa);

        //
        // initialized the class
        //
        status = cmc.Init();
        if (status == NO_ERROR)
        {
            //
            // loop thru the access entry accesses
            //
            for (ULONG newidx = 0; newidx < _pcaaaesindex ; newidx++ )
            {
                //
                // no access convered by ace with inherit only flag on
                //
                if (0 == (_pcaaaes[newidx]->AceFlags() & INHERIT_ONLY_ACE ) )
                {
                    BOOL fresult;

                    //
                    // check if the trustee is a member of the account access id
                    //
                    status = cmc.IsMemberOf( _pcaaaes[newidx],
                                             &fresult );
                    if (status == NO_ERROR)
                    {
                        if (fresult == TRUE)
                        {
                            //
                            // then decide which type to add it to
                            //
                            if ( (_pcaaaes[newidx]->AccessMode() ==
                                  SET_AUDIT_SUCCESS) ||
                                 (_pcaaaes[newidx]->AccessMode() ==
                                  SE_AUDIT_BOTH) )
                            {
                                *successmask |=_pcaaaes[newidx]->AccessMask();
                            }

                            if ( (_pcaaaes[newidx]->AccessMode() ==
                                  SET_AUDIT_FAILURE) ||
                                 (_pcaaaes[newidx]->AccessMode() ==
                                  SE_AUDIT_BOTH) )
                            {
                                *failuremask |=_pcaaaes[newidx]->AccessMask();
                            }
                        }
                     }
                     else
                     {
                         break;
                     }
                }
            }

            if (status == NO_ERROR)
            {
                //
                // loop thru the ACL AccountAccesses
                //
                for (ULONG oldidx = 0; oldidx < _pcaaaclindex ; oldidx++ )
                {
                    //
                    // no access convered by ace with inherit only flag on
                    //
                    if (0 == (_pcaaacl[oldidx]->AceFlags() & INHERIT_ONLY_ACE ) )
                    {
                        BOOL fresult;

                        //
                        // check if the trustee is a member of the account
                        //  access id
                        //
                        status = cmc.IsMemberOf( _pcaaacl[oldidx],
                                                 &fresult );
                        if (status == NO_ERROR)
                        {
                            if (fresult == TRUE)
                            {
                                //
                                // then decide which type to add it to
                                //
                                if ( (_pcaaacl[oldidx]->AccessMode() ==
                                                             SET_AUDIT_SUCCESS) ||
                                     (_pcaaacl[oldidx]->AccessMode() ==
                                                             SE_AUDIT_BOTH) )
                                {
                                    *successmask |=_pcaaacl[oldidx]->AccessMask();
                                }
                                if ( (_pcaaacl[oldidx]->AccessMode() ==
                                                             SET_AUDIT_FAILURE) ||
                                     (_pcaaacl[oldidx]->AccessMode() ==
                                                             SE_AUDIT_BOTH) )
                                {
                                    *failuremask |=_pcaaacl[oldidx]->AccessMask();
                                }
                            }
                         }
                         else
                         {
                             break;
                         }
                    }
                }
            }
        }
    }

    return(status);
}
#endif
//+---------------------------------------------------------------------------
//
//  Member:     _InitIterators, private
//
//  Synopsis:   resolves any conficts between the ACL and access entries,
//              and calculates the size required for an ACL or access entries
//              to return
//
//  Arguments:  none
//
//----------------------------------------------------------------------------
DWORD CAcl::_InitIterators()
{
    DWORD status = NO_ERROR;
    //
    // new the iterators if required
    //
    if (_pcacli == NULL)
    {
        if (NULL == (_pcacli = new CAclIterator()))
        {
            status = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if (status == NO_ERROR)
    {
        if (_pcaeli == NULL)
        {
            if (NULL == (_pcaeli = new CAesIterator()))
            {
                status = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    }
    return(status);
}
//+---------------------------------------------------------------------------
//
//  Member:     _Pass1, private
//
//  Synopsis:   resolves any conficts between the ACL and access entries,
//              and calculates the size required for an ACL or access entries
//              to return
//
//  Arguments:  [OUT] cSize - the size required for an ACL or access entries
//              [OUT] cCount - the count of ACEs or access entries
//              [IN] fBuildAcl - if FALSE, calculate size for access entries
//
//----------------------------------------------------------------------------
DWORD CAcl::_Pass1(PULONG cSize, PULONG cCount, BOOL fBuildAcl)
{

    DWORD status = NO_ERROR;
    BOOL useentry;

    //
    // initialize the size.
    //
    *cSize = fBuildAcl ? sizeof(ACL) : 0;
    *cCount = 0;

    //
    // assume that we are using all the (remaining) ACL entries
    // (ie. whats one more loop)
    //
    for (ULONG aclindex = 0; aclindex < _pcaaaclindex; aclindex++)
    {
        //
        // don't process any entries marked not used
        //
        if (_pcaaacl[aclindex]->AccessMode() != NOT_USED_ACCESS)
        {
            status = _UseEntry( _pcaaacl[aclindex],
                                cSize,
                                cCount,
                                fBuildAcl );
            if (status != NO_ERROR)
            {
                break;
            }
        }
    }
    //
    // if there are any access entries, resolve any conflicts
    //
    for (ULONG aeindex = 0; aeindex < _pcaaaesindex; aeindex++)
    {
        //
        // don't process any entries already marked not used.
        // (perhaps from a previous pass)
        //
        if (_pcaaaes[aeindex]->AccessMode() != NOT_USED_ACCESS)
        {
            //
            // first check for matching SIDs in the ACL
            //
            status = _CheckEntryList( _pcaaaes[aeindex],
                                      _pcaaacl,
                                      _pcaaaclindex,
                                      cSize,
                                      cCount,
                                      fBuildAcl );
            if (status != NO_ERROR)
            {
                break;
            }
            //
            // if the entry is still needed (access not already provided
            // by a previous entry), check the access entries list for matches
            //
            if (_pcaaaes[aeindex]->AccessMode() != NOT_USED_ACCESS)
            {
                //
                // then check for matching SIDS in any previous access entries
                //
                status = _CheckEntryList( _pcaaaes[aeindex],
                                          _pcaaaes,
                                          aeindex,
                                          cSize,
                                          cCount,
                                          fBuildAcl );
                if (status != NO_ERROR)
                {
                    break;
                }
                //
                // all done checking, if we still want the entry, use it
                //

                if ( (_pcaaaes[aeindex]->AccessMode() != NOT_USED_ACCESS) &&
                     (_pcaaaes[aeindex]->AccessMode() != REVOKE_ACCESS) )
                {
                    status = _UseEntry( _pcaaaes[aeindex],
                                        cSize,
                                        cCount,
                                        fBuildAcl );
                    if (status != NO_ERROR)
                    {
                        break;
                    }
                }
            }
        }
    }
    return(status);
}
//+---------------------------------------------------------------------------
//
//  Member:     _CheckEntryList, private
//
//  Synopsis:   resolves any conficts between the ACL and access entries,
//              and calculates the size required for an ACL or access entries
//              to return
//
//  Arguments:  [IN] pCAA - the Account Access class to check for matches against
//                          the list of account accessses
//              [IN] plistCAA - the list of account accesses to search thru
//              [IN] clistlength - the number of entries in the list
//              [IN/OUT] cSize - the size required for an ACL or access entries
//              [IN/OUT] cCount - the size required for an ACL or access entries
//              [IN] fBuildAcl - if FALSE, calculate size for access entries
//
//----------------------------------------------------------------------------
DWORD CAcl::_CheckEntryList(CAccountAccess *pCAA,
                            CAccountAccess **plistCAA,
                            ULONG clistlength,
                            PULONG cSize,
                            PULONG cCount,
                            BOOL fBuildAcl)
{
    DWORD status = NO_ERROR;

    BOOL dontuseentry = FALSE;

    for (ULONG index = 0; index < clistlength; index++)
    {
        //
        // don't process any entries already marked not used.
        // (perhaps from a previous pass)
        //
        if (plistCAA[index]->AccessMode() != NOT_USED_ACCESS)
        {
            //
            // check for matching ids (and matching modes, see
            // accesscontrolcdd.doc for a full explaination of this)
            // this impersonate stuff is specifically for DS objects,
            // and the kind of ace management they do (specifically, see
            // notes on DS object specific permissions, and query access
            //
            if ( (RtlEqualSid( pCAA->Sid(), plistCAA[index]->Sid())) &&
                 ( ( (pCAA->AccessMode() == DENY_ACCESS) ||
                     (plistCAA[index]->AccessMode() == DENY_ACCESS) ) ||
                   ( (pCAA->MultipleTrusteeOperation() != TRUSTEE_IS_IMPERSONATE) &&
                     (plistCAA[index]->MultipleTrusteeOperation() != TRUSTEE_IS_IMPERSONATE) ||
                   ( (pCAA->MultipleTrusteeOperation() == TRUSTEE_IS_IMPERSONATE) &&
                     (plistCAA[index]->MultipleTrusteeOperation() == TRUSTEE_IS_IMPERSONATE) ))))
            {

                //
                // do things based on the type of the new entry
                //
                switch (pCAA->AccessMode())
                {
                case GRANT_ACCESS:
                case DENY_ACCESS:
                    //
                    // merge the entries
                    //
                    status = _MergeEntries(pCAA,
                                           plistCAA[index],
                                           cSize,
                                           cCount,
                                           fBuildAcl);
                    break;
                case SET_ACCESS:
                case REVOKE_ACCESS:
                case SET_AUDIT_SUCCESS:
                case SET_AUDIT_FAILURE:
                    //
                    // don't use the old entry (since the new one takes
                    // precedence)
                    //

                    status = _RemoveEntry(plistCAA[index],
                                          cSize,
                                          cCount,
                                          fBuildAcl);
                    break;
                default:
                    ASSERT( (pCAA->AccessMode() != GRANT_ACCESS  ) ||
                            (pCAA->AccessMode() != DENY_ACCESS   ) ||
                            (pCAA->AccessMode() != SET_ACCESS    ) ||
                            (pCAA->AccessMode() != REVOKE_ACCESS ) ||
                            (pCAA->AccessMode() != SET_AUDIT_SUCCESS ) ||
                            (pCAA->AccessMode() != SET_AUDIT_FAILURE ) );
                    break;
                }
            }
        }
    }
    return(status);
}
//+---------------------------------------------------------------------------
//
//  Member:     _UseEntry, private
//
//  Synopsis:   uses the entry for the ACL or access entries being built
//
//  Arguments:  [IN] pCAA - the Account Access class to use
//              [IN/OUT] cSize - the size required for an ACL or access entries
//              [IN/OUT] cCount - the size required for an ACL or access entries
//              [IN] fBuildAcl - if FALSE, calculate size for access entries
//
//----------------------------------------------------------------------------
DWORD CAcl::_UseEntry(CAccountAccess *pCAA,
                        PULONG cSize,
                        PULONG cCount,
                        BOOL fBuildAcl)
{
    DWORD status = NO_ERROR;

    if (fBuildAcl)
    {
        //
        // increment the count (of aces in this case)
        // and grow the size
        //
        (*cSize) += _GetAceSize(pCAA);

    } else
    {
        //
        // get the size of the access entry
        //
        ULONG centrysize;

        status = _GetAccessEntrySize( pCAA,
                                      &centrysize);
        if (status == NO_ERROR)
        {
            (*cSize) += centrysize;
            if (pCAA->AccessMode() == SE_AUDIT_BOTH)
            {
                //
                // if it is an audit both (success and failure) ACE,
                // add two access entries
                //
                (*cSize) += centrysize;
                (*cCount)++;
            }
        }
    }
    //
    // increment the count (of access entries)
    //
    (*cCount)++;
    return(status);
}
//+---------------------------------------------------------------------------
//
//  Member:     _RemoveEntry, private
//
//  Synopsis:   removes the entry from those to be used for the ACL or access
//              entries being built
//
//  Arguments:  [IN] pCAA - the Account Access class to not use
//              [IN/OUT] cSize - the size required for an ACL or access entries
//              [IN/OUT] cCount - the size required for an ACL or access entries
//              [IN] fBuildAcl - if FALSE, calculate size for access entries
//
//----------------------------------------------------------------------------
DWORD CAcl::_RemoveEntry(CAccountAccess *pCAA,
                           PULONG cSize,
                           PULONG cCount,
                           BOOL fBuildAcl)
{
    DWORD status = NO_ERROR;

    ASSERT(pCAA->AccessMode() != NOT_USED_ACCESS);

    if (fBuildAcl)
    {
        //
        // increment the count (of aces in this case)
        // and grow the size
        //
        (*cSize) -= _GetAceSize(pCAA);
    } else
    {
        //
        // get the size of the access entry
        //
        ULONG centrysize;

        status = _GetAccessEntrySize( pCAA,
                                      &centrysize );
        if (status == NO_ERROR)
        {
            (*cSize) -= centrysize;
        }
    }
    //
    // increment the count (of access entries)
    //
    (*cCount)--;
    pCAA->SetAccessMode(NOT_USED_ACCESS);
    return(status);
}
//+---------------------------------------------------------------------------
//
//  Member:     _MergeEntries, private
//
//  Synopsis:   this merge function checks two access entries with matching
//              SIDs for inheritance and mask intersections.  It is assumed that
//              the new access entry is either DENY_ACCESS or GRANT_ACCESS,
//              and the old entry is either DENY_ACCESS, GRANT_ACCESS, or SET_ACCESS
//
//  Arguments:  [IN] pnewCAA - the new Account Access class to merge with the
//                             old one
//              [IN] poldCAA - the old Account Access class
//              [IN/OUT] cSize - the size required for an ACL or access entries
//              [IN/OUT] cCount - the size required for an ACL or access entries
//              [IN] fBuildAcl - if FALSE, calculate size for access entries
//
//----------------------------------------------------------------------------
DWORD CAcl::_MergeEntries(CAccountAccess *pnewCAA,
                            CAccountAccess *poldCAA,
                            PULONG cSize,
                            PULONG cCount,
                            BOOL fBuildAcl)
{

    DWORD status = NO_ERROR;
    BOOL leave_old_ace = FALSE;

    //
    // bogus while loop for fake gotos
    //
    while(1)
    {
        //
        // can't set inheritance on objects
        //
        if ( ( (_fdir == ACCESS_TO_UNKNOWN ) ||
               (_fdir == ACCESS_TO_OBJECT ) ) &&
             (0 != pnewCAA->AceFlags()) )
        {
            status = ERROR_INVALID_PARAMETER;
            break;
        } else if (_fdir == ACCESS_TO_CONTAINER )
        {
            //
            // check for inheritance intersections
            //
            if (0 == (pnewCAA->AceFlags() & poldCAA->AceFlags()))
            {
                //
                // if disjoint inheritance, the entries really don't match
                //
                break;

            } else if (pnewCAA->AceFlags() != poldCAA->AceFlags())
            {
                //
                // if the entries inheritance intersects in some way, return an
                // error (can only set or revoke access in this case)
                //
                status = ERROR_INVALID_PARAMETER;
                break;
            }
        }
        //
        // now to merge the masks, switch on mask intersection type, and
        // then on entry types,
        // NOTE that SYNCHRONIZE and READ_CONTROL are always added on the
        // mask compares, however
        // it is only actually applied on the SET_ACCESS ACEs, so that, for
        // example, READ can be allowed, and WRITE can be denied (as opposed to
        // not granted).
        //
        if (0 == ((pnewCAA->AccessMask() | SYNCHRONIZE | READ_CONTROL) &
                  (poldCAA->AccessMask() | SYNCHRONIZE | READ_CONTROL)))
        {
            //
            // disjoint
            //
            if ( (pnewCAA->AccessMode() == poldCAA->AccessMode()) ||
                 ( (pnewCAA->AccessMode() != DENY_ACCESS) &&
                   (poldCAA->AccessMode() != DENY_ACCESS) ) )
            {
                //
                // equivalent modes
                //
                pnewCAA->SetAccessMask(pnewCAA->AccessMask() |
                                       poldCAA->AccessMask());
                status = _RemoveEntry(poldCAA,
                                      cSize,
                                      cCount,
                                      fBuildAcl);
            }
        } else if ((pnewCAA->AccessMask() | SYNCHRONIZE | READ_CONTROL) ==
                   (poldCAA->AccessMask() | SYNCHRONIZE | READ_CONTROL) )
        {
            //
            // equal
            //
            status = _RemoveEntry(poldCAA,
                                  cSize,
                                  cCount,
                                  fBuildAcl);

        } else if ( (poldCAA->AccessMask() | pnewCAA->AccessMask() |
                     SYNCHRONIZE | READ_CONTROL) ==
                    (poldCAA->AccessMask() | SYNCHRONIZE | READ_CONTROL))
        {
            //
            // new is subset of old
            //
            if ( (pnewCAA->AccessMode() == poldCAA->AccessMode()) ||
                 ( (pnewCAA->AccessMode() != DENY_ACCESS) &&
                   (poldCAA->AccessMode() != DENY_ACCESS) ) )
            {
                //
                // equivalent modes
                //
                pnewCAA->SetAccessMode(NOT_USED_ACCESS);
            } else
            {
                //
                // one is deny, one is allow
                //
                poldCAA->SetAccessMask(poldCAA->AccessMask() &
                                       ~(pnewCAA->AccessMask()));
            }
        } else if ( (poldCAA->AccessMask() | pnewCAA->AccessMask() |
                     SYNCHRONIZE | READ_CONTROL) ==
                    (pnewCAA->AccessMask() | SYNCHRONIZE | READ_CONTROL))
        {
            //
            // old is subset of new
            //
            status = _RemoveEntry(poldCAA,
                                  cSize,
                                  cCount,
                                  fBuildAcl);
        } else
        {
            //
            // overlapping
            //
            if ( ( (pnewCAA->AccessMode() | SYNCHRONIZE | READ_CONTROL) ==
                   (poldCAA->AccessMode() | SYNCHRONIZE | READ_CONTROL) ) ||
                 ( (pnewCAA->AccessMode() != DENY_ACCESS) &&
                   (poldCAA->AccessMode() != DENY_ACCESS) ) )
            {
                //
                // equivalent modes
                //
                pnewCAA->SetAccessMask(pnewCAA->AccessMask() |
                                       poldCAA->AccessMask());
                status = _RemoveEntry(poldCAA,
                                      cSize,
                                      cCount,
                                      fBuildAcl);
            } else
            {
                //
                // one is deny, one is allow
                //
                poldCAA->SetAccessMask(poldCAA->AccessMask() &
                                       ~(pnewCAA->AccessMask()));
            }
        }
        break;
    }
    return(status);
}
//+---------------------------------------------------------------------------
//
//  Member:     _BuildAccessEntry, private
//
//  Synopsis:   converts an AccountAccess into an access entry
//
//  Arguments:  [IN] pCAA - the AccountAccess being converted to an access entry
//              [IN] nameptr - where to put the trustee name
//              [OUT] pAccessEntry - access entry to be stuffed
//              [IN] fAbsolute - if TRUE, trustee names are pointers
//
//+---------------------------------------------------------------------------
void CAcl::_BuildAccessEntry(CAccountAccess *pCAA,
                             LPWSTR *nameptr,
                             PACCESS_ENTRY pAccessEntry,
                             BOOL fAbsolute)
{

    pAccessEntry->AccessMode = pCAA->AccessMode();
    pAccessEntry->InheritType = (pCAA->AceFlags() & ACLBUILD_VALID_ACE_FLAGS);
    pAccessEntry->AccessMask = pCAA->AccessMask();

    //
    // now to make the trustee, first the single one
    //
    if (NULL != pCAA->Name())
    {
        wcscpy(*nameptr, pCAA->Name());
    } else
    {
        wcscpy(*nameptr, NAME_NOT_FOUND);
    }
    BuildTrusteeWithName(&(pAccessEntry->Trustee), *nameptr);
    //
    // return the real (simplified) trustee type
    //
    switch (pCAA->SidType())
    {
    case SidTypeUser:
        pAccessEntry->Trustee.TrusteeType = TRUSTEE_IS_USER;
        break;
    case SidTypeGroup:
    case SidTypeDomain:
    case SidTypeAlias:
    case SidTypeWellKnownGroup:
        pAccessEntry->Trustee.TrusteeType = TRUSTEE_IS_GROUP;
        break;
    case SidTypeDeletedAccount:
    case SidTypeInvalid:
    case SidTypeUnknown:
    default:
        pAccessEntry->Trustee.TrusteeType = TRUSTEE_IS_UNKNOWN;
        break;
    }
    //
    // increment to the next trustee
    //
    *nameptr = (LPWSTR)((PBYTE)(*nameptr) + (wcslen(*nameptr) + 1) * sizeof(WCHAR));

    //
    // now if there is a multiple trustee
    //
    if (pCAA->MultipleTrusteeOperation() == TRUSTEE_IS_IMPERSONATE)
    {
        //
        // make space for the impersonate trustee
        //
        PTRUSTEE pImpTrustee = (PTRUSTEE)*nameptr;
        (*nameptr) = (LPWSTR)((PBYTE)*nameptr  + sizeof(TRUSTEE));
        //
        // figure out the sid size
        // why not make the server a name based trustee??
        // answer: because it is not easier
        //
        PSID psid = pCAA->ImpersonateSid();
        ULONG sidsize = RtlLengthSid(psid);
        //
        // copy the sid, and increment the buffer pointer
        //
        RtlCopySid(sidsize, *nameptr,psid);
        //
        // connect the trustee together with the sid
        //
        BuildTrusteeWithSid(pImpTrustee, *nameptr);
        //
        // move the buffer pointer past the sid
        //
        (*nameptr) = (LPWSTR)((PBYTE)*nameptr + sidsize);
        //
        // finally turn the original trustee into an impersonate trustee
        // with the other one
        //
        BuildImpersonateTrustee(&(pAccessEntry->Trustee), pImpTrustee);
    }
}
//+---------------------------------------------------------------------------
//
//  Member:     _BuildDualAuditEntries, private
//
//  Synopsis:   converts an ACEs AccountAccess for auditing both success
//              and failed opens into two access entries
//
//  Arguments:  [IN] pCAA - the AccountAccess being converted to an access entry
//              [IN] nameptr - where to put the trustee name
//              [IN/OUT] pae - list of access entries to be stuffed
//              [IN/OUT] ccount - index into access entry list to start stuffing
//              [IN] fAbsolute - if TRUE, trustee names are pointers
//
//+---------------------------------------------------------------------------
void CAcl::_BuildDualAuditEntries(CAccountAccess *pCAA,
                             LPWSTR *nameptr,
                             PACCESS_ENTRY pae,
                             DWORD *ccount,
                             BOOL fAbsolute)
{
    //
    // first add an access entry for the successful open
    _BuildAccessEntry(pCAA,
                      nameptr,
                      &(pae[*ccount]),
                      fAbsolute);
    pae[(*ccount)++].AccessMode = SET_AUDIT_SUCCESS;

    //
    // then add an entry for the failed open
    //
    _BuildAccessEntry(pCAA,
                      nameptr,
                      &(pae[*ccount]),
                      fAbsolute);
    pae[(*ccount)++].AccessMode = SET_AUDIT_FAILURE;
}
#if 0
//+---------------------------------------------------------------------------
//
//  Member:     _ComputeEffective, private
//
//  Synopsis:   computes effective rights from an AccountAccess, including
//              doing a check for group membership
//
//  Arguments:  [IN] pCAA - the AccountAccess to test against
//              [IN] cMC - the member check class
//              [IN OUT] AllowedMask - the mask to add allowed accesses to
//              [IN OUT] DeniedMask - the mask to add denied accesses to
//
//+---------------------------------------------------------------------------
DWORD CAcl::_ComputeEffective(CAccountAccess *pCAA,
                        CMemberCheck *cMC,
                        PACCESS_MASK AllowMask,
                        PACCESS_MASK DenyMask)
{
    DWORD status = NO_ERROR;
    //
    // no access convered by ace with inherit only flag on
    //
    if (0 == (pCAA->AceFlags() & INHERIT_ONLY_ACE ) )
    {
        BOOL fresult;

        //
        // check of the trustee is a member of the account access id
        //
        status = cMC->IsMemberOf( pCAA,
                                  &fresult );
        if (status == NO_ERROR)
        {
            if (fresult == TRUE)
            {
                //
                // if a denied, then add to the deny mask
                //
                if (pCAA->AccessMode() == DENY_ACCESS)
                {
                    *DenyMask |= pCAA->AccessMask();
                //
                // if a set, then add to the allowed mask
                //
                } else if ( (pCAA->AccessMode() ==  SET_ACCESS) ||
                            (pCAA->AccessMode() ==  GRANT_ACCESS) )
                {
                    *AllowMask |= pCAA->AccessMask();
                }
            }
        }
    }
    return(status);
}
#endif

//+---------------------------------------------------------------------------
//
//  Member:     _SetAceFlags, private
//
//  Synopsis:   sets the ACE (inheritance) flag on an ACE in an ACL being
//              constructed1
//
//  Arguments:  IN - [AceIndex]  - the index of the ace
//              IN/OUT - [pacl] - the acl
//              IN - [pcaa] - the account access for the ace index
//
//----------------------------------------------------------------------------
DWORD CAcl::_SetAceFlags(ULONG AceIndex, PACL pacl, CAccountAccess *pcaa)
{
    NTSTATUS ntstatus = STATUS_SUCCESS;
    if (0 != pcaa->AceFlags())
    {
        //
        // get the ACE and set the ace flags
        //
        PACE_HEADER pah;
        if (NT_SUCCESS(ntstatus = RtlGetAce(pacl,
                                            AceIndex,
                                            (void **)&pah)))
        {
            pah->AceFlags |= (BYTE)(pcaa->AceFlags() & VALID_INHERIT_FLAGS);
        } else
        {
            return(RtlNtStatusToDosError(ntstatus));
        }
    }
    return(ERROR_SUCCESS);
}
//+---------------------------------------------------------------------------
//
//  Member:     _GetAceSize, private
//
//  Synopsis:   gets the size required for an ACE
//
//  Arguments:  IN - [pcaa]  - returns the size required for the ACE
//
//----------------------------------------------------------------------------
ULONG CAcl::_GetAceSize(CAccountAccess *pcaa)
{
    if (pcaa->AccessMode() == REVOKE_ACCESS)
    {
        return(0);
    } else if (pcaa->MultipleTrusteeOperation() == TRUSTEE_IS_IMPERSONATE)
    {
        return(RtlLengthSid(pcaa->Sid()) +
                sizeof(ACE_HEADER) +
                sizeof(ACCESS_MASK) +
                sizeof(ULONG) + // sizeof compound ace type & reserved short
                RtlLengthSid(pcaa->ImpersonateSid()) );
    } else
    {
        return(RtlLengthSid(pcaa->Sid()) +
               sizeof(ACE_HEADER) +
               sizeof(ACCESS_MASK));
    }
}
//+---------------------------------------------------------------------------
//
//  Member:     _GetAccessEntrySize, private
//
//  Synopsis:   gets the size required for an access entry
//
//  Arguments:  IN - [pcaa]  - the size required for an access entry
//
//----------------------------------------------------------------------------
DWORD CAcl::_GetAccessEntrySize(CAccountAccess *pcaa, PULONG cAccessEntrySize)
{
    DWORD status;
    LPWSTR name;

    status = pcaa->LookupName(&name);
    if (status == NO_ERROR)
    {
        *cAccessEntrySize = (name == NULL ?
                           (wcslen(NAME_NOT_FOUND) + 1) * sizeof(WCHAR) +
                           sizeof(ACCESS_ENTRY) :
                           (wcslen(name) + 1) * sizeof(WCHAR) +
                           sizeof(ACCESS_ENTRY));

        if (pcaa->MultipleTrusteeOperation() == TRUSTEE_IS_IMPERSONATE)
        {
            (*cAccessEntrySize) += (sizeof(TRUSTEE) +
                                    RtlLengthSid(pcaa->ImpersonateSid()));
        }
    }
    return(status);
}
//+---------------------------------------------------------------------------
//
//  Member:     _AddEntry , private
//
//  Synopsis:   adds an entry (either an ACE or an access entry) to the CACL
//              objects list of AccountAccess objects
//
//  Arguments:  IN - [ci]  - the iterator class
//              OUT - [pcaa] - the account access class for the entry
//              OUT - [pcaaindex] the index of the entry
//
//----------------------------------------------------------------------------
DWORD CAcl::_AddEntry(CIterator *ci,
                        CAccountAccess **pcaa,
                        PULONG pcaaindex)
{

    DWORD status;


    //
    // allocate space for the account access class
    //
    if (NULL != (*pcaa = new CAccountAccess()))
    {
        //
        // initialize the account access
        //
        status = ci->InitAccountAccess( *pcaa,
                                        _system,
                                        _fdir,
                                        _fsave_names_and_sids );
        if (status == NO_ERROR)
        {
            (*pcaaindex)++;

        }
        else
        {
            delete *pcaa;
        }
    }
    else
    {
        status = ERROR_NOT_ENOUGH_MEMORY;
    }


    //
    // Map ERROR_BAD_INHERITANCE_ACL to NO_ERROR. That error is returned
    // when an ACE is inherit-only, so we don't want it in the ACL entry.
    // We do, however, want to skip the ACE so it is good that hte
    // index is not incremented.
    //
    //
    // JINHUANG: InitAccountAccess is changed so that INHERIT_ONLY ace
    // is also added to the list. So this error should never be returned
    //

    if (status == ERROR_BAD_INHERITANCE_ACL)
    {
        status = NO_ERROR;
    }

    return(status);
}
//+---------------------------------------------------------------------------
//
//  Member:     _CheckForDuplicateEntries, private
//
//  Synopsis:   checks for duplicate AccountAccess objects in the CACLs list of
//              AccountAccess objects.
//
//  Arguments:  IN - [pcaa]  - the list of account access objects
//              IN - [curindex] - the account access just added (at the end)
//              IN - [countold] - the number of account accesses in the list
//
//----------------------------------------------------------------------------
DWORD CAcl::_CheckForDuplicateEntries(CAccountAccess **pcaa,
                                        ULONG curindex,
                                        ULONG countold)
{

    DWORD status = NO_ERROR;


    //
    // loop thru the existing AccountAccesses to see if the latest matches
    //
    for (ULONG idx = 0; idx < countold; idx++)
    {
        if (RtlEqualSid(pcaa[idx]->Sid(), pcaa[curindex]->Sid()))
        {
            pcaa[idx]->SetAccessMode(NOT_USED_ACCESS);
        }
    }
    //
    // loop thru the new AccountAccesses to see if the latest matches
    // (they start at countold, which is where idx is left at after
    // the last loop)
    //
    for (; idx < curindex; idx++)
    {
        if (RtlEqualSid(pcaa[idx]->Sid(), pcaa[curindex]->Sid()))
        {
            status =ERROR_INVALID_PARAMETER;
            break;
        }
    }

    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\accctrl2\src\accacc.cxx ===
//+------------------------------------------------------------------
//
// Copyright (C) 1993, Microsoft Corporation.
//
// File:        accacc.cxx
//
// Classes:     CAccountAccess
//
// History:     Nov-93      DaveMont         Created.
//
//-------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Member:     CAccountAccess::CAccountAccess, public
//
//  Synopsis:   initializes data members, constructor will not throw
//
//  Arguments:  none
//
//----------------------------------------------------------------------------
CAccountAccess::CAccountAccess()
    : _principal(NULL),
      _domain(NULL),
      _psid(NULL),
      _accessmask(0),
      _accessmode(NOT_USED_ACCESS),
      _aceflags(0xff),
      _esidtype(SidTypeUnknown),
      _freedomain(FALSE),
      _freename(FALSE),
      _freesid(FALSE),
      _pimpersonatesid(NULL),
      _pimpersonatename(NULL),
      _multipletrusteeoperation(NO_MULTIPLE_TRUSTEE)
{
}
//+---------------------------------------------------------------------------
//
//  Member:     dtor
//
//  Synopsis:   initializes data members
//
//  Arguments:  none
//
//----------------------------------------------------------------------------
CAccountAccess::~CAccountAccess()
{

}
//+---------------------------------------------------------------------------
//
//  Member:    new, public
//
//  Synopsis:
//
//----------------------------------------------------------------------------
void * CAccountAccess::operator new(size_t size)
{
    return(RtlAllocateHeap(RtlProcessHeap(), HEAP_ZERO_MEMORY, (ULONG)size));
}
//+---------------------------------------------------------------------------
//
//  Member:    delete, public
//
//  Synopsis:
//
//----------------------------------------------------------------------------
void CAccountAccess::operator delete(void *p, size_t size)
{
    RtlFreeHeap(RtlProcessHeap(), 0, p);
}
//+---------------------------------------------------------------------------
//
//  Member:     CAccountAccess::Init, public
//
//  Synopsis:   initializes by name, and lookup the SID
//
//  Arguments:  IN [Name] - principal or trustee
//              IN [System] - the server where the name is found
//              IN [AccessMode] - set/deny/grant, etc.
//              IN [AccessMask] - the access mask
//              IN [AceFlags] - inheritance flags
//
//----------------------------------------------------------------------------
DWORD CAccountAccess::Init(LPWSTR Name,
                           LPWSTR System,
                           ACCESS_MODE AccessMode,
                           ACCESS_MASK AccessMask,
                           DWORD AceFlags,
                           BOOL fSaveName)
{

    DWORD status = NO_ERROR;
    DWORD cusid = 0, crd = 0;

    _principal = Name;
    _system = System;
    _accessmode = AccessMode;
    _accessmask = AccessMask;

    //
    // should allow INHERIT_ONLY_ACE to be added bug #234020
    //
    /*
    if (AceFlags & INHERIT_ONLY_ACE)
    {
        return(ERROR_BAD_INHERITANCE_ACL);
    }
    */
    _aceflags = AceFlags;

    //
    // check for CURRENT_USER (in which case we get the name from the token
    //
    if (0 == _wcsicmp(Name, L"CURRENT_USER"))
    {

        HANDLE token_handle;
        //
        // see if a thread token exists
        //
        if (!OpenThreadToken(GetCurrentThread(),
                             TOKEN_ALL_ACCESS,
                             FALSE,
                             &token_handle))
        {
            //
            // if not, use the process token
            //
            if (ERROR_NO_TOKEN == (status = GetLastError()))
            {
                status = NO_ERROR;
                if (!OpenProcessToken(GetCurrentProcess(),
                                      TOKEN_ALL_ACCESS,
                                      &token_handle))
                {
                    status = GetLastError();
                }
            }
        }
        //
        // if we have a token, get the user SID from it
        //
        if (status == NO_ERROR)
        {
            ULONG cinfosize;

            //
            // Note: Since the buffer is long enough to accomodate any sid
            // last error value is not checked for buffer overflow.
            //

            BYTE buf[8 + 4 * SID_MAX_SUB_AUTHORITIES];

            TOKEN_USER *ptu = (TOKEN_USER *)buf;

            if (GetTokenInformation(token_handle,
                                     TokenUser,
                                     ptu,
                                     (8 + 4 * SID_MAX_SUB_AUTHORITIES),
                                     &cinfosize))
            {
                //
                // allocate room for the returned sid
                //
                ULONG sidsize = RtlLengthSid(ptu->User.Sid);
                if (NULL != (_psid = (PSID)
                               AccAlloc(sidsize)))
                {
                    //
                    // and copy the new sid
                    //
                    NTSTATUS ntstatus;
                    if (NT_SUCCESS(ntstatus = RtlCopySid(sidsize,
                                                         _psid,
                                                         ptu->User.Sid)))
                    {
                        _freesid = TRUE;
                    }else
                    {
                        status = RtlNtStatusToDosError(ntstatus);
                        AccFree(_psid);
                    }
                } else
                {
                    status = ERROR_NOT_ENOUGH_MEMORY;
                }
            } else
            {
                status = GetLastError();
            }
        }
    } else
    {
        if (!LookupAccountName( _system,
                                _principal,
                                NULL,
                                &cusid,
                                NULL,
                                &crd,
                                &_esidtype))
        {
            if (ERROR_INSUFFICIENT_BUFFER == (status = GetLastError()))
            {
                if (NULL == (_psid = (PSID)AccAlloc(cusid)))
                {
                    status = ERROR_NOT_ENOUGH_MEMORY;
                } else if (crd > 0)
                {
                    if (NULL == (_domain = (LPWSTR )AccAlloc(crd * sizeof(WCHAR))))
                    {
                        AccFree(_psid);
                        status = ERROR_NOT_ENOUGH_MEMORY;
                    }  else
                    {
                        _freesid = TRUE;
                        _freedomain = TRUE;

                        if ( LookupAccountName( _system,
                                                _principal,
                                                _psid,
                                                &cusid,
                                                _domain,
                                                &crd,
                                                &_esidtype) )
                        {
                           status = NO_ERROR;
                        } else
                        {
                            status = GetLastError();
                        }
                    }
                }
            }
        }
    }
    if (status == NO_ERROR && fSaveName)
    {
        LPWSTR tmp;
        if (NULL != (tmp = (LPWSTR )AccAlloc(
                (wcslen(_principal) + 1) * sizeof(WCHAR))))
        {
            wcscpy(tmp,_principal);
            _principal = tmp;
            _freename = TRUE;
        }  else
        {
            status = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    return(status);
}
//+---------------------------------------------------------------------------
//
//  Member:     CAccountAccess::Init, public
//
//  Synopsis:   initializes by sid, but do not lookup the name
//
//  Arguments:  IN [pSid] - the sid
//              IN [System] - the server where the name is found
//              IN [AccessMode] - set/deny/grant, etc.
//              IN [AccessMask] - the access mask
//              IN [AceFlags] - inheritance flags
//
//----------------------------------------------------------------------------
DWORD CAccountAccess::Init(PSID  pSid,
                           LPWSTR System,
                           ACCESS_MODE AccessMode,
                           ACCESS_MASK AccessMask,
                           DWORD AceFlags,
                           BOOL fSaveSid)
{
    DWORD status = NO_ERROR;

    //
    // should allow INHERIT_ONLY_ACE to be added bug #234020
    //
    /*
    if (AceFlags & INHERIT_ONLY_ACE)
    {
        return(ERROR_BAD_INHERITANCE_ACL);
    }
    */

    _system = System;
    _accessmode = AccessMode;
    _accessmask = AccessMask;
    _aceflags = AceFlags;
    if (fSaveSid)
    {
        ULONG sidsize = RtlLengthSid(pSid);

        if (NULL != (_psid = (LPWSTR)AccAlloc(sidsize)))
        {
            NTSTATUS ntstatus;
            _freesid = TRUE;

            if (!NT_SUCCESS(ntstatus = RtlCopySid(sidsize,
                                               _psid, pSid)))
            {
                status = RtlNtStatusToDosError(ntstatus);
            }
        } else
        {
            status = ERROR_NOT_ENOUGH_MEMORY;
        }
    } else
    {
        _psid       = pSid;
    }

    return(status);
}
//+---------------------------------------------------------------------------
//
//  Member:     CAccountAccess::Clone, public
//
//  Synopsis:   makes a copy of the class
//
//  Arguments:  OUT [clone] - address of new CAccountAccess object
//
//----------------------------------------------------------------------------
DWORD CAccountAccess::Clone(CAccountAccess **clone)
{
    DWORD status = NO_ERROR;

    if (NULL != (*clone = new CAccountAccess()))
    {
        if (_freename)
        {
            if (NULL != ((*clone)->_principal = (LPWSTR)AccAlloc(
                           (wcslen(_principal) + 1) * sizeof(WCHAR))))
            {
                (*clone)->_freename     = _freename;
                wcscpy( (*clone)->_principal, _principal);
            } else
            {
                status = ERROR_NOT_ENOUGH_MEMORY;
            }
        } else
        {
            (*clone)->_principal    = _principal;
        }
        if (_freedomain)
        {
            if (NULL != ((*clone)->_domain = (LPWSTR)AccAlloc(
                           (wcslen(_domain) + 1) * sizeof(WCHAR))))
            {
                (*clone)->_freedomain   = _freedomain;
                wcscpy( (*clone)->_domain, _domain);
            } else
            {
                status = ERROR_NOT_ENOUGH_MEMORY;
            }
        } else
        {
            (*clone)->_domain       = _domain;
        }
        if (_freesid)
        {
            ULONG sidsize = RtlLengthSid(_psid);
            if (NULL != ((*clone)->_psid = (LPWSTR)AccAlloc(
                           sidsize)))
            {
                NTSTATUS ntstatus;
                (*clone)->_freesid      = _freesid;
                if (!NT_SUCCESS(ntstatus = RtlCopySid(sidsize,
                                                   (*clone)->_psid, _psid)))
                {
                    status = RtlNtStatusToDosError(ntstatus);
                }
            } else
            {
                status = ERROR_NOT_ENOUGH_MEMORY;
            }
        } else
        {
            (*clone)->_psid       = _psid;
        }
        (*clone)->_accessmask   = _accessmask;
        (*clone)->_accessmode   = _accessmode;
        (*clone)->_aceflags     = _aceflags;
        (*clone)->_esidtype     = _esidtype;

        if (status != NO_ERROR)
        {
            delete (*clone);
        }
    }
    else
    {
        status = ERROR_NOT_ENOUGH_MEMORY;
    }
    return(status);
}
//+---------------------------------------------------------------------------
//
//  Member:     CAccountAccess::LookupName, public
//
//  Synopsis:   returns the principal for the class
//
//  Arguments:  OUT [Name] - address of the principal name
//
//----------------------------------------------------------------------------
DWORD CAccountAccess::LookupName(LPWSTR *Name)
{
    DWORD status = NO_ERROR;
    DWORD can = 0, crd = 0;


    if (_principal == NULL)
    {
        if (!LookupAccountSid( _system,
                               _psid,
                               NULL,
                               &can,
                               NULL,
                               &crd,
                               &_esidtype))
        {
            if (ERROR_INSUFFICIENT_BUFFER == (status = GetLastError()))
            {
                if (NULL == (_principal = (LPWSTR )AccAlloc(can * sizeof(WCHAR))))
                {
                    status = ERROR_NOT_ENOUGH_MEMORY;
                } else if (NULL == (_domain = (LPWSTR )AccAlloc(crd * sizeof(WCHAR))))
                {
                    AccFree(_principal);
                    status = ERROR_NOT_ENOUGH_MEMORY;
                } else
                {
                    _freename = TRUE;
                    _freedomain = TRUE;

                    if ( !LookupAccountSid( _system,
                                           _psid,
                                           _principal,
                                           &can,
                                           _domain,
                                           &crd,
                                           &_esidtype) )
                    {
                       status = GetLastError();
                    } else
                    {
                        *Name = _principal;
                        status = NO_ERROR;
                    }
                }
            }
        }
    } else
    {
        *Name = _principal;
    }

    return(status);
}
//+---------------------------------------------------------------------------
//
//  Member:     CAccountAccess::SetImpersonateSid, public
//
//  Synopsis:   sets the impersonating server sid
//
//  Arguments:  IN [PSID] - address of the sid
//
//----------------------------------------------------------------------------
DWORD CAccountAccess::SetImpersonateSid(PSID pSid)
{
    DWORD status= NO_ERROR;

    if (NULL == _pimpersonatesid)
    {
        ULONG sidsize  = RtlLengthSid(pSid);
        if (NULL != (_pimpersonatesid = (PSID) AccAlloc(sidsize)))
        {
            NTSTATUS ntstatus;

            if (!NT_SUCCESS(ntstatus = RtlCopySid(sidsize,
                                                 _pimpersonatesid,
                                                 pSid)))
            {
                AccFree(_pimpersonatesid);
                _pimpersonatesid = NULL;
                status = RtlNtStatusToDosError(ntstatus);
            } else
            {
                _multipletrusteeoperation = TRUSTEE_IS_IMPERSONATE;
            }
        } else
        {
            status = ERROR_NOT_ENOUGH_MEMORY;
        }
    } else
    {
        status = ERROR_INVALID_PARAMETER;
    }
    return(status);
}

//+---------------------------------------------------------------------------
//
//  Member:     CAccountAccess::SetImpersonateName, public
//
//  Synopsis:   sets the impersonating server name (and looks up the SID)
//
//  Arguments:  IN [PSID] - address of the name
//
//----------------------------------------------------------------------------
DWORD CAccountAccess::SetImpersonateName(LPWSTR name)
{
    DWORD status= NO_ERROR;

    if (NULL == _pimpersonatesid)
    {
        TRUSTEE trustee;
        PSID psid;

        BuildTrusteeWithName(&trustee, name);
        SID_NAME_USE    SNE;
        status = (*gNtMartaInfo.pfSid)(NULL,
                                       &trustee,
                                       &psid,
                                       &SNE);

        if (status == NO_ERROR)
        {
            if (NULL != (_pimpersonatename = (LPWSTR)AccAlloc((wcslen(name) + 1)
                                                              * sizeof(WCHAR))))
            {
                wcscpy(_pimpersonatename, name);
                _pimpersonatesid = psid;
                _multipletrusteeoperation = TRUSTEE_IS_IMPERSONATE;
            }
            else
            {
                AccFree(psid);
                status = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    }
    else
    {
        status = ERROR_INVALID_PARAMETER;
    }
    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\accctrl2\src\iterator.cxx ===
//+------------------------------------------------------------------
//
// Copyright (C) 1993, Microsoft Corporation.
//
// File:        iterator.cxx
//
// Classes:     CIterator
//
// History:     Nov-93      DaveMont         Created.
//
//-------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop

ULONG
CIterator::NumberEntries()
{
    return (0);
}

DWORD
CIterator::InitAccountAccess( CAccountAccess * caa,
                              LPWSTR           system,
                              IS_CONTAINER     fdir,
                              BOOL             fSaveNamesAndSids)
{
    return (0);
}

//+---------------------------------------------------------------------------
//
//  Member:    ctor, public
//
//  Synopsis:   initializes member variables
//
//  Arguments:  none
//
//----------------------------------------------------------------------------
CAclIterator::CAclIterator()
    : _pacl(NULL),
      _pcurrentace(NULL),
      _acecount(0)
{
}
//+---------------------------------------------------------------------------
//
//  Member:    new, public
//
//  Synopsis:
//
//----------------------------------------------------------------------------
void * CAclIterator::operator new(size_t size)
{
    return(RtlAllocateHeap(RtlProcessHeap(), HEAP_ZERO_MEMORY, (ULONG)size));
}
//+---------------------------------------------------------------------------
//
//  Member:    delete, public
//
//  Synopsis:
//
//----------------------------------------------------------------------------
void CAclIterator::operator delete(void *p, size_t size)
{
    RtlFreeHeap(RtlProcessHeap(), 0, p);
}
//+---------------------------------------------------------------------------
//
//  Member:    Init, public
//
//  Synopsis:   initializes acl variables
//
//  Arguments:  IN - [pacl]  - the acl to iterate thru
//
//----------------------------------------------------------------------------
void CAclIterator::Init(PACL pacl)
{
    _acecount = 0;
    _pacl = pacl;
}

//+---------------------------------------------------------------------------
//
//  Member:     InitAccountAccess, public
//
//  Synopsis:   initializes the AccountAccess object for the current ACL iteration
//
//  Arguments:  IN - [caa]  - class encapsulating accounts and access rights
//              IN - [system]  - the machine to use for name/id lookups
//              IN - [fdir] - object/container status
//
//----------------------------------------------------------------------------
DWORD CAclIterator::InitAccountAccess(CAccountAccess *caa,
                                      LPWSTR system,
                                      IS_CONTAINER fdir,
                                      BOOL fSaveNamesAndSids)
{
    ACCESS_MODE accessmode;
    BOOL fimpersonate = FALSE;
    DWORD status;


    //
    // set the access mode based on the ace type
    //
    if (_pcurrentace->AceType == ACCESS_ALLOWED_ACE_TYPE)
    {
        accessmode = SET_ACCESS;
    } else if (_pcurrentace->AceType == ACCESS_DENIED_ACE_TYPE)
    {
        accessmode = DENY_ACCESS;
    } else if (_pcurrentace->AceType == ACCESS_ALLOWED_COMPOUND_ACE_TYPE)
    {
        fimpersonate = TRUE;
        accessmode = SET_ACCESS;
    } else if (_pcurrentace->AceType == SYSTEM_AUDIT_ACE_TYPE)
    {
        if (_pcurrentace->AceFlags & SUCCESSFUL_ACCESS_ACE_FLAG)
        {
            if (_pcurrentace->AceFlags & FAILED_ACCESS_ACE_FLAG)
            {
                accessmode = (ACCESS_MODE) SE_AUDIT_BOTH;
            } else
            {
                accessmode = SET_AUDIT_SUCCESS;
            }
        } else if (_pcurrentace->AceFlags & FAILED_ACCESS_ACE_FLAG)
        {
            accessmode = SET_AUDIT_FAILURE;
        } else
        {
            return(ERROR_INVALID_ACL);
        }
    } else
    {
        return(ERROR_INVALID_ACL);
    }

    //
    // initialize the accountaccess class
    //
    if (!fimpersonate)
    {
         status = caa->Init((PSID) (&((PACCESS_ALLOWED_ACE)_pcurrentace)->SidStart),
                          system,
                       accessmode,
                       ((PACCESS_ALLOWED_ACE)_pcurrentace)->Mask,
                       _pcurrentace->AceFlags & VALID_INHERIT_FLAGS,
                       fSaveNamesAndSids);
    } else
    {
        PSID psid = (PSID)((PBYTE)(&((PCOMPOUND_ACCESS_ALLOWED_ACE)_pcurrentace)->SidStart) +
        RtlLengthSid(&((PCOMPOUND_ACCESS_ALLOWED_ACE)_pcurrentace)->SidStart));
        if (NO_ERROR == (status = caa->Init(psid,
                          system,
                       accessmode,
                       ((PCOMPOUND_ACCESS_ALLOWED_ACE)_pcurrentace)->Mask,
                       _pcurrentace->AceFlags & VALID_INHERIT_FLAGS,
                       fSaveNamesAndSids)))
        {
            status = caa->SetImpersonateSid((PSID) (&((PCOMPOUND_ACCESS_ALLOWED_ACE)_pcurrentace)->SidStart));
        }
    }

    return(status);
}

//+---------------------------------------------------------------------------
//
//  Member:     ctor, public
//
//  Synopsis:   initialized member variables
//
//  Arguments:  IN - [pae]  - access entries
//              IN - [count] - number of access entries
//
//----------------------------------------------------------------------------
CAesIterator::CAesIterator()
   :_pae(NULL),
    _pcurrententry(NULL),
    _curcount(0),
    _totalcount(0)
{
}
//+---------------------------------------------------------------------------
//
//  Member:    new, public
//
//  Synopsis:
//
//----------------------------------------------------------------------------
void * CAesIterator::operator new(size_t size)
{
    return(RtlAllocateHeap(RtlProcessHeap(), HEAP_ZERO_MEMORY, (ULONG)size));
}
//+---------------------------------------------------------------------------
//
//  Member:    delete, public
//
//  Synopsis:
//
//----------------------------------------------------------------------------
void CAesIterator::operator delete(void *p, size_t size)
{
    RtlFreeHeap(RtlProcessHeap(), 0, p);
}
//+---------------------------------------------------------------------------
//
//  Member:     Init, public
//
//  Synopsis:   initialized member variables
//
//  Arguments:  IN - [pae]  - access entries
//              IN - [count] - number of access entries
//
//----------------------------------------------------------------------------
void CAesIterator::Init(ULONG ccount, PACCESS_ENTRY pae)
{
    _pae = pae;
    _pcurrententry = NULL;
    _curcount = 0;
    _totalcount = ccount;
}
//+---------------------------------------------------------------------------
//
//  Member:     InitAccountAccess, public
//
//  Synopsis:   initializes the AccountAccess object for the current ACL iteration
//
//  Arguments:  IN - [caa]  - class encapsulating accounts and access rights
//              IN - [system]  - the machine to use for name/id lookups
//              IN - [fdir] - object/container status
//
//----------------------------------------------------------------------------
DWORD CAesIterator::InitAccountAccess(CAccountAccess *caa,
                                      LPWSTR system,
                                      IS_CONTAINER fdir,
                                      BOOL fSaveNamesAndSids)
{
    DWORD status;


    //
    // initialize the accountaccess class depending on type of trustee
    //
    if (_pcurrententry->Trustee.TrusteeForm == TRUSTEE_IS_SID)
    {
        status = caa->Init( (PSID)GetTrusteeName(&(_pcurrententry->Trustee)),
                            system,
                            _pcurrententry->AccessMode,
                            _pcurrententry->AccessMask,
                            _pcurrententry->InheritType,
                            fSaveNamesAndSids );
    }
    else if (_pcurrententry->Trustee.TrusteeForm == TRUSTEE_IS_NAME)
    {
        status = caa->Init( GetTrusteeName(&(_pcurrententry->Trustee)),
                            system,
                            _pcurrententry->AccessMode,
                            _pcurrententry->AccessMask,
                            _pcurrententry->InheritType,
                            fSaveNamesAndSids );
    }
    else
    {
        status = ERROR_NOT_SUPPORTED;
    }

    if ( status == NO_ERROR &&
         GetMultipleTrusteeOperation(&_pcurrententry->Trustee) ==
             TRUSTEE_IS_IMPERSONATE )
    {
        switch (GetTrusteeForm(GetMultipleTrustee(&_pcurrententry->Trustee)))
        {
        case TRUSTEE_IS_SID:
            status = caa->SetImpersonateSid(
                              (PSID)GetTrusteeName(
                                  GetMultipleTrustee(&_pcurrententry->Trustee)));
            break;
        case TRUSTEE_IS_NAME:
            status = caa->SetImpersonateName(
                              (LPWSTR)GetTrusteeName(
                                  GetMultipleTrustee(&_pcurrententry->Trustee)));
            break;
        default:
            //
            // in this case, need to lookup the name from the current sec token on
            // the thread or process
            //
            status = ERROR_NOT_SUPPORTED;
            break;
        }
    }

    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\accctrl2\src\convert.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1996.
//
//  File:       CONVERT.CXX
//
//  Contents:   Conversion routines for converting back and forth between
//              ANSI and UNICODE and NT4 and NT5 style structures
//
//  History:    14-Sep-96       MacM        Created
//
//----------------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   ConvertStringWToStringA
//
//  Synopsis:   Allocates a buffer and coverts the UNICODE string ANSI
//
//  Arguments:  [IN  pwszString]    --  String to be converted
//              [OUT ppszString]    --  Where to return the converted string
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//              ERROR_INVALID_PARAMETER A NULL destination string was given
//
//  Notes:      Returned memory must be freed via LocalFree
//
//----------------------------------------------------------------------------
DWORD
ConvertStringWToStringA(IN  PWSTR           pwszString,
                        OUT PSTR           *ppszString)
{
    if(ppszString == NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // Simply size the string, do the allocation, and use the c runtimes
    // to do the conversion
    //
    if(pwszString == NULL)
    {
        *ppszString = NULL;
    }
    else
    {
        ULONG cLen = wcslen(pwszString);
        *ppszString = (PSTR)LocalAlloc(LMEM_FIXED,sizeof(CHAR) *
                                  (wcstombs(NULL, pwszString, cLen + 1) + 1));
        if(*ppszString  != NULL)
        {
             wcstombs(*ppszString,
                      pwszString,
                      cLen + 1);
        }
        else
        {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
    }

    return(ERROR_SUCCESS);
}





//+---------------------------------------------------------------------------
//
//  Function:   ConvertStringAToStringW
//
//  Synopsis:   Allocates a buffer and coverts the ANSI string to UNICODE
//
//  Arguments:  [IN  pszString]     --  String to be converted
//              [OUT ppwszString]   --  Where to return the converted string
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//              ERROR_INVALID_PARAMETER A NULL destination string was given
//
//  Notes:      Returned memory must be freed via LocalFree
//
//----------------------------------------------------------------------------
DWORD
ConvertStringAToStringW(IN  PSTR            pszString,
                        OUT PWSTR          *ppwszString)
{
    if(ppwszString == NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    if(pszString == NULL)
    {
        *ppwszString = NULL;
    }
    else
    {
        ULONG cLen = strlen(pszString);
        *ppwszString = (PWSTR)LocalAlloc(LMEM_FIXED,sizeof(WCHAR) *
                                  (mbstowcs(NULL, pszString, cLen + 1) + 1));
        if(*ppwszString  != NULL)
        {
             mbstowcs(*ppwszString,
                      pszString,
                      cLen + 1);
        }
        else
        {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
    }

    return(ERROR_SUCCESS);
}




//+---------------------------------------------------------------------------
//
//  Function:   GetTrusteeWForSid
//
//  Synopsis:   Initializes the WIDE version of the trustee structure
//              with the NAME represented by the SID
//
//  Arguments:  [IN  pSid]          --  Trustee to be converted
//              [OUT pTrusteeW]     --  Trustee to be initialized
//
//  Returns:    ERROR_SUCCESS       --  Success
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
GetTrusteeWForSid(PSID       pSid,
                  PTRUSTEEW  pTrusteeW)
{
    DWORD   dwErr = ERROR_SUCCESS;
    SID_NAME_USE    SNE;
    PWSTR           pwszDomain;
    PWSTR           pwszName;

    //
    // First, lookup the name
    //
    dwErr = (*gNtMartaInfo.pfName)(NULL,
                                   (PSID)pSid,
                                   &pwszName,
                                   &pwszDomain,
                                   &SNE);
    if(dwErr == ERROR_SUCCESS)
    {
        //
        // Then, initialize the rest of the strucutre
        LocalFree(pwszDomain);
        pTrusteeW->ptstrName = pwszName;
        pTrusteeW->TrusteeForm = TRUSTEE_IS_NAME;

        if(SNE == SidTypeUnknown)
        {
            pTrusteeW->TrusteeType = TRUSTEE_IS_UNKNOWN;
        }
        else
        {
            pTrusteeW->TrusteeType = (TRUSTEE_TYPE)(SNE);
        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   ConvertTrusteeAToTrusteeW
//
//  Synopsis:   Converts an ANSI trustee to a UNICODE trustee, and optionally
//              updates the UNICODE trustee to be name based
//
//  Arguments:  [IN  pTrusteeA]     --  Trustee to convert
//              [OUT pTrusteeW]     --  Where to store the results
//              [IN  fSidToName]    --  If TRUE, convert the trustee sid to
//                                      a name
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A NULL destination string was given
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
ConvertTrusteeAToTrusteeW(IN  PTRUSTEE_A    pTrusteeA,
                          OUT PTRUSTEE_W    pTrusteeW,
                          IN  BOOL          fSidToName)
{
    DWORD   dwErr = ERROR_SUCCESS;

    if(pTrusteeA == NULL || pTrusteeW == NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    memcpy(pTrusteeW,
           pTrusteeA,
           sizeof(TRUSTEE));

    if(pTrusteeA->TrusteeForm == TRUSTEE_IS_NAME)
    {
        //
        // First, copy off the old string
        //
        PWSTR   pwszNewName = NULL;

        dwErr = ConvertStringAToStringW(pTrusteeA->ptstrName,
                                        &pwszNewName);
        if(dwErr == ERROR_SUCCESS)
        {
            pTrusteeW->ptstrName = pwszNewName;
        }
    }
    else
    {
        //
        // See if we need to lookup the account name
        //
        if(fSidToName == TRUE)
        {
            dwErr = GetTrusteeWForSid((PSID)pTrusteeA->ptstrName,
                                      pTrusteeW);
        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   ConvertTrusteeWToTrusteeA
//
//  Synopsis:   Inverse of the last function
//
//  Arguments:  [IN  pTrusteeW]     --  Trustee to convert
//              [OUT pTrusteeA]     --  Where to store the results
//              [IN  fSidToName]    --  If TRUE, convert the trustee sid to
//                                      a name
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A NULL destination string was given
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
ConvertTrusteeWToTrusteeA(IN  PTRUSTEE_W    pTrusteeW,
                          OUT PTRUSTEE_A    pTrusteeA,
                          IN  BOOL          fSidToName)
{
    DWORD   dwErr = ERROR_SUCCESS;

    if(pTrusteeA == NULL || pTrusteeW == NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    memcpy(pTrusteeA,
           pTrusteeW,
           sizeof(TRUSTEE));

    PTRUSTEE_W  pActiveTrusteeW = pTrusteeW;
    TRUSTEE_W   TrusteeW;

    //
    // See if we need to convert to a name from a sid
    //
    if(pTrusteeW->TrusteeForm == TRUSTEE_IS_SID && fSidToName == TRUE)
    {
        pActiveTrusteeW = &TrusteeW;
        pActiveTrusteeW->ptstrName = NULL;
        dwErr = GetTrusteeWForSid((PSID)pTrusteeW->ptstrName,
                                  pActiveTrusteeW);
    }

    if(pActiveTrusteeW->TrusteeForm == TRUSTEE_IS_NAME)
    {
        //
        // First, copy off the old string
        //
        PSTR   pszNewName = NULL;

        dwErr = ConvertStringWToStringA(pActiveTrusteeW->ptstrName,
                                        &pszNewName);
        if(dwErr == ERROR_SUCCESS)
        {
            pTrusteeA->ptstrName = pszNewName;
        }
    }

    if(pActiveTrusteeW != pTrusteeW)
    {
        LocalFree(pActiveTrusteeW->ptstrName);
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   CompStringNode
//
//  Synopsis:   Compares a StringNode to a string pointer to see if they are
//              equal.  Used by the CList class for the ConvertAList*
//              rountines.
//
//  Arguments:  [IN pvValue]    --      String to look for
//              [IN pvNode]     --      List node to compare against
//
//  Returns:    TRUE            --      Nodes equal
//              FALSE           --      Nodes not equal
//
//----------------------------------------------------------------------------
BOOL  CompStringNode(IN  PVOID     pvValue,
                     IN  PVOID     pvNode)
{
    return(pvNode == pvValue);
}




//+---------------------------------------------------------------------------
//
//  Function:   ConvertAListWToAlistAInplace
//
//  Synopsis:   Converts an ACTRL_ACCESSW structure to a ACTRL_ACCESSA
//              structure inplace.  It simply changes all of the UNICODE
//              strings to ANSI strings.
//
//  Arguments:  [IN  pAListW]       --  Structure to convert
//
//  Returns:    ERROR_SUCCESS       --  Success
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
ConvertAListWToAlistAInplace(IN OUT  PACTRL_ACCESSW     pAListW)
{
    DWORD   dwErr = ERROR_SUCCESS;

    CSList  StringList(NULL);

    //
    // Ok, we'll start processing each particular entry.. When we find a
    // string, will try to insert it into our temporary list, if it doesn't
    // already exist..
    //
    for(ULONG iProps = 0;
        iProps < pAListW->cEntries && dwErr == ERROR_SUCCESS &&
        pAListW->pPropertyAccessList != NULL;
        iProps++)
    {
        //
        // First, the property name...
        //
        dwErr = StringList.InsertIfUnique((PWSTR)
                            pAListW->pPropertyAccessList[iProps].lpProperty,
                            CompStringNode);
        if(dwErr == ERROR_SUCCESS)
        {
            PACTRL_ACCESS_ENTRY_LIST  pAEL =
                        pAListW->pPropertyAccessList[iProps].pAccessEntryList;

            //
            // Then the access entry strings
            //
            for(ULONG iEntry = 0;
                pAEL && iEntry < pAEL->cEntries && dwErr == ERROR_SUCCESS &&
                pAEL->pAccessList != NULL;
                iEntry++)
            {
                dwErr = StringList.InsertIfUnique((PWSTR)
                                pAEL->pAccessList[iEntry].Trustee.ptstrName,
                                CompStringNode);
                if(dwErr == ERROR_SUCCESS)
                {
                    dwErr = StringList.InsertIfUnique((PWSTR)
                                pAEL->pAccessList[iEntry].lpInheritProperty,
                                CompStringNode);
                }
            }
        }
    }

    //
    // Now, if all that worked, we'll go through and do the conversion
    //
    if(dwErr == ERROR_SUCCESS)
    {
        StringList.Reset();

        for(ULONG i = 0; i < StringList.QueryCount(); i++)
        {
            PWSTR   pwszCurrent = (PWSTR)StringList.NextData();
            if(pwszCurrent == NULL)
            {
                continue;
            }

            PSTR    pszCurrent = (PSTR)pwszCurrent;

#ifndef NO_DLL
            wcstombs(pszCurrent, pwszCurrent, wcslen(pwszCurrent) + 1);
#else
            while(*pwszCurrent != NULL)
            {
                wctomb(pszCurrent, *pwszCurrent);
                pszCurrent++;
                pwszCurrent++;
            }

            *pszCurrent = '\0';
#endif
        }
    }


    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   CleanupConvertNode
//
//  Synopsis:   Deletes a node from the list.  It restores the original
//              string and does a LocalFree on the new string
//
//  Arguments:  [IN pvNode]     --      Node to be removed
//
//  Returns:    VOID
//
//----------------------------------------------------------------------------
VOID
CleanupConvertNode(PVOID    pvNode)
{
    PCONVERT_ALIST_NODE pCAN = (PCONVERT_ALIST_NODE)pvNode;

    if(pCAN->ppwszInfoAddress != NULL)
    {
        LocalFree(*(pCAN->ppwszInfoAddress));
        *pCAN->ppwszInfoAddress = pCAN->pwszOldValue;
    }

    if(pCAN->pulVal1Address != NULL)
    {
        *pCAN->pulVal1Address = pCAN->ulOldVal1;
    }

    if(pCAN->pulVal2Address != NULL)
    {
        *pCAN->pulVal2Address = pCAN->ulOldVal2;
    }

    LocalFree(pCAN);
}



//+---------------------------------------------------------------------------
//
//  Function:   AllocAndInsertCNode
//
//  Synopsis:   Allocates a new coversion node and inserts into the linked
//              list.  This involves saving the old string pointer, and
//              replacing it's value with the specified new value.  Upon
//              deletion, this process is reversed.
//
//  Arguments:  [IN  SaveList]      --  List to insert into
//              [IN  ppwszAddress]  --  Address of the string to be changed
//              [IN  pwszOldValue]  --  Old value of the string
//              [IN  pwszNewValue]  --  New value of the string to be set
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//
//  Notes:      Returned memory must be freed via LocalFree
//
//----------------------------------------------------------------------------
DWORD
AllocAndInsertCNode(CSList      &SaveList,
                    PWSTR      *ppwszAddress,
                    PWSTR       pwszOldValue,
                    PWSTR       pwszNewValue,
                    PULONG      pulVal1Address,
                    ULONG       ulOldVal1,
                    ULONG       ulNewVal1,
                    PULONG      pulVal2Address,
                    ULONG       ulOldVal2,
                    ULONG       ulNewVal2)
{
    DWORD   dwErr = ERROR_SUCCESS;

    PCONVERT_ALIST_NODE pCAN = (PCONVERT_ALIST_NODE)
                                       LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                                                  sizeof(CONVERT_ALIST_NODE));
    if(pCAN == NULL)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }
    else
    {
        pCAN->ppwszInfoAddress = ppwszAddress;
        pCAN->pwszOldValue     = pwszOldValue;

        *ppwszAddress = pwszNewValue;

        if(pulVal1Address != NULL)
        {
            pCAN->pulVal1Address = pulVal1Address;
            pCAN->ulOldVal1 = ulOldVal1;
            *pulVal1Address = ulNewVal1;
        }
        else
        {
            pCAN->pulVal1Address = NULL;
        }

        if(pulVal2Address != NULL)
        {
            pCAN->pulVal2Address = pulVal2Address;
            pCAN->ulOldVal2 = ulOldVal2;
            *pulVal2Address = ulNewVal2;
        }
        else
        {
            pCAN->pulVal2Address = NULL;
        }

        dwErr = SaveList.Insert((PVOID)pCAN);

        if(dwErr != ERROR_SUCCESS)
        {
            LocalFree(pCAN);
        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   ConvertAListToNamedBasedW
//
//  Synopsis:   Goes through the give access list and converts all of the
//              TRUSTEES to named base, if they are not already
//
//  Arguments:  [IN  pAListW]       --  List to be changed
//              [IN  ChangedList]   --  Linked list class to save all of the
//                                      changes
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//
//  Notes:      Returned memory must be freed via LocalFree
//
//----------------------------------------------------------------------------
DWORD
ConvertAListToNamedBasedW(IN  PACTRL_ACCESSW pAListW,
                          IN  CSList&        ChangedList)
{
    DWORD   dwErr = ERROR_SUCCESS;

    if(pAListW == NULL)
    {
        return(ERROR_SUCCESS);
    }

    //
    // Ok, here, since our provider doesn't understand SIDs, we'll have to
    // go through and change any SIDs that we find to account names.  This
    // will happen by simply doing a lookup.
    //
    for(ULONG iIndex = 0;
        iIndex < pAListW->cEntries && dwErr == ERROR_SUCCESS &&
        pAListW->pPropertyAccessList != NULL;
        iIndex++)
    {
        for(ULONG iAE = 0;
            iAE < pAListW->pPropertyAccessList[iIndex].pAccessEntryList->
                                                                   cEntries &&
            pAListW->pPropertyAccessList[iIndex].pAccessEntryList->
                                                          pAccessList != NULL;
            iAE++)
        {
            //
            // If it's SID based, we'll have to lookup the name...
            //
            if(pAListW->pPropertyAccessList[iIndex].pAccessEntryList->
                       pAccessList[iAE].Trustee.TrusteeForm == TRUSTEE_IS_SID)
            {
                PACTRL_ACCESS_ENTRY pAE = (PACTRL_ACCESS_ENTRY)&(
                                        pAListW->pPropertyAccessList[iIndex].
                                        pAccessEntryList->pAccessList[iAE]);
                PSID   pOldSid = (PSID)pAE->Trustee.ptstrName;
                TRUSTEE_TYPE    OldType = pAE->Trustee.TrusteeType;

                dwErr = GetTrusteeWForSid((PSID)pAE->Trustee.ptstrName,
                                          &(pAE->Trustee));
                if(dwErr == ERROR_SUCCESS)
                {
                    dwErr = AllocAndInsertCNode(ChangedList,
                                            &(pAE->Trustee.ptstrName),
                                            (PWSTR)pOldSid,
                                            pAE->Trustee.ptstrName,
                                            (PULONG)&(pAE->Trustee.TrusteeType),
                                            (ULONG)OldType,
                                            (ULONG)pAE->Trustee.TrusteeType,
                                            (PULONG)&(pAE->Trustee.TrusteeForm),
                                            (ULONG)TRUSTEE_IS_SID,
                                            (ULONG)TRUSTEE_IS_NAME);
                    if(dwErr != ERROR_SUCCESS)
                    {
                        LocalFree(pAE->Trustee.ptstrName);
                        pAE->Trustee.ptstrName = (PWSTR)pOldSid;
                    }
                }

            }

            if(dwErr != ERROR_SUCCESS)
            {
                break;
            }
        }

    }

    return(dwErr);
}






//+---------------------------------------------------------------------------
//
//  Function:   ConvertAListAToNamedBasedW
//
//  Synopsis:   Same as above, but updates an ANSI list, and returns
//              a ptr to a WIDE list.  In addition, it will also convert
//              property and inheritproperty strings to UNICODE
//
//  Arguments:  [IN  pAListA]       --  List to be changed
//              [IN  ChangedList]   --  Linked list class to save all of the
//                                      changes
//              [IN  fSidToName]    --  If TRUE, the Sid-to-Name translation
//                                      is done
//              [OUT ppAListW]      --  Where the widw ptr to the list is
//                                      returned
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//              ERROR_INVALID_PARAMETER A bad parameter was given
//
//  Notes:      The returned WIDE pointer is NOT allocated, but rather
//              the pAListA structure is "converted" in place.  It gets
//              restored when the saved list is destructed
//
//----------------------------------------------------------------------------
DWORD
ConvertAListAToNamedBasedW(IN  PACTRL_ACCESSA   pAListA,
                           IN  CSList&          ChangedList,
                           IN  BOOL             fSidToName,
                           OUT PACTRL_ACCESSW  *ppAListW)
{
    DWORD   dwErr = ERROR_SUCCESS;
    PWSTR   pwszNew;

    if(pAListA == NULL)
    {
        *ppAListW = (PACTRL_ACCESSW)pAListA;
        return(ERROR_SUCCESS);
    }

    //
    // A little parameter checking first...
    //
    if(pAListA->cEntries != 0 && pAListA->pPropertyAccessList == NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }

    //
    // This works the same as above, with the exception that we also need
    // to convert any other strings we find...
    //
    for(ULONG iIndex = 0;
        iIndex < pAListA->cEntries && dwErr == ERROR_SUCCESS;
        iIndex++)
    {
        //
        // First, the property names
        //
        if(pAListA->pPropertyAccessList[iIndex].lpProperty != NULL)
        {
            dwErr  = ConvertStringAToStringW((PSTR)
                            pAListA->pPropertyAccessList[iIndex].lpProperty,
                            &pwszNew);
            if(dwErr == ERROR_SUCCESS)
            {
                dwErr = AllocAndInsertCNode(ChangedList,
                  (PWSTR *)&(pAListA->pPropertyAccessList[iIndex].lpProperty),
                  (PWSTR)pAListA->pPropertyAccessList[iIndex].lpProperty,
                  pwszNew);
                if(dwErr != ERROR_SUCCESS)
                {
                    LocalFree(pwszNew);
                }
            }
        }

        //
        // Now, process all of the entries
        //
        ULONG iUpper = 0;
        if(pAListA->pPropertyAccessList[iIndex].pAccessEntryList != NULL)
        {
            iUpper = pAListA->pPropertyAccessList[iIndex].pAccessEntryList->
                                                                     cEntries;
        }

        if(iUpper != 0 && pAListA->pPropertyAccessList[iIndex].
                                        pAccessEntryList->pAccessList == NULL)
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }

        for(ULONG iAE = 0; iAE < iUpper && dwErr == ERROR_SUCCESS; iAE++)
        {

            PACTRL_ACCESS_ENTRYA pAE = (PACTRL_ACCESS_ENTRYA)&(
                                        pAListA->pPropertyAccessList[iIndex].
                                        pAccessEntryList->pAccessList[iAE]);
            if(pAE->Trustee.TrusteeForm == TRUSTEE_IS_SID)
            {
                if(fSidToName == TRUE)
                {
                    TRUSTEE_W   TrusteeW;
                    dwErr = GetTrusteeWForSid((PSID)pAE->Trustee.ptstrName,
                                              &TrusteeW);
                    if(dwErr == ERROR_SUCCESS)
                    {
                        pAE->Trustee.TrusteeForm = TRUSTEE_IS_NAME;

                        dwErr = AllocAndInsertCNode(
                                           ChangedList,
                                           (PWSTR *)&(pAE->Trustee.ptstrName),
                                           (PWSTR)pAE->Trustee.ptstrName,
                                           TrusteeW.ptstrName,
                                           (PULONG)&(pAE->Trustee.TrusteeType),
                                           (ULONG)pAE->Trustee.TrusteeType,
                                           (ULONG)TrusteeW.TrusteeType,
                                           (PULONG)&(pAE->Trustee.TrusteeForm),
                                           (ULONG)TRUSTEE_IS_SID,
                                           (ULONG)TRUSTEE_IS_NAME);
                        pAE->Trustee.TrusteeType = TrusteeW.TrusteeType;
                        if(dwErr != ERROR_SUCCESS)
                        {
                            LocalFree(TrusteeW.ptstrName);
                        }
                    }
                }
            }
            else
            {
                //
                // We'll have to copy the name
                //

                dwErr  = ConvertStringAToStringW(pAE->Trustee.ptstrName,
                                                 &pwszNew);
                if(dwErr == ERROR_SUCCESS)
                {
                    dwErr = AllocAndInsertCNode(ChangedList,
                                            (PWSTR *)&(pAE->Trustee.ptstrName),
                                            (PWSTR)pAE->Trustee.ptstrName,
                                            pwszNew);
                    if(dwErr != ERROR_SUCCESS)
                    {
                        LocalFree(pwszNew);
                    }
                }
            }

            //
            // Finally, see if we have to do an inherit property
            //
            if(dwErr == ERROR_SUCCESS && pAE->lpInheritProperty != NULL)
            {
                dwErr  = ConvertStringAToStringW((PSTR)pAE->lpInheritProperty,
                                                 &pwszNew);
                if(dwErr == ERROR_SUCCESS)
                {
                    dwErr = AllocAndInsertCNode(ChangedList,
                                           (PWSTR *)&(pAE->lpInheritProperty),
                                           (PWSTR)pAE->lpInheritProperty,
                                           pwszNew);
                    if(dwErr != ERROR_SUCCESS)
                    {
                        LocalFree(pwszNew);
                    }
                }
            }

            if(dwErr != ERROR_SUCCESS)
            {
                break;
            }
        }
    }

    //
    // If it all worked, return the item as a wide version
    //
    if(dwErr == ERROR_SUCCESS)
    {
        *ppAListW = (PACTRL_ACCESSW)pAListA;
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   ConvertExplicitAccessAToAccessW
//
//  Synopsis:   Same as above, but converts from ANSI to WIDE as well
//
//  Arguments:  [IN  cEntries]      --  Number of explicit entries
//              [IN  pExplicit]     --  Explicit entries list to change
//              [IN  ChangedList]   --  Linked list of changed entries
//              [OUT ppAccessList]  --  Where the converted list is returned
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//
//  Notes:      Returned memory must be freed via LocalFree
//
//----------------------------------------------------------------------------
DWORD
ConvertExplicitAccessAToW(IN   ULONG                  cEntries,
                          IN   PEXPLICIT_ACCESS_A     pExplicit,
                          IN   CSList&                ChangedList)
{
    DWORD   dwErr = ERROR_SUCCESS;

    for(ULONG iIndex = 0;
        iIndex < cEntries && dwErr == ERROR_SUCCESS;
        iIndex++)
    {
        //
        // The only thing that has to happen is the Trustee name has to be
        // converted
        //
        if(pExplicit[iIndex].Trustee.TrusteeForm == TRUSTEE_IS_NAME)
        {
            PWSTR   pwszTrustee;
            dwErr = ConvertStringAToStringW(
                                    (PSTR)pExplicit[iIndex].Trustee.ptstrName,
                                    &pwszTrustee);
            if(dwErr == ERROR_SUCCESS)
            {
                dwErr = AllocAndInsertCNode(ChangedList,
                                        (PWSTR *)&(pExplicit[iIndex].Trustee.ptstrName),
                                        (PWSTR)pExplicit[iIndex].Trustee.ptstrName,
                                        pwszTrustee);
                if(dwErr != ERROR_SUCCESS)
                {
                    LocalFree(pwszTrustee);
                }
            }
        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   ConvertAEToExplicit
//
//  Synopsis:   Converts a single AccessEntry to an Explicit entry
//
//  Arguments:  [IN  pAE]           --  AccessEntry to convert
//              [IN  pEx]           --  Explicit entrie to fill in
//
//  Returns:    VOID
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
ConvertAEToExplicit(IN  PACTRL_ACCESS_ENTRYW    pAE,
                    IN  PEXPLICIT_ACCESS        pEx)
{
    memcpy(&(pEx->Trustee),
           &(pAE->Trustee),
           sizeof(TRUSTEE));
    pEx->grfInheritance = pAE->Inheritance;
    ConvertAccessRightToAccessMask(pAE->Access,
                                   &(pEx->grfAccessPermissions));
    if(FLAG_ON(pAE->fAccessFlags,ACTRL_ACCESS_ALLOWED))
    {
        pEx->grfAccessMode = SET_ACCESS;
    }
    else if (FLAG_ON(pAE->fAccessFlags,ACTRL_ACCESS_DENIED))
    {
        pEx->grfAccessMode = DENY_ACCESS;
    }
    else if (FLAG_ON(pAE->fAccessFlags,ACTRL_AUDIT_SUCCESS))
    {
        pEx->grfAccessMode = SET_AUDIT_SUCCESS;
    }
    else if (FLAG_ON(pAE->fAccessFlags,ACTRL_AUDIT_FAILURE))
    {
        pEx->grfAccessMode = SET_AUDIT_FAILURE;
    }
}


BOOL
__stdcall
CDeclWcsicmp(PVOID  pv1, PVOID pv2)
{
    return(_wcsicmp((PWSTR)pv1, (PWSTR)pv2) == 0 ? TRUE : FALSE);
}


//+---------------------------------------------------------------------------
//
//  Function:   ConvertAccessWToExplicitW
//
//  Synopsis:   Converts an ACTRL_ACCESS list to an EXPLICIT_ACCESS list
//
//  Arguments:  [IN  pAccess]       --  Access list to convert
//              [OUT pcEntries]     --  Where to return the count of items
//              [OUT ppExplicit]    --  Explicit entries list
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//
//  Notes:      Returned memory must be freed via LocalFree
//
//----------------------------------------------------------------------------
DWORD
ConvertAccessWToExplicitW(IN  PACTRL_ACCESSW    pAccess,
                          OUT PULONG            pcEntries,
                          OUT PEXPLICIT_ACCESS *ppExplicit)
{
    DWORD   dwErr = ERROR_SUCCESS;

    CSList  TrusteeList(NULL);

    ULONG               cEntries = 0;
    PEXPLICIT_ACCESS    pExplicit = NULL;

    //
    // First, count the entries and save the trustees
    //
    for(ULONG iProp = 0;
        iProp < pAccess->cEntries && dwErr == ERROR_SUCCESS &&
                                        pAccess->pPropertyAccessList != NULL;
        iProp++)
    {
        if(pAccess->pPropertyAccessList[iProp].pAccessEntryList != NULL)
        {
            PACTRL_ACCESS_ENTRY_LIST pAEL =
                        pAccess->pPropertyAccessList[iProp].pAccessEntryList;
            for(ULONG iEntry = 0;
                iEntry < pAEL->cEntries && dwErr == ERROR_SUCCESS &&
                                                    pAEL->pAccessList != NULL;
                iEntry++)
            {
                dwErr = TrusteeList.InsertIfUnique((PVOID)
                                 pAEL->pAccessList[iEntry].Trustee.ptstrName,
//                                 (CompFunc)_wcsicmp);
                                 CDeclWcsicmp);
                cEntries++;
            }
        }
    }

    //
    // Ok, now that we have a list of trustees, go ahead and size the strings
    //
    ULONG cSize = 0;

    if(dwErr == ERROR_SUCCESS)
    {
        TrusteeList.Reset();
        PWSTR pwszNext = (PWSTR)TrusteeList.NextData();
        while(pwszNext != NULL)
        {
            cSize += (ULONG)(SIZE_PWSTR(pwszNext));
            pwszNext = (PWSTR)TrusteeList.NextData();
        }
    }

    //
    // Ok, now for the allocation
    //
    if(dwErr == ERROR_SUCCESS)
    {
        pExplicit = (PEXPLICIT_ACCESS)AccAlloc(cSize +
                                        (cEntries * sizeof(EXPLICIT_ACCESS)));
        if(pExplicit == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            //
            // Now, we'll go through and convert all of ACCESS_ENTRYs to
            // EXPLICIT_ACCESSes.
            //
            ULONG iIndex = 0;
            for(iProp = 0;
                iProp < pAccess->cEntries && dwErr == ERROR_SUCCESS &&
                                         pAccess->pPropertyAccessList != NULL;
                iProp++)
            {
                if(pAccess->pPropertyAccessList[iProp].pAccessEntryList !=
                                                                        NULL)
                {
                    PACTRL_ACCESS_ENTRY_LIST pAEL =
                         pAccess->pPropertyAccessList[iProp].pAccessEntryList;
                    for(ULONG iEntry = 0;
                        iEntry < pAEL->cEntries && pAEL->pAccessList != NULL;
                        iEntry++)
                    {
                        ConvertAEToExplicit(&(pAEL->pAccessList[iEntry]),
                                            &(pExplicit[iIndex]));
                        iIndex++;
                    }
                }
            }

            //
            // Now, we'll have to go through and reset all of our trustees
            //
            PWSTR   pwszTrustee = (PWSTR)((PBYTE)pExplicit +
                                        (cEntries * sizeof(EXPLICIT_ACCESS)));
            TrusteeList.Reset();
            PWSTR pwszNext = (PWSTR)TrusteeList.NextData();
            while(pwszNext != NULL)
            {
                wcscpy(pwszTrustee,
                       pwszNext);

                //
                // Now, go through the explicit list, and find all instances
                // of this trustee, and change it...
                //
                for(ULONG iSrch = 0; iSrch < cEntries; iSrch++)
                {
                    if(_wcsicmp(pExplicit[iSrch].Trustee.ptstrName,
                                pwszTrustee) == 0)
                    {
                        pExplicit[iSrch].Trustee.ptstrName = pwszTrustee;
                    }
                }

                pwszTrustee = (PWSTR)((PBYTE)pwszTrustee +
                                                    SIZE_PWSTR(pwszTrustee));

                pwszNext = (PWSTR)TrusteeList.NextData();
            }
        }
    }

    //
    // If it all worked, return it.. Otherwise, delete it
    //
    if(dwErr == ERROR_SUCCESS)
    {
        *ppExplicit = pExplicit;
        *pcEntries  = cEntries;
    }
    else
    {
        LocalFree(pExplicit);
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   ConvertAccessWToExplicitA
//
//  Synopsis:   Converts an ACTRL_ACCESS list to an ANSI EXPLICIT_ACCESS list
//
//  Arguments:  [IN  pAccess]       --  Access list to convert
//              [OUT pcEntries]     --  Where to return the count of items
//              [OUT ppExplicit]    --  Explicit entries list
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//
//  Notes:      Returned memory must be freed via LocalFree
//
//----------------------------------------------------------------------------
DWORD
ConvertAccessWToExplicitA(IN  PACTRL_ACCESSW     pAccess,
                          OUT PULONG             pcEntries,
                          OUT PEXPLICIT_ACCESSA *ppExplicit)
{
    DWORD   dwErr = ERROR_SUCCESS;

    CSList  TrusteeList(NULL);

    ULONG               cEntries = 0;
    PEXPLICIT_ACCESSA   pExplicit = NULL;

    //
    // First, count the entries and save the trustees
    //
    for(ULONG iProp = 0;
        iProp < pAccess->cEntries && dwErr == ERROR_SUCCESS &&
                                         pAccess->pPropertyAccessList != NULL;
        iProp++)
    {
        if(pAccess->pPropertyAccessList[iProp].pAccessEntryList != NULL)
        {
            PACTRL_ACCESS_ENTRY_LIST pAEL =
                        pAccess->pPropertyAccessList[iProp].pAccessEntryList;
            for(ULONG iEntry = 0;
                iEntry < pAEL->cEntries && dwErr == ERROR_SUCCESS &&
                                                    pAEL->pAccessList != NULL;
                iEntry++)
            {
                dwErr = TrusteeList.InsertIfUnique((PVOID)
                                 pAEL->pAccessList[iEntry].Trustee.ptstrName,
//                                 (CompFunc)_wcsicmp);
                                 CDeclWcsicmp);
                cEntries++;
            }
        }
    }

    //
    // Ok, now that we have a list of trustees, go ahead and size the strings
    //
    ULONG cSize = 0;

    if(dwErr == ERROR_SUCCESS)
    {
        TrusteeList.Reset();
        PWSTR pwszNext = (PWSTR)TrusteeList.NextData();
        while(pwszNext != NULL)
        {
            cSize += wcstombs(NULL,pwszNext, wcslen(pwszNext) + 1) + 1;
            pwszNext = (PWSTR)TrusteeList.NextData();
        }
    }

    //
    // Ok, now for the allocation
    //
    if(dwErr == ERROR_SUCCESS)
    {
        pExplicit = (PEXPLICIT_ACCESSA)AccAlloc(cSize +
                                        (cEntries * sizeof(EXPLICIT_ACCESS)));
        if(pExplicit == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            //
            // Now, we'll go through and convert all of ACCESS_ENTRYs to
            // EXPLICIT_ACCESSes.
            //
            ULONG iIndex = 0;
            for(iProp = 0;
                iProp < pAccess->cEntries && dwErr == ERROR_SUCCESS &&
                                         pAccess->pPropertyAccessList != NULL;
                iProp++)
            {
                if(pAccess->pPropertyAccessList[iProp].pAccessEntryList !=
                                                                        NULL)
                {
                    PACTRL_ACCESS_ENTRY_LIST pAEL =
                         pAccess->pPropertyAccessList[iProp].pAccessEntryList;
                    for(ULONG iEntry = 0;
                        iEntry < pAEL->cEntries && pAEL->pAccessList != NULL;
                        iEntry++)
                    {
                        ConvertAEToExplicit(&(pAEL->pAccessList[iEntry]),
                                     (PEXPLICIT_ACCESSW)&(pExplicit[iIndex]));
                        iIndex++;
                    }
                }
            }

            //
            // Now, we'll have to go through and reset all of our trustees
            //
            PSTR   pszTrustee = (PSTR)((PBYTE)pExplicit +
                                        (cEntries * sizeof(EXPLICIT_ACCESS)));
            TrusteeList.Reset();
            PWSTR pwszNext = (PWSTR)TrusteeList.NextData();
            while(pwszNext != NULL)
            {
                wcstombs(pszTrustee, pwszNext, wcslen(pwszNext) + 1);

                //
                // Now, go through the explicit list, and find all instances
                // of this trustee, and change it...
                //
                for(ULONG iSrch = 0; iSrch < cEntries; iSrch++)
                {
                    if((PWSTR)pExplicit[iSrch].Trustee.ptstrName == pwszNext)
                    {
                        pExplicit[iSrch].Trustee.ptstrName = pszTrustee;
                    }
                }

                pszTrustee = (PSTR)((PBYTE)pszTrustee +
                           wcstombs(NULL,pwszNext, wcslen(pwszNext)) + 1);

                pwszNext = (PWSTR)TrusteeList.NextData();
            }
        }
    }

    //
    // If it all worked, return it.. Otherwise, delete it
    //
    if(dwErr == ERROR_SUCCESS)
    {
        *ppExplicit = pExplicit;
        *pcEntries  = cEntries;
    }
    else
    {
        LocalFree(pExplicit);
    }


    return(dwErr);
}





//+---------------------------------------------------------------------------
//
//  Function:   TrusteeAllocationSizeAToW
//
//  Synopsis:   Determines the size in UNICODE of an ANSI trustee
//
//  Arguments:  [IN  pTrustee]      --  Trustee to size
//
//  Returns:    size of the trustee on success
//              0 on failure
//
//
//
//----------------------------------------------------------------------------
ULONG TrusteeAllocationSizeAToW(IN PTRUSTEE_A pTrustee)
{
    ULONG cSize = 0;

    //
    // If impersonate, add size required for multiple trustees
    //
    if(pTrustee->MultipleTrusteeOperation == TRUSTEE_IS_IMPERSONATE)
    {
        //
        // Add the size of any linked trustees, note the recursion
        //
        cSize += sizeof(TRUSTEE_W) +
                      TrusteeAllocationSizeAToW(pTrustee->pMultipleTrustee);
    }

    //
    // Switch on the form, note that an invalid form just means no
    // size is added
    //
    switch(pTrustee->TrusteeForm)
    {
    case TRUSTEE_IS_NAME:
        cSize += (strlen(pTrustee->ptstrName) + 1) * sizeof(WCHAR);
        break;

    case TRUSTEE_IS_SID:
        cSize += RtlLengthSid((PSID)pTrustee->ptstrName) + sizeof(WCHAR);
        break;

    default:
        cSize = 0;
        break;
    }

    return(cSize);
}





//+---------------------------------------------------------------------------
//
//  Function:   TrusteeAllocationSizeWToW
//
//  Synopsis:   Determines the size in UNICODE of an UNICODE trustee
//
//  Arguments:  [IN  pTrustee]      --  Trustee to size
//
//  Returns:    size of the trustee on success
//              0 on failure
//
//
//
//----------------------------------------------------------------------------
ULONG TrusteeAllocationSizeWToW(IN PTRUSTEE_W pTrustee)
{
    ULONG cSize = 0;

    //
    // If impersonate, add size required for multiple trustees
    //
    if(pTrustee->MultipleTrusteeOperation == TRUSTEE_IS_IMPERSONATE)
    {
        //
        // Add the size of any linked trustees, note the recursion
        //
        cSize += sizeof(TRUSTEE_W) +
                      TrusteeAllocationSizeWToW(pTrustee->pMultipleTrustee);
    }

    //
    // Switch on the form, note that an invalid form just means no
    // size is added
    //
    switch(pTrustee->TrusteeForm)
    {
    case TRUSTEE_IS_NAME:
        cSize += (wcslen(pTrustee->ptstrName) + 1) * sizeof(WCHAR);
        break;

    case TRUSTEE_IS_SID:
        cSize += RtlLengthSid((PSID)pTrustee->ptstrName) + sizeof(WCHAR);
        break;

    default:
        cSize = 0;
        break;
    }

    return(cSize);
}





//+---------------------------------------------------------------------------
//
//  Function:   ConvertExplicitAccessAToExplicitAccessW
//
//  Synopsis:   Converts an ExplicitAccessList from ANSI to UNICODE
//
//  Arguments:  [IN  cAccess]       --  Number of items
//              [IN  pAccessA]      --  ANSI list
//              [OUT ppAccessW]     --  Where to return the WIDE list
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//
//  Notes:      Returned memory must be freed via LocalFree
//
//
//----------------------------------------------------------------------------
DWORD
ConvertExplicitAccessAToExplicitAccessW(IN  ULONG               cAccesses,
                                        IN  PEXPLICIT_ACCESS_A  pAccessA,
                                        OUT PEXPLICIT_ACCESS_W *ppAccessW)
{
    ULONG               cbBytes, i;
    PEXPLICIT_ACCESS_W  pAccess;
    PBYTE               pbStuffPtr;
    DWORD               dwErr = ERROR_SUCCESS;

    cbBytes = cAccesses * sizeof(EXPLICIT_ACCESS_W);

    for (i = 0; i < cAccesses; i++ )
    {
        cbBytes += TrusteeAllocationSizeAToW(&(pAccessA[i].Trustee));
    }

    pAccess = (PEXPLICIT_ACCESS_W)AccAlloc(cbBytes);
    if(pAccess == NULL)
    {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    pbStuffPtr = (PBYTE)pAccess + cAccesses * sizeof(EXPLICIT_ACCESS_W);

    for(i = 0; i < cAccesses; i++)
    {
        dwErr =  ConvertTrusteeAToTrusteeW(&(pAccessA[i].Trustee),
                                           &(pAccess[i].Trustee),
                                           FALSE);

        pAccess[i].grfAccessPermissions = pAccessA[i].grfAccessPermissions;
        pAccess[i].grfAccessMode        = pAccessA[i].grfAccessMode;
        pAccess[i].grfInheritance       = pAccessA[i].grfInheritance;
    }

    *ppAccessW = pAccess;

    return (dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   ConvertAccessRightToAccessMask
//
//  Synopsis:   Converts from ACCESS_RIGHTS to an AccessMask
//
//  Arguments:  [IN  AccessRight]   --  Access mask to convert
//              [OUT pAccessMask]   --  Where to return the access mask
//
//  Returns:    VOID
//
//  Notes:
//
//
//----------------------------------------------------------------------------
VOID
ConvertAccessRightToAccessMask(IN  ACCESS_RIGHTS    AccessRight,
                               OUT PACCESS_MASK     pAccessMask)
{
    //
    // Look for the known entries first
    //
    *pAccessMask = 0;

    if((AccessRight & (ACTRL_STD_RIGHTS_ALL | ACTRL_SYSTEM_ACCESS)) != 0)
    {

        *pAccessMask = (AccessRight & ACTRL_STD_RIGHTS_ALL) >> 11;

    }

    //
    // Add in the remaining rights
    //
    *pAccessMask |= (AccessRight & ~(ACTRL_STD_RIGHTS_ALL | ACTRL_SYSTEM_ACCESS));
}




//+---------------------------------------------------------------------------
//
//  Function:   ConvertAccessMaskToAccessRight
//
//  Synopsis:   Converts from an AccessMask to ACCESS_RIGHTS
//
//  Arguments:  [IN  AccessMask]    --  Access mask to convert
//              [OUT pAccessRight]  --  Where to return the access rights
//
//  Returns:    VOID
//
//  Notes:
//
//
//----------------------------------------------------------------------------
VOID
ConvertAccessMaskToAccessRight(IN  ACCESS_MASK      AccessMask,
                               OUT PACCESS_RIGHTS   pAccessRight)
{
    //
    // Look for the known entries first
    //
    *pAccessRight = 0;
    GENERIC_MAPPING GenMapping = {STANDARD_RIGHTS_READ     | 0x1,
                                  STANDARD_RIGHTS_WRITE    | 0x2,
                                  STANDARD_RIGHTS_EXECUTE  | 0x4,
                                  STANDARD_RIGHTS_REQUIRED | 0x7};
    MapGenericMask(&AccessMask,
                   &GenMapping);

    if((AccessMask & STANDARD_RIGHTS_ALL) != 0)
    {
        *pAccessRight = (AccessMask & STANDARD_RIGHTS_ALL) << 11;
    }

    //
    // Add in the remaining rights
    //
    *(pAccessRight) |= (AccessMask & ~STANDARD_RIGHTS_ALL);
}





//+---------------------------------------------------------------------------
//
//  Function:   ConvertTrusteeWToTrusteeA
//
//  Synopsis:   Converts a WIDE trustee to an ANSI one.  Allocates the new
//              destination trustee
//
//  Arguments:  [IN  pTrusteeW]     --  Trustee to convert
//              [IN  ppTrusteeA]    --  Where to return the ANSI version of
//                                      the trustee
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//
//  Notes:      Returned memory must be freed via LocalFree
//
//
//----------------------------------------------------------------------------
DWORD
ConvertTrusteeWToTrusteeA(IN  PTRUSTEE_W        pTrusteeW,
                          OUT PTRUSTEE_A       *ppTrusteeA)
{
    DWORD   dwErr = ERROR_SUCCESS;

    if(pTrusteeW == NULL)
    {
        *ppTrusteeA = NULL;
    }
    else
    {
        //
        // First, if necessary, convert our wide name to an ascii name
        //
        ULONG   cNameSize = 0;
        if(pTrusteeW->TrusteeForm == TRUSTEE_IS_NAME)
        {
            cNameSize = wcstombs(NULL,
                                 pTrusteeW->ptstrName,
                                 wcslen(pTrusteeW->ptstrName) + 1) + 1;
        }
        else if(pTrusteeW->TrusteeForm == TRUSTEE_IS_SID)
        {
            if(RtlValidSid((PSID)pTrusteeW->ptstrName) == FALSE)
            {
                dwErr = ERROR_INVALID_SID;
            }
            else
            {
                cNameSize = RtlLengthSid((PSID)pTrusteeW->ptstrName);
            }
        }
        else
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }

        if(dwErr == ERROR_SUCCESS)
        {
            //
            // Allocate it
            //
            *ppTrusteeA = (PTRUSTEE_A)AccAlloc(sizeof(TRUSTEE_A) + cNameSize);
            if(*ppTrusteeA == NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
            }
            else
            {
                //
                // And copy it...
                //
                memcpy(*ppTrusteeA,
                       pTrusteeW,
                       sizeof(TRUSTEE_W));
                (*ppTrusteeA)->ptstrName = (PSTR)((PBYTE)*ppTrusteeA +
                                                           sizeof(TRUSTEE_A));

                if(pTrusteeW->TrusteeForm == TRUSTEE_IS_NAME)
                {
                    wcstombs((*ppTrusteeA)->ptstrName,
                             pTrusteeW->ptstrName,
                             wcslen(pTrusteeW->ptstrName) + 1);
                }
                else
                {
                    RtlCopySid(cNameSize,
                               (PSID)((*ppTrusteeA)->ptstrName),
                               (PSID)(pTrusteeW->ptstrName));
                }
            }
        }
    }

    return(dwErr);
}


//+---------------------------------------------------------------------------
//
// Stolen from old win32 access control API code
//+---------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Function : SpecialCopyTrustee
//
//  Synopsis : copies the from trustee into the to trustee, and any data
//             (such as the name, sid or linked multiple trustees) to the
//             stuff pointer, and moves the stuff pointer.
//
//  Arguments: IN OUT [pStuffPtr] - place to stuff data pointed to by the
//                                  from trustee
//             IN OUT [pToTrustee] - the trustee to copy to
//             IN OUT [pFromTrustee] - the trustee to copy from
//
//----------------------------------------------------------------------------
VOID
SpecialCopyTrustee(VOID **pStuffPtr, PTRUSTEE pToTrustee, PTRUSTEE pFromTrustee)
{


    //
    // first copy the current trustee
    // switch on the form, note that an invalid form just means no
    // data is copied
    //
    pToTrustee->MultipleTrusteeOperation = pFromTrustee->MultipleTrusteeOperation;
    pToTrustee->TrusteeForm = pFromTrustee->TrusteeForm;
    pToTrustee->TrusteeType = pFromTrustee->TrusteeType;
    pToTrustee->ptstrName = (LPWSTR)*pStuffPtr;
    //
    // copy the pointed to data
    //
    switch (pToTrustee->TrusteeForm)
    {
    case TRUSTEE_IS_NAME:
        wcscpy(pToTrustee->ptstrName, pFromTrustee->ptstrName);
        *pStuffPtr = ((PBYTE)*pStuffPtr +
                        (wcslen(pFromTrustee->ptstrName) + 1) * sizeof(WCHAR));
        break;
    case TRUSTEE_IS_SID:
    {
        ULONG csidsize = RtlLengthSid((PSID)pFromTrustee->ptstrName);

        //
        // Note: rtlcopysid can not fail unless there is a bug in
        // RtlLengthSid.
        //

        RtlCopySid(csidsize, (PSID)*pStuffPtr, (PSID)pFromTrustee->ptstrName);
        *pStuffPtr = ((PBYTE)*pStuffPtr +
                              csidsize + sizeof(WCHAR));
        break;
    }
    }
    //
    // if impersonate, copy multiple trustees, note the recursion
    //
    if (pFromTrustee->MultipleTrusteeOperation != NO_MULTIPLE_TRUSTEE)
    {
        //
        // move the stuff pointer, saving room for the new trustee structure
        //
        pToTrustee->pMultipleTrustee = (PTRUSTEE)*pStuffPtr;
        *pStuffPtr = (VOID *)((PBYTE)*pStuffPtr + sizeof(TRUSTEE));
        SpecialCopyTrustee(pStuffPtr,
                           (PTRUSTEE) ((ULONG_PTR)*pStuffPtr - sizeof(TRUSTEE)),
                           pFromTrustee->pMultipleTrustee);
    } else
    {
        pToTrustee->pMultipleTrustee = NULL;
    }
}


//+---------------------------------------------------------------------------
//
//  Function :  Win32AccessRequestToExplicitEntry
//
//  Synopsis : converts access requests to  explicit accesses
//
//  Arguments: IN [cCountOfExplicitAccesses] - number of input explicit accesses
//             IN [pExplicitAccessList]   - list of explicit accesses
//             OUT [pAccessEntryList]   - output access entries, caller must
//                                        free with AccFree
//
//----------------------------------------------------------------------------
DWORD
Win32ExplicitAccessToAccessEntry(IN ULONG cCountOfExplicitAccesses,
                                 IN PEXPLICIT_ACCESS pExplicitAccessList,
                                 OUT PACCESS_ENTRY *pAccessEntryList)

{
    DWORD status = NO_ERROR;
    //
    // allocate room for the access entrys
    //
    if (NULL != (*pAccessEntryList = (PACCESS_ENTRY)AccAlloc(
                              cCountOfExplicitAccesses * sizeof(ACCESS_ENTRY))))
    {
        //
        // copy them, note the the trustee is not copied
        //
        for (ULONG idx = 0; idx < cCountOfExplicitAccesses; idx++)
        {
           (*pAccessEntryList)[idx].AccessMode = (ACCESS_MODE)
                                          pExplicitAccessList[idx].grfAccessMode;
           (*pAccessEntryList)[idx].InheritType =
                                         pExplicitAccessList[idx].grfInheritance;
           (*pAccessEntryList)[idx].AccessMask =
                                  pExplicitAccessList[idx].grfAccessPermissions;
           (*pAccessEntryList)[idx].Trustee = pExplicitAccessList[idx].Trustee;
        }
    } else
    {
        status = ERROR_NOT_ENOUGH_MEMORY;
    }
    return(status);
}

//+---------------------------------------------------------------------------
//
//  Function :  AccessEntryToWin32ExplicitAccess
//
//  Synopsis : gets trustee names and access rights from access entries
//
//  Arguments: IN [cCountOfAccessEntries]   - the count of acccess entries
//             IN [pListOfAccessEntries]   - the list of acccess entries
//             OUT [pListOfExplicitAccesses]  - the returned list of trustee
//
//----------------------------------------------------------------------------
DWORD
AccessEntryToWin32ExplicitAccess(IN ULONG cCountOfAccessEntries,
                                 IN PACCESS_ENTRY pListOfAccessEntries,
                                 OUT PEXPLICIT_ACCESS *pListOfExplicitAccesses)
{
    DWORD status = NO_ERROR;
    LPWSTR trustee;

    if (cCountOfAccessEntries > 0)
    {
        DWORD csize = cCountOfAccessEntries * sizeof(EXPLICIT_ACCESS);
        //
        // figure out how big the returned list is
        //
        for (ULONG idx = 0; idx < cCountOfAccessEntries; idx++)
        {
            csize += TrusteeAllocationSizeWToW(&
                                        (pListOfAccessEntries[idx].Trustee));
        }
        //
        // allocate space for the returned list
        //
        if (NULL !=(*pListOfExplicitAccesses =  (PEXPLICIT_ACCESS)
                                                AccAlloc(csize)))
        {
            //
            // loop thru the access entries, stuffing them as we go
            //
            PTRUSTEE stuffptr = (PTRUSTEE)((PBYTE)*pListOfExplicitAccesses +
                            cCountOfAccessEntries * sizeof(EXPLICIT_ACCESS));

            for (idx = 0; idx < cCountOfAccessEntries; idx++)
            {
                //
                // copy the trustee and move the stuff pointer
                //
                SpecialCopyTrustee((void **)&stuffptr,
                                   &((*pListOfExplicitAccesses)[idx].Trustee),
                                   &(pListOfAccessEntries[idx].Trustee));
                //
                // copy the rest of the data
                //
                (*pListOfExplicitAccesses)[idx].grfInheritance =
                                      pListOfAccessEntries[idx].InheritType;
                (*pListOfExplicitAccesses)[idx].grfAccessPermissions =
                                      pListOfAccessEntries[idx].AccessMask;
                (*pListOfExplicitAccesses)[idx].grfAccessMode =
                                      pListOfAccessEntries[idx].AccessMode;
            }
        } else
        {
            status = ERROR_NOT_ENOUGH_MEMORY;
        }
    } else
    {
        (*pListOfExplicitAccesses) = NULL;
    }
    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\accctrl2\drt\aclapi.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1996.
//
//  File:       ACLAPI.C
//
//  Contents:   Implements the drt for MARTA and Win32Ex APIs
//
//  History:    14-Sep-96       MacM        Created
//
//  Notes:
//
//----------------------------------------------------------------------------
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <aclapi.h>
#include <marta.h>
#include <seopaque.h>
#include <ntrtl.h>


#define EVERYONE L"EVERYONE"
#define EVERYONE_A "EVERYONE"
#define GUEST L"GUEST"
#define GUEST_A "GUEST"
#define GUEST_COMPARE L"GUEST"
#define SYSTEM L"SYSTEM"
#define SYSTEM_A "SYSTEM"
#define MAX_LINE 256

//
// Globals
//
BOOL    fVerbose = FALSE;

//
// Function prototypes
//
DWORD   Nt4BuildW(PACL *ppAcl);
DWORD   Nt4BuildA(PACL *ppAcl);
DWORD   Nt5BuildW(PACTRL_ACCESSW   *ppAccess);
DWORD   Nt5BuildA(PACTRL_ACCESSA   *ppAccess);
DWORD   Nt4DrtW(PACL            pAcl,
                PSTR            pszObject,
                SE_OBJECT_TYPE  ObjType);

DWORD   Nt4DrtA(PACL            pAcl,
                PSTR            pszObject,
                SE_OBJECT_TYPE  ObjType);

DWORD   Nt5DrtW(PACTRL_ACCESSW  pAccess,
                PSTR            pszObject,
                SE_OBJECT_TYPE  ObjType);

DWORD   Nt5DrtA(PACTRL_ACCESSA  pAccess,
                PSTR            pszObject,
                SE_OBJECT_TYPE  ObjType);

VOID
ConvertAccessMaskToAccessRight(IN  ACCESS_MASK      AccessMask,
                               OUT PACCESS_RIGHTS   pAccessRight);
//+---------------------------------------------------------------------------
//
//  Function:   main
//
//  Synopsis:   The main
//
//  Arguments:  [IN  argc]          --  Count of arguments
//              [IN  argv]          --  List of arguments
//
//  Returns:    0                   --  Success
//              non-0               --  Failure
//
//----------------------------------------------------------------------------
__cdecl main(INT argc, CHAR *argv[])
{

    DWORD           dwErr = ERROR_SUCCESS;
    PACL            pNt4AclW = NULL, pNt4AclA = NULL;
    PACTRL_ACCESSW  pNt5AccessW = NULL;
    PACTRL_ACCESSA  pNt5AccessA = NULL;
    FILE           *fp = NULL;
    SE_OBJECT_TYPE  ObjType;
    CHAR            szBuff[MAX_LINE];

    if (argc < 2 || argc > 3)
    {
        fprintf(stderr,"USAGE: aclexdrt input_file [verbose]\n");
        exit(1);
    }

    if(argc == 3)
    {
        fVerbose = TRUE;
    }

    AccProvInit(dwErr);

    //
    // Do the Nt4 style build routines
    //
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = Nt4BuildW(&pNt4AclW);
    }

    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = Nt4BuildA(&pNt4AclA);
    }

    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = Nt5BuildW(&pNt5AccessW);
    }

    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = Nt5BuildA(&pNt5AccessA);
    }

    //
    // Now, open the file and process it...
    //
    if(dwErr == ERROR_SUCCESS)
    {
        fp = fopen(argv[1], "r");
        if(fp == NULL)
        {
            fprintf(stderr, "File %s not found\n", argv[1]);
            dwErr = ERROR_FILE_NOT_FOUND;
        }

        while(dwErr == ERROR_SUCCESS && fgets(szBuff, MAX_LINE, fp) != NULL)
        {
            BOOL    fIsDSObj = FALSE;
            PSTR    pszType;
            PSTR    pszObject = strtok(szBuff, " ");
            if(pszObject != NULL)
            {
                pszType = strtok(NULL," \n\r\0");
            }

            if(pszObject == NULL && pszType == NULL)
            {
                continue;
            }
            else if(pszObject == NULL || pszType == NULL)
            {
                fprintf(stderr,
                        "Invalid entry %s in input file %s\n",
                        szBuff,
                        argv[1]);
                dwErr = ERROR_INVALID_DATA;
            }
            else
            {
                if(_stricmp(pszType, "FILE") == 0)
                {
                    ObjType = SE_FILE_OBJECT;
                }
                else if(_stricmp(pszType, "SERVICE") == 0)
                {
                    ObjType = SE_SERVICE;
                }
                else if(_stricmp(pszType, "PRINTER") == 0)
                {
                    ObjType = SE_PRINTER;
                }
                else if (_stricmp(pszType, "REGISTRY_KEY") == 0)
                {
                    ObjType = SE_REGISTRY_KEY;
                }
                else if(_stricmp(pszType, "SHARE") == 0)
                {
                    ObjType = SE_LMSHARE;
                }
                else if(_stricmp(pszType, "DSOBJ") == 0)
                {
                    ObjType = SE_DS_OBJECT;
                    fIsDSObj = TRUE;
                }
                else if(_stricmp(pszType, "DSOBJALL") == 0)
                {
                    ObjType = SE_DS_OBJECT_ALL;
                    fIsDSObj = TRUE;
                }
                else
                {
                    fprintf(stderr, "Invalid object type %s\n", pszType);
                    dwErr = ERROR_INVALID_DATA;
                }
            }

            //
            // If it worked, do the tests...
            //
            if(dwErr == ERROR_SUCCESS && fIsDSObj == FALSE)
            {
                dwErr = Nt4DrtW(pNt4AclW,
                                pszObject,
                                ObjType);
            }

            if(dwErr == ERROR_SUCCESS && fIsDSObj == FALSE)
            {
                dwErr = Nt4DrtA(pNt4AclA,
                                pszObject,
                                ObjType);
            }

            if(dwErr == ERROR_SUCCESS)
            {
                dwErr = Nt5DrtW(pNt5AccessW,
                                pszObject,
                                ObjType);
            }

            if(dwErr == ERROR_SUCCESS)
            {
                dwErr = Nt5DrtA(pNt5AccessA,
                                pszObject,
                                ObjType);
            }
        }

        if(fp != NULL)
        {
            fclose(fp);
        }

    }
    LocalFree(pNt4AclW);
    LocalFree(pNt4AclA);
    LocalFree(pNt5AccessW);
    LocalFree(pNt5AccessA);

    if(dwErr == ERROR_SUCCESS)
    {
        printf("Success\n");
    }
    else
    {
        printf("Failure: %lu\n", dwErr);
    }

    return(dwErr);
}



//+---------------------------------------------------------------------------
//
//  Function:   CompareAcls
//
//  Synopsis:   Compares 2 acls for equality
//
//  Arguments:  [pAcl1]             --  First ACL
//              [pAcl2]             --  Second ACL
//
//  Returns:    ERROR_SUCCESS       --  They match
//              ERROR_INVALID_DATA  --  They don't match
//
//----------------------------------------------------------------------------
DWORD   CompAcls(PACL pAcl1,
                 PACL pAcl2)
{
    DWORD   dwErr = ERROR_SUCCESS;

    ACL_SIZE_INFORMATION        AclSize1, AclSize2;
    ACL_REVISION_INFORMATION    AclRev1, AclRev2;
    PKNOWN_ACE                  pAce1, pAce2;
    PSID                        pSid1, pSid2;
    DWORD                       iIndex;

    if(pAcl1 == NULL || pAcl2 == NULL)
    {
        if(pAcl1 != pAcl2)
        {
            if(fVerbose)
            {
                fprintf(stderr,"Acl %lu is NULL\n", pAcl1 == NULL ? 1 : 2);
            }
            dwErr = ERROR_INVALID_DATA;
        }
    }
    else
    {
        if(GetAclInformation(pAcl1,
                             &AclRev1,
                             sizeof(ACL_REVISION_INFORMATION),
                             AclRevisionInformation) == FALSE ||
           GetAclInformation(pAcl2,
                             &AclRev2,
                             sizeof(ACL_REVISION_INFORMATION),
                             AclRevisionInformation) == FALSE)
        {
            return(ERROR_INVALID_DATA);
        }

        if(GetAclInformation(pAcl1,
                             &AclSize1,
                             sizeof(ACL_SIZE_INFORMATION),
                             AclSizeInformation) == FALSE ||
           GetAclInformation(pAcl2,
                             &AclSize2,
                             sizeof(ACL_SIZE_INFORMATION),
                             AclSizeInformation) == FALSE)
        {
            return(ERROR_INVALID_DATA);
        }

        if(AclRev1.AclRevision !=  AclRev2.AclRevision)
        {
            if(fVerbose)
            {
                fprintf(stderr,
                        "Revision mismatch: %lu %lu\n",
                        AclRev1.AclRevision,
                        AclRev2.AclRevision);
            }
            dwErr = ERROR_INVALID_DATA;
        }

        if(AclSize1.AceCount !=  AclSize2.AceCount)
        {
            if(fVerbose)
            {
                fprintf(stderr,
                        "AceCount mismatch: %lu %lu\n",
                        AclSize1.AceCount,
                        AclSize2.AceCount);
            }
            dwErr = ERROR_INVALID_DATA;
        }

        if(AclSize1.AclBytesInUse !=  AclSize2.AclBytesInUse)
        {
            if(fVerbose)
            {
                fprintf(stderr,
                        "BytesInUse mismatch: %lu %lu\n",
                        AclSize1.AclBytesInUse,
                        AclSize2.AclBytesInUse);
            }
            dwErr = ERROR_INVALID_DATA;
        }

        if(pAcl1->Sbz1 !=  pAcl2->Sbz1)
        {
            if(fVerbose)
            {
                fprintf(stderr,
                        "Acl flags mismatch: %lu %lu\n",
                        pAcl1->Sbz1,
                        pAcl2->Sbz1);
            }
            dwErr = ERROR_INVALID_DATA;
        }


        if(dwErr != ERROR_SUCCESS)
        {
            return(dwErr);
        }

        //
        // Now, compare all of the aces
        //
        pAce1 = FirstAce(pAcl1);
        pAce2 = FirstAce(pAcl2);
        for(iIndex = 0;
            iIndex < pAcl1->AceCount && dwErr == ERROR_SUCCESS;
            iIndex++)
        {
            ACCESS_RIGHTS   Rights1, Rights2;

            if(fVerbose)
            {
                printf("Ace %lu\n", iIndex);
            }

            if(pAce1->Header.AceType !=  pAce2->Header.AceType)
            {
                if(fVerbose)
                {
                    fprintf(stderr,
                            "\tAceType mismatch: %lu %lu\n",
                            pAce1->Header.AceType,
                            pAce2->Header.AceType);
                }
                dwErr = ERROR_INVALID_DATA;
            }

            if(pAce1->Header.AceFlags !=  pAce2->Header.AceFlags)
            {
                if(fVerbose)
                {
                    fprintf(stderr,
                            "\tAceType mismatch: %lu %lu\n",
                            pAce1->Header.AceFlags,
                            pAce2->Header.AceFlags);
                }
                dwErr = ERROR_INVALID_DATA;
            }

            if(pAce1->Header.AceSize !=  pAce2->Header.AceSize)
            {
                if(fVerbose)
                {
                    fprintf(stderr,
                            "\tAceType mismatch: %lu %lu\n",
                            pAce1->Header.AceSize,
                            pAce2->Header.AceSize);
                }
                dwErr = ERROR_INVALID_DATA;
            }

            ConvertAccessMaskToAccessRight(pAce1->Mask, &Rights1);
            ConvertAccessMaskToAccessRight(pAce2->Mask, &Rights2);
            if(Rights1 != Rights1)
            {
                if(fVerbose)
                {
                    fprintf(stderr,
                            "\tAccessMask mismatch: %lu %lu\n",
                            Rights1,
                            Rights2);
                }
                dwErr = ERROR_INVALID_DATA;
            }

            if(!RtlEqualSid((PSID)&(pAce1->SidStart), (PSID)&(pAce2->SidStart)))
            {
                if(fVerbose)
                {
                    fprintf(stderr,
                            "\tSids don't match\n");
                }
                dwErr = ERROR_INVALID_DATA;
            }

            pAce1 = NextAce(pAce1);
            pAce2 = NextAce(pAce2);
        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   CompStringsW
//
//  Synopsis:   Compares 2 string pointers for equality
//
//  Arguments:  [pwszStr1]          --  First string
//              [pwszStr2]          --  Second string
//
//  Returns:    ERROR_SUCCESS       --  They match
//              ERROR_INVALID_DATA  --  They don't match
//
//----------------------------------------------------------------------------
DWORD
CompStringsW(PWSTR  pwszStr1, PWSTR  pwszStr2)
{
    if(pwszStr1 != NULL && pwszStr2 != NULL)
    {
        if(_wcsicmp(pwszStr1, pwszStr2) == 0)
        {
            return(ERROR_SUCCESS);
        }
    }
    else
    {
        if(pwszStr1 == NULL)
        {
            return(ERROR_SUCCESS);
        }
    }

    return(ERROR_INVALID_DATA);
}




//+---------------------------------------------------------------------------
//
//  Function:   CompStringsA
//
//  Synopsis:   Compares 2 string pointers for equality
//
//  Arguments:  [pszStr1]           --  First string
//              [pszStr2]           --  Second string
//
//  Returns:    ERROR_SUCCESS       --  They match
//              ERROR_INVALID_DATA  --  They don't match
//
//----------------------------------------------------------------------------
DWORD
CompStringsA(PSTR  pszStr1, PSTR  pszStr2)
{
    if(pszStr1 != NULL && pszStr2 != NULL)
    {
        if(_stricmp(pszStr1, pszStr2) == 0)
        {
            return(ERROR_SUCCESS);
        }
    }
    else
    {
        if(pszStr1 == NULL)
        {
            return(ERROR_SUCCESS);
        }
    }


    return(ERROR_INVALID_DATA);
}




//+---------------------------------------------------------------------------
//
//  Function:   CompAccessW
//
//  Synopsis:   Compares 2 WIDE access lists for equality
//
//  Arguments:  [pAccess1]          --  First list
//              [pAccess2]          --  Second list
//
//  Returns:    ERROR_SUCCESS       --  They match
//              ERROR_INVALID_DATA  --  They don't match
//
//----------------------------------------------------------------------------
DWORD CompAccessW(PACTRL_ACCESSW pAccess1,
                  PACTRL_ACCESSW pAccess2)
{
    DWORD dwErr = ERROR_SUCCESS;
    ULONG iIndex = 0;

    if(pAccess1 == NULL || pAccess2 == NULL)
    {
        if(pAccess1 != pAccess2)
        {
            if(fVerbose)
            {
                fprintf(stderr,"Access %lu is NULL\n",
                        pAccess1 == NULL ? 1 : 2);
            }
            dwErr = ERROR_INVALID_DATA;
        }
    }
    else
    {
        PACTRL_ACCESS_ENTRY_LISTW pAAEL1;
        PACTRL_ACCESS_ENTRY_LISTW pAAEL2;

        dwErr = CompStringsW((PWSTR)pAccess1->pPropertyAccessList[0].lpProperty,
                             (PWSTR)pAccess2->pPropertyAccessList[0].lpProperty);
        if(dwErr != ERROR_SUCCESS)
        {
            return(dwErr);
        }

        pAAEL1 = pAccess1->pPropertyAccessList[0].pAccessEntryList;
        pAAEL2 = pAccess2->pPropertyAccessList[0].pAccessEntryList;
        if(pAAEL1->cEntries != pAAEL2->cEntries)
        {
            dwErr = ERROR_INVALID_DATA;
            if(fVerbose)
            {
                fprintf(stderr, "cEntries: %lu %lu\n",
                        pAAEL1->cEntries,
                        pAAEL2->cEntries);
            }
        }
        else
        {
            //
            // Compare all of the entries
            //
            for(iIndex = 0; iIndex < pAAEL1->cEntries; iIndex++)
            {
                if(_wcsicmp(pAAEL1->pAccessList[iIndex].Trustee.ptstrName,
                            pAAEL1->pAccessList[iIndex].Trustee.ptstrName) != 0)
                {
                    if(fVerbose)
                    {
                        fprintf(stderr, "Trustees: %ws %ws\n",
                                pAAEL1->pAccessList[iIndex].Trustee.ptstrName,
                                pAAEL2->pAccessList[iIndex].Trustee.ptstrName);
                    }
                    dwErr = ERROR_INVALID_DATA;
                    continue;
                }

                if(pAAEL1->pAccessList[iIndex].fAccessFlags !=
                                    pAAEL1->pAccessList[iIndex].fAccessFlags)
                {
                    if(fVerbose)
                    {
                        fprintf(stderr, "AccessFlags: %lu %lu\n",
                                pAAEL1->pAccessList[iIndex].fAccessFlags,
                                pAAEL2->pAccessList[iIndex].fAccessFlags);
                    }
                    dwErr = ERROR_INVALID_DATA;
                    continue;
                }

                if(pAAEL1->pAccessList[iIndex].Access !=
                                    pAAEL1->pAccessList[iIndex].Access)
                {
                    if(fVerbose)
                    {
                        fprintf(stderr, "Access: %lu %lu\n",
                                pAAEL1->pAccessList[iIndex].Access,
                                pAAEL2->pAccessList[iIndex].Access);
                    }
                    dwErr = ERROR_INVALID_DATA;
                    continue;
                }

                if(pAAEL1->pAccessList[iIndex].ProvSpecificAccess !=
                              pAAEL1->pAccessList[iIndex].ProvSpecificAccess)
                {
                    if(fVerbose)
                    {
                        fprintf(stderr, "ProvSpecificAccess: %lu %lu\n",
                                pAAEL1->pAccessList[iIndex].ProvSpecificAccess,
                                pAAEL2->pAccessList[iIndex].ProvSpecificAccess);
                    }
                    dwErr = ERROR_INVALID_DATA;
                    continue;
                }

                if(pAAEL1->pAccessList[iIndex].Inheritance !=
                                    pAAEL1->pAccessList[iIndex].Inheritance)
                {
                    if(fVerbose)
                    {
                        fprintf(stderr, "AccessFlags: %lu %lu\n",
                                pAAEL1->pAccessList[iIndex].Inheritance,
                                pAAEL2->pAccessList[iIndex].Inheritance);
                    }
                    dwErr = ERROR_INVALID_DATA;
                    continue;
                }

                //
                // The inheritance property
                //
                dwErr = CompStringsW(
                        (PWSTR)pAAEL1->pAccessList[iIndex].lpInheritProperty,
                        (PWSTR)pAAEL1->pAccessList[iIndex].lpInheritProperty);

                if(dwErr == ERROR_SUCCESS && fVerbose)
                {
                    printf("AccessEntry %lu\n", iIndex);
                }
            }
        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   CompAccessA
//
//  Synopsis:   Compares 2 ANSI access lists for equality
//
//  Arguments:  [pAccess1]          --  First list
//              [pAccess2]          --  Second list
//
//  Returns:    ERROR_SUCCESS       --  They match
//              ERROR_INVALID_DATA  --  They don't match
//
//----------------------------------------------------------------------------
DWORD CompAccessA(PACTRL_ACCESSA pAccess1,
                  PACTRL_ACCESSA pAccess2)
{
    DWORD dwErr = ERROR_SUCCESS;
    ULONG iIndex = 0;

    if(pAccess1 == NULL || pAccess2 == NULL)
    {
        if(pAccess1 != pAccess2)
        {
            if(fVerbose)
            {
                fprintf(stderr,"Access %lu is NULL\n",
                        pAccess1 == NULL ? 1 : 2);
            }
            dwErr = ERROR_INVALID_DATA;
        }
    }
    else
    {
        PACTRL_ACCESS_ENTRY_LISTA pAAEL1;
        PACTRL_ACCESS_ENTRY_LISTA pAAEL2;

        dwErr = CompStringsA((PSTR)pAccess1->pPropertyAccessList[0].lpProperty,
                             (PSTR)pAccess2->pPropertyAccessList[0].lpProperty);
        if(dwErr != ERROR_SUCCESS)
        {
            return(dwErr);
        }

        pAAEL1 = pAccess1->pPropertyAccessList[0].pAccessEntryList;
        pAAEL2 = pAccess2->pPropertyAccessList[0].pAccessEntryList;
        if(pAAEL1->cEntries != pAAEL2->cEntries)
        {
            dwErr = ERROR_INVALID_DATA;
            if(fVerbose)
            {
                fprintf(stderr, "cEntries: %lu %lu\n",
                        pAAEL1->cEntries,
                        pAAEL2->cEntries);
            }
        }
        else
        {
            //
            // Compare all of the entries
            //
            for(iIndex = 0; iIndex < pAAEL1->cEntries; iIndex++)
            {
                if(_stricmp(pAAEL1->pAccessList[iIndex].Trustee.ptstrName,
                            pAAEL1->pAccessList[iIndex].Trustee.ptstrName) != 0)
                {
                    if(fVerbose)
                    {
                        fprintf(stderr, "Trustees: %ws %ws\n",
                                pAAEL1->pAccessList[iIndex].Trustee.ptstrName,
                                pAAEL2->pAccessList[iIndex].Trustee.ptstrName);
                    }
                    dwErr = ERROR_INVALID_DATA;
                    continue;
                }

                if(pAAEL1->pAccessList[iIndex].fAccessFlags !=
                                    pAAEL1->pAccessList[iIndex].fAccessFlags)
                {
                    if(fVerbose)
                    {
                        fprintf(stderr, "AccessFlags: %lu %lu\n",
                                pAAEL1->pAccessList[iIndex].fAccessFlags,
                                pAAEL2->pAccessList[iIndex].fAccessFlags);
                    }
                    dwErr = ERROR_INVALID_DATA;
                    continue;
                }

                if(pAAEL1->pAccessList[iIndex].Access !=
                                    pAAEL1->pAccessList[iIndex].Access)
                {
                    if(fVerbose)
                    {
                        fprintf(stderr, "Access: %lu %lu\n",
                                pAAEL1->pAccessList[iIndex].Access,
                                pAAEL2->pAccessList[iIndex].Access);
                    }
                    dwErr = ERROR_INVALID_DATA;
                    continue;
                }

                if(pAAEL1->pAccessList[iIndex].ProvSpecificAccess !=
                              pAAEL1->pAccessList[iIndex].ProvSpecificAccess)
                {
                    if(fVerbose)
                    {
                        fprintf(stderr, "ProvSpecificAccess: %lu %lu\n",
                                pAAEL1->pAccessList[iIndex].ProvSpecificAccess,
                                pAAEL2->pAccessList[iIndex].ProvSpecificAccess);
                    }
                    dwErr = ERROR_INVALID_DATA;
                    continue;
                }

                if(pAAEL1->pAccessList[iIndex].Inheritance !=
                                    pAAEL1->pAccessList[iIndex].Inheritance)
                {
                    if(fVerbose)
                    {
                        fprintf(stderr, "AccessFlags: %lu %lu\n",
                                pAAEL1->pAccessList[iIndex].Inheritance,
                                pAAEL2->pAccessList[iIndex].Inheritance);
                    }
                    dwErr = ERROR_INVALID_DATA;
                    continue;
                }

                //
                // The inheritance property
                //
                dwErr = CompStringsA(
                          (PSTR)pAAEL1->pAccessList[iIndex].lpInheritProperty,
                          (PSTR)pAAEL1->pAccessList[iIndex].lpInheritProperty);

                if(dwErr == ERROR_SUCCESS && fVerbose)
                {
                    printf("AccessEntry %lu\n", iIndex);
                }
            }
        }
    }

    return(dwErr);
}



//+---------------------------------------------------------------------------
//
//  Function:   DumpAccessW
//
//  Synopsis:   Dumps an ACTRL_ACCESSW structure to the screen
//
//  Arguments:  [pAccess]           --  Structure to dump
//
//  Returns:    VOID
//
//----------------------------------------------------------------------------
VOID
DumpAccessW(PACTRL_ACCESSW  pAccess)
{
    if(fVerbose)
    {
        ULONG iProp, iEnt;
        printf("\tEntries: %lu\n", pAccess->cEntries);
        for(iProp = 0; iProp < pAccess->cEntries; iProp++)
        {
            printf("\t\tProperty: %ws\n",
                   pAccess->pPropertyAccessList[iProp].lpProperty == NULL ?
                              L"NULL" :
                              pAccess->pPropertyAccessList[iProp].lpProperty);
            printf("\t\tFlags: %lu\n",
                   pAccess->pPropertyAccessList[iProp].fListFlags);
            if(pAccess->pPropertyAccessList[iProp].pAccessEntryList == NULL)
            {
                printf("\t\tpAccessEntryList: NULL\n");
            }
            else
            {
                PACTRL_ACCESS_ENTRYW pAE= pAccess->pPropertyAccessList[iProp].
                                                pAccessEntryList->pAccessList;
                printf("\t\t\tcEntries: %lu\n",
                       pAccess->pPropertyAccessList[iProp].pAccessEntryList->
                                                                    cEntries);

                for(iEnt = 0;
                    iEnt < pAccess->pPropertyAccessList[iProp].
                                                   pAccessEntryList->cEntries;
                    iEnt++)
                {
                    printf("\t\t\tEntry %lu:\n", iEnt);
                    printf("\t\t\t\tTrustee.Name: %ws\n",
                           pAE[iEnt].Trustee.ptstrName);
                    printf("\t\t\t\tfAccessFlags: %lu\n",
                           pAE[iEnt].fAccessFlags);
                    printf("\t\t\t\tAccess: 0x%lx\n", pAE[iEnt].Access);
                    printf("\t\t\t\tProvSpecificAccess: %lu\n",
                           pAE[iEnt].ProvSpecificAccess);
                    printf("\t\t\t\tInheritance: %lu\n", pAE[iEnt].Inheritance);
                    printf("\t\t\t\tlpInheritProperty: %ws\n",
                           pAE[iEnt].lpInheritProperty == NULL ?
                                                L""  :
                                                pAE[iEnt].lpInheritProperty);
                }
            }
        }
    }
}

#define BUILD_COUNT 5
//+---------------------------------------------------------------------------
//
//  Function:   Nt4BuildW
//
//  Synopsis:   Builds an ACL using the NT4 API WIDE apis
//
//  Arguments:  [ppAcl]             --  Acl to build
//
//  Returns:    ERROR_SUCCESS       --  Everything worked
//              ERROR_INVALID_DATA  --  One of the compares failed
//
//----------------------------------------------------------------------------
DWORD   Nt4BuildW(PACL *ppAcl)
{
    DWORD               dwErr = ERROR_SUCCESS;
    ULONG               cCount;
    EXPLICIT_ACCESS_W   EAW;
    PEXPLICIT_ACCESS_W  pEAW;
    PACL                pAcl = NULL, pNewAcl;
    ULONG               iIndex, iVer;

    PWSTR rgTrustees[BUILD_COUNT] = {EVERYONE,
                                     SYSTEM,
                                     GUEST,
                                     EVERYONE,
                                     SYSTEM};

    DWORD rgAccess[BUILD_COUNT] =   {GENERIC_ALL | 0x8,
                                     GENERIC_ALL,
                                     GENERIC_ALL | 0x8,
                                     GENERIC_ALL | 0x8,
                                     0};

    ACCESS_MODE rgMode[BUILD_COUNT] = {SET_ACCESS,
                                       DENY_ACCESS,
                                       SET_ACCESS,
                                       SET_ACCESS,
                                       REVOKE_ACCESS};

    DWORD rgInherit[BUILD_COUNT] = {NO_INHERITANCE,
                                    NO_INHERITANCE,
                                    SUB_CONTAINERS_AND_OBJECTS_INHERIT,
                                    NO_INHERITANCE,
                                    SUB_CONTAINERS_AND_OBJECTS_INHERIT};

    DWORD rgSrch[BUILD_COUNT][BUILD_COUNT + 1] = {{1, 0},
                                                  {2, 1, 0},
                                                  {3, 1, 2, 0},
                                                  {3, 1, 3, 2},
                                                  {2, 3, 2}};
    if(fVerbose)
    {
        printf("Nt4BuildW\n");
    }

    //
    // We'll do this in a loop, since we have BUILD_COUNT different builds to do
    //
    for(iIndex = 0; iIndex < BUILD_COUNT && dwErr == ERROR_SUCCESS; iIndex++)
    {
        //
        // Build the new entry
        //
        BuildExplicitAccessWithNameW(&EAW,
                                     rgTrustees[iIndex],
                                     rgAccess[iIndex],
                                     rgMode[iIndex],
                                     rgInherit[iIndex]);

        dwErr = SetEntriesInAclW(1,
                                 &EAW,
                                 pAcl,
                                 &pNewAcl);

        if(dwErr == ERROR_SUCCESS)
        {
            LocalFree(pAcl);
            pAcl = pNewAcl;

            //
            // Get the explicit entries, and we'll verify them...
            //
            dwErr = GetExplicitEntriesFromAclW(pAcl,
                                               &cCount,
                                               &pEAW);
            if(dwErr == ERROR_SUCCESS)
            {
                PDWORD  pSrch = rgSrch[iIndex];
                ULONG   cExpected = pSrch[0];

                if(cCount != cExpected)
                {
                    dwErr = ERROR_INVALID_DATA;
                    if(fVerbose)
                    {
                        printf("\tCount mismatched: %lu, expected %lu\n",
                               cCount,
                               cExpected);
                    }
                }
                else
                {
                    //
                    // verify the rest of the data
                    //
                    for(iVer = 0; iVer < cExpected; iVer++)
                    {
                        ULONG iSrch = pSrch[iVer + 1];
                        if(_wcsicmp(pEAW[iVer].Trustee.ptstrName,
                                    rgTrustees[iSrch]) != 0)
                        {
                            dwErr = ERROR_INVALID_DATA;
                            if(fVerbose)
                            {
                                printf("\tTrustee mismatch[%lu]: %ws, expected "
                                       "%ws\n",
                                       iVer,
                                       pEAW[iVer].Trustee.ptstrName,
                                       rgTrustees[iSrch]);
                            }
                        }
                    }
                }

                if(dwErr == ERROR_SUCCESS)
                {
                    if(fVerbose)
                    {
                        printf("\tCount: %lu\n", cCount);
                    }
                }
                LocalFree(pEAW);
            }
            else
            {
                fprintf(stderr,
                        "\tNt4BuildW: SetEntriesInAclW failed with %lu\n",
                        dwErr);
            }
        }
        else
        {
            fprintf(stderr,"\tNt4BuildW: SetEntriesInAclW failed with %lu\n",
                    dwErr);
        }

    }

    if(dwErr == ERROR_SUCCESS)
    {
        *ppAcl = pAcl;
    }
    else
    {
        LocalFree(pAcl);
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   Nt4BuildA
//
//  Synopsis:   Builds an ACL using the NT4 API ANSI apis
//
//  Arguments:  [ppAcl]             --  Acl to build
//
//  Returns:    ERROR_SUCCESS       --  Everything worked
//              ERROR_INVALID_DATA  --  One of the compares failed
//
//----------------------------------------------------------------------------
DWORD   Nt4BuildA(PACL *ppAcl)
{
    DWORD               dwErr = ERROR_SUCCESS;
    ULONG               cCount;
    EXPLICIT_ACCESS_A   EAA;
    PEXPLICIT_ACCESS_A  pEAA;
    PACL                pAcl = NULL, pNewAcl;
    ULONG               iIndex, iVer;

    PSTR rgTrustees[BUILD_COUNT] = {EVERYONE_A,
                                    SYSTEM_A,
                                    GUEST_A,
                                    EVERYONE_A,
                                    SYSTEM_A};

    DWORD rgAccess[BUILD_COUNT] =   {GENERIC_ALL | 0x8,
                                     GENERIC_ALL,
                                     GENERIC_ALL | 0x8,
                                     GENERIC_ALL | 0x8,
                                     0};

    ACCESS_MODE rgMode[BUILD_COUNT] = {SET_ACCESS,
                                       DENY_ACCESS,
                                       SET_ACCESS,
                                       SET_ACCESS,
                                       REVOKE_ACCESS};

    DWORD rgInherit[BUILD_COUNT] = {NO_INHERITANCE,
                                    NO_INHERITANCE,
                                    SUB_CONTAINERS_AND_OBJECTS_INHERIT,
                                    NO_INHERITANCE,
                                    SUB_CONTAINERS_AND_OBJECTS_INHERIT};

    DWORD rgSrch[BUILD_COUNT][BUILD_COUNT + 1] = {{1, 0},
                                                  {2, 1, 0},
                                                  {3, 1, 2, 0},
                                                  {3, 1, 3, 2},
                                                  {2, 3, 2}};
    if(fVerbose)
    {
        printf("Nt4BuildA\n");
    }

    //
    // We'll do this in a loop, since we have BUILD_COUNT different builds to do
    //
    for(iIndex = 0; iIndex < BUILD_COUNT && dwErr == ERROR_SUCCESS; iIndex++)
    {
        //
        // Build the new entry
        //
        BuildExplicitAccessWithNameA(&EAA,
                                     rgTrustees[iIndex],
                                     rgAccess[iIndex],
                                     rgMode[iIndex],
                                     rgInherit[iIndex]);

        dwErr = SetEntriesInAclA(1,
                                 &EAA,
                                 pAcl,
                                 &pNewAcl);

        if(dwErr == ERROR_SUCCESS)
        {
            LocalFree(pAcl);
            pAcl = pNewAcl;

            //
            // Get the explicit entries, and we'll verify them...
            //
            dwErr = GetExplicitEntriesFromAclA(pAcl,
                                               &cCount,
                                               &pEAA);
            if(dwErr == ERROR_SUCCESS)
            {
                PDWORD  pSrch = rgSrch[iIndex];
                ULONG   cExpected = pSrch[0];

                if(cCount != cExpected)
                {
                    dwErr = ERROR_INVALID_DATA;
                    if(fVerbose)
                    {
                        printf("\tCount mismatched: %lu, expected %lu\n",
                               cCount,
                               cExpected);
                    }
                }
                else
                {
                    //
                    // verify the rest of the data
                    //
                    for(iVer = 0; iVer < cExpected; iVer++)
                    {
                        ULONG iSrch = pSrch[iVer + 1];
                        if(_stricmp(pEAA[iVer].Trustee.ptstrName,
                                    rgTrustees[iSrch]) != 0)
                        {
                            dwErr = ERROR_INVALID_DATA;
                            if(fVerbose)
                            {
                                printf("\tTrustee mismatch[%lu]: %s, expected "
                                       "%s\n",
                                       iVer,
                                       pEAA[iVer].Trustee.ptstrName,
                                       rgTrustees[iSrch]);
                            }
                        }
                    }
                }

                if(dwErr == ERROR_SUCCESS)
                {
                    if(fVerbose)
                    {
                        printf("\tCount: %lu\n", cCount);
                    }
                }

                LocalFree(pEAA);
            }
            else
            {
                fprintf(stderr,
                        "\tNt4BuildA: SetEntriesInAclA failed with %lu\n",
                        dwErr);
            }
        }
        else
        {
            fprintf(stderr,"\tNt4BuildA: SetEntriesInAclA failed with %lu\n",
                    dwErr);
        }

    }

    if(dwErr == ERROR_SUCCESS)
    {
        *ppAcl = pAcl;
    }
    else
    {
        LocalFree(pAcl);
    }

    return(dwErr);
}



#undef BUILD_COUNT
#define BUILD_COUNT 6
//+---------------------------------------------------------------------------
//
//  Function:   Nt5BuildW
//
//  Synopsis:   Builds an ACL using the NT5 API WIDE apis
//
//  Arguments:  [ppAccess]          --  Access list to build
//
//  Returns:    ERROR_SUCCESS       --  Everything worked
//              ERROR_INVALID_DATA  --  One of the compares failed
//
//----------------------------------------------------------------------------
DWORD   Nt5BuildW(PACTRL_ACCESSW   *ppAccess)
{
    DWORD   dwErr = ERROR_SUCCESS;

    PACTRL_ACCESSW      pAccess = NULL, pNewAccess;
    ULONG               iIndex, iVer;

    PWSTR rgTrustees[BUILD_COUNT] = {SYSTEM, EVERYONE, SYSTEM, GUEST,
                                     EVERYONE, SYSTEM};

    DWORD rgTypes[BUILD_COUNT] = {ACTRL_ACCESS_ALLOWED,
                                  ACTRL_ACCESS_ALLOWED,
                                  ACTRL_ACCESS_DENIED,
                                  ACTRL_ACCESS_ALLOWED,
                                  ACTRL_ACCESS_ALLOWED,
                                  ACTRL_ACCESS_DENIED};

    DWORD rgAccess[BUILD_COUNT] =   {ACTRL_STD_RIGHTS_ALL | ACTRL_PERM_5,
                                     ACTRL_STD_RIGHTS_ALL | ACTRL_PERM_1,
                                     ACTRL_STD_RIGHTS_ALL | ACTRL_PERM_2,
                                     ACTRL_STD_RIGHTS_ALL | ACTRL_PERM_3,
                                     ACTRL_STD_RIGHTS_ALL | ACTRL_PERM_4,
                                     ACTRL_STD_RIGHTS_ALL | ACTRL_PERM_2};

    ACCESS_MODE rgMode[BUILD_COUNT] = {SET_ACCESS, SET_ACCESS, GRANT_ACCESS,
                                       GRANT_ACCESS, GRANT_ACCESS,
                                       REVOKE_ACCESS};

    DWORD rgInherit[BUILD_COUNT] = {NO_INHERITANCE, NO_INHERITANCE,
                                    NO_INHERITANCE, NO_INHERITANCE,
                                    NO_INHERITANCE, NO_INHERITANCE};

    DWORD rgSrch[BUILD_COUNT][BUILD_COUNT + 1] = {{1, 0},
                                                  {1, 1},
                                                  {2, 2, 1},
                                                  {3, 2, 3, 1},
                                                  {4, 2, 4, 3, 1},
                                                  {3, 4, 3, 1}};
    if(fVerbose)
    {
        printf("Nt5BuildW\n");
    }

    //
    // We'll do this in a loop, since we have BUILD_COUNT different builds to do
    //
    for(iIndex = 0; iIndex < BUILD_COUNT && dwErr == ERROR_SUCCESS; iIndex++)
    {

        ACTRL_ACCESS_ENTRYW  AAE;

        BuildTrusteeWithNameW(&(AAE.Trustee),
                              rgTrustees[iIndex]);
        AAE.fAccessFlags = rgTypes[iIndex];
        AAE.Access = rgAccess[iIndex];
        AAE.ProvSpecificAccess = 0;
        AAE.Inheritance = rgInherit[iIndex];
        AAE.lpInheritProperty = NULL;

        dwErr = SetEntriesInAccessListW(1,
                                        &AAE,
                                        rgMode[iIndex],
                                        NULL,
                                        pAccess,
                                        &pNewAccess);
        if(dwErr == ERROR_SUCCESS)
        {
            LocalFree(pAccess);
            pAccess = pNewAccess;
        }

        if(dwErr == ERROR_SUCCESS)
        {
            //
            // Now, verify the new entries...
            //
            PACTRL_ACCESS_ENTRY_LISTW pAAELW =
                           pAccess->pPropertyAccessList[0].pAccessEntryList;
            PDWORD  pSrch = rgSrch[iIndex];
            ULONG   cExpected = pSrch[0];

            if(pAAELW->cEntries != cExpected)
            {
                dwErr = ERROR_INVALID_DATA;
                if(fVerbose)
                {
                    printf("\tCount mismatched: %lu, expected %lu\n",
                           pAAELW->cEntries,
                           cExpected);
                }
            }
            else
            {
                //
                // verify the rest of the data
                //
                for(iVer = 0; iVer < pAAELW->cEntries; iVer++)
                {
                    ULONG iSrch = pSrch[iVer + 1];
                    if(_wcsicmp(pAAELW->pAccessList[iVer].Trustee.ptstrName,
                                rgTrustees[iSrch]) != 0)
                    {
                        dwErr = ERROR_INVALID_DATA;
                        if(fVerbose)
                        {
                            printf("\tTrustee mismatch[%lu]: %ws, expected "
                                   "%ws\n",
                                   iVer,
                                   pAAELW->pAccessList[iVer].Trustee.ptstrName,
                                   rgTrustees[iSrch]);
                        }
                    }
                }
            }

            if(dwErr == ERROR_SUCCESS)
            {
                if(fVerbose)
                {
                    printf("\tCount: %lu\n", cExpected);
                }
            }
        }
        else
        {
            fprintf(stderr,"\tNt5BuildW: SetEntriesInAccessListW failed "
                    "with %lu\n",
                    dwErr);
        }

    }

    if(dwErr == ERROR_SUCCESS)
    {
        *ppAccess = pAccess;
    }
    else
    {
        LocalFree(pAccess);
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   Nt5BuildA
//
//  Synopsis:   Builds an ACL using the NT5 API ANSI apis
//
//  Arguments:  [ppAccess]          --  Access list to build
//
//  Returns:    ERROR_SUCCESS       --  Everything worked
//              ERROR_INVALID_DATA  --  One of the compares failed
//
//----------------------------------------------------------------------------
DWORD   Nt5BuildA(PACTRL_ACCESSA   *ppAccess)
{
    DWORD   dwErr = ERROR_SUCCESS;

    PACTRL_ACCESSA      pAccess = NULL, pNewAccess;
    ULONG               iIndex, iVer;

    PSTR rgTrustees[BUILD_COUNT] = {SYSTEM_A, EVERYONE_A, SYSTEM_A, GUEST_A,
                                     EVERYONE_A, SYSTEM_A};

    DWORD rgTypes[BUILD_COUNT] = {ACTRL_ACCESS_ALLOWED,
                                  ACTRL_ACCESS_ALLOWED,
                                  ACTRL_ACCESS_DENIED,
                                  ACTRL_ACCESS_ALLOWED,
                                  ACTRL_ACCESS_ALLOWED,
                                  ACTRL_ACCESS_DENIED};

    DWORD rgAccess[BUILD_COUNT] =   {ACTRL_STD_RIGHTS_ALL | ACTRL_PERM_5,
                                     ACTRL_STD_RIGHTS_ALL | ACTRL_PERM_1,
                                     ACTRL_STD_RIGHTS_ALL | ACTRL_PERM_2,
                                     ACTRL_STD_RIGHTS_ALL | ACTRL_PERM_3,
                                     ACTRL_STD_RIGHTS_ALL | ACTRL_PERM_4,
                                     ACTRL_STD_RIGHTS_ALL | ACTRL_PERM_2};

    ACCESS_MODE rgMode[BUILD_COUNT] = {SET_ACCESS, SET_ACCESS, GRANT_ACCESS,
                                       GRANT_ACCESS, GRANT_ACCESS,
                                       REVOKE_ACCESS};

    DWORD rgInherit[BUILD_COUNT] = {NO_INHERITANCE, NO_INHERITANCE,
                                    NO_INHERITANCE, NO_INHERITANCE,
                                    NO_INHERITANCE, NO_INHERITANCE};

    DWORD rgSrch[BUILD_COUNT][BUILD_COUNT + 1] = {{1, 0},
                                                  {1, 1},
                                                  {2, 2, 1},
                                                  {3, 2, 3, 1},
                                                  {4, 2, 4, 3, 1},
                                                  {3, 4, 3, 1}};
    if(fVerbose)
    {
        printf("Nt5BuildA\n");
    }

    //
    // We'll do this in a loop, since we have BUILD_COUNT different builds to do
    //
    for(iIndex = 0; iIndex < BUILD_COUNT && dwErr == ERROR_SUCCESS; iIndex++)
    {

        ACTRL_ACCESS_ENTRYA  AAE;

        BuildTrusteeWithNameA(&(AAE.Trustee),
                             rgTrustees[iIndex]);
        AAE.fAccessFlags = rgTypes[iIndex];
        AAE.Access = rgAccess[iIndex];
        AAE.ProvSpecificAccess = 0;
        AAE.Inheritance = rgInherit[iIndex];
        AAE.lpInheritProperty = NULL;

        dwErr = SetEntriesInAccessListA(1,
                                        &AAE,
                                        rgMode[iIndex],
                                        NULL,
                                        pAccess,
                                        &pNewAccess);
        if(dwErr == ERROR_SUCCESS)
        {
            LocalFree(pAccess);
            pAccess = pNewAccess;
        }

        if(dwErr == ERROR_SUCCESS)
        {
            //
            // Now, verify the new entries...
            //
            PACTRL_ACCESS_ENTRY_LISTA pAAELA =
                           pAccess->pPropertyAccessList[0].pAccessEntryList;
            PDWORD  pSrch = rgSrch[iIndex];
            ULONG   cExpected = pSrch[0];

            if(pAAELA->cEntries != cExpected)
            {
                dwErr = ERROR_INVALID_DATA;
                if(fVerbose)
                {
                    printf("\tCount mismatched: %lu, expected %lu\n",
                           pAAELA->cEntries,
                           cExpected);
                }
            }
            else
            {
                //
                // verify the rest of the data
                //
                for(iVer = 0; iVer < pAAELA->cEntries; iVer++)
                {
                    ULONG iSrch = pSrch[iVer + 1];
                    if(_stricmp(pAAELA->pAccessList[iVer].Trustee.ptstrName,
                                rgTrustees[iSrch]) != 0)
                    {
                        dwErr = ERROR_INVALID_DATA;
                        if(fVerbose)
                        {
                            printf("\tTrustee mismatch[%lu]: %s, expected "
                                   "%s\n",
                                   iVer,
                                   pAAELA->pAccessList[iVer].Trustee.ptstrName,
                                   rgTrustees[iSrch]);
                        }
                    }
                }
            }

            if(dwErr == ERROR_SUCCESS)
            {
                if(fVerbose)
                {
                    printf("\tCount: %lu\n", cExpected);
                }
            }
        }
        else
        {
            fprintf(stderr,"\tNt5BuildA: SetEntriesInAccessListA failed "
                    "with %lu\n",
                    dwErr);
        }

    }

    if(dwErr == ERROR_SUCCESS)
    {
        *ppAccess = pAccess;
    }
    else
    {
        LocalFree(pAccess);
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   Nt4DrtW
//
//  Synopsis:   Does the actual API drt.  This involves reading the existing
//              access, writing the new one, rereading the new one and
//              verifing the results, and then restores the old one.  This
//              uses the WIDE version of the NT4 APIs
//
//  Arguments:  [pAcl]              --  Acl to write on the object
//              [pszObject]         --  The object in question
//              [ObjType]           --  Type of the object
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_DATA  --  One of the compares failed
//
//----------------------------------------------------------------------------
DWORD   Nt4DrtW(PACL            pAcl,
                PSTR            pszObject,
                SE_OBJECT_TYPE  ObjType)
{
    DWORD                   dwErr = ERROR_SUCCESS;
    WCHAR                   wszPath[MAX_PATH + 1];
    PACL                    pOldAcl = NULL;
    PSECURITY_DESCRIPTOR    pSD = NULL;

    mbstowcs(wszPath, pszObject, strlen(pszObject) + 1);

    if(fVerbose)
    {
        printf("Nt4DrtW: Processing %ws [%lu]\n", wszPath, ObjType);
    }

    //
    // First, get the old acl
    //
    dwErr = GetNamedSecurityInfoW(wszPath,
                                  ObjType,
                                  DACL_SECURITY_INFORMATION,
                                  NULL,
                                  NULL,
                                  &pOldAcl,
                                  NULL,
                                  &pSD);
    if(dwErr == ERROR_SUCCESS)
    {
        //
        // Set, get, and compare the new acl...
        //
        dwErr = SetNamedSecurityInfoW(wszPath,
                                      ObjType,
                                      DACL_SECURITY_INFORMATION,
                                      NULL,
                                      NULL,
                                      pAcl,
                                      NULL);
        if(dwErr == ERROR_SUCCESS)
        {
            PACL    pNewAcl = NULL;
            PSECURITY_DESCRIPTOR    pNewSD = NULL;
            dwErr = GetNamedSecurityInfoW(wszPath,
                                          ObjType,
                                          DACL_SECURITY_INFORMATION,
                                          NULL,
                                          NULL,
                                          &pNewAcl,
                                          NULL,
                                          &pNewSD);
            if(dwErr == ERROR_SUCCESS)
            {
                //
                // Compare them...
                //
                dwErr = CompAcls(pAcl, pNewAcl);
                if(dwErr != ERROR_SUCCESS)
                {
                    fprintf(stderr, "\tSet and old ACLs don't compare\n");
                }
                LocalFree(pNewSD);
            }
            else
            {
                if(fVerbose)
                {
                    printf("\tSecond GetNamedSecurityW on %ws failed with %lu\n",
                           wszPath,
                           dwErr);
                }
            }
        }
        else
        {
            if(fVerbose)
            {
                printf("\tSetNamedSecurityInfoW on %ws failed with %lu\n",
                       wszPath,
                       dwErr);
            }
        }
    }
    else
    {
        fprintf(stderr,
                "\tGetNamedSecurityInfoW failed on %ws: %lu\n",
                wszPath,
                dwErr);
    }

    //
    // Restore the objects security
    //
    if(pSD != NULL)
    {
        DWORD   dwErr2 = SetNamedSecurityInfoW(wszPath,
                                               ObjType,
                                               DACL_SECURITY_INFORMATION,
                                               NULL,
                                               NULL,
                                               pOldAcl,
                                               NULL);
        if(dwErr2 != ERROR_SUCCESS)
        {
            fprintf(stderr,
                    "Restoring access to %ws failed with %lu\n",
                    wszPath,
                    dwErr2);

        }

        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = dwErr2;
        }

    }
    LocalFree(pSD);
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   Nt4DrtA
//
//  Synopsis:   Does the actual API drt.  This involves reading the existing
//              access, writing the new one, rereading the new one and
//              verifing the results, and then restores the old one.  This
//              uses the ANSI version of the NT4 APIs
//
//  Arguments:  [pAcl]              --  Acl to write on the object
//              [pszObject]         --  The object in question
//              [ObjType]           --  Type of the object
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_DATA  --  One of the compares failed
//
//----------------------------------------------------------------------------
DWORD   Nt4DrtA(PACL            pAcl,
                PSTR            pszObject,
                SE_OBJECT_TYPE  ObjType)
{
    DWORD                   dwErr = ERROR_SUCCESS;
    PACL                    pOldAcl = NULL;
    PSECURITY_DESCRIPTOR    pSD = NULL;

    if(fVerbose)
    {
        printf("Nt4DrtA: Processing %s [%lu]\n", pszObject, ObjType);
    }

    //
    // First, get the old acl
    //
    dwErr = GetNamedSecurityInfoA(pszObject,
                                  ObjType,
                                  DACL_SECURITY_INFORMATION,
                                  NULL,
                                  NULL,
                                  &pOldAcl,
                                  NULL,
                                  &pSD);
    if(dwErr == ERROR_SUCCESS)
    {
        //
        // Set, get, and compare the new acl...
        //
        dwErr = SetNamedSecurityInfoA(pszObject,
                                      ObjType,
                                      DACL_SECURITY_INFORMATION,
                                      NULL,
                                      NULL,
                                      pAcl,
                                      NULL);
        if(dwErr == ERROR_SUCCESS)
        {
            PACL    pNewAcl = NULL;
            PSECURITY_DESCRIPTOR    pNewSD = NULL;
            dwErr = GetNamedSecurityInfoA(pszObject,
                                          ObjType,
                                          DACL_SECURITY_INFORMATION,
                                          NULL,
                                          NULL,
                                          &pNewAcl,
                                          NULL,
                                          &pNewSD);
            if(dwErr == ERROR_SUCCESS)
            {
                //
                // Compare them...
                //
                dwErr = CompAcls(pAcl, pNewAcl);
                if(dwErr != ERROR_SUCCESS)
                {
                    fprintf(stderr, "\tSet and old ACLs don't compare\n");
                }
                LocalFree(pNewSD);
            }
            else
            {
                if(fVerbose)
                {
                    printf("\tSecond GetNamedSecurityA on %s failed with %lu\n",
                           pszObject,
                           dwErr);
                }
            }
        }
        else
        {
            if(fVerbose)
            {
                printf("\tSetNamedSecurityInfoA on %s failed with %lu\n",
                       pszObject,
                       dwErr);
            }
        }
    }
    else
    {
        fprintf(stderr,
                "\tGetNamedSecurityInfoA failed on %s: %lu\n",
                pszObject,
                dwErr);
    }

    //
    // Restore the objects security
    //
    if(pSD != NULL)
    {
        DWORD   dwErr2 = SetNamedSecurityInfoA(pszObject,
                                               ObjType,
                                               DACL_SECURITY_INFORMATION,
                                               NULL,
                                               NULL,
                                               pOldAcl,
                                               NULL);
        if(dwErr2 != ERROR_SUCCESS)
        {
            fprintf(stderr,
                    "Restoring access to %s failed with %lu\n",
                    pszObject,
                    dwErr2);

        }

        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = dwErr2;
        }

    }
    LocalFree(pSD);
    return(dwErr);
}





//+---------------------------------------------------------------------------
//
//  Function:   Nt5DrtW
//
//  Synopsis:   Does the actual API drt.  This involves reading the existing
//              access, writing the new one, rereading the new one and
//              verifing the results, and then restores the old one.  This
//              uses the WIDE version of the NT5 APIs
//
//  Arguments:  [pAccess]           --  Access list to write on the object
//              [pszObject]         --  The object in question
//              [ObjType]           --  Type of the object
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_DATA  --  One of the compares failed
//
//----------------------------------------------------------------------------
DWORD   Nt5DrtW(PACTRL_ACCESSW  pAccess,
                PSTR            pszObject,
                SE_OBJECT_TYPE  ObjType)
{
    DWORD                   dwErr = ERROR_SUCCESS;
    WCHAR                   wszPath[MAX_PATH + 1];
    PACTRL_ACCESSW          pOldAccess = NULL;

    mbstowcs(wszPath, pszObject, strlen(pszObject) + 1);

    if(fVerbose)
    {
        printf("Nt5DrtW: Processing %ws [%lu]\n", wszPath, ObjType);
    }

    //
    // First, get the old acl
    //
    dwErr = GetNamedSecurityInfoExW(wszPath,
                                    ObjType,
                                    DACL_SECURITY_INFORMATION,
                                    NULL,
                                    NULL,
                                    &pOldAccess,
                                    NULL,
                                    NULL,
                                    NULL);
    if(dwErr == ERROR_SUCCESS)
    {

        //
        // Set, get, and compare the new value...
        //
        dwErr = SetNamedSecurityInfoExW(wszPath,
                                        ObjType,
                                        DACL_SECURITY_INFORMATION,
                                        NULL,
                                        pAccess,
                                        NULL,
                                        NULL,
                                        NULL,
                                        NULL);
        if(dwErr == ERROR_SUCCESS)
        {
            PACTRL_ACCESS    pNewAccess = NULL;
            dwErr = GetNamedSecurityInfoExW(wszPath,
                                            ObjType,
                                            DACL_SECURITY_INFORMATION,
                                            NULL,
                                            NULL,
                                            &pNewAccess,
                                            NULL,
                                            NULL,
                                            NULL);
            if(dwErr == ERROR_SUCCESS)
            {
                //
                // Compare them...
                //
                dwErr = CompAccessW(pAccess, pNewAccess);
                if(dwErr != ERROR_SUCCESS)
                {
                    fprintf(stderr, "\tSet and old Accesses don't compare\n");
                }
            }
            else
            {
                if(fVerbose)
                {
                    printf("\tSecond GetNamedSecurityExW on %ws failed "
                           "with %lu\n",
                           wszPath,
                           dwErr);
                }
            }
        }
        else
        {
            if(fVerbose)
            {
                printf("\tSetNamedSecurityInfoExW on %ws failed with %lu\n",
                       wszPath,
                       dwErr);
            }
        }
    }
    else
    {
        fprintf(stderr,
                "\tGetNamedSecurityInfoExW failed on %ws: %lu\n",
                wszPath,
                dwErr);
    }

    //
    // Restore the objects security
    //
    if(pOldAccess != NULL)
    {
        DWORD   dwErr2 = SetNamedSecurityInfoExW(wszPath,
                                                 ObjType,
                                                 DACL_SECURITY_INFORMATION,
                                                 NULL,
                                                 pOldAccess,
                                                 NULL,
                                                 NULL,
                                                 NULL,
                                                 NULL);
        if(dwErr2 != ERROR_SUCCESS)
        {
            fprintf(stderr,
                    "Restoring access to %ws failed with %lu\n",
                    wszPath,
                    dwErr2);

        }

        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = dwErr2;
        }

    }

    LocalFree(pOldAccess);

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   Nt5DrtA
//
//  Synopsis:   Does the actual API drt.  This involves reading the existing
//              access, writing the new one, rereading the new one and
//              verifing the results, and then restores the old one.  This
//              uses the ANSI version of the NT5 APIs
//
//  Arguments:  [pAccess]           --  Access list to write on the object
//              [pszObject]         --  The object in question
//              [ObjType]           --  Type of the object
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_DATA  --  One of the compares failed
//
//----------------------------------------------------------------------------
DWORD   Nt5DrtA(PACTRL_ACCESSA  pAccess,
                PSTR            pszObject,
                SE_OBJECT_TYPE  ObjType)
{
    DWORD                   dwErr = ERROR_SUCCESS;
    PACTRL_ACCESSA          pOldAccess = NULL;

    if(fVerbose)
    {
        printf("Nt5DrtA: Processing %s [%lu]\n", pszObject, ObjType);
    }

    //
    // First, get the old acl
    //
    dwErr = GetNamedSecurityInfoExA(pszObject,
                                    ObjType,
                                    DACL_SECURITY_INFORMATION,
                                    NULL,
                                    NULL,
                                    &pOldAccess,
                                    NULL,
                                    NULL,
                                    NULL);
    if(dwErr == ERROR_SUCCESS)
    {
        //
        // Set, get, and compare the new value...
        //
        dwErr = SetNamedSecurityInfoExA(pszObject,
                                        ObjType,
                                        DACL_SECURITY_INFORMATION,
                                        NULL,
                                        pAccess,
                                        NULL,
                                        NULL,
                                        NULL,
                                        NULL);
        if(dwErr == ERROR_SUCCESS)
        {
            PACTRL_ACCESSA    pNewAccess = NULL;
            dwErr = GetNamedSecurityInfoExA(pszObject,
                                            ObjType,
                                            DACL_SECURITY_INFORMATION,
                                            NULL,
                                            NULL,
                                            &pNewAccess,
                                            NULL,
                                            NULL,
                                            NULL);
            if(dwErr == ERROR_SUCCESS)
            {
                //
                // Compare them...
                //
                dwErr = CompAccessA(pAccess, pNewAccess);
                if(dwErr != ERROR_SUCCESS)
                {
                    fprintf(stderr, "\tSet and old Accesses don't compare\n");
                }
            }
            else
            {
                if(fVerbose)
                {
                    printf("\tSecond GetNamedSecurityExA on %s failed "
                           "with %lu\n",
                           pszObject,
                           dwErr);
                }
            }
        }
        else
        {
            if(fVerbose)
            {
                printf("\tSetNamedSecurityInfoExA on %s failed with %lu\n",
                       pszObject,
                       dwErr);
            }
        }
    }
    else
    {
        fprintf(stderr,
                "\tGetNamedSecurityInfoExA failed on %s: %lu\n",
                pszObject,
                dwErr);
    }

    //
    // Restore the objects security
    //
    if(pOldAccess != NULL)
    {
        DWORD   dwErr2 = SetNamedSecurityInfoExA(pszObject,
                                                 ObjType,
                                                 DACL_SECURITY_INFORMATION,
                                                 NULL,
                                                 pOldAccess,
                                                 NULL,
                                                 NULL,
                                                 NULL,
                                                 NULL);
        if(dwErr2 != ERROR_SUCCESS)
        {
            fprintf(stderr,
                    "Restoring access to %s failed with %lu\n",
                    pszObject,
                    dwErr2);

        }

        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = dwErr2;
        }

    }

    LocalFree(pOldAccess);

    //
    // Finally, try to convert to and from a security descriptor
    //
    if(dwErr == ERROR_SUCCESS)
    {
        PSECURITY_DESCRIPTOR    pSD;
        dwErr = ConvertAccessToSecurityDescriptorA(pAccess,
                                                   NULL,
                                                   "ntds\\macm",
                                                   NULL,
                                                   &pSD);
        if(dwErr != ERROR_SUCCESS)
        {
            fprintf(stderr,
                    "ConvertAccessToSecurityDescriptor failed with %lu\n",
                    dwErr);
        }
        else
        {
            PACTRL_ACCESSA  pNewAccess;
            PSTR            pszName;

            dwErr = ConvertSecurityDescriptorToAccessA(pszObject,
                                                       ObjType,
                                                       pSD,
                                                       &pNewAccess,
                                                       NULL,
                                                       &pszName,
                                                       NULL);
            if(dwErr == ERROR_SUCCESS)
            {
                AccFree(pszName);
                AccFree(pNewAccess);
            }
            else
            {
                fprintf(stderr,
                        "ConvertSecurityDescriptorToAccessA failed with %lu\n",
                        dwErr);
            }

            LocalFree(pSD);
        }

    }

    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\accctrl2\src\aclapi.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1996.
//
//  File:       ACLAPI.CXX
//
//  Contents:   Regular versions of the Access Control APIs
//
//  History:    14-Sep-96       MacM        Created
//
//  Notes:      This replaces the DaveMont's aclapi.cxx, although it steals
//              large sections of code from it.
//
//----------------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop

#include <seopaque.h>
#include <sertlp.h>

#define CONDITIONAL_EXIT(a, b) if (ERROR_SUCCESS != (a)) { goto b; }
//
// This macro will load the MARTA functions if they haven't already been
// loaded, and exit on failure
//
#define LOAD_MARTA(err)                                 \
err = AccProvpLoadMartaFunctions();                     \
if(err != ERROR_SUCCESS)                                \
{                                                       \
    return(err);                                        \
}


DWORD
GetErrorChecks(
    IN  SE_OBJECT_TYPE         ObjectType,
    IN  SECURITY_INFORMATION   SecurityInfo,
    OUT PSID                 * ppSidOwner,
    OUT PSID                 * ppSidGroup,
    OUT PACL                 * ppDacl,
    OUT PACL                 * ppSacl,
    OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor
    )
{
    if(FLAG_ON(SecurityInfo, OWNER_SECURITY_INFORMATION))
    {
        if (NULL == ppSidOwner)
        {
            if (NULL == ppSecurityDescriptor)
            {
                return ERROR_INVALID_PARAMETER;
            }
        }
        else
        {
            *ppSidOwner = NULL;
        }
    }

    if(FLAG_ON(SecurityInfo, GROUP_SECURITY_INFORMATION))
    {
        if (NULL == ppSidGroup)
        {
            if (NULL == ppSecurityDescriptor)
            {
                return ERROR_INVALID_PARAMETER;
            }
        }
        else
        {
            *ppSidGroup = NULL;
        }
    }

    if(FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION))
    {
        if (NULL == ppDacl)
        {
            if (NULL == ppSecurityDescriptor)
            {
                return ERROR_INVALID_PARAMETER;
            }
        }
        else
        {
            *ppDacl = NULL;
        }
    }

    if(FLAG_ON(SecurityInfo, SACL_SECURITY_INFORMATION))
    {
        if (NULL == ppSacl)
        {
            if (NULL == ppSecurityDescriptor)
            {
                return ERROR_INVALID_PARAMETER;
            }
        }
        else
        {
            *ppSacl = NULL;
        }
    }

    if (NULL != ppSecurityDescriptor)
    {
        *ppSecurityDescriptor = NULL;
    }

    return ERROR_SUCCESS;
}

DWORD
SetErrorChecks(
    IN  SE_OBJECT_TYPE       ObjectType,
    IN  SECURITY_INFORMATION SecurityInfo,
    IN  PSID                 pSidOwner,
    IN  PSID                 pSidGroup,
    IN  PACL                 pDacl,
    IN  PACL                 pSacl,
    OUT PSECURITY_DESCRIPTOR pSD
    )
{
    InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION);

    if (FLAG_ON(SecurityInfo, OWNER_SECURITY_INFORMATION))
    {
        if (FALSE == RtlValidSid(pSidOwner))
        {
            return ERROR_INVALID_PARAMETER;
        }

        if (FALSE == SetSecurityDescriptorOwner(pSD, pSidOwner, FALSE))
        {
            return GetLastError();
        }
    }

    if (FLAG_ON(SecurityInfo, GROUP_SECURITY_INFORMATION))
    {
        if (FALSE == RtlValidSid(pSidGroup))
        {
            return ERROR_INVALID_PARAMETER;
        }

        if (FALSE == SetSecurityDescriptorGroup(pSD, pSidGroup, FALSE))
        {
            return GetLastError();
        }
    }

    if (FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION))
    {
        if (NULL == pDacl)
        {
            //
            // Protect the DACL.
            //

            if (FALSE == SetSecurityDescriptorControl(pSD, SE_DACL_PROTECTED, SE_DACL_PROTECTED))
            {
                return GetLastError();
            }
        }
        else
        {
            if (FALSE == SetSecurityDescriptorDacl(pSD, TRUE, pDacl, FALSE))
            {
                return GetLastError();
            }

            if (FLAG_ON(SecurityInfo, PROTECTED_DACL_SECURITY_INFORMATION))
            {
                if (FALSE == SetSecurityDescriptorControl(pSD, SE_DACL_PROTECTED, SE_DACL_PROTECTED))
                {
                    return GetLastError();
                }
            }
        }
    }

    if (FLAG_ON(SecurityInfo, SACL_SECURITY_INFORMATION))
    {
        if (NULL == pSacl)
        {
            //
            // Protect the SACL.
            //

            if (FALSE == SetSecurityDescriptorControl(pSD, SE_SACL_PROTECTED, SE_SACL_PROTECTED))
            {
                return GetLastError();
            }
        }
        else
        {
            if(FALSE == SetSecurityDescriptorSacl(pSD, TRUE, pSacl, FALSE))
            {
                return GetLastError();
            }

            if (FLAG_ON(SecurityInfo, PROTECTED_SACL_SECURITY_INFORMATION))
            {
                if (FALSE == SetSecurityDescriptorControl(pSD, SE_SACL_PROTECTED, SE_SACL_PROTECTED))
                {
                    return GetLastError();
                }
            }
        }
    }

    return ERROR_SUCCESS;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetNamedSecurityInfoW
//
//  Synopsis:   Gets the specified security information from the indicated
//              object
//
//  Arguments:  [IN  pObjectName]   --  Object for which the permissions are
//                                      needed
//              [IN  ObjectType]    --  Type of object specified by lpObject
//              [IN  SecurityInfo]  --  What is to be returned
//              [OUT ppsidOwner]    --  Where the owners, if requested, is
//                                      returned.
//              [OUT ppsidGroup]    --  Where the groups, if requested, is
//                                      returned.
//              [OUT ppDacl]        --  Where the DACL, if requested, is
//                                      returned.
//              [OUT ppSacl]        --  Where the SACL, if requested, is
//                                      returned.
//              [OUT ppSecurityDescriptor]  Where the security descriptor is
//                                      returned
//
//  Returns:    ERROR_SUCCESS       --  Success
//
//----------------------------------------------------------------------------
#define NEW_MARTA_API
#ifdef NEW_MARTA_API
DWORD
WINAPI
GetNamedSecurityInfoW(IN  LPWSTR                 pObjectName,
                      IN  SE_OBJECT_TYPE         ObjectType,
                      IN  SECURITY_INFORMATION   SecurityInfo,
                      OUT PSID                  *ppsidOwner,
                      OUT PSID                  *ppsidGroup,
                      OUT PACL                  *ppDacl,
                      OUT PACL                  *ppSacl,
                      OUT PSECURITY_DESCRIPTOR  *ppSecurityDescriptor)
{
    DWORD   dwErr = ERROR_SUCCESS;

    if (NULL == pObjectName)
    {
        return ERROR_INVALID_PARAMETER;
    }

    dwErr = GetErrorChecks(
                ObjectType,
                SecurityInfo,
                ppsidOwner,
                ppsidGroup,
                ppDacl,
                ppSacl,
                ppSecurityDescriptor
                );

    CONDITIONAL_EXIT(dwErr, End)

    LOAD_MARTA(dwErr);

    CONDITIONAL_EXIT(dwErr, End)

    dwErr = (*(gNtMartaInfo.pfrGetNamedRights))(
                   pObjectName,
                   ObjectType,
                   SecurityInfo,
                   ppsidOwner,
                   ppsidGroup,
                   ppDacl,
                   ppSacl,
                   ppSecurityDescriptor
                   );

End:
    return(dwErr);
}

#else

DWORD
WINAPI
GetNamedSecurityInfoW(IN  LPWSTR                 pObjectName,
                      IN  SE_OBJECT_TYPE         ObjectType,
                      IN  SECURITY_INFORMATION   SecurityInfo,
                      OUT PSID                  *ppsidOwner,
                      OUT PSID                  *ppsidGroup,
                      OUT PACL                  *ppDacl,
                      OUT PACL                  *ppSacl,
                      OUT PSECURITY_DESCRIPTOR  *ppSecurityDescriptor)
{
    DWORD   dwErr = ERROR_SUCCESS;

    LOAD_MARTA(dwErr);

    //
    // We'll do this the easy way...
    //
    PACTRL_ACCESSW  pAccess = NULL, pAudit = NULL;
    PWSTR           pwszOwner = NULL, pwszGroup = NULL;

    dwErr = GetNamedSecurityInfoExW(pObjectName,
                                    ObjectType,
                                    SecurityInfo,
                                    NULL,
                                    NULL,
                                    FLAG_ON(SecurityInfo,
                                            DACL_SECURITY_INFORMATION) ?
                                                                  &pAccess :
                                                                  NULL,
                                    FLAG_ON(SecurityInfo,
                                            SACL_SECURITY_INFORMATION) ?
                                                                  &pAudit :
                                                                  NULL,

                                    FLAG_ON(SecurityInfo,
                                            OWNER_SECURITY_INFORMATION) ?
                                                                  &pwszOwner :
                                                                  NULL,

                                    FLAG_ON(SecurityInfo,
                                            GROUP_SECURITY_INFORMATION) ?
                                                                  &pwszGroup  :
                                                                  NULL);
    //
    // Now, we'll need to convert our access entries back into a
    // security descriptor, so we can rip it apart again...
    //
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = (*gNtMartaInfo.pfAToSD)(pAccess,
                                        pAudit,
                                        pwszOwner,
                                        pwszGroup,
                                        ppSecurityDescriptor);
        if(dwErr == ERROR_SUCCESS)
        {
            SECURITY_DESCRIPTOR *pSD =
                            (SECURITY_DESCRIPTOR *)*ppSecurityDescriptor;

            if(FLAG_ON(SecurityInfo, OWNER_SECURITY_INFORMATION) &&
               ppsidOwner != NULL)
            {
                *ppsidOwner = RtlpOwnerAddrSecurityDescriptor(pSD);
            }

            if(FLAG_ON(SecurityInfo, GROUP_SECURITY_INFORMATION) &&
               ppsidGroup != NULL)
            {
                *ppsidGroup = RtlpGroupAddrSecurityDescriptor(pSD);
            }

            if(FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION) &&
               ppDacl != NULL)
            {
                *ppDacl = RtlpDaclAddrSecurityDescriptor(pSD);
            }

            if(FLAG_ON(SecurityInfo, SACL_SECURITY_INFORMATION) &&
               ppSacl != NULL)
            {
                *ppSacl = RtlpSaclAddrSecurityDescriptor(pSD);
            }
        }

        LocalFree(pAccess);
        LocalFree(pAudit);
        LocalFree(pwszOwner);
        LocalFree(pwszGroup);
    }

    return(dwErr);
}


#endif

//+---------------------------------------------------------------------------
//
//  Function:   GetNamedSecurityInfoA
//
//  Synopsis:   Same as above, except ANSI
//
//  Arguments:  [IN  pObjectName]   --  Object for which the permissions are
//                                      needed
//              [IN  ObjectType]    --  Type of object specified by lpObject
//              [IN  SecurityInfo]  --  What is to be returned
//              [OUT ppsidOwner]    --  Where the owners, if requested, is
//                                      returned.
//              [OUT ppsidGroup]    --  Where the groups, if requested, is
//                                      returned.
//              [OUT ppDacl]        --  Where the DACL, if requested, is
//                                      returned.
//              [OUT ppSacl]        --  Where the SACL, if requested, is
//                                      returned.
//              [OUT ppSecurityDescriptor]  Where the security descriptor is
//                                      returned
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD
WINAPI
GetNamedSecurityInfoA(IN  LPSTR                  pObjectName,
                      IN  SE_OBJECT_TYPE         ObjectType,
                      IN  SECURITY_INFORMATION   SecurityInfo,
                      OUT PSID                  *ppsidOwner,
                      OUT PSID                  *ppsidGroup,
                      OUT PACL                  *ppDacl,
                      OUT PACL                  *ppSacl,
                      OUT PSECURITY_DESCRIPTOR  *ppSecurityDescriptor)
{
    //
    // Do the conversion, and pass it on...
    //
    PWSTR   pwszObject;

    DWORD  dwErr = ConvertStringAToStringW(pObjectName,
                                           &pwszObject);

    if(dwErr == ERROR_SUCCESS)
    {

        dwErr = GetNamedSecurityInfoW(pwszObject,
                                      ObjectType,
                                      SecurityInfo,
                                      ppsidOwner,
                                      ppsidGroup,
                                      ppDacl,
                                      ppSacl,
                                      ppSecurityDescriptor);
        LocalFree(pwszObject);
    }
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   GetSecurityInfoW
//
//  Synopsis:   Gets the specified security information from the indicated
//              object
//
//  Arguments:  [IN  handle]        --  Handle to the open object on which
//                                      to get the security info
//              [IN  ObjectType]    --  Type of object specified by lpObject
//              [IN  SecurityInfo]  --  What is to be returned
//              [OUT ppsidOwner]    --  Where the owners, if requested, is
//                                      returned.
//              [OUT ppsidGroup]    --  Where the groups, if requested, is
//                                      returned.
//              [OUT ppDacl]        --  Where the DACL, if requested, is
//                                      returned.
//              [OUT ppSacl]        --  Where the SACL, if requested, is
//                                      returned.
//              [OUT ppSecurityDescriptor]  Where the security descriptor is
//                                      returned
//
//  Returns:    ERROR_SUCCESS       --  Success
//
//----------------------------------------------------------------------------
#ifdef NEW_MARTA_API
DWORD
WINAPI
GetSecurityInfo(IN  HANDLE                 handle,
                IN  SE_OBJECT_TYPE         ObjectType,
                IN  SECURITY_INFORMATION   SecurityInfo,
                OUT PSID                  *ppsidOwner,
                OUT PSID                  *ppsidGroup,
                OUT PACL                  *ppDacl,
                OUT PACL                  *ppSacl,
                OUT PSECURITY_DESCRIPTOR  *ppSecurityDescriptor)
{

    DWORD   dwErr = ERROR_SUCCESS;

    if (NULL == handle)
    {
        return ERROR_INVALID_HANDLE;
    }

    dwErr = GetErrorChecks(
                ObjectType,
                SecurityInfo,
                ppsidOwner,
                ppsidGroup,
                ppDacl,
                ppSacl,
                ppSecurityDescriptor
                );

    CONDITIONAL_EXIT(dwErr, End)

    LOAD_MARTA(dwErr);

    CONDITIONAL_EXIT(dwErr, End)

    dwErr = (*(gNtMartaInfo.pfrGetHandleRights))(
                   handle,
                   ObjectType,
                   SecurityInfo,
                   ppsidOwner,
                   ppsidGroup,
                   ppDacl,
                   ppSacl,
                   ppSecurityDescriptor
                   );

End:
    return(dwErr);
}

#else

DWORD
WINAPI
GetSecurityInfo(IN  HANDLE                 handle,
                IN  SE_OBJECT_TYPE         ObjectType,
                IN  SECURITY_INFORMATION   SecurityInfo,
                OUT PSID                  *ppsidOwner,
                OUT PSID                  *ppsidGroup,
                OUT PACL                  *ppDacl,
                OUT PACL                  *ppSacl,
                OUT PSECURITY_DESCRIPTOR  *ppSecurityDescriptor)
{
    DWORD   dwErr = ERROR_SUCCESS;

    LOAD_MARTA(dwErr);

    //
    // We'll do this the easy way...
    //
    PACTRL_ACCESSW  pAccess = NULL, pAudit = NULL;
    PWSTR           pwszOwner = NULL, pwszGroup = NULL;

    dwErr = GetSecurityInfoExW(handle,
                               ObjectType,
                               SecurityInfo,
                               NULL,
                               NULL,
                               FLAG_ON(SecurityInfo,
                                       DACL_SECURITY_INFORMATION) ?
                                                             &pAccess :
                                                             NULL,
                               FLAG_ON(SecurityInfo,
                                       SACL_SECURITY_INFORMATION) ?
                                                             &pAudit :
                                                             NULL,
                               FLAG_ON(SecurityInfo,
                                       OWNER_SECURITY_INFORMATION) ?
                                                             &pwszOwner :
                                                             NULL,
                               FLAG_ON(SecurityInfo,
                                       GROUP_SECURITY_INFORMATION) ?
                                                             &pwszGroup :
                                                             NULL);
    if(dwErr == ERROR_SUCCESS)
    {
        //
        // Now, convert it back into a SecurityDescriptor, so we
        // can rip it apart and return the right information
        //
        dwErr = (*gNtMartaInfo.pfAToSD)(pAccess,
                                        pAudit,
                                        pwszOwner,
                                        pwszGroup,
                                        ppSecurityDescriptor);
        if(dwErr == ERROR_SUCCESS)
        {
            SECURITY_DESCRIPTOR *pSD =
                                (SECURITY_DESCRIPTOR *)*ppSecurityDescriptor;

            if(FLAG_ON(SecurityInfo, OWNER_SECURITY_INFORMATION) &&
               ppsidOwner != NULL)
            {
                *ppsidOwner = RtlpOwnerAddrSecurityDescriptor(pSD);
            }

            if(FLAG_ON(SecurityInfo, GROUP_SECURITY_INFORMATION) &&
               ppsidGroup != NULL)
            {
                *ppsidGroup = RtlpGroupAddrSecurityDescriptor(pSD);
            }

            if(FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION) &&
               ppDacl != NULL)
            {
                *ppDacl = RtlpDaclAddrSecurityDescriptor(pSD);
            }

            if(FLAG_ON(SecurityInfo, SACL_SECURITY_INFORMATION) &&
               ppSacl != NULL)
            {
                *ppSacl = RtlpSaclAddrSecurityDescriptor(pSD);
            }
        }

        LocalFree(pAccess);
        LocalFree(pAudit);
        LocalFree(pwszOwner);
        LocalFree(pwszGroup);

    }
    return(dwErr);
}
#endif




//+---------------------------------------------------------------------------
//
//  Function:   SetNamedSecurityInfoW
//
//  Synopsis:   Sets the specified security information from the indicated
//              object
//
//  Arguments:  [IN  pObjectName]   --  Object on which to set the security
//              [IN  ObjectType]    --  Type of object specified by lpObject
//              [IN  SecurityInfo]  --  What is to be returned
//              [OUT psidOwner]     --  Owner to set
//              [OUT psidGroup]     --  Group to set
//              [OUT pDacl]         --  Dacl to set
//              [OUT pSacl]         --  Sacl to set
//
//  Returns:    ERROR_SUCCESS       --  Success
//
//----------------------------------------------------------------------------
#ifdef NEW_MARTA_API
DWORD
WINAPI
SetNamedSecurityInfoW(IN LPWSTR                pObjectName,
                      IN SE_OBJECT_TYPE        ObjectType,
                      IN SECURITY_INFORMATION  SecurityInfo,
                      IN PSID                  psidOwner,
                      IN PSID                  psidGroup,
                      IN PACL                  pDacl,
                      IN PACL                  pSacl)
{
    DWORD dwErr;
    SECURITY_DESCRIPTOR SD;

    if (NULL == pObjectName)
    {
        return ERROR_INVALID_PARAMETER;
    }

    dwErr = SetErrorChecks(
                ObjectType,
                SecurityInfo,
                psidOwner,
                psidGroup,
                pDacl,
                pSacl,
                &SD
                );

    CONDITIONAL_EXIT(dwErr, End);

    LOAD_MARTA(dwErr);

    CONDITIONAL_EXIT(dwErr, End);

    dwErr = (*(gNtMartaInfo.pfrSetNamedRights))(
                pObjectName,
                ObjectType,
                SecurityInfo,
                &SD,
                FALSE // Do not skip inherited ace computation
                );

End:
    return dwErr;

}

#else

DWORD
WINAPI
SetNamedSecurityInfoW(IN LPWSTR                pObjectName,
                      IN SE_OBJECT_TYPE        ObjectType,
                      IN SECURITY_INFORMATION  SecurityInfo,
                      IN PSID                  psidOwner,
                      IN PSID                  psidGroup,
                      IN PACL                  pDacl,
                      IN PACL                  pSacl)
{
    DWORD   dwErr = ERROR_SUCCESS;
    BOOLEAN Dacl = FALSE, Sacl = FALSE, Owner = FALSE, Group = FALSE;

    LOAD_MARTA(dwErr);

    //
    // Here, we'll first create a security descriptor, convert that into
    // access lists, and pass it on.
    //
    SECURITY_DESCRIPTOR SD;
    InitializeSecurityDescriptor(&SD, SECURITY_DESCRIPTOR_REVISION);

    //
    // Set the owner, group, DAcl and SAcl in the SD
    //
    if(FLAG_ON(SecurityInfo, OWNER_SECURITY_INFORMATION))
    {
        if(SetSecurityDescriptorOwner(&SD, psidOwner, FALSE) == FALSE)
        {
            dwErr = GetLastError();
        }
        else
        {
            if(psidOwner != NULL)
            {
                Owner = TRUE;
            }
        }


    }

    if(dwErr == ERROR_SUCCESS &&
                        FLAG_ON(SecurityInfo, GROUP_SECURITY_INFORMATION))
    {
        if(SetSecurityDescriptorGroup(&SD, psidGroup, FALSE) == FALSE)
        {
            dwErr = GetLastError();
        }
        else
        {
            if(psidGroup != NULL)
            {
                Group = TRUE;
            }
        }
    }


    if(dwErr == ERROR_SUCCESS &&
                        FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION))
    {
        if(SetSecurityDescriptorDacl(&SD, TRUE, pDacl, FALSE) == FALSE)
        {
            dwErr = GetLastError();
        }
        else
        {
            if(pDacl != NULL)
            {
                Dacl = TRUE;
            }

            if(FLAG_ON(SecurityInfo, PROTECTED_DACL_SECURITY_INFORMATION))
            {
                SetSecurityDescriptorControl( &SD, SE_DACL_PROTECTED, SE_DACL_PROTECTED );
            }
        }
    }

    if(dwErr == ERROR_SUCCESS &&
                        FLAG_ON(SecurityInfo, SACL_SECURITY_INFORMATION))
    {
        if(SetSecurityDescriptorSacl(&SD, TRUE, pSacl, FALSE) == FALSE)
        {
            dwErr = GetLastError();
        }
        else
        {
            if(pSacl != NULL)
            {
                Sacl = TRUE;
            }

            if(FLAG_ON(SecurityInfo, PROTECTED_SACL_SECURITY_INFORMATION))
            {
                SetSecurityDescriptorControl( &SD, SE_SACL_PROTECTED, SE_SACL_PROTECTED );
            }
        }
    }

    //
    // Now, if that worked, we'll convert it to our access format, and pass
    // it on.
    //
    if(dwErr == ERROR_SUCCESS)
    {
        PACTRL_ACCESSW  pAccess = NULL, pAudit = NULL;
        PWSTR           pwszOwner = NULL, pwszGroup = NULL;

        dwErr = (*gNtMartaInfo.pfSDToA)(ObjectType,
                                        &SD,
                                        Dacl == FALSE ?
                                                  NULL  :
                                                  &pAccess,
                                        Sacl == FALSE ?
                                                  NULL  :
                                                  &pAudit,
                                        Owner == FALSE ?
                                                  NULL  :
                                                  &pwszOwner,
                                        Group == FALSE ?
                                                  NULL  :
                                                  &pwszGroup);
        if(dwErr == ERROR_SUCCESS)
        {
            //
            // Now that we have our access lists, pass them on to
            // the other APIs
            //
            dwErr = SetNamedSecurityInfoExW(pObjectName,
                                            ObjectType,
                                            SecurityInfo,
                                            NULL,
                                            pAccess,
                                            pAudit,
                                            pwszOwner,
                                            pwszGroup,
                                            NULL);
            LocalFree(pAccess);
            LocalFree(pAudit);
            LocalFree(pwszOwner);
            LocalFree(pwszGroup);
        }
    }

    return(dwErr);
}

#endif


//+---------------------------------------------------------------------------
//
//  Function:   SetNamedSecurityInfoA
//
//  Synopsis:   Same as above, except ANSI
//
//  Arguments:  [IN  pObjectName]   --  Object on which to set the security
//              [IN  ObjectType]    --  Type of object specified by lpObject
//              [IN  SecurityInfo]  --  What is to be returned
//              [OUT psidOwner]     --  Owner to set
//              [OUT psidGroup]     --  Group to set
//              [OUT pDacl]         --  Dacl to set
//              [OUT pSacl]         --  Sacl to set
//
//  Returns:    ERROR_SUCCESS       --  Success
//
//----------------------------------------------------------------------------
DWORD
WINAPI
SetNamedSecurityInfoA(IN LPSTR                 pObjectName,
                      IN SE_OBJECT_TYPE        ObjectType,
                      IN SECURITY_INFORMATION  SecurityInfo,
                      IN PSID                  psidOwner,
                      IN PSID                  psidGroup,
                      IN PACL                  pDacl,
                      IN PACL                  pSacl)
{
    //
    // Do the conversion, and pass it on...
    //
    PWSTR   pwszObject;

    DWORD   dwErr = ConvertStringAToStringW(pObjectName,
                                            &pwszObject);

    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = SetNamedSecurityInfoW(pwszObject,
                                      ObjectType,
                                      SecurityInfo,
                                      psidOwner,
                                      psidGroup,
                                      pDacl,
                                      pSacl);
        LocalFree(pwszObject);
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   SetSecurityInfo
//
//  Synopsis:   Sets the specified security information from the indicated
//              object
//
//  Arguments:  [IN  handle]        --  Handle to the open object on which
//                                      to set the security
//              [IN  ObjectType]    --  Type of object specified by lpObject
//              [IN  SecurityInfo]  --  What is to be returned
//              [OUT psidOwner]     --  Owner to set
//              [OUT psidGroup]     --  Group to set
//              [OUT pDacl]         --  Dacl to set
//              [OUT pSacl]         --  Sacl to set
//
//  Returns:    ERROR_SUCCESS       --  Success
//
//----------------------------------------------------------------------------
#ifdef NEW_MARTA_API
DWORD
WINAPI
SetSecurityInfo(IN HANDLE                handle,
                IN SE_OBJECT_TYPE        ObjectType,
                IN SECURITY_INFORMATION  SecurityInfo,
                IN PSID                  psidOwner,
                IN PSID                  psidGroup,
                IN PACL                  pDacl,
                IN PACL                  pSacl)
{
    DWORD dwErr;
    SECURITY_DESCRIPTOR SD;

    if (NULL == handle)
    {
        return ERROR_INVALID_HANDLE;
    }

    dwErr = SetErrorChecks(
                ObjectType,
                SecurityInfo,
                psidOwner,
                psidGroup,
                pDacl,
                pSacl,
                &SD
                );

    CONDITIONAL_EXIT(dwErr, End);

    LOAD_MARTA(dwErr);

    CONDITIONAL_EXIT(dwErr, End);

    dwErr = (*(gNtMartaInfo.pfrSetHandleRights))(
                handle,
                ObjectType,
                SecurityInfo,
                &SD
                );

End:
    return dwErr;

}

#else

DWORD
WINAPI
SetSecurityInfo(IN HANDLE                handle,
                IN SE_OBJECT_TYPE        ObjectType,
                IN SECURITY_INFORMATION  SecurityInfo,
                IN PSID                  psidOwner,
                IN PSID                  psidGroup,
                IN PACL                  pDacl,
                IN PACL                  pSacl)
{
    DWORD   dwErr = ERROR_SUCCESS;
    BOOLEAN Dacl = FALSE, Sacl = FALSE, Owner = FALSE, Group = FALSE;

    LOAD_MARTA(dwErr);

    //
    // Same as before: Create the SecurityDescriptor, convert it to an
    // access list, and pass it on to the Ex APIs
    //
    SECURITY_DESCRIPTOR SD;
    InitializeSecurityDescriptor(&SD, SECURITY_DESCRIPTOR_REVISION);

    //
    // Set the owner, group, DAcl and SAcl in the SD
    //
    if(FLAG_ON(SecurityInfo, OWNER_SECURITY_INFORMATION))
    {
        if(SetSecurityDescriptorOwner(&SD, psidOwner, FALSE) == FALSE)
        {
            dwErr = GetLastError();
        }
        else
        {
            if(psidOwner != NULL)
            {
                Owner = TRUE;
            }
        }
    }

    if(dwErr == ERROR_SUCCESS &&
                        FLAG_ON(SecurityInfo, GROUP_SECURITY_INFORMATION))
    {
        if(SetSecurityDescriptorGroup(&SD, psidGroup, FALSE) == FALSE)
        {
            dwErr = GetLastError();
        }
        else
        {
            if(psidGroup != NULL)
            {
                Group = TRUE;
            }
        }
    }


    if(dwErr == ERROR_SUCCESS &&
                        FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION))
    {
        if(SetSecurityDescriptorDacl(&SD, TRUE, pDacl, FALSE) == FALSE)
        {
            dwErr = GetLastError();
        }
        else
        {
            if(pDacl != NULL)
            {
                Dacl = TRUE;
            }
        }
    }

    if(dwErr == ERROR_SUCCESS &&
                        FLAG_ON(SecurityInfo, SACL_SECURITY_INFORMATION))
    {
        if(SetSecurityDescriptorSacl(&SD, TRUE, pSacl, FALSE) == FALSE)
        {
            dwErr = GetLastError();
        }
        else
        {
            if(pSacl != NULL)
            {
                Sacl = TRUE;
            }
        }
    }

    //
    // Now, if that worked, we'll convert it our access format, and pass
    // it on.
    //
    if(dwErr == ERROR_SUCCESS)
    {
        PACTRL_ACCESSW  pAccess = NULL, pAudit = NULL;
        PWSTR           pwszOwner = NULL, pwszGroup = NULL;

        dwErr = (*gNtMartaInfo.pfSDToA)(ObjectType,
                                        &SD,
                                        Dacl == FALSE ?
                                                  NULL  :
                                                  &pAccess,
                                        Sacl == FALSE ?
                                                  NULL  :
                                                  &pAudit,
                                        Owner == FALSE ?
                                                  NULL  :
                                                  &pwszOwner,
                                        Group == FALSE ?
                                                  NULL  :
                                                  &pwszGroup);
        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = SetSecurityInfoExW(handle,
                                       ObjectType,
                                       SecurityInfo,
                                       NULL,
                                       pAccess,
                                       pAudit,
                                       pwszOwner,
                                       pwszGroup,
                                       NULL);
            LocalFree(pAccess);
            LocalFree(pAudit);
            LocalFree(pwszOwner);
            LocalFree(pwszGroup);
        }
    }

    return(dwErr);
}
#endif




//+---------------------------------------------------------------------------
//
//  Function:   SetEntriesInAclW
//
//  Synopsis:   Adds the specified entries into the existing (if present)
//              ACL, returning the results
//
//  Arguments:  [IN  cCountOfExplicitEntries]   Number of items in list
//              [IN  pListOfExplicitEntries]    List of entries to be added
//              [IN  OldAcl]        --  OPTIONAL.  If present, the above
//                                      entries are merged with the this ACL
//              [OUT pNewAcl]       --  Where the new acl is returned
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//
//----------------------------------------------------------------------------
#ifdef NEW_MARTA_API

DWORD
WINAPI
SetEntriesInAclW(IN  ULONG               cCountOfExplicitEntries,
                 IN  PEXPLICIT_ACCESS_W  pListOfExplicitEntries,
                 IN  PACL                OldAcl,
                 OUT PACL               *pNewAcl)
{
    DWORD   dwErr = ERROR_SUCCESS;

    LOAD_MARTA(dwErr);

    return (*(gNtMartaInfo.pfrSetEntriesInAcl))(
                   cCountOfExplicitEntries,
                   pListOfExplicitEntries,
                   OldAcl,
                   pNewAcl
                   );
}

#else
DWORD
WINAPI
SetEntriesInAclW(IN  ULONG               cCountOfExplicitEntries,
                 IN  PEXPLICIT_ACCESS_W  pListOfExplicitEntries,
                 IN  PACL                OldAcl,
                 OUT PACL               *pNewAcl)
{
    DWORD           dwErr = ERROR_SUCCESS;
    PACCESS_ENTRY   pAEntries = NULL;

    LOAD_MARTA(dwErr);

    CAcl CA(NULL,
            ACCESS_TO_UNKNOWN,
            FALSE,
            FALSE);

    //
    // Set the old ACL
    //
    dwErr = CA.SetAcl(OldAcl);


    if(dwErr == ERROR_SUCCESS && cCountOfExplicitEntries > 0)
    {
        dwErr = Win32ExplicitAccessToAccessEntry(cCountOfExplicitEntries,
                                                 pListOfExplicitEntries,
                                                 &pAEntries);
        if(dwErr == ERROR_SUCCESS)
        {
            //
            // Add the requested access entries
            //
            dwErr = CA.AddAccessEntries(cCountOfExplicitEntries,
                                        pAEntries);
        }
    }

    if(dwErr == ERROR_SUCCESS)
    {
        //
        // Build the new ACL and merge in the access entries if necessary
        //
        dwErr = CA.BuildAcl(pNewAcl);
    }

    if(pAEntries)
    {
        LocalFree(pAEntries);
    }

    return(dwErr);
}
#endif




//+---------------------------------------------------------------------------
//
//  Function:   SetEntriesInAclA
//
//  Synopsis:   Same as above, execpt ANSI
//
//  Arguments:  [IN  cCountOfExplicitEntries]   Number of items in list
//              [IN  pListOfExplicitEntries]    List of entries to be added
//              [IN  OldAcl]        --  OPTIONAL.  If present, the above
//                                      entries are merged with the this ACL
//              [OUT pNewAcl]       --  Where the new acl is returned
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//
//----------------------------------------------------------------------------

#ifdef NEW_MARTA_API

typedef struct _MARTA_TMP_STRINGS
{
    LPSTR Name;
    LPSTR ObjectTypeName;
    LPSTR InheritedObjectTypeName;
} MARTA_TMP_STRINGS, *PMARTA_TMP_STRINGS;

DWORD
WINAPI
SetEntriesInAclA(IN  ULONG               cCountOfExplicitEntries,
                 IN  PEXPLICIT_ACCESS_A  pListOfExplicitEntries,
                 IN  PACL                OldAcl,
                 OUT PACL              *pNewAcl)
{
    DWORD   dwErr = ERROR_SUCCESS;
    PMARTA_TMP_STRINGS Tmp = NULL;
    LPWSTR UnicodeString;
    POBJECTS_AND_NAME_A pObjName = NULL;
    ULONG i;

    if (0 != cCountOfExplicitEntries)
    {
        Tmp = (PMARTA_TMP_STRINGS) AccAlloc(sizeof(MARTA_TMP_STRINGS) * cCountOfExplicitEntries);

        if (NULL == Tmp)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        for (i = 0; i < cCountOfExplicitEntries; i++)
        {
            Tmp[i].Name = NULL;
            Tmp[i].ObjectTypeName = NULL;
            Tmp[i].InheritedObjectTypeName = NULL;

            switch (pListOfExplicitEntries[i].Trustee.TrusteeForm)
            {
            case TRUSTEE_IS_NAME:

                dwErr = ConvertStringAToStringW(
                            pListOfExplicitEntries[i].Trustee.ptstrName,
                            &UnicodeString
                            );

                if (ERROR_SUCCESS != dwErr)
                {
                    goto End;
                }

                Tmp[i].Name = pListOfExplicitEntries[i].Trustee.ptstrName;
                pListOfExplicitEntries[i].Trustee.ptstrName = (LPSTR) UnicodeString;

                break;

            case TRUSTEE_IS_OBJECTS_AND_NAME:

                pObjName = (POBJECTS_AND_NAME_A) pListOfExplicitEntries[i].Trustee.ptstrName;

                dwErr = ConvertStringAToStringW(
                            pObjName->ptstrName,
                            &UnicodeString
                            );

                if (ERROR_SUCCESS != dwErr)
                {
                    goto End;
                }

                Tmp[i].Name = pObjName->ptstrName;
                pObjName->ptstrName = (LPSTR) UnicodeString;

                dwErr = ConvertStringAToStringW(
                            pObjName->ObjectTypeName,
                            &UnicodeString
                            );

                if (ERROR_SUCCESS != dwErr)
                {
                    goto End;
                }

                Tmp[i].ObjectTypeName = pObjName->ObjectTypeName;
                pObjName->ObjectTypeName = (LPSTR) UnicodeString;

                dwErr = ConvertStringAToStringW(
                            pObjName->InheritedObjectTypeName,
                            &UnicodeString
                            );

                if (ERROR_SUCCESS != dwErr)
                {
                    goto End;
                }

                Tmp[i].InheritedObjectTypeName = pObjName->InheritedObjectTypeName;
                pObjName->InheritedObjectTypeName = (LPSTR) UnicodeString;

                break;

            default:
                break;
            }
        }
    }

    dwErr = SetEntriesInAclW(cCountOfExplicitEntries,
                             (PEXPLICIT_ACCESS_W)pListOfExplicitEntries,
                             OldAcl,
                             pNewAcl);

End:

    for (i = 0; i < cCountOfExplicitEntries; i++)
    {
        switch (pListOfExplicitEntries[i].Trustee.TrusteeForm)
        {
        case TRUSTEE_IS_NAME:

            if (NULL != Tmp[i].Name)
            {
                AccFree(pListOfExplicitEntries[i].Trustee.ptstrName);
                pListOfExplicitEntries[i].Trustee.ptstrName = Tmp[i].Name;
            }

            break;

        case TRUSTEE_IS_OBJECTS_AND_NAME:

            pObjName = (POBJECTS_AND_NAME_A) pListOfExplicitEntries[i].Trustee.ptstrName;

            Tmp[i].ObjectTypeName = pObjName->ObjectTypeName;
            Tmp[i].InheritedObjectTypeName = pObjName->InheritedObjectTypeName;
            if (NULL != Tmp[i].Name)
            {
                AccFree(pObjName->ptstrName);
                pObjName->ptstrName = Tmp[i].Name;
            }

            if (NULL != Tmp[i].ObjectTypeName)
            {
                AccFree(pObjName->ObjectTypeName);
                pObjName->ObjectTypeName = Tmp[i].ObjectTypeName;
            }

            if (NULL != Tmp[i].InheritedObjectTypeName)
            {
                AccFree(pObjName->InheritedObjectTypeName);
                pObjName->InheritedObjectTypeName = Tmp[i].ObjectTypeName;
            }

            break;

        default:
            break;
        }
    }

    if (NULL != Tmp)
    {
        AccFree(Tmp);
    }

    return dwErr;
}
#else

DWORD
WINAPI
SetEntriesInAclA(IN  ULONG               cCountOfExplicitEntries,
                 IN  PEXPLICIT_ACCESS_A  pListOfExplicitEntries,
                 IN  PACL                OldAcl,
                 OUT PACL              *pNewAcl)
{
    DWORD   dwErr = ERROR_SUCCESS;
    CSList  ChangedList(CleanupConvertNode);

    dwErr = ConvertExplicitAccessAToW(cCountOfExplicitEntries,
                                      pListOfExplicitEntries,
                                      ChangedList);
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = SetEntriesInAclW(cCountOfExplicitEntries,
                                 (PEXPLICIT_ACCESS_W)pListOfExplicitEntries,
                                 OldAcl,
                                 pNewAcl);
    }

    return(dwErr);
}
#endif


//+---------------------------------------------------------------------------
//
//  Function:   GetEffectiveRightsFromAclW
//
//  Synopsis:   Determines the effective rights of the given trustee from
//              the given acl
//
//  Arguments:  [IN  pacl]          --  The ACL to search
//              [IN  pTrustee]      --  Trustee for whom to get the effective
//                                      rights.
//              [OUT pAccessRights] --  Where the access mask is returned
//
//  Returns:    ERROR_SUCCESS       --  Success
//
//----------------------------------------------------------------------------
DWORD
WINAPI
GetEffectiveRightsFromAclW(IN  PACL          pacl,
                           IN  PTRUSTEE_W    pTrustee,
                           OUT PACCESS_MASK  pAccessRights)
{
    DWORD   dwErr = ERROR_SUCCESS;

    LOAD_MARTA(dwErr);

    //
    // Ok, here we simply make the right call to get the rights for
    // the trustee
    //
    ACCESS_RIGHTS   Allowed, Denied;
    dwErr = (*gNtMartaInfo.pfGetAccess)(pTrustee,
                                        pacl,
                                        DACL_SECURITY_INFORMATION,
                                        NULL,
                                        &Allowed,
                                        &Denied);
    if(dwErr == ERROR_SUCCESS)
    {
        ACCESS_MASK CnvtAllowed, CnvtDenied;
        ConvertAccessRightToAccessMask(Allowed, &CnvtAllowed);
        ConvertAccessRightToAccessMask(Denied,  &CnvtDenied);

        *pAccessRights = CnvtAllowed & ~CnvtDenied;
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   GetEffectiveRightsFromAclA
//
//  Synopsis:   Same as above, except ANSI
//
//  Arguments:  [IN  pacl]          --  The ACL to search
//              [IN  pTrustee]      --  Trustee for whom to get the effective
//                                      rights.
//              [OUT pAccessRights] --  Where the access mask is returned
//
//  Returns:    ERROR_SUCCESS       --  Success
//
//----------------------------------------------------------------------------
DWORD
WINAPI
GetEffectiveRightsFromAclA(IN  PACL          pacl,
                           IN  PTRUSTEE_A    pTrustee,
                           OUT PACCESS_MASK  pAccessRights)
{
    //
    // Convert the trustee to WIDE, and pass it on up
    //
    DWORD dwErr = ERROR_SUCCESS;
    TRUSTEE_W   TrusteeW;
    LOAD_MARTA(dwErr);

    dwErr = ConvertTrusteeAToTrusteeW(pTrustee,
                                      &TrusteeW,
                                      TRUE);
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = GetEffectiveRightsFromAclW(pacl,
                                           &TrusteeW,
                                           pAccessRights);
        LocalFree(TrusteeW.ptstrName);
    }

    return(dwErr);
}


#if 0
#include "geefa_rewrite.cxx"
#endif


//+---------------------------------------------------------------------------
//
//  Function:   GetExplicitEntriesFromAclW
//
//  Synopsis:   "Converts" the given ACL into a list of EXPLICIT_ACCESS
//              entries
//
//  Arguments:  [IN  pacl]          --  The ACL to "convert"
//              [IN  pcCountOfExplicitEntries]  Where to return the number of
//                                      items in the list
//              [OUT pListOfExplicitEntries]    Where to return the list
//
//  Returns:    ERROR_SUCCESS       --  Success
//
//----------------------------------------------------------------------------
#ifdef NEW_MARTA_API
DWORD
WINAPI
GetExplicitEntriesFromAclW(IN  PACL                 pacl,
                           OUT PULONG               pcCountOfExplicitEntries,
                           OUT PEXPLICIT_ACCESS_W  *pListOfExplicitEntries)
{
    DWORD   dwErr = ERROR_SUCCESS;


#if 0
    return AccRewriteGetExplicitEntriesFromAcl(
              pacl,
              pcCountOfExplicitEntries,
              pListOfExplicitEntries
              );
#else

    LOAD_MARTA(dwErr);
    return (*gNtMartaInfo.pfrGetExplicitEntriesFromAcl)(
                 pacl,
                 pcCountOfExplicitEntries,
                 pListOfExplicitEntries
                 );
#endif
}
#else
DWORD
WINAPI
GetExplicitEntriesFromAclW(IN  PACL                 pacl,
                           OUT PULONG               pcCountOfExplicitEntries,
                           OUT PEXPLICIT_ACCESS_W  *pListOfExplicitEntries)
{
    DWORD   dwErr = ERROR_SUCCESS;
    LOAD_MARTA(dwErr);

    //
    // Convert the acl into an access list, and then do the conversion
    // on that...
    //
    PACTRL_ACCESSW  pAccess;
    dwErr = (*gNtMartaInfo.pfAclToA)(SE_UNKNOWN_OBJECT_TYPE,
                                     pacl,
                                     &pAccess);
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = ConvertAccessWToExplicitW(pAccess,
                                          pcCountOfExplicitEntries,
                                          pListOfExplicitEntries);
        LocalFree(pAccess);
    }

    return(dwErr);
}
#endif




//+---------------------------------------------------------------------------
//
//  Function:   GetExplicitEntriesFromAclA
//
//  Synopsis:   Same as above, except ANSI
//
//  Arguments:  [IN  pacl]          --  The ACL to "convert"
//              [IN  pcCountOfExplicitEntries]  Where to return the number of
//                                      items in the list
//              [OUT pListOfExplicitEntries]    Where to return the list
//
//  Returns:    ERROR_SUCCESS       --  Success
//
//----------------------------------------------------------------------------
#ifdef NEW_MARTA_API
DWORD
WINAPI
GetExplicitEntriesFromAclA(IN  PACL                  pacl,
                           OUT PULONG                pcCountOfExplicitEntries,
                           OUT PEXPLICIT_ACCESS_A  * pListOfExplicitEntries)
{

    return GetExplicitEntriesFromAclW(
               pacl,
               pcCountOfExplicitEntries,
               (PEXPLICIT_ACCESS_W *) pListOfExplicitEntries
               );
}
#else
DWORD
WINAPI
GetExplicitEntriesFromAclA(IN  PACL                  pacl,
                           OUT PULONG                pcCountOfExplicitEntries,
                           OUT PEXPLICIT_ACCESS_A  * pListOfExplicitEntries)
{
    DWORD   dwErr = ERROR_SUCCESS;
    LOAD_MARTA(dwErr);

    //
    // Do the same conversion as above
    //
    PACTRL_ACCESSW  pAccess;
    dwErr = (*gNtMartaInfo.pfAclToA)(SE_UNKNOWN_OBJECT_TYPE,
                                     pacl,
                                     &pAccess);

    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = ConvertAccessWToExplicitA(pAccess,
                                          pcCountOfExplicitEntries,
                                          pListOfExplicitEntries);
        LocalFree(pAccess);
    }


    return(dwErr);
}
#endif



//+---------------------------------------------------------------------------
//
//  Function:   GetAuditedPermissionsFromAclW
//
//  Synopsis:   Determines the auditing rights for the given trustee
//
//  Arguments:  [IN  pacl]          --  The ACL to examine
//              [IN  pTrustee]      --  The trustee to check for
//              [OUT pSuccessfulAuditedRights]  Where the successful audit
//                                      mask is returned
//              [OUT pFailedAuditedRights]      Where the failed audit
//                                      mask is returned
//
//  Returns:    ERROR_SUCCESS       --  Success
//
//----------------------------------------------------------------------------
DWORD
WINAPI
GetAuditedPermissionsFromAclW(IN  PACL          pacl,
                              IN  PTRUSTEE_W    pTrustee,
                              OUT PACCESS_MASK  pSuccessfulAuditedRights,
                              OUT PACCESS_MASK  pFailedAuditRights)
{
    DWORD   dwErr = ERROR_SUCCESS;
    LOAD_MARTA(dwErr);

    //
    // Ok, here we simply make the right call into the NTMARTA dll
    //
    ACCESS_RIGHTS   Allowed, Denied;
    dwErr = (*gNtMartaInfo.pfGetAccess)(pTrustee,
                                        pacl,
                                        SACL_SECURITY_INFORMATION,
                                        NULL,
                                        &Allowed,
                                        &Denied);
    if(dwErr == ERROR_SUCCESS)
    {
        ConvertAccessRightToAccessMask(Allowed, pSuccessfulAuditedRights);
        ConvertAccessRightToAccessMask(Denied,  pFailedAuditRights);
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   GetAuditedPermissionsFromAclA
//
//  Synopsis:   Same as above, except ANSI
//
//  Arguments:  [IN  pacl]          --  The ACL to examine
//              [IN  pTrustee]      --  The trustee to check for
//              [OUT pSuccessfulAuditedRights]  Where the successful audit
//                                      mask is returned
//              [OUT pFailedAuditedRights]      Where the failed audit
//                                      mask is returned
//
//  Returns:    ERROR_SUCCESS       --  Success
//
//----------------------------------------------------------------------------
DWORD
WINAPI
GetAuditedPermissionsFromAclA(IN  PACL          pAcl,
                              IN  PTRUSTEE_A    pTrustee,
                              OUT PACCESS_MASK  pSuccessfulAuditedRights,
                              OUT PACCESS_MASK  pFailedAuditRights)
{
    //
    // Convert the trustee to WIDE, and pass it on up
    //
    TRUSTEE_W   TrusteeW;

    DWORD  dwErr = ConvertTrusteeAToTrusteeW(pTrustee,
                                             &TrusteeW,
                                             TRUE);
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = GetAuditedPermissionsFromAclW(pAcl,
                                              &TrusteeW,
                                              pSuccessfulAuditedRights,
                                              pFailedAuditRights);
        LocalFree(TrusteeW.ptstrName);
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   BuildSecurityDescriptorW
//
//  Synopsis:   Builds a security descriptor from the various explicit access
//              and trustee information.  The returned security descriptor
//              is self relative.
//
//  Arguments:  [IN  pOwner]        --  Items new owner
//              [IN  pGroup]        --  Items new group
//              [IN  cCountOfAccessEntries] Number of items in access list
//              [IN  pListOfAccessEntries]  Actual access list
//              [IN  cCountOfAuditEntries]  Number of items in audit list
//              [IN  pListOfAuditEntries]   Actual audit list
//              [IN  pOldSD]        --  OPTIONAL.  Existing security
//                                      descriptor to merge with.  MUST BE
//                                      SELF RELATIVE
//              [OUT pSizeNewSD]    --  New SecDesc. size is returned here
//              [OUT pNewSD]        --  New SecDesc is returned here
//
//
//  Returns:    ERROR_SUCCESS       --  Success
//
//----------------------------------------------------------------------------
DWORD
WINAPI
BuildSecurityDescriptorW(IN  PTRUSTEE_W              pOwner,
                         IN  PTRUSTEE_W              pGroup,
                         IN  ULONG                   cCountOfAccessEntries,
                         IN  PEXPLICIT_ACCESS_W      pListOfAccessEntries,
                         IN  ULONG                   cCountOfAuditEntries,
                         IN  PEXPLICIT_ACCESS_W      pListOfAuditEntries,
                         IN  PSECURITY_DESCRIPTOR    pOldSD,
                         OUT PULONG                  pSizeNewSD,
                         OUT PSECURITY_DESCRIPTOR   *pNewSD)
{
    DWORD               dwErr;
    SECURITY_DESCRIPTOR SD;
    PACL                pDAcl = NULL, pSAcl = NULL;
    PACL                pNewDAcl = NULL, pNewSAcl = NULL;
    BOOL                fFreeDAcl = FALSE, fFreeSAcl = FALSE;
    PSID                pOwnerSid = NULL, pGroupSid = NULL;
    BOOL                fFreeOwner = FALSE, fFreeGroup = FALSE;

    LOAD_PROVIDERS(dwErr);

    if ( dwErr != ERROR_SUCCESS )
    {
        return( dwErr );
    }

    InitializeSecurityDescriptor(&SD, SECURITY_DESCRIPTOR_REVISION);

    //
    // input SD must be self relative
    //
    if(pOldSD != NULL)
    {
        SECURITY_DESCRIPTOR  *pIOldSd = (PISECURITY_DESCRIPTOR)pOldSD;

        if(!FLAG_ON(pIOldSd->Control,SE_SELF_RELATIVE))
        {
            dwErr = ERROR_INVALID_SECURITY_DESCR;
            goto errorexit;
        }

        //
        // get the owner, group, dacl and sacl from the input sd
        //
        if(pIOldSd->Owner)
        {
            pOwnerSid = RtlpOwnerAddrSecurityDescriptor( pIOldSd );
        }

        if(pIOldSd->Group)
        {
            pGroupSid = RtlpGroupAddrSecurityDescriptor( pIOldSd );
        }

        if(pIOldSd->Dacl)
        {
            pDAcl = RtlpDaclAddrSecurityDescriptor( pIOldSd );
        }

        if(pIOldSd->Sacl)
        {
            pSAcl = RtlpSaclAddrSecurityDescriptor( pIOldSd );
        }
    }

    //
    // if there is an input owner, override the one from the old SD
    //
    if(pOwner != NULL)
    {
        SID_NAME_USE    SNE;
        dwErr = (*gNtMartaInfo.pfSid)(NULL,
                                      pOwner,
                                      &pOwnerSid,
                                      &SNE);
        if (dwErr != ERROR_SUCCESS)
        {
            goto errorexit;
        }

        fFreeOwner = TRUE;
    }

    //
    // then the group
    //
    if (pGroup != NULL)
    {
        SID_NAME_USE    SNE;
        dwErr = (*gNtMartaInfo.pfSid)(NULL,
                                      pGroup,
                                      &pGroupSid,
                                      &SNE);
        if (dwErr != ERROR_SUCCESS)
        {
            goto errorexit;
        }

        fFreeGroup = TRUE;
    }

    //
    // then the dacl
    //
    if(cCountOfAccessEntries != 0)
    {
        dwErr = SetEntriesInAcl(cCountOfAccessEntries,
                                pListOfAccessEntries,
                                pDAcl,
                                &pNewDAcl);

        if(dwErr != ERROR_SUCCESS)
        {
            goto errorexit;
        }
        fFreeDAcl = TRUE;
    }
    else
    {
        pNewDAcl = pDAcl;
    }

    //
    // then the sacl
    //
    if(cCountOfAuditEntries != 0)
    {
        dwErr = SetEntriesInAcl(cCountOfAuditEntries,
                                pListOfAuditEntries,
                                pSAcl,
                                &pNewSAcl);
        if(dwErr != ERROR_SUCCESS)
        {
            goto errorexit;
        }
        fFreeSAcl = TRUE;
    }
    else
    {
        pNewSAcl = pSAcl;
    }


    //
    // Set the owner, group, dacl and sacl in the SD
    //
    if(SetSecurityDescriptorOwner(&SD, pOwnerSid, FALSE) == FALSE)
    {
        dwErr = GetLastError();
        goto errorexit;
    }

    if(SetSecurityDescriptorGroup(&SD, pGroupSid, FALSE) == FALSE)
    {
        dwErr = GetLastError();
        goto errorexit;
    }

    if(SetSecurityDescriptorDacl(&SD, TRUE, pNewDAcl, FALSE) == FALSE)
    {
        dwErr = GetLastError();
        goto errorexit;
    }

    if(SetSecurityDescriptorSacl(&SD, TRUE, pNewSAcl, FALSE) == FALSE)
    {
        dwErr = GetLastError();
        goto errorexit;
    }

    //
    // now make the final, self relative SD
    //
    *pSizeNewSD = 0;

    if (!MakeSelfRelativeSD(&SD, NULL, pSizeNewSD))
    {
        dwErr = GetLastError();

        if(dwErr == ERROR_INSUFFICIENT_BUFFER)
        {
            *pNewSD = (PISECURITY_DESCRIPTOR)AccAlloc(*pSizeNewSD);

            if(*pNewSD == NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
            }
            else
            {
                if(MakeSelfRelativeSD(&SD, *pNewSD, pSizeNewSD) == FALSE)
                {
                    LocalFree(*pNewSD);
                    dwErr = GetLastError();
                }
                else
                {

                    dwErr = ERROR_SUCCESS;
                }
            }
        }
    }
    else
    {
          dwErr = ERROR_INVALID_PARAMETER;
    }

errorexit:
    if(fFreeOwner)
    {
        AccFree(pOwnerSid);
    }

    if(fFreeGroup)
    {
        AccFree(pGroupSid);
    }

    if(fFreeDAcl)
    {
        AccFree(pNewDAcl);
    }

    if(fFreeSAcl)
    {
        AccFree(pNewSAcl);
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   BuildSecurityDescriptorA
//
//  Synopsis:   ANSI version of the above
//
//  Arguments:  [IN  pOwner]        --  Items new owner
//              [IN  pGroup]        --  Items new group
//              [IN  cCountOfAccessEntries] Number of items in access list
//              [IN  pListOfAccessEntries]  Actual access list
//              [IN  cCountOfAuditEntries]  Number of items in audit list
//              [IN  pListOfAuditEntries]   Actual audit list
//              [IN  pOldSD]        --  OPTIONAL.  Existing security
//                                      descriptor to merge with
//              [OUT pSizeNewSD]    --  New SecDesc. size is returned here
//              [OUT pNewSD]        --  New SecDesc is returned here
//
//
//  Returns:    ERROR_SUCCESS       --  Success
//
//----------------------------------------------------------------------------
DWORD
WINAPI
BuildSecurityDescriptorA(IN  PTRUSTEE_A             pOwner,
                         IN  PTRUSTEE_A             pGroup,
                         IN  ULONG                  cCountOfAccessEntries,
                         IN  PEXPLICIT_ACCESS_A     pListOfAccessEntries,
                         IN  ULONG                  cCountOfAuditEntries,
                         IN  PEXPLICIT_ACCESS_A     pListOfAuditEntries,
                         IN  PSECURITY_DESCRIPTOR   pOldSD,
                         OUT PULONG                 pSizeNewSD,
                         OUT PSECURITY_DESCRIPTOR  *ppNewSD)
{
    TRUSTEE_W           OwnerW, *pOwnerW = NULL;
    TRUSTEE_W           GroupW, *pGroupW = NULL;
    PEXPLICIT_ACCESS_W  pAccessW = NULL;
    PEXPLICIT_ACCESS_W  pAuditW = NULL;
    ULONG               cbBytes;
    PBYTE               pbStuffPtr;
    DWORD               dwErr = ERROR_SUCCESS;

    LOAD_MARTA(dwErr);

    OwnerW.ptstrName = NULL;
    GroupW.ptstrName = NULL;

    //
    // Convert owner.
    //
    if(pOwner != NULL)
    {
        dwErr = ConvertTrusteeAToTrusteeW(pOwner,
                                          &OwnerW,
                                          FALSE);
        pOwnerW = &OwnerW;

    }

    //
    // Convert the group now...
    //
    if(dwErr == ERROR_SUCCESS && pGroup != NULL)
    {
        dwErr = ConvertTrusteeAToTrusteeW(pGroup,
                                          &GroupW,
                                          FALSE);
        pGroupW = &GroupW;
    }

    //
    // Convert the access lists
    //
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = ConvertExplicitAccessAToExplicitAccessW(cCountOfAccessEntries,
                                                        pListOfAccessEntries,
                                                        &pAccessW);
    }

    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = ConvertExplicitAccessAToExplicitAccessW(cCountOfAuditEntries,
                                                        pListOfAuditEntries,
                                                        &pAuditW );
    }

    //
    // Then, make the call
    //
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = BuildSecurityDescriptorW(pOwnerW,
                                         pGroupW,
                                         cCountOfAccessEntries,
                                         pAccessW,
                                         cCountOfAuditEntries,
                                         pAuditW,
                                         pOldSD,
                                         pSizeNewSD,
                                         ppNewSD);
    }

    //
    // Cleanup any allocated memory
    //
    if(pOwnerW != NULL)
    {
        AccFree(OwnerW.ptstrName);
    }

    if(pGroupW != NULL)
    {
        AccFree(GroupW.ptstrName);
    }

    if(pAccessW != NULL)
    {
        AccFree(pAccessW);
    }

    if(pAuditW != NULL)
    {
        AccFree(pAuditW);
    }

    return (dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   LookupSecurityDescriptorPartsW
//
//  Synopsis:   Converts a security descriptor into it's component parts
//
//  Arguments:  [OUT ppOwner]       --  Where to return the owner
//              [OUT ppGroup]       --  Where to return the group
//              [OUT pcCountOfAccessEntries]    Where to return the count of
//                                              access items
//              [OUT ppListOfAccessEntries]     Where to return the list of
//                                              access items
//              [OUT pcCountOfAuditEntries]     Where to return the count of
//                                              audit items
//              [OUT ppListOfAuditEntries]      Where to return the list of
//                                              audit items
//              [IN  pSD]           --  Security descriptor to seperate
//
//  Returns:    ERROR_SUCCESS       --  Success
//
//----------------------------------------------------------------------------
DWORD
WINAPI
LookupSecurityDescriptorPartsW(OUT PTRUSTEE_W          *ppOwner,
                               OUT PTRUSTEE_W          *ppGroup,
                               OUT PULONG               pcCountOfAccessEntries,
                               OUT PEXPLICIT_ACCESS_W  *ppListOfAccessEntries,
                               OUT PULONG               pcCountOfAuditEntries,
                               OUT PEXPLICIT_ACCESS_W  *ppListOfAuditEntries,
                               IN  PSECURITY_DESCRIPTOR pSD)
{
    DWORD               dwErr = ERROR_SUCCESS;
    PACL                pAcl;
    PSID                pSid;
    BOOL                fDefaulted, fPresent;
    PTRUSTEE_W          pOwner = NULL, pGroup = NULL;
    ULONG               cAccess = 0, cAudit = 0;
    PEXPLICIT_ACCESS_W  pAccess = NULL, pAudit = NULL;

    LOAD_MARTA(dwErr);

    //
    // First, the owner
    //
    if(ppOwner != NULL)
    {
        if(GetSecurityDescriptorOwner(pSD, &pSid, &fDefaulted) == TRUE)
        {
            dwErr = (*gNtMartaInfo.pfTrustee)(NULL,
                                              pSid,
                                              &pOwner);
        }
        else
        {
            dwErr = GetLastError();
        }
    }

    //
    // Then the group
    //
    if(dwErr == ERROR_SUCCESS && ppGroup != NULL)
    {
        if(GetSecurityDescriptorGroup(pSD, &pSid, &fDefaulted))
        {
            dwErr = (*gNtMartaInfo.pfTrustee)(NULL,
                                              pSid,
                                              &pGroup);
        }
        else
        {
            dwErr = GetLastError();
        }
    }

    //
    // Now the DACL
    //
    if(dwErr == ERROR_SUCCESS && pcCountOfAccessEntries != NULL &&
                                              ppListOfAccessEntries != NULL)
    {
        if(GetSecurityDescriptorDacl(pSD,
                                     &fPresent,
                                     &pAcl,
                                     &fDefaulted) == TRUE)
        {
            dwErr = GetExplicitEntriesFromAclW(pAcl,
                                               &cAccess,
                                               &pAccess);
        }
        else
        {
            dwErr = GetLastError();
        }
    }
    else if(dwErr == ERROR_SUCCESS && (pcCountOfAccessEntries != NULL ||
                                               ppListOfAccessEntries != NULL))
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }


    //
    // Finally, the SACL
    //
    if(dwErr == ERROR_SUCCESS && pcCountOfAuditEntries != NULL &&
                                                ppListOfAuditEntries != NULL)
    {
        if(GetSecurityDescriptorSacl(pSD,
                                     &fPresent,
                                     &pAcl,
                                     &fDefaulted) == TRUE)
        {
            dwErr = GetExplicitEntriesFromAclW(pAcl,
                                               &cAudit,
                                               &pAudit);
        }
        else
        {
            dwErr = GetLastError();
        }
    }
    else if(dwErr == ERROR_SUCCESS &&  (pcCountOfAuditEntries != NULL ||
                                                ppListOfAuditEntries != NULL))
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }

    //
    // if succeeded, fill in the return arguments
    //
    if (dwErr == ERROR_SUCCESS)
    {
        if(ppOwner != NULL)
        {
            *ppOwner = pOwner;
        }

        if(ppGroup != NULL)
        {
            *ppGroup = pGroup;
        }

        if(ppListOfAccessEntries != NULL)
        {
            *ppListOfAccessEntries = pAccess;
            *pcCountOfAccessEntries = cAccess;
        }

        if(ppListOfAuditEntries != NULL)
        {
            *ppListOfAuditEntries = pAudit;
            *pcCountOfAuditEntries = cAudit;
        }
    }
    else
    {
        //
        // otherwise free any allocated memory
        //
        if(pOwner != NULL)
        {
            LocalFree(pOwner);
        }

        if(pGroup != NULL)
        {
            LocalFree(pGroup);
        }

        if(pAccess != NULL)
        {
            LocalFree(pAccess);
        }

        if(pAudit != NULL)
        {
            LocalFree(pAudit);
        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   LookupSecurityDescriptorPartsA
//
//  Synopsis:   ANSI version of the above
//
//  Arguments:  [OUT ppOwner]       --  Where to return the owner
//              [OUT ppGroup]       --  Where to return the group
//              [OUT pcCountOfAccessEntries]    Where to return the count of
//                                              access items
//              [OUT ppListOfAccessEntries]     Where to return the list of
//                                              access items
//              [OUT pcCountOfAuditEntries]     Where to return the count of
//                                              audit items
//              [OUT ppListOfAuditEntries]      Where to return the list of
//                                              audit items
//              [IN  pSD]           --  Security descriptor to seperate
//
//  Returns:    ERROR_SUCCESS       --  Success
//
//----------------------------------------------------------------------------
DWORD
WINAPI
LookupSecurityDescriptorPartsA(OUT PTRUSTEE_A           *ppOwner,
                               OUT PTRUSTEE_A           *ppGroup,
                               OUT PULONG                pcCountOfAccessEntries,
                               OUT PEXPLICIT_ACCESS_A   *ppListOfAccessEntries,
                               OUT PULONG                pcCountOfAuditEntries,
                               OUT PEXPLICIT_ACCESS_A   *ppListOfAuditEntries,
                               IN  PSECURITY_DESCRIPTOR  pSD)
{
    DWORD               dwErr = ERROR_SUCCESS;
    PACL                pAcl;
    PSID                pSid;
    BOOL                fDefaulted, fPresent;
    PTRUSTEE_A          pOwner = NULL, pGroup = NULL;
    ULONG               cAccess = 0, cAudit = 0;
    PEXPLICIT_ACCESS_A  pAccess = NULL, pAudit = NULL;

    LOAD_MARTA(dwErr);

    //
    // First, the owner
    //
    if(ppOwner != NULL)
    {
        if(GetSecurityDescriptorOwner(pSD, &pSid, &fDefaulted) == TRUE)
        {
            PTRUSTEE_W  pTrusteeW;
            dwErr = (*gNtMartaInfo.pfTrustee)(NULL,
                                              pSid,
                                              &pTrusteeW);
            if(dwErr == ERROR_SUCCESS)
            {
                dwErr = ConvertTrusteeWToTrusteeA(pTrusteeW,
                                                  &pOwner);
                LocalFree(pTrusteeW);
            }
        }
        else
        {
            dwErr = GetLastError();
        }
    }

    //
    // Then the group
    //
    if(dwErr == ERROR_SUCCESS && ppGroup != NULL)
    {
        if(GetSecurityDescriptorGroup(pSD, &pSid, &fDefaulted))
        {
            PTRUSTEE_W  pTrusteeW;
            dwErr = (*gNtMartaInfo.pfTrustee)(NULL,
                                              pSid,
                                              &pTrusteeW);
            if(dwErr == ERROR_SUCCESS)
            {
                dwErr = ConvertTrusteeWToTrusteeA(pTrusteeW,
                                                  &pGroup);
                LocalFree(pTrusteeW);
            }
        }
        else
        {
            dwErr = GetLastError();
        }
    }

    //
    // Now the DACL
    //
    if(dwErr == ERROR_SUCCESS && pcCountOfAccessEntries != NULL &&
                                              ppListOfAccessEntries != NULL)
    {
        if(GetSecurityDescriptorDacl(pSD,
                                     &fPresent,
                                     &pAcl,
                                     &fDefaulted) == TRUE)
        {
            dwErr = GetExplicitEntriesFromAclA(pAcl,
                                               &cAccess,
                                               &pAccess);
        }
        else
        {
            dwErr = GetLastError();
        }
    }
    else if(dwErr == ERROR_SUCCESS && (pcCountOfAccessEntries != NULL ||
                                               ppListOfAccessEntries != NULL))
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }


    //
    // Finally, the SACL
    //
    if(dwErr == ERROR_SUCCESS && pcCountOfAuditEntries != NULL &&
                                                ppListOfAuditEntries != NULL)
    {
        if(GetSecurityDescriptorSacl(pSD,
                                     &fPresent,
                                     &pAcl,
                                     &fDefaulted) == TRUE)
        {
            dwErr = GetExplicitEntriesFromAclA(pAcl,
                                               &cAudit,
                                               &pAudit);
        }
        else
        {
            dwErr = GetLastError();
        }
    }
    else if(dwErr == ERROR_SUCCESS &&  (pcCountOfAuditEntries != NULL ||
                                                ppListOfAuditEntries != NULL))
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }

    //
    // if succeeded, fill in the return arguments
    //
    if (dwErr == ERROR_SUCCESS)
    {
        if(ppOwner != NULL)
        {
            *ppOwner = pOwner;
        }

        if(ppGroup != NULL)
        {
            *ppGroup = pGroup;
        }

        if(ppListOfAccessEntries != NULL)
        {
            *ppListOfAccessEntries = pAccess;
            *pcCountOfAccessEntries = cAccess;
        }

        if(ppListOfAuditEntries != NULL)
        {
            *ppListOfAuditEntries = pAudit;
            *pcCountOfAuditEntries = cAudit;
        }
    }
    else
    {
        //
        // otherwise free any allocated memory
        //
        if(pOwner != NULL)
        {
            LocalFree(pOwner);
        }

        if(pGroup != NULL)
        {
            LocalFree(pGroup);
        }

        if(pAccess != NULL)
        {
            LocalFree(pAccess);
        }

        if(pAudit != NULL)
        {
            LocalFree(pAudit);
        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   BuildExplicitAccessWithNameW
//
//  Synopsis:   Initializes the given EXPLICIT_ACCESS entry
//
//  Arguments:  [OUT pExplicitAccess]   Structure to fill in
//              [IN  pTrusteeName]  --  Trustee name to set in strucutre
//              [IN  AccessPermissions] Access mask to set
//              [IN  AccessMode]    --  How to set the access permissions
//              [IN  Ihheritance]   --  Inheritance flags
//
//  Returns:    ERROR_SUCCESS       --  Success
//
//----------------------------------------------------------------------------
VOID
WINAPI
BuildExplicitAccessWithNameW(IN OUT PEXPLICIT_ACCESS_W  pExplicitAccess,
                             IN     LPWSTR              pTrusteeName,
                             IN     DWORD               AccessPermissions,
                             IN     ACCESS_MODE         AccessMode,
                             IN     DWORD               Inheritance)
{
    BuildTrusteeWithNameW(&(pExplicitAccess->Trustee), pTrusteeName);
    pExplicitAccess->grfAccessPermissions = AccessPermissions;
    pExplicitAccess->grfAccessMode = AccessMode;
    pExplicitAccess->grfInheritance = Inheritance;
}


//+---------------------------------------------------------------------------
//
//  Function:   BuildExplicitAccessWithNameA
//
//  Synopsis:   ANSI version of the above
//
//  Arguments:  [OUT pExplicitAccess]   Structure to fill in
//              [IN  pTrusteeName]  --  Trustee name to set in strucutre
//              [IN  AccessPermissions] Access mask to set
//              [IN  AccessMode]    --  How to set the access permissions
//              [IN  Ihheritance]   --  Inheritance flags
//
//  Returns:    ERROR_SUCCESS       --  Success
//
//----------------------------------------------------------------------------
VOID
WINAPI
BuildExplicitAccessWithNameA(IN OUT PEXPLICIT_ACCESS_A  pExplicitAccess,
                             IN     LPSTR               pTrusteeName,
                             IN     DWORD               AccessPermissions,
                             IN     ACCESS_MODE         AccessMode,
                             IN     DWORD               Inheritance)
{
    BuildTrusteeWithNameA(&(pExplicitAccess->Trustee), pTrusteeName);
    pExplicitAccess->grfAccessPermissions = AccessPermissions;
    pExplicitAccess->grfAccessMode = AccessMode;
    pExplicitAccess->grfInheritance = Inheritance;
}




//+---------------------------------------------------------------------------
//
//  Function:   BuildImpersonateExplicitAccessWithNameW
//
//  Synopsis:   Builds an impersonation explicit access entry
//
//  Arguments:  [OUT pExplicitAccess]   Structure to fill in
//              [IN  pTrusteeName]  --  Trustee name to set in strucutre
//              [IN  pTrustee]      --  Impersonate trustee
//              [IN  AccessPermissions] Access mask to set
//              [IN  AccessMode]    --  How to set the access permissions
//              [IN  Ihheritance]   --  Inheritance flags
//
//  Returns:    ERROR_SUCCESS       --  Success
//
//----------------------------------------------------------------------------
VOID
WINAPI
BuildImpersonateExplicitAccessWithNameW(
    IN OUT PEXPLICIT_ACCESS_W  pExplicitAccess,
    IN     LPWSTR              pTrusteeName,
    IN     PTRUSTEE_W          pTrustee,
    IN     DWORD               AccessPermissions,
    IN     ACCESS_MODE         AccessMode,
    IN     DWORD               Inheritance)
{
    BuildTrusteeWithNameW( &(pExplicitAccess->Trustee), pTrusteeName );
    BuildImpersonateTrusteeW( &(pExplicitAccess->Trustee), pTrustee );
    pExplicitAccess->grfAccessPermissions = AccessPermissions;
    pExplicitAccess->grfAccessMode = AccessMode;
    pExplicitAccess->grfInheritance = Inheritance;
}




//+---------------------------------------------------------------------------
//
//  Function:   BuildImpersonateExplicitAccessWithNameW
//
//  Synopsis:   ANSI version of the above
//
//  Arguments:  [OUT pExplicitAccess]   Structure to fill in
//              [IN  pTrusteeName]  --  Trustee name to set in strucutre
//              [IN  pTrustee]      --  Impersonate trustee
//              [IN  AccessPermissions] Access mask to set
//              [IN  AccessMode]    --  How to set the access permissions
//              [IN  Ihheritance]   --  Inheritance flags
//
//  Returns:    ERROR_SUCCESS       --  Success
//
//----------------------------------------------------------------------------
VOID
WINAPI
BuildImpersonateExplicitAccessWithNameA(
    IN OUT PEXPLICIT_ACCESS_A  pExplicitAccess,
    IN     LPSTR               pTrusteeName,
    IN     PTRUSTEE_A          pTrustee,
    IN     DWORD               AccessPermissions,
    IN     ACCESS_MODE         AccessMode,
    IN     DWORD               Inheritance)
{
    BuildTrusteeWithNameA( &(pExplicitAccess->Trustee), pTrusteeName );
    BuildImpersonateTrusteeA( &(pExplicitAccess->Trustee), pTrustee );
    pExplicitAccess->grfAccessPermissions = AccessPermissions;
    pExplicitAccess->grfAccessMode = AccessMode;
    pExplicitAccess->grfInheritance = Inheritance;
}

//+---------------------------------------------------------------------------
//
//  Function: TreeResetNamedSecurityInfoW
//
//  Synopsis:   Sets the specified security information from the indicated
//              object
//
//  Arguments:  [IN  pObjectName]   --  Object on which to set the security
//              [IN  ObjectType]    --  Type of object specified by lpObject
//              [IN  SecurityInfo]  --  What is to be returned
//              [IN psidOwner]      --  Owner to set
//              [IN psidGroup]      --  Group to set
//              [IN pDacl]          --  Dacl to set
//              [IN pSacl]          --  Sacl to set
//              [IN KeepExplicit]   --  Whether children should retain explicit aces
//              [IN fnProgress]     --  Callback function
//              [IN ProgressInvokeSetting] --  Sacl to set
//              [IN Args]           --  Caller supplied arguments for callback
//
//  Returns:    ERROR_SUCCESS       --  Success
//
//----------------------------------------------------------------------------
DWORD
WINAPI
TreeResetNamedSecurityInfoW(
    IN LPWSTR               pObjectName,
    IN SE_OBJECT_TYPE       ObjectType,
    IN SECURITY_INFORMATION SecurityInfo,
    IN PSID                 pOwner,
    IN PSID                 pGroup,
    IN PACL                 pDacl,
    IN PACL                 pSacl,
    IN BOOL                 KeepExplicit,
    IN FN_PROGRESS          fnProgress,
    IN PROG_INVOKE_SETTING  ProgressInvokeSetting,
    IN PVOID                Args
    )
{
    DWORD dwErr = ERROR_SUCCESS;

    if (NULL == pObjectName)
    {
        return ERROR_INVALID_PARAMETER;
    }

    switch(ObjectType)
    {
    case SE_FILE_OBJECT:
    case SE_REGISTRY_KEY:
        break;
    default:
        return ERROR_INVALID_PARAMETER;
    }

    if (SecurityInfo & DACL_SECURITY_INFORMATION)
    {
        if ((SecurityInfo & PROTECTED_DACL_SECURITY_INFORMATION) &&
            (SecurityInfo & UNPROTECTED_DACL_SECURITY_INFORMATION))
        {
            return ERROR_INVALID_PARAMETER;
        }
    }

    if (SecurityInfo & SACL_SECURITY_INFORMATION)
    {
        if ((SecurityInfo & PROTECTED_SACL_SECURITY_INFORMATION) &&
            (SecurityInfo & UNPROTECTED_SACL_SECURITY_INFORMATION))
        {
            return ERROR_INVALID_PARAMETER;
        }
    }

    LOAD_MARTA(dwErr);

    if (dwErr != ERROR_SUCCESS)
    {
        return dwErr;
    }

    return (*(gNtMartaInfo.pfrTreeResetNamedSecurityInfo)) (
                  pObjectName,
                  ObjectType,
                  SecurityInfo,
                  pOwner,
                  pGroup,
                  pDacl,
                  pSacl,
                  KeepExplicit,
                  fnProgress,
                  ProgressInvokeSetting,
                  Args
                  );

}

//+---------------------------------------------------------------------------
//
//  Function: TreeResetNamedSecurityInfoA
//
//  Synopsis:   Sets the specified security information from the indicated
//              object
//
//  Arguments:  [IN  pObjectName]   --  Object on which to set the security
//              [IN  ObjectType]    --  Type of object specified by lpObject
//              [IN  SecurityInfo]  --  What is to be returned
//              [IN psidOwner]      --  Owner to set
//              [IN psidGroup]      --  Group to set
//              [IN pDacl]          --  Dacl to set
//              [IN pSacl]          --  Sacl to set
//              [IN KeepExplicit]   --  Whether children should retain explicit aces
//              [IN fnProgress]     --  Callback function
//              [IN ProgressInvokeSetting] --  Sacl to set
//              [IN Args]           --  Caller supplied arguments for callback
//
//  Returns:    ERROR_CALL_NOT_IMPLEMENTED.
//              ANSI version is not supported.
//
//----------------------------------------------------------------------------
DWORD
WINAPI
TreeResetNamedSecurityInfoA(
    IN LPSTR                pObjectName,
    IN SE_OBJECT_TYPE       ObjectType,
    IN SECURITY_INFORMATION SecurityInfo,
    IN PSID                 pOwner,
    IN PSID                 pGroup,
    IN PACL                 pDacl,
    IN PACL                 pSacl,
    IN BOOL                 KeepExplicit,
    IN FN_PROGRESS          fnProgress,
    IN PROG_INVOKE_SETTING  ProgressInvokeSetting,
    IN PVOID                Args
    )
{
    return ERROR_CALL_NOT_IMPLEMENTED;
}

//+---------------------------------------------------------------------------
//
//  Function: GetInheritanceSourceW
//
//  Synopsis:   For every inherited ace in a given acl, find the ancestor
//              from which it was inherited.
//
//  Arguments:  [IN pObjectName]      --  Name of the object
//              [IN ObjectType]       --  Type of object specified
//              [IN SecurityInfo]     --  Dacl or Sacl
//              [IN Container]        --  Whether object or container
//              [IN pObjectClassGuids]  --  Guids of the object
//              [IN GuidCount]        --  Number of guids 
//              [IN pAcl]             --  Dacl to set
//              [IN pfnArray]         --  For future, for any resource manager
//              [IN pGenericMapping]  --  Generic mapping for the object
//              [OUT pInheritArray]   --  To return output values as (Level, Name)
//
//  Returns:    ERROR_SUCCESS         --  Success
//
//----------------------------------------------------------------------------
DWORD
WINAPI
GetInheritanceSourceW(
    IN  LPWSTR                   pObjectName,
    IN  SE_OBJECT_TYPE           ObjectType,
    IN  SECURITY_INFORMATION     SecurityInfo,
    IN  BOOL                     Container,
    IN  GUID                  ** pObjectClassGuids OPTIONAL,
    IN  DWORD                    GuidCount,
    IN  PACL                     pAcl,
    IN  PFN_OBJECT_MGR_FUNCTS    pfnArray OPTIONAL,
    IN  PGENERIC_MAPPING         pGenericMapping,
    OUT PINHERITED_FROMW         pInheritArray

    )
{
    DWORD dwErr;

    LOAD_MARTA(dwErr);

    CONDITIONAL_EXIT(dwErr, End);

    dwErr = (*(gNtMartaInfo.pfrGetInheritanceSource)) (
                   pObjectName,
                   ObjectType,
                   SecurityInfo,
                   Container,
                   pObjectClassGuids,
                   GuidCount,
                   pAcl,
                   pGenericMapping,
                   pfnArray,
                   pInheritArray
                   );
End:
    return dwErr;
}

//+---------------------------------------------------------------------------
//
//  Function: GetInheritanceSourceA
//
//  Synopsis:   For every inherited ace in a given acl, find the ancestor
//              from which it was inherited.
//
//  Arguments:  [IN pObjectName]     --  Name of the object
//              [IN ObjectType]      --  Type of object specified
//              [IN SecurityInfo]    --  Dacl or Sacl
//              [IN Container]       --  Whether object or container
//              [IN pObjectTypeGuid] --  Guids of the object
//              [IN GuidCount]       --  Number of guids 
//              [IN pAcl]            --  Dacl to set
//              [IN pfnArray]        --  For future, for any resource manager
//              [IN pGenericMapping] --  Generic mapping for the object
//              [OUT pInheritArray]  --  To return output values as (Level, Name)
//
//  Returns:    ERROR_CALL_NOT_IMPLEMENTED
//              ANSI version is not supported.
//
//----------------------------------------------------------------------------
DWORD
WINAPI
GetInheritanceSourceA(
    IN  LPSTR                    pObjectName,
    IN  SE_OBJECT_TYPE           ObjectType,
    IN  SECURITY_INFORMATION     SecurityInfo,
    IN  BOOL                     Container,
    IN  GUID                  ** pObjectTypeGuid,
    IN  DWORD                    GuidCount,
    IN  PACL                     pAcl,
    IN  PFN_OBJECT_MGR_FUNCTS    pfnArray OPTIONAL,
    IN  PGENERIC_MAPPING         pGenericMapping,
    OUT PINHERITED_FROMA         pInheritArray

    )
{
    return ERROR_CALL_NOT_IMPLEMENTED;
}

//+---------------------------------------------------------------------------
//
//  Function: FreeInheritedFromArray
//
//  Synopsis:   Free the strings that were allocated and assigned to the array 
//              elements.
//
//  Arguments:  [IN pInheritArray]  --  Array from which strings will be freed.
//              [IN AceCnt]         --  Number of aces in the array
//              [IN pfnArray]       --  For future, for any resource manager
//
//  Returns:    ERROR_SUCCESS       --  Success
//
//----------------------------------------------------------------------------
DWORD
WINAPI
FreeInheritedFromArray(
    IN PINHERITED_FROMW pInheritArray,
    IN USHORT AceCnt,
    IN PFN_OBJECT_MGR_FUNCTS   pfnArray OPTIONAL
    )
{

    DWORD dwErr;

    LOAD_MARTA(dwErr);

    CONDITIONAL_EXIT(dwErr, End);

    dwErr = (*(gNtMartaInfo.pfrFreeIndexArray)) (
                   pInheritArray,
                   AceCnt,
                   NULL // Use LocalFree
                   );
End:
    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\accctrl2\inc\marta.h ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1996.
//
//  File:       MARTA.H
//
//  Contents:   Private definitions and function prototypes used by the
//              access control APIs to handle the provider independence
//
//  History:    19-Jun-96       MacM        Created
//
//--------------------------------------------------------------------
#ifndef __MARTA_H__
#define __MARTA_H__

#include <accprov.h>

//
// List of entry points for the provider DLL functions
//
#define ACC_PROV_GET_CAPS       "AccProvGetCapabilities"
#define ACC_PROV_OBJ_ACCESS     "AccProvIsObjectAccessible"
#define ACC_PROV_GRANT_ACCESS   "AccProvGrantAccessRights"
#define ACC_PROV_SET_ACCESS     "AccProvSetAccessRights"
#define ACC_PROV_REVOKE_ACCESS  "AccProvRevokeAccessRights"
#define ACC_PROV_REVOKE_AUDIT   "AccProvRevokeAuditRights"
#define ACC_PROV_GET_ALL        "AccProvGetAllRights"
#define ACC_PROV_ACCESS         "AccProvGetTrusteesAccess"
#define ACC_PROV_AUDIT          "AccProvIsAccessAudited"
#define ACC_PROV_OBJ_INFO       "AccProvGetAccessInfoPerObjectType"
#define ACC_PROV_CANCEL         "AccProvCancelOperation"
#define ACC_PROV_GET_RESULTS    "AccProvGetOperationResults"

#define ACC_PROV_HOBJ_ACCESS    "AccProvHandleIsObjectAccessible"
#define ACC_PROV_HGRANT_ACCESS  "AccProvHandleGrantAccessRights"
#define ACC_PROV_HSET_ACCESS    "AccProvHandleSetAccessRights"
#define ACC_PROV_HREVOKE_ACCESS "AccProvHandleRevokeAccessRights"
#define ACC_PROV_HREVOKE_AUDIT  "AccProvHandleRevokeAuditRights"
#define ACC_PROV_HGET_ALL       "AccProvHandleGetAllRights"
#define ACC_PROV_HACCESS        "AccProvHandleGetTrusteesAccess"
#define ACC_PROV_HAUDIT         "AccProvHandleIsAccessAudited"
#define ACC_PROV_HOBJ_INFO      "AccProvHandleGetAccessInfoPerObjectType"


//
// Registry keys that hold the provider information
//
#define ACC_PROV_REG_ROOT                                                   \
                L"System\\CurrentControlSet\\Control\\LSA\\AccessProviders"
#define ACC_PROV_REG_ORDER  L"ProviderOrder"
#define ACC_PROV_REG_UNIQUE L"RequireUniqueAccessibility"
#define ACC_PROV_REG_PATH   L"ProviderPath"


//
// Flags used to control the provider state
//
#define ACC_PROV_PROV_OK        0x00000001
#define ACC_PROV_PROV_FAILED    0x00000000

//
// Indicates that the RequireUniqueAccessibility flag was present
//
#define ACC_PROV_REQ_UNIQUE         0x00000001

//
// Indicates that the providers have been loaded
//
#define ACC_PROV_PROVIDERS_LOADED   0x00000002

//
// This structure is what contains all of the required information about
// each of the providers
//
typedef struct _ACCPROV_PROV_INFO
{
    PWSTR               pwszProviderName;   // "Friendly" name of the provider
    PWSTR               pwszProviderPath;   // DLL path name.  Null after
                                            // module loaded
    HMODULE             hDll;               // Module handle of the DLL
                                            // after being loaded
    ULONG               fProviderCaps;      // Provider capabilities
    ULONG               fProviderState;     // Current state of the provider

    //
    // The following is the function table used to call the provider
    // functions
    //

    //
    // General functions
    //
    pfAccProvObjAccess          pfObjAccess;    // AccProvIsObjectAccessible
    pfAccProvHandleObjAccess    pfhObjAccess;   // AccProvHandleIsObjectAccessible
    pfAccProvCancelOp           pfCancel;       // AccProvCancelOperation
    pfAccProvGetResults         pfResults;      // AccProvGetOperationResults

    //
    // Required path based functions
    //
    pfAccProvAddRights      pfGrantAccess;  // AccProvGrantAccessRights
    pfAccProvSetRights      pfSetAccess;    // AccProvSetAccessRights
    pfAccProvRevoke         pfRevokeAccess; // AccProvRevokeAccessRights
    pfAccProvRevoke         pfRevokeAudit;  // AccProvRevokeAuditRights
    pfAccProvGetRights      pfGetRights;    // AccProvGetAllRights
    pfAccProvTrusteeAccess  pfTrusteeAccess;// AccProvGetTrusteesAccess
    pfAccProvAccessAudit    pfAudit;        // AccProvIsAccessAudited
    pfAccProvGetObjTypeInfo pfObjInfo;      // AccProvGetAccessInfoPerObjectType

    //
    // Optional, handle based functions
    //
    pfAccProvHandleAddRights      pfhGrantAccess;  // AccProvHandleGrantAccessRights
    pfAccProvHandleSetRights      pfhSetAccess;    // AccProvHandleSetAccessRights
    pfAccProvHandleRevoke         pfhRevokeAccess; // AccProvHandleRevokeAccessRights
    pfAccProvHandleRevoke         pfhRevokeAudit;  // AccProvHandleRevokeAuditRights
    pfAccProvHandleGetRights      pfhGetRights;    // AccProvHandleGetAllRights
    pfAccProvHandleTrusteeAccess  pfhTrusteeAccess;// AccProvHandleGetTrusteesAccess
    pfAccProvHandleAccessAudit    pfhAudit;        // AccProvHandleIsAccessAudited
    pfAccProvHandleGetObjTypeInfo pfhObjInfo;      // AccProvHandleGetAccessInfoPerObjectType
} ACCPROV_PROV_INFO, *PACCPROV_PROV_INFO;


//
// This structure contains all of the information about the availible security
// providers
//
typedef struct _ACCPROV_PROVIDERS
{
    CRITICAL_SECTION    ProviderLoadLock;   // Lock the provider list during load time
    ULONG               fOptions;           // Various provider options
    ULONG               cProviders;         // Number of providers;
    PACCPROV_PROV_INFO  pProvList;          // Actual list of providers
} ACCPROV_PROVIDERS, *PACCPROV_PROVIDERS;


extern ACCPROV_PROVIDERS gAccProviders;

//
// Allocates the provider list
//
DWORD
AccProvpAllocateProviderList(IN OUT PACCPROV_PROVIDERS  pProviders);

//
// Frees a provider list
//
VOID
AccProvpFreeProviderList(IN  PACCPROV_PROVIDERS  pProviders);

//
// Gets the capabilities of the given provider
//
DWORD
AccProvpGetProviderCapabilities(IN  PACCPROV_PROV_INFO  pProvInfo);

//
// Loads a provider definition from the registry
//
DWORD
AccProvpLoadProviderDef(IN  HKEY                hkReg,
                        IN  PWSTR               pwszNextProv,
                        OUT PACCPROV_PROV_INFO  pProvInfo);

//
// Initializes the list of providers
//
DWORD
AccProvpInitProviders(IN OUT PACCPROV_PROVIDERS  pProviders);

//
// Loads the NTMARTA.DLL functions
//
DWORD
AccProvpLoadMartaFunctions();

BOOL
MartaInitialize();

BOOL
MartaDllInitialize(IN   HINSTANCE   hMod,
                   IN   DWORD       dwReason,
                   IN   PVOID       pvReserved);

//
// Unloads any loaded DLLs
//
VOID
AccProvUnload();

//
// Determines the provider for an object
//
DWORD
AccProvpProbeProviderForObject(IN   PWSTR               pwszObject,
                               IN   HANDLE              hObject,
                               IN   SE_OBJECT_TYPE      ObjectType,
                               IN   PACCPROV_PROVIDERS  pProviders,
                               OUT  PACCPROV_PROV_INFO *ppProvider);

//
// Determines which provider should handle a request...
//
DWORD
AccProvpGetProviderForPath(IN  PCWSTR              pcwszObject,
                           IN  SE_OBJECT_TYPE      ObjectType,
                           IN  PCWSTR              pcwszProvider,
                           IN  PACCPROV_PROVIDERS  pProviders,
                           OUT PACCPROV_PROV_INFO *ppProvider);

DWORD
AccProvpGetProviderForHandle(IN  HANDLE              hObject,
                             IN  SE_OBJECT_TYPE      ObjectType,
                             IN  PCWSTR              pcwszProvider,
                             IN  PACCPROV_PROVIDERS  pProviders,
                             OUT PACCPROV_PROV_INFO *ppProvider);


//
// Macro to load a function pointer from a DLL
//
#define LOAD_ENTRYPT(ptr, typ, dll, str)            \
ptr = (typ)GetProcAddress(dll, str);                \
if(ptr == NULL)                                     \
{                                                   \
    goto Error;                                     \
}



#endif // ifndef __MARTA_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\advapi\tpriv.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    tuser.c

Abstract:

    This module tests windows LookupPrivilegeNameX for a specific
    condition that required a Daytona hotfix.

Author:

    Jim Kelly (JimK) July-27-1994


Revision History:

--*/

#include <windows.h>
#include <stdio.h>



VOID
DoLookup( DWORD L );

CHAR BufferA[0x11000];
CHAR BufferA1[0x11000];
WCHAR BufferW[11000];

int
main (void)
{

    //
    // Lookup privilege names with certain special buffer lengths.


    DoLookup( 0xFFFF );
    DoLookup( 0xFFFC );
    DoLookup( 0x45 );
    DoLookup( 0x10000 );
    DoLookup( 0x10010 );
    DoLookup( 0x2 );

    return(0);
}



VOID
DoLookup( DWORD L )
{

    DWORD
        Language,
        Length;

    LUID
        PrivilegeId;

    Language = 0;
    

    Length = L;
    PrivilegeId.HighPart = 0;
    PrivilegeId.LowPart  = 7;   //SE_TCB_PRIVILEGE;

    printf("length %d\n", Length);
    printf("  LookupPrivilegeNameA:");
    if (LookupPrivilegeNameA( "", &PrivilegeId, &BufferA[0], &Length)) {
        printf("success  (%s)\n", &BufferA[0] );
    } else {
        printf("failed ****\n");
    }

    printf("  LookupPrivilegeDisplayNameA:");
    if (LookupPrivilegeDisplayNameA( "", &BufferA[0], &BufferA1[0], &Length, &Language)) {
        printf("success  (%s)\n", &BufferA1[0] );
    } else {
        printf("failed ****\n");
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\accctrl2\src\trustee.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1996.
//
//  File:       TRUSTEE.CXX
//
//  Contents:   Implements the trustee support functions
//
//  History:    04-Sep-96       MacM        Created
//
//  Notes:      Trustee functions taken from DaveMont code:
//                      \windows\base\accctrl\src\helper.cxx
//
//----------------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop

MARTA_NTMARTA_INFO   gNtMartaInfo;
CRITICAL_SECTION     NtMartaLoadCritical;

//+---------------------------------------------------------------------------
//
//  Function:   MartaInitialize
//
//  Synopsis:   Initializes MARTA.
//
//  Arguments:  None
//
//  Returns:    TRUE                --  Success
//              FALSE               --  Failure
//
//----------------------------------------------------------------------------
BOOL
MartaInitialize()
{
    NTSTATUS Status ;

    gAccProviders.fOptions = 0;
    gAccProviders.cProviders = 0;
    gNtMartaInfo.hDll = 0;

    Status = RtlInitializeCriticalSection( &gAccProviders.ProviderLoadLock );

    if  ( !NT_SUCCESS( Status ) ) {
        return FALSE ;
    }

    Status = RtlInitializeCriticalSection( &NtMartaLoadCritical );

    if  ( !NT_SUCCESS( Status ) ) {
        return FALSE ;
    }

    return(TRUE);
}




//+---------------------------------------------------------------------------
//
//  Function:   MartaDllInitialize
//
//  Synopsis:   Initializes MARTA.  This will happen during host DLL load time.
//
//  Arguments:  None
//
//  Returns:    TRUE                --  Success
//              FALSE               --  Failure
//
//----------------------------------------------------------------------------
BOOL
MartaDllInitialize(IN   HINSTANCE   hMod,
                   IN   DWORD       dwReason,
                   IN   PVOID       pvReserved)
{
    if(dwReason == DLL_PROCESS_ATTACH)
    {
        return(MartaInitialize());
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        AccProvUnload();
        DeleteCriticalSection( &gAccProviders.ProviderLoadLock );

        DeleteCriticalSection( &NtMartaLoadCritical );
    }

    return(TRUE);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccProvpLoadMartaFunctions
//
//  Synopsis:   Loads the function pointer table for the NTMARTA functions.
//
//  Arguments:  None
//
//  Returns:    ERROR_SUCCESS       --  Success
//
//----------------------------------------------------------------------------
DWORD
AccProvpLoadMartaFunctions()
{
    DWORD   dwErr = ERROR_SUCCESS;
    HMODULE hDll;

    //
    // Do this here so we can get out fast in the normal
    // case.
    //

    if(gNtMartaInfo.hDll != NULL)
    {
        return(ERROR_SUCCESS);
    }

    //
    // We have to load the library _before_ entering the critsec to prevent 
    // a deadlock in case ntmarta functions are called from dllmain.
    //
    // Thread 1: Calls ntmarta function from dllmain of another dll and is 
    //           holding the loader lock. This thread now waits on the critsec.
    // Thread 2: Calls ntmarta function and grabs the critsec before thread 1
    //           can get there. This thread will hang since it can not get the
    //           loader lock.
    //

    hDll = LoadLibrary(L"NTMARTA.DLL");

    if(hDll == NULL)
    {
        dwErr = GetLastError();
        return(dwErr);
    }

    //
    // Try to load the entrypoints
    //

    LOAD_ENTRYPT(gNtMartaInfo.pfrFreeIndexArray,
                 pfNTMartaFreeIndexArray,
                 hDll,
                 "AccFreeIndexArray");

    LOAD_ENTRYPT(gNtMartaInfo.pfrTreeResetNamedSecurityInfo,
                 pfNTMartaTreeResetNamedSecurityInfo,
                 hDll,
                 "AccTreeResetNamedSecurityInfo");

    LOAD_ENTRYPT(gNtMartaInfo.pfrGetInheritanceSource,
                 pfNTMartaGetInheritanceSource,
                 hDll,
                 "AccGetInheritanceSource");

    LOAD_ENTRYPT(gNtMartaInfo.pfTrustee,
                 pfNTMartaLookupTrustee,
                 hDll,
                 "AccLookupAccountTrustee");

    LOAD_ENTRYPT(gNtMartaInfo.pfrGetNamedRights,
                 pfNTMartaGetNamedRights,
                 hDll,
                 "AccRewriteGetNamedRights");

    LOAD_ENTRYPT(gNtMartaInfo.pfrSetNamedRights,
                 pfNTMartaSetNamedRights,
                 hDll,
                 "AccRewriteSetNamedRights");

    LOAD_ENTRYPT(gNtMartaInfo.pfrGetHandleRights,
                 pfNTMartaGetHandleRights,
                 hDll,
                 "AccRewriteGetHandleRights");

    LOAD_ENTRYPT(gNtMartaInfo.pfrSetHandleRights,
                 pfNTMartaSetHandleRights,
                 hDll,
                 "AccRewriteSetHandleRights");

    LOAD_ENTRYPT(gNtMartaInfo.pfrSetEntriesInAcl,
                 pfNTMartaSetEntriesInAcl,
                 hDll,
                 "AccRewriteSetEntriesInAcl");

    LOAD_ENTRYPT(gNtMartaInfo.pfrGetExplicitEntriesFromAcl,
                 pfNTMartaGetExplicitEntriesFromAcl,
                 hDll,
                 "AccRewriteGetExplicitEntriesFromAcl");

    LOAD_ENTRYPT(gNtMartaInfo.pfName,
                 pfNTMartaLookupName,
                 hDll,
                 "AccLookupAccountName");

    LOAD_ENTRYPT(gNtMartaInfo.pfSid,
                 pfNTMartaLookupSid,
                 hDll,
                 "AccLookupAccountSid");

    LOAD_ENTRYPT(gNtMartaInfo.pfSetAList,
                 pfNTMartaSetAList,
                 hDll,
                 "AccSetEntriesInAList");

    LOAD_ENTRYPT(gNtMartaInfo.pfAToSD,
                 pfNTMartaAToSD,
                 hDll,
                 "AccConvertAccessToSecurityDescriptor");

    LOAD_ENTRYPT(gNtMartaInfo.pfSDToA,
                 pfNTMartaSDToA,
                 hDll,
                 "AccConvertSDToAccess");

    LOAD_ENTRYPT(gNtMartaInfo.pfGetAccess,
                 pfNTMartaGetAccess,
                 hDll,
                 "AccGetAccessForTrustee");

    LOAD_ENTRYPT(gNtMartaInfo.pfAclToA,
                 pfNTMartaAclToA,
                 hDll,
                 "AccConvertAclToAccess");

    LOAD_ENTRYPT(gNtMartaInfo.pfGetExplicit,
                 pfNTMartaGetExplicit,
                 hDll,
                 "AccGetExplicitEntries");

    EnterCriticalSection( &NtMartaLoadCritical );

    //
    // If the global is non-null, another thread succeeded in loading ntmarta 
    // before us. Return after decrementing the refcount on the library.
    //

    if(gNtMartaInfo.hDll != NULL)
    {
        LeaveCriticalSection( &NtMartaLoadCritical );
        FreeLibrary(hDll);
        return(ERROR_SUCCESS);
    }

    gNtMartaInfo.hDll = hDll;

    LeaveCriticalSection( &NtMartaLoadCritical );

    SetLastError(ERROR_SUCCESS);

Error:

    dwErr = GetLastError();

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccProvUnload
//
//  Synopsis:   Unlaods the various loaded dlls
//
//  Arguments:  None
//
//  Returns:    VOID
//
//----------------------------------------------------------------------------
VOID
AccProvUnload()
{
    for(ULONG iIndex = 0; iIndex < gAccProviders.cProviders; iIndex++)
    {
        if(gAccProviders.pProvList[iIndex].hDll != NULL)
        {
            FreeLibrary(gAccProviders.pProvList[iIndex].hDll);
        }
    }

    if(gNtMartaInfo.hDll != NULL)
    {
        FreeLibrary(gNtMartaInfo.hDll);
    }

    //
    // Finally, deallocate any memory
    //
    AccProvpFreeProviderList(&gAccProviders);
}




//+---------------------------------------------------------------------------
//
//  Function:   BuildTrusteeWithNameW
//
//  Synopsis:   Builds a TRUSTEE from a name
//
//  Arguments:  [OUT pTrustee]      --  Trustee to initialize
//              [IN  pName]         --  Name to use for initialization
//
//  Returns:    VOID
//
//----------------------------------------------------------------------------
VOID
WINAPI
BuildTrusteeWithNameW( IN OUT PTRUSTEE_W  pTrustee,
                       IN     LPWSTR      pName)
{
    pTrustee->pMultipleTrustee = NULL;
    pTrustee->MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    pTrustee->TrusteeForm = TRUSTEE_IS_NAME;
    pTrustee->TrusteeType = TRUSTEE_IS_UNKNOWN;
    pTrustee->ptstrName = pName;
}




//+---------------------------------------------------------------------------
//
//  Function:   BuildTrusteeWithNameA
//
//  Synopsis:   Builds a TRUSTEE from a name
//
//  Arguments:  [OUT pTrustee]      --  Trustee to initialize
//              [IN  pName]         --  Name to use for initialization
//
//  Returns:    VOID
//
//----------------------------------------------------------------------------
VOID
WINAPI
BuildTrusteeWithNameA( IN OUT PTRUSTEE_A  pTrustee,
                       IN     LPSTR       pName)
{
    pTrustee->pMultipleTrustee = NULL;
    pTrustee->MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    pTrustee->TrusteeForm = TRUSTEE_IS_NAME;
    pTrustee->TrusteeType = TRUSTEE_IS_UNKNOWN;
    pTrustee->ptstrName = pName;
}




//+---------------------------------------------------------------------------
//
//  Function:   BuildImpersonateTrusteeWithNameW
//
//  Synopsis:   Builds an impersonation TRUSTEE from existing trustees
//
//  Arguments:  [OUT pTrustee]      --  Trustee to initialize
//              [IN  pImpersonateTurstee]   The impersonation trustee
//
//  Returns:    VOID
//
//----------------------------------------------------------------------------
VOID
WINAPI
BuildImpersonateTrusteeW( IN OUT PTRUSTEE_W  pTrustee,
                          IN     PTRUSTEE_W  pImpersonateTrustee)
{
    pTrustee->pMultipleTrustee = pImpersonateTrustee;
    pTrustee->MultipleTrusteeOperation = TRUSTEE_IS_IMPERSONATE;
}




//+---------------------------------------------------------------------------
//
//  Function:   BuildImpersonateTrusteeWithNameA
//
//  Synopsis:   Builds an impersonation TRUSTEE from existing trustees
//
//  Arguments:  [OUT pTrustee]      --  Trustee to initialize
//              [IN  pImpersonateTurstee]   The impersonation trustee
//
//  Returns:    VOID
//
//----------------------------------------------------------------------------
VOID
WINAPI
BuildImpersonateTrusteeA( IN OUT PTRUSTEE_A  pTrustee,
                          IN     PTRUSTEE_A  pImpersonateTrustee)
{
    pTrustee->pMultipleTrustee = pImpersonateTrustee;
    pTrustee->MultipleTrusteeOperation = TRUSTEE_IS_IMPERSONATE;
}




//+---------------------------------------------------------------------------
//
//  Function:   BuildTrusteeWithSidW
//
//  Synopsis:   Builds a TRUSTEE from a sid
//
//  Arguments:  [OUT pTrustee]      --  Trustee to initialize
//              [IN  pSid]          --  Sid to use for initialization
//
//  Returns:    VOID
//
//----------------------------------------------------------------------------
VOID
WINAPI
BuildTrusteeWithSidW( IN OUT PTRUSTEE_W  pTrustee,
                      IN     PSID        pSid)
{
    pTrustee->pMultipleTrustee = NULL;
    pTrustee->MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    pTrustee->TrusteeForm = TRUSTEE_IS_SID;
    pTrustee->TrusteeType = TRUSTEE_IS_UNKNOWN;
    pTrustee->ptstrName = (LPWSTR)pSid;
}




//+---------------------------------------------------------------------------
//
//  Function:   BuildTrusteeWithSidA
//
//  Synopsis:   Builds a TRUSTEE from a sid
//
//  Arguments:  [OUT pTrustee]      --  Trustee to initialize
//              [IN  pSid]          --  Sid to use for initialization
//
//  Returns:    VOID
//
//----------------------------------------------------------------------------
VOID
WINAPI
BuildTrusteeWithSidA( IN OUT PTRUSTEE_A  pTrustee,
                      IN     PSID        pSid)
{
    pTrustee->pMultipleTrustee = NULL;
    pTrustee->MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    pTrustee->TrusteeForm = TRUSTEE_IS_SID;
    pTrustee->TrusteeType = TRUSTEE_IS_UNKNOWN;
    pTrustee->ptstrName = (LPSTR)pSid;
}

//+---------------------------------------------------------------------------
//
//  Function:   BuildTrusteeWithObjectsAndSidA
//
//  Synopsis:   Builds a TRUSTEE from a name
//
//  Arguments:  [OUT pTrustee]             -- Trustee to initialize
//              [IN  pObjSid]              -- ObjSid struct for initialization
//              [IN  pObjectGuid]          -- Guid pointer for initialization
//              [IN  pInheritedObjectGuid] -- Guid pointer for initialization
//              [IN  pSid]                 --  Sid to use for initialization
//
//  Returns:    VOID
//
//----------------------------------------------------------------------------

VOID
WINAPI
BuildTrusteeWithObjectsAndSidA(IN OUT PTRUSTEE_A         pTrustee,
                               IN     POBJECTS_AND_SID   pObjSid,
                               IN     GUID             * pObjectGuid,
                               IN     GUID             * pInheritedObjectGuid,
                               IN     PSID               pSid)
{
    GUID ZeroGuid = {0, 0, 0, 0};

    pTrustee->pMultipleTrustee = NULL;
    pTrustee->MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    pTrustee->TrusteeForm = TRUSTEE_IS_OBJECTS_AND_SID;
    pTrustee->TrusteeType = TRUSTEE_IS_UNKNOWN;
    pTrustee->ptstrName = (LPSTR)pObjSid;

    pObjSid->ObjectsPresent = 0;
    pObjSid->ObjectTypeGuid = ZeroGuid;
    pObjSid->InheritedObjectTypeGuid = ZeroGuid;

    if (NULL != pObjectGuid)
    {
        pObjSid->ObjectsPresent |= ACE_OBJECT_TYPE_PRESENT;
        pObjSid->ObjectTypeGuid = *pObjectGuid;
    }

    if (NULL != pInheritedObjectGuid)
    {
        pObjSid->ObjectsPresent |= ACE_INHERITED_OBJECT_TYPE_PRESENT;
        pObjSid->InheritedObjectTypeGuid = *pInheritedObjectGuid;
    }

    pObjSid->pSid = (SID *) pSid;
}


//+---------------------------------------------------------------------------
//
//  Function:   BuildTrusteeWithObjectsAndSidW
//
//  Synopsis:   Builds a TRUSTEE from a name
//
//  Arguments:  [OUT pTrustee]             -- Trustee to initialize
//              [IN  pObjSid]              -- ObjSid struct for initialization
//              [IN  pObjectGuid]          -- Guid pointer for initialization
//              [IN  pInheritedObjectGuid] -- Guid pointer for initialization
//              [IN  pSid]                 --  Sid to use for initialization
//
//  Returns:    VOID
//
//----------------------------------------------------------------------------

VOID
WINAPI
BuildTrusteeWithObjectsAndSidW(IN OUT PTRUSTEE_W         pTrustee,
                               IN     POBJECTS_AND_SID   pObjSid,
                               IN     GUID             * pObjectGuid,
                               IN     GUID             * pInheritedObjectGuid,
                               IN     PSID               pSid)
{
    GUID ZeroGuid = {0, 0, 0, 0};

    pTrustee->pMultipleTrustee = NULL;
    pTrustee->MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    pTrustee->TrusteeForm = TRUSTEE_IS_OBJECTS_AND_SID;
    pTrustee->TrusteeType = TRUSTEE_IS_UNKNOWN;
    pTrustee->ptstrName = (LPWSTR)pObjSid;

    pObjSid->ObjectsPresent = 0;
    pObjSid->ObjectTypeGuid = ZeroGuid;
    pObjSid->InheritedObjectTypeGuid = ZeroGuid;

    if (NULL != pObjectGuid)
    {
        pObjSid->ObjectsPresent |= ACE_OBJECT_TYPE_PRESENT;
        pObjSid->ObjectTypeGuid = *pObjectGuid;
    }

    if (NULL != pInheritedObjectGuid)
    {
        pObjSid->ObjectsPresent |= ACE_INHERITED_OBJECT_TYPE_PRESENT;
        pObjSid->InheritedObjectTypeGuid = *pInheritedObjectGuid;
    }

    pObjSid->pSid = (SID *) pSid;
}

//+---------------------------------------------------------------------------
//
//  Function:   BuildTrusteeWithObjectsAndSidW
//
//  Synopsis:   Builds a TRUSTEE from a name
//
//  Arguments:[OUT pTrustee]                 -- Trustee to initialize
//            [IN  pObjName]                 -- ObjName struct for initialization
//            [IN  pObjectType]              -- Object type for initialization
//            [IN  pObjectTypeName]          -- Guid name for initialization
//            [IN  pInheritedObjectTypeName] -- Guid name for initialization
//            [IN  Name]                     --  Name to use for initialization
//
//  Returns:    VOID
//
//----------------------------------------------------------------------------

VOID
WINAPI
BuildTrusteeWithObjectsAndNameA(IN OUT PTRUSTEE_A          pTrustee,
                                IN     POBJECTS_AND_NAME_A pObjName,
                                IN     SE_OBJECT_TYPE      ObjectType,
                                IN     LPSTR               ObjectTypeName,
                                IN     LPSTR               InheritedObjectTypeName,
                                IN     LPSTR               Name)
{
    pTrustee->pMultipleTrustee = NULL;
    pTrustee->MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    pTrustee->TrusteeForm = TRUSTEE_IS_OBJECTS_AND_NAME;
    pTrustee->TrusteeType = TRUSTEE_IS_UNKNOWN;
    pTrustee->ptstrName = (LPSTR)pObjName;

    pObjName->ObjectsPresent = 0;
    pObjName->ObjectType = ObjectType;
    pObjName->ObjectTypeName = ObjectTypeName;
    pObjName->InheritedObjectTypeName = InheritedObjectTypeName;

    if (NULL != ObjectTypeName)
    {
        pObjName->ObjectsPresent |= ACE_OBJECT_TYPE_PRESENT;
    }

    if (NULL != InheritedObjectTypeName)
    {
        pObjName->ObjectsPresent |= ACE_INHERITED_OBJECT_TYPE_PRESENT;
    }

    pObjName->ptstrName = Name;
}

VOID
WINAPI
BuildTrusteeWithObjectsAndNameW(IN OUT PTRUSTEE_W          pTrustee,
                                IN     POBJECTS_AND_NAME_W pObjName,
                                IN     SE_OBJECT_TYPE      ObjectType,
                                IN     LPWSTR              ObjectTypeName,
                                IN     LPWSTR              InheritedObjectTypeName,
                                IN     LPWSTR              Name)
{
    pTrustee->pMultipleTrustee = NULL;
    pTrustee->MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    pTrustee->TrusteeForm = TRUSTEE_IS_OBJECTS_AND_NAME;
    pTrustee->TrusteeType = TRUSTEE_IS_UNKNOWN;
    pTrustee->ptstrName = (LPWSTR)pObjName;

    pObjName->ObjectsPresent = 0;
    pObjName->ObjectType = ObjectType;
    pObjName->ObjectTypeName = ObjectTypeName;
    pObjName->InheritedObjectTypeName = InheritedObjectTypeName;

    if (NULL != ObjectTypeName)
    {
        pObjName->ObjectsPresent |= ACE_OBJECT_TYPE_PRESENT;
    }

    if (NULL != InheritedObjectTypeName)
    {
        pObjName->ObjectsPresent |= ACE_INHERITED_OBJECT_TYPE_PRESENT;
    }

    pObjName->ptstrName = Name;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetTrusteeNameW
//
//  Synopsis:   Gets the trustee name from the trustee
//
//  Arguments:  [IN  pTrustee]      --  Trustee to process
//
//  Returns:    Ptr to the trustee's name
//
//----------------------------------------------------------------------------
LPWSTR
WINAPI
GetTrusteeNameW( IN PTRUSTEE_W  pTrustee)
{
    if(pTrustee->ptstrName != NULL)
    {
        return(pTrustee->ptstrName);
    }
    else
    {
        return(NULL);
    }
}




//+---------------------------------------------------------------------------
//
//  Function:   GetTrusteeNameA
//
//  Synopsis:   Gets the trustee name from the trustee
//
//  Arguments:  [IN  pTrustee]      --  Trustee to process
//
//  Returns:    Ptr to the trustee's name
//
//----------------------------------------------------------------------------
LPSTR
WINAPI
GetTrusteeNameA( IN PTRUSTEE_A  pTrustee)
{
    if(pTrustee->ptstrName != NULL)
    {
        return(pTrustee->ptstrName);
    }
    else
    {
        return(NULL);
    }
}




//+---------------------------------------------------------------------------
//
//  Function:   GetTrusteeTypeW
//
//  Synopsis:   Gets the type of the trustee structure
//
//  Arguments:  [IN  pTrustee]      --  Trustee to process
//
//  Returns:    TrusteeType
//
//----------------------------------------------------------------------------
TRUSTEE_TYPE
WINAPI
GetTrusteeTypeW( IN PTRUSTEE_W  pTrustee)
{
    if(pTrustee  != NULL)
    {
        return(pTrustee->TrusteeType);
    }

    return(TRUSTEE_IS_UNKNOWN);
}




//+---------------------------------------------------------------------------
//
//  Function:   GetTrusteeTypeA
//
//  Synopsis:   Gets the type of the trustee structure
//
//  Arguments:  [IN  pTrustee]      --  Trustee to process
//
//  Returns:    TrusteeType
//
//----------------------------------------------------------------------------
TRUSTEE_TYPE
WINAPI
GetTrusteeTypeA( IN PTRUSTEE_A  pTrustee)
{
    if(pTrustee  != NULL)
    {
        return(pTrustee->TrusteeType);
    }

    return(TRUSTEE_IS_UNKNOWN);
}




//+---------------------------------------------------------------------------
//
//  Function:   GetTrusteeFormW
//
//  Synopsis:   Gets the form of the trustee structure
//
//  Arguments:  [IN  pTrustee]      --  Trustee to process
//
//  Returns:    TrusteeForm
//
//----------------------------------------------------------------------------
TRUSTEE_FORM
WINAPI
GetTrusteeFormW( IN PTRUSTEE_W  pTrustee)
{
    if(pTrustee != NULL)
    {
        return(pTrustee->TrusteeForm);
    }

    return(TRUSTEE_BAD_FORM);
}




//+---------------------------------------------------------------------------
//
//  Function:   GetTrusteeFormA
//
//  Synopsis:   Gets the form of the trustee structure
//
//  Arguments:  [IN  pTrustee]      --  Trustee to process
//
//  Returns:    TrusteeForm
//
//----------------------------------------------------------------------------
TRUSTEE_FORM
WINAPI
GetTrusteeFormA( IN PTRUSTEE_A  pTrustee)
{
    if(pTrustee != NULL)
    {
        return(pTrustee->TrusteeForm);
    }

    return(TRUSTEE_BAD_FORM);
}




//+---------------------------------------------------------------------------
//
//  Function:   GetMultipleTrusteeOperationW
//
//  Synopsis:   Gets the multiple trustee operation of the trustee structure
//
//  Arguments:  [IN  pTrustee]      --  Trustee to process
//
//  Returns:    mutliple trustee operation
//
//----------------------------------------------------------------------------
MULTIPLE_TRUSTEE_OPERATION
WINAPI
GetMultipleTrusteeOperationW( IN PTRUSTEE_W  pTrustee)
{
    if(pTrustee != NULL)
    {
        return(pTrustee->MultipleTrusteeOperation);
    }
    return(NO_MULTIPLE_TRUSTEE);
}




//+---------------------------------------------------------------------------
//
//  Function:   GetMultipleTrusteeOperationA
//
//  Synopsis:   Gets the multiple trustee operation of the trustee structure
//
//  Arguments:  [IN  pTrustee]      --  Trustee to process
//
//  Returns:    mutliple trustee operation
//
//----------------------------------------------------------------------------
MULTIPLE_TRUSTEE_OPERATION
WINAPI
GetMultipleTrusteeOperationA( IN PTRUSTEE_A  pTrustee)
{
    if(pTrustee != NULL)
    {
        return(pTrustee->MultipleTrusteeOperation);
    }
    return(NO_MULTIPLE_TRUSTEE);
}




//+---------------------------------------------------------------------------
//
//  Function:   GetMultipleTrusteeW
//
//  Synopsis:   Gets the impersonate trustee from the trustee structure
//
//  Arguments:  [IN  pTrustee]      --  Trustee to process
//
//  Returns:    Impersonate trustee
//
//----------------------------------------------------------------------------
PTRUSTEE_W
WINAPI
GetMultipleTrusteeW( IN PTRUSTEE_W  pTrustee)
{
    if(pTrustee != NULL)
    {
        return(pTrustee->pMultipleTrustee);
    }

    return(NULL);
}




//+---------------------------------------------------------------------------
//
//  Function:   GetMultipleTrusteeA
//
//  Synopsis:   Gets the impersonate trustee from the trustee structure
//
//  Arguments:  [IN  pTrustee]      --  Trustee to process
//
//  Returns:    Impersonate trustee
//
//----------------------------------------------------------------------------
PTRUSTEE_A
WINAPI
GetMultipleTrusteeA( IN PTRUSTEE_A  pTrustee)
{
    if(pTrustee != NULL)
    {
        return(pTrustee->pMultipleTrustee);
    }

    return(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\advapi\tlogon.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       logon2.c
//
//  Contents:   Logon test app
//
//  Classes:
//
//  Functions:
//
//  History:    6-20-94   richardw   Created
//
//----------------------------------------------------------------------------



#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>

#include <windows.h>

#define DUMP_TOKEN  1
#define DUMP_HEX    2


char *User = NULL;
char *Domain = NULL;
char *Password = NULL;
char *SecPackage = NULL;
char *Cmd = NULL;

DWORD   fLogon = 0;
DWORD   fMe = 0;
DWORD   fService = 0;
DWORD   fCookie = 0;
FILE *  fOut;
DWORD   Threads;
DWORD   fDup = 0;
DWORD   LogonType = LOGON32_LOGON_INTERACTIVE;

char *  ImpLevels[] = { "Anonymous", "Identity", "Impersonation", "Delegation"};

char *  LogonTypes[] = { "Invalid", "Invalid", "Interactive", "Network", "Batch", "Service", "Proxy" };

void DumpToken(HANDLE hToken);

void
DoArgs(int argc,
        char **argv)

{
    int i;

    Threads = 1;

    if (argc < 3)
    {
        fprintf( fOut,"usage: %s <name> <domain> [-p pw] [-f flags] [-s] [-d] [-x cmd]\n", argv[0]);
        fprintf( fOut,"Tests logon path\n");
        fprintf( fOut," -p     \tOverride password\n");
        fprintf( fOut," -D     \tDump token\n");
        fprintf( fOut," -d     \tduplicate\n");
        fprintf( fOut," -s     \tLogon as service\n");
        fprintf( fOut," -x cmd \tStart cmd as user\n");
        fprintf( fOut," -o file\tSend output to file\n");
        fprintf( fOut," -t #   \tHit with # threads at once\n");
        fprintf( fOut," -l type\tLogon type\n");
        exit(1);
    }

    for (i = 1; i < argc ; i++ )
    {
        if (*argv[i] == '-')
        {
            switch (*(argv[i]+1))
            {
                case 'f':
                    fLogon = atoi(argv[++i]);
                    break;

                case 'd':
                    fDup = 1;
                    break;

                case 'D':
                    fMe |= DUMP_TOKEN;
                    break;

                case 'x':
                    Cmd = argv[++i];
                    break;

                case 'p':
                    Password = argv[++i];
                    break;

                case 't':
                    Threads = atoi(argv[++i]);
                    break;

                case 's':
                    LogonType = LOGON32_LOGON_SERVICE;
                    break;

                case 'l':
                    ++i;
                    if (argv[i] == NULL )
                    {
                        fprintf(fOut, "No logon type specified\n");
                        exit(1);
                    }
                    for (LogonType = 2 ;
                         LogonType < sizeof(LogonTypes) / sizeof(PSTR) ;
                         LogonType ++ )
                    {
                        if (_stricmp( LogonTypes[LogonType], argv[i]) == 0 )
                        {
                            break;
                        }
                    }

                    if (LogonType == (sizeof(LogonTypes) / sizeof(PSTR) ))
                    {
                        fprintf(fOut, "Invalid logon type '%s'\n", argv[i]);
                        exit(1);
                    }
                    break;

                case 'o':
                    fOut = fopen(argv[++i], "w");
                    if (!fOut)
                    {
                        fOut = stderr;
                    }
                    break;

                default:
                    fprintf( fOut,"Invalid switch %s\n", argv[i]);
                    exit(1);
            }
        }
        else
        {
            if (!User)
                User = argv[i];
             else
                if (!Domain)
                    Domain = argv[i];
        }
    }

    if (!Password)
        Password = User;
}

DWORD
DoIt(
    PVOID   pv)
{
    NTSTATUS         scRet, SubStatus, Status;
    PISID                   pSid;
    LUID                    Luid;
    TOKEN_GROUPS            TokenGroups;
    STRING                  sMe;
    HANDLE                  hToken;
    HANDLE                  hImp;
    HANDLE                  hDup;
    STRING                  sPackage;
    ULONG                   Package;
    LUID                    LogonId;
    TOKEN_SOURCE            TokenSource;
    char                    ImpersonateName[MAX_PATH];
    DWORD                   cbImpersonateName = MAX_PATH;
    STARTUPINFO             si;
    PROCESS_INFORMATION     pi;
    POBJECT_TYPE_INFORMATION    pTypeInfo;
    POBJECT_NAME_INFORMATION    pNameInfo;
    POBJECT_BASIC_INFORMATION   pBasicInfo;
    UCHAR   Buffer[1024];
    HANDLE  hWait;

    hWait = (HANDLE) pv;

    if (hWait != NULL)
    {
        WaitForSingleObjectEx( hWait, INFINITE, FALSE );
    }

    fprintf( fOut,"Logging on %s to %s\n", User, Domain);

    //
    // Copy the strings into the right places:
    //

    if (!LogonUserA(User, Domain, Password,
                LogonType,
                LOGON32_PROVIDER_DEFAULT, &hToken))
    {
        fprintf( fOut,"FAILED to logon, GetLastError is %d\n", GetLastError());
    }

    else
    {
        if (fMe & DUMP_TOKEN)
            DumpToken(hToken);

        if (!ImpersonateLoggedOnUser(hToken))
        {
            fprintf( fOut, "FAILED to impersonate, GetLastError is %d\n", GetLastError());
        }

        GetUserName(ImpersonateName, &cbImpersonateName);
        if (fDup)
        {
            if (OpenThreadToken( GetCurrentThread(),
                            MAXIMUM_ALLOWED,
                            TRUE,
                            &hImp))
            {
                DumpToken( hImp );
                if (DuplicateTokenEx(   hImp,
                                        MAXIMUM_ALLOWED,
                                        NULL,
                                        SecurityImpersonation,
                                        TokenPrimary,
                                        &hDup ) )
                {
                    fprintf( fOut, "Success!  Duplicated that token!\n");
                    DumpToken( hToken );
                    CloseHandle( hToken );
                }
                else
                {
                    fprintf( fOut, "DuplicateTokenEx FAILED, %d\n", GetLastError() );

                }

                CloseHandle( hImp );

            }
            else
            {
                fprintf( fOut, "OpenThreadToken FAILED, %d\n", GetLastError() );
            }

        }
        RevertToSelf();
        fprintf( fOut,"Hey look!  I'm %s\n", ImpersonateName);

        if (Cmd)
        {
            fprintf( fOut,"Starting '%s' as user\n", Cmd);
            ZeroMemory(&si, sizeof(si));
            si.cb = sizeof(si);
            if (!CreateProcessAsUser(hToken, NULL, Cmd, NULL, NULL, FALSE,
                                CREATE_SEPARATE_WOW_VDM, NULL,
                                NULL, &si, &pi))
            {
                fprintf( fOut,"FAILED, %d\n", GetLastError());
            }

            fprintf( fOut,"Process Info:\n");
            fprintf( fOut,"  Process Handle    \t%x\n", pi.hProcess );
            fprintf( fOut,"  Thread Handle     \t%x\n", pi.hThread );
            fprintf( fOut,"  Process Id        \t%d\n", pi.dwProcessId );
            fprintf( fOut,"  Thread Id         \t%d\n", pi.dwThreadId );

            ZeroMemory( Buffer, 1024 );

            pTypeInfo = (POBJECT_TYPE_INFORMATION) Buffer;
            pNameInfo = (POBJECT_NAME_INFORMATION) Buffer;
            pBasicInfo = (POBJECT_BASIC_INFORMATION) Buffer;

            Status = NtQueryObject( pi.hProcess, ObjectTypeInformation, pTypeInfo, 1024, NULL );

            if (NT_SUCCESS(Status))
            {
                fprintf( fOut,"  Type         \t%ws\n", pTypeInfo->TypeName.Buffer );
            }

            ZeroMemory( Buffer, 1024 );
            Status = NtQueryObject(pi.hProcess, ObjectBasicInformation, pBasicInfo, 1024, NULL);
            if (NT_SUCCESS(Status))
            {
                fprintf( fOut,"  Attributes   \t%#x\n", pBasicInfo->Attributes );
                fprintf( fOut,"  GrantedAccess\t%#x\n", pBasicInfo->GrantedAccess );
                fprintf( fOut,"  HandleCount  \t%d\n", pBasicInfo->HandleCount );
                fprintf( fOut,"  PointerCount \t%d\n", pBasicInfo->PointerCount );
            }
            else
            {
                fprintf( fOut,"FAILED %x to query basic info\n", Status );
            }

            ZeroMemory( Buffer, 1024 );
            Status = NtQueryObject( pi.hProcess, ObjectNameInformation, pNameInfo, 1024, NULL );

            if (NT_SUCCESS(Status))
            {
                fprintf( fOut,"  Name         \t%ws\n", pNameInfo->Name.Buffer);
            }
            else
            {
                fprintf( fOut,"FAILED %x to query name info\n", Status );
            }

            CloseHandle( pi.hProcess );
            CloseHandle( pi.hThread );

        }
        CloseHandle(hToken);

    }



    return(0);

}


__cdecl
main (int argc, char *argv[])
{
    HANDLE  hWait;
    DWORD   i;
    DWORD   tid;
    HANDLE  hThreads[64];

    fOut = stdout;

    //
    // Get params
    //
    DoArgs(argc, argv);

    if (Threads == 1)
    {
        DoIt(NULL);

    }
    else
    {
        if (Threads > 64 )
        {
            Threads = 64;
        }

        hWait = CreateEvent( NULL, TRUE, FALSE, NULL );

        for (i = 0; i < Threads ; i++ )
        {
            hThreads[i] = CreateThread( NULL, 0, DoIt, hWait, 0, &tid);
        }

        SetEvent( hWait );

        WaitForMultipleObjectsEx( Threads, hThreads, TRUE, INFINITE, FALSE );

        for ( i = 0 ; i < Threads ; i++ )
        {
            CloseHandle( hThreads[i] );
        }
    }


    return( 0 );
}


#define SATYPE_USER     1
#define SATYPE_GROUP    2
#define SATYPE_PRIV     3


ULONG   PID;

void
DumpSid(PSID    pxSid)
{
    PISID   pSid = pxSid;
    int i, j =0;


    fprintf( fOut,"  S-%d-", pSid->Revision);
    for (i = 0;i < 6 ; i++ )
    {
        if (j)
        {
            fprintf( fOut,"%x", pSid->IdentifierAuthority.Value[i]);
        }
        else
        {
            if (pSid->IdentifierAuthority.Value[i])
            {
                j = 1;
                fprintf( fOut,"%x", pSid->IdentifierAuthority.Value[i]);
            }
        }
        if (i==4)
        {
            j = 1;
        }
    }
    for (i = 0; i < pSid->SubAuthorityCount ; i++ )
    {
        fprintf( fOut,(fMe & DUMP_HEX ? "-%x" : "-%lu"), pSid->SubAuthority[i]);
    }
}

void
DumpSidAttr(PSID_AND_ATTRIBUTES pSA,
            int                 SAType)
{
    DumpSid(pSA->Sid);

    if (SAType == SATYPE_GROUP)
    {
        fprintf( fOut,"\tAttributes - ");
        if (pSA->Attributes & SE_GROUP_MANDATORY)
        {
            fprintf( fOut,"Mandatory ");
        }
        if (pSA->Attributes & SE_GROUP_ENABLED_BY_DEFAULT)
        {
            fprintf( fOut,"Default ");
        }
        if (pSA->Attributes & SE_GROUP_ENABLED)
        {
            fprintf( fOut,"Enabled ");
        }
        if (pSA->Attributes & SE_GROUP_OWNER)
        {
            fprintf( fOut,"Owner ");
        }
        if (pSA->Attributes & SE_GROUP_LOGON_ID)
        {
            fprintf( fOut,"LogonId ");
        }
    }

}

CHAR *  GetPrivName(PLUID   pPriv)
{
    switch (pPriv->LowPart)
    {
        case SE_CREATE_TOKEN_PRIVILEGE:
            return(SE_CREATE_TOKEN_NAME);
        case SE_ASSIGNPRIMARYTOKEN_PRIVILEGE:
            return(SE_ASSIGNPRIMARYTOKEN_NAME);
        case SE_LOCK_MEMORY_PRIVILEGE:
            return(SE_LOCK_MEMORY_NAME);
        case SE_INCREASE_QUOTA_PRIVILEGE:
            return(SE_INCREASE_QUOTA_NAME);
        case SE_UNSOLICITED_INPUT_PRIVILEGE:
            return(SE_UNSOLICITED_INPUT_NAME);
        case SE_TCB_PRIVILEGE:
            return(SE_TCB_NAME);
        case SE_SECURITY_PRIVILEGE:
            return(SE_SECURITY_NAME);
        case SE_TAKE_OWNERSHIP_PRIVILEGE:
            return(SE_TAKE_OWNERSHIP_NAME);
        case SE_LOAD_DRIVER_PRIVILEGE:
            return(SE_LOAD_DRIVER_NAME);
        case SE_SYSTEM_PROFILE_PRIVILEGE:
            return(SE_SYSTEM_PROFILE_NAME);
        case SE_SYSTEMTIME_PRIVILEGE:
            return(SE_SYSTEMTIME_NAME);
        case SE_PROF_SINGLE_PROCESS_PRIVILEGE:
            return(SE_PROF_SINGLE_PROCESS_NAME);
        case SE_INC_BASE_PRIORITY_PRIVILEGE:
            return(SE_INC_BASE_PRIORITY_NAME);
        case SE_CREATE_PAGEFILE_PRIVILEGE:
            return(SE_CREATE_PAGEFILE_NAME);
        case SE_CREATE_PERMANENT_PRIVILEGE:
            return(SE_CREATE_PERMANENT_NAME);
        case SE_BACKUP_PRIVILEGE:
            return(SE_BACKUP_NAME);
        case SE_RESTORE_PRIVILEGE:
            return(SE_RESTORE_NAME);
        case SE_SHUTDOWN_PRIVILEGE:
            return(SE_SHUTDOWN_NAME);
        case SE_DEBUG_PRIVILEGE:
            return(SE_DEBUG_NAME);
        case SE_AUDIT_PRIVILEGE:
            return(SE_AUDIT_NAME);
        case SE_SYSTEM_ENVIRONMENT_PRIVILEGE:
            return(SE_SYSTEM_ENVIRONMENT_NAME);
        case SE_CHANGE_NOTIFY_PRIVILEGE:
            return(SE_CHANGE_NOTIFY_NAME);
        case SE_REMOTE_SHUTDOWN_PRIVILEGE:
            return(SE_REMOTE_SHUTDOWN_NAME);
        default:
            return("Unknown Privilege");
    }
}

void
DumpLuidAttr(PLUID_AND_ATTRIBUTES   pLA,
             int                    LAType)
{
    char *  PrivName;

    fprintf( fOut,"0x%x%08x", pLA->Luid.HighPart, pLA->Luid.LowPart);
    fprintf( fOut," %-32s", GetPrivName(&pLA->Luid));

    if (LAType == SATYPE_PRIV)
    {
        fprintf( fOut,"  Attributes - ");
        if (pLA->Attributes & SE_PRIVILEGE_ENABLED)
        {
            fprintf( fOut,"Enabled ");
        }

        if (pLA->Attributes & SE_PRIVILEGE_ENABLED_BY_DEFAULT)
        {
            fprintf( fOut,"Default ");
        }
    }

}

void
DumpToken(HANDLE    hToken)
{
    PTOKEN_USER         pTUser;
    PTOKEN_GROUPS       pTGroups;
    PTOKEN_PRIVILEGES   pTPrivs;
    PTOKEN_OWNER        pTOwner;
    PTOKEN_PRIMARY_GROUP    pTPrimaryGroup;
    TOKEN_STATISTICS    TStats;
    ULONG               cbInfo;
    ULONG               cbRetInfo;
    NTSTATUS            status;
    DWORD               i;


    pTUser = malloc(256);


    status = GetTokenInformation(   hToken,
                                        TokenUser,
                                        pTUser,
                                        256,
                                        &cbRetInfo);

    if (!NT_SUCCESS(status))
    {
        fprintf( fOut,"FAILED querying token, %#x\n", status);
        return;
    }

    fprintf( fOut,"User\n  ");
    DumpSidAttr(&pTUser->User, SATYPE_USER);

    fprintf( fOut,"\nGroups");
    pTGroups = malloc(4096);
    status = GetTokenInformation(   hToken,
                                        TokenGroups,
                                        pTGroups,
                                        4096,
                                        &cbRetInfo);

    for (i = 0; i < pTGroups->GroupCount ; i++ )
    {
        fprintf( fOut,"\n %02d ", i);
        DumpSidAttr(&pTGroups->Groups[i], SATYPE_GROUP);
    }

    pTPrimaryGroup  = malloc(128);
    status = GetTokenInformation(   hToken,
                                        TokenPrimaryGroup,
                                        pTPrimaryGroup,
                                        128,
                                        &cbRetInfo);

    fprintf( fOut,"\nPrimary Group:\n  ");
    DumpSid(pTPrimaryGroup->PrimaryGroup);

    fprintf( fOut,"\nPrivs\n");
    pTPrivs = malloc(4096);
    status = GetTokenInformation(   hToken,
                                        TokenPrivileges,
                                        pTPrivs,
                                        4096,
                                        &cbRetInfo);

    for (i = 0; i < pTPrivs->PrivilegeCount ; i++ )
    {
        fprintf( fOut,"\n %02d ", i);
        DumpLuidAttr(&pTPrivs->Privileges[i], SATYPE_PRIV);
    }

    status = GetTokenInformation(   hToken,
                                        TokenStatistics,
                                        &TStats,
                                        sizeof(TStats),
                                        &cbRetInfo);

    fprintf( fOut, "\n\nAuth ID  %x:%x\n", TStats.AuthenticationId.HighPart, TStats.AuthenticationId.LowPart);
    fprintf( fOut, "TokenId     %x:%x\n", TStats.TokenId.HighPart, TStats.TokenId.LowPart);
    fprintf( fOut, "TokenType   %s\n", TStats.TokenType == TokenPrimary ? "Primary" : "Impersonation");
    fprintf( fOut, "Imp Level   %s\n", ImpLevels[ TStats.ImpersonationLevel ]);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\advapi\tuser.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    tuser.c

Abstract:

    This module tests windows GetUserName API.

Author:

    Dave Snipp (DaveSn) 27-May-92

Revision History:

--*/

#include <windows.h>
#include <stdio.h>

CHAR BufferA[256];
WCHAR BufferW[256];

DWORD cbBufA = 256, cbBufW = 256;

int
main (void)
{
    if (GetUserNameW(BufferW, &cbBufW))
        printf("UniCode UserName : %ws\nNo of Characters = %d\n", BufferW, cbBufW);
    else
        printf("UniCode Failed : 0x%0x\n", GetLastError());

    if (GetUserNameA(BufferA, &cbBufA))
        printf("Ansi UserName : %s\nNo of Characters = %d\n", BufferA, cbBufA);
    else
        printf("Ansi Failed : 0x%0x\n", GetLastError());

    cbBufW=0;

    if (!GetUserNameW(BufferW, &cbBufW)) {
        printf("GetUserNameW requires %d size buffer\n", cbBufW);
    } else
        printf("GetUserNameW should not have succeeded\n");

    cbBufA=0;

    if (!GetUserNameA(BufferA, &cbBufA)) {
        printf("GetUserNameA requires %d size buffer\n", cbBufA);
    } else
        printf("GetUserNameA should not have succeeded\n");

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\accctrl2\src\marta.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1996.
//
//  File:       MARTA.CXX
//
//  Contents:   Multi-provider support functions
//
//  History:    14-Sep-96       MacM        Created
//
//----------------------------------------------------------------------------
#define _ADVAPI32_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>
#include <accctrl.h>
#include <aclapi.h>
#include <marta.h>

//
// Global definitions
//
ACCPROV_PROVIDERS    gAccProviders;

//+---------------------------------------------------------------------------
//
//  Function:   AccProvpLoadDllEntryPoints
//
//  Synopsis:   This function will load all of the entry points for the
//              given provider dll.
//
//  Arguments:  [IN  pProvInfo]     --  Info on the provider
//
//  Returns:    ERROR_SUCCESS       --  Success
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
AccProvpLoadDllEntryPoints(PACCPROV_PROV_INFO   pProvInfo)
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // First, GrantAccess
    //
    LOAD_ENTRYPT(pProvInfo->pfGrantAccess,
                 pfAccProvAddRights,
                 pProvInfo->hDll,
                 ACC_PROV_GRANT_ACCESS);

    //
    // Now, SetAccess
    //
    LOAD_ENTRYPT(pProvInfo->pfSetAccess,
                 pfAccProvSetRights,
                 pProvInfo->hDll,
                 ACC_PROV_SET_ACCESS);

    //
    // Then revoke
    //
    LOAD_ENTRYPT(pProvInfo->pfRevokeAccess,
                 pfAccProvRevoke,
                 pProvInfo->hDll,
                 ACC_PROV_REVOKE_ACCESS);

    LOAD_ENTRYPT(pProvInfo->pfRevokeAudit,
                 pfAccProvRevoke,
                 pProvInfo->hDll,
                 ACC_PROV_REVOKE_AUDIT);

    //
    // Next is GetRights
    //
    LOAD_ENTRYPT(pProvInfo->pfGetRights,
                 pfAccProvGetRights,
                 pProvInfo->hDll,
                 ACC_PROV_GET_ALL);

    //
    //  Is object accessible?
    //
    LOAD_ENTRYPT(pProvInfo->pfObjAccess,
                 pfAccProvObjAccess,
                 pProvInfo->hDll,
                 ACC_PROV_OBJ_ACCESS);

    LOAD_ENTRYPT(pProvInfo->pfhObjAccess,
                 pfAccProvHandleObjAccess,
                 pProvInfo->hDll,
                 ACC_PROV_HOBJ_ACCESS);

    //
    // Is access allowed?
    //
    LOAD_ENTRYPT(pProvInfo->pfTrusteeAccess,
                 pfAccProvTrusteeAccess,
                 pProvInfo->hDll,
                 ACC_PROV_ACCESS);

    //
    // Is access audited?
    //
    LOAD_ENTRYPT(pProvInfo->pfAudit,
                 pfAccProvAccessAudit,
                 pProvInfo->hDll,
                 ACC_PROV_AUDIT);

    //
    // Object Info
    //
    LOAD_ENTRYPT(pProvInfo->pfObjInfo,
                 pfAccProvGetObjTypeInfo,
                 pProvInfo->hDll,
                 ACC_PROV_OBJ_INFO);

    //
    // Cancel
    //
    LOAD_ENTRYPT(pProvInfo->pfCancel,
                 pfAccProvCancelOp,
                 pProvInfo->hDll,
                 ACC_PROV_CANCEL);
    //
    // Get the results
    //
    LOAD_ENTRYPT(pProvInfo->pfResults,
                 pfAccProvGetResults,
                 pProvInfo->hDll,
                 ACC_PROV_GET_RESULTS);

    //
    // Load the OPTIONAL handle functions, if they exist
    //
    if((pProvInfo->fProviderCaps & ACTRL_CAP_SUPPORTS_HANDLES) != 0)
    {
        LOAD_ENTRYPT(pProvInfo->pfhGrantAccess,
                     pfAccProvHandleAddRights,
                     pProvInfo->hDll,
                     ACC_PROV_HGRANT_ACCESS);

        LOAD_ENTRYPT(pProvInfo->pfhSetAccess,
                     pfAccProvHandleSetRights,
                     pProvInfo->hDll,
                     ACC_PROV_HSET_ACCESS);

        LOAD_ENTRYPT(pProvInfo->pfhRevokeAccess,
                     pfAccProvHandleRevoke,
                     pProvInfo->hDll,
                     ACC_PROV_HREVOKE_AUDIT);

        LOAD_ENTRYPT(pProvInfo->pfhRevokeAudit,
                     pfAccProvHandleRevoke,
                     pProvInfo->hDll,
                     ACC_PROV_HREVOKE_ACCESS);

        LOAD_ENTRYPT(pProvInfo->pfhGetRights,
                     pfAccProvHandleGetRights,
                     pProvInfo->hDll,
                     ACC_PROV_HGET_ALL);

        LOAD_ENTRYPT(pProvInfo->pfhTrusteeAccess,
                     pfAccProvHandleTrusteeAccess,
                     pProvInfo->hDll,
                     ACC_PROV_HACCESS);

        LOAD_ENTRYPT(pProvInfo->pfhAudit,
                     pfAccProvHandleAccessAudit,
                     pProvInfo->hDll,
                     ACC_PROV_HAUDIT);

        LOAD_ENTRYPT(pProvInfo->pfhObjInfo,
                     pfAccProvHandleGetObjTypeInfo,
                     pProvInfo->hDll,
                     ACC_PROV_HOBJ_INFO);
    }

    SetLastError(ERROR_SUCCESS);

Error:
    dwErr = GetLastError();

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccProvpGetStringFromRegistry
//
//  Synopsis:   This function will read the indicated string from the
//              registry.  A buffer is allocated to hold the destination
//              string.  If the value being read is a REG_EXPAND_SZ type
//              string, it will be expanded before being returned.
//
//  Arguments:  [IN  hkReg]         --  Open registry handle
//              [IN  pwszRegKey]    --  Which key to read
//              [OUT ppwszValue]    --  Where the read string is to be
//                                      returned.
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//
//  Notes:      Memory is allocated with AccAlloc and should be freed with
//              LocalFree.
//
//----------------------------------------------------------------------------
DWORD
AccProvpGetStringFromRegistry(HKEY      hkReg,
                              PWSTR     pwszRegKey,
                              PWSTR    *ppwszValue)
{
    DWORD   dwErr = ERROR_SUCCESS;

    DWORD   dwType, dwSize = 0;

    //
    // First, get the size of the string
    //
    dwErr = RegQueryValueEx(hkReg,
                            pwszRegKey,
                            NULL,
                            &dwType,
                            NULL,
                            &dwSize);
    if(dwErr == ERROR_SUCCESS)
    {
        //
        // Allocate the string...
        //
        *ppwszValue = (PWSTR)LocalAlloc(LMEM_FIXED, dwSize);
        if(*ppwszValue == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            //
            // Call it again and get the actual value...
            //
            dwErr = RegQueryValueEx(hkReg,
                                    pwszRegKey,
                                    NULL,
                                    &dwType,
                                    (PBYTE)*ppwszValue,
                                    &dwSize);

            if(dwErr == ERROR_SUCCESS)
            {
                //
                // If it's a REG_EXPAND_SZ string, we'll want to go ahead
                // and do the expansion on it...
                //
                if(dwType == REG_EXPAND_SZ)
                {
                    DWORD   dwLength  = 0;

                    PWSTR   pwszDest = NULL;
                    dwLength = ExpandEnvironmentStrings(*ppwszValue,
                                                        pwszDest,
                                                        0);
                    if(dwLength == 0)
                    {
                        dwErr = GetLastError();
                    }
                    else
                    {
                        pwszDest = (PWSTR)LocalAlloc(LMEM_FIXED,
                                                    dwLength * sizeof(WCHAR));
                        if(pwszDest == NULL)
                        {
                            dwErr = ERROR_NOT_ENOUGH_MEMORY;
                        }
                        else
                        {
                            dwLength = ExpandEnvironmentStrings(*ppwszValue,
                                                                pwszDest,
                                                                dwLength);
                            if(dwLength == 0)
                            {
                                dwErr = GetLastError();
                                LocalFree(pwszDest);
                            }
                            else
                            {
                                LocalFree(*ppwszValue);
                                *ppwszValue = pwszDest;
                            }
                        }
                    }
                }
            }
        }

        if(dwErr != ERROR_SUCCESS)
        {
            //
            // Something failed, so clean up...
            //
            LocalFree(*ppwszValue);
        }

    }

    return(dwErr);
}



//+---------------------------------------------------------------------------
//
//  Function:   AccProvpAllocateProviderList
//
//  Synopsis:   This function will allocate and initialize the list of
//              provider info structs
//
//  Arguments:  [IN OUT  pProviders]    Provider info struct that has
//                                      provider list to be allocated
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD
AccProvpAllocateProviderList(IN OUT  PACCPROV_PROVIDERS  pProviders)
{
    DWORD   dwErr = ERROR_SUCCESS;

    pProviders->pProvList = (PACCPROV_PROV_INFO)
                            LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                                       sizeof(ACCPROV_PROV_INFO) *
                                                      pProviders->cProviders);
    if(pProviders->pProvList == NULL)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccProvpFreeProvderList
//
//  Synopsis:   This function will cleanup and deallocate a list of providers
//
//  Arguments:  [IN  pProviders]    --  Information on the list of proivders
//
//  Returns:    VOID
//
//----------------------------------------------------------------------------
VOID
AccProvpFreeProviderList(IN  PACCPROV_PROVIDERS  pProviders)
{
    if(pProviders != NULL && pProviders->cProviders != 0 &&
                                               pProviders->pProvList != NULL)
    {
        ULONG iIndex;
        PACCPROV_PROV_INFO pCurrent = pProviders->pProvList;
        for(iIndex = 0; iIndex < pProviders->cProviders; iIndex++)
        {
            if(pCurrent->pwszProviderName != NULL)
            {
                LocalFree(pCurrent->pwszProviderName);
            }

            if(pCurrent->pwszProviderPath != NULL)
            {
                LocalFree(pCurrent->pwszProviderPath);
            }

            if(pCurrent->hDll != NULL)
            {
                FreeLibrary(pCurrent->hDll);
            }

            pCurrent++;
        }

        LocalFree(pProviders->pProvList);
    }
}




//+---------------------------------------------------------------------------
//
//  Function:   AccProvpGetProviderCapabilities
//
//  Synopsis:   Gets the provider capabilities.  This is accomplished by
//              loading the specified DLL, and then calling the
//              appropriate entry point
//
//  Arguments:  IN  [pProvInfo]     --  Information about the provider DLL on
//                                      input.  This information is updated
//                                      during the course of this call
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_MOD_NOT_FOUND --  Something went wrong.  Either the
//                                      given module path was invalid or
//                                      we had no module path at all...
//
//----------------------------------------------------------------------------
DWORD
AccProvpGetProviderCapabilities(IN  PACCPROV_PROV_INFO  pProvInfo)
{
    DWORD   dwErr = ERROR_SUCCESS;


    //
    // We can tell if the capabilities have been read by examining
    // the the state of some of the provider info.  Namely, if the provider
    // path is not null and the module handle is, we know we haven't done
    // a load yet.  If the converse of that is true, than a load has already
    // ben done.  If they are both NULL, then we are in trouble, so we'll
    // simply fail it.
    //
    if(pProvInfo->hDll == NULL)
    {
        if(pProvInfo->pwszProviderPath == NULL)
        {
            dwErr = ERROR_MOD_NOT_FOUND;
        }
        else
        {
            //
            // Ok, we need to load the provider DLL and call the capabilities
            // functions
            //

            pProvInfo->hDll = LoadLibrary(pProvInfo->pwszProviderPath);
            if(pProvInfo->hDll == NULL)
            {
                dwErr = GetLastError();
            }
            else
            {
                pfAccProvGetCaps pfGetCaps;

                //
                // Now, that we have the provider loaded, we can delete the
                // provider path, since we won't need that again...
                //
                LocalFree(pProvInfo->pwszProviderPath);
                pProvInfo->pwszProviderPath = NULL;

                pfGetCaps =
                          (pfAccProvGetCaps)GetProcAddress(pProvInfo->hDll,
                                                           ACC_PROV_GET_CAPS);
                if(pfGetCaps == NULL)
                {
                    dwErr = GetLastError();
                }
                else
                {
                    //
                    // Now, it's a simple matter to get the capabilities
                    //
                    __try
                    {
                        (*pfGetCaps)(ACTRL_CLASS_GENERAL,
                                     &(pProvInfo->fProviderCaps));
                    }
                    __except(EXCEPTION_EXECUTE_HANDLER)
                    {
                        dwErr = ERROR_BAD_PROVIDER;
                    }

                    //
                    // Don't need to keep the provider path anymore
                    //
                    LocalFree(pProvInfo->pwszProviderPath);
                    pProvInfo->pwszProviderPath = NULL;
                }
            }
        }
    }


    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccProvpInitProviders
//
//  Synopsis:   Initializes all of the information regarding the providers.
//              This happens via reading the registry and creating the
//              necessary structures.
//
//  Arguments:  [IN OUT pProviders] --  Structure to fill in with all of the
//                                      provider information.
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD
AccProvpInitProviders(IN OUT PACCPROV_PROVIDERS  pProviders)
{
    DWORD   dwErr = ERROR_SUCCESS;
    HKEY    hkReg = NULL;

    EnterCriticalSection( &gAccProviders.ProviderLoadLock );

    //
    // If they've already been loaded, just return
    //
    if((pProviders->fOptions & ACC_PROV_PROVIDERS_LOADED) != 0)
    {
        LeaveCriticalSection( &gAccProviders.ProviderLoadLock );
        return(ERROR_SUCCESS);
    }

    //
    // Get the list of supported providers.  We'll do this by reading the
    // provider order
    //
    dwErr = RegOpenKey(HKEY_LOCAL_MACHINE,
                       ACC_PROV_REG_ROOT,
                       &hkReg);
    if(dwErr == ERROR_SUCCESS)
    {
        PWSTR   pwszOrder = NULL;

        dwErr = AccProvpGetStringFromRegistry(hkReg,
                                              ACC_PROV_REG_ORDER,
                                              &pwszOrder);
        if(dwErr == ERROR_SUCCESS)
        {
            //
            // Go through and count the number of entries...
            //
            PWSTR   pwszNextProv = pwszOrder;
            ULONG   cItems = 0;

            //
            // Protect against an empty list
            //
            if(wcslen(pwszNextProv) > 0)
            {
                while(pwszNextProv != NULL)
                {
                    cItems++;
                    pwszNextProv = wcschr(pwszNextProv, ',');
                    if(pwszNextProv != NULL)
                    {
                        pwszNextProv++;
                    }
                }
            }

            if(cItems == 0)
            {
                dwErr = ERROR_INVALID_DATA;
            }
            else
            {
                pProviders->cProviders = cItems;

                //
                // Go ahead and do the init and load the providers
                //
                dwErr = AccProvpAllocateProviderList(pProviders);

                if(dwErr == ERROR_SUCCESS)
                {
                    ULONG iIndex = 0;

                    //
                    // Now, start loading each of the providers
                    //
                    pwszNextProv =  pwszOrder;

                    while(pwszNextProv != NULL)
                    {
                        PWSTR pwszSep = wcschr(pwszNextProv, L',');

                        if(pwszSep != NULL)
                        {
                            *pwszSep = L'\0';
                        }

                        dwErr = AccProvpLoadProviderDef(hkReg,
                                                        pwszNextProv,
                                            &(pProviders->pProvList[iIndex]));

                        if(pwszSep != NULL)
                        {
                            *pwszSep = L',';
                            pwszSep++;
                        }

                        //
                        // Move on to the next value
                        //
                        pwszNextProv = pwszSep;
                        if(dwErr == ERROR_SUCCESS)
                        {
                            iIndex++;
                        }
                        else
                        {
                            dwErr = ERROR_SUCCESS;
                        }
                    }

                    //
                    // if we didn't load any providers, it's an error!
                    //
                    if(iIndex == 0)
                    {
                        dwErr = ERROR_BAD_PROVIDER;
                    }

                    //
                    // Finally, if all of that worked, pick up our flags
                    //
                    if(dwErr == ERROR_SUCCESS)
                    {
                        DWORD dwType;
                        DWORD dwUnique;
                        DWORD dwSize = sizeof(ULONG);

                        dwErr = RegQueryValueEx(hkReg,
                                                ACC_PROV_REG_UNIQUE,
                                                NULL,
                                                &dwType,
                                                (PBYTE)&dwUnique,
                                                &dwSize);

                        if(dwErr == ERROR_SUCCESS)
                        {
                            //
                            // Set our capabilities
                            //
                            if(dwUnique == 1)
                            {
                                pProviders->fOptions |= ACC_PROV_REQ_UNIQUE;
                            }
                        }
                        else
                        {
                            //
                            // If it wasn't found, then it's not an error.
                            // We just assume it be false
                            //
                            if(dwErr == ERROR_FILE_NOT_FOUND)
                            {
                                dwErr = ERROR_SUCCESS;
                            }
                        }
                    }
                }

            }
        }
    }

    if(hkReg != NULL)
    {
        RegCloseKey(hkReg);
    }

    if(dwErr == ERROR_SUCCESS)
    {
        //
        // Load the NT marta functions
        //
        dwErr = AccProvpLoadMartaFunctions();
        if(dwErr == ERROR_SUCCESS)
        {
            pProviders->fOptions |= ACC_PROV_PROVIDERS_LOADED;
        }
    }

    LeaveCriticalSection( &gAccProviders.ProviderLoadLock );

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccProvpLoadProviderDef
//
//  Synopsis:   Loads a provider definition from the registry
//
//  Arguments:  [IN  hkReg]         --  Registry key to the open parent
//              [IN  pwszProvider]  --  Name of the provider to load
//              [OUT pProvInfo]     --  Provider info struct to fill
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed.
//
//----------------------------------------------------------------------------
DWORD
AccProvpLoadProviderDef(IN  HKEY                hkReg,
                        IN  PWSTR               pwszProvider,
                        OUT PACCPROV_PROV_INFO  pProvInfo)
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // First, open the proper key...
    //
    HKEY    hkProv = NULL;
    dwErr = RegOpenKey(hkReg,
                       pwszProvider,
                       &hkProv);

    if(dwErr == ERROR_SUCCESS)
    {
        //
        // Ok, we've already got the provider name.  Now just save it off
        //
        pProvInfo->pwszProviderName = (PWSTR)LocalAlloc(LMEM_FIXED,
                                                sizeof(WCHAR) *
                                                  (wcslen(pwszProvider) + 1));
        if(pProvInfo->pwszProviderName == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            wcscpy(pProvInfo->pwszProviderName,
                   pwszProvider);
        }

        if(dwErr == ERROR_SUCCESS)
        {

            dwErr = AccProvpGetStringFromRegistry(hkProv,
                                            ACC_PROV_REG_PATH,
                                            &(pProvInfo->pwszProviderPath));

            if(dwErr == ERROR_SUCCESS)
            {
                pProvInfo->fProviderState |=  ACC_PROV_PROV_OK;
            }
            else
            {
                //
                // No need to take up extra memory..
                //
                LocalFree(pProvInfo->pwszProviderName);
                pProvInfo->pwszProviderName = NULL;
                pProvInfo->fProviderState =  ACC_PROV_PROV_FAILED;
            }
        }


        RegCloseKey(hkProv);
    }

    //
    // If that worked, load it's capabilities
    //
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = AccProvpGetProviderCapabilities(pProvInfo);
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccProvpProbeProviderForObject
//
//  Synopsis:   Locates which provider supports an object.  The index of
//              this provider in the global list is returned.  In the
//              case where unique accessiblity is required, all the providers
//              will be tried.
//
//  Arguments:  [IN  pwszObject]    --  Object to look for
//              [IN  hObject]       --  Handle to object.  Either this or
//                                      pwszObject must be valid (but only
//                                      one);
//              [IN  ObjectType]    --  Type of object specified by pwszObject
//              [IN  pProviders]    --  List of providers to search
//              [OUT ppProvider]    --  Where the pointer to the active
//                                      provider is to be returned.
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_AMBIGUOUS_PATH--  The RequireUniqueAccessibilty flag
//                                      was set and the path was reachable
//                                      by more than one provider.
//              ERROR_BAD_PROVIDER  --  No providers installed.
//
//----------------------------------------------------------------------------
DWORD
AccProvpProbeProviderForObject(IN   PWSTR               pwszObject,
                               IN   HANDLE              hObject,
                               IN   SE_OBJECT_TYPE      ObjectType,
                               IN   PACCPROV_PROVIDERS  pProviders,
                               OUT  PACCPROV_PROV_INFO *ppProvider)
{
    DWORD   dwErr = ERROR_BAD_PROVIDER;

    //
    // Walk through the entire list..
    //
    ULONG iIndex;
    ULONG iActive = 0xFFFFFFFF;
    PACCPROV_PROV_INFO  pCurrent = pProviders->pProvList;
    for(iIndex = 0; iIndex < pProviders->cProviders; iIndex++)
    {
        if(pCurrent->pfObjAccess == NULL || pCurrent->pfhObjAccess == NULL)
        {
            dwErr = AccProvpLoadDllEntryPoints(pCurrent);
            if(dwErr != ERROR_SUCCESS)
            {
                break;
            }
        }

        //
        // Now, go ahead and do the call
        //
        __try
        {
            if(pwszObject != NULL)
            {
                dwErr = (*(pCurrent->pfObjAccess))(pwszObject,
                                                   ObjectType);
            }
            else
            {
                dwErr = (*(pCurrent->pfhObjAccess))(hObject,
                                                    ObjectType);
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            dwErr = GetExceptionCode();
        }


        if(dwErr == ERROR_SUCCESS)
        {
            //
            // See what's going on... If we don't require unique access,
            // simply accept this current one.  If we do require unique access
            // and this is the first provider, save it.  Otherwise, this is
            // not the provider, so return an error...
            //
            if((pProviders->fOptions & ACC_PROV_REQ_UNIQUE) != 0)
            {
                //
                // Ok, requiring unique...
                //
                if(iActive == 0xFFFFFFFF)
                {
                    iActive = iIndex;
                }
                else
                {
                    //
                    // Got a conflict
                    //

                    dwErr = ERROR_PATH_NOT_FOUND;
                    break;
                }
            }
            else
            {
                iActive = iIndex;
                break;
            }
        }
        else if (dwErr ==  ERROR_PATH_NOT_FOUND)
        {
            dwErr = ERROR_SUCCESS;
        }

        pCurrent++;
    }

    //
    // If we got a match, return it...
    //
    if(dwErr == ERROR_SUCCESS)
    {
        if(iActive != 0xFFFFFFFF)
        {
            *ppProvider = &(pProviders->pProvList[iActive]);
        }
        else
        {
            //
            // Nobody recognized the object path...
            //
            dwErr = ERROR_PATH_NOT_FOUND;
        }
    }


    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccProvpGetProviderForPath
//
//  Synopsis:   Gets the current provider for the path.  If a provider name
//              is passed it, it is compared against the loaded list.
//              Otherwise, and attempt is made to locate it.  Once located,
//              the function table is loaded, if not already done..
//
//  Arguments:  [IN  pwszObject]    --  Object to look for
//              [IN  ObjectType]    --  Type of object specified by pwszObject
//              [IN  pwszProvider]  --  If known, the provider to handle the
//                                      request.
//              [IN  pProviders]    --  List of providers to search
//              [OUT ppProvider]    --  Where the pointer to the active
//                                      provider is to be returned.
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_AMBIGUOUS_PATH--  The RequireUniqueAccessibilty flag
//                                      was set and the path was reachable
//                                      by more than one provider.
//
//----------------------------------------------------------------------------
DWORD
AccProvpGetProviderForPath(IN  PCWSTR              pcwszObject,
                           IN  SE_OBJECT_TYPE      ObjectType,
                           IN  PCWSTR              pcwszProvider,
                           IN  PACCPROV_PROVIDERS  pProviders,
                           OUT PACCPROV_PROV_INFO *ppProvider)
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // Ok, first see if we have a provider given or if we need to locate it..
    //
    if(pcwszProvider == NULL)
    {
        //
        // No provider... Go find one
        //
        dwErr = AccProvpProbeProviderForObject((PWSTR)pcwszObject,
                                               NULL,
                                               ObjectType,
                                               pProviders,
                                               ppProvider);
    }
    else
    {
        ULONG iIndex;

        //
        // See if we can find it...
        //
        dwErr = ERROR_BAD_PROVIDER;
        for(iIndex = 0; iIndex < pProviders->cProviders; iIndex++)
        {
            if(_wcsicmp((PWSTR)pcwszProvider,
                        pProviders->pProvList[iIndex].pwszProviderName) == 0)
            {
                //
                // Found a match
                //
                *ppProvider = &(pProviders->pProvList[iIndex]);
                dwErr = ERROR_SUCCESS;
                break;
            }
        }
    }

    //
    // Now, see if we need to load the appropriate function tables
    //
    if(dwErr == ERROR_SUCCESS && (*ppProvider)->pfGrantAccess == NULL)
    {
        dwErr = AccProvpLoadDllEntryPoints(*ppProvider);
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccProvpGetProviderForHandle
//
//  Synopsis:   Gets the current provider for the path.  If a provider name
//              is passed it, it is compared against the loaded list.
//              Otherwise, and attempt is made to locate it.  Once located,
//              the function table is loaded, if not already done..
//
//  Arguments:  [IN  hObject]       --  Object to look for
//              [IN  ObjectType]    --  Type of object specified by pwszObject
//              [IN  pwszProvider]  --  If known, the provider to handle the
//                                      request.
//              [IN  pProviders]    --  List of providers to search
//              [OUT ppProvider]    --  Where the pointer to the active
//                                      provider is to be returned.
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_AMBIGUOUS_PATH--  The RequireUniqueAccessibilty flag
//                                      was set and the path was reachable
//                                      by more than one provider.
//
//----------------------------------------------------------------------------
DWORD
AccProvpGetProviderForHandle(IN  HANDLE              hObject,
                             IN  SE_OBJECT_TYPE      ObjectType,
                             IN  PCWSTR              pcwszProvider,
                             IN  PACCPROV_PROVIDERS  pProviders,
                             OUT PACCPROV_PROV_INFO *ppProvider)
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // Ok, first see if we have a provider given or if we need to locate it..
    //
    if(pcwszProvider == NULL)
    {
        //
        // No provider... Go find one
        //
        dwErr = AccProvpProbeProviderForObject(NULL,
                                               hObject,
                                               ObjectType,
                                               pProviders,
                                               ppProvider);
    }
    else
    {
        ULONG iIndex;

        //
        // See if we can find it...
        //
        dwErr = ERROR_BAD_PROVIDER;
        for(iIndex = 0; iIndex < pProviders->cProviders; iIndex++)
        {
            if(_wcsicmp((PWSTR)pcwszProvider,
                        pProviders->pProvList[iIndex].pwszProviderName) == 0)
            {
                //
                // Found a match
                //
                *ppProvider = &(pProviders->pProvList[iIndex]);
                break;
            }
        }
    }

    //
    // Make sure that we support the handle based APIs for this provider
    //
    if(dwErr == ERROR_SUCCESS &&
       ((*ppProvider)->fProviderCaps & ACTRL_CAP_SUPPORTS_HANDLES) == 0)
    {
        dwErr = ERROR_CALL_NOT_IMPLEMENTED;
    }


    //
    // Now, see if we need to load the appropriate function tables
    //
    if(dwErr == ERROR_SUCCESS && (*ppProvider)->pfGrantAccess == NULL)
    {
        dwErr = AccProvpLoadDllEntryPoints(*ppProvider);
    }

    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\advapi\feclient\feclient.cpp ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    feclient.cpp

Abstract:

    This module implements stubs to call EFS Api

Author:

    Robert Reichel (RobertRe)
    Robert Gu (RobertG)

Revision History:

--*/

//
// Turn off lean and mean so we get wincrypt.h and winefs.h included
//

#undef WIN32_LEAN_AND_MEAN

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <feclient.h>
#include <efsstruc.h>
#include <userenv.h>


//
// Constants used in export\import file
//

#define FILE_SIGNATURE    L"ROBS"
#define STREAM_SIGNATURE  L"NTFS"
#define DATA_SIGNATURE    L"GURE"
#define DEFAULT_STREAM    L"::$DATA"
#define DEF_STR_LEN       14

#define PROPERTY_SET     L":$PROPERTY_SET"
#define INISECTIONNAME   L"Encryption"
#define INIKEYNAME       L"Disable"
#define INIFILENAME      L"\\Desktop.ini"
#define TRUSTEDPEOPLE L"TrustedPeople"

#define PROPERTY_SET_LEN    wcslen(PROPERTY_SET)

#if DBG

ULONG DebugLevel = 0;

#endif


LPSTR   EfsOidlpstr  = szOID_KP_EFS;

//
// External prototypes
//
extern "C" {
DWORD
EfsReadFileRawRPCClient(
    IN      PFE_EXPORT_FUNC ExportCallback,
    IN      PVOID           CallbackContext,
    IN      PVOID           Context
    );

DWORD
EfsWriteFileRawRPCClient(
    IN      PFE_IMPORT_FUNC ImportCallback,
    IN      PVOID           CallbackContext,
    IN      PVOID           Context
    );

DWORD
EfsAddUsersRPCClient(
    IN LPCWSTR lpFileName,
    IN PENCRYPTION_CERTIFICATE_LIST pEncryptionCertificates
    );


DWORD
EfsRemoveUsersRPCClient(
    IN LPCWSTR lpFileName,
    IN PENCRYPTION_CERTIFICATE_HASH_LIST pHashes
    );

DWORD
EfsQueryRecoveryAgentsRPCClient(
    IN LPCWSTR lpFileName,
    OUT PENCRYPTION_CERTIFICATE_HASH_LIST * pRecoveryAgents
    );


DWORD
EfsQueryUsersRPCClient(
    IN LPCWSTR lpFileName,
    OUT PENCRYPTION_CERTIFICATE_HASH_LIST * pUsers
    );

DWORD
EfsSetEncryptionKeyRPCClient(
    IN PENCRYPTION_CERTIFICATE pEncryptionCertificate
    );

DWORD
EfsDuplicateEncryptionInfoRPCClient(
    IN LPCWSTR lpSrcFileName,
    IN LPCWSTR lpDestFileName,
    IN DWORD dwCreationDistribution, 
    IN DWORD dwAttributes, 
    IN PEFS_RPC_BLOB pRelativeSD,
    IN BOOL bInheritHandle
    );

DWORD
EfsFileKeyInfoRPCClient(
    IN      LPCWSTR        lpFileName,
    IN      DWORD          InfoClass,
    OUT     PEFS_RPC_BLOB  *KeyInfo
    );


}



//
// Internal function prototypes
//

NTSTATUS
GetStreamInformation(
    IN HANDLE SourceFile,
    OUT PFILE_STREAM_INFORMATION * StreamInfoBase,
    PULONG StreamInfoSize
    );

DWORD
OpenFileStreams(
    IN HANDLE hSourceFile,
    IN ULONG ShareMode,
    IN PFILE_STREAM_INFORMATION StreamInfoBase,
    IN ULONG FileAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOption,
    OUT PUNICODE_STRING * StreamNames,
    OUT PHANDLE * StreamHandles,
    OUT PULONG StreamCount
    );

VOID
CleanupOpenFileStreams(
    IN PHANDLE Handles OPTIONAL,
    IN PUNICODE_STRING StreamNames OPTIONAL,
    IN PFILE_STREAM_INFORMATION StreamInfoBase OPTIONAL,
    IN HANDLE HSourceFile OPTIONAL,
    IN ULONG StreamCount
    );

ULONG
CheckSignature(
    IN void *Signature
    );

//
// Exported function prototypes
//

DWORD
EfsClientEncryptFile(
    IN LPCWSTR      FileName
    );

DWORD
EfsClientDecryptFile(
    IN LPCWSTR      FileName,
    IN DWORD        Recovery
    );

BOOL
EfsClientFileEncryptionStatus(
    IN LPCWSTR      FileName,
    OUT LPDWORD     lpStatus
    );

DWORD
EfsClientOpenFileRaw(
    IN      LPCWSTR         lpFileName,
    IN      ULONG           Flags,
    OUT     PVOID *         Context
    );

DWORD
EfsClientReadFileRaw(
    IN      PFE_EXPORT_FUNC    ExportCallback,
    IN      PVOID           CallbackContext,
    IN      PVOID           Context
    );

DWORD
EfsClientWriteFileRaw(
    IN      PFE_IMPORT_FUNC    ImportCallback,
    IN      PVOID           CallbackContext,
    IN      PVOID           Context
    );

VOID
EfsClientCloseFileRaw(
    IN      PVOID           Context
    );

DWORD
EfsClientAddUsers(
    IN LPCTSTR lpFileName,
    IN PENCRYPTION_CERTIFICATE_LIST pEncryptionCertificates
    );

DWORD
EfsClientRemoveUsers(
    IN LPCTSTR lpFileName,
    IN PENCRYPTION_CERTIFICATE_HASH_LIST pHashes
    );

DWORD
EfsClientQueryRecoveryAgents(
    IN      LPCTSTR                             lpFileName,
    OUT     PENCRYPTION_CERTIFICATE_HASH_LIST * pRecoveryAgents
    );

DWORD
EfsClientQueryUsers(
    IN      LPCTSTR                             lpFileName,
    OUT     PENCRYPTION_CERTIFICATE_HASH_LIST * pUsers
    );

DWORD
EfsClientSetEncryptionKey(
    IN PENCRYPTION_CERTIFICATE pEncryptionCertificate
    );

VOID
EfsClientFreeHashList(
    IN PENCRYPTION_CERTIFICATE_HASH_LIST pHashList
    );

DWORD
EfsClientDuplicateEncryptionInfo(
    IN LPCWSTR lpSrcFile,
    IN LPCWSTR lpDestFile,
    IN DWORD dwCreationDistribution, 
    IN DWORD dwAttributes, 
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );

BOOL
EfsClientEncryptionDisable(
    IN LPCWSTR DirPath,
    IN BOOL Disable
	);

DWORD
EfsClientFileKeyInfo(
    IN      LPCWSTR        lpFileName,
    IN      DWORD          InfoClass,
    OUT     PEFS_RPC_BLOB  *KeyInfo
    );

VOID
EfsClientFreeKeyInfo(
    IN PEFS_RPC_BLOB  pKeyInfo
    );

FE_CLIENT_DISPATCH_TABLE DispatchTable = {  EfsClientEncryptFile,
                                            EfsClientDecryptFile,
                                            EfsClientFileEncryptionStatus,
                                            EfsClientOpenFileRaw,
                                            EfsClientReadFileRaw,
                                            EfsClientWriteFileRaw,
                                            EfsClientCloseFileRaw,
                                            EfsClientAddUsers,
                                            EfsClientRemoveUsers,
                                            EfsClientQueryRecoveryAgents,
                                            EfsClientQueryUsers,
                                            EfsClientSetEncryptionKey,
                                            EfsClientFreeHashList,
                                            EfsClientDuplicateEncryptionInfo,
                                            EfsClientEncryptionDisable,
                                            EfsClientFileKeyInfo,
                                            EfsClientFreeKeyInfo
                                            };


FE_CLIENT_INFO ClientInfo = {
                            FE_REVISION_1_0,
                            &DispatchTable
                            };

//
// Internal function prototypes
//


BOOL
TranslateFileName(
    IN LPCWSTR FileName,
    OUT PUNICODE_STRING FullFileNameU
    );

BOOL
RemoteFile(
    IN LPCWSTR FileName
    );

extern "C"
BOOL
EfsClientInit(
    IN PVOID hmod,
    IN ULONG Reason,
    IN PCONTEXT Context
    )
{
    return( TRUE );
}

extern "C"
BOOL
FeClientInitialize(
    IN     DWORD           dwFeRevision,
    OUT    LPFE_CLIENT_INFO       *lpFeInfo
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    dwFeRevision - Is the revision of the current FEAPI interface.

    lpFeInfo - On successful return, must contain a pointer to a structure
         describing the FE Client Interface.  Once returned, the FE Client
         must assume that the caller will continue to reference this table until
         an unload call has been made.  Any changes to this information, or
         deallocation of the memory containing the information may result in
         system corruptions.


Return Value:

    TRUE - Indicates the Client DLL successfully initialized.

    FALSE - Indicates the client DLL has not loaded.  More information may be
         obtained by calling GetLastError().

--*/

{

    *lpFeInfo = &ClientInfo;

    return( TRUE );
}

BOOL
TranslateFileName(
    IN LPCWSTR FileName,
    OUT PUNICODE_STRING FullFileNameU
    )

/*++

Routine Description:

    This routine takes the filename passed by the user and converts
    it to a fully qualified pathname in the passed Unicode string.

Arguments:

    FileName - Supplies the user-supplied file name.

    FullFileNameU - Returns the fully qualified pathname of the passed file.
        The buffer in this string is allocated out of heap memory and
        must be freed by the caller.

Return Value:

    TRUE on success, FALSE otherwise.

--*/


//
// Note: need to free the buffer of the returned string
//
{

    UNICODE_STRING FileNameU;
    BOOLEAN TranslationStatus;
    LPWSTR SrcFileName = (LPWSTR)FileName;
    WCHAR   Sep = L'\\';
    int  SrcLen =wcslen(FileName);

    if (0 == SrcLen) {
       SetLastError(ERROR_INVALID_PARAMETER);
       return FALSE;
    }
    FullFileNameU->Buffer = (PWSTR)RtlAllocateHeap( RtlProcessHeap(), 0, MAX_PATH * sizeof( WCHAR ));
    if (!FullFileNameU->Buffer) {
        SetLastError(ERROR_OUTOFMEMORY);
        return FALSE;
    }

    FullFileNameU->MaximumLength = MAX_PATH * sizeof( WCHAR );

    FullFileNameU->Length = (USHORT)RtlGetFullPathName_U(
                                         SrcFileName,
                                         FullFileNameU->MaximumLength,
                                         FullFileNameU->Buffer,
                                         NULL
                                         );

    //
    // The return value is supposed to be the length of the filename, without counting
    // the trailing NULL character.  MAX_PATH is supposed be long enough to contain
    // the length of the file name and the trailing NULL, so what we get back had
    // better be less than MAX_PATH wchars.
    //

    if ( FullFileNameU->Length >= FullFileNameU->MaximumLength ){

        RtlFreeHeap( RtlProcessHeap(), 0, FullFileNameU->Buffer );
        FullFileNameU->Buffer = (PWSTR)RtlAllocateHeap( RtlProcessHeap(), 0, FullFileNameU->Length + sizeof(WCHAR));

        if (FullFileNameU->Buffer == NULL) {
            return( FALSE );
        }
        FullFileNameU->MaximumLength = FullFileNameU->Length + sizeof(WCHAR);

        FullFileNameU->Length = (USHORT)RtlGetFullPathName_U(
                                            SrcFileName,
                                            FullFileNameU->MaximumLength,
                                            FullFileNameU->Buffer,
                                            NULL
                                            );
    }


    if (FullFileNameU->Length == 0) {
        //
        // We failed for some reason
        //
    
        RtlFreeHeap( RtlProcessHeap(), 0, FullFileNameU->Buffer );
        return( FALSE );
    }
    
    return( TRUE );

/******************
    if (0 == SrcLen) {
       SetLastError(ERROR_INVALID_PARAMETER);
       return FALSE;
    }
    FullFileNameU->Buffer = (PWSTR)RtlAllocateHeap( RtlProcessHeap(), 0, MAX_PATH * sizeof( WCHAR ));

    if (FullFileNameU->Buffer == NULL) {
        SetLastError(ERROR_OUTOFMEMORY);
        return( FALSE );
    }

    if ((SrcLen >= 5) && (FileName[0] == Sep) && (FileName[1] == Sep) && (FileName[2] == L'?') && (FileName[3] == Sep)){

       if (FileName[5] == L':') {
          SrcFileName = (LPWSTR)&FileName[4];
       } else if ((SrcLen >= 7) && (FileName[4] == L'U') && (FileName[5] == L'N') && (FileName[6] == L'C') && (FileName[7] == Sep)){
          SrcFileName = (LPWSTR)&FileName[6];
          SrcFileName[0] = Sep;
       }

    } else if ((SrcLen >= 6) && (FileName[0] == Sep) && (FileName[1] == L'?') && (FileName[2] == FileName[1]) && (FileName[3] == FileName[0])) {

        //
        // /??/... format
        //

        SrcFileName = (LPWSTR)&FileName[4];

    }

    if ( SrcFileName != (LPWSTR)FileName ){

        //
        // User passed in a FULL path with \\?\ format.
        // RtlGetFullPathName_U may fail if we pass in a long file name without \\?\
        //

        FullFileNameU->Length = wcslen(SrcFileName)*sizeof( WCHAR );
        if ( FullFileNameU->Length >= MAX_PATH * sizeof( WCHAR ) ){
            RtlFreeHeap( RtlProcessHeap(), 0, FullFileNameU->Buffer );
            FullFileNameU->Buffer = (PWSTR)RtlAllocateHeap( RtlProcessHeap(), 0, FullFileNameU->Length + sizeof(WCHAR));

            if (FullFileNameU->Buffer == NULL) {
                if ((SrcLen >= 7) && (SrcFileName == &FileName[6])) {
                    SrcFileName[0] = L'C';
                }
                return( FALSE );
            }
            FullFileNameU->MaximumLength = FullFileNameU->Length + sizeof(WCHAR);
        }
        RtlCopyMemory(FullFileNameU->Buffer, SrcFileName, FullFileNameU->Length + sizeof(WCHAR));

    } else {

        FullFileNameU->MaximumLength = MAX_PATH * sizeof( WCHAR );

        FullFileNameU->Length = (USHORT)RtlGetFullPathName_U(
                                             SrcFileName,
                                             FullFileNameU->MaximumLength,
                                             FullFileNameU->Buffer,
                                             NULL
                                             );

        //
        // The return value is supposed to be the length of the filename, without counting
        // the trailing NULL character.  MAX_PATH is supposed be long enough to contain
        // the length of the file name and the trailing NULL, so what we get back had
        // better be less than MAX_PATH wchars.
        //

        if ( FullFileNameU->Length >= FullFileNameU->MaximumLength ){

            RtlFreeHeap( RtlProcessHeap(), 0, FullFileNameU->Buffer );
            FullFileNameU->Buffer = (PWSTR)RtlAllocateHeap( RtlProcessHeap(), 0, FullFileNameU->Length + sizeof(WCHAR));

            if (FullFileNameU->Buffer == NULL) {
                if (SrcFileName == &FileName[6]) {
                    SrcFileName[0] = L'C';
                }
                return( FALSE );
            }
            FullFileNameU->MaximumLength = FullFileNameU->Length + sizeof(WCHAR);

            FullFileNameU->Length = (USHORT)RtlGetFullPathName_U(
                                                SrcFileName,
                                                FullFileNameU->MaximumLength,
                                                FullFileNameU->Buffer,
                                                NULL
                                                );
        }
    }

    if ((SrcLen >= 7) && (SrcFileName == &FileName[6])) {
        SrcFileName[0] = L'C';
    }

    if (FullFileNameU->Length == 0) {
        //
        // We failed for some reason
        //

        RtlFreeHeap( RtlProcessHeap(), 0, FullFileNameU->Buffer );
        return( FALSE );
    }

    return( TRUE );
 *******************/
}

BOOL
WriteEfsIni(
    IN LPCWSTR SectionName,
	IN LPCWSTR KeyName,
	IN LPCWSTR WriteValue,
	IN LPCWSTR IniFileName
	)
/*++

Routine Description:

    This routine writes to the ini file. A wrap of WritePrivateProfileString
    
Arguments:

    SectionName - Section name (Encryption).

    KeyName - Key name (Disable).
    
    WriteValue - The value to be write (1).
    
    IniFileName - The path for ini file (dir\desktop.ini).

Return Value:

    TRUE on success

--*/
{
    BOOL bRet;

	bRet = WritePrivateProfileString(
                SectionName,
                KeyName,
                WriteValue,
                IniFileName
                );

    //
    // If SetFileAttributes fails, life should go on.
    //

    SetFileAttributes(IniFileName, FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN );

    return bRet;
}


BOOL
EfsClientEncryptionDisable(
    IN LPCWSTR DirPath,
    IN BOOL Disable
	)
/*++

Routine Description:

    This routine disable and enable EFS in the directory DirPath.
        
Arguments:

    DirPath - Directory path.

    Disable - TRUE to disable
    

Return Value:

    TRUE for SUCCESS

--*/
{
    LPWSTR IniFilePath;
    WCHAR  WriteValue[2];
    BOOL   bRet = FALSE;

    if (DirPath) {

        IniFilePath = (LPWSTR)RtlAllocateHeap( 
                                RtlProcessHeap(), 
                                0,
                                (wcslen(DirPath)+1+wcslen(INIFILENAME))*sizeof(WCHAR) 
                                );
        if (IniFilePath) {
            if (Disable) {
                wcscpy(WriteValue, L"1");
            } else {
                wcscpy(WriteValue, L"0");
            }
    
            wcscpy(IniFilePath, DirPath);
            wcscat(IniFilePath, INIFILENAME);
            bRet = WriteEfsIni(INISECTIONNAME, INIKEYNAME, WriteValue, IniFilePath);
            RtlFreeHeap( RtlProcessHeap(), 0, IniFilePath );
    
        }

    } else {
        SetLastError(ERROR_INVALID_PARAMETER);
    }

    return bRet;
}

BOOL
EfsDisabled(
    IN LPCWSTR SectionName,
	IN LPCWSTR KeyName,
	IN LPCWSTR IniFileName
	)
/*++

Routine Description:

    This routine checks if the encryption has been turned off for the ini file.
        
Arguments:

    SectionName - Section name (Encryption).

    KeyName - Key name (Disable).
    
    IniFileName - The path for ini file (dir\desktop.ini).

Return Value:

    TRUE for disabled

--*/
{
    DWORD ValueLength;
    WCHAR ResultString[4];

    memset( ResultString, 0, sizeof(ResultString) );

    ValueLength = GetPrivateProfileString(
                      SectionName,
                      KeyName,
                      L"0",
                      ResultString,
                      sizeof(ResultString)/sizeof(WCHAR),
                      IniFileName
                      );

    //
    // If GetPrivateProfileString failed, EFS will be enabled
    //

    return (!wcscmp(L"1", ResultString));
}

BOOL
DirEfsDisabled(
    IN LPCWSTR  DirName
    )
/*++

Routine Description:

    This routine checks if the encryption has been turned off for the dir.
        
Arguments:

    SectionName - Section name (Encryption).

    KeyName - Key name (Disable).
    
    IniFileName - The path for ini file (dir\desktop.ini).

Return Value:

    TRUE for disabled

--*/
{
    LPWSTR FileName;
    DWORD  FileLength = (wcslen(INIFILENAME)+wcslen(DirName)+1)*sizeof (WCHAR);
    BOOL   bRet = FALSE;

    FileName = (PWSTR)RtlAllocateHeap( RtlProcessHeap(), 0, FileLength );
    if (FileName) {
        wcscpy( FileName, DirName );
        wcscat( FileName, INIFILENAME );
        bRet = EfsDisabled( INISECTIONNAME, INIKEYNAME, FileName );
        RtlFreeHeap( RtlProcessHeap(), 0, FileName );
    }

    return bRet;
}

BOOL
RemoteFile(
    IN LPCWSTR FileName
    )
/*++

Routine Description:

    This routine checks if the file is a local file.
    If a UNC name is passed in, it assumes a remote file. A loopback operation will occur.

Arguments:

    FileName - Supplies the user-supplied file name.

Return Value:

    TRUE for remote file.

--*/

{

    if ( FileName[1] == L':' ){

        WCHAR DriveLetter[3];
        DWORD BufferLength = 3;
        DWORD RetCode = ERROR_SUCCESS;

        DriveLetter[0] = FileName[0];
        DriveLetter[1] = FileName[1];
        DriveLetter[2] = 0;

        RetCode = WNetGetConnectionW(
                                DriveLetter,
                                DriveLetter,
                                &BufferLength
                                );

        if (RetCode == ERROR_NOT_CONNECTED) {
            return FALSE;
        } else {
            return TRUE;
        }

    } else {
        return TRUE;
    }

}

DWORD
EfsClientEncryptFile(
    IN LPCWSTR      FileName
    )
{
    DWORD           rc;
    BOOL            Result;


    UNICODE_STRING FullFileNameU;

    if (NULL == FileName) {
       return ERROR_INVALID_PARAMETER;
    }
    Result = TranslateFileName( FileName, &FullFileNameU );

    if (Result) {

        //
        // Call the server
        //

        rc = EfsEncryptFileRPCClient( &FullFileNameU );
        RtlFreeHeap(RtlProcessHeap(), 0, FullFileNameU.Buffer);

    } else {
        rc = GetLastError();
    }

    return( rc );
}

DWORD
EfsClientDecryptFile(
    IN LPCWSTR      FileName,
    IN DWORD        dwRecovery
    )
{
    DWORD           rc;
    BOOL            Result;

    UNICODE_STRING FullFileNameU;

    if (NULL == FileName) {
       return ERROR_INVALID_PARAMETER;
    }
    Result = TranslateFileName( FileName, &FullFileNameU );

    if (Result) {

        //
        // Call the server
        //

        //rc = EfsDecryptFileAPI( &FullFileNameU, dwRecovery );
        rc = EfsDecryptFileRPCClient( &FullFileNameU, dwRecovery );
        RtlFreeHeap(RtlProcessHeap(), 0, FullFileNameU.Buffer);

    } else {
        rc = GetLastError();
    }


    return( rc );
}

BOOL
EfsClientFileEncryptionStatus(
    IN LPCWSTR      FileName,
    OUT LPDWORD      lpStatus
    )
/*++

Routine Description:

    This routine checks if a file is encryptable or not.

    We do not test the NTFS Volume 5 for the reason of performance.
    This means we might return a file encryptable (on FAT at etc.), but
    actually it could not be encrypted. This should be OK. This is a best effort
    API. We have the same problem with network file. Any way, a file could fail
    to be encrypted for many reasons, delegation, disk space and etc.
    We disable the encryption from %windir% down.
    We might change these features later.

Arguments:

    FileName - The file to be checked.

    lpStatus - The encryption status of the file. Error code if the return value is
                    FALSE.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL            Result;
    DWORD        FileAttributes;

    UNICODE_STRING FullFileNameU;

    if ((NULL == FileName) || ( NULL == lpStatus)) {
       SetLastError(ERROR_INVALID_PARAMETER);
       return FALSE;
    }

    //
    // GetFileAttributes should use the name before TanslateFileName
    // in case the passed in name is longer than MAX_PATH and using the
    // format \\?\
    //

    FileAttributes = GetFileAttributes( FileName );

    if (FileAttributes == -1){
        *lpStatus = GetLastError();
        return FALSE;
    }

    Result = TranslateFileName( FileName, &FullFileNameU );

    ASSERT(FullFileNameU.Buffer[FullFileNameU.Length / 2] == 0);

    if (Result) {

        if ( (FileAttributes & FILE_ATTRIBUTE_ENCRYPTED) ||
             (FileAttributes & FILE_ATTRIBUTE_SYSTEM) ) {

            //
            // File not encryptable. Either it is encypted or a system file.
            //

            if ( FileAttributes & FILE_ATTRIBUTE_ENCRYPTED ){

                *lpStatus = FILE_IS_ENCRYPTED;

            } else {

                *lpStatus = FILE_SYSTEM_ATTR ;

            }

        } else {

            LPWSTR  TmpBuffer;
            LPWSTR  FullPathName;
            UINT    TmpBuffLen;
            UINT    FullPathLen;
            UINT    PathLength;
            BOOL    GotRoot;
            BOOL    EfsDisabled = FALSE;

            //
            // Check if it is the root.
            //

            if ( FullFileNameU.Length >= MAX_PATH * sizeof(WCHAR)){

                //
                // We need to put back the \\?\ or \\?\UNC\ to use the
                // Win 32 API
                //

                FullPathLen = FullFileNameU.Length + 7 * sizeof(WCHAR);
                TmpBuffLen = FullPathLen;
                FullPathName = (LPWSTR)RtlAllocateHeap(
                                            RtlProcessHeap(),
                                            0,
                                            FullPathLen
                                            );
                TmpBuffer = (LPWSTR)RtlAllocateHeap(
                                            RtlProcessHeap(),
                                            0,
                                            TmpBuffLen
                                            );

                if ((FullPathName == NULL) || (TmpBuffer == NULL)){
                    RtlFreeHeap(RtlProcessHeap(), 0, FullFileNameU.Buffer);
                    if (FullPathName){
                        RtlFreeHeap(RtlProcessHeap(), 0, FullPathName);
                    }
                    if (TmpBuffer){
                        RtlFreeHeap(RtlProcessHeap(), 0, TmpBuffer);
                    }
                    *lpStatus = ERROR_OUTOFMEMORY;
                    return FALSE;
                }

                if ( FullFileNameU.Buffer[0] == L'\\' ){

                    //
                    // Put back the \\?\UNC\
                    //

                    wcscpy(FullPathName, L"\\\\?\\UNC");
                    wcscat(FullPathName, &(FullFileNameU.Buffer[1]));
                    FullPathLen = FullFileNameU.Length + 6 * sizeof(WCHAR);

                } else {

                    //
                    // Put back the \\?\
                    //

                    wcscpy(FullPathName, L"\\\\?\\");
                    wcscat(FullPathName, FullFileNameU.Buffer);
                    FullPathLen = FullFileNameU.Length + 4 * sizeof(WCHAR);
                }

            } else {
                TmpBuffLen = MAX_PATH * sizeof(WCHAR);
                TmpBuffer = (LPWSTR)RtlAllocateHeap(
                                            RtlProcessHeap(),
                                            0,
                                            TmpBuffLen
                                            );
                if (TmpBuffer == NULL){
                    RtlFreeHeap(RtlProcessHeap(), 0, FullFileNameU.Buffer);
                    *lpStatus = ERROR_OUTOFMEMORY;
                    return FALSE;
                }

                FullPathName = FullFileNameU.Buffer;
                FullPathLen = FullFileNameU.Length;
            }

            //
            // Check desktop.ini here
            //


            wcscpy(TmpBuffer, FullFileNameU.Buffer); 
            if (!(FileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {

                //
                // This is a file. Get the DIR path
                //

                int ii;

                ii = wcslen(TmpBuffer) - 1;
                while ((ii >= 0) && (TmpBuffer[ii] != L'\\')) {
                    ii--;
                }
                if (ii>=0) {
                    TmpBuffer[ii] = 0;
                }

            }

            EfsDisabled = DirEfsDisabled( TmpBuffer );

            if (EfsDisabled) {
               *lpStatus = FILE_DIR_DISALLOWED;
            } else if (!(FileAttributes & FILE_ATTRIBUTE_DIRECTORY) && (FileAttributes & FILE_ATTRIBUTE_READONLY)){

                //
                // Read only file
                //

                *lpStatus = FILE_READ_ONLY;
            } else {
                GotRoot = GetVolumePathName(
                                    FullPathName,
                                    TmpBuffer,
                                    TmpBuffLen
                                    );
    
                if ( GotRoot ){
    
                    DWORD RootLength = wcslen(TmpBuffer) - 1;
                    TmpBuffer[RootLength] = NULL;
                    if ( (FullPathLen == RootLength * sizeof (WCHAR))
                           && !wcscmp(TmpBuffer, FullPathName)){
    
                        //
                        // It is the root
                        //
    
                        *lpStatus = FILE_ROOT_DIR;
    
                    } else {
    
                        //
                        // Check if it is the Windows\system32 directories
                        //
    
                        PathLength = GetSystemWindowsDirectory( TmpBuffer, TmpBuffLen );                    
                        //PathLength = GetWindowsDirectory( TmpBuffer, TmpBuffLen );
                        //PathLength = GetSystemDirectory( TmpBuffer, TmpBuffLen );
    
                        ASSERT(PathLength <= TmpBuffLen);
    
                        if ( PathLength > TmpBuffLen ) {
    
                            //
                            // This is unlikely. Not sure who will ever have the length
                            // of %windir%\system32 longer than MAXPATH in the real world. 
                            // Even this happen, user could still encrypt the file. FILE_UNKNOWN
                            // does not mean file could\or couldn't be encrypted.
                            //
    
                            *lpStatus = FILE_UNKNOWN ;
    
                        } else {
    
                            if ( ( FullFileNameU.Length < PathLength * sizeof (WCHAR) ) ||
                                  ( ( FullFileNameU.Buffer[PathLength] ) &&
                                    ( FullFileNameU.Buffer[PathLength] != L'\\') )){
    
                                //
                                // Check if a remote file
                                //
    
                                if ( RemoteFile( FullFileNameU.Buffer ) ){
    
                                    *lpStatus = FILE_UNKNOWN;
    
                                } else {
    
                                    *lpStatus = FILE_ENCRYPTABLE;
    
                                }
    
                            } else {
    
                                if ( _wcsnicmp(TmpBuffer, FullFileNameU.Buffer, PathLength)){
    
                                    //
                                    // Not under %SystemRoot%
                                    //
    
                                    if ( RemoteFile( FullFileNameU.Buffer ) ){
    
                                        *lpStatus = FILE_UNKNOWN;
    
                                    } else {
    
                                        *lpStatus = FILE_ENCRYPTABLE;
    
                                    }
                                } else {
    
                                    //
                                    // In windows root directory. WINNT
                                    //
    
                                    BOOL bRet;
                                    DWORD allowPathLen;
    
                                    //
                                    // Check for allow lists
                                    //
    
                                    allowPathLen = (DWORD) TmpBuffLen;
                                    bRet = GetProfilesDirectory(TmpBuffer, &allowPathLen);
                                    if (!bRet){
                                        RtlFreeHeap(RtlProcessHeap(), 0, TmpBuffer);
                                        TmpBuffer = (LPWSTR)RtlAllocateHeap(
                                                                RtlProcessHeap(),
                                                                0,
                                                                allowPathLen
                                                                );
                                        if (TmpBuffer){
                                            bRet = GetProfilesDirectory(TmpBuffer, &allowPathLen);
                                        } else {
                                            *lpStatus = ERROR_OUTOFMEMORY;
                                            Result = FALSE;
                                        }
                                    }
                                    if (bRet){
    
                                        //
                                        // Check for Profiles directory
                                        //
    
                                        if (!_wcsnicmp(TmpBuffer, FullFileNameU.Buffer, allowPathLen - 1)){
                                            *lpStatus = FILE_ENCRYPTABLE;
                                        } else {
    
                                            //
                                            // Under %windir% but not profiles
                                            //
    
                                            *lpStatus = FILE_SYSTEM_DIR;
                                        }
                                    } else {
    
                                        if ( *lpStatus != ERROR_OUTOFMEMORY){
    
                                            //
                                            // This should not happen, unless a bug in GetProfilesDirectoryEx()
                                            //
                                            ASSERT(FALSE);
    
                                            *lpStatus = FILE_UNKNOWN;
                                        }
    
                                    }
                                }
                            }
                        }
                    }
                } else {
    
                    //
                    // Cannot get the root. The reason might very well be out of memory.
                    // Return FILE_UNKNOWN and let other codes dealing with the memory
                    // problem.
                    //
    
                    *lpStatus = FILE_UNKNOWN ;
    
                }
            }

            if ((FullPathName != FullFileNameU.Buffer) && FullPathName){
                RtlFreeHeap(RtlProcessHeap(), 0, FullPathName);
            }

            if (TmpBuffer){
                RtlFreeHeap(RtlProcessHeap(), 0, TmpBuffer);
            }

        }

        RtlFreeHeap(RtlProcessHeap(), 0, FullFileNameU.Buffer);

    } else {
        *lpStatus = GetLastError();
    }

    return  Result;
}

DWORD
EfsClientOpenFileRaw(
    IN      LPCWSTR         FileName,
    IN      ULONG           Flags,
    OUT     PVOID *         Context
    )

/*++

Routine Description:

    This routine is used to open an encrypted file. It opens the file and
    prepares the necessary context to be used in ReadRaw data and WriteRaw
    data.


Arguments:

    FileName  --  File name of the file to be exported

    Flags -- Indicating if open for export or import; for directory or file.

    Context - Export context to be used by READ operation later. Caller should
              pass this back in ReadRaw().


Return Value:

    Result of the operation.

--*/

{
    DWORD        rc;
    BOOL            Result;
    UNICODE_STRING FullFileNameU;

    if ((NULL == FileName) || ( NULL == Context)) {
       return ERROR_INVALID_PARAMETER;
    }

    Result = TranslateFileName( FileName, &FullFileNameU );

    if (Result) {

        rc =  (EfsOpenFileRawRPCClient(
                        FullFileNameU.Buffer,
                        Flags,
                        Context
                        )
                    );

        RtlFreeHeap(RtlProcessHeap(), 0, FullFileNameU.Buffer);

    } else {
        rc = GetLastError();
    }

    return rc;

}

DWORD
EfsClientReadFileRaw(
    IN      PFE_EXPORT_FUNC ExportCallback,
    IN      PVOID           CallbackContext,
    IN      PVOID           Context
    )
/*++

Routine Description:

    This routine is used to read encrypted file's raw data. It uses
    NTFS FSCTL to get the data.

Arguments:

    ExportCallback --  Caller supplied callback function to process the
                       raw data.

    CallbackContext -- Caller's context passed back in ExportCallback.

    Context - Export context created in the CreateRaw.

Return Value:

    Result of the operation.

--*/

{
    return ( EfsReadFileRawRPCClient(
                    ExportCallback,
                    CallbackContext,
                    Context
                    ));
}

DWORD
EfsClientWriteFileRaw(
    IN      PFE_IMPORT_FUNC ImportCallback,
    IN      PVOID           CallbackContext,
    IN      PVOID           Context
    )

/*++

Routine Description:

    This routine is used to write encrypted file's raw data. It uses
    NTFS FSCTL to write the data.

Arguments:

    ImportCallback --  Caller supplied callback function to provide the
                       raw data.

    CallbackContext -- Caller's context passed back in ImportCallback.

    Context - Import context created in the CreateRaw.

Return Value:

    Result of the operation.

--*/

{

    return ( EfsWriteFileRawRPCClient(
                    ImportCallback,
                    CallbackContext,
                    Context
                    ));
}

VOID
EfsClientCloseFileRaw(
    IN      PVOID           Context
    )
/*++

Routine Description:

    This routine frees the resources allocated by the CreateRaw

Arguments:

    Context - Created by the CreateRaw.

Return Value:

    NO.

--*/
{
    if ( !Context ){
        return;
    }

    EfsCloseFileRawRPCClient( Context );
}


//
// Beta 2 API
//

DWORD
EfsClientAddUsers(
    IN LPCWSTR lpFileName,
    IN PENCRYPTION_CERTIFICATE_LIST pEncryptionCertificates
    )
/*++

Routine Description:

    Calls client stub for AddUsersToFile EFS API.

Arguments:

    lpFileName - Supplies the name of the file to be modified.

    nUsers - Supplies the number of entries in teh pEncryptionCertificates array

    pEncryptionCertificates - Supplies an array of pointers to PENCRYPTION_CERTIFICATE
        structures.  Length of array is given in nUsers parameter.

Return Value:

--*/
{
    DWORD        rc = ERROR_SUCCESS;
    UNICODE_STRING FullFileNameU;
    DWORD        ii = 0;
    CERT_CHAIN_PARA CertChainPara;


    if ((NULL == lpFileName) || (NULL == pEncryptionCertificates)) {
       return ERROR_INVALID_PARAMETER;
    }

    //
    // Let's check to see if the certs are good or not.
    //

    CertChainPara.cbSize = sizeof(CERT_CHAIN_PARA);
    CertChainPara.RequestedUsage.dwType = USAGE_MATCH_TYPE_AND;
    CertChainPara.RequestedUsage.Usage.cUsageIdentifier = 1;
    CertChainPara.RequestedUsage.Usage.rgpszUsageIdentifier=&EfsOidlpstr;

    while ((ERROR_SUCCESS == rc) && (ii < pEncryptionCertificates->nUsers)) {

        PCCERT_CONTEXT pCertContext = CertCreateCertificateContext(
                                          X509_ASN_ENCODING,
                                          pEncryptionCertificates->pUsers[ii]->pCertBlob->pbData,
                                          pEncryptionCertificates->pUsers[ii]->pCertBlob->cbData
                                          );
        if (pCertContext != NULL) {

            PCCERT_CHAIN_CONTEXT pChainContext;

            //
            // Do the chain validation
            //
            
            if (CertGetCertificateChain (
                                        HCCE_CURRENT_USER,
                                        pCertContext,
                                        NULL,
                                        NULL,
                                        &CertChainPara,
                                        0,
                                        NULL,
                                        &pChainContext
                                        )) {
                //
                // Let's check the chain
                //

                PCERT_SIMPLE_CHAIN pChain = pChainContext->rgpChain[ pChainContext->cChain - 1 ];
                PCERT_CHAIN_ELEMENT pElement = pChain->rgpElement[ pChain->cElement - 1 ];
                BOOL bSelfSigned = pElement->TrustStatus.dwInfoStatus & CERT_TRUST_IS_SELF_SIGNED;
                DWORD dwErrorStatus = pChainContext->TrustStatus.dwErrorStatus;

                if (dwErrorStatus) {
                    if ((dwErrorStatus == CERT_TRUST_IS_UNTRUSTED_ROOT) && bSelfSigned ){

                        //
                        // Self signed. Check if it is in the my trusted store
                        //
                        HCERTSTORE trustedStore;
                        PCCERT_CONTEXT pCert=NULL;

                        trustedStore = CertOpenStore(
                                                CERT_STORE_PROV_SYSTEM_W,
                                                0,       // dwEncodingType
                                                0,       // hCryptProv,
                                                CERT_SYSTEM_STORE_CURRENT_USER,
                                                TRUSTEDPEOPLE
                                                );

                        if (trustedStore) {

                            pCert = CertFindCertificateInStore(
                                        trustedStore,
                                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                        0,
                                        CERT_FIND_EXISTING,
                                        pCertContext,
                                        pCert
                                        );
                            if (pCert) {
                    
                                //
                                // We found it.
                                //
                                CertFreeCertificateContext(pCert);

                            } else {

                                //
                                // Not trusted self-signed cert
                                //

                                rc = CERT_E_UNTRUSTEDROOT;

                            }

                            CertCloseStore( trustedStore, 0 );

                        } else {
                            rc = GetLastError();
                        }

                    } else {

                        //
                        // Other chain build error
                        //  Let's get the error code of the chain building.
                        //

                        CERT_CHAIN_POLICY_PARA PolicyPara;
                        CERT_CHAIN_POLICY_STATUS PolicyStatus;

                        RtlZeroMemory(&PolicyPara, sizeof(CERT_CHAIN_POLICY_PARA));
                        RtlZeroMemory(&PolicyStatus, sizeof(CERT_CHAIN_POLICY_STATUS));

                        PolicyPara.cbSize = sizeof(CERT_CHAIN_POLICY_PARA);
                        PolicyStatus.cbSize = sizeof(CERT_CHAIN_POLICY_STATUS);

                        if (!CertVerifyCertificateChainPolicy(
                                CERT_CHAIN_POLICY_BASE,
                                pChainContext,
                                &PolicyPara,
                                &PolicyStatus
                                )) {

                            rc = PolicyStatus.dwError;
                        }


                    }
                }

                CertFreeCertificateChain( pChainContext );

            } else {

                rc = GetLastError();

            }

            CertFreeCertificateContext(pCertContext);

        } else {

            rc = GetLastError();

        }

        ii++;
    }

    if (ERROR_SUCCESS == rc) {

        if (TranslateFileName( lpFileName, &FullFileNameU )) {
    
            rc = EfsAddUsersRPCClient( FullFileNameU.Buffer, pEncryptionCertificates );
    
            RtlFreeHeap(RtlProcessHeap(), 0, FullFileNameU.Buffer);
    
        } else {
    
            rc = GetLastError();
        }

    }

    return rc;
}

DWORD
EfsClientRemoveUsers(
    IN LPCWSTR lpFileName,
    IN PENCRYPTION_CERTIFICATE_HASH_LIST pHashes
    )
/*++

Routine Description:

    Calls client stub for RemoveUsersFromFile EFS API

Arguments:

    lpFileName - Supplies the name of the file to be modified.

    pHashes - Supplies a structure containing a list of PENCRYPTION_CERTIFICATE_HASH
        structures, each of which represents a user to remove from the specified file.

Return Value:

--*/
{
    DWORD        rc;
    UNICODE_STRING FullFileNameU;


    if ((NULL == lpFileName) || (NULL == pHashes) || (pHashes->pUsers == NULL)) {
       return ERROR_INVALID_PARAMETER;
    }
    if (TranslateFileName( lpFileName, &FullFileNameU )) {

        rc =  EfsRemoveUsersRPCClient( FullFileNameU.Buffer, pHashes );

        RtlFreeHeap(RtlProcessHeap(), 0, FullFileNameU.Buffer);

    } else {

        rc = GetLastError();
    }

    return rc;
}

DWORD
EfsClientQueryRecoveryAgents(
    IN      LPCWSTR                             lpFileName,
    OUT     PENCRYPTION_CERTIFICATE_HASH_LIST * pRecoveryAgents
    )
/*++

Routine Description:

    Calls client stub for QueryRecoveryAgents EFS API

Arguments:

    lpFileName - Supplies the name of the file to be modified.

    pRecoveryAgents - Returns a pointer to a structure containing a list
        of PENCRYPTION_CERTIFICATE_HASH structures, each of which represents
        a recovery agent on the file.

Return Value:

--*/
{
    DWORD        rc;
    UNICODE_STRING FullFileNameU;


    if ((NULL == lpFileName) || (NULL == pRecoveryAgents)) {
       return ERROR_INVALID_PARAMETER;
    }
    if (TranslateFileName( lpFileName, &FullFileNameU )) {

        rc =  EfsQueryRecoveryAgentsRPCClient( FullFileNameU.Buffer, pRecoveryAgents );

        RtlFreeHeap(RtlProcessHeap(), 0, FullFileNameU.Buffer);

    } else {

        rc = GetLastError();
    }

    return rc;
}

DWORD
EfsClientQueryUsers(
    IN      LPCWSTR                             lpFileName,
    OUT     PENCRYPTION_CERTIFICATE_HASH_LIST * pUsers
    )
/*++

Routine Description:

    Calls client stub for QueryUsersOnFile EFS API

Arguments:

    lpFileName - Supplies the name of the file to be modified.

    pUsers - Returns a pointer to a structure containing a list
        of PENCRYPTION_CERTIFICATE_HASH structures, each of which represents
        a user of this file (that is, someone who can decrypt the file).

Return Value:

--*/
{
    DWORD        rc;
    UNICODE_STRING FullFileNameU;

    if ((NULL == lpFileName) || (NULL == pUsers)) {
       return ERROR_INVALID_PARAMETER;
    }
    if (TranslateFileName( lpFileName, &FullFileNameU )) {

        rc =  EfsQueryUsersRPCClient( FullFileNameU.Buffer, pUsers );

        RtlFreeHeap(RtlProcessHeap(), 0, FullFileNameU.Buffer);

    } else {

        rc = GetLastError();
    }

    return rc;
}


DWORD
EfsClientSetEncryptionKey(
    IN PENCRYPTION_CERTIFICATE pEncryptionCertificate
    )
/*++

Routine Description:

    Calls client stub for SetFileEncryptionKey EFS API

Arguments:

    pEncryptionCertificate - Supplies a pointer to an EFS certificate
        representing the public key to use for future encryption operations.

Return Value:

--*/
{
    /*
    if ((NULL == pEncryptionCertificate) || ( NULL == pEncryptionCertificate->pCertBlob)) {
       return ERROR_INVALID_PARAMETER;
    }
    */

    if ( pEncryptionCertificate && ( NULL == pEncryptionCertificate->pCertBlob)) {
       return ERROR_INVALID_PARAMETER;
    }

    DWORD rc =  EfsSetEncryptionKeyRPCClient( pEncryptionCertificate );

    return( rc );
}

VOID
EfsClientFreeHashList(
    IN PENCRYPTION_CERTIFICATE_HASH_LIST pHashList
    )
/*++

Routine Description:

    This routine frees the memory allocated by a call to
    QueryUsersOnEncryptedFile and QueryRecoveryAgentsOnEncryptedFile

Arguments:

    pHashList - Supplies the hash list to be freed.

Return Value:

    None.  Faults in user's context if passed bogus data.

--*/

{
    if (NULL == pHashList) {
       SetLastError(ERROR_INVALID_PARAMETER);
       return;
    }

    for (DWORD i=0; i<pHashList->nCert_Hash ; i++) {

         PENCRYPTION_CERTIFICATE_HASH pHash = pHashList->pUsers[i];

         if (pHash->lpDisplayInformation) {
             MIDL_user_free( pHash->lpDisplayInformation );
         }

         if (pHash->pUserSid) {
             MIDL_user_free( pHash->pUserSid );
         }

         MIDL_user_free( pHash->pHash->pbData );
         MIDL_user_free( pHash->pHash );
         MIDL_user_free( pHash );
    }

    MIDL_user_free( pHashList->pUsers );
    MIDL_user_free( pHashList );

    return;
}

DWORD
EfsGetMySDRpcBlob(
    IN PSECURITY_DESCRIPTOR pInSD,
    OUT PEFS_RPC_BLOB *pOutSDRpcBlob
    )
{
    DWORD rc = ERROR_SUCCESS;
    PSECURITY_DESCRIPTOR pRelativeSD;
    ULONG SDLength = 0;

    if ( (pInSD == NULL) || !RtlValidSecurityDescriptor(pInSD) ) {
        return(ERROR_INVALID_PARAMETER);
    }

    if ( ((PISECURITY_DESCRIPTOR)pInSD)->Control & SE_SELF_RELATIVE) {

        //
        // The input SD is already RELATIVE
        // Just fill EFS_RPC_BLOB
        //


        *pOutSDRpcBlob = (PEFS_RPC_BLOB) RtlAllocateHeap(
                                             RtlProcessHeap(),
                                             0,
                                             sizeof(EFS_RPC_BLOB) 
                                             );
        if (*pOutSDRpcBlob) {

            (*pOutSDRpcBlob)->cbData = RtlLengthSecurityDescriptor (
                                            pInSD
                                            );
            (*pOutSDRpcBlob)->pbData = (PBYTE) pInSD;

        } else {

            return(ERROR_NOT_ENOUGH_MEMORY);

        }


    } else {

        //
        // get the length
        //
        RtlMakeSelfRelativeSD( pInSD,
                               NULL,
                               &SDLength
                             );
    
        if ( SDLength > 0 ) {
    
            *pOutSDRpcBlob = (PEFS_RPC_BLOB) RtlAllocateHeap(
                                                 RtlProcessHeap(),
                                                 0,
                                                 SDLength + sizeof(EFS_RPC_BLOB) 
                                                 );

    
            if ( !(*pOutSDRpcBlob) ) {
                return(ERROR_NOT_ENOUGH_MEMORY);
            }

            pRelativeSD = (PSECURITY_DESCRIPTOR)(*pOutSDRpcBlob + 1);
            (*pOutSDRpcBlob)->cbData = SDLength;
            (*pOutSDRpcBlob)->pbData = (PBYTE) pRelativeSD;

    
            rc = RtlNtStatusToDosError(
                     RtlMakeSelfRelativeSD( pInSD,
                                            pRelativeSD,
                                            &SDLength
                                          ));
            if ( rc != ERROR_SUCCESS ) {
    
                RtlFreeHeap(RtlProcessHeap(), 0, *pOutSDRpcBlob);
                *pOutSDRpcBlob = NULL;
                return(rc);

            }
    
        } else {
    
            //
            // something is wrong with the SD
            //
            return(ERROR_INVALID_PARAMETER);
        }
    }

    return(rc);

}

DWORD
EfsClientDuplicateEncryptionInfo(
    IN LPCWSTR lpSrcFile,
    IN LPCWSTR lpDestFile,
    IN DWORD dwCreationDistribution, 
    IN DWORD dwAttributes, 
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes
    )
{
    DWORD rc = ERROR_SUCCESS;

    UNICODE_STRING SrcFullFileNameU;
    UNICODE_STRING DestFullFileNameU;

    if (TranslateFileName( lpSrcFile, &SrcFullFileNameU )) {

        if (TranslateFileName( lpDestFile, &DestFullFileNameU )) {

            PEFS_RPC_BLOB pRpcBlob = NULL;
            BOOL bInheritHandle = FALSE;

            if (lpSecurityAttributes) {
                rc = EfsGetMySDRpcBlob(lpSecurityAttributes->lpSecurityDescriptor, &pRpcBlob);
                bInheritHandle = lpSecurityAttributes->bInheritHandle;
            }
            
            if (ERROR_SUCCESS == rc) {

                rc = EfsDuplicateEncryptionInfoRPCClient(
                        SrcFullFileNameU.Buffer,
                        DestFullFileNameU.Buffer,
                        dwCreationDistribution,
                        dwAttributes,
                        pRpcBlob,
                        bInheritHandle
                        );

                if (pRpcBlob) {

                    RtlFreeHeap(RtlProcessHeap(), 0, pRpcBlob);

                }
    
            }

            RtlFreeHeap(RtlProcessHeap(), 0, DestFullFileNameU.Buffer);

        } else {

            rc = GetLastError();
        }

        RtlFreeHeap(RtlProcessHeap(), 0, SrcFullFileNameU.Buffer);

    } else {

        rc = GetLastError();
    }

    return( rc );

}


DWORD
EfsClientFileKeyInfo(
    IN      LPCWSTR        lpFileName,
    IN      DWORD          InfoClass,
    OUT     PEFS_RPC_BLOB  *KeyInfo
    )
/*++

Routine Description:

    Calls client stub for EncryptedFileKeyInfo EFS API

Arguments:

    lpFileName - Supplies the name of the file.

    KeyInfo - Returns a pointer to a structure containing key info.
    
Return Value:

--*/
{
    DWORD        rc;
    UNICODE_STRING FullFileNameU;

    if ((NULL == lpFileName) || (NULL == KeyInfo)) {
       return ERROR_INVALID_PARAMETER;
    }
    if (TranslateFileName( lpFileName, &FullFileNameU )) {

        rc =  EfsFileKeyInfoRPCClient( FullFileNameU.Buffer, InfoClass, KeyInfo );

        RtlFreeHeap(RtlProcessHeap(), 0, FullFileNameU.Buffer);

    } else {

        rc = GetLastError();
    }

    return rc;
}


VOID
EfsClientFreeKeyInfo(
    IN PEFS_RPC_BLOB  pKeyInfo
    )
/*++

Routine Description:

    This routine frees the memory allocated by a call to
    EfsClientFileKeyInfo

Arguments:

    pKeyInfo - Supplies the memory pointer to be freed.

Return Value:

    None.  Faults in user's context if passed bogus data.

--*/

{
    if (NULL == pKeyInfo) {
       SetLastError(ERROR_INVALID_PARAMETER);
       return;
    }

    if (pKeyInfo->pbData) {
        MIDL_user_free( pKeyInfo->pbData );
    }
    
    MIDL_user_free( pKeyInfo );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\credui\controls.cpp ===
//=============================================================================
// Copyright (c) 2000 Microsoft Corporation
//
// controls.cpp
//
// User interface control classes.
//
// Created 02/29/2000 johnstep (John Stephens)
//=============================================================================

#include "precomp.hpp"
#include "controls.hpp"
#include "resource.h"
#include "utils.hpp"
#include <shlguid.h>
#include <htmlhelp.h>

//-----------------------------------------------------------------------------
// Values
//-----------------------------------------------------------------------------

// These are the positions of the children controls of the credential control,
// in DLUs:

// make more space to localize the edit control tags.
#define SIZEFIX 20

#define CREDUI_CONTROL_USERNAME_STATIC_X          0
#define CREDUI_CONTROL_USERNAME_STATIC_Y          2
#define CREDUI_CONTROL_USERNAME_STATIC_WIDTH      (48 + SIZEFIX)
#define CREDUI_CONTROL_USERNAME_STATIC_HEIGHT     8

#define CREDUI_CONTROL_USERNAME_X                (50 + SIZEFIX)
#define CREDUI_CONTROL_USERNAME_Y                 0
#define CREDUI_CONTROL_USERNAME_WIDTH           (121 - SIZEFIX)
#define CREDUI_CONTROL_USERNAME_HEIGHT           96

#define CREDUI_CONTROL_VIEW_X                   175
#define CREDUI_CONTROL_VIEW_Y                     0
#define CREDUI_CONTROL_VIEW_WIDTH                13
#define CREDUI_CONTROL_VIEW_HEIGHT               13

#define CREDUI_CONTROL_PASSWORD_STATIC_X          0
#define CREDUI_CONTROL_PASSWORD_STATIC_Y         19
#define CREDUI_CONTROL_PASSWORD_STATIC_WIDTH      (48 + SIZEFIX)
#define CREDUI_CONTROL_PASSWORD_STATIC_HEIGHT     8

#define CREDUI_CONTROL_PASSWORD_X                (50 + SIZEFIX)
#define CREDUI_CONTROL_PASSWORD_Y                17
#define CREDUI_CONTROL_PASSWORD_WIDTH           (121 - SIZEFIX)
#define CREDUI_CONTROL_PASSWORD_HEIGHT           12

#define CREDUI_CONTROL_SAVE_X                    (50 + SIZEFIX)
#define CREDUI_CONTROL_SAVE_Y                    36
#define CREDUI_CONTROL_SAVE_WIDTH               138
#define CREDUI_CONTROL_SAVE_HEIGHT               10

// Use a common maximum string length for certificate display names:

#define CREDUI_MAX_CERT_NAME_LENGTH 256
#define CREDUI_MAX_CMDLINE_MSG_LENGTH   256


//-----------------------------------------------------------------------------
// Global Variables
//-----------------------------------------------------------------------------

CLSID CreduiStringArrayClassId = // 82BD0E67-9FEA-4748-8672-D5EFE5B779B0
{
    0x82BD0E67,
    0x9FEA,
    0x4748,
    {0x86, 0x72, 0xD5, 0xEF, 0xE5, 0xB7, 0x79, 0xB0}
};

// Balloon tip infos for PasswordBox control:
CONST CREDUI_BALLOON_TIP_INFO CreduiCapsLockTipInfo =
{
    CreduiStrings.CapsLockTipTitle,
    CreduiStrings.CapsLockTipText,
    TTI_WARNING, 90, 76
};
// Balloon tip infos for Credential control:

CONST CREDUI_BALLOON_TIP_INFO CreduiBackwardsTipInfo =
{
    CreduiStrings.BackwardsTipTitle,
    CreduiStrings.BackwardsTipText,
    TTI_ERROR, 90, 76
};

WCHAR CreduiCustomTipTitle[CREDUI_MAX_BALLOON_TITLE_LENGTH + 1];
WCHAR CreduiCustomTipMessage[CREDUI_MAX_BALLOON_MESSAGE_LENGTH + 1];

CREDUI_BALLOON_TIP_INFO CreduiCustomTipInfo =
{
    CreduiCustomTipTitle,
    CreduiCustomTipMessage,
    TTI_INFO, 90, 76
};

//-----------------------------------------------------------------------------
// CreduiBalloonTip Class Implementation
//-----------------------------------------------------------------------------

//=============================================================================
// CreduiBalloonTip::CreduiBalloonTip
//
// Created 02/24/2000 johnstep (John Stephens)
//=============================================================================

CreduiBalloonTip::CreduiBalloonTip()
{
    Window = NULL;

    ParentWindow = NULL;
    ControlWindow = NULL;

    TipInfo = NULL;

    Visible = FALSE;
}

//=============================================================================
// CreduiBalloonTip::~CreduiBalloonTip
//
// Created 02/24/2000 johnstep (John Stephens)
//=============================================================================

CreduiBalloonTip::~CreduiBalloonTip()
{
    if (Window != NULL)
    {
        DestroyWindow(Window);
        Window = NULL;
    }
}

//=============================================================================
// CreduiBalloonTip::Init
//
// Creates and initializes the balloon window.
//
// Arguments:
//   instance (in) - this module
//   parentWindow (in) - the parent of the tool tip window
//
// Returns TRUE on success or FALSE otherwise.
//
// Created 02/24/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiBalloonTip::Init(
    HINSTANCE instance,
    HWND parentWindow
    )
{
    if (Window != NULL)
    {
        DestroyWindow(Window);

        Window = NULL;

        ParentWindow = NULL;
        ControlWindow = NULL;

        TipInfo = NULL;

        Visible = FALSE;
    }

    Window = CreateWindowEx(NULL, TOOLTIPS_CLASS, NULL,
                            WS_POPUP | TTS_NOPREFIX | TTS_BALLOON,
                            CW_USEDEFAULT, CW_USEDEFAULT,
                            CW_USEDEFAULT, CW_USEDEFAULT,
                            parentWindow, NULL, instance, NULL);

    // Only assign class member values once we have successfully created the
    // window:

    if (Window != NULL)
    {
        ParentWindow = parentWindow;
        TipInfo = NULL;
        return TRUE;
    }

    return FALSE;
}

//=============================================================================
// CreduiBalloonTip::SetInfo
//
// Sets the tool tip information and adds or updates the tool.
//
// Returns TRUE on success or FALSE otherwise.
//
// Created 03/02/2000 johnstep (John Stephens)
//=============================================================================

BOOL CreduiBalloonTip::SetInfo(
    HWND controlWindow,
    CONST CREDUI_BALLOON_TIP_INFO *tipInfo
    )
{
    //if ((controlWindow != ControlWindow) || (tipInfo != TipInfo))
    {
        TOOLINFO info;

        ZeroMemory(&info, sizeof info);

        info.cbSize = sizeof info;
        info.hwnd = ParentWindow;
        info.uId = reinterpret_cast<WPARAM>(ParentWindow);

        // If the tool already exists, hide it, then update the information.
        // Otherwise, add the tool now:

        if (SendMessage(Window, TTM_GETTOOLINFO, 0,
                reinterpret_cast<LPARAM>(&info)))
        {
            if (Visible)
            {
                Hide();
            }

            ZeroMemory(&info, sizeof info);

            info.cbSize = sizeof info;
            info.hwnd = ParentWindow;
            info.uId = reinterpret_cast<WPARAM>(ParentWindow);

            info.uFlags = TTF_IDISHWND | TTF_TRACK;
            info.hinst = NULL;
            info.lpszText = const_cast<WCHAR *>(tipInfo->Text);
            info.lParam = 0;

            SendMessage(Window, TTM_SETTOOLINFO, 0,
                reinterpret_cast<LPARAM>(&info));
        }
        else
        {
            info.uFlags = TTF_IDISHWND | TTF_TRACK;
            info.hinst = NULL;
            info.lpszText = const_cast<WCHAR *>(tipInfo->Text);
            info.lParam = 0;

            if (!SendMessage(Window, TTM_ADDTOOL, 0,
                reinterpret_cast<LPARAM>(&info)))
            {
                return FALSE;
            }
        }

        SendMessage(Window, TTM_SETTITLE, tipInfo->Icon,
                    reinterpret_cast<LPARAM>(tipInfo->Title));

        TipInfo = const_cast<CREDUI_BALLOON_TIP_INFO *>(tipInfo);
        ControlWindow = controlWindow;
    }

    return TRUE;
}

//=============================================================================
// CreduiBalloonTip::Show
//
// Updates the position of the balloon window, and then displays it.
//
// Returns TRUE on success or FALSE otherwise.
//
// Created 02/24/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiBalloonTip::Show()
{
    if (!Visible && IsWindowEnabled(ControlWindow))
    {
        SetFocus(ControlWindow);

        RECT rect;
        GetWindowRect(ControlWindow, &rect);

        SendMessage(Window,
                    TTM_TRACKPOSITION, 0,
                    MAKELONG(
                        rect.left + TipInfo->XPercent *
                            (rect.right - rect.left) / 100,
                        rect.top + TipInfo->YPercent *
                            (rect.bottom - rect.top) / 100));

        TOOLINFO info;

        ZeroMemory(&info, sizeof info);

        info.cbSize = sizeof info;
        info.hwnd = ParentWindow;
        info.uId = reinterpret_cast<WPARAM>(ParentWindow);

        SendMessage(Window, TTM_TRACKACTIVATE, TRUE,
            reinterpret_cast<LPARAM>(&info));

        Visible = TRUE;
    }

    return TRUE;
}

//=============================================================================
// CreduiBalloonTip::Hide
//
// Hides the balloon window.
//
// Returns TRUE on success or FALSE otherwise.
//
// Created 02/24/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiBalloonTip::Hide()
{
    if (Visible)
    {
        SendMessage(Window, TTM_TRACKACTIVATE, (WPARAM) FALSE, 0);

        Visible = FALSE;

        if (ParentWindow)
        {
            HWND hD = GetParent(ParentWindow);
            if (hD) 
            {
                InvalidateRgn(hD,NULL,FALSE);
                UpdateWindow(hD);
            }
        }
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
// CreduiPasswordBox Class Implementation
//-----------------------------------------------------------------------------

//=============================================================================
// CreduiPasswordBox::CreduiPasswordBox
//
// Created 06/06/2000 johnstep (John Stephens)
//=============================================================================

CreduiPasswordBox::CreduiPasswordBox()
{
    OriginalMessageHandler = NULL;

    Window = NULL;
    PasswordFont = NULL;
    BalloonTip = NULL;
    CapsLockTipInfo = NULL;
}

//=============================================================================
// CreduiPasswordBox::~CreduiPasswordBox
//
// Created 06/06/2000 johnstep (John Stephens)
//=============================================================================

CreduiPasswordBox::~CreduiPasswordBox()
{
    if (PasswordFont != NULL)
    {
        DeleteObject(static_cast<HGDIOBJ>(PasswordFont));
        PasswordFont = NULL;
    }
}

//=============================================================================
// CreduiPasswordBox::Init
//
// Created 06/06/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiPasswordBox::Init(
    HWND window,
    CreduiBalloonTip *balloonTip,
    CONST CREDUI_BALLOON_TIP_INFO *capsLockTipInfo,
    HFONT passwordFont,
    WCHAR passwordChar)
{
    // If passwordFont was passed, use it here, but leave the class
    // PasswordFont NULL so it will not be cleaned up by the destructor. If
    // it was not passed, create a font here, which will be freed by the
    // destructor:

    if (passwordFont == NULL)
    {
        passwordFont = PasswordFont;
    }

    Window = window;

    // If we still failed to create the font, and are not planning to display
    // balloon tips, then there's nothing do to, just return.

    if ((passwordFont == NULL) && (balloonTip == NULL))
    {
        return FALSE;
    }

    if (balloonTip != NULL)
    {
        if (capsLockTipInfo == NULL)
        {
            return FALSE;
        }

        BalloonTip = balloonTip;
        CapsLockTipInfo = capsLockTipInfo;

        OriginalMessageHandler =
            reinterpret_cast<WNDPROC>(
                GetWindowLongPtr(Window, GWLP_WNDPROC));

        if (OriginalMessageHandler != NULL)
        {
            SetLastError(ERROR_SUCCESS);

            if ((SetWindowLongPtr(
                    Window,
                    GWLP_USERDATA,
                    reinterpret_cast<LONG_PTR>(this)) == 0) &&
                (GetLastError() != ERROR_SUCCESS))
            {
                return FALSE;
            }

            SetLastError(ERROR_SUCCESS);

            if (SetWindowLongPtr(
                    Window,
                    GWLP_WNDPROC,
                    reinterpret_cast<LONG_PTR>(MessageHandlerCallback)) &&
                (GetLastError() != ERROR_SUCCESS))
            {
                return FALSE;
            }
        }
        else
        {
            return FALSE;
        }
    }

    if (passwordFont != NULL)
    {
        SendMessage(Window,
                    WM_SETFONT,
                    reinterpret_cast<WPARAM>(passwordFont),
                    0);
        SendMessage(Window, EM_SETPASSWORDCHAR, passwordChar, 0);

    }


    return TRUE;
}


//=============================================================================
// CreduiPasswordBox::MessageHandler
//
// This callback function just calls through to the original, except in a
// special case where Caps Lock is pressed. We then check to see if the tip is
// currently being displayed, and if the new state of Caps Lock is off, hide
// the tip.
//
// Arguments:
//   message (in)
//   wParam (in)
//   lParam (in)
//
// Returns the result of calling the original message handler in every case.
//
// Created 02/25/2000 johnstep (John Stephens)
//=============================================================================

LRESULT
CreduiPasswordBox::MessageHandler(
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch (message)
    {
    case WM_KEYDOWN:
        if (wParam == VK_CAPITAL)
        {
        }
        else
        {
            if (BalloonTip->IsVisible())
            {
                BalloonTip->Hide();
            }
        }

        break;

    case WM_SETFOCUS:
        // Make sure no one can steal the focus while a user is
        // entering their password:

        LockSetForegroundWindow(LSFW_LOCK);

        // If the Caps Lock key is down, notify the user, unless the
        // password tip is already visible:

        if (!BalloonTip->IsVisible() && CreduiIsCapsLockOn())
        {
//            BalloonTip->SetInfo(Window, CapsLockTipInfo);
//            BalloonTip->Show();
        }

        break;

    case WM_PASTE:
        if (BalloonTip->IsVisible())
        {
            BalloonTip->Hide();
        }
        break;

    case WM_KILLFOCUS:
        if (BalloonTip->IsVisible())
        {
            BalloonTip->Hide();
        }

        // Make sure other processes can set foreground window
        // once again:

        LockSetForegroundWindow(LSFW_UNLOCK);

        break;
    }

    return CallWindowProc(OriginalMessageHandler,
                          Window,
                          message,
                          wParam,
                          lParam);
}

//=============================================================================
// CreduiPasswordBox::MessageHandlerCallback
//
// This calls through to CreduiPasswordBox::MessageHandler, from the this
// pointer.
//
// Arguments:
//   passwordWindow (in)
//   message (in)
//   wParam (in)
//   lParam (in)
//
// Returns the result of calling the original message handler in every case.
//
// Created 02/25/2000 johnstep (John Stephens)
//=============================================================================

LRESULT
CALLBACK
CreduiPasswordBox::MessageHandlerCallback(
    HWND passwordWindow,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    CreduiPasswordBox *that =
        reinterpret_cast<CreduiPasswordBox *>(
            GetWindowLongPtr(passwordWindow, GWLP_USERDATA));

    ASSERT(that != NULL);
    ASSERT(that->BalloonTip != NULL);
    ASSERT(that->CapsLockTipInfo != NULL);

    ASSERT(that->Window == passwordWindow);

    return that->MessageHandler(message, wParam, lParam);
}

//-----------------------------------------------------------------------------
// CreduiStringArrayFactory Class Implementation
//-----------------------------------------------------------------------------

//=============================================================================
// CreduiStringArrayFactory::CreduiStringArrayFactory
//
// Created 04/03/2000 johnstep (John Stephens)
//=============================================================================

CreduiStringArrayFactory::CreduiStringArrayFactory()
{
    ReferenceCount = 1;
}

//=============================================================================
// CreduiStringArrayFactory::~CreduiStringArrayFactory
//
// Created 04/03/2000 johnstep (John Stephens)
//=============================================================================

CreduiStringArrayFactory::~CreduiStringArrayFactory()
{
}

//=============================================================================
// CreduiStringArrayFactory::QueryInterface (IUnknown)
//
// Created 04/03/2000 johnstep (John Stephens)
//=============================================================================

HRESULT
CreduiStringArrayFactory::QueryInterface(
    CONST IID &interfaceId,
    VOID **outInterface
    )
{
    if ((interfaceId == IID_IUnknown) || (interfaceId == IID_IClassFactory))
    {
        *outInterface = static_cast<void *>(static_cast<IClassFactory *>(this));
    }
    else
    {
        *outInterface = NULL;
        return E_NOINTERFACE;
    }

    static_cast<IUnknown *>(*outInterface)->AddRef();
    return S_OK;
}

//=============================================================================
// CreduiStringArrayFactory::Addref (IUnknown)
//
// Created 04/03/2000 johnstep (John Stephens)
//=============================================================================

ULONG
CreduiStringArrayFactory::AddRef()
{
    return InterlockedIncrement(reinterpret_cast<LONG *>(&ReferenceCount));
}

//=============================================================================
// CreduiStringArrayFactory::Release (IUnknown)
//
// Created 04/03/2000 johnstep (John Stephens)
//=============================================================================

ULONG
CreduiStringArrayFactory::Release()
{
    if (InterlockedDecrement(reinterpret_cast<LONG *>(&ReferenceCount)) > 0)
    {
        return ReferenceCount;
    }

    delete this;

    return 0;
}

//=============================================================================
// CreduiClassFactory::CreateInstance (IClassFactory)
//
// Created 04/03/2000 johnstep (John Stephens)
//=============================================================================

HRESULT
CreduiStringArrayFactory::CreateInstance(
    IUnknown *unknownOuter,
    CONST IID &interfaceId,
    VOID **outInterface
    )
{
    if (unknownOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION;
    }

    CreduiStringArray *stringArray = new CreduiStringArray;

    if (stringArray == NULL)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT result = stringArray->QueryInterface(interfaceId, outInterface);

    // Release the string array object in any case, because of the
    // QueryInterface succeeded, it already took another reference count on
    // the object:

    stringArray->Release();

    return result;
}

//=============================================================================
// CreduiClassFactory::LockServer (IClassFactory)
//
// Created 04/03/2000 johnstep (John Stephens)
//=============================================================================

HRESULT
CreduiStringArrayFactory::LockServer(
    BOOL lock
    )
{
    if (lock)
    {
        InterlockedIncrement(reinterpret_cast<LONG *>(
            &CreduiComReferenceCount));
    }
    else
    {
        InterlockedDecrement(reinterpret_cast<LONG *>(
            &CreduiComReferenceCount));
    }

    return S_OK;
}

//-----------------------------------------------------------------------------
// CreduiStringArray Class Implementation
//-----------------------------------------------------------------------------

//=============================================================================
// CreduiStringArray::CreduiStringArray
//
// Created 02/25/2000 johnstep (John Stephens)
//=============================================================================

CreduiStringArray::CreduiStringArray()
{
    ReferenceCount = 1;
    Index = 0;
    Count = 0;
    MaxCount = 0;
    Array = NULL;

    InterlockedIncrement(reinterpret_cast<LONG *>(&CreduiComReferenceCount));
}

//=============================================================================
// CreduiStringArray::~CreduiStringArray
//
// Created 02/25/2000 johnstep (John Stephens)
//=============================================================================

CreduiStringArray::~CreduiStringArray()
{
    if (Array != NULL)
    {
        while (Count > 0)
        {
            delete [] Array[--Count];
        }

        delete [] Array;
        MaxCount = 0;
        Count = 0;
    }

    InterlockedDecrement(reinterpret_cast<LONG *>(&CreduiComReferenceCount));
}

//=============================================================================
// CreduiStringArray::Init
//
// Initializes the string array.
//
// Arguments:
//   count (in) - number of strings in the array
//
// Returns TRUE on success or FALSE otherwise.
//
// Created 02/25/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiStringArray::Init(
    UINT count
    )
{
    Count = 0;
    MaxCount = count;

    Array = new WCHAR *[count];

    if (Array != NULL)
    {
        return TRUE;
    }

    // Clean up:

    MaxCount = 0;

    return FALSE;
}

//=============================================================================
// CreduiStringArray::Find
//
// Searches for a string in the array.
//
// Arguments:
//   string (in) - string to search for
//
// Returns TRUE if the string was found or FALSE otherwise.
//
// Created 02/27/2000 johnstep (John Stephens)
//=============================================================================

BOOL CreduiStringArray::Find(
    CONST WCHAR *string
    )
{
    // Search for the string:

    for (UINT i = 0; i < Count; ++i)
    {
        ASSERT(Array[i] != NULL);

        if (lstrcmpi(Array[i], string) == 0)
        {
            return TRUE;
        }
    }

    return FALSE;
}

//=============================================================================
// CreduiStringArray::Add
//
// Adds a string to the array.
//
// Arguments:
//   string (in) - string to add
//
// Returns TRUE if the string was added or FALSE otherwise.
//
// Created 02/25/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiStringArray::Add(
    CONST WCHAR *string
    )
{
    // The array does not grow, so once we reach the limit, no more:

    if (Count < MaxCount)
    {
        Array[Count] = new WCHAR[lstrlen(string) + 1];

        if (Array[Count] != NULL)
        {
            lstrcpy(Array[Count++], string);
            return TRUE;
        }
    }

    return FALSE;
}

//=============================================================================
// CreduiStringArray::QueryInterface (IUnknown)
//
// Created 02/25/2000 johnstep (John Stephens)
//=============================================================================

HRESULT
CreduiStringArray::QueryInterface(
    CONST IID &interfaceId,
    VOID **outInterface
    )
{
    if ((interfaceId == IID_IUnknown) || (interfaceId == IID_IEnumString))
    {
        *outInterface = static_cast<void *>(static_cast<IEnumString *>(this));
    }
    else
    {
        *outInterface = NULL;
        return E_NOINTERFACE;
    }

    static_cast<IUnknown *>(*outInterface)->AddRef();
    return S_OK;
}

//=============================================================================
// CreduiStringArray::Addref (IUnknown)
//
// Created 02/25/2000 johnstep (John Stephens)
//=============================================================================

ULONG
CreduiStringArray::AddRef()
{
    return InterlockedIncrement(reinterpret_cast<LONG *>(&ReferenceCount));
}

//=============================================================================
// CreduiStringArray::Release (IUnknown)
//
// Created 02/25/2000 johnstep (John Stephens)
//=============================================================================

ULONG
CreduiStringArray::Release()
{
    if (InterlockedDecrement(reinterpret_cast<LONG *>(&ReferenceCount)) > 0)
    {
        return ReferenceCount;
    }

    delete this;

    return 0;
}

//=============================================================================
// CreduiStringArray::Next (IEnumString)
//
// Created 02/25/2000 johnstep (John Stephens)
//=============================================================================

HRESULT
CreduiStringArray::Next(
    ULONG count,
    LPOLESTR *array,
    ULONG *countFetched
    )
{
    if ((count > 1) && (countFetched == NULL))
    {
        return E_INVALIDARG;
    }

    count = min(count, Count - Index);

    for (UINT i = 0; i < count; ++i)
    {
        array[i] = static_cast<WCHAR *>(CoTaskMemAlloc(
            (sizeof (WCHAR)) * (lstrlen(Array[Index]) + 1)));

        if (array[i] != NULL)
        {
            lstrcpy(array[i], Array[Index]);
        }
        else
        {
            while (i > 0)
            {
                CoTaskMemFree(array[--i]);
                array[i] = NULL;
            }

            if (countFetched != NULL)
            {
                *countFetched = 0;
            }

            return E_OUTOFMEMORY;
        }

        Index++;
    }

    if (countFetched != NULL)
    {
        *countFetched = count;
    }

    return (count > 0) ? S_OK : S_FALSE;
}

//=============================================================================
// CreduiStringArray::Skip (IEnumString)
//
// Created 02/25/2000 johnstep (John Stephens)
//=============================================================================

HRESULT
CreduiStringArray::Skip(
    ULONG
    )
{
    return E_NOTIMPL;
}

//=============================================================================
// CreduiStringArray::Reset (IEnumString)
//
// Created 02/25/2000 johnstep (John Stephens)
//=============================================================================

HRESULT
CreduiStringArray::Reset()
{
    Index = 0;

    return S_OK;
}

//=============================================================================
// CreduiStringArray::Clone (IEnumString)
//
// Created 02/25/2000 johnstep (John Stephens)
//=============================================================================

HRESULT
CreduiStringArray::Clone(
    IEnumString **
    )
{
    return E_NOTIMPL;
}

//-----------------------------------------------------------------------------
// CreduiAutoCompleteComboBox Class Implementation
//-----------------------------------------------------------------------------

//=============================================================================
// CreduiAutoCompleteComboBox::CreduiAutoCompleteComboBox
//
// Created 02/25/2000 johnstep (John Stephens)
//=============================================================================

CreduiAutoCompleteComboBox::CreduiAutoCompleteComboBox()
{
    Window = NULL;
    ImageList = NULL;
    StringArray = NULL;
}

//=============================================================================
// CreduiAutoCompleteComboBox::~CreduiAutoCompleteComboBox
//
// Created 02/25/2000 johnstep (John Stephens)
//=============================================================================

CreduiAutoCompleteComboBox::~CreduiAutoCompleteComboBox()
{
    if (StringArray != NULL)
    {
        StringArray->Release();
        StringArray = NULL;
    }

    if (ImageList != NULL)
    {
        ImageList_Destroy(ImageList);
        ImageList = NULL;
    }
}

//=============================================================================
// CreduiAutoCompleteComboBox::Init
//
// Initializes the shell auto complete list control for the given combo box,
// and sets the auto complete string list.
//
// Arguments:
//   instance (in)
//   comboBoxWindow (in)
//   stringCount (in)
//   imageListResourceId (in) - optional image list for the combo box
//
// Returns TRUE on success or FALSE otherwise.
//
// Created 02/25/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiAutoCompleteComboBox::Init(
    HMODULE instance,
    HWND comboBoxWindow,
    UINT stringCount,
    INT imageListResourceId,
    INT initialImage
    )
{
    Window = comboBoxWindow;

    if (imageListResourceId != 0)
    {
        ImageList = ImageList_LoadImage(
            instance,
            MAKEINTRESOURCE(imageListResourceId),
            0, 16, RGB(0, 128, 128), IMAGE_BITMAP,
            LR_DEFAULTSIZE | LR_SHARED);

        if (ImageList != NULL)
        {
            SendMessage(Window,
                        CBEM_SETIMAGELIST,
                        0, reinterpret_cast<LPARAM>(ImageList));
        }
        else
        {
            return FALSE;
        }
    }

    BOOL success = FALSE;

    if (stringCount > 0)
    {
        HRESULT result =
            CoCreateInstance(CreduiStringArrayClassId,
                             NULL,
                             CLSCTX_INPROC_SERVER,
                             IID_IEnumString,
                             reinterpret_cast<VOID **>(&StringArray));

        if (SUCCEEDED(result))
        {
            if (StringArray->Init(stringCount))
            {
                success = TRUE;
            }
            else
            {
                StringArray->Release();
                StringArray = NULL;
            }
        }
    }
    else
    {
        success = TRUE;
    }

    if (success == TRUE)
    {
        COMBOBOXEXITEMW item;

        item.mask = CBEIF_IMAGE | CBEIF_SELECTEDIMAGE;
        item.iItem = -1;
        item.iImage = initialImage;
        item.iSelectedImage = initialImage;

        SendMessage(Window, CBEM_SETITEM, 0,
                    reinterpret_cast<LPARAM>(&item));

        return TRUE;
    }

    if (ImageList != NULL)
    {
        ImageList_Destroy(ImageList);
        ImageList = NULL;
    }

    return FALSE;
}

//=============================================================================
// CreduiAutoCompleteComboBox::Add
//
// Returns the index of the new item or -1 on failure.
//
// Created 02/25/2000 johnstep (John Stephens)
//=============================================================================

INT
CreduiAutoCompleteComboBox::Add(
    WCHAR *string,
    INT image,
    BOOL autoComplete,
    BOOL addUnique,
    INT indexBefore,
    INT indent
    )
{
    INT index = -1;

    if (addUnique)
    {
        index = (INT) SendMessage(Window, CB_FINDSTRINGEXACT, 0,
                                  reinterpret_cast<LPARAM>(string));
    }

    if (index == -1)
    {
        if (!autoComplete || StringArray->Add(string))
        {
            COMBOBOXEXITEMW item;

            item.mask = CBEIF_TEXT | CBEIF_INDENT;
            item.iItem = indexBefore;
            item.pszText = string;
            item.iIndent = indent;

            if (ImageList != NULL)
            {
                item.mask |= CBEIF_IMAGE | CBEIF_SELECTEDIMAGE;
                item.iImage = image;
                item.iSelectedImage = image;
            }

            index = (INT) SendMessage(Window, CBEM_INSERTITEM, 0,
                                      reinterpret_cast<LPARAM>(&item));
        }
    }

    return index;
}

//=============================================================================
// CreduiAutoCompleteComboBox::Update
//
// Updates an existing item. This does not update the associated string for
// auto complete items.
//
// Created 04/15/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiAutoCompleteComboBox::Update(
    INT index,
    WCHAR *string,
    INT image
    )
{
    COMBOBOXEXITEMW item;

    item.iItem = index;

    // Use CBEM_SETITEM in these cases:
    //
    // 1. We're updating the default (-1) item.
    // 2. The dropdown is closed.
    //
    // For other cases, we delete and recreate the item for the desired
    // result.

    BOOL isDropped = (BOOL) SendMessage(Window, CB_GETDROPPEDSTATE, 0, 0);

    if ((index == -1) || !isDropped)
    {
        item.mask = CBEIF_TEXT;
        item.pszText = string;

        if (ImageList != NULL)
        {
            item.mask |= CBEIF_IMAGE | CBEIF_SELECTEDIMAGE;
            item.iImage = image;
            item.iSelectedImage = image;
        }

        if (SendMessage(Window, CBEM_SETITEM, 0,
                        reinterpret_cast<LPARAM>(&item)) != 0)
        {
            RECT rect;

            GetClientRect(Window, &rect);
            InvalidateRect(Window, &rect, FALSE);

            return TRUE;
        }
    }
    else
    {
        item.mask = CBEIF_IMAGE | CBEIF_INDENT | CBEIF_SELECTEDIMAGE;

        if (SendMessage(Window, CBEM_GETITEM,
                        0, reinterpret_cast<LPARAM>(&item)))
        {
            item.mask |= CBEIF_TEXT;
            item.pszText = string;

            LPARAM data = SendMessage(Window, CB_GETITEMDATA, index, 0);

            if (ImageList != NULL)
            {
                item.mask |= CBEIF_IMAGE | CBEIF_SELECTEDIMAGE;
                item.iImage = image;
                item.iSelectedImage = image;
            }

            SendMessage(Window, CBEM_DELETEITEM, index, 0);

            index = (INT) SendMessage(Window, CBEM_INSERTITEM, 0,
                                      reinterpret_cast<LPARAM>(&item));

            if (index != -1)
            {
                SendMessage(Window, CB_SETITEMDATA, index, data);

                INT current = (INT) SendMessage(Window, CB_GETCURSEL, 0, 0);

                if (current == index)
                {
                    SendMessage(Window, CB_SETCURSEL, current, 0);
                }

                return TRUE;
            }
        }
    }

    return FALSE;
}

//=============================================================================
// CreduiAutoCompleteComboBox::Enable
//
// Created 02/27/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiAutoCompleteComboBox::Enable()
{
    BOOL success = TRUE;

    if (StringArray != NULL)
    {
        success = FALSE;

        IAutoComplete2 *autoCompleteInterface;

        HRESULT result =
            CoCreateInstance(
                CLSID_AutoComplete,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IAutoComplete2,
                reinterpret_cast<void **>(&autoCompleteInterface));

        if (SUCCEEDED(result))
        {
            result = autoCompleteInterface->Init((HWND)
                SendMessage(Window, CBEM_GETEDITCONTROL, 0, 0),
                    StringArray, NULL, NULL);

            if (SUCCEEDED(result))
            {
                result = autoCompleteInterface->SetOptions(ACO_AUTOSUGGEST);

                if (SUCCEEDED(result))
                {
                    success = TRUE;
                }
                else
                {
                    CreduiDebugLog("CreduiAutoCompleteComboBox::Enable: "
                                   "SetOptions failed: 0x%08X\n", result);
                }
            }

            autoCompleteInterface->Release();
            autoCompleteInterface = NULL;
        }
        else
        {
            CreduiDebugLog(
                "CreduiAutoCompleteComboBox::Enable: "
                "CoCreateInstance CLSID_AutoComplete failed: 0x%08X\n",
                result);
        }

        StringArray->Release();
        StringArray = NULL;
    }

    return success;
}

//-----------------------------------------------------------------------------
// CreduiIconParentWindow Class Implementation
//-----------------------------------------------------------------------------

CONST WCHAR *CreduiIconParentWindow::ClassName = L"CreduiIconParentWindow";
HINSTANCE CreduiIconParentWindow::Instance = NULL;
LONG CreduiIconParentWindow::Registered = FALSE;

//=============================================================================
// CreduiIconParentWindow::CreduiIconParentWindow
//
// Created 02/29/2000 johnstep (John Stephens)
//=============================================================================

CreduiIconParentWindow::CreduiIconParentWindow()
{
    Window = NULL;
}

//=============================================================================
// CreduiIconParentWindow::~CreduiIconParentWindow
//
// Created 02/29/2000 johnstep (John Stephens)
//=============================================================================

CreduiIconParentWindow::~CreduiIconParentWindow()
{
    if (Window != NULL)
    {
        DestroyWindow(Window);
        Window = NULL;
    }
}

//=============================================================================
// CreduiIconParentWindow::Register
//
// Set the instance to allow registration, which will be deferred until a
// window needs to be created.
//
// Arguments:
//   instance (in)
//
// Returns TRUE on success or FALSE otherwise.
//
// Created 04/16/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiIconParentWindow::Register(
    HINSTANCE instance
    )
{
    Instance = instance;

    return TRUE;
}

//=============================================================================
// CreduiIconParentWindow::Unegister
//
// Unregisters the window class, if registered.
//
// Returns TRUE on success or FALSE otherwise.
//
// Created 04/16/2000 johnstep (John Stephens)
//=============================================================================

BOOL CreduiIconParentWindow::Unregister()
{
    if (InterlockedCompareExchange(&Registered, FALSE, TRUE))
    {
        return UnregisterClass(ClassName, Instance);
    }

    return TRUE;
}

//=============================================================================
// CreduiIconParentWindow::Init
//
// Registers the window class, if not already registered, and creates the
// window.
//
// Arguments:
//   instance (in) - module to load the icon from
//   iconResourceId (in)
//
// Returns TRUE on success or FALSE otherwise.
//
// Created 02/29/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiIconParentWindow::Init(
    HINSTANCE instance,
    UINT iconResourceId
    )
{
    WNDCLASS windowClass;

    ZeroMemory(&windowClass, sizeof windowClass);

    if (!InterlockedCompareExchange(&Registered, TRUE, FALSE))
    {
        windowClass.lpfnWndProc = DefWindowProc;
        windowClass.hInstance = Instance;
        windowClass.hIcon =
            LoadIcon(instance, MAKEINTRESOURCE(iconResourceId));
        windowClass.hCursor = LoadCursor(NULL, MAKEINTRESOURCE(IDC_ARROW));
        windowClass.lpszClassName = ClassName;

        InterlockedExchange(&Registered, RegisterClass(&windowClass) != 0);

        if (!InterlockedCompareExchange(&Registered, FALSE, FALSE))
        {
            return FALSE;
        }
    }

    Window = CreateWindow(
        L"CreduiIconParentWindow",
        NULL,
        WS_CAPTION | WS_SYSMENU,
        0, 0, 0, 0,
        NULL, NULL, instance, NULL);

    return (Window != NULL);
}

//-----------------------------------------------------------------------------
// CreduiCredentialControl Class Implementation
//-----------------------------------------------------------------------------

CONST WCHAR *CreduiCredentialControl::ClassName = WC_CREDENTIAL;
HINSTANCE CreduiCredentialControl::Instance = NULL;
LONG CreduiCredentialControl::Registered = FALSE;

//=============================================================================
// CreduiCredentialControl::CreduiCredentialControl
//
// Created 06/20/2000 johnstep (John Stephens)
//=============================================================================

CreduiCredentialControl::CreduiCredentialControl()
{
    IsInitialized = FALSE;

    DisabledControlMask = 0;

    Window = NULL;
    Style = 0;

    UserNameStaticWindow = NULL;
    UserNameControlWindow = NULL;
    ViewCertControlWindow = NULL;
    PasswordStaticWindow = NULL;
    PasswordControlWindow = NULL;

    FirstPaint = FALSE;
    ShowBalloonTip = FALSE;

    IsAutoComplete = FALSE;
    NoEditUserName = FALSE;
    KeepUserName = FALSE;

    IsPassport = FALSE;

    CertHashes = NULL;
    CertCount = 0;
    CertBaseInComboBox = 0;
    UserNameCertHash = NULL;
    SmartCardBaseInComboBox = 0;
    SmartCardReadCount = 0;
    IsChangingUserName = FALSE;
    IsChangingPassword = FALSE;

    UserNameSelection = 0;
    ScardUiHandle = NULL;

    DoingCommandLine = FALSE;
    TargetName = NULL;
    InitialUserName = NULL;
}

//=============================================================================
// CreduiCredentialControl::~CreduiCredentialControl
//
// Created 06/20/2000 johnstep (John Stephens)
//=============================================================================

CreduiCredentialControl::~CreduiCredentialControl()
{
}

//=============================================================================
// CreduiCredentialControl::Register
//
// Arguments:
//   instance (in)
//
// Returns TRUE on success or FALSE otherwise.
//
// Created 06/20/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiCredentialControl::Register(
    HINSTANCE instance
    )
{
    Instance = instance;

    WNDCLASS windowClass;

    ZeroMemory(&windowClass, sizeof windowClass);

    if (!InterlockedCompareExchange(&Registered, TRUE, FALSE))
    {
        windowClass.style = CS_GLOBALCLASS;
        windowClass.lpfnWndProc = MessageHandlerCallback;
        windowClass.cbWndExtra = sizeof (CreduiCredentialControl *);
        windowClass.hInstance = Instance;
        windowClass.hIcon = NULL;
        windowClass.hCursor = LoadCursor(NULL, MAKEINTRESOURCE(IDC_ARROW));
        windowClass.lpszClassName = ClassName;

        InterlockedExchange(&Registered, RegisterClass(&windowClass) != 0);

        if (!InterlockedCompareExchange(&Registered, FALSE, FALSE))
        {
            return FALSE;
        }
    }

    return TRUE;
}

//=============================================================================
// CreduiCredentialControl::Unegister
//
// Unregisters the window class, if registered.
//
// Returns TRUE on success or FALSE otherwise.
//
// Created 06/20/2000 johnstep (John Stephens)
//=============================================================================

BOOL CreduiCredentialControl::Unregister()
{
    if (InterlockedCompareExchange(&Registered, FALSE, TRUE))
    {
        return UnregisterClass(ClassName, Instance);
    }

    return TRUE;
}

//=============================================================================
// CreduiCredentialControl::ViewCertificate
//
// Views the certificate at index in our combo box.
//
// Arguments:
//   index (in) - index in the user name combo box
//
// Returns TRUE if the certificate was viewed, otherwise FALSE.
//
// Created 03/27/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiCredentialControl::ViewCertificate(
    INT index
    )
{
    BOOL success = FALSE;

    if (index < CertBaseInComboBox)
    {
        return FALSE;
    }

    CONST CERT_CONTEXT *certContext = NULL;
    HCERTSTORE certStore = NULL;

    // If this is not a smart card, open the MY store and find the certificate
    // from the hash. Otherwise, just grab the certificate context from the
    // CERT_ENUM structure:

    if ((SmartCardBaseInComboBox > 0) &&
        (index >= SmartCardBaseInComboBox))
    {
        CERT_ENUM *certEnum =
            reinterpret_cast<CERT_ENUM *>(
                SendMessage(UserNameControlWindow,
                            CB_GETITEMDATA, index, 0));

        if (certEnum != NULL)
        {
            certContext = certEnum->pCertContext;
        }
    }
    else
    {
        certStore = CertOpenSystemStore(NULL, L"MY");

        if (certStore != NULL)
        {
            CRYPT_HASH_BLOB hashBlob;

            hashBlob.cbData = CERT_HASH_LENGTH;
            hashBlob.pbData = reinterpret_cast<BYTE *>(
                CertHashes[index - CertBaseInComboBox]);

            certContext = CertFindCertificateInStore(
                              certStore,
                              X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                              0,
                              CERT_FIND_SHA1_HASH,
                              &hashBlob,
                              NULL);
        }
    }

    // If we found a certificate context, view the certificate:

    if (certContext != NULL)
    {
        // Now, show the certificate with the common UI:

        CRYPTUI_VIEWCERTIFICATE_STRUCT certViewInfo;

        ZeroMemory(&certViewInfo, sizeof certViewInfo);
        certViewInfo.dwSize = sizeof certViewInfo;
        certViewInfo.hwndParent = Window;
        certViewInfo.pCertContext = certContext;

        BOOL changed;
        changed = FALSE;
        CryptUIDlgViewCertificate(&certViewInfo, &changed);

        // Get the name again, in case it changed. However, skip this if this
        // is a card reader, and is now invalid:

        COMBOBOXEXITEMW item;
        BOOL updateName = TRUE;

        if (index >= SmartCardBaseInComboBox)
        {
            item.mask = CBEIF_IMAGE;
            item.iItem = index;

            if (!SendMessage(UserNameControlWindow,
                             CBEM_GETITEM,
                             0,
                             reinterpret_cast<LPARAM>(&item)) ||
                (item.iImage == IMAGE_SMART_CARD_MISSING))
            {
                updateName = FALSE;
            }
        }

        if (updateName)
        {
            WCHAR displayName[CREDUI_MAX_CERT_NAME_LENGTH];

            if (!CreduiGetCertificateDisplayName(
                    certContext,
                    displayName,
                    CREDUI_MAX_CERT_NAME_LENGTH,
                    CreduiStrings.Certificate,
                    CERT_NAME_FRIENDLY_DISPLAY_TYPE))
            {
                lstrcpyn(displayName,
                         CreduiStrings.Certificate,
                         CREDUI_MAX_CERT_NAME_LENGTH);
            }

            COMBOBOXEXITEMW item;

            item.mask = CBEIF_TEXT;
            item.iItem = index;
            item.pszText = displayName;

            SendMessage(UserNameControlWindow,
                        CBEM_SETITEM,
                        0,
                        reinterpret_cast<LPARAM>(&item));
        }

        success = TRUE;
    }

    // If we opened a store, free the certificate and close the store:

    if (certStore != NULL)
    {
        if (certContext != NULL)
        {
            CertFreeCertificateContext(certContext);
        }

        if (!CertCloseStore(certStore, 0))
        {
            CreduiDebugLog("CreduiCredentialControl::ViewCertificate: "
                           "CertCloseStore failed: %u\n", GetLastError());
        }
    }

    return success;
}

//=============================================================================
// CreduiCredentialControl::AddCertificates
//
// Adds interesting certificates to the combo box, and allocates an array of
// hashes to match. The hash is all we need to store the credential, and can
// be used to get a CERT_CONTEXT later to view the certificate.
//
// Assume CertCount is 0 upon entry.
//
// Stack space is used for temporary storage of hashes, since each hash is
// only 160 bits. We use a linked list structure, so including the next
// pointer and worst case alignment (8-byte) on 64-bit, the maximum structure
// size is 32 bytes. We don't want to consume too much stack space, so limit
// the number of entries to 256, which will consume up to 8 KB of stack space.
//
// Returns TRUE if at least one interesting certificate exists, and all were
// added to the combo box without error. Otherwise, returns FALSE.
//
// Created 03/25/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiCredentialControl::AddCertificates()
{
    BOOL success = FALSE;

    ASSERT(CertCount == 0);

    HCERTSTORE certStore = CertOpenSystemStore(NULL, L"MY");

    if (certStore != NULL)
    {
        struct HASH_ENTRY
        {
            UCHAR Hash[CERT_HASH_LENGTH];
            HASH_ENTRY *Next;
        };

        HASH_ENTRY *hashList = NULL;
        HASH_ENTRY *current = NULL;
        HASH_ENTRY *next = NULL;

        CONST CERT_CONTEXT *certContext = NULL;

        // NOTE: Currently, add all client authentication certificates. This
        //       should be revisited.

        CHAR *ekUsageIdentifiers[] = {
            szOID_PKIX_KP_CLIENT_AUTH
        };

        CERT_ENHKEY_USAGE ekUsage = { 1, ekUsageIdentifiers };

        // We allow a maximum of 256 certificates to be added. This is a
        // reasonable limit, given the current user interface. If this is an
        // unreasonable limit for the personal certificate store, then this
        // can always be changed.

        while (CertCount < 256)
        {
            certContext =
                CertFindCertificateInStore(
                    certStore,
                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                    CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG,
                    CERT_FIND_ENHKEY_USAGE,
                    static_cast<VOID *>(&ekUsage),
                    certContext);

            if (certContext != NULL)
            {
                DWORD length = CERT_HASH_LENGTH;

                // Only allocate a new entry if necessary. Something may have
                // failed from the previous loop iteration, so we can just
                // reuse the entry allocated then:

                if (next == NULL)
                {
                    // Wrap the alloca in an exception handler because it will
                    // throw a stack overflow exception on failure. Of course,
                    // of we're out of stack space, we may not even be able to
                    // clean up properly without throwing an exception.

                    __try
                    {
                        next = static_cast<HASH_ENTRY *>(
                                   alloca(sizeof HASH_ENTRY));
                    }
                    __except(EXCEPTION_EXECUTE_HANDLER)
                    {
                        next = NULL;
                    }

                    // If this fails, for whatever reason, break out of the
                    // loop:

                    if (next == NULL)
                    {
                        CertFreeCertificateContext(certContext);
                        break;
                    }

                    next->Next = NULL;
                }

                if (!CertGetCertificateContextProperty(
                        certContext,
                        CERT_SHA1_HASH_PROP_ID,
                        static_cast<VOID *>(&next->Hash),
                        &length))
                {
                    // If we failed to get the hash for this certificate, just
                    // ignore it and continue with the next. The memory we
                    // allocation for this entry will be used on the next
                    // iteration if we do not set it to NULL.

                    continue;
                }

                if (CreduiIsRemovableCertificate(certContext))
                {
                    // If this certificate requires a removable component,
                    // such as a smart card, then skip it. We will enumerate
                    // these later.

                    continue;
                }

                WCHAR displayName[CREDUI_MAX_CERT_NAME_LENGTH];

                if (!CreduiGetCertificateDisplayName(
                        certContext,
                        displayName,
                        CREDUI_MAX_CERT_NAME_LENGTH,
                        CreduiStrings.Certificate,
                        CERT_NAME_FRIENDLY_DISPLAY_TYPE))
                {
                    lstrcpyn(displayName,
                             CreduiStrings.Certificate,
                             CREDUI_MAX_CERT_NAME_LENGTH);
                }

                // Add the certificate to the combo box. Certificate names may
                // not be unique, so allow duplicates:

                if (UserNameComboBox.Add(
                        displayName,
                        CreduiIsExpiredCertificate(certContext) ?
                            IMAGE_CERT_EXPIRED :
                            IMAGE_CERT,
                        FALSE,
                        FALSE) == -1)
                {
                    CertFreeCertificateContext(certContext);
                    break;
                }

                // Everything succeeded, so add the certificate to our list:

                if (current == NULL)
                {
                    current = next;
                    hashList = current;
                }
                else
                {
                    ASSERT(current->Next == NULL);

                    current->Next = next;
                    current = current->Next;
                }

                if (current == NULL)
                {
                    CertFreeCertificateContext(certContext);
                    break;
                }

                // Set next to NULL so we will allocate new memory on the
                // next iteration:

                next = NULL;

                CertCount++;
            }
            else
            {
                break;
            }
        }

        if (CertCount > 0)
        {
            current = hashList;

            // Now, allocate the final array of certificates. We allocate
            // this in a single block to help avoid thrashing the heap:

            CertHashes = new UCHAR [CertCount][CERT_HASH_LENGTH];

            if (CertHashes != NULL)
            {
                for (UINT i = 0; i < CertCount; ++i)
                {
                    CopyMemory(CertHashes[i],
                               current->Hash,
                               CERT_HASH_LENGTH);

                    current = current->Next;
                }

                success = TRUE;
            }
        }

        CertCloseStore(certStore, 0);
    }

    return success;
}

//=============================================================================
// CreduiCredentialControl::FindSmartCardInComboBox
//
// Finds a smart card entry in the user name combo box based on a CERT_ENUM.
//
// Arguments:
//   certEnum (in)
//
// Returns the index of the smart card or -1 if not found.
//
// Created 04/15/2000 johnstep (John Stephens)
//=============================================================================

INT
CreduiCredentialControl::FindSmartCardInComboBox(
    CERT_ENUM *certEnum
    )
{
    UINT count = (UINT) SendMessage(UserNameControlWindow, CB_GETCOUNT, 0, 0);

    if (count == CB_ERR)
    {
        return -1;
    }

    CERT_ENUM *findCertEnum;

    for (UINT i = SmartCardBaseInComboBox; i < count; ++i)
    {
        findCertEnum =
            reinterpret_cast<CERT_ENUM *>(
                SendMessage(UserNameControlWindow, CB_GETITEMDATA, i, 0));

        ASSERT(findCertEnum != NULL);

        if (lstrcmpi(findCertEnum->pszReaderName,
                     certEnum->pszReaderName) == 0)
        {
            return i;
        }
    }

    return -1;
}

//=============================================================================
// CreduiCredentialControl::RemoveSmartCardFromComboBox
//
// Removes all entries for this smart card from the user name combo box.
//
// Arguments:
//   certEnum (in)
//   removeParent (in)
//
// Created 07/12/2000 johnstep (John Stephens)
//=============================================================================

VOID
CreduiCredentialControl::RemoveSmartCardFromComboBox(
    CERT_ENUM *certEnum,
    BOOL removeParent
    )
{
    INT count = (INT) SendMessage(UserNameControlWindow, CB_GETCOUNT, 0, 0);
    INT current = (INT) SendMessage(UserNameControlWindow,
                                    CB_GETCURSEL, 0, 0);

    if (count != CB_ERR)
    {
        CERT_ENUM *findCertEnum;
        BOOL parentEntry = TRUE;
        BOOL currentRemoved = FALSE;

        for (INT i = SmartCardBaseInComboBox; i < count; ++i)
        {
            findCertEnum =
                reinterpret_cast<CERT_ENUM *>(
                    SendMessage(UserNameControlWindow, CB_GETITEMDATA, i, 0));

            ASSERT(findCertEnum != NULL);

            if (lstrcmpi(findCertEnum->pszReaderName,
                         certEnum->pszReaderName) == 0)
            {
                if (parentEntry)
                {
                    parentEntry = FALSE;

                    if (!removeParent)
                    {
                        continue;
                    }
                }

                if (current == i)
                {
                    currentRemoved = TRUE;
                }

                SendMessage(
                    UserNameControlWindow,
                    CBEM_DELETEITEM,
                    i,
                    0);

                i--, count--;
            }
            else if (!parentEntry)
            {
                break;
            }
        }

        if (currentRemoved)
        {
            if (removeParent)
            {
                IsChangingUserName = TRUE;
                SendMessage(UserNameControlWindow, CB_SETCURSEL, -1, 0);
                UserNameComboBox.Update(-1, L"", IMAGE_USERNAME);
                IsChangingUserName = FALSE;

                IsChangingPassword = TRUE;
                SetWindowText(PasswordControlWindow, NULL);
                IsChangingPassword = FALSE;

                OnUserNameSelectionChange();
            }
            else
            {
                IsChangingUserName = TRUE;
                SendMessage(UserNameControlWindow, CB_SETCURSEL, --i, 0);
                IsChangingUserName = FALSE;
            }

            OnUserNameSelectionChange();
        }
    }
}

//=============================================================================
// CreduiCredentialControl::HandleSmartCardMessages
//
// Handle smart card messages.
//
// Arguments:
//   message (in)
//   certEnum (in)
//
// Returns TRUE if the message was handled or FALSE otherwise.
//
// Created 04/14/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiCredentialControl::HandleSmartCardMessages(
    UINT message,
    CERT_ENUM *certEnum
    )
{
    ASSERT(ScardUiHandle != NULL);

    // This is sort of ugly since we cannot use a switch. First check for any
    // possible smart card message because we must do some things in common
    // for any of the messages:

    if ((message == CreduiScarduiWmReaderArrival) ||
        (message == CreduiScarduiWmReaderRemoval) ||
        (message == CreduiScarduiWmCardInsertion) ||
        (message == CreduiScarduiWmCardRemoval) ||
        (message == CreduiScarduiWmCardCertAvail) ||
        (message == CreduiScarduiWmCardStatus))
    {
        if (certEnum == NULL)
        {
            CreduiDebugLog(
                "CreduiCredentialControl::HandleSmartCardMessages: "
                "NULL was passed for the CERT_ENUM!");

            // We handled the message, even though it was invalid:

            return TRUE;
        }

        ASSERT(certEnum->pszReaderName != NULL);
    }
    else
    {
        return FALSE;
    }

    WCHAR *displayString;
    WCHAR string[256]; // Must be >= CREDUI_MAX_CERT_NAME_LENGTH

    ASSERT((sizeof string / (sizeof string[0])) >=
           CREDUI_MAX_CERT_NAME_LENGTH);

    INT index = FindSmartCardInComboBox(certEnum);

    if (message == CreduiScarduiWmReaderArrival)
    {
#ifdef SCARDREPORTS
        CreduiDebugLog("CREDUI: Reader arrival event for %0x\n",this->Window);
#endif
        // Add the reader, if it is not already there; it should not be:

        if (index == -1)
        {

            //
            // Reset command line Hearbeat timer.
            //

            Heartbeats = 0;

            INT index =
                UserNameComboBox.Add(
                    DoingCommandLine ?
                    CreduiStrings.NoCard :
                    CreduiStrings.EmptyReader,
                    IMAGE_SMART_CARD_MISSING,
                    FALSE,
                    FALSE);

            if (index != -1)
            {
                SendMessage(UserNameControlWindow,
                            CB_SETITEMDATA,
                            index,
                            reinterpret_cast<LPARAM>(certEnum));

                if (UserNameCertHash != NULL)
                {
                    EnableWindow(ViewCertControlWindow, FALSE);
                    DisabledControlMask |= DISABLED_CONTROL_VIEW;

                    SetWindowText(
                        PasswordStaticWindow,
                        CreduiStrings.PinStatic);

                    IsChangingPassword = TRUE;
                    SetWindowText(PasswordControlWindow, NULL);
                    IsChangingPassword = FALSE;

                    EnableWindow(PasswordControlWindow, TRUE);
                    EnableWindow(PasswordStaticWindow, TRUE);
                    DisabledControlMask &= ~DISABLED_CONTROL_PASSWORD;

                    SetWindowText(
                        UserNameStaticWindow,
                        CreduiStrings.SmartCardStatic);

                    if (SaveControlWindow != NULL)
                    {
                        EnableWindow(SaveControlWindow, FALSE);
                        DisabledControlMask |= DISABLED_CONTROL_SAVE;
                    }

                    IsChangingUserName = TRUE;
                    UserNameComboBox.Update(
                        -1,
                        DoingCommandLine ?
                        CreduiStrings.NoCard :
                        CreduiStrings.EmptyReader,
                        IMAGE_SMART_CARD_MISSING);
                    IsChangingUserName = FALSE;
                }
            }
            else
            {
                CreduiDebugLog(
                    "CreduiCredentialControl::HandleSmartCardMessages: "
                    "Failed to add smart card\n");
            }
        }
        else
        {
            CreduiDebugLog(
                "CreduiCredentialControl::HandleSmartCardMessages: "
                "Reader arrived more than once");
        }

    }
    else if (message == CreduiScarduiWmReaderRemoval)
    {
#ifdef SCARDREPORTS
        CreduiDebugLog("CREDUI: Reader removal event for %0x\n",this->Window);
#endif
        if (index != -1)
        {
            RemoveSmartCardFromComboBox(certEnum, TRUE);
        }
        else
        {
            CreduiDebugLog(
                "CreduiCredentialControl::HandleSmartCardMessages: "
                "Reader removed more than once");
        }
    }
    else if (message == CreduiScarduiWmCardInsertion)
    {
#ifdef SCARDREPORTS
        CreduiDebugLog("CREDUI: card insertion event for %0x\n",this->Window);
#endif
        if (index != -1)
        {
            //
            // Reset command line Hearbeat timer.
            //

            Heartbeats = 0;

            SmartCardReadCount++;

            if (UserNameCertHash != NULL)
            {
                IsChangingUserName = TRUE;
                UserNameComboBox.Update(
                    -1,
                    CreduiStrings.ReadingCard,
                    IMAGE_SMART_CARD_MISSING);
                IsChangingUserName = FALSE;
            }

            IsChangingUserName = TRUE;
            UserNameComboBox.Update(index,
                                    CreduiStrings.ReadingCard,
                                    IMAGE_SMART_CARD_MISSING);
            IsChangingUserName = FALSE;
        }
        else
        {
            CreduiDebugLog(
                "CreduiCredentialControl::HandleSmartCardMessages: "
                "Card insertion to absent reader\n");
        }
    }
    else if (message == CreduiScarduiWmCardRemoval)
    {
#ifdef SCARDREPORTS
        CreduiDebugLog("CREDUI: card removal event for %0x\n",this->Window);
#endif
        if (index != -1)
        {
            if (BalloonTip.GetInfo() == &CreduiBackwardsTipInfo)
            {
                BalloonTip.Hide();
            }

            IsChangingUserName = TRUE;
            UserNameComboBox.Update(index,
                                    DoingCommandLine ?
                                    CreduiStrings.NoCard :
                                    CreduiStrings.EmptyReader,
                                    IMAGE_SMART_CARD_MISSING);
            IsChangingUserName = FALSE;

            RemoveSmartCardFromComboBox(certEnum, FALSE);
        }
        else
        {
            CreduiDebugLog(
                "CreduiCredentialControl::HandleSmartCardMessages: "
                "Card removal from absent reader\n");
        }
    }
    else if (message == CreduiScarduiWmCardCertAvail)
    {
#ifdef SCARDREPORTS
        CreduiDebugLog("CREDUI: cert available event for %0x\n",this->Window);
#endif
        if (index != -1)
        {
            // Filter certificates which are not for client authentication:

            if (!CreduiIsClientAuthCertificate(certEnum->pCertContext))
            {
                return TRUE;
            }

            UINT image = IMAGE_SMART_CARD_MISSING;
            COMBOBOXEXITEM item;

            item.mask = CBEIF_IMAGE;
            item.iItem = index;

            SendMessage(UserNameControlWindow, CBEM_GETITEM,
                        0, reinterpret_cast<LPARAM>(&item));

            //
            // For command line,
            //  get the UPN display name since the user is expected to type it.
            // For GUI,
            //  get the friendly display name since it is "friendly".
            //

            if (!CreduiGetCertificateDisplayName(
                   certEnum->pCertContext,
                   string,
                   CREDUI_MAX_CERT_NAME_LENGTH,
                   CreduiStrings.Certificate,
                   DoingCommandLine ?
                        CERT_NAME_UPN_TYPE :
                        CERT_NAME_FRIENDLY_DISPLAY_TYPE))
            {
                lstrcpyn(string,
                         CreduiStrings.Certificate,
                         CREDUI_MAX_CERT_NAME_LENGTH);
            }

            displayString = string;

            //
            // Trim trailing spaces and -'s so it doesn't look cheesy
            //

            if ( DoingCommandLine ) {
                DWORD StringLength = wcslen(string);

                while ( StringLength > 0 ) {
                    if ( string[StringLength-1] == ' ' || string[StringLength-1] == '-' ) {
                        string[StringLength-1] = '\0';
                        StringLength--;
                    } else {
                        break;
                    }
                }

            }
#ifdef SCARDREPORTS
        CreduiDebugLog("CREDUI: cert name '%ws' %0x\n", string, this->Window);
#endif

            if (SendMessage(UserNameControlWindow,
                            CB_GETCURSEL,
                            0,
                            0) == index)
            {
                EnableWindow(ViewCertControlWindow, TRUE);
                DisabledControlMask &= ~DISABLED_CONTROL_VIEW;
            }

            image =
                CreduiIsExpiredCertificate(certEnum->pCertContext) ?
                    IMAGE_SMART_CARD_EXPIRED :
                    IMAGE_SMART_CARD;

            INT newIndex = index;

            if (item.iImage != IMAGE_SMART_CARD_MISSING)
            {
                newIndex = UserNameComboBox.Add(displayString,
                                                image,
                                                FALSE,
                                                FALSE,
                                                index + 1,
                                                1);

                if (newIndex != -1)
                {
                    SendMessage(UserNameControlWindow,
                                CB_SETITEMDATA,
                                newIndex,
                                reinterpret_cast<LPARAM>(certEnum));
                }
                else
                {
                    newIndex = index;
                }
            }

            if (newIndex == index)
            {
                IsChangingUserName = TRUE;
                UserNameComboBox.Update(index, displayString, image);
                IsChangingUserName = FALSE;
            }

            if (UserNameCertHash != NULL)
            {
                UCHAR hash[CERT_HASH_LENGTH];
                DWORD length = CERT_HASH_LENGTH;

                if (CertGetCertificateContextProperty(
                        certEnum->pCertContext,
                        CERT_SHA1_HASH_PROP_ID,
                        static_cast<VOID *>(&hash),
                        &length))
                {
                    if (RtlCompareMemory(UserNameCertHash,
                                         hash,
                                         CERT_HASH_LENGTH) ==
                                         CERT_HASH_LENGTH)
                    {
                        delete [] UserNameCertHash;
                        UserNameCertHash = NULL;

                        IsChangingUserName = TRUE;
                        SendMessage(UserNameControlWindow,
                                    CB_SETCURSEL, newIndex, 0);
                        IsChangingUserName = FALSE;

                        OnUserNameSelectionChange();
                    }
                }
            }
        }
        else
        {
            CreduiDebugLog(
                "CreduiCredentialControl::HandleSmartCardMessages: "
                "Card certificate to absent reader\n");
        }
    }
    else if (message == CreduiScarduiWmCardStatus)
    {
#ifdef SCARDREPORTS
        CreduiDebugLog("CREDUI: card status event for %0x\n",this->Window);
#endif
        if (index != -1)
        {
            if (--SmartCardReadCount == 0)
            {
                if (UserNameCertHash != NULL)
                {
                    IsChangingUserName = TRUE;
                    SetWindowText(UserNameControlWindow,
                                    DoingCommandLine ?
                                    CreduiStrings.NoCard :
                                    CreduiStrings.EmptyReader);
                    IsChangingUserName = FALSE;
                }
            }

            UINT image = IMAGE_SMART_CARD_MISSING;
            BOOL showBalloon = FALSE;

            switch (certEnum->dwStatus)
            {
            case SCARD_S_SUCCESS:
                UINT image;
                COMBOBOXEXITEM item;

#ifdef SCARDREPORTS
        CreduiDebugLog("CREDUI: card status SUCCESS: %ws\n",  certEnum->pszCardName );
#endif
                item.mask = CBEIF_IMAGE;
                item.iItem = index;

                if (SendMessage(UserNameControlWindow, CBEM_GETITEM,
                                0, reinterpret_cast<LPARAM>(&item)) &&
                    (item.iImage != IMAGE_SMART_CARD_MISSING))
                {
                    return TRUE;
                }

                displayString = CreduiStrings.EmptyCard;
                break;

            case SCARD_E_UNKNOWN_CARD:
#ifdef SCARDREPORTS
        CreduiDebugLog("CREDUI: card status UNKNOWN CARD\n");
#endif
                displayString = CreduiStrings.UnknownCard;
                break;

            case SCARD_W_UNRESPONSIVE_CARD:
#ifdef SCARDREPORTS
        CreduiDebugLog("CREDUI: card status UNRESPONSIVE CARD\n");
#endif
                displayString = CreduiStrings.BackwardsCard;
                if (!DoingCommandLine) showBalloon = TRUE;
                break;

            case NTE_KEYSET_NOT_DEF:
#ifdef SCARDREPORTS
        CreduiDebugLog("CREDUI: card status NTE_KEYSET_NOT_DEF\n");
#endif
                // TODO: This case should be removed eventually.

                displayString = CreduiStrings.EmptyCard;
                break;

            case SCARD_W_REMOVED_CARD:
#ifdef SCARDREPORTS
        CreduiDebugLog("CREDUI: card status REMOVED CARD\n");
#endif
                displayString = DoingCommandLine ?
                                    CreduiStrings.NoCard :
                                    CreduiStrings.EmptyReader;
CreduiStrings.EmptyReader;
                break;

            default:
#ifdef SCARDREPORTS
        CreduiDebugLog("CREDUI: card status ERROR\n");
#endif
                displayString = CreduiStrings.CardError;
                break;
            }

            IsChangingUserName = TRUE;
            UserNameComboBox.Update(index, displayString, image);
            IsChangingUserName = FALSE;

            if (showBalloon && !BalloonTip.IsVisible())
            {
                BalloonTip.SetInfo(UserNameControlWindow,
                                   &CreduiBackwardsTipInfo);

                BalloonTip.Show();
            }
        }
        else
        {
            CreduiDebugLog(
                "CreduiCredentialControl::HandleSmartCardMessages: "
                "Card status to absent reader\n");
        }
    }

    // We handled the message:

    return TRUE;
}

//=============================================================================
// CreduiCredentialControl::CreateControls
//
// Created 06/23/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiCredentialControl::CreateControls()
{
    // First we need the parent window:

    HWND dialogWindow = GetParent(Window);

    if (dialogWindow == NULL)
    {
        return FALSE;
    }

    // Create the various windows:

    RECT clientRect;
    RECT rect;
    UINT add;
    BOOL noViewCert = FALSE;

    if ( Style & CRS_KEEPUSERNAME )
    {
        KeepUserName = TRUE;
    }

    if (!(Style & CRS_USERNAMES) )
    {
        NoEditUserName = TRUE;
    }
    else if ((Style & (CRS_CERTIFICATES | CRS_SMARTCARDS)) == 0)
    {
        noViewCert = TRUE;
    }

    if ( Style & CRS_SINGLESIGNON )
        IsPassport = TRUE;
    else
        IsPassport = FALSE;

    // Determine how much wider the control is than the minimum to resize and
    // reposition controls as necessary:

    GetClientRect(Window, &clientRect);

    rect.left = 0;
    rect.top = 0;
    rect.right = CREDUI_CONTROL_MIN_WIDTH;
    rect.bottom = CREDUI_CONTROL_MIN_HEIGHT;

    if ( !DoingCommandLine && !MapDialogRect(dialogWindow, &rect))
    {
        goto ErrorExit;
    }

    if ((clientRect.right - clientRect.left) >
        (rect.right - rect.left))
    {
        add = (clientRect.right - clientRect.left) -
              (rect.right - rect.left);
    }
    else
    {
        add = 0;
    }

    // Create user name static text control:

    rect.left = CREDUI_CONTROL_USERNAME_STATIC_X;
    rect.top = CREDUI_CONTROL_USERNAME_STATIC_Y;
    rect.right = rect.left + CREDUI_CONTROL_USERNAME_STATIC_WIDTH;
    rect.bottom = rect.top + CREDUI_CONTROL_USERNAME_STATIC_HEIGHT;

    if ( !DoingCommandLine && !MapDialogRect(dialogWindow, &rect))
    {
        goto ErrorExit;
    }

    WCHAR* pUserNameLabel;
    if ( IsPassport )
        pUserNameLabel = CreduiStrings.EmailName;
    else
        pUserNameLabel = CreduiStrings.UserNameStatic;


    UserNameStaticWindow =
        CreateWindowEx(
            WS_EX_NOPARENTNOTIFY,
            L"STATIC",
            pUserNameLabel,
            WS_VISIBLE | WS_CHILD | WS_GROUP,
            rect.left,
            rect.top,
            rect.right - rect.left,
            rect.bottom - rect.top,
            Window,
            reinterpret_cast<HMENU>(IDC_USERNAME_STATIC),
            CreduiCredentialControl::Instance,
            NULL);

    if (UserNameStaticWindow == NULL)
    {
        goto ErrorExit;
    }

    // Create user name combo box:

    rect.left = CREDUI_CONTROL_USERNAME_X;
    rect.top = CREDUI_CONTROL_USERNAME_Y;

    if (!noViewCert)
    {
        rect.right = rect.left + CREDUI_CONTROL_USERNAME_WIDTH;
    }
    else
    {
        rect.right = CREDUI_CONTROL_VIEW_X + CREDUI_CONTROL_VIEW_WIDTH;
    }

    if ( KeepUserName )
    {
        rect.top += 2;      // fudge it to make them line up better
        rect.bottom = rect.top + CREDUI_CONTROL_PASSWORD_STATIC_HEIGHT;  // make it the same height as the password edit
    }
    else
    {
        rect.bottom = rect.top + CREDUI_CONTROL_USERNAME_HEIGHT;  // set the height
    }


    if ( !DoingCommandLine && !MapDialogRect(dialogWindow, &rect))
    {
        goto ErrorExit;
    }

    // This block of statements and the usage of lExStyles : see bug 439840
    LONG_PTR lExStyles = GetWindowLongPtr(Window,GWL_EXSTYLE);
    SetWindowLongPtr(Window,GWL_EXSTYLE,(lExStyles | WS_EX_NOINHERITLAYOUT));

    if ( KeepUserName )
    {

        // create an edit box instead of a combo box

        UserNameControlWindow =
            CreateWindowEx(
                WS_EX_NOPARENTNOTIFY,
                L"Edit",
                L"",
                WS_VISIBLE | WS_CHILD | WS_TABSTOP | ES_READONLY,
                rect.left,
                rect.top,
                rect.right - rect.left + add,
                rect.bottom - rect.top,
                Window,
                reinterpret_cast<HMENU>(IDC_USERNAME),
                CreduiCredentialControl::Instance,
                NULL);
  
    }
    else
    {

        UserNameControlWindow =
            CreateWindowEx(
                WS_EX_NOPARENTNOTIFY,
                L"ComboBoxEx32",
                L"",
                WS_VISIBLE | WS_CHILD | WS_TABSTOP | WS_VSCROLL |
                    (NoEditUserName ? CBS_DROPDOWNLIST : CBS_DROPDOWN) |
                    CBS_AUTOHSCROLL,
                rect.left,
                rect.top,
                rect.right - rect.left + add,
                rect.bottom - rect.top,
                Window,
                reinterpret_cast<HMENU>(IDC_USERNAME),
                CreduiCredentialControl::Instance,
                NULL);
    }

    SetWindowLongPtr(Window,GWL_EXSTYLE,lExStyles);

    if (UserNameControlWindow == NULL)
    {
        goto ErrorExit;
    }

    // Create view button:

    if (!noViewCert)
    {
        rect.left = CREDUI_CONTROL_VIEW_X;
        rect.top = CREDUI_CONTROL_VIEW_Y;
        rect.right = rect.left + CREDUI_CONTROL_VIEW_WIDTH;
        rect.bottom = rect.top + CREDUI_CONTROL_VIEW_HEIGHT;

        if ( !DoingCommandLine && !MapDialogRect(dialogWindow, &rect))
        {
            goto ErrorExit;
        }

        ViewCertControlWindow =
            CreateWindowEx(
                WS_EX_NOPARENTNOTIFY,
                L"BUTTON",
                L"&...",
                WS_VISIBLE | WS_CHILD | WS_TABSTOP | WS_GROUP |
                    BS_PUSHBUTTON | BS_CENTER,
                rect.left + add,
                rect.top,
                rect.right - rect.left,
                rect.bottom - rect.top,
                Window,
                reinterpret_cast<HMENU>(IDC_VIEW_CERT),
                CreduiCredentialControl::Instance,
                NULL);

        if (ViewCertControlWindow == NULL)
        {
            goto ErrorExit;
        }

        EnableWindow(ViewCertControlWindow, FALSE);
        DisabledControlMask |= DISABLED_CONTROL_VIEW;
    }

    // Create password static text control:

    rect.left = CREDUI_CONTROL_PASSWORD_STATIC_X;
    rect.top = CREDUI_CONTROL_PASSWORD_STATIC_Y;
    rect.right = rect.left + CREDUI_CONTROL_PASSWORD_STATIC_WIDTH;
    rect.bottom = rect.top + CREDUI_CONTROL_PASSWORD_STATIC_HEIGHT;

    if ( !DoingCommandLine && !MapDialogRect(dialogWindow, &rect))
    {
        goto ErrorExit;
    }

    PasswordStaticWindow =
        CreateWindowEx(
            WS_EX_NOPARENTNOTIFY,
            L"STATIC",
            CreduiStrings.PasswordStatic,
            WS_VISIBLE | WS_CHILD | WS_GROUP,
            rect.left,
            rect.top,
            rect.right - rect.left,
            rect.bottom - rect.top,
            Window,
            reinterpret_cast<HMENU>(IDC_PASSWORD_STATIC),
            CreduiCredentialControl::Instance,
            NULL);

    if (PasswordStaticWindow == NULL)
    {
        goto ErrorExit;
    }

    // Create password edit control:

    rect.left = CREDUI_CONTROL_PASSWORD_X;
    rect.top = CREDUI_CONTROL_PASSWORD_Y;
    if (!noViewCert)
    {
        rect.right = rect.left + CREDUI_CONTROL_PASSWORD_WIDTH;
    }
    else
    {
        rect.right = CREDUI_CONTROL_VIEW_X + CREDUI_CONTROL_VIEW_WIDTH;
    }
    rect.bottom = rect.top + CREDUI_CONTROL_PASSWORD_HEIGHT;

    if (!DoingCommandLine && !MapDialogRect(dialogWindow, &rect))
    {
        goto ErrorExit;
    }
    
    // This block of statements and the usage of lExStyles : see bug 439840
    lExStyles = GetWindowLongPtr(Window,GWL_EXSTYLE);
    SetWindowLongPtr(Window,GWL_EXSTYLE,(lExStyles | WS_EX_NOINHERITLAYOUT));

    PasswordControlWindow =
        CreateWindowEx(
            WS_EX_NOPARENTNOTIFY | WS_EX_CLIENTEDGE,
            L"EDIT",
            L"",
            WS_VISIBLE | WS_CHILD | WS_TABSTOP | ES_PASSWORD | ES_AUTOHSCROLL,
            rect.left,
            rect.top,
            rect.right - rect.left + add,
            rect.bottom - rect.top + 1, // NOTE: Add 1 for now, investigate
            Window,
            reinterpret_cast<HMENU>(IDC_PASSWORD),
            CreduiCredentialControl::Instance,
            NULL);
    
    SetWindowLongPtr(Window,GWL_EXSTYLE,lExStyles);

    if (PasswordControlWindow == NULL)
    {
        goto ErrorExit;
    }

    // Create save check box:

    if (Style & CRS_SAVECHECK )
    {
        rect.left = CREDUI_CONTROL_SAVE_X;
        rect.top = CREDUI_CONTROL_SAVE_Y;
        rect.right = rect.left + CREDUI_CONTROL_SAVE_WIDTH;
        rect.bottom = rect.top + CREDUI_CONTROL_SAVE_HEIGHT;

        if (!DoingCommandLine && !MapDialogRect(dialogWindow, &rect))
        {
            goto ErrorExit;
        }

        WCHAR* pSavePromptString;

        if ( IsPassport )
            pSavePromptString = CreduiStrings.PassportSave;
        else
            pSavePromptString = CreduiStrings.Save;

        SaveControlWindow =
            CreateWindowEx(
                WS_EX_NOPARENTNOTIFY,
                L"BUTTON",
                pSavePromptString,
                WS_VISIBLE | WS_CHILD | WS_TABSTOP | WS_GROUP |
                    BS_AUTOCHECKBOX,
                rect.left,
                rect.top,
                rect.right - rect.left + add,
                rect.bottom - rect.top,
                Window,
                reinterpret_cast<HMENU>(IDC_SAVE),
                CreduiCredentialControl::Instance,
                NULL);

        if (SaveControlWindow == NULL)
        {
            goto ErrorExit;
        }

        SendMessage(SaveControlWindow, BM_SETCHECK, BST_UNCHECKED, 0);
    }

    SendMessage(
        Window,
        WM_SETFONT,
        SendMessage(dialogWindow, WM_GETFONT, 0, 0),
        FALSE);

    return TRUE;

ErrorExit:

    if (SaveControlWindow != NULL)
    {
        DestroyWindow(SaveControlWindow);
        SaveControlWindow = NULL;
    }

    if (PasswordControlWindow != NULL)
    {
        DestroyWindow(PasswordControlWindow);
        PasswordControlWindow = NULL;
    }

    if (PasswordStaticWindow != NULL)
    {
        DestroyWindow(PasswordStaticWindow);
        PasswordStaticWindow = NULL;
    }

    if (ViewCertControlWindow != NULL)
    {
        DestroyWindow(ViewCertControlWindow);
        ViewCertControlWindow = NULL;
    }

    if (UserNameControlWindow != NULL)
    {
        DestroyWindow(UserNameControlWindow);
        UserNameControlWindow = NULL;
    }

    if (UserNameStaticWindow != NULL)
    {
        DestroyWindow(UserNameStaticWindow);
        UserNameStaticWindow = NULL;
    }

    return FALSE;
}

LPWSTR
TrimUsername(
    IN LPWSTR AccountDomainName OPTIONAL,
    IN LPWSTR UserName
    )
/*++

Routine Description:

    Returns a pointer to the substring of UserName past any AccountDomainName prefix.

Arguments:

    AccountDomainName - The DomainName to check to see if it prefixes the UserName.

    UserName - The UserName to check

Return Values:

    Return a pointer to the non-prefixed username

--*/
{
    DWORD AccountDomainNameLength;
    DWORD UserNameLength;
    WCHAR Temp[CNLEN+1];

    //
    // If we couldn't determine the AccountDomainName,
    //  return the complete user name.
    //

    if ( AccountDomainName == NULL ) {
        return UserName;
    }

    //
    // If the user name isn't prefixed by the account domain name,
    //  return the complete user name.
    //

    AccountDomainNameLength = lstrlen( AccountDomainName );
    UserNameLength = lstrlen( UserName );

    if ( AccountDomainNameLength > CNLEN || AccountDomainNameLength < 1 ) {
        return UserName;
    }

    if ( AccountDomainNameLength+2 > UserNameLength ) {
        return UserName;
    }

    if ( UserName[AccountDomainNameLength] != '\\' ) {
        return UserName;
    }

    RtlCopyMemory( Temp, UserName, AccountDomainNameLength*sizeof(WCHAR) );
    Temp[AccountDomainNameLength] = '\0';

    if ( lstrcmpi( Temp, AccountDomainName ) != 0 ) {
        return UserName;
    }

    return &UserName[AccountDomainNameLength+1];
}

//=============================================================================
// CreduiCredentialControl::InitComboBoxUserNames
//
// Created 06/23/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiCredentialControl::InitComboBoxUserNames()
{
    CREDENTIAL **credentialSet = NULL;
    LOCALGROUP_MEMBERS_INFO_2 *groupInfo = NULL;
    DWORD nameCount = 0;
    LPWSTR AccountDomainName = NULL;

    if (Style & CRS_ADMINISTRATORS)
    {
        //
        // Enumerate the members of LocalAdministrators
        //

        if ( !CreduiGetAdministratorsGroupInfo(&groupInfo, &nameCount)) {
            return FALSE;
        }
    }
    else
    {
        if (!LocalCredEnumerateW(NULL, 0, &nameCount, &credentialSet))
        {
            return FALSE;
        }
    }

    // Initialize COM for STA, unless there are zero names:

    if ((Style & CRS_AUTOCOMPLETE) && nameCount > 0)
    {
        HRESULT comResult = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);

        if (SUCCEEDED(comResult))
        {
            IsAutoComplete = TRUE;
        }
        else
        {
            // The auto complete object and our string object require a STA.
            // Our object could easily support a MTA, but we do not support
            // marshaling between apartments.

            if (comResult == RPC_E_CHANGED_MODE)
            {
                CreduiDebugLog("CreduiCredentialControl: "
                               "Auto complete disabled for MTA\n");
            }

            IsAutoComplete = FALSE;
        }
    }
    else
    {
        IsAutoComplete = FALSE;
    }

    // Initialize the auto complete combo box:

    if (!UserNameComboBox.Init(CreduiInstance,
                               UserNameControlWindow,
                               IsAutoComplete ? nameCount : 0,
                               IDB_TYPES,
                               IMAGE_USERNAME))
    {
        // If initialization failed, and we had attempted for auto complete
        // support, try again without auto complete:

        if (IsAutoComplete)
        {
            IsAutoComplete = FALSE;

            CoUninitialize();

            if (!UserNameComboBox.Init(CreduiInstance,
                                       UserNameControlWindow,
                                       0,
                                       IDB_TYPES,
                                       IMAGE_USERNAME))
            {
                return FALSE;
            }
        }
        else
        {
            return FALSE;
        }
    }

    //
    // If we'll complete the user name,
    //  truncate any username displayed here.
    //  (We'll complete it later.)
    //

    if ( Style & CRS_COMPLETEUSERNAME ) {
        AccountDomainName = GetAccountDomainName();
    }

    // Add user names from credentials, if not requesting an
    // Administrator:

   if (!(Style & CRS_KEEPUSERNAME))
   {
        // only add usernames if we're not keeping the one set

        UINT i = 0;

        if (!(Style & CRS_ADMINISTRATORS))
        {
            for (i = 0; i < nameCount; ++i)
            {
                // Skip domain certificates:

                if (credentialSet[i]->Type == CRED_TYPE_DOMAIN_CERTIFICATE)
                {
                    continue;
                }

                // If this is a generic credential, look for a marshaled
                // credential, and skip, if found:

                if ((credentialSet[i]->Type == CRED_TYPE_GENERIC) &&
                    LocalCredIsMarshaledCredentialW(credentialSet[i]->UserName))
                {
                    continue;
                }

                // Skip this credential if the name is empty:

                if (credentialSet[i]->UserName == NULL)
                {
                    continue;
                }

                // Add the user name to the combo box with auto complete. If
                // this fails, do not continue:

                if (UserNameComboBox.Add(
                       TrimUsername( AccountDomainName, credentialSet[i]->UserName),
                       0, IsAutoComplete, TRUE) == -1)
                {
                    break;
                }
            }

            LocalCredFree(static_cast<VOID *>(credentialSet));
        }
        else if (groupInfo != NULL)
        {
            PSID adminSid = NULL;

            if ( !CreduiLookupLocalSidFromRid(DOMAIN_USER_RID_ADMIN, &adminSid)) {
                adminSid = NULL;
            }

            // Add local administrators to the combo box:

            for (i = 0; i < nameCount; ++i)
            {
                if ( groupInfo[i].lgrmi2_sidusage == SidTypeUser )
                {
                    DWORD ComboBoxIndex;
                    BOOLEAN IsAdminAccount;
                    BOOLEAN RememberComboBoxIndex;


                    //
                    // If this is Personal and not safe mode,
                    //  Ignore the well-known Administrator account.
                    //

                    IsAdminAccount = (adminSid != NULL) &&
                                     EqualSid(adminSid, groupInfo[i].lgrmi2_sid);

                    if ( CreduiIsPersonal &&
                                !CreduiIsSafeMode &&
                                IsAdminAccount ) {

                            continue;
                    }

                    //
                    // If the caller wants to prepopulate the edit box,
                    //  flag that we need to remember this account
                    //
                    // Detect the well known admin account
                    //

                    RememberComboBoxIndex = FALSE;

                    if ( (Style & CRS_PREFILLADMIN) != 0 &&
                         IsAdminAccount ) {

                        RememberComboBoxIndex = TRUE;

                    }

                    //
                    // Add the name to the combo box
                    //

                    ComboBoxIndex =  UserNameComboBox.Add(
                            TrimUsername( AccountDomainName, groupInfo[i].lgrmi2_domainandname),
                            0,
                            IsAutoComplete,
                            TRUE);

                    if ( ComboBoxIndex == -1 ) {
                        break;
                    }

                    //
                    // If we're to remember the index,
                    //  do so.
                    //

                    if ( RememberComboBoxIndex ) {

                        UserNameSelection = ComboBoxIndex;

                        IsChangingUserName = TRUE;
                        SendMessage(UserNameControlWindow,
                                    CB_SETCURSEL,
                                    ComboBoxIndex,
                                    0);
                        IsChangingUserName = FALSE;
                    }
                }

            }

            delete [] adminSid;
            NetApiBufferFree(groupInfo);
        }
    }

    if ( AccountDomainName != NULL ) {
        NetApiBufferFree( AccountDomainName );
    }

    return TRUE;
}

//=============================================================================
// CreduiCredentialControl::InitWindow
//
// Created 06/20/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiCredentialControl::InitWindow()
{
    // Set that we're intialized here, even though the controls have not yet
    // been created, etc.:

    IsInitialized = TRUE;

    // Make sure WS_EX_CONTROLPARENT is set:

    SetWindowLong(Window,
                  GWL_EXSTYLE,
                  GetWindowLong(Window, GWL_EXSTYLE) |
                      WS_EX_CONTROLPARENT);

    // Initialize the balloon tip for this window:

    if (!CreateControls() ||
        !BalloonTip.Init(CreduiInstance, Window))
    {
        return FALSE;
    }

    // Limit the number of characters entered into the user name and password
    // edit controls:

    SendMessage(UserNameControlWindow,
                CB_LIMITTEXT,
                CREDUI_MAX_USERNAME_LENGTH,
                0);

    SendMessage(PasswordControlWindow,
                EM_LIMITTEXT,
                CREDUI_MAX_PASSWORD_LENGTH,
                0);

    // Set the password character to something cooler:

    PasswordBox.Init(PasswordControlWindow,
                     &BalloonTip,
                     &CreduiCapsLockTipInfo);

    // Initialize the user name auto complete combo box:

    if ( !KeepUserName )
    {
        if (((Style & CRS_USERNAMES) && InitComboBoxUserNames()) ||
            UserNameComboBox.Init(CreduiInstance,
                                  UserNameControlWindow,
                                  0,
                                  IDB_TYPES,
                                  IMAGE_USERNAME))
        {
            // Since we're finished adding auto complete names, enable it now.
            // On failure, the UI can still be presented:

            UserNameComboBox.Enable();

            BOOL haveCertificates = FALSE;

            CertBaseInComboBox = (ULONG)
                SendMessage(UserNameControlWindow,
                            CB_GETCOUNT, 0, 0);

            if (Style & CRS_CERTIFICATES)
            {
                haveCertificates = AddCertificates();
            }

            SmartCardBaseInComboBox = CertBaseInComboBox + CertCount;

            if ((Style & CRS_SMARTCARDS) && CreduiHasSmartCardSupport)
            {
    #ifdef SCARDREPORTS
                CreduiDebugLog("CREDUI: Call to SCardUIInit for %0x\n",Window);
    #endif
                ScardUiHandle = SCardUIInit(Window);

                if (ScardUiHandle == NULL)
                {
    #ifdef SCARDREPORTS
                    CreduiDebugLog("CREDUI: Call to SCardUIInit failed\n");
    #endif
                    CreduiDebugLog("CreduiCredentialControl::InitWindow: "
                                   "SCardUIInit failed\n");
                }
            }

            // If NoEditUserName is allowed, make sure we eithet have at least one certificate
            // or a prefilled username for the control, otherwise fail

            if (NoEditUserName )
            {
                if (!haveCertificates &&
                    (ScardUiHandle == NULL))
                {
                    return FALSE;
                }

                IsChangingUserName = TRUE;
                SendMessage(UserNameControlWindow,
                            CB_SETCURSEL,
                            0,
                            0);
                IsChangingUserName = FALSE;

                // If we have at least one certificate, enable the view control
                // now. If a smart card, it will be enabled later:

                if (CertCount > 0)
                {
                    EnableWindow(ViewCertControlWindow, TRUE);
                    DisabledControlMask &= ~DISABLED_CONTROL_VIEW;
                }
            }

            // Wait until everything has been initialized before
            // we have the update.  This will now properly determine if the default
            // user name is a smart card or not.
            OnUserNameSelectionChange();
        }
        else
        {
            return FALSE;
        }
    }

    if ( !DoingCommandLine ) {
        SetFocus(UserNameControlWindow);
    }

    return TRUE;
}

//=============================================================================
// CredioCredentialControl::Enable
//
// Enables or disables all the user controls in the control.
//
// Arguments:
//   enable (in) - TRUE to enable the controls, FALSE to disable.
//
// Created 06/20/2000 johnstep (John Stephens)
//=============================================================================

VOID
CreduiCredentialControl::Enable(
    BOOL enable
    )
{
    if (enable && (DisabledControlMask & DISABLED_CONTROL))
    {
        DisabledControlMask &= ~DISABLED_CONTROL;

        //EnableWindow(UserNameStaticWindow, TRUE);
        //EnableWindow(UserNameControlWindow, TRUE);

        if (!(DisabledControlMask & DISABLED_CONTROL_USERNAME))
        {
            EnableWindow(UserNameControlWindow, TRUE);
            EnableWindow(UserNameStaticWindow, TRUE);
        }
        
        if (!(DisabledControlMask & DISABLED_CONTROL_PASSWORD))
        {
            EnableWindow(PasswordControlWindow, TRUE);
            EnableWindow(PasswordStaticWindow, TRUE);
        }
        if (!(DisabledControlMask & DISABLED_CONTROL_VIEW))
        {
            EnableWindow(ViewCertControlWindow, TRUE);
        }
        if (SaveControlWindow != NULL)
        {
            if (!(DisabledControlMask & DISABLED_CONTROL_SAVE))
            {
                EnableWindow(SaveControlWindow, TRUE);
            }
        }

        IsChangingUserName = TRUE;
        SendMessage(UserNameControlWindow,
                    CB_SETCURSEL,
                    UserNameSelection,
                    0);
        IsChangingUserName = FALSE;

        OnUserNameSelectionChange();
    }
    else if (!(DisabledControlMask & DISABLED_CONTROL))
    {
        // Hide the balloon tip before disabling the window:

        if (BalloonTip.IsVisible())
        {
            BalloonTip.Hide();
        }

        DisabledControlMask |= DISABLED_CONTROL;

        UserNameSelection = (LONG) SendMessage(UserNameControlWindow,
                                               CB_GETCURSEL, 0, 0);

        EnableWindow(UserNameStaticWindow, FALSE);
        EnableWindow(UserNameControlWindow, FALSE);
        EnableWindow(ViewCertControlWindow, FALSE);

        EnableWindow(PasswordControlWindow, FALSE);
        SetFocus(UserNameControlWindow);
        EnableWindow(PasswordStaticWindow, FALSE);

        if (SaveControlWindow != NULL)
        {
            EnableWindow(SaveControlWindow, FALSE);
        }
    }
}

//=============================================================================
// CreduiCredentialControl::MessageHandlerCallback
//
// This is the actual callback function for the control window.
//
// Arguments:
//   window (in)
//   message (in)
//   wParam (in)
//   lParam (in)
//
// Created 06/20/2000 johnstep (John Stephens)
//=============================================================================

LRESULT
CALLBACK
CreduiCredentialControl::MessageHandlerCallback(
    HWND window,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    // CreduiDebugLog( "Control Callback: %8.8lx %8.8lx %8.8lx\n", message, wParam, lParam );
    CreduiCredentialControl *that =
        reinterpret_cast<CreduiCredentialControl *>(
            GetWindowLongPtr(window, 0));

    if (that != NULL)
    {
        LRESULT result2;
        ASSERT(window == that->Window);
        // CreduiDebugLog( "Certhashes: %8.8lx %8.8lx\n", that, that->CertHashes );

        result2 = that->MessageHandler(message, wParam, lParam);

        // CreduiDebugLog( "Certhashes2: %8.8lx %8.8lx\n", that, that->CertHashes );
        return result2;
    }

    if (message == WM_CREATE)
    {
        CreduiCredentialControl *control = new CreduiCredentialControl;

        if (control != NULL)
        {
            // Initialize some state:

            control->FirstPaint = TRUE;
            control->ShowBalloonTip = FALSE;

            control->Window = window;
            control->Style = GetWindowLong(window, GWL_STYLE);

            // Store this object's pointer in the user data window long:

            SetLastError(0);
            LONG_PTR retPtr = SetWindowLongPtr(window,
                                            0,
                                            reinterpret_cast<LONG_PTR>(control));

            if ( retPtr != 0  || GetLastError() == 0 )
            {
                // we sucessfully set the window pointer

                // If any of the required styles are set, initialize the window
                // now. Otherwise, defer until CRM_INITSTYLE:

                if (control->Style & (CRS_USERNAMES |
                                      CRS_CERTIFICATES |
                                      CRS_SMARTCARDS))
                {
                    if (control->InitWindow())
                    {
                        return TRUE;
                    }
                }
                else
                {
                    return TRUE;
                }
            }

            SetWindowLongPtr(window, 0, 0);

            delete control;
            control = NULL;
        }

        DestroyWindow(window);
        return 0;
    }

    return DefWindowProc(window, message, wParam, lParam);
}

//=============================================================================
// CreduiCredentialControl::OnSetUserNameA
//
// Created 06/22/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiCredentialControl::OnSetUserNameA(
    CHAR *userNameA
    )
{
    BOOL success = FALSE;

    if (userNameA != NULL)
    {
        ULONG bufferSize = lstrlenA(userNameA) + 1;

        WCHAR *userName = new WCHAR[bufferSize];

        if (userName != NULL)
        {
            if (MultiByteToWideChar(CP_ACP,
                                    0,
                                    userNameA,
                                    -1,
                                    userName,
                                    bufferSize) > 0)
            {
                success = OnSetUserName(userName);
            }

            delete [] userName;
        }
    }
    else
    {
        success = OnSetUserName(NULL);
    }

    return success;
};

//=============================================================================
// CreduiCredentialControl::OnSetUserName
//
// Created 06/22/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiCredentialControl::OnSetUserName(
    WCHAR *userName
    )
{
    if ((userName == NULL) || !LocalCredIsMarshaledCredentialW(userName))
    {

        //
        // Save the initial user name for command line
        //

        if ( DoingCommandLine ) {
            InitialUserName = new WCHAR[lstrlen(userName) + 1];

            if ( InitialUserName == NULL ) {
                return FALSE;
            }

            lstrcpy( InitialUserName, userName );
        }

        return SetWindowText(UserNameControlWindow, userName);
    }
    else
    {
        CRED_MARSHAL_TYPE credMarshalType;
        CERT_CREDENTIAL_INFO *certCredInfo = NULL;
        BOOL foundCert = FALSE;

        if (LocalCredUnmarshalCredentialW(
                userName,
                &credMarshalType,
                reinterpret_cast<VOID **>(&certCredInfo)))
        {
            // Search for the certificate. What can we do if it is a
            // smart card? Well, at least we can still search for it,
            // but it is a bit more work because we must retrieve the
            // hash from the context.

            if (credMarshalType == CertCredential)
            {
                for (UINT i = 0; i < CertCount; ++i)
                {
                    if (RtlCompareMemory(CertHashes[i],
                                         certCredInfo->rgbHashOfCert,
                                         CERT_HASH_LENGTH) ==
                                         CERT_HASH_LENGTH)
                    {
                        IsChangingUserName = TRUE;
                        SendMessage(UserNameControlWindow,
                                    CB_SETCURSEL,
                                    CertBaseInComboBox + i,
                                    0);
                        IsChangingUserName = FALSE;

                        OnUserNameSelectionChange();

                        EnableWindow(ViewCertControlWindow, TRUE);
                        DisabledControlMask &= ~DISABLED_CONTROL_VIEW;

                        foundCert = TRUE;
                        break;
                    }
                }

                // If we couldn't find the certificate in our list, determine
                // if this is a smart card certificate, based on its entry in
                // the MY certificate store. If it is, store the hash and
                // check for it on certificate arrival messages:

                if (!foundCert)
                {
                    CONST CERT_CONTEXT *certContext = NULL;
                    HCERTSTORE certStore = NULL;

                    certStore = CertOpenSystemStore(NULL, L"MY");

                    if (certStore != NULL)
                    {
                        CRYPT_HASH_BLOB hashBlob;

                        hashBlob.cbData = CERT_HASH_LENGTH;
                        hashBlob.pbData = reinterpret_cast<BYTE *>(
                            certCredInfo->rgbHashOfCert);

                        certContext = CertFindCertificateInStore(
                                          certStore,
                                          X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                          0,
                                          CERT_FIND_SHA1_HASH,
                                          &hashBlob,
                                          NULL);
                    }

                    // If we found a certificate context, check to see if it
                    // is from a smart card:

                    if ((certContext != NULL) &&
                        CreduiIsRemovableCertificate(certContext))
                    {
                        UserNameCertHash = new UCHAR [1][CERT_HASH_LENGTH];

                        if (UserNameCertHash != NULL)
                        {
                            CopyMemory(UserNameCertHash,
                                       certCredInfo->rgbHashOfCert,
                                       CERT_HASH_LENGTH);

                            foundCert = TRUE;
                        }
                    }

                    // If we opened a store, free the certificate and close
                    // the store:

                    if (certStore != NULL)
                    {
                        if (certContext != NULL)
                        {
                            CertFreeCertificateContext(certContext);
                        }

                        if (!CertCloseStore(certStore, 0))
                        {
                            CreduiDebugLog(
                                "CreduiCredentialControl::OnSetUserName: "
                                "CertCloseStore failed: %u\n",
                                GetLastError());
                        }
                    }
                }
            }

            LocalCredFree(static_cast<VOID *>(certCredInfo));
        }
        else
        {
            // Could not unmarshal, so just forget it:

            CreduiDebugLog(
                "CreduiCredentialControl::OnSetUserName: "
                "CredUnmarshalCredential failed: %u\n",
                GetLastError());
        }

        return foundCert;
    }
};

//=============================================================================
// CreduiCredentialControl::OnGetUserNameA
//
// Created 06/22/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiCredentialControl::OnGetUserNameA(
    CHAR *userNameA,
    ULONG maxChars
    )
{
    BOOL success = FALSE;

    if ((userNameA != NULL) && (maxChars != 0))
    {
        WCHAR *userName = new WCHAR[maxChars + 1];

        if (userName != NULL)
        {
            if (OnGetUserName(userName, maxChars) &&
                WideCharToMultiByte(
                    CP_ACP,
                    0,
                    userName,
                    -1,
                    userNameA,
                    maxChars + 1, NULL, NULL))
            {
                success = TRUE;
            }

            delete [] userName;
        }
    }

    return success;
};

//=============================================================================
// CreduiCredentialControl::OnGetUserName
//
// Created 06/22/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiCredentialControl::OnGetUserName(
    WCHAR *userName,
    ULONG maxChars
    )
{

    if (  KeepUserName )
    {
        SetLastError(0);

        return (GetWindowText(UserNameControlWindow,
                              userName,
                              maxChars + 1) > 0) ||
               (GetLastError() == ERROR_SUCCESS);


    }
    else
    {


        COMBOBOXEXITEM item;

        item.iItem = SendMessage(UserNameControlWindow, CB_GETCURSEL, 0, 0);

        // If we are trying to match a smart card certificate, fail this:

        if (UserNameCertHash != NULL)
        {
            return FALSE;
        }

        // If this is not a certificate, it's easy:

        if ((item.iItem == CB_ERR) || (item.iItem < CertBaseInComboBox))
        {
            BOOL RetVal;
            SetLastError(0);

            RetVal = GetWindowText(UserNameControlWindow,
                                   userName,
                                   maxChars + 1) > 0;

            if ( !RetVal ) {
                return ( GetLastError() == ERROR_SUCCESS );
            }

            //
            // Complete the typed in username


            if ( Style & CRS_COMPLETEUSERNAME) {

                RetVal = CompleteUserName(
                                     userName,
                                     maxChars,
                                     NULL,      // No target info
                                     NULL,
                                     0);        // No target name

            } else {

                RetVal = TRUE;
            }

            return RetVal;

        }

        // This is a certificate, maybe from a smart card:

        item.mask = CBEIF_IMAGE | CBEIF_TEXT;
        item.pszText = userName;
        item.cchTextMax = maxChars + 1;

        if (!SendMessage(UserNameControlWindow,
                         CBEM_GETITEM,
                         0,
                         reinterpret_cast<LPARAM>(&item)))
        {
            return FALSE;
        }

        CERT_CREDENTIAL_INFO certCredInfo;

        certCredInfo.cbSize = sizeof certCredInfo;

        if (item.iItem >= SmartCardBaseInComboBox)
        {
            if (item.iImage == IMAGE_SMART_CARD_MISSING)
            {
                return FALSE;
            }

            CERT_ENUM *certEnum =
                reinterpret_cast<CERT_ENUM *>(
                    SendMessage(UserNameControlWindow,
                                CB_GETITEMDATA, item.iItem, 0));

            // NOTE: Consider more complete error handling here.

            if (certEnum != NULL)
            {
                DWORD length = CERT_HASH_LENGTH;

                if (!CertGetCertificateContextProperty(
                        certEnum->pCertContext,
                        CERT_SHA1_HASH_PROP_ID,
                        static_cast<VOID *>(
                            certCredInfo.rgbHashOfCert),
                        &length))
                {
                    return FALSE;
                }
            }
            else
            {
                return FALSE;
            }
        }
        else
        {
            CopyMemory(certCredInfo.rgbHashOfCert,
                       &CertHashes[item.iItem - CertBaseInComboBox],
                       CERT_HASH_LENGTH);
        }

        WCHAR *marshaledCred;

        if (LocalCredMarshalCredentialW(CertCredential,
                                  &certCredInfo,
                                  &marshaledCred))
        {
            lstrcpyn(userName,
                     marshaledCred,
                     maxChars + 1);

            LocalCredFree(static_cast<VOID *>(marshaledCred));

            return TRUE;
        }
        else
        {
            CreduiDebugLog("CreduiCredentialControl::OnGetUserName: "
                           "CredMarshalCredential failed: %u\n",
                           GetLastError());

            return FALSE;
        }

    }

}

//=============================================================================
// CreduiCredentialControl::OnSetPasswordA
//
// Created 06/22/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiCredentialControl::OnSetPasswordA(
    CHAR *passwordA
    )
{
    return SetWindowTextA(PasswordControlWindow, passwordA);
};

//=============================================================================
// CreduiCredentialControl::OnSetPassword
//
// Created 06/22/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiCredentialControl::OnSetPassword(
    WCHAR *password
    )
{
    return SetWindowText(PasswordControlWindow, password);
};

//=============================================================================
// CreduiCredentialControl::OnGetPasswordA
//
// Created 06/22/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiCredentialControl::OnGetPasswordA(
    CHAR *passwordA,
    ULONG maxChars
    )
{
    if (DisabledControlMask & DISABLED_CONTROL_PASSWORD)
    {
        return FALSE;
    }

    SetLastError(0);

    return (GetWindowTextA(PasswordControlWindow,
                           passwordA,
                           maxChars + 1) > 0) ||
           (GetLastError() == ERROR_SUCCESS);
};

//=============================================================================
// CreduiCredentialControl::OnGetPassword
//
// Created 06/22/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiCredentialControl::OnGetPassword(
    WCHAR *password,
    ULONG maxChars
    )
{
    if (DisabledControlMask & DISABLED_CONTROL_PASSWORD)
    {
        return FALSE;
    }

    SetLastError(0);

    return (GetWindowText(PasswordControlWindow,
                          password,
                          maxChars + 1) > 0) ||
           (GetLastError() == ERROR_SUCCESS);
};

//=============================================================================
// CreduiCredentialControl::OnGetUserNameLength
//
// Created 07/19/2000 johnstep (John Stephens)
//=============================================================================

LONG
CreduiCredentialControl::OnGetUserNameLength()
{
    COMBOBOXEXITEM item;

    if (UserNameCertHash != NULL)
    {
        return -1;
    }

    item.iItem = SendMessage(UserNameControlWindow, CB_GETCURSEL, 0, 0);

    // If this is not a certificate, it's easy:

    if ((item.iItem == CB_ERR) || (item.iItem < CertBaseInComboBox))
    {
        return GetWindowTextLength(UserNameControlWindow);
    }
    else
    {
        WCHAR userName[CREDUI_MAX_USERNAME_LENGTH + 1];

        if (OnGetUserName(userName, CREDUI_MAX_USERNAME_LENGTH))
        {
            return lstrlen(userName);
        }
        else
        {
            return -1;
        }
    }
}

//=============================================================================
// CreduiCredentialControl::OnShowBalloonA
//
// Created 06/23/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiCredentialControl::OnShowBalloonA(
    CREDUI_BALLOONA *balloonA
    )
{
    // If NULL was passed, this means to hide the balloon:

    if (balloonA == NULL)
    {
        if (BalloonTip.IsVisible())
        {
            BalloonTip.Hide();
        }
        return TRUE;
    }

    // Argument validation, should match OnShowBalloon:

    if ((balloonA->dwVersion != 1) ||
        (balloonA->pszTitleText == NULL) ||
        (balloonA->pszMessageText == NULL))
    {
        return FALSE;
    }

    if ((balloonA->pszTitleText[0] == '\0') ||
        (balloonA->pszMessageText[0] == '\0'))
    {
        return FALSE;
    }

    BOOL success = FALSE;

    CREDUI_BALLOON balloon;

    balloon.dwVersion = balloonA->dwVersion;
    balloon.iControl = balloonA->iControl;
    balloon.iIcon = balloonA->iIcon;

    ULONG titleTextLength = lstrlenA(balloonA->pszTitleText);
    ULONG messageTextLength = lstrlenA(balloonA->pszMessageText);

    balloon.pszTitleText = new WCHAR[titleTextLength + 1];

    if (balloon.pszTitleText != NULL)
    {
        if (MultiByteToWideChar(CP_ACP,
                                0,
                                balloonA->pszTitleText,
                                -1,
                                balloon.pszTitleText,
                                titleTextLength + 1) > 0)
        {
            balloon.pszMessageText = new WCHAR[messageTextLength + 1];

            if (balloon.pszMessageText != NULL)
            {
                if (MultiByteToWideChar(CP_ACP,
                                        0,
                                        balloonA->pszMessageText,
                                        -1,
                                        balloon.pszMessageText,
                                        messageTextLength + 1) > 0)
                {
                    success = OnShowBalloon(&balloon);
                }

                delete [] balloon.pszMessageText;
            }
        }

        delete [] balloon.pszTitleText;
    }

    return success;
};

//=============================================================================
// CreduiCredentialControl::OnShowBalloon
//
// Created 06/23/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiCredentialControl::OnShowBalloon(
    CREDUI_BALLOON *balloon
    )
{
    // If NULL was passed, this means to hide the balloon:

    if (balloon == NULL)
    {
        if (BalloonTip.IsVisible())
        {
            BalloonTip.Hide();
        }
        return TRUE;
    }

    // Argument validation:

    if ((balloon->dwVersion != 1) ||
        (balloon->pszTitleText == NULL) ||
        (balloon->pszMessageText == NULL))
    {
        return FALSE;
    }


    if ((balloon->pszTitleText[0] == L'\0') ||
        (balloon->pszMessageText[0] == L'\0'))
    {
        return FALSE;
    }

    lstrcpyn(CreduiCustomTipInfo.Title,
             balloon->pszTitleText,
             CREDUI_MAX_BALLOON_TITLE_LENGTH + 1);

    lstrcpyn(CreduiCustomTipInfo.Text,
             balloon->pszMessageText,
             CREDUI_MAX_BALLOON_MESSAGE_LENGTH + 1);

    CreduiCustomTipInfo.Icon = balloon->iIcon;

//    BalloonTip.SetInfo(
//        (balloon->iControl == CREDUI_CONTROL_PASSWORD) ?
//            PasswordControlWindow : UserNameControlWindow,
//        &CreduiCustomTipInfo);

    if ( balloon->iControl != CREDUI_CONTROL_PASSWORD )
    BalloonTip.SetInfo( UserNameControlWindow, &CreduiCustomTipInfo);

    BalloonTip.Show();

    return TRUE;
};

//=============================================================================
// CreduiCredentialControl::OnUserNameSelectionChange
//
// Created 06/21/2000 johnstep (John Stephens)
//=============================================================================

VOID
CreduiCredentialControl::OnUserNameSelectionChange()
{
    COMBOBOXEXITEM item;
    LRESULT current;

    // Delete the user name certificate hash if the user has changed the
    // selection:

    if (UserNameCertHash != NULL)
    {
        delete [] UserNameCertHash;
        UserNameCertHash = NULL;
    }

    current = SendMessage(UserNameControlWindow,
                          CB_GETCURSEL, 0, 0);

    item.mask = CBEIF_IMAGE;
    item.iItem = current;

    SendMessage(UserNameControlWindow, CBEM_GETITEM,
                0, reinterpret_cast<LPARAM>(&item));

    if (current < CertBaseInComboBox)
    {
        EnableWindow(ViewCertControlWindow, FALSE);
        DisabledControlMask |= DISABLED_CONTROL_VIEW;

        SetWindowText(
            PasswordStaticWindow,
            CreduiStrings.PasswordStatic);

        EnableWindow(PasswordControlWindow, TRUE);
        EnableWindow(PasswordStaticWindow, TRUE);
        DisabledControlMask &= ~DISABLED_CONTROL_PASSWORD;

        WCHAR* pUserNameLabel;
        if ( IsPassport )
            pUserNameLabel = CreduiStrings.EmailName;
        else
            pUserNameLabel = CreduiStrings.UserNameStatic;

        SetWindowText(
            UserNameStaticWindow,
            pUserNameLabel);

        if (SaveControlWindow != NULL)
        {
            EnableWindow(SaveControlWindow, TRUE);
            DisabledControlMask &= ~DISABLED_CONTROL_SAVE;
        }
    }
    else
    {
        SetWindowText(
            PasswordStaticWindow,
            CreduiStrings.PinStatic);

        if (item.iImage != IMAGE_SMART_CARD_MISSING)
        {
            EnableWindow(ViewCertControlWindow, TRUE);
            DisabledControlMask &= ~DISABLED_CONTROL_VIEW;
        }
        else
        {
            EnableWindow(ViewCertControlWindow, FALSE);
            DisabledControlMask |= DISABLED_CONTROL_VIEW;
        }

        IsChangingPassword = TRUE;
        SetWindowText(PasswordControlWindow, NULL);
        IsChangingPassword = FALSE;

        if (current >= SmartCardBaseInComboBox)
        {
            EnableWindow(PasswordControlWindow, TRUE);
            EnableWindow(PasswordStaticWindow, TRUE);
            DisabledControlMask &= ~DISABLED_CONTROL_PASSWORD;
        }
        else
        {
            EnableWindow(PasswordControlWindow, FALSE);
            EnableWindow(PasswordStaticWindow, FALSE);
            DisabledControlMask |= DISABLED_CONTROL_PASSWORD;
        }

        SetWindowText(
            UserNameStaticWindow,
            item.iImage >= IMAGE_SMART_CARD ?
                CreduiStrings.SmartCardStatic :
                CreduiStrings.CertificateStatic);

        if (SaveControlWindow != NULL)
        {
            EnableWindow(SaveControlWindow, FALSE);
            DisabledControlMask |= DISABLED_CONTROL_SAVE;
        }
    }
}

//=============================================================================
// CreduiCredentialControl::MessageHandler
//
// Called from the control window callback to handle the window messages.
//
// Arguments:
//   message (in)
//   wParam (in)
//   lParam (in)
//
// Created 06/20/2000 johnstep (John Stephens)
//=============================================================================

LRESULT
CreduiCredentialControl::MessageHandler(
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    // If not initialized, only handle CRM_INITSTYLE:

    if (!IsInitialized)
    {
        if (message == CRM_INITSTYLE)
        {
            wParam &= CRS_USERNAMES |
                      CRS_CERTIFICATES |
                      CRS_SMARTCARDS |
                      CRS_ADMINISTRATORS |
                      CRS_PREFILLADMIN |
                      CRS_COMPLETEUSERNAME |
                      CRS_SAVECHECK |
                      CRS_KEEPUSERNAME;

            if (wParam != 0)
            {
                Style |= wParam;

                SetWindowLong(Window,
                              GWL_STYLE,
                              GetWindowLong(Window, GWL_STYLE) | Style);

                DoingCommandLine = (BOOL) lParam;

                return InitWindow();
            }

            return FALSE;
        }
        else
        {
            return DefWindowProc(Window, message, wParam, lParam);
        }
    }
    else if (message == WM_ENABLE)
    {
        Enable((BOOL) wParam);
    }

    // Always handle smart card messages, if support is available:

    if (ScardUiHandle != NULL)
    {
        // This function call will return TRUE if the message was handled:

        if (HandleSmartCardMessages(
                message,
                reinterpret_cast<CERT_ENUM *>(wParam)))
        {
            return 0;
        }
    }

    switch (message)
    {
    case CRM_SETUSERNAMEMAX:
        SendMessage(UserNameControlWindow, CB_LIMITTEXT, wParam, 0);
        return TRUE;

    case CRM_SETPASSWORDMAX:
        SendMessage(PasswordControlWindow, EM_LIMITTEXT, wParam, 0);
        return TRUE;
        
    case CRM_DISABLEUSERNAME:
        {
            DisabledControlMask |= DISABLED_CONTROL_USERNAME;
            EnableWindow(UserNameControlWindow,FALSE);
            EnableWindow(UserNameStaticWindow,FALSE);
            return TRUE;
        }
    case CRM_ENABLEUSERNAME:
        {
            DisabledControlMask &= ~DISABLED_CONTROL_USERNAME;
            EnableWindow(UserNameControlWindow,TRUE);
            EnableWindow(UserNameStaticWindow,TRUE);
            return TRUE;
        }
    
    case CRM_GETUSERNAMEMAX:
        return
            SendMessage(
                reinterpret_cast<HWND>(
                    SendMessage(Window, CBEM_GETEDITCONTROL, 0, 0)),
                 EM_GETLIMITTEXT,
                 0,
                 0);

    case CRM_GETPASSWORDMAX:
        return SendMessage(UserNameControlWindow, EM_GETLIMITTEXT, 0, 0);

    case CRM_SETUSERNAMEA:
        return OnSetUserNameA(reinterpret_cast<CHAR *>(lParam));
    case CRM_SETUSERNAMEW:
        return OnSetUserName(reinterpret_cast<WCHAR *>(lParam));

    case CRM_GETUSERNAMEA:
        return OnGetUserNameA(reinterpret_cast<CHAR *>(lParam), (ULONG) wParam);
    case CRM_GETUSERNAMEW:
        return OnGetUserName(reinterpret_cast<WCHAR *>(lParam), (ULONG) wParam);

    case CRM_SETPASSWORDA:
        return OnSetPasswordA(reinterpret_cast<CHAR *>(lParam));
    case CRM_SETPASSWORDW:
        return OnSetPassword(reinterpret_cast<WCHAR *>(lParam));

    case CRM_GETPASSWORDA:
        return OnGetPasswordA(reinterpret_cast<CHAR *>(lParam), (ULONG) wParam);
    case CRM_GETPASSWORDW:
        return OnGetPassword(reinterpret_cast<WCHAR *>(lParam), (ULONG) wParam);

    case CRM_GETUSERNAMELENGTH:
        return OnGetUserNameLength();

    case CRM_GETPASSWORDLENGTH:
        if (IsWindowEnabled(PasswordControlWindow))
        {
            return GetWindowTextLength(PasswordControlWindow);
        }
        return -1;

    case CRM_SETFOCUS:
        if ( DoingCommandLine ) {
            return 0;
        }
        switch (wParam)
        {
        case CREDUI_CONTROL_USERNAME:
            SetFocus(UserNameControlWindow);
            return TRUE;

        case CREDUI_CONTROL_PASSWORD:
            if (IsWindowEnabled(PasswordControlWindow))
            {
                SetFocus(PasswordControlWindow);

                // NOTE: Is it OK to always select the entire password text
                //       on this explicit set focus message?

                SendMessage(PasswordControlWindow, EM_SETSEL, 0, -1);
                return TRUE;
            }
            break;
        }
        return 0;

    case CRM_SHOWBALLOONA:
        return OnShowBalloonA(reinterpret_cast<CREDUI_BALLOONA *>(lParam));
    case CRM_SHOWBALLOONW:
        return OnShowBalloon(reinterpret_cast<CREDUI_BALLOON *>(lParam));

    case CRM_GETMINSIZE:
        SIZE *minSize;

        minSize = reinterpret_cast<SIZE *>(lParam);

        if (minSize != NULL)
        {
            minSize->cx = CREDUI_CONTROL_MIN_WIDTH;
            minSize->cy = CREDUI_CONTROL_MIN_HEIGHT;

            if (Style & CRS_SAVECHECK )
            {
                minSize->cy += CREDUI_CONTROL_ADD_SAVE;
            }

            return TRUE;
        }

        return FALSE;

    case CRM_SETCHECK:
        switch (wParam)
        {
        case CREDUI_CONTROL_SAVE:
            if ((Style & CRS_SAVECHECK ) &&
                IsWindowEnabled(SaveControlWindow))
            {
                CheckDlgButton(Window, IDC_SAVE,
                               lParam ? BST_CHECKED : BST_UNCHECKED);

                return TRUE;
            }
            break;

        }
        return FALSE;

    case CRM_GETCHECK:
        switch (wParam)
        {
        case CREDUI_CONTROL_SAVE:
            return
                (Style & CRS_SAVECHECK ) &&
                IsWindowEnabled(SaveControlWindow) &&
                IsDlgButtonChecked(Window, IDC_SAVE);

        default:
            return FALSE;
        }

    case CRM_DOCMDLINE:
        ASSERT( DoingCommandLine );

        //
        // For smartcards,
        //  just start the timer and we'll prompt when the timer has gone off.
        //

        TargetName = (LPWSTR)lParam;
        if ( Style & CRS_SMARTCARDS) {
            DWORD WinStatus;

            Heartbeats = 0;
            {
                WCHAR szMsg[CREDUI_MAX_CMDLINE_MSG_LENGTH + 1];
                szMsg[0] = 0;
                FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                            CreduiInstance,
                            IDS_READING_SMARTCARDS,
                            0,
                            szMsg,
                            CREDUI_MAX_CMDLINE_MSG_LENGTH,
                            NULL);
                CredPutStdout(szMsg);
            }

            if ( SetTimer ( Window, CREDUI_HEARTBEAT_TIMER, CREDUI_HEARTBEAT_TIMER_VALUE, NULL ) == 0 ) {
                // bail out of our wait loop if we couldn't set a timer
                return GetLastError();
            }


        //
        // For passwords,
        //  just do the prompt to save.
        //

        } else {

            CmdlineSavePrompt();
            PostQuitMessage( NO_ERROR );
        }

        return NO_ERROR;


    case WM_HELP:
        return OnHelpInfo(lParam);

    case WM_SETFONT:
        // Forward font setting from dialog to each control, except the
        // password control since we use a special font there:

        if (UserNameStaticWindow != NULL)
        {
            SendMessage(UserNameStaticWindow, message, wParam, lParam);
        }

        if (UserNameControlWindow != NULL)
        {
            SendMessage(UserNameControlWindow, message, wParam, lParam);
        }

        if (ViewCertControlWindow != NULL)
        {
            SendMessage(ViewCertControlWindow, message, wParam, lParam);
        }

        if (PasswordStaticWindow != NULL)
        {
            SendMessage(PasswordStaticWindow, message, wParam, lParam);
        }

        if (PasswordControlWindow != NULL)
        {
            SendMessage(PasswordControlWindow, message, wParam, lParam);
        }

        if (SaveControlWindow != NULL)
        {
            SendMessage(SaveControlWindow, message, wParam, lParam);
        }

        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_VIEW_CERT:
            ViewCertificate((INT)
                SendMessage(UserNameControlWindow,
                            CB_GETCURSEL, 0, 0));
            return 0;

        case IDC_PASSWORD:
            if (HIWORD(wParam) == EN_CHANGE)
            {
                // Always send the change message?

                SendMessage(
                    GetParent(Window),
                    WM_COMMAND,
                    MAKELONG(GetWindowLongPtr(Window, GWLP_ID),
                             CRN_PASSWORDCHANGE),
                    reinterpret_cast<LPARAM>(Window));
            }
            return 0;

        case IDC_USERNAME:
            switch (HIWORD(wParam))
            {
            case CBN_EDITCHANGE:
            case CBN_DROPDOWN:
            case CBN_KILLFOCUS:
                if ((HIWORD(wParam) != CBN_EDITCHANGE) || !IsChangingUserName)
                {
                    if (BalloonTip.IsVisible())
                    {
                        BalloonTip.Hide();
                    }
                }

                if (HIWORD(wParam) == CBN_EDITCHANGE)
                {
                    // Always send the change message?

                    SendMessage(
                        GetParent(Window),
                        WM_COMMAND,
                        MAKELONG(GetWindowLongPtr(Window, GWLP_ID),
                                 CRN_USERNAMECHANGE),
                        reinterpret_cast<LPARAM>(Window));

                    // If the name has changed as a result of user editing,
                    // reset to user name settings:

                    BOOL isDropped = (BOOL)
                        SendMessage(UserNameControlWindow,
                                    CB_GETDROPPEDSTATE, 0, 0);

                    if (isDropped)
                    {
                        OnUserNameSelectionChange();

                        RECT rect;

                        GetClientRect(UserNameControlWindow, &rect);
                        InvalidateRect(UserNameControlWindow, &rect, FALSE);

                        SendMessage(Window,
                                    CB_SETCURSEL,
                                    SendMessage(Window, CB_GETCURSEL, 0, 0),
                                    0);

                        return 0;
                    }

                    if (IsChangingUserName)
                    {
                        return 0;
                    }

                    if (((UserNameCertHash != NULL) ||
                         (SendMessage(UserNameControlWindow,
                             CB_GETCURSEL, 0, 0) >= CertBaseInComboBox)) &&
                        !isDropped)
                    {
                        if (UserNameCertHash != NULL)
                        {
                            delete [] UserNameCertHash;
                            UserNameCertHash = NULL;
                        }

                        if (!SendMessage(UserNameControlWindow,
                                         CB_GETDROPPEDSTATE, 0, 0))
                        {
                            SetFocus(UserNameControlWindow);

                            if (SendMessage(UserNameControlWindow,
                                            CB_GETCURSEL, 0, 0) == CB_ERR)
                            {
                                IsChangingUserName = TRUE;
                                UserNameComboBox.Update(
                                    -1,
                                    L"",
                                    IMAGE_USERNAME);
                                IsChangingUserName = FALSE;

                                IsChangingPassword = TRUE;
                                SetWindowText(PasswordControlWindow, NULL);
                                IsChangingPassword = FALSE;

                                OnUserNameSelectionChange();
                            }
                        }
                    }
                }

                if (HIWORD(wParam) == CBN_DROPDOWN)
                {
                    if (UserNameCertHash != NULL)
                    {
                        delete [] UserNameCertHash;
                        UserNameCertHash = NULL;

                        IsChangingUserName = TRUE;
                        UserNameComboBox.Update(
                            -1,
                            L"",
                            IMAGE_USERNAME);
                        IsChangingUserName = FALSE;

                        IsChangingPassword = TRUE;
                        SetWindowText(PasswordControlWindow, NULL);
                        IsChangingPassword = FALSE;

                        OnUserNameSelectionChange();
                    }
                }

                return 0;

            case CBN_SELCHANGE:
                OnUserNameSelectionChange();
                return 0;
            }
            break;

        case IDC_SAVE:
            if (HIWORD(wParam) == BN_CLICKED)
            {
                return TRUE;
            }
            break;

        }
        break;

    case WM_PAINT:
        if (FirstPaint && GetUpdateRect(Window, NULL, FALSE))
        {
            FirstPaint = FALSE;

            if (ShowBalloonTip)
            {
                ShowBalloonTip = FALSE;
                BalloonTip.Show();
            }
        }
        break;

    case WM_TIMER:
        if ( wParam == CREDUI_HEARTBEAT_TIMER )
        {

            Heartbeats++;
#ifdef SCARDREPORTS
        CreduiDebugLog("CREDUI: thump thump\n",this->Window);
#endif


            //
            // If we've waited long enough,
            //  or all cards have been read,
            //  process the cards.
            //

            if ( Heartbeats > CREDUI_MAX_HEARTBEATS ||
                  ( Heartbeats > 2 && SmartCardReadCount == 0 )) {
#ifdef SCARDREPORTS
        CreduiDebugLog("CREDUI: Heartbeat timeout\n",this->Window);
#endif

                fputs( "\n", stdout );
                KillTimer ( Window, CREDUI_HEARTBEAT_TIMER );
                CmdlineSmartCardPrompt();

            //
            // If we're going to wait longer,
            //  let the user know we're making progress.
            //
            } else {
                fputs( ".", stdout );
            }



        }

        break;

    case WM_DESTROY:
        if (PasswordControlWindow != NULL)
        {
            SetWindowText(PasswordControlWindow, NULL);
            DestroyWindow(PasswordControlWindow);
            PasswordControlWindow = NULL;
        }

        if (PasswordStaticWindow != NULL)
        {
            DestroyWindow(PasswordStaticWindow);
            PasswordStaticWindow = NULL;
        }

        if (ViewCertControlWindow != NULL)
        {
            DestroyWindow(ViewCertControlWindow);
            ViewCertControlWindow = NULL;
        }

        if (UserNameControlWindow != NULL)
        {
            DestroyWindow(UserNameControlWindow);
            UserNameControlWindow = NULL;
        }

        if (UserNameStaticWindow != NULL)
        {
            DestroyWindow(UserNameStaticWindow);
            UserNameStaticWindow = NULL;
        }

        if (ScardUiHandle != NULL)
        {
#ifdef SCARDREPORTS
            CreduiDebugLog("CREDUI: Call to SCardUIExit\n");
#endif
            SCardUIExit(ScardUiHandle);
            ScardUiHandle = NULL;
        }

        if (UserNameCertHash != NULL)
        {
            delete [] UserNameCertHash;
            UserNameCertHash = NULL;
        }

        if (CertCount > 0)
        {
            ASSERT(CertHashes != NULL);

            delete [] CertHashes;
            CertHashes = NULL;
            CertCount = 0;
        }

        if ( InitialUserName != NULL ) {
            delete InitialUserName;
            InitialUserName = NULL;
        }

        // Only call CoUninitialize if we successfully initialized for STA:

        if (IsAutoComplete)
        {
            CoUninitialize();
        }

        return 0;

    case WM_NCDESTROY:
        delete this;
        return 0;
    }

    return DefWindowProc(Window, message, wParam, lParam);
}


BOOL CreduiCredentialControl::GetSmartCardInfo(
    IN DWORD SmartCardIndex,
    IN DWORD BufferLength,
    OUT LPWSTR Buffer,
    OUT BOOL *IsValid,
    OUT CERT_ENUM **CertEnum OPTIONAL
    )
/*++

Routine Description:

    Routine to get the smart card info for a smart card in the combo box

Arguments:

    SmartCardIndex - Index of the smart card relative to SmartCardBaseInComboBox

    BufferLength - Specifies the length of Buffer (in characters)

    Buffer - Specifies the buffer to return the text for the smart card

    IsValid - Return TRUE if the smartcard is valid
        Returns FALSE otherwise

    CertEnum - If specified, returns the description of the cert on the smartcard
        This field is should be ignore if IsValid is returns false

Return Values:

    Returns TRUE if Buffer and IsValid are filled in.

--*/
{
    COMBOBOXEXITEM item;

    //
    // Get the item from the control
    //

    item.iItem = SmartCardBaseInComboBox + SmartCardIndex;
    item.mask = CBEIF_IMAGE | CBEIF_TEXT;
    item.pszText = Buffer;
    item.cchTextMax = BufferLength;

    if (!SendMessage(UserNameControlWindow,
                     CBEM_GETITEM,
                     0,
                     reinterpret_cast<LPARAM>(&item)))
    {
        return FALSE;
    }

    *IsValid = (item.iImage == IMAGE_SMART_CARD);

    if ( CertEnum != NULL) {
        if ( *IsValid ) {

            *CertEnum = (CERT_ENUM *) SendMessage( UserNameControlWindow,
                                                   CB_GETITEMDATA, item.iItem, 0);

            // NOTE: Consider more complete error handling here.

            if ( *CertEnum == NULL) {
                return FALSE;
            }
        }
    }
    return TRUE;
}


LPWSTR CreduiCredentialControl::MatchSmartCard(
    IN DWORD SmartCardCount,
    IN LPWSTR UserName,
    OUT LPDWORD RetCertIndex,
    OUT CERT_ENUM **RetCertEnum
    )
/*++

Routine Description:

    Returns the smart card that matches UserName.

Arguments:

    SmartCardCount  - specifies the number of smart cards to search

    UserName - specifies the user name to match

    RetCertIndex - returns an index to the found smart card.

    RetCertEnum - returns the description of the cert on the smartcard

Return Values:

    Returns NULL if UserName matches one of the smart cards

    On failure, returns a printf-style format string describing the error

--*/
{
    WCHAR SmartCardText[CREDUI_MAX_USERNAME_LENGTH + 1];
    DWORD i;
    BOOL SmartCardValid;
    CERT_ENUM *CertEnum;
    CERT_ENUM *SavedCertEnum = NULL;
    DWORD SavedCertIndex = 0;


    //
    // Loop through the list of smart cards seeing if we see a match
    //

    for ( i=0; i<SmartCardCount; i++ ) {

        if ( !GetSmartCardInfo( i, CREDUI_MAX_USERNAME_LENGTH, SmartCardText, &SmartCardValid, &CertEnum ) ) {
            //return CreduiStrings.NoUsernameMatch;
            return (LPWSTR) IDS_NO_USERNAME_MATCH;
        }

        if ( !SmartCardValid ) {
            continue;
        }

        //
        // If the username is marshaled,
        //  compare the marshaled strings.
        //

        if ( LocalCredIsMarshaledCredentialW( UserName ) ) {
            WCHAR szTestmarshall[CREDUI_MAX_USERNAME_LENGTH+1];
            // see if this is the marshalled cred
             if ( CredUIMarshallNode ( CertEnum, szTestmarshall ) )
             {
                 if ( wcscmp ( szTestmarshall, UserName) == 0 ) {
                     *RetCertEnum = CertEnum;
                     *RetCertIndex = i;
                     return NULL;
                 }
             }

        //
        // If the username is not marshalled,
        //  just match a substring of the name
        //

        }  else if ( LookForUserNameMatch ( UserName, SmartCardText ) ) {

            //
            // If we already found a match,
            //  complain about the ambiguity.
            //

            if ( SavedCertEnum != NULL ) {
                //return CreduiStrings.ManyUsernameMatch;
                return (LPWSTR) IDS_MANY_USERNAME_MATCH;
            }

            SavedCertEnum = CertEnum;
            SavedCertIndex = i;
        }

    }

    //
    // If we didn't find a match,
    //  fail
    //

    if ( SavedCertEnum == NULL) {
        //return CreduiStrings.NoUsernameMatch;
        return (LPWSTR) IDS_NO_USERNAME_MATCH;
    }

    *RetCertEnum = SavedCertEnum;
    *RetCertIndex = SavedCertIndex;
    return NULL;
}



void CreduiCredentialControl::CmdlineSmartCardPrompt()
/*++

Routine Description:

    Command line code to select a smartcard from the list of ones available.

    Post a WM_QUIT message to terminate message processing.  The status of the operation
    is returned in wParam.
    UserName and Password strings set in their respective controls.

Arguments:

    None

Return Values:

    None

--*/
{
    DWORD WinStatus;

    LONG ComboBoxItemCount;
    DWORD SmartCardCount;
    DWORD ValidSmartCardCount = 0;
    DWORD InvalidSmartCardCount = 0;
    DWORD KnownGoodCard = 0;

    DWORD i;
    DWORD_PTR rgarg[2];          // at most 2 substitution arguments

    WCHAR szMsg[CREDUI_MAX_CMDLINE_MSG_LENGTH + 1];
    WCHAR UserName[CREDUI_MAX_USERNAME_LENGTH + 1];
    WCHAR Password[CREDUI_MAX_PASSWORD_LENGTH + 1];

    WCHAR SmartCardText[CREDUI_MAX_USERNAME_LENGTH + 1];
    BOOL SmartCardValid;

    CERT_ENUM *SavedCertEnum = NULL;
    DWORD SavedCertIndex = 0;
    LPWSTR ErrorString = NULL;

    //
    // Compute the number of smart card entries
    //

    ComboBoxItemCount = (LONG) SendMessage(UserNameControlWindow, CB_GETCOUNT, 0, 0);

    if ( ComboBoxItemCount == CB_ERR ||
         ComboBoxItemCount <= SmartCardBaseInComboBox ) {

        // Didn't find any smart card readers
        szMsg[0] = 0;
        FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                    CreduiInstance,
                    IDS_CHOOSE_A_CERT,
                    0,
                    szMsg,
                    CREDUI_MAX_CMDLINE_MSG_LENGTH,
                    NULL);
        CredPutStdout(szMsg);
        WinStatus = ERROR_CANCELLED;
        goto Cleanup;
    }

    SmartCardCount = ComboBoxItemCount - SmartCardBaseInComboBox;


    //
    // Get a count of the number of valid and invalid smartcards
    //

    for ( i=0; i<SmartCardCount; i++ ) {

        if ( !GetSmartCardInfo( i, CREDUI_MAX_USERNAME_LENGTH, SmartCardText, &SmartCardValid, NULL ) ) {
            WinStatus = ERROR_INTERNAL_ERROR;
            goto Cleanup;
        }

        if ( SmartCardValid ) {
            ValidSmartCardCount ++;
            KnownGoodCard = i;
        } else {
            InvalidSmartCardCount ++;
        }

    }


    //
    // Get the username passed into the API
    //
    // Can't do a GetWindowText( UserNameControlWindow ) since the cert control has
    //  a non-editable window so we can't set the window text
    //

    if ( InitialUserName != NULL) {
        lstrcpyn( UserName, InitialUserName, CREDUI_MAX_USERNAME_LENGTH );
    } else {
        UserName[0] = '\0';
    }

    //
    // If the caller passed a name into the API,
    //  check to see if the name matches one of the smart cards.
    //

    if ( UserName[0] != '\0' ) {

        //
        // Find the smartcard that matches the username
        //

        ErrorString = MatchSmartCard(
                             SmartCardCount,
                             UserName,
                             &SavedCertIndex,
                             &SavedCertEnum );

        if ( ErrorString == NULL ) {
            WinStatus = NO_ERROR;
            goto Cleanup;
        }

    }



    //
    // Report any errors to the user
    //

    if ( InvalidSmartCardCount ) {

        szMsg[0] = 0;
        FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                    CreduiInstance,
                    IDS_CMDLINE_ERRORS,
                    0,
                    szMsg,
                    CREDUI_MAX_CMDLINE_MSG_LENGTH,
                    NULL);
        CredPutStdout(szMsg);

        for ( i=0; i<SmartCardCount; i++ ) {

            if ( !GetSmartCardInfo( i, CREDUI_MAX_USERNAME_LENGTH, SmartCardText, &SmartCardValid, NULL ) ) {
                WinStatus = ERROR_INTERNAL_ERROR;
                goto Cleanup;
            }

            if ( !SmartCardValid ) {
                // GetSmartCardInfo() fills SmartCardText, which may include user's name
                CredPutStdout( SmartCardText );
                //swprintf(szMsg,CreduiStrings.CmdLineError,i+1);
                szMsg[0] = 0;
                INT j = i+1;
                FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                            Instance,
                            IDS_CMDLINE_ERROR,
                            0,
                            szMsg,
                            CREDUI_MAX_CMDLINE_MSG_LENGTH,
                            (va_list *) &j);
                CredPutStdout( szMsg);
            }

        }
        CredPutStdout( L"\n" );

    }

    //
    // If the caller passed a name into the API,
    //  simply report that we couldn't find the cert and return
    //

    if ( UserName[0] != '\0' ) {

        // ErrorString is expected to be NoMatch or ManyMatch
        //_snwprintf(szMsg,
        //      CREDUI_MAX_CMDLINE_MSG_LENGTH,
        //      ErrorString,
        //      UserName);
        //      szMsg[0] = 0;
        //szMsg[CREDUI_MAX_CMDLINE_MSG_LENGTH] = L'\0';
        szMsg[0] = 0;
        // Note that ErrorString returned from MatchSmartCard has type LPWSTR, but it is actually
        //  a message ID.  We take the low word of the pointer as the ID.
        FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                    CreduiInstance,
                    LOWORD(ErrorString),
                    0,
                    szMsg,
                    CREDUI_MAX_CMDLINE_MSG_LENGTH,
                    (va_list *) UserName);

        CredPutStdout( szMsg );
        WinStatus = ERROR_CANCELLED;
        goto Cleanup;

    }

    //
    // If there was only one smartcard and it was valid,
    //  use it
    //

    // if ( ValidSmartCardCount == 1 && InvalidSmartCardCount == 0 ) {
    // gm: If list can only contain one item, use it.
    if ( ValidSmartCardCount == 1 ) {

        if ( !GetSmartCardInfo( KnownGoodCard, CREDUI_MAX_USERNAME_LENGTH, SmartCardText, &SmartCardValid, &SavedCertEnum ) ) {
            WinStatus = ERROR_INTERNAL_ERROR;
            goto Cleanup;
        }

        SavedCertIndex = KnownGoodCard;
        WinStatus = NO_ERROR;
        goto Cleanup;

    //
    // If there were valid smartcard,
    //  List the valid smartcards for the user
    //

    } else if ( ValidSmartCardCount ) {

        //
        // Tell user about all certs
        //

        szMsg[0] = 0;
        FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                    CreduiInstance,
                    IDS_CHOOSE_A_CERT,
                    0,
                    szMsg,
                    CREDUI_MAX_CMDLINE_MSG_LENGTH,
                    NULL);
        CredPutStdout(szMsg);

        for ( i=0; i<SmartCardCount; i++ ) {

            if ( !GetSmartCardInfo( i, CREDUI_MAX_USERNAME_LENGTH, SmartCardText, &SmartCardValid, NULL ) ) {
                WinStatus = ERROR_INTERNAL_ERROR;
                goto Cleanup;
            }

            if ( SmartCardValid ) {
                //swprintf(szMsg,CreduiStrings.CmdLinePreamble,i+1,SmartCardText);
                szMsg[0] = 0;
                rgarg[0] = i+1;
                rgarg[1] = (DWORD_PTR) SmartCardText;
                
                FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                            Instance,
                            IDS_CMDLINE_PREAMBLE,
                            0,
                            szMsg,
                            CREDUI_MAX_CMDLINE_MSG_LENGTH,
                            (va_list *) &rgarg);
                CredPutStdout( szMsg );
            }

        }
        CredPutStdout( L"\n" );

        //
        // Ask user to enter the reader number of one of the smartcards
        //

        //_snwprintf(szMsg,
        //     CREDUI_MAX_CMDLINE_MSG_LENGTH,
        //      CreduiStrings.SCardPrompt,
        //      TargetName);
        //szMsg[CREDUI_MAX_CMDLINE_MSG_LENGTH] = L'\0';
        szMsg[0] = 0;
        rgarg[0] = (DWORD_PTR)TargetName;
        rgarg[1] = 0;
        FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                    Instance,
                    IDS_SCARD_PROMPT,
                    0,
                    szMsg,
                    CREDUI_MAX_CMDLINE_MSG_LENGTH,
                    (va_list *) rgarg);
        CredPutStdout( szMsg );

        CredGetStdin( UserName, CREDUI_MAX_USERNAME_LENGTH, TRUE );

        if ( wcslen (UserName ) == 0 ) {
            szMsg[0] = 0;
            FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                        CreduiInstance,
                        IDS_NO_SCARD_ENTERED ,
                        0,
                        szMsg,
                        CREDUI_MAX_CMDLINE_MSG_LENGTH,
                        NULL);
            CredPutStdout(szMsg);
            WinStatus = ERROR_CANCELLED;
            goto Cleanup;
        }

        //
        // Find the smartcard that matches the username
        //
        INT iWhich = 0;
        WCHAR *pc = NULL;
        
        iWhich = wcstol(UserName,&pc,10);
        if (pc == UserName) {
            // Invalid if at least one char was not numeric
            szMsg[0] = 0;
            FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                        CreduiInstance,
                        IDS_READERINVALID,
                        0,
                        szMsg,
                        CREDUI_MAX_CMDLINE_MSG_LENGTH,
                        NULL);
            CredPutStdout(szMsg);
            WinStatus = ERROR_CANCELLED;
            goto Cleanup;
        }
        // convert 1 based UI number to 0 based internal index
        if (iWhich > 0) iWhich -= 1;
        if ( !GetSmartCardInfo( iWhich, CREDUI_MAX_USERNAME_LENGTH, SmartCardText, &SmartCardValid, &SavedCertEnum ) ) {
            // Invalid if that indexed card did not read correctly
                szMsg[0] = 0;
                FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                            CreduiInstance,
                            IDS_READERINVALID,
                            0,
                            szMsg,
                            CREDUI_MAX_CMDLINE_MSG_LENGTH,
                            NULL);
                CredPutStdout(szMsg);
            WinStatus = ERROR_CANCELLED;
            goto Cleanup;
        }

        // At this point, a valid number was entered, and an attempt to read the card made
        // GetSmartCardInfo() returned OK, but SmartCardValid may still be false
        if (!SmartCardValid)
        {
                szMsg[0] = 0;
                FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                            CreduiInstance,
                            IDS_READERINVALID,
                            0,
                            szMsg,
                            CREDUI_MAX_CMDLINE_MSG_LENGTH,
                            NULL);
                CredPutStdout(szMsg);
            WinStatus = ERROR_CANCELLED;
            goto Cleanup;
        }
        else
        {
            SavedCertIndex = iWhich;
            WinStatus = NO_ERROR;
            goto Cleanup;
        }
    }

    WinStatus = ERROR_CANCELLED;


    //
    // Complete the operation.
    //
    //  WinStatus is the status of the operation so far
    //  if NO_ERROR, SavedCertEnum is the description of the cert to use, and
    //               SavedCertIndex is the index to the selected cert.
    //
Cleanup:


    if ( WinStatus == NO_ERROR) {

        if ( CredUIMarshallNode ( SavedCertEnum, UserName ) ) {

            //
            // Save the username
            //

            UserNameSelection = SmartCardBaseInComboBox + SavedCertIndex;
            IsChangingUserName = TRUE;
            SendMessage(UserNameControlWindow,
                        CB_SETCURSEL,
                        UserNameSelection,
                        0);
            IsChangingUserName = FALSE;



            //
            // Prompt for the pin
            //

            //CredPutStdout( CreduiStrings.PinPrompt );
            //swprintf(szMsg,CreduiStrings.CmdLineThisCard,SavedCertIndex + 1);
            szMsg[0] = 0;
            i = SavedCertIndex + 1;
            FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                        Instance,
                        IDS_CMDLINE_THISCARD,
                        0,
                        szMsg,
                        CREDUI_MAX_CMDLINE_MSG_LENGTH,
                        (va_list *) &i);
            CredPutStdout(szMsg);

            CredGetStdin( Password, CREDUI_MAX_PASSWORD_LENGTH, FALSE );

            //
            // Save the pin
            //

            if  (!OnSetPassword( Password ) ) {
                WinStatus = GetLastError();

                CreduiDebugLog("CreduiCredentialControl::CmdlineSmartCardPrompt: "
                               "OnSetPassword failed: %u\n",
                               WinStatus );
            }


            //
            // Prompt whether the save the cred or not
            //

            CmdlineSavePrompt();


        } else {
            WinStatus = GetLastError();

            CreduiDebugLog("CreduiCredentialControl::CmdlineSmartCardPrompt: "
                           "CredMarshalCredential failed: %u\n",
                           WinStatus );
        }

    }

    //
    // Tell our parent window that we're done prompting
    //

    PostQuitMessage( WinStatus );

    return;
}


void CreduiCredentialControl::CmdlineSavePrompt()
/*++

Routine Description:

    Command line code to prompt for saving the credential

Arguments:

    None

Return Values:

    None

--*/
{
    WCHAR szMsg[CREDUI_MAX_CMDLINE_MSG_LENGTH + 1];
    WCHAR szY[CREDUI_MAX_CMDLINE_MSG_LENGTH + 1];
    WCHAR szN[CREDUI_MAX_CMDLINE_MSG_LENGTH + 1];

    //
    // Only prompt if we've been asked to display the checkbox
    //

    while ( Style & CRS_SAVECHECK ) {
        WCHAR szMsg[CREDUI_MAX_CMDLINE_MSG_LENGTH+1];

            // Fetch the strings one by one from the messages, and cobble them together
            WCHAR *rgsz[2];
            szY[0] = 0;
            szN[0] = 0;
            rgsz[0] = szY;
            rgsz[1] = szN;
            szMsg[0] = 0;
            // Fetch yes and no strings
            FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                        CreduiInstance,
                        IDS_YES_TEXT,
                        0,
                        szY,
                        CREDUI_MAX_CMDLINE_MSG_LENGTH,
                        NULL);
            FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                        CreduiInstance,
                        IDS_NO_TEXT,
                        0,
                        szN,
                        CREDUI_MAX_CMDLINE_MSG_LENGTH,
                        NULL);
            // Arg substitute them into the prompt
            FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                        CreduiInstance,
                        IDS_SAVE_PROMPT,
                        0,
                        szMsg,
                        CREDUI_MAX_CMDLINE_MSG_LENGTH,
                        (va_list *) rgsz);

        szMsg[CREDUI_MAX_CMDLINE_MSG_LENGTH] = L'\0';
        CredPutStdout( szMsg );

        CredGetStdin( szMsg, CREDUI_MAX_CMDLINE_MSG_LENGTH, TRUE );

//        if ( toupper(szMsg[0]) == toupper(CreduiStrings.YesText[0]) ) {
        if ( toupper(szMsg[0]) == toupper(szY[0]) ) {
            Credential_CheckSave( Window, TRUE );
            break;
//        } else if ( toupper(szMsg[0]) == toupper(CreduiStrings.NoText[0]) ) {
        } else if ( toupper(szMsg[0]) == toupper(szN[0]) ) {
            Credential_CheckSave( Window, FALSE );
            break;
        }

    }
}

UINT CreduiCredentialControl::MapID(UINT uiID) {
   switch(uiID) {

   case IDC_USERNAME:
       return IDH_USERNAMEEDIT;
   case IDC_PASSWORD:
       return IDH_PASSWORDEDIT;
   case IDC_SAVE:
       return IDH_SAVECHECKBOX;
   default:
       return IDS_NOHELP;
   }
}



BOOL
CreduiCredentialControl::OnHelpInfo(LPARAM lp) {

    HELPINFO* pH;
    INT iMapped;
    pH = (HELPINFO *) lp;
    HH_POPUP stPopUp;
    RECT rcW;
    UINT gID;

    gID = pH->iCtrlId;
    iMapped = MapID(gID);
    
    if (iMapped == 0) return TRUE;
    
    if (IDS_NOHELP != iMapped) {

      memset(&stPopUp,0,sizeof(stPopUp));
      stPopUp.cbStruct = sizeof(HH_POPUP);
      stPopUp.hinst = Instance;
      stPopUp.idString = iMapped;
      stPopUp.pszText = NULL;
      stPopUp.clrForeground = -1;
      stPopUp.clrBackground = -1;
      stPopUp.rcMargins.top = -1;
      stPopUp.rcMargins.bottom = -1;
      stPopUp.rcMargins.left = -1;
      stPopUp.rcMargins.right = -1;
      stPopUp.pszFont = NULL;
      if (GetWindowRect((HWND)pH->hItemHandle,&rcW)) {
          stPopUp.pt.x = (rcW.left + rcW.right) / 2;
          stPopUp.pt.y = (rcW.top + rcW.bottom) / 2;
      }
      else stPopUp.pt = pH->MousePos;
      HtmlHelp((HWND) pH->hItemHandle,NULL,HH_DISPLAY_TEXT_POPUP,(DWORD_PTR) &stPopUp);
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\credui\api.cpp ===
//=============================================================================
// Copyright (c) 2000 Microsoft Corporation
//
// api.cpp
//
// Win32 API function implementation and the DLL entry function.
//
// Created 02/29/2000 johnstep (John Stephens)
//=============================================================================

#include "precomp.hpp"
#include "dialogs.hpp"
#include "resource.h"
//#include "utils.hpp"

//-----------------------------------------------------------------------------
// Global Variables
//-----------------------------------------------------------------------------

HMODULE CreduiInstance = NULL;
ULONG CreduiComReferenceCount = 0;

BOOL CreduiIsPersonal = FALSE;
BOOL CreduiIsDomainController = FALSE;
BOOL CreduiIsSafeMode = FALSE;

CREDUI_STRINGS CreduiStrings;

UINT CreduiScarduiWmReaderArrival = 0;
UINT CreduiScarduiWmReaderRemoval = 0;
UINT CreduiScarduiWmCardInsertion = 0;
UINT CreduiScarduiWmCardRemoval = 0;
UINT CreduiScarduiWmCardCertAvail = 0;
UINT CreduiScarduiWmCardStatus = 0;

BOOL CreduiHasSmartCardSupport = FALSE;

static LONG CreduiFirstTime = TRUE;
static HANDLE CreduiInitEvent = NULL;

BOOL  gbWaitingForSSOCreds = FALSE;
WCHAR gszSSOUserName[CREDUI_MAX_USERNAME_LENGTH];
WCHAR gszSSOPassword[CREDUI_MAX_PASSWORD_LENGTH];
BOOL gbStoredSSOCreds = FALSE;

//-----------------------------------------------------------------------------
// Functions
//-----------------------------------------------------------------------------

//=============================================================================
// CreduiInitStringTable
//
// This function loads all the string resources into the global string table.
// It only needs to be called once per process.
//
// Return TRUE if the string table was successfully initialized or FALSE
// otherwise.
//
// Created 03/26/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiInitStringTable()
{
#define CREDUI_STRING(id, name) {\
    id, CreduiStrings.##name, (sizeof CreduiStrings.##name) / (sizeof WCHAR)\
}

    static struct
    {
        UINT Id;
        WCHAR *String;
        ULONG Length;
    } stringInfo[] = {
        // Static labels for controls
        CREDUI_STRING(IDS_USERNAME_STATIC, UserNameStatic),
        CREDUI_STRING(IDS_PASSWORD_STATIC, PasswordStatic),
        CREDUI_STRING(IDS_CERTIFICATE_STATIC, CertificateStatic),
        CREDUI_STRING(IDS_PIN_STATIC, PinStatic),
        CREDUI_STRING(IDS_CARD_STATIC, SmartCardStatic),
        // Caption strings
        CREDUI_STRING(IDS_DNS_CAPTION, DnsCaption),
        CREDUI_STRING(IDS_NETBIOS_CAPTION, NetbiosCaption),
        CREDUI_STRING(IDS_GENERIC_CAPTION, GenericCaption),
        CREDUI_STRING(IDS_WELCOME, Welcome),
        CREDUI_STRING(IDS_WELCOME_BACK, WelcomeBack),
        CREDUI_STRING(IDS_CONNECTING, Connecting),
        CREDUI_STRING(IDS_LOOKUP_NAME, LookupName),
        CREDUI_STRING(IDS_CARD_ERROR, CardError),
        CREDUI_STRING(IDS_SAVE, Save),
        CREDUI_STRING(IDS_PASSPORT_SAVE, PassportSave ),
        CREDUI_STRING(IDS_EMAIL_NAME, EmailName ),
        // Tooltip strings
        CREDUI_STRING(IDS_USERNAME_TIP_TITLE, UserNameTipTitle),
        CREDUI_STRING(IDS_USERNAME_TIP_TEXT, UserNameTipText),
        CREDUI_STRING(IDS_PASSWORD_TIP_TITLE, PasswordTipTitle),
        CREDUI_STRING(IDS_PASSWORD_TIP_TEXT, PasswordTipText),
        CREDUI_STRING(IDS_CAPSLOCK_TIP_TITLE, CapsLockTipTitle),
        CREDUI_STRING(IDS_CAPSLOCK_TIP_TEXT, CapsLockTipText),
        CREDUI_STRING(IDS_LOGON_TIP_TITLE, LogonTipTitle),
        CREDUI_STRING(IDS_LOGON_TIP_TEXT, LogonTipText),
        CREDUI_STRING(IDS_LOGON_TIP_CAPS, LogonTipCaps),
        CREDUI_STRING(IDS_BACKWARDS_TIP_TITLE, BackwardsTipTitle),
        CREDUI_STRING(IDS_BACKWARDS_TIP_TEXT, BackwardsTipText),
        CREDUI_STRING(IDS_WRONG_OLD_TIP_TITLE, WrongOldTipTitle),
        CREDUI_STRING(IDS_WRONG_OLD_TIP_TEXT, WrongOldTipText),
        CREDUI_STRING(IDS_NOT_SAME_TIP_TITLE, NotSameTipTitle),
        CREDUI_STRING(IDS_NOT_SAME_TIP_TEXT, NotSameTipText),
        CREDUI_STRING(IDS_TOO_SHORT_TIP_TITLE, TooShortTipTitle),
        CREDUI_STRING(IDS_TOO_SHORT_TIP_TEXT, TooShortTipText),
        CREDUI_STRING(IDS_DOWNGRADE_TIP_TEXT, DowngradeTipText),
        CREDUI_STRING(IDS_EMAILNAME_TIP_TITLE, EmailNameTipTitle),
        CREDUI_STRING(IDS_EMAILNAME_TIP_TEXT, EmailNameTipText),
        // strings that can appear in GUI or be copied from GUI and presented on cmdline
        CREDUI_STRING(IDS_CMDLINE_NOCARD,NoCard),               
        CREDUI_STRING(IDS_EMPTY_READER, EmptyReader),
        CREDUI_STRING(IDS_READING_CARD, ReadingCard),          
        CREDUI_STRING(IDS_CERTIFICATE, Certificate),
        CREDUI_STRING(IDS_EMPTY_CARD, EmptyCard),             
        CREDUI_STRING(IDS_UNKNOWN_CARD, UnknownCard),          
        CREDUI_STRING(IDS_BACKWARDS_CARD, BackwardsCard)
    };

#undef CREDUI_STRING

    for (UINT i = 0; i < (sizeof stringInfo) / (sizeof stringInfo[0]); ++i)
    {
        // Read all strings into string array from resources of application
        // Some strings which are GUI-only taken from resources
        // Strings that are may be output to cmdline are taken from MC file, which also
        //  permits more flexible argument substitution during localization
        if (stringInfo[i].Id >= 2500)
        {
            stringInfo[i].String[0] = 0;
            FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                        CreduiInstance,
                        stringInfo[i].Id,
                        0,
                        stringInfo[i].String,
                        stringInfo[i].Length - 1,
                        NULL);
        }
        else if (!LoadString(CreduiInstance,
                        stringInfo[i].Id,
                        stringInfo[i].String,
                        stringInfo[i].Length))
        {
            CreduiDebugLog("CreduiInitStringTable: Load string %u failed\n",
                           stringInfo[i].Id);
            return FALSE;
        }
    }

    return TRUE;
}

//=============================================================================
// CreduiInitSmartCardWindowMessages
//
// Return TRUE on success or FALSE otherwise.
//
// Created 03/26/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiInitSmartCardWindowMessages()
{
    struct
    {
        UINT *message;
        CHAR *string;
    } messageInfo[] = {
        &CreduiScarduiWmReaderArrival, SCARDUI_READER_ARRIVAL,
        &CreduiScarduiWmReaderRemoval, SCARDUI_READER_REMOVAL,
        &CreduiScarduiWmCardInsertion, SCARDUI_SMART_CARD_INSERTION,
        &CreduiScarduiWmCardRemoval, SCARDUI_SMART_CARD_REMOVAL,
        &CreduiScarduiWmCardCertAvail, SCARDUI_SMART_CARD_CERT_AVAIL,
        &CreduiScarduiWmCardStatus, SCARDUI_SMART_CARD_STATUS
    };

    for (UINT i = 0; i < (sizeof messageInfo) / (sizeof messageInfo[0]); ++i)
    {
        *messageInfo[i].message =
            RegisterWindowMessageA(messageInfo[i].string);

        if (*messageInfo[i].message == 0)
        {
            return FALSE;
        }
    }

    return TRUE;
}

//=============================================================================
// CreduiApiInit
//
// This function is called at API entry points to ensure the common controls
// we need are initialized. Currently, the only initialization done is only
// needed once per process, but this macro will handle per thread
// initialization in the future, if necessary:
//
// Returns TRUE on success or FALSE otherwise.
//
// Created 03/10/2000 johnstep (John Stephens)
//=============================================================================

static
BOOL
CreduiApiInit()
{
    // First time initialization:

    ASSERT(CreduiInitEvent != NULL);

    if (InterlockedCompareExchange(&CreduiFirstTime, FALSE, TRUE))
    {
        INITCOMMONCONTROLSEX init;
        init.dwSize = sizeof init;
        init.dwICC = ICC_USEREX_CLASSES;

        if (!InitCommonControlsEx(&init))
        {
            return FALSE;
        }

        // Check for Personal SKU:

        OSVERSIONINFOEXW versionInfo;

        versionInfo.dwOSVersionInfoSize = sizeof OSVERSIONINFOEXW;

        if (GetVersionEx(reinterpret_cast<OSVERSIONINFOW *>(&versionInfo)))
        {
            CreduiIsPersonal =
                (versionInfo.wProductType == VER_NT_WORKSTATION) &&
                (versionInfo.wSuiteMask & VER_SUITE_PERSONAL);
            CreduiIsDomainController =
                (versionInfo.wProductType == VER_NT_DOMAIN_CONTROLLER);
        }

        // Check for safe mode:

        HKEY key;

        if (RegOpenKeyEx(
               HKEY_LOCAL_MACHINE,
               L"SYSTEM\\CurrentControlSet\\Control\\SafeBoot\\Option",
               0,
               KEY_READ,
               &key) == ERROR_SUCCESS)
        {
            if (RegQueryValueEx(
                    key,
                    L"OptionValue",
                    NULL,
                    NULL,
                    NULL,
                    NULL) == ERROR_SUCCESS)
            {
                CreduiIsSafeMode = TRUE;
            }

            RegCloseKey(key);
        }

        // Do other initialization:

        InitializeCredMgr();
        if (!CreduiInitStringTable())
        {
            return FALSE;
        }

        CreduiHasSmartCardSupport = CreduiInitSmartCardWindowMessages();

        CreduiIconParentWindow::Register(CreduiInstance);

        SetEvent(CreduiInitEvent);
    }
    else
    {
        WaitForSingleObject(CreduiInitEvent, INFINITE);
    }

    return TRUE;
}

//=============================================================================
// CreduiValidateUiInfo
//
// This function validates the CREDUI_INFO structure passed in. A NULL value
// is acceptable, and impies defaults.
//
// CredValidateUiInfoW for wide
// CredValidateUiInfoA for ANSI
//
// Arguments:
//   uiInfo (in) - structure to validate
//
// Returns TRUE if the structure is valid, or FALSE otherwise.
//
// Created 03/25/2000 johnstep (John Stephens)
//=============================================================================

static
BOOL
CreduiValidateUiInfoW(
    CREDUI_INFOW *uiInfo
    )
{
   
    if (uiInfo != NULL)
    {
    	if (uiInfo->cbSize != sizeof(*uiInfo) )  
        {
            return FALSE;
        }

        if ((uiInfo->hbmBanner != NULL) &&
            (GetObjectType(uiInfo->hbmBanner) != OBJ_BITMAP))
        {
            return FALSE;
        }

        if ((uiInfo->pszMessageText != NULL) &&
            (lstrlenW(uiInfo->pszMessageText) > CREDUI_MAX_MESSAGE_LENGTH))
        {
            return FALSE;
        }


        if ((uiInfo->pszCaptionText != NULL) &&
            (lstrlenW(uiInfo->pszCaptionText) > CREDUI_MAX_CAPTION_LENGTH))
        {
            return FALSE;
        }

    }

    return TRUE;
}

//=============================================================================
// CreduiConvertUiInfoToWide
//
// This function converts a CREDUI_INFOA structure to CREDUI_INFOW. On
// success,The caller is responsible for freeing pszMessageText and
// pszCaptionText via the delete [] operator.
//
// Arguments:
//   uiInfoA (in) - structure to convert
//   uiInfoW (out) - storage for converted structure. The pszMessageText and
//                   pszCaptionText will be set to NULL on failure or valid
//                   pointers (unless the in pointer is NULL) on success,
//                   allocated via the new [] operator.
//
// Returns TRUE if the structure is valid, or FALSE otherwise.
//
// Created 03/26/2000 johnstep (John Stephens)
//=============================================================================

static
BOOL
CreduiConvertUiInfoToWide(
    CREDUI_INFOA *uiInfoA,
    CREDUI_INFOW *uiInfoW
    )
{
    uiInfoW->cbSize = uiInfoA->cbSize;
    uiInfoW->hwndParent = uiInfoA->hwndParent;
    uiInfoW->pszMessageText = NULL;
    uiInfoW->pszCaptionText = NULL;
    uiInfoW->hbmBanner = uiInfoA->hbmBanner;

    if (uiInfoA->pszMessageText != NULL)
    {
        uiInfoW->pszMessageText =
            new WCHAR[lstrlenA(uiInfoA->pszMessageText) + 1];

        if (uiInfoW->pszMessageText == NULL)
        {
            goto ErrorExit;
        }

        if (MultiByteToWideChar(
                CP_ACP, 0, uiInfoA->pszMessageText, -1,
                const_cast<WCHAR *>(uiInfoW->pszMessageText),
                CREDUI_MAX_MESSAGE_LENGTH + 1) == 0)
        {
            goto ErrorExit;
        }
    }
    else
    {
        uiInfoW->pszMessageText = NULL;
    }

    if (uiInfoA->pszCaptionText != NULL)
    {
        uiInfoW->pszCaptionText =
            new WCHAR[lstrlenA(uiInfoA->pszCaptionText) + 1];

        if (uiInfoW->pszCaptionText == NULL)
        {
            goto ErrorExit;
        }

        if (MultiByteToWideChar(
                CP_ACP, 0, uiInfoA->pszCaptionText, -1,
                const_cast<WCHAR *>(uiInfoW->pszCaptionText),
                CREDUI_MAX_CAPTION_LENGTH + 1) == 0)
        {
            goto ErrorExit;
        }
    }
    else
    {
        uiInfoW->pszCaptionText = NULL;
    }

    return TRUE;

ErrorExit:

    if (uiInfoW->pszCaptionText != NULL)
    {
        delete [] const_cast<WCHAR *>(uiInfoW->pszCaptionText);
        uiInfoW->pszCaptionText = NULL;
    }

    if (uiInfoW->pszMessageText != NULL)
    {
        delete [] const_cast<WCHAR *>(uiInfoW->pszMessageText);
        uiInfoW->pszMessageText = NULL;
    }

    return FALSE;
}



//=============================================================================
// CredUIPromptForCredentials
//
// Presents a user interface to get credentials from an application.
//
// CredUIPromptForCredentialsW for wide
// CredUIPromptForCredentialsA for ANSI
//
// Arguments:
//   uiInfo (in,optional)
//   targetName (in) - if specified, securityContext must be NULL
//   securityContext (in) - if specified, targetName must be NULL
//   error (in) - the authentication error
//   userName (in,out)
//   userNameBufferSize (in) - maximum length of userName
//   password (in,out)
//   passwordBufferSize (in) - maximum length of password
//   save (in/out) - TRUE if save check box was checked
//   flags (in)
//
// Returns:
//   ERROR_SUCCESS
//   ERROR_CANCELLED
//   ERROR_NO_SUCH_LOGON_SESSION - if credential manager cannot be used
//   ERROR_GEN_FAILURE
//   ERROR_INVALID_FLAGS
//   ERROR_INVALID_PARAMETER
//   ERROR_OUTOFMEMORY
//
// Created 10/17/2000 johnhaw

DWORD
CredUIPromptForCredentialsWorker(
    IN BOOL doingCommandLine,
    CREDUI_INFOW *uiInfo,
    CONST WCHAR *targetName,
    CtxtHandle *securityContext,
    DWORD authError,
    PWSTR pszUserName,
    ULONG ulUserNameBufferSize,
    PWSTR pszPassword,
    ULONG ulPasswordBufferSize,
    BOOL *save,
    DWORD flags
    )
/*++

Routine Description:

    This routine implements the GUI and command line prompt for credentials.

Arguments:

    DoingCommandLine - TRUE if prompting is to be done via the command line
        FALSE if prompting is to be done via GUI

    ... - Other parameters are the same a CredUIPromptForCredentials API

Return Values:

    Same as CredUIPromptForCredentials.

--*/
{
    ULONG CertFlags;
    ULONG CredCategory;
    ULONG PersistFlags;

    CreduiDebugLog("CUIPFCWorker: Flags: %x, Target: %S doingCommandLine: %i\n", flags, targetName, doingCommandLine);
    
    if ((NULL == pszUserName) || (NULL == pszPassword))
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (!CreduiApiInit())
    {
        return ERROR_GEN_FAILURE;
    }

    // Validate arguments:
    if ((flags & ~CREDUI_FLAGS_PROMPT_VALID) != 0)
    {
        CreduiDebugLog("CreduiPromptForCredentials: flags not valid %lx.\n", flags );
        return ERROR_INVALID_FLAGS;
    }

    //
    // Ensure there is is only one bit defining cert support
    //
    CertFlags = flags & (CREDUI_FLAGS_REQUIRE_SMARTCARD|CREDUI_FLAGS_REQUIRE_CERTIFICATE|CREDUI_FLAGS_EXCLUDE_CERTIFICATES);

    if ( CertFlags != 0 && !JUST_ONE_BIT(CertFlags) ) {
        CreduiDebugLog("CreduiPromptForCredentials: require smartcard, require certificate, and exclude certificates are mutually exclusive %lx.\n", flags );
        return ERROR_INVALID_FLAGS;
    }

    //
    // For the command line version,
    //  limit cert support further.
    //

    if ( doingCommandLine ) {
        if ( CertFlags == 0 ||
             (CertFlags & CREDUI_FLAGS_REQUIRE_CERTIFICATE) != 0 ) {
            CreduiDebugLog("CreduiPromptForCredentials: need either require smartcard or exclude certificates for command line %lx.\n", flags );
            return ERROR_INVALID_FLAGS;
        }
    }

    //
    // Ensure there is only one bit defining the credential category

    CredCategory = flags & (CREDUI_FLAGS_GENERIC_CREDENTIALS|CREDUI_FLAGS_USERNAME_TARGET_CREDENTIALS);

    if ( CredCategory != 0 && !JUST_ONE_BIT(CredCategory) ) {
        CreduiDebugLog("CreduiPromptForCredentials: generic creds and username target are mutually exclusive %lx.\n", flags );
        return ERROR_INVALID_FLAGS;
    }

    //
    // Ensure there is only one bit set saying whether the cred is to persist or not
    //

    PersistFlags = flags & (CREDUI_FLAGS_DO_NOT_PERSIST|CREDUI_FLAGS_PERSIST);

    if ( PersistFlags != 0 && !JUST_ONE_BIT(PersistFlags) ) {
        CreduiDebugLog("CreduiPromptForCredentials: DoNotPersist and Persist are mutually exclusive %lx.\n", flags );
        return ERROR_INVALID_FLAGS;
    }

    //
    // Ensure AlwaysShowUi is only specified for generic credentials
    //

    if ( flags & CREDUI_FLAGS_ALWAYS_SHOW_UI ) {
        if ( (flags & CREDUI_FLAGS_GENERIC_CREDENTIALS) == 0) {
            CreduiDebugLog("CreduiPromptForCredentials: AlwaysShowUi is only supported for generic credentials %lx.\n", flags );
            return ERROR_INVALID_FLAGS;
        }
    }

    //
    // Don't support a half-implemented feature
    //

    if ( securityContext != NULL ) {
        CreduiDebugLog("CreduiPromptForCredentials: securityContext must be null.\n" );
        return ERROR_INVALID_PARAMETER;
    }


    //
    // Validate the passed in UI info
    //

    if (!CreduiValidateUiInfoW(uiInfo))
    {
        CreduiDebugLog("CreduiPromptForCredentials: UI info is invalid.\n" );
        return ERROR_INVALID_PARAMETER;
    }



    //
    // Ensure there are strings defined for the caption
    //

    if (flags & CREDUI_FLAGS_DO_NOT_PERSIST)
    {
        if ((targetName == NULL) &&
            ((uiInfo == NULL) ||
             (uiInfo->pszMessageText == NULL) ||
             (uiInfo->pszCaptionText == NULL)))
        {
            CreduiDebugLog("CreduiPromptForCredentials: DoNotPersist and target data empty.\n" );
            return ERROR_INVALID_PARAMETER;
        }

    }
    else if (targetName != NULL)
    {
        if ((securityContext != NULL) ||
            (targetName[0] == L'\0') ||
            (lstrlen(targetName) > CREDUI_MAX_DOMAIN_TARGET_LENGTH))
        {
            CreduiDebugLog("CreduiPromptForCredentials: target name bad %ws.\n", targetName );
            return ERROR_INVALID_PARAMETER;
        }
    }
    else if (securityContext == NULL)
    {
        CreduiDebugLog("CreduiPromptForCredentials: no target data.\n" );
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Ensure the caller supplied the default value for the save check box
    //
    if (flags & CREDUI_FLAGS_SHOW_SAVE_CHECK_BOX)
    {
        if (save == NULL)
        {
            CreduiDebugLog("CreduiPromptForCredentials: ShowSaveCheckbox and save is NULL.\n" );
            return ERROR_INVALID_PARAMETER;
        }
    }

    //
    // Ensure the user supplied a username if they set CREDUI_FLAGS_KEEP_USERNAME
    //
    if ( flags & CREDUI_FLAGS_KEEP_USERNAME )
    {
        if ( pszUserName == NULL )
        {
            CreduiDebugLog("CreduiPromptForCredentials: CREDUI_FLAGS_KEEP_USERNAME and pszUserName is NULL.\n" );
            return ERROR_INVALID_PARAMETER;
        }

    }

    // Use the stack for user name and password:

    WCHAR userName[CREDUI_MAX_USERNAME_LENGTH + 1];
    WCHAR password[CREDUI_MAX_PASSWORD_LENGTH + 1];

    ZeroMemory(userName, sizeof(userName));
    ZeroMemory(password, sizeof(password));

    if ( pszUserName != NULL && wcslen(pszUserName) > 0 )
    {
        wcscpy ( userName, pszUserName );
    }

    if ( pszPassword != NULL && wcslen(pszPassword) > 0)
    {
        wcscpy ( password, pszPassword );
    }

    // Do the password dialog box:
    //
    //  Delay actually writing the credential to cred man if we're returning
    //  the credential to the caller.
    //  Otherwise, the CredWrite is just harvesting credentials for the next caller.
    //  So delay the CredWrite until this caller confirms the validity.
    //


    DWORD result = ERROR_OUTOFMEMORY;

    CreduiPasswordDialog* pDlg = new CreduiPasswordDialog(
        doingCommandLine,
        (pszUserName != NULL && pszPassword != NULL ),
        CredCategory,
        uiInfo,
        targetName,
        userName,
        sizeof(userName)/sizeof(WCHAR)-sizeof(WCHAR),   // Pass MaxChars instead of buffer size
        password,
        sizeof(password)/sizeof(WCHAR)-sizeof(WCHAR),   // Pass MaxChars instead of buffer size
        save,
        flags,
        (flags & CREDUI_FLAGS_GENERIC_CREDENTIALS) ? NULL : securityContext,
        authError,
        &result);

    if ( pDlg != NULL )
    {
        delete pDlg;
        pDlg = NULL;
    }
    else
    {
        // couldn't create dialog, return.
        result = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    // copy outbound username
    if ( pszUserName != NULL )
    {
        if (ulUserNameBufferSize > wcslen ( userName ) )
        {
            wcscpy ( pszUserName, userName );
        }
        else
        {
            CreduiDebugLog("CreduiPromptForCredentials: type username is too long.\n" );
            result = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }
    }

    if ( pszPassword != NULL )
    {
        if (ulPasswordBufferSize > wcslen ( password ) )
        {
            wcscpy ( pszPassword, password );
        }
        else
        {
            CreduiDebugLog("CreduiPromptForCredentials: type password is too long.\n" );
            result = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }
    }


Cleanup:
    ZeroMemory(password, sizeof(password) );


    return result;

}

//=============================================================================

CREDUIAPI
DWORD
WINAPI
CredUIPromptForCredentialsW(
    CREDUI_INFOW *uiInfo,
    CONST WCHAR *targetName,
    CtxtHandle *securityContext,
    DWORD authError,
    PWSTR pszUserName,
    ULONG ulUserNameBufferSize,
    PWSTR pszPassword,
    ULONG ulPasswordBufferSize,
    BOOL *save,
    DWORD flags
    )
{

    //
    // Call the common code indicating this is the GUI interface
    //


    return CredUIPromptForCredentialsWorker(
                FALSE,      // GUI version
                uiInfo,
                targetName,
                securityContext,
                authError,
                pszUserName,
                ulUserNameBufferSize,
                pszPassword,
                ulPasswordBufferSize,
                save,
                flags );

}

CREDUIAPI
DWORD
WINAPI
CredUIPromptForCredentialsA(
    CREDUI_INFOA *uiInfo,
    CONST CHAR *targetName,
    CtxtHandle *securityContext,
    DWORD authError,
    PSTR  pszUserName,
    ULONG ulUserNameBufferSize,
    PSTR pszPassword,
    ULONG ulPasswordBufferSize,
    BOOL *save,
    DWORD flags
    )
{
    DWORD result;
    WCHAR targetNameW[CREDUI_MAX_DOMAIN_TARGET_LENGTH + 1];

    WCHAR userName[CREDUI_MAX_USERNAME_LENGTH + 1];
    WCHAR password[CREDUI_MAX_PASSWORD_LENGTH + 1];

    CREDUI_INFOW uiInfoW = {0};

    if ((NULL == pszUserName) || (NULL == pszPassword))
    {
        result = ERROR_INVALID_PARAMETER;
        goto Exit;
    }

    // Convert in paramters to Unicode:
    // If a CREDUI_INFO structure was passed, convert it to wide now:

    if (uiInfo != NULL) {
        if (!CreduiConvertUiInfoToWide(uiInfo, &uiInfoW)) {
            result = ERROR_OUTOFMEMORY;
            goto Exit;
        }
    }


    // If a target name was passed, convert it to wide now:

    if (targetName != NULL)
    {
        if (MultiByteToWideChar(
                CP_ACP, 0, targetName, -1,
                targetNameW,
                CREDUI_MAX_DOMAIN_TARGET_LENGTH + 1) == 0)
        {
            result = ERROR_OUTOFMEMORY;
            goto Exit;
        }
    }


    userName[0] ='\0';
    password[0] = '\0';

    if (lstrlenA(pszUserName) > 0 )
    {
        if ( !MultiByteToWideChar( CP_ACP, 0, pszUserName, -1,
                userName, sizeof(userName)/sizeof(WCHAR) ) ) {

            result = ERROR_OUTOFMEMORY;
            goto Exit;
        }
    }

    if (lstrlenA(pszPassword) > 0)
    {
        if ( !MultiByteToWideChar( CP_ACP, 0, pszPassword, -1,
                password, sizeof(password)/sizeof(WCHAR) ) ) {

            result = ERROR_OUTOFMEMORY;
            goto Exit;
        }
    }

    //
    // Call the common code indicating this is the GUI interface
    //
    result = CredUIPromptForCredentialsWorker(
                FALSE,      // GUI version
                (uiInfo != NULL) ? &uiInfoW : NULL,
                (targetName != NULL) ? targetNameW : NULL,
                securityContext,
                authError,
                userName,
                ulUserNameBufferSize,
                password,
                ulPasswordBufferSize,
                save,
                flags );


    if ( result == NO_ERROR && pszUserName != NULL )
    {
        if ( wcslen(userName) < ulUserNameBufferSize )
        {
            if (!WideCharToMultiByte(CP_ACP, 0, userName, -1, pszUserName,
                                ulUserNameBufferSize, NULL, NULL) ) {
                CreduiDebugLog("CreduiPromptForCredentials: type username cannot be converted to ANSI.\n" );
                result = ERROR_INVALID_PARAMETER;
            }

        }
        else
        {
            CreduiDebugLog("CreduiPromptForCredentials: type username is too long.\n" );
            result = ERROR_INVALID_PARAMETER;
        }
    }

    if ( result == NO_ERROR && pszPassword != NULL )
    {
        if ( wcslen ( password ) < ulPasswordBufferSize )
        {
            if (!WideCharToMultiByte(CP_ACP, 0, password, -1, pszPassword,
                            ulPasswordBufferSize, NULL, NULL) ) {
                CreduiDebugLog("CreduiPromptForCredentials: type password cannot be converted to ANSI.\n" );
                result = ERROR_INVALID_PARAMETER;
            }
        }
        else
        {
            CreduiDebugLog("CreduiPromptForCredentials: type password is too long.\n" );
            result = ERROR_INVALID_PARAMETER;
        }
    }

Exit:
    ZeroMemory(password, sizeof(password) );

    // Free the CREDUI_INFO allocations:

    if (uiInfo != NULL)
    {
        if (uiInfoW.pszMessageText != NULL)
        {
            delete [] const_cast<WCHAR *>(uiInfoW.pszMessageText);
        }

        if (uiInfoW.pszCaptionText != NULL)
        {
            delete [] const_cast<WCHAR *>(uiInfoW.pszCaptionText);
        }
    }

    return result;


}



DWORD
WINAPI
CredUIParseUserNameW(
    CONST WCHAR *UserName,
    WCHAR *user,
    ULONG userBufferSize,
    WCHAR *domain,
    ULONG domainBufferSize
    )
/*++

Routine Description:

    CredUIParseUserName is used to breakup a username returned by the cred management APIs
    into a username and domain part that can be used as input to other system APIs that
    require the full broken-up user credential.

    The following formats are supported:

        @@<MarshalledCredentialReference>: This is a marshaled credential reference as
        as defined by the CredIsMarshaledCredential API.  Such a credential is returned
        in the 'user' parameter.  The 'domain' parameter is set to an empty string.


        <DomainName>\<UserName>: The <UserName> is returned in the 'user' parameter and
        the <DomainName> is returned in the 'domain' parameter. The name is considered
        to have the this syntax if the 'UserName' string contains a \.

        <UserName>@<DnsDomainName>: The entire string is returned in the 'user' parameter.
        The 'domain' parameter is set to an empty string.
        For this syntax, the last @ in the string is used since <UserName> may
        contain an @ but <DnsDomainName> cannot.

        <UserName>: The <UserName> is returned in the 'user' parameter.
        The 'domain' parameter is set to an empty string.


Arguments:

    UserName - The user name to be parsed.

    user - Specifies a buffer to copy the user name portion of the parsed string to.

    userBufferSize - Specifies the size of the 'user' array in characters.
        The caller can ensure the passed in array is large enough by using an array
        that is CRED_MAX_USERNAME_LENGTH+1 characters long or by passing in an array that
        is wcslen(UserName)+1 characters long.

    domain - Specifies a buffer to copy the domain name portion of the parsed string to.

    domainBufferSize - Specifies the size of the 'domain' array in characters.
        The caller can ensure the passed in array is large enough by using an array
        that is CRED_MAX_USERNAME_LENGTH+1 characters long or by passing in an array that
        is wcslen(UserName)+1 characters long.

Return Values:

    The following status codes may be returned:

        ERROR_INVALID_ACCOUNT_NAME - The user name is not valid.

        ERROR_INVALID_PARAMETER - One of the parameters is invalid.

        ERROR_INSUFFICIENT_BUFFER - One of the buffers is too small.


--*/
{
    DWORD Status;
    CREDUI_USERNAME_TYPE UsernameType;


    //
    // Use the low level routine to do the work
    //

    Status = CredUIParseUserNameWithType(
                    UserName,
                    user,
                    userBufferSize,
                    domain,
                    domainBufferSize,
                    &UsernameType );

    if ( Status != NO_ERROR ) {
        return Status;
    }

    //
    // Avoid relative user names (for backward compatibility)
    //

    if ( UsernameType == CreduiRelativeUsername ) {
        user[0] = L'\0';
        domain[0] = L'\0';
        return ERROR_INVALID_ACCOUNT_NAME;
    }

    return NO_ERROR;

}

DWORD
WINAPI
CredUIParseUserNameA(
    CONST CHAR *userName,
    CHAR *user,
    ULONG userBufferSize,
    CHAR *domain,
    ULONG domainBufferSize
    )
/*++

Routine Description:

    Ansi version of CredUIParseUserName.

Arguments:

    Same as wide version except userBufferSize and domainBufferSize are in terms of bytes.

Return Values:

    Same as wide version.

--*/
{
    DWORD Status;

    WCHAR LocalUserName[CRED_MAX_USERNAME_LENGTH + 1];
    WCHAR RetUserName[CRED_MAX_USERNAME_LENGTH + 1];
    WCHAR RetDomainName[CRED_MAX_USERNAME_LENGTH + 1];


    //
    // Convert the passed in username to unicode
    //

    if ( MultiByteToWideChar( CP_ACP,
                              MB_ERR_INVALID_CHARS,
                              userName,
                              -1,
                              LocalUserName,
                              CRED_MAX_USERNAME_LENGTH + 1 ) == 0 ) {


        Status = GetLastError();
        goto Cleanup;
    }

    //
    // Call the unicode version of the API
    //

    Status = CredUIParseUserNameW(
                    LocalUserName,
                    RetUserName,
                    CRED_MAX_USERNAME_LENGTH + 1,
                    RetDomainName,
                    CRED_MAX_USERNAME_LENGTH + 1 );

    if ( Status != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Convert the answers back to ANSI
    //

    if ( WideCharToMultiByte( CP_ACP,
                              0,
                              RetUserName,
                              -1,
                              user,
                              userBufferSize,
                              NULL,
                              NULL ) == 0 ) {

        Status = GetLastError();
        goto Cleanup;
    }

    if ( WideCharToMultiByte( CP_ACP,
                              0,
                              RetDomainName,
                              -1,
                              domain,
                              domainBufferSize,
                              NULL,
                              NULL ) == 0 ) {

        Status = GetLastError();
        goto Cleanup;
    }



    Status = NO_ERROR;

Cleanup:
    if ( Status != NO_ERROR ) {
        user[0] = L'\0';
        domain[0] = L'\0';
    }
    return Status;
}



////////////////////////
// Command Line functions


//=============================================================================
// CredUIInitControls
//
// Returns TRUE on success or FALSE otherwise.
//
// Created 06/21/2000 johnstep (John Stephens)
//=============================================================================

extern "C"
BOOL
WINAPI
CredUIInitControls()
{
    if (CreduiApiInit())
    {
        // Register the Credential controls:

        if (CreduiCredentialControl::Register(CreduiInstance))
        {
            return TRUE;
        }
    }

    return FALSE;
}

//=============================================================================
// DllMain
//
// The DLL entry function. Since we are linked to the CRT, we must define a
// function with this name, which will be called from _DllMainCRTStartup.
//
// Arguments:
//   instance (in)
//   reason (in)
//   (unused)
//
// Returns TRUE on success, or FALSE otherwise.
//
// Created 02/29/2000 johnstep (John Stephens)
//=============================================================================

extern "C"
BOOL
WINAPI
DllMain(
    HINSTANCE instance,
    DWORD reason,
    VOID *
    )
{
    BOOL success = TRUE;

    switch (reason)
    {
    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls(instance);
        CreduiInstance = instance;

        // Create a global event which will be set when first-time
        // initialization is completed by the first API call:

        CreduiInitEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

        if (CreduiInitEvent == NULL)
        {
            success = FALSE;
        }

        SHFusionInitialize(NULL);
        // Register the Credential controls:

        if (!CreduiCredentialControl::Register(instance))
        {
            CloseHandle(CreduiInitEvent);
            CreduiInitEvent = NULL;

            success = FALSE;
        }

//        InitializeCredMgr();

        //
        // Initialize the confirmation list
        //

        if ( !InitConfirmationList() ) {

            CreduiCredentialControl::Unregister();
            CloseHandle(CreduiInitEvent);
            CreduiInitEvent = NULL;

            success = FALSE;
        }

        break;

    case DLL_PROCESS_DETACH:

        CleanUpConfirmationList();

        if (CreduiFirstTime == FALSE)
        {
            CreduiIconParentWindow::Unregister();
        }

        // Unregister the Credential controls:

        CreduiCredentialControl::Unregister();

        SHFusionUninitialize();
        // Make sure to free the global initialization event:

        if (CreduiInitEvent != NULL)
        {
            CloseHandle(CreduiInitEvent);
        }

        UninitializeCredMgr();

        break;
    };

    return success;
}

//=============================================================================
// DllCanUnloadNow (COM)
//
// Created 04/03/2000 johnstep (John Stephens)
//=============================================================================

STDAPI
DllCanUnloadNow()
{
    return (CreduiComReferenceCount == 0) ? S_OK : S_FALSE;
}

//=============================================================================
// DllGetClassObject (COM)
//
// Created 04/03/2000 johnstep (John Stephens)
//=============================================================================

STDAPI
DllGetClassObject(
    CONST CLSID &classId,
    CONST IID &interfaceId,
    VOID **outInterface
    )
{
    if (classId != CreduiStringArrayClassId)
    {
        return CLASS_E_CLASSNOTAVAILABLE;
    }

    CreduiStringArrayFactory *factory = new CreduiStringArrayFactory;

    if (factory == NULL)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT result = factory->QueryInterface(interfaceId, outInterface);

    factory->Release();

    // Release the string array object in any case, because of the
    // QueryInterface succeeded, it already took another reference count on
    // the object:

    return result;
}

//=============================================================================
// DllRegisterServer (COM)
//
// Created 04/03/2000 johnstep (John Stephens)
//=============================================================================

STDAPI
DllRegisterServer()
{
    HRESULT result = E_FAIL;

    WCHAR fileName[MAX_PATH + 1];

    if (GetModuleFileName(CreduiInstance, fileName, MAX_PATH))
    {
        HKEY regKey;

        if (RegCreateKeyEx(
                HKEY_CLASSES_ROOT,
                L"CLSID\\" CREDUI_STRING_ARRAY_CLASS_STRING
                    L"\\InProcServer32",
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                KEY_SET_VALUE,
                NULL,
                &regKey,
                NULL) == ERROR_SUCCESS)
        {
            if (RegSetValueEx(
                    regKey,
                    NULL,
                    0,
                    REG_SZ,
                    reinterpret_cast<CONST BYTE *>(fileName),
                    (lstrlen(fileName) + 1) * 2) == ERROR_SUCCESS)
            {
                if (RegSetValueEx(
                        regKey,
                        L"ThreadingModel",
                        0,
                        REG_SZ,
                        reinterpret_cast<CONST BYTE *>(L"Apartment"),
                        18) == ERROR_SUCCESS)
                {
                    result = S_OK;
                }
            }

            RegCloseKey(regKey);
        }
    }

    return result;
}

//=============================================================================
// DllUnregisterServer (COM)
//
// Created 04/03/2000 johnstep (John Stephens)
//=============================================================================

STDAPI
DllUnregisterServer()
{
    HRESULT result = S_OK;
    LONG error;

    // Delete our InProcServer32 key:

    error =
        RegDeleteKey(
            HKEY_CLASSES_ROOT,
            L"CLSID\\" CREDUI_STRING_ARRAY_CLASS_STRING L"\\InProcServer32");

    if ((error != ERROR_SUCCESS) &&
        (error != ERROR_FILE_NOT_FOUND))
    {
        result = E_FAIL;
    }

    // Delete our class ID key:

    error =
        RegDeleteKey(
            HKEY_CLASSES_ROOT,
            L"CLSID\\" CREDUI_STRING_ARRAY_CLASS_STRING);

    if ((error != ERROR_SUCCESS) &&
        (error != ERROR_FILE_NOT_FOUND))
    {
        result = E_FAIL;
    }

    return result;
}


CREDUIAPI
DWORD
WINAPI
CredUIConfirmCredentialsW(
    PCWSTR pszTargetName,
    BOOL  bConfirm
    )
{

    return ConfirmCred ( pszTargetName, bConfirm, TRUE );

}

CREDUIAPI
DWORD
WINAPI
CredUIConfirmCredentialsA(
    PCSTR pszTargetName,
    BOOL  bConfirm
    )
{
    WCHAR targetNameW[CRED_MAX_STRING_LENGTH+1+CRED_MAX_STRING_LENGTH];

    // If a target name was passed, convert it to wide now:

    if (pszTargetName != NULL)
    {
        if (MultiByteToWideChar(
                CP_ACP, 0, pszTargetName, -1,
                targetNameW,
                CRED_MAX_STRING_LENGTH+1+CRED_MAX_STRING_LENGTH) == 0)
        {
            return GetLastError();
        }
    }


    return CredUIConfirmCredentialsW ( targetNameW, bConfirm );


}


CREDUIAPI
DWORD
WINAPI
CredUICmdLinePromptForCredentialsW(
    PCWSTR targetName,
    PCtxtHandle securityContext,
    DWORD dwAuthError,
    PWSTR UserName,
    ULONG ulUserBufferSize,
    PWSTR pszPassword,
    ULONG ulPasswordBufferSize,
    PBOOL pfSave,
    DWORD flags
    )
{

    //
    // Call the common code indicating this is the command line interface
    //

    return CredUIPromptForCredentialsWorker(
                TRUE,       // Command line version
                NULL,       // Command line version has no uiInfo,
                targetName,
                securityContext,
                dwAuthError,
                UserName,
                ulUserBufferSize,
                pszPassword,
                ulPasswordBufferSize,
                pfSave,
                flags );


}



CREDUIAPI
DWORD
WINAPI
CredUICmdLinePromptForCredentialsA(
    PCSTR targetName,
    PCtxtHandle pContext,
    DWORD dwAuthError,
    PSTR UserName,
    ULONG ulUserBufferSize,
    PSTR pszPassword,
    ULONG ulPasswordBufferSize,
    PBOOL pfSave,
    DWORD flags
    )
{
    DWORD result = ERROR_GEN_FAILURE;
    INT targetNameLength = lstrlenA(targetName);
    WCHAR *targetNameW = NULL;

    if (!CreduiApiInit())
    {
        return ERROR_GEN_FAILURE;
    }

    // convert to unicode


    WCHAR userNameW[CREDUI_MAX_USERNAME_LENGTH + 1];
    WCHAR *pUserNameW;

    if ( UserName != NULL )
    {
        if (MultiByteToWideChar(CP_ACP, 0, UserName, -1,
                            userNameW, sizeof(userNameW)/sizeof(WCHAR)) == 0)
        {
            result = GetLastError();
            goto Exit;
        }
        pUserNameW = userNameW;
    }
    else
    {
        pUserNameW = NULL;
    }


    WCHAR passwordW[CREDUI_MAX_PASSWORD_LENGTH + 1];
    WCHAR *ppasswordW;

    if ( pszPassword != NULL )
    {
        if (MultiByteToWideChar(CP_ACP, 0, pszPassword, -1,
                            passwordW, sizeof(passwordW)/sizeof(WCHAR)) == 0)
        {
            result = GetLastError();
            goto Exit;
        }
        ppasswordW = passwordW;
    }
    else
    {
        ppasswordW = NULL;
    }


    // Allocate the target name memory because it can be up to 32 KB:



    if (targetName != NULL)
    {
        targetNameW = new WCHAR[targetNameLength + 1];

        if (targetNameW != NULL)
        {
            if (MultiByteToWideChar(CP_ACP, 0, targetName, -1,
                                    targetNameW, sizeof(targetNameW)/sizeof(WCHAR)) == 0)
            {
                result = GetLastError();
                goto Exit;
            }
        }
        else
        {
            result = ERROR_NOT_ENOUGH_MEMORY;
            goto Exit;
        }
    }
    else
    {
        targetNameW = NULL;
    }


    result = CredUICmdLinePromptForCredentialsW ( targetNameW,
                                                  pContext,
                                                  dwAuthError,
                                                  userNameW,
                                                  ulUserBufferSize,
                                                  passwordW,
                                                  ulPasswordBufferSize,
                                                  pfSave,
                                                  flags );


    if ( UserName != NULL )
    {
        if ( wcslen(userNameW) < ulUserBufferSize )
        {
            if (!WideCharToMultiByte(CP_ACP, 0, userNameW, -1, UserName,
                                ulUserBufferSize, NULL, NULL) ) {
                result = GetLastError();
                goto Exit;
            }

        }
        else
        {
            CreduiDebugLog("CreduiPromptForCredentials: typed username is too long.\n" );
            result = ERROR_INVALID_PARAMETER;
            goto Exit;
        }
    }

    if ( pszPassword != NULL )
    {
        if ( wcslen ( passwordW ) < ulPasswordBufferSize )
        {
            if (!WideCharToMultiByte(CP_ACP, 0, passwordW, -1, pszPassword,
                            ulPasswordBufferSize, NULL, NULL)) {
                result = GetLastError();
                goto Exit;
            }
        }
        else
        {
            CreduiDebugLog("CreduiPromptForCredentials: typed password is too long.\n" );
            result = ERROR_INVALID_PARAMETER;
            goto Exit;
        }
    }






Exit:

    ZeroMemory(passwordW, sizeof(passwordW) );

    // Free the target name memory:

    if (targetNameW != NULL)
    {
        delete [] targetNameW;
    }


    return result;
}



// call this api to store a single-sign-on credential
// retruns ERROR_SUCCESS if success

CREDUIAPI
DWORD
WINAPI
CredUIStoreSSOCredW (
    PCWSTR pszRealm,
    PCWSTR pszUsername,
    PCWSTR pszPassword,
    BOOL   bPersist
    )
{

    DWORD dwResult = ERROR_GEN_FAILURE;

    if ( pszUsername == NULL || pszPassword == NULL )
        return dwResult;

    WCHAR szTargetName[CREDUI_MAX_DOMAIN_TARGET_LENGTH];
    PVOID password = (PVOID)pszPassword;

    // temporarily cache them locally
    wcsncpy ( gszSSOUserName, pszUsername, CREDUI_MAX_USERNAME_LENGTH );
    wcsncpy ( gszSSOPassword, pszPassword, CREDUI_MAX_PASSWORD_LENGTH );

    gbStoredSSOCreds = TRUE;

    if ( gbWaitingForSSOCreds || !bPersist)
    {
        dwResult = ERROR_SUCCESS;

    }
    else
    {
        // otherwise store them in credmgr

        if ( pszRealm )
        {
            // validate it's not zero length
            int len = wcslen(pszRealm);
            if ( len == 0 || len > CREDUI_MAX_DOMAIN_TARGET_LENGTH - 3 )
            {
                return ERROR_INVALID_PARAMETER;
            }

            wcsncpy ( szTargetName, pszRealm, len+1 );

        }
        else
        {
            GetDeaultSSORealm(szTargetName, TRUE);
        }


        // finalize the target name
        wcscat ( szTargetName, L"\\*" );

        // encrypt the password
        PVOID pEncryptedPassword;
        DWORD dwESize = wcslen(pszPassword)+1;
        DWORD dwEncrypt = EncryptPassword ( (PWSTR)pszPassword, &pEncryptedPassword, &dwESize );
        if ( dwEncrypt == ERROR_SUCCESS )
        {
            password = pEncryptedPassword;
        }

        // write it out

        CREDENTIALW NewCredential;

        memset ( (void*)&NewCredential, 0, sizeof(CREDENTIALW));

        DWORD dwFlags = 0;

        NewCredential.TargetName = szTargetName;
        NewCredential.Type = CRED_TYPE_DOMAIN_VISIBLE_PASSWORD;
        NewCredential.Persist = bPersist ? CRED_PERSIST_ENTERPRISE : CRED_PERSIST_SESSION;
        NewCredential.Flags =  0;
        NewCredential.CredentialBlobSize = dwESize;
        NewCredential.UserName = (LPWSTR)pszUsername;
        NewCredential.CredentialBlob = reinterpret_cast<BYTE *>(password);

        if ( CredWriteW(&NewCredential, dwFlags))
        {
            dwResult = ERROR_SUCCESS;
        }

        if ( dwEncrypt == ERROR_SUCCESS )
        {
            LocalFree (pEncryptedPassword);
        }

    }

    return dwResult;

}


CREDUIAPI
DWORD
WINAPI
CredUIStoreSSOCredA (
    PCSTR pszRealm,
    PCSTR pszUsername,
    PCSTR pszPassword,
    BOOL  bPersist
    )
{
    DWORD dwResult = ERROR_GEN_FAILURE;

    // convert to unicode

    WCHAR realmW[CREDUI_MAX_DOMAIN_TARGET_LENGTH];
    WCHAR *prealmW;

    if ( pszRealm != NULL )
    {
        if (MultiByteToWideChar(CP_ACP, 0, pszRealm, -1,
                            realmW, lstrlenA(pszRealm) + 1) == 0)
        {
            goto Exit;
        }
        prealmW = realmW;
    }
    else
    {
        prealmW = NULL;
    }



    WCHAR userNameW[CREDUI_MAX_USERNAME_LENGTH + 1];
    WCHAR *pUserNameW;

    if ( pszUsername != NULL )
    {
        if (MultiByteToWideChar(CP_ACP, 0, pszUsername, -1,
                            userNameW, lstrlenA(pszUsername) + 1) == 0)
        {
            goto Exit;
        }
        pUserNameW = userNameW;
    }
    else
    {
        pUserNameW = NULL;
    }


    WCHAR passwordW[CREDUI_MAX_PASSWORD_LENGTH + 1];
    WCHAR *ppasswordW;

    if ( pszPassword != NULL )
    {
        if (MultiByteToWideChar(CP_ACP, 0, pszPassword, -1,
                            passwordW, lstrlenA(pszPassword) + 1) == 0)
        {
            goto Exit;
        }
        ppasswordW = passwordW;
    }
    else
    {
        ppasswordW = NULL;
    }


    dwResult = CredUIStoreSSOCredW ( prealmW, pUserNameW, ppasswordW, bPersist );


Exit:
    // clean up passwords in memory
    ZeroMemory(passwordW, CREDUI_MAX_PASSWORD_LENGTH * sizeof (WCHAR) + 1);


    return dwResult;

}


// call this api to retrieve the username for a single-sign-on credential
// retruns ERROR_SUCCESS if success, ERROR_NOT_FOUND if none was found

CREDUIAPI
DWORD
WINAPI
CredUIReadSSOCredW (
    PCWSTR pszRealm,
    PWSTR* ppszUsername
    )
{

    DWORD dwReturn = ERROR_NOT_FOUND;
    WCHAR szTargetName[CREDUI_MAX_DOMAIN_TARGET_LENGTH];

    if ( pszRealm )
    {
        // validate it's not zero length
        int len = wcslen(pszRealm);
        if ( len == 0 || len > CREDUI_MAX_DOMAIN_TARGET_LENGTH - 3 )
        {
            return ERROR_INVALID_PARAMETER;
        }

        wcsncpy ( szTargetName, pszRealm, len+1 );

    }
    else
    {
        GetDeaultSSORealm(szTargetName, FALSE);
    }

    if ( wcslen ( szTargetName ) != 0 )
    {
        // finalize the target name
        wcscat ( szTargetName, L"\\*" );

        PCREDENTIALW pCred;
        DWORD dwFlags = 0;

        if ( CredReadW ( szTargetName,
                    CRED_TYPE_DOMAIN_VISIBLE_PASSWORD,
                    dwFlags,
                    &pCred ) )
        {
            *ppszUsername = (PWSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(WCHAR)*(wcslen(pCred->UserName)+1));
            if ( *ppszUsername )
            {
                dwReturn = ERROR_SUCCESS;
                wcscpy ( *ppszUsername, pCred->UserName );

            }


            CredFree ( pCred );

        }
    }

    return dwReturn;
}



// call this api to retrieve the username for a single-sign-on credential
// retruns ERROR_SUCCESS if success, ERROR_NOT_FOUND if none was found

CREDUIAPI
DWORD
WINAPI
CredUIReadSSOCredA (
    PCSTR pszRealm,
    PSTR* ppszUsername
    )
{

    DWORD dwReturn = ERROR_NOT_FOUND;
    WCHAR szTargetName[CREDUI_MAX_DOMAIN_TARGET_LENGTH];

    PCREDENTIALW pCred;
    DWORD dwFlags = 0;

    if ( pszRealm )
    {
        // validate it's not zero length
        int len = lstrlenA(pszRealm);
        if ( len == 0 || len > CREDUI_MAX_DOMAIN_TARGET_LENGTH - 3 )
        {
            return ERROR_INVALID_PARAMETER;
        }

        if (MultiByteToWideChar(CP_ACP, 0, pszRealm, -1,
                            szTargetName, len + 1) == 0)
        {
            goto Exit;
        }


    }
    else
    {
        GetDeaultSSORealm(szTargetName, FALSE);
    }

    if ( wcslen ( szTargetName ) != 0 )
    {


        // finalize the target name
        wcscat ( szTargetName, L"\\*" );


        // first call credmgr to set the target info
        if ( CredReadW ( szTargetName,
                    CRED_TYPE_DOMAIN_VISIBLE_PASSWORD,
                    dwFlags,
                    &pCred ) )
        {
            DWORD dwLen = wcslen(pCred->UserName);
            *ppszUsername = (PSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(CHAR)*(dwLen+1));
            if ( *ppszUsername )
            {

                WideCharToMultiByte(CP_ACP, 0, pCred->UserName, -1, *ppszUsername,
                                    dwLen, NULL, NULL);

                dwReturn = ERROR_SUCCESS;
            }


            CredFree ( pCred );

        }
    }

Exit:

    return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\credui\controls.hpp ===
//=============================================================================
// Copyright (c) 2000 Microsoft Corporation
//
// controls.hpp
//
// User interface control classes.
//
// Created 02/29/2000 johnstep (John Stephens)
//=============================================================================

#ifndef __CONTROLS_HPP__
#define __CONTROLS_HPP__

//-----------------------------------------------------------------------------

#include <objidl.h>
#include <scuisupp.h>

//-----------------------------------------------------------------------------
// Global Variables
//-----------------------------------------------------------------------------

extern CLSID CreduiStringArrayClassId;

#define CREDUI_STRING_ARRAY_CLASS_STRING\
            L"{82BD0E67-9FEA-4748-8672-D5EFE5B779B0}"

//-----------------------------------------------------------------------------
// Types
//-----------------------------------------------------------------------------

struct CREDUI_BALLOON_TIP_INFO
{
    WCHAR *Title;
    WCHAR *Text;
    INT Icon;
    INT XPercent;
    INT YPercent;
};

//-----------------------------------------------------------------------------
// CreduiBalloonTip Class
//-----------------------------------------------------------------------------

class CreduiBalloonTip
{
public:

    CreduiBalloonTip();
    ~CreduiBalloonTip();

    BOOL Init(HINSTANCE instance, HWND parentWindow);

    BOOL SetInfo(HWND controlWindow, CONST CREDUI_BALLOON_TIP_INFO *tipInfo);
    CREDUI_BALLOON_TIP_INFO *GetInfo() { return TipInfo; }

    BOOL Show();
    BOOL Hide();
    BOOL IsVisible() { return Visible; }

private:

    HWND Window;
    HWND ParentWindow;
    HWND ControlWindow;

    CREDUI_BALLOON_TIP_INFO *TipInfo;

    BOOL Visible;
};

//-----------------------------------------------------------------------------
// CreduiPasswordBox Class
//-----------------------------------------------------------------------------

class CreduiPasswordBox
{
public:

    CreduiPasswordBox();
    ~CreduiPasswordBox();

    BOOL Init(
        HWND window,
        CreduiBalloonTip *ballonTip,
        CONST CREDUI_BALLOON_TIP_INFO *capsLockTipInfo,
        HFONT passwordFont = NULL,
        WCHAR passwordChar = L'');

private:

    WNDPROC OriginalMessageHandler;

    LRESULT
    MessageHandler(
        UINT message,
        WPARAM wParam,
        LPARAM lParam
        );

    static LRESULT CALLBACK MessageHandlerCallback(
        HWND passwordWindow,
        UINT message,
        WPARAM wParam,
        LPARAM lParam
        );

    HWND Window;
    HFONT PasswordFont;
    CreduiBalloonTip *BalloonTip;
    CONST CREDUI_BALLOON_TIP_INFO *CapsLockTipInfo;
};

//-----------------------------------------------------------------------------
// CreduiStringArrayFactory Class
//-----------------------------------------------------------------------------

class CreduiStringArrayFactory : public IClassFactory
{
public:

    CreduiStringArrayFactory();

    // IUnknown

    HRESULT STDMETHODCALLTYPE QueryInterface(
        CONST IID &interfaceId,
        VOID **outInterface
        );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IClassFactory

    HRESULT STDMETHODCALLTYPE CreateInstance(
        IUnknown *unknownOuter,
        CONST IID &interfaceId,
        VOID **outInterface
        );
    HRESULT STDMETHODCALLTYPE LockServer(BOOL lock);

private:

    ~CreduiStringArrayFactory(); // must use IUnknown::Release()

    ULONG ReferenceCount;
};

//-----------------------------------------------------------------------------
// CreduiStringArray Class
//-----------------------------------------------------------------------------

class CreduiStringArray : public IEnumString
{
public:

    CreduiStringArray();

    BOOL Init(UINT count);
    BOOL Find(CONST WCHAR *string);
    INT Add(CONST WCHAR *string);

    UINT GetCount() CONST { return Count; }

    // IUnknown

    HRESULT STDMETHODCALLTYPE QueryInterface(
        CONST IID &interfaceId,
        VOID **outInterface
        );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IEnumString

    HRESULT STDMETHODCALLTYPE Next(
        ULONG count,
        WCHAR **array,
        ULONG *countFetched
        );
    HRESULT STDMETHODCALLTYPE Skip(ULONG count);
    HRESULT STDMETHODCALLTYPE Reset();
    HRESULT STDMETHODCALLTYPE Clone(IEnumString **enumInterface);

private:

    ~CreduiStringArray(); // must use IUnknown::Release()

    ULONG ReferenceCount;
    UINT Index;
    UINT Count;
    UINT MaxCount;
    WCHAR **Array;
};

//-----------------------------------------------------------------------------
// CreduiAutoCompleteComboBox Class
//-----------------------------------------------------------------------------

class CreduiAutoCompleteComboBox
{
public:

    CreduiAutoCompleteComboBox();
    ~CreduiAutoCompleteComboBox();

    BOOL Init(
        HMODULE instance,
        HWND comboBoxwindow,
        UINT stringCount,
        INT imageListResourceId = 0,
        INT initialImage = -1
        );
    INT Add(
        WCHAR *string,
        INT image = -1,
        BOOL autoComplete = TRUE,
        BOOL addUnique = TRUE,
        INT indexBefore = -1,
        INT indent = 0
        );
    BOOL Update(
        INT index,
        WCHAR *string,
        INT image = -1
        );
    BOOL Enable();

private:

    HWND Window;
    HIMAGELIST ImageList;
    CreduiStringArray *StringArray;
};

//-----------------------------------------------------------------------------
// CreduiIconParentWindow Class
//-----------------------------------------------------------------------------

class CreduiIconParentWindow
{
public:

    CreduiIconParentWindow();
    ~CreduiIconParentWindow();

    BOOL Init(HINSTANCE instance, UINT iconResourceId);
    HWND GetWindow() { return Window; }

    static BOOL Register(HINSTANCE instance);
    static BOOL Unregister();

private:

    HWND Window;

    static CONST WCHAR *ClassName;
    static HINSTANCE Instance;
    static LONG Registered;
};




//-----------------------------------------------------------------------------
// CreduiCredentialControl Class
//-----------------------------------------------------------------------------

class CreduiCredentialControl
{
public:

    CreduiCredentialControl();
    ~CreduiCredentialControl();

    static BOOL Register(HINSTANCE instance);
    static BOOL Unregister();

    virtual BOOL
    OnHelpInfo(
        LPARAM lp
        );


    virtual UINT
    MapID(UINT uid);


private:

    static CONST WCHAR *ClassName;
    static HINSTANCE Instance;
    static LONG Registered;

    BOOL IsInitialized;

    // User interface control state flags:

    enum
    {
        DISABLED_CONTROL            = 0x0001,
        DISABLED_CONTROL_PASSWORD   = 0x0002,
        DISABLED_CONTROL_USERNAME   = 0x0010,
        DISABLED_CONTROL_VIEW       = 0x0004,
        DISABLED_CONTROL_SAVE       = 0x0008,
    };

    BOOL DisabledControlMask;

    // User type image indices:

    enum
    {
        IMAGE_USERNAME              = 0,
        IMAGE_CERT                  = 1,
        IMAGE_CERT_EXPIRED          = 2,
        IMAGE_SMART_CARD            = 3,
        IMAGE_SMART_CARD_MISSING    = 4,
        IMAGE_SMART_CARD_EXPIRED    = 5
    };

    HWND Window;
    LONG Style;

    HWND UserNameStaticWindow;
    HWND UserNameControlWindow;
    HWND ViewCertControlWindow;
    HWND PasswordStaticWindow;
    HWND PasswordControlWindow;
    HWND SaveControlWindow;

    BOOL FirstPaint;
    BOOL ShowBalloonTip;
    CreduiBalloonTip BalloonTip;

    BOOL IsAutoComplete;
    BOOL NoEditUserName;
    BOOL KeepUserName;

    BOOL IsPassport;

    CreduiPasswordBox PasswordBox;

    UCHAR (*CertHashes)[CERT_HASH_LENGTH];
    ULONG CertCount;
    INT   CertBaseInComboBox;
    UCHAR (*UserNameCertHash)[CERT_HASH_LENGTH];
    INT   SmartCardBaseInComboBox;
    UINT SmartCardReadCount;
    UINT IsChangingUserName;
    UINT IsChangingPassword;

    CreduiAutoCompleteComboBox UserNameComboBox;

    LONG UserNameSelection;

    HSCARDUI ScardUiHandle;

    // Functions:

    BOOL InitWindow();
    BOOL CreateControls();
    BOOL InitComboBoxUserNames();
    BOOL AddCertificates();

    BOOL ViewCertificate(INT index);

    BOOL HandleSmartCardMessages(UINT message, CERT_ENUM *certEnum);

    INT FindSmartCardInComboBox(CERT_ENUM *certEnum);
    VOID RemoveSmartCardFromComboBox(CERT_ENUM *certEnum, BOOL removeParent);

    VOID Enable(BOOL enable = TRUE);

    VOID OnUserNameSelectionChange();

    BOOL OnSetUserNameA(CHAR *userNameA);
    BOOL OnSetUserName(WCHAR *userName);

    BOOL OnGetUserNameA(CHAR *userNameA, ULONG maxChars);
    BOOL OnGetUserName(WCHAR *userName, ULONG maxChars);

    BOOL OnSetPasswordA(CHAR *passwordA);
    BOOL OnSetPassword(WCHAR *password);

    BOOL OnGetPasswordA(CHAR *passwordA, ULONG maxChars);
    BOOL OnGetPassword(WCHAR *password, ULONG maxChars);

    LONG OnGetUserNameLength();

    BOOL OnShowBalloonA(CREDUI_BALLOONA *balloonA);
    BOOL OnShowBalloon(CREDUI_BALLOON *balloon);

    static LRESULT CALLBACK MessageHandlerCallback(
        HWND window,
        UINT message,
        WPARAM wParam,
        LPARAM lParam
        );
    LRESULT
    MessageHandler(
        UINT message,
        WPARAM wParam,
        LPARAM lParam
        );

    //
    // Command line specific data
    //

    BOOL DoingCommandLine;
    INT  Heartbeats;
#define CREDUI_HEARTBEAT_TIMER           1
#define CREDUI_HEARTBEAT_TIMER_VALUE    2000
#define CREDUI_MAX_HEARTBEATS           5

    LPWSTR TargetName;
    LPWSTR InitialUserName;

    void CmdlineSmartCardPrompt();
    void CmdlineSavePrompt();

    BOOL GetSmartCardInfo(
        IN DWORD SmartCardIndex,
        IN DWORD BufferLength,
        OUT LPWSTR Buffer,
        OUT BOOL *IsValid,
        OUT CERT_ENUM **CertEnum OPTIONAL
        );

    LPWSTR MatchSmartCard(
        IN DWORD SmartCardCount,
        IN LPWSTR UserName,
        OUT LPDWORD RetCertIndex,
        OUT CERT_ENUM **RetCertEnum
        );

};



//-----------------------------------------------------------------------------

#endif // __CONTROLS_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\credui\dialogs.hpp ===
//=============================================================================
// Copyright (c) 2000 Microsoft Corporation
//
// dialogs.hpp
//
// Credential manager user interface classes used to get credentials.
//
// Created 02/29/2000 johnstep (John Stephens)
//=============================================================================

#ifndef __DIALOGS_HPP__
#define __DIALOGS_HPP__

//-----------------------------------------------------------------------------

#include "controls.hpp"

//-----------------------------------------------------------------------------
// Types
//-----------------------------------------------------------------------------

struct CREDUI_CHANGE_PASSWORD_INFO
{
    CONST WCHAR *UserName;
    WCHAR *Password;
    ULONG PasswordMaxChars;
    CreduiBalloonTip BalloonTip;
    CreduiPasswordBox OldPasswordBox;
    CreduiPasswordBox NewPasswordBox;
    CreduiPasswordBox ConfirmPasswordBox;
};

//-----------------------------------------------------------------------------
// Functions
//-----------------------------------------------------------------------------

static
INT_PTR
CALLBACK
CreduiChangePasswordCallback(
    HWND changePasswordWindow,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

extern
BOOL
CreduiChangeDomainPassword(
    HWND parentWindow,
    CONST WCHAR *userName,
    WCHAR *password,
    ULONG passwordMaxChars
    );

//-----------------------------------------------------------------------------
// CreduiPasswordDialog Class
//-----------------------------------------------------------------------------

class CreduiPasswordDialog
{
public:

    CreduiPasswordDialog(
        IN BOOL DoingCommandLine,
        IN BOOL DelayCredentialWrite,
        IN DWORD credCategory,
        CREDUI_INFO *uiInfo,
        CONST WCHAR *targetName,
        WCHAR *userName,
        ULONG userNameMaxChars,
        WCHAR *password,
        ULONG passwordMaxChars,
        BOOL *save,
        DWORD flags,
        CtxtHandle *securityContext,
        DWORD authError,
        DWORD *result
        );
    ~CreduiPasswordDialog();

private:

    // Variables:

    DWORD Result;
    DWORD AuthError;

    HWND DialogWindow;

    HWND CredControlWindow;
    DWORD CredControlStyle;

    // User interface control state flags:

    enum
    {
        DISABLED_DIALOG             = 0x0001,
        DISABLED_CONTROL_CRED       = 0x0002,
        DISABLED_CONTROL_OK         = 0x0004,
    };

    BOOL DisabledControlMask;

    BOOL DelayCredentialWrite;
    BOOL EncryptedVisiblePassword;

    DWORD Flags;

    //
    // CredCategory defines the type of the credential
    //
    DWORD CredCategory;
#define DOMAIN_CATEGORY 0
#define USERNAME_TARGET_CATEGORY CREDUI_FLAGS_USERNAME_TARGET_CREDENTIALS
#define GENERIC_CATEGORY CREDUI_FLAGS_GENERIC_CREDENTIALS


    BOOL Save;
    WCHAR *TargetName;
    WCHAR *UserOrTargetName;
    CtxtHandle *SecurityContext;
    CREDUI_INFO UiInfo;
    WCHAR *UserName;
    ULONG UserNameMaxChars;
    WCHAR *Password;
    ULONG PasswordMaxChars;

    BOOL fInitialSaveState; // initial state of the Save checkbox
    BOOL fPassedUsername;
    BOOL fPasswordOnly;

    BOOL FirstPaint;
    CONST CREDUI_BALLOON *CredBalloon;

    enum
    {
        PASSWORD_UNINIT     = 0,
        PASSWORD_INIT       = 1,
        PASSWORD_CHANGED    = 2
    };

    DWORD PasswordState;

    LONG ResizeTop;
    LONG ResizeDelta;

    // Functions:

    BOOL InitWindow(HWND dialogWindow);
    VOID SelectAndSetWindowCaption();
    VOID SelectAndSetWindowMessage();

    VOID Enable(BOOL enable = TRUE);

    DWORD HandleOk();
    void    SetCredTargetFromInfo();
    DWORD UsernameHandleOk();
    DWORD FinishHandleOk();

    static LRESULT CALLBACK CmdLineMessageHandlerCallback(
        HWND window,
        UINT message,
        WPARAM wParam,
        LPARAM lParam
        );
    LRESULT
    CreduiPasswordDialog::CmdLineMessageHandler(
        UINT message,
        WPARAM wParam,
        LPARAM lParam
        );

    static INT_PTR CALLBACK DialogMessageHandlerCallback(
        HWND dialogWindow,
        UINT message,
        WPARAM wParam,
        LPARAM lParam
        );
    INT_PTR DialogMessageHandler(
        UINT message,
        WPARAM wParam,
        LPARAM lParam
        );

    static BOOL CALLBACK ResizeDialogCallback(
        HWND childWindow,
        LPARAM lParam);

    CREDENTIAL_TARGET_INFORMATION *TargetInfo;
    CREDENTIAL *PasswordCredential;
    CREDENTIAL *OldCredential;
    CREDENTIAL NewCredential;
    WCHAR OldUserName[CRED_MAX_USERNAME_LENGTH + 1];
    WCHAR NewTargetName[CRED_MAX_STRING_LENGTH + 1];
    WCHAR NewTargetAlias[CRED_MAX_STRING_LENGTH + 1];

    SSOPACKAGE SSOPackage;
    DWORD dwIDDResource;
    RECT rcBrand;
    HBITMAP hBrandBmp;

    DWORD MaximumPersist;
    DWORD MaximumPersistSso;

    //
    // Data specific to command line
    //

    DWORD
    CmdLineDialog(
        VOID
        );

    HWND CmdLineWindow;
    BOOL DoingCommandLine;
    static LONG Registered;

    DWORD
    CmdlinePasswordPrompt(
        VOID
        );



    // Functions:

    BOOL CompleteUserName();
    VOID SelectBestTargetName(BOOL serverOnly);
};

//-----------------------------------------------------------------------------

#endif // __DIALOGS_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\credui\dialogs.cpp ===
//=============================================================================
// Copyright (c) 2000 Microsoft Corporation
//
// dialogs.cpp
//
// Credential manager user interface classes used to get credentials.
//
// Created 02/29/2000 johnstep (John Stephens)
//=============================================================================

#include "precomp.hpp"
#include "shellapi.h"
#include "dialogs.hpp"
#include "resource.h"
#include "utils.hpp"
#include "shpriv.h"
#include "shlobj.h"
#include "shlobjp.h"

// compile switch to allow credui to update wildcard creds
#define SETWILDCARD
NET_API_STATUS NetUserChangePasswordEy(LPCWSTR domainname, LPCWSTR username, LPCWSTR oldpassword, LPCWSTR newpassword);


// .NET logo sizes
#define BRANDLEFT_PIXEL_WIDTH       3
#define BRANDLEFT_PIXEL_HEIGHT      4
#define BRANDMID_PIXEL_HEIGHT       4
#define BRANDRIGHT_PIXEL_WIDTH    144
#define BRANDRIGHT_PIXEL_HEIGHT    37


//-----------------------------------------------------------------------------
// Values
//-----------------------------------------------------------------------------

#define CREDUI_MAX_WELCOME_TEXT_LINES 8

#define CREDUI_MAX_LOGO_HEIGHT        80

#define CREDUI_MAX_CMDLINE_MSG_LENGTH   256

//-----------------------------------------------------------------------------
// Global Variables
//-----------------------------------------------------------------------------

extern BOOL  gbWaitingForSSOCreds;
extern WCHAR gszSSOUserName[CREDUI_MAX_USERNAME_LENGTH];
extern WCHAR gszSSOPassword[CREDUI_MAX_PASSWORD_LENGTH];

// Balloon tip infos for change password dialog:

CONST CREDUI_BALLOON_TIP_INFO CreduiWrongOldTipInfo =
{
    CreduiStrings.WrongOldTipTitle,
    CreduiStrings.WrongOldTipText,
    TTI_ERROR, 96, 76
};

CONST CREDUI_BALLOON_TIP_INFO CreduiNotSameTipInfo =
{
    CreduiStrings.NotSameTipTitle,
    CreduiStrings.NotSameTipText,
    TTI_ERROR, 96, 76
};

CONST CREDUI_BALLOON_TIP_INFO CreduiTooShortTipInfo =
{
    CreduiStrings.TooShortTipTitle,
    CreduiStrings.TooShortTipText,
    TTI_ERROR, 96, 76
};

// Control balloons for password dialog:

CONST CREDUI_BALLOON CreduiUserNameBalloon =
{
    1, CREDUI_CONTROL_USERNAME, CREDUI_BALLOON_ICON_INFO,
    CreduiStrings.UserNameTipTitle,
    CreduiStrings.UserNameTipText
};

CONST CREDUI_BALLOON CreduiEmailNameBalloon =
{
    1, CREDUI_CONTROL_USERNAME, CREDUI_BALLOON_ICON_INFO,
    CreduiStrings.EmailNameTipTitle,
    CreduiStrings.EmailNameTipText
};

CONST CREDUI_BALLOON CreduiDowngradeBalloon =
{
    1, CREDUI_CONTROL_USERNAME, CREDUI_BALLOON_ICON_ERROR,
    CreduiStrings.LogonTipTitle,
    CreduiStrings.DowngradeTipText
};

CONST CREDUI_BALLOON CreduiLogonBalloon =
{
    1, CREDUI_CONTROL_PASSWORD, CREDUI_BALLOON_ICON_ERROR,
    CreduiStrings.LogonTipTitle,
    CreduiStrings.LogonTipText
};

CONST CREDUI_BALLOON CreduiLogonCapsBalloon =
{
    1, CREDUI_CONTROL_PASSWORD, CREDUI_BALLOON_ICON_ERROR,
    CreduiStrings.LogonTipTitle,
    CreduiStrings.LogonTipCaps
};

// Placehold for known password:

CONST WCHAR CreduiKnownPassword[] = L"********";

//-----------------------------------------------------------------------------
// Functions
//-----------------------------------------------------------------------------

void DemoteOldDefaultSSOCred (
    PCREDENTIAL_TARGET_INFORMATION pTargetInfo,     // target info of new cred
    DWORD Flags
    );

//=============================================================================
// CreduiChangePasswordCallback
//
// This callback handles changing a domain password.
//
// Arguments:
//   changePasswordWindow (in)
//   message (in)
//   wParam (in)
//   lParam (in) - on WM_INITDIALOG, this is the info structure
//
// Returns TRUE if we handled the message, otherwise FALSE.
//
// Created 04/26/2000 johnstep (John Stephens)
//=============================================================================

INT_PTR
CALLBACK
CreduiChangePasswordCallback(
    HWND changePasswordWindow,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    CREDUI_CHANGE_PASSWORD_INFO *info =
        reinterpret_cast<CREDUI_CHANGE_PASSWORD_INFO *>(
            GetWindowLongPtr(changePasswordWindow, GWLP_USERDATA));

    if (message == WM_INITDIALOG)
    {
        info = reinterpret_cast<CREDUI_CHANGE_PASSWORD_INFO *>(lParam);

        if (info != NULL)
        {
            // Store this object's pointer in the user data window long:

            SetWindowLongPtr(changePasswordWindow,
                             GWLP_USERDATA,
                             reinterpret_cast<LONG_PTR>(info));

            SetWindowText(
                GetDlgItem(changePasswordWindow, IDC_USERNAME),
                info->UserName);

            info->BalloonTip.Init(CreduiInstance, changePasswordWindow);

            info->OldPasswordBox.Init(
                GetDlgItem(changePasswordWindow, IDC_PASSWORD),
                &info->BalloonTip,
                &CreduiCapsLockTipInfo);

            info->NewPasswordBox.Init(
                GetDlgItem(changePasswordWindow, IDC_NEW_PASSWORD),
                &info->BalloonTip,
                &CreduiCapsLockTipInfo);

            info->ConfirmPasswordBox.Init(
                GetDlgItem(changePasswordWindow, IDC_CONFIRM_PASSWORD),
                &info->BalloonTip,
                &CreduiCapsLockTipInfo);

            return TRUE;
        }
        else
        {
            EndDialog(changePasswordWindow, IDCANCEL);
        }
    }
    else switch (message)
    {
    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_PASSWORD:
        case IDC_NEW_PASSWORD:
            if ((HIWORD(wParam) == EN_KILLFOCUS) ||
                (HIWORD(wParam) == EN_CHANGE))
            {
                if (info->BalloonTip.IsVisible())
                {
                    info->BalloonTip.Hide();
                }
            }
            break;

        case IDOK:
            WCHAR userDomain[CRED_MAX_USERNAME_LENGTH + 1];
            WCHAR userName[CRED_MAX_USERNAME_LENGTH + 1];
            WCHAR oldPassword[CRED_MAX_STRING_LENGTH + 1];
            WCHAR newPassword[CRED_MAX_STRING_LENGTH + 1];
            WCHAR confirmPassword[CRED_MAX_STRING_LENGTH + 1];

            oldPassword[0] = L'\0';
            newPassword[0] = L'\0';
            confirmPassword[0] = L'\0';

            GetWindowText(
                GetDlgItem(changePasswordWindow, IDC_NEW_PASSWORD),
                newPassword,
                CRED_MAX_STRING_LENGTH);

            GetWindowText(
                GetDlgItem(changePasswordWindow, IDC_CONFIRM_PASSWORD),
                confirmPassword,
                CRED_MAX_STRING_LENGTH);

            if (lstrcmp(newPassword, confirmPassword) != 0)
            {
                SetWindowText(
                    GetDlgItem(changePasswordWindow, IDC_NEW_PASSWORD),
                    NULL);

                SetWindowText(
                    GetDlgItem(changePasswordWindow, IDC_CONFIRM_PASSWORD),
                    NULL);

                info->BalloonTip.SetInfo(
                    GetDlgItem(changePasswordWindow, IDC_NEW_PASSWORD),
                    &CreduiNotSameTipInfo);

                info->BalloonTip.Show();
                ZeroMemory( newPassword, sizeof(newPassword) );
                ZeroMemory( confirmPassword, sizeof(confirmPassword) );
                break;
            }

            // Confirm password is no longer needed
            ZeroMemory( confirmPassword, sizeof(confirmPassword) );

            GetWindowText(
                GetDlgItem(changePasswordWindow, IDC_PASSWORD),
                oldPassword,
                CRED_MAX_STRING_LENGTH);

            if (CredUIParseUserName(
                    info->UserName,
                    userName,
                    sizeof(userName)/sizeof(WCHAR),
                    userDomain,
                    sizeof(userDomain)/sizeof(WCHAR)) == ERROR_SUCCESS)
            {
                NET_API_STATUS netStatus =
                    NetUserChangePasswordEy(userDomain,
                                          userName,
                                          oldPassword,
                                          newPassword);

                // Old password is no longer needed
                ZeroMemory(oldPassword, sizeof oldPassword);


                switch (netStatus)
                {
                case NERR_Success:
                    // Once we make it this far, the password has been
                    // changed. If the following call fails to update the
                    // credential, we really cannot do much about it except
                    // maybe notify the user.

                    lstrcpyn(info->Password,
                             newPassword,
                             info->PasswordMaxChars+1);

                    // Scrub the passwords on the stack and clear the
                    // controls:

                    ZeroMemory(newPassword, sizeof newPassword);

                    // NOTE: We may want to first set the controls to some
                    //       pattern to fill the memory, then clear it.

                    SetWindowText(
                        GetDlgItem(changePasswordWindow, IDC_PASSWORD),
                        NULL);
                    SetWindowText(
                        GetDlgItem(changePasswordWindow, IDC_NEW_PASSWORD),
                        NULL);
                    SetWindowText(
                        GetDlgItem(changePasswordWindow,
                                   IDC_CONFIRM_PASSWORD),
                        NULL);

                    // NOTE: We may want to notify the user that the password
                    //       has been successfully changed.

                    break;

                default:
                    // NOTE: If we got an unknown error, just handle it the
                    //       same way as an invalid password, for now:

                case ERROR_INVALID_PASSWORD:

                    // New password is no longer needed
                    ZeroMemory(newPassword, sizeof newPassword);

                    SetWindowText(
                        GetDlgItem(changePasswordWindow, IDC_PASSWORD),
                        NULL);

                    info->BalloonTip.SetInfo(
                        GetDlgItem(changePasswordWindow, IDC_PASSWORD),
                        &CreduiWrongOldTipInfo);

                    info->BalloonTip.Show();
                    return TRUE;

                case ERROR_ACCESS_DENIED:
                    // NOTE: One use of this return value is when the new
                    //       password and old are the same. Would any
                    //       configuration ever allow them to match? If not,
                    //       we could just compare before calling the API.

                case NERR_PasswordTooShort:

                    // New password is no longer needed
                    ZeroMemory(newPassword, sizeof newPassword);

                    SetWindowText(
                        GetDlgItem(changePasswordWindow, IDC_NEW_PASSWORD),
                        NULL);
                    SetWindowText(
                        GetDlgItem(changePasswordWindow,
                                   IDC_CONFIRM_PASSWORD),
                        NULL);

                    info->BalloonTip.SetInfo(
                        GetDlgItem(changePasswordWindow, IDC_NEW_PASSWORD),
                        &CreduiTooShortTipInfo);

                    info->BalloonTip.Show();
                    return TRUE;
                }
            }
            else
            {
                break;
            }
            // Fall through...

        case IDCANCEL:
            EndDialog(changePasswordWindow, LOWORD(wParam));
            return TRUE;
        }
        break;
    }

    return FALSE;
}

//=============================================================================
// CreduiChangeDomainPassword
//
// Displays a dialog allowing the user to change the domain password.
//
// Arguments:
//   parentWindow (in)
//   userName (in)
//   password (out)
//   passwordMaxChars (in) - on WM_INITDIALOG, this is the info structure
//
// Returns TRUE if we handled the message, otherwise FALSE.
//
// Created 06/06/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiChangeDomainPassword(
    HWND parentWindow,
    CONST WCHAR *userName,
    WCHAR *password,
    ULONG passwordMaxChars
    )
{
    CREDUI_CHANGE_PASSWORD_INFO info;

    info.UserName = userName;
    info.Password = password;
    info.PasswordMaxChars = passwordMaxChars;

    return
        DialogBoxParam(
            CreduiInstance,
            MAKEINTRESOURCE(IDD_CHANGE_PASSWORD),
            parentWindow,
            CreduiChangePasswordCallback,
            reinterpret_cast<LPARAM>(&info)) == IDOK;
}

//-----------------------------------------------------------------------------
// CreduiPasswordDialog Class Implementation
//-----------------------------------------------------------------------------

LONG CreduiPasswordDialog::Registered = FALSE;

//=============================================================================
// CreduiPasswordDialog::SetCredTargetFromInfo()
//
// Created 04/03/2001 georgema
//=============================================================================
void CreduiPasswordDialog::SetCredTargetFromInfo()
{
    BOOL serverOnly = TRUE;

    NewCredential.Type = (CredCategory == GENERIC_CATEGORY) ?
                                CRED_TYPE_GENERIC :
                                CRED_TYPE_DOMAIN_PASSWORD;

    if ( TargetInfo != NULL )
    {
        if ( TargetInfo->CredTypeCount == 1 && *(TargetInfo->CredTypes) == CRED_TYPE_DOMAIN_VISIBLE_PASSWORD ) {
            NewCredential.Type = CRED_TYPE_DOMAIN_VISIBLE_PASSWORD;
            MaximumPersist = MaximumPersistSso;
            serverOnly = (Flags & CREDUI_FLAGS_SERVER_CREDENTIAL);
        }

    }

    if ( CredCategory == DOMAIN_CATEGORY &&
        (TargetInfo != NULL))
    {
        SelectBestTargetName(serverOnly);

        NewCredential.TargetName = NewTargetName;
    }
    else
    {
        NewCredential.TargetName = const_cast<WCHAR *>(UserOrTargetName);
    }


}
//=============================================================================
// CreduiPasswordDialog::CreduiPasswordDialog
//
// Created 02/25/2000 johnstep (John Stephens)
//=============================================================================

CreduiPasswordDialog::CreduiPasswordDialog(
    IN BOOL doingCommandLine,
    IN BOOL delayCredentialWrite,
    IN DWORD credCategory,
    CREDUI_INFO *uiInfo,
    CONST WCHAR *targetName,
    WCHAR *userName,
    ULONG userNameMaxChars,
    WCHAR *password,
    ULONG passwordMaxChars,
    BOOL *save,
    DWORD flags,
    CtxtHandle *securityContext,
    DWORD authError,
    DWORD *result
    )
/*++

Routine Description:

    This routine implements the GUI prompt for credentials

Arguments:

    DoingCommandLine - TRUE if prompting is to be done via the command line
        FALSE if prompting is to be done via GUI

    delayCredentialWrite - TRUE if the credential is to be written only upon confirmation.
        FALSE, if the credential is to be written now as a session credential then
            morphed to a more persistent credential upon confirmation.
        This field is ignored if Flags doesn't specify CREDUI_FLAGS_EXPECT_CONFIRMATION.

    credCategory - This is the subset of the "flags" parameter defining the category of
        the credential.


    ...

Return Values:

    None

--*/

{

    Result = ERROR_CANCELLED;

    hBrandBmp = NULL;

    // Initialize the result out argument for failure:
    if ( result != NULL )
        *result = Result;
// Turn on the following chatter always for debug builds
#if DBG
    // ensure that we don't miss uninitialized members in test...
    memset(this,0xcc,sizeof(CreduiPasswordDialog));
    OutputDebugString(L"CreduiPasswordDialog: Constructor\n" );
    OutputDebugString(L"Incoming targetname = ");
    if (targetName) OutputDebugString(targetName);
    OutputDebugString(L"\n");
    OutputDebugString(L"Incoming username = ");
   if (userName) OutputDebugString(userName);
    OutputDebugString(L"\n");
#endif
    CREDENTIAL **credentialSet = NULL;
    SecPkgContext_CredentialName credentialName = { 0, NULL };
    ZeroMemory(&NewCredential, sizeof(NewCredential));
    fPassedUsername = FALSE;
    fPasswordOnly = FALSE;

    //FIX 399728
    if ((userName != NULL) &&
        (wcslen(userName) != 0)) fPassedUsername = TRUE;

    // Set most of the class members to valid initial values. The window
    // handles will be initialized later if everything succeeds:

    DoingCommandLine = doingCommandLine;
    DelayCredentialWrite = delayCredentialWrite;
    CredCategory = credCategory;
    UserName = userName;
    UserNameMaxChars = userNameMaxChars;
    Password = password;
    PasswordMaxChars = passwordMaxChars;
    Flags = flags;
    AuthError = authError;
    Save = (Flags & CREDUI_FLAGS_SHOW_SAVE_CHECK_BOX) ? *save : FALSE;

    rcBrand.top = 0;
    rcBrand.left = 0;
    rcBrand.right = 0;
    rcBrand.bottom = 0;


    if (targetName != NULL)
    {
        TargetName = const_cast<WCHAR *>(targetName);
        SecurityContext = NULL;
    }
    else if ( CredCategory == DOMAIN_CATEGORY )
    {
        if( securityContext == NULL) {
            CreduiDebugLog("CreduiPasswordDialog: Need to pass target name for domain creds.\n" );
            if ( result != NULL )
                *result = ERROR_INVALID_PARAMETER;
            return;
        }

        SecurityContext = securityContext;

        // Get the credential name, which includes the type, from the
        // security context:

        if (QueryContextAttributes(
                SecurityContext,
                SECPKG_ATTR_CREDENTIAL_NAME,
                static_cast<VOID *>(&credentialName)) != SEC_E_OK)
        {
            // This is an invalid security context for this function:

            CreduiDebugLog("CreduiPasswordDialog: Cannot QueryContextAttributes.\n" );
            if ( result != NULL )
                *result = ERROR_INVALID_PARAMETER;
            return;
        }

        TargetName = credentialName.sCredentialName;
    }
    else TargetName = NULL;

    if (uiInfo != NULL)
    {
        UiInfo = *uiInfo;
    }
    else
    {
        UiInfo.cbSize = sizeof(UiInfo);
        UiInfo.hwndParent = NULL;
        UiInfo.pszMessageText = NULL;
        UiInfo.pszCaptionText = NULL;
        UiInfo.hbmBanner = NULL;
    }

    PasswordCredential = NULL;
    OldCredential = NULL;
    TargetInfo = NULL;

    EncryptedVisiblePassword = TRUE;

    FirstPaint = TRUE;
    CredBalloon = NULL;

    NewTargetName[0] = L'\0';
    NewTargetAlias[0] = L'\0';

    DisabledControlMask = 0;

    PasswordState = PASSWORD_UNINIT;

    ResizeTop = 0;
    ResizeDelta = 0;

    DWORD MaximumPersistArray[CRED_TYPE_MAXIMUM];

    if ( LocalCredGetSessionTypes( CRED_TYPE_MAXIMUM, MaximumPersistArray)) {

        //
        // Maintain "MaximumPersist" as the maximum persistence to use.
        //  We don't know yet whether this is an SSO cred, so keep it in a separate location
        //  until we know for sure.
        //
        // Be careful to not use MaximumPersist until we do know for sure
        //
        if ( CredCategory == DOMAIN_CATEGORY || CredCategory == USERNAME_TARGET_CATEGORY ) {
            MaximumPersist = MaximumPersistArray[CRED_TYPE_DOMAIN_PASSWORD];
        } else {
            MaximumPersist = MaximumPersistArray[CRED_TYPE_GENERIC];
        }

        MaximumPersistSso = MaximumPersistArray[CRED_TYPE_DOMAIN_VISIBLE_PASSWORD];

    } else {
        MaximumPersist = CRED_PERSIST_NONE;
        MaximumPersistSso = CRED_PERSIST_NONE;
    }


    fInitialSaveState = FALSE;

    //
    // USERNAME_TARGET creds have two concepts of TargetName
    //  The target name on the peristed credential needs to be the UserName
    //  The target name everywhere else is the prompt text
    // UserOrTargetName is used in all the former cases.

    if ( CredCategory == USERNAME_TARGET_CATEGORY ) {
        UserOrTargetName = UserName;
    } else {
        UserOrTargetName = TargetName;
    }

    //
    // Get the target information for the target
    //
    // Only attempt to get target information if the target name is not a wildcard name.
    //
    // Do this regardless of whether the credential will be persisted.
    // Target info is used for completing the username.
    //

    if ( CredCategory == DOMAIN_CATEGORY &&
         SecurityContext == NULL &&
         !CreduiIsWildcardTargetName(TargetName) &&
         LocalCredGetTargetInfoW( TargetName,
                                  CRED_ALLOW_NAME_RESOLUTION,
                                  &TargetInfo) )
    {

        //
        // Check out the target info to ensure it matches the flag bits
        //  passed by the caller.
        //
        // If not, ignore the target info.
        //  We'll assume that the caller is using a different auth package than
        //  the one matching the cached info.
        //

        if ( TargetInfo->CredTypeCount != 0 ) {

            ULONG AuthPackageStyle;
            BOOL CertOk = FALSE;
            BOOL PasswordOk = FALSE;
            AuthPackageStyle = 0;

            //
            // Loop through the supported cred types seeing what style the auth package supports
            //

            for (UINT i = 0; i < TargetInfo->CredTypeCount; ++i)
            {
                switch ( TargetInfo->CredTypes[i] ) {
                case CRED_TYPE_DOMAIN_CERTIFICATE:
                    CertOk = TRUE;
                    break;
                case CRED_TYPE_DOMAIN_PASSWORD:
                case CRED_TYPE_DOMAIN_VISIBLE_PASSWORD:
                    PasswordOk = TRUE;
                    break;
                }

            }


            //
            // Adjust that for what the caller requires
            //
            if (Flags & (CREDUI_FLAGS_REQUIRE_SMARTCARD|CREDUI_FLAGS_REQUIRE_CERTIFICATE) ) {
                PasswordOk = FALSE;
            } else if (Flags & CREDUI_FLAGS_EXCLUDE_CERTIFICATES) {
                CertOk = FALSE;
            }

            //
            // If nothing to supported,
            //  ignore the target info
            //

            if ( !CertOk && !PasswordOk ) {
                LocalCredFree(static_cast<VOID *>(TargetInfo));
                TargetInfo = NULL;
            }
        }
    }


    //
    // If the credential might be peristed,
    //  determine the existing credential and
    //  build a template for the credential to be persisted.
    //

    if (!(Flags & CREDUI_FLAGS_DO_NOT_PERSIST))
    {
        // Read the existing credential for this target:

        CREDENTIAL *credential = NULL;

        Result = ERROR_SUCCESS;


        if ( CredCategory == GENERIC_CATEGORY )
        {
            if (LocalCredReadW(TargetName,
                         CRED_TYPE_GENERIC,
                         0,
                         &PasswordCredential))
            {
                OldCredential = PasswordCredential;
            }
            else
            {
                Result = GetLastError();
            }
        }
        else
        {
            DWORD count;

            //
            // If a TargetInfo was found,
            //  use it to read the matching credentials.
            //

            if ( TargetInfo != NULL ) {


                if (LocalCredReadDomainCredentialsW(TargetInfo, 0, &count,
                                              &credentialSet))
                {
                    for (DWORD i = 0; i < count; ++i)
                    {
#ifndef SETWILDCARD
                        //
                        // Ignore RAS and wildcard credentials,
                        //  we never want credUI to change such a credential.
                        //

                        if ( CreduiIsSpecialCredential(credentialSet[i]) ) {
                            continue;
                        }
#endif

                        //
                        // If the caller needs a server credential,
                        //  ignore wildcard credentials.
                        //

                        if ((Flags & CREDUI_FLAGS_SERVER_CREDENTIAL) &&
                             CreduiIsWildcardTargetName( credentialSet[i]->TargetName)) {

                            continue;
                        }

                        //
                        // If the caller wants a certificate,
                        //  ignore non certificates.
                        //

                        if ( Flags & (CREDUI_FLAGS_REQUIRE_CERTIFICATE|CREDUI_FLAGS_REQUIRE_SMARTCARD) ) {
                            if ( credentialSet[i]->Type != CRED_TYPE_DOMAIN_CERTIFICATE ) {
                                continue;
                            }
                        }

                        //
                        // If the caller wants to avoid certificates,
                        //  ignore certificates.
                        //

                        if ( Flags & CREDUI_FLAGS_EXCLUDE_CERTIFICATES ) {
                            if ( credentialSet[i]->Type == CRED_TYPE_DOMAIN_CERTIFICATE ) {
                                continue;
                            }
                        }

                        //
                        // CredReadDomain domain credentials returns creds in preference
                        //  order as specified by the TargetInfo.
                        //  So use the first valid one.
                        //
                        if ( OldCredential == NULL ) {
                            OldCredential = credentialSet[i];
                        }

                        //
                        // Remember the PasswordCredential in case we need to fall back to it
                        //
                        if ( credentialSet[i]->Type == CRED_TYPE_DOMAIN_PASSWORD ) {
                            PasswordCredential = credentialSet[i];
                        }
                    }

                    if (OldCredential == NULL)
                    {
                        Result = ERROR_NOT_FOUND;
                    }
                    else
                    {
                        Result = ERROR_SUCCESS;
                    }
                }
                else
                {
                    Result = GetLastError();
                }
            }

            //
            // We don't have a target info
            //  read each of the possible credential types
            //

            else
            {

                if (!(Flags & CREDUI_FLAGS_EXCLUDE_CERTIFICATES) &&
                    ((SecurityContext == NULL) ||
                        (credentialName.CredentialType ==
                            CRED_TYPE_DOMAIN_CERTIFICATE)) &&
                    *UserOrTargetName != '\0' &&
                    LocalCredReadW(UserOrTargetName,
                             CRED_TYPE_DOMAIN_CERTIFICATE,
                             0,
                             &credential))
                {
                    if (CreduiIsSpecialCredential(credential))
                    {
                        LocalCredFree(static_cast<VOID *>(credential));
                        credential = NULL;
                    }
                    else
                    {
                        OldCredential = credential;
                    }
                }

                if ( ( Flags & (CREDUI_FLAGS_REQUIRE_CERTIFICATE|CREDUI_FLAGS_REQUIRE_SMARTCARD)) == 0 ) {
                    if ( OldCredential == NULL &&
                         ((SecurityContext == NULL) ||
                            (credentialName.CredentialType ==
                                CRED_TYPE_DOMAIN_PASSWORD)) &&
                        *UserOrTargetName != '\0' &&
                        LocalCredReadW(UserOrTargetName,
                                 CRED_TYPE_DOMAIN_PASSWORD,
                                 0,
                                 &credential))
                    {
                        if (CreduiIsSpecialCredential(credential))
                        {
                            LocalCredFree(static_cast<VOID *>(credential));
                            credential = NULL;
                        }
                        else
                        {
                            PasswordCredential = credential;

                            OldCredential = credential;

                            Result = ERROR_SUCCESS;
                        }
                    }

                    if ( OldCredential == NULL &&
                         ((SecurityContext == NULL) ||
                            (credentialName.CredentialType ==
                                CRED_TYPE_DOMAIN_VISIBLE_PASSWORD)) &&
                        *UserOrTargetName != '\0' &&
                        LocalCredReadW(UserOrTargetName,
                                 CRED_TYPE_DOMAIN_VISIBLE_PASSWORD,
                                 0,
                                 &credential))
                    {
                        if (CreduiIsSpecialCredential(credential))
                        {
                            LocalCredFree(static_cast<VOID *>(credential));
                            credential = NULL;
                        }
                        else
                        {
                            OldCredential = credential;

                            Result = ERROR_SUCCESS;
                        }
                    }
                }

                if (OldCredential == NULL)
                {
                    Result = GetLastError();
                }
                else
                {
                    fInitialSaveState = TRUE;
                    Result = ERROR_SUCCESS;
                }
            }
        }

        if (Result == ERROR_SUCCESS)
        {

            NewCredential = *OldCredential;

            // if we have an existing cred, set the save state
            if (OldCredential != NULL)
            {
                fInitialSaveState = TRUE;
            }


            // If a user name was not passed, copy the user name and password
            // from the existing credential:

            if (UserName[0] == L'\0')
            {
                if (OldCredential->UserName != NULL)
                {
                    lstrcpyn(UserName,
                             OldCredential->UserName,
                             UserNameMaxChars + 1);
                }

                if (Password[0] == L'\0')
                {
                    if ((OldCredential->Type == CRED_TYPE_GENERIC) )
                    {
                        CopyMemory(
                            Password,
                            OldCredential->CredentialBlob,
                            OldCredential->CredentialBlobSize
                            );

                        Password[OldCredential->
                            CredentialBlobSize >> 1] = L'\0';

                    }
                    else if (OldCredential->Type == CRED_TYPE_DOMAIN_VISIBLE_PASSWORD)
                    {
                        // check to see if the new one should be encrypted, but in any case, we can't prefill
                        // the password box
                        EncryptedVisiblePassword = IsPasswordEncrypted(OldCredential->CredentialBlob,
                                                                       OldCredential->CredentialBlobSize);
                        PasswordState = PASSWORD_CHANGED;
                    }
                    else
                    {
                        // If prompt is required now, or if we're rerturning the password, then we can't prefill the
                        // password box:
                        fInitialSaveState = TRUE;

                        if (OldCredential->Flags & CRED_FLAGS_PROMPT_NOW || DelayCredentialWrite )
                        {
                            PasswordState = PASSWORD_CHANGED;
                        }
                        else
                        {
                            lstrcpyn(Password,
                                     CreduiKnownPassword,
                                     PasswordMaxChars + 1);
                        }
                    }

                }
            }
        }
        else
        {
            if (Result != ERROR_NO_SUCH_LOGON_SESSION)
            {
                Result = ERROR_SUCCESS;
            }

            OldCredential = NULL;

            SetCredTargetFromInfo();


            PasswordState = PASSWORD_CHANGED;
        }

        NewCredential.UserName = UserName;
        NewCredential.CredentialBlob = reinterpret_cast<BYTE *>(Password);

        //
        // Since the old cred is an SSO cred,
        //  use the SSO maximum persistence.
        //
        // Wait till now since NewCredential.Type is updated from either the old credential
        //  or from the target info above.
        //
        // BUGBUG: If there is no old credential or target info,
        //  we won't know this until later.
        //
        if ( NewCredential.Type == CRED_TYPE_DOMAIN_VISIBLE_PASSWORD ) {
            MaximumPersist = MaximumPersistSso;
        }

        //
        // If the session type isn't supported on this machine,
        //  fail if the caller needs to save the credential.
        //

        if ( MaximumPersist == CRED_PERSIST_NONE ) {
            if ( DelayCredentialWrite )
            {
                // no credmgr available, and user asked to persist.  We can't persist, but we
                // can continue with UI and return values via the api - add CREDUI_FLAGS_DO_NOT_PERSIST
                Flags |= CREDUI_FLAGS_DO_NOT_PERSIST;

            }
            else
            {
                // we can't do anything without credmgr, return error
                if ( result != NULL )
                    *result = ERROR_NO_SUCH_LOGON_SESSION;
                return;
            }
        }
    }

    //
    // If the cred may not be persisted,
    //  clear the NewCredential.
    //

    if ( Flags & CREDUI_FLAGS_DO_NOT_PERSIST)
    {
        // NEED TO Initialize NewCred here
        ZeroMemory(&NewCredential, sizeof NewCredential);

        SetCredTargetFromInfo();
        PasswordState = PASSWORD_CHANGED;
        NewCredential.UserName = UserName;
        NewCredential.CredentialBlob = reinterpret_cast<BYTE *>(Password);



        Result = ERROR_SUCCESS;
    }

    if (Result == ERROR_SUCCESS)
    {
        HWND parentWindow = UiInfo.hwndParent;
        CreduiIconParentWindow iconWindow;

        if ((parentWindow == NULL) || !IsWindow(parentWindow))
        {
            if (iconWindow.Init(CreduiInstance, IDI_DEFAULT))
            {
                parentWindow = iconWindow.GetWindow();
            }
        }

        BOOL doPasswordDialog = TRUE;

        // Before doing the dialog, check for special errors:

        if ( CredCategory == DOMAIN_CATEGORY &&
             !DoingCommandLine &&
             CREDUIP_IS_EXPIRED_ERROR( authError ) &&
            (OldCredential != NULL))
        {
            if (CreduiChangeDomainPassword(
                    parentWindow,
                    UserName,
                    Password,
                    PasswordMaxChars))
            {
                doPasswordDialog = FALSE;

                // Attempt to write the new credential, first get the length.
                // The blob does not include the terminating NULL:

                NewCredential.CredentialBlobSize =
                    lstrlen(Password) * sizeof (WCHAR);

                // If the password is empty, do not write a credential blob:

                if (NewCredential.CredentialBlobSize == 0)
                {
                    NewCredential.CredentialBlob = NULL;
                }
                else
                {
                    NewCredential.CredentialBlob =
                        reinterpret_cast<BYTE *>(Password);
                }

                Result = FinishHandleOk();
            }
        }

        // Check to see if we can skip the UI:

        if ( CredCategory == GENERIC_CATEGORY &&
            !(Flags & CREDUI_FLAGS_ALWAYS_SHOW_UI) &&
            (OldCredential != NULL) &&
            !(OldCredential->Flags & CRED_FLAGS_PROMPT_NOW))
        {
            doPasswordDialog = FALSE;

            if ((Flags & CREDUI_FLAGS_REQUIRE_CERTIFICATE) &&
                !LocalCredIsMarshaledCredentialW(OldCredential->UserName))
            {
                doPasswordDialog = TRUE;
            }

            if ((Flags & CREDUI_FLAGS_EXCLUDE_CERTIFICATES) &&
                LocalCredIsMarshaledCredentialW(OldCredential->UserName))
            {
                doPasswordDialog = TRUE;
            }
        }

        // Do the dialog box:

        // check to see if this is an SSO cred
        if ( GetSSOPackageInfo( TargetInfo, &SSOPackage ) )
        {
            // it's an sso cred
            dwIDDResource = IDD_BRANDEDPASSWORD;

            // we never set initial save state on these
            fInitialSaveState = FALSE;

            // check to see if we already have a cred for this
            if (!CheckForSSOCred( NULL ))
            {


                // check to see if we should run the wizard
                if ( !(SSOPackage.dwRegistrationCompleted) && (SSOPackage.dwNumRegistrationRuns < 5) )
                {


                    doPasswordDialog = !TryLauchRegWizard ( &SSOPackage, UiInfo.hwndParent, (MaximumPersistSso > CRED_PERSIST_SESSION),
                                                           userName, userNameMaxChars,
                                                           password, passwordMaxChars,
                                                           &Result );

                }
            }
        }
        else
        {

            // it's not an sso cred
           dwIDDResource = IDD_PASSWORD;
        }


        // save a copy of the current working user name for later
        if (NewCredential.UserName != NULL)
        {
            wcscpy(OldUserName,NewCredential.UserName);
        }
        else
        {
            OldUserName[0] = 0;
        }

        if (doPasswordDialog)
        {
            if ( DoingCommandLine ) 
            {

                //
                // Do the command line version of a dialog box
                //

                Result = CmdLineDialog();

            } 
            else 
            {
       	        LinkWindow_RegisterClass();
                if (DialogBoxParam(
                        CreduiInstance,
                        MAKEINTRESOURCE(dwIDDResource),
                        parentWindow,
                        DialogMessageHandlerCallback,
                        reinterpret_cast<LPARAM>(this)) == IDOK)
                {
                    if ((Result != ERROR_SUCCESS) &&
                        (Result != ERROR_NO_SUCH_LOGON_SESSION))
                    {
                        Result = ERROR_CANCELLED;
                    }
                }
                else
                {
                    Result = ERROR_CANCELLED;
                }
            }
        }

    }
    else
    {
        Result = ERROR_NO_SUCH_LOGON_SESSION;
    }

    // kill outbound username if share-level access
    if (fPasswordOnly)
    {
        CreduiDebugLog("CUIPD: Share level credentials\n");
        userName[0] = 0;
    }

    // Make sure other processes can set foreground window once again:

    LockSetForegroundWindow(LSFW_UNLOCK);
    AllowSetForegroundWindow(ASFW_ANY);

    if (TargetInfo != NULL)
    {
        LocalCredFree(static_cast<VOID *>(TargetInfo));
    }

    // If we read a credential set, PasswordCredential
    // is a pointer into this set. Otherwise, they were
    // read separately:

    if (credentialSet != NULL)
    {
        LocalCredFree(static_cast<VOID *>(credentialSet));
    }
    else
    {
        if (PasswordCredential != NULL)
        {
            LocalCredFree(static_cast<VOID *>(PasswordCredential));
        }

    }

    if ( result != NULL )
        *result = Result;

    if ( save != NULL &&
        (Result == ERROR_SUCCESS))
    {
        *save = Save;
    }
}

//=============================================================================
// CreduiPasswordDialog::~CreduiPasswordDialog
//
// The constructor cleans up after itself, and since that is the only way to
// use this class, there's nothing to do in the destructor.
//
// Created 02/25/2000 johnstep (John Stephens)
//=============================================================================

CreduiPasswordDialog::~CreduiPasswordDialog()
{
    WCHAR ClassName[] = {L"CreduiCmdLineHelperWindow"};
    LONG lRet;
    
    if ( hBrandBmp != NULL )
        DeleteObject ( hBrandBmp );
    
    // If 'Registered' is nonzero, unregister the class
    if (InterlockedCompareExchange(&Registered, FALSE, TRUE))
    {
        lRet = UnregisterClass(ClassName, 0);
        // Put the class handle back if deregister failed
        if (0 == lRet) 
        {
            // If the unregister fails, allow other instances to retry the unregister
            CreduiDebugLog( "CreduiPasswordDialog::~CreduiPasswordDialog UnregisterClass failed.\n" );
            // put back the flag value that we had destroyed
            InterlockedExchange(&Registered,TRUE);
        }
    }
}


#define MAX_TEMP_TARGETNAME  64


DWORD
CreduiPasswordDialog::CmdLineDialog(
    VOID
)
/*++

Routine Description:

    This routine implements the command line prompt for credentials

Arguments:

    None
Return Values:

    Win 32 status of the operation

--*/
{
    DWORD WinStatus;
    HWND Window;
    MSG msg;


    //
    // Create the window class if it doesn't already exist
    //
    if (!InterlockedCompareExchange(&Registered, TRUE, FALSE))
    {
        WNDCLASS windowClass;

        ZeroMemory(&windowClass, sizeof windowClass);

        windowClass.style = CS_GLOBALCLASS;
        windowClass.cbWndExtra = 0;
        windowClass.lpfnWndProc = CmdLineMessageHandlerCallback;
        windowClass.hInstance = CreduiInstance;
        windowClass.hIcon = NULL;
        windowClass.hCursor = LoadCursor(NULL, MAKEINTRESOURCE(IDC_ARROW));
        windowClass.lpszClassName = L"CreduiCmdLineHelperWindow";

        InterlockedExchange(&Registered, RegisterClass(&windowClass) != 0);

        if (!InterlockedCompareExchange(&Registered, FALSE, FALSE)) 
        {
            WinStatus = GetLastError();
            goto Cleanup;
        }
    }

    //
    // Create a window of that class
    //

    Window = CreateWindow(
        L"CreduiCmdLineHelperWindow",
        NULL,
        WS_POPUP,
        0, 0, 0, 0,
        NULL, NULL, CreduiInstance,(LPVOID) this);

    if ( Window == NULL ) 
    {
        WinStatus = GetLastError();
        goto Cleanup;
    }

    //
    // Run the message loop
    //


    CreduiDebugLog( "Entering message loop\n" );
    for (;;) {
        BOOL GmStatus;

        GmStatus = GetMessage(&msg, NULL, 0, 0 );

        if ( GmStatus == -1 ) 
        {
            WinStatus = GetLastError();
            break;
        } 
        else if ( GmStatus == 0 ) 
        {
            WinStatus = Result;
            break;
        }

        DispatchMessage(&msg);
    }

    //
    // Get the status left from the message loop.

    WinStatus = (DWORD) msg.wParam;
    CreduiDebugLog( "Got Quit Message: %ld\n", WinStatus );

    //
    // Process the data as though the user hit OK to the GUI
    //

    if ( WinStatus == NO_ERROR ) {

        PasswordState = PASSWORD_CHANGED;

        WinStatus = HandleOk();

        if ( WinStatus == ERROR_NO_SUCH_LOGON_SESSION) 
        {
            WinStatus = ERROR_CANCELLED;
        }
    }

    CreduiDebugLog( "Calling destroy\n" );
    DestroyWindow( Window );

Cleanup:
    return WinStatus;
}

//=============================================================================
// CreduiPasswordDialog::FinishHandleOk
//
// This function writes the credential for domain credentials.
//
// Created 04/09/2000 johnstep (John Stephens)
//=============================================================================

DWORD
CreduiPasswordDialog::FinishHandleOk()
{

    DWORD error = ERROR_SUCCESS;
    PCREDENTIAL_TARGET_INFORMATION pTargetInfo = TargetInfo;

    if (Flags & CREDUI_FLAGS_KEEP_USERNAME )
        return error;

    DWORD dwCredWriteFlags = 0;
    BOOL bDoSave = TRUE;

    if (PasswordState == PASSWORD_INIT)
    {
        dwCredWriteFlags |= CRED_PRESERVE_CREDENTIAL_BLOB;
    }


    if ( dwIDDResource == IDD_BRANDEDPASSWORD )
    {
        // we need to reinterpret what Save means.  Save in this case means to save as the default
        // for the SSO realm, while !Save means rename the cred target as the username and
        // save without the password

        // never delay writing these creds
        DelayCredentialWrite = FALSE;

        if ( Save )
        {
            NewCredential.Persist = CRED_PERSIST_ENTERPRISE;
            if ( !(Flags & CREDUI_FLAGS_KEEP_USERNAME ))
                DemoteOldDefaultSSOCred ( TargetInfo, Flags );
        }
        else
        {
            // save this under the username if it doesn't already match NewCred's username

            if ( (OldCredential != NULL && OldCredential->UserName != NULL &&
                _wcsicmp ( OldCredential->UserName, UserName ) == 0 )||
                (Flags & CREDUI_FLAGS_KEEP_USERNAME ) )
            {
                // don't do this save if the username matches the currently saved cred - we don't want a duplicate
                bDoSave = FALSE;
            }

            // alter the TargetName
            TargetName = UserName;
            TargetInfo->TargetName = TargetName;

            // don't set a TargetInfo for this
            pTargetInfo = NULL;

            NewCredential.Persist = CRED_PERSIST_ENTERPRISE;
            NewCredential.CredentialBlob = NULL;
            NewCredential.CredentialBlobSize = 0;
            NewCredential.TargetName = TargetName;
            NewCredential.Flags = CRED_FLAGS_USERNAME_TARGET;

            DelayCredentialWrite = FALSE;
            EncryptedVisiblePassword = FALSE;
            dwCredWriteFlags = 0;

        }

    }


    //
    // Write the credential to credential manager
    //
    //  Don't delay actually writing the credential to cred man since we're not
    //  returning the credential to the caller.
    //

    if ( bDoSave )
    {
        error = WriteCred( TargetName,
                            Flags,
                            pTargetInfo,
                            &NewCredential,
                            dwCredWriteFlags,
                            DelayCredentialWrite,
                            EncryptedVisiblePassword);
    }
    else
    {
        error = ERROR_SUCCESS;
    }

    if ( error != NO_ERROR ) {
        CreduiDebugLog("CreduiPasswordDialog::HandleOk: "
                       "WriteCred failed: "
                       "%u\n", error);
    }

    if ((SecurityContext != NULL) && (error == ERROR_SUCCESS))
    {
        BOOL isValidated = TRUE;

        if (!SetContextAttributes(
                SecurityContext,
                SECPKG_ATTR_USE_VALIDATED,
                &isValidated,
                sizeof isValidated))
        {
            error = ERROR_GEN_FAILURE;
        }
    }

    // Clear any password from memory, and also make sure the credential blob
    // points to Password once again (in case it was set to NULL due to a zero
    // length blob):

    NewCredential.CredentialBlob = reinterpret_cast<BYTE *>(Password);
    NewCredential.CredentialBlobSize = 0;

    return error;
}

//=============================================================================
// CreduiPasswordDialog::Enable
//
// Enables or disables all the user controls in the dialog box. This allows us
// to maintain dialog responsiveness, while waiting for some potentially
// lengthy (network usually) operation to complete.
//
// Most controls are always enabled normally, but we need to track the state
// of IDC_CRED and IDOK. Do this with a simple DWORD bitmask.
//
// NOTE: Allow Cancel to remain enabled, and use it to abort the current
//       lookup? This means we have to somehow kill the thread, though, or
//       maybe just leave it, and close our handle to it?
//
// Arguments:
//   enable (in) - TRUE to enable the controls, FALSE to disable.
//
// Created 04/07/2000 johnstep (John Stephens)
//=============================================================================

VOID
CreduiPasswordDialog::Enable(
    BOOL enable
    )
{
    if (enable && (DisabledControlMask & DISABLED_DIALOG))
    {
        DisabledControlMask &= ~DISABLED_DIALOG;

        EnableWindow(CredControlWindow, TRUE);
        if ( DialogWindow) {
            EnableWindow(GetDlgItem(DialogWindow, IDCANCEL), TRUE);

            if (!(DisabledControlMask & DISABLED_CONTROL_OK))
            {
                EnableWindow(GetDlgItem(DialogWindow, IDOK), TRUE);
            }
        }
    }
    else if (!(DisabledControlMask & DISABLED_DIALOG))
    {
        // Hide the balloon tip before disabling the window:

        DisabledControlMask |= DISABLED_DIALOG;

        EnableWindow(CredControlWindow, FALSE);
        if ( DialogWindow ) {

            EnableWindow(GetDlgItem(DialogWindow, IDCANCEL), FALSE);
            EnableWindow(GetDlgItem(DialogWindow, IDOK), FALSE);
        }
    }
}

//=============================================================================
// CreduiPasswordDialog::SelectAndSetWindowCaption
//
// Created 03/10/2000 johnstep (John Stephens)
//=============================================================================

VOID
CreduiPasswordDialog::SelectAndSetWindowCaption()
{

    //
    // Command line doesn't have a caption
    //
    if ( !DialogWindow ) {
        return;
    }
    if (UiInfo.pszCaptionText != NULL)
    {

        SetWindowText(DialogWindow, UiInfo.pszCaptionText);
    }
    else
    {
        WCHAR captionText[256];
        captionText[255] = L'\0';

        if ( CredCategory == DOMAIN_CATEGORY )
        {
            if (TargetInfo != NULL)
            {
                if ((TargetInfo->DnsServerName != NULL) ||
                    (TargetInfo->NetbiosServerName == NULL))
                {
                    _snwprintf(captionText, 255,
                               CreduiStrings.DnsCaption,
                               (TargetInfo->DnsServerName != NULL) ?
                                   TargetInfo->DnsServerName :
                                   TargetInfo->TargetName);
                }
                else if ((TargetInfo->NetbiosServerName != NULL) &&
                         (TargetInfo->NetbiosDomainName != NULL))
                {
                    _snwprintf(captionText, 255,
                               CreduiStrings.NetbiosCaption,
                               TargetInfo->NetbiosServerName,
                               TargetInfo->NetbiosDomainName);
                }
                else
                {
                    _snwprintf(captionText, 255,
                               CreduiStrings.DnsCaption, TargetName);
                }
            }
            else
            {
                _snwprintf(captionText, 255,
                           CreduiStrings.DnsCaption, TargetName);
            }
        }
        else
        {

            _snwprintf(captionText, 255,
                       CreduiStrings.GenericCaption, TargetName);
        }


        SetWindowText(DialogWindow, captionText);
    }
}

//=============================================================================
// CreduiPasswordDialog::ResizeDialogCallback
//
// Created 04/12/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CALLBACK
CreduiPasswordDialog::ResizeDialogCallback(
    HWND childWindow,
    LPARAM lParam
    )
{
    CreduiPasswordDialog *that =
        reinterpret_cast<CreduiPasswordDialog *>(lParam);

    ASSERT(that != NULL);

    //
    // Command line doesn't care about window size
    //

    if ( that->DoingCommandLine ) {
        return TRUE;
    }


    HWND dialogWindow = GetParent(childWindow);

    if (dialogWindow == NULL)
    {
        // Stop enumeration because our window must have been destroyed or
        // something:

        return FALSE;
    }
    else if (dialogWindow == that->DialogWindow)
    {
        RECT childRect;

        GetWindowRect(childWindow, &childRect);

        // If this child window is below the message window, move it down:

        if (childRect.top >= that->ResizeTop)
        {
            MapWindowPoints ( NULL, dialogWindow,
                                reinterpret_cast<POINT *>(&childRect.left), 2 );

            SetWindowPos(childWindow,
                         NULL,
                         childRect.left,
                         childRect.top + that->ResizeDelta,
                         0,
                         0,
                         SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOOWNERZORDER |
                            SWP_NOZORDER);
        }
    }

    return TRUE;
}

//=============================================================================
// CreduiPasswordDialog::SelectAndSetWindowMessage
//
// This function will also resize the dialog to accomodate very long message
// text. The maximum number of lines allowed at once is
// CREDUI_MAX_WELCOME_TEXT_LINES, and, beyond that, a scrollbar is added.
//
// Created 03/10/2000 johnstep (John Stephens)
//=============================================================================

VOID
CreduiPasswordDialog::SelectAndSetWindowMessage()
{
    HWND welcomeTextWindow = GetDlgItem(DialogWindow, IDC_WELCOME_TEXT);

    //
    // Command line doesn't have welcome text
    //

    if ( DoingCommandLine ) {
        return;
    }


    ASSERT(welcomeTextWindow != NULL);

    if (UiInfo.pszMessageText != NULL)
    {
        SetWindowText(welcomeTextWindow, UiInfo.pszMessageText);
    }
    else
    {
        WCHAR messageText[256];
        messageText[255] = L'\0';

        if ( CredCategory == GENERIC_CATEGORY )
        {
            if (UserName[0] == L'\0')
            {
                _snwprintf(messageText, 255,
                           CreduiStrings.Welcome, TargetName);
            }
            else
            {
                _snwprintf(messageText, 255,
                          CreduiStrings.WelcomeBack, TargetName);
            }
        }
        else
        {
            _snwprintf(messageText, 255,
                       CreduiStrings.Connecting, TargetName);
        }

        SetWindowText(welcomeTextWindow, messageText);
    }

    ULONG lineCount = (ULONG) SendMessage(welcomeTextWindow,
                                          EM_GETLINECOUNT,
                                          0,
                                          0);
    if (lineCount > 1)
    {
        if ( dwIDDResource == IDD_BRANDEDPASSWORD )
        {
            // Different layout (text to side of graphic)
            RECT messageRect;         // RECT for welcomeTextWindow
            ULONG lineHeight = 13;    // Height of line in welcomeTextWindow
            DWORD lineIndex = 0;      // Character index of first char in second line of welcomeTextWindow
            DWORD linePos = 0;        // Position of first char in second line of welcomeTextWindow

            GetWindowRect(welcomeTextWindow, &messageRect);

            // We don't want to resize anything for the branded password dialog
            ResizeDelta = 0;
            ResizeTop = messageRect.bottom;

            // Get the first character index of the second line
            lineIndex = (DWORD)SendMessage(welcomeTextWindow, EM_LINEINDEX, 1, 0);
            if (lineIndex > -1)
            {
                // Get the position of the first character of the second line
                linePos = (ULONG)SendMessage(welcomeTextWindow, EM_POSFROMCHAR, lineIndex, 0);

                if (linePos)
                {
                    // This is our line height
                    lineHeight = (ULONG)HIWORD(linePos);
                }
            }

            if ((lineCount * lineHeight) > CREDUI_MAX_LOGO_HEIGHT)
            {
                // Add the scrollbar. Consider adjusting the formatting rectangle
                // of the edit control because, by default, it is adjusted to
                // allow just exactly enough room for the scrollbar. This means
                // text could potentially "touch" the scrollbar, which would look
                // bad.

                LONG_PTR style = GetWindowLongPtr(welcomeTextWindow, GWL_STYLE);

                SetWindowLongPtr(welcomeTextWindow,
                                 GWL_STYLE,
                                 style |= WS_VSCROLL);
            }

            SetWindowPos(welcomeTextWindow,
                         NULL,
                         0,
                         0,
                         messageRect.right - messageRect.left,
                         messageRect.bottom - messageRect.top,
                         SWP_FRAMECHANGED | SWP_NOACTIVATE | SWP_NOMOVE |
                             SWP_NOOWNERZORDER | SWP_NOZORDER);


        }
        else
        {
            // normal layout (text below graphic)
            RECT messageRect;

            GetWindowRect(welcomeTextWindow, &messageRect);

            ULONG lineHeight = messageRect.bottom - messageRect.top;

            ResizeTop = messageRect.bottom;
            ResizeDelta = lineHeight *
                          (min(CREDUI_MAX_WELCOME_TEXT_LINES, lineCount) - 1);

            messageRect.bottom += ResizeDelta;

            if (lineCount > CREDUI_MAX_WELCOME_TEXT_LINES)
            {
                // Add the scrollbar. Consider adjusting the formatting rectangle
                // of the edit control because, by default, it is adjusted to
                // allow just exactly enough room for the scrollbar. This means
                // text could potentially "touch" the scrollbar, which would look
                // bad.

                LONG_PTR style = GetWindowLongPtr(welcomeTextWindow, GWL_STYLE);

                SetWindowLongPtr(welcomeTextWindow,
                                 GWL_STYLE,
                                 style |= WS_VSCROLL);
            }

            SetWindowPos(welcomeTextWindow,
                         NULL,
                         0,
                         0,
                         messageRect.right - messageRect.left,
                         messageRect.bottom - messageRect.top,
                         SWP_FRAMECHANGED | SWP_NOACTIVATE | SWP_NOMOVE |
                             SWP_NOOWNERZORDER | SWP_NOZORDER);

        }

        // Reposition all the other controls:

        EnumChildWindows(DialogWindow,
                         ResizeDialogCallback,
                         reinterpret_cast<LPARAM>(this));

        // Resize the dialog box now
        RECT dialogRect;

        GetWindowRect(DialogWindow, &dialogRect);

        SetWindowPos(DialogWindow,
                      NULL,
                      dialogRect.left,
                      dialogRect.top - (ResizeDelta / 2),
                      dialogRect.right - dialogRect.left,
                      (dialogRect.bottom - dialogRect.top) + ResizeDelta,
                      SWP_NOACTIVATE | SWP_NOOWNERZORDER | SWP_NOZORDER);

        ResizeTop = 0;
        ResizeDelta = 0;
    }
}

//=============================================================================
// CreduiPasswordDialog::InitWindow
//
// Created 02/25/2000 johnstep (John Stephens)
//
// Initialize the window
//
// dialogWindow - Window handle
//=============================================================================

BOOL
CreduiPasswordDialog::InitWindow(HWND dialogWindow)
{


    //
    // Store this object's pointer in the user data window long:
    //

    SetWindowLongPtr(dialogWindow,
                     GWLP_USERDATA,
                     reinterpret_cast<LONG_PTR>(this));

    //
    // In the GUI case, remember the dialog box window
    //

    if ( !DoingCommandLine ) {
        DialogWindow = dialogWindow;

        // Get the window handles for the various controls:

        CredControlWindow = GetDlgItem(DialogWindow, IDC_CRED);

    //
    // In the command line case, remember the popup window
    //

    } else {
        CmdLineWindow = dialogWindow;

        //
        // Create a CredControlWindow
        //  It isn't visible, but the existence of the window allows the command line
        //  code to share logic with the GUI implementation
        //

        CredControlWindow =
            CreateWindowEx(
                WS_EX_NOPARENTNOTIFY,
                WC_CREDENTIAL,
                NULL,           // No window name
                WS_CHILD | WS_GROUP,
                0, 0, 0, 0,     // No coordinates on the screen
                CmdLineWindow,  // Parent window
                NULL,           // No menu window
                CreduiInstance,
                NULL);

        if ( CredControlWindow == NULL) {
            return FALSE;
        }
    }

    ASSERT(CredControlWindow != NULL);

    //
    // First, initialize the Credential control window:
    //
    // Set the default style
    //


    if (Flags & CREDUI_FLAGS_REQUIRE_SMARTCARD)
    {
        CredControlStyle = CRS_SMARTCARDS;
    }
    else if (Flags & CREDUI_FLAGS_REQUIRE_CERTIFICATE)
    {
        CredControlStyle = CRS_CERTIFICATES | CRS_SMARTCARDS;
    }
    else if (Flags & CREDUI_FLAGS_EXCLUDE_CERTIFICATES)
    {
        CredControlStyle = CRS_USERNAMES;
    }
    else
    {
        CredControlStyle = CRS_USERNAMES | CRS_CERTIFICATES | CRS_SMARTCARDS;
    }

    if (Flags & CREDUI_FLAGS_KEEP_USERNAME )
    {
        CredControlStyle |= CRS_KEEPUSERNAME;
    }


    //
    // If we have a target info,
    //  refine the style to match match what the auth package needs
    //
    // If the auth package has no opinion of its needs, allow everything.
    //
    if ( CredCategory == DOMAIN_CATEGORY &&
        TargetInfo != NULL &&
        TargetInfo->CredTypeCount != 0 )
    {
        ULONG AuthPackageStyle;
        AuthPackageStyle = 0;

        //
        // Loop through the supported cred types seeing what style the auth package supports
        //

        for (UINT i = 0; i < TargetInfo->CredTypeCount; ++i)
        {
            switch ( TargetInfo->CredTypes[i] ) {
            case CRED_TYPE_DOMAIN_CERTIFICATE:
                AuthPackageStyle |= CRS_CERTIFICATES | CRS_SMARTCARDS;
                break;
            case CRED_TYPE_DOMAIN_PASSWORD:
            case CRED_TYPE_DOMAIN_VISIBLE_PASSWORD:
                AuthPackageStyle |= CRS_USERNAMES;
                break;
            }

        }

        CredControlStyle &= (AuthPackageStyle | CRS_KEEPUSERNAME );
        ASSERT( CredControlStyle != 0);

    }

    //
    // If the caller wants only administrators,
    //  include that request in the style.
    //

    if (Flags & CREDUI_FLAGS_REQUEST_ADMINISTRATOR)
    {
        CredControlStyle |= CRS_ADMINISTRATORS;
    }


    //
    // If the caller asked to see the save checkbox,
    //  and we're running in a session that supports saving,
    //  include the save checkbox in the style

    if ( (Flags & (CREDUI_FLAGS_DO_NOT_PERSIST|CREDUI_FLAGS_PERSIST)) == 0 &&
         !(Flags & CREDUI_FLAGS_KEEP_USERNAME ) &&
         MaximumPersist != CRED_PERSIST_NONE )
    {
        CredControlStyle |= CRS_SAVECHECK;

    //
    // If the caller wants us to prompt for saving and return the result to him,
    //  include the save checkbox in the style
    //
    }
    else if ( (Flags & (CREDUI_FLAGS_DO_NOT_PERSIST|CREDUI_FLAGS_SHOW_SAVE_CHECK_BOX)) ==
                       (CREDUI_FLAGS_DO_NOT_PERSIST|CREDUI_FLAGS_SHOW_SAVE_CHECK_BOX) &&
                       !(Flags & CREDUI_FLAGS_KEEP_USERNAME ))
    {
        CredControlStyle |= CRS_SAVECHECK;
    }

    //
    // If we're not displaying the save checkbox,
    //  adust the size of the dialog box.
    //

    if ( (CredControlStyle & CRS_SAVECHECK) == 0 &&
         DialogWindow != NULL ) {


        RECT rect;
        SetRect(&rect, 0, 0, 0, 0);

        rect.bottom = CREDUI_CONTROL_ADD_SAVE;

        MapDialogRect(DialogWindow, &rect);
        ResizeDelta = -rect.bottom;

        GetWindowRect(CredControlWindow, &rect);
        ResizeTop = rect.bottom;

        // Reposition all the other controls:

        EnumChildWindows(DialogWindow,
                         ResizeDialogCallback,
                         reinterpret_cast<LPARAM>(this));

        // Resize the dialog box now:

        GetWindowRect(DialogWindow, &rect);

        SetWindowPos(DialogWindow,
                     NULL,
                     rect.left,
                     rect.top - (ResizeDelta / 2),
                     rect.right - rect.left,
                     (rect.bottom - rect.top) + ResizeDelta,
                     SWP_NOACTIVATE | SWP_NOOWNERZORDER | SWP_NOZORDER);


        GetClientRect(CredControlWindow, &rect);

        SetWindowPos(CredControlWindow,
                     NULL,
                     0,
                     0,
                     rect.right - rect.left,
                     (rect.bottom - rect.top) + ResizeDelta,
                     SWP_NOMOVE | SWP_NOACTIVATE |
                     SWP_NOOWNERZORDER | SWP_NOZORDER);

        ResizeTop = 0;
        ResizeDelta = 0;

    }


if ( dwIDDResource == IDD_BRANDEDPASSWORD )
    {
        // size the parts of the brand
        RECT rect;
        RECT rectleft;
        RECT rectright;
        RECT rectmid;
        HWND hwndRight = GetDlgItem(DialogWindow, IDC_BRANDRIGHT);
        HWND hwndMid = GetDlgItem(DialogWindow, IDC_BRANDMID);
        HWND hwndLeft = GetDlgItem(DialogWindow, IDC_BRANDLEFT);
        HBITMAP hBmp;

        GetWindowRect(hwndRight, &rect);

        // Load the images from files
        // We can't load them in the .rc because then we lose transparency
        hBmp = (HBITMAP)LoadImage(CreduiInstance, MAKEINTRESOURCE(IDB_BRANDRIGHT), IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION); 
        if (hBmp)
        {
            SendMessage(hwndRight, STM_SETIMAGE, (WPARAM)IMAGE_BITMAP, (LPARAM)hBmp);
        }
        
        hBmp = (HBITMAP)LoadImage(CreduiInstance, MAKEINTRESOURCE(IDB_BRANDMID), IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);
        if (hBmp)
        {
            if (hwndMid)
            {
                SendMessage(hwndMid, STM_SETIMAGE, (WPARAM)IMAGE_BITMAP, (LPARAM)hBmp);
            }
        }

        hBmp = (HBITMAP)LoadImage(CreduiInstance, MAKEINTRESOURCE(IDB_BRANDLEFT), IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);
        if (hBmp)
        {
            if (hwndLeft)
            {
                SendMessage(hwndLeft, STM_SETIMAGE, (WPARAM)IMAGE_BITMAP, (LPARAM)hBmp);
            }
        }

        rectright.bottom = rect.bottom;
        rectright.top = rect.bottom - BRANDRIGHT_PIXEL_HEIGHT;
        rectright.right = rect.right;
        rectright.left = rect.right - BRANDRIGHT_PIXEL_WIDTH;

        rectleft.bottom = rect.bottom;
        rectleft.top = rect.bottom - BRANDLEFT_PIXEL_HEIGHT;
        rectleft.left = rect.left;
        rectleft.right = rect.left + BRANDLEFT_PIXEL_WIDTH;

        MapWindowPoints(NULL, DialogWindow, (LPPOINT)&rectleft, 2);
        MapWindowPoints(NULL, DialogWindow, (LPPOINT)&rectright, 2);

        if ( rectleft.right >= rectright.left )
        {
            // dialog is really narrow, just use rectright

            // hide the other two
            ShowWindow ( hwndMid, SW_HIDE );
            ShowWindow ( hwndLeft, SW_HIDE );

        }
        else
        {

            // calculate rectmid
            rectmid.bottom = rectleft.bottom;
            rectmid.top = rectleft.bottom - BRANDMID_PIXEL_HEIGHT;
            rectmid.left = rectleft.right;
            rectmid.right = rectright.left;

            // No need to MapWindowsPoints for rectmid, since it's base off of the already-mapped rects.
            SetWindowPos(hwndMid,
                         NULL,
                         rectmid.left,
                         rectmid.top,
                         rectmid.right - rectmid.left,
                         rectmid.bottom - rectmid.top,
                         SWP_NOACTIVATE | SWP_NOOWNERZORDER |
                            SWP_NOZORDER);

            SetWindowPos(hwndLeft,
                         NULL,
                         rectleft.left,
                         rectleft.top,
                         rectleft.right - rectleft.left,
                         rectleft.bottom - rectleft.top,
                         SWP_NOACTIVATE | SWP_NOOWNERZORDER |
                            SWP_NOZORDER);

        }


        SetWindowPos(hwndRight,
                     NULL,
                     rectright.left,
                     rectright.top,
                     rectright.right - rectright.left,
                     rectright.bottom - rectright.top,
                     SWP_NOACTIVATE | SWP_NOOWNERZORDER |
                        SWP_NOZORDER);



    }

    //
    // Tell the control window the style flags and whether we're doing command line
    //
    if (!SendMessage(CredControlWindow, CRM_INITSTYLE, (WPARAM)(CredControlStyle), DoingCommandLine ) )
    {
        return FALSE;
    }

    // If a custom banner bitmap was provided, set it now, and free the
    // default bitmap:

    if ( DialogWindow != NULL && UiInfo.hbmBanner != NULL)
    {
        HWND bannerControlWindow = GetDlgItem(DialogWindow, IDC_BANNER);

        ASSERT(bannerControlWindow != NULL);

        HBITMAP oldBitmap =
            reinterpret_cast<HBITMAP>(
                SendMessage(
                    bannerControlWindow,
                    STM_SETIMAGE,
                    IMAGE_BITMAP,
                    reinterpret_cast<LPARAM>(UiInfo.hbmBanner)));

        ASSERT(oldBitmap != NULL);

        DeleteObject(static_cast<HGDIOBJ>(oldBitmap));
    }
    else if ( DialogWindow != NULL && dwIDDResource == IDD_BRANDEDPASSWORD )
    {
        // if it's branded and there's no banner, hide the banner control
        HWND bannerControlWindow = GetDlgItem(DialogWindow, IDC_BANNER);

        if (bannerControlWindow != NULL)
        {
            ShowWindow ( bannerControlWindow, SW_HIDE );
        }

    }

    // Limit the number of characters entered into the user name and password
    // edit controls:
    Credential_SetUserNameMaxChars(CredControlWindow, UserNameMaxChars);
    Credential_SetPasswordMaxChars(CredControlWindow, PasswordMaxChars);

    SelectAndSetWindowCaption();
    SelectAndSetWindowMessage();

    //
    // Set the default check box states
    //  Default to don't save.  That ensures the user has to take an action to
    //  change global state.
    //
    //
    // If the caller is specifying the default value of the checkbox,
    //  grab that default
    //

    fInitialSaveState = FALSE;


    if (Flags & CREDUI_FLAGS_SHOW_SAVE_CHECK_BOX)
    {

        if (dwIDDResource != IDD_BRANDEDPASSWORD)
        {

            fInitialSaveState = Save;
        }
        else
        {
            fInitialSaveState = FALSE;
        }


    //
    // Only save if credman is available
    //

    } else if ( MaximumPersist != CRED_PERSIST_NONE ) {

        //
        // If the caller is forcing the save flag on,
        //  default the save flag to TRUE.
        //

        if ( Flags & CREDUI_FLAGS_PERSIST ) {
            fInitialSaveState = TRUE;
        }

    }

    Credential_CheckSave(CredControlWindow, fInitialSaveState);

    // Make sure the new password window is the foreground window, if
    // possible:

    if ( DialogWindow != NULL ) {
        AllowSetForegroundWindow(GetCurrentProcessId());
        SetForegroundWindow(DialogWindow);
        AllowSetForegroundWindow(ASFW_ANY);
    }

    // NOTE: Do we really need the guest user name here?

    if ((TargetInfo != NULL) && (UserName[0] == L'\0'))
    {
        if (TargetInfo->Flags & CRED_TI_ONLY_PASSWORD_REQUIRED)
        {
            LPWSTR ServerName = NULL;

            if ( TargetInfo->NetbiosServerName != NULL ) {
                ServerName = TargetInfo->NetbiosServerName;

            } else if ( TargetInfo->DnsServerName != NULL &&
                (TargetInfo->Flags & CRED_TI_SERVER_FORMAT_UNKNOWN) != 0 ) {

                ServerName = TargetInfo->DnsServerName;
            }


            if ( ServerName != NULL )
            {
                LPWSTR GuestName;

                if ( !CreduiLookupLocalNameFromRid( DOMAIN_USER_RID_GUEST, &GuestName ) ) {
                    GuestName = NULL;
                }

                _snwprintf(UserName,
                           CREDUI_MAX_USERNAME_LENGTH,
                           L"%s\\%s",
                           ServerName,
                           GuestName == NULL ? L"Guest" : GuestName );

                if ( GuestName != NULL ) {
                    delete GuestName;
                }

            }
        }
        else
        {
            if ( DialogWindow ) {
                EnableWindow(GetDlgItem(DialogWindow, IDOK), FALSE);
            }
            
            DisabledControlMask |= DISABLED_CONTROL_OK;
        }
    }

    if ((UserName[0] != L'\0') || (Password[0] != L'\0'))
    {
        // If this fails, it may be because the certificate was not found in
        // the store, so if this is a domain credential, use the password one,
        // if available:
        BOOL isMarshaled = LocalCredIsMarshaledCredentialW(UserName);

        if (Credential_SetUserName(CredControlWindow, UserName))
        {
            if (!isMarshaled)
            {
                Credential_SetPassword(CredControlWindow, Password);
            }
            if (TargetInfo)
            {
                if (TargetInfo->Flags & CRED_TI_ONLY_PASSWORD_REQUIRED)
                {
                    Credential_DisableUserName(CredControlWindow);
                    // when disabling the username field, prepare to return no username to the caller
                    if (Flags & CREDUI_FLAGS_PASSWORD_ONLY_OK)
                    {
                        fPasswordOnly = TRUE;
                        CreduiDebugLog("CreduiPasswordDialog::InitWindow - Password only share\n");
                    }
                }
            }
        }
        else
        {
            if ( CredCategory == DOMAIN_CATEGORY &&
                 isMarshaled &&
                 (PasswordCredential != NULL))
            {
                OldCredential = PasswordCredential;

                // Change as little as possible about the new credential
                // because we already selected the target name, etc.:

                if (OldCredential->UserName != NULL)
                {
                    lstrcpyn(UserName,
                             OldCredential->UserName,
                             UserNameMaxChars + 1);
                }
                else
                {
                    UserName[0] = L'\0';
                }

                Password[0] = L'\0';

                Credential_SetPassword(CredControlWindow, Password);
            }
            else
            {
                UserName[0] = L'\0';
                Password[0] = L'\0';
            }
        }

        if (PasswordState == PASSWORD_UNINIT)
        {
            PasswordState = PASSWORD_INIT;
        }

        if (UserName[0] != L'\0')
        {
            Credential_SetPasswordFocus(CredControlWindow);

            if (Flags & CREDUI_FLAGS_INCORRECT_PASSWORD)
            {
                if (CreduiIsCapsLockOn())
                {
                    CredBalloon = &CreduiLogonCapsBalloon;
                }
                else
                {
                    CredBalloon = &CreduiLogonBalloon;
                }
            }
        }
    }


    if (Flags & CREDUI_FLAGS_KEEP_USERNAME )
    {
        // okay button should always be enabled for this case
        EnableWindow(GetDlgItem(DialogWindow, IDOK), TRUE);
        DisabledControlMask &= ~DISABLED_CONTROL_OK;
    }

    return TRUE;
}

//=============================================================================
// CreduiPasswordDialog::CompleteUserName
//
// Searches the user name for a domain name, and determines whether this
// specifies the target server or a domain. If a domain is not present in the
// user name, add it if this is a workstation or no target information is
// available.
//
// Returns TRUE if a domain was already present in the user name, or if we
// added one. Otherwise, return FALSE.
//
// Created 03/10/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiPasswordDialog::CompleteUserName()
{

    return ::CompleteUserName(
                UserName,
                UserNameMaxChars,
                TargetInfo,
                TargetName,
                Flags);

}

//=============================================================================
// CreduiPasswordDialog::SelectBestTargetName
//
// Given TargetInfo, this function determines the most general target name
// possible, and stores the result in NewTargetName. If a target alias is
// available (NetBIOS name for a DNS name), this will be stored in
// NewTargetAlias. If the wildcard won't fit within the required string
// length, then it is not used.
//
// If serverOnly then, use the target information form of the target name,
// with the user-typed name as the alias. If unavailable, just use the user-
// typed form with a NULL alias.
//
// Created 03/10/2000 johnstep (John Stephens)
//=============================================================================

VOID
CreduiPasswordDialog::SelectBestTargetName(
    BOOL serverOnly
    )
{
    NET_API_STATUS NetStatus;

    BOOL usePrefixWildcard = TRUE;
    WCHAR *credName = NULL;
    LPWSTR DomainName = NULL;
    LPWSTR DnsDomainName = NULL;
    LPWSTR DnsForestName = NULL;
    LPWSTR ComputerName = NULL;
    BOOLEAN IsWorkgroupName;
    BOOLEAN AddWildcard = TRUE;

    // If serverOnly is passed, always use the new server-only behavior.
    
    if (serverOnly)
    {
        if (TargetInfo->TargetName != NULL)
        {
            credName = TargetInfo->TargetName;
            NewCredential.TargetAlias = TargetName;
        }
        else
        {
            credName = TargetName;
            NewCredential.TargetAlias = NULL;
        }

        ASSERT(credName != NULL);
        lstrcpyn(NewTargetName, credName, CRED_MAX_STRING_LENGTH);

        return;
    }
    
    // Determine the maximum length name we can use for the wildcard case:

    const ULONG maxChars = ((sizeof NewTargetName) /
                            (sizeof NewTargetName[0])) - 3;

    if (TargetInfo->Flags & CRED_TI_ONLY_PASSWORD_REQUIRED )
    {
        serverOnly = TRUE;
    }

    //
    // If the auth package requires us to create a target info by an explicit name,
    //  only use that name.
    //

    if (    TargetInfo->Flags & CRED_TI_CREATE_EXPLICIT_CRED  )
    {
        credName = TargetInfo->TargetName;
        AddWildcard = FALSE;
    }


    //
    // If this machine is a member of a domain,
    //  and the target machine is a member of the same forest,
    //  and the user is logged onto an account in the forest,
    //  then this prompt must be because of an authorization issue.
    //
    // Avoid this check if a username was passed into the call
    //
    //  Special case this and create a server specific credential
    //
    if ( credName == NULL &&
         !serverOnly &&
         UserName[0] == '\0' ) {

        BOOL MachineInSameForest = FALSE;
        BOOL UserUsingDomainAccount = FALSE;

        //
        // First determine if this machine is in the same forest as the target machine
        //

        NetStatus = NetpGetDomainNameExExEx (
                        &DomainName,
                        &DnsDomainName,
                        &DnsForestName,
                        NULL,   // Don't need the GUID
                        &IsWorkgroupName );

        if ( NetStatus == NO_ERROR &&
             !IsWorkgroupName ) {

            //
            // check if the netbios domain names match
            //

            if ( TargetInfo->NetbiosDomainName != NULL &&
                 DomainName != NULL &&
                 lstrcmpi( TargetInfo->NetbiosDomainName, DomainName ) == 0 ) {

                MachineInSameForest = TRUE;

            //
            // check if the DNS domain names match
            //

            } else if ( TargetInfo->DnsDomainName != NULL &&
                        DnsDomainName != NULL &&
                        lstrcmpi( TargetInfo->DnsDomainName, DnsDomainName ) == 0 ) {

                MachineInSameForest = TRUE;

            //
            // handle the special domain format unknown case
            //

            } else if ( TargetInfo->DnsDomainName != NULL &&
                        DomainName != NULL &&
                        (TargetInfo->Flags & CRED_TI_DOMAIN_FORMAT_UNKNOWN) != 0 &&
                        lstrcmpi( TargetInfo->DnsDomainName, DomainName ) == 0 ) {

                MachineInSameForest = TRUE;

            //
            // handle the forest name
            //  (Too bad this doesn't work for the other trees in the forest.)
            //

            } else if ( TargetInfo->DnsTreeName != NULL &&
                        DnsForestName != NULL &&
                        lstrcmpi( TargetInfo->DnsTreeName, DnsForestName ) == 0 ) {

                MachineInSameForest = TRUE;

            }

        }

        //
        // If this machine and target machine are in the same forest,
        //  see if the user is logged onto an account that should have worked.
        //

        if ( MachineInSameForest ) {
            WCHAR UserNameBuffer[CRED_MAX_USERNAME_LENGTH+1];
            ULONG UserNameLength = CRED_MAX_USERNAME_LENGTH+1;

            if ( GetUserNameEx( NameSamCompatible,
                                UserNameBuffer,
                                &UserNameLength ) ) {

                //
                // Parse off the netbios account domain name
                //

                LPWSTR SlashPointer;

                SlashPointer = wcsrchr( UserNameBuffer, L'\\' );

                if ( SlashPointer != NULL ) {

                    *SlashPointer = '\0';

                    //
                    // Get the computer name of this machine
                    //

                    NetStatus = NetpGetComputerName( &ComputerName );


                    if ( NetStatus == NO_ERROR ) {

                        //
                        // If the netbios account domain doesn't match the local computer name,
                        //  then the user is logged onto an account in the forest.
                        //  Since trust within the forest is transitive,
                        //  these creds should have worked
                        //

                        if ( lstrcmpi( ComputerName, UserNameBuffer ) != 0 ) {
                            UserUsingDomainAccount = TRUE;
                        }
                    }
                }
            }

        }

        //
        // If both conditions are true,
        //  we should create a server only cred.
        //

        if ( MachineInSameForest && UserUsingDomainAccount ) {
            serverOnly = TRUE;
        }

    }


    //
    // Compute the most generic form of the target name
    //
    if ( credName == NULL && !serverOnly)
    {
        // Look for the most general name possible first, selecting DNS over
        // NetBIOS:

        if ((TargetInfo->DnsServerName != NULL) &&
            (TargetInfo->DnsTreeName != NULL) &&
            CreduiIsPostfixString(TargetInfo->DnsServerName,
                                  TargetInfo->DnsTreeName) &&
            (lstrlen(TargetInfo->DnsTreeName) <= maxChars))
        {
            // Credential form: *.DnsTreeName

            credName = TargetInfo->DnsTreeName;
        }
        else if ((TargetInfo->DnsServerName != NULL) &&
                 (TargetInfo->DnsDomainName != NULL) &&
                 !(TargetInfo->Flags & CRED_TI_DOMAIN_FORMAT_UNKNOWN) &&
                 CreduiIsPostfixString(TargetInfo->DnsServerName,
                                       TargetInfo->DnsDomainName) &&
                 (lstrlen(TargetInfo->DnsDomainName) <= maxChars))
        {
            // Credential form: *.DnsDomainName

            credName = TargetInfo->DnsDomainName;
        }
        else
        {
            usePrefixWildcard = FALSE;

            // If we have a DNS domain name, and it is different from the
            // target name and different from the NetBIOS server, if it
            // exists, then use it:

            if ((TargetInfo->DnsDomainName != NULL) &&
                (lstrlen(TargetInfo->DnsDomainName) <= maxChars))
            {
                // Credential form: DnsDomainName\*

                credName = TargetInfo->DnsDomainName;

                // Set the target alias, if we have one. Don't change the
                // field otherwise, because it may already have been stored in
                // the old credential which was copied over:

                if (TargetInfo->NetbiosDomainName != NULL)
                {
                    ULONG append = lstrlen(TargetInfo->NetbiosDomainName);

                    if (append <= maxChars)
                    {
                        lstrcpy(NewTargetAlias,
                                TargetInfo->NetbiosDomainName);

                        NewTargetAlias[append + 0] = L'\\';
                        NewTargetAlias[append + 1] = L'*';
                        NewTargetAlias[append + 2] = L'\0';

                        NewCredential.TargetAlias = NewTargetAlias;
                    }
                }
            }
            else if ((TargetInfo->NetbiosDomainName != NULL) &&
                     (lstrlen(TargetInfo->NetbiosDomainName) <= maxChars))
            {
                // Credential form: NetbiosDomainName\*

                credName = TargetInfo->NetbiosDomainName;
            }
        }
    }

    //
    // If we still don't have a target name, select a server target name:
    //

    if (credName == NULL)
    {
        if (TargetInfo->DnsServerName != NULL)
        {
            // Credential form: DnsServerName

            credName = TargetInfo->DnsServerName;

            // Set the target alias, if we have one. Don't change the field
            // otherwise, because it may already have been stored in the old
            // credential which was copied over:

            if (TargetInfo->NetbiosServerName != NULL)
            {
                NewCredential.TargetAlias = TargetInfo->NetbiosServerName;
            }
        }
        else if (TargetInfo->NetbiosServerName != NULL)
        {
            // Credential form: NetbiosServerName

            credName = TargetInfo->NetbiosServerName;
        }
        else
        {
            // Credential form: TargetName

            credName = TargetName;
        }

        AddWildcard = FALSE;

    }
    ASSERT( credName != NULL );

    //
    // If the target name should be wildcarded,
    //  add the wildcard
    //

    if ( AddWildcard )
    {
        // Add the wildcard in the required format:

        if (usePrefixWildcard)
        {
            NewTargetName[0] = L'*';
            NewTargetName[1] = L'.';

            lstrcpy(NewTargetName + 2, credName);
        }
        else
        {
            lstrcpy(NewTargetName, credName);

            ULONG append = lstrlen(NewTargetName);

            ASSERT(append <= maxChars);

            NewTargetName[append + 0] = L'\\';
            NewTargetName[append + 1] = L'*';
            NewTargetName[append + 2] = L'\0';
        }
    } else {
        lstrcpy(NewTargetName, credName);
    }


    if ( DomainName != NULL ) {
        NetApiBufferFree( DomainName );
    }
    if ( DnsDomainName != NULL ) {
        NetApiBufferFree( DnsDomainName );
    }
    if ( DnsForestName != NULL ) {
        NetApiBufferFree( DnsForestName );
    }
    if ( ComputerName != NULL ) {
        NetApiBufferFree( ComputerName );
    }

}

//=============================================================================
// CreduiPasswordDialog::UsernameHandleOk
//
// Do the username part of "HandleOk".  The caller should already have filled in
//  UserName as typed by the user.  On succes, UserName may be modified to reflect
//  completion flags.
//
// This part of HandleOk is split out because command line is considered to have two
//  OKs.  The first is when the user hits 'enter' after typing the username.  So
//  username validation happens then by calling this routine.
//
// Returns:
//  NO_ERROR: if the user name is OK.
//  ERROR_BAD_USERNAME: if the username syntax is bad
//  ERROR_DOWNGRADE_DETECTED: if the username doesn't match downgrade requirements
//
//=============================================================================

DWORD
CreduiPasswordDialog::UsernameHandleOk()
{
    DWORD WinStatus;

    BOOL isMarshaled = LocalCredIsMarshaledCredentialW(UserName);

    CreduiDebugLog("UsernameHandleOK: Flags = %x\n",Flags);
    //
    // Compute the credential type based on the new username
    //

    if ( CredCategory != GENERIC_CATEGORY )
    {
        if (isMarshaled)
        {
            NewCredential.Type = CRED_TYPE_DOMAIN_CERTIFICATE;
        }
        else
        {
            SSOPACKAGE SSOPackage;
            // look in registry
            if ( GetSSOPackageInfo( TargetInfo, &SSOPackage ) )
            {
                // it's an sso cred
                NewCredential.Type = CRED_TYPE_DOMAIN_VISIBLE_PASSWORD;
                MaximumPersist = MaximumPersistSso;

            }
            else
            {
                // just a regular domain cred
                NewCredential.Type = CRED_TYPE_DOMAIN_PASSWORD;
            }
        }

        // Set the flag for username target cred
        if ( CredCategory == USERNAME_TARGET_CATEGORY ) {
            NewCredential.Flags |= CRED_FLAGS_USERNAME_TARGET;
        }
    }
    else
    {
        NewCredential.Type = CRED_TYPE_GENERIC;
    }


    //
    // If the caller wanted the username validated,
    //  do so now.
    //

    WinStatus = NO_ERROR;
    if ( NewCredential.Type == CRED_TYPE_DOMAIN_PASSWORD ||
         (Flags & CREDUI_FLAGS_COMPLETE_USERNAME) != 0 ) {

        if ( !CompleteUserName() ) {
            WinStatus = ERROR_BAD_USERNAME;
        }

    } else if ( Flags & CREDUI_FLAGS_VALIDATE_USERNAME ) {

        WCHAR user[CREDUI_MAX_USERNAME_LENGTH+1];
        WCHAR domain[CREDUI_MAX_USERNAME_LENGTH+1];

        WinStatus = CredUIParseUserNameW( UserName,
                              user,
                              sizeof(user)/sizeof(WCHAR),
                              domain,
                              sizeof(domain)/sizeof(WCHAR) );

        if (WinStatus != NO_ERROR) {
            WinStatus = ERROR_BAD_USERNAME;
        }

    }

    //
    // If all is good so far,
    //  and we were originally called because of a downgrade detection,
    //  and the user typed his logon creds,
    //  fail so that the downgrade attacker doesn't "win".
    //

    if ( WinStatus == NO_ERROR &&
         CREDUIP_IS_DOWNGRADE_ERROR( AuthError ) ) {

        WCHAR UserNameBuffer[CRED_MAX_USERNAME_LENGTH+1];
        ULONG UserNameLength;

        //
        // If the typed name is the sam compatible name,
        //  fail.
        //

        UserNameLength = sizeof(UserNameBuffer)/sizeof(WCHAR);

        if ( GetUserNameEx( NameSamCompatible,
                            UserNameBuffer,
                            &UserNameLength ) ) {


            if ( _wcsicmp( UserNameBuffer, UserName ) == 0 ) {
                WinStatus = ERROR_DOWNGRADE_DETECTED;
            }

        }


        //
        // If the typed name is the UPN,
        //  fail.
        //

        UserNameLength = sizeof(UserNameBuffer)/sizeof(WCHAR);

        if ( WinStatus == NO_ERROR &&
            wcsrchr( UserName, L'@' ) != NULL &&
            GetUserNameEx( NameUserPrincipal,
                           UserNameBuffer,
                           &UserNameLength ) ) {

            if ( _wcsicmp( UserNameBuffer, UserName ) == 0 ) {
                WinStatus = ERROR_DOWNGRADE_DETECTED;
            }
        }

    }

//    if (NULL == UserName) CreduiDebugLog("Exit UsernameHandleOK: Username NULL, Flags = %x\n",Flags);
//    else CreduiDebugLog("Exit UsernameHandleOK: UserName = %S, Flags = %x\n", UserName, Flags);

    return WinStatus;
}

//=============================================================================
// CreduiPasswordDialog::HandleOk
//
// Returns ERROR_SUCCESS on success, ERROR_NO_SUCH_LOGON_SESSION if credential
// manager cannot be used to write the credential, or an error from CredWrite
// or FinishHandleOk.
//
// Created 02/25/2000 johnstep (John Stephens)
//=============================================================================

DWORD
CreduiPasswordDialog::HandleOk()
{
    // Get the user name, password, and other settings from the dialog:
    if (!Credential_GetUserName(CredControlWindow,
                                UserName,
                                UserNameMaxChars))
    {
        return ERROR_GEN_FAILURE;
    }

#ifdef SETWILDCARD
    // if is wildcard cred, see if username entered in control matches the
    //  cred username.  If not, override the old credential.
    if ( CreduiIsSpecialCredential(&NewCredential) )
    {
        if (0 != _wcsicmp(OldUserName,UserName) )
        {
            // Change the TargetName from special cred to explicit target passed by caller
            ZeroMemory(&NewCredential,sizeof NewCredential);
            SetCredTargetFromInfo();
            NewCredential.UserName = UserName;
        }
    }

#endif

    // If we cannot get the password, then this is probably a certificate
    // so just set a blank password, which will result in no credential
    // blob:

    BOOL gotPassword =
        Credential_GetPassword(CredControlWindow,
                               Password,
                               PasswordMaxChars);

    if (!gotPassword)
    {
        Password[0] = L'\0';
    }

    //
    // Get the state of the Save checkbox
    //
    if ( CredControlStyle & CRS_SAVECHECK ) {
        Save = Credential_IsSaveChecked(CredControlWindow);
    } else {
        Save = fInitialSaveState;
    }



    DWORD error = ERROR_SUCCESS;

    if (!(Flags & CREDUI_FLAGS_DO_NOT_PERSIST))
    {
        //
        // Only save the credential if the user checked the 'save' checkbox
        //

        if ( Save ) {

            //
            // Keep any existing persistence or use the maximum persistance available.
            //

            if (OldCredential != NULL) {
                NewCredential.Persist = OldCredential->Persist;
            } else {
                NewCredential.Persist = MaximumPersist;
            }

        //
        // The credential might still be saved if the caller didn't asked for the creds
        //  to be returned.
        //
        // ISSUE-2000/12/04-CliffV: Such callers are buggy.  We should assign bugs and get them fixed.
        //

        } else {
            NewCredential.Persist = CRED_PERSIST_SESSION;
        }



        if ( CredCategory == GENERIC_CATEGORY || PasswordState == PASSWORD_CHANGED )
        {
            // Attempt to write the new credential, first get the length. The blob
            // does not include the terminating NULL:

            NewCredential.CredentialBlobSize = lstrlen(Password) * sizeof (WCHAR);
        }
        else
        {
            NewCredential.CredentialBlobSize = 0;
        }

        // If the password is empty, there is nothing to write:

        if (NewCredential.CredentialBlobSize == 0)
        {
            NewCredential.CredentialBlob = NULL;
        }
        else
        {
            NewCredential.CredentialBlob = reinterpret_cast<BYTE *>(Password);
        }
    }

    //
    // Validate the username
    //

    error = UsernameHandleOk();

    //
    // Save the credentials as required
    //
    if (!(Flags & CREDUI_FLAGS_DO_NOT_PERSIST) &&
        error == ERROR_SUCCESS ) {


        //
        // Only save the credential if the user checked the 'save' checkbox
        //
        // Also store them for callers that didn't ask for creds to be returned
        //
        // Also store them for Branded credenials
        //

        if ( Save ||
             !DelayCredentialWrite ||
             dwIDDResource == IDD_BRANDEDPASSWORD ) {

            error = FinishHandleOk();
            // Bug 230648: CredWrite could come back with ERROR_INVALID_PASSWORD here

        }
        else if ( fInitialSaveState && !Save )
        {

            // user unchecked the save box, delete the cred
            LocalCredDeleteW ( NewCredential.TargetName,
                               NewCredential.Type,
                               0 );

        } else {
            error = ERROR_SUCCESS;
        }

        if (error == ERROR_SUCCESS)
        {
            if ( DialogWindow ) {
                EndDialog(DialogWindow, IDOK);
            }

            return error;
        }
        else if (error == ERROR_NO_SUCH_LOGON_SESSION)
        {
            if ( DialogWindow ) {
                EndDialog(DialogWindow, IDCANCEL);
            }

            return error;
        }

        // can still fall out of this block with ERROR_INVALID_PASSWORD

        Credential_SetUserName(CredControlWindow, UserName);
    }

    //
    // If the credential couldn't be written,
    //  let the user type a better one.
    //
    if ((error != ERROR_SUCCESS) &&
        (error != ERROR_NO_SUCH_LOGON_SESSION))
    {
        // For some reason we failed to write the credential:

        if ( error == ERROR_DOWNGRADE_DETECTED ) {
            SendMessage(CredControlWindow,
                        CRM_SHOWBALLOON,
                        0,
                        reinterpret_cast<LPARAM>(&CreduiDowngradeBalloon));
        } else if ( error == ERROR_INVALID_PASSWORD ) {
            // Handler for 230648 !
            //EDITBALLOONTIP structBt = {0};
            //structBt.cbStruct = sizeof(structBt);
            //structBt.pszTitle = PasswordTipTitle;
            //structBt.pszText = PasswordTipText;
            //structBt.ttiIcon = TTI_INFO;
            //Edit_ShowBalloonTip(hwndPassword,&structBt);
            // for now, use preexisting credui mechanism, though that may go away in
            // lieu of shell's global implementation using EM_SHOWBALLOONTIP
            Credential_ShowPasswordBalloon(CredControlWindow,
                            TTI_INFO,
                            CreduiStrings.PasswordTipTitle,
                            CreduiStrings.PasswordTipText);
        } else {
            if ( dwIDDResource == IDD_BRANDEDPASSWORD )
            {
                SendMessage(CredControlWindow,
                            CRM_SHOWBALLOON,
                            0,
                            reinterpret_cast<LPARAM>(&CreduiEmailNameBalloon));

            }
            else
            {
                SendMessage(CredControlWindow,
                            CRM_SHOWBALLOON,
                            0,
                            reinterpret_cast<LPARAM>(&CreduiUserNameBalloon));
            }
        }
    }

    return error;
}

DWORD CreduiPasswordDialog::CmdlinePasswordPrompt()
/*++

Routine Description:

    Command line code get username and password as needed from the user.

    UserName and Password strings set in their respective controls.

Arguments:

    None

Return Values:

    Status of the operation.

--*/
{
    DWORD WinStatus;

    WCHAR szMsg[CREDUI_MAX_CMDLINE_MSG_LENGTH + 1];
    ULONG LocalUserNameLength = 0;
    WCHAR LocalPassword[CREDUI_MAX_PASSWORD_LENGTH + 1];
    WCHAR LocalUserName[CREDUI_MAX_USERNAME_LENGTH + 1] = {0};

    BOOL bNeedUserNamePrompt = FALSE;

    //
    // Get the username passed into the API
    //

    if (!Credential_GetUserName(CredControlWindow,
                                UserName,
                                UserNameMaxChars))
    {
        UserName[0] = '\0';
    }

    // FIX352582 - allow update of wildcard creds.  Matched wildcard cred presents
    //  username.  User should see it and be able to override it.
    //bNeedUserNamePrompt = (UserName[0] == '\0');
    // FIX 399728 - prevent username prompting if the name was passed explicitly

    if (fPassedUsername) bNeedUserNamePrompt = FALSE;
    else if (!(Flags & USERNAME_TARGET_CATEGORY)) bNeedUserNamePrompt = TRUE;

    //
    // Loop getting the username until the user types a valid one
    //

    while ( bNeedUserNamePrompt ) {

        //
        // Prompt for username
        //

        if (UserName[0] != 0)
        {
                WCHAR *rgsz[2];
                rgsz[0] = UserName;
                rgsz[1] = TargetName;
                szMsg[0] = 0;
                FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                            CreduiInstance,
                            IDS_PASSEDNAME_PROMPT,
                            0,
                            szMsg,
                            CREDUI_MAX_CMDLINE_MSG_LENGTH,
                            (va_list *) rgsz);
        }
        else
        {
                WCHAR *rgsz[2];
                rgsz[0] = TargetName;
                rgsz[1] = 0;
                szMsg[0] = 0;
                FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                            CreduiInstance,
                            IDS_USERNAME_PROMPT,
                            0,
                            szMsg,
                            CREDUI_MAX_CMDLINE_MSG_LENGTH,
                            (va_list *) rgsz);
        }
        szMsg[CREDUI_MAX_CMDLINE_MSG_LENGTH] = L'\0';
        CredPutStdout( szMsg );

        CredGetStdin( LocalUserName, UserNameMaxChars, TRUE );

        LocalUserNameLength = wcslen( LocalUserName );

        // If nothing entered and nothing passed, bail.
        // If nothing entered and a previous value exists, use previous value unchanged
        // else use overwrite old value with new value
        if ( LocalUserNameLength == 0 ) {
            if (UserName[0] == '\0')
            {
                WinStatus = ERROR_CANCELLED;
                goto Cleanup;
            }
        }
        else
            wcscpy(UserName, LocalUserName);

        CreduiDebugLog("CreduiCredentialControl::CmdlinePasswordPrompt: "
                       "Username : %s\n",
                       UserName );

        //
        // See if the username is valid (and optional complete the new name)
        //

        WinStatus = UsernameHandleOk();

        if ( WinStatus != NO_ERROR ) {
            // invalid username, put up message and try again
            if ( WinStatus == ERROR_DOWNGRADE_DETECTED ) {
                    szMsg[0] = 0;
                    FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                CreduiInstance,
                                IDS_DOWNGRADE_CMD_TEXT,
                                0,
                                szMsg,
                                CREDUI_MAX_CMDLINE_MSG_LENGTH,
                                NULL);
                    CredPutStdout(szMsg);
            } else {
                    szMsg[0] = 0;
                    FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                CreduiInstance,
                                IDS_INVALID_USERNAME,
                                0,
                                szMsg,
                                CREDUI_MAX_CMDLINE_MSG_LENGTH,
                                NULL);
                    CredPutStdout(szMsg);
            }
            CredPutStdout( L"\n" );
            continue;
        }

        //
        // Save the username in the control as though the GUI prompted for it
        //
        if  ( !Credential_SetUserName( CredControlWindow, UserName ) ) {

            WinStatus = GetLastError();

            CreduiDebugLog("CreduiCredentialControl::CmdlinePasswordPrompt: "
                           "OnSetUserName failed: %u\n",
                           WinStatus );
            goto Cleanup;
        }

        break;

    }

    //
    // Prompt for a password
    //

    //FIX216477 detect marshalled name and change the prompt string
    // to a generic one for any certificate
    if (CredIsMarshaledCredentialW( UserName )) {
        {
            WCHAR *rgsz[2];
            rgsz[0] = TargetName;
            szMsg[0] = 0;
            FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                        CreduiInstance,
                        IDS_CERTIFICATE_PROMPT,
                        0,
                        szMsg,
                        CREDUI_MAX_CMDLINE_MSG_LENGTH,
                        (va_list *) rgsz);
        }
    } 
    else if ((Flags & USERNAME_TARGET_CATEGORY) || (LocalUserNameLength != 0)) 
    {
            WCHAR *rgsz[2];
            rgsz[0] = TargetName;
            szMsg[0] = 0;
            FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                        CreduiInstance,
                        IDS_SIMPLEPASSWORD_PROMPT,
                        0,
                        szMsg,
                        CREDUI_MAX_CMDLINE_MSG_LENGTH,
                        (va_list *) rgsz);
    } else {
            WCHAR *rgsz[2];
            rgsz[0] = UserName;
            rgsz[1] = TargetName;
            szMsg[0] = 0;
            FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                        CreduiInstance,
                        IDS_PASSWORD_PROMPT,
                        0,
                        szMsg,
                        CREDUI_MAX_CMDLINE_MSG_LENGTH,
                        (va_list *) rgsz);
            szMsg[CREDUI_MAX_CMDLINE_MSG_LENGTH] = L'\0';
    }
    CredPutStdout( szMsg );

    CredGetStdin( LocalPassword, CREDUI_MAX_PASSWORD_LENGTH, FALSE );

    //
    // Save the password in the control as though the GUI prompted for it
    //

    if  ( !Credential_SetPassword( CredControlWindow, LocalPassword ) ) {
        WinStatus = GetLastError();

        CreduiDebugLog("CreduiCredentialControl::CmdlinePasswordPrompt: "
                       "OnSetPassword failed: %u\n",
                       WinStatus );
        goto Cleanup;
    }

    WinStatus = NO_ERROR;

    //
    // Tell our parent window that we're done prompting
    //
Cleanup:
    ZeroMemory( LocalPassword, sizeof(LocalPassword) );
    return WinStatus;
}



//=============================================================================
// CreduiPasswordDialog::CmdLineMessageHandlerCallback
//
//
// The command line message handler function
//
// Arguments:
//   Window (in)
//   message (in)
//   wParam (in)
//   lParam (in)
//
//=============================================================================

LRESULT
CALLBACK
CreduiPasswordDialog::CmdLineMessageHandlerCallback(
    HWND window,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    // CreduiDebugLog( "CmdLine Callback: %8.8lx %8.8lx %8.8lx\n", message, wParam, lParam );

    // on window message, retrieve object ptr from window data ptr
    // call class object handler function.
    CreduiPasswordDialog *that =
        reinterpret_cast<CreduiPasswordDialog *>(
            GetWindowLongPtr(window, GWLP_USERDATA));

    if (that != NULL) {
        ASSERT(window == that->CmdLineWindow);
        return that->CmdLineMessageHandler(message, wParam, lParam);
    }

    if (message == WM_CREATE)
    {
        DWORD WinStatus;
        LPCREATESTRUCT lpCreateStruct = (LPCREATESTRUCT)lParam;
        that = (CreduiPasswordDialog *)lpCreateStruct->lpCreateParams;

        if (that != NULL) {

            //
            // Initialize the window
            //

            if (!that->InitWindow( window )) {
                PostQuitMessage( ERROR_CANCELLED );
                return 0;
            }

            SetWindowPos ( window, HWND_BOTTOM, 0,0,0,0,  SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE | SWP_FRAMECHANGED );


            //
            // For passwords,
            //  prompt here.
            //
            // It is better to prompt here than in the control window since
            //  command line has to do user name completion and that is done at this layer.
            //

            if ( (that->Flags & CREDUI_FLAGS_REQUIRE_SMARTCARD) == 0 ) {
                WinStatus = that->CmdlinePasswordPrompt();

                if ( WinStatus != NO_ERROR ) {
                    PostQuitMessage( WinStatus );
                    return 0;
                }
            }

            //
            // For smartcards,
            //  Prompt in the control window since it supports smart card enumeration
            // For password,
            //  prompt where to save the cred.
            //

            WinStatus = (DWORD) SendMessage(that->CredControlWindow, CRM_DOCMDLINE, 0, (LPARAM)that->TargetName );

            if ( WinStatus != NO_ERROR ) {
                PostQuitMessage( WinStatus );
                return 0;
            }


        }
        return 0;
    }

    return DefWindowProc(window, message, wParam, lParam);

}



//=============================================================================
// CreduiPasswordDialog::CmdLineMessageHandler
//
// Called from the control window callback to handle the window messages.
//
// Arguments:
//   message (in)
//   wParam (in)
//   lParam (in)
//
//=============================================================================

LRESULT
CreduiPasswordDialog::CmdLineMessageHandler(
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{

    return SendMessage( CredControlWindow, message, wParam, lParam );
}

//=============================================================================
// CreduiPasswordDialog::DialogMessageHandlerCallback
//
// This is the actual callback function for the dialog window. On the intial
// create, this handles WM_INITDIALOG. After that, it is only responsible for
// getting the this pointer and calling DialogMessageHandler.
//
// Arguments:
//   dialogWindow (in)
//   message (in)
//   wParam (in)
//   lParam (in)
//
// Returns TRUE if the message was handled or FALSE otherwise. FALSE is also
// returned in special cases such as WM_INITDIALOG.
//
// Created 02/25/2000 johnstep (John Stephens)
//=============================================================================

INT_PTR
CALLBACK
CreduiPasswordDialog::DialogMessageHandlerCallback(
    HWND dialogWindow,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    //CreduiDebugLog( "Dialog Callback: %8.8lx %8.8lx %8.8lx\n", message, wParam, lParam );
    CreduiPasswordDialog *that =
        reinterpret_cast<CreduiPasswordDialog *>(
            GetWindowLongPtr(dialogWindow, GWLP_USERDATA));

    if (that != NULL)
    {
        ASSERT(dialogWindow == that->DialogWindow);

        return that->DialogMessageHandler(message, wParam, lParam);
    }

    if (message == WM_INITDIALOG)
    {
        that = reinterpret_cast<CreduiPasswordDialog *>(lParam);

        if (that != NULL)
        {
            if (!that->InitWindow(dialogWindow))
            {
                EndDialog(dialogWindow, IDCANCEL);
            }
        }
    }

    return FALSE;
}

//=============================================================================
// CreduiPasswordDialog::DialogMessageHandler
//
// Called from the dialog window callback to handle the window messages.
//
// Arguments:
//   message (in)
//   wParam (in)
//   lParam (in)
//
// Returns TRUE if the message was handled or FALSE otherwise.
//
// Created 02/25/2000 johnstep (John Stephens)
//=============================================================================

INT_PTR
CreduiPasswordDialog::DialogMessageHandler(
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch (message)
    {

    case WM_NOTIFY:
        {
            int idCtrl = (int)wParam;
            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch (pnmh->code)
            {

            case NM_CLICK:
            case NM_RETURN:
                switch (idCtrl)
                {
                    case IDC_GETALINK:
                        {
                            DWORD dwResult;

                            if ( TryLauchRegWizard ( &SSOPackage, DialogWindow, TRUE /* HasLogonSession */,
                                                           UserName, UserNameMaxChars,
                                                           Password, PasswordMaxChars,
                                                           &dwResult ))
                            {
                                // end dialog, Result
                                if ( dwResult == ERROR_SUCCESS )
                                {
                                    EndDialog(DialogWindow, IDOK);
                                    return TRUE;
                                }
                            }
                            else
                            {
                                // if we couldn't launch the wizard, try the web page.
                                if ( wcslen(SSOPackage.szRegURL) > 0 )
                                {
                                    ShellExecute ( NULL,
                                               NULL,
                                               SSOPackage.szRegURL,
                                               NULL,
                                               NULL,
                                               SW_SHOWNORMAL );
                                }
                            }
                        }

                        break;
                    case IDC_HELPLINK:
                        if ( wcslen(SSOPackage.szHelpURL) > 0 )
                        {
                            ShellExecute ( NULL,
                                       NULL,
                                       SSOPackage.szHelpURL,
                                       NULL,
                                       NULL,
                                       SW_SHOWNORMAL );
                        }
                        break;

                }

            }
        }
        break;


    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDOK:
            Result = HandleOk();

            if (Result != ERROR_SUCCESS)
            {
                if (Result == ERROR_NO_SUCH_LOGON_SESSION)
                {
                    wParam = IDCANCEL;
                }
                else
                {
                    return TRUE;
                }
            }
            // Fall through...

        case IDCANCEL:
            EndDialog(DialogWindow, LOWORD(wParam));
            return TRUE;

        case IDC_CRED:
            if (HIWORD(wParam) == CRN_USERNAMECHANGE)
            {
                BOOL enable = TRUE;
                LONG length = Credential_GetUserNameLength(CredControlWindow);

                // Validate the user name:

                if ( CredCategory == DOMAIN_CATEGORY &&
                    ((TargetInfo == NULL) ||
                     !(TargetInfo->Flags & CRED_TI_ONLY_PASSWORD_REQUIRED)))
                {
                    enable = length > 0;
                }
                else
                {
                    enable = length != -1;
                }

                if (enable)
                {
                    EnableWindow(GetDlgItem(DialogWindow, IDOK), TRUE);
                    DisabledControlMask &= ~DISABLED_CONTROL_OK;
                }
                else
                {
                    EnableWindow(GetDlgItem(DialogWindow, IDOK), FALSE);
                    DisabledControlMask |= DISABLED_CONTROL_OK;
                }
            }
            else if (HIWORD(wParam) == CRN_PASSWORDCHANGE)
            {
                if (PasswordState == PASSWORD_INIT)
                {
                    PasswordState = PASSWORD_CHANGED;
                }
            }
            return TRUE;


        }
        break;

    case WM_ENTERSIZEMOVE:
        Credential_HideBalloon(CredControlWindow);
        return TRUE;

    case WM_PAINT:
        if (FirstPaint && GetUpdateRect(DialogWindow, NULL, FALSE))
        {
            FirstPaint = FALSE;

            if (CredBalloon != NULL)
            {
                SendMessage(CredControlWindow,
                            CRM_SHOWBALLOON,
                            0,
                            reinterpret_cast<LPARAM>(CredBalloon));
            }

            CredBalloon = NULL;
        }
        break;
    }

    return FALSE;
}

// looks for an existing cred with the same name as that of pNewCredential and demotes it to
// username only
void DemoteOldDefaultSSOCred (
    PCREDENTIAL_TARGET_INFORMATION pTargetInfo,     // target info of new cred
    DWORD Flags
    )
{
    CREDENTIALW **credentialSet = NULL;
    DWORD count;


    if ( pTargetInfo == NULL  )
        return;

    if (LocalCredReadDomainCredentialsW( pTargetInfo, 0, &count,
                                              &credentialSet))
    {

        PCREDENTIAL pOldCredential = NULL;

        for ( DWORD i = 0; i < count; i++ )
        {

#ifndef SETWILDCARD
            //
            // Ignore RAS and wildcard credentials,
            //  we never want credUI to change such a credential.
            //
            if ( CreduiIsSpecialCredential(credentialSet[i]) )
            {
                continue;
            }
#endif

            //
            // CredReadDomain domain credentials returns creds in preference
            //  order as specified by the TargetInfo.
            //  So use the first valid one.
            //
            if ( credentialSet[i]->Type == CRED_TYPE_DOMAIN_VISIBLE_PASSWORD )
            {
                pOldCredential = credentialSet[i];
                break;
            }


        }


        if ( pOldCredential != NULL )
        {
            // save this under the username

            pOldCredential->Persist = CRED_PERSIST_ENTERPRISE;
            pOldCredential->CredentialBlob = NULL;
            pOldCredential->CredentialBlobSize = 0;
            pOldCredential->TargetName = pOldCredential->UserName;
            pOldCredential->Flags = CRED_FLAGS_USERNAME_TARGET;


            WriteCred(  pOldCredential->UserName,
                        Flags,
                        NULL,
                        pOldCredential,
                        0,
                        FALSE,
                        FALSE);

        }
    }

    if (credentialSet != NULL)
    {
        LocalCredFree(static_cast<VOID *>(credentialSet));
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\credui\resource.h ===
//=============================================================================
// Copyright (c) 2000 Microsoft Corporation
//
// resource.h
//
// Resource identifiers for credential manager user interface resources.
//
// Created 02/18/2000 johnstep (John Stephens)
//=============================================================================

#ifndef __RESOURCE_H__
#define __RESOURCE_H__

//-----------------------------------------------------------------------------
#include "consmsg.h"

#define IDD_PASSWORD            101
#define IDD_CERTIFICATE         102
#define IDD_CHANGE_PASSWORD     103
#define IDD_BRANDEDPASSWORD     104

#define IDC_WELCOME_TEXT        1001
#define IDC_CRED                1002
#define IDC_USERNAME            1003
#define IDC_USERNAME_STATIC     1004
#define IDC_PASSWORD            1005
#define IDC_PASSWORD_STATIC     1006
#define IDC_SAVE                1007
#define IDC_BANNER              1009
#define IDC_VIEW_CERT           1010
#define IDC_NEW_PASSWORD        1011
#define IDC_CONFIRM_PASSWORD    1012
#define IDC_BRAND               1013
#define IDC_GETALINK            1014
#define IDC_HELPLINK            1015

#define IDC_BRANDRIGHT          1016
#define IDC_BRANDMID            1017
#define IDC_BRANDLEFT           1018

#define IDB_BANNER              1101
#define IDB_TYPES               1102
#define IDB_BRAND               1103

#define IDB_BRANDRIGHT          1104
#define IDB_BRANDMID            1105
#define IDB_BRANDLEFT           1106

#define IDI_DEFAULT             1201

#define IDS_USERNAME_TIP_TITLE  2001
#define IDS_USERNAME_TIP_TEXT   2002
#define IDS_CAPSLOCK_TIP_TITLE  2003
#define IDS_CAPSLOCK_TIP_TEXT   2004
#define IDS_LOGON_TIP_TITLE     2005
#define IDS_LOGON_TIP_TEXT      2006
#define IDS_LOGON_TIP_CAPS      2007
#define IDS_DNS_CAPTION         2008
#define IDS_NETBIOS_CAPTION     2009
#define IDS_GENERIC_CAPTION     2010
#define IDS_WELCOME             2011
#define IDS_WELCOME_BACK        2012
#define IDS_CONNECTING          2013
#define IDS_PASSWORD_STATIC     2014
#define IDS_PIN_STATIC          2015
#define IDS_USERNAME_STATIC     2016
#define IDS_CERTIFICATE_STATIC  2017
#define IDS_LOOKUP_NAME         2019
#define IDS_CARD_READY          2024
#define IDS_BACKWARDS_TIP_TITLE 2027
#define IDS_BACKWARDS_TIP_TEXT  2028
#define IDS_CARD_STATIC         2029
#define IDS_WRONG_OLD_TIP_TITLE 2030
#define IDS_WRONG_OLD_TIP_TEXT  2031
#define IDS_NOT_SAME_TIP_TITLE  2032
#define IDS_NOT_SAME_TIP_TEXT   2033
#define IDS_TOO_SHORT_TIP_TITLE 2034
#define IDS_TOO_SHORT_TIP_TEXT  2035
#define IDS_SAVE                2036
#define IDS_PASSPORT_SAVE       2051
#define IDS_EMAIL_NAME          2052
#define IDS_DOWNGRADE_TIP_TEXT  2056
#define IDS_DOWNGRADE_CMD_TEXT  2057
#define IDS_EMAILNAME_TIP_TITLE 2058
#define IDS_EMAILNAME_TIP_TEXT  2059
#define IDS_PASSWORD_TIP_TITLE  2061
#define IDS_PASSWORD_TIP_TEXT   2062

// Help strings - context help for controls
#define IDS_NOHELP                          2100
#define IDH_USERNAMEEDIT                    2101
#define IDH_PASSWORDEDIT                    2102
#define IDH_SAVECHECKBOX                    2103


//-----------------------------------------------------------------------------

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\credui\makefile.inc ===
#
# build a private credui.lib that contains undocumented and
# private functions
#

$(O)\creduip.def: credui.src
    @echo Creating $@ from $**
    $(C_PREPROCESSOR_NAME) /DNOT_PUBLIC= $(C_PREPROCESSOR_FLAGS) $** > $@


$(O)\creduip.lib: $(O)\creduip.def $(LIBRARY_OBJS)
   -lib -out:$@ @<<
$(LIBRARIAN_FLAGS)
-def:$(O)\creduip.def
$(LIBRARY_OBJS)
<<NOKEEP


#
# Build public credui.lib
#

$(O)\credui.def: credui.src
    @echo Creating $@ from $**
    $(C_PREPROCESSOR_NAME) /DNOT_PUBLIC=PRIVATE $(C_PREPROCESSOR_FLAGS) $** > $@


$(O)\credui.lib : $(O)\credui.def $(LIBRARY_OBJS)
   -lib -out:$@ @<<
$(LIBRARIAN_FLAGS)
-def:$(O)\credui.def
$(LIBRARY_OBJS)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\credui\pswchg.cpp ===
#include "precomp.hpp"
//#include <nt.h>
//#include <ntrtl.h>
//#include <nturtl.h>
//#include <windows.h>
#include <wincred.h>
#include <align.h>
#include <lm.h>
#include <ntsecapi.h>
#include <dsgetdc.h>
#include <stdlib.h>
//#include <stdio.h>
#include <string.h>

// !!!!!
// this file is a duplicate of a nearly identical file in the keymgr project.  It should be removed when
// the implementation of NetUserChangePassword() is updated to handle unc names and MIT Kerberos
// realms properly.  For now, it wraps NetUserChangePassword() to handle the extra cases.

// Dependent libraries:
//  secur32.lib, netapi32.lib

// external fn:  NET_API_STATUS NetUserChangePasswordEy(LPCWSTR,LPCWSTR,LPCWSTR,LPCWSTR)

BOOL 
IsMITName (
    LPCWSTR UserName
)
{
    BOOL fReturn = FALSE;
    HKEY MitKey;
    DWORD Index;
    PWSTR Realms;
    DWORD RealmSize;
    int err;
    DWORD NumRealms;
    DWORD MaxRealmLength;
    FILETIME KeyTime;
    WCHAR *szUncTail;
    
    if (NULL == UserName) return FALSE;
    
    szUncTail = wcschr(UserName,'@');
    if (NULL == szUncTail) return FALSE;
    szUncTail++;                        // point to char following @

    err = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                TEXT("System\\CurrentControlSet\\Control\\Lsa\\Kerberos\\Domains"),
                0,
                KEY_READ,
                &MitKey );

    if ( err == 0 )
    {
#ifdef LOUDLY
        OutputDebugString(L"Kerberos domains key opened\n");
#endif
        err = RegQueryInfoKey( MitKey,
                               NULL,
                               NULL,
                               NULL,
                               &NumRealms,
                               &MaxRealmLength,
                               NULL,
                               NULL,
                               NULL,
                               NULL,
                               NULL,
                               NULL );

        MaxRealmLength++ ;

        MaxRealmLength *= sizeof( WCHAR );

        Realms = (PWSTR) malloc(MaxRealmLength );


        if ( Realms)
        {
#ifdef LOUDLY
        OutputDebugString(L"Kerberos realms found\n");
#endif

            for ( Index = 0 ; Index < NumRealms ; Index++ )
            {
                RealmSize = MaxRealmLength ;

                err = RegEnumKeyEx( MitKey,
                                  Index,
                                  Realms,
                                  &RealmSize,
                                  NULL,
                                  NULL,
                                  NULL,
                                  &KeyTime );
                if (err == 0)
                {
#ifdef LOUDLY
                    OutputDebugString(L"Fetched realm: ");
                    OutputDebugString(Realms);
                    OutputDebugString(L"\n");
                    OutputDebugString(L"Username suffix: ");
                    OutputDebugString(szUncTail);
                    OutputDebugString(L"\n");
#endif
                    if (0 == _wcsicmp(szUncTail, Realms))
                    {
#ifdef LOUDLY
                        OutputDebugString(L"Username maps to an MIT realm\n");
#endif
                        fReturn = TRUE;
                        break;
                    }
                }
            }
        }
        free(Realms);
    }
    return fReturn;
}

NTSTATUS
MitChangePasswordEy(
    LPCWSTR       DomainName,
    LPCWSTR       UserName,
    LPCWSTR       OldPassword,
    LPCWSTR       NewPassword,
    NTSTATUS      *pSubStatus
    )
{
    HANDLE hLsa = NULL;
    NTSTATUS Status;
    NTSTATUS SubStatus;
    
    STRING Name;
    ULONG PackageId;
    
    PVOID Response = NULL ;
    ULONG ResponseSize;
    
    PKERB_CHANGEPASSWORD_REQUEST ChangeRequest = NULL;
    ULONG ChangeSize;
    
    UNICODE_STRING User,Domain,OldPass,NewPass;

    Status = LsaConnectUntrusted(&hLsa);
    if (!SUCCEEDED(Status)) goto Cleanup;
#ifdef LOUDLY
    OutputDebugString(L"We have an LSA handle\n");
#endif

    RtlInitString(
        &Name,
        MICROSOFT_KERBEROS_NAME_A
        );

    Status = LsaLookupAuthenticationPackage(
                hLsa,
                &Name,
                &PackageId
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
#ifdef LOUDLY
    OutputDebugString(L"Authentication package found\n");
#endif

    RtlInitUnicodeString(
        &User,
        UserName
        );
    RtlInitUnicodeString(
        &Domain,
        DomainName
        );
    RtlInitUnicodeString(
        &OldPass,
        OldPassword
        );
    RtlInitUnicodeString(
        &NewPass,
        NewPassword
        );

    ChangeSize = ROUND_UP_COUNT(sizeof(KERB_CHANGEPASSWORD_REQUEST),4)+
                                    User.Length +
                                    Domain.Length +
                                    OldPass.Length +
                                    NewPass.Length ;
    ChangeRequest = (PKERB_CHANGEPASSWORD_REQUEST) LocalAlloc(LMEM_ZEROINIT, ChangeSize );

    if ( ChangeRequest == NULL )
    {
        Status = STATUS_NO_MEMORY ;
        goto Cleanup ;
    }

    ChangeRequest->MessageType = KerbChangePasswordMessage;

    ChangeRequest->AccountName = User;
    ChangeRequest->AccountName.Buffer = (LPWSTR) ROUND_UP_POINTER(sizeof(KERB_CHANGEPASSWORD_REQUEST) + (PBYTE) ChangeRequest,4);

    RtlCopyMemory(
        ChangeRequest->AccountName.Buffer,
        User.Buffer,
        User.Length
        );

    ChangeRequest->DomainName = Domain;
    ChangeRequest->DomainName.Buffer = ChangeRequest->AccountName.Buffer + ChangeRequest->AccountName.Length / sizeof(WCHAR);

    RtlCopyMemory(
        ChangeRequest->DomainName.Buffer,
        Domain.Buffer,
        Domain.Length
        );

    ChangeRequest->OldPassword = OldPass;
    ChangeRequest->OldPassword.Buffer = ChangeRequest->DomainName.Buffer + ChangeRequest->DomainName.Length / sizeof(WCHAR);

    RtlCopyMemory(
        ChangeRequest->OldPassword.Buffer,
        OldPass.Buffer,
        OldPass.Length
        );

    ChangeRequest->NewPassword = NewPass;
    ChangeRequest->NewPassword.Buffer = ChangeRequest->OldPassword.Buffer + ChangeRequest->OldPassword.Length / sizeof(WCHAR);

    RtlCopyMemory(
        ChangeRequest->NewPassword.Buffer,
        NewPass.Buffer,
        NewPass.Length
        );


    //
    // We are running as the caller, so state we are impersonating
    //

    //ChangeRequest->Impersonating = TRUE;
#ifdef LOUDLY
    OutputDebugString(L"Attempting to call the authentication package\n");
#endif
    Status = LsaCallAuthenticationPackage(
                hLsa,
                PackageId,
                ChangeRequest,
                ChangeSize,
                &Response,
                &ResponseSize,
                &SubStatus
                );
    if (!NT_SUCCESS(Status) || !NT_SUCCESS(SubStatus))
    {
#ifdef LOUDLY
        WCHAR szsz[200];
        swprintf(szsz,L"Call failed. Status %x SubStatus %x\n",Status, SubStatus);
        OutputDebugString(szsz);
#endif
        if (NT_SUCCESS(Status))
        {
            Status = SubStatus;
            *pSubStatus = STATUS_UNSUCCESSFUL ;
        } 
        else 
        {
            *pSubStatus = SubStatus;
        }
    }

Cleanup:

    if (hLsa) LsaDeregisterLogonProcess(hLsa);

    if (Response != NULL) LsaFreeReturnBuffer(Response);
    if (ChangeRequest != NULL) LocalFree(ChangeRequest);
    
    return(Status);
}

/*

NetUserChangePasswordEy()

A wrapper function to superset the functionality of NetUserChangePassword(), specifically
by adding support for changing the account password for an MIT Kerberos principal.

This routine accepts:

1.  uncracked username, with NULL domain
2.  cracked username, with domain portion routed to the domain argument

In case 1, it handles all cases, including MIT realm password changes
In case 2, it will not handle MIT realms.  

Case 2 is provided for backwards compatibility with NetUserChangePassword().  It is intended
that callers should pass the uncracked name, and remove the cracking code from the client.

*/
NET_API_STATUS
NetUserChangePasswordEy (
    LPCWSTR domainname,
    LPCWSTR username,
    LPCWSTR oldpassword,
    LPCWSTR newpassword
)
{
    NTSTATUS ns;    // status from call
    NET_API_STATUS nas;
    NTSTATUS ss;    // substatus
#ifdef LOUDLY
    OutputDebugString(L"NetUserChangePasswordEy called for ");
    OutputDebugString(username);
    OutputDebugString(L"\n");
#endif
    // domainname may be a kerberos realm
    // If not a UNC name, call through to NetUserChangePassword
    // else
    //  locate UNC suffix
    //  search all domains returned by DsEnumerateDomainTrusts() for a match
    //  On match, if is kerberos realm, call MitChangePasswordEy()
    //  else call NetUserChangePassword
    if ((domainname == NULL) && IsMITName(username))
    {
        ns = MitChangePasswordEy(domainname, username, oldpassword, newpassword, &ss);
        // remap certain errors returned by MitChangePasswordEy to coincide with those of NetUserChangePassword
        if (NT_SUCCESS(ns)) nas = NERR_Success;
        else
        {
            switch (ns)
            {
                case STATUS_CANT_ACCESS_DOMAIN_INFO:
                case STATUS_NO_SUCH_DOMAIN:
                {
                    nas = NERR_InvalidComputer;
                    break;
                }
                case STATUS_NO_SUCH_USER:
                case STATUS_WRONG_PASSWORD_CORE:
                case STATUS_WRONG_PASSWORD:
                {
                    nas = ERROR_INVALID_PASSWORD;
                    break;
                }
                case STATUS_ACCOUNT_RESTRICTION:
                case STATUS_ACCESS_DENIED:
                case STATUS_BACKUP_CONTROLLER:
                {
                    nas = ERROR_ACCESS_DENIED;
                    break;
                }
                case STATUS_PASSWORD_RESTRICTION:
                {
                    nas = NERR_PasswordTooShort;
                    break;
                }
                        
                default:
                    nas = -1;       // will produce omnibus error message when found (none of the above)
                    break;
            }
        }
    }
    else if (NULL == domainname)
    {
        WCHAR RetUserName[CRED_MAX_USERNAME_LENGTH + 1];
        WCHAR RetDomainName[CRED_MAX_USERNAME_LENGTH + 1];
        RetDomainName[0] = 0;
        DWORD Status = CredUIParseUserNameW(
                        username,
                        RetUserName,
                        CRED_MAX_USERNAME_LENGTH,
                        RetDomainName,
                        CRED_MAX_USERNAME_LENGTH);
        switch (Status)
        {
            case NO_ERROR:
            {
#ifdef LOUDLY
                OutputDebugString(L"Non-MIT password change for ");
                OutputDebugString(RetUserName);
                OutputDebugString(L" of domain ");
                OutputDebugString(RetDomainName);
                OutputDebugString(L"\n");
#endif
                nas = NetUserChangePassword(RetDomainName,RetUserName,oldpassword,newpassword);
                break;
            }
            case ERROR_INSUFFICIENT_BUFFER:
                nas = ERROR_INVALID_PARAMETER;
                break;
            case ERROR_INVALID_ACCOUNT_NAME:
            default:
                nas = NERR_UserNotFound;
                break;
        }

    }
    else 
    {
        // both username and domainname passed.
        nas = NetUserChangePassword(domainname,username,oldpassword,newpassword);
    }
#ifdef LOUDLY
    WCHAR szsz[200];
    swprintf(szsz,L"NUCPEy returns %x\n",nas);
    OutputDebugString(szsz);
#endif
    return nas;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\credui\precomp.hpp ===
//=============================================================================
// Copyright (c) 2000 Microsoft Corporation
//
// precomp.hpp
//
// Created 02/29/2000 johnstep (John Stephens)
//=============================================================================

#define UNICODE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <malloc.h>
extern "C" {
#include <commctrl.h>
}
#define _CREDUI_
#include <wincrui.h>

#ifndef SECURITY_WIN32
#define SECURITY_WIN32
#endif

#include <security.h>

#include <controls.hpp>
#include "utils.hpp"
#include <netlib.h>
#include <shfusion.h>

#if defined(DBG)
#if defined(CREDUIPRINTF)
#define CreduiDebugLog printf
#else
#define CreduiDebugLog DbgPrint
#endif
#else
#define CreduiDebugLog
#endif

//-----------------------------------------------------------------------------
// Types
//-----------------------------------------------------------------------------

struct CREDUI_STRINGS
{
    WCHAR UserNameTipTitle[32];
    WCHAR UserNameTipText[256];
    WCHAR PasswordTipTitle[32];
    WCHAR PasswordTipText[256];
    WCHAR CapsLockTipTitle[32];
    WCHAR CapsLockTipText[256];
    WCHAR LogonTipTitle[32];
    WCHAR LogonTipText[256];
    WCHAR LogonTipCaps[256];
    WCHAR DnsCaption[64];
    WCHAR NetbiosCaption[64];
    WCHAR GenericCaption[64];
    WCHAR Welcome[64];
    WCHAR WelcomeBack[64];
    WCHAR Connecting[64];
    WCHAR PasswordStatic[32];
    WCHAR PinStatic[32];
    WCHAR UserNameStatic[32];
    WCHAR CertificateStatic[32];
    WCHAR Certificate[32];
    WCHAR LookupName[64];
    WCHAR EmptyReader[64];
    WCHAR NoCard[32];
    WCHAR UnknownCard[64];
    WCHAR BackwardsCard[64];
    WCHAR EmptyCard[64];
    WCHAR ReadingCard[64];
    WCHAR CardError[64];
    WCHAR BackwardsTipTitle[32];
    WCHAR BackwardsTipText[128];
    WCHAR SmartCardStatic[32];
    WCHAR WrongOldTipTitle[32];
    WCHAR WrongOldTipText[256];
    WCHAR NotSameTipTitle[32];
    WCHAR NotSameTipText[256];
    WCHAR TooShortTipTitle[32];
    WCHAR TooShortTipText[256];
    WCHAR Save[64];
    WCHAR PromptForUse[256];
    WCHAR NoUsernameEntered[256];
    WCHAR PassportSave[64];
    WCHAR EmailName[64];
    WCHAR DowngradeTipText[256];
    WCHAR EmailNameTipTitle[64];
    WCHAR EmailNameTipText[256];
};

// Private window message:

enum
{
    CREDUI_WM_APP_LOOKUP_COMPLETE   = WM_APP + 0,
    CREDUI_WM_APP_VIEW_COMPLETE     = WM_APP + 1
};

//-----------------------------------------------------------------------------
// Global Variables
//-----------------------------------------------------------------------------

extern HMODULE CreduiInstance;
extern ULONG CreduiComReferenceCount;

extern BOOL CreduiIsPersonal;
extern BOOL CreduiIsDomainController;
extern BOOL CreduiIsSafeMode;

extern CREDUI_STRINGS CreduiStrings;

extern UINT CreduiScarduiWmReaderArrival;
extern UINT CreduiScarduiWmReaderRemoval;
extern UINT CreduiScarduiWmCardInsertion;
extern UINT CreduiScarduiWmCardRemoval;
extern UINT CreduiScarduiWmCardCertAvail;
extern UINT CreduiScarduiWmCardStatus;

extern BOOL CreduiHasSmartCardSupport;

extern CONST CREDUI_BALLOON_TIP_INFO CreduiCapsLockTipInfo;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\credui\utils.cpp ===
//=============================================================================
// Copyright (c) 2000 Microsoft Corporation
//
// utils.cpp
//
// Credential manager user interface utility functions.
//
// Created 06/06/2000 johnstep (John Stephens)
//=============================================================================

#include "precomp.hpp"
#include <lm.h>
#include <credp.h>
#include "wininet.h"
#include <windns.h> // DnsValidateName_W
extern "C" {
#include <names.h> // NetpIsDomainNameValid
}

#include "shpriv.h"

extern BOOL  gbWaitingForSSOCreds;
extern WCHAR gszSSOUserName[CREDUI_MAX_USERNAME_LENGTH];
extern WCHAR gszSSOPassword[CREDUI_MAX_PASSWORD_LENGTH];
extern BOOL gbStoredSSOCreds;

#define SIZE_OF_SALT  37
#define SALT_SHIFT     2

WCHAR g_szSalt[] = L"82BD0E67-9FEA-4748-8672-D5EFE5B779B0";

HMODULE hAdvapi32 = NULL;

CRITICAL_SECTION CredConfirmationCritSect;
CRED_AWAITING_CONFIRMATION* pCredConfirmationListHead = NULL;

//-----------------------------------------------------------------------------
// Functions
//-----------------------------------------------------------------------------



//=============================================================================
// CreduiIsSpecialCredential
//
// Returns TRUE if the credential is a special type which we should not
// update or FALSE otherwise.
//
// Created 05/25/2000 johnstep (John Stephens)
//
//=============================================================================

BOOL
CreduiIsSpecialCredential(
    CREDENTIAL *credential
    )
{
    ASSERT(credential != NULL);

    // If credential empty for some reason, don't attempt the test
    if (credential->TargetName == NULL) return FALSE;
    
    if ((credential->TargetName[0] == L'*') &&
        (credential->TargetName[1] == L'\0'))
    {
        // The magical global wildcard credential, which we never create nor
        // update. This is a special credential:

        return TRUE;
    }

    if (_wcsicmp(credential->TargetName, CRED_SESSION_WILDCARD_NAME) == 0)
    {
        // This is another special credential:

        return TRUE;
    }

    return FALSE;
}

//=============================================================================
// CreduiLookupLocalSidFromRid
//
// Looks up the SID from the RID, allocates storage for the SID, and returns a
// pointer to it. The caller is responsible for freeing the memory via the
// delete [] operator.
//
// Arguments:
//   rid (in)
//   sid (out)
//
// Returns TRUE on success or FALSE otherwise.
//
// Created 04/12/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiLookupLocalSidFromRid(
    DWORD rid,
    PSID *sid
    )
{
    BOOL success = FALSE;

    *sid = NULL;

    // Get the account domain SID on the target machine.
    //
    // Note: If you were looking up multiple SIDs based on the same account
    //       domain, you only need to call this once.

    USER_MODALS_INFO_2 *userInfo;

    if (NetUserModalsGet(
            NULL,
            2,
            reinterpret_cast<BYTE **>(&userInfo)) == NERR_Success)
    {
        UCHAR subAuthCount =
            *GetSidSubAuthorityCount(userInfo->usrmod2_domain_id);

        SID *newSid =
            reinterpret_cast<SID *>(
                new BYTE [GetSidLengthRequired(subAuthCount + 1)]);

        if (newSid != NULL)
        {
            InitializeSid(
                newSid,
                GetSidIdentifierAuthority(userInfo->usrmod2_domain_id),
                subAuthCount + 1);

            // Copy existing sub authorities from account SID into new SID:

            for (ULONG i = 0; i < subAuthCount; ++i)
            {
                *GetSidSubAuthority(newSid, i) =
                    *GetSidSubAuthority(userInfo->usrmod2_domain_id, i);
            }


            // Append RID to new SID:

            *GetSidSubAuthority(newSid, subAuthCount) = rid;
            *sid = newSid;

            success = TRUE;
        }

        // Finished with userInfo, so free it here:
        NetApiBufferFree(userInfo);
    }

    return success;
}

//=============================================================================
// CreduiLookupLocalNameFromRid
//
// Looks up the Name from the RID, allocates storage for the Name, and returns a
// pointer to it. The caller is responsible for freeing the memory via the
// delete [] operator.
//
// Arguments:
//   rid (in)
//   name (out)
//
// Returns TRUE on success or FALSE otherwise.
//
// Created 04/12/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiLookupLocalNameFromRid(
    DWORD rid,
    LPWSTR *name
    )
{
    BOOL RetVal = FALSE;
    PSID Sid;
    WCHAR NameBuffer[UNLEN+1];
    DWORD NameLen;
    WCHAR DomainBuffer[DNLEN+1];
    DWORD DomainLen;
    SID_NAME_USE NameUse;

    //
    // First translate the rid to a SID
    //

    if ( !CreduiLookupLocalSidFromRid( rid, &Sid )) {
        return FALSE;
    }

    //
    // Translate the SID to a name
    //

    NameLen = UNLEN+1;
    DomainLen = DNLEN+1;
    if ( LookupAccountSid( NULL,
                            Sid,
                            NameBuffer,
                            &NameLen,
                            DomainBuffer,
                            &DomainLen,
                            &NameUse ) ) {


        //
        //  Allocate a buffer for the name
        //

        *name = (LPWSTR)( new WCHAR[NameLen+1]);

        if ( *name != NULL ) {

            RtlCopyMemory( *name, NameBuffer, (NameLen+1)*sizeof(WCHAR) );
            RetVal = TRUE;

        }
    }

    delete Sid;
    return RetVal;
}

//=============================================================================
// CreduiGetAdministratorsGroupInfo
//
// Returns a structure containing members of the well-known local
// Administrators group. The caller is responsible for freeing the returned
// memory via NetApiBufferFree.
//
// Arguments:
//   groupInfo (out)
//   memberCount (out)
//
// Returns TRUE on success or FALSE otherwise.
//
// Created 04/13/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiGetAdministratorsGroupInfo(
    LOCALGROUP_MEMBERS_INFO_2 **groupInfo,
    DWORD *memberCount
    )
{
    BOOL success = FALSE;

    *groupInfo = NULL;
    *memberCount = 0;

    SID_IDENTIFIER_AUTHORITY ntAuth = SECURITY_NT_AUTHORITY;

    SID *adminsSid = NULL;

    if (AllocateAndInitializeSid(&ntAuth,
                                 2,
                                 SECURITY_BUILTIN_DOMAIN_RID,
                                 DOMAIN_ALIAS_RID_ADMINS,
                                 0,
                                 0,
                                 0,
                                 0,
                                 0,
                                 0,
                                 reinterpret_cast<VOID **>(&adminsSid)))
    {
        WCHAR user[UNLEN + 1];
        WCHAR domain[UNLEN + 1];

        DWORD userLength = (sizeof user) / (sizeof (WCHAR));
        DWORD domainLength = (sizeof domain) / (sizeof (WCHAR));

        SID_NAME_USE nameUse;

        // Get the name of the well-known Administrators SID:

        if (LookupAccountSid(NULL,
                             adminsSid,
                             user,
                             &userLength,
                             domain,
                             &domainLength,
                             &nameUse))
        {
            LOCALGROUP_MEMBERS_INFO_2 *info;
            DWORD count;
            DWORD total;

            if (NetLocalGroupGetMembers(NULL,
                                        user,
                                        2,
                                        reinterpret_cast<BYTE **>(&info),
                                        MAX_PREFERRED_LENGTH,
                                        &count,
                                        &total,
                                        NULL) == NERR_Success)
            {
                *groupInfo = info;
                *memberCount = count;

                success = TRUE;
            }
        }

        FreeSid(adminsSid);
    }

    return success;
}

//=============================================================================
// CreduiIsRemovableCertificate
//
// Arguments:
//   certContext (in) - certificate context to query
//
// Returns TRUE if the certificate has a removable component (such as a smart
// card) or FALSE otherwise.
//
// Created 04/09/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiIsRemovableCertificate(
    CONST CERT_CONTEXT *certContext
    )
{
    ASSERT(certContext != NULL);

    BOOL isRemovable = FALSE;

    // First, determine the buffer size:

    DWORD bufferSize = 0;

    if (CertGetCertificateContextProperty(
            certContext,
            CERT_KEY_PROV_INFO_PROP_ID,
            NULL,
            &bufferSize))
    {
        // Allocate the buffer on the stack:

        CRYPT_KEY_PROV_INFO *provInfo;

        __try
        {
            provInfo = static_cast<CRYPT_KEY_PROV_INFO *>(alloca(bufferSize));
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            provInfo = NULL;
        }

        if (provInfo != NULL)
        {
            if (CertGetCertificateContextProperty(
                    certContext,
                    CERT_KEY_PROV_INFO_PROP_ID,
                    provInfo,
                    &bufferSize))
            {
                HCRYPTPROV provContext;

                if (CryptAcquireContext(
                        &provContext,
                        NULL,
                        provInfo->pwszProvName,
                        provInfo->dwProvType,
                        CRYPT_VERIFYCONTEXT | CRYPT_SILENT))
                {
                    DWORD impType;
                    DWORD impTypeSize = sizeof impType;

                    if (CryptGetProvParam(
                            provContext,
                            PP_IMPTYPE,
                            reinterpret_cast<BYTE *>(&impType),
                            &impTypeSize,
                            0))
                    {
                        if (impType & CRYPT_IMPL_REMOVABLE)
                        {
                            isRemovable = TRUE;
                        }
                    }

                    if (!CryptReleaseContext(provContext, 0))
                    {
                        CreduiDebugLog(
                            "CreduiIsRemovableCertificate: "
                            "CryptReleaseContext failed: %u\n",
                            GetLastError());
                    }
                }
            }
        }
    }

    return isRemovable;
}

//=============================================================================
// CreduiIsExpiredCertificate
//
// Arguments:
//   certContext (in) - certificate context to query
//
// Returns TRUE if the certificate has expired or FALSE otherwise.
//
// Created 06/12/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiIsExpiredCertificate(
    CONST CERT_CONTEXT *certContext
    )
{
    ASSERT(certContext != NULL);

    DWORD flags = CERT_STORE_TIME_VALIDITY_FLAG;

    return CertVerifySubjectCertificateContext(certContext,
                                               NULL,
                                               &flags) &&
           (flags & CERT_STORE_TIME_VALIDITY_FLAG);
}

//=============================================================================
// CreduiIsClientAuthCertificate
//
// Arguments:
//   certContext (in) - certificate context to query
//
// Returns TRUE if the certificate has the client authentication enhanced key
// usage extension (not property) or FALSE otherwise.
//
// Created 07/12/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiIsClientAuthCertificate(
    CONST CERT_CONTEXT *certContext
    )
{
    ASSERT(certContext != NULL);

    BOOL isClientAuth = FALSE;

    // First, determine the buffer size:

    DWORD bufferSize = 0;

    if (CertGetEnhancedKeyUsage(
            certContext,
            CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG,
            NULL,
            &bufferSize))
    {
        // Allocate the buffer on the stack:

        CERT_ENHKEY_USAGE *usage;

        __try
        {
            usage = static_cast<CERT_ENHKEY_USAGE *>(alloca(bufferSize));
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            usage = NULL;
        }

        if (usage != NULL)
        {
            if (CertGetEnhancedKeyUsage(
                    certContext,
                    CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG,
                    usage,
                    &bufferSize))
            {
                for (UINT i = 0; i < usage->cUsageIdentifier; ++i)
                {
                    if (lstrcmpA(usage->rgpszUsageIdentifier[i],
                                 szOID_PKIX_KP_CLIENT_AUTH) == 0)
                    {
                        isClientAuth = TRUE;
                        break;
                    }
                }
            }
        }
    }

    return isClientAuth;
}

//=============================================================================
// CreduiGetCertificateDisplayName
//
// Arguments:
//   certContext (in)
//   displayName (out)
//   displayNameMaxChars (in)
//   certificateString (in)
//   dwDisplayType (in)
//
// Returns TRUE if a display name was stored or FALSE otherwise.
//
// Created 06/12/2000 johnstep (John Stephens)
//=============================================================================


BOOL
CreduiGetCertificateDisplayName(
    CONST CERT_CONTEXT *certContext,
    WCHAR *displayName,
    ULONG displayNameMaxChars,
    WCHAR *certificateString,
    DWORD dwDisplayType
    )
{
    ASSERT(displayNameMaxChars >= 16);

    BOOL success = FALSE;

    WCHAR *tempName;
    ULONG tempNameMaxChars = displayNameMaxChars / 2 - 1;

    __try
    {
        tempName =
            static_cast<WCHAR *>(
                alloca(tempNameMaxChars * sizeof (WCHAR)));
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        tempName = NULL;
    }

    if (tempName == NULL)
    {
        return FALSE;
    }

    displayName[0] = L'\0';
    tempName[0] = L'\0';

    if (CertGetNameString(
            certContext,
            dwDisplayType,
            0,
            NULL,
            tempName,
            tempNameMaxChars))
    {
        success = TRUE;
        lstrcpy(displayName, tempName);
    }

    if (CertGetNameString(
            certContext,
            dwDisplayType,
            CERT_NAME_ISSUER_FLAG,
            NULL,
            tempName,
            tempNameMaxChars))
    {
        if (lstrcmpi(displayName, tempName) != 0)
        {
            success = TRUE;

            WCHAR *where = &displayName[lstrlen(displayName)];

            if (where > displayName)
            {
                *where++ = L' ';
                *where++ = L'-';
                *where++ = L' ';
            }

            lstrcpy(where, tempName);
        }
    }

    return success;
}

//=============================================================================
// CreduiIsWildcardTargetName
//
// This function determines if the given target name is a wildcard name.
// Currently, that means it either starts with a '*' or ends with a '*'. I
// suppose, a more general solution is to simply search for a '*' anywhere in
// the name.
//
// Arguments:
//   targetName (in) - The string to search
//
// Return TRUE if the target name is a wildcard name or FALSE otherwise.
//
// Created 03/09/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiIsWildcardTargetName(
    WCHAR *targetName
    )
{
    if ((targetName != NULL) && (targetName[0] != L'\0'))
    {
        return (targetName[0] == L'*') ||
               (targetName[lstrlen(targetName) - 1] == L'*');
    }
    else
    {
        return FALSE;
    }
}

//=============================================================================
// CreduiIsPostfixString
//
// This function determines if the postfix string is in fact a postfix string
// of the source string. This is similar to a strstr type of function, except
// the substring (postfix) must be at the end of the source string.
//
// Arguments:
//   source (in) - The string to search
//   postfix (in) - The postfix string to search for
//
// Return TRUE if postfix is a postfix string of source or FALSE otherwise
//
// Created 03/09/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiIsPostfixString(
    WCHAR *source,
    WCHAR *postfix
    )
{
    ULONG sourceLength = lstrlen(source);
    ULONG postfixLength = lstrlen(postfix);

    if (sourceLength >= postfixLength)
    {
        return lstrcmpi(source + sourceLength - postfixLength, postfix) == 0;
    }

    return FALSE;
}


//
// returns TRUE if pszUserName exists as a prefix of pszCredential
//
// The UserName can either be an exact match or must be a prefix of a significant component.
//  That is, the first unmatched character must be an @ or \ character

BOOL
LookForUserNameMatch (
    const WCHAR * pszUserName,
    const WCHAR * pszCredential
    )
{
    ULONG length;
    int cmp;

    if ( pszUserName == NULL || pszCredential == NULL )
        return FALSE;


    length = wcslen ( pszUserName );
    if ( length <= 0 )
        return FALSE;

    if ( _wcsicmp ( pszUserName, pszCredential ) == 0 )
        return TRUE;

    if ( _wcsnicmp ( pszUserName, pszCredential, length ) == 0 ) {
        if ( pszCredential[length] == '@' || pszCredential[length] == '\\' ) {
            return TRUE;
        }
    }


    // didn't find it
    return FALSE;
}


// copies the marshalled name of pCert into pszMarshalledName.
// pszMarshalledName must be at least CREDUI_MAX_USERNAME_LENGTH in length
//
// returns TRUE if successful, FALSE if not
BOOL
CredUIMarshallNode (
    CERT_ENUM * pCert,
    WCHAR* pszMarshalledName
    )
{
    BOOL bMarshalled = FALSE;

    // marshall username
    WCHAR *marshaledCred;
    CERT_CREDENTIAL_INFO certCredInfo;

    certCredInfo.cbSize = sizeof certCredInfo;

    if (pCert != NULL)
    {
        DWORD length = CERT_HASH_LENGTH;

        if (CertGetCertificateContextProperty(
                pCert->pCertContext,
                CERT_SHA1_HASH_PROP_ID,
                static_cast<VOID *>(
                    certCredInfo.rgbHashOfCert),
                &length))
        {
            if (LocalCredMarshalCredentialW(CertCredential,
                                      &certCredInfo,
                                      &marshaledCred))
            {
                wcsncpy ( pszMarshalledName, marshaledCred, CREDUI_MAX_USERNAME_LENGTH );
                bMarshalled = TRUE;

                LocalCredFree(static_cast<VOID *>(marshaledCred));

            }

        }

    }

    return bMarshalled;
}

#define MAX_KEY_LENGTH   1024


// removes any leading *. from pszIn and copies the right hand portion to pszOut.
// Assumes pszOut is at least MAX_KEY_LENGTH in size
void
StripLeadingWildcard (
    WCHAR* pszIn,
    WCHAR* pszOut )
{
    WCHAR* pStartPtr = pszIn;

    if ( wcslen ( pszIn ) > 2 )
    {
        if ( pszIn[0] == L'*' && pszIn[1] == L'.' )
        {
            pStartPtr += 2;
        }
    }

    wcsncpy ( pszOut, pStartPtr, MAX_KEY_LENGTH );
}


// copies pszIn to pszOut and trucates pszOut at the first '\'
// Assumes pszOut is at least MAX_KEY_LENGTH in size
void
StripTrailingWildcard (
    WCHAR* pszIn,
    WCHAR* pszOut )
{
    wcsncpy ( pszOut, pszIn, MAX_KEY_LENGTH );

    wcstok ( pszOut, L"\\" );
}


// Looks in the registry for an SSO entry for the specified package.
// Fills in the SSOPackage struct and returns TRUE if found.  Returns
// FALSE if no registry entry found
BOOL
GetSSOPackageInfo (
    CREDENTIAL_TARGET_INFORMATION* pTargetInfo,
    SSOPACKAGE* pSSOStruct
    )
{

    BOOL bSSO = FALSE;
    WCHAR szKeyName[MAX_KEY_LENGTH];
    HKEY key;
    DWORD dwType;
    DWORD dwSize;

    WCHAR szSSOName[MAX_KEY_LENGTH];

    if ( pSSOStruct == NULL )
        return FALSE;

    pSSOStruct->szBrand[0] = '\0';
    pSSOStruct->szURL[0] = '\0';
    pSSOStruct->szAttrib[0] = '\0';
    pSSOStruct->dwRegistrationCompleted = 0;
    pSSOStruct->dwNumRegistrationRuns = 0;
    pSSOStruct->pRegistrationWizard = NULL;


    // figure out SSO Name from Target Info
    if ( pTargetInfo == NULL )
        return FALSE;


    if ( pTargetInfo->PackageName != NULL && wcslen(pTargetInfo->PackageName) < MAX_KEY_LENGTH )
    {
        wcsncpy ( szSSOName, pTargetInfo->PackageName, MAX_KEY_LENGTH );
    }
    else
    {
        return FALSE;
    }

    _snwprintf (
        szKeyName,
        MAX_KEY_LENGTH,
        L"SYSTEM\\CurrentControlSet\\Control\\Lsa\\SSO\\%s",
        szSSOName );

    if ( RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            szKeyName,
            0,
            KEY_READ,
            &key) == ERROR_SUCCESS)
    {
        dwSize = MAX_SSO_URL_SIZE * sizeof(WCHAR);

        bSSO = TRUE;

        if ( RegQueryValueEx(
                key,
                L"SSOBrand",
                NULL,
                &dwType,
                (LPBYTE)(pSSOStruct->szBrand),
                &dwSize) == ERROR_SUCCESS )
        {
            bSSO = TRUE;
        }


        dwSize = MAX_SSO_URL_SIZE * sizeof(WCHAR);
        if ( RegQueryValueEx(
                key,
                L"SSOAttribute",
                NULL,
                &dwType,
                (LPBYTE)(pSSOStruct->szAttrib),
                &dwSize ) != ERROR_SUCCESS )
        {
            if ( wcsstr ( szSSOName, L"Passport" ) )
            {
                wcscpy ( pSSOStruct->szAttrib, L"Passport" );
            }
        }

        RegCloseKey(key);

    }

    // Now get stuff under Internet Settings
    _snwprintf (
        szKeyName,
        MAX_KEY_LENGTH,
        L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\%s",
        pSSOStruct->szAttrib );


    if ( RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                szKeyName,
                0,
                KEY_READ,
                &key) == ERROR_SUCCESS)
    {
        dwSize = MAX_SSO_URL_SIZE * sizeof(WCHAR);
        if ( RegQueryValueEx(
                key,
                L"RegistrationUrl",
                NULL,
                &dwType,
                (LPBYTE)(pSSOStruct->szRegURL),
                &dwSize) == ERROR_SUCCESS )
        {

        }

        dwSize = MAX_SSO_URL_SIZE * sizeof(WCHAR);
        if ( RegQueryValueEx(
                key,
                L"Help",
                NULL,
                &dwType,
                (LPBYTE)(pSSOStruct->szHelpURL),
                &dwSize) == ERROR_SUCCESS )
        {

        }

        RegCloseKey(key);

    }


    if ( RegOpenKeyEx(
            HKEY_CURRENT_USER,
            szKeyName,
            0,
            KEY_READ,
            &key) == ERROR_SUCCESS)
    {

        dwSize = sizeof(DWORD);
        if ( RegQueryValueEx(
                key,
                L"RegistrationCompleted",
                NULL,
                &dwType,
                (LPBYTE)&(pSSOStruct->dwRegistrationCompleted),
                &dwSize ) == ERROR_SUCCESS )
        {
        }

        dwSize = sizeof(DWORD);
        if ( RegQueryValueEx(
                key,
                L"NumRegistrationRuns",
                NULL,
                &dwType,
                (LPBYTE)&(pSSOStruct->dwNumRegistrationRuns),
                &dwSize ) == ERROR_SUCCESS )
        {
        }

        RegCloseKey(key);

    }

    // TBD - get regwizard CLSID
    if ( bSSO && IsDeaultSSORealm ( pTargetInfo->DnsDomainName ) )
    {
        pSSOStruct->pRegistrationWizard = &CLSID_PassportWizard;
    }

    return bSSO;

}





// returns TRUE if it was found, with the value copied to pszRealm.
// pszRealm is expected to be at least CREDUI_MAX_DOMAIN_TARGET_LENGTH in length
// returns FALSE if not found
BOOL ReadPassportRealmFromRegistry (
    WCHAR* pszRealm
    )
{
    BOOL retval = FALSE;
    HKEY key;

    if ( pszRealm == NULL )
        return FALSE;

    if ( RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Passport",
            0,
            KEY_READ,
            &key) == ERROR_SUCCESS)
    {
        DWORD dwType;
        DWORD dwSize;

        dwSize = CREDUI_MAX_DOMAIN_TARGET_LENGTH * sizeof(WCHAR);

        if ( RegQueryValueEx(
                key,
                L"LoginServerRealm",
                NULL,
                &dwType,
                (LPBYTE)(pszRealm),
                &dwSize) == ERROR_SUCCESS )
        {
            if ( wcslen(pszRealm) > 0 )
                retval = TRUE;
            else
                retval = FALSE;
        }
        else
        {
            retval = FALSE;
            pszRealm[0] = L'\0';
        }

        RegCloseKey(key);

    }

    return retval;

}

#define MAX_SZTARGETNAME 256

BOOL CheckForSSOCred( WCHAR* pszTargetRealm )
{
    BOOL bIsItThere = FALSE;

    WCHAR szTargetName[MAX_SZTARGETNAME + 1];

    if ( pszTargetRealm != NULL )
    {
        wcsncpy ( szTargetName, pszTargetRealm, MAX_SZTARGETNAME);
        szTargetName[MAX_SZTARGETNAME] = 0;
    }
    else
    {
        GetDeaultSSORealm ( szTargetName, FALSE );
    }

    if ( wcslen ( szTargetName ) != 0 )
    {
        // finalize the target name
        wcscat ( szTargetName, L"\\*" );

        PCREDENTIALW pCred;
        DWORD dwFlags = 0;

        // first call credmgr to set the target info
        if ( CredReadW ( szTargetName,
                    CRED_TYPE_DOMAIN_VISIBLE_PASSWORD,
                    dwFlags,
                    &pCred ) )
        {
            bIsItThere = TRUE;

            CredFree ( pCred );

        }
        else
        {
            bIsItThere = FALSE;

        }
    }
    else
    {
        bIsItThere = FALSE;

    }

    return bIsItThere;

}

EXTERN_C typedef BOOL (STDAPICALLTYPE *PFN_FORCENEXUSLOOKUP)();

void GetDeaultSSORealm ( WCHAR* pszTargetName, BOOL bForceLookup )
{

    if ( pszTargetName == NULL )
        return;

    pszTargetName[0] = L'\0';

    // check the registry to see if we've already written the passport
    if ( ! ReadPassportRealmFromRegistry ( pszTargetName ) && bForceLookup )
    {
        // if not, call winiet to do this and then re-read the registry

        HMODULE hWininet = LoadLibrary(L"wininet.dll");
        if ( hWininet )
        {

            PFN_FORCENEXUSLOOKUP pfnForceNexusLookup = (PFN_FORCENEXUSLOOKUP)GetProcAddress(hWininet, "ForceNexusLookup");
            if ( pfnForceNexusLookup )
            {
                pfnForceNexusLookup();
            }

            FreeLibrary ( hWininet );
        }


        // try again
        if ( ! ReadPassportRealmFromRegistry ( pszTargetName ) )
            return;

    }

}

// returns TRUE if the targetrealm equals the default
BOOL IsDeaultSSORealm ( WCHAR* pszTargetName )
{
    BOOL bRet = FALSE;


    if ( pszTargetName == NULL )
        return FALSE;   // can't be the default if it doesn't exist

    WCHAR szTarget[CREDUI_MAX_DOMAIN_TARGET_LENGTH];

    GetDeaultSSORealm ( szTarget, TRUE );

    if ( wcslen ( szTarget ) > 0 )
    {
        if ( _wcsicmp ( szTarget, pszTargetName) == 0 )
        {
            bRet = TRUE;
        }
    }
    
    return bRet;

}


// encrypt cred

DWORD EncryptPassword ( PWSTR pszPassword, PVOID* ppszEncryptedPassword, DWORD* pSize )
{
    DWORD dwResult = ERROR_GEN_FAILURE;

    if ( pszPassword == NULL || ppszEncryptedPassword == NULL )
        return ERROR_INVALID_PARAMETER;


    DATA_BLOB InBlob;
    DATA_BLOB OutBlob;

    InBlob.pbData = (BYTE*)pszPassword;
    InBlob.cbData = sizeof(WCHAR)*(wcslen(pszPassword)+1);

    DATA_BLOB EntropyBlob;
    WCHAR szSalt[SIZE_OF_SALT];
    wcscpy ( szSalt, g_szSalt);
    for ( int i = 0; i < SIZE_OF_SALT; i++ )
        szSalt[i] <<= SALT_SHIFT;
    EntropyBlob.pbData = (BYTE*)szSalt;
    EntropyBlob.cbData = sizeof(WCHAR)*(wcslen(szSalt)+1);

    if ( CryptProtectData ( &InBlob,
                            L"SSOCred",
                            &EntropyBlob,           // optional entropy
//                            NULL,           // optional entropy
                            NULL,
                            NULL,
                            CRYPTPROTECT_UI_FORBIDDEN,
                            &OutBlob ) )
    {

        *ppszEncryptedPassword = (PWSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, OutBlob.cbData);
        if ( *ppszEncryptedPassword )
        {
            memcpy ( *ppszEncryptedPassword, OutBlob.pbData, OutBlob.cbData );
            *pSize = OutBlob.cbData;
            dwResult = ERROR_SUCCESS;
        }
        LocalFree ( OutBlob.pbData );
    }

    memset ( szSalt, 0, SIZE_OF_SALT);

    return dwResult;

}


BOOL IsPasswordEncrypted ( PVOID pPassword, DWORD cbSize )
{
    BOOL bRet = FALSE;

    DATA_BLOB InBlob;
    DATA_BLOB OutBlob;
    LPWSTR pszDesc;

    InBlob.pbData = (BYTE*)pPassword;
    InBlob.cbData = cbSize;

    DATA_BLOB EntropyBlob;
    WCHAR szSalt[SIZE_OF_SALT];
    wcscpy ( szSalt, g_szSalt);
    for ( int i = 0; i < SIZE_OF_SALT; i++ )
        szSalt[i] <<= SALT_SHIFT;
    EntropyBlob.pbData = (BYTE*)szSalt;
    EntropyBlob.cbData = sizeof(WCHAR)*(wcslen(szSalt)+1);
    
    if ( CryptUnprotectData ( &InBlob,
                            &pszDesc,
                            &EntropyBlob,
//                            NULL,
                            NULL,
                            NULL,
                            CRYPTPROTECT_UI_FORBIDDEN,
                            &OutBlob ) )
    {

        if ( wcscmp (L"SSOCred", pszDesc) == 0 )
        {
            bRet = TRUE;
        }
        LocalFree ( pszDesc );
        LocalFree ( OutBlob.pbData );
    }

    memset ( szSalt, 0, SIZE_OF_SALT);

    return bRet;
}




// cred confirmation routines

VOID
DeleteConfirmationListEntry (
    IN CRED_AWAITING_CONFIRMATION* pConf
    )
/*++

Routine Description:

    This routine deletes a single confirmation list entry.

Arguments:

    pConf - Confirmation list entry to delete

Return Values:

    None.

--*/
{
    //
    // Delete the target info
    //

    if ( pConf->TargetInfo != NULL ) {
        LocalCredFree( pConf->TargetInfo );
    }

    //
    // Delete the credential
    //

    if ( pConf->EncodedCredential != NULL ) {

        if ( pConf->EncodedCredential->CredentialBlobSize != 0 &&
             pConf->EncodedCredential->CredentialBlob != NULL ) {

            ZeroMemory( pConf->EncodedCredential->CredentialBlob,
                        pConf->EncodedCredential->CredentialBlobSize );

        }
        LocalCredFree( pConf->EncodedCredential );
    }



    //
    // Free the confirmation list entry itself
    //
    delete (pConf);
}

DWORD
WriteCred(
    IN PCWSTR pszTargetName,
    IN DWORD Flags,
    IN PCREDENTIAL_TARGET_INFORMATION TargetInfo OPTIONAL,
    IN PCREDENTIAL Credential,
    IN DWORD dwCredWriteFlags,
    IN BOOL DelayCredentialWrite,
    IN BOOL EncryptedVisiblePassword
    )

/*++

Routine Description:

    This routine writes a credential.

    If the credential needs confirmation, the credential will be added to the
    confirmation list.

Arguments:

    pszTargetName - The target name of the resource that caused the credential to be
        written.

    Flags - Flags passed by the original caller.
        CREDUI_FLAGS_EXPECT_CONFIRMATION - Specifies that the credential is to be written
            to the confirmation list instead of being written immediately.

    TargetInfo - The target information associated with the target name.
        If not specified, the target informatio isn't known.

    Credential - The credential that is to be written.

    dwCredWriteFlags - Flags to pass to CredWrite when writing the credential

    DelayCredentialWrite - TRUE if the credential is to be written only upon confirmation.
        FALSE, if the credential is to be written now as a session credential then
            morphed to a more persistent credential upon confirmation.
        This field is ignored if Flags doesn't specify CREDUI_FLAGS_EXPECT_CONFIRMATION.

Return Values:

    TRUE - The cred was sucessfully added to the confirmation list.

    FALSE - There isn't enough memory to add the cred to the confirmation list.

--*/
{
    DWORD Win32Status = NO_ERROR;
    BOOL WriteCredNow;
    PVOID pCredentialBlob = NULL;
    DWORD dwCredentialBlobSize = 0;
    CREDENTIAL TempCredential;


    //
    // Check to see if we should wait for confirmation
    //
    // ISSUE-2000/12/14-CliffV - there's no reason to avoid adding 'visible' passwords to
    //  the confirmation list.
    //

    if ( (Flags & CREDUI_FLAGS_EXPECT_CONFIRMATION) != 0 &&
         Credential->Type != CRED_TYPE_DOMAIN_VISIBLE_PASSWORD ) {

        if ( AddCredToConfirmationList ( pszTargetName,
                                         TargetInfo,
                                         Credential,
                                         dwCredWriteFlags,
                                         DelayCredentialWrite ) ) {

            //
            // Alter cred persistence type
            //  Then, at least, the credential will disappear upon logoff
            //

            Credential->Persist = CRED_PERSIST_SESSION;
            WriteCredNow = !DelayCredentialWrite;

        } else {

            // If we couldn't queue the CredWrite, do it now.
            WriteCredNow = TRUE;
        }

    //
    // If the caller doesn't supply a confirmation,
    //  write the credential now.
    //
    } else {
        WriteCredNow = TRUE;
    }

    //
    // Determine if we should encrypt the visible password
    //
    if ( Credential->Type == CRED_TYPE_DOMAIN_VISIBLE_PASSWORD && EncryptedVisiblePassword ) {

        // encrypt it

        if ( ERROR_SUCCESS == EncryptPassword ( (WCHAR*)Credential->CredentialBlob,
                                                 &pCredentialBlob,
                                                 &dwCredentialBlobSize ) )
        {

            // Make a copy of the credential so we don't modify the original

            TempCredential = *Credential;
            Credential = &TempCredential;

            Credential->CredentialBlob = (LPBYTE)pCredentialBlob;
            Credential->CredentialBlobSize = dwCredentialBlobSize;
        }
    }

    //
    // If the credential needs to be written now,
    //  do it
    //

    if ( WriteCredNow ) {

        if ( TargetInfo != NULL ) {
            if ( !LocalCredWriteDomainCredentialsW ( TargetInfo, Credential, dwCredWriteFlags) ) {
                Win32Status = GetLastError();
            }
        } else {
            if (!LocalCredWriteW( Credential, dwCredWriteFlags)) {
                Win32Status = GetLastError();
            }

        }
    }

    //
    // Free any credential blob we allocated.
    if ( pCredentialBlob )
    {
        ZeroMemory ( pCredentialBlob, dwCredentialBlobSize );
        LocalFree ( pCredentialBlob );
    }

    return Win32Status;
}


BOOL
AddCredToConfirmationList (
    IN PCWSTR pszTargetName,
    IN PCREDENTIAL_TARGET_INFORMATION TargetInfo OPTIONAL,
    IN PCREDENTIAL Credential,
    IN DWORD dwCredWriteFlags,
    IN BOOL DelayCredentialWrite
    )

/*++

Routine Description:

    This routine adds a credential to the confirmation list.  Such a credential must
    be confirmed at a later point in time or it will be deleted.

Arguments:

    pszTargetName - The target name of the resource that caused the credential to be
        written.  This target name is the handle used to identify the confirmation list
        entry.

    TargetInfo - The target information associated with the target name.
        If not specified, the target informatio isn't known.

    Credential - The credential that is to be written.

    dwCredWriteFlags - Flags to pass to CredWrite when writing the credential

    DelayCredentialWrite - TRUE if the credential is to be written only upon confirmation.
        FALSE, if the credential is to be written now as a session credential then
            morphed to a more persistent credential upon confirmation.

Return Values:

    TRUE - The cred was sucessfully added to the confirmation list.

    FALSE - There isn't enough memory to add the cred to the confirmation list.

--*/
{
    DWORD Win32Status;

    BOOLEAN bRetVal;
    CRED_AWAITING_CONFIRMATION* pNewEntry = NULL;
    CRED_AWAITING_CONFIRMATION* pOldEntry;

    CreduiDebugLog(
        "AddCredToConfirmationList: "
        "Called for target %S with target info %x\n",
        pszTargetName,(void *)TargetInfo);

    //
    // Allocate the entry itself
    //
    pNewEntry = new CRED_AWAITING_CONFIRMATION;

    if ( pNewEntry == NULL ) {
        bRetVal = FALSE;
        goto Cleanup;
    }

    //
    // Fill in the
    wcsncpy ( pNewEntry->szTargetName, pszTargetName, CRED_MAX_STRING_LENGTH+1+CRED_MAX_STRING_LENGTH);
    pNewEntry->szTargetName[CRED_MAX_STRING_LENGTH+1+CRED_MAX_STRING_LENGTH] = 0;
    pNewEntry->EncodedCredential = NULL;
    pNewEntry->TargetInfo = NULL;
    pNewEntry->DelayCredentialWrite = DelayCredentialWrite;
    pNewEntry->dwCredWriteFlags =dwCredWriteFlags;


    //
    // Make a copy of the target info
    //

    if ( TargetInfo != NULL ) {
        Win32Status = CredpConvertTargetInfo (
                                DoWtoW,
                                TargetInfo,
                                &pNewEntry->TargetInfo,
                                NULL );

        if ( Win32Status != NO_ERROR ) {
            bRetVal = FALSE;
            goto Cleanup;
        }

    }

    //
    // Make a copy of the credential
    //

    Win32Status = CredpConvertCredential (
                            DoWtoW,
                            DoBlobEncode,      // Encode the copied credential
                            Credential,
                            &pNewEntry->EncodedCredential );

    if ( Win32Status != NO_ERROR ) {
        bRetVal = FALSE;
        goto Cleanup;
    }


    //
    // Delete any existing entry
    //  (Wait until the new entry is allocated to ensure we don't delete the old
    //  entry when failing to create the new one.)
    //

    ConfirmCred( pszTargetName, FALSE, FALSE );

    //
    // Link the new entry into the global list
    //

    EnterCriticalSection( &CredConfirmationCritSect );
    
    if ( pCredConfirmationListHead == NULL) {
        pNewEntry->pNext = NULL;
    } else {
        pNewEntry->pNext = (void*)pCredConfirmationListHead;
    }

    pCredConfirmationListHead = pNewEntry;
    LeaveCriticalSection( &CredConfirmationCritSect );

    pNewEntry = NULL;

    bRetVal = TRUE;

    //
    // Release any locally used resources
    //
Cleanup:
    //
    // Free any partially allocated entry
    //

    if ( pNewEntry != NULL) {
        DeleteConfirmationListEntry( pNewEntry );
    }

    // Trim the list to 5 entries total
    INT i=0;                    // count the entries
    if ((pOldEntry = pCredConfirmationListHead) != NULL)
    {
        EnterCriticalSection( &CredConfirmationCritSect );
        while((pNewEntry = (CRED_AWAITING_CONFIRMATION*)(pOldEntry->pNext)) != NULL)
        {
            if (++i > 4)
            {
                // leave old (5th) entry alone, and remove all following one at a time
                pOldEntry->pNext = pNewEntry->pNext;
                CreduiDebugLog(
                    "AddCredToConfirmationList: "
                    "Removing excess waiting credential #%d for %S\n",
                    i,pNewEntry->szTargetName);
                // discard this record and continue to end
                DeleteConfirmationListEntry(pNewEntry);
            }
            else 
            {
                pOldEntry = pNewEntry;
                CreduiDebugLog(
                    "AddCredToConfirmationList: "
                    "Walking the list #%d\n",
                    i);
            }
        }
        LeaveCriticalSection( &CredConfirmationCritSect );
    }

    return bRetVal;
}



DWORD
ConfirmCred (
    IN PCWSTR pszTargetName,
    IN BOOL bConfirm,
    IN BOOL bOkToDelete
    )

/*++

Routine Description:

    This routine either confirms (bConfirm = TRUE ) or cancels (bConfirm = FALSE) the credential

Arguments:

    pszTargetName - The target name of the resource that caused the credential to be
        written.  This target name is the handle used to identify the confirmation list
        entry.

        ISSUE-2000/11/29-CliffV: We shouldn't be using pszTargetName as the handle.  It isn't
        specific enough.  We should use something that maps to a particular credential with a
        particular type.

    bConfirm - If TRUE, commits the credential.
        If FALSE, Aborts the transaction.  Deletes the transaction history.

    bOkToDelete - If TRUE and bConfirm is FALSE, any session credential created at the
        beginning of the transaction is deleted.  If FALSE, any session credential created at
        the begining of the transaction remains.

Return Values:

    Status of the operation.

--*/
{
    DWORD Result = NO_ERROR;

    CRED_AWAITING_CONFIRMATION* pPrev = NULL;
    CRED_AWAITING_CONFIRMATION* pConf;

    //
    // Find the credential in the global list.
    //

    EnterCriticalSection( &CredConfirmationCritSect );
    pConf = pCredConfirmationListHead;

    while ( pConf != NULL ) {

        if ( _wcsicmp ( pszTargetName, pConf->szTargetName ) == 0 ) {
            break;
        }

        pPrev = pConf;
        pConf = (CRED_AWAITING_CONFIRMATION*)pConf->pNext;

    }

    //
    // We found the cred indicated
    //
    if (pConf == NULL) {
        //return ERROR_NOT_FOUND;       cannot return here
        Result = ERROR_NOT_FOUND;
        goto Cleanup;
    } 
    else {

        //
        // If the caller wants to commit the change,
        //  do it by writing the cred to cred manager.
        //
        // This works even if DelayCredentialWrite is false.
        // In that case, a session persistent credential has already been written.
        // However, the cached credential is better than that credential in every respect.
        //

        if ( bConfirm ) {

            //
            // Decode the Credential before writing it
            //

            if (!CredpDecodeCredential( (PENCRYPTED_CREDENTIALW)pConf->EncodedCredential ) ) {

                Result = ERROR_INVALID_PARAMETER;

            //
            // Actually write the credential
            //

            } else if ( pConf->TargetInfo != NULL ) {

                if ( !LocalCredWriteDomainCredentialsW ( pConf->TargetInfo,
                                                         pConf->EncodedCredential,
                                                         pConf->dwCredWriteFlags) ) {

                    Result = GetLastError();
                }

            } else {

                if ( !LocalCredWriteW ( pConf->EncodedCredential,
                                        pConf->dwCredWriteFlags) ) {

                    Result = GetLastError();
                }

            }


        //
        // If the caller wants to abort the commit,
        //  delete any credential credui already created.
        //

        } else {

            //
            // Only do this if credui actually wrote the credential.
            //
            // Note there is a timing window where we might be deleting a credential
            //  other than the one credui just wrote.  However, we're weeding out
            //  the applications that don't use DelayCredentialWrite.  That's the
            //  real fix.  In the mean time, it is better to delete creds that that
            //  don't work.
            //

            if ( !pConf->DelayCredentialWrite && bOkToDelete ) {

                if ( !LocalCredDeleteW ( pConf->EncodedCredential->TargetName,
                                         pConf->EncodedCredential->Type,
                                         0 ) ) {

                    Result = GetLastError();
                }
            }
        }


        //
        // remove it from list
        //

        if ( pPrev ) {
            pPrev->pNext = pConf->pNext;
        } else {
            pCredConfirmationListHead = (CRED_AWAITING_CONFIRMATION*)(pConf->pNext);
        }

        DeleteConfirmationListEntry(pConf);

    }
Cleanup:
    LeaveCriticalSection( &CredConfirmationCritSect );
    return Result;

}

void
CleanUpConfirmationList ()
{

    CRED_AWAITING_CONFIRMATION* pNext;
    CRED_AWAITING_CONFIRMATION* pConf;


    EnterCriticalSection( &CredConfirmationCritSect );
    pConf = pCredConfirmationListHead;

    while ( pConf != NULL )
    {

        pNext = (CRED_AWAITING_CONFIRMATION*)pConf->pNext;
        DeleteConfirmationListEntry(pConf);
        pConf = pNext;

    }

    pCredConfirmationListHead = NULL;
    LeaveCriticalSection( &CredConfirmationCritSect );

    //
    // Delete the Critical Section used to serialize access to the global list
    //

    DeleteCriticalSection( &CredConfirmationCritSect );

}

BOOL
InitConfirmationList ()
{
    //
    // Initialize the Critical Section used to serialize access to the global list
    //
    pCredConfirmationListHead = NULL;
    return InitializeCriticalSectionAndSpinCount( &CredConfirmationCritSect, 0 );

}



/////////////////
// wincred.h dynamic stuff
//

BOOL bCredMgrAvailable = FALSE;
PFN_CREDWRITEW pfnCredWriteW = NULL;
PFN_CREDREADW pfnCredReadW = NULL;
PFN_CREDENUMERATEW pfnCredEnumerateW = NULL;
PFN_CREDWRITEDOMAINCREDENTIALSW pfnCredWriteDomainCredentialsW = NULL;
PFN_CREDREADDOMAINCREDENTIALSW pfnCredReadDomainCredentialsW = NULL;
PFN_CREDDELETEW pfnCredDeleteW = NULL;
PFN_CREDRENAMEW pfnCredRenameW = NULL;
PFN_CREDGETTARGETINFOW pfnCredGetTargetInfoW = NULL;
PFN_CREDMARSHALCREDENTIALW pfnCredMarshalCredentialW = NULL;
PFN_CREDUNMARSHALCREDENTIALW pfnCredUnMarshalCredentialW = NULL;
PFN_CREDISMARSHALEDCREDENTIALW pfnCredIsMarshaledCredentialW = NULL;
PFN_CREDISMARSHALEDCREDENTIALA pfnCredIsMarshaledCredentialA = NULL;
PFN_CREDGETSESSIONTYPES pfnCredGetSessionTypes = NULL;
PFN_CREDFREE pfnCredFree = NULL;


// attempts to load credmgr functions - returns TRUE if credmgr is avail, FALSE if not
BOOL
InitializeCredMgr ()
{

    bCredMgrAvailable = FALSE;

    if ( hAdvapi32 == NULL )
        hAdvapi32 = LoadLibrary(L"advapi32.dll");

    if ( hAdvapi32 != NULL )
    {

        pfnCredWriteW = (PFN_CREDWRITEW)
            GetProcAddress(hAdvapi32, "CredWriteW");
        if (*pfnCredWriteW == NULL)
        {
            FreeLibrary(hAdvapi32);
            hAdvapi32 = NULL;
            goto Exit;
        }

        pfnCredReadW = (PFN_CREDREADW)
            GetProcAddress(hAdvapi32, "CredReadW");
        if (*pfnCredReadW == NULL)
        {
            FreeLibrary(hAdvapi32);
            hAdvapi32 = NULL;
            goto Exit;
        }

        pfnCredEnumerateW = (PFN_CREDENUMERATEW)
            GetProcAddress(hAdvapi32, "CredEnumerateW");
        if (*pfnCredEnumerateW == NULL)
        {
            FreeLibrary(hAdvapi32);
            hAdvapi32 = NULL;
            goto Exit;
        }

        pfnCredWriteDomainCredentialsW = (PFN_CREDWRITEDOMAINCREDENTIALSW)
            GetProcAddress(hAdvapi32, "CredWriteDomainCredentialsW");
        if (*pfnCredWriteDomainCredentialsW == NULL)
        {
            FreeLibrary(hAdvapi32);
            hAdvapi32 = NULL;
            goto Exit;
        }

        pfnCredReadDomainCredentialsW = (PFN_CREDREADDOMAINCREDENTIALSW)
            GetProcAddress(hAdvapi32, "CredReadDomainCredentialsW");
        if (*pfnCredReadDomainCredentialsW == NULL)
        {
            FreeLibrary(hAdvapi32);
            hAdvapi32 = NULL;
            goto Exit;
        }

        pfnCredDeleteW = (PFN_CREDDELETEW)
            GetProcAddress(hAdvapi32, "CredDeleteW");
        if (*pfnCredDeleteW == NULL)
        {
            FreeLibrary(hAdvapi32);
            hAdvapi32 = NULL;
            goto Exit;
        }

        pfnCredRenameW = (PFN_CREDRENAMEW)
            GetProcAddress(hAdvapi32, "CredRenameW");
        if (*pfnCredRenameW == NULL)
        {
            FreeLibrary(hAdvapi32);
            hAdvapi32 = NULL;
            goto Exit;
        }

        pfnCredGetTargetInfoW = (PFN_CREDGETTARGETINFOW)
            GetProcAddress(hAdvapi32, "CredGetTargetInfoW");
        if (*pfnCredGetTargetInfoW == NULL)
        {
            FreeLibrary(hAdvapi32);
            hAdvapi32 = NULL;
            goto Exit;
        }

        pfnCredMarshalCredentialW = (PFN_CREDMARSHALCREDENTIALW)
            GetProcAddress(hAdvapi32, "CredMarshalCredentialW");
        if (*pfnCredMarshalCredentialW == NULL)
        {
            FreeLibrary(hAdvapi32);
            hAdvapi32 = NULL;
            goto Exit;
        }

        pfnCredUnMarshalCredentialW = (PFN_CREDUNMARSHALCREDENTIALW)
            GetProcAddress(hAdvapi32, "CredUnmarshalCredentialW");
        if (*pfnCredUnMarshalCredentialW == NULL)
        {
            FreeLibrary(hAdvapi32);
            hAdvapi32 = NULL;
            goto Exit;
        }

        pfnCredIsMarshaledCredentialW = (PFN_CREDISMARSHALEDCREDENTIALW)
            GetProcAddress(hAdvapi32, "CredIsMarshaledCredentialW");
        if (*pfnCredIsMarshaledCredentialW == NULL)
        {
            FreeLibrary(hAdvapi32);
            hAdvapi32 = NULL;
            goto Exit;
        }

        pfnCredIsMarshaledCredentialA = (PFN_CREDISMARSHALEDCREDENTIALA)
            GetProcAddress(hAdvapi32, "CredIsMarshaledCredentialA");
        if (*pfnCredIsMarshaledCredentialA == NULL)
        {
            FreeLibrary(hAdvapi32);
            hAdvapi32 = NULL;
            goto Exit;
        }

        pfnCredGetSessionTypes = (PFN_CREDGETSESSIONTYPES)
            GetProcAddress(hAdvapi32, "CredGetSessionTypes");
        if (*pfnCredGetSessionTypes == NULL)
        {
            FreeLibrary(hAdvapi32);
            hAdvapi32 = NULL;
            goto Exit;
        }

        pfnCredFree = (PFN_CREDFREE)
            GetProcAddress(hAdvapi32, "CredFree");
        if (*pfnCredFree == NULL)
        {
            FreeLibrary(hAdvapi32);
            hAdvapi32 = NULL;
            goto Exit;
        }

        bCredMgrAvailable = TRUE;
    }

Exit:

    return bCredMgrAvailable;

}


void
UninitializeCredMgr ()
{


    if ( hAdvapi32 != NULL )
        FreeLibrary(hAdvapi32);

    bCredMgrAvailable = FALSE;

}

/////////////////////
// Local functions to indirect CredMgr funcs
//

BOOL
WINAPI
LocalCredWriteW (
    IN PCREDENTIALW Credential,
    IN DWORD Flags
    )
{
    if ( bCredMgrAvailable && pfnCredWriteW != NULL )
    {
        if (pfnCredWriteW(Credential,Flags))
        {
            return TRUE;
        }
        else
        {
            if (ERROR_INVALID_PARAMETER == GetLastError())
            {
                // attempt to null the alias field of the cred and try again
                Credential->TargetAlias = NULL;
                return pfnCredWriteW(Credential,Flags);
            }
            else
            {
                // Something else was wrong
                return FALSE;
            }
        }
    }
    else
    {
        return FALSE;
    }


}


BOOL
WINAPI
LocalCredReadW (
    IN LPCWSTR TargetName,
    IN DWORD Type,
    IN DWORD Flags,
    OUT PCREDENTIALW *Credential
    )
{
    if ( bCredMgrAvailable && pfnCredReadW != NULL )
    {
        return pfnCredReadW ( TargetName, Type, Flags, Credential );
    }
    else
    {
        return FALSE;
    }

}

BOOL
WINAPI
LocalCredEnumerateW (
    IN LPCWSTR Filter,
    IN DWORD Flags,
    OUT DWORD *Count,
    OUT PCREDENTIALW **Credential
    )
{
    if ( bCredMgrAvailable && pfnCredEnumerateW != NULL )
    {
        return pfnCredEnumerateW ( Filter, Flags, Count, Credential );
    }
    else
    {
        return FALSE;
    }

}



BOOL
WINAPI
LocalCredWriteDomainCredentialsW (
    IN PCREDENTIAL_TARGET_INFORMATIONW TargetInfo,
    IN PCREDENTIALW Credential,
    IN DWORD Flags
    )
{
    if ( bCredMgrAvailable && pfnCredWriteDomainCredentialsW != NULL )
    {
        if (pfnCredWriteDomainCredentialsW ( TargetInfo, Credential, Flags ))
        {
            return TRUE;
        }
        else
        {
            if (ERROR_INVALID_PARAMETER == GetLastError())
            {
                // attempt to null the alias field of the cred and try again
                Credential->TargetAlias = NULL;
                return pfnCredWriteDomainCredentialsW ( TargetInfo, Credential, Flags );
            }
            else
            {
                return FALSE;
            }
        }
    }
    else
    {
        return FALSE;
    }

}

BOOL
WINAPI
LocalCredReadDomainCredentialsW (
    IN PCREDENTIAL_TARGET_INFORMATIONW TargetInfo,
    IN DWORD Flags,
    OUT DWORD *Count,
    OUT PCREDENTIALW **Credential
    )
{
    if ( bCredMgrAvailable && pfnCredReadDomainCredentialsW != NULL )
    {
        return pfnCredReadDomainCredentialsW ( TargetInfo, Flags, Count, Credential );
    }
    else
    {
        return FALSE;
    }

}

BOOL
WINAPI
LocalCredDeleteW (
    IN LPCWSTR TargetName,
    IN DWORD Type,
    IN DWORD Flags
    )
{
    if ( bCredMgrAvailable && pfnCredDeleteW != NULL )
    {
        return pfnCredDeleteW ( TargetName, Type, Flags );
    }
    else
    {
        return FALSE;
    }


}

BOOL
WINAPI
LocalCredRenameW (
    IN LPCWSTR OldTargetName,
    IN LPCWSTR NewTargetName,
    IN DWORD Type,
    IN DWORD Flags
    )
{
    if ( bCredMgrAvailable && pfnCredRenameW != NULL )
    {
        return pfnCredRenameW ( OldTargetName, NewTargetName, Type, Flags );
    }
    else
    {
        return FALSE;
    }

}


BOOL
WINAPI
LocalCredGetTargetInfoW (
    IN LPCWSTR TargetName,
    IN DWORD Flags,
    OUT PCREDENTIAL_TARGET_INFORMATIONW *TargetInfo
    )
{
    if ( bCredMgrAvailable && pfnCredGetTargetInfoW != NULL )
    {
        return pfnCredGetTargetInfoW ( TargetName, Flags, TargetInfo);
    }
    else
    {
        return FALSE;
    }


}


BOOL
WINAPI
LocalCredMarshalCredentialW(
    IN CRED_MARSHAL_TYPE CredType,
    IN PVOID Credential,
    OUT LPWSTR *MarshaledCredential
    )
{
    if ( bCredMgrAvailable && pfnCredMarshalCredentialW != NULL )
    {
        return pfnCredMarshalCredentialW ( CredType, Credential, MarshaledCredential );
    }
    else
    {
        return FALSE;
    }

}


BOOL
WINAPI
LocalCredUnmarshalCredentialW(
    IN LPCWSTR MarshaledCredential,
    OUT PCRED_MARSHAL_TYPE CredType,
    OUT PVOID *Credential
    )
{
    if ( bCredMgrAvailable && pfnCredUnMarshalCredentialW != NULL )
    {
        return pfnCredUnMarshalCredentialW ( MarshaledCredential, CredType, Credential );
    }
    else
    {
        return FALSE;
    }

}


BOOL
WINAPI
LocalCredIsMarshaledCredentialW(
    IN LPCWSTR MarshaledCredential
    )
{
    if ( bCredMgrAvailable && pfnCredIsMarshaledCredentialW != NULL )
    {
        return pfnCredIsMarshaledCredentialW ( MarshaledCredential );
    }
    else
    {
        return FALSE;
    }

}

BOOL
WINAPI
LocalCredIsMarshaledCredentialA(
    IN LPCSTR MarshaledCredential
    )
{
    if ( bCredMgrAvailable && pfnCredIsMarshaledCredentialA != NULL )
    {
        return pfnCredIsMarshaledCredentialA ( MarshaledCredential );
    }
    else
    {
        return FALSE;
    }

}


BOOL
WINAPI
LocalCredGetSessionTypes (
    IN DWORD MaximumPersistCount,
    OUT LPDWORD MaximumPersist
    )
{
    if ( bCredMgrAvailable && pfnCredGetSessionTypes != NULL )
    {
        return pfnCredGetSessionTypes ( MaximumPersistCount, MaximumPersist );
    }
    else
    {
        return FALSE;
    }

}

VOID
WINAPI
LocalCredFree (
    IN PVOID Buffer
    )
{
    if ( bCredMgrAvailable && pfnCredFree != NULL )
    {
        pfnCredFree ( Buffer );
    }
    else
    {

    }


}

VOID
CredPutStdout(
    IN LPWSTR String
    )
/*++

Routine Description:

    Output a string to stdout in the Console code page

    We can't use fputws since it uses the wrong code page.

Arguments:

    String - String to output

Return Values:

    None.

--*/
{
    int size;
    LPSTR Buffer = NULL;
    HANDLE hC = GetStdHandle(STD_OUTPUT_HANDLE);    // std output device handle
    DWORD dwcc = 0;                                                     // char count
    DWORD dwWritten = 0;                                            // chars actually sent
    BOOL fIsConsole = TRUE;                                         // default - tested and set

    if (String == NULL) return;                                       // done if no string
    
    if (hC != NULL)
    {
        DWORD ft = GetFileType(hC);
        ft &= ~FILE_TYPE_REMOTE;
        fIsConsole = (ft == FILE_TYPE_CHAR);
    }

    dwcc = wcslen(String);
    
    if (fIsConsole) 
    {
        WriteConsole(hC,String,dwcc,&dwWritten,NULL);
        return;
    }

    // Handle non-console output routing
    //
    // Compute the size of the converted string
    //

    size = WideCharToMultiByte( GetConsoleOutputCP(),
                                0,
                                String,
                                -1,
                                NULL,
                                0,
                                NULL,
                                NULL );

    if ( size == 0 ) {
        return;
    }

    //
    // Allocate a buffer for it
    //

    __try {
        Buffer = static_cast<LPSTR>( alloca(size) );
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        Buffer = NULL;
    }

    if ( Buffer == NULL) {
        return;
    }

    //
    // Convert the string to the console code page
    //

    size = WideCharToMultiByte( GetConsoleOutputCP(),
                                0,
                                String,
                                -1,
                                Buffer,
                                size,
                                NULL,
                                NULL );

    if ( size == 0 ) {
        return;
    }

    //
    // Write the string to stdout
    //

    //fputs( Buffer, stdout );
    WriteFile(hC,Buffer,size,&dwWritten,NULL);

}


/***    GetPasswdStr -- read in password string
 *
 *      DWORD GetPasswdStr(char far *, USHORT);
 *
 *      ENTRY:  buf             buffer to put string in
 *              buflen          size of buffer
 *              &len            address of USHORT to place length in
 *
 *      RETURNS:
 *              0 or NERR_BufTooSmall if user typed too much.  Buffer
 *              contents are only valid on 0 return.
 *
 *      History:
 *              who     when    what
 *              erichn  5/10/89 initial code
 *              dannygl 5/28/89 modified DBCS usage
 *              erichn  7/04/89 handles backspaces
 *              danhi   4/16/91 32 bit version for NT
 *              cliffv  3/12/01 Stolen from netcmd
 */
#define CR              0xD
#define BACKSPACE       0x8

DWORD
GetPasswdStr(
    LPWSTR  buf,
    DWORD   buflen,
    PDWORD  len
    )
{
    WCHAR   ch;
    WCHAR   *bufPtr = buf;
    DWORD   c;
    DWORD   err;
    DWORD   mode;

    buflen -= 1;    /* make space for null terminator */
    *len = 0;       /* GP fault probe (a la API's)    */


    //
    // Init mode in case GetConsoleMode() fails
    //

    mode = ENABLE_LINE_INPUT | ENABLE_ECHO_INPUT | ENABLE_PROCESSED_INPUT |
               ENABLE_MOUSE_INPUT;

    GetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), &mode);

    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE),
        (~(ENABLE_ECHO_INPUT|ENABLE_LINE_INPUT)) & mode);

    while (TRUE) {

        err = ReadConsole(GetStdHandle(STD_INPUT_HANDLE), &ch, 1, &c, 0);

        if (!err || c != 1) {
            ch = 0xffff;
        }

        if ((ch == CR) || (ch == 0xffff))       /* end of the line */
        {
            break;
        }

        if (ch == BACKSPACE)    /* back up one or two */
        {
            /*
             * IF bufPtr == buf then the next two lines are
             * a no op.
             */
            if (bufPtr != buf)
            {
                bufPtr--;
                (*len)--;
            }
        }
        else
        {
            *bufPtr = ch;

            if (*len < buflen)
                bufPtr++ ;                   /* don't overflow buf */
            (*len)++;                        /* always increment len */
        }
    }

    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), mode);

    *bufPtr = '\0';         /* null terminate the string */
    putchar( '\n' );

    return ((*len <= buflen) ? 0 : NERR_BufTooSmall);
}


/***    GetString -- read in string with echo
 *
 *      DWORD GetString(char far *, USHORT, USHORT far *, char far *);
 *
 *      ENTRY:  buf             buffer to put string in
 *              buflen          size of buffer
 *              &len            address of USHORT to place length in
 *
 *      RETURNS:
 *              0 or NERR_BufTooSmall if user typed too much.  Buffer
 *              contents are only valid on 0 return.  Len is ALWAYS valid.
 *
 *      OTHER EFFECTS:
 *              len is set to hold number of bytes typed, regardless of
 *              buffer length.
 *
 *      Read in a string a character at a time.  Is aware of DBCS.
 *
 *      History:
 *              who     when    what
 *              erichn  5/11/89 initial code
 *              dannygl 5/28/89 modified DBCS usage
 *              danhi   3/20/91 ported to 32 bits
 *              cliffv  3/12/01 Stolen from netcmd
 */

DWORD
GetString(
    LPWSTR  buf,
    DWORD   buflen,
    PDWORD  len
    )
{
    DWORD c;
    DWORD err;

    buflen -= 1;    /* make space for null terminator */
    *len = 0;       /* GP fault probe (a la API's) */

    while (TRUE) {
        err = ReadConsole(GetStdHandle(STD_INPUT_HANDLE), buf, 1, &c, 0);
        if (!err || c != 1) {
            *buf = 0xffff;
        }

        if (*buf == (WCHAR)EOF) {
            break;
        }

        if (*buf ==  '\r' || *buf == '\n' ) {
            INPUT_RECORD    ir;
            DWORD cr;

            if (PeekConsoleInput(GetStdHandle(STD_INPUT_HANDLE), &ir, 1, &cr)) {
                ReadConsole(GetStdHandle(STD_INPUT_HANDLE), buf, 1, &c, 0);
            }
            break;
        }

        buf += (*len < buflen) ? 1 : 0; /* don't overflow buf */
        (*len)++;                       /* always increment len */
    }

    *buf = '\0';            /* null terminate the string */

    return ((*len <= buflen) ? 0 : NERR_BufTooSmall);
}


VOID
CredGetStdin(
    OUT LPWSTR Buffer,
    IN DWORD BufferMaxChars,
    IN BOOLEAN EchoChars
    )
/*++

Routine Description:

    Input a string from stdin in the Console code page.

    We can't use fgetws since it uses the wrong code page.

Arguments:

    Buffer - Buffer to put the read string into.
        The Buffer will be zero terminated and will have any traing CR/LF removed

    BufferMaxChars - Maximum number of characters to return in the buffer not including
        the trailing NULL.

    EchoChars - TRUE if the typed characters are to be echoed.
        FALSE if not.

Return Values:

    None.

--*/
{
    DWORD NetStatus;
    DWORD Length;

    if ( EchoChars ) {
        NetStatus = GetString( Buffer,
                               BufferMaxChars+1,
                               &Length );
    } else {
        NetStatus = GetPasswdStr( Buffer,
                                  BufferMaxChars+1,
                                  &Length );
    }

    if ( NetStatus == NERR_BufTooSmall ) {
        Buffer[0] = '\0';
    }
}


BOOLEAN
CredpValidateDnsString(
    IN OUT LPWSTR String OPTIONAL,
    IN DNS_NAME_FORMAT DnsNameFormat,
    OUT PULONG StringSize
    )

/*++

Routine Description:

    This routine validates a passed in string.  The string must be a valid DNS name.
    Any trailing . is truncated.

Arguments:

    String - String to validate
        Any trailing . is truncated.
        This field is only modified if the routine returns TRUE.

    DnsNameFormat - Expected format of the name.

    StringSize - Returns the length of the string (in bytes) including the
        trailing zero character.
        This field is only updated if the routine returns TRUE.

Return Values:

    TRUE - String is valid.

    FALSE - String is not valid.

--*/

{
    ULONG TempStringLen;

    if ( String == NULL ) {
        return FALSE;
    }

    TempStringLen = wcslen( String );

    if ( TempStringLen == 0 ) {
        return FALSE;
    } else {
        //
        // Remove the trailing .
        //
        if ( String[TempStringLen-1] == L'.' ) {

            TempStringLen -= 1;

            //
            // Ensure the string isn't empty now.
            //

            if ( TempStringLen == 0 ) {
                return FALSE;

            //
            // Ensure there aren't multiple trailing .'s
            //
            } else {
                if ( String[TempStringLen-1] == L'.' ) {
                    return FALSE;
                }
            }
        }

        //
        // Have DNS finish the validation
        //

        if ( TempStringLen != 0 ) {
            DWORD WinStatus;

            WinStatus = DnsValidateName_W( String, DnsNameFormat );

            if ( WinStatus != NO_ERROR &&
                 WinStatus != DNS_ERROR_NON_RFC_NAME ) {

                //
                // The RFC says hostnames cannot have numeric leftmost labels.
                //  However, Win 2K servers have such hostnames.
                //  So, allow them here forever more.
                //

                if ( DnsNameFormat == DnsNameHostnameFull &&
                     WinStatus == DNS_ERROR_NUMERIC_NAME ) {

                    /* Drop through */

                } else {
                    return FALSE;
                }

            }
        }
    }

    if ( TempStringLen > DNS_MAX_NAME_LENGTH ) {
        return FALSE;
    }

    String[TempStringLen] = L'\0';
    *StringSize = (TempStringLen + 1) * sizeof(WCHAR);
    return TRUE;
}


DWORD
CredUIParseUserNameWithType(
    CONST WCHAR *UserName,
    WCHAR *user,
    ULONG userBufferSize,
    WCHAR *domain,
    ULONG domainBufferSize,
    PCREDUI_USERNAME_TYPE UsernameType
    )
/*++

Routine Description:

    Same as CredUIParseUserNameW except it returns an enum defining which username
    syntax was found.

Arguments:

    UserName - The user name to be parsed.

    user - Specifies a buffer to copy the user name portion of the parsed string to.

    userBufferSize - Specifies the size of the 'user' array in characters.
        The caller can ensure the passed in array is large enough by using an array
        that is CRED_MAX_USERNAME_LENGTH+1 characters long or by passing in an array that
        is wcslen(UserName)+1 characters long.

    domain - Specifies a buffer to copy the domain name portion of the parsed string to.

    domainBufferSize - Specifies the size of the 'domain' array in characters.
        The caller can ensure the passed in array is large enough by using an array
        that is CRED_MAX_USERNAME_LENGTH+1 characters long or by passing in an array that
        is wcslen(UserName)+1 characters long.

Return Values:

    The following status codes may be returned:

        ERROR_INVALID_ACCOUNT_NAME - The user name is not valid.

        ERROR_INVALID_PARAMETER - One of the parameters is invalid.

        ERROR_INSUFFICIENT_BUFFER - One of the buffers is too small.


--*/
{
    DWORD Status;
    ULONG UserNameLength;
    LPWSTR LocalUserName = NULL;
    LPWSTR SlashPointer;

    LPWSTR AtPointer;
    ULONG LocalStringSize;
    LPCWSTR UserNameToCopy = NULL;
    LPCWSTR DomainNameToCopy = NULL;

    //
    // Validate the input parameters
    //

    if ( UserName == NULL ||
         user == NULL ||
         domain == NULL ||
         userBufferSize == 0 ||
         domainBufferSize == 0 ) {

        return ERROR_INVALID_PARAMETER;
    }

    user[0] = L'\0';
    domain[0] = L'\0';

    //
    // Compute the length of the UserName
    //

    UserNameLength = wcslen ( UserName );

    if ( UserNameLength > CRED_MAX_USERNAME_LENGTH ) {
        return ERROR_INVALID_ACCOUNT_NAME;
    }

    //
    // If this is a marshalled credential reference,
    //  just copy the entire string as the username.
    //  Set the domain name to an empty string.
    //

    if (LocalCredIsMarshaledCredentialW( UserName)) {

        UserNameToCopy = UserName;
        *UsernameType = CreduiMarshalledUsername;
        Status = NO_ERROR;
        goto Cleanup;
    }


    //
    // Grab a local writable copy of the string.
    //

    LocalUserName = (LPWSTR) LocalAlloc( 0, (UserNameLength+1)*sizeof(WCHAR) );

    if ( LocalUserName == NULL ) {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    RtlCopyMemory( LocalUserName, UserName, (UserNameLength+1)*sizeof(WCHAR) );




    //
    // Classify the input account name.
    //
    // The name is considered to be <DomainName>\<UserName> if the string
    // contains an \.
    //

    SlashPointer = wcsrchr( LocalUserName, L'\\' );

    if ( SlashPointer != NULL ) {
        LPWSTR LocalUserNameEnd;
        LPWSTR AfterSlashPointer;

        //
        // Skip the backslash
        //

        *SlashPointer = L'\0';
        AfterSlashPointer = SlashPointer + 1;

        //
        // Ensure the string to the left of the \ is a valid domain name
        //
        // (Do DNS name first to allow the name to be canonicalized.)

        if ( !CredpValidateDnsString( LocalUserName, DnsNameDomain, &LocalStringSize ) &&
             !NetpIsDomainNameValid( LocalUserName ) ) {
            Status = ERROR_INVALID_ACCOUNT_NAME;
            goto Cleanup;
        }

        //
        // Ensure the string to the right of the \ is a valid user name
        //

        if ( !NetpIsUserNameValid( AfterSlashPointer )) {
            Status = ERROR_INVALID_ACCOUNT_NAME;
            goto Cleanup;
        }

        //
        // Copy the user name and domain name back to the caller.
        //

        UserNameToCopy = AfterSlashPointer;
        DomainNameToCopy = LocalUserName;

        *UsernameType = CreduiAbsoluteUsername;
        Status = NO_ERROR;
        goto Cleanup;

    }



    //
    // A UPN has the syntax <AccountName>@<DnsDomainName>.
    // If there are multiple @ signs,
    //  use the last one since an AccountName can have an @ in it.
    //
    //

    AtPointer = wcsrchr( LocalUserName, L'@' );
    if ( AtPointer != NULL ) {

        //
        // The string to the left of the @ can really have any syntax.
        //  But must be non-null.
        //

        if ( AtPointer == LocalUserName ) {
            Status = ERROR_INVALID_ACCOUNT_NAME;
            goto Cleanup;
        }


        //
        // Ensure the string to the right of the @ is a DNS domain name
        //

        AtPointer ++;
        if ( !CredpValidateDnsString( AtPointer, DnsNameDomain, &LocalStringSize ) ) {
            Status = ERROR_INVALID_ACCOUNT_NAME;
            goto Cleanup;
        }

        //
        // Return the entire UPN in the username field
        //

        UserNameToCopy = UserName;
        *UsernameType = CreduiUpn;
        Status = NO_ERROR;
        goto Cleanup;

    }

    //
    // Finally, check to see it it is an unqualified user name
    //

    if ( NetpIsUserNameValid( LocalUserName )) {

        UserNameToCopy = UserName;
        *UsernameType = CreduiRelativeUsername;
        Status = NO_ERROR;
        goto Cleanup;
    }


    //
    // All other values are invalid
    //

    Status = ERROR_INVALID_ACCOUNT_NAME;


    //
    // Cleanup
    //
Cleanup:

    //
    // On Success,
    //  copy the names back to the caller.
    //

    if ( Status == NO_ERROR ) {
        ULONG Length;

        //
        // Copy the user name back to the caller.
        //

        Length = wcslen( UserNameToCopy );

        if ( Length >= userBufferSize ) {
            Status = ERROR_INSUFFICIENT_BUFFER;
        } else {
            lstrcpy( user, UserNameToCopy );
        }

        //
        // Copy the domain name back to the caller
        //

        if ( Status == NO_ERROR && DomainNameToCopy != NULL ) {

            //
            // Copy the user name back to the caller.
            //

            Length = wcslen( DomainNameToCopy );

            if ( Length >= domainBufferSize ) {
                user[0] = L'\0';
                Status = ERROR_INSUFFICIENT_BUFFER;
            } else {
                lstrcpy( domain, DomainNameToCopy );
            }

        }

    }

    if ( LocalUserName != NULL ) {
        MIDL_user_free( LocalUserName );
    }

    return Status;

}

LPWSTR
GetAccountDomainName(
    VOID
    )
/*++

Routine Description:

    Returns the name of the account domain for this machine.

    For workstatations, the account domain is the netbios computer name.
    For DCs, the account domain is the netbios domain name.

Arguments:

    None.

Return Values:

    Returns a pointer to the name.  The name should be free using NetApiBufferFree.

    NULL - on error.

--*/
{
    DWORD WinStatus;

    LPWSTR AllocatedName = NULL;


    //
    // If this machine is a domain controller,
    //  get the domain name.
    //

    if ( CreduiIsDomainController ) {

        WinStatus = NetpGetDomainName( &AllocatedName );

        if ( WinStatus != NO_ERROR ) {
            return NULL;
        }

    //
    // Otherwise, the 'account domain' is the computername
    //

    } else {

        WinStatus = NetpGetComputerName( &AllocatedName );

        if ( WinStatus != NO_ERROR ) {
            return NULL;
        }

    }

    return AllocatedName;
}

BOOL
CompleteUserName(
    IN OUT LPWSTR UserName,
    IN ULONG UserNameMaxChars,
    IN PCREDENTIAL_TARGET_INFORMATIONW TargetInfo OPTIONAL,
    IN LPWSTR TargetName OPTIONAL,
    IN DWORD Flags
    )
/*++

Routine Description:

    Searches the user name for a domain name, and determines whether this
    specifies the target server or a domain. If a domain is not present in the
    user name, add it if this is a workstation or no target information is
    available.

Arguments:

    UserName - The username to modify.  The buffer is modified in place.

    UserNameMaxChars - Size (in chars) of the UserName buffer not including space for the
        trailing NULL.
        The input string may be shorter than this.

    TargetInfo - The TargetInfo describing the target these credentials are for.
        If not specified, the Target info will not be used to contruct the domain name.

    TargetName - The user supplied target name describing the target these credentials are for.

    Flags - As passed to CredUIPromptForCredentials()
    
Return Values:

    Returns TRUE if a domain was already present in the user name, or if we
    added one. Otherwise, return FALSE.

--*/
{
    BOOLEAN RetVal;

    DWORD WinStatus;
    WCHAR RetUserName[CRED_MAX_USERNAME_LENGTH + 1];
    WCHAR RetDomainName[CRED_MAX_USERNAME_LENGTH + 1];
    WCHAR LogonDomainName[CRED_MAX_USERNAME_LENGTH + 1];
    CREDUI_USERNAME_TYPE UsernameType;

    LPWSTR AllocatedName = NULL;

    WCHAR *serverName = NULL;


    if ((Flags & CREDUI_FLAGS_GENERIC_CREDENTIALS) &&
        !(Flags & CREDUI_FLAGS_COMPLETE_USERNAME)) return FALSE;
    
    //
    // Determine the type and validity of the user name
    //

    WinStatus = CredUIParseUserNameWithType(
                    UserName,
                    RetUserName,
                    CRED_MAX_USERNAME_LENGTH + 1,
                    RetDomainName,
                    CRED_MAX_USERNAME_LENGTH + 1,
                    &UsernameType );

    if ( WinStatus != NO_ERROR ) {
        RetVal = FALSE;
        goto Cleanup;
    }

    //
    // Most Types don't need to be completed
    //

    if ( UsernameType != CreduiRelativeUsername ) {
        RetVal = TRUE;
        goto Cleanup;
    }



    //
    // If we have target info,
    //  Use the information from the TargetInfo to qualify the username.
    //

    if (TargetInfo != NULL) {

        //
        // See if the target system claims to be a standalone system.
        //  In which case we just fill in the server name for the domain since
        //  all accounts valid for the system

        if ( TargetInfo->DnsTreeName != NULL ||
             TargetInfo->DnsDomainName != NULL ||
             TargetInfo->NetbiosDomainName != NULL ||
             (TargetInfo->Flags & CRED_TI_SERVER_FORMAT_UNKNOWN) != 0
          ) {

            // The target info contains domain information, so this is probably
            // not a standalone server; the user should enter the domain name:
            // gm: But we will prepend the user's logon domain name...
            ULONG ulSize = CRED_MAX_USERNAME_LENGTH;
            if (GetUserNameEx(NameSamCompatible,LogonDomainName,&ulSize))
            {
                WCHAR *pwc=wcschr(LogonDomainName, L'\\');
                if (NULL != pwc) 
                {
                    *pwc = '\0';    // term username at logon domain name only
                    serverName = LogonDomainName;
                }
            } 
            else 
            {
                RetVal = FALSE;
                goto Cleanup;
            }
        }
        else
        {
            if (TargetInfo->NetbiosServerName) {
                serverName = TargetInfo->NetbiosServerName;
            } else {
                serverName = TargetName;
            }
        }

    } 
    else if ( (TargetName != NULL)                     &&
            !CreduiIsWildcardTargetName(TargetName)             &&
            !(Flags & CREDUI_FLAGS_USERNAME_TARGET_CREDENTIALS)   )
    {

        // No target information, but this is not a wildcard target name, so
        // use this as the domain for the user name:

        serverName = TargetName;

        //
        // There is no target.
        //  therefore, the target must be the local machine.
        //  Use the 'account domain' of the local machine.

    } else {

        AllocatedName = GetAccountDomainName();

        serverName = AllocatedName;

    }

    //
    // If no name was found,
    //  we're done.
    //

    if (serverName == NULL) {
        RetVal = FALSE;
        goto Cleanup;
    }

    //
    // Append the found name
    //

    WCHAR *where;

    ULONG userNameLength = lstrlen(UserName);
    ULONG serverLength = lstrlen(serverName);

    if ((userNameLength == 0 ) ||
        (userNameLength + serverLength + 1) > UserNameMaxChars)
    {
        RetVal = FALSE;
        goto Cleanup;
    }

    WCHAR *source = UserName + userNameLength + 1;

    where = source + serverLength;

    while (source > UserName)
    {
        *where-- = *--source;
    }

    lstrcpy(UserName, serverName);
    *where = L'\\';

    RetVal = TRUE;

Cleanup:
    if ( AllocatedName != NULL ) {
        NetApiBufferFree ( AllocatedName );
    }

    return RetVal;
}


// returns TRUE if the wizard was sucessfull, FALSE if not and a dialog should be popped
BOOL TryLauchRegWizard ( 
    SSOPACKAGE* pSSOPackage,  
    HWND hwndParent,
    BOOL HasLogonSession,
    WCHAR *userName,
    ULONG userNameMaxChars,
    WCHAR *password,
    ULONG passwordMaxChars,
    DWORD* pResult
    )
{


    BOOL bDoPasswordDialog = TRUE;

    if ( pSSOPackage == NULL )
        return TRUE;

    if ( pResult == NULL )
        return TRUE;

    *pResult = ERROR_CANCELLED;



    IModalWindow* pPPWizModalWindow;

    // launch wizard, if one is registered
    if ( pSSOPackage->pRegistrationWizard != NULL )
    {
        gbStoredSSOCreds = FALSE;

        HRESULT hr = CoCreateInstance ( *(pSSOPackage->pRegistrationWizard), NULL, CLSCTX_INPROC_SERVER,
                                        IID_IModalWindow, (LPVOID*)&pPPWizModalWindow );

        if ( FAILED(hr) || pPPWizModalWindow == NULL )
        {
            bDoPasswordDialog = TRUE;
        }
        else
        {
            // check to see if we have a logon session to do passport creds
            if ( !HasLogonSession )
            {
                if ( gbWaitingForSSOCreds )
                {
                    // can't re-enter this section of code, just do the dialog
                    bDoPasswordDialog = TRUE;
                }
                else
                {
                    gbWaitingForSSOCreds = TRUE;
                    bDoPasswordDialog = FALSE;
                    ZeroMemory(gszSSOUserName, CREDUI_MAX_USERNAME_LENGTH * sizeof (WCHAR) );
                    ZeroMemory(gszSSOPassword, CREDUI_MAX_PASSWORD_LENGTH * sizeof (WCHAR) );
                }

            }
            else
            {
                bDoPasswordDialog = FALSE;
            }



            if ( bDoPasswordDialog == FALSE )
            {
                // try the wizard

                pPPWizModalWindow->Show(hwndParent);

                // check to see if it's been set
                if ( HasLogonSession ) 
                {
                    // look in credmgr
                    if ( gbStoredSSOCreds  ) //CheckForSSOCred( NULL ) )
                    {
                        *pResult = ERROR_SUCCESS;
                    }
                    else
                    {
                        *pResult = ERROR_CANCELLED;
                    }

                    // copy them to user-supplied input
                    if ( userName != NULL && password != NULL )
                    {
                        wcsncpy ( userName, gszSSOUserName, userNameMaxChars );
                        wcsncpy ( password, gszSSOPassword, passwordMaxChars );
                    }

                }
                else
                {
                    // look to see if it was squirreled away
                    if ( wcslen (gszSSOUserName) > 0 ) 
                    {
                        *pResult = ERROR_SUCCESS;

                        // copy them to user-supplied input
                        if ( userName != NULL && password != NULL )
                        {
                            wcsncpy ( userName, gszSSOUserName, userNameMaxChars );
                            wcsncpy ( password, gszSSOPassword, passwordMaxChars );
                        }
                        else
                        {
                            // can't do anything, return appropriate error to indicate no credmgr
                            *pResult = ERROR_NO_SUCH_LOGON_SESSION;
                        }

                    }
                    else
                    {
                        *pResult = ERROR_CANCELLED;
                    }

                    gbWaitingForSSOCreds = FALSE;
    
                }

                // zero out global strings
                ZeroMemory(gszSSOUserName, CREDUI_MAX_USERNAME_LENGTH * sizeof (WCHAR) );
                ZeroMemory(gszSSOPassword, CREDUI_MAX_PASSWORD_LENGTH * sizeof (WCHAR) );

            }

        }
    }


    return !bDoPasswordDialog;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\credui\creduit\creduit.cxx ===
/*--

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    creduit.cxx

Abstract:

    Test program for the credential manager UI API.


Author:

    16-Jan-2001 (cliffv)

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:


--*/

#define UNICODE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <shellapi.h>
#include <wincred.h>
#include <credp.h>
#include <stdio.h>
#include <stdlib.h>
#include <lmerr.h>
#include <align.h>

#define _CREDUI_
#include <wincrui.h>

#include <lmcons.h>
extern "C" {
#include <names.h>
#include <rpcutil.h>
}
#include <winerror.dbg>

//
// Structure defining a array of parsed strings
//

typedef struct _STRING_ARRAY {
    BOOLEAN Specified;
    DWORD Count;
#define STRING_ARRAY_COUNT 100
    LPWSTR Strings[STRING_ARRAY_COUNT];
} STRING_ARRAY, *PSTRING_ARRAY;

//
// Parsed Parameters
//

LPWSTR CommandLine;
DWORD GlCommand = 0xFFFFFFFF;

BOOLEAN GlAnsi;
BOOLEAN GlDoGui;

LPWSTR GlUserName;
LPWSTR GlTargetName;
LPWSTR GlMessage;
LPWSTR GlTitle;
LPWSTR GlAuthError;
DWORD GlCreduiFlags;
BOOLEAN GlNoConfirm;
BOOL GlSave;

//
// Table of valid parameters to the command.
//

struct _PARAMAMTER_DEF {
    LPWSTR Name;   // Name of the parameter

    LPSTR ValueName; // Test describing parameter value

    DWORD Type;     // Parameter type
#define PARM_COMMAND        1 // Parameter defines a command
#define PARM_COMMAND_STR    2 // Parameter defines a command (and has text string)
#define PARM_COMMAND_OPTSTR 3 // Parameter defines a command (and optionaly has text string)
#define PARM_STRING         4 // Parameter defines a text string
#define PARM_STRING_ENUM    5 // Parameter is an enumeration of text strings
#define PARM_STRING_ARRAY   6 // Parameter is an array of text strings
#define PARM_BOOLEAN        7 // Parameter set a boolean
#define PARM_BIT            8 // Parameter sets a bit in a DWORD

    PVOID Global;   // Address of global to write

    LPWSTR *EnumStrings;

    //
    // Describe relationships to other parameters.
    //
    DWORD Relationships;
#define ALLOW_CRED 0x01 // If specified, this parameter allows other IS_CRED parameters
#define IS_CRED    0x02 // This parameter is only allow if an ALLOW_CRED parameter has been seen previously
#define ALLOW_TI   0x10 // If specified, this parameter allows other IS_TI or IS_TIX parameters
#define IS_TI      0x20 // This parameter is only allow if an ALLOW_TI parameter has been seen previously
#define IS_TIX     0x40 // This parameter is only allow if an ALLOW_TI parameter has been seen previously
    LPSTR Comment;
} ParameterDefinitions[] =
{
    {L"UserName",   "UserName",          PARM_STRING,       &GlUserName,        NULL,            0,         "User Name" },
    {L"TargetName", "TargetName",        PARM_STRING,       &GlTargetName,      NULL,            0,         "Target Name" },
    {L"Message",    "Message",           PARM_STRING,       &GlMessage,         NULL,            0,         "Message for dialog box" },
    {L"Title",      "Title",             PARM_STRING,       &GlTitle,           NULL,            0,         "Title for dialog box" },
    {L"Gui",        NULL,                PARM_BOOLEAN,      &GlDoGui,           NULL,            0,         "Call GUI version of API" },
    {L"Ansi",       NULL,                PARM_BOOLEAN,      &GlAnsi,            NULL,            0,         "Use ANSI version of APIs" },
    { NULL },
    {L"ReqSmartcard",   (LPSTR)ULongToPtr(CREDUI_FLAGS_REQUIRE_SMARTCARD),    PARM_BIT, &GlCreduiFlags, NULL,            0,         "Require smartcard" },
    {L"ReqCertificate", (LPSTR)ULongToPtr(CREDUI_FLAGS_REQUIRE_CERTIFICATE),  PARM_BIT, &GlCreduiFlags, NULL,            0,         "Require certificate" },
    {L"ExcCertificates",(LPSTR)ULongToPtr(CREDUI_FLAGS_EXCLUDE_CERTIFICATES), PARM_BIT, &GlCreduiFlags, NULL,            0,         "Exclude certificates" },
    { NULL },
    {L"GenericCreds",   (LPSTR)ULongToPtr(CREDUI_FLAGS_GENERIC_CREDENTIALS),  PARM_BIT, &GlCreduiFlags, NULL,            0,         "Generic Credentials" },
    {L"RunasCreds",     (LPSTR)ULongToPtr(CREDUI_FLAGS_USERNAME_TARGET_CREDENTIALS),PARM_BIT,&GlCreduiFlags, NULL,       0,         "Runas Credentials" },
    { NULL },
    {L"Persist",        (LPSTR)ULongToPtr(CREDUI_FLAGS_PERSIST),              PARM_BIT, &GlCreduiFlags, NULL,            0,         "Always save Credentials" },
    {L"NoPersist",      (LPSTR)ULongToPtr(CREDUI_FLAGS_DO_NOT_PERSIST),       PARM_BIT, &GlCreduiFlags, NULL,            0,         "Never save Credentials" },
    {L"ShowSaveCheckbox:(T/F)",(LPSTR)ULongToPtr(CREDUI_FLAGS_SHOW_SAVE_CHECK_BOX), PARM_BIT, &GlCreduiFlags, ((LPWSTR *)&GlSave),   0,         "Show Save checkbox (initial value)" },
    { NULL },
    {L"ValidateUsername",(LPSTR)ULongToPtr(CREDUI_FLAGS_VALIDATE_USERNAME),   PARM_BIT, &GlCreduiFlags, NULL,            0,         "Validate Username" },
    {L"CompleteUsername",(LPSTR)ULongToPtr(CREDUI_FLAGS_COMPLETE_USERNAME),   PARM_BIT, &GlCreduiFlags, NULL,            0,         "Complete Username" },
    { NULL },
    {L"Confirm",         (LPSTR)ULongToPtr(CREDUI_FLAGS_EXPECT_CONFIRMATION), PARM_BIT, &GlCreduiFlags, NULL,            0,         "Confirm that the credential worked" },
    {L"NoConfirm",       NULL,                                                PARM_BOOLEAN,&GlNoConfirm,NULL,            0,         "Confirm that the credential failed" },
    { NULL },
    {L"AlwaysShowUi",(LPSTR)ULongToPtr(CREDUI_FLAGS_ALWAYS_SHOW_UI),          PARM_BIT, &GlCreduiFlags, NULL,            0,         "Always Show UI" },
    {L"IncorrectPassword",(LPSTR)ULongToPtr(CREDUI_FLAGS_INCORRECT_PASSWORD), PARM_BIT, &GlCreduiFlags, NULL,            0,         "Show 'incorrect password' tip" },
    {L"AuthError",       "ErrorNum",     PARM_STRING,       &GlAuthError,       NULL,            0,         "Previous auth error number" },


};
#define PARAMETER_COUNT (sizeof(ParameterDefinitions)/sizeof(ParameterDefinitions[0]))

VOID
PrintOneUsage(
    LPWSTR Argument OPTIONAL,
    ULONG ArgumentIndex
    )
/*++

Routine Description:

    Print the command line parameter usage for one parameter

Arguments:

    Argument - Argument as typed by caller
        NULL if printing complete list of arguments

    ArugmentIndex - Index of the parameter to print

Return Value:

    None

--*/
{
    ULONG j;

    if ( ParameterDefinitions[ArgumentIndex].Name == NULL ) {
        fprintf( stderr, "\n" );
        return;
    }

    if ( Argument != NULL ) {
        fprintf( stderr,  "\nSyntax of '%ls' parameter is:\n", Argument );
    }

    fprintf( stderr,  "    /%ls", ParameterDefinitions[ArgumentIndex].Name );

    switch ( ParameterDefinitions[ArgumentIndex].Type ) {
    case PARM_COMMAND:
    case PARM_BOOLEAN:
        break;
    case PARM_BIT:
        if ( ParameterDefinitions[ArgumentIndex].EnumStrings == NULL ) {
            break;
        } else {
            fprintf( stderr, ":{T/F}" );
            break;
        }
    case PARM_COMMAND_OPTSTR:
        fprintf( stderr, "[:<%s>]", ParameterDefinitions[ArgumentIndex].ValueName );
        break;
    case PARM_STRING:
    case PARM_COMMAND_STR:
        fprintf( stderr, ":<%s>", ParameterDefinitions[ArgumentIndex].ValueName );
        break;
    case PARM_STRING_ENUM:
        fprintf( stderr, ":<" );
        for ( j=0; ParameterDefinitions[ArgumentIndex].EnumStrings[j] != NULL; j++) {
            if ( j!= 0 ) {
                fprintf( stderr, "|");
            }
            fprintf( stderr, "%ls", ParameterDefinitions[ArgumentIndex].EnumStrings[j] );
        }
        fprintf( stderr, ">" );

        break;
    case PARM_STRING_ARRAY:
        fprintf( stderr, ":<%s>", ParameterDefinitions[ArgumentIndex].ValueName );
        break;
    }

    if ( Argument == NULL ) {
        fprintf( stderr, " - %s", ParameterDefinitions[ArgumentIndex].Comment );
    }

    fprintf( stderr, "\n" );

}

VOID
PrintUsage(
    )
/*++

Routine Description:

    Print the command line parameter usage.

Arguments:

    None

Return Value:

    None

--*/
{
    ULONG i;

    fprintf( stderr, "\nUsage: creduit [Options]\n\nWhere options are:\n\n");

    for ( i=0; i<PARAMETER_COUNT; i++ ) {
        PrintOneUsage( NULL, i );
    }

}

LPSTR
FindSymbolicNameForStatus(
    DWORD Id
    )
{
    ULONG i;

    i = 0;
    if (Id == 0) {
        return "NO_ERROR";
    }

#ifdef notdef
    if (Id & 0xC0000000) {
        while (ntstatusSymbolicNames[ i ].SymbolicName) {
            if (ntstatusSymbolicNames[ i ].MessageId == (NTSTATUS)Id) {
                return ntstatusSymbolicNames[ i ].SymbolicName;
            } else {
                i += 1;
            }
        }
    }
#endif // notdef

    while (winerrorSymbolicNames[ i ].SymbolicName) {
        if (winerrorSymbolicNames[ i ].MessageId == Id) {
            return winerrorSymbolicNames[ i ].SymbolicName;
        } else {
            i += 1;
        }
    }

#ifdef notdef
    while (neteventSymbolicNames[ i ].SymbolicName) {
        if (neteventSymbolicNames[ i ].MessageId == Id) {
            return neteventSymbolicNames[ i ].SymbolicName
        } else {
            i += 1;
        }
    }
#endif // notdef

    return NULL;
}


VOID
PrintStatus(
    DWORD NetStatus
    )
/*++

Routine Description:

    Print a net status code.

Arguments:

    NetStatus - The net status code to print.

Return Value:

    None

--*/
{
    printf( "Status = %lu 0x%lx", NetStatus, NetStatus );

    switch (NetStatus) {
    case NERR_Success:
        printf( " NERR_Success" );
        break;

    case NERR_DCNotFound:
        printf( " NERR_DCNotFound" );
        break;

    case NERR_UserNotFound:
        printf( " NERR_UserNotFound" );
        break;

    case NERR_NetNotStarted:
        printf( " NERR_NetNotStarted" );
        break;

    case NERR_WkstaNotStarted:
        printf( " NERR_WkstaNotStarted" );
        break;

    case NERR_ServerNotStarted:
        printf( " NERR_ServerNotStarted" );
        break;

    case NERR_BrowserNotStarted:
        printf( " NERR_BrowserNotStarted" );
        break;

    case NERR_ServiceNotInstalled:
        printf( " NERR_ServiceNotInstalled" );
        break;

    case NERR_BadTransactConfig:
        printf( " NERR_BadTransactConfig" );
        break;

    default:
        printf( " %s", FindSymbolicNameForStatus( NetStatus ) );
        break;

    }

    printf( "\n" );
}

VOID
PrintBytes(
    PVOID Buffer,
    DWORD BufferSize
    )
/*++

Routine Description:

    Dumps the buffer content as hex and characters.

Arguments:

    Buffer: buffer pointer.

    BufferSize: size of the buffer.

Return Value:

    none

--*/
{
#define NUM_CHARS 16

    DWORD i, limit;
    CHAR TextBuffer[NUM_CHARS + 1];
    LPBYTE BufferPtr = (LPBYTE)Buffer;
    BOOLEAN DumpDwords = FALSE;

    //
    // Preprocess
    //

    if ( BufferSize > NUM_CHARS ) {
        printf("\n");  // Ensure this starts on a new line
        printf("------------------------------------\n");
    } else {
        if ( BufferSize % sizeof(DWORD) == 0 ) {
            DumpDwords = TRUE;
        }
    }

    //
    // Hex dump of the bytes
    //
    limit = ((BufferSize - 1) / NUM_CHARS + 1) * NUM_CHARS;

    for (i = 0; i < limit; i++) {

        if (i < BufferSize) {

            if ( DumpDwords ) {
                if ( i % sizeof(DWORD) == 0 ) {
                    DWORD ADword;
                    RtlCopyMemory( &ADword, &BufferPtr[i], sizeof(DWORD) );
                    printf("%08x ", ADword);
                }
            } else {
                printf("%02x ", BufferPtr[i]);
            }

            if ( isprint(BufferPtr[i]) ) {
                TextBuffer[i % NUM_CHARS] = (CHAR) BufferPtr[i];
            } else {
                TextBuffer[i % NUM_CHARS] = '.';
            }

        } else {

            if ( DumpDwords ) {
                TextBuffer[i % NUM_CHARS] = '\0';
            } else {
                if ( BufferSize > NUM_CHARS ) {
                    printf("   ");
                    TextBuffer[i % NUM_CHARS] = ' ';
                } else {
                    TextBuffer[i % NUM_CHARS] = '\0';
                }
            }

        }

        if ((i + 1) % NUM_CHARS == 0) {
            TextBuffer[NUM_CHARS] = 0;
            printf("  %s\n", TextBuffer);
        }

    }

    if ( BufferSize > NUM_CHARS ) {
        printf("------------------------------------\n");
    } else if ( BufferSize < NUM_CHARS ) {
        printf("\n");
    }
}

VOID
PrintTime(
    LPSTR Comment,
    LPFILETIME ConvertTime
    )
/*++

Routine Description:

    Print the specified time

Arguments:

    Comment - Comment to print in front of the time

    Time - GMT time to print (Nothing is printed if this is zero)

Return Value:

    None

--*/
{
    //
    // If we've been asked to convert an NT GMT time to ascii,
    //  Do so
    //

    if ( ConvertTime->dwLowDateTime != 0 || ConvertTime->dwHighDateTime != 0 ) {
        SYSTEMTIME SystemTime;
        FILETIME LocalFileTime;

        printf( "%s", Comment );

        if ( !FileTimeToLocalFileTime( ConvertTime, &LocalFileTime ) ) {
            printf( "Can't convert time from GMT to Local time: " );
            PrintStatus( GetLastError() );
            return;
        }

        if ( !FileTimeToSystemTime( &LocalFileTime, &SystemTime ) ) {
            printf( "Can't convert time from file time to system time: " );
            PrintStatus( GetLastError() );
            return;
        }

        printf( "%ld/%ld/%ld %ld:%2.2ld:%2.2ld\n",
                SystemTime.wMonth,
                SystemTime.wDay,
                SystemTime.wYear,
                SystemTime.wHour,
                SystemTime.wMinute,
                SystemTime.wSecond );
    }
}


BOOLEAN
ParseParameters(
    VOID
    )
/*++

Routine Description:

    Parse the command line parameters

Arguments:

    None

Return Value:

    TRUE if parse was successful.

--*/
{
    LPWSTR *argvw;
    int argcw;
    int i;
    ULONG j;

    LPWSTR OrigArgument;
    LPWSTR Argument;


    //
    // Get the command line in Unicode
    //

    CommandLine = GetCommandLine();

    argvw = CommandLineToArgvW( CommandLine, &argcw );

    if ( argvw == NULL ) {
        fprintf( stderr, "Can't convert command line to Unicode: %ld\n", GetLastError() );

        return FALSE;
    }

    //
    // Loop through the command line arguments
    //

    for ( i=1; i<argcw; i++ ) {

        OrigArgument = Argument = argvw[i];

        //
        // Check if the Argument is a switch
        //

        if ( Argument[0] == '-' || Argument[0] == '/' ) {
            DWORD ArgumentIndex;
            ULONG ArgumentLength;
            PWCHAR ColonPointer;
            Argument ++;

            //
            // Find the colon at the end of the argument
            //

            ColonPointer = wcschr( Argument, L':' );
            if ( ColonPointer != NULL ) {
                *ColonPointer = '\0';
            }
            ArgumentLength = wcslen(Argument);

            //
            // Loop through the list of valid arguments finding all that match
            //

            ArgumentIndex = 0xFFFFFFFF;
            for ( j=0; j<PARAMETER_COUNT; j++ ) {

                //
                // Ignore placeholders
                //

                if ( ParameterDefinitions[j].Name == NULL ) {
                    continue;
                }

                //
                // Compare the names
                //

                if ( _wcsnicmp( Argument, ParameterDefinitions[j].Name, ArgumentLength ) == 0 ) {
                    //
                    // If more than one matches,
                    //  it's an error
                    //

                    if ( ArgumentIndex != 0xFFFFFFFF ) {
                        fprintf( stderr,
                                 "\nArgument '%ls' is ambiguous: %ls or %ls.\n",
                                 OrigArgument,
                                 ParameterDefinitions[j].Name,
                                 ParameterDefinitions[ArgumentIndex].Name );

                        return FALSE;
                    }

                    ArgumentIndex = j;

                    //
                    // If this is an exact match,
                    //  we're done.
                    //

                    if ( ArgumentLength == wcslen(ParameterDefinitions[j].Name)) {
                        break;
                    }
                }
            }

            //
            // If there were not matches,
            //  complain.
            //

            if ( ArgumentIndex == 0xFFFFFFFF ) {
                fprintf( stderr,
                         "\nArgument '%ls' is invalid.\n",
                         OrigArgument );
                PrintUsage();
                return FALSE;
            }

            //
            // Ensure the : is present as required
            //


            //
            // Return TRUE if the specified argument should have a : character after the
            //  argument name.
            //

            if ( ParameterDefinitions[ArgumentIndex].Type == PARM_COMMAND ||
                 ParameterDefinitions[ArgumentIndex].Type == PARM_BOOLEAN ||
                 (ParameterDefinitions[ArgumentIndex].Type == PARM_BIT &&
                  ParameterDefinitions[ArgumentIndex].EnumStrings == NULL ) ) {

                if ( ColonPointer != NULL ) {
                    PrintOneUsage( OrigArgument, ArgumentIndex );
                    return FALSE;
                }

            } else {

                if ( ColonPointer == NULL ) {
                    if ( ParameterDefinitions[ArgumentIndex].Type != PARM_COMMAND_OPTSTR ) {
                        PrintOneUsage( OrigArgument, ArgumentIndex );
                        return FALSE;
                    }
                } else {
                    Argument = ColonPointer + 1;
                }

            }

            //
            // Parse the rest of the argument
            //
            // Handle commands
            //

            switch ( ParameterDefinitions[ArgumentIndex].Type ) {
            case PARM_COMMAND:
            case PARM_COMMAND_STR:
            case PARM_COMMAND_OPTSTR:
                if ( GlCommand != 0xFFFFFFFF ) {
                    fprintf( stderr,
                             "\nArgument '%ls' and '/%ls' are mutually exclusive.\n",
                             OrigArgument,
                             ParameterDefinitions[GlCommand].Name );

                    return FALSE;
                }
                GlCommand = ArgumentIndex;


                /* Drop through */

            //
            // Handle parameters of the form /xxx:string
            //

            case PARM_STRING: {
                LPWSTR *StringPointer;
                StringPointer = (LPWSTR *)(ParameterDefinitions[ArgumentIndex].Global);

                //
                // If a string is not present,
                //  we're done.
                //

                if ( ColonPointer == NULL ) {
                    break;
                }

                //
                // Ensure argument only specified once.
                //

                if ( *StringPointer != NULL ) {
                    fprintf( stderr,
                             "\nArgument '%ls' may only be specified once.\n",
                             OrigArgument );

                    return FALSE;

                }

                //
                // Ensure an actual string was specified.
                //

                if ( *Argument == '\0' ) {
                    fprintf( stderr,
                             "\nArgument '%ls' requires a value.\n",
                             OrigArgument );

                    return FALSE;
                }


                *StringPointer = Argument;
                break;
            }

            //
            // Handle parameters of the form /xxx:a|b|c
            //

            case PARM_STRING_ENUM: {
                ULONG EnumIndex;
                LPDWORD DwordPointer;
                LPWSTR *EnumStrings;

                //
                // Ensure argument only specified once.
                //

                DwordPointer = (LPDWORD)(ParameterDefinitions[ArgumentIndex].Global);

                if ( *DwordPointer != 0 ) {
                    fprintf( stderr,
                             "\nArgument '%ls' may only be specified once.\n",
                             OrigArgument );

                    return FALSE;

                }

                EnumStrings = ParameterDefinitions[ArgumentIndex].EnumStrings;
                ArgumentLength = wcslen(Argument);

                //
                // Loop through the list of valid values finding all that match
                //

                EnumIndex = 0xFFFFFFFF;
                for ( j=0; EnumStrings[j] != NULL; j++ ) {

                    //
                    // Compare the names
                    //

                    if ( _wcsnicmp( Argument, EnumStrings[j], ArgumentLength ) == 0 ) {

                        //
                        // If more than one matches,
                        //  it's an error
                        //

                        if ( EnumIndex != 0xFFFFFFFF ) {

                            PrintOneUsage( OrigArgument, ArgumentIndex );

                            fprintf( stderr,
                                     "\nValue '%ls' is ambiguous: %ls or %ls.\n",
                                     Argument,
                                     EnumStrings[j],
                                     EnumStrings[EnumIndex] );

                            return FALSE;
                        }

                        EnumIndex = j;

                        //
                        // If this is an exact match,
                        //  we're done.
                        //

                        if ( ArgumentLength == wcslen(EnumStrings[j]) ) {
                            break;
                        }
                    }
                }

                //
                // If there were not matches,
                //  complain.
                //

                if ( EnumIndex == 0xFFFFFFFF ) {

                    PrintOneUsage( OrigArgument, ArgumentIndex );

                    fprintf( stderr,
                             "\nValue '%ls' is invalid.\n",
                             Argument );

                    return FALSE;
                }
                *DwordPointer = EnumIndex + 1;
                break;
            }

            //
            // Handle parameters of the form /xxx:a,b,c
            //

            case PARM_STRING_ARRAY: {
                PWCHAR CommaPointer;
                PSTRING_ARRAY StringArray;

                StringArray = ((PSTRING_ARRAY)(ParameterDefinitions[ArgumentIndex].Global));

                //
                // Ensure argument only specified once.
                //

                if ( StringArray->Specified ) {
                    fprintf( stderr,
                             "\nArgument '%ls' may only be specified once.\n",
                             OrigArgument );

                    return FALSE;

                }
                StringArray->Specified = TRUE;

                //
                // Loop through the values specified by the user
                //

                for (;;) {

                    //
                    // Ensure an actual string was specified.
                    //

                    if ( *Argument == '\0' ) {
                        fprintf( stderr,
                                 "\nArgument '%ls' requires a value.\n",
                                 OrigArgument );

                        return FALSE;
                    }

                    //
                    // Save it
                    //

                    StringArray->Count ++;

                    if ( StringArray->Count >= STRING_ARRAY_COUNT ) {
                        fprintf( stderr,
                                 "\nArgument '%ls' has too many values.\n",
                                 OrigArgument );

                        return FALSE;
                    }

                    StringArray->Strings[StringArray->Count-1] = Argument;

                    //
                    // Determine if there is another value
                    //
                    CommaPointer = wcschr( Argument, L',' );
                    if ( CommaPointer == NULL ) {
                        break;
                    }

                    *CommaPointer = '\0';
                    Argument = CommaPointer + 1;

                };

                break;
            }

            //
            // Handle parameters of the form /xxx
            //

            case PARM_BOOLEAN: {
                BOOLEAN *BooleanPointer;
                BooleanPointer = (BOOLEAN *)(ParameterDefinitions[ArgumentIndex].Global);

                *BooleanPointer = TRUE;
                break;
            }

            //
            // Handle parameters of the form /xxx that imply setting a bit
            //

            case PARM_BIT: {
                DWORD *DwordPointer;
                DwordPointer = (DWORD *)(ParameterDefinitions[ArgumentIndex].Global);

                *DwordPointer |= PtrToUlong( ParameterDefinitions[ArgumentIndex].ValueName );

                //
                // Some of these have TRUE or FALSE as an optional argument
                //

                if ( ParameterDefinitions[ArgumentIndex].EnumStrings != NULL ) {
                    if ( toupper(*Argument) == 'T' ) {
                        *((BOOL *)(ParameterDefinitions[ArgumentIndex].EnumStrings)) = TRUE;
                    } else if ( toupper(*Argument) == 'F' ) {
                        *((BOOL *)(ParameterDefinitions[ArgumentIndex].EnumStrings)) = FALSE;
                    } else {
                        fprintf( stderr,
                                 "\nArgument '%ls' requires a T or F as value.\n",
                                 OrigArgument );

                        return FALSE;
                    }
                }
                break;
            }

            default:
                fprintf( stderr,
                         "\nArgument '%ls' had an internal error.\n",
                         OrigArgument );
                return FALSE;

            }


        //
        // Handle arguments that aren't switches.
        //
        } else {

            //
            // All current arguments are switches
            //

            PrintUsage();
            return FALSE;

        }

    }


    return TRUE;
}


//
// Include routines to support the /ANSI parameter
//

LPSTR
NetpAllocAStrFromWStr (
    IN LPCWSTR Unicode
    )

/*++

Routine Description:

    Convert an UNICODE (zero terminated) string to the corresponding ANSI
    string.

Arguments:

    Unicode - Specifies the UNICODE zero terminated string to convert.


Return Value:

    NULL - There was some error in the conversion.

    Otherwise, it returns a pointer to the zero terminated ANSI string in
    an allocated buffer.  The buffer must be freed using NetApiBufferFree.

--*/

{
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;

    RtlInitUnicodeString( &UnicodeString, Unicode );

    AnsiString.MaximumLength =
        (USHORT) RtlUnicodeStringToAnsiSize( &UnicodeString );

    AnsiString.Buffer = (PCHAR) LocalAlloc( 0, AnsiString.MaximumLength );

    if ( AnsiString.Buffer == NULL) {
        return (NULL);
    }

    if(!NT_SUCCESS( RtlUnicodeStringToAnsiString( &AnsiString,
                                                  &UnicodeString,
                                                  FALSE))){
        (void) LocalFree( AnsiString.Buffer );
        return NULL;
    }

    return AnsiString.Buffer;

} // NetpAllocStrFromWStr

extern "C"
BOOL
DllMain(
    HINSTANCE instance,
    DWORD reason,
    VOID *
    );

int __cdecl
main(
    IN int argc,
    IN char ** argv
    )
/*++

Routine Description:

    Drive the credential manager API.

Arguments:

    argc - the number of command-line arguments.

    argv - an array of pointers to the arguments.

Return Value:

    Exit status

--*/
{
    DWORD WinStatus;
    WCHAR Password[CREDUI_MAX_PASSWORD_LENGTH + 1];
    WCHAR UserName[CREDUI_MAX_USERNAME_LENGTH + 1];
    DWORD AuthError = NO_ERROR;
    CREDUI_INFOW UiInfoW;
    PCREDUI_INFOW UiInfoWptr = NULL;

    //
    // Parse the command line parameters
    //

    UserName[0] = '\0';
    Password[0] = '\0';

    if ( !ParseParameters() ) {
        return 1;
    }

    //
    // Fill in the parameters
    //

    if ( GlUserName != NULL) {
        wcscpy( UserName, GlUserName );
    }

    //
    // Get the error number
    //

    if ( GlAuthError != NULL ) {
        LPWSTR End;

        AuthError = wcstoul( GlAuthError, &End, 10 );
    }

    //
    // Handle special parameters
    //

    if ( GlNoConfirm ) {
        GlCreduiFlags |= CREDUI_FLAGS_EXPECT_CONFIRMATION;
    }

    //
    // Build the UI info
    //

    if ( GlMessage || GlTitle ) {
        UiInfoWptr = &UiInfoW;

        ZeroMemory( &UiInfoW, sizeof(UiInfoW) );

        UiInfoW.cbSize = sizeof(UiInfoW);
        UiInfoW.pszMessageText = GlMessage;
        UiInfoW.pszCaptionText = GlTitle;
    }


    //
    // Execute the requested command
    //

    switch ( GlCommand ) {
    case 0xFFFFFFFF:
        if ( GlAnsi ) {
            printf( "We don't yet do ansi.\n");
        } else {

            if ( GlDoGui ) {
                WinStatus = CredUIPromptForCredentialsW(
                                UiInfoWptr,
                                GlTargetName,
                                NULL,   // No security context
                                AuthError,
                                UserName,
                                sizeof(UserName)/sizeof(WCHAR),
                                Password,
                                sizeof(Password)/sizeof(WCHAR),
                                &GlSave,
                                GlCreduiFlags );
            } else {
                WinStatus = CredUICmdLinePromptForCredentialsW(
                                GlTargetName,
                                NULL,   // No security context
                                AuthError,
                                UserName,
                                sizeof(UserName)/sizeof(WCHAR),
                                Password,
                                sizeof(Password)/sizeof(WCHAR),
                                &GlSave,
                                GlCreduiFlags );

            }

            if ( WinStatus != NO_ERROR ) {
                fprintf( stderr, "CredUIPromptForCredentialsW failed: \n" );
                PrintStatus( WinStatus );
                return 1;
            }

            printf( "UserName: '%ws'\n", UserName );
            printf( "Password: '%ws'\n", Password );
            printf( "Save: %ld\n", GlSave );

            //
            // Do confirmation
            //

            if ( GlCreduiFlags & CREDUI_FLAGS_EXPECT_CONFIRMATION ) {

                WinStatus = CredUIConfirmCredentialsW( GlTargetName, !GlNoConfirm );

                if ( WinStatus != NO_ERROR ) {
                    fprintf( stderr, "CredUIConfirmCredentialsW failed: \n" );
                    PrintStatus( WinStatus );
                }

            }
        }
        break;

    default:
        fprintf( stderr, "Internal error: %ld\n", GlCommand );
        return 1;
    }

    fprintf( stderr, "Command completed successfully.\n" );
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\autoenrl\csenroll\enroll.c ===
#include <windows.h>
#include <wincrypt.h>
#include <autoenr.h>
#include <cryptui.h>
#include <stdio.h>
#include <certca.h>
#include <stdlib.h>

#define SHA1_HASH_LEN 20
#define MSG_ERROR_S 1
#define MSG_ERROR_C 2
#define MSG_WARNING_S 4
#define MSG_WARNING_C 8
#define MSG_INFO_S 16
#define MSG_INFO_C 32

#define szOID_WINDOWS_SYSTEM_COMPONENT_VERIFICATION "1.3.6.1.4.1.311.10.3.6"
#define wszCERTTYPE_WINDOWS_TEST_BUILD_SIGNING L"WindowsTestBuildSigning"

PWCHAR mySanitizeName(IN WCHAR const *pwszName);

DWORD dwMsgLevel = MSG_ERROR_S | MSG_ERROR_C | MSG_INFO_S | MSG_INFO_C;

#define PrintMessage(MsgType, Msg) \
	if (MsgType & dwMsgLevel & MSG_ERROR_S)        _PrintMessage(L"csenroll: error: "); \
	else if (MsgType & dwMsgLevel & MSG_ERROR_C)   _PrintMessage(L"                 "); \
	else if (MsgType & dwMsgLevel & MSG_WARNING_S) _PrintMessage(L"csenroll: warning: "); \
	else if (MsgType & dwMsgLevel & MSG_WARNING_C) _PrintMessage(L"                   "); \
	else if (MsgType & dwMsgLevel & MSG_INFO_S) _PrintMessage(L"csenroll: "); \
	else if (MsgType & dwMsgLevel & MSG_INFO_C) _PrintMessage(L"          "); \
	if (MsgType & dwMsgLevel) _PrintMessage Msg

void
_PrintMessage(
	LPWSTR pwszFormat,
	...
	)
{
	WCHAR rgwszBuffer[1024];

	va_list argList;

	va_start(argList, pwszFormat);
	vswprintf(rgwszBuffer, pwszFormat, argList);

	fwprintf(stderr, rgwszBuffer);
}

				
BOOL
EnrollForCodeSigningCertificate(
    IN LPWSTR pwszCAName,
    IN LPWSTR pwszDNSName,
	PCERT_CONTEXT pOldCert
    )
{
    CRYPTUI_WIZ_CERT_REQUEST_INFO       CertRequestInfo;
    CRYPTUI_WIZ_CERT_REQUEST_PVK_NEW    NewKeyInfo;
    CRYPTUI_WIZ_CERT_TYPE               CertType;
    CRYPT_KEY_PROV_INFO                 ProviderInfo;
    PCCERT_CONTEXT                      pCertContext = NULL;
    PCCERT_CONTEXT                      pCert = NULL;
    DWORD                               dwCAStatus;
    DWORD                               dwAcquireFlags = 0;
    LPWSTR                              pwszProvName = NULL;
	WCHAR								rgwszMachineName[MAX_COMPUTERNAME_LENGTH + 1]; 
    DWORD                               cMachineName = MAX_COMPUTERNAME_LENGTH + 1;
    CRYPT_DATA_BLOB                     CryptData;
    DWORD                               dwErr = 0;
    BOOL                                fRet = FALSE;
	LPWSTR								rgwszCertType[2];

    memset(&CertRequestInfo, 0, sizeof(CertRequestInfo));
    memset(&NewKeyInfo, 0, sizeof(NewKeyInfo));
    memset(&ProviderInfo, 0, sizeof(ProviderInfo));
    memset(&rgwszMachineName, 0, sizeof(rgwszMachineName));
    memset(&CryptData, 0, sizeof(CryptData));
    memset(&CertType, 0, sizeof(CertType));

    // set up the provider info
    ProviderInfo.dwProvType = 0; // pInfo->dwProvType;
    ProviderInfo.pwszProvName = NULL;  // The wizard will choose one based
                                       // on the cert type

    // set the acquire context flags
    // UNDONE - need to add silent flag
    ProviderInfo.dwFlags = 0; // dwAcquireFlags;

    // set the key specification
    ProviderInfo.dwKeySpec = 0; // pInfo->dwKeySpec;

    // set up the new key info
    NewKeyInfo.dwSize = sizeof(NewKeyInfo);
    NewKeyInfo.pKeyProvInfo = &ProviderInfo;
    // set the flags to be passed when calling CryptGenKey
    NewKeyInfo.dwGenKeyFlags = 0; // pInfo->dwGenKeyFlags;

    // set the request info
    CertRequestInfo.dwSize = sizeof(CertRequestInfo);

    // cert exists then check if expired (if so do renewal)
    if (pOldCert)
    {
        CertRequestInfo.dwPurpose = CRYPTUI_WIZ_CERT_RENEW;
        CertRequestInfo.pRenewCertContext = pOldCert;
    }
    else
    {
        CertRequestInfo.dwPurpose = CRYPTUI_WIZ_CERT_ENROLL;
        CertRequestInfo.pRenewCertContext = NULL;
    }

    // UNDONE - for now always gen a new key, later may allow using existing key
    // for things like renewal
    CertRequestInfo.dwPvkChoice = CRYPTUI_WIZ_CERT_REQUEST_PVK_CHOICE_NEW;
    CertRequestInfo.pPvkNew = &NewKeyInfo;

    // destination cert store is the MY store (!!!! hard coded !!!!)
    CertRequestInfo.pwszDesStore = L"MY";

    // set algorithm for hashing
    CertRequestInfo.pszHashAlg = NULL;

    // set the cert type
	rgwszCertType[0] = wszCERTTYPE_WINDOWS_TEST_BUILD_SIGNING;
	rgwszCertType[1] = NULL;

    CertRequestInfo.dwCertChoice = CRYPTUI_WIZ_CERT_REQUEST_CERT_TYPE;
    CertType.dwSize = sizeof(CertType);
    CertType.cCertType = 1;
    CertType.rgwszCertType = rgwszCertType;
    CertRequestInfo.pCertType = &CertType;

    // set the Cert Server machine and authority
    CertRequestInfo.pwszCALocation = pwszDNSName;
    CertRequestInfo.pwszCAName = mySanitizeName(pwszCAName);

    // certify and create a key at the same time
    if (!CryptUIWizCertRequest(
		CRYPTUI_WIZ_NO_UI, 
		0, 
		NULL,
        &CertRequestInfo, 
		&pCertContext,     
        &dwCAStatus))    
    {
        PrintMessage(MSG_ERROR_S, (L"CyptUIWizCertRequest failed with %lxh\n", GetLastError()));
        goto Ret;
    }

	if (dwCAStatus != CRYPTUI_WIZ_CERT_REQUEST_STATUS_SUCCEEDED) {

        PrintMessage(MSG_ERROR_S, (L"CyptUIWizCertRequest failed to issue certificate\n"));
        goto Ret;
	}

    fRet = TRUE;
Ret:
	if (CertRequestInfo.pwszCAName)
		LocalFree((PVOID) CertRequestInfo.pwszCAName);

    if (pCertContext)
        CertFreeCertificateContext(pCertContext);

    if (pCert)
        CertFreeCertificateContext(pCert);

    if (pwszProvName)
        LocalFree(pwszProvName);

    return fRet;
}

BOOL
ExportCertificateHash(
	PCERT_CONTEXT pCertContext
	)
{
	BYTE bSHA1Hash[SHA1_HASH_LEN], bPrintHash[SHA1_HASH_LEN * 2 + 1];
	DWORD cbHashLen = sizeof(bSHA1Hash), i;

	if (CertGetCertificateContextProperty(
		pCertContext,
		CERT_SHA1_HASH_PROP_ID,
		bSHA1Hash,
		&cbHashLen
		) == FALSE) {

		return FALSE;
	}

	for (i = 0; i < SHA1_HASH_LEN; i++) {

		BYTE dwVal = bSHA1Hash[i];

		bPrintHash[i * 2] = ((dwVal >> 4) >= 10 ? (dwVal >> 4) + 'A' - 10 : (dwVal >> 4) + '0');
		bPrintHash[i * 2 + 1] = ((dwVal & 0xf) >= 10 ? (dwVal & 0xf) + 'A' - 10 : (dwVal & 0xf) + '0');
	}

	bPrintHash[SHA1_HASH_LEN * 2] = '\0';

	printf(bPrintHash);

	return TRUE;
}

PCERT_CONTEXT
FindCodeSigningCertificate(
	HCERTSTORE hCertStore,
	LPWSTR pwszCAName,
	BYTE *pbSHA1Hash
	)
{
	PCERT_CONTEXT pRootContext = NULL, pCertContext = NULL;
	PCERT_CONTEXT pPrevCertContext = NULL, pReturnCertContext = NULL;
	PCERT_CHAIN_CONTEXT pChainContext = NULL;
	CERT_CHAIN_PARA ChainPara;
	CERT_ENHKEY_USAGE EnhKeyUsage, *pEnhKeyUsage;
	LPSTR rgpszOids[2];
	DWORD cElement, cbHashLen, cbUsageLen, i;
	BOOL bFound = FALSE, bFoundCodeSigning, bFoundWindowsVerification;
	BYTE rgbHashBuffer[SHA1_HASH_LEN];
	BYTE rgbUsage[1024];
	ULARGE_INTEGER CertTime, PrevCertTime;

	PrevCertTime.QuadPart = 0;

	__try {

		for (pPrevCertContext = NULL; ;pPrevCertContext = pCertContext) { 

			pCertContext = (PCERT_CONTEXT) CertFindCertificateInStore(
				hCertStore,              
				X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
				0,
				CERT_FIND_ISSUER_STR, 
				pwszCAName,
				pPrevCertContext
				);

			if (pCertContext == NULL) {

				__leave;
			}

			cbUsageLen = sizeof(rgbUsage);
							
			pEnhKeyUsage = (PCERT_ENHKEY_USAGE) rgbUsage;

			if (CertGetEnhancedKeyUsage(
				pCertContext,
				0,
				pEnhKeyUsage,
				&cbUsageLen
				) == FALSE) {

				PrintMessage(MSG_ERROR_S, (L"Can't get certificate usage\n"));
				__leave;
			}

			bFoundCodeSigning = FALSE;
			bFoundWindowsVerification = FALSE;

			for (i = 0; i < pEnhKeyUsage->cUsageIdentifier; i++) {

				if (strcmp(
					   pEnhKeyUsage->rgpszUsageIdentifier[i], 
					   szOID_PKIX_KP_CODE_SIGNING) == 0) {

					bFoundCodeSigning = TRUE;
				}

				if (strcmp(
					   pEnhKeyUsage->rgpszUsageIdentifier[i], 
					   szOID_WINDOWS_SYSTEM_COMPONENT_VERIFICATION) == 0) {

					bFoundWindowsVerification = TRUE;
				}

				if (bFoundCodeSigning && bFoundWindowsVerification) {

					break;
				}
			}

			if (bFoundCodeSigning == FALSE || bFoundWindowsVerification == FALSE) {

				PrintMessage(MSG_WARNING_S, (L"Certificate issued by CA %s in 'MY store' can't be used for Windows build signing\n", pwszCAName));
				continue;

			} 

			bFound = FALSE;

			memset(rgbHashBuffer, 0, sizeof(rgbHashBuffer));

			// the user specified a hash for the root cert
			// check if this cert chains up to this root.
			if (memcmp(pbSHA1Hash, rgbHashBuffer, sizeof(rgbHashBuffer)) != 0) {

				rgpszOids[0] = szOID_PKIX_KP_CODE_SIGNING;
				rgpszOids[1] = szOID_WINDOWS_SYSTEM_COMPONENT_VERIFICATION;

				ChainPara.cbSize = sizeof(ChainPara);
				ChainPara.RequestedUsage.dwType = USAGE_MATCH_TYPE_AND;
				ChainPara.RequestedUsage.Usage.cUsageIdentifier = 2;
				ChainPara.RequestedUsage.Usage.rgpszUsageIdentifier = rgpszOids;

				if (CertGetCertificateChain(
					NULL, 
					pCertContext, 
					NULL,
					NULL,
					&ChainPara,
					0, 
					NULL,
					(CERT_CHAIN_CONTEXT const **) &pChainContext
					) == FALSE) {

					__leave;
				}

				// get to the root cert of this chain
				cElement = pChainContext->rgpChain[0]->cElement;
				pRootContext = (PCERT_CONTEXT) 
					pChainContext->rgpChain[0]->rgpElement[cElement - 1]->pCertContext;

				cbHashLen = sizeof(rgbHashBuffer);

				if (CertGetCertificateContextProperty(
					pRootContext,
					CERT_SHA1_HASH_PROP_ID,
					rgbHashBuffer,
					&cbHashLen
					) == FALSE) {

					PrintMessage(MSG_ERROR_S, (L"Can't get SHA1 hash for Windows build signing certificate\n"));
					__leave;
				}

				// check if this is the root cert we want
				if (memcmp(rgbHashBuffer, pbSHA1Hash, cbHashLen) != 0) {

					PrintMessage(MSG_WARNING_S, (L"Found Windows build signing certificate does not chain up to"));
					PrintMessage(MSG_WARNING_C, (L"requested root cert (wrong hash provided with -roothash?)\n"));
					continue;
					__leave;
				}

				bFound = TRUE;
				break;
			}

			// check the cert time of this cert against the time of the prev. valid cert.
			memcpy(&CertTime, &pCertContext->pCertInfo->NotAfter, sizeof(CertTime));

			if (CertTime.QuadPart > PrevCertTime.QuadPart) {

				if (pReturnCertContext) {

					CertFreeCertificateContext(pReturnCertContext);
				}

				pReturnCertContext = (PCERT_CONTEXT) CertDuplicateCertificateContext(pCertContext);
				PrevCertTime.QuadPart = CertTime.QuadPart;
			}
		}
	}
	__finally {

		if (pChainContext) {

			CertFreeCertificateChain(pChainContext);
		}

		if (bFound == FALSE) {

			CertFreeCertificateContext(pCertContext);
			pCertContext = NULL;
		}
	}

	return pReturnCertContext;
}

HCAINFO
CheckCA(
	LPWSTR pwszCAName
	)
{
	LPWSTR *pwszCertTypes = NULL, pwszSanitizeName = NULL;
	HCAINFO hCAInfo = NULL;
	BOOL bFoundCodeSigningCA = FALSE;
	int i;

	__try {

		if ((pwszSanitizeName = mySanitizeName(pwszCAName)) == NULL) {

			__leave;
		}

		// scan through the list of CAs to find a valid CA name
		if (CAFindByName(
				pwszSanitizeName,
				NULL,
				0,
				&hCAInfo
				) != S_OK) {

			PrintMessage(MSG_WARNING_S, (L"Can't find CA %s\n", pwszCAName));
			__leave;
		}

		// get the list of certificate templates that this CA can issue
		if (CAGetCAProperty(
			hCAInfo,
			CA_PROP_CERT_TYPES,
			&pwszCertTypes
			) != S_OK) {

			PrintMessage(MSG_ERROR_S, (L"Unable to retrieve certificate template list from CA %s\n", pwszCAName));
			__leave;
		}

		for (i = 0; pwszCertTypes[i]; i++) {

			if (wcscmp (pwszCertTypes[i], wszCERTTYPE_CODE_SIGNING) == 0) {

				bFoundCodeSigningCA = TRUE;
				break;
			}
		}
	}
	__finally {

		if (pwszCertTypes) {

			CAFreeCAProperty(hCAInfo, pwszCertTypes);
		}

		if (bFoundCodeSigningCA == FALSE && hCAInfo) {

			CACloseCA(hCAInfo);
			hCAInfo = NULL;
		}

		if (pwszSanitizeName != NULL) {

			LocalFree(pwszSanitizeName);
		}
	}

	return hCAInfo;
}

void 
PrintHelp(
	void
	)
{
	printf("Usage: csenroll -ca CAName [-ca CAName] [-d Days] [-h] [-roothash Hash]\n");
	printf(" Enroll for a Windows build signing certificate\n");
	printf("\n");
	printf(" Options:\n");
	printf(" -ca <CAName>       Name of CA from where to get a certificate\n");
	printf("                    For backup purposes you can specify multiple names.\n");
	printf("\n");
	printf(" -d <days>          Number of days before expiration of current certificate\n");
	printf("                    when an attempt is made to renew current certificate.\n");
	printf("\n");
	printf(" -h                 Show this help.\n");
	printf("\n");
	printf(" -roothash <Hash>   Specifiy the hash of the root certificate that the current\n");
	printf("                    Windows build signing certficate has to chain up to.\n");
	printf("                    Use this option to ensure that your Windows build signing\n");
	printf("                    certificate chains up to the correct root certificate\n");
	printf("\n");
	printf("\n");
}

int 
__cdecl
main(int argc, char **argv)
{
	PCERT_CONTEXT pCertContext = NULL;
	HCAINFO hCAInfo = NULL;
	HCERTSTORE hCertStore = NULL;
	LPWSTR pwszCAName = NULL, *pwszCAList = NULL, *pwszDNSName = NULL;
	BYTE rgbRootHash[SHA1_HASH_LEN];
	BOOL bRootHash = FALSE, bRet = FALSE;
	int i, dwNumCA = 0, dwDaysValid = 0, dwDays = 10;

	memset(rgbRootHash, 0, sizeof(rgbRootHash));

	__try {

		while (--argc) {

			argv += 1;

			if (_stricmp(*argv, "-ca") == 0) {

				int dwLen;

				argc -= 1;
				argv += 1;

				dwLen = (strlen(*argv) + 1) * sizeof(WCHAR);			

				if (pwszCAList == NULL) {

					pwszCAList = (LPWSTR *) malloc(sizeof(LPWSTR) * (dwNumCA + 2));

				} else {

					pwszCAList = (LPWSTR *) realloc(pwszCAList, sizeof(LPWSTR) * (dwNumCA + 2));
				}

				if (pwszCAList == NULL) {

					PrintMessage(MSG_ERROR_S, (L"Failed to allocate memory\n"));
					__leave;
				}

				pwszCAList[dwNumCA + 1] = NULL;
				pwszCAList[dwNumCA] = (LPWSTR) malloc(dwLen);

				if (pwszCAList[dwNumCA] == NULL) {

					PrintMessage(MSG_ERROR_S, (L"Failed to allocate memory\n"));
					__leave;
				}

				MultiByteToWideChar(
					CP_UTF8,
					0,
					*argv,
					-1,
					pwszCAList[dwNumCA],
					dwLen
					);

				dwNumCA += 1;
			}

			if (_stricmp(*argv, "-roothash") == 0) {

				argv += 1;
				argc -= 1;

				if (strlen(*argv) != SHA1_HASH_LEN * 2) {

					PrintMessage(MSG_ERROR_S, (L"Hash must have a length of 40 bytes\n"));
					__leave;
				}

				_strupr(*argv);

				for (i = 0; i < SHA1_HASH_LEN * 2; i++) {

					BYTE bNum;

					if ((*argv)[i] >= '0' && (*argv)[i] <= '9') {

						bNum = (*argv)[i] - '0';

					} else if ((*argv)[i] >= 'A' && (*argv)[i] <= 'F') {

						bNum = (*argv)[i] - 'A' + 10;

					} else {

						PrintMessage(MSG_ERROR_S, (L"Illegal hexdecimal number in hash\n"));
						__leave;
					}

					rgbRootHash[i / 2] |= (i % 2 ? bNum : bNum << 4);
				}

				bRootHash = TRUE;
			}

			if (_stricmp(*argv, "-v") == 0) {

				dwMsgLevel |= MSG_WARNING_S | MSG_WARNING_C;
			}

			if (_stricmp(*argv, "-d") == 0) {

				argv += 1;
				argc -= 1;

				dwDays = atoi(*argv);
			}

			if (_stricmp(*argv, "-h") == 0) {

				PrintHelp();
				__leave;
			}
		}

		if (dwNumCA == 0) {

			PrintHelp();
			__leave;
		}

		hCertStore = CertOpenSystemStore(
			0,               
			L"MY"
			);

		if (hCertStore == NULL) {

			PrintMessage(MSG_ERROR_S, (L"Can't open 'MY store'\n"));
			__leave;
		}

		if (bRootHash == FALSE) {

			PrintMessage(MSG_WARNING_S, (L"Certificate chain can't be verified (no -roothash specified)\n"));
		}

		for (i = 0; i < dwNumCA; i++) {

			//
			// now try to find a Windows build signing cert that was issued 
			// from a known ca and that chains up to a known root
			//
			pCertContext = FindCodeSigningCertificate(
				hCertStore,
				pwszCAList[i],
				rgbRootHash
				);

			if (pCertContext) {

				pwszCAName = pwszCAList[i];
				break;
			}
		}

		if (pCertContext) {

			// check how long the current cert is valid
			ULARGE_INTEGER CertTime, CurrentTime, days;
			FILETIME SystemTime, LocalTime;	

			memcpy(&CertTime, &pCertContext->pCertInfo->NotAfter, sizeof(CertTime));

			GetSystemTimeAsFileTime(&SystemTime);
			memcpy(&CurrentTime, &SystemTime, sizeof(CurrentTime));

			if (CertTime.QuadPart > CurrentTime.QuadPart) {

				dwDaysValid = (DWORD) 
					((CertTime.QuadPart - CurrentTime.QuadPart) / 
					(10000000i64 * 24 * 60 * 60));
			}

			//
			// now check if the CA that originally issued 
			// the cert is still available
			//
			if ((hCAInfo = CheckCA(pwszCAName)) == NULL) {

				PrintMessage(MSG_WARNING_S, (L"Can't find CA %s to renew certificate\n", pwszCAName));

				if (dwDaysValid < (dwDays / 2)) {

					// since we won't be able to renew this cert, just get a new one.
					CertFreeCertificateContext(pCertContext);
					pCertContext = NULL;
				} 
			}
		} 
		
		if (pCertContext == NULL) {

			// find a CA that can issue a windows build signing cert
			for (i = 0; i < dwNumCA; i++) {

				if (hCAInfo = CheckCA(pwszCAList[i])) {

					pwszCAName = pwszCAList[i];
					break;
				}
			}
		}

		if (pCertContext == NULL && hCAInfo == NULL) {

			PrintMessage(MSG_ERROR_S, (L"Can't find Windows build signing CA\n"));
			__leave;
		}

		if (hCAInfo && (pCertContext == NULL ||	dwDaysValid < dwDays)) {

			PrintMessage(
				MSG_INFO_S, 
				(L"%s build signing certificate. Please wait...\n", pCertContext ? L"Renewing" : L"Enrolling for")
				);

			// get DNS name of CA
			if (CAGetCAProperty(
				hCAInfo,
				CA_PROP_DNSNAME,
				&pwszDNSName
				) != S_OK) {

				PrintMessage(MSG_ERROR_S, (L"Unable to retrieve DNS name for %s\n", pwszCAName));
				__leave;
			}

			if (EnrollForCodeSigningCertificate(
				pwszCAName,
				*pwszDNSName,
				pCertContext
				) == FALSE) {

				PrintMessage(MSG_ERROR_S, (L"Enrollment for Windows build signing certificate failed\n"));
				PrintMessage(MSG_ERROR_C, (L"Check access rights to CA %s and\n", pwszCAName));
				PrintMessage(MSG_ERROR_C, (L"Windows build signing certificate template\n"));
				__leave;
			}

			// now make sure that we really have a cert in the store
			if (pCertContext) {

				CertFreeCertificateContext(pCertContext);
				pCertContext = NULL;
			}

			if (CertControlStore(
				hCertStore,                 
				0,                         
				CERT_STORE_CTRL_RESYNC,                      
				NULL                 
				) == FALSE) {

				PrintMessage(MSG_ERROR_S, (L"Failed to resync the 'MY store'\n"));
				__leave;
			}

			pCertContext = FindCodeSigningCertificate(
				hCertStore,
				pwszCAName,
				rgbRootHash
				);

			if (pCertContext == NULL) {

				PrintMessage(MSG_ERROR_S, (L"Can't find valid Windows build signing certificate in 'MY store'\n"));
				__leave;
			}
		}

		if (ExportCertificateHash(pCertContext) == FALSE) {

			PrintMessage(MSG_ERROR_S, (L"Export of Windows build signing certificate has failed\n"));
			__leave;
		}

		bRet = TRUE;
	}
	__finally {

		if (pwszDNSName) {

			CAFreeCAProperty(hCAInfo, pwszDNSName);
		}

		if (hCAInfo) {

			CACloseCA(hCAInfo);
		}

		if (pCertContext) {

			CertFreeCertificateContext(pCertContext);
		}

		if (hCertStore) {

			CertCloseStore(hCertStore, 0);
		}

	}
	return (bRet ? 0 : -1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\autoenrl\pautoenr\autoenro.h ===
//+--------------------------------------------------------------------------
//  FILE          : autoenro.h                                             
//  DESCRIPTION   : Private Auto Enrollment functions                      
//                                                             
//            
//  Copyright (C) 1993-2000 Microsoft Corporation   All Rights Reserved    
//+--------------------------------------------------------------------------

#ifndef __AUTOENRO_H__
#define __AUTOENRO_H__

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//--------------------------------------------------------------------------
//  Globals
//--------------------------------------------------------------------------
extern HINSTANCE   g_hmodThisDll;


//--------------------------------------------------------------------------
//  contant defines
//--------------------------------------------------------------------------
#define AE_PENDING_REQUEST_ACTIVE_PERIOD        60      //60 days

#define SHA1_HASH_LENGTH    20

#define ENCODING_TYPE       X509_ASN_ENCODING | PKCS_7_ASN_ENCODING

#define MY_STORE            L"MY"

#define REQUEST_STORE       L"REQUEST"

#define ACRS_STORE          L"ACRS"

//possible status for the request tree
#define CERT_REQUEST_STATUS_ACTIVE                      0x01

#define CERT_REQUEST_STATUS_OBTAINED                    0x02

#define CERT_REQUEST_STATUS_PENDING                     0x03  
                                                
#define CERT_REQUEST_STATUS_SUPERSEDE_ACTIVE            0x04  


// Time skew margin for fast CA's
#define FILETIME_TICKS_PER_SECOND           10000000

#define AE_DEFAULT_SKEW                     60*60*1  // 1 hour

#define MAX_DN_SIZE                         256

#define AE_SUMMARY_COLUMN_SIZE              100

#define PENDING_ALLOC_SIZE                  20   

#define USER_AUTOENROLL_DELAY_FOR_MACHINE   70       //70 seconds to wait


//defines for autoenrollment event log
#define EVENT_AUTO_NAME                     L"AutoEnrollment"
#define AUTO_ENROLLMENT_EVENT_LEVEL_KEY     TEXT("SOFTWARE\\Microsoft\\Cryptography\\AutoEnrollment")
#define AUTO_ENROLLMENT_EVENT_LEVEL         TEXT("AEEventLogLevel")

//defines for autoenrollment disable key
#define AUTO_ENROLLMENT_DISABLE_KEY         L"SOFTWARE\\Microsoft\\Cryptography\\AutoEnrollment\\AEDisable"

//defines for autoenrollment user no wait for 60 seconds key
#define AUTO_ENROLLMENT_EXPRESS_KEY         L"SOFTWARE\\Microsoft\\Cryptography\\AutoEnrollment\\AEExpress"

//defines for autoenrollment directory cache information
#define AUTO_ENROLLMENT_DS_KEY              L"SOFTWARE\\Microsoft\\Cryptography\\AutoEnrollment\\AEDirectoryCache"
#define AUTO_ENROLLMENT_DS_USN              L"AEMaxUSN"
#define AUTO_ENROLLMENT_DS_OBJECT           L"AEObjectCount"

#define AUTO_ENROLLMENT_TEMPLATE_KEY        L"SOFTWARE\\Microsoft\\Cryptography\\CertificateTemplateCache"

#define AUTO_ENROLLMENT_USN_ATTR            L"uSNChanged"

//defines for the UI component
#define AUTO_ENROLLMENT_SHOW_TIME           15                  //show the balloon for 15 seconds
#define AUTO_ENROLLMENT_INTERVAL            7 * 60 * 30         //show the icon for 7 hours 7* 3600
#define AUTO_ENROLLMENT_RETRIAL             2

#define AUTO_ENROLLMENT_QUERY_INTERVAL      30              //query continue every 30 seconds

#define AUTO_ENROLLMENT_BALLOON_LENGTH      7 * 60 * 60              	//keep the balloon for 7 hours

#define AE_DEFAULT_POSTPONE                 1                   //we relaunch autoenrollment for 1 hour

//define used for sorting of columns in the list view
#define AE_SUMMARY_COLUMN_TYPE              1
#define AE_SUMMARY_COLUMN_REASON            2
#define SORT_COLUMN_ASCEND                  0x00010000
#define SORT_COLUMN_DESCEND                 0x00020000


//--------------------------------------------------------------------------
//  struct defines
//--------------------------------------------------------------------------
//struct for autoenrollment main thread
typedef struct _AE_MAIN_THREAD_INFO_
{
    HWND     hwndParent;
    DWORD    dwStatus;
} AE_MAIN_THREAD_INFO;


//struct for updating certificate store from AD
typedef struct _AE_STORE_INFO_
{
    LPWSTR      pwszStoreName;
    LPWSTR      pwszLdapPath;
} AE_STORE_INFO;

//struct for the information we compute from DS
typedef struct _AE_DS_INFO_
{
    BOOL                fValidData;
    DWORD               dwObjects;
    ULARGE_INTEGER      maxUSN;
} AE_DS_INFO;

//struct for param of view RA certificate dialogue
typedef struct _AE_VIEW_RA_INFO_
{
    PCERT_CONTEXT       pRAContext;
    LPWSTR              pwszRATemplate;
} AE_VIEW_RA_INFO;


//struct for individual certifcate information
typedef struct _AE_CERT_INFO_
{
    BOOL    fValid;
    BOOL    fRenewal;
} AE_CERT_INFO;

//strcut for certificate's template information
typedef struct _AE_TEMPLATE_INFO_
{
    LPWSTR  pwszName;
    LPWSTR  pwszOid;
    DWORD   dwVersion;
} AE_TEMPLATE_INFO;

//struct for certificate authority information
typedef struct _AE_CA_INFO_
{
    HCAINFO         hCAInfo;
    LPWSTR          *awszCertificateTemplate;
    LPWSTR          *awszCAName;
    LPWSTR          *awszCADNS;
    LPWSTR          *awszCADisplay;
} AE_CA_INFO;


//struct for keeping the issued pending certificates
typedef struct _AE_PEND_INFO_
{
    CRYPT_DATA_BLOB blobPKCS7;          //the issued pending certificate for UI installation
    CRYPT_DATA_BLOB blobHash;           //the hash of the certificate request to be removed from the request store
}AE_PEND_INFO;

//struct for certificate template information
typedef struct _AE_CERTTYPE_INFO_
{
    HCERTTYPE       hCertType;
    DWORD           dwSchemaVersion;
    DWORD           dwVersion;
    LPWSTR          *awszName;
    LPWSTR          *awszDisplay;
    LPWSTR          *awszOID;  
    LPWSTR          *awszSupersede;
    DWORD           dwEnrollmentFlag;
    DWORD           dwPrivateKeyFlag;
    LARGE_INTEGER   ftExpirationOffset;
    DWORD           dwStatus;
    BOOL            fCheckMyStore;
    BOOL            fRenewal;
    BOOL            fNeedRA;            //the request needs to be signed by itself or another certificate
    BOOL            fCrossRA;           //the request is cross RAed.
    BOOL            fSupersedeVisited;  //the flag to prevent infinite loop in superseding relationship
    BOOL            fUIActive;
    DWORD           dwActive;
    DWORD           *prgActive;
    DWORD           dwRandomCAIndex;
    PCERT_CONTEXT   pOldCert;           //for renewal case managing MY store
    HCERTSTORE      hArchiveStore;      //contains the certificates to be archived
    HCERTSTORE      hObtainedStore;     //for supersede relation ships
    HCERTSTORE      hIssuedStore;       //keep issued certificates for re-publishing
    DWORD           dwPendCount;        //the count of pending issued certs
    AE_PEND_INFO    *rgPendInfo;        //the point to the struct array
    DWORD           idsSummary;         //the summary string ID
} AE_CERTTYPE_INFO;

//struct for the autoenrollment process
typedef struct _AE_GENERAL_INFO_
{
    HWND                hwndParent;
    LDAP *              pld;
    HANDLE              hToken;
    BOOL                fMachine;
    DWORD               dwPolicy;
    DWORD               dwLogLevel;
    WCHAR               wszMachineName[MAX_COMPUTERNAME_LENGTH + 2];
    HCERTSTORE          hMyStore;
    HCERTSTORE          hRequestStore;
    DWORD               dwCertType;
    AE_CERTTYPE_INFO    *rgCertTypeInfo;
    DWORD               dwCA;
    AE_CA_INFO          *rgCAInfo;
    HMODULE             hXenroll;
    BOOL                fUIProcess;                 //whether we are doing interactive enrollment
    HANDLE              hCancelEvent;
    HANDLE              hCompleteEvent;
    HANDLE              hThread;
    HWND                hwndDlg;                    //the dialogue window handle of the UI window
    DWORD               dwUIPendCount;              //the count of UI required pending requests
    DWORD               dwUIEnrollCount;            //the count of UI requires new requests
    DWORD               dwUIProgressCount;          //the count of active working items
    BOOL                fSmartcardSystem;           //whether a smart card reader is installed
} AE_GENERAL_INFO;

//--------------------------------------------------------------------------
//  Class definition
//--------------------------------------------------------------------------
class CQueryContinue : IQueryContinue
{
public:
    CQueryContinue();
    ~CQueryContinue();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IQueryContinue
    STDMETHODIMP QueryContinue();    // S_OK -> Continue, other 

    // DoBalloon
    HRESULT DoBalloon();

private:
    LONG                    m_cRef;
    IUserNotification       *m_pIUserNotification;
    HANDLE                  m_hTimer;
};


//--------------------------------------------------------------------------
//  function prototype
//--------------------------------------------------------------------------
HRESULT 
AEGetConfigDN(
    IN  LDAP *pld,
    OUT LPWSTR *pwszConfigDn
    );

HRESULT
AERobustLdapBind(
    OUT LDAP ** ppldap,
    OUT LPWSTR *ppwszDCName);

BOOL    AERetrieveGeneralInfo(AE_GENERAL_INFO *pAE_General_Info);

BOOL    AEFreeGeneralInfo(AE_GENERAL_INFO *pAE_General_Info);

BOOL    AERetrieveCAInfo(LDAP *pld, BOOL fMachine, HANDLE hToken, DWORD *pdwCA, AE_CA_INFO **prgCAInfo);

BOOL    AEFreeCAInfo(DWORD dwCA, AE_CA_INFO *rgCAInfo);

BOOL    AEFreeCAStruct(AE_CA_INFO *pCAInfo);

BOOL    AERetrieveCertTypeInfo(LDAP *pld, BOOL fMachine, DWORD *pdwCertType, AE_CERTTYPE_INFO **prgCertType);

BOOL    AEFreeCertTypeInfo(DWORD dwCertType, AE_CERTTYPE_INFO *rgCertTypeInfo);

BOOL    AEFreeCertTypeStruct(AE_CERTTYPE_INFO *pCertTypeInfo);

BOOL    AEAllocAndCopy(LPWSTR    pwszSrc, LPWSTR    *ppwszDest);

BOOL    AEIfSupersede(LPWSTR  pwsz, LPWSTR *awsz, AE_GENERAL_INFO *pAE_General_Info);

BOOL    AEClearVistedFlag(AE_GENERAL_INFO *pAE_General_Info);

BOOL    AECopyCertStore(HCERTSTORE     hSrcStore,   HCERTSTORE     hDesStore);

BOOL    AEIsAnElement(LPWSTR   pwsz, LPWSTR *awsz);

BOOL    AECancelled(HANDLE hCancelEvent);

BOOL    AERetrieveTemplateInfo(PCCERT_CONTEXT           pCertCurrent, 
                                AE_TEMPLATE_INFO        *pTemplateInfo);

BOOL    AEFreeTemplateInfo(AE_TEMPLATE_INFO *pAETemplateInfo);

AE_CERTTYPE_INFO *AEFindTemplateInRequestTree(AE_TEMPLATE_INFO  *pTemplateInfo,
                                              AE_GENERAL_INFO   *pAE_General_Info);


BOOL    AEUIProgressAdvance(AE_GENERAL_INFO *pAE_General_Info);

BOOL    AEUIProgressReport(BOOL fPending, AE_CERTTYPE_INFO *pCertType, HWND hwndDlg, HANDLE hCancelEvent);

BOOL    FormatMessageUnicode(LPWSTR * ppwszFormat, UINT ids, ...);

void    AELogAutoEnrollmentEvent(IN DWORD    dwLogLevel,
                            IN BOOL     fError,
                            IN HRESULT  hr,
                            IN DWORD    dwEventId,
                            IN BOOL     fMachine,
                            IN HANDLE   hToken,
                            IN DWORD    dwParamCount,
                            ...
                            );

BOOL    AENetLogonUser(
                        LPTSTR UserName,
                        LPTSTR DomainName,
                        LPTSTR Password,
                        PHANDLE phToken
                        );
//--------------------------------------------------------------------------
//  Debug prints
//--------------------------------------------------------------------------
#if DBG
#define AE_ERROR                0x0001
#define AE_WARNING              0x0002
#define AE_INFO                 0x0004
#define AE_TRACE                0x0008
#define AE_ALLOC                0x0010
#define AE_RES                  0x0020

#define AE_DEBUG(x) AEDebugLog x
#define AE_BEGIN(x) AEDebugLog(AE_TRACE, L"BEGIN:" x L"\n");
#define AE_RETURN(x) { AEDebugLog(AE_TRACE, L"RETURN (%lx) Line %d\n",(x), __LINE__); return (x); }
#define AE_END()    { AEDebugLog(AE_TRACE, L"END:Line %d\n",  __LINE__); }
#define AE_BREAK()  { AEDebugLog(AE_TRACE, L"BREAK  Line %d\n",  __LINE__); }
void    AEDebugLog(long Mask,  LPCWSTR Format, ...);

#define MAX_DEBUG_BUFFER 256

#else
#define AE_DEBUG(x) 
#define AE_BEGIN(x) 
#define AE_RETURN(x) return (x)
#define AE_END() 
#define AE_BREAK() 

#endif

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif // __AUTOENRO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\autoenrl\csenroll\convert.c ===
#include <windows.h>
#include <wincrypt.h>
#include <autoenr.h>
#include <cryptui.h>
#include <stdio.h>
#include <certca.h>
#include <stdlib.h>

#define wszInvalidFileAndKeyChars  L"<>\"/\\:|?*"
#define wszUnsafeURLChars          L"#\"&<>[]^`{}|"
#define wszUnsafeDSChars           L"()='\"`,;+"
#define  wszSANITIZEESCAPECHAR  L"!"
#define  wszURLESCAPECHAR       L"%"
#define  wcSANITIZEESCAPECHAR   L'!'

BOOL
myIsCharSanitized(
    IN WCHAR wc)
{
    BOOL fCharOk = TRUE;
    if (L' ' > wc ||
        L'~' < wc ||
        NULL != wcschr(
		    wszInvalidFileAndKeyChars
			wszUnsafeURLChars
			wszSANITIZEESCAPECHAR
			wszURLESCAPECHAR
			wszUnsafeDSChars,
		    wc))
    {
	fCharOk = FALSE;
    }
    return(fCharOk);
}

PWCHAR 
mySanitizeName(
    IN WCHAR const *pwszName
	)
{
    HRESULT hr = S_OK;
    WCHAR const *pwszPassedName;
    WCHAR *pwszDst;
    WCHAR *pwszOut = NULL;
    WCHAR wcChar;
    DWORD dwSize;

    pwszPassedName = pwszName;

    dwSize = 0;

    if (NULL == pwszName)
    {
	return NULL;
    }

    while (L'\0' != (wcChar = *pwszPassedName++))
    {
	if (myIsCharSanitized(wcChar))
	{
	    dwSize++;
	}
        else
        {
            dwSize += 5; // format !XXXX
        }
    }
    if (0 == dwSize)
    {
        return NULL;
    }

    pwszOut = (WCHAR *) LocalAlloc(LMEM_ZEROINIT, (dwSize + 1) * sizeof(WCHAR));
    if (NULL == pwszOut)
    {
		return NULL;
    }

    pwszDst = pwszOut;
    while (L'\0' != (wcChar = *pwszName++))
    {
	if (myIsCharSanitized(wcChar))
	{
            *pwszDst = wcChar;
	    pwszDst++;
	}
        else
        {
            wsprintf(pwszDst, L"%ws", wszSANITIZEESCAPECHAR);
            pwszDst++;
            wsprintf(pwszDst, L"%04x", wcChar);
	    pwszDst += 4;
        }
    }
    *pwszDst = wcChar; // L'\0' terminator

	return pwszOut;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\credui\utils.hpp ===
//=============================================================================
// Copyright (c) 2000 Microsoft Corporation
//
// dialogs.hpp
//
// Credential manager user interface classes used to get credentials.
//
// Created 02/29/2000 johnstep (John Stephens)
//=============================================================================

#ifndef __UTILS_HPP__
#define __UTILS_HPP__

#include <wincrypt.h>
#include <cryptui.h>
#include <lm.h>

//
// Determine if the passed in DWORD has precisely one bit set.
//

#define JUST_ONE_BIT( _x ) (((_x) != 0 ) && ( ( (~(_x) + 1) & (_x) ) == (_x) ))

// Singly-linked list Structure for holding a cred awaiting confirmation
typedef struct _CRED_AWAITING_CONFIRMATION
{
    WCHAR szTargetName[CRED_MAX_STRING_LENGTH+1+CRED_MAX_STRING_LENGTH + 1];
    PCREDENTIAL_TARGET_INFORMATION TargetInfo;
    PCREDENTIAL EncodedCredential;
    DWORD dwCredWriteFlags;
    BOOL DelayCredentialWrite;
    void* pNext;        // pointer to next cred in list
} CRED_AWAITING_CONFIRMATION;

//-----------------------------------------------------------------------------
// Functions
//-----------------------------------------------------------------------------

BOOL
CreduiIsSpecialCredential(
    CREDENTIAL *credential
    );

BOOL
CreduiLookupLocalSidFromRid(
    DWORD rid,
    PSID *sid
    );

BOOL
CreduiLookupLocalNameFromRid(
    DWORD rid,
    LPWSTR *name
    );

BOOL
CreduiGetAdministratorsGroupInfo(
    LOCALGROUP_MEMBERS_INFO_2 **groupInfo,
    DWORD *memberCount
    );

BOOL
CreduiIsRemovableCertificate(
    CONST CERT_CONTEXT *certContext
    );

BOOL
CreduiIsExpiredCertificate(
    CONST CERT_CONTEXT *certContext
    );

BOOL
CreduiIsClientAuthCertificate(
    CONST CERT_CONTEXT *certContext
    );

BOOL
CreduiGetCertificateDisplayName(
    CONST CERT_CONTEXT *certContext,
    WCHAR *displayName,
    ULONG displayNameMaxChars,
    WCHAR *certificateString,
    DWORD dwDisplayType
    );

BOOL
CreduiIsWildcardTargetName(
    WCHAR *targetName
    );

BOOL
CreduiIsPostfixString(
    WCHAR *source,
    WCHAR *postfix
    );

// returns TRUE if pszUserName exists as a substring in pszCredential, FALSE if not
BOOL
LookForUserNameMatch (
    const WCHAR * pszUserName,
    const WCHAR * pszCredential
    );


// copies the marshalled name of pCert into pszMarshalledName.
// pszMarshalledName must be at least CREDUI_MAX_USERNAME_LENGTH in length
//
// returns TRUE if successful, FALSE if not
BOOL
CredUIMarshallNode (
    CERT_ENUM * pCert,
    WCHAR* pszMarshalledName
    );

DWORD
WriteCred(
    IN PCWSTR pszTargetName,
    IN DWORD Flags,
    IN PCREDENTIAL_TARGET_INFORMATION TargetInfo OPTIONAL,
    IN PCREDENTIAL Credential,
    IN DWORD dwCredWriteFlags,
    IN BOOL DelayCredentialWrite,
    IN BOOL EncryptedVisiblePassword
    );


BOOL AddCredToConfirmationList (
    IN PCWSTR pszTargetName,
    IN PCREDENTIAL_TARGET_INFORMATION TargetInfo OPTIONAL,
    IN PCREDENTIAL Credential,
    IN DWORD dwCredWriteFlags,
    IN BOOL DelayCredentialWrite
    );

DWORD
ConfirmCred (
    IN PCWSTR pszTargetName,
    IN BOOL bConfirm,
    IN BOOL bOkToDelete
    );

void CleanUpConfirmationList();
BOOL InitConfirmationList();

BOOL IsDeaultSSORealm ( WCHAR* pszTargetName );


#define MAX_SSO_URL_SIZE    4096

#define SSOBRAND_X_SIZE     320
#define SSOBRAND_Y_SIZE      60

typedef struct _SSOPACKAGE {
    WCHAR szBrand[MAX_SSO_URL_SIZE];
    WCHAR szURL[MAX_SSO_URL_SIZE];
    WCHAR szAttrib[CRED_MAX_STRING_LENGTH];
    WCHAR szRegURL[MAX_SSO_URL_SIZE];
    WCHAR szHelpURL[MAX_SSO_URL_SIZE];
    DWORD dwRegistrationCompleted;              // 0 if not completed, 1 if completed
    DWORD dwNumRegistrationRuns;                // number of times we've prompted for registration
    CONST CLSID* pRegistrationWizard;                 // CLSID of any registration wizard   
} SSOPACKAGE;

// Looks in the registry for an SSO entry for the specified package.
// Fills in the SSOPackage struct and returns TRUE if found.  Returns
// FALSE if no registry entry found
BOOL
GetSSOPackageInfo (
    CREDENTIAL_TARGET_INFORMATION* TargetInfo,
    SSOPACKAGE* pSSOStruct
    );


// returns TRUE if it was found, with the value copied to pszRealm.
// pszRealm is expected to be at least CREDUI_MAX_DOMAIN_TARGET_LENGTH in length
// returns FALSE if not found
BOOL ReadPassportRealmFromRegistry (
    WCHAR* pszRealm );


void GetDeaultSSORealm ( WCHAR* pszTargetName, BOOL bForceLookup = TRUE );

// returns TRUE if a cred is saved for that realm
BOOL CheckForSSOCred( WCHAR* pszTargetRealm );

DWORD EncryptPassword ( PWSTR pszPassword, PVOID* ppszEncryptedPassword, DWORD* pSize );

BOOL IsPasswordEncrypted ( PVOID pPassword, DWORD cbSize );


// Uses GDI+ to load an image as an HBITMAP
HBITMAP LoadImageFromFileViaGdiPlus(
    PWSTR pszFileName,
    UINT *pcWidth,
    UINT *pcHeight);



///////////////////////////////////////////////////////////////////////////////////////////////
//
// Wincred.h functions
//
// these are local mirrors of the credmgr functions so we can handle downlevel cases properly
//
///////////////////////////////////////////////////////////////////////////////////////////////

// Prototypes for Whistler functions

typedef
BOOL
(WINAPI
*PFN_CREDWRITEW) (
    IN PCREDENTIALW Credential,
    IN DWORD Flags
    );


typedef
BOOL
(WINAPI
*PFN_CREDREADW) (
    IN LPCWSTR TargetName,
    IN DWORD Type,
    IN DWORD Flags,
    OUT PCREDENTIALW *Credential
    );

typedef
BOOL
(WINAPI
*PFN_CREDENUMERATEW) (
    IN LPCWSTR Filter,
    IN DWORD Flags,
    OUT DWORD *Count,
    OUT PCREDENTIALW **Credential
    );


typedef
BOOL
(WINAPI
*PFN_CREDWRITEDOMAINCREDENTIALSW) (
    IN PCREDENTIAL_TARGET_INFORMATIONW TargetInfo,
    IN PCREDENTIALW Credential,
    IN DWORD Flags
    );

typedef
BOOL
(WINAPI
*PFN_CREDREADDOMAINCREDENTIALSW) (
    IN PCREDENTIAL_TARGET_INFORMATIONW TargetInfo,
    IN DWORD Flags,
    OUT DWORD *Count,
    OUT PCREDENTIALW **Credential
    );

typedef
BOOL
(WINAPI
*PFN_CREDDELETEW) (
    IN LPCWSTR TargetName,
    IN DWORD Type,
    IN DWORD Flags
    );

typedef
BOOL
(WINAPI
*PFN_CREDRENAMEW) (
    IN LPCWSTR OldTargetName,
    IN LPCWSTR NewTargetName,
    IN DWORD Type,
    IN DWORD Flags
    );


typedef
BOOL
(WINAPI
*PFN_CREDGETTARGETINFOW) (
    IN LPCWSTR TargetName,
    IN DWORD Flags,
    OUT PCREDENTIAL_TARGET_INFORMATIONW *TargetInfo
    );


typedef
BOOL
(WINAPI
*PFN_CREDMARSHALCREDENTIALW) (
    IN CRED_MARSHAL_TYPE CredType,
    IN PVOID Credential,
    OUT LPWSTR *MarshaledCredential
    );


typedef
BOOL
(WINAPI
*PFN_CREDUNMARSHALCREDENTIALW) (
    IN LPCWSTR MarshaledCredential,
    OUT PCRED_MARSHAL_TYPE CredType,
    OUT PVOID *Credential
    );


typedef
BOOL
(WINAPI
*PFN_CREDISMARSHALEDCREDENTIALW) (
    IN LPCWSTR MarshaledCredential
    );

typedef
BOOL
(WINAPI
*PFN_CREDISMARSHALEDCREDENTIALA) (
    IN LPCSTR MarshaledCredential
    );


typedef
BOOL
(WINAPI
*PFN_CREDGETSESSIONTYPES) (
    IN DWORD MaximumPersistCount,
    OUT LPDWORD MaximumPersist
    );

typedef
VOID
(WINAPI
*PFN_CREDFREE) (
    IN PVOID Buffer
    );

// pointers to Whistler functions

extern BOOL bCredMgrAvailable;
extern PFN_CREDWRITEW pfnCredWriteW;
extern PFN_CREDREADW pfnCredReadW;
extern PFN_CREDENUMERATEW pfnCredEnumerateW;
extern PFN_CREDWRITEDOMAINCREDENTIALSW pfnCredWriteDomainCredentialsW;
extern PFN_CREDREADDOMAINCREDENTIALSW pfnCredReadDomainCredentialsW;
extern PFN_CREDDELETEW pfnCredDeleteW;
extern PFN_CREDRENAMEW pfnCredRenameW;
extern PFN_CREDGETTARGETINFOW pfnCredGetTargetInfoW;
extern PFN_CREDMARSHALCREDENTIALW pfnCredMarshalCredentialW;
extern PFN_CREDUNMARSHALCREDENTIALW pfnCredUnMarshalCredentialW;
extern PFN_CREDISMARSHALEDCREDENTIALW pfnCredIsMarshaledCredentialW;
extern PFN_CREDISMARSHALEDCREDENTIALA pfnCredIsMarshaledCredentialA;
extern PFN_CREDGETSESSIONTYPES pfnCredGetSessionType;
extern PFN_CREDFREE pfnCredFree;


//////
// local functions prototypes
//

BOOL
WINAPI
LocalCredWriteW (
    IN PCREDENTIALW Credential,
    IN DWORD Flags
    );


BOOL
WINAPI
LocalCredReadW (
    IN LPCWSTR TargetName,
    IN DWORD Type,
    IN DWORD Flags,
    OUT PCREDENTIALW *Credential
    );

BOOL
WINAPI
LocalCredEnumerateW (
    IN LPCWSTR Filter,
    IN DWORD Flags,
    OUT DWORD *Count,
    OUT PCREDENTIALW **Credential
    );


BOOL
WINAPI
LocalCredWriteDomainCredentialsW (
    IN PCREDENTIAL_TARGET_INFORMATIONW TargetInfo,
    IN PCREDENTIALW Credential,
    IN DWORD Flags
    );

BOOL
WINAPI
LocalCredReadDomainCredentialsW (
    IN PCREDENTIAL_TARGET_INFORMATIONW TargetInfo,
    IN DWORD Flags,
    OUT DWORD *Count,
    OUT PCREDENTIALW **Credential
    );

BOOL
WINAPI
LocalCredDeleteW (
    IN LPCWSTR TargetName,
    IN DWORD Type,
    IN DWORD Flags
    );

BOOL
WINAPI
LocalCredRenameW (
    IN LPCWSTR OldTargetName,
    IN LPCWSTR NewTargetName,
    IN DWORD Type,
    IN DWORD Flags
    );


BOOL
WINAPI
LocalCredGetTargetInfoW (
    IN LPCWSTR TargetName,
    IN DWORD Flags,
    OUT PCREDENTIAL_TARGET_INFORMATIONW *TargetInfo
    );


BOOL
WINAPI
LocalCredMarshalCredentialW(
    IN CRED_MARSHAL_TYPE CredType,
    IN PVOID Credential,
    OUT LPWSTR *MarshaledCredential
    );


BOOL
WINAPI
LocalCredUnmarshalCredentialW(
    IN LPCWSTR MarshaledCredential,
    OUT PCRED_MARSHAL_TYPE CredType,
    OUT PVOID *Credential
    );


BOOL
WINAPI
LocalCredIsMarshaledCredentialW(
    IN LPCWSTR MarshaledCredential
    );

BOOL
WINAPI
LocalCredIsMarshaledCredentialA(
    IN LPCSTR MarshaledCredential
    );


BOOL
WINAPI
LocalCredGetSessionTypes (
    IN DWORD MaximumPersistCount,
    OUT LPDWORD MaximumPersist
    );

VOID
WINAPI
LocalCredFree (
    IN PVOID Buffer
    );


// function to load pointers
BOOL
InitializeCredMgr ();

// function to unload lib
void
UninitializeCredMgr();

VOID
CredPutStdout(
    IN LPWSTR String
    );

VOID
CredGetStdin(
    OUT LPWSTR Buffer,
    IN DWORD BufferLength,
    IN BOOLEAN EchoChars
    );






//=============================================================================
// CreduiIsCapsLockOn
//
// Returns TRUE if the Caps Lock key was on at the time the most recent
// message was posted or FALSE otherwise.
//
// Created 02/27/2000 johnstep (John Stephens)
//=============================================================================

inline
BOOL
CreduiIsCapsLockOn()
{
    return (GetKeyState(VK_CAPITAL) & 1) == 1;
}



//
// Type of username
//

typedef enum _CREDUI_USERNAME_TYPE {
    CreduiMarshalledUsername, // @@...
    CreduiAbsoluteUsername,   // <DomainName>\<UserName>
    CreduiUpn,                // <UserName>@<DnsDomainName>
    CreduiRelativeUsername,   // <UserName>
} CREDUI_USERNAME_TYPE, *PCREDUI_USERNAME_TYPE;

DWORD
CredUIParseUserNameWithType(
    CONST WCHAR *UserName,
    WCHAR *user,
    ULONG userMaxChars,
    WCHAR *domain,
    ULONG domainMaxChars,
    PCREDUI_USERNAME_TYPE UsernameType
    );

LPWSTR
GetAccountDomainName(
    VOID
    );

BOOL
CompleteUserName(
    IN OUT LPWSTR UserName,
    IN ULONG UserNameMaxChars,
    IN PCREDENTIAL_TARGET_INFORMATIONW TargetInfo OPTIONAL,
    IN LPWSTR TargetName OPTIONAL,
    IN DWORD Flags
    );


BOOL TryLauchRegWizard ( 
    SSOPACKAGE* pSSOPackage,                        
    HWND hwndParent,
    BOOL HasLogonSession,
    WCHAR *userName,
    ULONG userNameMaxChars,
    WCHAR *password,
    ULONG passwordMaxChars,
    DWORD* pResult
    );

//-----------------------------------------------------------------------------

#endif // __UTILS_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\autoenrl\pautoenr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDD_USER_AUTOENROLL_GENERAL_DLG 184
#define IDD_USER_AUTOENROLL_INFO_DLG    185
#define IDD_VIEW_RA_CERTIFICATE_DLG     186
#define IDD_USER_SUMMARY_DLG            187
#define IDC_EDIT2                       200
#define IDC_EDIT1                       201
#define IDC_BUTTON1                     202
#define IDC_BUTTON2                     203
#define IDC_ENROLL_PROGRESS             204
#define IDC_EDIT3                       204
#define IDC_BUTTON3                     205
#define IDC_LIST1                       291
#define IDC_LIST2                       292
#define IDI_AUTOENROLL_ICON             1000
#define IDI_ENROLL_ICON                 1001
#define IDI_KEY_ICON                    1002
#define IDS_USER                        2000
#define IDS_MACHINE                     2001
#define IDS_BALLOON_TITLE               2002
#define IDS_BALLOON_TEXT                2003
#define IDS_ICON_TIP                    2004
#define IDS_REPORT_ENROLL               2005
#define IDS_REPORT_RENEW                2006
#define IDS_REPORT_ENROLL_RA            2007
#define IDS_REPORT_PENDING              2008
#define IDS_VIEW_RA_INFO                2011
#define IDS_VIEW_RA_INFO_GENERAL        2012
#define IDS_SUMMARY_REQUEST             2013
#define IDS_SUMMARY_CA                  2014
#define IDS_SUMMARY_INSTALL             2015
#define IDS_COLUMN_TYPE                 2016  
#define IDS_COLUMN_REASON               2017


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        242
#define _APS_NEXT_COMMAND_VALUE         32787
#define _APS_NEXT_CONTROL_VALUE         293
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\autoenrl\pautoenr\autoenro.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       autoenro.cpp
//
//--------------------------------------------------------------------------
#include <windows.h>
#include <winuser.h>
#include <wincrypt.h>
#include <cryptui.h>
#include <lmcons.h>
#include <lmapibuf.h>
#include <dsgetdc.h>
#include <oleauto.h>
#define SECURITY_WIN32
#include <rpc.h>
#include <security.h>
#include <winldap.h>
#include <dsrole.h>
#include <shobjidl.h>
#include <shellapi.h>
#include <commctrl.h>
#include <winscard.h>
#include <Rpcdce.h>

#include <certca.h>
#include <certsrv.h>
#include <autoenr.h>
#include <autoenro.h>
#include <autolog.h>
#include <resource.h>
#include <xenroll.h>

//*******************************************************************************
//
//
//     Global Defines and Data Structures
//
//
//*******************************************************************************


HINSTANCE   g_hmodThisDll = NULL;   // Handle to this DLL itself.

#if DBG
DWORD g_AutoenrollDebugLevel = AE_ERROR; //| AE_WARNING | AE_INFO | AE_TRACE;
#endif

//when we look at supersede relationship, we based on the following order
DWORD   g_rgdwSupersedeOrder[]={CERT_REQUEST_STATUS_OBTAINED,
                                CERT_REQUEST_STATUS_ACTIVE,
                                CERT_REQUEST_STATUS_PENDING,
                                CERT_REQUEST_STATUS_SUPERSEDE_ACTIVE};

DWORD   g_dwSupersedeOrder=sizeof(g_rgdwSupersedeOrder)/sizeof(g_rgdwSupersedeOrder[0]);


//the list of certificate store to update
AE_STORE_INFO   g_rgStoreInfo[]={
    L"ROOT",    L"ldap://%s/CN=Certification Authorities,CN=Public Key Services,CN=Services,%s?cACertificate?one?objectCategory=certificationAuthority",
    L"NTAuth",  L"ldap://%s/CN=Public Key Services,CN=Services,%s?cACertificate?one?cn=NTAuthCertificates",
    L"CA",      L"ldap://%s/CN=AIA,CN=Public Key Services,CN=Services,%s?crossCertificatePair,cACertificate?one?objectCategory=certificationAuthority"
};

DWORD   g_dwStoreInfo=sizeof(g_rgStoreInfo)/sizeof(g_rgStoreInfo[0]);

typedef   IEnroll4 * (WINAPI *PFNPIEnroll4GetNoCOM)();

static WCHAR * s_wszLocation = L"CN=Public Key Services,CN=Services,";

//Enhanced key usage for DS email replication
#ifndef CT_FLAG_REMOVE_INVALID_CERTIFICATE_FROM_PERSONAL_STORE
#define CT_FLAG_REMOVE_INVALID_CERTIFICATE_FROM_PERSONAL_STORE  0x00000400
#endif


//*******************************************************************************
//
//
//     Implementation of IQueryContinue for use autoenrollment notification
//
//
//*******************************************************************************
//--------------------------------------------------------------------------
//  CQueryContinue 
//--------------------------------------------------------------------------
CQueryContinue::CQueryContinue()
{
    m_cRef=1;
    m_pIUserNotification=NULL;
    m_hTimer=NULL;
}

//--------------------------------------------------------------------------
//  ~CQueryContinue 
//--------------------------------------------------------------------------
CQueryContinue::~CQueryContinue()
{


}

//--------------------------------------------------------------------------
//  CQueryContinue 
//--------------------------------------------------------------------------
HRESULT CQueryContinue::QueryInterface(REFIID riid, void **ppv)
{
    if(IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IQueryContinue))
    {
        *ppv=(LPVOID)this;
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

//--------------------------------------------------------------------------
//  AddRef
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CQueryContinue::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//--------------------------------------------------------------------------
//  Release 
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CQueryContinue::Release()
{
    if (InterlockedDecrement(&m_cRef))
        return m_cRef;

    delete this;
    return 0;
}

//--------------------------------------------------------------------------
//  CQueryContinue 
//--------------------------------------------------------------------------
HRESULT CQueryContinue::QueryContinue()
{
    //disable the balloon
    if(m_pIUserNotification)
        m_pIUserNotification->SetBalloonInfo(NULL, NULL, NIIF_INFO);

    //wait for the timer to be activated
    if(m_hTimer)
    {
        if(WAIT_OBJECT_0 == WaitForSingleObject(m_hTimer, 0))
          return S_FALSE;
    }
  
    return S_OK;
}
   

//--------------------------------------------------------------------------
//  DoBalloon() 
//--------------------------------------------------------------------------
HRESULT CQueryContinue::DoBalloon()
{

    HRESULT             hr=E_FAIL;
    WCHAR               wszTitle[MAX_DN_SIZE];
    WCHAR               wszText[MAX_DN_SIZE];
    HICON               hIcon=NULL;
    LARGE_INTEGER       DueTime;

   if(S_OK != (hr=CoCreateInstance(CLSID_UserNotification,
                                   NULL,
				   CLSCTX_ALL,
				   IID_IUserNotification,
				   (void **)&m_pIUserNotification)))
		goto Ret;

    if(NULL==m_pIUserNotification)
    {
        hr=E_FAIL;
        goto Ret;
    }

    //create a waitable timer with default security setting
    m_hTimer=CreateWaitableTimer(NULL, TRUE, NULL);

    if(NULL==m_hTimer)
    {
        hr=E_FAIL;
        goto Ret;
    }

    //set the timer
    DueTime.QuadPart = Int32x32To64(-10000, AUTO_ENROLLMENT_BALLOON_LENGTH * 1000);

    if(!SetWaitableTimer(m_hTimer, &DueTime, 0, NULL, 0, FALSE))
    {
        hr=E_FAIL;
        goto Ret;
    }


    if(S_OK != (hr=m_pIUserNotification->SetBalloonRetry(AUTO_ENROLLMENT_SHOW_TIME * 1000,
                                        AUTO_ENROLLMENT_INTERVAL * 1000,
                                        AUTO_ENROLLMENT_RETRIAL)))
        goto Ret;

    if((!LoadStringW(g_hmodThisDll,IDS_ICON_TIP, wszText, MAX_DN_SIZE)) ||
       (NULL==(hIcon=LoadIcon(g_hmodThisDll, MAKEINTRESOURCE(IDI_AUTOENROLL_ICON)))))
    {
       hr=E_FAIL;
       goto Ret;
    }

    if(S_OK != (hr=m_pIUserNotification->SetIconInfo(hIcon, wszText)))
        goto Ret;


    if((!LoadStringW(g_hmodThisDll,IDS_BALLOON_TITLE, wszTitle, MAX_DN_SIZE)) ||
       (!LoadStringW(g_hmodThisDll,IDS_BALLOON_TEXT, wszText, MAX_DN_SIZE)))
    {
       hr=E_FAIL;
       goto Ret;
    }

    if(S_OK !=(hr=m_pIUserNotification->SetBalloonInfo(wszTitle, wszText, NIIF_INFO)))
        goto Ret;

    //user did not click on the icon or we time out
    hr= m_pIUserNotification->Show(this, AUTO_ENROLLMENT_QUERY_INTERVAL * 1000);

Ret:
    if(m_hTimer)
    {
        CloseHandle(m_hTimer);
        m_hTimer=NULL;
    }


    if(m_pIUserNotification)
    {
        m_pIUserNotification->Release();
        m_pIUserNotification=NULL;
    }

    return hr;
}

//*******************************************************************************
//
//
//     Functions for autoenrollment
//
//
//*******************************************************************************

//--------------------------------------------------------------------------
//
// Name:    FindCertificateInOtherStore
//
//--------------------------------------------------------------------------
PCCERT_CONTEXT FindCertificateInOtherStore(
    IN HCERTSTORE hOtherStore,
    IN PCCERT_CONTEXT pCert
    )
{
    BYTE rgbHash[SHA1_HASH_LENGTH];
    CRYPT_DATA_BLOB HashBlob;

    HashBlob.pbData = rgbHash;
    HashBlob.cbData = SHA1_HASH_LENGTH;
    if (!CertGetCertificateContextProperty(
            pCert,
            CERT_SHA1_HASH_PROP_ID,
            rgbHash,
            &HashBlob.cbData
            ) || SHA1_HASH_LENGTH != HashBlob.cbData)
        return NULL;

    return CertFindCertificateInStore(
            hOtherStore,
            ENCODING_TYPE,      // dwCertEncodingType
            0,                  // dwFindFlags
            CERT_FIND_SHA1_HASH,
            (const void *) &HashBlob,
            NULL                //pPrevCertContext
            );
}

//--------------------------------------------------------------------------
//
//  AEUpdateCertificateStore
//
// Description: This function enumerates all of the certificate in the DS based
// LdapPath, and moves them into the corresponding local machine store.
//
//--------------------------------------------------------------------------
HRESULT WINAPI  AEUpdateCertificateStore(LDAP   *pld,
                                        LPWSTR  pwszConfig,
                                        LPWSTR  pwszDCName,
                                        LPWSTR  pwszStoreName,
                                        LPWSTR  pwszLdapPath)
{
    HRESULT                 hr = S_OK;
    PCCERT_CONTEXT          pContext = NULL,
                            pOtherCert = NULL;

    LPWSTR                  pwszLdapStore = NULL;
    HCERTSTORE              hEnterpriseStore = NULL,
                            hLocalStore = NULL;

    if((NULL==pld) || (NULL==pwszConfig) || (NULL==pwszDCName) || (NULL==pwszStoreName) || (NULL==pwszLdapPath))
    {
        hr = E_INVALIDARG;
        goto error;
    }

    pwszLdapStore = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR)*(wcslen(pwszConfig)+wcslen(pwszDCName)+wcslen(pwszLdapPath)));
    if(pwszLdapStore == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    wsprintf(pwszLdapStore, 
             pwszLdapPath,
             pwszDCName,
             pwszConfig);

    
    hLocalStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_REGISTRY_W, 
                                0, 
                                0, 
                                CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE, 
                                pwszStoreName);
    if(hLocalStore == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        AE_DEBUG((AE_ERROR, L"Unable to open ROOT store (%lx)\n\r", hr));
        goto error;
    }

    hEnterpriseStore = CertOpenStore(CERT_STORE_PROV_LDAP, 
                  0,
                  0,
                  CERT_STORE_READONLY_FLAG | CERT_LDAP_STORE_SIGN_FLAG |
                      CERT_LDAP_STORE_AREC_EXCLUSIVE_FLAG,
                  pwszLdapStore);
    
    if(hEnterpriseStore == NULL)
    {
        DWORD err = GetLastError();

        if((err == ERROR_FILE_NOT_FOUND))
        {
            // There was no store, so there are no certs
            hr = S_OK;
            goto error;
        }


        hr = HRESULT_FROM_WIN32(err);

        AE_DEBUG((AE_ERROR, L"Unable to open ROOT store (%lx)\n\r", hr));
        goto error;
    }


    while(pContext = CertEnumCertificatesInStore(hEnterpriseStore, pContext))
    {
        if (pOtherCert = FindCertificateInOtherStore(hLocalStore, pContext)) {
            CertFreeCertificateContext(pOtherCert);
        } 
        else
        {
            CertAddCertificateContextToStore(hLocalStore,
                                         pContext,
                                         CERT_STORE_ADD_ALWAYS,
                                         NULL);
        }
    }

    while(pContext = CertEnumCertificatesInStore(hLocalStore, pContext))
    {
        if (pOtherCert = FindCertificateInOtherStore(hEnterpriseStore, pContext)) {
            CertFreeCertificateContext(pOtherCert);
        } 
        else
        {
            CertDeleteCertificateFromStore(CertDuplicateCertificateContext(pContext));
        }
    }


error:

    if(hr != S_OK)
    {
        AELogAutoEnrollmentEvent(
                            STATUS_SEVERITY_ERROR,  //this event will always be logged
                            TRUE,
                            hr,
                            EVENT_FAIL_DOWNLOAD_CERT,
                            TRUE,
                            NULL,
                            3,
                            pwszStoreName,
                            pwszConfig,
                            pwszLdapPath);

    }

    if(pwszLdapStore)
    {
        LocalFree(pwszLdapStore);
    }

    if(hEnterpriseStore)
    {
        CertCloseStore(hEnterpriseStore,0);
    }

    if(hLocalStore)
    {
        CertCloseStore(hLocalStore,0);
    }

    return hr;
}

//--------------------------------------------------------------------------
//
//  AENeedToUpdateDSCache
//
//--------------------------------------------------------------------------
BOOL AENeedToUpdateDSCache(LDAP *pld, LPWSTR pwszDCInvocationID, LPWSTR pwszConfig, AE_DS_INFO *pAEDSInfo)
{
    BOOL                fNeedToUpdate=TRUE;
    DWORD               dwRegObject=0;
    ULARGE_INTEGER      maxRegUSN;
    ULARGE_INTEGER      maxDsUSN;
    DWORD               dwType=0;
    DWORD               dwSize=0;
    DWORD               dwDisp=0;
    struct l_timeval    timeout;
    LPWSTR              rgwszAttrs[] = {AUTO_ENROLLMENT_USN_ATTR, NULL};
    LDAPMessage         *Entry=NULL;

    LPWSTR              *awszValue = NULL;
    HKEY                hDSKey=NULL;
    HKEY                hDCKey=NULL;
    LDAPMessage         *SearchResult = NULL;
    LPWSTR              pwszContainer=NULL;


    if((NULL==pld) || (NULL==pwszDCInvocationID) || (NULL==pwszConfig) || (NULL==pAEDSInfo))
        goto error;

    //init
    memset(pAEDSInfo, 0, sizeof(AE_DS_INFO));

    //compute the # of objects and maxUSN from the directory
    pwszContainer=(LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * (1 + wcslen(pwszConfig) + wcslen(s_wszLocation)));
    if(NULL == pwszContainer)
        goto error;
        
    wcscpy(pwszContainer, s_wszLocation);
    wcscat(pwszContainer, pwszConfig);

    timeout.tv_sec = 300;
    timeout.tv_usec = 0;
    
	if(LDAP_SUCCESS != ldap_search_stW(
		      pld, 
		      pwszContainer,
		      LDAP_SCOPE_SUBTREE,
		      L"(objectCategory=certificationAuthority)",
		      rgwszAttrs,
		      0,
		      &timeout,
		      &SearchResult))
        goto error;

    //get the # of objects
    pAEDSInfo->dwObjects = ldap_count_entries(pld, SearchResult);

    for(Entry = ldap_first_entry(pld, SearchResult);  Entry != NULL; Entry = ldap_next_entry(pld, Entry))
    {

        awszValue = ldap_get_values(pld, Entry, AUTO_ENROLLMENT_USN_ATTR);

        if(NULL==awszValue)
            goto error;

        if(NULL==awszValue[0])
            goto error;

        maxDsUSN.QuadPart=0;

        maxDsUSN.QuadPart=_wtoi64(awszValue[0]);

        //if any error happens, maxDsUSN will be 0.
        if(0 == maxDsUSN.QuadPart)
            goto error;

        if((pAEDSInfo->maxUSN).QuadPart < maxDsUSN.QuadPart)
             (pAEDSInfo->maxUSN).QuadPart = maxDsUSN.QuadPart;

        ldap_value_free(awszValue);
        awszValue=NULL;
    }

    //signal that we have retrieved correct data from the directory
    pAEDSInfo->fValidData=TRUE;

   //find if we have cached any information about the DC of interest
    if(ERROR_SUCCESS != RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                         AUTO_ENROLLMENT_DS_KEY,
                         0,
                         TEXT(""),
                         REG_OPTION_NON_VOLATILE,
                         KEY_ALL_ACCESS,
                         NULL,
                         &hDSKey,
                         &dwDisp))        
        goto error;


    if(ERROR_SUCCESS != RegOpenKeyEx(
                        hDSKey,
                        pwszDCInvocationID,
                        0,
                        KEY_ALL_ACCESS,
                        &hDCKey))
        goto error;


    dwSize=sizeof(dwRegObject);

    if(ERROR_SUCCESS != RegQueryValueEx(
                        hDCKey,
                        AUTO_ENROLLMENT_DS_OBJECT,  
                        NULL,
                        &dwType,
                        (PBYTE)(&dwRegObject),    
                        &dwSize))
        goto error;

    if(REG_DWORD != dwType)
        goto error;


    dwSize=sizeof(maxRegUSN);

    if(ERROR_SUCCESS != RegQueryValueEx(
                        hDCKey,
                        AUTO_ENROLLMENT_DS_USN,  
                        NULL,
                        &dwType,
                        (PBYTE)(&(maxRegUSN)),    
                        &dwSize))
        goto error;

    if(REG_BINARY != dwType)
        goto error;


    //compare the registry data with the data from directory
    if(dwRegObject != (pAEDSInfo->dwObjects))
        goto error;

    if(maxRegUSN.QuadPart != ((pAEDSInfo->maxUSN).QuadPart))
        goto error;

    fNeedToUpdate=FALSE;

error:
    
    if(awszValue)
        ldap_value_free(awszValue);

    if(pwszContainer)
        LocalFree(pwszContainer);

    if(hDCKey)
        RegCloseKey(hDCKey);

    if(hDSKey)
        RegCloseKey(hDSKey);

    if(SearchResult)
        ldap_msgfree(SearchResult);

    //remove the temporary data
    if(pAEDSInfo)
    {
        if(FALSE == fNeedToUpdate)
            memset(pAEDSInfo, 0, sizeof(AE_DS_INFO));
    }


    return fNeedToUpdate;
}

//--------------------------------------------------------------------------
//
//  AEUpdateDSCache
//
//--------------------------------------------------------------------------
BOOL AEUpdateDSCache(LPWSTR pwszDCInvocationID, AE_DS_INFO *pAEDSInfo)
{

    BOOL    fResult=FALSE;
    DWORD   dwDisp=0;

    HKEY    hDSKey=NULL;
    HKEY    hDCKey=NULL;

    if((NULL==pwszDCInvocationID) || (NULL==pAEDSInfo))
        goto error;

    if(ERROR_SUCCESS != RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                         AUTO_ENROLLMENT_DS_KEY,
                         0,
                         TEXT(""),
                         REG_OPTION_NON_VOLATILE,
                         KEY_ALL_ACCESS,
                         NULL,
                         &hDSKey,
                         &dwDisp))
        goto error;


    //create the key named by the DC
    if(ERROR_SUCCESS != RegCreateKeyEx(hDSKey,
                         pwszDCInvocationID,
                         0,
                         TEXT(""),
                         REG_OPTION_NON_VOLATILE,
                         KEY_ALL_ACCESS,
                         NULL,
                         &hDCKey,
                         &dwDisp))
        goto error;

    //set the # of objects value
    if(ERROR_SUCCESS != RegSetValueEx(hDCKey,
                    AUTO_ENROLLMENT_DS_OBJECT,
                    NULL,
                    REG_DWORD,
                    (PBYTE)&(pAEDSInfo->dwObjects),
                    sizeof(pAEDSInfo->dwObjects)))
        goto error;

    //set the max uSN value
    if(ERROR_SUCCESS != RegSetValueEx(hDCKey,
                    AUTO_ENROLLMENT_DS_USN,
                    NULL,
                    REG_BINARY,
                    (PBYTE)&(pAEDSInfo->maxUSN),
                    sizeof(pAEDSInfo->maxUSN)))
        goto error;

    fResult=TRUE;

error:

    if(hDCKey)
        RegCloseKey(hDCKey);

    if(hDSKey)
        RegCloseKey(hDSKey);


    return fResult;
}


//--------------------------------------------------------------------------
//
//  AERetrieveInvocationID
//
//--------------------------------------------------------------------------
BOOL  AERetrieveInvocationID(LDAP *pld, LPWSTR *ppwszID)
{  
    BOOL                fResult=FALSE;
    struct l_timeval    timeout;
    LPWSTR              rgwszDSAttrs[] = {L"dsServiceName", NULL};
    LPWSTR              rgwszIDAttr[] = {L"invocationId", NULL};
    LDAPMessage         *Entry=NULL;

    LPWSTR              *awszValues = NULL;
    LDAPMessage         *SearchResults = NULL;
    struct berval       **apUUID = NULL;
    LDAPMessage         *SearchIDResult = NULL;
    BYTE                *pbUUID=NULL;



    if((NULL==pld) || (NULL==ppwszID))
        goto error;

    *ppwszID=NULL;

    //retrieve the dsSerivceName attribute
    timeout.tv_sec = 300;
    timeout.tv_usec = 0;

	if(LDAP_SUCCESS != ldap_search_stW(
		      pld, 
		      NULL,                     //NULL DN for dsServiceName
		      LDAP_SCOPE_BASE,
		      L"(objectCategory=*)",
		      rgwszDSAttrs,
		      0,
		      &timeout,
		      &SearchResults))
        goto error;


    Entry = ldap_first_entry(pld, SearchResults);

    if(NULL == Entry)
        goto error;

    awszValues = ldap_get_values(pld, Entry, rgwszDSAttrs[0]);

    if(NULL==awszValues)
        goto error;

    if(NULL==awszValues[0])
        goto error;

    //retrieve the invocationId attribute
    timeout.tv_sec = 300;
    timeout.tv_usec = 0;

	if(LDAP_SUCCESS != ldap_search_stW(
		      pld, 
		      awszValues[0],                     
		      LDAP_SCOPE_BASE,
		      L"(objectCategory=*)",
		      rgwszIDAttr,
		      0,
		      &timeout,
		      &SearchIDResult))
        goto error;


    Entry = ldap_first_entry(pld, SearchIDResult);

    if(NULL == Entry)
        goto error;

	apUUID = ldap_get_values_len(pld, Entry, rgwszIDAttr[0]);

    if(NULL == apUUID)
        goto error;

    if(NULL == (*apUUID))
        goto error;

    pbUUID = (BYTE *)LocalAlloc(LPTR, (*apUUID)->bv_len);

    if(NULL == (pbUUID))
        goto error;

    memcpy(pbUUID, (*apUUID)->bv_val, (*apUUID)->bv_len);

    if(RPC_S_OK != UuidToStringW((UUID *)pbUUID, ppwszID))
        goto error;

    fResult=TRUE;

error:

    if(pbUUID)
        LocalFree(pbUUID);

    if(apUUID)
        ldap_value_free_len(apUUID);

    if(SearchIDResult)
        ldap_msgfree(SearchIDResult);

    if(awszValues)
        ldap_value_free(awszValues);

    if(SearchResults)
        ldap_msgfree(SearchResults);

    return fResult;
}

//--------------------------------------------------------------------------
//
//  AEDownloadStore
//
//--------------------------------------------------------------------------
BOOL WINAPI AEDownloadStore(LDAP *pld, LPWSTR pwszDCName)
{
    BOOL        fResult = TRUE;
    DWORD       dwIndex = 0;
    AE_DS_INFO  AEDSInfo;

    LPWSTR      wszConfig = NULL;
    LPWSTR      pwszDCInvocationID = NULL;

    memset(&AEDSInfo, 0, sizeof(AEDSInfo));

    if(S_OK  != AEGetConfigDN(pld, &wszConfig))
    {
        fResult=FALSE;
        goto error;
    }

    //get the pwszDCInvocationID.  NULL means AENeedToUpdateDSCache will return TRUE
    AERetrieveInvocationID(pld, &pwszDCInvocationID);

    if(AENeedToUpdateDSCache(pld, pwszDCInvocationID, wszConfig, &AEDSInfo))
    {
        for(dwIndex =0; dwIndex < g_dwStoreInfo; dwIndex++)
        {
            fResult = fResult && (S_OK == AEUpdateCertificateStore(
                                            pld, 
                                            wszConfig,
                                            pwszDCName,
                                            g_rgStoreInfo[dwIndex].pwszStoreName,
                                            g_rgStoreInfo[dwIndex].pwszLdapPath));
        }

        //only update the new DS cached information if we have a successful download
        if((fResult) && (TRUE == AEDSInfo.fValidData) && (pwszDCInvocationID))
            AEUpdateDSCache(pwszDCInvocationID, &AEDSInfo);
    }


error:

    if(pwszDCInvocationID)
        RpcStringFreeW(&pwszDCInvocationID);

    if(wszConfig)
    {
        LocalFree(wszConfig);
    }

    return fResult;
}


//--------------------------------------------------------------------------
//
//  AESetWakeUpFlag
//
//  We set the flag to tell winlogon if autoenrollment should be waken up
//  during each policy check
//
//--------------------------------------------------------------------------
BOOL WINAPI AESetWakeUpFlag(BOOL    fMachine,   BOOL fWakeUp)
{
    BOOL    fResult = FALSE;
    DWORD   dwDisp = 0;
    DWORD   dwFlags = 0;

    HKEY    hAEKey = NULL;
    
    if(ERROR_SUCCESS != RegCreateKeyEx(
                    fMachine ? HKEY_LOCAL_MACHINE : HKEY_CURRENT_USER,
                    AUTO_ENROLLMENT_FLAG_KEY,
                    0,
                    L"",
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hAEKey,
                    &dwDisp))
        goto Ret;

    if(fWakeUp)
        dwFlags = AUTO_ENROLLMENT_WAKE_UP_REQUIRED;

    if(ERROR_SUCCESS != RegSetValueEx(
                    hAEKey,
                    AUTO_ENROLLMENT_FLAG,
                    0,
                    REG_DWORD,
                    (PBYTE)&dwFlags,
                    sizeof(dwFlags)))
        goto Ret;


    fResult=TRUE;

Ret:
    if(hAEKey)
        RegCloseKey(hAEKey);

    return fResult;
}


//--------------------------------------------------------------------------
//
//  AESetWakeUpTimer
//
//  Set the timer to wake us up in 8 hrs
//
//--------------------------------------------------------------------------
BOOL WINAPI AESetWakeUpTimer(BOOL fMachine, LARGE_INTEGER *pPreTime, LARGE_INTEGER *pPostTime)
{
    HRESULT hr;
    HKEY hKey;
    HKEY hCurrent;
    DWORD dwType, dwSize, dwResult;
    LONG lTimeout;
    LARGE_INTEGER DueTime;
    WCHAR * wszTimerName;
    LARGE_INTEGER EnrollmentTime;

    // must be cleaned up
    HANDLE hTimer=NULL;

    // Build a timer event to ping us in about 8 hours if we don't get notified sooner.
    lTimeout=AE_DEFAULT_REFRESH_RATE;

    // Query for the refresh timer value
    if (ERROR_SUCCESS==RegOpenKeyEx((fMachine?HKEY_LOCAL_MACHINE:HKEY_CURRENT_USER), SYSTEM_POLICIES_KEY, 0, KEY_READ, &hKey)) {
        dwSize=sizeof(lTimeout);
        RegQueryValueEx(hKey, TEXT("AutoEnrollmentRefreshTime"), NULL, &dwType, (LPBYTE) &lTimeout, &dwSize);
        RegCloseKey(hKey);
    }

    // Limit the timeout to once every 240 hours (10 days)
    if (lTimeout>=240) {
        lTimeout=240;
    } else if (lTimeout<0) {
        lTimeout=0;
    }

    // Convert hours to milliseconds
    lTimeout=lTimeout*60*60*1000;

    // Special case 0 milliseconds to be 7 seconds
    if (lTimeout==0) {
        lTimeout=7000;
    }

    // convert to 10^-7s. not yet negative values are relative
    DueTime.QuadPart=Int32x32To64(-10000, lTimeout);

    // if user has hold on the UI for too long and the cycle passed the 8 hours.
    // we set the time for 1 hour
    EnrollmentTime.QuadPart=pPostTime->QuadPart - pPreTime->QuadPart;

    if(EnrollmentTime.QuadPart > 0)
    {
        if((-(DueTime.QuadPart)) > EnrollmentTime.QuadPart)
        {
            DueTime.QuadPart = DueTime.QuadPart + EnrollmentTime.QuadPart;
        }
        else
        {
            // Convert hours to milliseconds
            lTimeout=AE_DEFAULT_POSTPONE*60*60*1000;
            DueTime.QuadPart = Int32x32To64(-10000, lTimeout);
        }
    }


    // find the timer
    if (fMachine) {
        wszTimerName=L"Global\\" MACHINE_AUTOENROLLMENT_TIMER_NAME;
    } else {
        wszTimerName=USER_AUTOENROLLMENT_TIMER_NAME;
    }
    hTimer=OpenWaitableTimer(TIMER_MODIFY_STATE, false, wszTimerName);
    if (NULL==hTimer) {
        hr=HRESULT_FROM_WIN32(GetLastError());
        AE_DEBUG((AE_ERROR, L"OpenWaitableTimer(%s) failed with 0x%08X.\n", wszTimerName, hr));
        goto error;
    }

    // set the timer
    if (!SetWaitableTimer (hTimer, &DueTime, 0, NULL, 0, FALSE)) {
        hr=HRESULT_FROM_WIN32(GetLastError());
        AE_DEBUG((AE_ERROR, L"SetWaitableTimer  failed with 0x%08X.\n", hr));
        goto error;
    }

    AE_DEBUG((AE_INFO, L"Set wakeup timer.\n"));

    hr=S_OK;
error:
    if (NULL!=hTimer) {
        CloseHandle(hTimer);
    }
    return (S_OK==hr);
}


//--------------------------------------------------------------------------
//
//  AEGetPendingRequestProperty
//
//--------------------------------------------------------------------------
BOOL    AEGetPendingRequestProperty(IEnroll4    *pIEnroll4, 
                                    DWORD       dwIndex, 
                                    DWORD       dwProp, 
                                    LPVOID      pProp)
{
    CRYPT_DATA_BLOB *pBlob=NULL;
    BOOL            fResult=FALSE;

    if((NULL==pIEnroll4) || (NULL==pProp))
        return FALSE;

    switch(dwProp)
    {
        case XEPR_REQUESTID:   
        case XEPR_DATE:           
        case XEPR_VERSION:
                fResult = (S_OK == pIEnroll4->enumPendingRequestWStr(dwIndex, dwProp, pProp));
            break;
            
            
        case XEPR_CANAME:                     
        case XEPR_CAFRIENDLYNAME: 
        case XEPR_CADNS:          
        case XEPR_V1TEMPLATENAME: 
        case XEPR_V2TEMPLATEOID:  
        case XEPR_HASH:
                
                pBlob=(CRYPT_DATA_BLOB *)pProp;

                pBlob->cbData=0;
                pBlob->pbData=NULL;

                if(S_OK != pIEnroll4->enumPendingRequestWStr(dwIndex, dwProp, pProp))
                    goto Ret;

                if(0 == pBlob->cbData)
                    goto Ret;

                pBlob->pbData=(BYTE *)LocalAlloc(LPTR, pBlob->cbData);
                if(NULL == pBlob->pbData)
                    goto Ret;

                fResult = (S_OK == pIEnroll4->enumPendingRequestWStr(dwIndex, dwProp, pProp));

            break;

        default:
            break;
    }

Ret:
    if(FALSE==fResult)
    {
        if(pBlob)
        {
            if(pBlob->pbData)
                LocalFree(pBlob->pbData);

            memset(pBlob, 0, sizeof(CRYPT_DATA_BLOB));
        }
    }

    return fResult;
}
//--------------------------------------------------------------------------
//
//  AERetrieveRequestProperty
//
//--------------------------------------------------------------------------
BOOL    AERetrieveRequestProperty(IEnroll4          *pIEnroll4, 
                                  DWORD             dwIndex, 
                                  DWORD             *pdwCount, 
                                  DWORD             *pdwMax, 
                                  CRYPT_DATA_BLOB   **prgblobHash)
{
    BOOL                fResult=FALSE;
    CRYPT_DATA_BLOB     *pblobHash=NULL;

    if((NULL==pIEnroll4) || (NULL==pdwCount) || (NULL==pdwMax) || (NULL==prgblobHash) ||
        (NULL==*prgblobHash))
        goto Ret;

    //need to alloc more memory
    if((*pdwCount) >= (*pdwMax))
    {
        pblobHash=*prgblobHash;

        *prgblobHash=(CRYPT_DATA_BLOB *)LocalAlloc(LPTR, 
                                    ((*pdwMax) + PENDING_ALLOC_SIZE) * sizeof(CRYPT_DATA_BLOB));
        if(NULL==(*prgblobHash))
        {
            *prgblobHash=pblobHash;
            pblobHash=NULL;
            goto Ret;
        }

        memset(*prgblobHash, 0, ((*pdwMax) + PENDING_ALLOC_SIZE) * sizeof(CRYPT_DATA_BLOB));

        //copy the old memmory
        memcpy(*prgblobHash, pblobHash, (*pdwMax) * sizeof(CRYPT_DATA_BLOB));

        *pdwMax=(*pdwMax) + PENDING_ALLOC_SIZE;
    }


    if(!AEGetPendingRequestProperty(pIEnroll4, dwIndex, XEPR_HASH, 
                                    &((*prgblobHash)[*pdwCount])))
        goto Ret;

    (*pdwCount)=(*pdwCount) + 1;

    fResult=TRUE;

Ret:

    if(pblobHash)
        LocalFree(pblobHash);

    return fResult;
}


//--------------------------------------------------------------------------
//
//  AERemovePendingRequest
//
//--------------------------------------------------------------------------
BOOL    AERemovePendingRequest(IEnroll4         *pIEnroll4, 
                               DWORD            dwCount, 
                               CRYPT_DATA_BLOB  *rgblobHash)
{
    DWORD   dwIndex=0;
    BOOL    fResult=TRUE;

    if((NULL==pIEnroll4) || (NULL==rgblobHash))
        return FALSE;

    for(dwIndex=0; dwIndex < dwCount; dwIndex++)
    {
        if(S_OK != (pIEnroll4->removePendingRequestWStr(rgblobHash[dwIndex])))
            fResult=FALSE;
    }

    return fResult;
}

//--------------------------------------------------------------------------
//
//  AEFreePendingRequests
//
//--------------------------------------------------------------------------
BOOL    AEFreePendingRequests(DWORD dwCount, CRYPT_DATA_BLOB    *rgblobHash)
{
    DWORD   dwIndex=0;

    if(rgblobHash)
    {
        for(dwIndex=0; dwIndex < dwCount; dwIndex++)
        {
            if(rgblobHash[dwIndex].pbData)
                LocalFree(rgblobHash[dwIndex].pbData);
        }

        LocalFree(rgblobHash);
    }

    return TRUE;
}


//--------------------------------------------------------------------------
//
//  AEValidVersionCert
//  
//      Verify the certificate returned from CA has the latest version info.
//  If so, copy the certificate to the hIssuedStore for potentical publishing
// 
//--------------------------------------------------------------------------
BOOL    AEValidVersionCert(AE_CERTTYPE_INFO *pCertType, IEnroll4  *pIEnroll4, CRYPT_DATA_BLOB  *pBlobPKCS7)
{
    BOOL                fValid=FALSE;   

    PCCERT_CONTEXT      pCertContext=NULL;
    AE_TEMPLATE_INFO    AETemplateInfo;

    memset(&AETemplateInfo, 0, sizeof(AE_TEMPLATE_INFO));

    if((NULL==pCertType) || (NULL==pIEnroll4) || (NULL==pBlobPKCS7))
        goto Ret;

    if(NULL==(pBlobPKCS7->pbData))
        goto Ret;

    if(S_OK != pIEnroll4->getCertContextFromResponseBlob(pBlobPKCS7, &pCertContext))
        goto Ret;

    if(!AERetrieveTemplateInfo(pCertContext, &AETemplateInfo))
        goto Ret;
                      

    if(AETemplateInfo.pwszOid)
    {
        if(AETemplateInfo.dwVersion >= (pCertType->dwVersion))
            fValid=TRUE;
    }
    else
    {
        //V1 template
        if(NULL == AETemplateInfo.pwszName)
            goto Ret;

        fValid=TRUE;
    }

    if(pCertContext && (TRUE == fValid))
    {
        CertAddCertificateContextToStore(pCertType->hIssuedStore, 
                                        pCertContext,
                                        CERT_STORE_ADD_USE_EXISTING,
                                        NULL);
    }

Ret:
    if(pCertContext)
        CertFreeCertificateContext(pCertContext);

    AEFreeTemplateInfo(&AETemplateInfo);

    return fValid;
}


//--------------------------------------------------------------------------
//
//  AECopyPendingBlob
//  
//      Copy the issued PKCS7 and request hash.
// 
//--------------------------------------------------------------------------
BOOL    AECopyPendingBlob(CRYPT_DATA_BLOB   *pBlobPKCS7,
                          IEnroll4          *pIEnroll4, 
                          DWORD             dwXenrollIndex, 
                          AE_CERTTYPE_INFO  *pCertType)
{
    BOOL            fResult=FALSE;
    DWORD           dwIndex=0;

    AE_PEND_INFO    *pPendInfo=NULL;

    if((NULL==pBlobPKCS7)||(NULL==pIEnroll4)||(NULL==pCertType))
        goto Ret;

    if(NULL==(pBlobPKCS7->pbData))
        goto Ret;

    dwIndex=pCertType->dwPendCount;

    //increase the memory array
    if(0 != dwIndex)
    {
        pPendInfo=pCertType->rgPendInfo;

        pCertType->rgPendInfo=(AE_PEND_INFO *)LocalAlloc(LPTR, 
                                    (dwIndex + 1) * sizeof(AE_PEND_INFO));

        if(NULL==(pCertType->rgPendInfo))
        {
            pCertType->rgPendInfo=pPendInfo;
            pPendInfo=NULL;
            goto Ret;
        }

        memset(pCertType->rgPendInfo, 0, (dwIndex + 1) * sizeof(AE_PEND_INFO));

        //copy the old memmory
        memcpy(pCertType->rgPendInfo, pPendInfo, (dwIndex) * sizeof(AE_PEND_INFO));
    }
    else
    {
        pCertType->rgPendInfo=(AE_PEND_INFO *)LocalAlloc(LPTR, sizeof(AE_PEND_INFO));

        if(NULL==(pCertType->rgPendInfo))
            goto Ret;

        memset(pCertType->rgPendInfo, 0, sizeof(AE_PEND_INFO));
    }

    
    //copy the issued PKCS7 blob
    (pCertType->rgPendInfo)[dwIndex].blobPKCS7.pbData=(BYTE *)LocalAlloc(
                                            LPTR,
                                            pBlobPKCS7->cbData);

    if(NULL == ((pCertType->rgPendInfo)[dwIndex].blobPKCS7.pbData))
        goto Ret;
                  
    memcpy((pCertType->rgPendInfo)[dwIndex].blobPKCS7.pbData,
            pBlobPKCS7->pbData,
            pBlobPKCS7->cbData);

    (pCertType->rgPendInfo)[dwIndex].blobPKCS7.cbData=pBlobPKCS7->cbData;

    //copy the hash of the request
    if(!AEGetPendingRequestProperty(pIEnroll4, dwXenrollIndex, XEPR_HASH, 
                                    &((pCertType->rgPendInfo)[dwIndex].blobHash)))
    {
        LocalFree((pCertType->rgPendInfo)[dwIndex].blobPKCS7.pbData);
        (pCertType->rgPendInfo)[dwIndex].blobPKCS7.pbData=NULL;
        (pCertType->rgPendInfo)[dwIndex].blobPKCS7.cbData=0;
        goto Ret;
    }

    (pCertType->dwPendCount)++;

    fResult=TRUE;

Ret:
    if(pPendInfo)
        LocalFree(pPendInfo);

    return fResult;
}
//--------------------------------------------------------------------------
//
//  AEProcessUIPendingRequest
//  
//      In this function, we install the issued pending certificate request
//  that will require UI.
// 
//--------------------------------------------------------------------------
BOOL WINAPI AEProcessUIPendingRequest(AE_GENERAL_INFO *pAE_General_Info)
{
    DWORD                   dwIndex=0;
    DWORD                   dwPendIndex=0;
    AE_CERTTYPE_INFO        *pCertTypeInfo=pAE_General_Info->rgCertTypeInfo;
    AE_CERTTYPE_INFO        *pCertType=NULL;
    BOOL                    fInit=FALSE;
    PFNPIEnroll4GetNoCOM    pfnPIEnroll4GetNoCOM=NULL;
    HMODULE                 hXenroll=NULL;
    HRESULT                 hr=E_FAIL;

    IEnroll4                *pIEnroll4=NULL;

    if(NULL==pAE_General_Info)
        goto Ret;

    //has to be in the UI mode
    if(FALSE == pAE_General_Info->fUIProcess)
        goto Ret;

    if(NULL==pCertTypeInfo)
        goto Ret;

    hXenroll=pAE_General_Info->hXenroll;

    if(NULL==hXenroll)
        goto Ret;

    if(NULL==(pfnPIEnroll4GetNoCOM=(PFNPIEnroll4GetNoCOM)GetProcAddress(
                        hXenroll,
                        "PIEnroll4GetNoCOM")))
        goto Ret;


    if(FAILED(CoInitialize(NULL)))
	    goto Ret;

    fInit=TRUE;

    if(NULL==(pIEnroll4=pfnPIEnroll4GetNoCOM()))
        goto Ret;

    //Set the request store flag based on fMachine
    if(pAE_General_Info->fMachine)
    {
        if(S_OK != pIEnroll4->put_RequestStoreFlags(CERT_SYSTEM_STORE_LOCAL_MACHINE))
            goto Ret;
    }
    else
    {
        if(S_OK != pIEnroll4->put_RequestStoreFlags(CERT_SYSTEM_STORE_CURRENT_USER))
            goto Ret;
    }

    //initialize the enumerator
    if(S_OK != pIEnroll4->enumPendingRequestWStr(XEPR_ENUM_FIRST, 0, NULL))
        goto Ret;

    for(dwIndex=0; dwIndex < pAE_General_Info->dwCertType; dwIndex++)
    {
        pCertType = &(pCertTypeInfo[dwIndex]);

        if(pCertType->dwPendCount)
        {
            for(dwPendIndex=0; dwPendIndex < pCertType->dwPendCount; dwPendIndex++)
            {
                //check if cancel button is clicked
                if(AECancelled(pAE_General_Info->hCancelEvent))
                    break;

                //report the current enrollment action
                AEUIProgressReport(TRUE, pCertType, pAE_General_Info->hwndDlg, pAE_General_Info->hCancelEvent);

   		        //install the certificate
                if(S_OK == (hr = pIEnroll4->acceptResponseBlob(
                    &((pCertType->rgPendInfo)[dwPendIndex].blobPKCS7))))
                {
                    //mark the status to obtained if required
                    //this is a valid certificate
                    if(AEValidVersionCert(pCertType, pIEnroll4, &((pCertType->rgPendInfo)[dwPendIndex].blobPKCS7)))
                        pCertType->dwStatus = CERT_REQUEST_STATUS_OBTAINED;

                    //the certificate is successfully issued and installed
                    //remove the request from the request store
                    pIEnroll4->removePendingRequestWStr((pCertType->rgPendInfo)[dwPendIndex].blobHash);

                    AELogAutoEnrollmentEvent(
                        pAE_General_Info->dwLogLevel,
                        FALSE, 
                        S_OK, 
                        EVENT_PENDING_INSTALLED, 
                        pAE_General_Info->fMachine, 
                        pAE_General_Info->hToken, 
                        1,
                        pCertType->awszDisplay[0]);

                }
                else
                {
                    //doing this for summary page
                    if((SCARD_E_CANCELLED != hr) && (SCARD_W_CANCELLED_BY_USER != hr))
                        pCertType->idsSummary=IDS_SUMMARY_INSTALL;

                    AELogAutoEnrollmentEvent(
                        pAE_General_Info->dwLogLevel,
                        TRUE, 
                        hr, 
                        EVENT_PENDING_FAILED, 
                        pAE_General_Info->fMachine, 
                        pAE_General_Info->hToken, 
                        1,
                        pCertType->awszDisplay[0]);
                }

                //advance progress
                AEUIProgressAdvance(pAE_General_Info);
            }
        }
    }

Ret:
    if(pIEnroll4)
        pIEnroll4->Release();

    if(fInit)
        CoUninitialize();
    
    return TRUE;
}   
   

//--------------------------------------------------------------------------
//
//  AEProcessPendingRequest -- UIless call.
//  
//      In this function, we check each pending requests in the request store.
//  We install the certificate is the request has been issued by the CA, and 
//  mark the certificate type status to obtained if the certificate is issued
//  and of correct version
//
//      We remove any requests that are stale based on the # of days defined
//  in the registry.  If no value is defined in the registry, use 
//  AE_PENDING_REQUEST_ACTIVE_PERIOD (60 days).
//
//      Also, if there is no more pending requests active in the request store,
//  we set the registry value to indicate that winlogon should not wake us up.
// 
//--------------------------------------------------------------------------
BOOL WINAPI AEProcessPendingRequest(AE_GENERAL_INFO *pAE_General_Info)
{
    DWORD                   dwRequestID=0;
    LONG                    dwDisposition=0;
    DWORD                   dwIndex=0;
    DWORD                   dwCount=0;
    DWORD                   dwMax=PENDING_ALLOC_SIZE;
    AE_CERTTYPE_INFO        *pCertType=NULL;
    PFNPIEnroll4GetNoCOM    pfnPIEnroll4GetNoCOM=NULL;
    BOOL                    fInit=FALSE;
    AE_TEMPLATE_INFO        AETemplateInfo;
    CRYPT_DATA_BLOB         blobPKCS7;
    HMODULE                 hXenroll=NULL;
    VARIANT                 varCMC; 
	HRESULT					hr=E_FAIL;
  

    IEnroll4                *pIEnroll4=NULL;
    ICertRequest2           *pICertRequest=NULL;
	BSTR	                bstrCert=NULL;
    LPWSTR                  pwszCAConfig=NULL;
    BSTR                    bstrConfig=NULL;
    CRYPT_DATA_BLOB         *rgblobHash=NULL;
    CRYPT_DATA_BLOB         blobCAName;
    CRYPT_DATA_BLOB         blobCALocation;
    CRYPT_DATA_BLOB         blobName;


    if(NULL==pAE_General_Info)
        goto Ret;

    //init the dwUIPendCount to 0
    pAE_General_Info->dwUIPendCount=0;

    //has to be in the UIless mode
    if(TRUE == pAE_General_Info->fUIProcess)
        goto Ret;

    hXenroll=pAE_General_Info->hXenroll;

    if(NULL==hXenroll)
        goto Ret;

    if(NULL==(pfnPIEnroll4GetNoCOM=(PFNPIEnroll4GetNoCOM)GetProcAddress(
                        hXenroll,
                        "PIEnroll4GetNoCOM")))
        goto Ret;


    if(FAILED(CoInitialize(NULL)))
	    goto Ret;

    fInit=TRUE;

    if(NULL==(pIEnroll4=pfnPIEnroll4GetNoCOM()))
        goto Ret;


	if(S_OK != CoCreateInstance(CLSID_CCertRequest,
									NULL,
									CLSCTX_INPROC_SERVER,
									IID_ICertRequest2,
									(void **)&pICertRequest))
		goto Ret;

    //Set the request store flag based on fMachine
    if(pAE_General_Info->fMachine)
    {
        if(S_OK != pIEnroll4->put_RequestStoreFlags(CERT_SYSTEM_STORE_LOCAL_MACHINE))
            goto Ret;
    }
    else
    {
        if(S_OK != pIEnroll4->put_RequestStoreFlags(CERT_SYSTEM_STORE_CURRENT_USER))
            goto Ret;
    }

    memset(&blobCAName, 0, sizeof(blobCAName));
    memset(&blobCALocation, 0, sizeof(blobCALocation));
    memset(&blobName, 0, sizeof(blobName));
    memset(&AETemplateInfo, 0, sizeof(AETemplateInfo));

    rgblobHash=(CRYPT_DATA_BLOB *)LocalAlloc(LPTR, dwMax * sizeof(CRYPT_DATA_BLOB));
    if(NULL==rgblobHash)
        goto Ret;

    memset(rgblobHash, 0, dwMax * sizeof(CRYPT_DATA_BLOB));

    //initialize the enumerator
    if(S_OK != pIEnroll4->enumPendingRequestWStr(XEPR_ENUM_FIRST, 0, NULL))
        goto Ret;

    //initlialize the variant
    VariantInit(&varCMC); 

    while(AEGetPendingRequestProperty(
                    pIEnroll4,
                    dwIndex,
                    XEPR_REQUESTID,
                    &dwRequestID))
    {

        //query the status of the requests to the CA
        if(!AEGetPendingRequestProperty(
                    pIEnroll4,
                    dwIndex,
                    XEPR_CANAME,
                    &blobCAName))
            goto Next;

        if(!AEGetPendingRequestProperty(
                    pIEnroll4,
                    dwIndex,
                    XEPR_CADNS,
                    &blobCALocation))
            goto Next;

        //build the config string
        pwszCAConfig=(LPWSTR)LocalAlloc(LPTR, 
            sizeof(WCHAR) * (wcslen((LPWSTR)(blobCALocation.pbData)) + wcslen((LPWSTR)(blobCAName.pbData)) + wcslen(L"\\") + 1));

        if(NULL==pwszCAConfig)
            goto Next;

        wcscpy(pwszCAConfig, (LPWSTR)(blobCALocation.pbData));
        wcscat(pwszCAConfig, L"\\");
        wcscat(pwszCAConfig, (LPWSTR)(blobCAName.pbData));

        //conver to bstr
        bstrConfig=SysAllocString(pwszCAConfig);
        if(NULL==bstrConfig)
            goto Next;

        //find the template information
        //get the version and the template name of the request
        if(AEGetPendingRequestProperty(pIEnroll4, dwIndex, XEPR_V2TEMPLATEOID, &blobName))
        {
            AETemplateInfo.pwszOid=(LPWSTR)blobName.pbData;
        }
        else
        {
            if(!AEGetPendingRequestProperty(pIEnroll4, dwIndex, XEPR_V1TEMPLATENAME, &blobName))
                goto Next;

            AETemplateInfo.pwszName=(LPWSTR)blobName.pbData;
        }

        //find the template
        if(NULL==(pCertType=AEFindTemplateInRequestTree(
                        &AETemplateInfo, pAE_General_Info)))
            goto Next;


        if(S_OK != pICertRequest->RetrievePending(
                            dwRequestID,
							bstrConfig,
							&dwDisposition))
            goto Next;

 	    switch(dwDisposition)
	    {
		    case CR_DISP_ISSUED:
				    if(S_OK != pICertRequest->GetFullResponseProperty(
                                            FR_PROP_FULLRESPONSE, 0, PROPTYPE_BINARY, CR_OUT_BINARY,
										    &varCMC))
                    {
                        goto Next;
                    }

                    // Check to make sure we've gotten a BSTR back: 
                    if (VT_BSTR != varCMC.vt) 
                    {
	                    goto Next; 
                    }

                    bstrCert = varCMC.bstrVal; 

                    // Marshal the cert into a CRYPT_DATA_BLOB:
				    blobPKCS7.cbData = (DWORD)SysStringByteLen(bstrCert);
				    blobPKCS7.pbData = (BYTE *)bstrCert;

                    // we will keep the PKCS7 blob for installation
                    if(CT_FLAG_USER_INTERACTION_REQUIRED & (pCertType->dwEnrollmentFlag))
                    {
                        //signal that we should pop up the UI balloon
                        (pAE_General_Info->dwUIPendCount)++;

                        //copy the PKCS7 blob from the cert server
                        AECopyPendingBlob(&blobPKCS7,
                                            pIEnroll4, 
                                            dwIndex, 
                                            pCertType);
                    }
                    else
                    {
   				        //install the certificate
                        if(S_OK != (hr = pIEnroll4->acceptResponseBlob(&blobPKCS7)))
						{
							AELogAutoEnrollmentEvent(
								pAE_General_Info->dwLogLevel,
								TRUE, 
								hr, 
								EVENT_PENDING_FAILED, 
								pAE_General_Info->fMachine, 
								pAE_General_Info->hToken, 
								1,
								pCertType->awszDisplay[0]);

                            goto Next;
						}

                        //mark the status to obtained if required
                        //this is a valid certificate
                        if(AEValidVersionCert(pCertType, pIEnroll4, &blobPKCS7))
                            pCertType->dwStatus = CERT_REQUEST_STATUS_OBTAINED;

                        //the certificate is successfully issued and installed
                        //remove the request from the request store
                        AERetrieveRequestProperty(pIEnroll4, dwIndex, &dwCount, &dwMax, &rgblobHash);
                    }

                    AELogAutoEnrollmentEvent(
                        pAE_General_Info->dwLogLevel,
                        FALSE, 
                        S_OK, 
                        EVENT_PENDING_ISSUED, 
                        pAE_General_Info->fMachine, 
                        pAE_General_Info->hToken, 
                        2,
                        pCertType->awszDisplay[0],
                        pwszCAConfig);
			    break;

		    case CR_DISP_UNDER_SUBMISSION:

                    AELogAutoEnrollmentEvent(
                        pAE_General_Info->dwLogLevel,
                        FALSE, 
                        S_OK, 
                        EVENT_PENDING_PEND, 
                        pAE_General_Info->fMachine, 
                        pAE_General_Info->hToken, 
                        2,
                        pCertType->awszDisplay[0],
                        pwszCAConfig);


			    break;

		    case CR_DISP_INCOMPLETE:
		    case CR_DISP_ERROR:   
		    case CR_DISP_DENIED:   
		    case CR_DISP_ISSUED_OUT_OF_BAND:	  //we consider it a failure in this case
		    case CR_DISP_REVOKED:
		    default:
                    //requests failed.  remove the request from the request store
                    AERetrieveRequestProperty(pIEnroll4, dwIndex, &dwCount, &dwMax, &rgblobHash);

					if(S_OK == pICertRequest->GetLastStatus(&hr))
					{
						AELogAutoEnrollmentEvent(
							pAE_General_Info->dwLogLevel,
							TRUE, 
							hr, 
							EVENT_PENDING_DENIED, 
							pAE_General_Info->fMachine, 
							pAE_General_Info->hToken,
							2,
							pwszCAConfig,
							pCertType->awszDisplay[0]);
					}

			    break;
	    }
   
Next:
        if(pwszCAConfig)
            LocalFree(pwszCAConfig);
        pwszCAConfig=NULL;

        if(bstrConfig)
            SysFreeString(bstrConfig);
        bstrConfig=NULL;

	    if(bstrCert)
		    SysFreeString(bstrCert);
        bstrCert=NULL;

        if(blobCAName.pbData)
            LocalFree(blobCAName.pbData);
        memset(&blobCAName, 0, sizeof(blobCAName));

        if(blobCALocation.pbData)
            LocalFree(blobCALocation.pbData);
        memset(&blobCALocation, 0, sizeof(blobCALocation));

        if(blobName.pbData)
            LocalFree(blobName.pbData);
        memset(&blobName, 0, sizeof(blobName));

        memset(&AETemplateInfo, 0, sizeof(AETemplateInfo));

        VariantInit(&varCMC); 

        dwIndex++;
    }

    //remove the requests based the hash
    AERemovePendingRequest(pIEnroll4, dwCount, rgblobHash);

Ret:

    AEFreePendingRequests(dwCount, rgblobHash);

    if(pICertRequest)
        pICertRequest->Release();

    if(pIEnroll4)
        pIEnroll4->Release();

    if(fInit)
        CoUninitialize();
    
    return TRUE;
}
   
//--------------------------------------------------------------------------
//
//  AEIsLocalSystem
//
//--------------------------------------------------------------------------

BOOL
AEIsLocalSystem(BOOL *pfIsLocalSystem)
{
    HANDLE                      hToken = 0;
    SID_IDENTIFIER_AUTHORITY    siaNtAuthority = SECURITY_NT_AUTHORITY;
    BOOL                        fRet = FALSE;
    BOOL                        fRevertToSelf = FALSE;

    PSID                        psidLocalSystem = NULL;

    *pfIsLocalSystem = FALSE;

    if (!OpenThreadToken(
                 GetCurrentThread(),
                 TOKEN_QUERY,
                 TRUE,
                 &hToken))
    {
        if (ERROR_NO_TOKEN != GetLastError())
            goto Ret;

        //we need to impersonateself and get the thread token again
        if(!ImpersonateSelf(SecurityImpersonation))
            goto Ret;

        fRevertToSelf = TRUE;

        if (!OpenThreadToken(
                     GetCurrentThread(),
                     TOKEN_QUERY,
                     TRUE,
                     &hToken))
            goto Ret;
    }

    //build the well known local system SID (s-1-5-18)
    if (!AllocateAndInitializeSid(
                    &siaNtAuthority,
                    1,
                    SECURITY_LOCAL_SYSTEM_RID,
                    0, 0, 0, 0, 0, 0, 0,
                    &psidLocalSystem
                    ))
        goto Ret;

    fRet = CheckTokenMembership(
                    hToken,
                    psidLocalSystem,
                    pfIsLocalSystem);

Ret:

    if(fRevertToSelf)
        RevertToSelf();

    if(psidLocalSystem)
        FreeSid(psidLocalSystem);

    if (hToken)
        CloseHandle(hToken);

    return fRet;
}


//--------------------------------------------------------------------------
//
//  AEInSafeBoot
//
//  copied from the service controller code
//--------------------------------------------------------------------------
BOOL WINAPI AEInSafeBoot()
{
    DWORD   dwSafeBoot = 0;
    DWORD   cbSafeBoot = sizeof(dwSafeBoot);
    DWORD   dwType = 0;

    HKEY    hKeySafeBoot = NULL;

    if(ERROR_SUCCESS == RegOpenKeyW(
                              HKEY_LOCAL_MACHINE,
                              L"system\\currentcontrolset\\control\\safeboot\\option",
                              &hKeySafeBoot))
    {
        // we did in fact boot under safeboot control
        if(ERROR_SUCCESS != RegQueryValueExW(
                                    hKeySafeBoot,
                                    L"OptionValue",
                                    NULL,
                                    &dwType,
                                    (LPBYTE)&dwSafeBoot,
                                    &cbSafeBoot))
        {
            dwSafeBoot = 0;
        }

        if(hKeySafeBoot)
            RegCloseKey(hKeySafeBoot);
    }

    return (0 != dwSafeBoot);
}


//--------------------------------------------------------------------------
//
//  AEIsDomainMember
//
//--------------------------------------------------------------------------
BOOL WINAPI AEIsDomainMember()
{
    DWORD dwErr;
    BOOL bIsDomainMember=FALSE;

    // must be cleaned up
    DSROLE_PRIMARY_DOMAIN_INFO_BASIC * pDomInfo=NULL;

    dwErr=DsRoleGetPrimaryDomainInformation(NULL, DsRolePrimaryDomainInfoBasic, (BYTE **)&pDomInfo);
    if (ERROR_SUCCESS==dwErr) {
        if (DsRole_RoleStandaloneWorkstation!=pDomInfo->MachineRole 
            && DsRole_RoleStandaloneServer!=pDomInfo->MachineRole) {
            bIsDomainMember=TRUE;
        }
    }

    if (NULL!=pDomInfo) {
        DsRoleFreeMemory(pDomInfo);
    }

    return bIsDomainMember;
}


//-----------------------------------------------------------------------
//
//  AEGetPolicyFlag
//
//-----------------------------------------------------------------------
BOOL    AEGetPolicyFlag(BOOL   fMachine, DWORD  *pdwPolicy)
{
    DWORD   dwPolicy = 0;
    DWORD   cbPolicy = sizeof(dwPolicy);
    DWORD   dwType = 0;

    HKEY    hKey = NULL;

    if(ERROR_SUCCESS ==  RegOpenKeyW(
                                fMachine ? HKEY_LOCAL_MACHINE : HKEY_CURRENT_USER,
                                AUTO_ENROLLMENT_KEY,
                                &hKey))
    {
        if(ERROR_SUCCESS != RegQueryValueExW(
                                    hKey,
                                    AUTO_ENROLLMENT_POLICY,
                                    NULL,
                                    &dwType,
                                    (LPBYTE)&dwPolicy,
                                    &cbPolicy))
	    {
            dwPolicy = 0;
        }

        if(hKey)
            RegCloseKey(hKey);

    }

    *pdwPolicy=dwPolicy;

    return TRUE;
}

//-----------------------------------------------------------------------
//
//  AERetrieveLogLevel
//
//-----------------------------------------------------------------------
BOOL AERetrieveLogLevel(BOOL    fMachine, DWORD *pdwLogLevel)
{
    DWORD   dwLogLevel = STATUS_SEVERITY_ERROR;   //we default to highest logging level
    DWORD   cbLogLevel = sizeof(dwLogLevel);
    DWORD   dwType = 0;

    HKEY    hKey = NULL;

    if(ERROR_SUCCESS ==  RegOpenKeyW(
                                fMachine ? HKEY_LOCAL_MACHINE : HKEY_CURRENT_USER,
                                AUTO_ENROLLMENT_EVENT_LEVEL_KEY,
                                &hKey))
    {
        if(ERROR_SUCCESS != RegQueryValueExW(
                                    hKey,
                                    AUTO_ENROLLMENT_EVENT_LEVEL,
                                    NULL,
                                    &dwType,
                                    (LPBYTE)&dwLogLevel,
                                    &cbLogLevel))
	    {
            dwLogLevel = STATUS_SEVERITY_ERROR;
        }

        if(hKey)
            RegCloseKey(hKey);

    }

    *pdwLogLevel=dwLogLevel;

    return TRUE;
}

//-----------------------------------------------------------------------
//
//  AERetrieveTemplateInfo
//
//-----------------------------------------------------------------------
BOOL    AERetrieveTemplateInfo(PCCERT_CONTEXT           pCertCurrent, 
                                AE_TEMPLATE_INFO        *pTemplateInfo)
{
    BOOL                fResult = FALSE;
    PCERT_EXTENSION     pExt = NULL;
    DWORD               cbData=0;

    CERT_NAME_VALUE     *pbName = NULL;
    CERT_TEMPLATE_EXT   *pbTemplate = NULL;

    if((NULL==pCertCurrent) || (NULL==pTemplateInfo))
        goto Ret;

    memset(pTemplateInfo, 0, sizeof(AE_TEMPLATE_INFO));

    //try to find V2 template extension first
    if(pExt = CertFindExtension(szOID_CERTIFICATE_TEMPLATE,
                                pCertCurrent->pCertInfo->cExtension,
                                pCertCurrent->pCertInfo->rgExtension))
    {
        if(!CryptDecodeObject(X509_ASN_ENCODING,
                              szOID_CERTIFICATE_TEMPLATE,
                              pExt->Value.pbData,
                              pExt->Value.cbData,
                              0,
                              NULL,
                              &cbData))
            goto Ret;

        pbTemplate = (CERT_TEMPLATE_EXT *)LocalAlloc(LPTR, cbData);

        if(NULL==pbTemplate)
            goto Ret;

        if(!CryptDecodeObject(X509_ASN_ENCODING,
                              szOID_CERTIFICATE_TEMPLATE,
                              pExt->Value.pbData,
                              pExt->Value.cbData,
                              0,
                              pbTemplate,
                              &cbData))
            goto Ret;

        //copy the version
        pTemplateInfo->dwVersion=pbTemplate->dwMajorVersion;

        //copy the extension oid
        if(NULL==pbTemplate->pszObjId)
            goto Ret;

        if(0 == (cbData = MultiByteToWideChar(CP_ACP, 
                                  0,
                                  pbTemplate->pszObjId,
                                  -1,
                                  NULL,
                                  0)))
            goto Ret;

        if(NULL==(pTemplateInfo->pwszOid=(LPWSTR)LocalAlloc(LPTR, cbData * sizeof(WCHAR))))
            goto Ret;

        if(0 == MultiByteToWideChar(CP_ACP, 
                                  0,
                                  pbTemplate->pszObjId,
                                  -1,
                                  pTemplateInfo->pwszOid,
                                  cbData))
            goto Ret;

    }
    else
    {

        //try V1 template extension
        if(NULL == (pExt = CertFindExtension(
                                    szOID_ENROLL_CERTTYPE_EXTENSION,
                                    pCertCurrent->pCertInfo->cExtension,
                                    pCertCurrent->pCertInfo->rgExtension)))
            goto Ret;

        if(!CryptDecodeObject(X509_ASN_ENCODING,
                              X509_UNICODE_ANY_STRING,
                              pExt->Value.pbData,
                              pExt->Value.cbData,
                              0,
                              NULL,
                              &cbData))
            goto Ret;

        pbName = (CERT_NAME_VALUE *)LocalAlloc(LPTR, cbData);

        if(NULL==pbName)
            goto Ret;

        if(!CryptDecodeObject(X509_ASN_ENCODING,
                              X509_UNICODE_ANY_STRING,
                              pExt->Value.pbData,
                              pExt->Value.cbData,
                              0,
                              pbName,
                              &cbData))
            goto Ret;

        if(!AEAllocAndCopy((LPWSTR)(pbName->Value.pbData),
                            &(pTemplateInfo->pwszName)))
            goto Ret;
    }


    fResult = TRUE;

Ret:

    if(pbTemplate)
        LocalFree(pbTemplate);

    if(pbName)
        LocalFree(pbName);

    return fResult;
}

//-----------------------------------------------------------------------
//
//  AEFreeTemplateInfo
//
//-----------------------------------------------------------------------
BOOL    AEFreeTemplateInfo(AE_TEMPLATE_INFO *pAETemplateInfo)
{
    if(pAETemplateInfo->pwszName)
        LocalFree(pAETemplateInfo->pwszName);

    if(pAETemplateInfo->pwszOid)
        LocalFree(pAETemplateInfo->pwszOid);

    memset(pAETemplateInfo, 0, sizeof(AE_TEMPLATE_INFO));

    return TRUE;
}

//-----------------------------------------------------------------------
//
//  AEFindTemplateInRequestTree
//
//-----------------------------------------------------------------------
AE_CERTTYPE_INFO *AEFindTemplateInRequestTree(AE_TEMPLATE_INFO  *pTemplateInfo,
                                              AE_GENERAL_INFO   *pAE_General_Info)
{
    DWORD               dwIndex = 0;
    AE_CERTTYPE_INFO    *rgCertTypeInfo=NULL;
    AE_CERTTYPE_INFO    *pCertType=NULL;
    
    if(NULL == (rgCertTypeInfo=pAE_General_Info->rgCertTypeInfo))
        return NULL;

    if( (NULL == pTemplateInfo->pwszName) && (NULL == pTemplateInfo->pwszOid))
        return NULL;

    for(dwIndex=0; dwIndex < pAE_General_Info->dwCertType; dwIndex++)
    {
        if(pTemplateInfo->pwszOid)
        {
            //we are guaranteed to have an OID if the schema is greater than or equal to 2
            if(rgCertTypeInfo[dwIndex].dwSchemaVersion >= CERTTYPE_SCHEMA_VERSION_2)
            {
                if(0 == wcscmp(pTemplateInfo->pwszOid, (rgCertTypeInfo[dwIndex].awszOID)[0]))
                {
                    pCertType = &(rgCertTypeInfo[dwIndex]);
                    break;
                }
            }
        }
        else
        {
            //we are guaranteed to have a name
            if(0 == wcscmp(pTemplateInfo->pwszName, (rgCertTypeInfo[dwIndex].awszName)[0]))
            {
                pCertType = &(rgCertTypeInfo[dwIndex]);
                break;
            }
        }
    }

    return pCertType;
}

//-----------------------------------------------------------------------
//
//  AEIsLogonDCCertificate
//
//
//-----------------------------------------------------------------------
BOOL AEIsLogonDCCertificate(PCCERT_CONTEXT pCertContext)
{
    BOOL                fDCCert=FALSE;
    PCERT_EXTENSION     pExt = NULL;
    DWORD               cbData = 0;
    DWORD               dwIndex = 0;
    BOOL                fFound = FALSE;

    CERT_ENHKEY_USAGE   *pbKeyUsage=NULL;
    AE_TEMPLATE_INFO    AETemplateInfo;

    memset(&AETemplateInfo, 0, sizeof(AE_TEMPLATE_INFO));


    if(NULL==pCertContext)
        return FALSE;


    if(!AERetrieveTemplateInfo(pCertContext, &AETemplateInfo))
        goto Ret;
                      

    if(AETemplateInfo.pwszName)
    {
        //this is a V1 template.  Search for the hard coded DC template name
        if(0 == _wcsicmp(wszCERTTYPE_DC, AETemplateInfo.pwszName))
            fDCCert=TRUE;
    }
    else
    {
        //this is a V2 template.  Search for the smart card logon OID
        if(NULL==(pExt=CertFindExtension(szOID_ENHANCED_KEY_USAGE,
                                    pCertContext->pCertInfo->cExtension,
                                    pCertContext->pCertInfo->rgExtension)))
            goto Ret;

        if(!CryptDecodeObject(X509_ASN_ENCODING,
                              szOID_ENHANCED_KEY_USAGE,
                              pExt->Value.pbData,
                              pExt->Value.cbData,
                              0,
                              NULL,
                              &cbData))
            goto Ret;

        pbKeyUsage=(CERT_ENHKEY_USAGE *)LocalAlloc(LPTR, cbData);
        if(NULL==pbKeyUsage)
            goto Ret;

        if(!CryptDecodeObject(X509_ASN_ENCODING,
                              szOID_ENHANCED_KEY_USAGE,
                              pExt->Value.pbData,
                              pExt->Value.cbData,
                              0,
                              pbKeyUsage,
                              &cbData))
            goto Ret;

        for(dwIndex=0; dwIndex < pbKeyUsage->cUsageIdentifier; dwIndex++)
        {
            if(0==_stricmp(szOID_KP_SMARTCARD_LOGON,(pbKeyUsage->rgpszUsageIdentifier)[dwIndex]))
            {
                fDCCert=TRUE;
                break;
            }
        }
    }


Ret:

    if(pbKeyUsage)
        LocalFree(pbKeyUsage);

    AEFreeTemplateInfo(&AETemplateInfo);

    return fDCCert;

}
//-----------------------------------------------------------------------
//
//  AEValidateCertificateInfo
//
//      This function verifies if the certificate needs to be renewed or 
//  re-enrolled based on:
//  
//      1. Presence of the private key
//      2. Chaining of the certificate
//      3. If the certificate is close to expiration
//
//-----------------------------------------------------------------------
BOOL    AEValidateCertificateInfo(AE_GENERAL_INFO   *pAE_General_Info,
                                  AE_CERTTYPE_INFO  *pCertType,
                                  BOOL              fCheckForPrivateKey,
                                  PCCERT_CONTEXT    pCertCurrent, 
                                  AE_CERT_INFO      *pAECertInfo)
{
    BOOL                        fResult = TRUE;
    DWORD                       cbData = 0;
    CERT_CHAIN_PARA             ChainParams;
    CERT_CHAIN_POLICY_PARA      ChainPolicy;
    CERT_CHAIN_POLICY_STATUS    PolicyStatus;
    LARGE_INTEGER               ftTime;
    HRESULT                     hrChainStatus = S_OK;
    LARGE_INTEGER               ftHalfLife;

    PCCERT_CHAIN_CONTEXT        pChainContext = NULL;

    if((NULL==pCertCurrent) || (NULL==pAECertInfo)  || (NULL==pAE_General_Info))
    {
        SetLastError(E_INVALIDARG);
        fResult = FALSE;
        goto Ret;
    }

    //assume the certificate is bad
    pAECertInfo->fValid = FALSE;
    pAECertInfo->fRenewal = FALSE;

    //////////////////////////////////////////////////
    //
    //check for the private key information
    //
    //////////////////////////////////////////////////
    if(fCheckForPrivateKey)
    {
        if(!CertGetCertificateContextProperty(
                pCertCurrent,
                CERT_KEY_PROV_INFO_PROP_ID,
                NULL,
                &cbData))
            goto Ret;
    }

    /////////////////////////////////////////////////////////
    //
    //check for chaining, revoke status and expiration of the certificate
    //
    /////////////////////////////////////////////////////////

    memset(&ChainParams, 0, sizeof(ChainParams));
    ChainParams.cbSize = sizeof(ChainParams);
    ChainParams.RequestedUsage.dwType = USAGE_MATCH_TYPE_AND;

    ChainParams.RequestedUsage.Usage.cUsageIdentifier = 0;
    ChainParams.RequestedUsage.Usage.rgpszUsageIdentifier = NULL;

    // Build a small time skew into the chain building in order to deal
    // with servers that may skew slightly fast.
    GetSystemTimeAsFileTime((LPFILETIME)&ftTime);
    ftTime.QuadPart += Int32x32To64(FILETIME_TICKS_PER_SECOND, AE_DEFAULT_SKEW);

    // Build a cert chain for the current status of the cert..
    if(!CertGetCertificateChain(pAE_General_Info->fMachine?HCCE_LOCAL_MACHINE:HCCE_CURRENT_USER,
                                pCertCurrent,
                                (LPFILETIME)&ftTime,
                                NULL,
                                &ChainParams,
                                CERT_CHAIN_REVOCATION_CHECK_CHAIN,
                                NULL,
                                &pChainContext))
    {
        AE_DEBUG((AE_WARNING, L"Could not build certificate chain (%lx)\n\r", GetLastError()));
        goto Ret;
    }
    
    //validate the certificate chain

    //special case for domain controller certificate.
    //it should not have any revocation error, even for status unknown case

    //check against the base policy
    memset(&ChainPolicy, 0, sizeof(ChainPolicy));
    ChainPolicy.cbSize = sizeof(ChainPolicy);
    ChainPolicy.dwFlags = 0;  // ignore nothing
    ChainPolicy.pvExtraPolicyPara = NULL;

    memset(&PolicyStatus, 0, sizeof(PolicyStatus));
    PolicyStatus.cbSize = sizeof(PolicyStatus);
    PolicyStatus.dwError = 0;
    PolicyStatus.lChainIndex = -1;
    PolicyStatus.lElementIndex = -1;
    PolicyStatus.pvExtraPolicyStatus = NULL;

    if(!CertVerifyCertificateChainPolicy(CERT_CHAIN_POLICY_BASE,
                                          pChainContext,
                                          &ChainPolicy,
                                          &PolicyStatus))
    {
        AE_DEBUG((AE_WARNING, L"Base Chain Policy failed (%lx) - must get new cert\n\r", GetLastError()));
        goto Ret;
    }

    hrChainStatus = PolicyStatus.dwError;

    if((S_OK ==  hrChainStatus) ||
       (CRYPT_E_NO_REVOCATION_CHECK ==  hrChainStatus) ||
       (CRYPT_E_REVOCATION_OFFLINE ==  hrChainStatus))
    {
        // The cert is still currently acceptable by trust standards, so we can renew it
        pAECertInfo->fRenewal = TRUE;
    }
    else
    {
        goto Ret;
    }

    if(pChainContext)
    {
        CertFreeCertificateChain(pChainContext);
        pChainContext = NULL;
    }

    /////////////////////////////////////////////////////////////////////
    //
    // Check if the certificate is close to expire
    //
    ///////////////////////////////////////////////////////////////////////
    if(NULL==pCertType)
        goto Ret;

    // Nudge the evaluation of the cert chain by the expiration
    // offset so we know if is expired by that time in the future.
    GetSystemTimeAsFileTime((LPFILETIME)&ftTime);

    // Build the certificate chain for trust operations
    memset(&ChainParams, 0, sizeof(ChainParams));
    ChainParams.cbSize = sizeof(ChainParams);
    ChainParams.RequestedUsage.dwType = USAGE_MATCH_TYPE_AND;

    ChainParams.RequestedUsage.Usage.cUsageIdentifier = 0;
    ChainParams.RequestedUsage.Usage.rgpszUsageIdentifier = NULL;

    //get the half lifetime of the certificate
    ftHalfLife.QuadPart = (((LARGE_INTEGER UNALIGNED *)&(pCertCurrent->pCertInfo->NotAfter))->QuadPart - 
                               ((LARGE_INTEGER UNALIGNED *)&(pCertCurrent->pCertInfo->NotBefore))->QuadPart)/2;

    //check if the old cert is time nesting invalid
    if(ftHalfLife.QuadPart < 0)
        goto Ret;

    //check if the offset was specified in a relative value
    if(pCertType->ftExpirationOffset.QuadPart < 0)
    {
        if(ftHalfLife.QuadPart > (- pCertType->ftExpirationOffset.QuadPart))
        {
            ftTime.QuadPart -= pCertType->ftExpirationOffset.QuadPart;
        }
        else
        {
            ftTime.QuadPart += ftHalfLife.QuadPart;
        }
    }
    else
    {
        //the offset was specified in an absolute value
        if(0 < pCertType->ftExpirationOffset.QuadPart) 
            ftTime = pCertType->ftExpirationOffset;
        else
            //use the half time mark if the offset is 0
            ftTime.QuadPart += ftHalfLife.QuadPart;
    }

    //check the certificate chain at a future time
    if(!CertGetCertificateChain(pAE_General_Info->fMachine?HCCE_LOCAL_MACHINE:HCCE_CURRENT_USER,
                                    pCertCurrent,
                                    (LPFILETIME)&ftTime,
                                    NULL,               //no additional store
                                    &ChainParams,
                                    0,                  //no revocation check
                                    NULL,               //Reserved
                                    &pChainContext))
    {
        AE_DEBUG((AE_WARNING, L"Could not build certificate chain (%lx)\n\r", GetLastError()));
        goto Ret;
    }

    // Verify expiration of the certificate
    memset(&ChainPolicy, 0, sizeof(ChainPolicy));
    ChainPolicy.cbSize = sizeof(ChainPolicy);
    ChainPolicy.dwFlags = 0;  // ignore nothing
    ChainPolicy.pvExtraPolicyPara = NULL;

    memset(&PolicyStatus, 0, sizeof(PolicyStatus));
    PolicyStatus.cbSize = sizeof(PolicyStatus);
    PolicyStatus.dwError = 0;
    PolicyStatus.lChainIndex = -1;
    PolicyStatus.lElementIndex = -1;
    PolicyStatus.pvExtraPolicyStatus = NULL;

    if(!CertVerifyCertificateChainPolicy(CERT_CHAIN_POLICY_BASE,
                                          pChainContext,
                                          &ChainPolicy,
                                          &PolicyStatus))
    {
        AE_DEBUG((AE_WARNING, L"Base Chain Policy failed (%lx) - must get new cert\n\r", GetLastError()));
        goto Ret;
    }

    hrChainStatus = PolicyStatus.dwError;

    if((S_OK != hrChainStatus) &&
       (CRYPT_E_NO_REVOCATION_CHECK != hrChainStatus) &&
       (CRYPT_E_REVOCATION_OFFLINE != hrChainStatus))
    {
        // The cert is close to expire. we must re-renewal
        goto Ret;
    }

    //the certificate is good
    pAECertInfo->fValid = TRUE;

    fResult = TRUE;

Ret:
    if(pChainContext)
        CertFreeCertificateChain(pChainContext);

    return fResult;
}

//-----------------------------------------------------------------------
//
//  AESameOID
//
//      Check if the two OIDs are the same
//-----------------------------------------------------------------------
BOOL AESameOID(LPWSTR pwszOID, LPSTR pszOID)
{
    DWORD   cbChar=0;
    BOOL    fSame=FALSE;

    LPSTR   pszNewOID=NULL;

    if((NULL==pwszOID) || (NULL==pszOID))
        return FALSE;

    cbChar= WideCharToMultiByte(
                CP_ACP,                // codepage
                0,                      // dwFlags
                pwszOID,
                -1,
                NULL,
                0,
                NULL,
                NULL);

    if(0 == cbChar)
        goto Ret;

    if(NULL==(pszNewOID=(LPSTR)LocalAlloc(LPTR, cbChar)))
        goto Ret;

    cbChar= WideCharToMultiByte(
                CP_ACP,                // codepage
                0,                      // dwFlags
                pwszOID,
                -1,
                pszNewOID,
                cbChar,
                NULL,
                NULL);

    if(0 == cbChar)
        goto Ret;


    if(0 == _stricmp(pszNewOID, pszOID))
        fSame=TRUE;

Ret:

    if(pszNewOID)
        LocalFree(pszNewOID);

    return fSame;
}


//-----------------------------------------------------------------------
//
//  AEValidRAPolicyWithProperty
//
//      Check if the certificate matches the RA signature requirement
//  of the certificate type
//-----------------------------------------------------------------------
BOOL    AEValidRAPolicyWithProperty(PCCERT_CONTEXT pCertContext, 
                                    LPWSTR          *rgwszPolicy,
                                    LPWSTR          *rgwszAppPolicy)
{
    PCERT_EXTENSION     pExt = NULL;
    DWORD               cbData = 0;
    DWORD               dwIndex = 0;
    DWORD               dwFindIndex=0;
    BOOL                fFound = FALSE;
    BOOL                fValid = FALSE;

    CERT_ENHKEY_USAGE   *pbKeyUsage=NULL;
    CERT_POLICIES_INFO  *pbAppPolicy=NULL;
    CERT_POLICIES_INFO  *pbPolicy=NULL;

    //find the EKUs
    if(pExt=CertFindExtension(szOID_ENHANCED_KEY_USAGE,
                                pCertContext->pCertInfo->cExtension,
                                pCertContext->pCertInfo->rgExtension))
    {
        cbData=0;
        if(!CryptDecodeObject(X509_ASN_ENCODING,
                          szOID_ENHANCED_KEY_USAGE,
                          pExt->Value.pbData,
                          pExt->Value.cbData,
                          0,
                          NULL,
                          &cbData))
        goto Ret;

        pbKeyUsage=(CERT_ENHKEY_USAGE *)LocalAlloc(LPTR, cbData);
        if(NULL==pbKeyUsage)
            goto Ret;

        if(!CryptDecodeObject(X509_ASN_ENCODING,
                              szOID_ENHANCED_KEY_USAGE,
                              pExt->Value.pbData,
                              pExt->Value.cbData,
                              0,
                              pbKeyUsage,
                              &cbData))
            goto Ret;
    }

    //get the cert issurance policy
    if(pExt=CertFindExtension(szOID_CERT_POLICIES,
                                pCertContext->pCertInfo->cExtension,
                                pCertContext->pCertInfo->rgExtension))
    {
        cbData=0;
        if(!CryptDecodeObject(X509_ASN_ENCODING,
                          szOID_CERT_POLICIES,
                          pExt->Value.pbData,
                          pExt->Value.cbData,
                          0,
                          NULL,
                          &cbData))
        goto Ret;

        pbPolicy=(CERT_POLICIES_INFO *)LocalAlloc(LPTR, cbData);
        if(NULL==pbPolicy)
            goto Ret;

        if(!CryptDecodeObject(X509_ASN_ENCODING,
                              szOID_CERT_POLICIES,
                              pExt->Value.pbData,
                              pExt->Value.cbData,
                              0,
                              pbPolicy,
                              &cbData))
            goto Ret;
    }
   
    
    //get the cert application policy
    if(pExt=CertFindExtension(szOID_APPLICATION_CERT_POLICIES,
                                pCertContext->pCertInfo->cExtension,
                                pCertContext->pCertInfo->rgExtension))
    {
        cbData=0;
        if(!CryptDecodeObject(X509_ASN_ENCODING,
                          szOID_CERT_POLICIES,
                          pExt->Value.pbData,
                          pExt->Value.cbData,
                          0,
                          NULL,
                          &cbData))
        goto Ret;

        pbAppPolicy=(CERT_POLICIES_INFO *)LocalAlloc(LPTR, cbData);
        if(NULL==pbAppPolicy)
            goto Ret;

        if(!CryptDecodeObject(X509_ASN_ENCODING,
                              szOID_CERT_POLICIES,
                              pExt->Value.pbData,
                              pExt->Value.cbData,
                              0,
                              pbAppPolicy,
                              &cbData))
            goto Ret;
    }
    

    if(rgwszPolicy)
    {
        if(rgwszPolicy[0])
        {
            if(NULL==pbPolicy)
                goto Ret;

            dwIndex=0;
            while(rgwszPolicy[dwIndex])
            {
                fFound=FALSE;

                for(dwFindIndex=0; dwFindIndex < pbPolicy->cPolicyInfo; dwFindIndex++)
                {
                    if(AESameOID(rgwszPolicy[dwIndex], (pbPolicy->rgPolicyInfo)[dwFindIndex].pszPolicyIdentifier))
                    {
                        fFound=TRUE;
                        break;
                    }
                }

                if(FALSE == fFound)
                    goto Ret;

                dwIndex++;
            }
        }
    }

    if(rgwszAppPolicy)
    {
        if(rgwszAppPolicy[0])
        {
            if((NULL==pbAppPolicy) && (NULL==pbKeyUsage))
                goto Ret;

            dwIndex=0;
            while(rgwszAppPolicy[dwIndex])
            {
                fFound=FALSE;

                if(pbAppPolicy)
                {
                    for(dwFindIndex=0; dwFindIndex < pbAppPolicy->cPolicyInfo; dwFindIndex++)
                    {
                        if(AESameOID(rgwszAppPolicy[dwIndex], (pbAppPolicy->rgPolicyInfo)[dwFindIndex].pszPolicyIdentifier))
                        {
                            fFound=TRUE;
                            break;
                        }
                    }
                }

                if((FALSE == fFound) && (pbKeyUsage))
                {
                    for(dwFindIndex=0; dwFindIndex < pbKeyUsage->cUsageIdentifier; dwFindIndex++)
                    {
                        if(AESameOID(rgwszAppPolicy[dwIndex],(pbKeyUsage->rgpszUsageIdentifier)[dwFindIndex]))
                        {
                            fFound=TRUE;
                            break;
                        }
                    }
                }

                if(FALSE == fFound)
                    goto Ret;

                dwIndex++;
            }
        }
    }

    fValid=TRUE;

Ret:
    if(pbKeyUsage)
        LocalFree(pbKeyUsage);

    if(pbPolicy)
        LocalFree(pbPolicy);

    if(pbAppPolicy)
        LocalFree(pbAppPolicy);

    return fValid;
}


//-----------------------------------------------------------------------
//
//  AEValidRAPolicy
//
//      Check if the certificate matches the RA signature requirement
//  of the certificate type
//-----------------------------------------------------------------------
BOOL    AEValidRAPolicy(PCCERT_CONTEXT pCertContext, AE_CERTTYPE_INFO *pCertType)
{
    BOOL                fValid=FALSE;

    LPWSTR              *rgwszPolicy=NULL;
    LPWSTR              *rgwszAppPolicy=NULL;

    if((NULL==pCertType) || (NULL==pCertContext))
        return FALSE;

    //get the certificate type properties
    CAGetCertTypePropertyEx(pCertType->hCertType,
                            CERTTYPE_PROP_RA_POLICY,
                            &rgwszPolicy);


    CAGetCertTypePropertyEx(pCertType->hCertType,
                            CERTTYPE_PROP_RA_APPLICATION_POLICY,
                            &rgwszAppPolicy);

    fValid = AEValidRAPolicyWithProperty(pCertContext, rgwszPolicy, rgwszAppPolicy);


    if(rgwszPolicy)
        CAFreeCertTypeProperty(pCertType->hCertType, rgwszPolicy);

    if(rgwszAppPolicy)
        CAFreeCertTypeProperty(pCertType->hCertType, rgwszAppPolicy);

    return fValid;

}

//-----------------------------------------------------------------------
//
//  AESomeCSPSupported
//
//-----------------------------------------------------------------------
BOOL    AESomeCSPSupported(HCERTTYPE     hCertType)
{
    BOOL            fResult=FALSE;
    DWORD           dwIndex=0;
    DWORD           dwCSPIndex=0;
    DWORD           dwProviderType=0;
    DWORD           cbSize=0;

    LPWSTR          *awszCSP=NULL;
    LPWSTR          pwszProviderName=NULL;
    HCRYPTPROV      hProv=NULL;


    if(NULL==hCertType)
        goto Ret;

    //no CSPs means all CSPs are fine
    if((S_OK != CAGetCertTypePropertyEx(
                    hCertType,
                    CERTTYPE_PROP_CSP_LIST,
                    &awszCSP)) || (NULL == awszCSP))
    {
        fResult=TRUE;
        goto Ret;
    }

    //no CSP means all CSPs are fine
    if(NULL == awszCSP[0])
    {
        fResult=TRUE;
        goto Ret;
    }

    for(dwIndex=0; NULL != awszCSP[dwIndex]; dwIndex++)
    {
        for (dwCSPIndex = 0; 
	        CryptEnumProvidersW(dwCSPIndex, 0, 0, &dwProviderType, NULL, &cbSize);
	        dwCSPIndex++)
        {	
	        pwszProviderName = (LPWSTR)LocalAlloc(LPTR, cbSize);

	        if(NULL == pwszProviderName)
	            goto Ret;
	    
	        //get the provider name and type
	        if(!CryptEnumProvidersW(dwCSPIndex,
	            0,
	            0,
	            &dwProviderType,
	            pwszProviderName,
	            &cbSize))
	            goto Ret; 

            if(0 == _wcsicmp(pwszProviderName, awszCSP[dwIndex]))
            {
                //find the CSP.  See if it is present in the box
                if(CryptAcquireContextW(
                            &hProv,
                            NULL,
                            awszCSP[dwIndex],
                            dwProviderType,
                            CRYPT_VERIFYCONTEXT | CRYPT_SILENT))
                {

                    CryptReleaseContext(hProv, 0);
                    hProv=NULL;

                    fResult=TRUE;
                    break;
                }
            }

            //keep the CSP enumeration
            if(pwszProviderName)
                LocalFree(pwszProviderName);

            pwszProviderName=NULL;
            cbSize=0;
            dwProviderType=0;
        }

        //detect if a valid CSP if found
        if(TRUE == fResult)
        {
            break;
        }

        cbSize=0;
        dwProviderType=0;
    }

Ret:
    if(pwszProviderName)
        LocalFree(pwszProviderName);

    if(hProv)
        CryptReleaseContext(hProv, 0);

    if(awszCSP)
        CAFreeCertTypeProperty(hCertType, awszCSP);

    return fResult;

}


//-----------------------------------------------------------------------
//
//  AESmartcardOnlyTemplate
//
//-----------------------------------------------------------------------
BOOL    AESmartcardOnlyTemplate(HCERTTYPE   hCertType)
{
    BOOL            fResult=FALSE;
    DWORD           dwIndex=0;
    DWORD           dwImpType=0;
    DWORD           cbData=0;
    DWORD           dwSCCount=0;

    LPWSTR          *awszCSP=NULL;
    HCRYPTPROV      hProv = NULL;

    if(NULL==hCertType)
        goto Ret;

    if(S_OK != CAGetCertTypePropertyEx(
                    hCertType,
                    CERTTYPE_PROP_CSP_LIST,
                    &awszCSP))
        goto Ret;

    if(NULL==awszCSP)
        goto Ret;

    for(dwIndex=0; NULL != awszCSP[dwIndex]; dwIndex++)
    {
        dwImpType=0;

        //all smart card CSPs are RSA_FULL. 
        if(CryptAcquireContextW(
                    &hProv,
                    NULL,
                    awszCSP[dwIndex],
                    PROV_RSA_FULL,
                    CRYPT_VERIFYCONTEXT | CRYPT_SILENT))
        {

            cbData = sizeof(dwImpType);
         
            if(CryptGetProvParam(hProv,
                    PP_IMPTYPE,
                    (BYTE *)(&dwImpType),
                    &cbData,
                    0))
            {
                if((CRYPT_IMPL_REMOVABLE & dwImpType) && (CRYPT_IMPL_MIXED & dwImpType))
                    dwSCCount++;
            }

            CryptReleaseContext(hProv, 0);
            hProv=NULL;
        }
    }

    //smart card CSP only if all CSPs are for smart card only
    if((0 != dwIndex) && (dwIndex==dwSCCount))
        fResult=TRUE;

Ret:
    if(hProv)
        CryptReleaseContext(hProv, 0);

    if(awszCSP)
        CAFreeCertTypeProperty(hCertType, awszCSP);

    return fResult;
}

//-----------------------------------------------------------------------
//
//  AEUserProtectionForTemplate
//
//-----------------------------------------------------------------------
BOOL   AEUserProtectionForTemplate(AE_GENERAL_INFO *pAE_General_Info, PCERT_CONTEXT pCertContext)
{
    BOOL                fUserProtection=FALSE;
    AE_CERTTYPE_INFO    *pCertType=NULL;

    AE_TEMPLATE_INFO    AETemplateInfo;


    memset(&AETemplateInfo, 0, sizeof(AE_TEMPLATE_INFO));

    if((NULL == pAE_General_Info) || (NULL == pCertContext))
        goto Ret;

    //get the template information for the certificate
    if(!AERetrieveTemplateInfo(pCertContext, &AETemplateInfo))
        goto Ret;

    pCertType=AEFindTemplateInRequestTree(&AETemplateInfo, pAE_General_Info);

    if(NULL==pCertType)
        goto Ret;

    if(CT_FLAG_STRONG_KEY_PROTECTION_REQUIRED & (pCertType->dwPrivateKeyFlag))
        fUserProtection=TRUE;

Ret:

    AEFreeTemplateInfo(&AETemplateInfo);

    return fUserProtection;
}

//-----------------------------------------------------------------------
//
//  AEUISetForTemplate
//
//-----------------------------------------------------------------------
BOOL    AEUISetForTemplate(AE_GENERAL_INFO *pAE_General_Info, PCERT_CONTEXT pCertContext)
{
    BOOL                fUI=FALSE;
    AE_CERTTYPE_INFO    *pCertType=NULL;

    AE_TEMPLATE_INFO    AETemplateInfo;


    memset(&AETemplateInfo, 0, sizeof(AE_TEMPLATE_INFO));

    if((NULL == pAE_General_Info) || (NULL == pCertContext))
        goto Ret;

    //get the template information for the certificate
    if(!AERetrieveTemplateInfo(pCertContext, &AETemplateInfo))
        goto Ret;

    pCertType=AEFindTemplateInRequestTree(&AETemplateInfo, pAE_General_Info);

    if(NULL==pCertType)
        goto Ret;

    if(CT_FLAG_USER_INTERACTION_REQUIRED & (pCertType->dwEnrollmentFlag))
        fUI=TRUE;

Ret:

    AEFreeTemplateInfo(&AETemplateInfo);

    return fUI;
}

//-----------------------------------------------------------------------
//
//  AECanEnrollCertType
//
//-----------------------------------------------------------------------
BOOL    AECanEnrollCertType(HANDLE  hToken, AE_CERTTYPE_INFO *pCertType, AE_GENERAL_INFO *pAE_General_Info, BOOL *pfUserProtection)
{
    DWORD               dwValue = 0;
    PCCERT_CONTEXT      pCertCurrent=NULL;
    AE_CERT_INFO        AECertInfo;

    memset(&AECertInfo, 0, sizeof(AE_CERT_INFO));

	*pfUserProtection=FALSE;

    //check enrollment ACL
    if(S_OK != CACertTypeAccessCheckEx(
                        pCertType->hCertType,
                        hToken,
                        CERTTYPE_ACCESS_CHECK_ENROLL | CERTTYPE_ACCESS_CHECK_NO_MAPPING))
        return FALSE;


    //check the subject requirements
    if(S_OK != CAGetCertTypeFlagsEx(
                        pCertType->hCertType,
                        CERTTYPE_SUBJECT_NAME_FLAG,
                        &dwValue))
        return FALSE;

    if((CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT & dwValue) || 
       (CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT_ALT_NAME & dwValue))
        return FALSE;

    //check if we are doing smart card CSPs and there is no reader installed
    if(FALSE == (pAE_General_Info->fSmartcardSystem))
    {
        if(AESmartcardOnlyTemplate(pCertType->hCertType))
            return FALSE;
    }

    //check if all CSPs on the template is not supported 
    {
        if(!AESomeCSPSupported(pCertType->hCertType))
            return FALSE;
    }


    //we might not get the RA property for V1 template
    dwValue = 0;

    //check the RA support
    if(S_OK != CAGetCertTypePropertyEx(
                pCertType->hCertType,
                CERTTYPE_PROP_RA_SIGNATURE,
                &dwValue))
        return TRUE;

    if(0==dwValue)
        return TRUE;

    //self-template RA
    if((CT_FLAG_PREVIOUS_APPROVAL_VALIDATE_REENROLLMENT & (pCertType->dwEnrollmentFlag)) &&
        ((pCertType->fRenewal) && (pCertType->pOldCert))
       )
    {
        //the request has to be RAed
        pCertType->fNeedRA=TRUE;
        return TRUE;
    }

    //autoenrollment only deal with one RA signature.  
    //it is sufficient for autoenrollment RA scenarios
    if(1!=dwValue)
        return FALSE;

    //the certificate template requires one and only one RA signature

    //cross-template RA
    //enumerate all certificate in store
    while(pCertCurrent = CertEnumCertificatesInStore(pAE_General_Info->hMyStore, pCertCurrent))
    {
        //check if we need to enroll/renewal for the certificate
        AEValidateCertificateInfo(pAE_General_Info, 
                                NULL,
                                TRUE,               //valid private key
                                pCertCurrent, 
                                &AECertInfo);

        //the certificate is good enough for RA signature purpose
        if(AECertInfo.fRenewal)
        {
            if(AEValidRAPolicy(pCertCurrent, pCertType))
            {
				if(AEUserProtectionForTemplate(pAE_General_Info, (PCERT_CONTEXT)pCertCurrent))
				{
					if(pAE_General_Info->fMachine)
					{
						*pfUserProtection=TRUE;
						continue;
					}
					else
					{
						if(0==(CT_FLAG_USER_INTERACTION_REQUIRED & (pCertType->dwEnrollmentFlag)))
						{
							*pfUserProtection=TRUE;
							continue;
						}
					}
				}

                pCertType->fRenewal=TRUE;

                if(pCertType->pOldCert)
                {
                    CertFreeCertificateContext(pCertType->pOldCert);
                    pCertType->pOldCert=NULL;
                }

                //we will free the certificate context later
                pCertType->pOldCert=(PCERT_CONTEXT)pCertCurrent;

                //we mark UI required if the RAing certificate template requires UI
                if(AEUISetForTemplate(pAE_General_Info, pCertType->pOldCert))
                    pCertType->fUIActive=TRUE;

                //we mark the requests has to be RAed.
                pCertType->fNeedRA=TRUE;

                //we mark that we are doing cross RAing.
                pCertType->fCrossRA=TRUE;

				*pfUserProtection=FALSE;

                return TRUE;
            }
        }

        memset(&AECertInfo, 0, sizeof(AE_CERT_INFO));
    }


    return FALSE;
}
//-----------------------------------------------------------------------
//
//  AEMarkAutoenrollment
//
//-----------------------------------------------------------------------
BOOL    AEMarkAutoenrollment(AE_GENERAL_INFO *pAE_General_Info)
{
    DWORD   dwIndex = 0;

    for(dwIndex=0; dwIndex < pAE_General_Info->dwCertType; dwIndex++)
    {
        if(CT_FLAG_AUTO_ENROLLMENT & ((pAE_General_Info->rgCertTypeInfo)[dwIndex].dwEnrollmentFlag))
        {
            //check the autoenrollment ACL
            if(S_OK != CACertTypeAccessCheckEx(
                            (pAE_General_Info->rgCertTypeInfo)[dwIndex].hCertType,
                            pAE_General_Info->hToken,
                            CERTTYPE_ACCESS_CHECK_AUTO_ENROLL | CERTTYPE_ACCESS_CHECK_NO_MAPPING))
                continue;


            //mark the template nees to be auto-enrolled
            (pAE_General_Info->rgCertTypeInfo)[dwIndex].dwStatus=CERT_REQUEST_STATUS_ACTIVE;
            (pAE_General_Info->rgCertTypeInfo)[dwIndex].fCheckMyStore=TRUE;
        }
    }

    return TRUE;
}

//-----------------------------------------------------------------------
//
//    IsACRSStoreEmpty
//
//
//-----------------------------------------------------------------------
BOOL IsACRSStoreEmpty(BOOL fMachine)
{
    DWORD                       dwOpenStoreFlags = CERT_SYSTEM_STORE_LOCAL_MACHINE | CERT_STORE_READONLY_FLAG;
    LPSTR                       pszCTLUsageOID = NULL;
    BOOL                        fEmpty = TRUE;
    CERT_PHYSICAL_STORE_INFO    PhysicalStoreInfo;
    CTL_FIND_USAGE_PARA         CTLFindUsage;

    PCCTL_CONTEXT               pCTLContext = NULL;
    HCERTSTORE                  hStoreACRS=NULL;

    memset(&PhysicalStoreInfo, 0, sizeof(PhysicalStoreInfo));
    memset(&CTLFindUsage, 0, sizeof(CTLFindUsage));


    // if the auto enrollment is for a user then we need to shut off inheritance
    // from the local machine store so that we don't try and enroll for certs
    // which are meant to be for the machine
    if (FALSE == fMachine)
    {
		dwOpenStoreFlags = CERT_SYSTEM_STORE_CURRENT_USER | CERT_STORE_READONLY_FLAG;

        PhysicalStoreInfo.cbSize = sizeof(PhysicalStoreInfo);
        PhysicalStoreInfo.dwFlags = CERT_PHYSICAL_STORE_OPEN_DISABLE_FLAG;

        if (!CertRegisterPhysicalStore(ACRS_STORE, 
                                       CERT_SYSTEM_STORE_CURRENT_USER,
                                       CERT_PHYSICAL_STORE_LOCAL_MACHINE_NAME, 
                                       &PhysicalStoreInfo,
                                       NULL))
        {
            AE_DEBUG((AE_ERROR, L"Could not register ACRS store: (%lx)\n\r", GetLastError()));
            goto Ret;
        }
    }

    // open the ACRS store and fine the CTL based on the auto enrollment usage
    if (NULL == (hStoreACRS = CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
                                          ENCODING_TYPE, 
                                          NULL, 
                                          dwOpenStoreFlags, 
                                          ACRS_STORE)))
    {
        AE_DEBUG((AE_ERROR, L"Could not open ACRS store: (%lx)\n\r", GetLastError()));
        goto Ret;
    }

    //find the template name specified in the CTLContext
    CTLFindUsage.cbSize = sizeof(CTLFindUsage);
    CTLFindUsage.SubjectUsage.cUsageIdentifier = 1;
    pszCTLUsageOID = szOID_AUTO_ENROLL_CTL_USAGE;
    CTLFindUsage.SubjectUsage.rgpszUsageIdentifier = &pszCTLUsageOID;

    while(pCTLContext = CertFindCTLInStore(hStoreACRS,
                                           X509_ASN_ENCODING,
                                           CTL_FIND_SAME_USAGE_FLAG,
                                           CTL_FIND_USAGE,
                                           &CTLFindUsage,
                                           pCTLContext))
    {
        fEmpty=FALSE;
        break;
    }


Ret:

    if(pCTLContext)
        CertFreeCTLContext(pCTLContext);

    if(hStoreACRS)
        CertCloseStore(hStoreACRS, 0);

    return fEmpty;
}


//-----------------------------------------------------------------------
//
//  AEMarkAEObject
//
//      Mark the active status based on ACRS store
//
//      INFORMATION:
//      we do not honor the CA specified in the autoenrollment object anymore.  All CAs
//      in the enterprise should be treated equal; and once the CA is renewed, it certificate
//      will be changed anyway.
//-----------------------------------------------------------------------
BOOL    AEMarkAEObject(AE_GENERAL_INFO  *pAE_General_Info)
{
    DWORD                       dwOpenStoreFlags = CERT_SYSTEM_STORE_LOCAL_MACHINE | CERT_STORE_READONLY_FLAG;
    PCCTL_CONTEXT               pCTLContext = NULL;
    LPSTR                       pszCTLUsageOID = NULL;
    LPWSTR                      wszCertTypeName = NULL;
    AE_CERTTYPE_INFO            *pCertType=NULL;
    CERT_PHYSICAL_STORE_INFO    PhysicalStoreInfo;
    CTL_FIND_USAGE_PARA         CTLFindUsage;
    AE_TEMPLATE_INFO            AETemplateInfo;

    HCERTSTORE                  hStoreACRS=NULL;

    memset(&PhysicalStoreInfo, 0, sizeof(PhysicalStoreInfo));
    memset(&CTLFindUsage, 0, sizeof(CTLFindUsage));
    memset(&AETemplateInfo, 0, sizeof(AETemplateInfo));


    // if the auto enrollment is for a user then we need to shut off inheritance
    // from the local machine store so that we don't try and enroll for certs
    // which are meant to be for the machine
    if (FALSE == (pAE_General_Info->fMachine))
    {
		dwOpenStoreFlags = CERT_SYSTEM_STORE_CURRENT_USER | CERT_STORE_READONLY_FLAG;

        PhysicalStoreInfo.cbSize = sizeof(PhysicalStoreInfo);
        PhysicalStoreInfo.dwFlags = CERT_PHYSICAL_STORE_OPEN_DISABLE_FLAG;

        if (!CertRegisterPhysicalStore(ACRS_STORE, 
                                       CERT_SYSTEM_STORE_CURRENT_USER,
                                       CERT_PHYSICAL_STORE_LOCAL_MACHINE_NAME, 
                                       &PhysicalStoreInfo,
                                       NULL))
        {
            AE_DEBUG((AE_ERROR, L"Could not register ACRS store: (%lx)\n\r", GetLastError()));
            goto Ret;
        }
    }

    // open the ACRS store and fine the CTL based on the auto enrollment usage
    if (NULL == (hStoreACRS = CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
                                          ENCODING_TYPE, 
                                          NULL, 
                                          dwOpenStoreFlags, 
                                          ACRS_STORE)))
    {
        AE_DEBUG((AE_ERROR, L"Could not open ACRS store: (%lx)\n\r", GetLastError()));
        goto Ret;
    }

    //find the template name specified in the CTLContext
    CTLFindUsage.cbSize = sizeof(CTLFindUsage);
    CTLFindUsage.SubjectUsage.cUsageIdentifier = 1;
    pszCTLUsageOID = szOID_AUTO_ENROLL_CTL_USAGE;
    CTLFindUsage.SubjectUsage.rgpszUsageIdentifier = &pszCTLUsageOID;

    while(pCTLContext = CertFindCTLInStore(hStoreACRS,
                                           X509_ASN_ENCODING,
                                           CTL_FIND_SAME_USAGE_FLAG,
                                           CTL_FIND_USAGE,
                                           &CTLFindUsage,
                                           pCTLContext))
    {
        if(NULL== (pCTLContext->pCtlInfo->ListIdentifier.pbData))
            continue;

        wszCertTypeName = wcschr((LPWSTR)pCTLContext->pCtlInfo->ListIdentifier.pbData, L'|');
        if(wszCertTypeName)
        {
            wszCertTypeName++;
        }
        else
        {
            wszCertTypeName = (LPWSTR)pCTLContext->pCtlInfo->ListIdentifier.pbData;
        }

        AETemplateInfo.pwszName = wszCertTypeName;

        if(pCertType=AEFindTemplateInRequestTree(&AETemplateInfo, pAE_General_Info))
        {
            if(0 == pCertType->dwStatus)
            {
                //mark the template needs to be auto-enrolled
                pCertType->dwStatus=CERT_REQUEST_STATUS_ACTIVE;
                pCertType->fCheckMyStore=TRUE;
            }
        }
        else
        {
            //log that the template is invalid
            AELogAutoEnrollmentEvent(pAE_General_Info->dwLogLevel, FALSE, S_OK, EVENT_INVALID_ACRS_OBJECT,                              
                 pAE_General_Info->fMachine, pAE_General_Info->hToken, 1, wszCertTypeName);
        }

    }


Ret:

    if(hStoreACRS)
        CertCloseStore(hStoreACRS, 0);

    return TRUE;
}


//-----------------------------------------------------------------------
//
//  AEManageAndMarkMyStore
//
//-----------------------------------------------------------------------
BOOL    AEManageAndMarkMyStore(AE_GENERAL_INFO *pAE_General_Info)
{
    AE_CERT_INFO        AECertInfo;
    AE_CERTTYPE_INFO    *pCertType=NULL;
    BOOL                fNeedToValidate=TRUE;
    PCCERT_CONTEXT      pCertCurrent = NULL;
    DWORD               cbData=0;

    AE_TEMPLATE_INFO    AETemplateInfo;


    memset(&AECertInfo, 0, sizeof(AE_CERT_INFO));
    memset(&AETemplateInfo, 0, sizeof(AE_TEMPLATE_INFO));

    //enumerate all certificate in store
    while(pCertCurrent = CertEnumCertificatesInStore(pAE_General_Info->hMyStore, pCertCurrent))
    {
        //only interested in certificate with template information
        if(AERetrieveTemplateInfo(pCertCurrent, &AETemplateInfo))
        {
            if(pCertType=AEFindTemplateInRequestTree(
                            &AETemplateInfo, pAE_General_Info))
            {
                //if we are not supposed to check for my store, only search
                //for template with ACTIVE status
                if(0 == (AUTO_ENROLLMENT_ENABLE_MY_STORE_MANAGEMENT & (pAE_General_Info->dwPolicy)))
                {
                    if(!(pCertType->fCheckMyStore))
                        goto Next;
                }

                //make sure the version of the certificate template is up to date
                //we do not have version for V1 template
                if(AETemplateInfo.pwszOid)
                {
                    if(AETemplateInfo.dwVersion < pCertType->dwVersion)
                    {
                        AECertInfo.fValid=FALSE;
                        AECertInfo.fRenewal = FALSE;

                        //self-RA renewal
                        if(CT_FLAG_PREVIOUS_APPROVAL_VALIDATE_REENROLLMENT & pCertType->dwEnrollmentFlag)
                        {
                            if(CertGetCertificateContextProperty(
                                pCertCurrent,
                                CERT_KEY_PROV_INFO_PROP_ID,
                                NULL,
                                &cbData))
                                AECertInfo.fRenewal = TRUE;
                        }

                        fNeedToValidate=FALSE;
                    }
                }
                
                if(fNeedToValidate)
                {
                    //check if we need to enroll/renewal for the certificate
                    AEValidateCertificateInfo(pAE_General_Info, 
                                            pCertType,
                                            TRUE,               //valid private key
                                            pCertCurrent, 
                                            &AECertInfo);
                }

                if(AECertInfo.fValid)
                {
                    //if the certificate is valid, mark as obtained.  And copy the 
                    //certificate to the obtained store.  Keep the archive store.
                    pCertType->dwStatus = CERT_REQUEST_STATUS_OBTAINED;

                    CertAddCertificateContextToStore(
                            pCertType->hObtainedStore,
                            pCertCurrent,
                            CERT_STORE_ADD_ALWAYS,
                            NULL);

                }
                else
                {
                    //the certificate is not valid
                    //mark the status to active if it is not obtained
                    if(CERT_REQUEST_STATUS_OBTAINED != pCertType->dwStatus)
                    {
                        pCertType->dwStatus = CERT_REQUEST_STATUS_ACTIVE;

                        if(AECertInfo.fRenewal)
                        {
                            //we only need to copy renewal information once
                            if(!pCertType->fRenewal)
                            {
                                pCertType->fRenewal=TRUE;
                                pCertType->pOldCert=(PCERT_CONTEXT)CertDuplicateCertificateContext(pCertCurrent);
                            }
                        }
                    }

                    //copy the certificate to the Archive certificate store
                    CertAddCertificateContextToStore(
                            pCertType->hArchiveStore,
                            pCertCurrent,
                            CERT_STORE_ADD_ALWAYS,
                            NULL);
                }
            }
            else
            {
                 //log that the template is invalid
                 AELogAutoEnrollmentEvent(
                    pAE_General_Info->dwLogLevel, 
                    FALSE, 
                    S_OK, 
                    EVENT_INVALID_TEMPLATE_MY_STORE,                              
                    pAE_General_Info->fMachine, 
                    pAE_General_Info->hToken, 
                    1,
                    AETemplateInfo.pwszName ? AETemplateInfo.pwszName : AETemplateInfo.pwszOid);

            }
        }

Next:
        memset(&AECertInfo, 0, sizeof(AE_CERT_INFO));
        AEFreeTemplateInfo(&AETemplateInfo);
        fNeedToValidate=TRUE;
        cbData=0;
    }

    return TRUE;
}

//-----------------------------------------------------------------------
//
//  AEOpenUserDSStore
//
//      INFORMATION: We could just open the "UserDS" store as if it is "My"
//
//-----------------------------------------------------------------------
HCERTSTORE  AEOpenUserDSStore(AE_GENERAL_INFO *pAE_General_Info, DWORD dwOpenFlag)
{
    LPWSTR      pwszPath=L"ldap:///%s?userCertificate?base?objectCategory=user";
    DWORD       dwSize=0;
    WCHAR       wszDN[MAX_DN_SIZE];

    LPWSTR      pwszDN=NULL;
    LPWSTR      pwszStore=NULL;
    HCERTSTORE  hStore=NULL;

    dwSize=MAX_DN_SIZE;

    if(!GetUserNameExW(NameFullyQualifiedDN, wszDN, &dwSize))
    {
        if(dwSize > MAX_DN_SIZE)
        {
            pwszDN=(LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * dwSize);

            if(NULL==pwszDN)
                goto Ret;

            if(!GetUserNameExW(NameFullyQualifiedDN, pwszDN, &dwSize))
                goto Ret;
        }
        else
            goto Ret;
    }

    pwszStore = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR)*(wcslen(pwszDN ? pwszDN : wszDN)+wcslen(pwszPath)+1));
    if(pwszStore == NULL)
        goto Ret;

    wsprintf(pwszStore, 
             pwszPath,
             pwszDN ? pwszDN : wszDN);

    hStore = CertOpenStore(CERT_STORE_PROV_LDAP, 
                  ENCODING_TYPE,
                  NULL,
                  dwOpenFlag, 
                  pwszStore);

Ret:

    if(pwszStore)
        LocalFree(pwszStore);

    if(pwszDN)
        LocalFree(pwszDN);

    return hStore;
}


//-----------------------------------------------------------------------
//
//  AECheckUserDSStore
//
//-----------------------------------------------------------------------
BOOL    AECheckUserDSStore(AE_GENERAL_INFO  *pAE_General_Info)
{
    PCCERT_CONTEXT      pCertCurrent = NULL;
    AE_CERTTYPE_INFO    *pCertType=NULL;
    BOOL                fNeedToValidate=TRUE;
    AE_CERT_INFO        AECertInfo;

    HCERTSTORE          hUserDS = NULL;
    AE_TEMPLATE_INFO    AETemplateInfo;
    
    memset(&AECertInfo, 0, sizeof(AE_CERT_INFO));
    memset(&AETemplateInfo, 0, sizeof(AE_TEMPLATE_INFO));
    
    pCertType=pAE_General_Info->rgCertTypeInfo;

    if(NULL==pCertType)
        goto Ret;

    if(NULL== (hUserDS = AEOpenUserDSStore(pAE_General_Info, CERT_STORE_READONLY_FLAG)))
        goto Ret;

    pCertType = NULL;
    while(pCertCurrent = CertEnumCertificatesInStore(hUserDS, pCertCurrent))
    {
        //only interested in certificate with template information
        if(AERetrieveTemplateInfo(pCertCurrent, &AETemplateInfo))
        {
            if(pCertType=AEFindTemplateInRequestTree(
                            &AETemplateInfo, pAE_General_Info))
            {
                //if we are not supposed to check for UserDS store, only search
                //for template with ACTIVE status
                if(0 == (AUTO_ENROLLMENT_ENABLE_MY_STORE_MANAGEMENT & (pAE_General_Info->dwPolicy)))
                {
                    if(!(pCertType->fCheckMyStore))
                        goto Next;
                }

                //make sure the version of the certificate template is up to date
                //we do not have version for V1 template
                if(AETemplateInfo.pwszOid)
                {
                    if(AETemplateInfo.dwVersion < pCertType->dwVersion)
                    {
                        AECertInfo.fValid=FALSE;
                        AECertInfo.fRenewal=FALSE;
                        fNeedToValidate=FALSE;
                    }
                }
                
                if(fNeedToValidate)
                {
                    //check if we need to enroll/renewal for the certificate
                    AEValidateCertificateInfo(pAE_General_Info, 
                                            pCertType,
                                            FALSE,               //does not valid private key
                                            pCertCurrent, 
                                            &AECertInfo);
                }

                //we only interested in any valid certificate
                if(AECertInfo.fValid)
                {
                    if((CT_FLAG_AUTO_ENROLLMENT_CHECK_USER_DS_CERTIFICATE & (pCertType->dwEnrollmentFlag)) &&
                        (CERT_REQUEST_STATUS_OBTAINED != pCertType->dwStatus))
                    {
                        //mark the status as obtained. 
                        pCertType->dwStatus = CERT_REQUEST_STATUS_OBTAINED;
                    }

                    CertAddCertificateContextToStore(
                            pCertType->hObtainedStore,
                            pCertCurrent,
                            CERT_STORE_ADD_USE_EXISTING,
                            NULL);

                }
                else
                {
                    //copy the certificate to the Archive certificate store
                    CertAddCertificateContextToStore(
                            pCertType->hArchiveStore,
                            pCertCurrent,
                            CERT_STORE_ADD_USE_EXISTING,
                            NULL);
                }
            }
        }

Next:
        memset(&AECertInfo, 0, sizeof(AE_CERT_INFO));
        AEFreeTemplateInfo(&AETemplateInfo);
        fNeedToValidate=TRUE;
    }
Ret:
    
    if(hUserDS)
        CertCloseStore(hUserDS, 0);

    return TRUE;
}

//-----------------------------------------------------------------------
//
//  AECheckPendingRequests
//
//      If we have pending update-to-date certificate requests, no need
//  to enroll/renew for duplicates.
//-----------------------------------------------------------------------
BOOL    AECheckPendingRequests(AE_GENERAL_INFO *pAE_General_Info)
{
    DWORD                   dwIndex=0;
    DWORD                   dwVersion=0;
    AE_CERTTYPE_INFO        *pCertType=NULL;
    BOOL                    fValid=FALSE;
    DWORD                   dwCount=0;
    DWORD                   dwMax=PENDING_ALLOC_SIZE;
    PFNPIEnroll4GetNoCOM    pfnPIEnroll4GetNoCOM=NULL;
    FILETIME                ftTime;
    LARGE_INTEGER           ftRequestTime;
    AE_TEMPLATE_INFO        AETemplateInfo;

    IEnroll4                *pIEnroll4=NULL;
    CRYPT_DATA_BLOB         *rgblobHash=NULL;
    CRYPT_DATA_BLOB         blobName;

    //init before any goto Ret
    memset(&blobName, 0, sizeof(blobName));
    memset(&AETemplateInfo, 0, sizeof(AETemplateInfo));

    if(NULL==pAE_General_Info->hXenroll)
        goto Ret;

    if(NULL==(pfnPIEnroll4GetNoCOM=(PFNPIEnroll4GetNoCOM)GetProcAddress(
                        pAE_General_Info->hXenroll,
                        "PIEnroll4GetNoCOM")))
        goto Ret;

    if(NULL==(pIEnroll4=pfnPIEnroll4GetNoCOM()))
        goto Ret;

    GetSystemTimeAsFileTime(&ftTime);

    if(pAE_General_Info->fMachine)
    {
        if(S_OK != pIEnroll4->put_RequestStoreFlags(CERT_SYSTEM_STORE_LOCAL_MACHINE))
            goto Ret;
    }
    else
    {
        if(S_OK != pIEnroll4->put_RequestStoreFlags(CERT_SYSTEM_STORE_CURRENT_USER))
            goto Ret;
    }

    //enumerate all the pending requests

    rgblobHash=(CRYPT_DATA_BLOB *)LocalAlloc(LPTR, dwMax * sizeof(CRYPT_DATA_BLOB));
    if(NULL==rgblobHash)
        goto Ret;

    memset(rgblobHash, 0, dwMax * sizeof(CRYPT_DATA_BLOB));

    //initialize the enumerator
    if(S_OK != pIEnroll4->enumPendingRequestWStr(XEPR_ENUM_FIRST, 0, NULL))
        goto Ret;

    while(AEGetPendingRequestProperty(
                    pIEnroll4,
                    dwIndex,
                    XEPR_DATE,
                    &ftRequestTime))
    {
        ftRequestTime.QuadPart += Int32x32To64(FILETIME_TICKS_PER_SECOND, 
                                    AE_PENDING_REQUEST_ACTIVE_PERIOD * 24 * 3600);

        //remove the request if out of date
        if(0 <= CompareFileTime(&ftTime, (LPFILETIME)&ftRequestTime))
        {
            AERetrieveRequestProperty(pIEnroll4, dwIndex, &dwCount, &dwMax, &rgblobHash);
        }
        else
        {
            //get the version and the template name of the request
            if(AEGetPendingRequestProperty(pIEnroll4, dwIndex, XEPR_V2TEMPLATEOID, &blobName))
            {
                //this is a V2 template
                if(!AEGetPendingRequestProperty(pIEnroll4, dwIndex, XEPR_VERSION, &dwVersion))
                    goto Next;

                AETemplateInfo.pwszOid=(LPWSTR)blobName.pbData;

            }
            else
            {
                if(!AEGetPendingRequestProperty(pIEnroll4, dwIndex, XEPR_V1TEMPLATENAME, &blobName))
                    goto Next;

                AETemplateInfo.pwszName=(LPWSTR)blobName.pbData;
            }

            //find the template
            if(NULL==(pCertType=AEFindTemplateInRequestTree(
                            &AETemplateInfo, pAE_General_Info)))
                goto Next;

            if(AETemplateInfo.pwszName)
                fValid=TRUE;
            else
            {
                if(dwVersion >= pCertType->dwVersion)
                    fValid=TRUE;
            }

            if(fValid)
            {
                //this is a valid pending request 
                if(CERT_REQUEST_STATUS_OBTAINED != pCertType->dwStatus)
                    pCertType->dwStatus=CERT_REQUEST_STATUS_PENDING;
            }
            else
            {
                if(CERT_REQUEST_STATUS_OBTAINED == pCertType->dwStatus)
                    AERetrieveRequestProperty(pIEnroll4, dwIndex, &dwCount, &dwMax, &rgblobHash);
            }
        }

Next:
        
        if(blobName.pbData)
            LocalFree(blobName.pbData);
        memset(&blobName, 0, sizeof(blobName));

        memset(&AETemplateInfo, 0, sizeof(AETemplateInfo));

        fValid=FALSE;
        dwVersion=0;

        dwIndex++;
    }

    //remove the requests based the hash
    if(dwCount)
    {
        AERemovePendingRequest(pIEnroll4, dwCount, rgblobHash);
        AELogAutoEnrollmentEvent(pAE_General_Info->dwLogLevel, FALSE, S_OK, EVENT_PENDING_INVALID, pAE_General_Info->fMachine, pAE_General_Info->hToken, 0);
    }

Ret:

    AEFreePendingRequests(dwCount, rgblobHash);

    if(blobName.pbData)
        LocalFree(blobName.pbData);

    if(pIEnroll4)
        pIEnroll4->Release();

    return TRUE;
}

//-----------------------------------------------------------------------
//
//  AECheckSupersedeRequest
//
//-----------------------------------------------------------------------
BOOL AECheckSupersedeRequest(DWORD              dwCurIndex,
                             AE_CERTTYPE_INFO   *pCurCertType, 
                             AE_CERTTYPE_INFO   *pSupersedingCertType, 
                             AE_GENERAL_INFO    *pAE_General_Info)
{
    BOOL                fFound=FALSE;

    LPWSTR              *awszSuperseding=NULL; 

    if(S_OK == CAGetCertTypePropertyEx(
                 pSupersedingCertType->hCertType, 
                 CERTTYPE_PROP_SUPERSEDE,
                 &(awszSuperseding)))
    {
        if(awszSuperseding && awszSuperseding[0])
        {
            if(AEIfSupersede(pCurCertType->awszName[0], awszSuperseding, pAE_General_Info))
            {
                switch(pCurCertType->dwStatus)
                {
                    case CERT_REQUEST_STATUS_ACTIVE:
                    case CERT_REQUEST_STATUS_SUPERSEDE_ACTIVE:
                            //remove the active status if it is superseded by an obtained certificate
                            if(CERT_REQUEST_STATUS_OBTAINED != pSupersedingCertType->dwStatus) 
                            {
                                pCurCertType->dwStatus = CERT_REQUEST_STATUS_SUPERSEDE_ACTIVE;
                                pSupersedingCertType->prgActive[pSupersedingCertType->dwActive]=dwCurIndex;
                                (pSupersedingCertType->dwActive)++;
                            }
                            else
                            {
                                pCurCertType->dwStatus = 0;
                            }

                    case CERT_REQUEST_STATUS_PENDING:
                                AECopyCertStore(pCurCertType->hArchiveStore,
                                                pSupersedingCertType->hArchiveStore);

                        break;

                    case CERT_REQUEST_STATUS_OBTAINED:

                                AECopyCertStore(pCurCertType->hObtainedStore,
                                                pSupersedingCertType->hArchiveStore);

                        break;

                   default:

                        break;    
                }

                //we consider that we find a valid superseding template only if the status
                //is obtained.  If the status is anyting else, we need to keep searching since
                //enrollment/renewal requests might not be granted
                if(CERT_REQUEST_STATUS_OBTAINED == pSupersedingCertType->dwStatus)
                    fFound=TRUE;
            }

            //clear the visited flag in AE_General_Info
            AEClearVistedFlag(pAE_General_Info);
        }

        //free the property
        if(awszSuperseding)
            CAFreeCertTypeProperty(
                pSupersedingCertType->hCertType,
                awszSuperseding);

        awszSuperseding=NULL;
    }

    return fFound;
}

//-----------------------------------------------------------------------
//
//  AEIsCALonger
//
//      For renewal, the CA's certificate has to live longer than the 
//  renewing certificate    
//  
//-----------------------------------------------------------------------
BOOL    AEIsCALonger(HCAINFO    hCAInfo, PCERT_CONTEXT  pOldCert)
{
    BOOL            fCALonger=TRUE;

    PCCERT_CONTEXT  pCACert=NULL;

    //we assume the CA is good unless we found something wrong
    if((NULL == hCAInfo) || (NULL == pOldCert))
        goto Ret;

    if(S_OK != CAGetCACertificate(hCAInfo, &pCACert))
        goto Ret;

    if(NULL == pCACert)
        goto Ret;

    //CA cert's NotAfter should be longer than the issued certificate' NotAfger
    if(1 == CompareFileTime(&(pCACert->pCertInfo->NotAfter), &(pOldCert->pCertInfo->NotAfter)))
        goto Ret;

    fCALonger=FALSE;

Ret:

    if(pCACert)
        CertFreeCertificateContext(pCACert);

    return fCALonger;
}


//-----------------------------------------------------------------------
//
//  AECanFindCAForCertType
//
//      Check if there exists a CA that can issue the specified certificate 
//  template.    
//  
//-----------------------------------------------------------------------
BOOL    AECanFindCAForCertType(AE_GENERAL_INFO   *pAE_General_Info, AE_CERTTYPE_INFO *pCertType)
{
    DWORD           dwIndex=0;
    BOOL            fFound=FALSE;
    AE_CA_INFO      *prgCAInfo=pAE_General_Info->rgCAInfo;
    BOOL            fRenewal=FALSE;


    //detect if we are performing an enrollment or renewal
    if((pCertType->fRenewal) && (pCertType->pOldCert))
    {
        if((pCertType->fNeedRA) && (pCertType->fCrossRA))
            fRenewal=FALSE;
        else
            fRenewal=TRUE;
    }
    else
        fRenewal=FALSE;

    if(prgCAInfo)
    {
        for(dwIndex=0; dwIndex < pAE_General_Info->dwCA; dwIndex++)
        {
            //make sure the CA supports the specific template
            if(AEIsAnElement((pCertType->awszName)[0], 
                              (prgCAInfo[dwIndex]).awszCertificateTemplate))
            {
                if(FALSE == fRenewal)
                {
                    fFound=TRUE;
                    break;
                }
                else
                {
                    if(AEIsCALonger(prgCAInfo[dwIndex].hCAInfo, pCertType->pOldCert))
                    {
                        fFound=TRUE;
                        break;
                    }
                }
            }
        }
    }

    return fFound;
}

//-----------------------------------------------------------------------
//
//  AEManageActiveTemplates
//      
//      We make sure that for all active templates, we can in deed enroll
//  for it.
//
//-----------------------------------------------------------------------
BOOL    AEManageActiveTemplates(AE_GENERAL_INFO   *pAE_General_Info)
{
    DWORD               dwIndex=0;
    AE_CERTTYPE_INFO    *pCertTypeInfo=pAE_General_Info->rgCertTypeInfo;
    AE_CERTTYPE_INFO    *pCurCertType=NULL;
    BOOL                fCanEnrollCertType=FALSE;
	BOOL				fUserProtection=FALSE;
	DWORD				dwEventID=0;

    if(pCertTypeInfo)
    {
        for(dwIndex=0; dwIndex < pAE_General_Info->dwCertType; dwIndex++)
        {
            pCurCertType = &(pCertTypeInfo[dwIndex]);

            fCanEnrollCertType=FALSE;
			fUserProtection=FALSE;

            if(CERT_REQUEST_STATUS_PENDING == pCurCertType->dwStatus)
            {
                //check if UI is required
                if(CT_FLAG_USER_INTERACTION_REQUIRED & (pCurCertType->dwEnrollmentFlag))
                {
                    pCurCertType->fUIActive=TRUE;

                    if(pAE_General_Info->fMachine)
                    {
                        pCurCertType->dwStatus = 0;

                        //log that user does not have access right to the template
                        AELogAutoEnrollmentEvent(pAE_General_Info->dwLogLevel, FALSE, S_OK, EVENT_NO_ACCESS_ACRS_OBJECT,                              
                            pAE_General_Info->fMachine, pAE_General_Info->hToken, 1, (pCurCertType->awszDisplay)[0]);
                    }
                }

                continue;
            }


            if(CERT_REQUEST_STATUS_ACTIVE != pCurCertType->dwStatus)
                continue;

			//check if CRYPT_USER_PROTECTED is used for machine certificate template
			if(CT_FLAG_STRONG_KEY_PROTECTION_REQUIRED & pCurCertType->dwPrivateKeyFlag)
			{
                if(pAE_General_Info->fMachine)
                {
                    pCurCertType->dwStatus = 0;

                    //log that machine template should not require user password
                    AELogAutoEnrollmentEvent(pAE_General_Info->dwLogLevel, FALSE, S_OK, EVENT_NO_ACCESS_ACRS_OBJECT,                              
                        pAE_General_Info->fMachine, pAE_General_Info->hToken, 1, (pCurCertType->awszDisplay)[0]);

					continue;
                }
				else
				{
					if(0 == (CT_FLAG_USER_INTERACTION_REQUIRED & (pCurCertType->dwEnrollmentFlag)))
					{
						pCurCertType->dwStatus = 0;

						//log that user interaction is not set
						AELogAutoEnrollmentEvent(pAE_General_Info->dwLogLevel, FALSE, S_OK, EVENT_NO_ACCESS_ACRS_OBJECT,                              
							pAE_General_Info->fMachine, pAE_General_Info->hToken, 1, (pCurCertType->awszDisplay)[0]);

						continue;
					}
				}
			}

            fCanEnrollCertType=AECanEnrollCertType(pAE_General_Info->hToken, pCurCertType, pAE_General_Info, &fUserProtection);

            if((!fCanEnrollCertType) ||
               (!AECanFindCAForCertType(pAE_General_Info, pCurCertType))
              )
            {
                pCurCertType->dwStatus = 0;

                //log that user does not have access right to the template
				if(FALSE == fUserProtection)
				{
					dwEventID=EVENT_NO_ACCESS_ACRS_OBJECT;
				}
				else
				{
					if(pAE_General_Info->fMachine)
						dwEventID=EVENT_NO_ACCESS_ACRS_OBJECT;
					else
						dwEventID=EVENT_NO_ACCESS_ACRS_OBJECT;
				}

				AELogAutoEnrollmentEvent(pAE_General_Info->dwLogLevel, FALSE, S_OK, dwEventID,                              
						pAE_General_Info->fMachine, pAE_General_Info->hToken, 1, (pCurCertType->awszDisplay)[0]);
            }
            else
            {
                //check if UI is required
                if(CT_FLAG_USER_INTERACTION_REQUIRED & (pCurCertType->dwEnrollmentFlag))
                {
                    pCurCertType->fUIActive=TRUE;

                    if(pAE_General_Info->fMachine)
                    {
                        pCurCertType->dwStatus = 0;

                        //log that user does not have access right to the template
                        AELogAutoEnrollmentEvent(pAE_General_Info->dwLogLevel, FALSE, S_OK, EVENT_NO_ACCESS_ACRS_OBJECT,                              
                            pAE_General_Info->fMachine, pAE_General_Info->hToken, 1, (pCurCertType->awszDisplay)[0]);
                    }
                }

            }
        }

    }

    return TRUE;
}        
//-----------------------------------------------------------------------
//
//  AEManageSupersedeRequests
//      remove duplicated requests based on "Supersede" relationship
//
//
//-----------------------------------------------------------------------
BOOL    AEManageSupersedeRequests(AE_GENERAL_INFO   *pAE_General_Info)
{
    DWORD               dwIndex=0;
    DWORD               dwSuperseding=0;
    DWORD               dwOrder=0;
    AE_CERTTYPE_INFO    *pCertTypeInfo=pAE_General_Info->rgCertTypeInfo;
    AE_CERTTYPE_INFO    *pCurCertType=NULL;
    AE_CERTTYPE_INFO    *pSupersedingCertType=NULL;
    BOOL                fFound=FALSE;

    if(pCertTypeInfo)
    {
        for(dwIndex=0; dwIndex < pAE_General_Info->dwCertType; dwIndex++)
        {
            pCurCertType = &(pCertTypeInfo[dwIndex]);

            //we only consider templates with valid status
            if(0 == pCurCertType->dwStatus)
                continue;

            fFound=FALSE;

            for(dwOrder=0; dwOrder < g_dwSupersedeOrder; dwOrder++)
            {
                for(dwSuperseding=0; dwSuperseding < pAE_General_Info->dwCertType; dwSuperseding++)
                {
                    //one can not be superseded by itself
                    if(dwIndex == dwSuperseding)
                        continue;

                    pSupersedingCertType = &(pCertTypeInfo[dwSuperseding]);

                    //we consider templates with obtained status first
                    if(g_rgdwSupersedeOrder[dwOrder] != pSupersedingCertType->dwStatus)
                        continue;

                    fFound = AECheckSupersedeRequest(dwIndex, pCurCertType, pSupersedingCertType, pAE_General_Info);

                    //we find a valid superseding template
                    if(fFound)
                        break;
                }

                //we find a valid superseding template
                if(fFound)
                    break;
            }
        }
    }

    return TRUE;
}

//-----------------------------------------------------------------------
//
//  AEDoOneEnrollment
//
//-----------------------------------------------------------------------
/*BOOL    AEDoOneEnrollment(HWND                  hwndParent,
                          BOOL                  fUIProcess,
                          BOOL                  fMachine,
                          LPWSTR                pwszMachineName,
                          AE_CERTTYPE_INFO      *pCertType, 
                          AE_CA_INFO            *pCAInfo,
                          DWORD                 *pdwStatus)
{
    BOOL                                fResult = FALSE;
    CRYPTUI_WIZ_CERT_REQUEST_INFO       CertRequestInfo;
    CRYPTUI_WIZ_CERT_TYPE               CertWizType;
    CRYPTUI_WIZ_CERT_REQUEST_PVK_NEW    CertPvkNew;
    CRYPT_KEY_PROV_INFO                 KeyProvInfo;

    memset(&CertRequestInfo, 0, sizeof(CRYPTUI_WIZ_CERT_REQUEST_INFO));
    memset(&CertWizType, 0, sizeof(CRYPTUI_WIZ_CERT_TYPE));
    memset(&CertPvkNew, 0, sizeof(CRYPTUI_WIZ_CERT_REQUEST_PVK_NEW));
    memset(&KeyProvInfo, 0, sizeof(CRYPT_KEY_PROV_INFO));

    CertRequestInfo.dwSize = sizeof(CRYPTUI_WIZ_CERT_REQUEST_INFO);

    //enroll or renewal
    if((pCertType->fRenewal) && (pCertType->pOldCert))
    {
        CertRequestInfo.dwPurpose = CRYPTUI_WIZ_CERT_RENEW;
        CertRequestInfo.pRenewCertContext = pCertType->pOldCert;
    }
    else
        CertRequestInfo.dwPurpose = CRYPTUI_WIZ_CERT_ENROLL;

    //machine name
    if(fMachine)
    {
        CertRequestInfo.pwszMachineName = pwszMachineName;
    }

    //private key information
    CertRequestInfo.dwPvkChoice = CRYPTUI_WIZ_CERT_REQUEST_PVK_CHOICE_NEW;
    CertRequestInfo.pPvkNew = &CertPvkNew;

    CertPvkNew.dwSize = sizeof(CertPvkNew);
    CertPvkNew.pKeyProvInfo = &KeyProvInfo;
    CertPvkNew.dwGenKeyFlags = 0;   //no need to specify the exportable flags

    //SILENT is always set for machine
    if(fMachine)
        KeyProvInfo.dwFlags = CRYPT_MACHINE_KEYSET | CRYPT_SILENT;
    else
    {
        if(fUIProcess)
            KeyProvInfo.dwFlags = 0;
        else
            KeyProvInfo.dwFlags = CRYPT_SILENT;
    }

    //CA information
    CertRequestInfo.pwszCALocation = pCAInfo->awszCADNS[0];
    CertRequestInfo.pwszCAName = pCAInfo->awszCAName[0];

    //enroll for the template
    CertRequestInfo.dwCertChoice = CRYPTUI_WIZ_CERT_REQUEST_CERT_TYPE;
    CertRequestInfo.pCertType = &CertWizType;

    CertWizType.dwSize = sizeof(CertWizType);
    CertWizType.cCertType = 1;
    CertWizType.rgwszCertType = &(pCertType->awszName[0]);

    //ISSUE: we need to call Duncanb's new no-DS look up API
    //for faster performance
    fResult = CryptUIWizCertRequest(CRYPTUI_WIZ_NO_UI_EXCEPT_CSP | CRYPTUI_WIZ_NO_INSTALL_ROOT,
                            hwndParent,
                            NULL,
                            &CertRequestInfo,
                            NULL,               //pCertContext
                            pdwStatus);
    return fResult;
} */

//-----------------------------------------------------------------------
//
//  AECreateEnrollmentRequest
//
//   
//-----------------------------------------------------------------------
BOOL    AECreateEnrollmentRequest(
                          HWND                  hwndParent,
                          BOOL                  fUIProcess,
                          BOOL                  fMachine,
                          LPWSTR                pwszMachineName,
                          AE_CERTTYPE_INFO      *pCertType,
                          AE_CA_INFO            *pCAInfo,
                          HANDLE                *phRequest,
                          DWORD                 *pdwLastError)
{
    BOOL                                    fResult = FALSE;
    CRYPTUI_WIZ_CREATE_CERT_REQUEST_INFO    CreateRequestInfo;
    CRYPTUI_WIZ_CERT_REQUEST_PVK_NEW        CertPvkNew;
    CRYPT_KEY_PROV_INFO                     KeyProvInfo;
    DWORD                                   dwFlags=CRYPTUI_WIZ_NO_UI_EXCEPT_CSP | 
                                                    CRYPTUI_WIZ_NO_INSTALL_ROOT |
                                                    CRYPTUI_WIZ_ALLOW_ALL_TEMPLATES |
                                                    CRYPTUI_WIZ_ALLOW_ALL_CAS;
    DWORD                                   dwSize=0;
    DWORD                                   dwAcquireFlags=0;
    BOOL                                    fResetProv=FALSE;

    CRYPT_KEY_PROV_INFO                     *pKeyProvInfo=NULL;
    HANDLE                                  hRequest=NULL;

    memset(&CreateRequestInfo, 0, sizeof(CRYPTUI_WIZ_CREATE_CERT_REQUEST_INFO));
    memset(&CertPvkNew, 0, sizeof(CRYPTUI_WIZ_CERT_REQUEST_PVK_NEW));
    memset(&KeyProvInfo, 0, sizeof(CRYPT_KEY_PROV_INFO));

    CreateRequestInfo.dwSize = sizeof(CreateRequestInfo);


    //enroll or renewal
    if((pCertType->fRenewal) && (pCertType->pOldCert))
    {
        CreateRequestInfo.dwPurpose = CRYPTUI_WIZ_CERT_RENEW;
        CreateRequestInfo.pRenewCertContext = pCertType->pOldCert;

        //we should not archive renewal certificate for cross template RA
        if((pCertType->fNeedRA) && (pCertType->fCrossRA))
            dwFlags |= CRYPTUI_WIZ_NO_ARCHIVE_RENEW_CERT;

        //we should disalbe UI for machine or non-UI enrollment renew/RA certificate
        if((TRUE == fMachine) || (FALSE == fUIProcess))
        {
            dwSize=0;
            if(!CertGetCertificateContextProperty(pCertType->pOldCert,
                                                CERT_KEY_PROV_INFO_PROP_ID,
                                                NULL,
                                                &dwSize))
                goto error;

            pKeyProvInfo=(CRYPT_KEY_PROV_INFO *)LocalAlloc(LPTR, dwSize);

            if(NULL == pKeyProvInfo)
                goto error;

            if(!CertGetCertificateContextProperty(pCertType->pOldCert,
                                                CERT_KEY_PROV_INFO_PROP_ID,
                                                pKeyProvInfo,
                                                &dwSize))
                goto error;

            dwAcquireFlags=pKeyProvInfo->dwFlags;

            pKeyProvInfo->dwFlags |= CRYPT_SILENT;

            //set the property
            if(!CertSetCertificateContextProperty(pCertType->pOldCert,
                                                 CERT_KEY_PROV_INFO_PROP_ID,
                                                 CERT_SET_PROPERTY_INHIBIT_PERSIST_FLAG,
                                                 pKeyProvInfo))
                goto error;

            fResetProv=TRUE;
        }
    }
    else
        CreateRequestInfo.dwPurpose = CRYPTUI_WIZ_CERT_ENROLL;

    //cert template information
    CreateRequestInfo.hCertType = pCertType->hCertType;

    //machine name
    if(fMachine)
    {
        CreateRequestInfo.fMachineContext = TRUE;
    }

    //private key information
    CreateRequestInfo.dwPvkChoice = CRYPTUI_WIZ_CERT_REQUEST_PVK_CHOICE_NEW;
    CreateRequestInfo.pPvkNew = &CertPvkNew;

    CertPvkNew.dwSize = sizeof(CertPvkNew);
    CertPvkNew.pKeyProvInfo = &KeyProvInfo;
    CertPvkNew.dwGenKeyFlags = 0;   //no need to specify the exportable flags

    //SILENT is always set for machine
    if(fMachine)
        KeyProvInfo.dwFlags = CRYPT_MACHINE_KEYSET | CRYPT_SILENT;
    else
    {
        if(fUIProcess)
            KeyProvInfo.dwFlags = 0;
        else
            KeyProvInfo.dwFlags = CRYPT_SILENT;
    }


    //CA information
    CreateRequestInfo.pwszCALocation = pCAInfo->awszCADNS[0];
    CreateRequestInfo.pwszCAName = pCAInfo->awszCAName[0];

    if(!CryptUIWizCreateCertRequestNoDS(
                            dwFlags,
                            hwndParent,
                            &CreateRequestInfo,
                            &hRequest))
        goto error;


    if(NULL==hRequest)
        goto error;

    *phRequest=hRequest;

    hRequest=NULL;


    fResult = TRUE;

error:

    //get the last error
    if(FALSE == fResult)
    {
        *pdwLastError=GetLastError();
    }

    //reset the property
    if(TRUE == fResetProv)
    {
        if((pKeyProvInfo) && (pCertType->pOldCert))
        {
            pKeyProvInfo->dwFlags = dwAcquireFlags;

            //set the property
            CertSetCertificateContextProperty(pCertType->pOldCert,
                                             CERT_KEY_PROV_INFO_PROP_ID,
                                             CERT_SET_PROPERTY_INHIBIT_PERSIST_FLAG,
                                             pKeyProvInfo);
        }
    }

    if(pKeyProvInfo)
        LocalFree(pKeyProvInfo);

    if(hRequest)
        CryptUIWizFreeCertRequestNoDS(hRequest);

    return fResult;
}

//-----------------------------------------------------------------------
//
//  AECancelled
//
//-----------------------------------------------------------------------
BOOL    AECancelled(HANDLE hCancelEvent)
{
    if(NULL==hCancelEvent)
        return FALSE;

    //test if the event is signalled
    if(WAIT_OBJECT_0 == WaitForSingleObject(hCancelEvent, 0))
        return TRUE;

    return FALSE;
}
//-----------------------------------------------------------------------
//
//  AEDoEnrollment
//
//  return TRUE is no need to do another renewal.   
//  *pdwStatus contain the real enrollment status.
//
//-----------------------------------------------------------------------
BOOL    AEDoEnrollment(HWND             hwndParent,
                       HANDLE           hCancelEvent,
                       BOOL             fUIProcess,
                       DWORD            dwLogLevel,
                       HANDLE           hToken,
                       BOOL             fMachine,
                       LPWSTR           pwszMachineName,
                       AE_CERTTYPE_INFO *pCertType, 
                       DWORD            dwCA,
                       AE_CA_INFO       *rgCAInfo,
                       DWORD            *pdwStatus)
{
    BOOL            fResult = FALSE;
    DWORD           dwIndex = 0;
    DWORD           dwCAIndex = 0;
    BOOL            fRenewal = FALSE;
    DWORD           dwEventID = 0;
    BOOL            fFoundCA = FALSE; 
    DWORD           idsSummary = 0;         //keep the last failure case
    DWORD           dwLastError = 0;

    CRYPTUI_WIZ_QUERY_CERT_REQUEST_INFO     QueryCertRequestInfo;

    HANDLE          hRequest=NULL;
    PCCERT_CONTEXT  pCertContext=NULL;


    //init the out parameter
    *pdwStatus = CRYPTUI_WIZ_CERT_REQUEST_STATUS_REQUEST_ERROR;

    //detect if we are performing an enrollment or renewal
    if((pCertType->fRenewal) && (pCertType->pOldCert))
    {
        if((pCertType->fNeedRA) && (pCertType->fCrossRA))
            fRenewal=FALSE;
        else
            fRenewal=TRUE;
    }
    else
        fRenewal=FALSE;


    //loop through all the CAs
    for(dwIndex =0; dwIndex < dwCA; dwIndex++)
    {
        dwCAIndex =  (dwIndex + pCertType->dwRandomCAIndex) % dwCA;

        if(AECancelled(hCancelEvent))
        {
            //no need to renew any more
            fResult=TRUE;

            //log that autoenrollment is cancelled
            AELogAutoEnrollmentEvent(dwLogLevel,
                                    FALSE, 
                                    S_OK, 
                                    EVENT_AUTOENROLL_CANCELLED,
                                    fMachine, 
                                    hToken,
                                    0);

            break;
        }

        //make sure the CA supports the specific template
        if(!AEIsAnElement((pCertType->awszName)[0], 
                          rgCAInfo[dwCAIndex].awszCertificateTemplate))
            continue;

        //make sure the CA's validity period of more than the renewing certificate
        if(TRUE == fRenewal)
        {
            if(!AEIsCALonger(rgCAInfo[dwCAIndex].hCAInfo, pCertType->pOldCert))
                continue;
        }

        //enroll to the CA
        *pdwStatus = CRYPTUI_WIZ_CERT_REQUEST_STATUS_REQUEST_ERROR;
        fFoundCA = TRUE;

        //create a certificate request
        if(NULL==hRequest)
        {
            if(!AECreateEnrollmentRequest(hwndParent, fUIProcess, fMachine, pwszMachineName, pCertType, &(rgCAInfo[dwCAIndex]), &hRequest, &dwLastError))
            {
                //check if user cancelled the enrollment.  If so, no 
                //need to try another CA.
                if((HRESULT_FROM_WIN32(ERROR_CANCELLED) == dwLastError) ||
                   (SCARD_W_CANCELLED_BY_USER == dwLastError))
                {
                    //no need to renewal anymore
                    fResult = TRUE;

                    //log that autoenrollment is cancelled
                    AELogAutoEnrollmentEvent(dwLogLevel,
                                            FALSE, 
                                            S_OK, 
                                            EVENT_AUTOENROLL_CANCELLED_TEMPLATE,
                                            fMachine, 
                                            hToken,
                                            1,
                                            pCertType->awszDisplay[0]);

                    break;

                }
                else
                {
                    idsSummary=IDS_SUMMARY_REQUEST;

                    if(CT_FLAG_REQUIRE_PRIVATE_KEY_ARCHIVAL & pCertType->dwPrivateKeyFlag)
                    {
                        //we have a chance of success with another CA
                        if(hRequest)
                        {
                            CryptUIWizFreeCertRequestNoDS(hRequest);
                            hRequest=NULL;
                        }

                        continue;

                    }
                    else
                    {
                        //we have no hope to create a request successfully
                        //mark dwIndex to the dwCA so that we will log an event at the end of the loop
                        dwIndex=dwCA;
                        break;
                    }
                }
            }
        }

        //check the cancel again because significant time can pass during 
        //request creation
        if(AECancelled(hCancelEvent))
        {
            //no need to renew any more
            fResult=TRUE;

            //log that autoenrollment is cancelled
            AELogAutoEnrollmentEvent(dwLogLevel,
                                    FALSE, 
                                    S_OK, 
                                    EVENT_AUTOENROLL_CANCELLED,
                                    fMachine, 
                                    hToken,
                                    0);

            break;
        }

        if(CryptUIWizSubmitCertRequestNoDS(
                    hRequest, 
                    hwndParent,
                    rgCAInfo[dwCAIndex].awszCAName[0], 
                    rgCAInfo[dwCAIndex].awszCADNS[0], 
                    pdwStatus, 
                    &pCertContext))
        {
            //no need to try another CA if the request is successful or pending
            if((CRYPTUI_WIZ_CERT_REQUEST_STATUS_SUCCEEDED == (*pdwStatus)) ||
                (CRYPTUI_WIZ_CERT_REQUEST_STATUS_UNDER_SUBMISSION == (*pdwStatus))
              )
            {
                //no need to renewal anymore
                fResult = TRUE;

                if(CRYPTUI_WIZ_CERT_REQUEST_STATUS_SUCCEEDED == (*pdwStatus))
                {
                    //we copy the certificate to publishing
                    if(pCertContext)
                    {
                        CertAddCertificateContextToStore(pCertType->hIssuedStore,
                                                        pCertContext,
                                                        CERT_STORE_ADD_USE_EXISTING,
                                                        NULL);

                        CertFreeCertificateContext(pCertContext);
                        pCertContext=NULL;
                    }

                    dwEventID=fRenewal ? EVENT_RENEWAL_SUCCESS_ONCE : EVENT_ENROLL_SUCCESS_ONCE; 
                }
                else
                {
                    dwEventID=fRenewal ? EVENT_RENEWAL_PENDING_ONCE : EVENT_ENROLL_PENDING_ONCE; 
                }

                //log the enrollment sucess or pending event
                AELogAutoEnrollmentEvent(dwLogLevel,
                                        FALSE, 
                                        S_OK, 
                                        dwEventID,
                                        fMachine, 
                                        hToken,
                                        3,
                                        pCertType->awszDisplay[0],
                                        rgCAInfo[dwCAIndex].awszCADisplay[0],
                                        rgCAInfo[dwCAIndex].awszCADNS[0]);

                //log if the private key is re-used
                memset(&QueryCertRequestInfo, 0, sizeof(QueryCertRequestInfo));
                QueryCertRequestInfo.dwSize=sizeof(QueryCertRequestInfo);

                if(CryptUIWizQueryCertRequestNoDS(hRequest,
                                                  &QueryCertRequestInfo))
                {
                    if(CRYPTUI_WIZ_QUERY_CERT_REQUEST_STATUS_CREATE_REUSED_PRIVATE_KEY &
                        (QueryCertRequestInfo.dwStatus))
                    {
                        AELogAutoEnrollmentEvent(dwLogLevel,
                                                FALSE, 
                                                S_OK, 
                                                EVENT_PRIVATE_KEY_REUSED,
                                                fMachine, 
                                                hToken,
                                                1,
                                                pCertType->awszDisplay[0]);
                    }
                }


                break;
            }
        }

        //get the last error
        dwLastError=GetLastError();

        idsSummary=IDS_SUMMARY_CA;

        //log the one enrollment warning
        AELogAutoEnrollmentEvent(dwLogLevel,
                                TRUE, 
                                HRESULT_FROM_WIN32(dwLastError), 
                                fRenewal ? EVENT_RENEWAL_FAIL_ONCE : EVENT_ENROLL_FAIL_ONCE, 
                                fMachine, 
                                hToken,
                                3,
                                pCertType->awszDisplay[0],
                                rgCAInfo[dwCAIndex].awszCADisplay[0],
                                rgCAInfo[dwCAIndex].awszCADNS[0]);


        //we should recreate the request for key archival
        if(CT_FLAG_REQUIRE_PRIVATE_KEY_ARCHIVAL & pCertType->dwPrivateKeyFlag)
        {
            if(hRequest)
            {
                CryptUIWizFreeCertRequestNoDS(hRequest);
                hRequest=NULL;
            }
        }
   }

    //log all enrollments error
    //the loop will exit only if CANCEL, or SUCCEED, or we run out of CAs to try or
    //the request can not be created
    if(dwIndex == dwCA)
    {
        //we either run out of CAs to try or the request can not be created
        if(0 != idsSummary)
            pCertType->idsSummary=idsSummary;

        if(fFoundCA)
        {
            dwEventID = fRenewal ? EVENT_RENEWAL_FAIL : EVENT_ENROLL_FAIL; 
        }
        else
        {
            //if there is no CA, no need to try re-enrollment
            if(fRenewal)
                 pCertType->fRenewal=FALSE; 
           
            dwEventID = fRenewal ? EVENT_RENEWAL_NO_CA_FAIL : EVENT_ENROLL_NO_CA_FAIL;
        }

        AELogAutoEnrollmentEvent(dwLogLevel,
                                fFoundCA ? TRUE : FALSE, 
                                HRESULT_FROM_WIN32(dwLastError), 
                                dwEventID,
                                fMachine, 
                                hToken,
                                1,
                                pCertType->awszDisplay[0]);
    }

    if(hRequest)
        CryptUIWizFreeCertRequestNoDS(hRequest);

    return fResult;
}

//-----------------------------------------------------------------------
//
//  AEEnrollmentCertificates
//
//-----------------------------------------------------------------------
BOOL    AEEnrollmentCertificates(AE_GENERAL_INFO *pAE_General_Info, DWORD dwEnrollStatus)
{
    AE_CERTTYPE_INFO    *rgCertTypeInfo = NULL;
    DWORD               dwIndex =0 ;
    DWORD               dwStatus= 0;
    DWORD               dwRandom = 0;

    HCRYPTPROV          hProv = NULL;

    rgCertTypeInfo = pAE_General_Info->rgCertTypeInfo;

    if(NULL == rgCertTypeInfo)
        return FALSE;

    if((0 == pAE_General_Info->dwCA) || (NULL==pAE_General_Info->rgCAInfo))
        return FALSE;

    if(!CryptAcquireContextW(&hProv,
                NULL,
                MS_DEF_PROV_W,
                PROV_RSA_FULL,
                CRYPT_VERIFYCONTEXT))
        hProv=NULL;


    //going through all the active requests
    for(dwIndex=0; dwIndex < pAE_General_Info->dwCertType; dwIndex++)
    {
        //we enroll/renew for templates that are active
        if(dwEnrollStatus != rgCertTypeInfo[dwIndex].dwStatus)
            continue;

        if(pAE_General_Info->fUIProcess != rgCertTypeInfo[dwIndex].fUIActive)
            continue;
 
        //select a random CA index to balance the load
        if((hProv) && (CryptGenRandom(hProv, sizeof(dwRandom), (BYTE *)(&dwRandom))))
        {
            rgCertTypeInfo[dwIndex].dwRandomCAIndex = dwRandom % (pAE_General_Info->dwCA);
        }
        else
            rgCertTypeInfo[dwIndex].dwRandomCAIndex = 0;

        
        //enroll
        dwStatus=0;

        //report progress
        if(pAE_General_Info->fUIProcess)
        {
            //continue if user choose CANCEL in view RA dialogue
            if(!AEUIProgressReport(FALSE, &(rgCertTypeInfo[dwIndex]),pAE_General_Info->hwndDlg, pAE_General_Info->hCancelEvent))
            {
                AEUIProgressAdvance(pAE_General_Info);
                continue;
            }

        }

        if(AEDoEnrollment(  pAE_General_Info->hwndDlg ? pAE_General_Info->hwndDlg : pAE_General_Info->hwndParent,
                            pAE_General_Info->hCancelEvent,
                            pAE_General_Info->fUIProcess,
                            pAE_General_Info->dwLogLevel,
                            pAE_General_Info->hToken,
                            pAE_General_Info->fMachine,
                            pAE_General_Info->wszMachineName,
                            &(rgCertTypeInfo[dwIndex]), 
                            pAE_General_Info->dwCA,
                            pAE_General_Info->rgCAInfo,
                            &dwStatus))
        {
            //mark the status
            if(CRYPTUI_WIZ_CERT_REQUEST_STATUS_SUCCEEDED == dwStatus)
                rgCertTypeInfo[dwIndex].dwStatus=CERT_REQUEST_STATUS_OBTAINED;
        }
        else
        {
            //if renewal failed, we try to re-enrollment if no RA is required
            if((rgCertTypeInfo[dwIndex].fRenewal) && (FALSE == (rgCertTypeInfo[dwIndex].fNeedRA)))
            {
                 rgCertTypeInfo[dwIndex].fRenewal=FALSE;  
                 dwStatus=0;

                 if(AEDoEnrollment( pAE_General_Info->hwndDlg ? pAE_General_Info->hwndDlg : pAE_General_Info->hwndParent,
                                    pAE_General_Info->hCancelEvent,
                                    pAE_General_Info->fUIProcess,
                                    pAE_General_Info->dwLogLevel,
                                    pAE_General_Info->hToken,
                                    pAE_General_Info->fMachine,
                                    pAE_General_Info->wszMachineName,
                                    &(rgCertTypeInfo[dwIndex]), 
                                    pAE_General_Info->dwCA,
                                    pAE_General_Info->rgCAInfo,
                                    &dwStatus))
                 {
                    //mark the status
                    if(CRYPTUI_WIZ_CERT_REQUEST_STATUS_SUCCEEDED == dwStatus)
                        rgCertTypeInfo[dwIndex].dwStatus=CERT_REQUEST_STATUS_OBTAINED;
                 }
            }
        }

        //advance progress
        if(pAE_General_Info->fUIProcess)
        {
            AEUIProgressAdvance(pAE_General_Info);
        }

    }

    if(hProv)
        CryptReleaseContext(hProv, 0);

    return TRUE;
}


//-----------------------------------------------------------------------
//
//  AEIsDeletableCert
//      Decide if we should archive or delete the certificate
//
//-----------------------------------------------------------------------
BOOL AEIsDeletableCert(PCCERT_CONTEXT pCertContext, AE_GENERAL_INFO *pAE_General_Info)
{
    AE_CERTTYPE_INFO    *pCertType=NULL;
    BOOL                fDelete=FALSE;

    AE_TEMPLATE_INFO    AETemplateInfo;

    memset(&AETemplateInfo, 0, sizeof(AE_TEMPLATE_INFO));

    //only interested in certificate with template information
    if(!AERetrieveTemplateInfo(pCertContext, &AETemplateInfo))
        goto Ret;

    pCertType=AEFindTemplateInRequestTree(&AETemplateInfo, pAE_General_Info);

    if(NULL==pCertType)
        goto Ret;

    if(CT_FLAG_REMOVE_INVALID_CERTIFICATE_FROM_PERSONAL_STORE & (pCertType->dwEnrollmentFlag))
        fDelete=TRUE;
    else 
        fDelete=FALSE;
Ret:

    AEFreeTemplateInfo(&AETemplateInfo);

    return fDelete;
}

//-----------------------------------------------------------------------
//
//  AEArchiveObsoleteCertificates
//      archive old certificate after the enrollment/renewal
//
//      clean up the hUserDS store (delete the expired or revoked certificate)
//-----------------------------------------------------------------------
BOOL    AEArchiveObsoleteCertificates(AE_GENERAL_INFO *pAE_General_Info)
{
    AE_CERTTYPE_INFO    *rgCertTypeInfo = NULL;
    DWORD               dwIndex = 0;
    CRYPT_DATA_BLOB     Archived;
    BOOL                fArchived = FALSE;
    AE_CERT_INFO        AECertInfo;
    BOOL                fRepublish=FALSE;
	BYTE				rgbHash[SHA1_HASH_LENGTH];
	CRYPT_HASH_BLOB		blobHash;
	BOOL				fHash=FALSE;

    HCERTSTORE          hUserDS = NULL;
    PCCERT_CONTEXT      pCertContext = NULL;
    PCCERT_CONTEXT      pMyContext = NULL;
    PCCERT_CONTEXT      pDSContext = NULL;
	PCCERT_CONTEXT		pIssuedContext = NULL;

    rgCertTypeInfo = pAE_General_Info->rgCertTypeInfo;

    if(NULL == rgCertTypeInfo)
        return FALSE;

    memset(&Archived, 0, sizeof(CRYPT_DATA_BLOB));
    memset(&AECertInfo, 0, sizeof(AE_CERT_INFO));

    //open the UserDS store
    if(!(pAE_General_Info->fMachine))
    {
    	hUserDS = AEOpenUserDSStore(pAE_General_Info, 0);
    }

    for(dwIndex=0; dwIndex < pAE_General_Info->dwCertType; dwIndex++)
    {
		fHash=FALSE;
		fRepublish=FALSE;

        if(CERT_REQUEST_STATUS_OBTAINED == rgCertTypeInfo[dwIndex].dwStatus)
        {
			//get the hash of newly enrolled certificate
			blobHash.cbData=SHA1_HASH_LENGTH;
			blobHash.pbData=rgbHash;

			if(rgCertTypeInfo[dwIndex].hIssuedStore)
			{
				if(pIssuedContext = CertEnumCertificatesInStore(
									rgCertTypeInfo[dwIndex].hIssuedStore, NULL))
				{
					if(CryptHashCertificate(
						NULL,             
						0,
						X509_ASN_ENCODING,
						pIssuedContext->pbCertEncoded,
						pIssuedContext->cbCertEncoded,
						blobHash.pbData,
						&(blobHash.cbData)))
					{
						fHash=TRUE;
					}
				}

				//free the cert context
				if(pIssuedContext)
				{
                    CertFreeCertificateContext(pIssuedContext);
                    pIssuedContext = NULL;
				}
			}

            while(pCertContext = CertEnumCertificatesInStore(
                    rgCertTypeInfo[dwIndex].hArchiveStore, pCertContext))
            {
                //archive or delete the certificate from my store
                pMyContext = FindCertificateInOtherStore(
                        pAE_General_Info->hMyStore,
                        pCertContext);


                if(pMyContext)
                {
					//set the Hash of the newly enrolled certificate
					if(fHash)
					{
						CertSetCertificateContextProperty(
											pMyContext,
											CERT_RENEWAL_PROP_ID,
											0,
											&blobHash);
					}

                    if(AEIsDeletableCert(pMyContext, pAE_General_Info))
                    {
                        CertDeleteCertificateFromStore(CertDuplicateCertificateContext(pMyContext));
                    }
                    else
                    {
                        // We force an archive on the old cert and close it.
                        CertSetCertificateContextProperty(pMyContext,
                                                          CERT_ARCHIVED_PROP_ID,
                                                          0,
                                                          &Archived);

                        fArchived=TRUE;
                    }

                    CertFreeCertificateContext(pMyContext);
                    pMyContext = NULL;
                }

                //check the DS store. remove the certificates from DS store
                if(hUserDS)
                {
                    if(pMyContext = FindCertificateInOtherStore(
                            hUserDS,
                            pCertContext))
                    {
                        CertDeleteCertificateFromStore(pMyContext);
                        pMyContext = NULL;
                        fRepublish=TRUE;
                    }
                }
            }
        }
    }


    //now we are done with archiving, we clean up user DS store
   if(AUTO_ENROLLMENT_ENABLE_MY_STORE_MANAGEMENT & (pAE_General_Info->dwPolicy))
   {
    	if(hUserDS)
        {
            while(pDSContext = CertEnumCertificatesInStore(hUserDS, pDSContext))
            {
                AEValidateCertificateInfo(pAE_General_Info, 
                    NULL,                //do not evaluate soon to expire
                    FALSE,               //do not valid private key
                    pDSContext, 
                    &AECertInfo);

                if(FALSE == AECertInfo.fRenewal) 
                {
                    CertDeleteCertificateFromStore(CertDuplicateCertificateContext(pDSContext));
                    fRepublish=TRUE;
                }

                memset(&AECertInfo, 0, sizeof(AE_CERT_INFO));
            }
        }
   }

   //we have to republish the certificates as we have rewritten the user DS store
   //CA might has just published to the location
   if(fRepublish)
   {
       if(hUserDS)
       {
            for(dwIndex=0; dwIndex < pAE_General_Info->dwCertType; dwIndex++)
            {
                if(CERT_REQUEST_STATUS_OBTAINED == rgCertTypeInfo[dwIndex].dwStatus)
                {
                    if((rgCertTypeInfo[dwIndex].hIssuedStore) && 
                       (CT_FLAG_PUBLISH_TO_DS & rgCertTypeInfo[dwIndex].dwEnrollmentFlag)
                      )
                    {
                        pCertContext=NULL;
                        while(pCertContext = CertEnumCertificatesInStore(
                                rgCertTypeInfo[dwIndex].hIssuedStore, pCertContext))
                        {
                            CertAddCertificateContextToStore(hUserDS, 
                                                              pCertContext,
                                                              CERT_STORE_ADD_USE_EXISTING,
                                                              NULL);
                        }
                    }
                }
            }
       }
   }
   
   
   //report the event if archival has happened
    if(fArchived)
        AELogAutoEnrollmentEvent(pAE_General_Info->dwLogLevel, FALSE, S_OK, EVENT_ARCHIVE_CERT,                              
                 pAE_General_Info->fMachine, pAE_General_Info->hToken, 0);

    if(hUserDS)
        CertCloseStore(hUserDS, 0);

    return TRUE;
}

//-----------------------------------------------------------------------
//
//  AERemoveSupersedeActive
//      Remove supersedeActive flag after any successful the enrollment/renewal
//
//-----------------------------------------------------------------------
BOOL    AERemoveSupersedeActive(AE_GENERAL_INFO *pAE_General_Info)
{
    AE_CERTTYPE_INFO    *rgCertTypeInfo = NULL;
    DWORD               dwIndex = 0;
    DWORD               dwActiveIndex = 0;
    DWORD               dwMarkIndex = 0;


    rgCertTypeInfo = pAE_General_Info->rgCertTypeInfo;

    if(NULL == rgCertTypeInfo)
        return FALSE;

    for(dwIndex=0; dwIndex < pAE_General_Info->dwCertType; dwIndex++)
    {
        if(CERT_REQUEST_STATUS_OBTAINED == rgCertTypeInfo[dwIndex].dwStatus)
        {
             for(dwActiveIndex=0; dwActiveIndex < rgCertTypeInfo[dwIndex].dwActive; dwActiveIndex++)
             {
                dwMarkIndex = rgCertTypeInfo[dwIndex].prgActive[dwActiveIndex];
                rgCertTypeInfo[dwMarkIndex].dwStatus=CERT_REQUEST_STATUS_OBTAINED;
             }
        }
    }


    return TRUE;
}

//-----------------------------------------------------------------------
//
//  AEEnrollmentWalker
//
//      This functin performs enrollment tasks 
//
//
//-----------------------------------------------------------------------
BOOL    AEEnrollmentWalker(AE_GENERAL_INFO *pAE_General_Info)
{

    BOOL    fResult = FALSE;

    //we need to set the range for the progress bar in the 
    //UI case
    if((pAE_General_Info->fUIProcess) && (pAE_General_Info->hwndDlg))
    {
        //set the range
        if(0 != (pAE_General_Info->dwUIEnrollCount))
        {
            SendMessage(GetDlgItem(pAE_General_Info->hwndDlg, IDC_ENROLL_PROGRESS),
                        PBM_SETRANGE,
                        0,
                        MAKELPARAM(0, ((pAE_General_Info->dwUIEnrollCount) & (0xFFFF)))
                        );


            SendMessage(GetDlgItem(pAE_General_Info->hwndDlg, IDC_ENROLL_PROGRESS),
                        PBM_SETSTEP, 
                        (WPARAM)1, 
                        0);

            SendMessage(GetDlgItem(pAE_General_Info->hwndDlg, IDC_ENROLL_PROGRESS),
                        PBM_SETPOS, 
                        (WPARAM)0, 
                        0);
        }
    }

    //retrieve the pending request.  Mark the status to obtained if the
    //certificate is issued and of the correct version
    if(AUTO_ENROLLMENT_ENABLE_PENDING_FETCH & (pAE_General_Info->dwPolicy))
    {
        if(FALSE == pAE_General_Info->fUIProcess)
        {
            if(!AEProcessPendingRequest(pAE_General_Info))
                goto Ret;
        }
        else
        {
            if(!AEProcessUIPendingRequest(pAE_General_Info))
                goto Ret;
        }
    }

    //remove duplicated requests based on "Supersede" relationship
    //supress active templates that are superseded by other templates
    if(!AEManageSupersedeRequests(pAE_General_Info))
        goto Ret; 

    //do enrollment/renewal
    if(!AEEnrollmentCertificates(pAE_General_Info, CERT_REQUEST_STATUS_ACTIVE))
        goto Ret;

    
    //We try to get the superseded templates if supserseding templates failed.
    //Only for machine for the case of two V2 DC templates.
    if(TRUE == pAE_General_Info->fMachine)
    {
        //remove supersedeActive based on the obtained flag
        if(!AERemoveSupersedeActive(pAE_General_Info))
            goto Ret;

        //do enrollment/renewal again since we migh fail to get superseding templates
        if(!AEEnrollmentCertificates(pAE_General_Info, CERT_REQUEST_STATUS_SUPERSEDE_ACTIVE))
            goto Ret;
    }

    fResult = TRUE;

Ret:

    return fResult;
}

//-----------------------------------------------------------------------------
//
// AEUIProgressAdvance
//
//      Increase the progress bar by one step
//-----------------------------------------------------------------------------
BOOL   AEUIProgressAdvance(AE_GENERAL_INFO *pAE_General_Info)
{
    BOOL    fResult=FALSE;

    if(NULL==pAE_General_Info)
        goto Ret;

    if(NULL==(pAE_General_Info->hwndDlg))
        goto Ret;

    //check if CANCEL button is clicked
    if(AECancelled(pAE_General_Info->hCancelEvent))
    {
        fResult=TRUE;
        goto Ret;
    }

    //advance the progress bar
    SendMessage(GetDlgItem(pAE_General_Info->hwndDlg, IDC_ENROLL_PROGRESS),
        PBM_STEPIT,
        0,
        0);

    fResult=TRUE;

Ret:

    return fResult;
}

//-----------------------------------------------------------------------------
//
// AEUIGetNameFromCert
//
//      Retrieve a unique string to identify the certificate. 
//-----------------------------------------------------------------------------
BOOL    AEUIGetNameFromCert(PCCERT_CONTEXT pCertContext, LPWSTR *ppwszRACert)
{

    BOOL                fResult=FALSE;
    DWORD               dwChar=0;
    DWORD               cbOID=0;
    PCCRYPT_OID_INFO    pOIDInfo=NULL;

    LPWSTR              pwszRACert=NULL;
    AE_TEMPLATE_INFO    TemplateInfo;
    LPSTR               szOID=NULL;

    if((NULL==pCertContext) || (NULL==ppwszRACert))
        goto Ret;

    *ppwszRACert=NULL;
    
    memset(&TemplateInfo, 0, sizeof(TemplateInfo));

    //get the template name first
    if(!AERetrieveTemplateInfo(pCertContext, &TemplateInfo))
        goto Ret;
    
    if(TemplateInfo.pwszName)
    {
        pwszRACert=(LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * (wcslen(TemplateInfo.pwszName) + 1));
        if(NULL == pwszRACert)
            goto Ret;

        wcscpy(pwszRACert, TemplateInfo.pwszName);
    }
    else
    {
        if(NULL==(TemplateInfo.pwszOid))
            goto Ret;

        //find the OID
        if(0 == (cbOID = WideCharToMultiByte(CP_ACP, 
                                  0,
                                  TemplateInfo.pwszOid,
                                  -1,
                                  NULL,
                                  0,
                                  NULL,
                                  NULL)))
            goto Ret;

        szOID=(LPSTR)LocalAlloc(LPTR, cbOID);

        if(NULL==szOID)
            goto Ret;

        if(0 == WideCharToMultiByte(CP_ACP, 
                                  0,
                                  TemplateInfo.pwszOid,
                                  -1,
                                  szOID,
                                  cbOID,
                                  NULL,
                                  NULL))
            goto Ret;
            
        pOIDInfo=CryptFindOIDInfo(
                    CRYPT_OID_INFO_OID_KEY,
                    szOID,
                    CRYPT_TEMPLATE_OID_GROUP_ID);


        if(pOIDInfo)
        {
            if(pOIDInfo->pwszName)
            {
                pwszRACert=(LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * (wcslen(pOIDInfo->pwszName) + 1));
                if(NULL== pwszRACert)
                    goto Ret;

                wcscpy(pwszRACert, pOIDInfo->pwszName);
            }
        }

    }

    //if template name does not exist.  Get the subject name for now
  /*  if(NULL==pwszRACert)
    {
        if(0 == (dwChar=CertGetNameStringW(
                    pCertContext,
                    CERT_NAME_SIMPLE_DISPLAY_TYPE,
                    0,
                    NULL,
                    NULL,
                    0)))
            goto Ret;

        pwszRACert=(LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * (dwChar));
        if(NULL== pwszRACert)
            goto Ret;

        if(0 == (dwChar=CertGetNameStringW(
                    pCertContext,
                    CERT_NAME_SIMPLE_DISPLAY_TYPE,
                    0,
                    NULL,
                    pwszRACert,
                    dwChar)))
            goto Ret;
    } */

    *ppwszRACert = pwszRACert;
    pwszRACert=NULL;

    fResult=TRUE;

Ret:

    if(pwszRACert)
        LocalFree(pwszRACert);

    if(szOID)
        LocalFree(szOID);

    AEFreeTemplateInfo(&TemplateInfo);


    return fResult;

}

//-----------------------------------------------------------------------------
//
//  AEGetRACertInfo
//
//-----------------------------------------------------------------------------
BOOL    AEGetRACertInfo(PCERT_CONTEXT   pRAContext,  
                        LPWSTR          pwszRATemplate,
                        LPWSTR          *ppwszRACertInfo)
{
    BOOL        fResult=FALSE;
    UINT        idsMessage=0;
    DWORD       dwSize=0;

    LPWSTR      pwszIssuer=NULL;

    if(NULL==pRAContext)
        goto Ret;

    if(pwszRATemplate)
        idsMessage=IDS_VIEW_RA_INFO;
    else
        idsMessage=IDS_VIEW_RA_INFO_GENERAL;

    //the cert has to have an issuer
    if(0 == (dwSize=CertNameToStrW(
            ENCODING_TYPE,
            &(pRAContext->pCertInfo->Issuer),
            CERT_X500_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
            NULL,
            0)))
        goto Ret;

    pwszIssuer=(LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * dwSize);
    if(NULL==pwszIssuer)
        goto Ret;

    if(0 == CertNameToStrW(
            ENCODING_TYPE,
            &(pRAContext->pCertInfo->Issuer),
            CERT_X500_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
            pwszIssuer,
            dwSize))
        goto Ret;


    if(!FormatMessageUnicode(
            ppwszRACertInfo, 
            idsMessage, 
            pwszIssuer,
            pwszRATemplate))
        goto Ret;

    fResult=TRUE;

Ret:

    if(pwszIssuer)
        LocalFree(pwszIssuer);

    return fResult;
}



//-----------------------------------------------------------------------------
//
//  WinProc for the view RA certificate dialogue
//
//-----------------------------------------------------------------------------
INT_PTR CALLBACK AEViewRADlgProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL                            fPropertyChanged = FALSE;
    AE_VIEW_RA_INFO                 *pAEViewRAInfo = NULL;
    CRYPTUI_VIEWCERTIFICATE_STRUCT  CertViewStruct;

    LPWSTR                          pwszRACertInfo=NULL;

    switch (msg) 
    {
        case WM_INITDIALOG:
                pAEViewRAInfo=(AE_VIEW_RA_INFO *)lParam;

                if(NULL==pAEViewRAInfo)
                    break;

                SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)pAEViewRAInfo);

                //display the RA template and issuer dynamically
                if(AEGetRACertInfo(pAEViewRAInfo->pRAContext,  
                                    pAEViewRAInfo->pwszRATemplate,
                                    &pwszRACertInfo))
                {
                    SetDlgItemTextW(hwndDlg, IDC_EDIT3, pwszRACertInfo);

                    LocalFree((HLOCAL)pwszRACertInfo);

                }

                return TRUE;
            break;

         case WM_NOTIFY:
            break;

        case WM_CLOSE:
                EndDialog(hwndDlg, IDC_BUTTON3);
                return TRUE;
            break;

        case WM_COMMAND:
                switch (LOWORD(wParam))
                {
                    //view certificate
                    case IDC_BUTTON1:
                            if(NULL==(pAEViewRAInfo=(AE_VIEW_RA_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break; 
                            
                            if(NULL==pAEViewRAInfo->pRAContext)
                                break;

                            //show the certificate
                            memset(&CertViewStruct, 0, sizeof(CRYPTUI_VIEWCERTIFICATE_STRUCT));
                            CertViewStruct.dwSize=sizeof(CRYPTUI_VIEWCERTIFICATE_STRUCT);
                            CertViewStruct.hwndParent=hwndDlg;
                            CertViewStruct.dwFlags=CRYPTUI_DISABLE_EDITPROPERTIES;
                            CertViewStruct.pCertContext=pAEViewRAInfo->pRAContext;

                            fPropertyChanged=FALSE;

                            CryptUIDlgViewCertificate(&CertViewStruct, &fPropertyChanged);

                        return TRUE;

                    //OK
                    case IDC_BUTTON2:
                        EndDialog(hwndDlg, IDC_BUTTON2);
                        return TRUE;
                }
            break;

        default:
                return FALSE;
    }

    return FALSE;
}                             
//-----------------------------------------------------------------------------
//
// AEUIProgressReport
//
//      Report the current enrollment action.  Return FALSE if no progress status
// can be reported.
//-----------------------------------------------------------------------------
BOOL    AEUIProgressReport(BOOL fPending, AE_CERTTYPE_INFO *pCertType, HWND hwndDlg, HANDLE hCancelEvent)
{
    BOOL                fResult=FALSE;
    UINT                idsMessage=0;
    INT_PTR             ret=0;
    AE_VIEW_RA_INFO     AEViewRAInfo;

    LPWSTR              *awszFriendlyName=NULL;
    LPWSTR              pwszRACert=NULL;
    LPWSTR              pwszReport=NULL;

    memset(&AEViewRAInfo, 0, sizeof(AE_VIEW_RA_INFO));

    if((NULL==pCertType) || (NULL==hwndDlg))
        goto Ret;

    if(NULL==(pCertType->hCertType))
        goto Ret;

    if(AECancelled(hCancelEvent))
    {
        fResult=TRUE;
        goto Ret;
    }

    if(fPending)
        idsMessage=IDS_REPORT_PENDING;
    else
    {
        if((pCertType->fRenewal) && (pCertType->pOldCert))
        {
            if(pCertType->fNeedRA)
            {
                if(FALSE == (pCertType->fCrossRA))
                    idsMessage=IDS_REPORT_RENEW;
                else
                    idsMessage=IDS_REPORT_ENROLL_RA;
            }
            else
                idsMessage=IDS_REPORT_RENEW;
        }
        else
            idsMessage=IDS_REPORT_ENROLL;
    }

    //retrieve the template's friendly name
    if(S_OK != CAGetCertTypePropertyEx(
                  pCertType->hCertType, 
                  CERTTYPE_PROP_FRIENDLY_NAME,
                  &awszFriendlyName))
        goto Ret;

    if(NULL==awszFriendlyName)
        goto Ret;

    if(NULL==(awszFriendlyName[0]))
        goto Ret;


    //retrieve the RA certificate's template name
    if(IDS_REPORT_ENROLL_RA == idsMessage)
    {
        if(!AEUIGetNameFromCert(pCertType->pOldCert, &pwszRACert))
        {
            pwszRACert=NULL;
        }
    }

    if(!FormatMessageUnicode(&pwszReport, idsMessage, awszFriendlyName[0]))
        goto Ret;

    if(0 == SetDlgItemTextW(hwndDlg, IDC_EDIT2, pwszReport))
        goto Ret;

    //we will give user an opportunity to view the RA certificate before we go on
    //format the view message
    if(IDS_REPORT_ENROLL_RA != idsMessage)
    {
        //no need to do anything more
        fResult=TRUE;
        goto Ret;
    }

    AEViewRAInfo.pRAContext=pCertType->pOldCert;
    AEViewRAInfo.pwszRATemplate=pwszRACert;

    //ask user if he/she wants to view the RA certificate
    ret=DialogBoxParam(g_hmodThisDll, 
                 (LPCWSTR)MAKEINTRESOURCE(IDD_VIEW_RA_CERTIFICATE_DLG),
                 hwndDlg, 
                 AEViewRADlgProc,
                 (LPARAM)(&AEViewRAInfo));

    fResult=TRUE;

Ret:

    if(pwszRACert)
        LocalFree(pwszRACert);

    if(awszFriendlyName)
        CAFreeCertTypeProperty(pCertType->hCertType, awszFriendlyName);

    if(pwszReport)
        LocalFree((HLOCAL) pwszReport);
    
    return fResult;
}



//-----------------------------------------------------------------------------
//
//  the call back function to compare summary column
//
//-----------------------------------------------------------------------------
int CALLBACK CompareSummary(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    AE_CERTTYPE_INFO    *pCertTypeOne=NULL;
    AE_CERTTYPE_INFO    *pCertTypeTwo=NULL;
    DWORD               dwColumn=0;
    int                 iCompare=0;
    
    LPWSTR              pwszOne=NULL;
    LPWSTR              pwszTwo=NULL;

    pCertTypeOne=(AE_CERTTYPE_INFO *)lParam1;
    pCertTypeTwo=(AE_CERTTYPE_INFO *)lParam2;

    dwColumn=(DWORD)lParamSort;

    if((NULL==pCertTypeOne) || (NULL==pCertTypeTwo))
        goto Ret;

    switch(dwColumn & 0x0000FFFF)
    {
       case AE_SUMMARY_COLUMN_TYPE:
	            //we should use wcsicoll instead of wcsicmp since wcsicoll use the
	            //lexicographic order of current code page.
	            iCompare=CompareStringW(LOCALE_USER_DEFAULT,
						            NORM_IGNORECASE,
						            pCertTypeOne->awszDisplay[0],
						            -1,
						            pCertTypeTwo->awszDisplay[0],
						            -1);
            break;

       case AE_SUMMARY_COLUMN_REASON:
                pwszOne=(LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * (MAX_DN_SIZE));
                pwszTwo=(LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * (MAX_DN_SIZE));

                if((NULL==pwszOne) || (NULL==pwszTwo))
                    goto Ret;


                if(0 == LoadStringW(g_hmodThisDll, 
                                pCertTypeOne->idsSummary, 
                                pwszOne, 
                                MAX_DN_SIZE))
                    goto Ret;


                if(0 == LoadStringW(g_hmodThisDll, 
                                pCertTypeTwo->idsSummary, 
                                pwszTwo, 
                                MAX_DN_SIZE))
                    goto Ret;

	            //we should use wcsicoll instead of wcsicmp since wcsicoll use the
	            //lexicographic order of current code page.
	            iCompare=CompareStringW(LOCALE_USER_DEFAULT,
						            NORM_IGNORECASE,
						            pwszOne,
						            -1,
						            pwszTwo,
						            -1);
           
            
           break;
       default:
                goto Ret;
            break;
    }

    switch(iCompare)
    {
        case CSTR_LESS_THAN:

                iCompare=-1;
            break;
            
        case CSTR_EQUAL:

                iCompare=0;
            break;

        case CSTR_GREATER_THAN:

                iCompare=1;
            break;

        default:
                goto Ret;
            break;
    }

    if(dwColumn & SORT_COLUMN_DESCEND)
        iCompare = 0-iCompare;

Ret:

    if(pwszOne)
        LocalFree(pwszOne);

    if(pwszTwo)
        LocalFree(pwszTwo);

    return iCompare;
}


//-----------------------------------------------------------------------------
//
//  AEDisplaySummaryInfo
//
//-----------------------------------------------------------------------------
BOOL    AEDisplaySummaryInfo(HWND hWndListView, AE_GENERAL_INFO *pAE_General_Info)
{
    BOOL                fResult=FALSE;
    AE_CERTTYPE_INFO    *rgCertTypeInfo = NULL;
    DWORD               dwIndex =0;
    DWORD               dwItem=0;
    LV_ITEMW            lvItem;   
    WCHAR               wszReason[MAX_DN_SIZE];
    AE_CERTTYPE_INFO    *pCertType=NULL;

    if((NULL==hWndListView) || (NULL==pAE_General_Info))
        goto Ret;

    rgCertTypeInfo = pAE_General_Info->rgCertTypeInfo;

    if(NULL == rgCertTypeInfo)
        goto Ret;

     // set up the fields in the list view item struct that don't change from item to item
    lvItem.mask = LVIF_TEXT | LVIF_PARAM;
    lvItem.state = 0;
    lvItem.stateMask = 0;
    lvItem.iItem=0;
    lvItem.iSubItem=0;
    lvItem.iImage = 0;
    lvItem.lParam = NULL;

    for(dwIndex=0; dwIndex < pAE_General_Info->dwCertType; dwIndex++)
    {
        if((TRUE == rgCertTypeInfo[dwIndex].fUIActive) && (0 != rgCertTypeInfo[dwIndex].idsSummary))
        {
            if(0 != LoadStringW(g_hmodThisDll, 
                                rgCertTypeInfo[dwIndex].idsSummary, 
                                wszReason, 
                                MAX_DN_SIZE))
            {
                lvItem.iItem=dwItem;
                lvItem.iSubItem=0;
                dwItem++;

                pCertType=&(rgCertTypeInfo[dwIndex]);

                lvItem.lParam = (LPARAM)(pCertType);

                //template name
                lvItem.pszText=rgCertTypeInfo[dwIndex].awszDisplay[0];

                ListView_InsertItem(hWndListView, &lvItem);

                //reason
                lvItem.iSubItem++;

                ListView_SetItemText(hWndListView, lvItem.iItem, lvItem.iSubItem, wszReason);
            }
        }
    }

    fResult=TRUE;

Ret:

    return fResult;
}

//-----------------------------------------------------------------------------
//
//  WinProc for the summary page
//
//-----------------------------------------------------------------------------
INT_PTR CALLBACK AESummaryDlgProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{

    AE_GENERAL_INFO             *pAE_General_Info=NULL;
    HWND                        hWndListView=NULL;
    UINT                        rgIDS[]={IDS_COLUMN_TYPE,
                                        IDS_COLUMN_REASON};
    DWORD                       dwIndex=0;
    DWORD                       dwCount=0;
    LV_COLUMNW                  lvC;
    WCHAR                       wszText[AE_SUMMARY_COLUMN_SIZE];
    NM_LISTVIEW                 *pnmv=NULL;
    DWORD                       dwSortParam=0;
    static DWORD                rgdwSortParam[]=
                                    {AE_SUMMARY_COLUMN_TYPE | SORT_COLUMN_ASCEND,
                                    AE_SUMMARY_COLUMN_REASON | SORT_COLUMN_DESCEND};

    switch (msg) 
    {
        case WM_INITDIALOG:
                pAE_General_Info=(AE_GENERAL_INFO *)lParam;

                if(NULL==pAE_General_Info)
                    break;

                SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)pAE_General_Info);

                //init the list view control
                //add the colums to the list view
                hWndListView = GetDlgItem(hwndDlg, IDC_LIST2);

                if(NULL==hWndListView)
                    break;

                dwCount=sizeof(rgIDS)/sizeof(rgIDS[0]);

                //set up the common info for the column
                memset(&lvC, 0, sizeof(LV_COLUMNW));

                lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
                lvC.fmt = LVCFMT_LEFT;      // Left-align the column.
                lvC.cx = 150;                // Width of the column, in pixels.
                lvC.iSubItem=0;
                lvC.pszText = wszText;      // The text for the column.

                //insert the column one at a time
                for(dwIndex=0; dwIndex < dwCount; dwIndex++)
                {
                    //get the column header
                    wszText[0]=L'\0';

                    if(0 != LoadStringW(g_hmodThisDll, rgIDS[dwIndex], wszText, AE_SUMMARY_COLUMN_SIZE))
                    {
                        ListView_InsertColumn(hWndListView, dwIndex, &lvC);
                    }
                }

                // set the style in the list view so that it highlights an entire line
                SendMessage(hWndListView, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT);

                AEDisplaySummaryInfo(hWndListView, pAE_General_Info);

                //autosize the columns
                for(dwIndex=0; dwIndex < dwCount; dwIndex++)
                {
                    ListView_SetColumnWidth(hWndListView, dwIndex, LVSCW_AUTOSIZE);
                }

                //sort 1st column of the list view
                dwSortParam=rgdwSortParam[0];

                SendDlgItemMessage(hwndDlg,
                    IDC_LIST2,
                    LVM_SORTITEMS,
                    (WPARAM) (LPARAM) dwSortParam,
                    (LPARAM) (PFNLVCOMPARE)CompareSummary);

                return TRUE;
            break;

         case WM_NOTIFY:
                switch (((NMHDR FAR *) lParam)->code)
                {
                    //the column has been changed
                    case LVN_COLUMNCLICK:

                            pnmv = (NM_LISTVIEW *) lParam;

                            dwSortParam=0;

                            //get the column number
                            switch(pnmv->iSubItem)
                            {
                                case 0:
                                case 1:
                                        dwSortParam=rgdwSortParam[pnmv->iSubItem];
                                    break;
                                default:
                                        dwSortParam=0;
                                    break;
                            }

                            if(0!=dwSortParam)
                            {
                                //remember to flip the ascend ording
                                if(dwSortParam & SORT_COLUMN_ASCEND)
                                {
                                    dwSortParam &= 0x0000FFFF;
                                    dwSortParam |= SORT_COLUMN_DESCEND;
                                }
                                else
                                {
                                    if(dwSortParam & SORT_COLUMN_DESCEND)
                                    {
                                        dwSortParam &= 0x0000FFFF;
                                        dwSortParam |= SORT_COLUMN_ASCEND;
                                    }
                                }

                                //sort the column
                                SendDlgItemMessage(hwndDlg,
                                    IDC_LIST2,
                                    LVM_SORTITEMS,
                                    (WPARAM) (LPARAM) dwSortParam,
                                    (LPARAM) (PFNLVCOMPARE)CompareSummary);

                                rgdwSortParam[pnmv->iSubItem]=dwSortParam;
                            }

                        break;
                }
            break;

        case WM_CLOSE:
                EndDialog(hwndDlg, IDC_BUTTON1);
                return TRUE;
            break;

        case WM_COMMAND:
                switch (LOWORD(wParam))
                {
                    case IDC_BUTTON1:
                        EndDialog(hwndDlg, IDC_BUTTON1);
                        return TRUE;
                }
            break;

        default:
                return FALSE;
    }

    return FALSE;
}                             


//-----------------------------------------------------------------------------
//
//  AEDisplaySummaryPage
//         
//-----------------------------------------------------------------------------
BOOL    AEDisplaySummaryPage(AE_GENERAL_INFO *pAE_General_Info)
{
    BOOL                fResult=FALSE;
    DWORD               dwIndex=0;
    BOOL                fSummary=FALSE;
    AE_CERTTYPE_INFO    *rgCertTypeInfo=NULL;
    AE_CERTTYPE_INFO    *pCertType=NULL;

    //decide if there is need to show the summary page.  
    //Checking for idsSummary for each template
    if(NULL == pAE_General_Info)
        goto Ret;

    if(NULL == (rgCertTypeInfo=pAE_General_Info->rgCertTypeInfo))
        goto Ret;

    for(dwIndex=0; dwIndex < pAE_General_Info->dwCertType; dwIndex++)
    {
        if((TRUE == rgCertTypeInfo[dwIndex].fUIActive) && (0 != rgCertTypeInfo[dwIndex].idsSummary))
        {
            fSummary=TRUE;
            break;
        }
    }

    //show the summary dialogue
    if(TRUE == fSummary)
    {
        if(pAE_General_Info->hwndDlg)
        {
            DialogBoxParam(g_hmodThisDll, 
                     (LPCWSTR)MAKEINTRESOURCE(IDD_USER_SUMMARY_DLG),
                     pAE_General_Info->hwndDlg, 
                     AESummaryDlgProc,
                     (LPARAM)(pAE_General_Info));
        }
    }

    fResult=TRUE;

Ret:
    return fResult;
}



//-----------------------------------------------------------------------------
//  WinProc for the autoenrollment progress window
//
//-----------------------------------------------------------------------------
INT_PTR CALLBACK progressDlgProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    AE_GENERAL_INFO         *pAE_General_Info = NULL;

    switch (msg) 
    {
        case WM_INITDIALOG:
                pAE_General_Info=(AE_GENERAL_INFO *)lParam;

                //copy the hwndDlg to the enrollment thread
                pAE_General_Info->hwndDlg=hwndDlg;

                //start the interacive enrollment thread
                if(1 != ResumeThread(pAE_General_Info->hThread))
                {   
                    pAE_General_Info->hwndDlg=NULL;

                    //we have to end the dialogue
                    EndDialog(hwndDlg, IDC_BUTTON1);
                    return TRUE;
                }

                SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)pAE_General_Info);

                return TRUE;
            break;

        case WM_NOTIFY:
            break;

        case WM_CLOSE:

                if(NULL==(pAE_General_Info=(AE_GENERAL_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                    break;

                //disable the cancel button
                EnableWindow(GetDlgItem(hwndDlg,IDC_BUTTON1), FALSE);

                //signal the cancel event
                if(pAE_General_Info->hCancelEvent)
                    SetEvent(pAE_General_Info->hCancelEvent);

                //close the dialogue if the enrollment work is completed
                if(WAIT_OBJECT_0 == WaitForSingleObject(pAE_General_Info->hCompleteEvent, 0))
                {
                    EndDialog(hwndDlg, IDC_BUTTON1);
                }
               
                return TRUE;

            break;

        case WM_COMMAND:
                switch (LOWORD(wParam))
                {
                    case IDC_BUTTON1:
                            if(NULL==(pAE_General_Info=(AE_GENERAL_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

                            //disable the cancel button
                            EnableWindow(GetDlgItem(hwndDlg,IDC_BUTTON1), FALSE);

                            //signal the cancel event
                            if(pAE_General_Info->hCancelEvent)
                                SetEvent(pAE_General_Info->hCancelEvent);


                        return TRUE;
                }
            break;

        default:
                return FALSE;
    }

    return FALSE;
}                             


//-----------------------------------------------------------------------------
//  AEInteractiveThreadProc
//
//      The thread procedue to do interactive enrollment
//-----------------------------------------------------------------------------
DWORD WINAPI AEInteractiveThreadProc(LPVOID lpParameter)
{
    BOOL                    fResult=FALSE;
    AE_GENERAL_INFO         *pAE_General_Info = NULL;

    if(NULL==lpParameter)
        return FALSE;

    __try
    {

        pAE_General_Info=(AE_GENERAL_INFO *)lpParameter;

        pAE_General_Info->fUIProcess=TRUE;
    
        fResult = AEEnrollmentWalker(pAE_General_Info);

        //show the summary page if not canceled
        if(!AECancelled(pAE_General_Info->hCancelEvent))
        {
            AEDisplaySummaryPage(pAE_General_Info);
        }

        //signal that the process is completed
        SetEvent(pAE_General_Info->hCompleteEvent);
        
        //signal the progress window that we are done
        if(pAE_General_Info->hwndDlg)
        {
                //click the close button
                SendMessage(pAE_General_Info->hwndDlg,
                            WM_CLOSE, //WM_COMMAND,
                            0, //IDC_BUTTON1,
                            NULL);
        }
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
    }
    
    return fResult;
}


//-----------------------------------------------------------------------------
//  AEInteractiveEnrollment
//
//      We are doing interactive enrollment
//-----------------------------------------------------------------------------
BOOL    AEInteractiveEnrollment(AE_GENERAL_INFO *pAE_General_Info)
{
    DWORD                       dwThreadID=0;
    BOOL                        fResult=FALSE;
    

    //create a notification event for cancel process
    pAE_General_Info->hCancelEvent=CreateEvent(
                    NULL,
                    TRUE,      // bmanual reset type           
                    FALSE,     // initial state
                    NULL);

    if(NULL==(pAE_General_Info->hCancelEvent))
        goto ret;

    //create a notification event for complete process
    pAE_General_Info->hCompleteEvent=CreateEvent(
                    NULL,
                    TRUE,      // bmanual reset type           
                    FALSE,     // initial state
                    NULL);

    if(NULL==(pAE_General_Info->hCompleteEvent))
        goto ret;

    //spawn a thread
    pAE_General_Info->hThread = CreateThread(NULL,
                            0,
                            AEInteractiveThreadProc,
                            pAE_General_Info,
                            CREATE_SUSPENDED,   //suspend execution
                            &dwThreadID);
    
    if(NULL==(pAE_General_Info->hThread))
        goto ret;

    //create the dialogue
    DialogBoxParam(
            g_hmodThisDll,
            MAKEINTRESOURCE(IDD_USER_AUTOENROLL_GENERAL_DLG),
            pAE_General_Info->hwndParent,      
            progressDlgProc,
            (LPARAM)(pAE_General_Info));

    //wait for thread to finish
    if(WAIT_FAILED == WaitForSingleObject(pAE_General_Info->hThread, INFINITE))
        goto ret;

    fResult=TRUE;

ret:

    //log the event
    if(!fResult)
    {
         AELogAutoEnrollmentEvent(
            pAE_General_Info->dwLogLevel,
            TRUE, 
            HRESULT_FROM_WIN32(GetLastError()), 
            EVENT_FAIL_INTERACTIVE_START, 
            pAE_General_Info->fMachine, 
            pAE_General_Info->hToken, 
            0);
    }


    return fResult;
}

//-----------------------------------------------------------------------------
//
//  WinProc for the confirmation to start certificate autoenrollment
//
//-----------------------------------------------------------------------------
INT_PTR CALLBACK AEConfirmDlgProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg) 
    {
        case WM_INITDIALOG:

                return TRUE;
            break;

        case WM_NOTIFY:
            break;

        case WM_CLOSE:
                EndDialog(hwndDlg, IDC_BUTTON2);
                return TRUE;
            break;

        case WM_COMMAND:
                switch (LOWORD(wParam))
                {
                    case IDC_BUTTON1:
                        EndDialog(hwndDlg, IDC_BUTTON1);
                        return TRUE;

                    case IDC_BUTTON2:
                        EndDialog(hwndDlg, IDC_BUTTON2);
                        return TRUE;
                }
            break;

        default:
                return FALSE;
    }

    return FALSE;
}                             

//-----------------------------------------------------------------------
//
//  AERegisterSysTrayApp 
//
//      This functin registers autoenrollment in the sys tray area
//  as an notification
//
//
//-----------------------------------------------------------------------
BOOL AERegisterSysTrayApp(HWND hwndParent)
{
    BOOL                        fResult=FALSE;
    BOOL                        fInit=FALSE;
    INT_PTR                     ret=0;
    DWORD                       dwError=0;

    CQueryContinue              *pCQueryContinue=NULL;


    if(FAILED(CoInitialize(NULL)))
	    goto Ret;

    fInit=TRUE;

    pCQueryContinue=new CQueryContinue();

    if(NULL==pCQueryContinue)
        goto Ret;

    if(S_OK != pCQueryContinue->DoBalloon())
        goto Ret;  

    //ask user if autoenrollment should be performed
    ret=DialogBox(g_hmodThisDll, 
                 (LPCWSTR)MAKEINTRESOURCE(IDD_USER_AUTOENROLL_INFO_DLG),
                 hwndParent, 
                 AEConfirmDlgProc);

    if(IDC_BUTTON1 != ret)
    {
        dwError=GetLastError();
        goto Ret;
    }
    
    fResult=TRUE;


Ret:

    if(pCQueryContinue)
    {
        delete pCQueryContinue;
    }

    if(fInit)
        CoUninitialize();

    return fResult;

}


//-----------------------------------------------------------------------
//
//  AEUIDisabled
//
//      Detect if the user notification balloon is disabled by user 
//  setting the autoenrollment registry key in current user
//
//
//-----------------------------------------------------------------------
BOOL    AEUIDisabled()
{
    BOOL    fResult=FALSE;
    
    HKEY    hKey=NULL;

    if(ERROR_SUCCESS == RegOpenKeyEx(
                HKEY_CURRENT_USER,                  // handle to open key
                AUTO_ENROLLMENT_DISABLE_KEY,        // subkey name
                0,                                  // reserved
                KEY_READ,                           // security access mask
                &hKey))                             // handle to open key
    {
        fResult=TRUE;
    }

    if(hKey)
        RegCloseKey(hKey);

    return fResult;
}

//-----------------------------------------------------------------------
//
//  AEUIRequired
//
//      Detect if the user notification balloon is needed
//
//
//-----------------------------------------------------------------------
BOOL    AEUIRequired(AE_GENERAL_INFO *pAE_General_Info)
{
    BOOL                fUI=FALSE;
    AE_CERTTYPE_INFO    *rgCertTypeInfo = NULL;
    DWORD               dwIndex = 0;

    if(NULL==pAE_General_Info)
        return FALSE;

    rgCertTypeInfo = pAE_General_Info->rgCertTypeInfo;

    pAE_General_Info->dwUIEnrollCount=0;

    if(NULL == rgCertTypeInfo)
        return FALSE;

    for(dwIndex=0; dwIndex < pAE_General_Info->dwCertType; dwIndex++)
    {
        if(rgCertTypeInfo[dwIndex].fUIActive)
        {
            if(CERT_REQUEST_STATUS_ACTIVE == rgCertTypeInfo[dwIndex].dwStatus)
            {
                fUI=TRUE;
                (pAE_General_Info->dwUIEnrollCount)++;
            }
        }
    }

    //add the pending count
    if(pAE_General_Info->dwUIPendCount)
    {
        fUI=TRUE;
        (pAE_General_Info->dwUIEnrollCount) +=(pAE_General_Info->dwUIPendCount); 
    }

    return fUI;  
}

                
//-----------------------------------------------------------------------
//
//  AEProcessEnrollment
//
//      This functin does the autoenrollment based on ACL and manage MY
//  store.
//
//
//-----------------------------------------------------------------------
BOOL  AEProcessEnrollment(HWND hwndParent, BOOL fMachine,   LDAP *pld, DWORD dwPolicy, DWORD dwLogLevel)
{
    BOOL                fResult=FALSE;

    AE_GENERAL_INFO     *pAE_General_Info=NULL;

    pAE_General_Info=(AE_GENERAL_INFO *)LocalAlloc(LPTR, sizeof(AE_GENERAL_INFO));

    if(NULL==pAE_General_Info)
        goto Ret;

    memset(pAE_General_Info, 0, sizeof(AE_GENERAL_INFO));

    if(NULL==pld)
        goto Ret;

    //we obtain all information needed for process enrollment
    pAE_General_Info->hwndParent = hwndParent;
    pAE_General_Info->pld = pld;
    pAE_General_Info->fMachine = fMachine;
    pAE_General_Info->dwPolicy = dwPolicy;
    pAE_General_Info->dwLogLevel = dwLogLevel;

    __try
    {

        if(!AERetrieveGeneralInfo(pAE_General_Info))
        {
            AELogAutoEnrollmentEvent(dwLogLevel,
                                TRUE, 
                                HRESULT_FROM_WIN32(GetLastError()), 
                                EVENT_FAIL_GENERAL_INFOMATION, 
                                fMachine, 
                                pAE_General_Info->hToken,
                                0);
            goto Ret;
        }

        if((0 == pAE_General_Info->dwCertType) || (NULL==pAE_General_Info->rgCertTypeInfo))
        {
            AELogAutoEnrollmentEvent(dwLogLevel, FALSE, S_OK, 
                EVENT_NO_CERT_TEMPLATE, fMachine, pAE_General_Info->hToken,0);

            AE_DEBUG((AE_WARNING, L"No CertType's available for auto-enrollment\n\r"));
            goto Ret;
        }

        //we build the auto-enrollment requests based on the ACL on the DS
        if(AUTO_ENROLLMENT_ENABLE_TEMPLATE_CHECK & (pAE_General_Info->dwPolicy))
        {
            if(!AEMarkAutoenrollment(pAE_General_Info))
                goto Ret;
        }

        //we build the auto-enrollment requests based on the ARCS store
        //this is enabled by default and can only be disabled if autoenrollment is 
        //completely disabled
        if(!AEMarkAEObject(pAE_General_Info))
            goto Ret;

        //manage MY store.  Check if we already have required certificates
        //we should always check my store with different behavior based on
        //AUTO_ENROLLMENT_ENABLE_MY_STORE_MANAGEMENT flag
        if(!AEManageAndMarkMyStore(pAE_General_Info))
                goto Ret;

        //manage UserDS store for user autoenrollment 
        if(!fMachine)
        {
            if(!AECheckUserDSStore(pAE_General_Info))
                goto Ret;
        }

        //manage pending request store.  Remove expired pending requests 
        if(AUTO_ENROLLMENT_ENABLE_PENDING_FETCH & (pAE_General_Info->dwPolicy))
        {
            if(!AECheckPendingRequests(pAE_General_Info))
                goto Ret;
        }

        //get CA information
        if(!AERetrieveCAInfo(pAE_General_Info->pld,
                             pAE_General_Info->fMachine,
                             pAE_General_Info->hToken,
                             &(pAE_General_Info->dwCA), 
                             &(pAE_General_Info->rgCAInfo)))
        {

            AELogAutoEnrollmentEvent(dwLogLevel, TRUE, HRESULT_FROM_WIN32(GetLastError()), 
                EVENT_FAIL_CA_INFORMATION, fMachine, pAE_General_Info->hToken, 0);


            AE_DEBUG((AE_ERROR, L"Unable to retrieve CA information (%lx)\n\r", GetLastError()));

            goto Ret;
        }

        if((0 == pAE_General_Info->dwCA) || (NULL==pAE_General_Info->rgCAInfo))
        {
            //we do not have any CAs on the domain.  All we need to do is to archive

            //archive old certificate after the enrollment/renewal
            AEArchiveObsoleteCertificates(pAE_General_Info);

            AELogAutoEnrollmentEvent(dwLogLevel, FALSE, S_OK, 
                EVENT_NO_CA, fMachine, pAE_General_Info->hToken, 0);

            AE_DEBUG((AE_WARNING, L"No CA's available for auto-enrollment\n\r"));

            goto Ret;
        }

        //we check if active templates do have a CA that we can enroll for
        if(!AEManageActiveTemplates(pAE_General_Info))
            goto Ret;

        //perform autoenrollment as the background 
        pAE_General_Info->fUIProcess=FALSE;
        if(!AEEnrollmentWalker(pAE_General_Info))
            goto Ret;

        //perform autoenrollment as a sys tray application for user only
        if(FALSE == fMachine)
        {
            //test if the notification balloon is disabled
            if(!AEUIDisabled())
            {
                //test if the notification balloon is needed
                if(AEUIRequired(pAE_General_Info))
                {
                    //register the sys tray application
                    if(AERegisterSysTrayApp(pAE_General_Info->hwndParent))
                    {
                        //perform autoenrollment in interactive mode
                        AEInteractiveEnrollment(pAE_General_Info);
                    }
                }
            }
        }

        //archive old certificate after the enrollment/renewal
        if(!AEArchiveObsoleteCertificates(pAE_General_Info))
            goto Ret;

    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        goto Ret;
    }

    fResult=TRUE;

Ret:

    //free memory only if no thread is created
    if(pAE_General_Info)
    {
        AEFreeGeneralInfo(pAE_General_Info);
        LocalFree(pAE_General_Info);
    }

    return fResult;
    
}

//-----------------------------------------------------------------------
//
//  AEExpress
//
//      Detect if the user autoenrollment has the express key set.  If the 
//  Express key is set, user autoenrollment will not wait for machine 
//  autoenrollment to complete on root certificates download
//
//
//-----------------------------------------------------------------------
BOOL    AEExpress()
{
    BOOL    fResult=FALSE;
    
    HKEY    hKey=NULL;

    if(ERROR_SUCCESS == RegOpenKeyEx(
                HKEY_CURRENT_USER,                  // handle to open key
                AUTO_ENROLLMENT_EXPRESS_KEY,        // subkey name
                0,                                  // reserved
                KEY_READ,                           // security access mask
                &hKey))                             // handle to open key
    {
        fResult=TRUE;
    }

    if(hKey)
        RegCloseKey(hKey);

    return fResult;
}

//-----------------------------------------------------------------------
//
//  AEMainThreadProc
//
//      The background thread for non-blocking autoenrollment background
//  processing.
//
//-----------------------------------------------------------------------
DWORD WINAPI AEMainThreadProc(LPVOID lpParameter)
{
    HRESULT         hr=S_OK;
    BOOL            fMachine=FALSE;
    DWORD           dwPolicy=0;
    DWORD           dwLogLevel=STATUS_SEVERITY_ERROR;
    HWND            hwndParent=0;
    DWORD           dwStatus=0;
    LARGE_INTEGER   ftPreTimeStamp;
    LARGE_INTEGER   ftPostTimeStamp;
    BOOL            fNeedToSetupTimer=FALSE;

    LDAP            *pld = NULL;
    LPWSTR          pwszDCName=NULL;

    //get the system time stamp
    GetSystemTimeAsFileTime((LPFILETIME)&ftPreTimeStamp);

    //the two input parameters are not yet used
    if(NULL==lpParameter)
        goto CommonReturn;

    hwndParent = ((AE_MAIN_THREAD_INFO *)lpParameter)->hwndParent;
    dwStatus = ((AE_MAIN_THREAD_INFO *)lpParameter)->dwStatus;

    AE_DEBUG((AE_INFO, L"Beginning CertAutoEnrollment(%s).\n", (CERT_AUTO_ENROLLMENT_START_UP==dwStatus?L"START_UP":L"WAKE_UP")));

    //no autoenrollment in the safe boot mode
    //no autoenrollment if we are not in a domain
    if(AEInSafeBoot() || !AEIsDomainMember())
        goto CommonReturn;

    //we need to set up the timer
    fNeedToSetupTimer=TRUE;

    //detect if we are running under user or machine context
    if(!AEIsLocalSystem(&fMachine))
        goto CommonReturn;
    AE_DEBUG((AE_INFO, L"CertAutoEnrollment running as %s.\n", (fMachine?L"machine":L"user")));

    AESetWakeUpFlag(fMachine, TRUE);   
    
    //we wait for 70 seconds for user case to give enough time for 
    //machine autoenrollment to complete, which will download certificates
    //from the directory
    if(!fMachine)
    {
        if(!AEExpress())
        {
            Sleep(USER_AUTOENROLL_DELAY_FOR_MACHINE * 1000);
        }
    }

   //get the autoenrollment log level
    if(!AERetrieveLogLevel(fMachine, &dwLogLevel))
        goto CommonReturn;

    //log the autoenrollment start event
    AELogAutoEnrollmentEvent(dwLogLevel, FALSE, S_OK, EVENT_AUTOENROLL_START, fMachine, NULL, 0);

   //get the autoenrollment policy flag
    if(!AEGetPolicyFlag(fMachine, &dwPolicy))
        goto CommonReturn;

    //no need to do anything if autoenrollment is completely disabled
    if(AUTO_ENROLLMENT_DISABLE_ALL & dwPolicy)
        goto CommonReturn;


    //download NTAuth And Enterprise root store for machine 
    if(fMachine)
    {    
        //bind to the DS
        if(S_OK != (hr=AERobustLdapBind(&pld, &pwszDCName)))
        {
            SetLastError(hr);
            AELogAutoEnrollmentEvent(dwLogLevel, TRUE, hr, EVENT_FAIL_BIND_TO_DS, fMachine, NULL, 0);
            goto CommonReturn;
        }

        AEDownloadStore(pld, pwszDCName);
    }

    //if we are required to do a WIN2K style autoenrollment, and the machine/user's
    //ACRS store is empty, just return as we done.
    if(0 == dwPolicy)
    {
        if(IsACRSStoreEmpty(fMachine))
            goto CommonReturn;
    }

    if(NULL==pld)
    {
        //bind to the DS
        if(S_OK != (hr=AERobustLdapBind(&pld, NULL)))
        {
            SetLastError(hr);
            AELogAutoEnrollmentEvent(dwLogLevel, TRUE, hr, EVENT_FAIL_BIND_TO_DS, fMachine, NULL, 0);
            goto CommonReturn;
        }
    }

    AEProcessEnrollment(hwndParent, fMachine, pld, dwPolicy, dwLogLevel);

CommonReturn:

    //get the system time
    GetSystemTimeAsFileTime((LPFILETIME)&ftPostTimeStamp);

    //set up the timer for next time
    if(TRUE == fNeedToSetupTimer)
    {
        // we will need to do this again in a few hours.
        AESetWakeUpTimer(fMachine, &ftPreTimeStamp, &ftPostTimeStamp);
    }

    if(pld)
        ldap_unbind(pld);

    if(pwszDCName)
        LocalFree(pwszDCName);

    if(lpParameter)
        LocalFree((HLOCAL)lpParameter);

    AELogAutoEnrollmentEvent(dwLogLevel, FALSE, S_OK, EVENT_AUTOENROLL_COMPLETE, fMachine, NULL, 0);

    return TRUE;
}

//--------------------------------------------------------------------------
//
//  CertAutoEnrollment
//
//      Function to perform autoenrollment actions.  It creates a working
//      thread and return immediately so that it is non-blocking.
//     
//      Parameters:
//          IN  hwndParent:     The parent window 
//          IN  dwStatus:       The status under which the function is called.  
//                              It can be one of the following:
//                              CERT_AUTO_ENROLLMENT_START_UP
//                              CERT_AUTO_ENROLLMENT_WAKE_UP
//
//--------------------------------------------------------------------------
HANDLE 
WINAPI
CertAutoEnrollment(IN HWND     hwndParent,
                   IN DWORD    dwStatus)
{
    DWORD                       dwThreadID=0;
                                //memory will be freed in the main thread
    AE_MAIN_THREAD_INFO         *pAE_Main_Thread_Info=NULL;     
        
    HANDLE                      hThread=NULL;

    pAE_Main_Thread_Info=(AE_MAIN_THREAD_INFO *)LocalAlloc(LPTR, sizeof(AE_MAIN_THREAD_INFO));
    if(NULL==pAE_Main_Thread_Info)
        return NULL;

    memset(pAE_Main_Thread_Info, 0, sizeof(AE_MAIN_THREAD_INFO));
    pAE_Main_Thread_Info->hwndParent=hwndParent;
    pAE_Main_Thread_Info->dwStatus=dwStatus;

    hThread = CreateThread(NULL,
                            0,
                            AEMainThreadProc,
                            pAE_Main_Thread_Info,
                            0,          //execute immediately
                            &dwThreadID);  

    //set the thread priority to low so that we will not compete with the shell
    SetThreadPriority(hThread,  THREAD_PRIORITY_BELOW_NORMAL);

    return hThread;
}

//--------------------------------------------------------------------
//
//  AERetrieveClientToken
//
//--------------------------------------------------------------------
BOOL    AERetrieveClientToken(HANDLE  *phToken)
{
    HRESULT         hr = S_OK;

    HANDLE          hHandle = NULL;
    HANDLE          hClientToken = NULL;

    hHandle = GetCurrentThread();
    if (NULL == hHandle)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else
    {

        if (!OpenThreadToken(hHandle,
                             TOKEN_QUERY,
                             TRUE,  // open as self
                             &hClientToken))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            CloseHandle(hHandle);
            hHandle = NULL;
        }
    }

    if(hr != S_OK)
    {
        hHandle = GetCurrentProcess();
        if (NULL == hHandle)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
        else
        {
            HANDLE hProcessToken = NULL;
            hr = S_OK;


            if (!OpenProcessToken(hHandle,
                                 TOKEN_DUPLICATE,
                                 &hProcessToken))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                CloseHandle(hHandle);
                hHandle = NULL;
            }
            else
            {
                if(!DuplicateToken(hProcessToken,
                               SecurityImpersonation,
                               &hClientToken))
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    CloseHandle(hHandle);
                    hHandle = NULL;
                }
                CloseHandle(hProcessToken);
            }
        }
    }


    if(S_OK == hr)
        *phToken = hClientToken;

    if(hHandle)
        CloseHandle(hHandle);

    return (S_OK == hr);
}

//--------------------------------------------------------------------------
//
//  AERetrieveGeneralInfo
//
//
//--------------------------------------------------------------------------
BOOL    AERetrieveGeneralInfo(AE_GENERAL_INFO *pAE_General_Info)
{
    BOOL                fResult = FALSE;
    DWORD               dwOpenStoreFlags = CERT_SYSTEM_STORE_CURRENT_USER;
    DWORD               cMachineName = MAX_COMPUTERNAME_LENGTH + 2;
	LONG	            dwResult = 0;

	SCARDCONTEXT		hSCContext=NULL;

    //get the client token
    if(pAE_General_Info->fMachine)
    {   
        if(!AENetLogonUser(NULL, NULL, NULL, &(pAE_General_Info->hToken)))
        {
            AE_DEBUG((AE_ERROR, L"Obtain local system's token (%lx)\n\r", GetLastError()));
            goto Ret;
        }
    }
    else
    {
        if(!AERetrieveClientToken(&(pAE_General_Info->hToken)))
            goto Ret;
    }

    //get the machine name
    if (!GetComputerNameW(pAE_General_Info->wszMachineName,
                          &cMachineName))
        goto Ret;

    if(pAE_General_Info->fMachine)
        dwOpenStoreFlags = CERT_SYSTEM_STORE_LOCAL_MACHINE;

    //open my store
    if (NULL == (pAE_General_Info->hMyStore = CertOpenStore(
                        CERT_STORE_PROV_SYSTEM_W, 
                        ENCODING_TYPE, 
                        NULL, 
                        dwOpenStoreFlags, 
                        MY_STORE)))
    {
        AE_DEBUG((AE_ERROR, L"Unable to open MY store (%lx)\n\r", GetLastError()));
        goto Ret;
    }

    if(!CertControlStore(pAE_General_Info->hMyStore, 
                        0, 
                        CERT_STORE_CTRL_AUTO_RESYNC, 
                        NULL))
    {
        AE_DEBUG((AE_ERROR, L"Unable configure MY store for auto-resync(%lx)\n\r", GetLastError()));
        goto Ret;
    }

    //open request store
    if (NULL == (pAE_General_Info->hRequestStore = CertOpenStore(
                        CERT_STORE_PROV_SYSTEM_W, 
                        ENCODING_TYPE, 
                        NULL, 
                        dwOpenStoreFlags, 
                        REQUEST_STORE)))
    {
        AE_DEBUG((AE_ERROR, L"Unable to open Request store (%lx)\n\r", GetLastError()));
        goto Ret;
    }

    //get CertType information
    if(!AERetrieveCertTypeInfo( pAE_General_Info->pld, 
                                pAE_General_Info->fMachine,
                                &(pAE_General_Info->dwCertType), 
                                &(pAE_General_Info->rgCertTypeInfo)))
    {
        AE_DEBUG((AE_ERROR, L"Unable to retrieve CertType information (%lx)\n\r", GetLastError()));
        goto Ret;
    }

    //load xenroll module.  No need to check errors since this is not a fatal error
    pAE_General_Info->hXenroll = LoadLibrary(L"xenroll.dll");


    //detect if the smart card subsystem if running for users only
    if(FALSE == pAE_General_Info->fMachine)
    {
        dwResult = SCardEstablishContext(
                        SCARD_SCOPE_USER,
                        NULL,
                        NULL,
                        &hSCContext );

        if((0 == dwResult) && (NULL != hSCContext))
            pAE_General_Info->fSmartcardSystem=TRUE;
    }

    fResult = TRUE;

Ret:

    if(hSCContext)
        SCardReleaseContext(hSCContext);

    if(FALSE == fResult)
        AEFreeGeneralInfo(pAE_General_Info);

    return fResult;
}


//--------------------------------------------------------------------------
//
//  AEFreeGeneralInfo
//
//
//--------------------------------------------------------------------------
BOOL    AEFreeGeneralInfo(AE_GENERAL_INFO *pAE_General_Info)
{
    if(pAE_General_Info)
    {
        if(pAE_General_Info->hToken)
            CloseHandle(pAE_General_Info->hToken);

        if(pAE_General_Info->hMyStore)
            CertCloseStore(pAE_General_Info->hMyStore, 0);

        if(pAE_General_Info->hRequestStore)
            CertCloseStore(pAE_General_Info->hRequestStore, 0);

        //free CA information
        AEFreeCAInfo(pAE_General_Info->dwCA, pAE_General_Info->rgCAInfo);

        //free CertType information
        AEFreeCertTypeInfo(pAE_General_Info->dwCertType, pAE_General_Info->rgCertTypeInfo);

        if(pAE_General_Info->hXenroll)
            FreeLibrary(pAE_General_Info->hXenroll);

        if(pAE_General_Info->hCancelEvent)
            CloseHandle(pAE_General_Info->hCancelEvent);

        if(pAE_General_Info->hCompleteEvent)
            CloseHandle(pAE_General_Info->hCompleteEvent);

        if(pAE_General_Info->hThread)
            CloseHandle(pAE_General_Info->hThread);

        memset(pAE_General_Info, 0, sizeof(AE_GENERAL_INFO));

    }

    return TRUE;
}


//--------------------------------------------------------------------------
//
//  AERetrieveCertTypeInfo
//
//--------------------------------------------------------------------------
BOOL    AERetrieveCertTypeInfo(LDAP *pld, BOOL fMachine, DWORD *pdwCertType, AE_CERTTYPE_INFO **prgCertType)
{
    BOOL                fResult=FALSE;
    DWORD               dwCount=0;
    DWORD               dwCertType=0;
    DWORD               dwIndex=0;
    HRESULT             hr=E_FAIL;

    HCERTTYPE           hCTCurrent = NULL;
    HCERTTYPE           hCTNew = NULL;
    AE_CERTTYPE_INFO    *rgCertTypeInfo=NULL;

    *pdwCertType=0;
    *prgCertType=NULL;

    if(S_OK != (hr = CAEnumCertTypesEx(
                (LPCWSTR)pld,
                fMachine?CT_ENUM_MACHINE_TYPES | CT_FIND_LOCAL_SYSTEM | CT_FLAG_SCOPE_IS_LDAP_HANDLE: CT_ENUM_USER_TYPES | CT_FLAG_SCOPE_IS_LDAP_HANDLE, 
                &hCTCurrent)))
    {
        SetLastError(hr);
        goto Ret;
    }

    if((NULL == hCTCurrent) || (0 == (dwCount = CACountCertTypes(hCTCurrent))))
    {
        AE_DEBUG((AE_WARNING, L"No CT's available for auto-enrollment\n\r"));
        fResult=TRUE;
        goto Ret;
    }

    rgCertTypeInfo=(AE_CERTTYPE_INFO *)LocalAlloc(LPTR, sizeof(AE_CERTTYPE_INFO) * dwCount);
    if(NULL==rgCertTypeInfo)
    {
        SetLastError(E_OUTOFMEMORY);
        goto Ret;
    }

    memset(rgCertTypeInfo, 0, sizeof(AE_CERTTYPE_INFO) * dwCount);

    for(dwIndex = 0; dwIndex < dwCount; dwIndex++ )       
    {

        //check if we have a new certificate template
        if(dwIndex > 0)
        {
            hr = CAEnumNextCertType(hCTCurrent, &hCTNew);

            if((S_OK != hr) || (NULL == hCTNew))
            {
                // Clean up from previous calls
                if(dwCertType < dwCount)
                    AEFreeCertTypeStruct(&(rgCertTypeInfo[dwCertType]));

                break;
            }

            hCTCurrent = hCTNew; 
        }

        // Clean up from previous calls
        AEFreeCertTypeStruct(&(rgCertTypeInfo[dwCertType]));

        //copy the new CertType' data
        //hCertType
        rgCertTypeInfo[dwCertType].hCertType = hCTCurrent;

        //CTName
        hr = CAGetCertTypePropertyEx(
                             hCTCurrent, 
                             CERTTYPE_PROP_DN,
                             &(rgCertTypeInfo[dwCertType].awszName));

        if((S_OK != hr) ||
           (NULL == rgCertTypeInfo[dwCertType].awszName) || 
           (NULL == (rgCertTypeInfo[dwCertType].awszName)[0])
          )
        {
            AE_DEBUG((AE_INFO, L"No name property for CertType\n\r"));
            continue;
        }
    
        //FriendlyName
        hr = CAGetCertTypePropertyEx(
                             hCTCurrent, 
                             CERTTYPE_PROP_FRIENDLY_NAME,
                             &(rgCertTypeInfo[dwCertType].awszDisplay));
        if((S_OK != hr) ||
           (NULL == rgCertTypeInfo[dwCertType].awszDisplay) || 
           (NULL == (rgCertTypeInfo[dwCertType].awszDisplay)[0])
          )
        {
            AE_DEBUG((AE_INFO, L"No display property for CertType\n\r"));

            //get the DN as the display name
            hr = CAGetCertTypePropertyEx(
                                 hCTCurrent, 
                                 CERTTYPE_PROP_DN,
                                 &(rgCertTypeInfo[dwCertType].awszDisplay));
            if((S_OK != hr) ||
               (NULL == rgCertTypeInfo[dwCertType].awszDisplay) || 
               (NULL == (rgCertTypeInfo[dwCertType].awszDisplay)[0])
              )
            {
                AE_DEBUG((AE_INFO, L"No name property for CertType\n\r"));
                continue;
            }
        }

        //dwSchemaVersion
        hr = CAGetCertTypePropertyEx(
                             hCTCurrent, 
                             CERTTYPE_PROP_SCHEMA_VERSION,
                             &(rgCertTypeInfo[dwCertType].dwSchemaVersion));

        if(hr != S_OK)
        {
            AE_DEBUG((AE_INFO, L"No schema version for CT %ls\n\r", (rgCertTypeInfo[dwCertType].awszName)[0]));
            continue;
        }

        //dwVersion
        hr = CAGetCertTypePropertyEx(
                             hCTCurrent, 
                             CERTTYPE_PROP_REVISION,
                             &(rgCertTypeInfo[dwCertType].dwVersion));

        if(hr != S_OK)
        {
            AE_DEBUG((AE_INFO, L"No major version for CT %ls\n\r", (rgCertTypeInfo[dwCertType].awszName)[0]));
            continue;
        }

        //dwEnrollmentFlag
        hr = CAGetCertTypeFlagsEx(
                            hCTCurrent,
                            CERTTYPE_ENROLLMENT_FLAG,
                            &(rgCertTypeInfo[dwCertType].dwEnrollmentFlag));

        if(hr != S_OK)
        {
            AE_DEBUG((AE_INFO, L"No enrollment flag for CT %ls\n\r", (rgCertTypeInfo[dwCertType].awszName)[0]));
            continue;
        }

        //dwPrivatekeyFlag
        hr = CAGetCertTypeFlagsEx(
                            hCTCurrent,
                            CERTTYPE_PRIVATE_KEY_FLAG,
                            &(rgCertTypeInfo[dwCertType].dwPrivateKeyFlag));

        if(hr != S_OK)
        {
            AE_DEBUG((AE_INFO, L"No private key flag for CT %ls\n\r", (rgCertTypeInfo[dwCertType].awszName)[0]));
            continue;
        }

        //expiration offset
        hr = CAGetCertTypeExpiration(
                            hCTCurrent,
                            NULL,
                            (LPFILETIME)&(rgCertTypeInfo[dwCertType].ftExpirationOffset));

        //we might not get the expiration date
        if(hr != S_OK)
        {
            AE_DEBUG((AE_WARNING, L"Could not get cert type expirations: %ls\n\r", (rgCertTypeInfo[dwCertType].awszName)[0]));
        }

        //oid
        hr = CAGetCertTypePropertyEx(
                             hCTCurrent, 
                             CERTTYPE_PROP_OID,
                             &(rgCertTypeInfo[dwCertType].awszOID));

        //we might not get the oid property
        if(rgCertTypeInfo[dwCertType].dwSchemaVersion >= CERTTYPE_SCHEMA_VERSION_2)
        {
            if((S_OK != hr) ||
               (NULL == rgCertTypeInfo[dwCertType].awszOID) || 
               (NULL == (rgCertTypeInfo[dwCertType].awszOID)[0])
              )
            {
                AE_DEBUG((AE_INFO, L"No oid for CT %ls\n\r", (rgCertTypeInfo[dwCertType].awszName)[0]));
                continue;
            }
        }


        //supersede
        hr = CAGetCertTypePropertyEx(
                             hCTCurrent, 
                             CERTTYPE_PROP_SUPERSEDE,
                             &(rgCertTypeInfo[dwCertType].awszSupersede));

        //we might not get the supersede property
        if(hr != S_OK)
        {
            AE_DEBUG((AE_INFO, L"No supersede for CT %ls\n\r", (rgCertTypeInfo[dwCertType].awszName)[0]));
        }

        //hArchiveStore
        if(NULL == (rgCertTypeInfo[dwCertType].hArchiveStore=CertOpenStore(
                        CERT_STORE_PROV_MEMORY,
                        ENCODING_TYPE,
                        NULL,
                        0,
                        NULL)))

        {
            AE_DEBUG((AE_INFO, L"Unable to open archive cert store for CT %ls\n\r", (rgCertTypeInfo[dwCertType].awszName)[0]));
            continue;
        }

        //hObtainedStore
        if(NULL == (rgCertTypeInfo[dwCertType].hObtainedStore=CertOpenStore(
                        CERT_STORE_PROV_MEMORY,
                        ENCODING_TYPE,
                        NULL,
                        0,
                        NULL)))

        {
            AE_DEBUG((AE_INFO, L"Unable to open obtained cert store for CT %ls\n\r", (rgCertTypeInfo[dwCertType].awszName)[0]));
            continue;
        }

        //hIssuedStore
        if(NULL == (rgCertTypeInfo[dwCertType].hIssuedStore=CertOpenStore(
                        CERT_STORE_PROV_MEMORY,
                        ENCODING_TYPE,
                        NULL,
                        0,
                        NULL)))

        {
            AE_DEBUG((AE_INFO, L"Unable to open issued cert store for CT %ls\n\r", (rgCertTypeInfo[dwCertType].awszName)[0]));
            continue;
        }

        //allocate memory
        rgCertTypeInfo[dwCertType].prgActive=(DWORD *)LocalAlloc(LPTR, sizeof(DWORD) * dwCount);
        if(NULL == rgCertTypeInfo[dwCertType].prgActive)
        {
            AE_DEBUG((AE_INFO, L"Unable to allocate memory for CT %ls\n\r", (rgCertTypeInfo[dwCertType].awszName)[0]));
            continue;
        }

        memset(rgCertTypeInfo[dwCertType].prgActive, 0, sizeof(DWORD) * dwCount);

        dwCertType++;
    }

    *pdwCertType=dwCertType;
    *prgCertType=rgCertTypeInfo;

    fResult = TRUE;

Ret:

    return fResult;
}

//--------------------------------------------------------------------------
//
//  AEFreeCertTypeInfo
//
//
//--------------------------------------------------------------------------
BOOL    AEFreeCertTypeInfo(DWORD dwCertType, AE_CERTTYPE_INFO *rgCertTypeInfo)
{
    DWORD   dwIndex=0;
    
    if(rgCertTypeInfo)
    {
        for(dwIndex=0; dwIndex < dwCertType; dwIndex++)
            AEFreeCertTypeStruct(&(rgCertTypeInfo[dwIndex]));        

        LocalFree(rgCertTypeInfo);
    }
    
    return TRUE;
}


//--------------------------------------------------------------------------
//
//  AEFreeCertTypeStruct
//
//
//--------------------------------------------------------------------------
BOOL    AEFreeCertTypeStruct(AE_CERTTYPE_INFO *pCertTypeInfo)
{
    DWORD   dwIndex=0;

    if(pCertTypeInfo)
    {
        if(pCertTypeInfo->hCertType)
        {
            if(pCertTypeInfo->awszName)
                CAFreeCertTypeProperty(pCertTypeInfo->hCertType, pCertTypeInfo->awszName);

            if(pCertTypeInfo->awszDisplay)
                CAFreeCertTypeProperty(pCertTypeInfo->hCertType, pCertTypeInfo->awszDisplay);

            if(pCertTypeInfo->awszOID)
                CAFreeCertTypeProperty(pCertTypeInfo->hCertType, pCertTypeInfo->awszOID);
    
            if(pCertTypeInfo->awszSupersede)
                CAFreeCertTypeProperty(pCertTypeInfo->hCertType, pCertTypeInfo->awszSupersede);

            CACloseCertType(pCertTypeInfo->hCertType);
        }

        if(pCertTypeInfo->prgActive)
            LocalFree(pCertTypeInfo->prgActive);

        if(pCertTypeInfo->pOldCert)
            CertFreeCertificateContext(pCertTypeInfo->pOldCert);

        if(pCertTypeInfo->hArchiveStore)
            CertCloseStore(pCertTypeInfo->hArchiveStore, 0);

        if(pCertTypeInfo->hObtainedStore)
            CertCloseStore(pCertTypeInfo->hObtainedStore, 0);

        if(pCertTypeInfo->hIssuedStore)
            CertCloseStore(pCertTypeInfo->hIssuedStore, 0);

        if(pCertTypeInfo->dwPendCount)
        {
            if(pCertTypeInfo->rgPendInfo)
            {
                for(dwIndex=0; dwIndex < pCertTypeInfo->dwPendCount; dwIndex++)
                {
                    if((pCertTypeInfo->rgPendInfo[dwIndex]).blobPKCS7.pbData)
                        LocalFree((pCertTypeInfo->rgPendInfo[dwIndex]).blobPKCS7.pbData);

                    if((pCertTypeInfo->rgPendInfo[dwIndex]).blobHash.pbData)
                        LocalFree((pCertTypeInfo->rgPendInfo[dwIndex]).blobHash.pbData);
                }

                LocalFree(pCertTypeInfo->rgPendInfo);
            }
        }

        memset(pCertTypeInfo, 0, sizeof(AE_CERTTYPE_INFO));
    }

    return TRUE;
}

//--------------------------------------------------------------------------
//
//  AERetrieveCAInfo
//
//
//--------------------------------------------------------------------------
BOOL    AERetrieveCAInfo(LDAP *pld, BOOL fMachine, HANDLE hToken, DWORD *pdwCA, AE_CA_INFO **prgCAInfo)
{
    BOOL                fResult = FALSE;
    DWORD               dwCount=0;
    DWORD               dwCA=0;
    DWORD               dwIndex=0;
    HRESULT             hr=E_FAIL;

    HCAINFO             hCACurrent = NULL;
    HCAINFO             hCANew = NULL;
    AE_CA_INFO          *rgCAInfo=NULL;

    *pdwCA=0;
    *prgCAInfo=NULL;

    if(S_OK != (hr = CAEnumFirstCA(
                        (LPCWSTR)pld, 
                        CA_FLAG_SCOPE_IS_LDAP_HANDLE | (fMachine?CA_FIND_LOCAL_SYSTEM:0), 
                        &hCACurrent)))
    {
        SetLastError(hr);
        goto Ret;
    }

    if((NULL == hCACurrent) || (0 == (dwCount = CACountCAs(hCACurrent))))
    {
        AE_DEBUG((AE_WARNING, L"No CA's available for auto-enrollment\n\r"));
        fResult=TRUE;
        goto Ret;
    }

    rgCAInfo=(AE_CA_INFO *)LocalAlloc(LPTR, sizeof(AE_CA_INFO) * dwCount);
    if(NULL==rgCAInfo)
    {
        SetLastError(E_OUTOFMEMORY);
        goto Ret;
    }

    memset(rgCAInfo, 0, sizeof(AE_CA_INFO) * dwCount);

    for(dwIndex = 0; dwIndex < dwCount; dwIndex++ )       
    {

        //check if we have a new CA
        if(dwIndex > 0)
        {
            hr = CAEnumNextCA(hCACurrent, &hCANew);

            if((S_OK != hr) || (NULL == hCANew))
            {
                // Clean up from previous calls
                if(dwCA < dwCount)
                    AEFreeCAStruct(&(rgCAInfo[dwCA]));

                break;
            }

            hCACurrent = hCANew; 
        }

        // Clean up from previous calls
        AEFreeCAStruct(&(rgCAInfo[dwCA]));

        //copy the new CA' data
        //hCAInfo
        rgCAInfo[dwCA].hCAInfo = hCACurrent;

        //CAName
        hr = CAGetCAProperty(hCACurrent, 
                             CA_PROP_NAME,
                             &(rgCAInfo[dwCA].awszCAName));

        if((S_OK != hr) ||
           (NULL == rgCAInfo[dwCA].awszCAName) || 
           (NULL == (rgCAInfo[dwCA].awszCAName)[0])
          )
        {
            AE_DEBUG((AE_INFO, L"No name property for ca\n\r"));
            continue;
        }

        //access check
        if(S_OK != CAAccessCheckEx(rgCAInfo[dwCA].hCAInfo, hToken, CERTTYPE_ACCESS_CHECK_ENROLL | CERTTYPE_ACCESS_CHECK_NO_MAPPING))
        {
            AE_DEBUG((AE_INFO, L"No access for CA %ls\n\r", (rgCAInfo[dwCA].awszCAName)[0]));
            continue;
        }

        //CA Display
        hr = CAGetCAProperty(hCACurrent, 
                             CA_PROP_DISPLAY_NAME,
                             &(rgCAInfo[dwCA].awszCADisplay));

        if((S_OK != hr) ||
           (NULL == rgCAInfo[dwCA].awszCADisplay) || 
           (NULL == (rgCAInfo[dwCA].awszCADisplay)[0])
          )
        {
            AE_DEBUG((AE_INFO, L"No display name property for ca\n\r"));

            hr = CAGetCAProperty(hCACurrent, 
                                 CA_PROP_NAME,
                                 &(rgCAInfo[dwCA].awszCADisplay));

            if((S_OK != hr) ||
               (NULL == rgCAInfo[dwCA].awszCADisplay) || 
               (NULL == (rgCAInfo[dwCA].awszCADisplay)[0])
              )
            {
                AE_DEBUG((AE_INFO, L"No name property for ca\n\r"));
                continue;
            }
        }

        //CADNS
        hr = CAGetCAProperty(hCACurrent, 
                             CA_PROP_DNSNAME,
                             &(rgCAInfo[dwCA].awszCADNS));

        if((S_OK != hr) ||
           (NULL == rgCAInfo[dwCA].awszCADNS) || 
           (NULL == (rgCAInfo[dwCA].awszCADNS)[0])
          )
        {
            AE_DEBUG((AE_INFO, L"No DNS property for CA %ls\n\r", (rgCAInfo[dwCA].awszCAName)[0]));
            continue;
        }

        //CACertificateTemplate
        hr = CAGetCAProperty(hCACurrent, 
                             CA_PROP_CERT_TYPES,
                             &(rgCAInfo[dwCA].awszCertificateTemplate));

        if((S_OK != hr) ||
           (NULL == rgCAInfo[dwCA].awszCertificateTemplate) || 
           (NULL == (rgCAInfo[dwCA].awszCertificateTemplate)[0])
          )
        {
            AE_DEBUG((AE_INFO, L"No CertType property for CA %ls\n\r", (rgCAInfo[dwCA].awszCAName)[0]));
            continue;
        }

        dwCA++;
    }

    *pdwCA=dwCA;
    *prgCAInfo=rgCAInfo;

    fResult = TRUE;

Ret:

    return fResult;
}

//--------------------------------------------------------------------------
//
//  AEFreeCAInfo
//
//
//--------------------------------------------------------------------------
BOOL    AEFreeCAInfo(DWORD dwCA, AE_CA_INFO *rgCAInfo)
{
    DWORD   dwIndex=0;

    if(rgCAInfo)
    {
        for(dwIndex=0; dwIndex < dwCA; dwIndex++)
            AEFreeCAStruct(&(rgCAInfo[dwIndex]));

        LocalFree(rgCAInfo);
    }

    return TRUE;
}


//--------------------------------------------------------------------------
//
//  AEFreeCAStruct
//
//
//--------------------------------------------------------------------------
BOOL    AEFreeCAStruct(AE_CA_INFO *pCAInfo)
{
    if(pCAInfo)
    {
        if(pCAInfo->hCAInfo)
        {
            if(pCAInfo->awszCAName)
            {
                CAFreeCAProperty(pCAInfo->hCAInfo,pCAInfo->awszCAName);       
            }
            if(pCAInfo->awszCADisplay)
            {
                CAFreeCAProperty(pCAInfo->hCAInfo,pCAInfo->awszCADisplay);       
            }
            if(pCAInfo->awszCADNS)
            {
                CAFreeCAProperty(pCAInfo->hCAInfo, pCAInfo->awszCADNS);       
            }
            if(pCAInfo->awszCertificateTemplate)
            {
                CAFreeCAProperty(pCAInfo->hCAInfo,pCAInfo->awszCertificateTemplate);
            }

            CACloseCA(pCAInfo->hCAInfo);
        }

        memset(pCAInfo, 0, sizeof(AE_CA_INFO));
    }

    return TRUE;
}

//--------------------------------------------------------------------------
//
//  AEClearVistedFlag
//
//--------------------------------------------------------------------------
BOOL    AEClearVistedFlag(AE_GENERAL_INFO *pAE_General_Info)
{   
    DWORD       dwIndex=0;

    if(pAE_General_Info)
    {
       if(pAE_General_Info->rgCertTypeInfo)
       {
            for(dwIndex=0; dwIndex < pAE_General_Info->dwCertType; dwIndex++)
            {
                (pAE_General_Info->rgCertTypeInfo)[dwIndex].fSupersedeVisited=FALSE;
            }
       }
    }

    return TRUE;
}
//--------------------------------------------------------------------------
//
//  AEIfSupersede
//
//      Recursively find if pwsz is superseded by one of the template in awsz.
//      Notice that we should not loop in the superseding relationship.
//      Superseding tree should be one directional tree without duplicated nodes.
//
//--------------------------------------------------------------------------
BOOL  AEIfSupersede(LPWSTR  pwsz, LPWSTR *awsz, AE_GENERAL_INFO *pAE_General_Info)
{
    BOOL                    fResult = FALSE;
    LPWSTR                  *pwszArray = awsz;
    AE_TEMPLATE_INFO        AETemplateInfo;
    AE_CERTTYPE_INFO        *pCertType = NULL;

    LPWSTR                  *awszSupersede=NULL;

    if((NULL==pwsz) || (NULL==awsz))
        return FALSE;

    while(*pwszArray)
    {
        if(0 == wcscmp(pwsz, *pwszArray))
        {
            fResult = TRUE;
            break;
        }

        //find the template
        memset(&AETemplateInfo, 0, sizeof(AE_TEMPLATE_INFO));

        AETemplateInfo.pwszName=*pwszArray;

        pCertType = AEFindTemplateInRequestTree(
                        &AETemplateInfo,
                        pAE_General_Info);

        if(pCertType)
        {
            if(!(pCertType->fSupersedeVisited))
            {
                //mark that we have visited superseding relationship for this template
                pCertType->fSupersedeVisited=TRUE;

                if(S_OK == CAGetCertTypePropertyEx(
                             pCertType->hCertType, 
                             CERTTYPE_PROP_SUPERSEDE,
                             &(awszSupersede)))
                {
                    fResult = AEIfSupersede(pwsz, awszSupersede, pAE_General_Info);

                    if(awszSupersede)
                        CAFreeCertTypeProperty(
                            pCertType->hCertType,
                            awszSupersede);

                    awszSupersede=NULL;
                
                    if(TRUE == fResult)
                        break;
                }
            }
        }

        pwszArray++;
    }

    return fResult;
}

//--------------------------------------------------------------------------
//
//  AEIsAnElement
//
//
//--------------------------------------------------------------------------
BOOL    AEIsAnElement(LPWSTR   pwsz, LPWSTR *awsz)
{
    BOOL                    fResult = FALSE;
    LPWSTR                  *pwszArray = awsz;
    
    if((NULL==pwsz) || (NULL==awsz))
        return FALSE;

    while(*pwszArray)
    {
        if(0 == wcscmp(pwsz, *pwszArray))
        {
            fResult = TRUE;
            break;
        }
    
        pwszArray++;
    }

    return fResult;
}
                          
//--------------------------------------------------------------------------
//
//  AECopyCertStore
//
//
//--------------------------------------------------------------------------
BOOL AECopyCertStore(HCERTSTORE     hSrcStore,
                     HCERTSTORE     hDesStore)
{
    PCCERT_CONTEXT  pCertContext=NULL;

    if((NULL==hSrcStore) || (NULL==hDesStore))
        return FALSE;

    while(pCertContext = CertEnumCertificatesInStore(hSrcStore, pCertContext))
    {
        CertAddCertificateContextToStore(hDesStore,
                                     pCertContext,
                                     CERT_STORE_ADD_USE_EXISTING,
                                     NULL);
    }

    return TRUE;
}

//--------------------------------------------------------------------------
//
//  AEGetConfigDN
//
//
//--------------------------------------------------------------------------
HRESULT 
AEGetConfigDN(
    IN  LDAP *pld,
    OUT LPWSTR *pwszConfigDn
    )
{

    HRESULT         hr;
    ULONG           LdapError;

    LDAPMessage  *SearchResult = NULL;
    LDAPMessage  *Entry = NULL;
    WCHAR        *Attr = NULL;
    BerElement   *BerElement;
    WCHAR        **Values = NULL;

    WCHAR  *AttrArray[3];
    struct l_timeval        timeout;

    WCHAR  *ConfigurationNamingContext = L"configurationNamingContext";
    WCHAR  *ObjectClassFilter          = L"objectCategory=*";

    //
    // Set the out parameters to null
    //
    if(pwszConfigDn)
    {
        *pwszConfigDn = NULL;
    }

    timeout.tv_sec = 300;
    timeout.tv_usec = 0;
    //
    // Query for the ldap server oerational attributes to obtain the default
    // naming context.
    //
    AttrArray[0] = ConfigurationNamingContext;
    AttrArray[1] = NULL;  // this is the sentinel

    LdapError = ldap_search_ext_s(pld,
                               NULL,
                               LDAP_SCOPE_BASE,
                               ObjectClassFilter,
                               AttrArray,
                               FALSE,
                               NULL,
                               NULL,
                               &timeout,
                               10000,
                               &SearchResult);

    hr = HRESULT_FROM_WIN32(LdapMapErrorToWin32(LdapError));

    if (S_OK == hr) 
    {

        Entry = ldap_first_entry(pld, SearchResult);

        if (Entry) 
        {

            Values = ldap_get_values(pld, 
                                        Entry, 
                                        ConfigurationNamingContext);

            if (Values && Values[0]) 
            {
                (*pwszConfigDn) = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR)*(wcslen(Values[0])+1));

                if(NULL==(*pwszConfigDn))
                    hr=E_OUTOFMEMORY;
                else
                    wcscpy((*pwszConfigDn), Values[0]);
            }

            ldap_value_free(Values);
        }

        if (pwszConfigDn && (!(*pwszConfigDn))) 
        {
            // We could not get the default domain or out of memory - bail out
            if(E_OUTOFMEMORY != hr)
                hr =  HRESULT_FROM_WIN32(ERROR_CANT_ACCESS_DOMAIN_INFO);
        }

        if(SearchResult)
        {
            ldap_msgfree(SearchResult);
        }
    }

    return hr;
}

//--------------------------------------------------------------------------
//
//  AERobustLdapBind
//
//--------------------------------------------------------------------------
HRESULT 
AERobustLdapBind(
    OUT LDAP ** ppldap,
    OUT LPWSTR *ppwszDCName)
{
    DWORD               dwErr = ERROR_SUCCESS;
    HRESULT             hr = S_OK;
    BOOL                fForceRediscovery = FALSE;
    DWORD               dwGetDCFlags = DS_RETURN_DNS_NAME | DS_BACKGROUND_ONLY;
    PDOMAIN_CONTROLLER_INFO pDomainInfo = NULL;
    LDAP                *pld = NULL;
    LPWSTR              wszDomainControllerName = NULL;
    ULONG               ulOptions = 0;

    ULONG               ldaperr;

    do {

        if(fForceRediscovery)
        {
           dwGetDCFlags |= DS_FORCE_REDISCOVERY;
        }

        ldaperr = LDAP_SERVER_DOWN;

        // Get the GC location
        dwErr = DsGetDcNameW(NULL,     // Delayload wrapped
                            NULL, 
                            NULL, 
                            NULL,
                            dwGetDCFlags,
                            &pDomainInfo);

        if(dwErr != ERROR_SUCCESS)
        {
            hr = HRESULT_FROM_WIN32(dwErr);
            goto error;
        }

        if((pDomainInfo == NULL) || 
           ((pDomainInfo->Flags & DS_DNS_CONTROLLER_FLAG) == 0) ||
           (pDomainInfo->DomainControllerName == NULL))
        {
            if(!fForceRediscovery)
            {
                fForceRediscovery = TRUE;
                continue;
            }
            hr = HRESULT_FROM_WIN32(ERROR_CANT_ACCESS_DOMAIN_INFO);
            goto error;
        }


        wszDomainControllerName = pDomainInfo->DomainControllerName;


        // skip past forward slashes (why are they there?)
        while(*wszDomainControllerName == L'\\')
        {
            wszDomainControllerName++;
        }

        // bind to ds
        if((pld = ldap_initW(wszDomainControllerName, LDAP_PORT)) == NULL)
        {
            ldaperr = LdapGetLastError();
        }
        else
        {                         
            //reduce bogus DNS query
            ulOptions = PtrToUlong(LDAP_OPT_ON);
            (void)ldap_set_optionW(pld, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );

            ldaperr = ldap_bind_sW(pld, NULL, NULL, LDAP_AUTH_NEGOTIATE);
        }
        hr = HRESULT_FROM_WIN32(LdapMapErrorToWin32(ldaperr));

        if(fForceRediscovery)
        {
            break;
        }
        fForceRediscovery = TRUE;

    } while(ldaperr == LDAP_SERVER_DOWN);


    if(S_OK != hr)
        goto error;

    if(ppwszDCName)
    {
        *ppwszDCName=(LPWSTR)LocalAlloc(LPTR, 
            sizeof(WCHAR) * (wcslen(wszDomainControllerName) + 1));

        if(NULL==*ppwszDCName)
        {
            hr=E_OUTOFMEMORY;
            goto error;
        }

        wcscpy(*ppwszDCName, wszDomainControllerName);
    }


    *ppldap = pld;
    pld = NULL;

    hr=S_OK;

error:

    if(pld)
    {
        ldap_unbind(pld);
    }

    if(pDomainInfo)
    {
        NetApiBufferFree(pDomainInfo);     
    }
    return hr;
}

//---------------------------------------------------------------------------
//
//  AEAllocAndCopy
//
//---------------------------------------------------------------------------
BOOL AEAllocAndCopy(LPWSTR    pwszSrc, LPWSTR    *ppwszDest)
{
    if((NULL==ppwszDest) || (NULL==pwszSrc))
    {
        SetLastError(E_INVALIDARG);
        return FALSE;
    }

    *ppwszDest=(LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * (wcslen(pwszSrc) + 1));
    if(NULL==(*ppwszDest))
    {
        SetLastError(E_OUTOFMEMORY);
        return FALSE;
    }

    wcscpy(*ppwszDest, pwszSrc);

    return TRUE;
}


//--------------------------------------------------------------------------
// Name:    AELogAutoEnrollmentEvent
//
// Description: This function registers an event in the event log of the
//              local machine.  Takes an optional argument list.
//
//--------------------------------------------------------------------------
void AELogAutoEnrollmentEvent(IN DWORD    dwLogLevel,
                            IN BOOL     fError,
                            IN HRESULT  hr,
                            IN DWORD    dwEventId,
                            IN BOOL     fMachine,
                            IN HANDLE   hToken,
                            IN DWORD    dwParamCount,
                            ...
                            )
{
    BYTE        FastBuffer[MAX_DN_SIZE];
    DWORD       cbUser =0;
    BOOL        fAlloced = FALSE;
    PSID        pSID = NULL;
    WORD        dwEventType = 0;
    LPWSTR      awszStrings[PENDING_ALLOC_SIZE + 3];
    WORD        cStrings = 0;
    LPWSTR      wszString = NULL;
	WCHAR       wszMsg[MAX_DN_SIZE];
    WCHAR       wszUser[MAX_DN_SIZE];
    DWORD       dwIndex=0;
    DWORD       dwSize=0;

    HANDLE      hEventSource = NULL;  
    LPWSTR      wszHR=NULL;
    PTOKEN_USER ptgUser = NULL;


    va_list     ArgList;


    //check the log level; log errors and success by default
    if(((dwEventId >> 30) < dwLogLevel) && ((dwEventId >> 30) != STATUS_SEVERITY_SUCCESS))
        return;

    if(NULL==(hEventSource = RegisterEventSourceW(NULL, EVENT_AUTO_NAME)))
        return;

    //copy the user/machine string
    wszUser[0]=L'\0';

    //use the user name for user case
    if(FALSE == fMachine)
    {
        dwSize=MAX_DN_SIZE;

        if(!GetUserNameEx(
                NameSamCompatible,      // name format
                wszUser,                // name buffer
                &dwSize))               // size of name buffer
        {
            LoadStringW(g_hmodThisDll, IDS_USER, wszUser, MAX_DN_SIZE);
        }
    }
    else
    {
        LoadStringW(g_hmodThisDll, IDS_MACHINE, wszUser, MAX_DN_SIZE);
    }

    awszStrings[cStrings++] = wszUser;

    //copy the variable strings if present
    va_start(ArgList, dwParamCount);

    for(dwIndex=0; dwIndex < dwParamCount; dwIndex++)
    {
